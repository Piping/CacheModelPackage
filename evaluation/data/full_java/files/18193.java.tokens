package com . badlogic . gdx . math ; import java . util . Random ; public final class MathUtils { static public final float nanoToSec = <int> / <int> f ; static public final float FLOAT_ROUNDING_ERROR = <float> ; static public final float PI = <float> ; static public final float PI2 = PI * <int> ; static public final float E = <float> ; static private final int SIN_BITS = <int> ; static private final int SIN_MASK = ~ ( - <int> < < SIN_BITS ) ; static private final int SIN_COUNT = SIN_MASK + <int> ; static private final float radFull = PI * <int> ; static private final float degFull = <int> ; static private final float radToIndex = SIN_COUNT / radFull ; static private final float degToIndex = SIN_COUNT / degFull ; static public final float radiansToDegrees = <int> f / PI ; static public final float radDeg = radiansToDegrees ; static public final float degreesToRadians = PI / <int> ; static public final float degRad = degreesToRadians ; static private class Sin { static final float [ ] table = new float [ SIN_COUNT ] ; static { for ( int i = <int> ; i < SIN_COUNT ; i + + ) table [ i ] = ( float ) Math . sin ( ( i + <float> ) / SIN_COUNT * radFull ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) table [ ( int ) ( i * degToIndex ) & SIN_MASK ] = ( float ) Math . sin ( i * degreesToRadians ) ; } } static public float sin ( float radians ) { return Sin . table [ ( int ) ( radians * radToIndex ) & SIN_MASK ] ; } static public float cos ( float radians ) { return Sin . table [ ( int ) ( ( radians + PI / <int> ) * radToIndex ) & SIN_MASK ] ; } static public float sinDeg ( float degrees ) { return Sin . table [ ( int ) ( degrees * degToIndex ) & SIN_MASK ] ; } static public float cosDeg ( float degrees ) { return Sin . table [ ( int ) ( ( degrees + <int> ) * degToIndex ) & SIN_MASK ] ; } static public float atan2 ( float y , float x ) { if ( x = = <float> ) { if ( y > <float> ) return PI / <int> ; if ( y = = <float> ) return <float> ; return - PI / <int> ; } final float atan , z = y / x ; if ( Math . abs ( z ) < <float> ) { atan = z / ( <float> + <float> * z * z ) ; if ( x < <float> ) return y < <float> ? atan - PI : atan + PI ; return atan ; } atan = PI / <int> - z / ( z * z + <float> ) ; return y < <float> ? atan - PI : atan ; } static public Random random = new RandomXS128 ( ) ; static public int random ( int range ) { return random . nextInt ( range + <int> ) ; } static public int random ( int start , int end ) { return start + random . nextInt ( end - start + <int> ) ; } static public long random ( long range ) { return ( long ) ( random . nextDouble ( ) * range ) ; } static public long random ( long start , long end ) { return start + ( long ) ( random . nextDouble ( ) * ( end - start ) ) ; } static public boolean randomBoolean ( ) { return random . nextBoolean ( ) ; } static public boolean randomBoolean ( float chance ) { return MathUtils . random ( ) < chance ; } static public float random ( ) { return random . nextFloat ( ) ; } static public float random ( float range ) { return random . nextFloat ( ) * range ; } static public float random ( float start , float end ) { return start + random . nextFloat ( ) * ( end - start ) ; } static public int randomSign ( ) { return <int> | ( random . nextInt ( ) > > <int> ) ; } public static float randomTriangular ( ) { return random . nextFloat ( ) - random . nextFloat ( ) ; } public static float randomTriangular ( float max ) { return ( random . nextFloat ( ) - random . nextFloat ( ) ) * max ; } public static float randomTriangular ( float min , float max ) { return randomTriangular ( min , max , ( min + max ) * <float> ) ; } public static float randomTriangular ( float min , float max , float mode ) { float u = random . nextFloat ( ) ; float d = max - min ; if ( u < = ( mode - min ) / d ) return min + ( float ) Math . sqrt ( u * d * ( mode - min ) ) ; return max - ( float ) Math . sqrt ( ( <int> - u ) * d * ( max - mode ) ) ; } static public int nextPowerOfTwo ( int value ) { if ( value = = <int> ) return <int> ; value - - ; value | = value > > <int> ; value | = value > > <int> ; value | = value > > <int> ; value | = value > > <int> ; value | = value > > <int> ; return value + <int> ; } static public boolean isPowerOfTwo ( int value ) { return value ! = <int> & & ( value & value - <int> ) = = <int> ; } static public short clamp ( short value , short min , short max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; } static public int clamp ( int value , int min , int max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; } static public long clamp ( long value , long min , long max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; } static public float clamp ( float value , float min , float max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; } static public double clamp ( double value , double min , double max ) { if ( value < min ) return min ; if ( value > max ) return max ; return value ; } static public float lerp ( float fromValue , float toValue , float progress ) { return fromValue + ( toValue - fromValue ) * progress ; } public static float lerpAngle ( float fromRadians , float toRadians , float progress ) { float delta = ( ( toRadians - fromRadians + PI2 + PI ) % PI2 ) - PI ; return ( fromRadians + delta * progress + PI2 ) % PI2 ; } public static float lerpAngleDeg ( float fromDegrees , float toDegrees , float progress ) { float delta = ( ( toDegrees - fromDegrees + <int> + <int> ) % <int> ) - <int> ; return ( fromDegrees + delta * progress + <int> ) % <int> ; } static private final int BIG_ENOUGH_INT = <int> * <int> ; static private final double BIG_ENOUGH_FLOOR = BIG_ENOUGH_INT ; static private final double CEIL = <float> ; static private final double BIG_ENOUGH_CEIL = <float> ; static private final double BIG_ENOUGH_ROUND = BIG_ENOUGH_INT + <float> ; static public int floor ( float value ) { return ( int ) ( value + BIG_ENOUGH_FLOOR ) - BIG_ENOUGH_INT ; } static public int floorPositive ( float value ) { return ( int ) value ; } static public int ceil ( float value ) { return ( int ) ( value + BIG_ENOUGH_CEIL ) - BIG_ENOUGH_INT ; } static public int ceilPositive ( float value ) { return ( int ) ( value + CEIL ) ; } static public int round ( float value ) { return ( int ) ( value + BIG_ENOUGH_ROUND ) - BIG_ENOUGH_INT ; } static public int roundPositive ( float value ) { return ( int ) ( value + <float> ) ; } static public boolean isZero ( float value ) { return Math . abs ( value ) < = FLOAT_ROUNDING_ERROR ; } static public boolean isZero ( float value , float tolerance ) { return Math . abs ( value ) < = tolerance ; } static public boolean isEqual ( float a , float b ) { return Math . abs ( a - b ) < = FLOAT_ROUNDING_ERROR ; } static public boolean isEqual ( float a , float b , float tolerance ) { return Math . abs ( a - b ) < = tolerance ; } static public float log ( float a , float value ) { return ( float ) ( Math . log ( value ) / Math . log ( a ) ) ; } static public float log2 ( float value ) { return log ( <int> , value ) ; } } 
