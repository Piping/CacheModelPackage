package com . google . common . math ; import com . google . common . collect . ImmutableMap ; import java . math . RoundingMode ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; enum QuantilesAlgorithm { SORTING { @Override double singleQuantile ( int index , int scale , double [ ] dataset ) { Arrays . sort ( dataset ) ; return singleQuantileFromSorted ( index , scale , dataset ) ; } @Override Map < Integer , Double > multipleQuantiles ( Collection < Integer > indexes , int scale , double [ ] dataset ) { Arrays . sort ( dataset ) ; ImmutableMap . Builder < Integer , Double > builder = ImmutableMap . builder ( ) ; for ( int index : indexes ) { builder . put ( index , singleQuantileFromSorted ( index , scale , dataset ) ) ; } return builder . build ( ) ; } private double singleQuantileFromSorted ( int index , int scale , double [ ] dataset ) { long numerator = ( long ) index * ( dataset . length - <int> ) ; int positionFloor = ( int ) LongMath . divide ( numerator , scale , RoundingMode . DOWN ) ; int remainder = ( int ) ( numerator - positionFloor * scale ) ; if ( remainder = = <int> ) { return dataset [ positionFloor ] ; } else { double positionFrac = ( double ) remainder / scale ; return dataset [ positionFloor ] + positionFrac * ( dataset [ positionFloor + <int> ] - dataset [ positionFloor ] ) ; } } } , QUICKSELECT { @Override double singleQuantile ( int index , int scale , double [ ] dataset ) { long numerator = ( long ) index * ( dataset . length - <int> ) ; int positionFloor = ( int ) LongMath . divide ( numerator , scale , RoundingMode . DOWN ) ; int remainder = ( int ) ( numerator - positionFloor * scale ) ; double percentileFloor = select ( positionFloor , dataset ) ; if ( remainder = = <int> ) { return percentileFloor ; } else { double percentileCeiling = getMinValue ( dataset , positionFloor + <int> ) ; double positionFrac = ( double ) remainder / scale ; return percentileFloor + positionFrac * ( percentileCeiling - percentileFloor ) ; } } @Override Map < Integer , Double > multipleQuantiles ( Collection < Integer > indexes , int scale , double [ ] dataset ) { ImmutableMap . Builder < Integer , Double > builder = ImmutableMap . builder ( ) ; for ( int index : indexes ) { builder . put ( index , singleQuantile ( index , scale , dataset ) ) ; } return builder . build ( ) ; } } , TARGET { @Override double singleQuantile ( int index , int scale , double [ ] dataset ) { return Quantiles . scale ( scale ) . index ( index ) . computeInPlace ( dataset ) ; } @Override Map < Integer , Double > multipleQuantiles ( Collection < Integer > indexes , int scale , double [ ] dataset ) { return Quantiles . scale ( scale ) . indexes ( indexes ) . computeInPlace ( dataset ) ; } } , ; abstract double singleQuantile ( int index , int scale , double [ ] dataset ) ; abstract Map < Integer , Double > multipleQuantiles ( Collection < Integer > indexes , int scale , double [ ] dataset ) ; static double getMinValue ( double [ ] array , int from ) { int min = from ; for ( int i = from + <int> ; i < array . length ; i + + ) { if ( array [ min ] > array [ i ] ) { min = i ; } } return array [ min ] ; } static double select ( int k , double [ ] array ) { int from = <int> ; int to = array . length - <int> ; while ( true ) { if ( to < = from + <int> ) { if ( to = = from + <int> & & array [ to ] < array [ from ] ) { swap ( array , from , to ) ; } return array [ k ] ; } else { int midIndex = ( from + to ) > > > <int> ; swap ( array , midIndex , from + <int> ) ; if ( array [ from ] > array [ to ] ) { swap ( array , from , to ) ; } if ( array [ from + <int> ] > array [ to ] ) { swap ( array , from + <int> , to ) ; } if ( array [ from ] > array [ from + <int> ] ) { swap ( array , from , from + <int> ) ; } int low = from + <int> , high = to ; double partition = array [ from + <int> ] ; while ( true ) { do { low + + ; } while ( array [ low ] < partition ) ; do { high - - ; } while ( array [ high ] > partition ) ; if ( high < low ) { break ; } swap ( array , low , high ) ; } array [ from + <int> ] = array [ high ] ; array [ high ] = partition ; if ( high > = k ) { to = high - <int> ; } if ( high < = k ) { from = low ; } } } } private static void swap ( double [ ] array , int i , int j ) { double temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } } 
