package org . gradle . api . tasks . diagnostics . internal . text ; import com . google . common . base . Joiner ; import org . gradle . api . Action ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . logging . StyledTextOutput ; import org . gradle . logging . internal . LinePrefixingStyledTextOutput ; import org . gradle . reporting . ReportRenderer ; import java . io . File ; import java . io . IOException ; import java . util . Collection ; import static org . gradle . logging . StyledTextOutput . Style . Header ; import static org . gradle . logging . StyledTextOutput . Style . Normal ; public class DefaultTextReportBuilder implements TextReportBuilder { public static final String SEPARATOR = <str> ; public static final String INDENT = <str> ; private int depth ; private boolean hasTitledItems ; private StyledTextOutput textOutput ; private final FileResolver fileResolver ; public DefaultTextReportBuilder ( StyledTextOutput textOutput , FileResolver fileResolver ) { this . textOutput = textOutput ; this . fileResolver = fileResolver ; } public void item ( String title , String value ) { hasTitledItems = true ; StyledTextOutput itemOutput = new LinePrefixingStyledTextOutput ( textOutput , INDENT , false ) ; itemOutput . append ( title ) . append ( <str> ) ; itemOutput . append ( value ) . println ( ) ; } public void item ( String title , File value ) { item ( title , fileResolver . resolveAsRelativePath ( value ) ) ; } public void item ( String value ) { hasTitledItems = true ; textOutput . append ( value ) . println ( ) ; } @Override public void item ( String title , Iterable < String > values ) { item ( title , Joiner . on ( <str> ) . join ( values ) ) ; } public void item ( File value ) { item ( fileResolver . resolveAsRelativePath ( value ) ) ; } @Override public < T > void item ( final T value , final ReportRenderer < T , TextReportBuilder > renderer ) { renderItem ( new Action < TextReportBuilder > ( ) { @Override public void execute ( TextReportBuilder textReportBuilder ) { try { renderer . render ( value , textReportBuilder ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } } ) ; } public void heading ( String heading ) { if ( depth = = <int> ) { textOutput . println ( ) . style ( Header ) ; textOutput . println ( SEPARATOR ) ; textOutput . println ( heading ) ; textOutput . text ( SEPARATOR ) ; textOutput . style ( Normal ) ; textOutput . println ( ) . println ( ) ; } else if ( depth = = <int> ) { writeSubheading ( heading ) ; } else { textOutput . println ( heading ) ; textOutput = new LinePrefixingStyledTextOutput ( textOutput , INDENT ) ; } depth + + ; } public void subheading ( String heading ) { writeSubheading ( heading ) ; if ( depth = = <int> ) { depth = <int> ; } } private void writeSubheading ( String heading ) { textOutput . style ( Header ) . println ( heading ) ; for ( int i = <int> ; i < heading . length ( ) ; i + + ) { textOutput . text ( <str> ) ; } textOutput . style ( Normal ) . println ( ) ; } public < T > void collection ( String title , Collection < ? extends T > items , ReportRenderer < T , TextReportBuilder > renderer , String elementsPlural ) { if ( depth < = <int> & & ! hasTitledItems ) { writeSubheading ( title ) ; } else if ( depth = = <int> & & ! hasTitledItems ) { textOutput . println ( title ) ; } else { textOutput . append ( title ) . println ( <str> ) ; } if ( items . isEmpty ( ) ) { textOutput . formatln ( <str> , elementsPlural ) ; return ; } collection ( items , renderer ) ; } @Override public < T > void collection ( final Iterable < ? extends T > items , final ReportRenderer < T , TextReportBuilder > renderer ) { for ( final T t : items ) { nested ( new Action < TextReportBuilder > ( ) { @Override public void execute ( TextReportBuilder textReportBuilder ) { try { renderer . render ( t , textReportBuilder ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } } ) ; } } public StyledTextOutput getOutput ( ) { return textOutput ; } private void nested ( final Action < TextReportBuilder > action ) { final boolean indent = depth > <int> | | hasTitledItems ; renderItem ( new Action < TextReportBuilder > ( ) { @Override public void execute ( TextReportBuilder textReportBuilder ) { if ( indent ) { textOutput = new LinePrefixingStyledTextOutput ( textOutput , INDENT ) ; } depth + + ; action . execute ( textReportBuilder ) ; } } ) ; } private void renderItem ( Action < TextReportBuilder > action ) { StyledTextOutput original = textOutput ; int originalDepth = depth ; boolean originalItems = hasTitledItems ; try { hasTitledItems = false ; action . execute ( this ) ; } finally { textOutput = original ; depth = originalDepth ; hasTitledItems = originalItems ; } } } 
