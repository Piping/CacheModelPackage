package org . gradle . model . internal . registry ; import com . google . common . base . Joiner ; import com . google . common . collect . * ; import net . jcip . annotations . NotThreadSafe ; import org . gradle . api . Nullable ; import org . gradle . model . ConfigurationCycleException ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . RuleSource ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . inspect . ModelRuleExtractor ; import org . gradle . model . internal . report . unbound . UnboundRule ; import org . gradle . model . internal . type . ModelType ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . * ; import static org . gradle . model . internal . core . ModelNode . State . * ; @NotThreadSafe public class DefaultModelRegistry implements ModelRegistryInternal { private static final Logger LOGGER = LoggerFactory . getLogger ( DefaultModelRegistry . class ) ; private final ModelGraph modelGraph ; private final RuleBindings ruleBindings ; private final ModelRuleExtractor ruleExtractor ; private final Set < RuleBinder > unboundRules = Sets . newIdentityHashSet ( ) ; public DefaultModelRegistry ( ModelRuleExtractor ruleExtractor ) { this . ruleExtractor = ruleExtractor ; ModelRegistration rootRegistration = ModelRegistrations . of ( ModelPath . ROOT ) . descriptor ( <str> ) . withProjection ( EmptyModelProjection . INSTANCE ) . build ( ) ; modelGraph = new ModelGraph ( new ModelElementNode ( this , rootRegistration , null ) ) ; modelGraph . getRoot ( ) . setState ( Created ) ; ruleBindings = new RuleBindings ( modelGraph ) ; } public DefaultModelRegistry register ( ModelRegistration registration ) { ModelPath path = registration . getPath ( ) ; if ( ! ModelPath . ROOT . isDirectChild ( path ) ) { throw new InvalidModelRuleDeclarationException ( registration . getDescriptor ( ) , <str> + path + <str> + path . getRootParent ( ) + <str> ) ; } ModelNodeInternal root = modelGraph . getRoot ( ) ; root . addLink ( registration ) ; return this ; } @Override public < T extends ModelNodeInternal > T registerNode ( T node , Multimap < ModelActionRole , ? extends ModelAction < ? > > actions ) { addRuleBindings ( node , actions ) ; modelGraph . add ( node ) ; ruleBindings . nodeCreated ( node ) ; return node ; } private void addRuleBindings ( ModelNodeInternal node , Multimap < ModelActionRole , ? extends ModelAction < ? > > actions ) { for ( Map . Entry < ModelActionRole , ? extends ModelAction < ? > > entry : actions . entries ( ) ) { ModelActionRole role = entry . getKey ( ) ; ModelAction < ? > action = entry . getValue ( ) ; checkNodePath ( node , action ) ; RuleBinder binder = bindInternal ( action . getSubject ( ) , role , action , ModelPath . ROOT ) ; node . addRegistrationActionBinder ( binder ) ; } } @Override public DefaultModelRegistry configure ( ModelActionRole role , ModelAction < ? > action ) { bind ( action . getSubject ( ) , role , action , ModelPath . ROOT ) ; return this ; } @Override public ModelRegistry configure ( ModelActionRole role , ModelAction < ? > action , ModelPath scope ) { bind ( action . getSubject ( ) , role , action , scope ) ; return this ; } @Override public ModelRegistry configureMatching ( ModelPredicate predicate , final ModelActionRole role , final ModelAction < ? > action ) { if ( action . getSubject ( ) . getPath ( ) ! = null ) { throw new IllegalArgumentException ( <str> ) ; } final ModelType < ? > subjectType = action . getSubject ( ) . getType ( ) ; registerListener ( new DelegatingListener ( predicate ) { @Override public boolean matches ( MutableModelNode node ) { node . ensureAtLeast ( Discovered ) ; return node . canBeViewedAs ( subjectType ) & & super . matches ( node ) ; } @Override public boolean onDiscovered ( ModelNodeInternal node ) { bind ( ModelReference . of ( node . getPath ( ) , subjectType ) , role , action , ModelPath . ROOT ) ; return false ; } } ) ; return this ; } @Override public ModelRegistry configureMatching ( ModelPredicate predicate , final Class < ? extends RuleSource > rules ) { registerListener ( new DelegatingListener ( predicate ) { @Override public boolean onDiscovered ( ModelNodeInternal node ) { node . applyToSelf ( rules ) ; return false ; } } ) ; return this ; } @Override public ModelRegistry configure ( Class < ? extends RuleSource > rules , ModelPath scope ) { Iterable < ExtractedModelRule > extractedRules = ruleExtractor . extract ( rules ) ; for ( ExtractedModelRule extractedRule : extractedRules ) { if ( ! extractedRule . getRuleDependencies ( ) . isEmpty ( ) ) { throw new IllegalStateException ( String . format ( <str> , rules , extractedRule ) ) ; } extractedRule . apply ( this , scope ) ; } return this ; } static void checkNodePath ( ModelNodeInternal node , ModelAction < ? > action ) { if ( ! node . getPath ( ) . equals ( action . getSubject ( ) . getPath ( ) ) ) { throw new IllegalArgumentException ( String . format ( <str> , action . getSubject ( ) . getPath ( ) , node . getPath ( ) ) ) ; } } @Override public < T > void bind ( ModelReference < T > subject , ModelActionRole role , ModelAction < ? > mutator , ModelPath scope ) { bindInternal ( subject , role , mutator , scope ) ; } private < T > RuleBinder bindInternal ( ModelReference < T > subject , ModelActionRole role , ModelAction < ? > mutator , ModelPath scope ) { BindingPredicate mappedSubject = mapSubject ( subject , role , scope ) ; List < BindingPredicate > mappedInputs = mapInputs ( mutator . getInputs ( ) , scope ) ; RuleBinder binder = new RuleBinder ( mappedSubject , mappedInputs , mutator , unboundRules ) ; ruleBindings . add ( binder ) ; return binder ; } @Override public < T > T realize ( String path , Class < T > type ) { return realize ( path , ModelType . of ( type ) ) ; } @Override public < T > T realize ( String path , ModelType < T > type ) { return realize ( ModelPath . path ( path ) , type ) ; } @Override public < T > T realize ( ModelPath path , ModelType < T > type ) { return toType ( type , require ( path ) , <str> ) ; } public ModelNode atState ( ModelPath path , ModelNode . State state ) { return atStateOrMaybeLater ( path , state , false ) ; } @Override public ModelNode atStateOrLater ( ModelPath path , ModelNode . State state ) { return atStateOrMaybeLater ( path , state , true ) ; } @Override public < T > T atStateOrLater ( ModelPath path , ModelType < T > type , ModelNode . State state ) { return toType ( type , atStateOrMaybeLater ( path , state , true ) , <str> ) ; } private ModelNodeInternal atStateOrMaybeLater ( ModelPath path , ModelNode . State state , boolean laterOk ) { ModelNodeInternal node = modelGraph . find ( path ) ; if ( node = = null ) { throw new IllegalStateException ( <str> + path + <str> ) ; } transition ( node , state , laterOk ) ; return node ; } @Override public < T > T find ( String path , Class < T > type ) { return find ( path , ModelType . of ( type ) ) ; } @Override public < T > T find ( String path , ModelType < T > type ) { return find ( ModelPath . path ( path ) , type ) ; } @Override public < T > T find ( ModelPath path , ModelType < T > type ) { return toType ( type , get ( path ) , <str> ) ; } private < T > T toType ( ModelType < T > type , ModelNodeInternal node , String msg ) { if ( node = = null ) { return null ; } else { return node . asImmutable ( type , new SimpleModelRuleDescriptor ( msg ) ) . getInstance ( ) ; } } @Override public ModelNode realizeNode ( ModelPath path ) { return require ( path ) ; } private void registerListener ( ModelListener listener ) { modelGraph . addListener ( listener ) ; } @Override public void remove ( ModelPath path ) { ModelNodeInternal node = modelGraph . find ( path ) ; if ( node = = null ) { return ; } List < ModelNodeInternal > nodesToRemove = Lists . newArrayList ( ) ; ensureCanRemove ( node , nodesToRemove ) ; Collections . reverse ( nodesToRemove ) ; for ( ModelNodeInternal nodeToRemove : nodesToRemove ) { modelGraph . remove ( nodeToRemove ) ; ruleBindings . remove ( nodeToRemove ) ; unboundRules . removeAll ( nodeToRemove . getRegistrationActionBinders ( ) ) ; } } private void ensureCanRemove ( ModelNodeInternal node , List < ModelNodeInternal > nodesToRemove ) { if ( ! ( node instanceof ModelReferenceNode ) ) { for ( ModelNodeInternal childNode : node . getLinks ( ) ) { ensureCanRemove ( childNode , nodesToRemove ) ; } } if ( ! Iterables . isEmpty ( node . getDependents ( ) ) ) { throw new IllegalStateException ( String . format ( <str> , node . getPath ( ) , Joiner . on ( <str> ) . join ( node . getDependents ( ) ) ) ) ; } nodesToRemove . add ( node ) ; } @Override public void bindAllReferences ( ) throws UnboundModelRulesException { GoalGraph graph = new GoalGraph ( ) ; for ( ModelNodeInternal node : modelGraph . getFlattened ( ) . values ( ) ) { if ( ! node . isAtLeast ( Discovered ) ) { transitionTo ( graph , new Discover ( node . getPath ( ) ) ) ; } } if ( unboundRules . isEmpty ( ) ) { return ; } boolean newInputsBound = true ; while ( ! unboundRules . isEmpty ( ) & & newInputsBound ) { newInputsBound = false ; RuleBinder [ ] unboundBinders = unboundRules . toArray ( new RuleBinder [ unboundRules . size ( ) ] ) ; for ( RuleBinder binder : unboundBinders ) { transitionTo ( graph , new TryBindInputs ( binder ) ) ; newInputsBound = newInputsBound | | binder . isBound ( ) ; } } if ( ! unboundRules . isEmpty ( ) ) { SortedSet < RuleBinder > sortedBinders = new TreeSet < RuleBinder > ( new Comparator < RuleBinder > ( ) { @Override public int compare ( RuleBinder o1 , RuleBinder o2 ) { return String . valueOf ( o1 . getDescriptor ( ) ) . compareTo ( String . valueOf ( o2 . getDescriptor ( ) ) ) ; } } ) ; sortedBinders . addAll ( unboundRules ) ; throw unbound ( sortedBinders ) ; } } private UnboundModelRulesException unbound ( Iterable < ? extends RuleBinder > binders ) { ModelPathSuggestionProvider suggestionsProvider = new ModelPathSuggestionProvider ( modelGraph . getFlattened ( ) . keySet ( ) ) ; List < ? extends UnboundRule > unboundRules = new UnboundRulesProcessor ( binders , suggestionsProvider ) . process ( ) ; return new UnboundModelRulesException ( unboundRules ) ; } private ModelNodeInternal require ( ModelPath path ) { ModelNodeInternal node = get ( path ) ; if ( node = = null ) { throw new IllegalStateException ( <str> + path + <str> ) ; } return node ; } @Override public ModelNode . State state ( ModelPath path ) { ModelNodeInternal modelNode = modelGraph . find ( path ) ; return modelNode = = null ? null : modelNode . getState ( ) ; } private ModelNodeInternal get ( ModelPath path ) { GoalGraph graph = new GoalGraph ( ) ; transitionTo ( graph , graph . nodeAtState ( new NodeAtState ( path , Registered ) ) ) ; ModelNodeInternal node = modelGraph . find ( path ) ; if ( node = = null ) { return null ; } transitionTo ( graph , graph . nodeAtState ( new NodeAtState ( path , GraphClosed ) ) ) ; return node ; } private void transitionTo ( GoalGraph goalGraph , ModelGoal targetGoal ) { LinkedList < ModelGoal > queue = new LinkedList < ModelGoal > ( ) ; queue . add ( targetGoal ) ; while ( ! queue . isEmpty ( ) ) { ModelGoal goal = queue . getFirst ( ) ; if ( goal . state = = ModelGoal . State . Achieved ) { queue . removeFirst ( ) ; continue ; } if ( goal . state = = ModelGoal . State . NotSeen ) { if ( goal . isAchieved ( ) ) { goal . state = ModelGoal . State . Achieved ; queue . removeFirst ( ) ; continue ; } } if ( goal . state = = ModelGoal . State . VisitingDependencies ) { goal . apply ( ) ; goal . state = ModelGoal . State . Achieved ; queue . removeFirst ( ) ; continue ; } List < ModelGoal > newDependencies = new ArrayList < ModelGoal > ( ) ; goal . attachNode ( ) ; boolean done = goal . calculateDependencies ( goalGraph , newDependencies ) ; goal . state = done | | newDependencies . isEmpty ( ) ? ModelGoal . State . VisitingDependencies : ModelGoal . State . DiscoveringDependencies ; for ( int i = newDependencies . size ( ) - <int> ; i > = <int> ; i - - ) { ModelGoal dependency = newDependencies . get ( i ) ; if ( dependency . state = = ModelGoal . State . Achieved ) { continue ; } if ( dependency . state = = ModelGoal . State . NotSeen ) { queue . addFirst ( dependency ) ; continue ; } throw ruleCycle ( dependency , queue ) ; } } } private ConfigurationCycleException ruleCycle ( ModelGoal brokenGoal , LinkedList < ModelGoal > queue ) { List < String > path = new ArrayList < String > ( ) ; int pos = queue . indexOf ( brokenGoal ) ; ListIterator < ModelGoal > iterator = queue . listIterator ( pos + <int> ) ; while ( iterator . hasPrevious ( ) ) { ModelGoal goal = iterator . previous ( ) ; goal . attachToCycle ( path ) ; } brokenGoal . attachToCycle ( path ) ; Formatter out = new Formatter ( ) ; out . format ( <str> ) ; String last = null ; StringBuilder indent = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < path . size ( ) ; i + + ) { String node = path . get ( i ) ; if ( node . equals ( last ) ) { continue ; } last = node ; if ( i = = <int> ) { out . format ( <str> , indent , node ) ; } else { out . format ( <str> , indent , node ) ; indent . append ( <str> ) ; } } return new ConfigurationCycleException ( out . toString ( ) ) ; } @Override public void transition ( ModelNodeInternal node , ModelNode . State desired , boolean laterOk ) { ModelPath path = node . getPath ( ) ; ModelNode . State state = node . getState ( ) ; LOGGER . debug ( <str> , path , state . name ( ) , desired . name ( ) ) ; if ( desired . ordinal ( ) < state . ordinal ( ) ) { if ( laterOk ) { return ; } else { throw new IllegalStateException ( <str> + path + <str> + desired . name ( ) + <str> + state . name ( ) ) ; } } if ( state = = desired ) { return ; } GoalGraph goalGraph = new GoalGraph ( ) ; transitionTo ( goalGraph , goalGraph . nodeAtState ( new NodeAtState ( node . getPath ( ) , desired ) ) ) ; } private void fireAction ( RuleBinder boundMutator ) { final List < ModelView < ? > > inputs = toViews ( boundMutator . getInputBindings ( ) , boundMutator . getAction ( ) . getDescriptor ( ) ) ; ModelBinding subjectBinding = boundMutator . getSubjectBinding ( ) ; final ModelNodeInternal node = subjectBinding . getNode ( ) ; final ModelAction < ? > mutator = boundMutator . getAction ( ) ; ModelRuleDescriptor descriptor = mutator . getDescriptor ( ) ; LOGGER . debug ( <str> , node . getPath ( ) , descriptor ) ; try { RuleContext . run ( descriptor , new Runnable ( ) { @Override public void run ( ) { mutator . execute ( node , inputs ) ; } } ) ; } catch ( Exception e ) { throw new ModelRuleExecutionException ( descriptor , e ) ; } } private List < ModelView < ? > > toViews ( List < ModelBinding > bindings , ModelRuleDescriptor descriptor ) { @SuppressWarnings ( <str> ) ModelView < ? > [ ] array = new ModelView < ? > [ bindings . size ( ) ] ; int i = <int> ; for ( ModelBinding binding : bindings ) { ModelNodeInternal element = binding . getNode ( ) ; ModelView < ? > view = element . asImmutable ( binding . getPredicate ( ) . getType ( ) , descriptor ) ; array [ i + + ] = view ; } @SuppressWarnings ( <str> ) List < ModelView < ? > > views = Arrays . asList ( array ) ; return views ; } @Override public MutableModelNode getRoot ( ) { return modelGraph . getRoot ( ) ; } @Nullable public MutableModelNode node ( ModelPath path ) { return modelGraph . find ( path ) ; } private BindingPredicate mapSubject ( ModelReference < ? > subjectReference , ModelActionRole role , ModelPath scope ) { if ( ! role . isSubjectViewAvailable ( ) & & ! subjectReference . isUntyped ( ) ) { throw new IllegalStateException ( String . format ( <str> , subjectReference , role ) ) ; } ModelReference < ? > mappedReference ; if ( subjectReference . getPath ( ) = = null ) { mappedReference = subjectReference . inScope ( scope ) ; } else { mappedReference = subjectReference . withPath ( scope . descendant ( subjectReference . getPath ( ) ) ) ; } return new BindingPredicate ( mappedReference . atState ( role . getTargetState ( ) ) ) ; } private List < BindingPredicate > mapInputs ( List < ? extends ModelReference < ? > > inputs , ModelPath scope ) { if ( inputs . isEmpty ( ) ) { return Collections . emptyList ( ) ; } ArrayList < BindingPredicate > result = new ArrayList < BindingPredicate > ( inputs . size ( ) ) ; for ( ModelReference < ? > input : inputs ) { if ( input . getPath ( ) ! = null ) { result . add ( new BindingPredicate ( input . withPath ( scope . descendant ( input . getPath ( ) ) ) ) ) ; } else { result . add ( new BindingPredicate ( input . inScope ( ModelPath . ROOT ) ) ) ; } } return result ; } private class GoalGraph { private final Map < NodeAtState , ModelGoal > nodeStates = new HashMap < NodeAtState , ModelGoal > ( ) ; public ModelGoal nodeAtState ( NodeAtState goal ) { ModelGoal node = nodeStates . get ( goal ) ; if ( node = = null ) { switch ( goal . state ) { case Registered : node = new MakeKnown ( goal . path ) ; break ; case Discovered : node = new Discover ( goal . path ) ; break ; case GraphClosed : node = new CloseGraph ( goal ) ; break ; default : node = new ApplyActions ( goal ) ; } nodeStates . put ( goal , node ) ; } return node ; } } private abstract static class ModelGoal { enum State { NotSeen , DiscoveringDependencies , VisitingDependencies , Achieved , } public State state = State . NotSeen ; public boolean isAchieved ( ) { return false ; } public void attachNode ( ) { } public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { return true ; } void apply ( ) { } void attachToCycle ( List < String > displayValue ) { } @Override public abstract String toString ( ) ; } private abstract class ModelNodeGoal extends ModelGoal { public final ModelPath target ; public ModelNodeInternal node ; protected ModelNodeGoal ( ModelPath target ) { this . target = target ; } public ModelPath getPath ( ) { return target ; } @Override public final boolean isAchieved ( ) { node = modelGraph . find ( target ) ; return node ! = null & & doIsAchieved ( ) ; } protected boolean doIsAchieved ( ) { return false ; } @Override public void attachNode ( ) { if ( node ! = null ) { return ; } node = modelGraph . find ( getPath ( ) ) ; } } private class MakeKnown extends ModelNodeGoal { public MakeKnown ( ModelPath path ) { super ( path ) ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + state ; } @Override public boolean doIsAchieved ( ) { return true ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { ModelPath parent = getPath ( ) . getParent ( ) ; if ( parent ! = null ) { dependencies . add ( graph . nodeAtState ( new NodeAtState ( parent , SelfClosed ) ) ) ; } return true ; } } private abstract class TransitionNodeToState extends ModelNodeGoal { final NodeAtState target ; private boolean seenPredecessor ; public TransitionNodeToState ( NodeAtState target ) { super ( target . path ) ; this . target = target ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + target . state + <str> + state ; } public ModelNode . State getTargetState ( ) { return target . state ; } @Override public boolean doIsAchieved ( ) { return node . getState ( ) . compareTo ( getTargetState ( ) ) > = <int> ; } @Override public final boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( ! seenPredecessor ) { NodeAtState predecessor = new NodeAtState ( getPath ( ) , getTargetState ( ) . previous ( ) ) ; dependencies . add ( graph . nodeAtState ( predecessor ) ) ; dependencies . add ( new TransitionDependents ( predecessor ) ) ; seenPredecessor = true ; return false ; } if ( node = = null ) { throw new IllegalStateException ( String . format ( <str> , getPath ( ) , getTargetState ( ) . name ( ) ) ) ; } return doCalculateDependencies ( graph , dependencies ) ; } boolean doCalculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { return true ; } @Override public final void apply ( ) { if ( ! node . getState ( ) . equals ( getTargetState ( ) . previous ( ) ) ) { throw new IllegalStateException ( String . format ( <str> , node . getPath ( ) , getTargetState ( ) , node . getState ( ) ) ) ; } LOGGER . debug ( <str> , node . getPath ( ) , getTargetState ( ) . name ( ) ) ; node . setState ( getTargetState ( ) ) ; } @Override void attachToCycle ( List < String > displayValue ) { displayValue . add ( getPath ( ) . toString ( ) ) ; } } private class Discover extends ModelNodeGoal { public Discover ( ModelPath path ) { super ( path ) ; } @Override public boolean doIsAchieved ( ) { return node . isAtLeast ( Discovered ) ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { dependencies . add ( new ApplyActions ( new NodeAtState ( getPath ( ) , Discovered ) ) ) ; dependencies . add ( new NotifyDiscovered ( getPath ( ) ) ) ; return true ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + state ; } } private class TransitionDependents extends ModelGoal { private final NodeAtState input ; public TransitionDependents ( NodeAtState input ) { this . input = input ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { for ( RuleBinder rule : ruleBindings . getRulesWithInput ( input ) ) { ModelBinding subjectBinding = rule . getSubjectBinding ( ) ; if ( ! subjectBinding . isBound ( ) ) { continue ; } ModelPath targetPath = subjectBinding . getNode ( ) . getPath ( ) ; if ( targetPath . equals ( input . path ) ) { continue ; } ModelNode . State targetState = subjectBinding . getPredicate ( ) . getState ( ) ; dependencies . add ( graph . nodeAtState ( new NodeAtState ( targetPath , targetState ) ) ) ; } return true ; } @Override public String toString ( ) { return <str> + input . path + <str> + input . state + <str> + state ; } } private class TransitionChildrenOrReference extends ModelNodeGoal { private final ModelNode . State targetState ; protected TransitionChildrenOrReference ( ModelPath target , ModelNode . State targetState ) { super ( target ) ; this . targetState = targetState ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( node instanceof ModelReferenceNode ) { ModelReferenceNode referenceNode = ( ModelReferenceNode ) node ; ModelNodeInternal target = referenceNode . getTarget ( ) ; if ( target = = null | | target . getPath ( ) . isDescendant ( node . getPath ( ) ) ) { return true ; } if ( ! target . isAtLeast ( targetState ) ) { dependencies . add ( graph . nodeAtState ( new NodeAtState ( target . getPath ( ) , targetState ) ) ) ; } } else { for ( ModelNodeInternal child : node . getLinks ( ) ) { if ( ! child . isAtLeast ( targetState ) ) { dependencies . add ( graph . nodeAtState ( new NodeAtState ( child . getPath ( ) , targetState ) ) ) ; } } } return true ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + targetState + <str> + state ; } } private class ApplyActions extends TransitionNodeToState { private final Set < RuleBinder > seenRules = new HashSet < RuleBinder > ( ) ; public ApplyActions ( NodeAtState target ) { super ( target ) ; } @Override boolean doCalculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { boolean noActionsAdded = true ; for ( RuleBinder binder : ruleBindings . getRulesWithSubject ( target ) ) { if ( seenRules . add ( binder ) ) { noActionsAdded = false ; dependencies . add ( new RunModelAction ( getPath ( ) , binder ) ) ; } } return noActionsAdded ; } } private class CloseGraph extends TransitionNodeToState { public CloseGraph ( NodeAtState target ) { super ( target ) ; } @Override boolean doCalculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { dependencies . add ( new TransitionChildrenOrReference ( getPath ( ) , GraphClosed ) ) ; return true ; } } private class TryResolvePath extends ModelNodeGoal { private boolean attemptedParent ; public TryResolvePath ( ModelPath path ) { super ( path ) ; } @Override protected boolean doIsAchieved ( ) { return true ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( ! attemptedParent ) { dependencies . add ( new TryResolvePath ( getPath ( ) . getParent ( ) ) ) ; attemptedParent = true ; return false ; } ModelNodeInternal parent = modelGraph . find ( getPath ( ) . getParent ( ) ) ; if ( parent = = null ) { return true ; } if ( parent instanceof ModelReferenceNode ) { ModelReferenceNode parentReference = ( ModelReferenceNode ) parent ; if ( parentReference . getTarget ( ) ! = null ) { dependencies . add ( new TryResolveReference ( parentReference , getPath ( ) ) ) ; } } else { dependencies . add ( graph . nodeAtState ( new NodeAtState ( getPath ( ) . getParent ( ) , SelfClosed ) ) ) ; } return true ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + state ; } } private class TryResolveAndDiscoverPath extends TryResolvePath { private boolean attemptedPath ; public TryResolveAndDiscoverPath ( ModelPath path ) { super ( path ) ; } @Override protected boolean doIsAchieved ( ) { return node . isAtLeast ( Discovered ) ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( modelGraph . find ( getPath ( ) ) = = null ) { if ( ! attemptedPath ) { attemptedPath = super . calculateDependencies ( graph , dependencies ) ; return false ; } else { return true ; } } dependencies . add ( graph . nodeAtState ( new NodeAtState ( getPath ( ) , Discovered ) ) ) ; return true ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + state ; } } private class TryResolveReference extends ModelGoal { private final ModelReferenceNode parent ; private final ModelPath path ; public TryResolveReference ( ModelReferenceNode parent , ModelPath path ) { this . parent = parent ; this . path = path ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { dependencies . add ( new TryResolveAndDiscoverPath ( parent . getTarget ( ) . getPath ( ) . child ( path . getName ( ) ) ) ) ; return true ; } @Override void apply ( ) { ModelNodeInternal parentTarget = parent . getTarget ( ) ; ModelNodeInternal childTarget = parentTarget . getLink ( path . getName ( ) ) ; if ( childTarget = = null ) { throw new NullPointerException ( <str> ) ; } ModelRegistration registration = ModelRegistrations . of ( path ) . descriptor ( parent . getDescriptor ( ) ) . withProjection ( childTarget . getProjection ( ) ) . build ( ) ; ModelReferenceNode childNode = new ModelReferenceNode ( registration , parent ) ; childNode . setTarget ( childTarget ) ; registerNode ( childNode , ImmutableMultimap . < ModelActionRole , ModelAction < ? > > of ( ) ) ; ruleBindings . nodeDiscovered ( childNode ) ; } @Override public String toString ( ) { return <str> + path + <str> + state ; } } private class TryDiscoverSelfDiscoveringInScope extends ModelGoal { private final ModelNodeInternal scopeNode ; public TryDiscoverSelfDiscoveringInScope ( ModelNodeInternal scopeNode ) { this . scopeNode = scopeNode ; } @Override public boolean isAchieved ( ) { for ( ModelNodeInternal child : scopeNode . getLinks ( ) ) { if ( ! child . isAtLeast ( Discovered ) & & ! hasInputs ( new NodeAtState ( child . getPath ( ) , Discovered ) ) ) { return false ; } } return true ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { for ( ModelNodeInternal child : scopeNode . getLinks ( ) ) { NodeAtState target = new NodeAtState ( child . getPath ( ) , Discovered ) ; if ( ! child . isAtLeast ( Discovered ) & & ! hasInputs ( target ) ) { dependencies . add ( graph . nodeAtState ( target ) ) ; } } return false ; } @Override public String toString ( ) { return <str> + scopeNode . getPath ( ) + <str> + state ; } private boolean hasInputs ( NodeAtState target ) { for ( RuleBinder ruleBinder : ruleBindings . getRulesWithSubject ( target ) ) { if ( ! ruleBinder . getInputBindings ( ) . isEmpty ( ) ) { return true ; } } return false ; } } private class TryDefineScopeForType extends ModelGoal { private final ModelPath scope ; private final ModelType < ? > typeToBind ; private boolean attemptedPath ; private boolean attemptedSelfDiscoveringChildren ; private boolean attemptedCloseScope ; public TryDefineScopeForType ( ModelPath scope , ModelType < ? > typeToBind ) { this . scope = scope ; this . typeToBind = typeToBind ; } @Override public boolean isAchieved ( ) { ModelNodeInternal node = modelGraph . find ( scope ) ; if ( node = = null ) { return false ; } for ( ModelNodeInternal child : node . getLinks ( ) ) { if ( child . isAtLeast ( Discovered ) & & ( child . getPromise ( ) . canBeViewedAsImmutable ( typeToBind ) | | child . getPromise ( ) . canBeViewedAsMutable ( typeToBind ) ) ) { return true ; } } return false ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( ! attemptedPath ) { dependencies . add ( new TryResolvePath ( scope ) ) ; attemptedPath = true ; return false ; } ModelNodeInternal scopeNode = modelGraph . find ( scope ) ; if ( scopeNode = = null ) { return true ; } if ( ! attemptedSelfDiscoveringChildren ) { dependencies . add ( new TryDiscoverSelfDiscoveringInScope ( scopeNode ) ) ; attemptedSelfDiscoveringChildren = true ; return false ; } if ( isAchieved ( ) ) { return true ; } if ( ! attemptedCloseScope ) { dependencies . add ( graph . nodeAtState ( new NodeAtState ( scope , SelfClosed ) ) ) ; attemptedCloseScope = true ; return false ; } dependencies . add ( new TransitionChildrenOrReference ( scope , Discovered ) ) ; return true ; } @Override public String toString ( ) { return <str> + scope + <str> + typeToBind + <str> + state ; } } private class TryBindInputs extends ModelGoal { private final RuleBinder binder ; public TryBindInputs ( RuleBinder binder ) { this . binder = binder ; } @Override public String toString ( ) { return <str> + binder . getDescriptor ( ) + <str> + state ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { maybeBind ( binder . getSubjectBinding ( ) , dependencies ) ; for ( ModelBinding binding : binder . getInputBindings ( ) ) { maybeBind ( binding , dependencies ) ; } return true ; } private void maybeBind ( ModelBinding binding , Collection < ModelGoal > dependencies ) { if ( ! binding . isBound ( ) ) { BindingPredicate predicate = binding . getPredicate ( ) ; if ( predicate . getPath ( ) ! = null ) { dependencies . add ( new TryResolveAndDiscoverPath ( predicate . getPath ( ) ) ) ; } else { dependencies . add ( new TryDefineScopeForType ( predicate . getScope ( ) , predicate . getType ( ) ) ) ; } } } } private class RunModelAction extends ModelNodeGoal { private final RuleBinder binder ; private boolean bindInputs ; public RunModelAction ( ModelPath path , RuleBinder binder ) { super ( path ) ; this . binder = binder ; } @Override public String toString ( ) { return <str> + binder . getSubjectBinding ( ) . getPredicate ( ) + <str> + binder . getDescriptor ( ) + <str> + state ; } @Override public boolean calculateDependencies ( GoalGraph graph , Collection < ModelGoal > dependencies ) { if ( ! bindInputs ) { dependencies . add ( new TryBindInputs ( binder ) ) ; bindInputs = true ; return false ; } if ( ! binder . isBound ( ) ) { throw unbound ( Collections . singleton ( binder ) ) ; } for ( ModelBinding binding : binder . getInputBindings ( ) ) { dependencies . add ( graph . nodeAtState ( new NodeAtState ( binding . getNode ( ) . getPath ( ) , binding . getPredicate ( ) . getState ( ) ) ) ) ; } return true ; } @Override void attachToCycle ( List < String > displayValue ) { displayValue . add ( binder . getDescriptor ( ) . toString ( ) ) ; } @Override void apply ( ) { LOGGER . debug ( <str> , getPath ( ) , binder . getDescriptor ( ) ) ; fireAction ( binder ) ; node . notifyFired ( binder ) ; } } private class NotifyDiscovered extends ModelNodeGoal { protected NotifyDiscovered ( ModelPath target ) { super ( target ) ; } @Override void apply ( ) { ruleBindings . nodeDiscovered ( node ) ; modelGraph . nodeDiscovered ( node ) ; } @Override public String toString ( ) { return <str> + getPath ( ) + <str> + state ; } } private abstract static class DelegatingListener extends ModelListener { private final ModelPredicate predicate ; public DelegatingListener ( ModelPredicate predicate ) { this . predicate = predicate ; } @Override @Nullable public ModelPath getPath ( ) { return predicate . getPath ( ) ; } @Override @Nullable public ModelPath getParent ( ) { return predicate . getParent ( ) ; } @Override @Nullable public ModelPath getAncestor ( ) { return predicate . getAncestor ( ) ; } @Override public boolean matches ( MutableModelNode node ) { return predicate . matches ( node ) ; } } } 
