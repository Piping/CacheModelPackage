package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . collect . CollectPreconditions . checkEntryNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . j2objc . annotations . WeakOuter ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . EnumMap ; import java . util . Iterator ; import java . util . Map ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) @SuppressWarnings ( <str> ) public abstract class ImmutableMap < K , V > implements Map < K , V > , Serializable { public static < K , V > ImmutableMap < K , V > of ( ) { return ImmutableBiMap . of ( ) ; } public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 ) { return ImmutableBiMap . of ( k1 , v1 ) ; } public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return RegularImmutableMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) ) ; } public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { return RegularImmutableMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) ) ; } public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { return RegularImmutableMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) ) ; } public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { return RegularImmutableMap . fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) ) ; } static < K , V > ImmutableMapEntry < K , V > entryOf ( K key , V value ) { return new ImmutableMapEntry < K , V > ( key , value ) ; } public static < K , V > Builder < K , V > builder ( ) { return new Builder < K , V > ( ) ; } static void checkNoConflict ( boolean safe , String conflictDescription , Entry < ? , ? > entry1 , Entry < ? , ? > entry2 ) { if ( ! safe ) { throw new IllegalArgumentException ( <str> + conflictDescription + <str> + entry1 + <str> + entry2 ) ; } } public static class Builder < K , V > { Comparator < ? super V > valueComparator ; ImmutableMapEntry < K , V > [ ] entries ; int size ; boolean entriesUsed ; public Builder ( ) { this ( ImmutableCollection . Builder . DEFAULT_INITIAL_CAPACITY ) ; } @SuppressWarnings ( <str> ) Builder ( int initialCapacity ) { this . entries = new ImmutableMapEntry [ initialCapacity ] ; this . size = <int> ; this . entriesUsed = false ; } private void ensureCapacity ( int minCapacity ) { if ( minCapacity > entries . length ) { entries = ObjectArrays . arraysCopyOf ( entries , ImmutableCollection . Builder . expandedCapacity ( entries . length , minCapacity ) ) ; entriesUsed = false ; } } public Builder < K , V > put ( K key , V value ) { ensureCapacity ( size + <int> ) ; ImmutableMapEntry < K , V > entry = entryOf ( key , value ) ; entries [ size + + ] = entry ; return this ; } public Builder < K , V > put ( Entry < ? extends K , ? extends V > entry ) { return put ( entry . getKey ( ) , entry . getValue ( ) ) ; } public Builder < K , V > putAll ( Map < ? extends K , ? extends V > map ) { return putAll ( map . entrySet ( ) ) ; } @Beta public Builder < K , V > putAll ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { if ( entries instanceof Collection ) { ensureCapacity ( size + ( ( Collection < ? > ) entries ) . size ( ) ) ; } for ( Entry < ? extends K , ? extends V > entry : entries ) { put ( entry ) ; } return this ; } @Beta public Builder < K , V > orderEntriesByValue ( Comparator < ? super V > valueComparator ) { checkState ( this . valueComparator = = null , <str> ) ; this . valueComparator = checkNotNull ( valueComparator , <str> ) ; return this ; } public ImmutableMap < K , V > build ( ) { switch ( size ) { case <int> : return of ( ) ; case <int> : return of ( entries [ <int> ] . getKey ( ) , entries [ <int> ] . getValue ( ) ) ; default : if ( valueComparator ! = null ) { if ( entriesUsed ) { entries = ObjectArrays . arraysCopyOf ( entries , size ) ; } Arrays . sort ( entries , <int> , size , Ordering . from ( valueComparator ) . onResultOf ( Maps . < V > valueFunction ( ) ) ) ; } entriesUsed = size = = entries . length ; return RegularImmutableMap . fromEntryArray ( size , entries ) ; } } } public static < K , V > ImmutableMap < K , V > copyOf ( Map < ? extends K , ? extends V > map ) { if ( ( map instanceof ImmutableMap ) & & ! ( map instanceof ImmutableSortedMap ) ) { @SuppressWarnings ( <str> ) ImmutableMap < K , V > kvMap = ( ImmutableMap < K , V > ) map ; if ( ! kvMap . isPartialView ( ) ) { return kvMap ; } } else if ( map instanceof EnumMap ) { @SuppressWarnings ( <str> ) ImmutableMap < K , V > kvMap = ( ImmutableMap < K , V > ) copyOfEnumMap ( ( EnumMap < ? , ? > ) map ) ; return kvMap ; } return copyOf ( map . entrySet ( ) ) ; } @Beta public static < K , V > ImmutableMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( <str> ) Entry < K , V > [ ] entryArray = ( Entry < K , V > [ ] ) Iterables . toArray ( entries , EMPTY_ENTRY_ARRAY ) ; switch ( entryArray . length ) { case <int> : return of ( ) ; case <int> : Entry < K , V > onlyEntry = entryArray [ <int> ] ; return of ( onlyEntry . getKey ( ) , onlyEntry . getValue ( ) ) ; default : return RegularImmutableMap . fromEntries ( entryArray ) ; } } private static < K extends Enum < K > , V > ImmutableMap < K , V > copyOfEnumMap ( EnumMap < K , ? extends V > original ) { EnumMap < K , V > copy = new EnumMap < K , V > ( original ) ; for ( Map . Entry < ? , ? > entry : copy . entrySet ( ) ) { checkEntryNotNull ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ImmutableEnumMap . asImmutable ( copy ) ; } static final Entry < ? , ? > [ ] EMPTY_ENTRY_ARRAY = new Entry < ? , ? > [ <int> ] ; abstract static class IteratorBasedImmutableMap < K , V > extends ImmutableMap < K , V > { abstract UnmodifiableIterator < Entry < K , V > > entryIterator ( ) ; @Override ImmutableSet < Entry < K , V > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends ImmutableMapEntrySet < K , V > { @Override ImmutableMap < K , V > map ( ) { return IteratorBasedImmutableMap . this ; } @Override public UnmodifiableIterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } } return new EntrySetImpl ( ) ; } } ImmutableMap ( ) { } @Deprecated @Override public final V put ( K k , V v ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final V remove ( Object o ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final void putAll ( Map < ? extends K , ? extends V > map ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean isEmpty ( ) { return size ( ) = = <int> ; } @Override public boolean containsKey ( @Nullable Object key ) { return get ( key ) ! = null ; } @Override public boolean containsValue ( @Nullable Object value ) { return values ( ) . contains ( value ) ; } @Override public abstract V get ( @Nullable Object key ) ; private transient ImmutableSet < Entry < K , V > > entrySet ; @Override public ImmutableSet < Entry < K , V > > entrySet ( ) { ImmutableSet < Entry < K , V > > result = entrySet ; return ( result = = null ) ? entrySet = createEntrySet ( ) : result ; } abstract ImmutableSet < Entry < K , V > > createEntrySet ( ) ; private transient ImmutableSet < K > keySet ; @Override public ImmutableSet < K > keySet ( ) { ImmutableSet < K > result = keySet ; return ( result = = null ) ? keySet = createKeySet ( ) : result ; } ImmutableSet < K > createKeySet ( ) { return isEmpty ( ) ? ImmutableSet . < K > of ( ) : new ImmutableMapKeySet < K , V > ( this ) ; } UnmodifiableIterator < K > keyIterator ( ) { final UnmodifiableIterator < Entry < K , V > > entryIterator = entrySet ( ) . iterator ( ) ; return new UnmodifiableIterator < K > ( ) { @Override public boolean hasNext ( ) { return entryIterator . hasNext ( ) ; } @Override public K next ( ) { return entryIterator . next ( ) . getKey ( ) ; } } ; } private transient ImmutableCollection < V > values ; @Override public ImmutableCollection < V > values ( ) { ImmutableCollection < V > result = values ; return ( result = = null ) ? values = new ImmutableMapValues < K , V > ( this ) : result ; } private transient ImmutableSetMultimap < K , V > multimapView ; @Beta public ImmutableSetMultimap < K , V > asMultimap ( ) { if ( isEmpty ( ) ) { return ImmutableSetMultimap . of ( ) ; } ImmutableSetMultimap < K , V > result = multimapView ; return ( result = = null ) ? ( multimapView = new ImmutableSetMultimap < K , V > ( new MapViewOfValuesAsSingletonSets ( ) , size ( ) , null ) ) : result ; } @WeakOuter private final class MapViewOfValuesAsSingletonSets extends IteratorBasedImmutableMap < K , ImmutableSet < V > > { @Override public int size ( ) { return ImmutableMap . this . size ( ) ; } @Override public ImmutableSet < K > keySet ( ) { return ImmutableMap . this . keySet ( ) ; } @Override public boolean containsKey ( @Nullable Object key ) { return ImmutableMap . this . containsKey ( key ) ; } @Override public ImmutableSet < V > get ( @Nullable Object key ) { V outerValue = ImmutableMap . this . get ( key ) ; return ( outerValue = = null ) ? null : ImmutableSet . of ( outerValue ) ; } @Override boolean isPartialView ( ) { return ImmutableMap . this . isPartialView ( ) ; } @Override public int hashCode ( ) { return ImmutableMap . this . hashCode ( ) ; } @Override boolean isHashCodeFast ( ) { return ImmutableMap . this . isHashCodeFast ( ) ; } @Override UnmodifiableIterator < Entry < K , ImmutableSet < V > > > entryIterator ( ) { final Iterator < Entry < K , V > > backingIterator = ImmutableMap . this . entrySet ( ) . iterator ( ) ; return new UnmodifiableIterator < Entry < K , ImmutableSet < V > > > ( ) { @Override public boolean hasNext ( ) { return backingIterator . hasNext ( ) ; } @Override public Entry < K , ImmutableSet < V > > next ( ) { final Entry < K , V > backingEntry = backingIterator . next ( ) ; return new AbstractMapEntry < K , ImmutableSet < V > > ( ) { @Override public K getKey ( ) { return backingEntry . getKey ( ) ; } @Override public ImmutableSet < V > getValue ( ) { return ImmutableSet . of ( backingEntry . getValue ( ) ) ; } } ; } } ; } } @Override public boolean equals ( @Nullable Object object ) { return Maps . equalsImpl ( this , object ) ; } abstract boolean isPartialView ( ) ; @Override public int hashCode ( ) { return Sets . hashCodeImpl ( entrySet ( ) ) ; } boolean isHashCodeFast ( ) { return false ; } @Override public String toString ( ) { return Maps . toStringImpl ( this ) ; } static class SerializedForm implements Serializable { private final Object [ ] keys ; private final Object [ ] values ; SerializedForm ( ImmutableMap < ? , ? > map ) { keys = new Object [ map . size ( ) ] ; values = new Object [ map . size ( ) ] ; int i = <int> ; for ( Entry < ? , ? > entry : map . entrySet ( ) ) { keys [ i ] = entry . getKey ( ) ; values [ i ] = entry . getValue ( ) ; i + + ; } } Object readResolve ( ) { Builder < Object , Object > builder = new Builder < Object , Object > ( keys . length ) ; return createMap ( builder ) ; } Object createMap ( Builder < Object , Object > builder ) { for ( int i = <int> ; i < keys . length ; i + + ) { builder . put ( keys [ i ] , values [ i ] ) ; } return builder . build ( ) ; } private static final long serialVersionUID = <int> ; } Object writeReplace ( ) { return new SerializedForm ( this ) ; } } 
