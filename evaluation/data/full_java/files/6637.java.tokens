package org . elasticsearch . index . query ; import org . apache . lucene . search . FuzzyQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . support . QueryParsers ; import org . elasticsearch . index . search . MatchQuery ; import org . elasticsearch . index . search . MultiMatchQuery ; import java . io . IOException ; import java . util . Locale ; import java . util . Map ; import java . util . Objects ; import java . util . TreeMap ; public class MultiMatchQueryBuilder extends AbstractQueryBuilder < MultiMatchQueryBuilder > { public static final String NAME = <str> ; public static final MultiMatchQueryBuilder . Type DEFAULT_TYPE = MultiMatchQueryBuilder . Type . BEST_FIELDS ; public static final Operator DEFAULT_OPERATOR = Operator . OR ; public static final int DEFAULT_PHRASE_SLOP = MatchQuery . DEFAULT_PHRASE_SLOP ; public static final int DEFAULT_PREFIX_LENGTH = FuzzyQuery . defaultPrefixLength ; public static final int DEFAULT_MAX_EXPANSIONS = FuzzyQuery . defaultMaxExpansions ; public static final boolean DEFAULT_LENIENCY = MatchQuery . DEFAULT_LENIENCY ; public static final MatchQuery . ZeroTermsQuery DEFAULT_ZERO_TERMS_QUERY = MatchQuery . DEFAULT_ZERO_TERMS_QUERY ; private final Object value ; private final Map < String , Float > fieldsBoosts ; private MultiMatchQueryBuilder . Type type = DEFAULT_TYPE ; private Operator operator = DEFAULT_OPERATOR ; private String analyzer ; private int slop = DEFAULT_PHRASE_SLOP ; private Fuzziness fuzziness ; private int prefixLength = DEFAULT_PREFIX_LENGTH ; private int maxExpansions = DEFAULT_MAX_EXPANSIONS ; private String minimumShouldMatch ; private String fuzzyRewrite = null ; private Boolean useDisMax ; private Float tieBreaker ; private boolean lenient = DEFAULT_LENIENCY ; private Float cutoffFrequency = null ; private MatchQuery . ZeroTermsQuery zeroTermsQuery = DEFAULT_ZERO_TERMS_QUERY ; static final MultiMatchQueryBuilder PROTOTYPE = new MultiMatchQueryBuilder ( <str> ) ; public enum Type implements Writeable < Type > { BEST_FIELDS ( MatchQuery . Type . BOOLEAN , <float> , new ParseField ( <str> , <str> ) ) , MOST_FIELDS ( MatchQuery . Type . BOOLEAN , <float> , new ParseField ( <str> ) ) , CROSS_FIELDS ( MatchQuery . Type . BOOLEAN , <float> , new ParseField ( <str> ) ) , PHRASE ( MatchQuery . Type . PHRASE , <float> , new ParseField ( <str> ) ) , PHRASE_PREFIX ( MatchQuery . Type . PHRASE_PREFIX , <float> , new ParseField ( <str> ) ) ; private static final Type PROTOTYPE = BEST_FIELDS ; private MatchQuery . Type matchQueryType ; private final float tieBreaker ; private final ParseField parseField ; Type ( MatchQuery . Type matchQueryType , float tieBreaker , ParseField parseField ) { this . matchQueryType = matchQueryType ; this . tieBreaker = tieBreaker ; this . parseField = parseField ; } public float tieBreaker ( ) { return this . tieBreaker ; } public MatchQuery . Type matchQueryType ( ) { return matchQueryType ; } public ParseField parseField ( ) { return parseField ; } public static Type parse ( String value , ParseFieldMatcher parseFieldMatcher ) { MultiMatchQueryBuilder . Type [ ] values = MultiMatchQueryBuilder . Type . values ( ) ; Type type = null ; for ( MultiMatchQueryBuilder . Type t : values ) { if ( parseFieldMatcher . match ( value , t . parseField ( ) ) ) { type = t ; break ; } } if ( type = = null ) { throw new ElasticsearchParseException ( <str> , NAME , value ) ; } return type ; } @Override public Type readFrom ( StreamInput in ) throws IOException { return Type . values ( ) [ in . readVInt ( ) ] ; } public static Type readTypeFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } } public MultiMatchQueryBuilder . Type getType ( ) { return type ; } public MultiMatchQueryBuilder ( Object value , String . . . fields ) { if ( value = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } if ( fields = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . value = value ; this . fieldsBoosts = new TreeMap < > ( ) ; for ( String field : fields ) { field ( field ) ; } } public Object value ( ) { return value ; } public MultiMatchQueryBuilder field ( String field ) { if ( Strings . isEmpty ( field ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldsBoosts . put ( field , AbstractQueryBuilder . DEFAULT_BOOST ) ; return this ; } public MultiMatchQueryBuilder field ( String field , float boost ) { if ( Strings . isEmpty ( field ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldsBoosts . put ( field , boost ) ; return this ; } public MultiMatchQueryBuilder fields ( Map < String , Float > fields ) { this . fieldsBoosts . putAll ( fields ) ; return this ; } public Map < String , Float > fields ( ) { return fieldsBoosts ; } public MultiMatchQueryBuilder type ( MultiMatchQueryBuilder . Type type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . type = type ; return this ; } public MultiMatchQueryBuilder type ( Object type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . type = Type . parse ( type . toString ( ) . toLowerCase ( Locale . ROOT ) , ParseFieldMatcher . EMPTY ) ; return this ; } public Type type ( ) { return type ; } public MultiMatchQueryBuilder operator ( Operator operator ) { if ( operator = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . operator = operator ; return this ; } public Operator operator ( ) { return operator ; } public MultiMatchQueryBuilder analyzer ( String analyzer ) { this . analyzer = analyzer ; return this ; } public String analyzer ( ) { return analyzer ; } public MultiMatchQueryBuilder slop ( int slop ) { if ( slop < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . slop = slop ; return this ; } public int slop ( ) { return slop ; } public MultiMatchQueryBuilder fuzziness ( Object fuzziness ) { if ( fuzziness ! = null ) { this . fuzziness = Fuzziness . build ( fuzziness ) ; } return this ; } public Fuzziness fuzziness ( ) { return fuzziness ; } public MultiMatchQueryBuilder prefixLength ( int prefixLength ) { if ( prefixLength < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . prefixLength = prefixLength ; return this ; } public int prefixLength ( ) { return prefixLength ; } public MultiMatchQueryBuilder maxExpansions ( int maxExpansions ) { if ( maxExpansions < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxExpansions = maxExpansions ; return this ; } public int maxExpansions ( ) { return maxExpansions ; } public MultiMatchQueryBuilder minimumShouldMatch ( String minimumShouldMatch ) { this . minimumShouldMatch = minimumShouldMatch ; return this ; } public String minimumShouldMatch ( ) { return minimumShouldMatch ; } public MultiMatchQueryBuilder fuzzyRewrite ( String fuzzyRewrite ) { this . fuzzyRewrite = fuzzyRewrite ; return this ; } public String fuzzyRewrite ( ) { return fuzzyRewrite ; } @Deprecated public MultiMatchQueryBuilder useDisMax ( Boolean useDisMax ) { this . useDisMax = useDisMax ; return this ; } public Boolean useDisMax ( ) { return useDisMax ; } public MultiMatchQueryBuilder tieBreaker ( float tieBreaker ) { this . tieBreaker = tieBreaker ; return this ; } public MultiMatchQueryBuilder tieBreaker ( Float tieBreaker ) { this . tieBreaker = tieBreaker ; return this ; } public Float tieBreaker ( ) { return tieBreaker ; } public MultiMatchQueryBuilder lenient ( boolean lenient ) { this . lenient = lenient ; return this ; } public boolean lenient ( ) { return lenient ; } public MultiMatchQueryBuilder cutoffFrequency ( float cutoff ) { this . cutoffFrequency = cutoff ; return this ; } public MultiMatchQueryBuilder cutoffFrequency ( Float cutoff ) { this . cutoffFrequency = cutoff ; return this ; } public Float cutoffFrequency ( ) { return cutoffFrequency ; } public MultiMatchQueryBuilder zeroTermsQuery ( MatchQuery . ZeroTermsQuery zeroTermsQuery ) { if ( zeroTermsQuery = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . zeroTermsQuery = zeroTermsQuery ; return this ; } public MatchQuery . ZeroTermsQuery zeroTermsQuery ( ) { return zeroTermsQuery ; } @Override public void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( MultiMatchQueryParser . QUERY_FIELD . getPreferredName ( ) , value ) ; builder . startArray ( MultiMatchQueryParser . FIELDS_FIELD . getPreferredName ( ) ) ; for ( Map . Entry < String , Float > fieldEntry : this . fieldsBoosts . entrySet ( ) ) { builder . value ( fieldEntry . getKey ( ) + <str> + fieldEntry . getValue ( ) ) ; } builder . endArray ( ) ; builder . field ( MultiMatchQueryParser . TYPE_FIELD . getPreferredName ( ) , type . toString ( ) . toLowerCase ( Locale . ENGLISH ) ) ; builder . field ( MultiMatchQueryParser . OPERATOR_FIELD . getPreferredName ( ) , operator . toString ( ) ) ; if ( analyzer ! = null ) { builder . field ( MultiMatchQueryParser . ANALYZER_FIELD . getPreferredName ( ) , analyzer ) ; } builder . field ( MultiMatchQueryParser . SLOP_FIELD . getPreferredName ( ) , slop ) ; if ( fuzziness ! = null ) { fuzziness . toXContent ( builder , params ) ; } builder . field ( MultiMatchQueryParser . PREFIX_LENGTH_FIELD . getPreferredName ( ) , prefixLength ) ; builder . field ( MultiMatchQueryParser . MAX_EXPANSIONS_FIELD . getPreferredName ( ) , maxExpansions ) ; if ( minimumShouldMatch ! = null ) { builder . field ( MultiMatchQueryParser . MINIMUM_SHOULD_MATCH_FIELD . getPreferredName ( ) , minimumShouldMatch ) ; } if ( fuzzyRewrite ! = null ) { builder . field ( MultiMatchQueryParser . FUZZY_REWRITE_FIELD . getPreferredName ( ) , fuzzyRewrite ) ; } if ( useDisMax ! = null ) { builder . field ( MultiMatchQueryParser . USE_DIS_MAX_FIELD . getPreferredName ( ) , useDisMax ) ; } if ( tieBreaker ! = null ) { builder . field ( MultiMatchQueryParser . TIE_BREAKER_FIELD . getPreferredName ( ) , tieBreaker ) ; } builder . field ( MultiMatchQueryParser . LENIENT_FIELD . getPreferredName ( ) , lenient ) ; if ( cutoffFrequency ! = null ) { builder . field ( MultiMatchQueryParser . CUTOFF_FREQUENCY_FIELD . getPreferredName ( ) , cutoffFrequency ) ; } builder . field ( MultiMatchQueryParser . ZERO_TERMS_QUERY_FIELD . getPreferredName ( ) , zeroTermsQuery . toString ( ) ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { MultiMatchQuery multiMatchQuery = new MultiMatchQuery ( context ) ; if ( analyzer ! = null ) { if ( context . getAnalysisService ( ) . analyzer ( analyzer ) = = null ) { throw new QueryShardException ( context , <str> + NAME + <str> + analyzer + <str> ) ; } multiMatchQuery . setAnalyzer ( analyzer ) ; } multiMatchQuery . setPhraseSlop ( slop ) ; if ( fuzziness ! = null ) { multiMatchQuery . setFuzziness ( fuzziness ) ; } multiMatchQuery . setFuzzyPrefixLength ( prefixLength ) ; multiMatchQuery . setMaxExpansions ( maxExpansions ) ; multiMatchQuery . setOccur ( operator . toBooleanClauseOccur ( ) ) ; if ( fuzzyRewrite ! = null ) { multiMatchQuery . setFuzzyRewriteMethod ( QueryParsers . parseRewriteMethod ( context . parseFieldMatcher ( ) , fuzzyRewrite , null ) ) ; } if ( tieBreaker ! = null ) { multiMatchQuery . setTieBreaker ( tieBreaker ) ; } if ( cutoffFrequency ! = null ) { multiMatchQuery . setCommonTermsCutoff ( cutoffFrequency ) ; } multiMatchQuery . setLenient ( lenient ) ; multiMatchQuery . setZeroTermsQuery ( zeroTermsQuery ) ; if ( useDisMax ! = null ) { boolean typeUsesDismax = type . tieBreaker ( ) ! = <float> ; if ( typeUsesDismax ! = useDisMax ) { if ( useDisMax & & tieBreaker = = null ) { multiMatchQuery . setTieBreaker ( <float> ) ; } else { multiMatchQuery . setTieBreaker ( <float> ) ; } } } Map < String , Float > newFieldsBoosts = handleFieldsMatchPattern ( context . getMapperService ( ) , fieldsBoosts ) ; Query query = multiMatchQuery . parse ( type , newFieldsBoosts , value , minimumShouldMatch ) ; if ( query = = null ) { return null ; } return query ; } private static Map < String , Float > handleFieldsMatchPattern ( MapperService mapperService , Map < String , Float > fieldsBoosts ) { Map < String , Float > newFieldsBoosts = new TreeMap < > ( ) ; for ( Map . Entry < String , Float > fieldBoost : fieldsBoosts . entrySet ( ) ) { String fField = fieldBoost . getKey ( ) ; Float fBoost = fieldBoost . getValue ( ) ; if ( Regex . isSimpleMatchPattern ( fField ) ) { for ( String field : mapperService . simpleMatchToIndexNames ( fField ) ) { newFieldsBoosts . put ( field , fBoost ) ; } } else { newFieldsBoosts . put ( fField , fBoost ) ; } } return newFieldsBoosts ; } @Override protected MultiMatchQueryBuilder doReadFrom ( StreamInput in ) throws IOException { MultiMatchQueryBuilder multiMatchQuery = new MultiMatchQueryBuilder ( in . readGenericValue ( ) ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { multiMatchQuery . fieldsBoosts . put ( in . readString ( ) , in . readFloat ( ) ) ; } multiMatchQuery . type = MultiMatchQueryBuilder . Type . readTypeFrom ( in ) ; multiMatchQuery . operator = Operator . readOperatorFrom ( in ) ; multiMatchQuery . analyzer = in . readOptionalString ( ) ; multiMatchQuery . slop = in . readVInt ( ) ; if ( in . readBoolean ( ) ) { multiMatchQuery . fuzziness = Fuzziness . readFuzzinessFrom ( in ) ; } multiMatchQuery . prefixLength = in . readVInt ( ) ; multiMatchQuery . maxExpansions = in . readVInt ( ) ; multiMatchQuery . minimumShouldMatch = in . readOptionalString ( ) ; multiMatchQuery . fuzzyRewrite = in . readOptionalString ( ) ; multiMatchQuery . useDisMax = in . readOptionalBoolean ( ) ; multiMatchQuery . tieBreaker = ( Float ) in . readGenericValue ( ) ; multiMatchQuery . lenient = in . readBoolean ( ) ; multiMatchQuery . cutoffFrequency = ( Float ) in . readGenericValue ( ) ; multiMatchQuery . zeroTermsQuery = MatchQuery . ZeroTermsQuery . readZeroTermsQueryFrom ( in ) ; return multiMatchQuery ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeGenericValue ( value ) ; out . writeVInt ( fieldsBoosts . size ( ) ) ; for ( Map . Entry < String , Float > fieldsEntry : fieldsBoosts . entrySet ( ) ) { out . writeString ( fieldsEntry . getKey ( ) ) ; out . writeFloat ( fieldsEntry . getValue ( ) ) ; } type . writeTo ( out ) ; operator . writeTo ( out ) ; out . writeOptionalString ( analyzer ) ; out . writeVInt ( slop ) ; if ( fuzziness ! = null ) { out . writeBoolean ( true ) ; fuzziness . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; } out . writeVInt ( prefixLength ) ; out . writeVInt ( maxExpansions ) ; out . writeOptionalString ( minimumShouldMatch ) ; out . writeOptionalString ( fuzzyRewrite ) ; out . writeOptionalBoolean ( useDisMax ) ; out . writeGenericValue ( tieBreaker ) ; out . writeBoolean ( lenient ) ; out . writeGenericValue ( cutoffFrequency ) ; zeroTermsQuery . writeTo ( out ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( value , fieldsBoosts , type , operator , analyzer , slop , fuzziness , prefixLength , maxExpansions , minimumShouldMatch , fuzzyRewrite , useDisMax , tieBreaker , lenient , cutoffFrequency , zeroTermsQuery ) ; } @Override protected boolean doEquals ( MultiMatchQueryBuilder other ) { return Objects . equals ( value , other . value ) & & Objects . equals ( fieldsBoosts , other . fieldsBoosts ) & & Objects . equals ( type , other . type ) & & Objects . equals ( operator , other . operator ) & & Objects . equals ( analyzer , other . analyzer ) & & Objects . equals ( slop , other . slop ) & & Objects . equals ( fuzziness , other . fuzziness ) & & Objects . equals ( prefixLength , other . prefixLength ) & & Objects . equals ( maxExpansions , other . maxExpansions ) & & Objects . equals ( minimumShouldMatch , other . minimumShouldMatch ) & & Objects . equals ( fuzzyRewrite , other . fuzzyRewrite ) & & Objects . equals ( useDisMax , other . useDisMax ) & & Objects . equals ( tieBreaker , other . tieBreaker ) & & Objects . equals ( lenient , other . lenient ) & & Objects . equals ( cutoffFrequency , other . cutoffFrequency ) & & Objects . equals ( zeroTermsQuery , other . zeroTermsQuery ) ; } } 
