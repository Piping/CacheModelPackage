package org . elasticsearch . action . termvectors ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . FieldType ; import org . apache . lucene . document . StringField ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . IndexWriterConfig ; import org . apache . lucene . index . IndexWriterConfig . OpenMode ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . store . Directory ; import org . elasticsearch . action . termvectors . TermVectorsRequest . Flag ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . InputStreamStreamInput ; import org . elasticsearch . common . io . stream . OutputStreamStreamOutput ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . core . TypeParsers ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import org . elasticsearch . rest . action . termvectors . RestTermVectorsAction ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . StreamsUtils ; import org . hamcrest . Matchers ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . Arrays ; import java . util . EnumSet ; import java . util . HashSet ; import java . util . Set ; import static org . hamcrest . Matchers . equalTo ; public class TermVectorsUnitTests extends ESTestCase { public void testStreamResponse ( ) throws Exception { TermVectorsResponse outResponse = new TermVectorsResponse ( <str> , <str> , <str> ) ; outResponse . setExists ( true ) ; writeStandardTermVector ( outResponse ) ; ByteArrayOutputStream outBuffer = new ByteArrayOutputStream ( ) ; OutputStreamStreamOutput out = new OutputStreamStreamOutput ( outBuffer ) ; outResponse . writeTo ( out ) ; ByteArrayInputStream esInBuffer = new ByteArrayInputStream ( outBuffer . toByteArray ( ) ) ; InputStreamStreamInput esBuffer = new InputStreamStreamInput ( esInBuffer ) ; TermVectorsResponse inResponse = new TermVectorsResponse ( <str> , <str> , <str> ) ; inResponse . readFrom ( esBuffer ) ; checkIfStandardTermVector ( inResponse ) ; outResponse = new TermVectorsResponse ( <str> , <str> , <str> ) ; writeEmptyTermVector ( outResponse ) ; outBuffer = new ByteArrayOutputStream ( ) ; out = new OutputStreamStreamOutput ( outBuffer ) ; outResponse . writeTo ( out ) ; esInBuffer = new ByteArrayInputStream ( outBuffer . toByteArray ( ) ) ; esBuffer = new InputStreamStreamInput ( esInBuffer ) ; inResponse = new TermVectorsResponse ( <str> , <str> , <str> ) ; inResponse . readFrom ( esBuffer ) ; assertTrue ( inResponse . isExists ( ) ) ; } private void writeEmptyTermVector ( TermVectorsResponse outResponse ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig conf = new IndexWriterConfig ( new StandardAnalyzer ( ) ) ; conf . setOpenMode ( OpenMode . CREATE ) ; IndexWriter writer = new IndexWriter ( dir , conf ) ; FieldType type = new FieldType ( TextField . TYPE_STORED ) ; type . setStoreTermVectorOffsets ( true ) ; type . setStoreTermVectorPayloads ( false ) ; type . setStoreTermVectorPositions ( true ) ; type . setStoreTermVectors ( true ) ; type . freeze ( ) ; Document d = new Document ( ) ; d . add ( new Field ( <str> , <str> , StringField . TYPE_STORED ) ) ; writer . updateDocument ( new Term ( <str> , <str> ) , d ) ; writer . commit ( ) ; writer . close ( ) ; DirectoryReader dr = DirectoryReader . open ( dir ) ; IndexSearcher s = new IndexSearcher ( dr ) ; TopDocs search = s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; int doc = scoreDocs [ <int> ] . doc ; Fields fields = dr . getTermVectors ( doc ) ; EnumSet < Flag > flags = EnumSet . of ( Flag . Positions , Flag . Offsets ) ; outResponse . setFields ( fields , null , flags , fields ) ; outResponse . setExists ( true ) ; dr . close ( ) ; dir . close ( ) ; } private void writeStandardTermVector ( TermVectorsResponse outResponse ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriterConfig conf = new IndexWriterConfig ( new StandardAnalyzer ( ) ) ; conf . setOpenMode ( OpenMode . CREATE ) ; IndexWriter writer = new IndexWriter ( dir , conf ) ; FieldType type = new FieldType ( TextField . TYPE_STORED ) ; type . setStoreTermVectorOffsets ( true ) ; type . setStoreTermVectorPayloads ( false ) ; type . setStoreTermVectorPositions ( true ) ; type . setStoreTermVectors ( true ) ; type . freeze ( ) ; Document d = new Document ( ) ; d . add ( new Field ( <str> , <str> , StringField . TYPE_STORED ) ) ; d . add ( new Field ( <str> , <str> , type ) ) ; d . add ( new Field ( <str> , <str> , type ) ) ; writer . updateDocument ( new Term ( <str> , <str> ) , d ) ; writer . commit ( ) ; writer . close ( ) ; DirectoryReader dr = DirectoryReader . open ( dir ) ; IndexSearcher s = new IndexSearcher ( dr ) ; TopDocs search = s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; int doc = scoreDocs [ <int> ] . doc ; Fields termVectors = dr . getTermVectors ( doc ) ; EnumSet < Flag > flags = EnumSet . of ( Flag . Positions , Flag . Offsets ) ; outResponse . setFields ( termVectors , null , flags , termVectors ) ; dr . close ( ) ; dir . close ( ) ; } private void checkIfStandardTermVector ( TermVectorsResponse inResponse ) throws IOException { Fields fields = inResponse . getFields ( ) ; assertThat ( fields . terms ( <str> ) , Matchers . notNullValue ( ) ) ; assertThat ( fields . terms ( <str> ) , Matchers . notNullValue ( ) ) ; assertThat ( fields . size ( ) , equalTo ( <int> ) ) ; } public void testRestRequestParsing ( ) throws Exception { BytesReference inputBytes = new BytesArray ( <str> ) ; TermVectorsRequest tvr = new TermVectorsRequest ( null , null , null ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( inputBytes ) ; TermVectorsRequest . parseRequest ( tvr , parser ) ; Set < String > fields = tvr . selectedFields ( ) ; assertThat ( fields . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( fields . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( fields . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( tvr . offsets ( ) , equalTo ( false ) ) ; assertThat ( tvr . positions ( ) , equalTo ( false ) ) ; assertThat ( tvr . payloads ( ) , equalTo ( true ) ) ; String additionalFields = <str> ; RestTermVectorsAction . addFieldStringsFromParameter ( tvr , additionalFields ) ; assertThat ( tvr . selectedFields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fields . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( fields . contains ( <str> ) , equalTo ( true ) ) ; additionalFields = <str> ; RestTermVectorsAction . addFieldStringsFromParameter ( tvr , additionalFields ) ; inputBytes = new BytesArray ( <str> ) ; tvr = new TermVectorsRequest ( null , null , null ) ; parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( inputBytes ) ; TermVectorsRequest . parseRequest ( tvr , parser ) ; additionalFields = <str> ; RestTermVectorsAction . addFieldStringsFromParameter ( tvr , additionalFields ) ; assertThat ( tvr . selectedFields ( ) , equalTo ( null ) ) ; additionalFields = <str> ; RestTermVectorsAction . addFieldStringsFromParameter ( tvr , additionalFields ) ; assertThat ( tvr . selectedFields ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testRequestParsingThrowsException ( ) throws Exception { BytesReference inputBytes = new BytesArray ( <str> ) ; TermVectorsRequest tvr = new TermVectorsRequest ( null , null , null ) ; boolean threwException = false ; try { XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( inputBytes ) ; TermVectorsRequest . parseRequest ( tvr , parser ) ; } catch ( Exception e ) { threwException = true ; } assertThat ( threwException , equalTo ( true ) ) ; } public void testStreamRequest ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { TermVectorsRequest request = new TermVectorsRequest ( <str> , <str> , <str> ) ; request . offsets ( random ( ) . nextBoolean ( ) ) ; request . fieldStatistics ( random ( ) . nextBoolean ( ) ) ; request . payloads ( random ( ) . nextBoolean ( ) ) ; request . positions ( random ( ) . nextBoolean ( ) ) ; request . termStatistics ( random ( ) . nextBoolean ( ) ) ; String parent = random ( ) . nextBoolean ( ) ? <str> : null ; request . parent ( parent ) ; String pref = random ( ) . nextBoolean ( ) ? <str> : null ; request . preference ( pref ) ; ByteArrayOutputStream outBuffer = new ByteArrayOutputStream ( ) ; OutputStreamStreamOutput out = new OutputStreamStreamOutput ( outBuffer ) ; request . writeTo ( out ) ; ByteArrayInputStream esInBuffer = new ByteArrayInputStream ( outBuffer . toByteArray ( ) ) ; InputStreamStreamInput esBuffer = new InputStreamStreamInput ( esInBuffer ) ; TermVectorsRequest req2 = new TermVectorsRequest ( null , null , null ) ; req2 . readFrom ( esBuffer ) ; assertThat ( request . offsets ( ) , equalTo ( req2 . offsets ( ) ) ) ; assertThat ( request . fieldStatistics ( ) , equalTo ( req2 . fieldStatistics ( ) ) ) ; assertThat ( request . payloads ( ) , equalTo ( req2 . payloads ( ) ) ) ; assertThat ( request . positions ( ) , equalTo ( req2 . positions ( ) ) ) ; assertThat ( request . termStatistics ( ) , equalTo ( req2 . termStatistics ( ) ) ) ; assertThat ( request . preference ( ) , equalTo ( pref ) ) ; assertThat ( request . routing ( ) , equalTo ( parent ) ) ; } } public void testFieldTypeToTermVectorString ( ) throws Exception { FieldType ft = new FieldType ( ) ; ft . setStoreTermVectorOffsets ( false ) ; ft . setStoreTermVectorPayloads ( true ) ; ft . setStoreTermVectors ( true ) ; ft . setStoreTermVectorPositions ( true ) ; String ftOpts = FieldMapper . termVectorOptionsToString ( ft ) ; assertThat ( <str> , equalTo ( ftOpts ) ) ; AllFieldMapper . Builder builder = new AllFieldMapper . Builder ( null ) ; boolean exceptiontrown = false ; try { TypeParsers . parseTermVector ( <str> , ftOpts , builder ) ; } catch ( MapperParsingException e ) { exceptiontrown = true ; } assertThat ( <str> , exceptiontrown , equalTo ( false ) ) ; } public void testTermVectorStringGenerationWithoutPositions ( ) throws Exception { FieldType ft = new FieldType ( ) ; ft . setStoreTermVectorOffsets ( true ) ; ft . setStoreTermVectorPayloads ( true ) ; ft . setStoreTermVectors ( true ) ; ft . setStoreTermVectorPositions ( false ) ; String ftOpts = FieldMapper . termVectorOptionsToString ( ft ) ; assertThat ( ftOpts , equalTo ( <str> ) ) ; } public void testMultiParser ( ) throws Exception { byte [ ] data = StreamsUtils . copyToBytesFromClasspath ( <str> ) ; BytesReference bytes = new BytesArray ( data ) ; MultiTermVectorsRequest request = new MultiTermVectorsRequest ( ) ; request . add ( new TermVectorsRequest ( ) , bytes ) ; checkParsedParameters ( request ) ; data = StreamsUtils . copyToBytesFromClasspath ( <str> ) ; bytes = new BytesArray ( data ) ; request = new MultiTermVectorsRequest ( ) ; request . add ( new TermVectorsRequest ( ) , bytes ) ; checkParsedParameters ( request ) ; } void checkParsedParameters ( MultiTermVectorsRequest request ) { Set < String > ids = new HashSet < > ( ) ; ids . add ( <str> ) ; ids . add ( <str> ) ; Set < String > fields = new HashSet < > ( ) ; fields . add ( <str> ) ; fields . add ( <str> ) ; fields . add ( <str> ) ; for ( TermVectorsRequest singleRequest : request . requests ) { assertThat ( singleRequest . index ( ) , equalTo ( <str> ) ) ; assertThat ( singleRequest . type ( ) , equalTo ( <str> ) ) ; assertThat ( singleRequest . payloads ( ) , equalTo ( false ) ) ; assertThat ( singleRequest . positions ( ) , equalTo ( false ) ) ; assertThat ( singleRequest . offsets ( ) , equalTo ( false ) ) ; assertThat ( singleRequest . termStatistics ( ) , equalTo ( true ) ) ; assertThat ( singleRequest . fieldStatistics ( ) , equalTo ( false ) ) ; assertThat ( singleRequest . id ( ) , Matchers . anyOf ( Matchers . equalTo ( <str> ) , Matchers . equalTo ( <str> ) ) ) ; assertThat ( singleRequest . selectedFields ( ) , equalTo ( fields ) ) ; } } public void testMultiParserFilter ( ) throws Exception { byte [ ] data = StreamsUtils . copyToBytesFromClasspath ( <str> ) ; BytesReference bytes = new BytesArray ( data ) ; MultiTermVectorsRequest request = new MultiTermVectorsRequest ( ) ; request . add ( new TermVectorsRequest ( ) , bytes ) ; checkParsedFilterParameters ( request ) ; } void checkParsedFilterParameters ( MultiTermVectorsRequest multiRequest ) { Set < String > ids = new HashSet < > ( Arrays . asList ( <str> , <str> ) ) ; for ( TermVectorsRequest request : multiRequest . requests ) { assertThat ( request . index ( ) , equalTo ( <str> ) ) ; assertThat ( request . type ( ) , equalTo ( <str> ) ) ; assertTrue ( ids . remove ( request . id ( ) ) ) ; assertNotNull ( request . filterSettings ( ) ) ; assertThat ( request . filterSettings ( ) . maxNumTerms , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . minTermFreq , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . maxTermFreq , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . minDocFreq , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . maxDocFreq , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . minWordLength , equalTo ( <int> ) ) ; assertThat ( request . filterSettings ( ) . maxWordLength , equalTo ( <int> ) ) ; } assertTrue ( ids . isEmpty ( ) ) ; } } 
