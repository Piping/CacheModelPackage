package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . WildcardQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . query . support . QueryParsers ; import java . io . IOException ; import java . util . Objects ; public class WildcardQueryBuilder extends AbstractQueryBuilder < WildcardQueryBuilder > implements MultiTermQueryBuilder < WildcardQueryBuilder > { public static final String NAME = <str> ; private final String fieldName ; private final String value ; private String rewrite ; static final WildcardQueryBuilder PROTOTYPE = new WildcardQueryBuilder ( <str> , <str> ) ; public WildcardQueryBuilder ( String fieldName , String value ) { if ( Strings . isEmpty ( fieldName ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( value = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldName = fieldName ; this . value = value ; } public String fieldName ( ) { return fieldName ; } public String value ( ) { return value ; } public WildcardQueryBuilder rewrite ( String rewrite ) { this . rewrite = rewrite ; return this ; } public String rewrite ( ) { return this . rewrite ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; builder . field ( WildcardQueryParser . WILDCARD_FIELD . getPreferredName ( ) , value ) ; if ( rewrite ! = null ) { builder . field ( WildcardQueryParser . REWRITE_FIELD . getPreferredName ( ) , rewrite ) ; } printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; builder . endObject ( ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { String indexFieldName ; BytesRef valueBytes ; MappedFieldType fieldType = context . fieldMapper ( fieldName ) ; if ( fieldType ! = null ) { indexFieldName = fieldType . names ( ) . indexName ( ) ; valueBytes = fieldType . indexedValueForSearch ( value ) ; } else { indexFieldName = fieldName ; valueBytes = new BytesRef ( value ) ; } WildcardQuery query = new WildcardQuery ( new Term ( indexFieldName , valueBytes ) ) ; MultiTermQuery . RewriteMethod rewriteMethod = QueryParsers . parseRewriteMethod ( context . parseFieldMatcher ( ) , rewrite , null ) ; QueryParsers . setRewriteMethod ( query , rewriteMethod ) ; return query ; } @Override protected WildcardQueryBuilder doReadFrom ( StreamInput in ) throws IOException { WildcardQueryBuilder wildcardQueryBuilder = new WildcardQueryBuilder ( in . readString ( ) , in . readString ( ) ) ; wildcardQueryBuilder . rewrite = in . readOptionalString ( ) ; return wildcardQueryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; out . writeString ( value ) ; out . writeOptionalString ( rewrite ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( fieldName , value , rewrite ) ; } @Override protected boolean doEquals ( WildcardQueryBuilder other ) { return Objects . equals ( fieldName , other . fieldName ) & & Objects . equals ( value , other . value ) & & Objects . equals ( rewrite , other . rewrite ) ; } } 
