package org . eclipse . debug . tests . viewer . model ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class StateTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public StateTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } abstract protected ITreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception , InterruptedException { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } protected IInternalTreeModelViewer getInternalViewer ( ) { return ( IInternalTreeModelViewer ) fViewer ; } public void testUpdateViewer ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; TestElement element = model . getRootElement ( ) ; TreePath path0 = TreePath . EMPTY ; ModelDelta delta = new ModelDelta ( model . getRootElement ( ) , - <int> , IModelDelta . EXPAND , element . getChildren ( ) . length ) ; ModelDelta updateDelta = delta ; element = element . getChildren ( ) [ <int> ] ; TreePath path1 = path0 . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . EXPAND , element . fChildren . length ) ; element = element . getChildren ( ) [ <int> ] ; TreePath path2 = path1 . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . EXPAND , element . fChildren . length ) ; element = element . getChildren ( ) [ <int> ] ; TreePath path3 = path2 . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . SELECT ) ; fListener . reset ( false , false ) ; fListener . addChildreUpdate ( path0 , <int> ) ; fListener . addHasChildrenUpdate ( path1 ) ; fListener . addChildreCountUpdate ( path1 ) ; fListener . addLabelUpdate ( path1 ) ; fListener . addChildreUpdate ( path1 , <int> ) ; fListener . addHasChildrenUpdate ( path2 ) ; fListener . addChildreCountUpdate ( path2 ) ; fListener . addLabelUpdate ( path2 ) ; fListener . addHasChildrenUpdate ( path2 ) ; fListener . addChildreCountUpdate ( path2 ) ; fListener . addChildreUpdate ( path2 , <int> ) ; fListener . addHasChildrenUpdate ( path3 ) ; fListener . addLabelUpdate ( path3 ) ; fViewer . updateViewer ( updateDelta ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | LABEL_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta savedDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( path0 , savedDelta , IModelDelta . EXPAND | IModelDelta . SELECT ) ; if ( ! deltaMatches ( updateDelta , savedDelta ) ) { fail ( <str> + updateDelta . toString ( ) + <str> + savedDelta ) ; } } boolean deltaMatches ( ModelDelta requested , ModelDelta received ) { if ( requested . getElement ( ) . equals ( received . getElement ( ) ) & & requested . getFlags ( ) = = received . getFlags ( ) & & ( requested . getChildCount ( ) = = - <int> | | requested . getChildCount ( ) = = received . getChildCount ( ) ) & & ( requested . getIndex ( ) = = - <int> | | requested . getIndex ( ) = = received . getIndex ( ) ) & & ( ( requested . getReplacementElement ( ) ! = null & & requested . getReplacementElement ( ) . equals ( received . getReplacementElement ( ) ) ) | | ( requested . getReplacementElement ( ) = = null & & received . getReplacementElement ( ) = = null ) ) & & requested . getChildDeltas ( ) . length = = received . getChildDeltas ( ) . length ) { for ( int i = <int> ; i < requested . getChildDeltas ( ) . length ; i + + ) { ModelDelta requestedChildDelta = ( ModelDelta ) requested . getChildDeltas ( ) [ i ] ; ModelDelta receivedChildDelta = received . getChildDelta ( requestedChildDelta . getElement ( ) ) ; if ( receivedChildDelta = = null | | ! deltaMatches ( requestedChildDelta , receivedChildDelta ) ) { return false ; } } return true ; } return false ; } static TestModel alternatingSubsreesModel ( int size ) { TestModel model = new TestModel ( ) ; TestElement [ ] elements = new TestElement [ size ] ; for ( int i = <int> ; i < size ; i + + ) { String text = Integer . toString ( i + <int> ) ; elements [ i ] = new TestElement ( model , text , new TestElement [ ] { new TestElement ( model , text + <str> , new TestElement [ ] { new TestElement ( model , text + <str> , new TestElement [ <int> ] ) } ) } ) ; } model . setRoot ( new TestElement ( model , <str> , elements ) ) ; return model ; } static boolean areTreeSelectionsEqual ( ITreeSelection sel1 , ITreeSelection sel2 ) { Set < TreePath > sel1Set = new HashSet < TreePath > ( ) ; sel1Set . addAll ( Arrays . asList ( sel1 . getPaths ( ) ) ) ; Set < TreePath > sel2Set = new HashSet < TreePath > ( ) ; sel2Set . addAll ( Arrays . asList ( sel2 . getPaths ( ) ) ) ; return sel1Set . equals ( sel2Set ) ; } static void expandAlternateElements ( TestModelUpdatesListener listener , TestModel model , boolean waitForAllUpdates ) throws InterruptedException { listener . reset ( ) ; listener . setFailOnRedundantUpdates ( false ) ; TestElement rootElement = model . getRootElement ( ) ; TestElement [ ] children = rootElement . getChildren ( ) ; ModelDelta rootDelta = new ModelDelta ( rootElement , IModelDelta . NO_CHANGE ) ; ModelDelta expandDelta = model . getBaseDelta ( rootDelta ) ; for ( int i = <int> ; i < children . length ; i + + ) { if ( i % <int> = = <int> ) { continue ; } TestElement element = children [ i ] ; ModelDelta delta = expandDelta ; int index = i ; while ( element . getChildren ( ) . length ! = <int> ) { TreePath elementPath = model . findElement ( element . getLabel ( ) ) ; listener . addUpdates ( elementPath , element , <int> , CHILD_COUNT_UPDATES | ( waitForAllUpdates ? CHILDREN_UPDATES : <int> ) ) ; delta = delta . addNode ( element , index , IModelDelta . EXPAND , element . getChildren ( ) . length ) ; element = element . getChildren ( ) [ <int> ] ; index = <int> ; } } model . postDelta ( rootDelta ) ; while ( ! listener . isFinished ( CONTENT_SEQUENCE_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! Display . getDefault ( ) . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testPreserveExpandedOnRemove ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; ModelDelta delta = model . removeElementChild ( TreePath . EMPTY , <int> ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testPreserveExpandedOnInsert ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; ModelDelta delta = model . insertElementChild ( TreePath . EMPTY , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; TreePath path = model . findElement ( <str> ) ; fListener . reset ( path , ( TestElement ) path . getLastSegment ( ) , <int> , false , false ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testPreserveExpandedOnMultLevelContent ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; TreeSelection originalSelection = new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; model . removeElementChild ( TreePath . EMPTY , <int> ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getInternalViewer ( ) , TreePath . EMPTY , model . getRootElement ( ) , - <int> , ALL_UPDATES_COMPLETE ) ; ModelDelta rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ; ModelDelta elementDelta = model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) ; elementDelta . setFlags ( IModelDelta . CONTENT ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; assertTrue ( fListener . checkCoalesced ( TreePath . EMPTY , <int> , <int> ) ) ; } public void testPreserveExpandedOnSubTreeContent ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setAutoExpandLevel ( <int> ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; model . addElementChild ( model . findElement ( <str> ) , null , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; TreePath elementPath = model . findElement ( <str> ) ; ModelDelta rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; ModelDelta elementDelta = model . getElementDelta ( rootDelta , elementPath , true ) ; elementDelta . setFlags ( IModelDelta . CONTENT ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getInternalViewer ( ) , elementPath , model . getElement ( elementPath ) , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testPreserveExpandedOnContentStress ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { model . removeElementChild ( TreePath . EMPTY , <int> ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getInternalViewer ( ) , TreePath . EMPTY , model . getRootElement ( ) , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; model . addElementChild ( TreePath . EMPTY , null , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getInternalViewer ( ) , TreePath . EMPTY , model . getRootElement ( ) , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } } public void testPreserveLargeModelOnContent ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } expandAlternateElements ( fListener , model , false ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; model . removeElementChild ( TreePath . EMPTY , <int> ) ; fListener . reset ( false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; model . addElementChild ( TreePath . EMPTY , null , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; fListener . reset ( false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testPreserveSelectionDeltaAfterContent ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setSelection ( new TreeSelection ( model . findElement ( <str> ) ) ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta selectDelta = model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . SELECT ) ; fListener . resetModelChanged ( ) ; model . postDelta ( selectDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertEquals ( new TreeSelection ( model . findElement ( <str> ) ) , fViewer . getSelection ( ) ) ; } public void testPreserveCollapseDeltaAfterContent ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta collapseDelta = model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . COLLAPSE ) ; fListener . resetModelChanged ( ) ; fListener . removeLabelUpdate ( model . findElement ( <str> ) ) ; fListener . removeLabelUpdate ( model . findElement ( <str> ) ) ; fListener . removeLabelUpdate ( model . findElement ( <str> ) ) ; fListener . removeHasChildrenUpdate ( model . findElement ( <str> ) ) ; fListener . removeHasChildrenUpdate ( model . findElement ( <str> ) ) ; fListener . removeHasChildrenUpdate ( model . findElement ( <str> ) ) ; fListener . removeChildreCountUpdate ( model . findElement ( <str> ) ) ; fListener . removeChildrenUpdate ( model . findElement ( <str> ) , <int> ) ; fListener . removeChildrenUpdate ( model . findElement ( <str> ) , <int> ) ; fListener . removeChildrenUpdate ( model . findElement ( <str> ) , <int> ) ; model . postDelta ( collapseDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; } public void testPreserveExpandDeltaAfterContent ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta expandDelta = model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . EXPAND ) ; fListener . resetModelChanged ( ) ; model . postDelta ( expandDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; } public void testSaveAndRestore1 ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; fViewer . setSelection ( new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( false , false ) ; fListener . addStateUpdates ( getInternalViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta restoredState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , restoredState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; if ( ! deltaMatches ( originalState , restoredState ) ) { fail ( <str> + originalState . toString ( ) + <str> + restoredState ) ; } } public void testSaveAndRestore2 ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; fViewer . setSelection ( new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ) ; fViewer . setSelection ( new TreeSelection ( model . findElement ( <str> ) ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( true , false ) ; fListener . addStateUpdates ( getInternalViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta restoredState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , restoredState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; if ( ! deltaMatches ( originalState , restoredState ) ) { fail ( <str> + originalState . toString ( ) + <str> + restoredState ) ; } } public void testSaveAndRestoreInputInstance ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; fViewer . setSelection ( new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta restoredState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , restoredState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; if ( ! deltaMatches ( originalState , restoredState ) ) { fail ( <str> + originalState . toString ( ) + <str> + restoredState ) ; } } public void testSaveAndRestoreInputInstanceEquals ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; expandAlternateElements ( fListener , model , true ) ; fViewer . setSelection ( new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; TestElement newRoot = new TestElement ( model , model . getRootElement ( ) . getID ( ) , model . getRootElement ( ) . getChildren ( ) ) ; model . setRoot ( newRoot ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta restoredState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , restoredState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; if ( ! deltaMatches ( originalState , restoredState ) ) { fail ( <str> + originalState . toString ( ) + <str> + restoredState ) ; } } public void testSaveAndRestoreLarge ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } expandAlternateElements ( fListener , model , false ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( ) ; fListener . addStateUpdates ( getInternalViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testSaveAndRestorePartialStateLarge ( ) throws InterruptedException { TestModel model = alternatingSubsreesModel ( <int> ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } expandAlternateElements ( fListener , model , false ) ; TreeSelection originalSelection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( ) ; fListener . addStateUpdates ( getInternalViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestElement [ ] elements = model . getRootElement ( ) . getChildren ( ) ; TestElement [ ] newElements = new TestElement [ <int> ] ; System . arraycopy ( elements , <int> , newElements , <int> , newElements . length ) ; model . setElementChildren ( TreePath . EMPTY , newElements ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } public void testPreserveCollapseAndSelectDeltaAfterSaveAndRestore ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setSelection ( new TreeSelection ( model . findElement ( <str> ) ) ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( false , false ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; TreePath path = model . findElement ( <str> ) ; fListener . addUpdates ( null , path , ( TestElement ) path . getLastSegment ( ) , <int> , STATE_UPDATES ) ; path = model . findElement ( <str> ) ; fListener . addUpdates ( null , path , ( TestElement ) path . getLastSegment ( ) , <int> , STATE_UPDATES ) ; while ( ! fListener . isFinished ( STATE_RESTORE_STARTED | STATE_UPDATES | CHILDREN_UPDATES | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . resetModelChanged ( ) ; model . postDelta ( model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . COLLAPSE ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . resetModelChanged ( ) ; model . postDelta ( model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . COLLAPSE ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . postDelta ( model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . SELECT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } while ( ! fListener . isFinished ( STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertEquals ( new TreeSelection ( model . findElement ( <str> ) ) , fViewer . getSelection ( ) ) ; } public void testSaveRestoreOrder ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; model . setDelayUpdates ( true ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; TestModel copyModel = TestModel . simpleMultiLevel ( ) ; fListener . reset ( ) ; fListener . expectRestoreAfterSaveComplete ( ) ; fViewer . setInput ( copyModel . getRootElement ( ) ) ; while ( ! fListener . isFinished ( STATE_RESTORE_STARTED ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( <str> , fListener . isFinished ( STATE_SAVE_COMPLETE ) ) ; } public void testUpdateWithNullInput ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; ModelDelta expandedState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , expandedState , IModelDelta . EXPAND ) ; fListener . reset ( ) ; fListener . addChildreCountUpdate ( TreePath . EMPTY ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fViewer . setInput ( null ) ; fViewer . updateViewer ( expandedState ) ; while ( ! fListener . isFinished ( CONTENT_COMPLETE | VIEWER_UPDATES_RUNNING ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } } 
