package org . jbox2d . collision ; import org . jbox2d . collision . Distance . SimplexCache ; import org . jbox2d . collision . Manifold . ManifoldType ; import org . jbox2d . collision . shapes . CircleShape ; import org . jbox2d . collision . shapes . EdgeShape ; import org . jbox2d . collision . shapes . PolygonShape ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . pooling . IWorldPool ; public class Collision { public static final int NULL_FEATURE = Integer . MAX_VALUE ; private final IWorldPool pool ; public Collision ( IWorldPool argPool ) { incidentEdge [ <int> ] = new ClipVertex ( ) ; incidentEdge [ <int> ] = new ClipVertex ( ) ; clipPoints1 [ <int> ] = new ClipVertex ( ) ; clipPoints1 [ <int> ] = new ClipVertex ( ) ; clipPoints2 [ <int> ] = new ClipVertex ( ) ; clipPoints2 [ <int> ] = new ClipVertex ( ) ; pool = argPool ; } private final DistanceInput input = new DistanceInput ( ) ; private final SimplexCache cache = new SimplexCache ( ) ; private final DistanceOutput output = new DistanceOutput ( ) ; public final boolean testOverlap ( Shape shapeA , int indexA , Shape shapeB , int indexB , Transform xfA , Transform xfB ) { input . proxyA . set ( shapeA , indexA ) ; input . proxyB . set ( shapeB , indexB ) ; input . transformA . set ( xfA ) ; input . transformB . set ( xfB ) ; input . useRadii = true ; cache . count = <int> ; pool . getDistance ( ) . distance ( output , cache , input ) ; return output . distance < <float> * Settings . EPSILON ; } public static final void getPointStates ( final PointState [ ] state1 , final PointState [ ] state2 , final Manifold manifold1 , final Manifold manifold2 ) { for ( int i = <int> ; i < Settings . maxManifoldPoints ; i + + ) { state1 [ i ] = PointState . NULL_STATE ; state2 [ i ] = PointState . NULL_STATE ; } for ( int i = <int> ; i < manifold1 . pointCount ; i + + ) { ContactID id = manifold1 . points [ i ] . id ; state1 [ i ] = PointState . REMOVE_STATE ; for ( int j = <int> ; j < manifold2 . pointCount ; j + + ) { if ( manifold2 . points [ j ] . id . isEqual ( id ) ) { state1 [ i ] = PointState . PERSIST_STATE ; break ; } } } for ( int i = <int> ; i < manifold2 . pointCount ; i + + ) { ContactID id = manifold2 . points [ i ] . id ; state2 [ i ] = PointState . ADD_STATE ; for ( int j = <int> ; j < manifold1 . pointCount ; j + + ) { if ( manifold1 . points [ j ] . id . isEqual ( id ) ) { state2 [ i ] = PointState . PERSIST_STATE ; break ; } } } } public static final int clipSegmentToLine ( final ClipVertex [ ] vOut , final ClipVertex [ ] vIn , final Vec2 normal , float offset , int vertexIndexA ) { int numOut = <int> ; final ClipVertex vIn0 = vIn [ <int> ] ; final ClipVertex vIn1 = vIn [ <int> ] ; final Vec2 vIn0v = vIn0 . v ; final Vec2 vIn1v = vIn1 . v ; float distance0 = Vec2 . dot ( normal , vIn0v ) - offset ; float distance1 = Vec2 . dot ( normal , vIn1v ) - offset ; if ( distance0 < = <float> ) { vOut [ numOut + + ] . set ( vIn0 ) ; } if ( distance1 < = <float> ) { vOut [ numOut + + ] . set ( vIn1 ) ; } if ( distance0 * distance1 < <float> ) { float interp = distance0 / ( distance0 - distance1 ) ; ClipVertex vOutNO = vOut [ numOut ] ; vOutNO . v . x = vIn0v . x + interp * ( vIn1v . x - vIn0v . x ) ; vOutNO . v . y = vIn0v . y + interp * ( vIn1v . y - vIn0v . y ) ; vOutNO . id . indexA = ( byte ) vertexIndexA ; vOutNO . id . indexB = vIn0 . id . indexB ; vOutNO . id . typeA = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; vOutNO . id . typeB = ( byte ) ContactID . Type . FACE . ordinal ( ) ; + + numOut ; } return numOut ; } private static Vec2 d = new Vec2 ( ) ; public final void collideCircles ( Manifold manifold , final CircleShape circle1 , final Transform xfA , final CircleShape circle2 , final Transform xfB ) { manifold . pointCount = <int> ; Vec2 circle1p = circle1 . m_p ; Vec2 circle2p = circle2 . m_p ; float pAx = ( xfA . q . c * circle1p . x - xfA . q . s * circle1p . y ) + xfA . p . x ; float pAy = ( xfA . q . s * circle1p . x + xfA . q . c * circle1p . y ) + xfA . p . y ; float pBx = ( xfB . q . c * circle2p . x - xfB . q . s * circle2p . y ) + xfB . p . x ; float pBy = ( xfB . q . s * circle2p . x + xfB . q . c * circle2p . y ) + xfB . p . y ; float dx = pBx - pAx ; float dy = pBy - pAy ; float distSqr = dx * dx + dy * dy ; final float radius = circle1 . m_radius + circle2 . m_radius ; if ( distSqr > radius * radius ) { return ; } manifold . type = ManifoldType . CIRCLES ; manifold . localPoint . set ( circle1p ) ; manifold . localNormal . setZero ( ) ; manifold . pointCount = <int> ; manifold . points [ <int> ] . localPoint . set ( circle2p ) ; manifold . points [ <int> ] . id . zero ( ) ; } public final void collidePolygonAndCircle ( Manifold manifold , final PolygonShape polygon , final Transform xfA , final CircleShape circle , final Transform xfB ) { manifold . pointCount = <int> ; final Vec2 circlep = circle . m_p ; final Rot xfBq = xfB . q ; final Rot xfAq = xfA . q ; final float cx = ( xfBq . c * circlep . x - xfBq . s * circlep . y ) + xfB . p . x ; final float cy = ( xfBq . s * circlep . x + xfBq . c * circlep . y ) + xfB . p . y ; final float px = cx - xfA . p . x ; final float py = cy - xfA . p . y ; final float cLocalx = ( xfAq . c * px + xfAq . s * py ) ; final float cLocaly = ( - xfAq . s * px + xfAq . c * py ) ; int normalIndex = <int> ; float separation = - Float . MAX_VALUE ; final float radius = polygon . m_radius + circle . m_radius ; final int vertexCount = polygon . m_count ; float s ; final Vec2 [ ] vertices = polygon . m_vertices ; final Vec2 [ ] normals = polygon . m_normals ; for ( int i = <int> ; i < vertexCount ; i + + ) { final Vec2 vertex = vertices [ i ] ; final float tempx = cLocalx - vertex . x ; final float tempy = cLocaly - vertex . y ; s = normals [ i ] . x * tempx + normals [ i ] . y * tempy ; if ( s > radius ) { return ; } if ( s > separation ) { separation = s ; normalIndex = i ; } } final int vertIndex1 = normalIndex ; final int vertIndex2 = vertIndex1 + <int> < vertexCount ? vertIndex1 + <int> : <int> ; final Vec2 v1 = vertices [ vertIndex1 ] ; final Vec2 v2 = vertices [ vertIndex2 ] ; if ( separation < Settings . EPSILON ) { manifold . pointCount = <int> ; manifold . type = ManifoldType . FACE_A ; final Vec2 normal = normals [ normalIndex ] ; manifold . localNormal . x = normal . x ; manifold . localNormal . y = normal . y ; manifold . localPoint . x = ( v1 . x + v2 . x ) * <float> ; manifold . localPoint . y = ( v1 . y + v2 . y ) * <float> ; final ManifoldPoint mpoint = manifold . points [ <int> ] ; mpoint . localPoint . x = circlep . x ; mpoint . localPoint . y = circlep . y ; mpoint . id . zero ( ) ; return ; } final float tempX = cLocalx - v1 . x ; final float tempY = cLocaly - v1 . y ; final float temp2X = v2 . x - v1 . x ; final float temp2Y = v2 . y - v1 . y ; final float u1 = tempX * temp2X + tempY * temp2Y ; final float temp3X = cLocalx - v2 . x ; final float temp3Y = cLocaly - v2 . y ; final float temp4X = v1 . x - v2 . x ; final float temp4Y = v1 . y - v2 . y ; final float u2 = temp3X * temp4X + temp3Y * temp4Y ; if ( u1 < = <float> ) { final float dx = cLocalx - v1 . x ; final float dy = cLocaly - v1 . y ; if ( dx * dx + dy * dy > radius * radius ) { return ; } manifold . pointCount = <int> ; manifold . type = ManifoldType . FACE_A ; manifold . localNormal . x = cLocalx - v1 . x ; manifold . localNormal . y = cLocaly - v1 . y ; manifold . localNormal . normalize ( ) ; manifold . localPoint . set ( v1 ) ; manifold . points [ <int> ] . localPoint . set ( circlep ) ; manifold . points [ <int> ] . id . zero ( ) ; } else if ( u2 < = <float> ) { final float dx = cLocalx - v2 . x ; final float dy = cLocaly - v2 . y ; if ( dx * dx + dy * dy > radius * radius ) { return ; } manifold . pointCount = <int> ; manifold . type = ManifoldType . FACE_A ; manifold . localNormal . x = cLocalx - v2 . x ; manifold . localNormal . y = cLocaly - v2 . y ; manifold . localNormal . normalize ( ) ; manifold . localPoint . set ( v2 ) ; manifold . points [ <int> ] . localPoint . set ( circlep ) ; manifold . points [ <int> ] . id . zero ( ) ; } else { final float fcx = ( v1 . x + v2 . x ) * <float> ; final float fcy = ( v1 . y + v2 . y ) * <float> ; final float tx = cLocalx - fcx ; final float ty = cLocaly - fcy ; final Vec2 normal = normals [ vertIndex1 ] ; separation = tx * normal . x + ty * normal . y ; if ( separation > radius ) { return ; } manifold . pointCount = <int> ; manifold . type = ManifoldType . FACE_A ; manifold . localNormal . set ( normals [ vertIndex1 ] ) ; manifold . localPoint . x = fcx ; manifold . localPoint . y = fcy ; manifold . points [ <int> ] . localPoint . set ( circlep ) ; manifold . points [ <int> ] . id . zero ( ) ; } } private final Vec2 temp = new Vec2 ( ) ; private final Transform xf = new Transform ( ) ; private final Vec2 n = new Vec2 ( ) ; private final Vec2 v1 = new Vec2 ( ) ; public final void findMaxSeparation ( EdgeResults results , final PolygonShape poly1 , final Transform xf1 , final PolygonShape poly2 , final Transform xf2 ) { int count1 = poly1 . m_count ; int count2 = poly2 . m_count ; Vec2 [ ] n1s = poly1 . m_normals ; Vec2 [ ] v1s = poly1 . m_vertices ; Vec2 [ ] v2s = poly2 . m_vertices ; Transform . mulTransToOutUnsafe ( xf2 , xf1 , xf ) ; final Rot xfq = xf . q ; int bestIndex = <int> ; float maxSeparation = - Float . MAX_VALUE ; for ( int i = <int> ; i < count1 ; i + + ) { Rot . mulToOutUnsafe ( xfq , n1s [ i ] , n ) ; Transform . mulToOutUnsafe ( xf , v1s [ i ] , v1 ) ; float si = Float . MAX_VALUE ; for ( int j = <int> ; j < count2 ; + + j ) { Vec2 v2sj = v2s [ j ] ; float sij = n . x * ( v2sj . x - v1 . x ) + n . y * ( v2sj . y - v1 . y ) ; if ( sij < si ) { si = sij ; } } if ( si > maxSeparation ) { maxSeparation = si ; bestIndex = i ; } } results . edgeIndex = bestIndex ; results . separation = maxSeparation ; } public final void findIncidentEdge ( final ClipVertex [ ] c , final PolygonShape poly1 , final Transform xf1 , int edge1 , final PolygonShape poly2 , final Transform xf2 ) { int count1 = poly1 . m_count ; final Vec2 [ ] normals1 = poly1 . m_normals ; int count2 = poly2 . m_count ; final Vec2 [ ] vertices2 = poly2 . m_vertices ; final Vec2 [ ] normals2 = poly2 . m_normals ; assert ( <int> < = edge1 & & edge1 < count1 ) ; final ClipVertex c0 = c [ <int> ] ; final ClipVertex c1 = c [ <int> ] ; final Rot xf1q = xf1 . q ; final Rot xf2q = xf2 . q ; final Vec2 v = normals1 [ edge1 ] ; final float tempx = xf1q . c * v . x - xf1q . s * v . y ; final float tempy = xf1q . s * v . x + xf1q . c * v . y ; final float normal1x = xf2q . c * tempx + xf2q . s * tempy ; final float normal1y = - xf2q . s * tempx + xf2q . c * tempy ; int index = <int> ; float minDot = Float . MAX_VALUE ; for ( int i = <int> ; i < count2 ; + + i ) { Vec2 b = normals2 [ i ] ; float dot = normal1x * b . x + normal1y * b . y ; if ( dot < minDot ) { minDot = dot ; index = i ; } } int i1 = index ; int i2 = i1 + <int> < count2 ? i1 + <int> : <int> ; Vec2 v1 = vertices2 [ i1 ] ; Vec2 out = c0 . v ; out . x = ( xf2q . c * v1 . x - xf2q . s * v1 . y ) + xf2 . p . x ; out . y = ( xf2q . s * v1 . x + xf2q . c * v1 . y ) + xf2 . p . y ; c0 . id . indexA = ( byte ) edge1 ; c0 . id . indexB = ( byte ) i1 ; c0 . id . typeA = ( byte ) ContactID . Type . FACE . ordinal ( ) ; c0 . id . typeB = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; Vec2 v2 = vertices2 [ i2 ] ; Vec2 out1 = c1 . v ; out1 . x = ( xf2q . c * v2 . x - xf2q . s * v2 . y ) + xf2 . p . x ; out1 . y = ( xf2q . s * v2 . x + xf2q . c * v2 . y ) + xf2 . p . y ; c1 . id . indexA = ( byte ) edge1 ; c1 . id . indexB = ( byte ) i2 ; c1 . id . typeA = ( byte ) ContactID . Type . FACE . ordinal ( ) ; c1 . id . typeB = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; } private final EdgeResults results1 = new EdgeResults ( ) ; private final EdgeResults results2 = new EdgeResults ( ) ; private final ClipVertex [ ] incidentEdge = new ClipVertex [ <int> ] ; private final Vec2 localTangent = new Vec2 ( ) ; private final Vec2 localNormal = new Vec2 ( ) ; private final Vec2 planePoint = new Vec2 ( ) ; private final Vec2 tangent = new Vec2 ( ) ; private final Vec2 v11 = new Vec2 ( ) ; private final Vec2 v12 = new Vec2 ( ) ; private final ClipVertex [ ] clipPoints1 = new ClipVertex [ <int> ] ; private final ClipVertex [ ] clipPoints2 = new ClipVertex [ <int> ] ; public final void collidePolygons ( Manifold manifold , final PolygonShape polyA , final Transform xfA , final PolygonShape polyB , final Transform xfB ) { manifold . pointCount = <int> ; float totalRadius = polyA . m_radius + polyB . m_radius ; findMaxSeparation ( results1 , polyA , xfA , polyB , xfB ) ; if ( results1 . separation > totalRadius ) { return ; } findMaxSeparation ( results2 , polyB , xfB , polyA , xfA ) ; if ( results2 . separation > totalRadius ) { return ; } final PolygonShape poly1 ; final PolygonShape poly2 ; Transform xf1 , xf2 ; int edge1 ; boolean flip ; final float k_tol = <float> * Settings . linearSlop ; if ( results2 . separation > results1 . separation + k_tol ) { poly1 = polyB ; poly2 = polyA ; xf1 = xfB ; xf2 = xfA ; edge1 = results2 . edgeIndex ; manifold . type = ManifoldType . FACE_B ; flip = true ; } else { poly1 = polyA ; poly2 = polyB ; xf1 = xfA ; xf2 = xfB ; edge1 = results1 . edgeIndex ; manifold . type = ManifoldType . FACE_A ; flip = false ; } final Rot xf1q = xf1 . q ; findIncidentEdge ( incidentEdge , poly1 , xf1 , edge1 , poly2 , xf2 ) ; int count1 = poly1 . m_count ; final Vec2 [ ] vertices1 = poly1 . m_vertices ; final int iv1 = edge1 ; final int iv2 = edge1 + <int> < count1 ? edge1 + <int> : <int> ; v11 . set ( vertices1 [ iv1 ] ) ; v12 . set ( vertices1 [ iv2 ] ) ; localTangent . x = v12 . x - v11 . x ; localTangent . y = v12 . y - v11 . y ; localTangent . normalize ( ) ; localNormal . x = <float> * localTangent . y ; localNormal . y = - <float> * localTangent . x ; planePoint . x = ( v11 . x + v12 . x ) * <float> ; planePoint . y = ( v11 . y + v12 . y ) * <float> ; tangent . x = xf1q . c * localTangent . x - xf1q . s * localTangent . y ; tangent . y = xf1q . s * localTangent . x + xf1q . c * localTangent . y ; final float normalx = <float> * tangent . y ; final float normaly = - <float> * tangent . x ; Transform . mulToOut ( xf1 , v11 , v11 ) ; Transform . mulToOut ( xf1 , v12 , v12 ) ; float frontOffset = normalx * v11 . x + normaly * v11 . y ; float sideOffset1 = - ( tangent . x * v11 . x + tangent . y * v11 . y ) + totalRadius ; float sideOffset2 = tangent . x * v12 . x + tangent . y * v12 . y + totalRadius ; int np ; tangent . negateLocal ( ) ; np = clipSegmentToLine ( clipPoints1 , incidentEdge , tangent , sideOffset1 , iv1 ) ; tangent . negateLocal ( ) ; if ( np < <int> ) { return ; } np = clipSegmentToLine ( clipPoints2 , clipPoints1 , tangent , sideOffset2 , iv2 ) ; if ( np < <int> ) { return ; } manifold . localNormal . set ( localNormal ) ; manifold . localPoint . set ( planePoint ) ; int pointCount = <int> ; for ( int i = <int> ; i < Settings . maxManifoldPoints ; + + i ) { float separation = normalx * clipPoints2 [ i ] . v . x + normaly * clipPoints2 [ i ] . v . y - frontOffset ; if ( separation < = totalRadius ) { ManifoldPoint cp = manifold . points [ pointCount ] ; Vec2 out = cp . localPoint ; final float px = clipPoints2 [ i ] . v . x - xf2 . p . x ; final float py = clipPoints2 [ i ] . v . y - xf2 . p . y ; out . x = ( xf2 . q . c * px + xf2 . q . s * py ) ; out . y = ( - xf2 . q . s * px + xf2 . q . c * py ) ; cp . id . set ( clipPoints2 [ i ] . id ) ; if ( flip ) { cp . id . flip ( ) ; } + + pointCount ; } } manifold . pointCount = pointCount ; } private final Vec2 Q = new Vec2 ( ) ; private final Vec2 e = new Vec2 ( ) ; private final ContactID cf = new ContactID ( ) ; private final Vec2 e1 = new Vec2 ( ) ; private final Vec2 P = new Vec2 ( ) ; public void collideEdgeAndCircle ( Manifold manifold , final EdgeShape edgeA , final Transform xfA , final CircleShape circleB , final Transform xfB ) { manifold . pointCount = <int> ; Transform . mulToOutUnsafe ( xfB , circleB . m_p , temp ) ; Transform . mulTransToOutUnsafe ( xfA , temp , Q ) ; final Vec2 A = edgeA . m_vertex1 ; final Vec2 B = edgeA . m_vertex2 ; e . set ( B ) . subLocal ( A ) ; float u = Vec2 . dot ( e , temp . set ( B ) . subLocal ( Q ) ) ; float v = Vec2 . dot ( e , temp . set ( Q ) . subLocal ( A ) ) ; float radius = edgeA . m_radius + circleB . m_radius ; cf . indexB = <int> ; cf . typeB = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; if ( v < = <float> ) { final Vec2 P = A ; d . set ( Q ) . subLocal ( P ) ; float dd = Vec2 . dot ( d , d ) ; if ( dd > radius * radius ) { return ; } if ( edgeA . m_hasVertex0 ) { final Vec2 A1 = edgeA . m_vertex0 ; final Vec2 B1 = A ; e1 . set ( B1 ) . subLocal ( A1 ) ; float u1 = Vec2 . dot ( e1 , temp . set ( B1 ) . subLocal ( Q ) ) ; if ( u1 > <float> ) { return ; } } cf . indexA = <int> ; cf . typeA = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; manifold . pointCount = <int> ; manifold . type = Manifold . ManifoldType . CIRCLES ; manifold . localNormal . setZero ( ) ; manifold . localPoint . set ( P ) ; manifold . points [ <int> ] . id . set ( cf ) ; manifold . points [ <int> ] . localPoint . set ( circleB . m_p ) ; return ; } if ( u < = <float> ) { Vec2 P = B ; d . set ( Q ) . subLocal ( P ) ; float dd = Vec2 . dot ( d , d ) ; if ( dd > radius * radius ) { return ; } if ( edgeA . m_hasVertex3 ) { final Vec2 B2 = edgeA . m_vertex3 ; final Vec2 A2 = B ; final Vec2 e2 = e1 ; e2 . set ( B2 ) . subLocal ( A2 ) ; float v2 = Vec2 . dot ( e2 , temp . set ( Q ) . subLocal ( A2 ) ) ; if ( v2 > <float> ) { return ; } } cf . indexA = <int> ; cf . typeA = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; manifold . pointCount = <int> ; manifold . type = Manifold . ManifoldType . CIRCLES ; manifold . localNormal . setZero ( ) ; manifold . localPoint . set ( P ) ; manifold . points [ <int> ] . id . set ( cf ) ; manifold . points [ <int> ] . localPoint . set ( circleB . m_p ) ; return ; } float den = Vec2 . dot ( e , e ) ; assert ( den > <float> ) ; P . set ( A ) . mulLocal ( u ) . addLocal ( temp . set ( B ) . mulLocal ( v ) ) ; P . mulLocal ( <float> / den ) ; d . set ( Q ) . subLocal ( P ) ; float dd = Vec2 . dot ( d , d ) ; if ( dd > radius * radius ) { return ; } n . x = - e . y ; n . y = e . x ; if ( Vec2 . dot ( n , temp . set ( Q ) . subLocal ( A ) ) < <float> ) { n . set ( - n . x , - n . y ) ; } n . normalize ( ) ; cf . indexA = <int> ; cf . typeA = ( byte ) ContactID . Type . FACE . ordinal ( ) ; manifold . pointCount = <int> ; manifold . type = Manifold . ManifoldType . FACE_A ; manifold . localNormal . set ( n ) ; manifold . localPoint . set ( A ) ; manifold . points [ <int> ] . id . set ( cf ) ; manifold . points [ <int> ] . localPoint . set ( circleB . m_p ) ; } private final EPCollider collider = new EPCollider ( ) ; public void collideEdgeAndPolygon ( Manifold manifold , final EdgeShape edgeA , final Transform xfA , final PolygonShape polygonB , final Transform xfB ) { collider . collide ( manifold , edgeA , xfA , polygonB , xfB ) ; } private static class EdgeResults { public float separation ; public int edgeIndex ; } public static class ClipVertex { public final Vec2 v ; public final ContactID id ; public ClipVertex ( ) { v = new Vec2 ( ) ; id = new ContactID ( ) ; } public void set ( final ClipVertex cv ) { Vec2 v1 = cv . v ; v . x = v1 . x ; v . y = v1 . y ; ContactID c = cv . id ; id . indexA = c . indexA ; id . indexB = c . indexB ; id . typeA = c . typeA ; id . typeB = c . typeB ; } } public static enum PointState { NULL_STATE , ADD_STATE , PERSIST_STATE , REMOVE_STATE } static class EPAxis { enum Type { UNKNOWN , EDGE_A , EDGE_B } Type type ; int index ; float separation ; } static class TempPolygon { final Vec2 [ ] vertices = new Vec2 [ Settings . maxPolygonVertices ] ; final Vec2 [ ] normals = new Vec2 [ Settings . maxPolygonVertices ] ; int count ; public TempPolygon ( ) { for ( int i = <int> ; i < vertices . length ; i + + ) { vertices [ i ] = new Vec2 ( ) ; normals [ i ] = new Vec2 ( ) ; } } } static class ReferenceFace { int i1 , i2 ; final Vec2 v1 = new Vec2 ( ) ; final Vec2 v2 = new Vec2 ( ) ; final Vec2 normal = new Vec2 ( ) ; final Vec2 sideNormal1 = new Vec2 ( ) ; float sideOffset1 ; final Vec2 sideNormal2 = new Vec2 ( ) ; float sideOffset2 ; } static class EPCollider { enum VertexType { ISOLATED , CONCAVE , CONVEX } final TempPolygon m_polygonB = new TempPolygon ( ) ; final Transform m_xf = new Transform ( ) ; final Vec2 m_centroidB = new Vec2 ( ) ; Vec2 m_v0 = new Vec2 ( ) ; Vec2 m_v1 = new Vec2 ( ) ; Vec2 m_v2 = new Vec2 ( ) ; Vec2 m_v3 = new Vec2 ( ) ; final Vec2 m_normal0 = new Vec2 ( ) ; final Vec2 m_normal1 = new Vec2 ( ) ; final Vec2 m_normal2 = new Vec2 ( ) ; final Vec2 m_normal = new Vec2 ( ) ; VertexType m_type1 , m_type2 ; final Vec2 m_lowerLimit = new Vec2 ( ) ; final Vec2 m_upperLimit = new Vec2 ( ) ; float m_radius ; boolean m_front ; public EPCollider ( ) { for ( int i = <int> ; i < <int> ; i + + ) { ie [ i ] = new ClipVertex ( ) ; clipPoints1 [ i ] = new ClipVertex ( ) ; clipPoints2 [ i ] = new ClipVertex ( ) ; } } private final Vec2 edge1 = new Vec2 ( ) ; private final Vec2 temp = new Vec2 ( ) ; private final Vec2 edge0 = new Vec2 ( ) ; private final Vec2 edge2 = new Vec2 ( ) ; private final ClipVertex [ ] ie = new ClipVertex [ <int> ] ; private final ClipVertex [ ] clipPoints1 = new ClipVertex [ <int> ] ; private final ClipVertex [ ] clipPoints2 = new ClipVertex [ <int> ] ; private final ReferenceFace rf = new ReferenceFace ( ) ; private final EPAxis edgeAxis = new EPAxis ( ) ; private final EPAxis polygonAxis = new EPAxis ( ) ; public void collide ( Manifold manifold , final EdgeShape edgeA , final Transform xfA , final PolygonShape polygonB , final Transform xfB ) { Transform . mulTransToOutUnsafe ( xfA , xfB , m_xf ) ; Transform . mulToOutUnsafe ( m_xf , polygonB . m_centroid , m_centroidB ) ; m_v0 = edgeA . m_vertex0 ; m_v1 = edgeA . m_vertex1 ; m_v2 = edgeA . m_vertex2 ; m_v3 = edgeA . m_vertex3 ; boolean hasVertex0 = edgeA . m_hasVertex0 ; boolean hasVertex3 = edgeA . m_hasVertex3 ; edge1 . set ( m_v2 ) . subLocal ( m_v1 ) ; edge1 . normalize ( ) ; m_normal1 . set ( edge1 . y , - edge1 . x ) ; float offset1 = Vec2 . dot ( m_normal1 , temp . set ( m_centroidB ) . subLocal ( m_v1 ) ) ; float offset0 = <float> , offset2 = <float> ; boolean convex1 = false , convex2 = false ; if ( hasVertex0 ) { edge0 . set ( m_v1 ) . subLocal ( m_v0 ) ; edge0 . normalize ( ) ; m_normal0 . set ( edge0 . y , - edge0 . x ) ; convex1 = Vec2 . cross ( edge0 , edge1 ) > = <float> ; offset0 = Vec2 . dot ( m_normal0 , temp . set ( m_centroidB ) . subLocal ( m_v0 ) ) ; } if ( hasVertex3 ) { edge2 . set ( m_v3 ) . subLocal ( m_v2 ) ; edge2 . normalize ( ) ; m_normal2 . set ( edge2 . y , - edge2 . x ) ; convex2 = Vec2 . cross ( edge1 , edge2 ) > <float> ; offset2 = Vec2 . dot ( m_normal2 , temp . set ( m_centroidB ) . subLocal ( m_v2 ) ) ; } if ( hasVertex0 & & hasVertex3 ) { if ( convex1 & & convex2 ) { m_front = offset0 > = <float> | | offset1 > = <float> | | offset2 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal0 . x ; m_lowerLimit . y = m_normal0 . y ; m_upperLimit . x = m_normal2 . x ; m_upperLimit . y = m_normal2 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } } else if ( convex1 ) { m_front = offset0 > = <float> | | ( offset1 > = <float> & & offset2 > = <float> ) ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal0 . x ; m_lowerLimit . y = m_normal0 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal2 . x ; m_lowerLimit . y = - m_normal2 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } } else if ( convex2 ) { m_front = offset2 > = <float> | | ( offset0 > = <float> & & offset1 > = <float> ) ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = m_normal2 . x ; m_upperLimit . y = m_normal2 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = - m_normal0 . x ; m_upperLimit . y = - m_normal0 . y ; } } else { m_front = offset0 > = <float> & & offset1 > = <float> & & offset2 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal2 . x ; m_lowerLimit . y = - m_normal2 . y ; m_upperLimit . x = - m_normal0 . x ; m_upperLimit . y = - m_normal0 . y ; } } } else if ( hasVertex0 ) { if ( convex1 ) { m_front = offset0 > = <float> | | offset1 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal0 . x ; m_lowerLimit . y = m_normal0 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } } else { m_front = offset0 > = <float> & & offset1 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = - m_normal0 . x ; m_upperLimit . y = - m_normal0 . y ; } } } else if ( hasVertex3 ) { if ( convex2 ) { m_front = offset1 > = <float> | | offset2 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = m_normal2 . x ; m_upperLimit . y = m_normal2 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } } else { m_front = offset1 > = <float> & & offset2 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = - m_normal2 . x ; m_lowerLimit . y = - m_normal2 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } } } else { m_front = offset1 > = <float> ; if ( m_front ) { m_normal . x = m_normal1 . x ; m_normal . y = m_normal1 . y ; m_lowerLimit . x = - m_normal1 . x ; m_lowerLimit . y = - m_normal1 . y ; m_upperLimit . x = - m_normal1 . x ; m_upperLimit . y = - m_normal1 . y ; } else { m_normal . x = - m_normal1 . x ; m_normal . y = - m_normal1 . y ; m_lowerLimit . x = m_normal1 . x ; m_lowerLimit . y = m_normal1 . y ; m_upperLimit . x = m_normal1 . x ; m_upperLimit . y = m_normal1 . y ; } } m_polygonB . count = polygonB . m_count ; for ( int i = <int> ; i < polygonB . m_count ; + + i ) { Transform . mulToOutUnsafe ( m_xf , polygonB . m_vertices [ i ] , m_polygonB . vertices [ i ] ) ; Rot . mulToOutUnsafe ( m_xf . q , polygonB . m_normals [ i ] , m_polygonB . normals [ i ] ) ; } m_radius = <float> * Settings . polygonRadius ; manifold . pointCount = <int> ; computeEdgeSeparation ( edgeAxis ) ; if ( edgeAxis . type = = EPAxis . Type . UNKNOWN ) { return ; } if ( edgeAxis . separation > m_radius ) { return ; } computePolygonSeparation ( polygonAxis ) ; if ( polygonAxis . type ! = EPAxis . Type . UNKNOWN & & polygonAxis . separation > m_radius ) { return ; } final float k_relativeTol = <float> ; final float k_absoluteTol = <float> ; EPAxis primaryAxis ; if ( polygonAxis . type = = EPAxis . Type . UNKNOWN ) { primaryAxis = edgeAxis ; } else if ( polygonAxis . separation > k_relativeTol * edgeAxis . separation + k_absoluteTol ) { primaryAxis = polygonAxis ; } else { primaryAxis = edgeAxis ; } final ClipVertex ie0 = ie [ <int> ] ; final ClipVertex ie1 = ie [ <int> ] ; if ( primaryAxis . type = = EPAxis . Type . EDGE_A ) { manifold . type = Manifold . ManifoldType . FACE_A ; int bestIndex = <int> ; float bestValue = Vec2 . dot ( m_normal , m_polygonB . normals [ <int> ] ) ; for ( int i = <int> ; i < m_polygonB . count ; + + i ) { float value = Vec2 . dot ( m_normal , m_polygonB . normals [ i ] ) ; if ( value < bestValue ) { bestValue = value ; bestIndex = i ; } } int i1 = bestIndex ; int i2 = i1 + <int> < m_polygonB . count ? i1 + <int> : <int> ; ie0 . v . set ( m_polygonB . vertices [ i1 ] ) ; ie0 . id . indexA = <int> ; ie0 . id . indexB = ( byte ) i1 ; ie0 . id . typeA = ( byte ) ContactID . Type . FACE . ordinal ( ) ; ie0 . id . typeB = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; ie1 . v . set ( m_polygonB . vertices [ i2 ] ) ; ie1 . id . indexA = <int> ; ie1 . id . indexB = ( byte ) i2 ; ie1 . id . typeA = ( byte ) ContactID . Type . FACE . ordinal ( ) ; ie1 . id . typeB = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; if ( m_front ) { rf . i1 = <int> ; rf . i2 = <int> ; rf . v1 . set ( m_v1 ) ; rf . v2 . set ( m_v2 ) ; rf . normal . set ( m_normal1 ) ; } else { rf . i1 = <int> ; rf . i2 = <int> ; rf . v1 . set ( m_v2 ) ; rf . v2 . set ( m_v1 ) ; rf . normal . set ( m_normal1 ) . negateLocal ( ) ; } } else { manifold . type = Manifold . ManifoldType . FACE_B ; ie0 . v . set ( m_v1 ) ; ie0 . id . indexA = <int> ; ie0 . id . indexB = ( byte ) primaryAxis . index ; ie0 . id . typeA = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; ie0 . id . typeB = ( byte ) ContactID . Type . FACE . ordinal ( ) ; ie1 . v . set ( m_v2 ) ; ie1 . id . indexA = <int> ; ie1 . id . indexB = ( byte ) primaryAxis . index ; ie1 . id . typeA = ( byte ) ContactID . Type . VERTEX . ordinal ( ) ; ie1 . id . typeB = ( byte ) ContactID . Type . FACE . ordinal ( ) ; rf . i1 = primaryAxis . index ; rf . i2 = rf . i1 + <int> < m_polygonB . count ? rf . i1 + <int> : <int> ; rf . v1 . set ( m_polygonB . vertices [ rf . i1 ] ) ; rf . v2 . set ( m_polygonB . vertices [ rf . i2 ] ) ; rf . normal . set ( m_polygonB . normals [ rf . i1 ] ) ; } rf . sideNormal1 . set ( rf . normal . y , - rf . normal . x ) ; rf . sideNormal2 . set ( rf . sideNormal1 ) . negateLocal ( ) ; rf . sideOffset1 = Vec2 . dot ( rf . sideNormal1 , rf . v1 ) ; rf . sideOffset2 = Vec2 . dot ( rf . sideNormal2 , rf . v2 ) ; int np ; np = clipSegmentToLine ( clipPoints1 , ie , rf . sideNormal1 , rf . sideOffset1 , rf . i1 ) ; if ( np < Settings . maxManifoldPoints ) { return ; } np = clipSegmentToLine ( clipPoints2 , clipPoints1 , rf . sideNormal2 , rf . sideOffset2 , rf . i2 ) ; if ( np < Settings . maxManifoldPoints ) { return ; } if ( primaryAxis . type = = EPAxis . Type . EDGE_A ) { manifold . localNormal . set ( rf . normal ) ; manifold . localPoint . set ( rf . v1 ) ; } else { manifold . localNormal . set ( polygonB . m_normals [ rf . i1 ] ) ; manifold . localPoint . set ( polygonB . m_vertices [ rf . i1 ] ) ; } int pointCount = <int> ; for ( int i = <int> ; i < Settings . maxManifoldPoints ; + + i ) { float separation ; separation = Vec2 . dot ( rf . normal , temp . set ( clipPoints2 [ i ] . v ) . subLocal ( rf . v1 ) ) ; if ( separation < = m_radius ) { ManifoldPoint cp = manifold . points [ pointCount ] ; if ( primaryAxis . type = = EPAxis . Type . EDGE_A ) { Transform . mulTransToOutUnsafe ( m_xf , clipPoints2 [ i ] . v , cp . localPoint ) ; cp . id . set ( clipPoints2 [ i ] . id ) ; } else { cp . localPoint . set ( clipPoints2 [ i ] . v ) ; cp . id . typeA = clipPoints2 [ i ] . id . typeB ; cp . id . typeB = clipPoints2 [ i ] . id . typeA ; cp . id . indexA = clipPoints2 [ i ] . id . indexB ; cp . id . indexB = clipPoints2 [ i ] . id . indexA ; } + + pointCount ; } } manifold . pointCount = pointCount ; } public void computeEdgeSeparation ( EPAxis axis ) { axis . type = EPAxis . Type . EDGE_A ; axis . index = m_front ? <int> : <int> ; axis . separation = Float . MAX_VALUE ; float nx = m_normal . x ; float ny = m_normal . y ; for ( int i = <int> ; i < m_polygonB . count ; + + i ) { Vec2 v = m_polygonB . vertices [ i ] ; float tempx = v . x - m_v1 . x ; float tempy = v . y - m_v1 . y ; float s = nx * tempx + ny * tempy ; if ( s < axis . separation ) { axis . separation = s ; } } } private final Vec2 perp = new Vec2 ( ) ; private final Vec2 n = new Vec2 ( ) ; public void computePolygonSeparation ( EPAxis axis ) { axis . type = EPAxis . Type . UNKNOWN ; axis . index = - <int> ; axis . separation = - Float . MAX_VALUE ; perp . x = - m_normal . y ; perp . y = m_normal . x ; for ( int i = <int> ; i < m_polygonB . count ; + + i ) { Vec2 normalB = m_polygonB . normals [ i ] ; Vec2 vB = m_polygonB . vertices [ i ] ; n . x = - normalB . x ; n . y = - normalB . y ; float tempx = vB . x - m_v1 . x ; float tempy = vB . y - m_v1 . y ; float s1 = n . x * tempx + n . y * tempy ; tempx = vB . x - m_v2 . x ; tempy = vB . y - m_v2 . y ; float s2 = n . x * tempx + n . y * tempy ; float s = MathUtils . min ( s1 , s2 ) ; if ( s > m_radius ) { axis . type = EPAxis . Type . EDGE_B ; axis . index = i ; axis . separation = s ; return ; } if ( n . x * perp . x + n . y * perp . y > = <float> ) { if ( Vec2 . dot ( temp . set ( n ) . subLocal ( m_upperLimit ) , m_normal ) < - Settings . angularSlop ) { continue ; } } else { if ( Vec2 . dot ( temp . set ( n ) . subLocal ( m_lowerLimit ) , m_normal ) < - Settings . angularSlop ) { continue ; } } if ( s > axis . separation ) { axis . type = EPAxis . Type . EDGE_B ; axis . index = i ; axis . separation = s ; } } } } } 
