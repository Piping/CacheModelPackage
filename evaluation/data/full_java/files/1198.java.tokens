package org . apache . cassandra . utils ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . utils . concurrent . Ref ; import org . apache . cassandra . utils . concurrent . WrappedSharedCloseable ; import org . apache . cassandra . utils . obs . IBitSet ; public class BloomFilter extends WrappedSharedCloseable implements IFilter { private static final ThreadLocal < long [ ] > reusableIndexes = new ThreadLocal < long [ ] > ( ) { protected long [ ] initialValue ( ) { return new long [ <int> ] ; } } ; public final IBitSet bitset ; public final int hashCount ; public final boolean oldBfHashOrder ; BloomFilter ( int hashCount , IBitSet bitset , boolean oldBfHashOrder ) { super ( bitset ) ; this . hashCount = hashCount ; this . bitset = bitset ; this . oldBfHashOrder = oldBfHashOrder ; } private BloomFilter ( BloomFilter copy ) { super ( copy ) ; this . hashCount = copy . hashCount ; this . bitset = copy . bitset ; this . oldBfHashOrder = copy . oldBfHashOrder ; } public long serializedSize ( ) { return BloomFilterSerializer . serializedSize ( this ) ; } @VisibleForTesting public long [ ] getHashBuckets ( FilterKey key , int hashCount , long max ) { long [ ] hash = new long [ <int> ] ; key . filterHash ( hash ) ; long [ ] indexes = new long [ hashCount ] ; setIndexes ( hash [ <int> ] , hash [ <int> ] , hashCount , max , indexes ) ; return indexes ; } private long [ ] indexes ( FilterKey key ) { long [ ] indexes = reusableIndexes . get ( ) ; key . filterHash ( indexes ) ; setIndexes ( indexes [ <int> ] , indexes [ <int> ] , hashCount , bitset . capacity ( ) , indexes ) ; return indexes ; } private void setIndexes ( long base , long inc , int count , long max , long [ ] results ) { if ( oldBfHashOrder ) { long x = inc ; inc = base ; base = x ; } for ( int i = <int> ; i < count ; i + + ) { results [ i ] = FBUtilities . abs ( base % max ) ; base + = inc ; } } public void add ( FilterKey key ) { long [ ] indexes = indexes ( key ) ; for ( int i = <int> ; i < hashCount ; i + + ) { bitset . set ( indexes [ i ] ) ; } } public final boolean isPresent ( FilterKey key ) { long [ ] indexes = indexes ( key ) ; for ( int i = <int> ; i < hashCount ; i + + ) { if ( ! bitset . get ( indexes [ i ] ) ) { return false ; } } return true ; } public void clear ( ) { bitset . clear ( ) ; } public IFilter sharedCopy ( ) { return new BloomFilter ( this ) ; } @Override public long offHeapSize ( ) { return bitset . offHeapSize ( ) ; } public String toString ( ) { return <str> + hashCount + <str> + oldBfHashOrder + <str> + bitset . capacity ( ) + <str> ; } public void addTo ( Ref . IdentityCollection identities ) { super . addTo ( identities ) ; bitset . addTo ( identities ) ; } } 
