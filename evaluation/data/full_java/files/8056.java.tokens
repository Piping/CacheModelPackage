package org . elasticsearch . gateway ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . index . store . StoreFileMetaData ; import org . elasticsearch . indices . store . TransportNodesListShardStoreMetaData ; import org . elasticsearch . test . ESAllocationTestCase ; import org . junit . Before ; import java . util . Collections ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicBoolean ; import static java . util . Collections . unmodifiableMap ; import static org . hamcrest . Matchers . equalTo ; public class ReplicaShardAllocatorTests extends ESAllocationTestCase { private final ShardId shardId = new ShardId ( <str> , <int> ) ; private final DiscoveryNode node1 = newNode ( <str> ) ; private final DiscoveryNode node2 = newNode ( <str> ) ; private final DiscoveryNode node3 = newNode ( <str> ) ; private TestAllocator testAllocator ; @Before public void buildTestAllocator ( ) { this . testAllocator = new TestAllocator ( ) ; } public void testNoAsyncFetchData ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; testAllocator . clean ( ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNoAsyncFetchOnIndexCreation ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) , Settings . EMPTY , UnassignedInfo . Reason . INDEX_CREATED ) ; testAllocator . clean ( ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( testAllocator . getFetchDataCalledAndClean ( ) , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testAsyncFetchOnAnythingButIndexCreation ( ) { UnassignedInfo . Reason reason = RandomPicks . randomFrom ( getRandom ( ) , EnumSet . complementOf ( EnumSet . of ( UnassignedInfo . Reason . INDEX_CREATED ) ) ) ; RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) , Settings . EMPTY , reason ) ; testAllocator . clean ( ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( <str> + reason , testAllocator . getFetchDataCalledAndClean ( ) , equalTo ( true ) ) ; } public void testSimpleFullMatchAllocation ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; DiscoveryNode nodeToMatch = randomBoolean ( ) ? node2 : node3 ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( nodeToMatch , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( nodeToMatch . id ( ) ) ) ; } public void testSyncIdMatch ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; DiscoveryNode nodeToMatch = randomBoolean ( ) ? node2 : node3 ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( nodeToMatch , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( nodeToMatch . id ( ) ) ) ; } public void testFileChecksumMatch ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; DiscoveryNode nodeToMatch = randomBoolean ( ) ? node2 : node3 ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( nodeToMatch , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( nodeToMatch . id ( ) ) ) ; } public void testNoPrimaryData ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node2 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNoDataForReplicaOnAnyNode ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNoMatchingFilesForReplicaOnAnyNode ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNoOrThrottleDecidersRemainsInUnassigned ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( randomBoolean ( ) ? noAllocationDeciders ( ) : throttleAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testThrottleWhenAllocatingToMatchingNode ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( new AllocationDeciders ( Settings . EMPTY , new AllocationDecider [ ] { new TestAllocateDecision ( Decision . YES ) , new AllocationDecider ( Settings . EMPTY ) { @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( node . node ( ) . equals ( node2 ) ) { return Decision . THROTTLE ; } return Decision . YES ; } } } ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; testAllocator . allocateUnassigned ( allocation ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testDelayedAllocation ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) , Settings . builder ( ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , TimeValue . timeValueHours ( <int> ) ) . build ( ) , UnassignedInfo . Reason . NODE_LEFT ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; if ( randomBoolean ( ) ) { testAllocator . addData ( node2 , false , null ) ; } AllocationService . updateLeftDelayOfUnassignedShards ( allocation , Settings . EMPTY ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; allocation = onePrimaryOnNode1And1Replica ( yesAllocationDeciders ( ) , Settings . builder ( ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , TimeValue . timeValueHours ( <int> ) ) . build ( ) , UnassignedInfo . Reason . NODE_LEFT ) ; testAllocator . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; AllocationService . updateLeftDelayOfUnassignedShards ( allocation , Settings . EMPTY ) ; changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( node2 . id ( ) ) ) ; } public void testCancelRecoveryBetterSyncId ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node3 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; boolean changed = testAllocator . processExistingRecoveries ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNotCancellingRecoveryIfSyncedOnExistingRecovery ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node3 , false , randomBoolean ( ) ? <str> : <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; boolean changed = testAllocator . processExistingRecoveries ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } public void testNotCancellingRecovery ( ) { RoutingAllocation allocation = onePrimaryOnNode1And1ReplicaRecovering ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , true , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) . addData ( node2 , false , <str> , new StoreFileMetaData ( <str> , <int> , <str> ) ) ; boolean changed = testAllocator . processExistingRecoveries ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } private RoutingAllocation onePrimaryOnNode1And1Replica ( AllocationDeciders deciders ) { return onePrimaryOnNode1And1Replica ( deciders , Settings . EMPTY , UnassignedInfo . Reason . CLUSTER_RECOVERED ) ; } private RoutingAllocation onePrimaryOnNode1And1Replica ( AllocationDeciders deciders , Settings settings , UnassignedInfo . Reason reason ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) . put ( settings ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( shardId . getIndex ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( shardId ) . addShard ( TestShardRouting . newShardRouting ( shardId . getIndex ( ) , shardId . getId ( ) , node1 . id ( ) , true , ShardRoutingState . STARTED , <int> ) ) . addShard ( ShardRouting . newUnassigned ( shardId . getIndex ( ) , shardId . getId ( ) , null , false , new UnassignedInfo ( reason , null ) ) ) . build ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; return new RoutingAllocation ( deciders , new RoutingNodes ( state , false ) , state . nodes ( ) , ClusterInfo . EMPTY , System . nanoTime ( ) ) ; } private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering ( AllocationDeciders deciders ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( shardId . getIndex ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( shardId ) . addShard ( TestShardRouting . newShardRouting ( shardId . getIndex ( ) , shardId . getId ( ) , node1 . id ( ) , true , ShardRoutingState . STARTED , <int> ) ) . addShard ( TestShardRouting . newShardRouting ( shardId . getIndex ( ) , shardId . getId ( ) , node2 . id ( ) , null , null , false , ShardRoutingState . INITIALIZING , <int> , new UnassignedInfo ( UnassignedInfo . Reason . CLUSTER_RECOVERED , null ) ) ) . build ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; return new RoutingAllocation ( deciders , new RoutingNodes ( state , false ) , state . nodes ( ) , ClusterInfo . EMPTY , System . nanoTime ( ) ) ; } class TestAllocator extends ReplicaShardAllocator { private Map < DiscoveryNode , TransportNodesListShardStoreMetaData . StoreFilesMetaData > data = null ; private AtomicBoolean fetchDataCalled = new AtomicBoolean ( false ) ; public TestAllocator ( ) { super ( Settings . EMPTY ) ; } public void clean ( ) { data = null ; } public void cleanWithEmptyData ( ) { data = new HashMap < > ( ) ; } public boolean getFetchDataCalledAndClean ( ) { return fetchDataCalled . getAndSet ( false ) ; } public TestAllocator addData ( DiscoveryNode node , boolean allocated , String syncId , StoreFileMetaData . . . files ) { if ( data = = null ) { data = new HashMap < > ( ) ; } Map < String , StoreFileMetaData > filesAsMap = new HashMap < > ( ) ; for ( StoreFileMetaData file : files ) { filesAsMap . put ( file . name ( ) , file ) ; } Map < String , String > commitData = new HashMap < > ( ) ; if ( syncId ! = null ) { commitData . put ( Engine . SYNC_COMMIT_ID , syncId ) ; } data . put ( node , new TransportNodesListShardStoreMetaData . StoreFilesMetaData ( allocated , shardId , new Store . MetadataSnapshot ( unmodifiableMap ( filesAsMap ) , unmodifiableMap ( commitData ) , randomInt ( ) ) ) ) ; return this ; } @Override protected AsyncShardFetch . FetchResult < TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > fetchData ( ShardRouting shard , RoutingAllocation allocation ) { fetchDataCalled . set ( true ) ; Map < DiscoveryNode , TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData > tData = null ; if ( data ! = null ) { tData = new HashMap < > ( ) ; for ( Map . Entry < DiscoveryNode , TransportNodesListShardStoreMetaData . StoreFilesMetaData > entry : data . entrySet ( ) ) { tData . put ( entry . getKey ( ) , new TransportNodesListShardStoreMetaData . NodeStoreFilesMetaData ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } } return new AsyncShardFetch . FetchResult < > ( shardId , tData , Collections . < String > emptySet ( ) , Collections . < String > emptySet ( ) ) ; } } } 
