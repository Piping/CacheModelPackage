package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Before ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . FromDataPoints ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @RunWith ( Theories . class ) public abstract class AbstractEncoderTest extends AbstractCompressionTest { protected EmbeddedChannel channel ; protected abstract ByteBuf decompress ( ByteBuf compressed , int originalLength ) throws Exception ; @Before public abstract void initChannel ( ) ; @DataPoints ( <str> ) public static ByteBuf [ ] smallData ( ) { ByteBuf heap = Unpooled . wrappedBuffer ( BYTES_SMALL ) ; ByteBuf direct = Unpooled . directBuffer ( BYTES_SMALL . length ) ; direct . writeBytes ( BYTES_SMALL ) ; return new ByteBuf [ ] { heap , direct } ; } @DataPoints ( <str> ) public static ByteBuf [ ] largeData ( ) { ByteBuf heap = Unpooled . wrappedBuffer ( BYTES_LARGE ) ; ByteBuf direct = Unpooled . directBuffer ( BYTES_LARGE . length ) ; direct . writeBytes ( BYTES_LARGE ) ; return new ByteBuf [ ] { heap , direct } ; } @Theory public void testCompressionOfSmallChunkOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testCompression ( data ) ; } @Theory public void testCompressionOfLargeChunkOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testCompression ( data ) ; } @Theory public void testCompressionOfBatchedFlowOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testCompressionOfBatchedFlow ( data ) ; } protected void testCompression ( final ByteBuf data ) throws Exception { final int dataLength = data . readableBytes ( ) ; assertTrue ( channel . writeOutbound ( data . retain ( ) ) ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf decompressed = readDecompressed ( dataLength ) ; assertEquals ( data . resetReaderIndex ( ) , decompressed ) ; decompressed . release ( ) ; data . release ( ) ; } protected void testCompressionOfBatchedFlow ( final ByteBuf data ) throws Exception { final int dataLength = data . readableBytes ( ) ; int written = <int> , length = rand . nextInt ( <int> ) ; while ( written + length < dataLength ) { ByteBuf in = data . slice ( written , length ) ; assertTrue ( channel . writeOutbound ( in . retain ( ) ) ) ; written + = length ; length = rand . nextInt ( <int> ) ; } ByteBuf in = data . slice ( written , dataLength - written ) ; assertTrue ( channel . writeOutbound ( in . retain ( ) ) ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf decompressed = readDecompressed ( dataLength ) ; assertEquals ( data , decompressed ) ; decompressed . release ( ) ; data . release ( ) ; } protected ByteBuf readDecompressed ( final int dataLength ) throws Exception { CompositeByteBuf compressed = Unpooled . compositeBuffer ( ) ; ByteBuf msg ; while ( ( msg = channel . readOutbound ( ) ) ! = null ) { compressed . addComponent ( msg ) ; compressed . writerIndex ( compressed . writerIndex ( ) + msg . readableBytes ( ) ) ; } ByteBuf decompressed = decompress ( compressed , dataLength ) ; compressed . release ( ) ; return decompressed ; } } 
