package org . elasticsearch . index . search . geo ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . ConstantScoreScorer ; import org . apache . lucene . search . ConstantScoreWeight ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . TwoPhaseIterator ; import org . apache . lucene . search . Weight ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . index . fielddata . IndexGeoPointFieldData ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapperLegacy ; import java . io . IOException ; public class GeoDistanceRangeQuery extends Query { private final double lat ; private final double lon ; private final double inclusiveLowerPoint ; private final double inclusiveUpperPoint ; private final GeoDistance geoDistance ; private final GeoDistance . FixedSourceDistance fixedSourceDistance ; private GeoDistance . DistanceBoundingCheck distanceBoundingCheck ; private final Query boundingBoxFilter ; private final IndexGeoPointFieldData indexFieldData ; public GeoDistanceRangeQuery ( GeoPoint point , Double lowerVal , Double upperVal , boolean includeLower , boolean includeUpper , GeoDistance geoDistance , GeoPointFieldMapperLegacy . GeoPointFieldType fieldType , IndexGeoPointFieldData indexFieldData , String optimizeBbox ) { this . lat = point . lat ( ) ; this . lon = point . lon ( ) ; this . geoDistance = geoDistance ; this . indexFieldData = indexFieldData ; this . fixedSourceDistance = geoDistance . fixedSourceDistance ( lat , lon , DistanceUnit . DEFAULT ) ; if ( lowerVal ! = null ) { double f = lowerVal . doubleValue ( ) ; long i = NumericUtils . doubleToSortableLong ( f ) ; inclusiveLowerPoint = NumericUtils . sortableLongToDouble ( includeLower ? i : ( i + <int> ) ) ; } else { inclusiveLowerPoint = Double . NEGATIVE_INFINITY ; } if ( upperVal ! = null ) { double f = upperVal . doubleValue ( ) ; long i = NumericUtils . doubleToSortableLong ( f ) ; inclusiveUpperPoint = NumericUtils . sortableLongToDouble ( includeUpper ? i : ( i - <int> ) ) ; } else { inclusiveUpperPoint = Double . POSITIVE_INFINITY ; optimizeBbox = null ; } if ( optimizeBbox ! = null & & ! <str> . equals ( optimizeBbox ) ) { distanceBoundingCheck = GeoDistance . distanceBoundingCheck ( lat , lon , inclusiveUpperPoint , DistanceUnit . DEFAULT ) ; if ( <str> . equals ( optimizeBbox ) ) { boundingBoxFilter = null ; } else if ( <str> . equals ( optimizeBbox ) ) { boundingBoxFilter = IndexedGeoBoundingBoxQuery . create ( distanceBoundingCheck . topLeft ( ) , distanceBoundingCheck . bottomRight ( ) , fieldType ) ; distanceBoundingCheck = GeoDistance . ALWAYS_INSTANCE ; } else { throw new IllegalArgumentException ( <str> + optimizeBbox + <str> ) ; } } else { distanceBoundingCheck = GeoDistance . ALWAYS_INSTANCE ; boundingBoxFilter = null ; } } public double lat ( ) { return lat ; } public double lon ( ) { return lon ; } public GeoDistance geoDistance ( ) { return geoDistance ; } public double minInclusiveDistance ( ) { return inclusiveLowerPoint ; } public double maxInclusiveDistance ( ) { return inclusiveUpperPoint ; } public String fieldName ( ) { return indexFieldData . getFieldNames ( ) . indexName ( ) ; } @Override public Query rewrite ( IndexReader reader ) throws IOException { return super . rewrite ( reader ) ; } @Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores ) throws IOException { final Weight boundingBoxWeight ; if ( boundingBoxFilter ! = null ) { boundingBoxWeight = searcher . createNormalizedWeight ( boundingBoxFilter , false ) ; } else { boundingBoxWeight = null ; } return new ConstantScoreWeight ( this ) { @Override public Scorer scorer ( LeafReaderContext context ) throws IOException { final DocIdSetIterator approximation ; if ( boundingBoxWeight ! = null ) { approximation = boundingBoxWeight . scorer ( context ) ; } else { approximation = DocIdSetIterator . all ( context . reader ( ) . maxDoc ( ) ) ; } if ( approximation = = null ) { return null ; } final MultiGeoPointValues values = indexFieldData . load ( context ) . getGeoPointValues ( ) ; final TwoPhaseIterator twoPhaseIterator = new TwoPhaseIterator ( approximation ) { @Override public boolean matches ( ) throws IOException { final int doc = approximation . docID ( ) ; values . setDocument ( doc ) ; final int length = values . count ( ) ; for ( int i = <int> ; i < length ; i + + ) { GeoPoint point = values . valueAt ( i ) ; if ( distanceBoundingCheck . isWithin ( point . lat ( ) , point . lon ( ) ) ) { double d = fixedSourceDistance . calculate ( point . lat ( ) , point . lon ( ) ) ; if ( d > = inclusiveLowerPoint & & d < = inclusiveUpperPoint ) { return true ; } } } return false ; } @Override public float matchCost ( ) { if ( distanceBoundingCheck = = GeoDistance . ALWAYS_INSTANCE ) { return <float> ; } else { return <float> ; } } } ; return new ConstantScoreScorer ( this , score ( ) , twoPhaseIterator ) ; } } ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( super . equals ( o ) = = false ) return false ; GeoDistanceRangeQuery filter = ( GeoDistanceRangeQuery ) o ; if ( Double . compare ( filter . inclusiveLowerPoint , inclusiveLowerPoint ) ! = <int> ) return false ; if ( Double . compare ( filter . inclusiveUpperPoint , inclusiveUpperPoint ) ! = <int> ) return false ; if ( Double . compare ( filter . lat , lat ) ! = <int> ) return false ; if ( Double . compare ( filter . lon , lon ) ! = <int> ) return false ; if ( ! indexFieldData . getFieldNames ( ) . indexName ( ) . equals ( filter . indexFieldData . getFieldNames ( ) . indexName ( ) ) ) return false ; if ( geoDistance ! = filter . geoDistance ) return false ; return true ; } @Override public String toString ( String field ) { return <str> + indexFieldData . getFieldNames ( ) . indexName ( ) + <str> + geoDistance + <str> + inclusiveLowerPoint + <str> + inclusiveUpperPoint + <str> + lat + <str> + lon + <str> ; } @Override public int hashCode ( ) { int result = super . hashCode ( ) ; long temp ; temp = lat ! = + <float> ? Double . doubleToLongBits ( lat ) : <int> L ; result = <int> * result + Long . hashCode ( temp ) ; temp = lon ! = + <float> ? Double . doubleToLongBits ( lon ) : <int> L ; result = <int> * result + Long . hashCode ( temp ) ; temp = inclusiveLowerPoint ! = + <float> ? Double . doubleToLongBits ( inclusiveLowerPoint ) : <int> L ; result = <int> * result + Long . hashCode ( temp ) ; temp = inclusiveUpperPoint ! = + <float> ? Double . doubleToLongBits ( inclusiveUpperPoint ) : <int> L ; result = <int> * result + Long . hashCode ( temp ) ; result = <int> * result + ( geoDistance ! = null ? geoDistance . hashCode ( ) : <int> ) ; result = <int> * result + indexFieldData . getFieldNames ( ) . indexName ( ) . hashCode ( ) ; return result ; } } 
