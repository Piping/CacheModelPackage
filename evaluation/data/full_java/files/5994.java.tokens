package org . elasticsearch . common . lucene . search . function ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Explanation ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . index . fielddata . FieldData ; import org . elasticsearch . index . fielddata . IndexNumericFieldData ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public class FieldValueFactorFunction extends ScoreFunction { private final String field ; private final float boostFactor ; private final Modifier modifier ; private final Double missing ; private final IndexNumericFieldData indexFieldData ; public FieldValueFactorFunction ( String field , float boostFactor , Modifier modifierType , Double missing , IndexNumericFieldData indexFieldData ) { super ( CombineFunction . MULTIPLY ) ; this . field = field ; this . boostFactor = boostFactor ; this . modifier = modifierType ; this . indexFieldData = indexFieldData ; this . missing = missing ; } @Override public LeafScoreFunction getLeafScoreFunction ( LeafReaderContext ctx ) { final SortedNumericDoubleValues values ; if ( indexFieldData = = null ) { values = FieldData . emptySortedNumericDoubles ( ctx . reader ( ) . maxDoc ( ) ) ; } else { values = this . indexFieldData . load ( ctx ) . getDoubleValues ( ) ; } return new LeafScoreFunction ( ) { @Override public double score ( int docId , float subQueryScore ) { values . setDocument ( docId ) ; final int numValues = values . count ( ) ; double value ; if ( numValues > <int> ) { value = values . valueAt ( <int> ) ; } else if ( missing ! = null ) { value = missing ; } else { throw new ElasticsearchException ( <str> + field + <str> ) ; } double val = value * boostFactor ; double result = modifier . apply ( val ) ; if ( Double . isNaN ( result ) | | Double . isInfinite ( result ) ) { throw new ElasticsearchException ( <str> + modifier . toString ( ) + <str> + val + <str> ) ; } return result ; } @Override public Explanation explainScore ( int docId , Explanation subQueryScore ) { String modifierStr = modifier ! = null ? modifier . toString ( ) : <str> ; String defaultStr = missing ! = null ? <str> + missing : <str> ; double score = score ( docId , subQueryScore . getValue ( ) ) ; return Explanation . match ( CombineFunction . toFloat ( score ) , String . format ( Locale . ROOT , <str> , modifierStr , field , defaultStr , boostFactor ) ) ; } } ; } @Override public boolean needsScores ( ) { return false ; } @Override protected boolean doEquals ( ScoreFunction other ) { FieldValueFactorFunction fieldValueFactorFunction = ( FieldValueFactorFunction ) other ; return this . boostFactor = = fieldValueFactorFunction . boostFactor & & Objects . equals ( this . field , fieldValueFactorFunction . field ) & & Objects . equals ( this . modifier , fieldValueFactorFunction . modifier ) ; } public enum Modifier implements Writeable < Modifier > { NONE { @Override public double apply ( double n ) { return n ; } } , LOG { @Override public double apply ( double n ) { return Math . log10 ( n ) ; } } , LOG1P { @Override public double apply ( double n ) { return Math . log10 ( n + <int> ) ; } } , LOG2P { @Override public double apply ( double n ) { return Math . log10 ( n + <int> ) ; } } , LN { @Override public double apply ( double n ) { return Math . log ( n ) ; } } , LN1P { @Override public double apply ( double n ) { return Math . log1p ( n ) ; } } , LN2P { @Override public double apply ( double n ) { return Math . log1p ( n + <int> ) ; } } , SQUARE { @Override public double apply ( double n ) { return Math . pow ( n , <int> ) ; } } , SQRT { @Override public double apply ( double n ) { return Math . sqrt ( n ) ; } } , RECIPROCAL { @Override public double apply ( double n ) { return <float> / n ; } } ; public abstract double apply ( double n ) ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } public static Modifier readModifierFrom ( StreamInput in ) throws IOException { return Modifier . NONE . readFrom ( in ) ; } @Override public Modifier readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; if ( ordinal < <int> | | ordinal > = values ( ) . length ) { throw new IOException ( <str> + ordinal + <str> ) ; } return values ( ) [ ordinal ] ; } @Override public String toString ( ) { return super . toString ( ) . toLowerCase ( Locale . ROOT ) ; } public static Modifier fromString ( String modifier ) { return valueOf ( modifier . toUpperCase ( Locale . ROOT ) ) ; } } } 
