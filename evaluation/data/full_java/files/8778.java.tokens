package org . elasticsearch . script . javascript ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . test . ESTestCase ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . Matchers . equalTo ; public class JavaScriptScriptMultiThreadedTests extends ESTestCase { public void testExecutableNoRuntimeParams ( ) throws Exception { final JavaScriptScriptEngineService se = new JavaScriptScriptEngineService ( Settings . Builder . EMPTY_SETTINGS ) ; final Object compiled = se . compile ( <str> ) ; final AtomicBoolean failed = new AtomicBoolean ( ) ; Thread [ ] threads = new Thread [ <int> ] ; final CountDownLatch latch = new CountDownLatch ( threads . length ) ; final CyclicBarrier barrier = new CyclicBarrier ( threads . length + <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; long x = ThreadLocalRandom . current ( ) . nextInt ( ) ; long y = ThreadLocalRandom . current ( ) . nextInt ( ) ; long addition = x + y ; Map < String , Object > vars = new HashMap < String , Object > ( ) ; vars . put ( <str> , x ) ; vars . put ( <str> , y ) ; ExecutableScript script = se . executable ( new CompiledScript ( ScriptService . ScriptType . INLINE , <str> , <str> , compiled ) , vars ) ; for ( int i = <int> ; i < <int> ; i + + ) { long result = ( ( Number ) script . run ( ) ) . longValue ( ) ; assertThat ( result , equalTo ( addition ) ) ; } } catch ( Throwable t ) { failed . set ( true ) ; logger . error ( <str> , t ) ; } finally { latch . countDown ( ) ; } } } ) ; } for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] . start ( ) ; } barrier . await ( ) ; latch . await ( ) ; assertThat ( failed . get ( ) , equalTo ( false ) ) ; } public void testExecutableWithRuntimeParams ( ) throws Exception { final JavaScriptScriptEngineService se = new JavaScriptScriptEngineService ( Settings . Builder . EMPTY_SETTINGS ) ; final Object compiled = se . compile ( <str> ) ; final AtomicBoolean failed = new AtomicBoolean ( ) ; Thread [ ] threads = new Thread [ <int> ] ; final CountDownLatch latch = new CountDownLatch ( threads . length ) ; final CyclicBarrier barrier = new CyclicBarrier ( threads . length + <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; long x = ThreadLocalRandom . current ( ) . nextInt ( ) ; Map < String , Object > vars = new HashMap < String , Object > ( ) ; vars . put ( <str> , x ) ; ExecutableScript script = se . executable ( new CompiledScript ( ScriptService . ScriptType . INLINE , <str> , <str> , compiled ) , vars ) ; for ( int i = <int> ; i < <int> ; i + + ) { long y = ThreadLocalRandom . current ( ) . nextInt ( ) ; long addition = x + y ; script . setNextVar ( <str> , y ) ; long result = ( ( Number ) script . run ( ) ) . longValue ( ) ; assertThat ( result , equalTo ( addition ) ) ; } } catch ( Throwable t ) { failed . set ( true ) ; logger . error ( <str> , t ) ; } finally { latch . countDown ( ) ; } } } ) ; } for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] . start ( ) ; } barrier . await ( ) ; latch . await ( ) ; assertThat ( failed . get ( ) , equalTo ( false ) ) ; } public void testExecute ( ) throws Exception { final JavaScriptScriptEngineService se = new JavaScriptScriptEngineService ( Settings . Builder . EMPTY_SETTINGS ) ; final Object compiled = se . compile ( <str> ) ; final AtomicBoolean failed = new AtomicBoolean ( ) ; Thread [ ] threads = new Thread [ <int> ] ; final CountDownLatch latch = new CountDownLatch ( threads . length ) ; final CyclicBarrier barrier = new CyclicBarrier ( threads . length + <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; Map < String , Object > runtimeVars = new HashMap < String , Object > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { long x = ThreadLocalRandom . current ( ) . nextInt ( ) ; long y = ThreadLocalRandom . current ( ) . nextInt ( ) ; long addition = x + y ; runtimeVars . put ( <str> , x ) ; runtimeVars . put ( <str> , y ) ; long result = ( ( Number ) se . executable ( new CompiledScript ( ScriptService . ScriptType . INLINE , <str> , <str> , compiled ) , runtimeVars ) . run ( ) ) . longValue ( ) ; assertThat ( result , equalTo ( addition ) ) ; } } catch ( Throwable t ) { failed . set ( true ) ; logger . error ( <str> , t ) ; } finally { latch . countDown ( ) ; } } } ) ; } for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] . start ( ) ; } barrier . await ( ) ; latch . await ( ) ; assertThat ( failed . get ( ) , equalTo ( false ) ) ; } } 
