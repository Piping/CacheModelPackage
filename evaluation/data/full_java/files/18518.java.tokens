package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . g2d . ParticleEffect ; import com . badlogic . gdx . graphics . g2d . ParticleEffectPool ; import com . badlogic . gdx . graphics . g2d . ParticleEffectPool . PooledEffect ; import com . badlogic . gdx . graphics . g2d . ParticleEmitter ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . ui . Button ; import com . badlogic . gdx . scenes . scene2d . ui . CheckBox ; import com . badlogic . gdx . scenes . scene2d . ui . CheckBox . CheckBoxStyle ; import com . badlogic . gdx . scenes . scene2d . ui . Label ; import com . badlogic . gdx . scenes . scene2d . ui . Label . LabelStyle ; import com . badlogic . gdx . scenes . scene2d . ui . Skin ; import com . badlogic . gdx . scenes . scene2d . ui . Table ; import com . badlogic . gdx . scenes . scene2d . ui . TextButton ; import com . badlogic . gdx . scenes . scene2d . ui . TextButton . TextButtonStyle ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . viewport . ExtendViewport ; public class ParticleEmittersTest extends GdxTest { private SpriteBatch spriteBatch ; ParticleEffect effect ; ParticleEffectPool effectPool ; Array < PooledEffect > effects = new Array ( ) ; PooledEffect latestEffect ; float fpsCounter ; Stage ui ; CheckBox skipCleanup ; Button clearEmitters ; Label logLabel ; @Override public void create ( ) { spriteBatch = new SpriteBatch ( ) ; effect = new ParticleEffect ( ) ; effect . load ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) ) ; effect . setPosition ( Gdx . graphics . getWidth ( ) / <int> , Gdx . graphics . getHeight ( ) / <int> ) ; effectPool = new ParticleEffectPool ( effect , <int> , <int> ) ; setupUI ( ) ; InputProcessor inputProcessor = new InputAdapter ( ) { public boolean touchDragged ( int x , int y , int pointer ) { if ( latestEffect ! = null ) latestEffect . setPosition ( x , Gdx . graphics . getHeight ( ) - y ) ; return false ; } public boolean touchDown ( int x , int y , int pointer , int newParam ) { latestEffect = effectPool . obtain ( ) ; latestEffect . setEmittersCleanUpBlendFunction ( ! skipCleanup . isChecked ( ) ) ; latestEffect . setPosition ( x , Gdx . graphics . getHeight ( ) - y ) ; effects . add ( latestEffect ) ; return false ; } } ; InputMultiplexer multiplexer = new InputMultiplexer ( ) ; multiplexer . addProcessor ( ui ) ; multiplexer . addProcessor ( inputProcessor ) ; Gdx . input . setInputProcessor ( multiplexer ) ; } @Override public void dispose ( ) { spriteBatch . dispose ( ) ; effect . dispose ( ) ; } @Override public void resize ( int width , int height ) { ui . getViewport ( ) . update ( width , height ) ; } public void render ( ) { ui . act ( ) ; spriteBatch . getProjectionMatrix ( ) . setToOrtho2D ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; float delta = Gdx . graphics . getDeltaTime ( ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; for ( ParticleEffect e : effects ) e . draw ( spriteBatch , delta ) ; spriteBatch . end ( ) ; fpsCounter + = delta ; if ( fpsCounter > <int> ) { fpsCounter = <int> ; String log = effects . size + <str> + Gdx . graphics . getFramesPerSecond ( ) + <str> + spriteBatch . renderCalls ; Gdx . app . log ( <str> , log ) ; logLabel . setText ( log ) ; } ui . draw ( ) ; } public boolean needsGL20 ( ) { return false ; } private void setupUI ( ) { ui = new Stage ( new ExtendViewport ( <int> , <int> ) ) ; Skin skin = new Skin ( Gdx . files . internal ( <str> ) ) ; skipCleanup = new CheckBox ( <str> , skin ) ; skipCleanup . setTransform ( false ) ; skipCleanup . addListener ( listener ) ; logLabel = new Label ( <str> , skin . get ( LabelStyle . class ) ) ; clearEmitters = new TextButton ( <str> , skin ) ; clearEmitters . setTransform ( false ) ; clearEmitters . addListener ( listener ) ; Table table = new Table ( ) ; table . setTransform ( false ) ; table . setFillParent ( true ) ; table . defaults ( ) . padTop ( <int> ) . left ( ) ; table . top ( ) . left ( ) . padLeft ( <int> ) ; table . add ( skipCleanup ) . row ( ) ; table . add ( clearEmitters ) . row ( ) ; table . add ( logLabel ) ; ui . addActor ( table ) ; } void updateSkipCleanupState ( ) { for ( ParticleEffect eff : effects ) { for ( ParticleEmitter e : eff . getEmitters ( ) ) e . setCleansUpBlendFunction ( ! skipCleanup . isChecked ( ) ) ; } } ChangeListener listener = new ChangeListener ( ) { @Override public void changed ( ChangeEvent event , Actor actor ) { if ( actor = = skipCleanup ) { updateSkipCleanupState ( ) ; } else if ( actor = = clearEmitters ) { for ( PooledEffect e : effects ) e . free ( ) ; effects . clear ( ) ; } } } ; } 
