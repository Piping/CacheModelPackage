package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import java . util . Arrays ; import java . util . List ; import static io . netty . handler . codec . compression . Snappy . * ; public class SnappyFrameDecoder extends ByteToMessageDecoder { private enum ChunkType { STREAM_IDENTIFIER , COMPRESSED_DATA , UNCOMPRESSED_DATA , RESERVED_UNSKIPPABLE , RESERVED_SKIPPABLE } private static final byte [ ] SNAPPY = { <str> , <str> , <str> , <str> , <str> , <str> } ; private static final int MAX_UNCOMPRESSED_DATA_SIZE = <int> + <int> ; private final Snappy snappy = new Snappy ( ) ; private final boolean validateChecksums ; private boolean started ; private boolean corrupted ; public SnappyFrameDecoder ( ) { this ( false ) ; } public SnappyFrameDecoder ( boolean validateChecksums ) { this . validateChecksums = validateChecksums ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( corrupted ) { in . skipBytes ( in . readableBytes ( ) ) ; return ; } try { int idx = in . readerIndex ( ) ; final int inSize = in . readableBytes ( ) ; if ( inSize < <int> ) { return ; } final int chunkTypeVal = in . getUnsignedByte ( idx ) ; final ChunkType chunkType = mapChunkType ( ( byte ) chunkTypeVal ) ; final int chunkLength = in . getUnsignedMediumLE ( idx + <int> ) ; switch ( chunkType ) { case STREAM_IDENTIFIER : if ( chunkLength ! = SNAPPY . length ) { throw new DecompressionException ( <str> + chunkLength ) ; } if ( inSize < <int> + SNAPPY . length ) { break ; } byte [ ] identifier = new byte [ chunkLength ] ; in . skipBytes ( <int> ) . readBytes ( identifier ) ; if ( ! Arrays . equals ( identifier , SNAPPY ) ) { throw new DecompressionException ( <str> + <str> ) ; } started = true ; break ; case RESERVED_SKIPPABLE : if ( ! started ) { throw new DecompressionException ( <str> ) ; } if ( inSize < <int> + chunkLength ) { return ; } in . skipBytes ( <int> + chunkLength ) ; break ; case RESERVED_UNSKIPPABLE : throw new DecompressionException ( <str> + Integer . toHexString ( chunkTypeVal ) ) ; case UNCOMPRESSED_DATA : if ( ! started ) { throw new DecompressionException ( <str> ) ; } if ( chunkLength > MAX_UNCOMPRESSED_DATA_SIZE ) { throw new DecompressionException ( <str> ) ; } if ( inSize < <int> + chunkLength ) { return ; } in . skipBytes ( <int> ) ; if ( validateChecksums ) { int checksum = in . readIntLE ( ) ; validateChecksum ( checksum , in , in . readerIndex ( ) , chunkLength - <int> ) ; } else { in . skipBytes ( <int> ) ; } out . add ( in . readSlice ( chunkLength - <int> ) . retain ( ) ) ; break ; case COMPRESSED_DATA : if ( ! started ) { throw new DecompressionException ( <str> ) ; } if ( inSize < <int> + chunkLength ) { return ; } in . skipBytes ( <int> ) ; int checksum = in . readIntLE ( ) ; ByteBuf uncompressed = ctx . alloc ( ) . buffer ( <int> ) ; if ( validateChecksums ) { int oldWriterIndex = in . writerIndex ( ) ; try { in . writerIndex ( in . readerIndex ( ) + chunkLength - <int> ) ; snappy . decode ( in , uncompressed ) ; } finally { in . writerIndex ( oldWriterIndex ) ; } validateChecksum ( checksum , uncompressed , <int> , uncompressed . writerIndex ( ) ) ; } else { snappy . decode ( in . readSlice ( chunkLength - <int> ) , uncompressed ) ; } out . add ( uncompressed ) ; snappy . reset ( ) ; break ; } } catch ( Exception e ) { corrupted = true ; throw e ; } } private static ChunkType mapChunkType ( byte type ) { if ( type = = <int> ) { return ChunkType . COMPRESSED_DATA ; } else if ( type = = <int> ) { return ChunkType . UNCOMPRESSED_DATA ; } else if ( type = = ( byte ) <hex> ) { return ChunkType . STREAM_IDENTIFIER ; } else if ( ( type & <hex> ) = = <hex> ) { return ChunkType . RESERVED_SKIPPABLE ; } else { return ChunkType . RESERVED_UNSKIPPABLE ; } } } 
