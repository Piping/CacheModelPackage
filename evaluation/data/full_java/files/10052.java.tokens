package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionFeature . ALLOWS_NULL_QUERIES ; import static com . google . common . collect . testing . features . CollectionFeature . ALLOWS_NULL_VALUES ; import static com . google . common . collect . testing . features . CollectionFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION ; import static com . google . common . collect . testing . features . CollectionFeature . SUPPORTS_REMOVE ; import static com . google . common . collect . testing . features . CollectionSize . SEVERAL ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . testing . AbstractCollectionTester ; import com . google . common . collect . testing . MinimalCollection ; import com . google . common . collect . testing . WrongType ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; @SuppressWarnings ( <str> ) @GwtCompatible public class CollectionRemoveAllTester < E > extends AbstractCollectionTester < E > { @CollectionFeature.Require ( SUPPORTS_REMOVE ) public void testRemoveAll_emptyCollection ( ) { assertFalse ( <str> , collection . removeAll ( MinimalCollection . of ( ) ) ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) public void testRemoveAll_nonePresent ( ) { assertFalse ( <str> , collection . removeAll ( MinimalCollection . of ( e3 ( ) ) ) ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_allPresent ( ) { assertTrue ( <str> , collection . removeAll ( MinimalCollection . of ( e0 ( ) ) ) ) ; expectMissing ( e0 ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_somePresent ( ) { assertTrue ( <str> , collection . removeAll ( MinimalCollection . of ( e0 ( ) , e3 ( ) ) ) ) ; expectMissing ( e0 ( ) ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , FAILS_FAST_ON_CONCURRENT_MODIFICATION } ) @CollectionSize.Require ( SEVERAL ) public void testRemoveAllSomePresentConcurrentWithIteration ( ) { try { Iterator < E > iterator = collection . iterator ( ) ; assertTrue ( collection . removeAll ( MinimalCollection . of ( e0 ( ) , e3 ( ) ) ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_somePresentLargeCollectionToRemove ( ) { assertTrue ( <str> , collection . removeAll ( MinimalCollection . of ( e0 ( ) , e0 ( ) , e0 ( ) , e3 ( ) , e3 ( ) , e3 ( ) ) ) ) ; expectMissing ( e0 ( ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testRemoveAll_unsupportedEmptyCollection ( ) { try { assertFalse ( <str> + <str> , collection . removeAll ( MinimalCollection . of ( ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testRemoveAll_unsupportedNonePresent ( ) { try { assertFalse ( <str> + <str> , collection . removeAll ( MinimalCollection . of ( e3 ( ) ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_unsupportedPresent ( ) { try { collection . removeAll ( MinimalCollection . of ( e0 ( ) ) ) ; fail ( <str> + <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; assertTrue ( collection . contains ( e0 ( ) ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRemoveAll_nullCollectionReferenceEmptySubject ( ) { try { collection . removeAll ( null ) ; } catch ( NullPointerException expected ) { } } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_nullCollectionReferenceNonEmptySubject ( ) { try { collection . removeAll ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } @CollectionFeature.Require ( value = SUPPORTS_REMOVE , absent = ALLOWS_NULL_QUERIES ) public void testRemoveAll_containsNullNo ( ) { MinimalCollection < ? > containsNull = MinimalCollection . of ( ( Object ) null ) ; try { assertFalse ( <str> , collection . removeAll ( containsNull ) ) ; } catch ( NullPointerException tolerated ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , ALLOWS_NULL_QUERIES } ) public void testRemoveAll_containsNullNoButAllowed ( ) { MinimalCollection < ? > containsNull = MinimalCollection . of ( ( Object ) null ) ; assertFalse ( <str> , collection . removeAll ( containsNull ) ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = ZERO ) public void testRemoveAll_containsNullYes ( ) { initCollectionWithNullElement ( ) ; assertTrue ( <str> , collection . removeAll ( Collections . singleton ( null ) ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) public void testRemoveAll_containsWrongType ( ) { try { assertFalse ( <str> , collection . removeAll ( MinimalCollection . of ( WrongType . VALUE ) ) ) ; } catch ( ClassCastException tolerated ) { } expectUnchanged ( ) ; } } 
