package com . badlogic . gdx . math ; import java . io . Serializable ; import com . badlogic . gdx . utils . NumberUtils ; public class Quaternion implements Serializable { private static final long serialVersionUID = - <int> ; private static Quaternion tmp1 = new Quaternion ( <int> , <int> , <int> , <int> ) ; private static Quaternion tmp2 = new Quaternion ( <int> , <int> , <int> , <int> ) ; public float x ; public float y ; public float z ; public float w ; public Quaternion ( float x , float y , float z , float w ) { this . set ( x , y , z , w ) ; } public Quaternion ( ) { idt ( ) ; } public Quaternion ( Quaternion quaternion ) { this . set ( quaternion ) ; } public Quaternion ( Vector3 axis , float angle ) { this . set ( axis , angle ) ; } public Quaternion set ( float x , float y , float z , float w ) { this . x = x ; this . y = y ; this . z = z ; this . w = w ; return this ; } public Quaternion set ( Quaternion quaternion ) { return this . set ( quaternion . x , quaternion . y , quaternion . z , quaternion . w ) ; } public Quaternion set ( Vector3 axis , float angle ) { return setFromAxis ( axis . x , axis . y , axis . z , angle ) ; } public Quaternion cpy ( ) { return new Quaternion ( this ) ; } public final static float len ( final float x , final float y , final float z , final float w ) { return ( float ) Math . sqrt ( x * x + y * y + z * z + w * w ) ; } public float len ( ) { return ( float ) Math . sqrt ( x * x + y * y + z * z + w * w ) ; } @Override public String toString ( ) { return <str> + x + <str> + y + <str> + z + <str> + w + <str> ; } public Quaternion setEulerAngles ( float yaw , float pitch , float roll ) { return setEulerAnglesRad ( yaw * MathUtils . degreesToRadians , pitch * MathUtils . degreesToRadians , roll * MathUtils . degreesToRadians ) ; } public Quaternion setEulerAnglesRad ( float yaw , float pitch , float roll ) { final float hr = roll * <float> ; final float shr = ( float ) Math . sin ( hr ) ; final float chr = ( float ) Math . cos ( hr ) ; final float hp = pitch * <float> ; final float shp = ( float ) Math . sin ( hp ) ; final float chp = ( float ) Math . cos ( hp ) ; final float hy = yaw * <float> ; final float shy = ( float ) Math . sin ( hy ) ; final float chy = ( float ) Math . cos ( hy ) ; final float chy_shp = chy * shp ; final float shy_chp = shy * chp ; final float chy_chp = chy * chp ; final float shy_shp = shy * shp ; x = ( chy_shp * chr ) + ( shy_chp * shr ) ; y = ( shy_chp * chr ) - ( chy_shp * shr ) ; z = ( chy_chp * shr ) - ( shy_shp * chr ) ; w = ( chy_chp * chr ) + ( shy_shp * shr ) ; return this ; } public int getGimbalPole ( ) { final float t = y * x + z * w ; return t > <float> ? <int> : ( t < - <float> ? - <int> : <int> ) ; } public float getRollRad ( ) { final int pole = getGimbalPole ( ) ; return pole = = <int> ? MathUtils . atan2 ( <float> * ( w * z + y * x ) , <float> - <float> * ( x * x + z * z ) ) : ( float ) pole * <float> * MathUtils . atan2 ( y , w ) ; } public float getRoll ( ) { return getRollRad ( ) * MathUtils . radiansToDegrees ; } public float getPitchRad ( ) { final int pole = getGimbalPole ( ) ; return pole = = <int> ? ( float ) Math . asin ( MathUtils . clamp ( <float> * ( w * x - z * y ) , - <float> , <float> ) ) : ( float ) pole * MathUtils . PI * <float> ; } public float getPitch ( ) { return getPitchRad ( ) * MathUtils . radiansToDegrees ; } public float getYawRad ( ) { return getGimbalPole ( ) = = <int> ? MathUtils . atan2 ( <float> * ( y * w + x * z ) , <float> - <float> * ( y * y + x * x ) ) : <float> ; } public float getYaw ( ) { return getYawRad ( ) * MathUtils . radiansToDegrees ; } public final static float len2 ( final float x , final float y , final float z , final float w ) { return x * x + y * y + z * z + w * w ; } public float len2 ( ) { return x * x + y * y + z * z + w * w ; } public Quaternion nor ( ) { float len = len2 ( ) ; if ( len ! = <float> & & ! MathUtils . isEqual ( len , <float> ) ) { len = ( float ) Math . sqrt ( len ) ; w / = len ; x / = len ; y / = len ; z / = len ; } return this ; } public Quaternion conjugate ( ) { x = - x ; y = - y ; z = - z ; return this ; } public Vector3 transform ( Vector3 v ) { tmp2 . set ( this ) ; tmp2 . conjugate ( ) ; tmp2 . mulLeft ( tmp1 . set ( v . x , v . y , v . z , <int> ) ) . mulLeft ( this ) ; v . x = tmp2 . x ; v . y = tmp2 . y ; v . z = tmp2 . z ; return v ; } public Quaternion mul ( final Quaternion other ) { final float newX = this . w * other . x + this . x * other . w + this . y * other . z - this . z * other . y ; final float newY = this . w * other . y + this . y * other . w + this . z * other . x - this . x * other . z ; final float newZ = this . w * other . z + this . z * other . w + this . x * other . y - this . y * other . x ; final float newW = this . w * other . w - this . x * other . x - this . y * other . y - this . z * other . z ; this . x = newX ; this . y = newY ; this . z = newZ ; this . w = newW ; return this ; } public Quaternion mul ( final float x , final float y , final float z , final float w ) { final float newX = this . w * x + this . x * w + this . y * z - this . z * y ; final float newY = this . w * y + this . y * w + this . z * x - this . x * z ; final float newZ = this . w * z + this . z * w + this . x * y - this . y * x ; final float newW = this . w * w - this . x * x - this . y * y - this . z * z ; this . x = newX ; this . y = newY ; this . z = newZ ; this . w = newW ; return this ; } public Quaternion mulLeft ( Quaternion other ) { final float newX = other . w * this . x + other . x * this . w + other . y * this . z - other . z * y ; final float newY = other . w * this . y + other . y * this . w + other . z * this . x - other . x * z ; final float newZ = other . w * this . z + other . z * this . w + other . x * this . y - other . y * x ; final float newW = other . w * this . w - other . x * this . x - other . y * this . y - other . z * z ; this . x = newX ; this . y = newY ; this . z = newZ ; this . w = newW ; return this ; } public Quaternion mulLeft ( final float x , final float y , final float z , final float w ) { final float newX = w * this . x + x * this . w + y * this . z - z * y ; final float newY = w * this . y + y * this . w + z * this . x - x * z ; final float newZ = w * this . z + z * this . w + x * this . y - y * x ; final float newW = w * this . w - x * this . x - y * this . y - z * z ; this . x = newX ; this . y = newY ; this . z = newZ ; this . w = newW ; return this ; } public Quaternion add ( Quaternion quaternion ) { this . x + = quaternion . x ; this . y + = quaternion . y ; this . z + = quaternion . z ; this . w + = quaternion . w ; return this ; } public Quaternion add ( float qx , float qy , float qz , float qw ) { this . x + = qx ; this . y + = qy ; this . z + = qz ; this . w + = qw ; return this ; } public void toMatrix ( final float [ ] matrix ) { final float xx = x * x ; final float xy = x * y ; final float xz = x * z ; final float xw = x * w ; final float yy = y * y ; final float yz = y * z ; final float yw = y * w ; final float zz = z * z ; final float zw = z * w ; matrix [ Matrix4 . M00 ] = <int> - <int> * ( yy + zz ) ; matrix [ Matrix4 . M01 ] = <int> * ( xy - zw ) ; matrix [ Matrix4 . M02 ] = <int> * ( xz + yw ) ; matrix [ Matrix4 . M03 ] = <int> ; matrix [ Matrix4 . M10 ] = <int> * ( xy + zw ) ; matrix [ Matrix4 . M11 ] = <int> - <int> * ( xx + zz ) ; matrix [ Matrix4 . M12 ] = <int> * ( yz - xw ) ; matrix [ Matrix4 . M13 ] = <int> ; matrix [ Matrix4 . M20 ] = <int> * ( xz - yw ) ; matrix [ Matrix4 . M21 ] = <int> * ( yz + xw ) ; matrix [ Matrix4 . M22 ] = <int> - <int> * ( xx + yy ) ; matrix [ Matrix4 . M23 ] = <int> ; matrix [ Matrix4 . M30 ] = <int> ; matrix [ Matrix4 . M31 ] = <int> ; matrix [ Matrix4 . M32 ] = <int> ; matrix [ Matrix4 . M33 ] = <int> ; } public Quaternion idt ( ) { return this . set ( <int> , <int> , <int> , <int> ) ; } public boolean isIdentity ( ) { return MathUtils . isZero ( x ) & & MathUtils . isZero ( y ) & & MathUtils . isZero ( z ) & & MathUtils . isEqual ( w , <float> ) ; } public boolean isIdentity ( final float tolerance ) { return MathUtils . isZero ( x , tolerance ) & & MathUtils . isZero ( y , tolerance ) & & MathUtils . isZero ( z , tolerance ) & & MathUtils . isEqual ( w , <float> , tolerance ) ; } public Quaternion setFromAxis ( final Vector3 axis , final float degrees ) { return setFromAxis ( axis . x , axis . y , axis . z , degrees ) ; } public Quaternion setFromAxisRad ( final Vector3 axis , final float radians ) { return setFromAxisRad ( axis . x , axis . y , axis . z , radians ) ; } public Quaternion setFromAxis ( final float x , final float y , final float z , final float degrees ) { return setFromAxisRad ( x , y , z , degrees * MathUtils . degreesToRadians ) ; } public Quaternion setFromAxisRad ( final float x , final float y , final float z , final float radians ) { float d = Vector3 . len ( x , y , z ) ; if ( d = = <float> ) return idt ( ) ; d = <float> / d ; float l_ang = radians < <int> ? MathUtils . PI2 - ( - radians % MathUtils . PI2 ) : radians % MathUtils . PI2 ; float l_sin = ( float ) Math . sin ( l_ang / <int> ) ; float l_cos = ( float ) Math . cos ( l_ang / <int> ) ; return this . set ( d * x * l_sin , d * y * l_sin , d * z * l_sin , l_cos ) . nor ( ) ; } public Quaternion setFromMatrix ( boolean normalizeAxes , Matrix4 matrix ) { return setFromAxes ( normalizeAxes , matrix . val [ Matrix4 . M00 ] , matrix . val [ Matrix4 . M01 ] , matrix . val [ Matrix4 . M02 ] , matrix . val [ Matrix4 . M10 ] , matrix . val [ Matrix4 . M11 ] , matrix . val [ Matrix4 . M12 ] , matrix . val [ Matrix4 . M20 ] , matrix . val [ Matrix4 . M21 ] , matrix . val [ Matrix4 . M22 ] ) ; } public Quaternion setFromMatrix ( Matrix4 matrix ) { return setFromMatrix ( false , matrix ) ; } public Quaternion setFromMatrix ( boolean normalizeAxes , Matrix3 matrix ) { return setFromAxes ( normalizeAxes , matrix . val [ Matrix3 . M00 ] , matrix . val [ Matrix3 . M01 ] , matrix . val [ Matrix3 . M02 ] , matrix . val [ Matrix3 . M10 ] , matrix . val [ Matrix3 . M11 ] , matrix . val [ Matrix3 . M12 ] , matrix . val [ Matrix3 . M20 ] , matrix . val [ Matrix3 . M21 ] , matrix . val [ Matrix3 . M22 ] ) ; } public Quaternion setFromMatrix ( Matrix3 matrix ) { return setFromMatrix ( false , matrix ) ; } public Quaternion setFromAxes ( float xx , float xy , float xz , float yx , float yy , float yz , float zx , float zy , float zz ) { return setFromAxes ( false , xx , xy , xz , yx , yy , yz , zx , zy , zz ) ; } public Quaternion setFromAxes ( boolean normalizeAxes , float xx , float xy , float xz , float yx , float yy , float yz , float zx , float zy , float zz ) { if ( normalizeAxes ) { final float lx = <float> / Vector3 . len ( xx , xy , xz ) ; final float ly = <float> / Vector3 . len ( yx , yy , yz ) ; final float lz = <float> / Vector3 . len ( zx , zy , zz ) ; xx * = lx ; xy * = lx ; xz * = lx ; yx * = ly ; yy * = ly ; yz * = ly ; zx * = lz ; zy * = lz ; zz * = lz ; } final float t = xx + yy + zz ; if ( t > = <int> ) { float s = ( float ) Math . sqrt ( t + <int> ) ; w = <float> * s ; s = <float> / s ; x = ( zy - yz ) * s ; y = ( xz - zx ) * s ; z = ( yx - xy ) * s ; } else if ( ( xx > yy ) & & ( xx > zz ) ) { float s = ( float ) Math . sqrt ( <float> + xx - yy - zz ) ; x = s * <float> ; s = <float> / s ; y = ( yx + xy ) * s ; z = ( xz + zx ) * s ; w = ( zy - yz ) * s ; } else if ( yy > zz ) { float s = ( float ) Math . sqrt ( <float> + yy - xx - zz ) ; y = s * <float> ; s = <float> / s ; x = ( yx + xy ) * s ; z = ( zy + yz ) * s ; w = ( xz - zx ) * s ; } else { float s = ( float ) Math . sqrt ( <float> + zz - xx - yy ) ; z = s * <float> ; s = <float> / s ; x = ( xz + zx ) * s ; y = ( zy + yz ) * s ; w = ( yx - xy ) * s ; } return this ; } public Quaternion setFromCross ( final Vector3 v1 , final Vector3 v2 ) { final float dot = MathUtils . clamp ( v1 . dot ( v2 ) , - <float> , <float> ) ; final float angle = ( float ) Math . acos ( dot ) ; return setFromAxisRad ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x , angle ) ; } public Quaternion setFromCross ( final float x1 , final float y1 , final float z1 , final float x2 , final float y2 , final float z2 ) { final float dot = MathUtils . clamp ( Vector3 . dot ( x1 , y1 , z1 , x2 , y2 , z2 ) , - <float> , <float> ) ; final float angle = ( float ) Math . acos ( dot ) ; return setFromAxisRad ( y1 * z2 - z1 * y2 , z1 * x2 - x1 * z2 , x1 * y2 - y1 * x2 , angle ) ; } public Quaternion slerp ( Quaternion end , float alpha ) { final float d = this . x * end . x + this . y * end . y + this . z * end . z + this . w * end . w ; float absDot = d < <float> ? - d : d ; float scale0 = <float> - alpha ; float scale1 = alpha ; if ( ( <int> - absDot ) > <float> ) { final float angle = ( float ) Math . acos ( absDot ) ; final float invSinTheta = <float> / ( float ) Math . sin ( angle ) ; scale0 = ( ( float ) Math . sin ( ( <float> - alpha ) * angle ) * invSinTheta ) ; scale1 = ( ( float ) Math . sin ( ( alpha * angle ) ) * invSinTheta ) ; } if ( d < <float> ) scale1 = - scale1 ; x = ( scale0 * x ) + ( scale1 * end . x ) ; y = ( scale0 * y ) + ( scale1 * end . y ) ; z = ( scale0 * z ) + ( scale1 * end . z ) ; w = ( scale0 * w ) + ( scale1 * end . w ) ; return this ; } public Quaternion slerp ( Quaternion [ ] q ) { final float w = <float> / q . length ; set ( q [ <int> ] ) . exp ( w ) ; for ( int i = <int> ; i < q . length ; i + + ) mul ( tmp1 . set ( q [ i ] ) . exp ( w ) ) ; nor ( ) ; return this ; } public Quaternion slerp ( Quaternion [ ] q , float [ ] w ) { set ( q [ <int> ] ) . exp ( w [ <int> ] ) ; for ( int i = <int> ; i < q . length ; i + + ) mul ( tmp1 . set ( q [ i ] ) . exp ( w [ i ] ) ) ; nor ( ) ; return this ; } public Quaternion exp ( float alpha ) { float norm = len ( ) ; float normExp = ( float ) Math . pow ( norm , alpha ) ; float theta = ( float ) Math . acos ( w / norm ) ; float coeff = <int> ; if ( Math . abs ( theta ) < <float> ) coeff = normExp * alpha / norm ; else coeff = ( float ) ( normExp * Math . sin ( alpha * theta ) / ( norm * Math . sin ( theta ) ) ) ; w = ( float ) ( normExp * Math . cos ( alpha * theta ) ) ; x * = coeff ; y * = coeff ; z * = coeff ; nor ( ) ; return this ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + NumberUtils . floatToRawIntBits ( w ) ; result = prime * result + NumberUtils . floatToRawIntBits ( x ) ; result = prime * result + NumberUtils . floatToRawIntBits ( y ) ; result = prime * result + NumberUtils . floatToRawIntBits ( z ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( ! ( obj instanceof Quaternion ) ) { return false ; } Quaternion other = ( Quaternion ) obj ; return ( NumberUtils . floatToRawIntBits ( w ) = = NumberUtils . floatToRawIntBits ( other . w ) ) & & ( NumberUtils . floatToRawIntBits ( x ) = = NumberUtils . floatToRawIntBits ( other . x ) ) & & ( NumberUtils . floatToRawIntBits ( y ) = = NumberUtils . floatToRawIntBits ( other . y ) ) & & ( NumberUtils . floatToRawIntBits ( z ) = = NumberUtils . floatToRawIntBits ( other . z ) ) ; } public final static float dot ( final float x1 , final float y1 , final float z1 , final float w1 , final float x2 , final float y2 , final float z2 , final float w2 ) { return x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2 ; } public float dot ( final Quaternion other ) { return this . x * other . x + this . y * other . y + this . z * other . z + this . w * other . w ; } public float dot ( final float x , final float y , final float z , final float w ) { return this . x * x + this . y * y + this . z * z + this . w * w ; } public Quaternion mul ( float scalar ) { this . x * = scalar ; this . y * = scalar ; this . z * = scalar ; this . w * = scalar ; return this ; } public float getAxisAngle ( Vector3 axis ) { return getAxisAngleRad ( axis ) * MathUtils . radiansToDegrees ; } public float getAxisAngleRad ( Vector3 axis ) { if ( this . w > <int> ) this . nor ( ) ; float angle = ( float ) ( <float> * Math . acos ( this . w ) ) ; double s = Math . sqrt ( <int> - this . w * this . w ) ; if ( s < MathUtils . FLOAT_ROUNDING_ERROR ) { axis . x = this . x ; axis . y = this . y ; axis . z = this . z ; } else { axis . x = ( float ) ( this . x / s ) ; axis . y = ( float ) ( this . y / s ) ; axis . z = ( float ) ( this . z / s ) ; } return angle ; } public float getAngleRad ( ) { return ( float ) ( <float> * Math . acos ( ( this . w > <int> ) ? ( this . w / len ( ) ) : this . w ) ) ; } public float getAngle ( ) { return getAngleRad ( ) * MathUtils . radiansToDegrees ; } public void getSwingTwist ( final float axisX , final float axisY , final float axisZ , final Quaternion swing , final Quaternion twist ) { final float d = Vector3 . dot ( this . x , this . y , this . z , axisX , axisY , axisZ ) ; twist . set ( axisX * d , axisY * d , axisZ * d , this . w ) . nor ( ) ; swing . set ( twist ) . conjugate ( ) . mulLeft ( this ) ; } public void getSwingTwist ( final Vector3 axis , final Quaternion swing , final Quaternion twist ) { getSwingTwist ( axis . x , axis . y , axis . z , swing , twist ) ; } public float getAngleAroundRad ( final float axisX , final float axisY , final float axisZ ) { final float d = Vector3 . dot ( this . x , this . y , this . z , axisX , axisY , axisZ ) ; final float l2 = Quaternion . len2 ( axisX * d , axisY * d , axisZ * d , this . w ) ; return MathUtils . isZero ( l2 ) ? <float> : ( float ) ( <float> * Math . acos ( MathUtils . clamp ( ( float ) ( this . w / Math . sqrt ( l2 ) ) , - <float> , <float> ) ) ) ; } public float getAngleAroundRad ( final Vector3 axis ) { return getAngleAroundRad ( axis . x , axis . y , axis . z ) ; } public float getAngleAround ( final float axisX , final float axisY , final float axisZ ) { return getAngleAroundRad ( axisX , axisY , axisZ ) * MathUtils . radiansToDegrees ; } public float getAngleAround ( final Vector3 axis ) { return getAngleAround ( axis . x , axis . y , axis . z ) ; } } 
