package org . gradle . initialization ; import org . gradle . api . logging . LogLevel ; import org . gradle . cli . CommandLineArgumentException ; import org . gradle . logging . ConsoleOutput ; import org . gradle . logging . ShowStacktrace ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . hamcrest . Matchers ; import org . junit . Assert ; import org . junit . Rule ; import org . junit . Test ; import java . io . File ; import java . io . IOException ; import static org . gradle . util . WrapUtil . toList ; import static org . gradle . util . WrapUtil . toMap ; public class DefaultCommandLineConverterTest extends CommandLineConverterTestSupport { @Rule public TestNameTestDirectoryProvider testDir = new TestNameTestDirectoryProvider ( ) ; public DefaultCommandLineConverterTest ( ) { super ( ) ; currentDir = testDir . file ( <str> ) ; expectedCurrentDir = currentDir ; } @Test public void withoutAnyOptions ( ) { checkConversion ( ) ; } @Test public void withSpecifiedGradleUserHomeDirectory ( ) { expectedGradleUserHome = testDir . file ( <str> ) ; checkConversion ( <str> , expectedGradleUserHome . getAbsolutePath ( ) ) ; expectedGradleUserHome = currentDir . file ( <str> ) ; checkConversion ( <str> , <str> ) ; } @Test public void withSpecifiedProjectCacheDir ( ) { expectedProjectCacheDir = new File ( currentDir , <str> ) ; checkConversion ( <str> , <str> ) ; } @Test public void withSpecifiedProjectDirectory ( ) { expectedCurrentDir = testDir . file ( <str> ) ; expectedProjectDir = expectedCurrentDir ; checkConversion ( <str> , expectedCurrentDir . getAbsolutePath ( ) ) ; expectedCurrentDir = currentDir . file ( <str> ) ; expectedProjectDir = expectedCurrentDir ; checkConversion ( <str> , <str> ) ; } @Test public void withSpecifiedBuildFileName ( ) throws IOException { expectedBuildFile = testDir . file ( <str> ) ; expectedCurrentDir = expectedBuildFile . getParentFile ( ) ; expectedProjectDir = expectedCurrentDir ; checkConversion ( <str> , expectedBuildFile . getAbsolutePath ( ) ) ; expectedBuildFile = currentDir . file ( <str> ) ; expectedCurrentDir = expectedBuildFile . getParentFile ( ) ; expectedProjectDir = expectedCurrentDir ; checkConversion ( <str> , <str> ) ; } @Test public void withSpecifiedSettingsFileName ( ) throws IOException { File expectedSettingsFile = currentDir . file ( <str> ) ; expectedCurrentDir = expectedSettingsFile . getParentFile ( ) ; checkConversion ( <str> , <str> ) ; Assert . assertThat ( actualStartParameter . getSettingsFile ( ) , Matchers . equalTo ( ( File ) expectedSettingsFile ) ) ; } @Test public void withInitScripts ( ) { File script1 = currentDir . file ( <str> ) ; expectedInitScripts . add ( script1 ) ; checkConversion ( <str> ) ; File script2 = currentDir . file ( <str> ) ; expectedInitScripts . add ( script2 ) ; checkConversion ( <str> , <str> ) ; } @Test public void withSystemProperties ( ) { final String prop1 = <str> ; final String valueProp1 = <str> ; final String prop2 = <str> ; final String valueProp2 = <str> ; expectedSystemProperties = toMap ( prop1 , valueProp1 ) ; expectedSystemProperties . put ( prop2 , valueProp2 ) ; checkConversion ( <str> , prop1 + <str> + valueProp1 , <str> , prop2 + <str> + valueProp2 ) ; } @Test public void withSpecifiedGradleUserHomeDirectoryBySystemProperty ( ) { expectedGradleUserHome = testDir . file ( <str> ) ; String propName = <str> ; String propValue = expectedGradleUserHome . getAbsolutePath ( ) ; expectedSystemProperties = toMap ( propName , propValue ) ; checkConversion ( <str> , propName + <str> + propValue ) ; } @Test public void privilegeCmdLineOptionOverSystemPrefForGradleUserHome ( ) { expectedGradleUserHome = testDir . file ( <str> ) ; String propName = <str> ; String propValue = <str> ; expectedSystemProperties = toMap ( propName , propValue ) ; checkConversion ( <str> , propName + <str> + propValue , <str> , expectedGradleUserHome . getAbsolutePath ( ) ) ; } @Test public void withStartProperties ( ) { final String prop1 = <str> ; final String valueProp1 = <str> ; final String prop2 = <str> ; final String valueProp2 = <str> ; expectedProjectProperties = toMap ( prop1 , valueProp1 ) ; expectedProjectProperties . put ( prop2 , valueProp2 ) ; checkConversion ( <str> , prop1 + <str> + valueProp1 , <str> , prop2 + <str> + valueProp2 ) ; } @Test public void withTaskNames ( ) { expectedTaskNames = toList ( <str> , <str> ) ; checkConversion ( <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withUnknownCacheFlags ( ) { checkConversion ( <str> , <str> ) ; } @Test public void withSearchUpwardsFlagSet ( ) { expectedSearchUpwards = false ; checkConversion ( <str> ) ; } @Test public void withShowFullStacktrace ( ) { expectedShowStackTrace = ShowStacktrace . ALWAYS_FULL ; checkConversion ( <str> ) ; } @Test public void withShowStacktrace ( ) { expectedShowStackTrace = ShowStacktrace . ALWAYS ; checkConversion ( <str> ) ; } @Test public void withRerunTasks ( ) { expectedRerunTasks = true ; checkConversion ( <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withShowStacktraceAndShowFullStacktraceShouldThrowCommandLineArgumentEx ( ) { checkConversion ( <str> ) ; } @Test public void withDryRunFlagSet ( ) { expectedDryRun = true ; checkConversion ( <str> ) ; } @Test public void withExcludeTask ( ) { expectedExcludedTasks . add ( <str> ) ; checkConversion ( <str> , <str> ) ; expectedExcludedTasks . add ( <str> ) ; checkConversion ( <str> , <str> , <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withEmbeddedScriptAndConflictingNoSearchUpwardsOption ( ) { checkConversion ( <str> , <str> , <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withEmbeddedScriptAndConflictingSpecifyBuildFileOption ( ) { checkConversion ( <str> , <str> , <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withEmbeddedScriptAndConflictingSpecifySettingsFileOption ( ) { checkConversion ( <str> , <str> , <str> , <str> ) ; } @Test public void withNoProjectDependencyRebuild ( ) { buildProjectDependencies = false ; checkConversion ( <str> ) ; } @Test public void withQuietLoggingOptions ( ) { expectedLogLevel = LogLevel . QUIET ; checkConversion ( <str> ) ; } @Test public void withInfoLoggingOptions ( ) { expectedLogLevel = LogLevel . INFO ; checkConversion ( <str> ) ; } @Test public void withDebugLoggingOptions ( ) { expectedLogLevel = LogLevel . DEBUG ; checkConversion ( <str> ) ; } @Test public void withNoColor ( ) { expectedColorOutput = false ; expectedConsoleOutput = ConsoleOutput . Plain ; checkConversion ( <str> ) ; } @Test public void withColor ( ) { expectedConsoleOutput = ConsoleOutput . Rich ; checkConversion ( <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withLowerPParameterWithoutArgument ( ) { checkConversion ( <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withAParameterWithoutArgument ( ) { checkConversion ( <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withUpperAAndLowerAParameter ( ) { checkConversion ( <str> , <str> ) ; } @Test public void withProfile ( ) { expectedProfile = true ; checkConversion ( <str> ) ; } @Test public void withContinue ( ) { expectedContinue = true ; checkConversion ( <str> ) ; } @Test public void withOffline ( ) { expectedOffline = true ; checkConversion ( <str> ) ; checkConversion ( <str> ) ; } @Test public void withRefreshDependencies ( ) { expectedRefreshDependencies = true ; checkConversion ( <str> ) ; checkConversion ( <str> ) ; } @Test public void withRecompileScripts ( ) { expectedRecompileScripts = true ; checkConversion ( <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withUnknownOption ( ) { checkConversion ( <str> ) ; } @Test public void withTaskAndTaskOption ( ) { expectedTaskNames = toList ( <str> , <str> ) ; checkConversion ( <str> , <str> ) ; } @Test public void withParallelExecutor ( ) { expectedParallelProjectExecution = true ; expectedParallelExecutorCount = expectedMaxWorkersCount ; checkConversion ( <str> ) ; } @Test public void withParallelExecutorThreads ( ) { expectedParallelProjectExecution = true ; expectedMaxWorkersCount = expectedParallelExecutorCount = <int> ; checkConversion ( <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withInvalidParallelExecutorThreads ( ) { checkConversion ( <str> , <str> ) ; } @Test public void withMaxWorkers ( ) { expectedMaxWorkersCount = <int> ; checkConversion ( <str> , <str> ) ; } @Test ( expected = CommandLineArgumentException . class ) public void withInvalidMaxWorkers ( ) { checkConversion ( <str> , <str> ) ; } @Test public void withConfigureOnDemand ( ) { expectedConfigureOnDemand = true ; checkConversion ( <str> ) ; } @Test public void withContinuous ( ) { expectedContinuous = true ; checkConversion ( <str> ) ; } @Test public void withContinuousShortFlag ( ) { expectedContinuous = true ; checkConversion ( <str> ) ; } } 
