package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufInputStream ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import lzma . sdk . lzma . Decoder ; import lzma . streams . LzmaInputStream ; import org . junit . experimental . theories . FromDataPoints ; import org . junit . experimental . theories . Theory ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; import static org . junit . Assert . * ; public class LzmaFrameEncoderTest extends AbstractEncoderTest { @Override public void initChannel ( ) { channel = new EmbeddedChannel ( new LzmaFrameEncoder ( ) ) ; } @Theory @Override public void testCompressionOfBatchedFlowOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testCompressionOfBatchedFlow ( data ) ; } @Override protected void testCompressionOfBatchedFlow ( final ByteBuf data ) throws Exception { List < Integer > originalLengths = new ArrayList < Integer > ( ) ; final int dataLength = data . readableBytes ( ) ; int written = <int> , length = rand . nextInt ( <int> ) ; while ( written + length < dataLength ) { ByteBuf in = data . slice ( written , length ) ; assertTrue ( channel . writeOutbound ( in . retain ( ) ) ) ; written + = length ; originalLengths . add ( length ) ; length = rand . nextInt ( <int> ) ; } length = dataLength - written ; ByteBuf in = data . slice ( written , dataLength - written ) ; originalLengths . add ( length ) ; assertTrue ( channel . writeOutbound ( in . retain ( ) ) ) ; assertTrue ( channel . finish ( ) ) ; CompositeByteBuf decompressed = Unpooled . compositeBuffer ( ) ; ByteBuf msg ; int i = <int> ; while ( ( msg = channel . readOutbound ( ) ) ! = null ) { ByteBuf decompressedMsg = decompress ( msg , originalLengths . get ( i + + ) ) ; decompressed . addComponent ( decompressedMsg ) ; decompressed . writerIndex ( decompressed . writerIndex ( ) + decompressedMsg . readableBytes ( ) ) ; msg . release ( ) ; } assertEquals ( originalLengths . size ( ) , i ) ; assertEquals ( data , decompressed ) ; decompressed . release ( ) ; data . release ( ) ; } @Override protected ByteBuf decompress ( ByteBuf compressed , int originalLength ) throws Exception { InputStream is = new ByteBufInputStream ( compressed ) ; LzmaInputStream lzmaIs = new LzmaInputStream ( is , new Decoder ( ) ) ; byte [ ] decompressed = new byte [ originalLength ] ; int remaining = originalLength ; while ( remaining > <int> ) { int read = lzmaIs . read ( decompressed , originalLength - remaining , remaining ) ; if ( read > <int> ) { remaining - = read ; } else { break ; } } assertEquals ( - <int> , lzmaIs . read ( ) ) ; lzmaIs . close ( ) ; return Unpooled . wrappedBuffer ( decompressed ) ; } } 
