package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import com . google . common . base . Objects ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . serializers . * ; import org . apache . cassandra . utils . ByteBufferUtil ; public class TupleType extends AbstractType < ByteBuffer > { protected final List < AbstractType < ? > > types ; public TupleType ( List < AbstractType < ? > > types ) { super ( ComparisonType . CUSTOM ) ; for ( int i = <int> ; i < types . size ( ) ; i + + ) types . set ( i , types . get ( i ) . freeze ( ) ) ; this . types = types ; } public static TupleType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException { List < AbstractType < ? > > types = parser . getTypeParameters ( ) ; for ( int i = <int> ; i < types . size ( ) ; i + + ) types . set ( i , types . get ( i ) . freeze ( ) ) ; return new TupleType ( types ) ; } @Override public boolean references ( AbstractType < ? > check ) { if ( super . references ( check ) ) return true ; for ( AbstractType < ? > type : types ) if ( type . references ( check ) ) return true ; return false ; } public AbstractType < ? > type ( int i ) { return types . get ( i ) ; } public int size ( ) { return types . size ( ) ; } public List < AbstractType < ? > > allTypes ( ) { return types ; } public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? <int> : o2 . hasRemaining ( ) ? - <int> : <int> ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; for ( int i = <int> ; bb1 . remaining ( ) > <int> & & bb2 . remaining ( ) > <int> ; i + + ) { AbstractType < ? > comparator = types . get ( i ) ; int size1 = bb1 . getInt ( ) ; int size2 = bb2 . getInt ( ) ; if ( size1 < <int> ) { if ( size2 < <int> ) continue ; return - <int> ; } if ( size2 < <int> ) return <int> ; ByteBuffer value1 = ByteBufferUtil . readBytes ( bb1 , size1 ) ; ByteBuffer value2 = ByteBufferUtil . readBytes ( bb2 , size2 ) ; int cmp = comparator . compare ( value1 , value2 ) ; if ( cmp ! = <int> ) return cmp ; } if ( bb1 . remaining ( ) = = <int> ) return bb2 . remaining ( ) = = <int> ? <int> : - <int> ; return <int> ; } @Override public void validate ( ByteBuffer bytes ) throws MarshalException { ByteBuffer input = bytes . duplicate ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { if ( ! input . hasRemaining ( ) ) return ; if ( input . remaining ( ) < <int> ) throw new MarshalException ( String . format ( <str> , i ) ) ; int size = input . getInt ( ) ; if ( size < <int> ) continue ; if ( input . remaining ( ) < size ) throw new MarshalException ( String . format ( <str> , i ) ) ; ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; types . get ( i ) . validate ( field ) ; } if ( input . hasRemaining ( ) ) throw new MarshalException ( <str> ) ; } public ByteBuffer [ ] split ( ByteBuffer value ) { ByteBuffer [ ] components = new ByteBuffer [ size ( ) ] ; ByteBuffer input = value . duplicate ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { if ( ! input . hasRemaining ( ) ) return Arrays . copyOfRange ( components , <int> , i ) ; int size = input . getInt ( ) ; components [ i ] = size < <int> ? null : ByteBufferUtil . readBytes ( input , size ) ; } return components ; } public static ByteBuffer buildValue ( ByteBuffer [ ] components ) { int totalLength = <int> ; for ( ByteBuffer component : components ) totalLength + = <int> + ( component = = null ? <int> : component . remaining ( ) ) ; ByteBuffer result = ByteBuffer . allocate ( totalLength ) ; for ( ByteBuffer component : components ) { if ( component = = null ) { result . putInt ( - <int> ) ; } else { result . putInt ( component . remaining ( ) ) ; result . put ( component . duplicate ( ) ) ; } } result . rewind ( ) ; return result ; } @Override public String getString ( ByteBuffer value ) { StringBuilder sb = new StringBuilder ( ) ; ByteBuffer input = value . duplicate ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { if ( ! input . hasRemaining ( ) ) return sb . toString ( ) ; if ( i > <int> ) sb . append ( <str> ) ; AbstractType < ? > type = type ( i ) ; int size = input . getInt ( ) ; if ( size < <int> ) { sb . append ( <str> ) ; continue ; } ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; sb . append ( type . getString ( field ) . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) ) ; } return sb . toString ( ) ; } public ByteBuffer fromString ( String source ) { List < String > fieldStrings = AbstractCompositeType . split ( source ) ; if ( fieldStrings . size ( ) > size ( ) ) throw new MarshalException ( String . format ( <str> , asCQL3Type ( ) , size ( ) , fieldStrings . size ( ) ) ) ; ByteBuffer [ ] fields = new ByteBuffer [ fieldStrings . size ( ) ] ; for ( int i = <int> ; i < fieldStrings . size ( ) ; i + + ) { String fieldString = fieldStrings . get ( i ) ; if ( fieldString . equals ( <str> ) ) continue ; AbstractType < ? > type = type ( i ) ; fields [ i ] = type . fromString ( fieldString . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) ) ; } return buildValue ( fields ) ; } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof List ) ) throw new MarshalException ( String . format ( <str> , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; List list = ( List ) parsed ; if ( list . size ( ) > types . size ( ) ) throw new MarshalException ( String . format ( <str> , types . size ( ) , parsed ) ) ; else if ( types . size ( ) > list . size ( ) ) throw new MarshalException ( String . format ( <str> , types . size ( ) , parsed ) ) ; List < Term > terms = new ArrayList < > ( list . size ( ) ) ; Iterator < AbstractType < ? > > typeIterator = types . iterator ( ) ; for ( Object element : list ) { if ( element = = null ) { typeIterator . next ( ) ; terms . add ( Constants . NULL_VALUE ) ; } else { terms . add ( typeIterator . next ( ) . fromJSONObject ( element ) ) ; } } return new Tuples . DelayedValue ( this , terms ) ; } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < types . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; ByteBuffer value = CollectionSerializer . readValue ( buffer , protocolVersion ) ; if ( value = = null ) sb . append ( <str> ) ; else sb . append ( types . get ( i ) . toJSONString ( value , protocolVersion ) ) ; } return sb . append ( <str> ) . toString ( ) ; } public TypeSerializer < ByteBuffer > getSerializer ( ) { return BytesSerializer . instance ; } @Override public boolean isCompatibleWith ( AbstractType < ? > previous ) { if ( ! ( previous instanceof TupleType ) ) return false ; TupleType tt = ( TupleType ) previous ; if ( size ( ) < tt . size ( ) ) return false ; for ( int i = <int> ; i < tt . size ( ) ; i + + ) { AbstractType < ? > tprev = tt . type ( i ) ; AbstractType < ? > tnew = type ( i ) ; if ( ! tnew . isCompatibleWith ( tprev ) ) return false ; } return true ; } @Override public boolean isValueCompatibleWithInternal ( AbstractType < ? > otherType ) { if ( ! ( otherType instanceof TupleType ) ) return false ; TupleType tt = ( TupleType ) otherType ; if ( size ( ) < tt . size ( ) ) return false ; for ( int i = <int> ; i < tt . size ( ) ; i + + ) { AbstractType < ? > tprev = tt . type ( i ) ; AbstractType < ? > tnew = type ( i ) ; if ( ! tnew . isValueCompatibleWith ( tprev ) ) return false ; } return true ; } @Override public int hashCode ( ) { return Objects . hashCode ( types ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof TupleType ) ) return false ; TupleType that = ( TupleType ) o ; return types . equals ( that . types ) ; } @Override public CQL3Type asCQL3Type ( ) { return CQL3Type . Tuple . create ( this ) ; } @Override public String toString ( ) { return getClass ( ) . getName ( ) + TypeParser . stringifyTypeParameters ( types , true ) ; } } 
