package org . apache . cassandra . db . compaction . writers ; import java . io . File ; import java . util . Arrays ; import java . util . Set ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . RowIndexEntry ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableWriter ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; public class SplittingSizeTieredCompactionWriter extends CompactionAwareWriter { private static final Logger logger = LoggerFactory . getLogger ( SplittingSizeTieredCompactionWriter . class ) ; public static final long DEFAULT_SMALLEST_SSTABLE_BYTES = <int> ; private final double [ ] ratios ; private final long totalSize ; private final Set < SSTableReader > allSSTables ; private long currentBytesToWrite ; private int currentRatioIndex = <int> ; public SplittingSizeTieredCompactionWriter ( ColumnFamilyStore cfs , Directories directories , LifecycleTransaction txn , Set < SSTableReader > nonExpiredSSTables ) { this ( cfs , directories , txn , nonExpiredSSTables , DEFAULT_SMALLEST_SSTABLE_BYTES ) ; } @SuppressWarnings ( <str> ) public SplittingSizeTieredCompactionWriter ( ColumnFamilyStore cfs , Directories directories , LifecycleTransaction txn , Set < SSTableReader > nonExpiredSSTables , long smallestSSTable ) { super ( cfs , directories , txn , nonExpiredSSTables , false , false ) ; this . allSSTables = txn . originals ( ) ; totalSize = cfs . getExpectedCompactedFileSize ( nonExpiredSSTables , txn . opType ( ) ) ; double [ ] potentialRatios = new double [ <int> ] ; double currentRatio = <int> ; for ( int i = <int> ; i < potentialRatios . length ; i + + ) { currentRatio / = <int> ; potentialRatios [ i ] = currentRatio ; } int noPointIndex = <int> ; for ( double ratio : potentialRatios ) { noPointIndex + + ; if ( ratio * totalSize < smallestSSTable ) { break ; } } ratios = Arrays . copyOfRange ( potentialRatios , <int> , noPointIndex ) ; long currentPartitionsToWrite = Math . round ( estimatedTotalKeys * ratios [ currentRatioIndex ] ) ; currentBytesToWrite = Math . round ( totalSize * ratios [ currentRatioIndex ] ) ; switchCompactionLocation ( getWriteDirectory ( currentBytesToWrite ) ) ; logger . trace ( <str> , ratios , estimatedTotalKeys , totalSize , currentPartitionsToWrite , currentBytesToWrite ) ; } @Override public boolean realAppend ( UnfilteredRowIterator partition ) { RowIndexEntry rie = sstableWriter . append ( partition ) ; if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > currentBytesToWrite & & currentRatioIndex < ratios . length - <int> ) { currentRatioIndex + + ; currentBytesToWrite = Math . round ( totalSize * ratios [ currentRatioIndex ] ) ; switchCompactionLocation ( getWriteDirectory ( Math . round ( totalSize * ratios [ currentRatioIndex ] ) ) ) ; } return rie ! = null ; } public void switchCompactionLocation ( Directories . DataDirectory location ) { long currentPartitionsToWrite = Math . round ( ratios [ currentRatioIndex ] * estimatedTotalKeys ) ; @SuppressWarnings ( <str> ) SSTableWriter writer = SSTableWriter . create ( Descriptor . fromFilename ( cfs . getSSTablePath ( getDirectories ( ) . getLocationForDisk ( location ) ) ) , currentPartitionsToWrite , minRepairedAt , cfs . metadata , new MetadataCollector ( allSSTables , cfs . metadata . comparator , <int> ) , SerializationHeader . make ( cfs . metadata , nonExpiredSSTables ) , cfs . indexManager . listIndexes ( ) , txn ) ; logger . trace ( <str> , currentPartitionsToWrite ) ; sstableWriter . switchWriter ( writer ) ; } } 
