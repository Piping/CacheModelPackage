package org . elasticsearch . search . aggregations ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import org . elasticsearch . search . aggregations . support . AggregationPath . PathElement ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class AggregatorFactories { public static final AggregatorFactories EMPTY = new Empty ( ) ; private AggregatorFactory parent ; private AggregatorFactory [ ] factories ; private List < PipelineAggregatorFactory > pipelineAggregatorFactories ; public static Builder builder ( ) { return new Builder ( ) ; } private AggregatorFactories ( AggregatorFactory [ ] factories , List < PipelineAggregatorFactory > pipelineAggregators ) { this . factories = factories ; this . pipelineAggregatorFactories = pipelineAggregators ; } public List < PipelineAggregator > createPipelineAggregators ( ) throws IOException { List < PipelineAggregator > pipelineAggregators = new ArrayList < > ( ) ; for ( PipelineAggregatorFactory factory : this . pipelineAggregatorFactories ) { pipelineAggregators . add ( factory . create ( ) ) ; } return pipelineAggregators ; } public Aggregator [ ] createSubAggregators ( Aggregator parent ) throws IOException { Aggregator [ ] aggregators = new Aggregator [ count ( ) ] ; for ( int i = <int> ; i < factories . length ; + + i ) { final boolean collectsFromSingleBucket = false ; aggregators [ i ] = factories [ i ] . create ( parent . context ( ) , parent , collectsFromSingleBucket ) ; } return aggregators ; } public Aggregator [ ] createTopLevelAggregators ( AggregationContext ctx ) throws IOException { Aggregator [ ] aggregators = new Aggregator [ factories . length ] ; for ( int i = <int> ; i < factories . length ; i + + ) { final boolean collectsFromSingleBucket = true ; aggregators [ i ] = factories [ i ] . create ( ctx , null , collectsFromSingleBucket ) ; } return aggregators ; } public int count ( ) { return factories . length ; } void setParent ( AggregatorFactory parent ) { this . parent = parent ; for ( AggregatorFactory factory : factories ) { factory . parent = parent ; } } public void validate ( ) { for ( AggregatorFactory factory : factories ) { factory . validate ( ) ; } for ( PipelineAggregatorFactory factory : pipelineAggregatorFactories ) { factory . validate ( parent , factories , pipelineAggregatorFactories ) ; } } private final static class Empty extends AggregatorFactories { private static final AggregatorFactory [ ] EMPTY_FACTORIES = new AggregatorFactory [ <int> ] ; private static final Aggregator [ ] EMPTY_AGGREGATORS = new Aggregator [ <int> ] ; private static final List < PipelineAggregatorFactory > EMPTY_PIPELINE_AGGREGATORS = new ArrayList < > ( ) ; private Empty ( ) { super ( EMPTY_FACTORIES , EMPTY_PIPELINE_AGGREGATORS ) ; } @Override public Aggregator [ ] createSubAggregators ( Aggregator parent ) { return EMPTY_AGGREGATORS ; } @Override public Aggregator [ ] createTopLevelAggregators ( AggregationContext ctx ) { return EMPTY_AGGREGATORS ; } } public static class Builder { private final Set < String > names = new HashSet < > ( ) ; private final List < AggregatorFactory > factories = new ArrayList < > ( ) ; private final List < PipelineAggregatorFactory > pipelineAggregatorFactories = new ArrayList < > ( ) ; public Builder addAggregator ( AggregatorFactory factory ) { if ( ! names . add ( factory . name ) ) { throw new IllegalArgumentException ( <str> + factory . name + <str> ) ; } factories . add ( factory ) ; return this ; } public Builder addPipelineAggregator ( PipelineAggregatorFactory pipelineAggregatorFactory ) { this . pipelineAggregatorFactories . add ( pipelineAggregatorFactory ) ; return this ; } public AggregatorFactories build ( ) { if ( factories . isEmpty ( ) & & pipelineAggregatorFactories . isEmpty ( ) ) { return EMPTY ; } List < PipelineAggregatorFactory > orderedpipelineAggregators = resolvePipelineAggregatorOrder ( this . pipelineAggregatorFactories , this . factories ) ; return new AggregatorFactories ( factories . toArray ( new AggregatorFactory [ factories . size ( ) ] ) , orderedpipelineAggregators ) ; } private List < PipelineAggregatorFactory > resolvePipelineAggregatorOrder ( List < PipelineAggregatorFactory > pipelineAggregatorFactories , List < AggregatorFactory > aggFactories ) { Map < String , PipelineAggregatorFactory > pipelineAggregatorFactoriesMap = new HashMap < > ( ) ; for ( PipelineAggregatorFactory factory : pipelineAggregatorFactories ) { pipelineAggregatorFactoriesMap . put ( factory . getName ( ) , factory ) ; } Map < String , AggregatorFactory > aggFactoriesMap = new HashMap < > ( ) ; for ( AggregatorFactory aggFactory : aggFactories ) { aggFactoriesMap . put ( aggFactory . name , aggFactory ) ; } List < PipelineAggregatorFactory > orderedPipelineAggregatorrs = new LinkedList < > ( ) ; List < PipelineAggregatorFactory > unmarkedFactories = new ArrayList < PipelineAggregatorFactory > ( pipelineAggregatorFactories ) ; Set < PipelineAggregatorFactory > temporarilyMarked = new HashSet < PipelineAggregatorFactory > ( ) ; while ( ! unmarkedFactories . isEmpty ( ) ) { PipelineAggregatorFactory factory = unmarkedFactories . get ( <int> ) ; resolvePipelineAggregatorOrder ( aggFactoriesMap , pipelineAggregatorFactoriesMap , orderedPipelineAggregatorrs , unmarkedFactories , temporarilyMarked , factory ) ; } return orderedPipelineAggregatorrs ; } private void resolvePipelineAggregatorOrder ( Map < String , AggregatorFactory > aggFactoriesMap , Map < String , PipelineAggregatorFactory > pipelineAggregatorFactoriesMap , List < PipelineAggregatorFactory > orderedPipelineAggregators , List < PipelineAggregatorFactory > unmarkedFactories , Set < PipelineAggregatorFactory > temporarilyMarked , PipelineAggregatorFactory factory ) { if ( temporarilyMarked . contains ( factory ) ) { throw new IllegalArgumentException ( <str> + factory . getName ( ) + <str> ) ; } else if ( unmarkedFactories . contains ( factory ) ) { temporarilyMarked . add ( factory ) ; String [ ] bucketsPaths = factory . getBucketsPaths ( ) ; for ( String bucketsPath : bucketsPaths ) { List < AggregationPath . PathElement > bucketsPathElements = AggregationPath . parse ( bucketsPath ) . getPathElements ( ) ; String firstAggName = bucketsPathElements . get ( <int> ) . name ; if ( bucketsPath . equals ( <str> ) | | bucketsPath . equals ( <str> ) ) { continue ; } else if ( aggFactoriesMap . containsKey ( firstAggName ) ) { AggregatorFactory aggFactory = aggFactoriesMap . get ( firstAggName ) ; for ( int i = <int> ; i < bucketsPathElements . size ( ) ; i + + ) { PathElement pathElement = bucketsPathElements . get ( i ) ; String aggName = pathElement . name ; if ( ( i = = bucketsPathElements . size ( ) - <int> ) & & ( aggName . equalsIgnoreCase ( <str> ) | | aggName . equals ( <str> ) ) ) { break ; } else { AggregatorFactory [ ] subFactories = aggFactory . factories . factories ; boolean foundSubFactory = false ; for ( AggregatorFactory subFactory : subFactories ) { if ( aggName . equals ( subFactory . name ) ) { aggFactory = subFactory ; foundSubFactory = true ; break ; } } if ( ! foundSubFactory & & ( i = = bucketsPathElements . size ( ) - <int> ) ) { List < PipelineAggregatorFactory > subPipelineFactories = aggFactory . factories . pipelineAggregatorFactories ; for ( PipelineAggregatorFactory subFactory : subPipelineFactories ) { if ( aggName . equals ( subFactory . name ( ) ) ) { foundSubFactory = true ; break ; } } } if ( ! foundSubFactory ) { throw new IllegalArgumentException ( <str> + aggName + <str> + bucketsPath + <str> ) ; } } } continue ; } else { PipelineAggregatorFactory matchingFactory = pipelineAggregatorFactoriesMap . get ( firstAggName ) ; if ( matchingFactory ! = null ) { resolvePipelineAggregatorOrder ( aggFactoriesMap , pipelineAggregatorFactoriesMap , orderedPipelineAggregators , unmarkedFactories , temporarilyMarked , matchingFactory ) ; } else { throw new IllegalArgumentException ( <str> + bucketsPath + <str> ) ; } } } unmarkedFactories . remove ( factory ) ; temporarilyMarked . remove ( factory ) ; orderedPipelineAggregators . add ( factory ) ; } } AggregatorFactory [ ] getAggregatorFactories ( ) { return this . factories . toArray ( new AggregatorFactory [ this . factories . size ( ) ] ) ; } List < PipelineAggregatorFactory > getPipelineAggregatorFactories ( ) { return this . pipelineAggregatorFactories ; } } } 
