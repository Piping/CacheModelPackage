package org . eclipse . debug . internal . ui . viewers . model ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ICheckboxModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy2 ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxyFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxyFactory2 ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStateUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . TreeModelViewerFilter ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . widgets . Display ; public class TreeModelContentProvider implements ITreeModelContentProvider , IContentProvider , IModelChangedListener { private IInternalTreeModelViewer fViewer ; private int fModelDeltaMask = ~ <int> ; private Map < TreePath , IModelProxy > fTreeModelProxies = new HashMap < TreePath , IModelProxy > ( ) ; private Map < Object , IModelProxy > fModelProxies = new HashMap < Object , IModelProxy > ( ) ; private FilterTransform fTransform = new FilterTransform ( ) ; private ListenerList fModelListeners = new ListenerList ( ) ; private ListenerList fUpdateListeners = new ListenerList ( ) ; private boolean fModelSequenceRunning = false ; private Map < TreePath , List < ViewerUpdateMonitor > > fRequestsInProgress = new HashMap < TreePath , List < ViewerUpdateMonitor > > ( ) ; private Map < TreePath , List < ViewerUpdateMonitor > > fWaitingRequests = new HashMap < TreePath , List < ViewerUpdateMonitor > > ( ) ; private List < ViewerUpdateMonitor > fCompletedUpdates = new ArrayList < ViewerUpdateMonitor > ( ) ; private Runnable fCompletedUpdatesRunnable ; private ViewerStateTracker fStateTracker = new ViewerStateTracker ( this ) ; private TreePath fRevealPath ; private int fRevealIndex ; static final int UPDATE_SEQUENCE_BEGINS = <int> ; static final int UPDATE_SEQUENCE_COMPLETE = <int> ; static final int UPDATE_BEGINS = <int> ; static final int UPDATE_COMPLETE = <int> ; static final TreePath EMPTY_TREE_PATH = new TreePath ( new Object [ ] { } ) ; @Override public void dispose ( ) { if ( fViewer = = null ) { return ; } Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; for ( List < ViewerUpdateMonitor > requests : fRequestsInProgress . values ( ) ) { for ( ViewerUpdateMonitor vu : requests ) { vu . cancel ( ) ; } } fWaitingRequests . clear ( ) ; fStateTracker . dispose ( ) ; fModelListeners . clear ( ) ; fUpdateListeners . clear ( ) ; disposeAllModelProxies ( ) ; synchronized ( this ) { fViewer = null ; } } boolean isDisposed ( ) { synchronized ( this ) { return fViewer = = null ; } } @Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { synchronized ( this ) { fViewer = ( IInternalTreeModelViewer ) viewer ; } Assert . isTrue ( fViewer . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( oldInput ! = null ) { fStateTracker . saveViewerState ( oldInput ) ; } } @Override public void postInputChanged ( IInternalTreeModelViewer viewer , Object oldInput , Object newInput ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; cancelSubtreeUpdates ( TreePath . EMPTY ) ; disposeAllModelProxies ( ) ; cancelSubtreeUpdates ( TreePath . EMPTY ) ; fTransform . clear ( ) ; if ( newInput ! = null ) { installModelProxy ( newInput , TreePath . EMPTY ) ; fStateTracker . restoreViewerState ( newInput ) ; } } @Override public void addViewerUpdateListener ( IViewerUpdateListener listener ) { fUpdateListeners . add ( listener ) ; } @Override public void removeViewerUpdateListener ( IViewerUpdateListener listener ) { fUpdateListeners . remove ( listener ) ; } @Override public void addStateUpdateListener ( IStateUpdateListener listener ) { fStateTracker . addStateUpdateListener ( listener ) ; } @Override public void preserveState ( TreePath path ) { fStateTracker . appendToPendingStateDelta ( path ) ; } @Override public void removeStateUpdateListener ( IStateUpdateListener listener ) { fStateTracker . removeStateUpdateListener ( listener ) ; } @Override public void addModelChangedListener ( IModelChangedListener listener ) { fModelListeners . add ( listener ) ; } @Override public void removeModelChangedListener ( IModelChangedListener listener ) { fModelListeners . remove ( listener ) ; } @Override public void cancelRestore ( final TreePath path , final int flags ) { fStateTracker . cancelRestore ( path , flags ) ; } @Override public boolean setChecked ( TreePath path , boolean checked ) { IModelProxy elementProxy = getElementProxy ( path ) ; if ( elementProxy instanceof ICheckboxModelProxy ) { return ( ( ICheckboxModelProxy ) elementProxy ) . setChecked ( getPresentationContext ( ) , getViewer ( ) . getInput ( ) , path , checked ) ; } return false ; } private void installModelProxy ( Object input , TreePath path ) { if ( ! fTreeModelProxies . containsKey ( path ) & & ! fModelProxies . containsKey ( path . getLastSegment ( ) ) ) { Object element = path . getSegmentCount ( ) ! = <int> ? path . getLastSegment ( ) : input ; IModelProxy proxy = null ; IModelProxyFactory2 modelProxyFactory2 = ViewerAdapterService . getModelProxyFactory2 ( element ) ; if ( modelProxyFactory2 ! = null ) { proxy = modelProxyFactory2 . createTreeModelProxy ( input , path , getPresentationContext ( ) ) ; if ( proxy ! = null ) { fTreeModelProxies . put ( path , proxy ) ; } } if ( proxy = = null ) { IModelProxyFactory modelProxyFactory = ViewerAdapterService . getModelProxyFactory ( element ) ; if ( modelProxyFactory ! = null ) { proxy = modelProxyFactory . createModelProxy ( element , getPresentationContext ( ) ) ; if ( proxy ! = null ) { fModelProxies . put ( element , proxy ) ; } } } if ( proxy instanceof IModelProxy2 ) { proxy . addModelChangedListener ( this ) ; ( ( IModelProxy2 ) proxy ) . initialize ( getViewer ( ) ) ; } else if ( proxy ! = null ) { final IModelProxy finalProxy = proxy ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { IPresentationContext context = null ; Viewer viewer = null ; synchronized ( TreeModelContentProvider . this ) { if ( ! isDisposed ( ) ) { context = getPresentationContext ( ) ; viewer = ( Viewer ) getViewer ( ) ; } } if ( viewer ! = null & & context ! = null & & ! finalProxy . isDisposed ( ) ) { finalProxy . init ( context ) ; finalProxy . addModelChangedListener ( TreeModelContentProvider . this ) ; finalProxy . installed ( viewer ) ; } } return Status . OK_STATUS ; } @Override public boolean shouldRun ( ) { return ! isDisposed ( ) ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } } private IModelProxy getElementProxy ( TreePath path ) { while ( path ! = null ) { IModelProxy proxy = fTreeModelProxies . get ( path ) ; if ( proxy ! = null ) { return proxy ; } Object element = path . getSegmentCount ( ) = = <int> ? getViewer ( ) . getInput ( ) : path . getLastSegment ( ) ; proxy = fModelProxies . get ( element ) ; if ( proxy ! = null ) { return proxy ; } path = path . getParentPath ( ) ; } return null ; } private void disposeAllModelProxies ( ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; for ( IModelProxy proxy : fModelProxies . values ( ) ) { proxy . dispose ( ) ; } fModelProxies . clear ( ) ; for ( IModelProxy proxy : fTreeModelProxies . values ( ) ) { proxy . dispose ( ) ; } fTreeModelProxies . clear ( ) ; } private void disposeModelProxy ( TreePath path ) { IModelProxy proxy = fTreeModelProxies . remove ( path ) ; if ( proxy ! = null ) { proxy . dispose ( ) ; } proxy = fModelProxies . remove ( path . getLastSegment ( ) ) ; if ( proxy ! = null ) { proxy . dispose ( ) ; } } @Override public void modelChanged ( final IModelDelta delta , final IModelProxy proxy ) { Display display = null ; synchronized ( this ) { if ( fViewer ! = null & & ! proxy . isDisposed ( ) ) { display = fViewer . getDisplay ( ) ; } } if ( display ! = null ) { if ( Thread . currentThread ( ) . equals ( display . getThread ( ) ) ) { doModelChanged ( delta , proxy ) ; } else { fViewer . getDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { doModelChanged ( delta , proxy ) ; } } ) ; } } } private void doModelChanged ( IModelDelta delta , IModelProxy proxy ) { if ( ! proxy . isDisposed ( ) ) { if ( DebugUIPlugin . DEBUG_DELTAS & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . toString ( ) ) ; } updateModel ( delta , getModelDeltaMask ( ) ) ; trigger ( null ) ; Object [ ] listeners = fModelListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { ( ( IModelChangedListener ) listeners [ i ] ) . modelChanged ( delta , proxy ) ; } } } @Override public void setModelDeltaMask ( int mask ) { fModelDeltaMask = mask ; } @Override public int getModelDeltaMask ( ) { return fModelDeltaMask ; } @Override public void updateModel ( IModelDelta delta , int mask ) { if ( getViewer ( ) = = null | | getViewer ( ) . getInput ( ) = = null ) { return ; } fRevealPath = null ; IModelDelta [ ] deltaArray = new IModelDelta [ ] { delta } ; updateNodes ( deltaArray , mask & ( IModelDelta . REMOVED | IModelDelta . UNINSTALL ) ) ; updateNodes ( deltaArray , mask & ITreeModelContentProvider . UPDATE_MODEL_DELTA_FLAGS & ~ ( IModelDelta . REMOVED | IModelDelta . UNINSTALL ) ) ; updateNodes ( deltaArray , mask & ITreeModelContentProvider . CONTROL_MODEL_DELTA_FLAGS ) ; fStateTracker . checkIfRestoreComplete ( ) ; } TreePath getFullTreePath ( IModelDelta node ) { ArrayList < Object > list = new ArrayList < Object > ( ) ; while ( node . getParentDelta ( ) ! = null ) { list . add ( <int> , node . getElement ( ) ) ; node = node . getParentDelta ( ) ; } return new TreePath ( list . toArray ( ) ) ; } TreePath getViewerTreePath ( IModelDelta node ) { ArrayList < Object > list = new ArrayList < Object > ( ) ; IModelDelta parentDelta = node . getParentDelta ( ) ; while ( parentDelta ! = null ) { list . add ( <int> , node . getElement ( ) ) ; node = parentDelta ; parentDelta = node . getParentDelta ( ) ; } return new TreePath ( list . toArray ( ) ) ; } protected IInternalTreeModelViewer getViewer ( ) { synchronized ( this ) { return fViewer ; } } @Override public int viewToModelIndex ( TreePath parentPath , int index ) { return fTransform . viewToModelIndex ( parentPath , index ) ; } @Override public int viewToModelCount ( TreePath parentPath , int count ) { return fTransform . viewToModelCount ( parentPath , count ) ; } @Override public int modelToViewIndex ( TreePath parentPath , int index ) { return fTransform . modelToViewIndex ( parentPath , index ) ; } @Override public int modelToViewChildCount ( TreePath parentPath , int count ) { return fTransform . modelToViewCount ( parentPath , count ) ; } @Override public boolean areTreeModelViewerFiltersApplicable ( Object parentElement ) { ViewerFilter [ ] filters = fViewer . getFilters ( ) ; if ( filters . length > <int> ) { for ( int j = <int> ; j < filters . length ; j + + ) { if ( filters [ j ] instanceof TreeModelViewerFilter & & ( ( TreeModelViewerFilter ) filters [ j ] ) . isApplicable ( fViewer , parentElement ) ) { return true ; } } } return false ; } @Override public boolean shouldFilter ( Object parentElementOrTreePath , Object element ) { ViewerFilter [ ] filters = fViewer . getFilters ( ) ; if ( filters . length > <int> ) { for ( int j = <int> ; j < filters . length ; j + + ) { if ( filters [ j ] instanceof TreeModelViewerFilter ) { Object parentElement = parentElementOrTreePath instanceof TreePath ? ( ( TreePath ) parentElementOrTreePath ) . getLastSegment ( ) : parentElementOrTreePath ; if ( parentElement = = null ) { parentElement = fViewer . getInput ( ) ; } if ( ! ( ( TreeModelViewerFilter ) filters [ j ] ) . isApplicable ( fViewer , parentElement ) ) { continue ; } } if ( ! ( filters [ j ] . select ( ( Viewer ) fViewer , parentElementOrTreePath , element ) ) ) { return true ; } } } return false ; } @Override public void unmapPath ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fTransform . clear ( path ) ; cancelSubtreeUpdates ( path ) ; } boolean addFilteredIndex ( TreePath parentPath , int index , Object element ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; return fTransform . addFilteredIndex ( parentPath , index , element ) ; } void removeElementFromFilters ( TreePath parentPath , int index ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fTransform . removeElementFromFilters ( parentPath , index ) ; } boolean removeElementFromFilters ( TreePath parentPath , Object element ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; return fTransform . removeElementFromFilters ( parentPath , element ) ; } void setModelChildCount ( TreePath parentPath , int childCount ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fTransform . setModelChildCount ( parentPath , childCount ) ; } boolean isFiltered ( TreePath parentPath , int index ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; return fTransform . isFiltered ( parentPath , index ) ; } int [ ] getFilteredChildren ( TreePath parent ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; return fTransform . getFilteredChildren ( parent ) ; } void clearFilteredChild ( TreePath parent , int modelIndex ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fTransform . clear ( parent , modelIndex ) ; } void clearFilters ( TreePath parent ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fTransform . clear ( parent ) ; } void updateStarted ( ViewerUpdateMonitor update ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; List < ViewerUpdateMonitor > requests = fRequestsInProgress . get ( update . getSchedulingPath ( ) ) ; if ( requests = = null ) { requests = new ArrayList < ViewerUpdateMonitor > ( ) ; fRequestsInProgress . put ( update . getSchedulingPath ( ) , requests ) ; } requests . add ( update ) ; if ( ! fModelSequenceRunning ) { fModelSequenceRunning = true ; if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } notifyUpdate ( UPDATE_SEQUENCE_BEGINS , null ) ; } if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + update ) ; } notifyUpdate ( UPDATE_BEGINS , update ) ; } void updatesComplete ( final List < ViewerUpdateMonitor > updates ) { for ( int i = <int> ; i < updates . size ( ) ; i + + ) { ViewerUpdateMonitor update = updates . get ( i ) ; notifyUpdate ( UPDATE_COMPLETE , update ) ; if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + update ) ; } } getViewer ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } for ( int i = <int> ; i < updates . size ( ) ; i + + ) { ViewerUpdateMonitor update = updates . get ( i ) ; List < ViewerUpdateMonitor > requests = fRequestsInProgress . get ( update . getSchedulingPath ( ) ) ; boolean found = false ; if ( requests ! = null ) { for ( int j = <int> ; j < requests . size ( ) ; j + + ) { if ( requests . get ( j ) = = update ) { found = true ; requests . remove ( j ) ; break ; } } } if ( found ) { trigger ( update . getSchedulingPath ( ) ) ; } else { Assert . isTrue ( update . isCanceled ( ) ) ; } if ( requests ! = null & & requests . isEmpty ( ) ) { fRequestsInProgress . remove ( update . getSchedulingPath ( ) ) ; } } if ( fRequestsInProgress . isEmpty ( ) & & fWaitingRequests . isEmpty ( ) & & fModelSequenceRunning ) { fModelSequenceRunning = false ; if ( fRevealPath ! = null ) { getViewer ( ) . reveal ( fRevealPath , fRevealIndex ) ; fRevealPath = null ; } if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } notifyUpdate ( UPDATE_SEQUENCE_COMPLETE , null ) ; } } } ) ; } boolean areRequestsPending ( ) { return ! fRequestsInProgress . isEmpty ( ) | | ! fWaitingRequests . isEmpty ( ) ; } ViewerStateTracker getStateTracker ( ) { return fStateTracker ; } private void notifyUpdate ( final int type , final IViewerUpdate update ) { if ( ! fUpdateListeners . isEmpty ( ) ) { Object [ ] listeners = fUpdateListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { final IViewerUpdateListener listener = ( IViewerUpdateListener ) listeners [ i ] ; SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { switch ( type ) { case UPDATE_SEQUENCE_BEGINS : listener . viewerUpdatesBegin ( ) ; break ; case UPDATE_SEQUENCE_COMPLETE : listener . viewerUpdatesComplete ( ) ; break ; case UPDATE_BEGINS : listener . updateStarted ( update ) ; break ; case UPDATE_COMPLETE : listener . updateComplete ( update ) ; break ; default : break ; } } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } private void cancelSubtreeUpdates ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; for ( Entry < TreePath , List < ViewerUpdateMonitor > > entry : fRequestsInProgress . entrySet ( ) ) { TreePath entryPath = entry . getKey ( ) ; if ( entryPath . startsWith ( path , null ) ) { List < ViewerUpdateMonitor > requests = entry . getValue ( ) ; Iterator < ViewerUpdateMonitor > reqIter = requests . iterator ( ) ; while ( reqIter . hasNext ( ) ) { reqIter . next ( ) . cancel ( ) ; reqIter . remove ( ) ; } } } List < TreePath > purge = new ArrayList < TreePath > ( ) ; for ( TreePath entryPath : fWaitingRequests . keySet ( ) ) { if ( entryPath . startsWith ( path , null ) ) { purge . add ( entryPath ) ; } } for ( TreePath tp : purge ) { fWaitingRequests . remove ( tp ) ; } fStateTracker . cancelStateSubtreeUpdates ( path ) ; } private void schedule ( final ViewerUpdateMonitor update ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; TreePath schedulingPath = update . getSchedulingPath ( ) ; List < ViewerUpdateMonitor > requests = fWaitingRequests . get ( schedulingPath ) ; if ( requests = = null ) { requests = new LinkedList < ViewerUpdateMonitor > ( ) ; requests . add ( update ) ; fWaitingRequests . put ( schedulingPath , requests ) ; List < ViewerUpdateMonitor > inProgressList = fRequestsInProgress . get ( schedulingPath ) ; if ( inProgressList ! = null ) { int staleUpdateIndex = inProgressList . indexOf ( update ) ; if ( staleUpdateIndex > = <int> ) { ViewerUpdateMonitor staleUpdate = inProgressList . remove ( staleUpdateIndex ) ; staleUpdate . cancel ( ) ; } } if ( inProgressList = = null | | inProgressList . isEmpty ( ) ) { getViewer ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } trigger ( update . getSchedulingPath ( ) ) ; } } ) ; } } else { requests . add ( coalesce ( requests , update ) ) ; } } private ViewerUpdateMonitor coalesce ( List < ViewerUpdateMonitor > requests , ViewerUpdateMonitor toCoalesce ) { for ( ViewerUpdateMonitor waiting : requests ) { if ( waiting . coalesce ( toCoalesce ) ) { requests . remove ( waiting ) ; return coalesce ( requests , waiting ) ; } } return toCoalesce ; } boolean areChildrenUpdatesPending ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; List < ViewerUpdateMonitor > requests = fWaitingRequests . get ( path ) ; if ( requests ! = null ) { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { if ( requests . get ( i ) instanceof ChildrenUpdate ) { return true ; } } } requests = fRequestsInProgress . get ( path ) ; if ( requests ! = null ) { int numChildrenUpdateRequests = <int> ; for ( int i = <int> ; i < requests . size ( ) ; i + + ) { if ( requests . get ( i ) instanceof ChildrenUpdate ) { if ( + + numChildrenUpdateRequests > <int> ) { return true ; } } } } return false ; } private void trigger ( TreePath schedulingPath ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( fWaitingRequests . isEmpty ( ) ) { return ; } List < ViewerUpdateMonitor > waiting = fWaitingRequests . get ( schedulingPath ) ; if ( waiting = = null ) { int length = Integer . MAX_VALUE ; Entry < TreePath , List < ViewerUpdateMonitor > > candidate = null ; for ( Entry < TreePath , List < ViewerUpdateMonitor > > entry : fWaitingRequests . entrySet ( ) ) { TreePath key = entry . getKey ( ) ; if ( key . getSegmentCount ( ) < length & & ! isRequestBlocked ( key ) ) { candidate = entry ; length = key . getSegmentCount ( ) ; } } if ( candidate ! = null ) { startHighestPriorityRequest ( candidate . getKey ( ) , candidate . getValue ( ) ) ; } } else if ( ! isRequestBlocked ( schedulingPath ) ) { startHighestPriorityRequest ( schedulingPath , waiting ) ; } } private boolean isRequestBlocked ( TreePath requestPath ) { TreePath parentPath = requestPath ; List < ViewerUpdateMonitor > parentRequests = fRequestsInProgress . get ( parentPath ) ; while ( parentRequests = = null | | parentRequests . isEmpty ( ) ) { parentPath = parentPath . getParentPath ( ) ; if ( parentPath = = null ) { return false ; } parentRequests = fRequestsInProgress . get ( parentPath ) ; } return true ; } private void startHighestPriorityRequest ( TreePath key , List < ViewerUpdateMonitor > waiting ) { int priority = <int> ; ViewerUpdateMonitor next = null ; for ( ViewerUpdateMonitor vu : waiting ) { if ( vu . getPriority ( ) < priority ) { next = vu ; priority = next . getPriority ( ) ; } } if ( next ! = null ) { waiting . remove ( next ) ; if ( waiting . isEmpty ( ) ) { fWaitingRequests . remove ( key ) ; } next . start ( ) ; } } protected Object getElement ( TreePath path ) { if ( path . getSegmentCount ( ) > <int> ) { return path . getLastSegment ( ) ; } return getViewer ( ) . getInput ( ) ; } private void rescheduleUpdates ( TreePath parentPath , int modelIndex ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; List < ViewerUpdateMonitor > requests = fRequestsInProgress . get ( parentPath ) ; List < IChildrenUpdate > reCreate = null ; if ( requests ! = null ) { Iterator < ViewerUpdateMonitor > iterator = requests . iterator ( ) ; while ( iterator . hasNext ( ) ) { ViewerUpdateMonitor update = iterator . next ( ) ; if ( update instanceof IChildrenUpdate ) { IChildrenUpdate childrenUpdate = ( IChildrenUpdate ) update ; if ( childrenUpdate . getOffset ( ) > modelIndex ) { childrenUpdate . cancel ( ) ; iterator . remove ( ) ; if ( reCreate = = null ) { reCreate = new ArrayList < IChildrenUpdate > ( ) ; } reCreate . add ( childrenUpdate ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + childrenUpdate ) ; } } } } } requests = fWaitingRequests . get ( parentPath ) ; if ( requests ! = null ) { for ( ViewerUpdateMonitor update : requests ) { if ( update instanceof IChildrenUpdate ) { IChildrenUpdate childrenUpdate = ( IChildrenUpdate ) update ; if ( childrenUpdate . getOffset ( ) > modelIndex ) { ( ( ChildrenUpdate ) childrenUpdate ) . setOffset ( childrenUpdate . getOffset ( ) - <int> ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + childrenUpdate ) ; } } } } } if ( reCreate ! = null ) { for ( IChildrenUpdate childrenUpdate : reCreate ) { int start = childrenUpdate . getOffset ( ) - <int> ; int end = start + childrenUpdate . getLength ( ) ; for ( int i = start ; i < end ; i + + ) { doUpdateElement ( parentPath , i ) ; } } } } private void doUpdateChildCount ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; Object element = getElement ( path ) ; IElementContentProvider contentAdapter = ViewerAdapterService . getContentProvider ( element ) ; if ( contentAdapter ! = null ) { ChildrenCountUpdate request = new ChildrenCountUpdate ( this , getViewer ( ) . getInput ( ) , path , element , contentAdapter ) ; schedule ( request ) ; } } void doUpdateElement ( TreePath parentPath , int modelIndex ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; Object parent = getElement ( parentPath ) ; IElementContentProvider contentAdapter = ViewerAdapterService . getContentProvider ( parent ) ; if ( contentAdapter ! = null ) { ChildrenUpdate request = new ChildrenUpdate ( this , getViewer ( ) . getInput ( ) , parentPath , parent , modelIndex , contentAdapter ) ; schedule ( request ) ; } } private void doUpdateHasChildren ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; Object element = getElement ( path ) ; IElementContentProvider contentAdapter = ViewerAdapterService . getContentProvider ( element ) ; if ( contentAdapter ! = null ) { HasChildrenUpdate request = new HasChildrenUpdate ( this , getViewer ( ) . getInput ( ) , path , element , contentAdapter ) ; schedule ( request ) ; } } boolean areElementUpdatesPending ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; TreePath parentPath = path . getParentPath ( ) ; List < ViewerUpdateMonitor > requests = fWaitingRequests . get ( path ) ; if ( requests ! = null ) { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { ViewerUpdateMonitor update = requests . get ( i ) ; if ( update instanceof ChildrenUpdate ) { return true ; } } } requests = fWaitingRequests . get ( parentPath ) ; if ( requests ! = null ) { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { ViewerUpdateMonitor update = requests . get ( i ) ; if ( update . containsUpdate ( path ) ) { return true ; } } } requests = fRequestsInProgress . get ( path ) ; if ( requests ! = null ) { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { ViewerUpdateMonitor update = requests . get ( i ) ; if ( update instanceof ChildrenUpdate ) { return true ; } } } requests = fRequestsInProgress . get ( parentPath ) ; if ( requests ! = null ) { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { ViewerUpdateMonitor update = requests . get ( i ) ; if ( update . getElement ( ) . equals ( path . getLastSegment ( ) ) ) { return true ; } } } return false ; } protected IPresentationContext getPresentationContext ( ) { ITreeModelViewer viewer = getViewer ( ) ; if ( viewer ! = null ) { return viewer . getPresentationContext ( ) ; } return null ; } protected void updateNodes ( IModelDelta [ ] nodes , int mask ) { for ( int i = <int> ; i < nodes . length ; i + + ) { IModelDelta node = nodes [ i ] ; int flags = node . getFlags ( ) & mask ; if ( ( flags & IModelDelta . ADDED ) ! = <int> ) { handleAdd ( node ) ; } if ( ( flags & IModelDelta . REMOVED ) ! = <int> ) { handleRemove ( node ) ; } if ( ( flags & IModelDelta . CONTENT ) ! = <int> ) { handleContent ( node ) ; } if ( ( flags & IModelDelta . STATE ) ! = <int> ) { handleState ( node ) ; } if ( ( flags & IModelDelta . INSERTED ) ! = <int> ) { handleInsert ( node ) ; } if ( ( flags & IModelDelta . REPLACED ) ! = <int> ) { handleReplace ( node ) ; } if ( ( flags & IModelDelta . INSTALL ) ! = <int> ) { handleInstall ( node ) ; } if ( ( flags & IModelDelta . UNINSTALL ) ! = <int> ) { handleUninstall ( node ) ; } if ( ( flags & IModelDelta . EXPAND ) ! = <int> ) { handleExpand ( node ) ; } if ( ( flags & IModelDelta . COLLAPSE ) ! = <int> ) { handleCollapse ( node ) ; } if ( ( flags & IModelDelta . SELECT ) ! = <int> ) { handleSelect ( node ) ; } if ( ( flags & IModelDelta . REVEAL ) ! = <int> ) { handleReveal ( node ) ; } updateNodes ( node . getChildDeltas ( ) , mask ) ; } } protected void handleInstall ( IModelDelta delta ) { installModelProxy ( getViewer ( ) . getInput ( ) , getFullTreePath ( delta ) ) ; } protected void handleUninstall ( IModelDelta delta ) { disposeModelProxy ( getFullTreePath ( delta ) ) ; } protected void handleAdd ( IModelDelta delta ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } TreePath parentPath = getViewerTreePath ( parentDelta ) ; Object element = delta . getElement ( ) ; int count = parentDelta . getChildCount ( ) ; if ( count > <int> ) { setModelChildCount ( parentPath , count ) ; int modelIndex = count - <int> ; if ( delta . getIndex ( ) ! = - <int> ) { modelIndex = delta . getIndex ( ) ; } if ( shouldFilter ( parentPath , element ) ) { addFilteredIndex ( parentPath , modelIndex , element ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + modelIndex ) ; } } else { if ( isFiltered ( parentPath , modelIndex ) ) { clearFilteredChild ( parentPath , modelIndex ) ; } int viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; int viewCount = modelToViewChildCount ( parentPath , count ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + viewIndex + <str> + modelIndex + <str> + viewCount + <str> + count ) ; } getViewer ( ) . setChildCount ( parentPath , viewCount ) ; getViewer ( ) . autoExpand ( parentPath ) ; getViewer ( ) . replace ( parentPath , viewIndex , element ) ; TreePath childPath = parentPath . createChildPath ( element ) ; updateHasChildren ( childPath ) ; fStateTracker . restorePendingStateOnUpdate ( childPath , modelIndex , false , false , false ) ; } } else { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> ) ; } doUpdateChildCount ( getViewerTreePath ( delta . getParentDelta ( ) ) ) ; } } protected void handleContent ( IModelDelta delta ) { if ( delta . getParentDelta ( ) = = null & & delta . getChildCount ( ) = = <int> ) { if ( ! delta . getElement ( ) . equals ( getViewer ( ) . getInput ( ) ) ) { return ; } } TreePath treePath = getViewerTreePath ( delta ) ; cancelSubtreeUpdates ( treePath ) ; getViewer ( ) . refresh ( getElement ( treePath ) ) ; } protected void handleCollapse ( IModelDelta delta ) { TreePath elementPath = getViewerTreePath ( delta ) ; getViewer ( ) . setExpandedState ( elementPath , false ) ; cancelRestore ( elementPath , IModelDelta . EXPAND ) ; } protected void handleExpand ( IModelDelta delta ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta ! = null ) { if ( ( parentDelta . getFlags ( ) & IModelDelta . EXPAND ) = = <int> ) { handleExpand ( parentDelta ) ; } expand ( delta ) ; } else { int childCount = delta . getChildCount ( ) ; TreePath elementPath = getViewerTreePath ( delta ) ; if ( childCount > <int> ) { int viewCount = modelToViewChildCount ( elementPath , childCount ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + childCount + <str> + viewCount ) ; } getViewer ( ) . setChildCount ( elementPath , viewCount ) ; } } } private void expand ( IModelDelta delta ) { int childCount = delta . getChildCount ( ) ; int modelIndex = delta . getIndex ( ) ; IInternalTreeModelViewer treeViewer = getViewer ( ) ; TreePath elementPath = getViewerTreePath ( delta ) ; if ( modelIndex > = <int> ) { TreePath parentPath = elementPath . getParentPath ( ) ; if ( parentPath = = null ) { parentPath = TreePath . EMPTY ; } int viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; if ( viewIndex > = <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getParentDelta ( ) . getElement ( ) + <str> + modelIndex + <str> + viewIndex + <str> + delta . getElement ( ) ) ; } treeViewer . replace ( parentPath , viewIndex , delta . getElement ( ) ) ; } else { viewIndex = unfilterElement ( parentPath , delta . getElement ( ) , modelIndex ) ; if ( viewIndex < <int> ) { return ; } } } if ( childCount > <int> ) { int viewCount = modelToViewChildCount ( elementPath , childCount ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + childCount + <str> + viewCount ) ; } treeViewer . setChildCount ( elementPath , viewCount ) ; if ( ! treeViewer . getExpandedState ( elementPath ) ) { treeViewer . expandToLevel ( elementPath , <int> ) ; cancelRestore ( elementPath , IModelDelta . COLLAPSE ) ; } } } private int unfilterElement ( TreePath parentPath , Object element , int modelIndex ) { if ( shouldFilter ( parentPath , element ) ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + element + <str> + modelIndex ) ; } return - <int> ; } clearFilteredChild ( parentPath , modelIndex ) ; int viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; if ( viewIndex > = <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentPath . getLastSegment ( ) + <str> + modelIndex + <str> + viewIndex + <str> + element ) ; } getViewer ( ) . insert ( parentPath , element , viewIndex ) ; return viewIndex ; } else { return - <int> ; } } protected void handleInsert ( IModelDelta delta ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } TreePath parentPath = getViewerTreePath ( delta . getParentDelta ( ) ) ; Object element = delta . getElement ( ) ; int modelIndex = delta . getIndex ( ) ; int viewIndex = modelIndex > = <int> ? modelToViewIndex ( parentPath , modelIndex ) : - <int> ; int viewCount = getViewer ( ) . getChildCount ( parentPath ) ; if ( viewIndex > = <int> & & viewIndex < = viewCount ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentPath . getLastSegment ( ) + <str> + modelIndex + <str> + viewIndex + <str> + element ) ; } getViewer ( ) . insert ( parentPath , element , viewIndex ) ; } else if ( modelIndex > = <int> & & viewIndex < <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + modelIndex ) ; } } else { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> ) ; } doUpdateChildCount ( getViewerTreePath ( delta . getParentDelta ( ) ) ) ; } } protected void handleRemove ( IModelDelta delta ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> ) ; } IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } IInternalTreeModelViewer treeViewer = getViewer ( ) ; TreePath parentPath = getViewerTreePath ( parentDelta ) ; Object element = delta . getElement ( ) ; if ( removeElementFromFilters ( parentPath , element ) ) { return ; } int viewIndex = - <int> ; int modelIndex = delta . getIndex ( ) ; int unmappedIndex = - <int> ; int itemCount = - <int> ; if ( modelIndex < <int> ) { itemCount = treeViewer . getChildCount ( parentPath ) ; if ( itemCount = = - <int> ) { clearFilters ( parentPath ) ; } viewIndex = treeViewer . findElementIndex ( parentPath , element ) ; if ( viewIndex > = <int> ) { modelIndex = viewToModelIndex ( parentPath , viewIndex ) ; } else { unmappedIndex = treeViewer . findElementIndex ( parentPath , null ) ; } } else { viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; } if ( modelIndex > = <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentPath . getLastSegment ( ) + <str> + viewIndex + <str> + modelIndex ) ; } rescheduleUpdates ( parentPath , modelIndex ) ; getViewer ( ) . remove ( parentPath , viewIndex ) ; removeElementFromFilters ( parentPath , modelIndex ) ; return ; } if ( unmappedIndex > = <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentPath . getLastSegment ( ) + <str> + viewIndex + <str> + modelIndex + <str> + unmappedIndex ) ; } modelIndex = viewToModelIndex ( parentPath , unmappedIndex ) ; rescheduleUpdates ( parentPath , modelIndex ) ; getViewer ( ) . remove ( parentPath , unmappedIndex ) ; removeElementFromFilters ( parentPath , modelIndex ) ; return ; } int modelCount = parentDelta . getChildCount ( ) ; if ( itemCount > = <int> & & modelCount > = <int> ) { if ( modelToViewChildCount ( parentPath , modelCount ) = = itemCount ) { return ; } } if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) ) ; } getViewer ( ) . remove ( getViewerTreePath ( delta ) ) ; clearFilters ( parentPath ) ; getViewer ( ) . refresh ( parentDelta . getElement ( ) ) ; } protected void handleReplace ( IModelDelta delta ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } TreePath parentPath = getViewerTreePath ( parentDelta ) ; int index = delta . getIndex ( ) ; if ( index < <int> ) { index = fTransform . indexOfFilteredElement ( parentPath , delta . getElement ( ) ) ; } if ( index > = <int> ) { boolean filtered = isFiltered ( parentPath , index ) ; boolean shouldFilter = shouldFilter ( parentPath , delta . getReplacementElement ( ) ) ; if ( filtered ) { clearFilteredChild ( parentPath , index ) ; } if ( shouldFilter ) { addFilteredIndex ( parentPath , index , delta . getElement ( ) ) ; } if ( filtered ) { if ( ! shouldFilter ) { getViewer ( ) . insert ( parentPath , delta . getReplacementElement ( ) , modelToViewIndex ( parentPath , index ) ) ; } } else { if ( shouldFilter ) { getViewer ( ) . remove ( parentPath , modelToViewIndex ( parentPath , index ) ) ; } else { getViewer ( ) . replace ( parentPath , delta . getIndex ( ) , delta . getReplacementElement ( ) ) ; } } } } protected void handleSelect ( IModelDelta delta ) { int modelIndex = delta . getIndex ( ) ; IInternalTreeModelViewer treeViewer = getViewer ( ) ; IStructuredSelection candidate = new TreeSelection ( getViewerTreePath ( delta ) ) ; if ( ( delta . getFlags ( ) & IModelDelta . FORCE ) = = <int> & & ! treeViewer . overrideSelection ( treeViewer . getSelection ( ) , candidate ) ) { return ; } treeViewer . clearSelectionQuiet ( ) ; if ( modelIndex > = <int> ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } TreePath parentPath = getViewerTreePath ( parentDelta ) ; int viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; if ( viewIndex > = <int> ) { int modelCount = parentDelta . getChildCount ( ) ; if ( modelCount > <int> ) { int viewCount = modelToViewChildCount ( parentPath , modelCount ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentDelta . getElement ( ) + <str> + parentDelta . getChildCount ( ) + <str> + viewCount ) ; } treeViewer . setChildCount ( parentPath , viewCount ) ; } if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + parentDelta . getElement ( ) + <str> + modelIndex + <str> + viewIndex + <str> + delta . getElement ( ) ) ; } treeViewer . replace ( parentPath , viewIndex , delta . getElement ( ) ) ; } } TreePath selectionPath = getViewerTreePath ( delta ) ; if ( treeViewer . trySelection ( new TreeSelection ( selectionPath ) , false , ( delta . getFlags ( ) | IModelDelta . FORCE ) = = <int> ) ) { cancelRestore ( selectionPath , IModelDelta . SELECT ) ; } } protected void handleState ( IModelDelta delta ) { getViewer ( ) . update ( delta . getElement ( ) ) ; } protected void handleReveal ( IModelDelta delta ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta = = null ) { DebugUIPlugin . log ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + delta + <str> + getPresentationContext ( ) . getId ( ) , null ) ) ; return ; } handleExpand ( parentDelta ) ; reveal ( delta ) ; cancelRestore ( getViewerTreePath ( delta ) , IModelDelta . REVEAL ) ; } private void reveal ( IModelDelta delta ) { int modelIndex = delta . getIndex ( ) ; IInternalTreeModelViewer treeViewer = getViewer ( ) ; TreePath elementPath = getViewerTreePath ( delta ) ; if ( modelIndex > = <int> ) { TreePath parentPath = elementPath . getParentPath ( ) ; if ( parentPath = = null ) { parentPath = TreePath . EMPTY ; } int viewIndex = modelToViewIndex ( parentPath , modelIndex ) ; if ( viewIndex > = <int> ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getParentDelta ( ) . getElement ( ) + <str> + modelIndex + <str> + viewIndex + <str> + delta . getElement ( ) ) ; } treeViewer . replace ( parentPath , viewIndex , delta . getElement ( ) ) ; } else { viewIndex = unfilterElement ( parentPath , delta . getElement ( ) , modelIndex ) ; if ( viewIndex < <int> ) { return ; } } if ( ( delta . getFlags ( ) & IModelDelta . FORCE ) ! = <int> | | treeViewer . overrideSelection ( treeViewer . getSelection ( ) , new TreeSelection ( elementPath ) ) ) { fRevealPath = parentPath ; fRevealIndex = viewIndex ; treeViewer . reveal ( parentPath , viewIndex ) ; } } } @Override public TreePath [ ] getParents ( Object element ) { return null ; } @Override public void updateChildCount ( TreePath treePath , int currentChildCount ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( treePath ) + <str> + currentChildCount + <str> ) ; } doUpdateChildCount ( treePath ) ; } @Override public void updateElement ( TreePath parentPath , int viewIndex ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; int modelIndex = viewToModelIndex ( parentPath , viewIndex ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( parentPath ) + <str> + viewIndex + <str> + modelIndex ) ; } doUpdateElement ( parentPath , modelIndex ) ; } @Override public void updateHasChildren ( TreePath path ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( path ) ) ; } doUpdateHasChildren ( path ) ; } void scheduleViewerUpdate ( ViewerUpdateMonitor update ) { Display display ; Runnable updateJob = null ; synchronized ( this ) { if ( isDisposed ( ) ) { return ; } display = getViewer ( ) . getDisplay ( ) ; fCompletedUpdates . add ( update ) ; if ( fCompletedUpdatesRunnable = = null ) { fCompletedUpdatesRunnable = new Runnable ( ) { @Override public void run ( ) { if ( ! isDisposed ( ) ) { performUpdates ( ) ; } } } ; updateJob = fCompletedUpdatesRunnable ; } } if ( updateJob ! = null ) { if ( Thread . currentThread ( ) = = display . getThread ( ) ) { performUpdates ( ) ; } else { display . asyncExec ( updateJob ) ; } } } private void performUpdates ( ) { Assert . isTrue ( getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; List < ViewerUpdateMonitor > jobCompletedUpdates ; synchronized ( this ) { if ( isDisposed ( ) ) { return ; } jobCompletedUpdates = fCompletedUpdates ; fCompletedUpdatesRunnable = null ; fCompletedUpdates = new ArrayList < ViewerUpdateMonitor > ( ) ; } try { for ( int i = <int> ; i < jobCompletedUpdates . size ( ) ; i + + ) { ViewerUpdateMonitor completedUpdate = jobCompletedUpdates . get ( i ) ; if ( ! completedUpdate . isCanceled ( ) & & ! isDisposed ( ) ) { IStatus status = completedUpdate . getStatus ( ) ; if ( status = = null | | status . isOK ( ) ) { completedUpdate . performUpdate ( ) ; } } } } finally { updatesComplete ( jobCompletedUpdates ) ; } } } 
