package org . elasticsearch . common . util ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . cache . recycler . PageCacheRecycler ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . breaker . CircuitBreakingException ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . indices . breaker . HierarchyCircuitBreakerService ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . junit . Before ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; public class BigArraysTests extends ESSingleNodeTestCase { public static BigArrays randombigArrays ( ) { final PageCacheRecycler recycler = randomBoolean ( ) ? null : ESSingleNodeTestCase . getInstanceFromNode ( PageCacheRecycler . class ) ; return new MockBigArrays ( recycler , new NoneCircuitBreakerService ( ) ) ; } private BigArrays bigArrays ; @Before public void init ( ) { bigArrays = randombigArrays ( ) ; } public void testByteArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; ByteArray array = bigArrays . newByteArray ( startLen , randomBoolean ( ) ) ; byte [ ] ref = new byte [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomByte ( ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertEquals ( ref [ i ] , array . get ( i ) ) ; } array . close ( ) ; } public void testIntArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; IntArray array = bigArrays . newIntArray ( startLen , randomBoolean ( ) ) ; int [ ] ref = new int [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomInt ( ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertEquals ( ref [ i ] , array . get ( i ) ) ; } array . close ( ) ; } public void testLongArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; LongArray array = bigArrays . newLongArray ( startLen , randomBoolean ( ) ) ; long [ ] ref = new long [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomLong ( ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertEquals ( ref [ i ] , array . get ( i ) ) ; } array . close ( ) ; } public void testFloatArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; FloatArray array = bigArrays . newFloatArray ( startLen , randomBoolean ( ) ) ; float [ ] ref = new float [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomFloat ( ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertEquals ( ref [ i ] , array . get ( i ) , <float> ) ; } array . close ( ) ; } public void testDoubleArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; DoubleArray array = bigArrays . newDoubleArray ( startLen , randomBoolean ( ) ) ; double [ ] ref = new double [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomDouble ( ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertEquals ( ref [ i ] , array . get ( i ) , <float> ) ; } array . close ( ) ; } public void testObjectArrayGrowth ( ) { final int totalLen = randomIntBetween ( <int> , <int> ) ; final int startLen = randomIntBetween ( <int> , randomBoolean ( ) ? <int> : totalLen ) ; ObjectArray < Object > array = bigArrays . newObjectArray ( startLen ) ; final Object [ ] pool = new Object [ <int> ] ; for ( int i = <int> ; i < pool . length ; + + i ) { pool [ i ] = new Object ( ) ; } Object [ ] ref = new Object [ totalLen ] ; for ( int i = <int> ; i < totalLen ; + + i ) { ref [ i ] = randomFrom ( pool ) ; array = bigArrays . grow ( array , i + <int> ) ; array . set ( i , ref [ i ] ) ; } for ( int i = <int> ; i < totalLen ; + + i ) { assertSame ( ref [ i ] , array . get ( i ) ) ; } array . close ( ) ; } public void testByteArrayFill ( ) { final int len = randomIntBetween ( <int> , <int> ) ; final int fromIndex = randomIntBetween ( <int> , len - <int> ) ; final int toIndex = randomBoolean ( ) ? Math . min ( fromIndex + randomInt ( <int> ) , len ) : randomIntBetween ( fromIndex , len ) ; final ByteArray array2 = bigArrays . newByteArray ( len , randomBoolean ( ) ) ; final byte [ ] array1 = new byte [ len ] ; for ( int i = <int> ; i < len ; + + i ) { array1 [ i ] = randomByte ( ) ; array2 . set ( i , array1 [ i ] ) ; } final byte rand = randomByte ( ) ; Arrays . fill ( array1 , fromIndex , toIndex , rand ) ; array2 . fill ( fromIndex , toIndex , rand ) ; for ( int i = <int> ; i < len ; + + i ) { assertEquals ( array1 [ i ] , array2 . get ( i ) , <float> ) ; } array2 . close ( ) ; } public void testFloatArrayFill ( ) { final int len = randomIntBetween ( <int> , <int> ) ; final int fromIndex = randomIntBetween ( <int> , len - <int> ) ; final int toIndex = randomBoolean ( ) ? Math . min ( fromIndex + randomInt ( <int> ) , len ) : randomIntBetween ( fromIndex , len ) ; final FloatArray array2 = bigArrays . newFloatArray ( len , randomBoolean ( ) ) ; final float [ ] array1 = new float [ len ] ; for ( int i = <int> ; i < len ; + + i ) { array1 [ i ] = randomFloat ( ) ; array2 . set ( i , array1 [ i ] ) ; } final float rand = randomFloat ( ) ; Arrays . fill ( array1 , fromIndex , toIndex , rand ) ; array2 . fill ( fromIndex , toIndex , rand ) ; for ( int i = <int> ; i < len ; + + i ) { assertEquals ( array1 [ i ] , array2 . get ( i ) , <float> ) ; } array2 . close ( ) ; } public void testDoubleArrayFill ( ) { final int len = randomIntBetween ( <int> , <int> ) ; final int fromIndex = randomIntBetween ( <int> , len - <int> ) ; final int toIndex = randomBoolean ( ) ? Math . min ( fromIndex + randomInt ( <int> ) , len ) : randomIntBetween ( fromIndex , len ) ; final DoubleArray array2 = bigArrays . newDoubleArray ( len , randomBoolean ( ) ) ; final double [ ] array1 = new double [ len ] ; for ( int i = <int> ; i < len ; + + i ) { array1 [ i ] = randomDouble ( ) ; array2 . set ( i , array1 [ i ] ) ; } final double rand = randomDouble ( ) ; Arrays . fill ( array1 , fromIndex , toIndex , rand ) ; array2 . fill ( fromIndex , toIndex , rand ) ; for ( int i = <int> ; i < len ; + + i ) { assertEquals ( array1 [ i ] , array2 . get ( i ) , <float> ) ; } array2 . close ( ) ; } public void testLongArrayFill ( ) { final int len = randomIntBetween ( <int> , <int> ) ; final int fromIndex = randomIntBetween ( <int> , len - <int> ) ; final int toIndex = randomBoolean ( ) ? Math . min ( fromIndex + randomInt ( <int> ) , len ) : randomIntBetween ( fromIndex , len ) ; final LongArray array2 = bigArrays . newLongArray ( len , randomBoolean ( ) ) ; final long [ ] array1 = new long [ len ] ; for ( int i = <int> ; i < len ; + + i ) { array1 [ i ] = randomLong ( ) ; array2 . set ( i , array1 [ i ] ) ; } final long rand = randomLong ( ) ; Arrays . fill ( array1 , fromIndex , toIndex , rand ) ; array2 . fill ( fromIndex , toIndex , rand ) ; for ( int i = <int> ; i < len ; + + i ) { assertEquals ( array1 [ i ] , array2 . get ( i ) ) ; } array2 . close ( ) ; } public void testByteArrayBulkGet ( ) { final byte [ ] array1 = new byte [ randomIntBetween ( <int> , <int> ) ] ; getRandom ( ) . nextBytes ( array1 ) ; final ByteArray array2 = bigArrays . newByteArray ( array1 . length , randomBoolean ( ) ) ; for ( int i = <int> ; i < array1 . length ; + + i ) { array2 . set ( i , array1 [ i ] ) ; } final BytesRef ref = new BytesRef ( ) ; for ( int i = <int> ; i < <int> ; + + i ) { final int offset = randomInt ( array1 . length - <int> ) ; final int len = randomInt ( Math . min ( randomBoolean ( ) ? <int> : Integer . MAX_VALUE , array1 . length - offset ) ) ; array2 . get ( offset , len , ref ) ; assertEquals ( new BytesRef ( array1 , offset , len ) , ref ) ; } array2 . close ( ) ; } public void testByteArrayBulkSet ( ) { final byte [ ] array1 = new byte [ randomIntBetween ( <int> , <int> ) ] ; getRandom ( ) . nextBytes ( array1 ) ; final ByteArray array2 = bigArrays . newByteArray ( array1 . length , randomBoolean ( ) ) ; for ( int i = <int> ; i < array1 . length ; ) { final int len = Math . min ( array1 . length - i , randomBoolean ( ) ? randomInt ( <int> ) : randomInt ( <int> * BigArrays . BYTE_PAGE_SIZE ) ) ; array2 . set ( i , array1 , i , len ) ; i + = len ; } for ( int i = <int> ; i < array1 . length ; + + i ) { assertEquals ( array1 [ i ] , array2 . get ( i ) ) ; } array2 . close ( ) ; } public void testByteArrayEquals ( ) { final ByteArray empty1 = byteArrayWithBytes ( BytesRef . EMPTY_BYTES ) ; final ByteArray empty2 = byteArrayWithBytes ( BytesRef . EMPTY_BYTES ) ; assertTrue ( bigArrays . equals ( empty1 , empty1 ) ) ; assertTrue ( bigArrays . equals ( empty1 , empty2 ) ) ; empty1 . close ( ) ; empty2 . close ( ) ; final ByteArray a1 = byteArrayWithBytes ( new byte [ ] { <int> } ) ; final ByteArray a2 = byteArrayWithBytes ( new byte [ ] { <int> } ) ; assertFalse ( bigArrays . equals ( a1 , a2 ) ) ; a1 . close ( ) ; a2 . close ( ) ; final ByteArray a3 = byteArrayWithBytes ( new byte [ ] { <int> , <int> , <int> } ) ; final ByteArray a4 = byteArrayWithBytes ( new byte [ ] { <int> , <int> , <int> } ) ; assertFalse ( bigArrays . equals ( a3 , a4 ) ) ; a3 . close ( ) ; a4 . close ( ) ; final ByteArray a5 = byteArrayWithBytes ( new byte [ ] { <int> , <int> , <int> } ) ; final ByteArray a6 = byteArrayWithBytes ( new byte [ ] { <int> , <int> , <int> } ) ; assertFalse ( bigArrays . equals ( a5 , a6 ) ) ; a5 . close ( ) ; a6 . close ( ) ; } public void testByteArrayHashCode ( ) { assertEquals ( <int> , bigArrays . hashCode ( null ) ) ; final int emptyHash = Arrays . hashCode ( BytesRef . EMPTY_BYTES ) ; final ByteArray emptyByteArray = byteArrayWithBytes ( BytesRef . EMPTY_BYTES ) ; final int emptyByteArrayHash = bigArrays . hashCode ( emptyByteArray ) ; assertEquals ( emptyHash , emptyByteArrayHash ) ; emptyByteArray . close ( ) ; final byte [ ] array1 = new byte [ randomIntBetween ( <int> , <int> ) ] ; getRandom ( ) . nextBytes ( array1 ) ; final int array1Hash = Arrays . hashCode ( array1 ) ; final ByteArray array2 = byteArrayWithBytes ( array1 ) ; final int array2Hash = bigArrays . hashCode ( array2 ) ; assertEquals ( array1Hash , array2Hash ) ; array2 . close ( ) ; } private ByteArray byteArrayWithBytes ( byte [ ] bytes ) { ByteArray bytearray = bigArrays . newByteArray ( bytes . length ) ; for ( int i = <int> ; i < bytes . length ; + + i ) { bytearray . set ( i , bytes [ i ] ) ; } return bytearray ; } public void testMaxSizeExceededOnNew ( ) throws Exception { final int size = scaledRandomIntBetween ( <int> , <int> < < <int> ) ; for ( String type : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { HierarchyCircuitBreakerService hcbs = new HierarchyCircuitBreakerService ( Settings . builder ( ) . put ( HierarchyCircuitBreakerService . REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , size - <int> , ByteSizeUnit . BYTES ) . build ( ) , new NodeSettingsService ( Settings . EMPTY ) ) ; BigArrays bigArrays = new BigArrays ( null , hcbs ) . withCircuitBreaking ( ) ; Method create = BigArrays . class . getMethod ( <str> + type + <str> , long . class ) ; try { create . invoke ( bigArrays , size ) ; fail ( <str> + create ) ; } catch ( InvocationTargetException e ) { assertTrue ( e . getCause ( ) instanceof CircuitBreakingException ) ; } assertEquals ( <int> , hcbs . getBreaker ( CircuitBreaker . REQUEST ) . getUsed ( ) ) ; } } public void testMaxSizeExceededOnResize ( ) throws Exception { for ( String type : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { final long maxSize = randomIntBetween ( <int> < < <int> , <int> < < <int> ) ; HierarchyCircuitBreakerService hcbs = new HierarchyCircuitBreakerService ( Settings . builder ( ) . put ( HierarchyCircuitBreakerService . REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , maxSize , ByteSizeUnit . BYTES ) . build ( ) , new NodeSettingsService ( Settings . EMPTY ) ) ; BigArrays bigArrays = new BigArrays ( null , hcbs ) . withCircuitBreaking ( ) ; Method create = BigArrays . class . getMethod ( <str> + type + <str> , long . class ) ; final int size = scaledRandomIntBetween ( <int> , <int> ) ; BigArray array = ( BigArray ) create . invoke ( bigArrays , size ) ; Method resize = BigArrays . class . getMethod ( <str> , array . getClass ( ) . getInterfaces ( ) [ <int> ] , long . class ) ; while ( true ) { long newSize = array . size ( ) * <int> ; try { array = ( BigArray ) resize . invoke ( bigArrays , array , newSize ) ; } catch ( InvocationTargetException e ) { assertTrue ( e . getCause ( ) instanceof CircuitBreakingException ) ; break ; } } assertEquals ( array . ramBytesUsed ( ) , hcbs . getBreaker ( CircuitBreaker . REQUEST ) . getUsed ( ) ) ; array . close ( ) ; assertEquals ( <int> , hcbs . getBreaker ( CircuitBreaker . REQUEST ) . getUsed ( ) ) ; } } } 
