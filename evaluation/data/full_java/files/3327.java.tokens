package org . nd4j . linalg . jcublas . buffer ; import com . google . common . collect . HashBasedTable ; import com . google . common . collect . Table ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import jcuda . Pointer ; import jcuda . jcublas . JCublas2 ; import org . apache . commons . lang3 . tuple . Triple ; import org . nd4j . linalg . api . blas . BlasBufferUtil ; import org . nd4j . linalg . api . buffer . BaseDataBuffer ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . jcublas . buffer . allocation . HostDevicePointer ; import org . nd4j . linalg . jcublas . buffer . allocation . MemoryStrategy ; import org . nd4j . linalg . jcublas . complex . CudaComplexConversion ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . jcublas . context . CudaContext ; import org . nd4j . linalg . jcublas . util . PointerUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . lang . ref . WeakReference ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicLong ; public abstract class BaseCudaDataBuffer extends BaseDataBuffer implements JCudaBuffer { static AtomicLong allocated = new AtomicLong ( ) ; static AtomicLong totalAllocated = new AtomicLong ( ) ; private static Logger log = LoggerFactory . getLogger ( BaseCudaDataBuffer . class ) ; protected transient Table < String , Triple < Integer , Integer , Integer > , DevicePointerInfo > pointersToContexts = HashBasedTable . create ( ) ; protected AtomicBoolean modified = new AtomicBoolean ( false ) ; protected Collection < String > referencing = Collections . synchronizedSet ( new HashSet < String > ( ) ) ; protected transient WeakReference < DataBuffer > ref ; protected AtomicBoolean freed = new AtomicBoolean ( false ) ; private Map < String , Boolean > copied = new ConcurrentHashMap < > ( ) ; public BaseCudaDataBuffer ( ByteBuf buf , int length ) { super ( buf , length ) ; } public BaseCudaDataBuffer ( float [ ] data , boolean copy ) { super ( data , copy ) ; } public BaseCudaDataBuffer ( double [ ] data , boolean copy ) { super ( data , copy ) ; } public BaseCudaDataBuffer ( int [ ] data , boolean copy ) { super ( data , copy ) ; } public BaseCudaDataBuffer ( int length , int elementSize ) { super ( length , elementSize ) ; } public BaseCudaDataBuffer ( int length ) { super ( length ) ; } public BaseCudaDataBuffer ( float [ ] data ) { super ( data ) ; } public BaseCudaDataBuffer ( int [ ] data ) { super ( data ) ; } public BaseCudaDataBuffer ( double [ ] data ) { super ( data ) ; } public BaseCudaDataBuffer ( byte [ ] data , int length ) { super ( data , length ) ; } public BaseCudaDataBuffer ( ByteBuffer buffer , int length ) { super ( buffer , length ) ; } @Override protected void setNioBuffer ( ) { wrappedBuffer = ByteBuffer . allocateDirect ( elementSize * length ) ; wrappedBuffer . order ( ByteOrder . nativeOrder ( ) ) ; } @Override public void copyAtStride ( DataBuffer buf , int n , int stride , int yStride , int offset , int yOffset ) { super . copyAtStride ( buf , n , stride , yStride , offset , yOffset ) ; MemoryStrategy strategy = ContextHolder . getInstance ( ) . getMemoryStrategy ( ) ; strategy . setData ( buf , offset , stride , length ( ) ) ; } @Override public boolean copied ( String name ) { Boolean copied = this . copied . get ( name ) ; if ( copied = = null ) return false ; return this . copied . get ( name ) ; } @Override public void setCopied ( String name ) { copied . put ( name , true ) ; } @Override public AllocationMode allocationMode ( ) { return allocationMode ; } @Override public ByteBuffer getHostBuffer ( ) { return wrappedBuffer ; } @Override public void setHostBuffer ( ByteBuffer hostBuffer ) { this . wrappedBuffer = hostBuffer ; } @Override public Pointer getHostPointer ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Pointer getHostPointer ( int offset ) { throw new UnsupportedOperationException ( ) ; } @Override public void removeReferencing ( String id ) { referencing . remove ( id ) ; } @Override public Collection < String > references ( ) { return referencing ; } @Override public int getElementSize ( ) { return elementSize ; } @Override public void addReferencing ( String id ) { referencing . add ( id ) ; } @Override public void put ( int i , IComplexNumber result ) { modified . set ( true ) ; if ( dataType ( ) = = DataBuffer . Type . FLOAT ) { JCublas2 . cublasSetVector ( ( int ) length ( ) , getElementSize ( ) , PointerUtil . getPointer ( CudaComplexConversion . toComplex ( result . asFloat ( ) ) ) , <int> , getHostPointer ( ) , <int> ) ; } else { JCublas2 . cublasSetVector ( ( int ) length ( ) , getElementSize ( ) , PointerUtil . getPointer ( CudaComplexConversion . toComplexDouble ( result . asDouble ( ) ) ) , <int> , getHostPointer ( ) , <int> ) ; } } @Override public Pointer getDevicePointer ( int stride , int offset , int length ) { String name = Thread . currentThread ( ) . getName ( ) ; DevicePointerInfo devicePointerInfo = pointersToContexts . get ( name , Triple . of ( offset , length , <int> ) ) ; if ( devicePointerInfo = = null ) { int devicePointerLength = getElementSize ( ) * length ; allocated . addAndGet ( devicePointerLength ) ; totalAllocated . addAndGet ( devicePointerLength ) ; log . trace ( <str> , devicePointerLength , allocated . get ( ) , totalAllocated ) ; if ( devicePointerInfo = = null ) { if ( ! pointersToContexts . contains ( name , Triple . of ( <int> , this . length , <int> ) ) ) { MemoryStrategy strat = ContextHolder . getInstance ( ) . getConf ( ) . getMemoryStrategy ( ) ; devicePointerInfo = ( DevicePointerInfo ) strat . alloc ( this , <int> , <int> , this . length , true ) ; pointersToContexts . put ( name , Triple . of ( <int> , this . length , <int> ) , devicePointerInfo ) ; } if ( offset > <int> | | length < length ( ) ) { HostDevicePointer zero = pointersToContexts . get ( name , Triple . of ( <int> , length , <int> ) ) . getPointers ( ) ; HostDevicePointer ret = new HostDevicePointer ( zero . getHostPointer ( ) . withByteOffset ( offset * getElementSize ( ) ) , zero . getDevicePointer ( ) . withByteOffset ( offset * getElementSize ( ) ) ) ; devicePointerInfo = new DevicePointerInfo ( ret , length , stride , offset , false ) ; pointersToContexts . put ( name , Triple . of ( offset , length , stride ) , devicePointerInfo ) ; return ret . getDevicePointer ( ) ; } } freed . set ( false ) ; } if ( offset > <int> ) return devicePointerInfo . getPointers ( ) . getDevicePointer ( ) ; else return devicePointerInfo . getPointers ( ) . getDevicePointer ( ) ; } @Override public Pointer getDevicePointer ( INDArray arr , int stride , int offset , int length ) { String name = Thread . currentThread ( ) . getName ( ) ; DevicePointerInfo devicePointerInfo = pointersToContexts . get ( name , Triple . of ( offset , length , stride ) ) ; if ( devicePointerInfo = = null ) { int devicePointerLength = getElementSize ( ) * length ; allocated . addAndGet ( devicePointerLength ) ; totalAllocated . addAndGet ( devicePointerLength ) ; log . trace ( <str> , devicePointerLength , allocated . get ( ) , totalAllocated ) ; if ( arr . data ( ) ! = this ) { throw new IllegalArgumentException ( <str> ) ; } int compareLength = arr instanceof IComplexNDArray ? arr . length ( ) * <int> : arr . length ( ) ; if ( ! pointersToContexts . contains ( name , Triple . of ( <int> , this . length , <int> ) ) ) { devicePointerInfo = ( DevicePointerInfo ) ContextHolder . getInstance ( ) . getConf ( ) . getMemoryStrategy ( ) . alloc ( this , <int> , <int> , this . length , true ) ; pointersToContexts . put ( name , Triple . of ( <int> , this . length , <int> ) , devicePointerInfo ) ; } if ( offset > <int> ) { DevicePointerInfo info2 = pointersToContexts . get ( name , Triple . of ( <int> , this . length , <int> ) ) ; if ( info2 = = null ) throw new IllegalStateException ( <str> + name + <str> + offset + <str> + length ) ; HostDevicePointer zero = info2 . getPointers ( ) ; HostDevicePointer retOffset = new HostDevicePointer ( zero . getHostPointer ( ) . withByteOffset ( offset * getElementSize ( ) ) , zero . getDevicePointer ( ) . withByteOffset ( offset * getElementSize ( ) ) ) ; Pointer ret = retOffset . getDevicePointer ( ) ; devicePointerInfo = new DevicePointerInfo ( retOffset , length , stride , offset , false ) ; pointersToContexts . put ( name , Triple . of ( offset , compareLength , stride ) , devicePointerInfo ) ; return ret ; } else if ( offset = = <int> & & compareLength < arr . data ( ) . length ( ) ) { DevicePointerInfo info2 = pointersToContexts . get ( name , Triple . of ( <int> , this . length , <int> ) ) ; if ( info2 = = null ) { throw new IllegalStateException ( <str> + name + <str> + offset + <str> + length ) ; } DevicePointerInfo info3 = new DevicePointerInfo ( info2 . getPointers ( ) , this . length , stride , arr . offset ( ) , false ) ; int compareLength2 = arr instanceof IComplexNDArray ? arr . length ( ) * <int> : arr . length ( ) ; pointersToContexts . put ( name , Triple . of ( offset , compareLength2 , stride ) , info3 ) ; return info3 . getPointers ( ) . getDevicePointer ( ) ; } freed . set ( false ) ; } if ( devicePointerInfo = = null & & offset = = <int> & & length < length ( ) ) { DevicePointerInfo origin = pointersToContexts . get ( Thread . currentThread ( ) . getName ( ) , Triple . of ( <int> , length ( ) , <int> ) ) ; DevicePointerInfo newInfo = new DevicePointerInfo ( origin . getPointers ( ) , length , stride , <int> , false ) ; return newInfo . getPointers ( ) . getDevicePointer ( ) ; } return devicePointerInfo . getPointers ( ) . getDevicePointer ( ) . withByteOffset ( offset * getElementSize ( ) ) ; } @Override public void set ( Pointer pointer ) { modified . set ( true ) ; if ( dataType ( ) = = DataBuffer . Type . DOUBLE ) { JCublas2 . cublasDcopy ( ContextHolder . getInstance ( ) . getHandle ( ) , length ( ) , pointer , <int> , getHostPointer ( ) , <int> ) ; } else { JCublas2 . cublasScopy ( ContextHolder . getInstance ( ) . getHandle ( ) , length ( ) , pointer , <int> , getHostPointer ( ) , <int> ) ; } } private void copyOneElement ( int i , double val ) { if ( pointersToContexts ! = null ) for ( DevicePointerInfo info : pointersToContexts . values ( ) ) { if ( dataType ( ) = = Type . FLOAT ) JCublas2 . cublasSetVector ( <int> , getElementSize ( ) , Pointer . to ( new float [ ] { ( float ) val } ) , <int> , info . getPointers ( ) . getDevicePointer ( ) . withByteOffset ( getElementSize ( ) * i ) , <int> ) ; else JCublas2 . cublasSetVector ( <int> , getElementSize ( ) , Pointer . to ( new double [ ] { val } ) , <int> , info . getPointers ( ) . getDevicePointer ( ) . withByteOffset ( getElementSize ( ) * i ) , <int> ) ; } } @Override public void put ( int i , float element ) { super . put ( i , element ) ; copyOneElement ( i , element ) ; } @Override public void put ( int i , double element ) { super . put ( i , element ) ; copyOneElement ( i , element ) ; } @Override public IComplexFloat getComplexFloat ( int i ) { return Nd4j . createFloat ( getFloat ( i ) , getFloat ( i + <int> ) ) ; } @Override public IComplexDouble getComplexDouble ( int i ) { return Nd4j . createDouble ( getDouble ( i ) , getDouble ( i + <int> ) ) ; } @Override public IComplexNumber getComplex ( int i ) { return dataType ( ) = = DataBuffer . Type . FLOAT ? getComplexFloat ( i ) : getComplexDouble ( i ) ; } protected void set ( int index , int length , Pointer from , int inc ) { modified . set ( true ) ; int offset = getElementSize ( ) * index ; if ( offset > = length ( ) * getElementSize ( ) ) throw new IllegalArgumentException ( <str> + offset + <str> + index + <str> + length ( ) ) ; JCublas2 . cublasSetVectorAsync ( length , getElementSize ( ) , from , inc , getHostPointer ( ) . withByteOffset ( offset ) , <int> , ContextHolder . getInstance ( ) . getCudaStream ( ) ) ; ContextHolder . getInstance ( ) . setContext ( ) ; } protected void set ( int index , int length , Pointer from ) { set ( index , length , from , <int> ) ; } @Override public void assign ( DataBuffer data ) { JCudaBuffer buf = ( JCudaBuffer ) data ; set ( <int> , buf . getHostPointer ( ) ) ; } protected void set ( int index , Pointer from ) { set ( index , <int> , from ) ; } @Override public boolean freeDevicePointer ( int offset , int length ) { String name = Thread . currentThread ( ) . getName ( ) ; DevicePointerInfo devicePointerInfo = pointersToContexts . get ( name , offset ) ; if ( offset ! = <int> ) pointersToContexts . remove ( name , offset ) ; else if ( offset = = <int> & & isPersist ) { return true ; } else if ( devicePointerInfo ! = null & & ! freed . get ( ) ) { allocated . addAndGet ( - devicePointerInfo . getLength ( ) ) ; log . trace ( <str> , devicePointerInfo . getLength ( ) , allocated . get ( ) ) ; ContextHolder . getInstance ( ) . getMemoryStrategy ( ) . free ( this , offset , length ) ; freed . set ( true ) ; copied . remove ( name ) ; pointersToContexts . remove ( name , Triple . of ( offset , length , devicePointerInfo . getStride ( ) ) ) ; return true ; } return false ; } @Override public synchronized void copyToHost ( CudaContext context , int offset , int length , int stride ) { DevicePointerInfo devicePointerInfo = pointersToContexts . get ( Thread . currentThread ( ) . getName ( ) , Triple . of ( offset , length , stride ) ) ; if ( devicePointerInfo = = null ) throw new IllegalStateException ( <str> + offset ) ; if ( devicePointerInfo . getOffset ( ) ! = offset ) throw new IllegalStateException ( <str> ) ; if ( devicePointerInfo ! = null ) { ContextHolder . getInstance ( ) . getMemoryStrategy ( ) . copyToHost ( this , offset , stride , length , null , offset , stride ) ; } else throw new IllegalStateException ( <str> ) ; context . syncOldStream ( ) ; } @Override public synchronized void copyToHost ( int offset , int length ) { DevicePointerInfo devicePointerInfo = pointersToContexts . get ( Thread . currentThread ( ) . getName ( ) , Triple . of ( offset , length , <int> ) ) ; if ( devicePointerInfo = = null ) throw new IllegalStateException ( <str> + offset ) ; if ( devicePointerInfo . getOffset ( ) ! = offset ) throw new IllegalStateException ( <str> ) ; if ( devicePointerInfo ! = null ) { int deviceStride = devicePointerInfo . getStride ( ) ; int deviceOffset = devicePointerInfo . getOffset ( ) ; int deviceLength = ( int ) devicePointerInfo . getLength ( ) ; if ( deviceOffset = = <int> & & length < length ( ) ) { ContextHolder . getInstance ( ) . getMemoryStrategy ( ) . copyToHost ( this , offset , deviceStride , deviceLength , null , deviceOffset , deviceStride ) ; } else { ContextHolder . getInstance ( ) . getMemoryStrategy ( ) . copyToHost ( this , offset , deviceStride , deviceLength , null , deviceOffset , deviceStride ) ; } } } @Override public void flush ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void destroy ( ) { } private void writeObject ( java . io . ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; write ( stream ) ; } private void readObject ( java . io . ObjectInputStream stream ) throws IOException , ClassNotFoundException { doReadObject ( stream ) ; copied = new HashMap < > ( ) ; pointersToContexts = HashBasedTable . create ( ) ; ref = new WeakReference < DataBuffer > ( this , Nd4j . bufferRefQueue ( ) ) ; freed = new AtomicBoolean ( false ) ; } @Override public Table < String , Triple < Integer , Integer , Integer > , DevicePointerInfo > getPointersToContexts ( ) { return pointersToContexts ; } public void setPointersToContexts ( Table < String , Triple < Integer , Integer , Integer > , DevicePointerInfo > pointersToContexts ) { this . pointersToContexts = pointersToContexts ; } @Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; for ( int i = <int> ; i < length ( ) ; i + + ) { sb . append ( getDouble ( i ) ) ; if ( i < length ( ) - <int> ) sb . append ( <str> ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } } 
