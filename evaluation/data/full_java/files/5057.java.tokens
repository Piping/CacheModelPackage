package org . elasticsearch . action . admin . indices . alias ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . query . QueryBuilder ; import java . io . IOException ; import java . util . Map ; public class Alias implements Streamable { private String name ; @Nullable private String filter ; @Nullable private String indexRouting ; @Nullable private String searchRouting ; private Alias ( ) { } public Alias ( String name ) { this . name = name ; } public String name ( ) { return name ; } public String filter ( ) { return filter ; } public Alias filter ( String filter ) { this . filter = filter ; return this ; } public Alias filter ( Map < String , Object > filter ) { if ( filter = = null | | filter . isEmpty ( ) ) { this . filter = null ; return this ; } try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( filter ) ; this . filter = builder . string ( ) ; return this ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + filter + <str> , e ) ; } } public Alias filter ( QueryBuilder filterBuilder ) { if ( filterBuilder = = null ) { this . filter = null ; return this ; } try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; filterBuilder . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . close ( ) ; this . filter = builder . string ( ) ; return this ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public Alias routing ( String routing ) { this . indexRouting = routing ; this . searchRouting = routing ; return this ; } public String indexRouting ( ) { return indexRouting ; } public Alias indexRouting ( String indexRouting ) { this . indexRouting = indexRouting ; return this ; } public String searchRouting ( ) { return searchRouting ; } public Alias searchRouting ( String searchRouting ) { this . searchRouting = searchRouting ; return this ; } public static Alias read ( StreamInput in ) throws IOException { Alias alias = new Alias ( ) ; alias . readFrom ( in ) ; return alias ; } @Override public void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; filter = in . readOptionalString ( ) ; indexRouting = in . readOptionalString ( ) ; searchRouting = in . readOptionalString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeOptionalString ( filter ) ; out . writeOptionalString ( indexRouting ) ; out . writeOptionalString ( searchRouting ) ; } public static Alias fromXContent ( XContentParser parser ) throws IOException { Alias alias = new Alias ( parser . currentName ( ) ) ; String currentFieldName = null ; XContentParser . Token token = parser . nextToken ( ) ; if ( token = = null ) { throw new IllegalArgumentException ( <str> ) ; } while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { Map < String , Object > filter = parser . mapOrdered ( ) ; alias . filter ( filter ) ; } } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( <str> . equals ( currentFieldName ) ) { alias . routing ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { alias . indexRouting ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { alias . searchRouting ( parser . text ( ) ) ; } } } return alias ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Alias alias = ( Alias ) o ; if ( name ! = null ? ! name . equals ( alias . name ) : alias . name ! = null ) return false ; return true ; } @Override public int hashCode ( ) { return name ! = null ? name . hashCode ( ) : <int> ; } } 
