package com . google . common . util . concurrent ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Preconditions ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; @Beta @GwtCompatible ( emulated = true ) public final class Uninterruptibles { @GwtIncompatible ( <str> ) public static void awaitUninterruptibly ( CountDownLatch latch ) { boolean interrupted = false ; try { while ( true ) { try { latch . await ( ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static boolean awaitUninterruptibly ( CountDownLatch latch , long timeout , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { return latch . await ( remainingNanos , NANOSECONDS ) ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static void joinUninterruptibly ( Thread toJoin ) { boolean interrupted = false ; try { while ( true ) { try { toJoin . join ( ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } public static < V > V getUninterruptibly ( Future < V > future ) throws ExecutionException { boolean interrupted = false ; try { while ( true ) { try { return future . get ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static < V > V getUninterruptibly ( Future < V > future , long timeout , TimeUnit unit ) throws ExecutionException , TimeoutException { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { return future . get ( remainingNanos , NANOSECONDS ) ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static void joinUninterruptibly ( Thread toJoin , long timeout , TimeUnit unit ) { Preconditions . checkNotNull ( toJoin ) ; boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { NANOSECONDS . timedJoin ( toJoin , remainingNanos ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static < E > E takeUninterruptibly ( BlockingQueue < E > queue ) { boolean interrupted = false ; try { while ( true ) { try { return queue . take ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static < E > void putUninterruptibly ( BlockingQueue < E > queue , E element ) { boolean interrupted = false ; try { while ( true ) { try { queue . put ( element ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static void sleepUninterruptibly ( long sleepFor , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( sleepFor ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { NANOSECONDS . sleep ( remainingNanos ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } @GwtIncompatible ( <str> ) public static boolean tryAcquireUninterruptibly ( Semaphore semaphore , long timeout , TimeUnit unit ) { return tryAcquireUninterruptibly ( semaphore , <int> , timeout , unit ) ; } @GwtIncompatible ( <str> ) public static boolean tryAcquireUninterruptibly ( Semaphore semaphore , int permits , long timeout , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { return semaphore . tryAcquire ( permits , remainingNanos , NANOSECONDS ) ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } private Uninterruptibles ( ) { } } 
