package org . elasticsearch . action . bulk ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . action . get . MultiGetItemResponse ; import org . elasticsearch . action . get . MultiGetRequestBuilder ; import org . elasticsearch . action . get . MultiGetResponse ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . transport . TransportClient ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . both ; import static org . hamcrest . Matchers . either ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class BulkProcessorIT extends ESIntegTestCase { public void testThatBulkProcessorCountIsCorrect ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; BulkProcessorTestListener listener = new BulkProcessorTestListener ( latch ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; try ( BulkProcessor processor = BulkProcessor . builder ( client ( ) , listener ) . setName ( <str> ) . setConcurrentRequests ( randomIntBetween ( <int> , <int> ) ) . setBulkActions ( numDocs ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ) . build ( ) ) { MultiGetRequestBuilder multiGetRequestBuilder = indexDocs ( client ( ) , processor , numDocs ) ; latch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( <int> ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( <int> ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertResponseItems ( listener . bulkItems , numDocs ) ; assertMultiGetResponse ( multiGetRequestBuilder . get ( ) , numDocs ) ; } } public void testBulkProcessorFlush ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; BulkProcessorTestListener listener = new BulkProcessorTestListener ( latch ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; try ( BulkProcessor processor = BulkProcessor . builder ( client ( ) , listener ) . setName ( <str> ) . setConcurrentRequests ( randomIntBetween ( <int> , <int> ) ) . setBulkActions ( numDocs + randomIntBetween ( <int> , <int> ) ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ) . build ( ) ) { MultiGetRequestBuilder multiGetRequestBuilder = indexDocs ( client ( ) , processor , numDocs ) ; assertThat ( latch . await ( randomInt ( <int> ) , TimeUnit . MILLISECONDS ) , equalTo ( false ) ) ; processor . flush ( ) ; latch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( <int> ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( <int> ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertResponseItems ( listener . bulkItems , numDocs ) ; assertMultiGetResponse ( multiGetRequestBuilder . get ( ) , numDocs ) ; } } public void testBulkProcessorConcurrentRequests ( ) throws Exception { int bulkActions = randomIntBetween ( <int> , <int> ) ; int numDocs = randomIntBetween ( bulkActions , bulkActions + <int> ) ; int concurrentRequests = randomIntBetween ( <int> , <int> ) ; int expectedBulkActions = numDocs / bulkActions ; final CountDownLatch latch = new CountDownLatch ( expectedBulkActions ) ; int totalExpectedBulkActions = numDocs % bulkActions = = <int> ? expectedBulkActions : expectedBulkActions + <int> ; final CountDownLatch closeLatch = new CountDownLatch ( totalExpectedBulkActions ) ; BulkProcessorTestListener listener = new BulkProcessorTestListener ( latch , closeLatch ) ; MultiGetRequestBuilder multiGetRequestBuilder ; try ( BulkProcessor processor = BulkProcessor . builder ( client ( ) , listener ) . setConcurrentRequests ( concurrentRequests ) . setBulkActions ( bulkActions ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ) . build ( ) ) { multiGetRequestBuilder = indexDocs ( client ( ) , processor , numDocs ) ; latch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( expectedBulkActions ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( expectedBulkActions ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertThat ( listener . bulkItems . size ( ) , equalTo ( numDocs - numDocs % bulkActions ) ) ; } closeLatch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( totalExpectedBulkActions ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( totalExpectedBulkActions ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertThat ( listener . bulkItems . size ( ) , equalTo ( numDocs ) ) ; Set < String > ids = new HashSet < > ( ) ; for ( BulkItemResponse bulkItemResponse : listener . bulkItems ) { assertThat ( bulkItemResponse . getFailureMessage ( ) , bulkItemResponse . isFailed ( ) , equalTo ( false ) ) ; assertThat ( bulkItemResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( bulkItemResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( Integer . valueOf ( bulkItemResponse . getId ( ) ) , both ( greaterThan ( <int> ) ) . and ( lessThanOrEqualTo ( numDocs ) ) ) ; assertThat ( ids . add ( bulkItemResponse . getId ( ) ) , equalTo ( true ) ) ; } assertMultiGetResponse ( multiGetRequestBuilder . get ( ) , numDocs ) ; } public void testBulkProcessorConcurrentRequestsNoNodeAvailableException ( ) throws Exception { Settings settings = Settings . builder ( ) . put ( <str> , createTempDir ( ) . toString ( ) ) . build ( ) ; Client transportClient = TransportClient . builder ( ) . settings ( settings ) . build ( ) ; int bulkActions = randomIntBetween ( <int> , <int> ) ; int numDocs = randomIntBetween ( bulkActions , bulkActions + <int> ) ; int concurrentRequests = randomIntBetween ( <int> , <int> ) ; int expectedBulkActions = numDocs / bulkActions ; final CountDownLatch latch = new CountDownLatch ( expectedBulkActions ) ; int totalExpectedBulkActions = numDocs % bulkActions = = <int> ? expectedBulkActions : expectedBulkActions + <int> ; final CountDownLatch closeLatch = new CountDownLatch ( totalExpectedBulkActions ) ; BulkProcessorTestListener listener = new BulkProcessorTestListener ( latch , closeLatch ) ; try ( BulkProcessor processor = BulkProcessor . builder ( transportClient , listener ) . setConcurrentRequests ( concurrentRequests ) . setBulkActions ( bulkActions ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ) . build ( ) ) { indexDocs ( transportClient , processor , numDocs ) ; latch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( expectedBulkActions ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( expectedBulkActions ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( expectedBulkActions ) ) ; assertThat ( listener . bulkItems . size ( ) , equalTo ( <int> ) ) ; } closeLatch . await ( ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( totalExpectedBulkActions ) ) ; assertThat ( listener . bulkItems . size ( ) , equalTo ( <int> ) ) ; transportClient . close ( ) ; } public void testBulkProcessorWaitOnClose ( ) throws Exception { BulkProcessorTestListener listener = new BulkProcessorTestListener ( ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; BulkProcessor processor = BulkProcessor . builder ( client ( ) , listener ) . setName ( <str> ) . setConcurrentRequests ( randomIntBetween ( <int> , <int> ) ) . setBulkActions ( numDocs ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( randomIntBetween ( <int> , <int> ) , RandomPicks . randomFrom ( getRandom ( ) , ByteSizeUnit . values ( ) ) ) ) . build ( ) ; MultiGetRequestBuilder multiGetRequestBuilder = indexDocs ( client ( ) , processor , numDocs ) ; assertThat ( processor . isOpen ( ) , is ( true ) ) ; assertThat ( processor . awaitClose ( <int> , TimeUnit . MINUTES ) , is ( true ) ) ; if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { assertThat ( processor . awaitClose ( <int> , TimeUnit . MINUTES ) , is ( true ) ) ; } else { processor . close ( ) ; } } assertThat ( processor . isOpen ( ) , is ( false ) ) ; assertThat ( listener . beforeCounts . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( listener . afterCounts . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertResponseItems ( listener . bulkItems , numDocs ) ; assertMultiGetResponse ( multiGetRequestBuilder . get ( ) , numDocs ) ; } public void testBulkProcessorConcurrentRequestsReadOnlyIndex ( ) throws Exception { createIndex ( <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_BLOCKS_WRITE , true ) ) ) ; ensureGreen ( ) ; int bulkActions = randomIntBetween ( <int> , <int> ) ; int numDocs = randomIntBetween ( bulkActions , bulkActions + <int> ) ; int concurrentRequests = randomIntBetween ( <int> , <int> ) ; int expectedBulkActions = numDocs / bulkActions ; final CountDownLatch latch = new CountDownLatch ( expectedBulkActions ) ; int totalExpectedBulkActions = numDocs % bulkActions = = <int> ? expectedBulkActions : expectedBulkActions + <int> ; final CountDownLatch closeLatch = new CountDownLatch ( totalExpectedBulkActions ) ; int testDocs = <int> ; int testReadOnlyDocs = <int> ; MultiGetRequestBuilder multiGetRequestBuilder = client ( ) . prepareMultiGet ( ) ; BulkProcessorTestListener listener = new BulkProcessorTestListener ( latch , closeLatch ) ; try ( BulkProcessor processor = BulkProcessor . builder ( client ( ) , listener ) . setConcurrentRequests ( concurrentRequests ) . setBulkActions ( bulkActions ) . setFlushInterval ( TimeValue . timeValueHours ( <int> ) ) . setBulkSize ( new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ) . build ( ) ) { for ( int i = <int> ; i < = numDocs ; i + + ) { if ( randomBoolean ( ) ) { testDocs + + ; processor . add ( new IndexRequest ( <str> , <str> , Integer . toString ( testDocs ) ) . source ( <str> , <str> ) ) ; multiGetRequestBuilder . add ( <str> , <str> , Integer . toString ( testDocs ) ) ; } else { testReadOnlyDocs + + ; processor . add ( new IndexRequest ( <str> , <str> , Integer . toString ( testReadOnlyDocs ) ) . source ( <str> , <str> ) ) ; } } } closeLatch . await ( ) ; assertThat ( listener . beforeCounts . get ( ) , equalTo ( totalExpectedBulkActions ) ) ; assertThat ( listener . afterCounts . get ( ) , equalTo ( totalExpectedBulkActions ) ) ; assertThat ( listener . bulkFailures . size ( ) , equalTo ( <int> ) ) ; assertThat ( listener . bulkItems . size ( ) , equalTo ( testDocs + testReadOnlyDocs ) ) ; Set < String > ids = new HashSet < > ( ) ; Set < String > readOnlyIds = new HashSet < > ( ) ; for ( BulkItemResponse bulkItemResponse : listener . bulkItems ) { assertThat ( bulkItemResponse . getIndex ( ) , either ( equalTo ( <str> ) ) . or ( equalTo ( <str> ) ) ) ; assertThat ( bulkItemResponse . getType ( ) , equalTo ( <str> ) ) ; if ( bulkItemResponse . getIndex ( ) . equals ( <str> ) ) { assertThat ( bulkItemResponse . isFailed ( ) , equalTo ( false ) ) ; assertThat ( Integer . valueOf ( bulkItemResponse . getId ( ) ) , both ( greaterThan ( <int> ) ) . and ( lessThanOrEqualTo ( testDocs ) ) ) ; assertThat ( ids . add ( bulkItemResponse . getId ( ) ) , equalTo ( true ) ) ; } else { assertThat ( bulkItemResponse . isFailed ( ) , equalTo ( true ) ) ; assertThat ( Integer . valueOf ( bulkItemResponse . getId ( ) ) , both ( greaterThan ( <int> ) ) . and ( lessThanOrEqualTo ( testReadOnlyDocs ) ) ) ; assertThat ( readOnlyIds . add ( bulkItemResponse . getId ( ) ) , equalTo ( true ) ) ; } } assertMultiGetResponse ( multiGetRequestBuilder . get ( ) , testDocs ) ; } private static MultiGetRequestBuilder indexDocs ( Client client , BulkProcessor processor , int numDocs ) { MultiGetRequestBuilder multiGetRequestBuilder = client . prepareMultiGet ( ) ; for ( int i = <int> ; i < = numDocs ; i + + ) { processor . add ( new IndexRequest ( <str> , <str> , Integer . toString ( i ) ) . source ( <str> , randomRealisticUnicodeOfLengthBetween ( <int> , <int> ) ) ) ; multiGetRequestBuilder . add ( <str> , <str> , Integer . toString ( i ) ) ; } return multiGetRequestBuilder ; } private static void assertResponseItems ( List < BulkItemResponse > bulkItemResponses , int numDocs ) { assertThat ( bulkItemResponses . size ( ) , is ( numDocs ) ) ; int i = <int> ; for ( BulkItemResponse bulkItemResponse : bulkItemResponses ) { assertThat ( bulkItemResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( bulkItemResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( bulkItemResponse . getId ( ) , equalTo ( Integer . toString ( i + + ) ) ) ; assertThat ( bulkItemResponse . isFailed ( ) , equalTo ( false ) ) ; } } private static void assertMultiGetResponse ( MultiGetResponse multiGetResponse , int numDocs ) { assertThat ( multiGetResponse . getResponses ( ) . length , equalTo ( numDocs ) ) ; int i = <int> ; for ( MultiGetItemResponse multiGetItemResponse : multiGetResponse ) { assertThat ( multiGetItemResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getType ( ) , equalTo ( <str> ) ) ; assertThat ( multiGetItemResponse . getId ( ) , equalTo ( Integer . toString ( i + + ) ) ) ; } } private static class BulkProcessorTestListener implements BulkProcessor . Listener { private final CountDownLatch [ ] latches ; private final AtomicInteger beforeCounts = new AtomicInteger ( ) ; private final AtomicInteger afterCounts = new AtomicInteger ( ) ; private final List < BulkItemResponse > bulkItems = new CopyOnWriteArrayList < > ( ) ; private final List < Throwable > bulkFailures = new CopyOnWriteArrayList < > ( ) ; private BulkProcessorTestListener ( CountDownLatch . . . latches ) { this . latches = latches ; } @Override public void beforeBulk ( long executionId , BulkRequest request ) { beforeCounts . incrementAndGet ( ) ; } @Override public void afterBulk ( long executionId , BulkRequest request , BulkResponse response ) { bulkItems . addAll ( Arrays . asList ( response . getItems ( ) ) ) ; afterCounts . incrementAndGet ( ) ; for ( CountDownLatch latch : latches ) { latch . countDown ( ) ; } } @Override public void afterBulk ( long executionId , BulkRequest request , Throwable failure ) { bulkFailures . add ( failure ) ; afterCounts . incrementAndGet ( ) ; for ( CountDownLatch latch : latches ) { latch . countDown ( ) ; } } } } 
