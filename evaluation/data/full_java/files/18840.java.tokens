package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . util . List ; public class DelimiterBasedFrameDecoder extends ByteToMessageDecoder { private final ByteBuf [ ] delimiters ; private final int maxFrameLength ; private final boolean stripDelimiter ; private final boolean failFast ; private boolean discardingTooLongFrame ; private int tooLongFrameLength ; private final LineBasedFrameDecoder lineBasedDecoder ; public DelimiterBasedFrameDecoder ( int maxFrameLength , ByteBuf delimiter ) { this ( maxFrameLength , true , delimiter ) ; } public DelimiterBasedFrameDecoder ( int maxFrameLength , boolean stripDelimiter , ByteBuf delimiter ) { this ( maxFrameLength , stripDelimiter , true , delimiter ) ; } public DelimiterBasedFrameDecoder ( int maxFrameLength , boolean stripDelimiter , boolean failFast , ByteBuf delimiter ) { this ( maxFrameLength , stripDelimiter , failFast , new ByteBuf [ ] { delimiter . slice ( delimiter . readerIndex ( ) , delimiter . readableBytes ( ) ) } ) ; } public DelimiterBasedFrameDecoder ( int maxFrameLength , ByteBuf . . . delimiters ) { this ( maxFrameLength , true , delimiters ) ; } public DelimiterBasedFrameDecoder ( int maxFrameLength , boolean stripDelimiter , ByteBuf . . . delimiters ) { this ( maxFrameLength , stripDelimiter , true , delimiters ) ; } public DelimiterBasedFrameDecoder ( int maxFrameLength , boolean stripDelimiter , boolean failFast , ByteBuf . . . delimiters ) { validateMaxFrameLength ( maxFrameLength ) ; if ( delimiters = = null ) { throw new NullPointerException ( <str> ) ; } if ( delimiters . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( isLineBased ( delimiters ) & & ! isSubclass ( ) ) { lineBasedDecoder = new LineBasedFrameDecoder ( maxFrameLength , stripDelimiter , failFast ) ; this . delimiters = null ; } else { this . delimiters = new ByteBuf [ delimiters . length ] ; for ( int i = <int> ; i < delimiters . length ; i + + ) { ByteBuf d = delimiters [ i ] ; validateDelimiter ( d ) ; this . delimiters [ i ] = d . slice ( d . readerIndex ( ) , d . readableBytes ( ) ) ; } lineBasedDecoder = null ; } this . maxFrameLength = maxFrameLength ; this . stripDelimiter = stripDelimiter ; this . failFast = failFast ; } private static boolean isLineBased ( final ByteBuf [ ] delimiters ) { if ( delimiters . length ! = <int> ) { return false ; } ByteBuf a = delimiters [ <int> ] ; ByteBuf b = delimiters [ <int> ] ; if ( a . capacity ( ) < b . capacity ( ) ) { a = delimiters [ <int> ] ; b = delimiters [ <int> ] ; } return a . capacity ( ) = = <int> & & b . capacity ( ) = = <int> & & a . getByte ( <int> ) = = <str> & & a . getByte ( <int> ) = = <str> & & b . getByte ( <int> ) = = <str> ; } private boolean isSubclass ( ) { return getClass ( ) ! = DelimiterBasedFrameDecoder . class ; } @Override protected final void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { Object decoded = decode ( ctx , in ) ; if ( decoded ! = null ) { out . add ( decoded ) ; } } protected Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { if ( lineBasedDecoder ! = null ) { return lineBasedDecoder . decode ( ctx , buffer ) ; } int minFrameLength = Integer . MAX_VALUE ; ByteBuf minDelim = null ; for ( ByteBuf delim : delimiters ) { int frameLength = indexOf ( buffer , delim ) ; if ( frameLength > = <int> & & frameLength < minFrameLength ) { minFrameLength = frameLength ; minDelim = delim ; } } if ( minDelim ! = null ) { int minDelimLength = minDelim . capacity ( ) ; ByteBuf frame ; if ( discardingTooLongFrame ) { discardingTooLongFrame = false ; buffer . skipBytes ( minFrameLength + minDelimLength ) ; int tooLongFrameLength = this . tooLongFrameLength ; this . tooLongFrameLength = <int> ; if ( ! failFast ) { fail ( tooLongFrameLength ) ; } return null ; } if ( minFrameLength > maxFrameLength ) { buffer . skipBytes ( minFrameLength + minDelimLength ) ; fail ( minFrameLength ) ; return null ; } if ( stripDelimiter ) { frame = buffer . readSlice ( minFrameLength ) ; buffer . skipBytes ( minDelimLength ) ; } else { frame = buffer . readSlice ( minFrameLength + minDelimLength ) ; } return frame . retain ( ) ; } else { if ( ! discardingTooLongFrame ) { if ( buffer . readableBytes ( ) > maxFrameLength ) { tooLongFrameLength = buffer . readableBytes ( ) ; buffer . skipBytes ( buffer . readableBytes ( ) ) ; discardingTooLongFrame = true ; if ( failFast ) { fail ( tooLongFrameLength ) ; } } } else { tooLongFrameLength + = buffer . readableBytes ( ) ; buffer . skipBytes ( buffer . readableBytes ( ) ) ; } return null ; } } private void fail ( long frameLength ) { if ( frameLength > <int> ) { throw new TooLongFrameException ( <str> + maxFrameLength + <str> + frameLength + <str> ) ; } else { throw new TooLongFrameException ( <str> + maxFrameLength + <str> ) ; } } private static int indexOf ( ByteBuf haystack , ByteBuf needle ) { for ( int i = haystack . readerIndex ( ) ; i < haystack . writerIndex ( ) ; i + + ) { int haystackIndex = i ; int needleIndex ; for ( needleIndex = <int> ; needleIndex < needle . capacity ( ) ; needleIndex + + ) { if ( haystack . getByte ( haystackIndex ) ! = needle . getByte ( needleIndex ) ) { break ; } else { haystackIndex + + ; if ( haystackIndex = = haystack . writerIndex ( ) & & needleIndex ! = needle . capacity ( ) - <int> ) { return - <int> ; } } } if ( needleIndex = = needle . capacity ( ) ) { return i - haystack . readerIndex ( ) ; } } return - <int> ; } private static void validateDelimiter ( ByteBuf delimiter ) { if ( delimiter = = null ) { throw new NullPointerException ( <str> ) ; } if ( ! delimiter . isReadable ( ) ) { throw new IllegalArgumentException ( <str> ) ; } } private static void validateMaxFrameLength ( int maxFrameLength ) { if ( maxFrameLength < = <int> ) { throw new IllegalArgumentException ( <str> + maxFrameLength ) ; } } } 
