package com . badlogic . gdx . utils ; import java . io . IOException ; import java . io . Writer ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . regex . Pattern ; public class JsonWriter extends Writer { final Writer writer ; private final Array < JsonObject > stack = new Array ( ) ; private JsonObject current ; private boolean named ; private OutputType outputType = OutputType . json ; private boolean quoteLongValues = false ; public JsonWriter ( Writer writer ) { this . writer = writer ; } public Writer getWriter ( ) { return writer ; } public void setOutputType ( OutputType outputType ) { this . outputType = outputType ; } public void setQuoteLongValues ( boolean quoteLongValues ) { this . quoteLongValues = quoteLongValues ; } public JsonWriter name ( String name ) throws IOException { if ( current = = null | | current . array ) throw new IllegalStateException ( <str> ) ; if ( ! current . needsComma ) current . needsComma = true ; else writer . write ( <str> ) ; writer . write ( outputType . quoteName ( name ) ) ; writer . write ( <str> ) ; named = true ; return this ; } public JsonWriter object ( ) throws IOException { requireCommaOrName ( ) ; stack . add ( current = new JsonObject ( false ) ) ; return this ; } public JsonWriter array ( ) throws IOException { requireCommaOrName ( ) ; stack . add ( current = new JsonObject ( true ) ) ; return this ; } public JsonWriter value ( Object value ) throws IOException { if ( quoteLongValues & & ( value instanceof Long | | value instanceof Double | | value instanceof BigDecimal | | value instanceof BigInteger ) ) { value = value . toString ( ) ; } else if ( value instanceof Number ) { Number number = ( Number ) value ; long longValue = number . longValue ( ) ; if ( number . doubleValue ( ) = = longValue ) value = longValue ; } requireCommaOrName ( ) ; writer . write ( outputType . quoteValue ( value ) ) ; return this ; } public JsonWriter json ( String json ) throws IOException { requireCommaOrName ( ) ; writer . write ( json ) ; return this ; } private void requireCommaOrName ( ) throws IOException { if ( current = = null ) return ; if ( current . array ) { if ( ! current . needsComma ) current . needsComma = true ; else writer . write ( <str> ) ; } else { if ( ! named ) throw new IllegalStateException ( <str> ) ; named = false ; } } public JsonWriter object ( String name ) throws IOException { return name ( name ) . object ( ) ; } public JsonWriter array ( String name ) throws IOException { return name ( name ) . array ( ) ; } public JsonWriter set ( String name , Object value ) throws IOException { return name ( name ) . value ( value ) ; } public JsonWriter json ( String name , String json ) throws IOException { return name ( name ) . json ( json ) ; } public JsonWriter pop ( ) throws IOException { if ( named ) throw new IllegalStateException ( <str> ) ; stack . pop ( ) . close ( ) ; current = stack . size = = <int> ? null : stack . peek ( ) ; return this ; } public void write ( char [ ] cbuf , int off , int len ) throws IOException { writer . write ( cbuf , off , len ) ; } public void flush ( ) throws IOException { writer . flush ( ) ; } public void close ( ) throws IOException { while ( stack . size > <int> ) pop ( ) ; writer . close ( ) ; } private class JsonObject { final boolean array ; boolean needsComma ; JsonObject ( boolean array ) throws IOException { this . array = array ; writer . write ( array ? <str> : <str> ) ; } void close ( ) throws IOException { writer . write ( array ? <str> : <str> ) ; } } static public enum OutputType { json , javascript , minimal ; static private Pattern javascriptPattern = Pattern . compile ( <str> ) ; static private Pattern minimalNamePattern = Pattern . compile ( <str> ) ; static private Pattern minimalValuePattern = Pattern . compile ( <str> ) ; public String quoteValue ( Object value ) { if ( value = = null ) return <str> ; String string = value . toString ( ) ; if ( value instanceof Number | | value instanceof Boolean ) return string ; StringBuilder buffer = new StringBuilder ( string ) ; buffer . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) ; if ( this = = OutputType . minimal & & ! string . equals ( <str> ) & & ! string . equals ( <str> ) & & ! string . equals ( <str> ) & & ! string . contains ( <str> ) & & ! string . contains ( <str> ) ) { int length = buffer . length ( ) ; if ( length > <int> & & buffer . charAt ( length - <int> ) ! = <str> & & minimalValuePattern . matcher ( buffer ) . matches ( ) ) return buffer . toString ( ) ; } return <str> + buffer . replace ( <str> , <str> ) . toString ( ) + <str> ; } public String quoteName ( String value ) { StringBuilder buffer = new StringBuilder ( value ) ; buffer . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) ; switch ( this ) { case minimal : if ( ! value . contains ( <str> ) & & ! value . contains ( <str> ) & & minimalNamePattern . matcher ( buffer ) . matches ( ) ) return buffer . toString ( ) ; case javascript : if ( javascriptPattern . matcher ( buffer ) . matches ( ) ) return buffer . toString ( ) ; } return <str> + buffer . replace ( <str> , <str> ) . toString ( ) + <str> ; } } } 
