package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . SocketChannel ; import io . netty . handler . traffic . AbstractTrafficShapingHandler ; import io . netty . handler . traffic . ChannelTrafficShapingHandler ; import io . netty . handler . traffic . GlobalTrafficShapingHandler ; import io . netty . handler . traffic . TrafficCounter ; import io . netty . util . concurrent . DefaultEventExecutorGroup ; import io . netty . util . concurrent . EventExecutorGroup ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import java . io . IOException ; import java . util . Arrays ; import java . util . Random ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . * ; public class TrafficShapingHandlerTest extends AbstractSocketTest { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( TrafficShapingHandlerTest . class ) ; private static final InternalLogger loggerServer = InternalLoggerFactory . getInstance ( <str> ) ; private static final InternalLogger loggerClient = InternalLoggerFactory . getInstance ( <str> ) ; static final int messageSize = <int> ; static final int bandwidthFactor = <int> ; static final int minfactor = <int> ; static final int maxfactor = bandwidthFactor + bandwidthFactor / <int> ; static final long stepms = ( <int> / bandwidthFactor - <int> ) / <int> * <int> ; static final long minimalms = Math . max ( stepms / <int> , <int> ) / <int> * <int> ; static final long check = <int> ; private static final Random random = new Random ( ) ; static final byte [ ] data = new byte [ messageSize ] ; private static final String TRAFFIC = <str> ; private static String currentTestName ; private static int currentTestRun ; private static EventExecutorGroup group ; private static EventExecutorGroup groupForGlobal ; private static final ScheduledExecutorService executor = Executors . newScheduledThreadPool ( <int> ) ; static { random . nextBytes ( data ) ; } @BeforeClass public static void createGroup ( ) { logger . info ( <str> + minfactor + <str> + bandwidthFactor + <str> + maxfactor + <str> + stepms + <str> + minimalms + <str> + check ) ; group = new DefaultEventExecutorGroup ( <int> ) ; groupForGlobal = new DefaultEventExecutorGroup ( <int> ) ; } @AfterClass public static void destroyGroup ( ) throws Exception { group . shutdownGracefully ( ) . sync ( ) ; groupForGlobal . shutdownGracefully ( ) . sync ( ) ; executor . shutdown ( ) ; } private static long [ ] computeWaitRead ( int [ ] multipleMessage ) { long [ ] minimalWaitBetween = new long [ multipleMessage . length + <int> ] ; minimalWaitBetween [ <int> ] = <int> ; for ( int i = <int> ; i < multipleMessage . length ; i + + ) { if ( multipleMessage [ i ] > <int> ) { minimalWaitBetween [ i + <int> ] = ( multipleMessage [ i ] - <int> ) * stepms + minimalms ; } else { minimalWaitBetween [ i + <int> ] = <int> ; } } return minimalWaitBetween ; } private static long [ ] computeWaitWrite ( int [ ] multipleMessage ) { long [ ] minimalWaitBetween = new long [ multipleMessage . length + <int> ] ; for ( int i = <int> ; i < multipleMessage . length ; i + + ) { if ( multipleMessage [ i ] > <int> ) { minimalWaitBetween [ i ] = ( multipleMessage [ i ] - <int> ) * stepms + minimalms ; } else { minimalWaitBetween [ i ] = <int> ; } } return minimalWaitBetween ; } private static long [ ] computeWaitAutoRead ( int [ ] autoRead ) { long [ ] minimalWaitBetween = new long [ autoRead . length + <int> ] ; minimalWaitBetween [ <int> ] = <int> ; for ( int i = <int> ; i < autoRead . length ; i + + ) { if ( autoRead [ i ] ! = <int> ) { if ( autoRead [ i ] > <int> ) { minimalWaitBetween [ i + <int> ] = - <int> ; } else { minimalWaitBetween [ i + <int> ] = check ; } } else { minimalWaitBetween [ i + <int> ] = <int> ; } } return minimalWaitBetween ; } @Test ( timeout = <int> ) public void testNoTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testNoTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> } ; long [ ] minimalWaitBetween = null ; testTrafficShapping0 ( sb , cb , false , false , false , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testWriteTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testWriteTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitWrite ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , false , true , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testReadTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testReadTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitRead ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , true , false , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testWrite1TrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testWrite1TrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitWrite ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , false , true , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testRead1TrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testRead1TrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitRead ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , true , false , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testWriteGlobalTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testWriteGlobalTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitWrite ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , false , true , true , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testReadGlobalTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testReadGlobalTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = null ; int [ ] multipleMessage = { <int> , <int> , <int> , <int> } ; long [ ] minimalWaitBetween = computeWaitRead ( multipleMessage ) ; testTrafficShapping0 ( sb , cb , false , true , false , true , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testAutoReadTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testAutoReadTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = { <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , <int> , - <int> , <int> , <int> , <int> , <int> } ; int [ ] multipleMessage = new int [ autoRead . length ] ; Arrays . fill ( multipleMessage , <int> ) ; long [ ] minimalWaitBetween = computeWaitAutoRead ( autoRead ) ; testTrafficShapping0 ( sb , cb , false , true , false , false , autoRead , minimalWaitBetween , multipleMessage ) ; } @Test ( timeout = <int> ) public void testAutoReadGlobalTrafficShapping ( ) throws Throwable { currentTestName = <str> ; currentTestRun = <int> ; run ( ) ; } public void testAutoReadGlobalTrafficShapping ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { int [ ] autoRead = { <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , <int> , - <int> , <int> , <int> , <int> , <int> } ; int [ ] multipleMessage = new int [ autoRead . length ] ; Arrays . fill ( multipleMessage , <int> ) ; long [ ] minimalWaitBetween = computeWaitAutoRead ( autoRead ) ; testTrafficShapping0 ( sb , cb , false , true , false , true , autoRead , minimalWaitBetween , multipleMessage ) ; } private static void testTrafficShapping0 ( ServerBootstrap sb , Bootstrap cb , final boolean additionalExecutor , final boolean limitRead , final boolean limitWrite , final boolean globalLimit , int [ ] autoRead , long [ ] minimalWaitBetween , int [ ] multipleMessage ) throws Throwable { currentTestRun + + ; logger . info ( <str> + currentTestName + <str> + currentTestRun + <str> + additionalExecutor + <str> + limitRead + <str> + limitWrite + <str> + globalLimit ) ; final ServerHandler sh = new ServerHandler ( autoRead , multipleMessage ) ; Promise < Boolean > promise = group . next ( ) . newPromise ( ) ; final ClientHandler ch = new ClientHandler ( promise , minimalWaitBetween , multipleMessage , autoRead ) ; final AbstractTrafficShapingHandler handler ; if ( limitRead ) { if ( globalLimit ) { handler = new GlobalTrafficShapingHandler ( groupForGlobal , <int> , bandwidthFactor * messageSize , check ) ; } else { handler = new ChannelTrafficShapingHandler ( <int> , bandwidthFactor * messageSize , check ) ; } } else if ( limitWrite ) { if ( globalLimit ) { handler = new GlobalTrafficShapingHandler ( groupForGlobal , bandwidthFactor * messageSize , <int> , check ) ; } else { handler = new ChannelTrafficShapingHandler ( bandwidthFactor * messageSize , <int> , check ) ; } } else { handler = null ; } sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel c ) throws Exception { if ( limitRead ) { c . pipeline ( ) . addLast ( TRAFFIC , handler ) ; } c . pipeline ( ) . addLast ( sh ) ; } } ) ; cb . handler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel c ) throws Exception { if ( limitWrite ) { c . pipeline ( ) . addLast ( TRAFFIC , handler ) ; } c . pipeline ( ) . addLast ( ch ) ; } } ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; int totalNb = <int> ; for ( int i = <int> ; i < multipleMessage . length ; i + + ) { totalNb + = multipleMessage [ i ] ; } Long start = TrafficCounter . milliSecondFromNano ( ) ; int nb = multipleMessage [ <int> ] ; for ( int i = <int> ; i < nb ; i + + ) { cc . write ( cc . alloc ( ) . buffer ( ) . writeBytes ( data ) ) ; } cc . flush ( ) ; promise . await ( ) ; Long stop = TrafficCounter . milliSecondFromNano ( ) ; assertTrue ( <str> + promise . cause ( ) , promise . isSuccess ( ) ) ; float average = ( totalNb * messageSize ) / ( float ) ( stop - start ) ; logger . info ( <str> + currentTestName + <str> + currentTestRun + <str> + average + <str> + bandwidthFactor ) ; sh . channel . close ( ) . sync ( ) ; ch . channel . close ( ) . sync ( ) ; sc . close ( ) . sync ( ) ; if ( autoRead ! = null ) { Thread . sleep ( minimalms ) ; } if ( autoRead = = null & & minimalWaitBetween ! = null ) { assertTrue ( <str> + maxfactor + <str> + average , average < = maxfactor ) ; if ( additionalExecutor ) { assertTrue ( <str> + average , average > = <float> ) ; } else { assertTrue ( <str> + minfactor + <str> + average , average > = minfactor ) ; } } if ( handler ! = null & & globalLimit ) { ( ( GlobalTrafficShapingHandler ) handler ) . release ( ) ; } if ( sh . exception . get ( ) ! = null & & ! ( sh . exception . get ( ) instanceof IOException ) ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null & & ! ( ch . exception . get ( ) instanceof IOException ) ) { throw ch . exception . get ( ) ; } if ( sh . exception . get ( ) ! = null ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null ) { throw ch . exception . get ( ) ; } } private static class ClientHandler extends SimpleChannelInboundHandler < ByteBuf > { volatile Channel channel ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; volatile int step ; private long currentLastTime = TrafficCounter . milliSecondFromNano ( ) ; private final long [ ] minimalWaitBetween ; private final int [ ] multipleMessage ; private final int [ ] autoRead ; final Promise < Boolean > promise ; ClientHandler ( Promise < Boolean > promise , long [ ] minimalWaitBetween , int [ ] multipleMessage , int [ ] autoRead ) { this . minimalWaitBetween = minimalWaitBetween ; this . multipleMessage = Arrays . copyOf ( multipleMessage , multipleMessage . length ) ; this . promise = promise ; this . autoRead = autoRead ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { channel = ctx . channel ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { long lastTimestamp = <int> ; loggerClient . debug ( <str> + step + <str> + in . readableBytes ( ) / <int> + <str> ) ; while ( in . isReadable ( ) ) { lastTimestamp = in . readLong ( ) ; multipleMessage [ step ] - - ; } if ( multipleMessage [ step ] > <int> ) { return ; } long minimalWait = minimalWaitBetween ! = null ? minimalWaitBetween [ step ] : <int> ; int ar = <int> ; if ( autoRead ! = null ) { if ( step > <int> & & autoRead [ step - <int> ] ! = <int> ) { ar = autoRead [ step - <int> ] ; } } loggerClient . info ( <str> + step + <str> + ( lastTimestamp - currentLastTime ) + <str> + minimalWait + <str> + ar + <str> ) ; assertTrue ( <str> + ( lastTimestamp - currentLastTime ) + <str> + minimalWait , lastTimestamp - currentLastTime > = minimalWait ) ; currentLastTime = lastTimestamp ; step + + ; if ( multipleMessage . length > step ) { int nb = multipleMessage [ step ] ; for ( int i = <int> ; i < nb ; i + + ) { channel . write ( channel . alloc ( ) . buffer ( ) . writeBytes ( data ) ) ; } channel . flush ( ) ; } else { promise . setSuccess ( true ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { cause . printStackTrace ( ) ; promise . setFailure ( cause ) ; ctx . close ( ) ; } } } private static class ServerHandler extends SimpleChannelInboundHandler < ByteBuf > { private final int [ ] autoRead ; private final int [ ] multipleMessage ; volatile Channel channel ; volatile int step ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; ServerHandler ( int [ ] autoRead , int [ ] multipleMessage ) { this . autoRead = autoRead ; this . multipleMessage = Arrays . copyOf ( multipleMessage , multipleMessage . length ) ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { channel = ctx . channel ( ) ; } @Override public void channelRead0 ( final ChannelHandlerContext ctx , ByteBuf in ) throws Exception { byte [ ] actual = new byte [ in . readableBytes ( ) ] ; int nb = actual . length / messageSize ; loggerServer . info ( <str> + step + <str> + nb + <str> ) ; in . readBytes ( actual ) ; long timestamp = TrafficCounter . milliSecondFromNano ( ) ; int isAutoRead = <int> ; int laststep = step ; for ( int i = <int> ; i < nb ; i + + ) { multipleMessage [ step ] - - ; if ( multipleMessage [ step ] = = <int> ) { if ( autoRead ! = null ) { isAutoRead = autoRead [ step ] ; } step + + ; } } if ( laststep ! = step ) { if ( autoRead ! = null & & isAutoRead ! = <int> ) { if ( isAutoRead ! = <int> ) { loggerServer . info ( <str> + step + <str> + ( isAutoRead > <int> ) ) ; channel . config ( ) . setAutoRead ( isAutoRead > <int> ) ; } else { loggerServer . info ( <str> + step + <str> ) ; } } } Thread . sleep ( <int> ) ; loggerServer . debug ( <str> + step + <str> + nb ) ; for ( int i = <int> ; i < nb ; i + + ) { channel . write ( Unpooled . copyLong ( timestamp ) ) ; } channel . flush ( ) ; if ( laststep ! = step ) { if ( isAutoRead ! = <int> ) { if ( isAutoRead < <int> ) { final int exactStep = step ; long wait = isAutoRead = = - <int> ? minimalms : stepms + minimalms ; if ( isAutoRead = = - <int> ) { wait = stepms * <int> ; } executor . schedule ( new Runnable ( ) { @Override public void run ( ) { loggerServer . info ( <str> + exactStep + <str> ) ; channel . config ( ) . setAutoRead ( true ) ; } } , wait , TimeUnit . MILLISECONDS ) ; } else { if ( isAutoRead > <int> ) { loggerServer . debug ( <str> + step + <str> ) ; final int exactStep = step ; executor . schedule ( new Runnable ( ) { @Override public void run ( ) { loggerServer . info ( <str> + exactStep + <str> ) ; channel . config ( ) . setAutoRead ( true ) ; } } , stepms + minimalms , TimeUnit . MILLISECONDS ) ; } } } } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } } } } 
