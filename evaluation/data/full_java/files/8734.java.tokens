package org . elasticsearch . discovery . ec2 ; import com . amazonaws . AmazonClientException ; import com . amazonaws . services . ec2 . AmazonEC2 ; import com . amazonaws . services . ec2 . model . * ; import org . elasticsearch . Version ; import org . elasticsearch . cloud . aws . AwsEc2Service ; import org . elasticsearch . cloud . aws . AwsEc2Service . DISCOVERY_EC2 ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . SingleObjectCache ; import org . elasticsearch . discovery . zen . ping . unicast . UnicastHostsProvider ; import org . elasticsearch . transport . TransportService ; import java . util . * ; public class AwsEc2UnicastHostsProvider extends AbstractComponent implements UnicastHostsProvider { private static enum HostType { PRIVATE_IP , PUBLIC_IP , PRIVATE_DNS , PUBLIC_DNS } private final TransportService transportService ; private final AmazonEC2 client ; private final Version version ; private final boolean bindAnyGroup ; private final Set < String > groups ; private final Map < String , String > tags ; private final Set < String > availabilityZones ; private final HostType hostType ; private final DiscoNodesCache discoNodes ; @Inject public AwsEc2UnicastHostsProvider ( Settings settings , TransportService transportService , AwsEc2Service awsEc2Service , Version version ) { super ( settings ) ; this . transportService = transportService ; this . client = awsEc2Service . client ( ) ; this . version = version ; this . hostType = HostType . valueOf ( settings . get ( DISCOVERY_EC2 . HOST_TYPE , <str> ) . toUpperCase ( Locale . ROOT ) ) ; this . discoNodes = new DiscoNodesCache ( this . settings . getAsTime ( DISCOVERY_EC2 . NODE_CACHE_TIME , TimeValue . timeValueMillis ( <int> ) ) ) ; this . bindAnyGroup = settings . getAsBoolean ( DISCOVERY_EC2 . ANY_GROUP , true ) ; this . groups = new HashSet < > ( ) ; groups . addAll ( Arrays . asList ( settings . getAsArray ( DISCOVERY_EC2 . GROUPS ) ) ) ; this . tags = settings . getByPrefix ( DISCOVERY_EC2 . TAG_PREFIX ) . getAsMap ( ) ; Set < String > availabilityZones = new HashSet < > ( ) ; availabilityZones . addAll ( Arrays . asList ( settings . getAsArray ( DISCOVERY_EC2 . AVAILABILITY_ZONES ) ) ) ; if ( settings . get ( DISCOVERY_EC2 . AVAILABILITY_ZONES ) ! = null ) { availabilityZones . addAll ( Strings . commaDelimitedListToSet ( settings . get ( DISCOVERY_EC2 . AVAILABILITY_ZONES ) ) ) ; } this . availabilityZones = availabilityZones ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , hostType , tags , groups , bindAnyGroup , availabilityZones ) ; } } @Override public List < DiscoveryNode > buildDynamicNodes ( ) { return discoNodes . getOrRefresh ( ) ; } protected List < DiscoveryNode > fetchDynamicNodes ( ) { List < DiscoveryNode > discoNodes = new ArrayList < > ( ) ; DescribeInstancesResult descInstances ; try { descInstances = client . describeInstances ( buildDescribeInstancesRequest ( ) ) ; } catch ( AmazonClientException e ) { logger . info ( <str> , e . getMessage ( ) ) ; logger . debug ( <str> , e ) ; return discoNodes ; } logger . trace ( <str> ) ; for ( Reservation reservation : descInstances . getReservations ( ) ) { for ( Instance instance : reservation . getInstances ( ) ) { if ( ! groups . isEmpty ( ) ) { List < GroupIdentifier > instanceSecurityGroups = instance . getSecurityGroups ( ) ; ArrayList < String > securityGroupNames = new ArrayList < String > ( ) ; ArrayList < String > securityGroupIds = new ArrayList < String > ( ) ; for ( GroupIdentifier sg : instanceSecurityGroups ) { securityGroupNames . add ( sg . getGroupName ( ) ) ; securityGroupIds . add ( sg . getGroupId ( ) ) ; } if ( bindAnyGroup ) { if ( Collections . disjoint ( securityGroupNames , groups ) & & Collections . disjoint ( securityGroupIds , groups ) ) { logger . trace ( <str> , instance . getInstanceId ( ) , instanceSecurityGroups , groups ) ; continue ; } } else { if ( ! ( securityGroupNames . containsAll ( groups ) | | securityGroupIds . containsAll ( groups ) ) ) { logger . trace ( <str> , instance . getInstanceId ( ) , instanceSecurityGroups , groups ) ; continue ; } } } String address = null ; switch ( hostType ) { case PRIVATE_DNS : address = instance . getPrivateDnsName ( ) ; break ; case PRIVATE_IP : address = instance . getPrivateIpAddress ( ) ; break ; case PUBLIC_DNS : address = instance . getPublicDnsName ( ) ; break ; case PUBLIC_IP : address = instance . getPublicIpAddress ( ) ; break ; } if ( address ! = null ) { try { TransportAddress [ ] addresses = transportService . addressesFromString ( address , <int> ) ; for ( int i = <int> ; i < addresses . length ; i + + ) { logger . trace ( <str> , instance . getInstanceId ( ) , address , addresses [ i ] ) ; discoNodes . add ( new DiscoveryNode ( <str> + instance . getInstanceId ( ) + <str> + i , addresses [ i ] , version . minimumCompatibilityVersion ( ) ) ) ; } } catch ( Exception e ) { logger . warn ( <str> , e , instance . getInstanceId ( ) , address ) ; } } else { logger . trace ( <str> , instance . getInstanceId ( ) , hostType ) ; } } } logger . debug ( <str> , discoNodes ) ; return discoNodes ; } private DescribeInstancesRequest buildDescribeInstancesRequest ( ) { DescribeInstancesRequest describeInstancesRequest = new DescribeInstancesRequest ( ) . withFilters ( new Filter ( <str> ) . withValues ( <str> , <str> ) ) ; for ( Map . Entry < String , String > tagFilter : tags . entrySet ( ) ) { describeInstancesRequest . withFilters ( new Filter ( <str> + tagFilter . getKey ( ) ) . withValues ( tagFilter . getValue ( ) ) ) ; } if ( ! availabilityZones . isEmpty ( ) ) { describeInstancesRequest . withFilters ( new Filter ( <str> ) . withValues ( availabilityZones ) ) ; } return describeInstancesRequest ; } private final class DiscoNodesCache extends SingleObjectCache < List < DiscoveryNode > > { private boolean empty = true ; protected DiscoNodesCache ( TimeValue refreshInterval ) { super ( refreshInterval , new ArrayList < > ( ) ) ; } @Override protected boolean needsRefresh ( ) { return ( empty | | super . needsRefresh ( ) ) ; } @Override protected List < DiscoveryNode > refresh ( ) { List < DiscoveryNode > nodes = fetchDynamicNodes ( ) ; empty = nodes . isEmpty ( ) ; return nodes ; } } } 
