package org . elasticsearch . transport . netty ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . bytes . ReleasablePagedBytesReference ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . ReleasableBytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . math . MathUtils ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . netty . NettyUtils ; import org . elasticsearch . common . netty . OpenChannelsHandler ; import org . elasticsearch . common . netty . ReleaseChannelFutureListener ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . PortsRange ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . util . concurrent . KeyedLock ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BindTransportException ; import org . elasticsearch . transport . BytesTransportRequest ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . NodeNotConnectedException ; import org . elasticsearch . transport . Transport ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportServiceAdapter ; import org . elasticsearch . transport . support . TransportStatus ; import org . jboss . netty . bootstrap . ClientBootstrap ; import org . jboss . netty . bootstrap . ServerBootstrap ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import org . jboss . netty . channel . AdaptiveReceiveBufferSizePredictorFactory ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelFuture ; import org . jboss . netty . channel . ChannelFutureListener ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . channel . ChannelPipeline ; import org . jboss . netty . channel . ChannelPipelineFactory ; import org . jboss . netty . channel . Channels ; import org . jboss . netty . channel . ExceptionEvent ; import org . jboss . netty . channel . FixedReceiveBufferSizePredictorFactory ; import org . jboss . netty . channel . ReceiveBufferSizePredictorFactory ; import org . jboss . netty . channel . socket . nio . NioClientSocketChannelFactory ; import org . jboss . netty . channel . socket . nio . NioServerSocketChannelFactory ; import org . jboss . netty . channel . socket . nio . NioWorkerPool ; import org . jboss . netty . channel . socket . oio . OioClientSocketChannelFactory ; import org . jboss . netty . channel . socket . oio . OioServerSocketChannelFactory ; import org . jboss . netty . util . HashedWheelTimer ; import java . io . IOException ; import java . net . BindException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . net . UnknownHostException ; import java . nio . channels . CancelledKeyException ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_BLOCKING ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_BLOCKING_CLIENT ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_BLOCKING_SERVER ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_CONNECT_TIMEOUT ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_DEFAULT_CONNECT_TIMEOUT ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_DEFAULT_RECEIVE_BUFFER_SIZE ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_DEFAULT_SEND_BUFFER_SIZE ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_KEEP_ALIVE ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_NO_DELAY ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_RECEIVE_BUFFER_SIZE ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_REUSE_ADDRESS ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . TCP_SEND_BUFFER_SIZE ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . transport . NetworkExceptionHelper . isCloseConnectionException ; import static org . elasticsearch . common . transport . NetworkExceptionHelper . isConnectException ; import static org . elasticsearch . common . util . concurrent . ConcurrentCollections . newConcurrentMap ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; public class NettyTransport extends AbstractLifecycleComponent < Transport > implements Transport { static { NettyUtils . setup ( ) ; } public static final String HTTP_SERVER_WORKER_THREAD_NAME_PREFIX = <str> ; public static final String HTTP_SERVER_BOSS_THREAD_NAME_PREFIX = <str> ; public static final String TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX = <str> ; public static final String TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX = <str> ; public static final String WORKER_COUNT = <str> ; public static final String CONNECTIONS_PER_NODE_RECOVERY = <str> ; public static final String CONNECTIONS_PER_NODE_BULK = <str> ; public static final String CONNECTIONS_PER_NODE_REG = <str> ; public static final String CONNECTIONS_PER_NODE_STATE = <str> ; public static final String CONNECTIONS_PER_NODE_PING = <str> ; public static final String PING_SCHEDULE = <str> ; public static final TimeValue DEFAULT_PING_SCHEDULE = TimeValue . timeValueMillis ( - <int> ) ; public static final String DEFAULT_PORT_RANGE = <str> ; public static final String DEFAULT_PROFILE = <str> ; protected final NetworkService networkService ; protected final Version version ; protected final boolean blockingClient ; protected final TimeValue connectTimeout ; protected final ByteSizeValue maxCumulationBufferCapacity ; protected final int maxCompositeBufferComponents ; protected final boolean compress ; protected final ReceiveBufferSizePredictorFactory receiveBufferSizePredictorFactory ; protected final int workerCount ; protected final ByteSizeValue receivePredictorMin ; protected final ByteSizeValue receivePredictorMax ; protected final int connectionsPerNodeRecovery ; protected final int connectionsPerNodeBulk ; protected final int connectionsPerNodeReg ; protected final int connectionsPerNodeState ; protected final int connectionsPerNodePing ; private final TimeValue pingSchedule ; protected final BigArrays bigArrays ; protected final ThreadPool threadPool ; volatile OpenChannelsHandler serverOpenChannels ; protected volatile ClientBootstrap clientBootstrap ; protected final ConcurrentMap < DiscoveryNode , NodeChannels > connectedNodes = newConcurrentMap ( ) ; protected final Map < String , ServerBootstrap > serverBootstraps = newConcurrentMap ( ) ; protected final Map < String , List < Channel > > serverChannels = newConcurrentMap ( ) ; protected final ConcurrentMap < String , BoundTransportAddress > profileBoundAddresses = newConcurrentMap ( ) ; protected volatile TransportServiceAdapter transportServiceAdapter ; protected volatile BoundTransportAddress boundAddress ; protected final KeyedLock < String > connectionLock = new KeyedLock < > ( ) ; protected final NamedWriteableRegistry namedWriteableRegistry ; private final ReadWriteLock globalLock = new ReentrantReadWriteLock ( ) ; final ScheduledPing scheduledPing ; @Inject @SuppressForbidden ( reason = <str> ) public NettyTransport ( Settings settings , ThreadPool threadPool , NetworkService networkService , BigArrays bigArrays , Version version , NamedWriteableRegistry namedWriteableRegistry ) { super ( settings ) ; this . threadPool = threadPool ; this . networkService = networkService ; this . bigArrays = bigArrays ; this . version = version ; if ( settings . getAsBoolean ( <str> , false ) ) { System . setProperty ( <str> , <str> ) ; } this . workerCount = settings . getAsInt ( WORKER_COUNT , EsExecutors . boundedNumberOfProcessors ( settings ) * <int> ) ; this . blockingClient = settings . getAsBoolean ( <str> , settings . getAsBoolean ( TCP_BLOCKING_CLIENT , settings . getAsBoolean ( TCP_BLOCKING , false ) ) ) ; this . connectTimeout = this . settings . getAsTime ( <str> , settings . getAsTime ( <str> , settings . getAsTime ( TCP_CONNECT_TIMEOUT , TCP_DEFAULT_CONNECT_TIMEOUT ) ) ) ; this . maxCumulationBufferCapacity = this . settings . getAsBytesSize ( <str> , null ) ; this . maxCompositeBufferComponents = this . settings . getAsInt ( <str> , - <int> ) ; this . compress = settings . getAsBoolean ( TransportSettings . TRANSPORT_TCP_COMPRESS , false ) ; this . connectionsPerNodeRecovery = this . settings . getAsInt ( <str> , settings . getAsInt ( CONNECTIONS_PER_NODE_RECOVERY , <int> ) ) ; this . connectionsPerNodeBulk = this . settings . getAsInt ( <str> , settings . getAsInt ( CONNECTIONS_PER_NODE_BULK , <int> ) ) ; this . connectionsPerNodeReg = this . settings . getAsInt ( <str> , settings . getAsInt ( CONNECTIONS_PER_NODE_REG , <int> ) ) ; this . connectionsPerNodeState = this . settings . getAsInt ( <str> , settings . getAsInt ( CONNECTIONS_PER_NODE_STATE , <int> ) ) ; this . connectionsPerNodePing = this . settings . getAsInt ( <str> , settings . getAsInt ( CONNECTIONS_PER_NODE_PING , <int> ) ) ; if ( this . connectionsPerNodeReg = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( this . connectionsPerNodePing = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( this . connectionsPerNodeState = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } long defaultReceiverPredictor = <int> * <int> ; if ( JvmInfo . jvmInfo ( ) . getMem ( ) . getDirectMemoryMax ( ) . bytes ( ) > <int> ) { long l = ( long ) ( ( <float> * JvmInfo . jvmInfo ( ) . getMem ( ) . getDirectMemoryMax ( ) . bytes ( ) ) / workerCount ) ; defaultReceiverPredictor = Math . min ( defaultReceiverPredictor , Math . max ( l , <int> * <int> ) ) ; } this . receivePredictorMin = this . settings . getAsBytesSize ( <str> , this . settings . getAsBytesSize ( <str> , new ByteSizeValue ( defaultReceiverPredictor ) ) ) ; this . receivePredictorMax = this . settings . getAsBytesSize ( <str> , this . settings . getAsBytesSize ( <str> , new ByteSizeValue ( defaultReceiverPredictor ) ) ) ; if ( receivePredictorMax . bytes ( ) = = receivePredictorMin . bytes ( ) ) { receiveBufferSizePredictorFactory = new FixedReceiveBufferSizePredictorFactory ( ( int ) receivePredictorMax . bytes ( ) ) ; } else { receiveBufferSizePredictorFactory = new AdaptiveReceiveBufferSizePredictorFactory ( ( int ) receivePredictorMin . bytes ( ) , ( int ) receivePredictorMin . bytes ( ) , ( int ) receivePredictorMax . bytes ( ) ) ; } this . scheduledPing = new ScheduledPing ( ) ; this . pingSchedule = settings . getAsTime ( PING_SCHEDULE , DEFAULT_PING_SCHEDULE ) ; if ( pingSchedule . millis ( ) > <int> ) { threadPool . schedule ( pingSchedule , ThreadPool . Names . GENERIC , scheduledPing ) ; } this . namedWriteableRegistry = namedWriteableRegistry ; } public Settings settings ( ) { return this . settings ; } @Override public void transportServiceAdapter ( TransportServiceAdapter service ) { this . transportServiceAdapter = service ; } TransportServiceAdapter transportServiceAdapter ( ) { return transportServiceAdapter ; } ThreadPool threadPool ( ) { return threadPool ; } @Override protected void doStart ( ) { boolean success = false ; try { clientBootstrap = createClientBootstrap ( ) ; if ( settings . getAsBoolean ( <str> , true ) ) { final OpenChannelsHandler openChannels = new OpenChannelsHandler ( logger ) ; this . serverOpenChannels = openChannels ; Map < String , Settings > profiles = settings . getGroups ( <str> , true ) ; if ( ! profiles . containsKey ( DEFAULT_PROFILE ) ) { profiles = new HashMap < > ( profiles ) ; profiles . put ( DEFAULT_PROFILE , Settings . EMPTY ) ; } Settings fallbackSettings = createFallbackSettings ( ) ; Settings defaultSettings = profiles . get ( DEFAULT_PROFILE ) ; for ( Map . Entry < String , Settings > entry : profiles . entrySet ( ) ) { Settings profileSettings = entry . getValue ( ) ; String name = entry . getKey ( ) ; if ( ! Strings . hasLength ( name ) ) { logger . info ( <str> , profileSettings . toDelimitedString ( <str> ) ) ; continue ; } else if ( DEFAULT_PROFILE . equals ( name ) ) { profileSettings = settingsBuilder ( ) . put ( profileSettings ) . put ( <str> , profileSettings . get ( <str> , this . settings . get ( <str> , DEFAULT_PORT_RANGE ) ) ) . build ( ) ; } else if ( profileSettings . get ( <str> ) = = null ) { logger . info ( <str> , name ) ; continue ; } Settings mergedSettings = settingsBuilder ( ) . put ( fallbackSettings ) . put ( defaultSettings ) . put ( profileSettings ) . build ( ) ; createServerBootstrap ( name , mergedSettings ) ; bindServerBootstrap ( name , mergedSettings ) ; } } success = true ; } finally { if ( success = = false ) { doStop ( ) ; } } } @Override public Map < String , BoundTransportAddress > profileBoundAddresses ( ) { return unmodifiableMap ( new HashMap < > ( profileBoundAddresses ) ) ; } private ClientBootstrap createClientBootstrap ( ) { if ( blockingClient ) { clientBootstrap = new ClientBootstrap ( new OioClientSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX ) ) ) ) ; } else { int bossCount = settings . getAsInt ( <str> , <int> ) ; clientBootstrap = new ClientBootstrap ( new NioClientSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX ) ) , bossCount , new NioWorkerPool ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX ) ) , workerCount ) , new HashedWheelTimer ( daemonThreadFactory ( settings , <str> ) ) ) ) ; } clientBootstrap . setPipelineFactory ( configureClientChannelPipelineFactory ( ) ) ; clientBootstrap . setOption ( <str> , connectTimeout . millis ( ) ) ; String tcpNoDelay = settings . get ( <str> , settings . get ( TCP_NO_DELAY , <str> ) ) ; if ( ! <str> . equals ( tcpNoDelay ) ) { clientBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpNoDelay , null ) ) ; } String tcpKeepAlive = settings . get ( <str> , settings . get ( TCP_KEEP_ALIVE , <str> ) ) ; if ( ! <str> . equals ( tcpKeepAlive ) ) { clientBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpKeepAlive , null ) ) ; } ByteSizeValue tcpSendBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_SEND_BUFFER_SIZE , TCP_DEFAULT_SEND_BUFFER_SIZE ) ) ; if ( tcpSendBufferSize ! = null & & tcpSendBufferSize . bytes ( ) > <int> ) { clientBootstrap . setOption ( <str> , tcpSendBufferSize . bytes ( ) ) ; } ByteSizeValue tcpReceiveBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_RECEIVE_BUFFER_SIZE , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ) ; if ( tcpReceiveBufferSize ! = null & & tcpReceiveBufferSize . bytes ( ) > <int> ) { clientBootstrap . setOption ( <str> , tcpReceiveBufferSize . bytes ( ) ) ; } clientBootstrap . setOption ( <str> , receiveBufferSizePredictorFactory ) ; boolean reuseAddress = settings . getAsBoolean ( <str> , settings . getAsBoolean ( TCP_REUSE_ADDRESS , NetworkUtils . defaultReuseAddress ( ) ) ) ; clientBootstrap . setOption ( <str> , reuseAddress ) ; return clientBootstrap ; } private Settings createFallbackSettings ( ) { Settings . Builder fallbackSettingsBuilder = settingsBuilder ( ) ; String fallbackBindHost = settings . get ( <str> , settings . get ( <str> , settings . get ( <str> ) ) ) ; if ( fallbackBindHost ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackBindHost ) ; } String fallbackPublishHost = settings . get ( <str> , settings . get ( <str> , settings . get ( <str> ) ) ) ; if ( fallbackPublishHost ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackPublishHost ) ; } String fallbackTcpNoDelay = settings . get ( <str> , settings . get ( TCP_NO_DELAY , <str> ) ) ; if ( fallbackTcpNoDelay ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackTcpNoDelay ) ; } String fallbackTcpKeepAlive = settings . get ( <str> , settings . get ( TCP_KEEP_ALIVE , <str> ) ) ; if ( fallbackTcpKeepAlive ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackTcpKeepAlive ) ; } boolean fallbackReuseAddress = settings . getAsBoolean ( <str> , settings . getAsBoolean ( TCP_REUSE_ADDRESS , NetworkUtils . defaultReuseAddress ( ) ) ) ; fallbackSettingsBuilder . put ( <str> , fallbackReuseAddress ) ; ByteSizeValue fallbackTcpSendBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_SEND_BUFFER_SIZE , TCP_DEFAULT_SEND_BUFFER_SIZE ) ) ; if ( fallbackTcpSendBufferSize ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackTcpSendBufferSize ) ; } ByteSizeValue fallbackTcpBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_RECEIVE_BUFFER_SIZE , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ) ; if ( fallbackTcpBufferSize ! = null ) { fallbackSettingsBuilder . put ( <str> , fallbackTcpBufferSize ) ; } return fallbackSettingsBuilder . build ( ) ; } private void bindServerBootstrap ( final String name , final Settings settings ) { InetAddress hostAddresses [ ] ; String bindHosts [ ] = settings . getAsArray ( <str> , null ) ; try { hostAddresses = networkService . resolveBindHostAddresses ( bindHosts ) ; } catch ( IOException e ) { throw new BindTransportException ( <str> + Arrays . toString ( bindHosts ) + <str> , e ) ; } if ( logger . isDebugEnabled ( ) ) { String [ ] addresses = new String [ hostAddresses . length ] ; for ( int i = <int> ; i < hostAddresses . length ; i + + ) { addresses [ i ] = NetworkAddress . format ( hostAddresses [ i ] ) ; } logger . debug ( <str> , ( Object ) addresses ) ; } assert hostAddresses . length > <int> ; List < InetSocketAddress > boundAddresses = new ArrayList < > ( ) ; for ( InetAddress hostAddress : hostAddresses ) { boundAddresses . add ( bindToPort ( name , hostAddress , settings . get ( <str> ) ) ) ; } final BoundTransportAddress boundTransportAddress = createBoundTransportAddress ( name , settings , boundAddresses ) ; if ( DEFAULT_PROFILE . equals ( name ) ) { this . boundAddress = boundTransportAddress ; } else { profileBoundAddresses . put ( name , boundTransportAddress ) ; } } private InetSocketAddress bindToPort ( final String name , final InetAddress hostAddress , String port ) { PortsRange portsRange = new PortsRange ( port ) ; final AtomicReference < Exception > lastException = new AtomicReference < > ( ) ; final AtomicReference < InetSocketAddress > boundSocket = new AtomicReference < > ( ) ; boolean success = portsRange . iterate ( new PortsRange . PortCallback ( ) { @Override public boolean onPortNumber ( int portNumber ) { try { Channel channel = serverBootstraps . get ( name ) . bind ( new InetSocketAddress ( hostAddress , portNumber ) ) ; synchronized ( serverChannels ) { List < Channel > list = serverChannels . get ( name ) ; if ( list = = null ) { list = new ArrayList < > ( ) ; serverChannels . put ( name , list ) ; } list . add ( channel ) ; boundSocket . set ( ( InetSocketAddress ) channel . getLocalAddress ( ) ) ; } } catch ( Exception e ) { lastException . set ( e ) ; return false ; } return true ; } } ) ; if ( ! success ) { throw new BindTransportException ( <str> + port + <str> , lastException . get ( ) ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , name , NetworkAddress . format ( boundSocket . get ( ) ) ) ; } return boundSocket . get ( ) ; } private BoundTransportAddress createBoundTransportAddress ( String name , Settings profileSettings , List < InetSocketAddress > boundAddresses ) { String [ ] boundAddressesHostStrings = new String [ boundAddresses . size ( ) ] ; TransportAddress [ ] transportBoundAddresses = new TransportAddress [ boundAddresses . size ( ) ] ; for ( int i = <int> ; i < boundAddresses . size ( ) ; i + + ) { InetSocketAddress boundAddress = boundAddresses . get ( i ) ; boundAddressesHostStrings [ i ] = boundAddress . getHostString ( ) ; transportBoundAddresses [ i ] = new InetSocketTransportAddress ( boundAddress ) ; } final String [ ] publishHosts ; if ( DEFAULT_PROFILE . equals ( name ) ) { publishHosts = settings . getAsArray ( <str> , settings . getAsArray ( <str> , settings . getAsArray ( <str> , null ) ) ) ; } else { publishHosts = profileSettings . getAsArray ( <str> , boundAddressesHostStrings ) ; } final InetAddress publishInetAddress ; try { publishInetAddress = networkService . resolvePublishHostAddresses ( publishHosts ) ; } catch ( Exception e ) { throw new BindTransportException ( <str> , e ) ; } Integer publishPort ; if ( DEFAULT_PROFILE . equals ( name ) ) { publishPort = settings . getAsInt ( <str> , settings . getAsInt ( <str> , null ) ) ; } else { publishPort = profileSettings . getAsInt ( <str> , null ) ; } if ( publishPort = = null ) { for ( InetSocketAddress boundAddress : boundAddresses ) { InetAddress boundInetAddress = boundAddress . getAddress ( ) ; if ( boundInetAddress . isAnyLocalAddress ( ) | | boundInetAddress . equals ( publishInetAddress ) ) { publishPort = boundAddress . getPort ( ) ; break ; } } } if ( publishPort = = null ) { publishPort = boundAddresses . get ( <int> ) . getPort ( ) ; logger . warn ( <str> , publishInetAddress , boundAddresses , publishPort ) ; } final TransportAddress publishAddress = new InetSocketTransportAddress ( new InetSocketAddress ( publishInetAddress , publishPort ) ) ; return new BoundTransportAddress ( transportBoundAddresses , publishAddress ) ; } private void createServerBootstrap ( String name , Settings settings ) { boolean blockingServer = settings . getAsBoolean ( <str> , this . settings . getAsBoolean ( TCP_BLOCKING_SERVER , this . settings . getAsBoolean ( TCP_BLOCKING , false ) ) ) ; String port = settings . get ( <str> ) ; String bindHost = settings . get ( <str> ) ; String publishHost = settings . get ( <str> ) ; String tcpNoDelay = settings . get ( <str> ) ; String tcpKeepAlive = settings . get ( <str> ) ; boolean reuseAddress = settings . getAsBoolean ( <str> , NetworkUtils . defaultReuseAddress ( ) ) ; ByteSizeValue tcpSendBufferSize = settings . getAsBytesSize ( <str> , TCP_DEFAULT_SEND_BUFFER_SIZE ) ; ByteSizeValue tcpReceiveBufferSize = settings . getAsBytesSize ( <str> , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ; logger . debug ( <str> , name , workerCount , port , bindHost , publishHost , compress , connectTimeout , connectionsPerNodeRecovery , connectionsPerNodeBulk , connectionsPerNodeReg , connectionsPerNodeState , connectionsPerNodePing , receivePredictorMin , receivePredictorMax ) ; final ThreadFactory bossFactory = daemonThreadFactory ( this . settings , HTTP_SERVER_BOSS_THREAD_NAME_PREFIX , name ) ; final ThreadFactory workerFactory = daemonThreadFactory ( this . settings , HTTP_SERVER_WORKER_THREAD_NAME_PREFIX , name ) ; ServerBootstrap serverBootstrap ; if ( blockingServer ) { serverBootstrap = new ServerBootstrap ( new OioServerSocketChannelFactory ( Executors . newCachedThreadPool ( bossFactory ) , Executors . newCachedThreadPool ( workerFactory ) ) ) ; } else { serverBootstrap = new ServerBootstrap ( new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( bossFactory ) , Executors . newCachedThreadPool ( workerFactory ) , workerCount ) ) ; } serverBootstrap . setPipelineFactory ( configureServerChannelPipelineFactory ( name , settings ) ) ; if ( ! <str> . equals ( tcpNoDelay ) ) { serverBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpNoDelay , null ) ) ; } if ( ! <str> . equals ( tcpKeepAlive ) ) { serverBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpKeepAlive , null ) ) ; } if ( tcpSendBufferSize ! = null & & tcpSendBufferSize . bytes ( ) > <int> ) { serverBootstrap . setOption ( <str> , tcpSendBufferSize . bytes ( ) ) ; } if ( tcpReceiveBufferSize ! = null & & tcpReceiveBufferSize . bytes ( ) > <int> ) { serverBootstrap . setOption ( <str> , tcpReceiveBufferSize . bytes ( ) ) ; } serverBootstrap . setOption ( <str> , receiveBufferSizePredictorFactory ) ; serverBootstrap . setOption ( <str> , receiveBufferSizePredictorFactory ) ; serverBootstrap . setOption ( <str> , reuseAddress ) ; serverBootstrap . setOption ( <str> , reuseAddress ) ; serverBootstraps . put ( name , serverBootstrap ) ; } @Override protected void doStop ( ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { globalLock . writeLock ( ) . lock ( ) ; try { for ( Iterator < NodeChannels > it = connectedNodes . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { NodeChannels nodeChannels = it . next ( ) ; it . remove ( ) ; nodeChannels . close ( ) ; } Iterator < Map . Entry < String , List < Channel > > > serverChannelIterator = serverChannels . entrySet ( ) . iterator ( ) ; while ( serverChannelIterator . hasNext ( ) ) { Map . Entry < String , List < Channel > > serverChannelEntry = serverChannelIterator . next ( ) ; String name = serverChannelEntry . getKey ( ) ; List < Channel > serverChannels = serverChannelEntry . getValue ( ) ; for ( Channel serverChannel : serverChannels ) { try { serverChannel . close ( ) . awaitUninterruptibly ( ) ; } catch ( Throwable t ) { logger . debug ( <str> , t , name ) ; } } serverChannelIterator . remove ( ) ; } if ( serverOpenChannels ! = null ) { serverOpenChannels . close ( ) ; serverOpenChannels = null ; } Iterator < Map . Entry < String , ServerBootstrap > > serverBootstrapIterator = serverBootstraps . entrySet ( ) . iterator ( ) ; while ( serverBootstrapIterator . hasNext ( ) ) { Map . Entry < String , ServerBootstrap > serverBootstrapEntry = serverBootstrapIterator . next ( ) ; String name = serverBootstrapEntry . getKey ( ) ; ServerBootstrap serverBootstrap = serverBootstrapEntry . getValue ( ) ; try { serverBootstrap . releaseExternalResources ( ) ; } catch ( Throwable t ) { logger . debug ( <str> , t , name ) ; } serverBootstrapIterator . remove ( ) ; } for ( Iterator < NodeChannels > it = connectedNodes . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { NodeChannels nodeChannels = it . next ( ) ; it . remove ( ) ; nodeChannels . close ( ) ; } if ( clientBootstrap ! = null ) { clientBootstrap . releaseExternalResources ( ) ; clientBootstrap = null ; } } finally { globalLock . writeLock ( ) . unlock ( ) ; latch . countDown ( ) ; } } } ) ; try { latch . await ( <int> , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { } } @Override protected void doClose ( ) { } @Override public TransportAddress [ ] addressesFromString ( String address , int perAddressLimit ) throws Exception { return parse ( address , settings . get ( <str> , settings . get ( <str> , settings . get ( <str> , DEFAULT_PORT_RANGE ) ) ) , perAddressLimit ) ; } private static final Pattern BRACKET_PATTERN = Pattern . compile ( <str> ) ; static TransportAddress [ ] parse ( String hostPortString , String defaultPortRange , int perAddressLimit ) throws UnknownHostException { Objects . requireNonNull ( hostPortString ) ; String host ; String portString = null ; if ( hostPortString . startsWith ( <str> ) ) { Matcher matcher = BRACKET_PATTERN . matcher ( hostPortString ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( <str> + hostPortString ) ; } host = matcher . group ( <int> ) ; portString = matcher . group ( <int> ) ; } else { int colonPos = hostPortString . indexOf ( <str> ) ; if ( colonPos > = <int> & & hostPortString . indexOf ( <str> , colonPos + <int> ) = = - <int> ) { host = hostPortString . substring ( <int> , colonPos ) ; portString = hostPortString . substring ( colonPos + <int> ) ; } else { host = hostPortString ; if ( colonPos > = <int> ) { throw new IllegalArgumentException ( <str> + hostPortString ) ; } } } if ( portString = = null | | portString . isEmpty ( ) ) { portString = defaultPortRange ; } Set < InetAddress > addresses = new HashSet < > ( Arrays . asList ( InetAddress . getAllByName ( host ) ) ) ; List < TransportAddress > transportAddresses = new ArrayList < > ( ) ; int [ ] ports = new PortsRange ( portString ) . ports ( ) ; int limit = Math . min ( ports . length , perAddressLimit ) ; for ( int i = <int> ; i < limit ; i + + ) { for ( InetAddress address : addresses ) { transportAddresses . add ( new InetSocketTransportAddress ( address , ports [ i ] ) ) ; } } return transportAddresses . toArray ( new TransportAddress [ transportAddresses . size ( ) ] ) ; } @Override public boolean addressSupported ( Class < ? extends TransportAddress > address ) { return InetSocketTransportAddress . class . equals ( address ) ; } @Override public BoundTransportAddress boundAddress ( ) { return this . boundAddress ; } protected void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { if ( ! lifecycle . started ( ) ) { return ; } if ( isCloseConnectionException ( e . getCause ( ) ) ) { logger . trace ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; disconnectFromNodeChannel ( ctx . getChannel ( ) , e . getCause ( ) ) ; } else if ( isConnectException ( e . getCause ( ) ) ) { logger . trace ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; disconnectFromNodeChannel ( ctx . getChannel ( ) , e . getCause ( ) ) ; } else if ( e . getCause ( ) instanceof BindException ) { logger . trace ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; disconnectFromNodeChannel ( ctx . getChannel ( ) , e . getCause ( ) ) ; } else if ( e . getCause ( ) instanceof CancelledKeyException ) { logger . trace ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; disconnectFromNodeChannel ( ctx . getChannel ( ) , e . getCause ( ) ) ; } else if ( e . getCause ( ) instanceof SizeHeaderFrameDecoder . HttpOnTransportException ) { if ( ctx . getChannel ( ) . isOpen ( ) ) { ChannelBuffer buffer = ChannelBuffers . wrappedBuffer ( e . getCause ( ) . getMessage ( ) . getBytes ( StandardCharsets . UTF_8 ) ) ; ChannelFuture channelFuture = ctx . getChannel ( ) . write ( buffer ) ; channelFuture . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { future . getChannel ( ) . close ( ) ; } } ) ; } } else { logger . warn ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; disconnectFromNodeChannel ( ctx . getChannel ( ) , e . getCause ( ) ) ; } } TransportAddress wrapAddress ( SocketAddress socketAddress ) { return new InetSocketTransportAddress ( ( InetSocketAddress ) socketAddress ) ; } @Override public long serverOpen ( ) { OpenChannelsHandler channels = serverOpenChannels ; return channels = = null ? <int> : channels . numberOfOpenChannels ( ) ; } @Override public List < String > getLocalAddresses ( ) { List < String > local = new ArrayList < > ( ) ; local . add ( <str> ) ; if ( NetworkUtils . SUPPORTS_V6 ) { local . add ( <str> ) ; } return local ; } @Override public void sendRequest ( final DiscoveryNode node , final long requestId , final String action , final TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { Channel targetChannel = nodeChannel ( node , options ) ; if ( compress ) { options = TransportRequestOptions . builder ( options ) . withCompress ( true ) . build ( ) ; } byte status = <int> ; status = TransportStatus . setRequest ( status ) ; ReleasableBytesStreamOutput bStream = new ReleasableBytesStreamOutput ( bigArrays ) ; boolean addedReleaseListener = false ; try { bStream . skip ( NettyHeader . HEADER_SIZE ) ; StreamOutput stream = bStream ; if ( options . compress ( ) & & ( ! ( request instanceof BytesTransportRequest ) ) ) { status = TransportStatus . setCompress ( status ) ; stream = CompressorFactory . defaultCompressor ( ) . streamOutput ( stream ) ; } Version version = Version . smallest ( this . version , node . version ( ) ) ; stream . setVersion ( version ) ; stream . writeString ( action ) ; ReleasablePagedBytesReference bytes ; ChannelBuffer buffer ; if ( request instanceof BytesTransportRequest ) { BytesTransportRequest bRequest = ( BytesTransportRequest ) request ; assert node . version ( ) . equals ( bRequest . version ( ) ) ; bRequest . writeThin ( stream ) ; stream . close ( ) ; bytes = bStream . bytes ( ) ; ChannelBuffer headerBuffer = bytes . toChannelBuffer ( ) ; ChannelBuffer contentBuffer = bRequest . bytes ( ) . toChannelBuffer ( ) ; buffer = ChannelBuffers . wrappedBuffer ( NettyUtils . DEFAULT_GATHERING , headerBuffer , contentBuffer ) ; } else { request . writeTo ( stream ) ; stream . close ( ) ; bytes = bStream . bytes ( ) ; buffer = bytes . toChannelBuffer ( ) ; } NettyHeader . writeHeader ( buffer , requestId , status , version ) ; ChannelFuture future = targetChannel . write ( buffer ) ; ReleaseChannelFutureListener listener = new ReleaseChannelFutureListener ( bytes ) ; future . addListener ( listener ) ; addedReleaseListener = true ; transportServiceAdapter . onRequestSent ( node , requestId , action , request , options ) ; } finally { if ( ! addedReleaseListener ) { Releasables . close ( bStream . bytes ( ) ) ; } } } @Override public boolean nodeConnected ( DiscoveryNode node ) { return connectedNodes . containsKey ( node ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { connectToNode ( node , true ) ; } @Override public void connectToNode ( DiscoveryNode node ) { connectToNode ( node , false ) ; } public void connectToNode ( DiscoveryNode node , boolean light ) { if ( ! lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } if ( node = = null ) { throw new ConnectTransportException ( null , <str> ) ; } globalLock . readLock ( ) . lock ( ) ; try { connectionLock . acquire ( node . id ( ) ) ; try { if ( ! lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } NodeChannels nodeChannels = connectedNodes . get ( node ) ; if ( nodeChannels ! = null ) { return ; } try { if ( light ) { nodeChannels = connectToChannelsLight ( node ) ; } else { nodeChannels = new NodeChannels ( new Channel [ connectionsPerNodeRecovery ] , new Channel [ connectionsPerNodeBulk ] , new Channel [ connectionsPerNodeReg ] , new Channel [ connectionsPerNodeState ] , new Channel [ connectionsPerNodePing ] ) ; try { connectToChannels ( nodeChannels , node ) ; } catch ( Throwable e ) { logger . trace ( <str> , e , node ) ; nodeChannels . close ( ) ; throw e ; } } nodeChannels . start ( ) ; connectedNodes . put ( node , nodeChannels ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , node ) ; } transportServiceAdapter . raiseNodeConnected ( node ) ; } catch ( ConnectTransportException e ) { throw e ; } catch ( Exception e ) { throw new ConnectTransportException ( node , <str> , e ) ; } } finally { connectionLock . release ( node . id ( ) ) ; } } finally { globalLock . readLock ( ) . unlock ( ) ; } } protected NodeChannels connectToChannelsLight ( DiscoveryNode node ) { InetSocketAddress address = ( ( InetSocketTransportAddress ) node . address ( ) ) . address ( ) ; ChannelFuture connect = clientBootstrap . connect ( address ) ; connect . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connect . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connect . getCause ( ) ) ; } Channel [ ] channels = new Channel [ <int> ] ; channels [ <int> ] = connect . getChannel ( ) ; channels [ <int> ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; return new NodeChannels ( channels , channels , channels , channels , channels ) ; } protected void connectToChannels ( NodeChannels nodeChannels , DiscoveryNode node ) { ChannelFuture [ ] connectRecovery = new ChannelFuture [ nodeChannels . recovery . length ] ; ChannelFuture [ ] connectBulk = new ChannelFuture [ nodeChannels . bulk . length ] ; ChannelFuture [ ] connectReg = new ChannelFuture [ nodeChannels . reg . length ] ; ChannelFuture [ ] connectState = new ChannelFuture [ nodeChannels . state . length ] ; ChannelFuture [ ] connectPing = new ChannelFuture [ nodeChannels . ping . length ] ; InetSocketAddress address = ( ( InetSocketTransportAddress ) node . address ( ) ) . address ( ) ; for ( int i = <int> ; i < connectRecovery . length ; i + + ) { connectRecovery [ i ] = clientBootstrap . connect ( address ) ; } for ( int i = <int> ; i < connectBulk . length ; i + + ) { connectBulk [ i ] = clientBootstrap . connect ( address ) ; } for ( int i = <int> ; i < connectReg . length ; i + + ) { connectReg [ i ] = clientBootstrap . connect ( address ) ; } for ( int i = <int> ; i < connectState . length ; i + + ) { connectState [ i ] = clientBootstrap . connect ( address ) ; } for ( int i = <int> ; i < connectPing . length ; i + + ) { connectPing [ i ] = clientBootstrap . connect ( address ) ; } try { for ( int i = <int> ; i < connectRecovery . length ; i + + ) { connectRecovery [ i ] . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connectRecovery [ i ] . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connectRecovery [ i ] . getCause ( ) ) ; } nodeChannels . recovery [ i ] = connectRecovery [ i ] . getChannel ( ) ; nodeChannels . recovery [ i ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; } for ( int i = <int> ; i < connectBulk . length ; i + + ) { connectBulk [ i ] . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connectBulk [ i ] . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connectBulk [ i ] . getCause ( ) ) ; } nodeChannels . bulk [ i ] = connectBulk [ i ] . getChannel ( ) ; nodeChannels . bulk [ i ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; } for ( int i = <int> ; i < connectReg . length ; i + + ) { connectReg [ i ] . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connectReg [ i ] . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connectReg [ i ] . getCause ( ) ) ; } nodeChannels . reg [ i ] = connectReg [ i ] . getChannel ( ) ; nodeChannels . reg [ i ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; } for ( int i = <int> ; i < connectState . length ; i + + ) { connectState [ i ] . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connectState [ i ] . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connectState [ i ] . getCause ( ) ) ; } nodeChannels . state [ i ] = connectState [ i ] . getChannel ( ) ; nodeChannels . state [ i ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; } for ( int i = <int> ; i < connectPing . length ; i + + ) { connectPing [ i ] . awaitUninterruptibly ( ( long ) ( connectTimeout . millis ( ) * <float> ) ) ; if ( ! connectPing [ i ] . isSuccess ( ) ) { throw new ConnectTransportException ( node , <str> + connectTimeout + <str> , connectPing [ i ] . getCause ( ) ) ; } nodeChannels . ping [ i ] = connectPing [ i ] . getChannel ( ) ; nodeChannels . ping [ i ] . getCloseFuture ( ) . addListener ( new ChannelCloseListener ( node ) ) ; } if ( nodeChannels . recovery . length = = <int> ) { if ( nodeChannels . bulk . length > <int> ) { nodeChannels . recovery = nodeChannels . bulk ; } else { nodeChannels . recovery = nodeChannels . reg ; } } if ( nodeChannels . bulk . length = = <int> ) { nodeChannels . bulk = nodeChannels . reg ; } } catch ( RuntimeException e ) { List < ChannelFuture > futures = new ArrayList < > ( ) ; futures . addAll ( Arrays . asList ( connectRecovery ) ) ; futures . addAll ( Arrays . asList ( connectBulk ) ) ; futures . addAll ( Arrays . asList ( connectReg ) ) ; futures . addAll ( Arrays . asList ( connectState ) ) ; futures . addAll ( Arrays . asList ( connectPing ) ) ; for ( ChannelFuture future : Collections . unmodifiableList ( futures ) ) { future . cancel ( ) ; if ( future . getChannel ( ) ! = null & & future . getChannel ( ) . isOpen ( ) ) { try { future . getChannel ( ) . close ( ) ; } catch ( Exception e1 ) { } } } throw e ; } } @Override public void disconnectFromNode ( DiscoveryNode node ) { connectionLock . acquire ( node . id ( ) ) ; try { NodeChannels nodeChannels = connectedNodes . remove ( node ) ; if ( nodeChannels ! = null ) { try { logger . debug ( <str> , node ) ; nodeChannels . close ( ) ; } finally { logger . trace ( <str> , node ) ; transportServiceAdapter . raiseNodeDisconnected ( node ) ; } } } finally { connectionLock . release ( node . id ( ) ) ; } } protected boolean disconnectFromNode ( DiscoveryNode node , Channel channel , String reason ) { NodeChannels nodeChannels = connectedNodes . get ( node ) ; if ( nodeChannels ! = null & & nodeChannels . hasChannel ( channel ) ) { connectionLock . acquire ( node . id ( ) ) ; try { nodeChannels = connectedNodes . get ( node ) ; if ( nodeChannels ! = null & & nodeChannels . hasChannel ( channel ) ) { connectedNodes . remove ( node ) ; try { logger . debug ( <str> , node , reason ) ; nodeChannels . close ( ) ; } finally { logger . trace ( <str> , node , reason ) ; transportServiceAdapter . raiseNodeDisconnected ( node ) ; } return true ; } } finally { connectionLock . release ( node . id ( ) ) ; } } return false ; } protected void disconnectFromNodeChannel ( final Channel channel , final Throwable failure ) { threadPool ( ) . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { for ( DiscoveryNode node : connectedNodes . keySet ( ) ) { if ( disconnectFromNode ( node , channel , ExceptionsHelper . detailedMessage ( failure ) ) ) { break ; } } } } ) ; } protected Channel nodeChannel ( DiscoveryNode node , TransportRequestOptions options ) throws ConnectTransportException { NodeChannels nodeChannels = connectedNodes . get ( node ) ; if ( nodeChannels = = null ) { throw new NodeNotConnectedException ( node , <str> ) ; } return nodeChannels . channel ( options . type ( ) ) ; } public ChannelPipelineFactory configureClientChannelPipelineFactory ( ) { return new ClientChannelPipelineFactory ( this ) ; } protected static class ClientChannelPipelineFactory implements ChannelPipelineFactory { protected final NettyTransport nettyTransport ; public ClientChannelPipelineFactory ( NettyTransport nettyTransport ) { this . nettyTransport = nettyTransport ; } @Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline channelPipeline = Channels . pipeline ( ) ; SizeHeaderFrameDecoder sizeHeader = new SizeHeaderFrameDecoder ( ) ; if ( nettyTransport . maxCumulationBufferCapacity ! = null ) { if ( nettyTransport . maxCumulationBufferCapacity . bytes ( ) > Integer . MAX_VALUE ) { sizeHeader . setMaxCumulationBufferCapacity ( Integer . MAX_VALUE ) ; } else { sizeHeader . setMaxCumulationBufferCapacity ( ( int ) nettyTransport . maxCumulationBufferCapacity . bytes ( ) ) ; } } if ( nettyTransport . maxCompositeBufferComponents ! = - <int> ) { sizeHeader . setMaxCumulationBufferComponents ( nettyTransport . maxCompositeBufferComponents ) ; } channelPipeline . addLast ( <str> , sizeHeader ) ; channelPipeline . addLast ( <str> , new MessageChannelHandler ( nettyTransport , nettyTransport . logger , <str> ) ) ; return channelPipeline ; } } public ChannelPipelineFactory configureServerChannelPipelineFactory ( String name , Settings settings ) { return new ServerChannelPipelineFactory ( this , name , settings ) ; } protected static class ServerChannelPipelineFactory implements ChannelPipelineFactory { protected final NettyTransport nettyTransport ; protected final String name ; protected final Settings settings ; public ServerChannelPipelineFactory ( NettyTransport nettyTransport , String name , Settings settings ) { this . nettyTransport = nettyTransport ; this . name = name ; this . settings = settings ; } @Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline channelPipeline = Channels . pipeline ( ) ; channelPipeline . addLast ( <str> , nettyTransport . serverOpenChannels ) ; SizeHeaderFrameDecoder sizeHeader = new SizeHeaderFrameDecoder ( ) ; if ( nettyTransport . maxCumulationBufferCapacity ! = null ) { if ( nettyTransport . maxCumulationBufferCapacity . bytes ( ) > Integer . MAX_VALUE ) { sizeHeader . setMaxCumulationBufferCapacity ( Integer . MAX_VALUE ) ; } else { sizeHeader . setMaxCumulationBufferCapacity ( ( int ) nettyTransport . maxCumulationBufferCapacity . bytes ( ) ) ; } } if ( nettyTransport . maxCompositeBufferComponents ! = - <int> ) { sizeHeader . setMaxCumulationBufferComponents ( nettyTransport . maxCompositeBufferComponents ) ; } channelPipeline . addLast ( <str> , sizeHeader ) ; channelPipeline . addLast ( <str> , new MessageChannelHandler ( nettyTransport , nettyTransport . logger , name ) ) ; return channelPipeline ; } } protected class ChannelCloseListener implements ChannelFutureListener { private final DiscoveryNode node ; private ChannelCloseListener ( DiscoveryNode node ) { this . node = node ; } @Override public void operationComplete ( final ChannelFuture future ) throws Exception { NodeChannels nodeChannels = connectedNodes . get ( node ) ; if ( nodeChannels ! = null & & nodeChannels . hasChannel ( future . getChannel ( ) ) ) { threadPool ( ) . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { disconnectFromNode ( node , future . getChannel ( ) , <str> ) ; } } ) ; } } } public static class NodeChannels { List < Channel > allChannels = Collections . emptyList ( ) ; private Channel [ ] recovery ; private final AtomicInteger recoveryCounter = new AtomicInteger ( ) ; private Channel [ ] bulk ; private final AtomicInteger bulkCounter = new AtomicInteger ( ) ; private Channel [ ] reg ; private final AtomicInteger regCounter = new AtomicInteger ( ) ; private Channel [ ] state ; private final AtomicInteger stateCounter = new AtomicInteger ( ) ; private Channel [ ] ping ; private final AtomicInteger pingCounter = new AtomicInteger ( ) ; public NodeChannels ( Channel [ ] recovery , Channel [ ] bulk , Channel [ ] reg , Channel [ ] state , Channel [ ] ping ) { this . recovery = recovery ; this . bulk = bulk ; this . reg = reg ; this . state = state ; this . ping = ping ; } public void start ( ) { List < Channel > newAllChannels = new ArrayList < > ( ) ; newAllChannels . addAll ( Arrays . asList ( recovery ) ) ; newAllChannels . addAll ( Arrays . asList ( bulk ) ) ; newAllChannels . addAll ( Arrays . asList ( reg ) ) ; newAllChannels . addAll ( Arrays . asList ( state ) ) ; newAllChannels . addAll ( Arrays . asList ( ping ) ) ; this . allChannels = Collections . unmodifiableList ( newAllChannels ) ; } public boolean hasChannel ( Channel channel ) { for ( Channel channel1 : allChannels ) { if ( channel . equals ( channel1 ) ) { return true ; } } return false ; } public Channel channel ( TransportRequestOptions . Type type ) { if ( type = = TransportRequestOptions . Type . REG ) { return reg [ MathUtils . mod ( regCounter . incrementAndGet ( ) , reg . length ) ] ; } else if ( type = = TransportRequestOptions . Type . STATE ) { return state [ MathUtils . mod ( stateCounter . incrementAndGet ( ) , state . length ) ] ; } else if ( type = = TransportRequestOptions . Type . PING ) { return ping [ MathUtils . mod ( pingCounter . incrementAndGet ( ) , ping . length ) ] ; } else if ( type = = TransportRequestOptions . Type . BULK ) { return bulk [ MathUtils . mod ( bulkCounter . incrementAndGet ( ) , bulk . length ) ] ; } else if ( type = = TransportRequestOptions . Type . RECOVERY ) { return recovery [ MathUtils . mod ( recoveryCounter . incrementAndGet ( ) , recovery . length ) ] ; } else { throw new IllegalArgumentException ( <str> + type + <str> ) ; } } public synchronized void close ( ) { List < ChannelFuture > futures = new ArrayList < > ( ) ; for ( Channel channel : allChannels ) { try { if ( channel ! = null & & channel . isOpen ( ) ) { futures . add ( channel . close ( ) ) ; } } catch ( Exception e ) { } } for ( ChannelFuture future : futures ) { future . awaitUninterruptibly ( ) ; } } } class ScheduledPing extends AbstractRunnable { final CounterMetric successfulPings = new CounterMetric ( ) ; final CounterMetric failedPings = new CounterMetric ( ) ; @Override protected void doRun ( ) throws Exception { if ( lifecycle . stoppedOrClosed ( ) ) { return ; } for ( Map . Entry < DiscoveryNode , NodeChannels > entry : connectedNodes . entrySet ( ) ) { DiscoveryNode node = entry . getKey ( ) ; NodeChannels channels = entry . getValue ( ) ; for ( Channel channel : channels . allChannels ) { try { ChannelFuture future = channel . write ( NettyHeader . pingHeader ( ) ) ; future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { successfulPings . inc ( ) ; } } ) ; } catch ( Throwable t ) { if ( channel . isOpen ( ) ) { logger . debug ( <str> , t , node ) ; failedPings . inc ( ) ; } else { logger . trace ( <str> , t , node ) ; } } } } threadPool . schedule ( pingSchedule , ThreadPool . Names . GENERIC , this ) ; } @Override public void onFailure ( Throwable t ) { if ( lifecycle . stoppedOrClosed ( ) ) { logger . trace ( <str> , t ) ; } else { logger . warn ( <str> , t ) ; } } } } 
