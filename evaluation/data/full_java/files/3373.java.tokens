package jcuda . jcublas . kernel ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; import java . util . Arrays ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . atomic . AtomicInteger ; import org . apache . commons . lang3 . time . StopWatch ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . ops . BroadcastOp ; import org . nd4j . linalg . api . ops . executioner . OpExecutioner ; import org . nd4j . linalg . api . ops . impl . broadcast . * ; import org . nd4j . linalg . api . ops . impl . transforms . Log ; import org . nd4j . linalg . api . ops . impl . transforms . LogSoftMax ; import org . nd4j . linalg . api . ops . impl . transforms . SoftMax ; import org . nd4j . linalg . api . ops . impl . transforms . comparison . Eps ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . executors . ExecutorServiceProvider ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . ops . transforms . Transforms ; import org . nd4j . linalg . util . ArrayUtil ; import static org . junit . Assert . * ; public class TestMatrixOperations { @Test public void testDot ( ) { INDArray four = Nd4j . linspace ( <int> , <int> , <int> ) ; double dot = Nd4j . getBlasWrapper ( ) . dot ( four , four ) ; assertEquals ( <int> , dot , <float> ) ; } @Test public void testSums ( ) { INDArray a = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray tad = a . tensorAlongDimension ( <int> , <int> ) ; INDArray tadOne = a . tensorAlongDimension ( <int> , <int> ) ; int ele = tad . elementWiseStride ( ) ; int otherEle = tadOne . elementWiseStride ( ) ; assertEquals ( Nd4j . create ( new float [ ] { <int> , <int> } ) , a . sum ( <int> ) ) ; assertEquals ( <int> , a . sumNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testMeans ( ) { INDArray a = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray mean1 = a . mean ( <int> ) ; assertEquals ( Nd4j . create ( new double [ ] { <float> , <float> } ) , mean1 ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , a . mean ( <int> ) ) ; assertEquals ( <float> , Nd4j . linspace ( <int> , <int> , <int> ) . meanNumber ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <float> , a . meanNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testTad ( ) { INDArray arr = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { System . out . println ( arr . tensorAlongDimension ( i , <int> ) . offset ( ) ) ; } } @Test public void testSumWithRow2 ( ) { INDArray array3d = Nd4j . ones ( <int> , <int> , <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; INDArray array4d = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; int tad = array4d . tensorAlongDimension ( <int> , <int> ) . elementWiseStride ( ) ; int tads = array4d . tensorssAlongDimension ( <int> ) ; for ( int i = <int> ; i < array4d . tensorssAlongDimension ( <int> ) ; i + + ) { System . out . println ( array4d . tensorAlongDimension ( i , <int> ) . offset ( ) ) ; } array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; INDArray array5d = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; } @Test public void testEps ( ) { INDArray ones = Nd4j . ones ( <int> ) ; INDArray eps = Nd4j . getExecutioner ( ) . exec ( new Eps ( ones , ones , ones , ones . length ( ) ) ) . z ( ) ; double sum = eps . sumNumber ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testMean ( ) { INDArray mean2 = Nd4j . linspace ( <int> , <int> , <int> ) ; assertEquals ( <int> , mean2 . meanNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testBlasSum ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; double sum = Nd4j . getBlasWrapper ( ) . asum ( arr ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testSum2 ( ) { INDArray test = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray sum = test . sum ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <int> , <int> } ) ; assertEquals ( assertion , sum ) ; INDArray sum0 = Nd4j . create ( new double [ ] { <int> , <int> } ) ; assertEquals ( sum0 , test . sum ( <int> ) ) ; } @Test public void testRowSoftmax ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; SoftMax softMax = new SoftMax ( arr ) ; opExecutioner . exec ( softMax ) ; assertEquals ( <float> , softMax . z ( ) . sumNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testRowLogSoftMax ( ) { int [ ] [ ] shapes = new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } } ; double eps = <float> ; for ( int [ ] shape : shapes ) { INDArray orig = Nd4j . rand ( shape ) ; INDArray orig1 = orig . dup ( ) ; INDArray orig2 = orig . dup ( ) ; Nd4j . getExecutioner ( ) . exec ( new SoftMax ( orig1 ) , <int> ) ; Nd4j . getExecutioner ( ) . exec ( new Log ( orig1 ) ) ; Nd4j . getExecutioner ( ) . exec ( new LogSoftMax ( orig2 ) , <int> ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { double o1 = orig1 . getDouble ( i ) ; double o2 = orig2 . getDouble ( i ) ; if ( Math . abs ( o1 - o2 ) > eps ) { System . out . println ( ) ; } assertEquals ( o1 , o2 , eps ) ; } } } } @Test public void testSum ( ) { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray test = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray sum = n . sum ( - <int> ) ; assertEquals ( test , sum ) ; INDArray sumZero = n . sum ( <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( assertion , sumZero ) ; INDArray sumOne = n . sum ( <int> ) ; for ( int i = <int> ; i < n . tensorssAlongDimension ( <int> ) ; i + + ) { System . out . println ( n . tensorAlongDimension ( i , <int> ) ) ; } INDArray assertionTwo = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( assertionTwo , sumOne ) ; } @Test public void testArgMax ( ) { INDArray toArgMax = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; System . out . println ( toArgMax . tensorssAlongDimension ( <int> ) ) ; int elementWise = toArgMax . tensorAlongDimension ( <int> , <int> ) . elementWiseStride ( ) ; for ( int i = <int> ; i < toArgMax . tensorssAlongDimension ( <int> ) ; i + + ) { System . out . println ( toArgMax . tensorAlongDimension ( i , <int> ) ) ; } INDArray tensor = toArgMax . tensorAlongDimension ( <int> , <int> ) ; System . out . println ( toArgMax . max ( <int> ) ) ; System . out . println ( ) ; } @Test public void testElementWiseOp ( ) { Transforms . sigmoid ( Nd4j . ones ( <int> , <int> ) ) ; } @Test public void testTensorAlongDimension ( ) { int [ ] shape = new int [ ] { <int> , <int> , <int> } ; int length = ArrayUtil . prod ( shape ) ; INDArray arr = Nd4j . linspace ( <int> , length , length ) . reshape ( shape ) ; int [ ] dim0s = { <int> , <int> , <int> , <int> , <int> , <int> } ; int [ ] dim1s = { <int> , <int> , <int> , <int> , <int> , <int> } ; double [ ] sums = { <float> , <float> , <int> , <int> , <int> , <int> } ; for ( int i = <int> ; i < dim0s . length ; i + + ) { int firstDim = dim0s [ i ] ; int secondDim = dim1s [ i ] ; INDArray tad = arr . tensorAlongDimension ( <int> , firstDim , secondDim ) ; assertEquals ( <str> + i + <str> , sums [ i ] , tad . sumNumber ( ) . doubleValue ( ) , <float> ) ; } } @Test public void testNorm2Double ( ) { Nd4j . dtype = DataBuffer . Type . DOUBLE ; INDArray n = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; double assertion = <float> ; double norm3 = n . norm2Number ( ) . doubleValue ( ) ; assertEquals ( assertion , norm3 , <float> ) ; INDArray row = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray row1 = row . getRow ( <int> ) ; double norm2 = row1 . norm2Number ( ) . doubleValue ( ) ; double assertion2 = <float> ; assertEquals ( assertion2 , norm2 , <float> ) ; } @Test public void testNorm2 ( ) { INDArray n = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; float assertion = <float> ; float norm3 = n . norm2Number ( ) . floatValue ( ) ; assertEquals ( assertion , norm3 , <float> ) ; INDArray row = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray row1 = row . getRow ( <int> ) ; float norm2 = row1 . norm2Number ( ) . floatValue ( ) ; float assertion2 = <float> ; assertEquals ( assertion2 , norm2 , <float> ) ; } @Test public void testLength ( ) { INDArray values = Nd4j . create ( <int> , <int> ) ; INDArray values2 = Nd4j . create ( <int> , <int> ) ; values . put ( <int> , <int> , <int> ) ; values2 . put ( <int> , <int> , <int> ) ; values . put ( <int> , <int> , <int> ) ; values2 . put ( <int> , <int> , <int> ) ; values . put ( <int> , <int> , <int> ) ; values2 . put ( <int> , <int> , <int> ) ; values . put ( <int> , <int> , <int> ) ; values2 . put ( <int> , <int> , <int> ) ; for ( int i = <int> ; i < values . tensorssAlongDimension ( <int> ) ; i + + ) { System . out . println ( <str> + i + <str> + values . tensorAlongDimension ( i , <int> ) ) ; System . out . println ( <str> + i + <str> + values2 . tensorAlongDimension ( i , <int> ) ) ; } INDArray expected = Nd4j . repeat ( Nd4j . scalar ( <int> ) , <int> ) . reshape ( <int> , <int> ) ; Accumulation accum = Nd4j . getOpFactory ( ) . createAccum ( <str> , values , values2 ) ; INDArray results = Nd4j . getExecutioner ( ) . exec ( accum , <int> ) ; assertEquals ( expected , results ) ; } @Test public void testDivRowVector ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; arr . diviRowVector ( Nd4j . linspace ( <int> , <int> , <int> ) ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; assertEquals ( assertion , arr ) ; } @Test public void testMulRowVector ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; arr . muliRowVector ( Nd4j . linspace ( <int> , <int> , <int> ) ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; assertEquals ( assertion , arr ) ; } @Test public void testMMulColVectorRowVectorMixedOrder ( ) { INDArray colVec = Nd4j . ones ( <int> , <int> ) ; INDArray rowVec = Nd4j . ones ( <int> , <int> ) ; INDArray out = rowVec . mmul ( colVec ) ; assertArrayEquals ( out . shape ( ) , new int [ ] { <int> , <int> } ) ; assertTrue ( out . equals ( Nd4j . ones ( <int> , <int> ) . muli ( <int> ) ) ) ; INDArray colVectorC = Nd4j . create ( new int [ ] { <int> , <int> } , <str> ) ; INDArray rowVectorF = Nd4j . create ( new int [ ] { <int> , <int> } , <str> ) ; for ( int i = <int> ; i < colVectorC . length ( ) ; i + + ) colVectorC . putScalar ( i , <float> ) ; for ( int i = <int> ; i < rowVectorF . length ( ) ; i + + ) rowVectorF . putScalar ( i , <float> ) ; assertTrue ( colVec . equals ( colVectorC ) ) ; assertTrue ( rowVec . equals ( rowVectorF ) ) ; INDArray outCF = rowVectorF . mmul ( colVectorC ) ; assertArrayEquals ( outCF . shape ( ) , new int [ ] { <int> , <int> } ) ; assertTrue ( outCF . equals ( Nd4j . ones ( <int> , <int> ) . muli ( <int> ) ) ) ; } @Test public void testNdVectorOpLinSpace ( ) { int [ ] shape = { <int> , <int> , <int> , <int> , <int> } ; INDArray orig = Nd4j . linspace ( <int> , ArrayUtil . prod ( shape ) , ArrayUtil . prod ( shape ) ) . reshape ( shape ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { StringBuffer sb = new StringBuffer ( ) ; INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; for ( int j = <int> ; j < tad . length ( ) ; j + + ) { sb . append ( tad . get ( NDArrayIndex . point ( j ) ) . offset ( ) ) ; sb . append ( <str> ) ; } System . out . println ( sb ) ; } System . out . println ( ) ; INDArray vector = Nd4j . linspace ( <int> , shape [ dimension ] , shape [ dimension ] ) ; BroadcastOp op = new BroadcastAddOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( op . z ( ) . tensorAlongDimension ( i , dimension ) ) ; int opNum = <int> ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . add ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } NdIndexIterator iter = new NdIndexIterator ( orig . shape ( ) ) ; while ( iter . hasNext ( ) ) { int [ ] next = iter . next ( ) ; double origValue = orig . getDouble ( next ) ; double vectorValue = vector . getDouble ( next [ dimension ] ) ; double exp ; switch ( opNum ) { case <int> : exp = origValue + vectorValue ; break ; case <int> : exp = vectorValue ; break ; case <int> : exp = origValue / vectorValue ; break ; case <int> : exp = origValue * vectorValue ; break ; case <int> : exp = vectorValue / origValue ; break ; case <int> : exp = vectorValue - origValue ; break ; case <int> : exp = origValue - vectorValue ; break ; default : throw new RuntimeException ( ) ; } double actual = op . z ( ) . getDouble ( next ) ; double relError = Math . abs ( exp - actual ) / ( Math . abs ( exp ) + Math . abs ( actual ) ) ; assertTrue ( <str> + Arrays . toString ( shape ) , relError < <float> ) ; } } @Test public void testNdVectorOpLinSpaceDiv ( ) { int [ ] shape = { <int> , <int> , <int> , <int> , <int> } ; INDArray orig = Nd4j . linspace ( <int> , ArrayUtil . prod ( shape ) , ArrayUtil . prod ( shape ) ) . reshape ( shape ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { StringBuffer sb = new StringBuffer ( ) ; INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; for ( int j = <int> ; j < tad . length ( ) ; j + + ) { sb . append ( tad . get ( NDArrayIndex . point ( j ) ) . offset ( ) ) ; sb . append ( <str> ) ; } System . out . println ( sb ) ; } System . out . println ( ) ; INDArray vector = Nd4j . linspace ( <int> , shape [ dimension ] , shape [ dimension ] ) ; BroadcastOp op = new BroadcastDivOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( op . z ( ) . tensorAlongDimension ( i , dimension ) ) ; int opNum = <int> ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . div ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } NdIndexIterator iter = new NdIndexIterator ( orig . shape ( ) ) ; while ( iter . hasNext ( ) ) { int [ ] next = iter . next ( ) ; double origValue = orig . getDouble ( next ) ; double vectorValue = vector . getDouble ( next [ dimension ] ) ; double exp ; switch ( opNum ) { case <int> : exp = origValue + vectorValue ; break ; case <int> : exp = vectorValue ; break ; case <int> : exp = origValue / vectorValue ; break ; case <int> : exp = origValue * vectorValue ; break ; case <int> : exp = vectorValue / origValue ; break ; case <int> : exp = vectorValue - origValue ; break ; case <int> : exp = origValue - vectorValue ; break ; default : throw new RuntimeException ( ) ; } double actual = op . z ( ) . getDouble ( next ) ; double relError = Math . abs ( exp - actual ) / ( Math . abs ( exp ) + Math . abs ( actual ) ) ; assertTrue ( <str> + Arrays . toString ( shape ) , relError < <float> ) ; } } @Test public void testFiveBySevenDimOne ( ) { INDArray orig = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( orig . tensorAlongDimension ( i , dimension ) ) ; System . out . println ( ) ; BroadcastOp op = new BroadcastAddOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . add ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } NdIndexIterator iter = new NdIndexIterator ( orig . shape ( ) ) ; int [ ] shape = { <int> , <int> } ; int opNum = <int> ; while ( iter . hasNext ( ) ) { int [ ] next = iter . next ( ) ; double origValue = orig . getDouble ( next ) ; double vectorValue = vector . getDouble ( next [ dimension ] ) ; double exp ; switch ( opNum ) { case <int> : exp = origValue + vectorValue ; break ; case <int> : exp = vectorValue ; break ; case <int> : exp = origValue / vectorValue ; break ; case <int> : exp = origValue * vectorValue ; break ; case <int> : exp = vectorValue / origValue ; break ; case <int> : exp = vectorValue - origValue ; break ; case <int> : exp = origValue - vectorValue ; break ; default : throw new RuntimeException ( ) ; } double actual = op . z ( ) . getDouble ( next ) ; double relError = Math . abs ( exp - actual ) / ( Math . abs ( exp ) + Math . abs ( actual ) ) ; assertTrue ( <str> + Arrays . toString ( shape ) , relError < <float> ) ; } } @Test public void testFiveBySevenRDiv ( ) { INDArray orig = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( orig . tensorAlongDimension ( i , dimension ) ) ; System . out . println ( ) ; BroadcastOp op = new BroadcastRDivOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . rdiv ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } } @Test public void testFiveBySevenDiv ( ) { INDArray orig = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( orig . tensorAlongDimension ( i , dimension ) ) ; System . out . println ( ) ; BroadcastOp op = new BroadcastDivOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . div ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } } @Test public void testFiveBySeven ( ) { INDArray orig = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; int dimension = <int> ; System . out . println ( orig . tensorssAlongDimension ( dimension ) ) ; for ( int i = <int> ; i < <int> ; i + + ) System . out . println ( orig . tensorAlongDimension ( i , dimension ) ) ; System . out . println ( ) ; BroadcastOp op = new BroadcastAddOp ( orig , vector , orig . dup ( ) , dimension ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < orig . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray tad = orig . tensorAlongDimension ( i , dimension ) ; INDArray zDim = op . z ( ) . tensorAlongDimension ( i , dimension ) ; INDArray assertion = tad . add ( vector ) ; assertEquals ( <str> + tad + <str> + i , assertion , zDim ) ; } NdIndexIterator iter = new NdIndexIterator ( orig . shape ( ) ) ; int [ ] shape = { <int> , <int> } ; int opNum = <int> ; while ( iter . hasNext ( ) ) { int [ ] next = iter . next ( ) ; double origValue = orig . getDouble ( next ) ; double vectorValue = vector . getDouble ( next [ dimension ] ) ; double exp ; switch ( opNum ) { case <int> : exp = origValue + vectorValue ; break ; case <int> : exp = vectorValue ; break ; case <int> : exp = origValue / vectorValue ; break ; case <int> : exp = origValue * vectorValue ; break ; case <int> : exp = vectorValue / origValue ; break ; case <int> : exp = vectorValue - origValue ; break ; case <int> : exp = origValue - vectorValue ; break ; default : throw new RuntimeException ( ) ; } double actual = op . z ( ) . getDouble ( next ) ; double relError = Math . abs ( exp - actual ) / ( Math . abs ( exp ) + Math . abs ( actual ) ) ; assertTrue ( <str> + Arrays . toString ( shape ) , relError < <float> ) ; } } @Test public void testColumnVectorAdd ( ) { INDArray vector = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> , <float> } ) ; INDArray matrix = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , new int [ ] { <int> , <int> } ) ; int dimension = <int> ; BroadcastAddOp op = new BroadcastAddOp ( matrix , vector , matrix . dup ( ) , <int> ) ; INDArray assertion = matrix . dup ( ) ; for ( int i = <int> ; i < assertion . tensorssAlongDimension ( dimension ) ; i + + ) { assertion . tensorAlongDimension ( i , dimension ) . addi ( vector ) ; } Nd4j . getExecutioner ( ) . exec ( op ) ; assertEquals ( assertion , op . z ( ) ) ; } @Test public void testDimensionOneLengthSeven ( ) { INDArray seven = Nd4j . linspace ( <int> , <int> , <int> ) ; int [ ] tensorShape = { <int> , <int> , <int> , <int> , <int> } ; int len = ArrayUtil . prod ( tensorShape ) ; int dimension = <int> ; INDArray arr = Nd4j . linspace ( <int> , len , len ) . reshape ( tensorShape ) ; BroadcastAddOp op = new BroadcastAddOp ( arr , seven , arr , dimension ) ; INDArray dup = arr . dup ( ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; for ( int i = <int> ; i < <int> ; i + + ) { System . out . println ( <str> + seven + <str> + dup . tensorAlongDimension ( i , dimension ) ) ; System . out . println ( <str> + seven + <str> + arr . tensorAlongDimension ( i , dimension ) ) ; } System . out . println ( op . z ( ) ) ; } @Test public void testNdVectorOp ( ) { Nd4j . getRandom ( ) . setSeed ( <int> ) ; int [ ] maxShape = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int opNum = <int> ; opNum < <int> ; opNum + + ) { for ( int rank = <int> ; rank < maxShape . length ; rank + + ) { int [ ] shape = Arrays . copyOfRange ( maxShape , <int> , rank ) ; INDArray orig = Nd4j . rand ( shape ) ; for ( int i = <int> ; i < rank ; i + + ) { INDArray arr = orig . dup ( ) ; INDArray vector = i = = <int> ? Nd4j . rand ( <int> , shape [ i ] ) : Nd4j . rand ( shape [ i ] , <int> ) ; System . out . println ( <str> + rank + <str> + i + <str> + vector + <str> + Arrays . toString ( arr . shape ( ) ) ) ; BroadcastOp op ; switch ( opNum ) { case <int> : op = new BroadcastAddOp ( arr , vector , arr . dup ( ) , i ) ; break ; case <int> : op = new BroadcastCopyOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastDivOp ( arr , vector , arr . dup ( ) , i ) ; break ; case <int> : op = new BroadcastMulOp ( arr , vector , arr . dup ( ) , i ) ; break ; case <int> : op = new BroadcastRDivOp ( arr , vector , arr . dup ( ) , i ) ; break ; case <int> : op = new BroadcastRSubOp ( arr , vector , arr . dup ( ) , i ) ; break ; case <int> : op = new BroadcastSubOp ( arr , vector , arr . dup ( ) , i ) ; break ; default : throw new RuntimeException ( ) ; } StopWatch watch = new StopWatch ( ) ; watch . start ( ) ; System . out . println ( <str> + op . name ( ) ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; watch . stop ( ) ; System . out . println ( <str> + watch . getNanoTime ( ) + <str> + op . x ( ) . tensorssAlongDimension ( i ) ) ; INDArray assertion = arr . dup ( ) ; for ( int j = <int> ; j < arr . tensorssAlongDimension ( i ) ; j + + ) { switch ( opNum ) { case <int> : assertion . tensorAlongDimension ( j , i ) . addi ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . assign ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . divi ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . muli ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . rdivi ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . rsubi ( vector ) ; break ; case <int> : assertion . tensorAlongDimension ( j , i ) . subi ( vector ) ; break ; default : throw new RuntimeException ( ) ; } } assertEquals ( assertion , op . z ( ) ) ; } } } } @Test public void testCosineSim ( ) { Nd4j . dtype = DataBuffer . Type . FLOAT ; INDArray vec1 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; INDArray vec2 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; double sim = Transforms . cosineSim ( vec1 , vec2 ) ; assertEquals ( <int> , sim , <float> ) ; INDArray vec3 = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; INDArray vec4 = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; sim = Transforms . cosineSim ( vec3 , vec4 ) ; assertEquals ( <float> , sim , <float> ) ; } @Test public void testSumWithRow1 ( ) { INDArray array2d = Nd4j . ones ( <int> , <int> ) ; array2d . sum ( <int> ) ; array2d . sum ( <int> ) ; INDArray array3d = Nd4j . ones ( <int> , <int> , <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; INDArray array4d = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; INDArray array5d = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; } @Test public void testToOffsetZero ( ) { INDArray matrix = Nd4j . rand ( <int> , <int> ) ; INDArray rowOne = matrix . getRow ( <int> ) ; INDArray row1Copy = Shape . toOffsetZero ( rowOne ) ; assertEquals ( rowOne , row1Copy ) ; INDArray rows = matrix . getRows ( <int> , <int> ) ; INDArray rowsOffsetZero = Shape . toOffsetZero ( rows ) ; assertEquals ( rows , rowsOffsetZero ) ; INDArray tensor = Nd4j . rand ( new int [ ] { <int> , <int> , <int> } ) ; INDArray getTensor = tensor . slice ( <int> ) . slice ( <int> ) ; INDArray getTensorZero = Shape . toOffsetZero ( getTensor ) ; assertEquals ( getTensor , getTensorZero ) ; } @Test public void testSumLeadingTrailingZeros ( ) { testSumHelper ( <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> , <int> ) ; testSumHelper ( <int> , <int> , <int> , <int> , <int> , <int> ) ; } private void testSumHelper ( int . . . shape ) { INDArray array = Nd4j . ones ( shape ) ; for ( int i = <int> ; i < shape . length ; i + + ) { for ( int j = <int> ; j < array . vectorsAlongDimension ( i ) ; j + + ) { INDArray vec = array . vectorAlongDimension ( j , i ) ; } array . sum ( i ) ; } } @Test public void testMultipleThreads ( ) throws InterruptedException { int numThreads = <int> ; final INDArray array = Nd4j . rand ( <int> , <int> ) ; final INDArray expected = array . dup ( ) . mmul ( array ) . mmul ( array ) . div ( array ) . div ( array ) ; final AtomicInteger correct = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( numThreads ) ; System . out . println ( <str> + ContextHolder . getInstance ( ) . deviceNum ( ) ) ; ExecutorService executors = ExecutorServiceProvider . getExecutorService ( ) ; for ( int x = <int> ; x < numThreads ; x + + ) { executors . execute ( new Runnable ( ) { @Override public void run ( ) { try { int total = <int> ; int right = <int> ; for ( int x = <int> ; x < total ; x + + ) { StopWatch watch = new StopWatch ( ) ; watch . start ( ) ; INDArray actual = array . dup ( ) . mmul ( array ) . mmul ( array ) . div ( array ) . div ( array ) ; watch . stop ( ) ; if ( expected . equals ( actual ) ) right + + ; } if ( total = = right ) correct . incrementAndGet ( ) ; } finally { latch . countDown ( ) ; } } } ) ; } latch . await ( ) ; assertEquals ( numThreads , correct . get ( ) ) ; } } 
