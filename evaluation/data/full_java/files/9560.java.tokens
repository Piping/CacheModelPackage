package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . base . Predicates . equalTo ; import static com . google . common . base . Predicates . in ; import static com . google . common . base . Predicates . instanceOf ; import static com . google . common . base . Predicates . not ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static com . google . common . util . concurrent . Service . State . FAILED ; import static com . google . common . util . concurrent . Service . State . NEW ; import static com . google . common . util . concurrent . Service . State . RUNNING ; import static com . google . common . util . concurrent . Service . State . STARTING ; import static com . google . common . util . concurrent . Service . State . STOPPING ; import static com . google . common . util . concurrent . Service . State . TERMINATED ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import com . google . common . annotations . Beta ; import com . google . common . base . Function ; import com . google . common . base . MoreObjects ; import com . google . common . base . Stopwatch ; import com . google . common . collect . Collections2 ; import com . google . common . collect . ImmutableCollection ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableMultimap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . ImmutableSetMultimap ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . MultimapBuilder ; import com . google . common . collect . Multimaps ; import com . google . common . collect . Multiset ; import com . google . common . collect . Ordering ; import com . google . common . collect . SetMultimap ; import com . google . common . util . concurrent . ListenerCallQueue . Callback ; import com . google . common . util . concurrent . Service . State ; import com . google . j2objc . annotations . WeakOuter ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import java . util . Collections ; import java . util . EnumSet ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . concurrent . GuardedBy ; @Beta public final class ServiceManager { private static final Logger logger = Logger . getLogger ( ServiceManager . class . getName ( ) ) ; private static final Callback < Listener > HEALTHY_CALLBACK = new Callback < Listener > ( <str> ) { @Override void call ( Listener listener ) { listener . healthy ( ) ; } } ; private static final Callback < Listener > STOPPED_CALLBACK = new Callback < Listener > ( <str> ) { @Override void call ( Listener listener ) { listener . stopped ( ) ; } } ; @Beta public abstract static class Listener { public void healthy ( ) { } public void stopped ( ) { } public void failure ( Service service ) { } } private final ServiceManagerState state ; private final ImmutableList < Service > services ; public ServiceManager ( Iterable < ? extends Service > services ) { ImmutableList < Service > copy = ImmutableList . copyOf ( services ) ; if ( copy . isEmpty ( ) ) { logger . log ( Level . WARNING , <str> , new EmptyServiceManagerWarning ( ) ) ; copy = ImmutableList . < Service > of ( new NoOpService ( ) ) ; } this . state = new ServiceManagerState ( copy ) ; this . services = copy ; WeakReference < ServiceManagerState > stateReference = new WeakReference < ServiceManagerState > ( state ) ; for ( Service service : copy ) { service . addListener ( new ServiceListener ( service , stateReference ) , directExecutor ( ) ) ; checkArgument ( service . state ( ) = = NEW , <str> , service ) ; } this . state . markReady ( ) ; } public void addListener ( Listener listener , Executor executor ) { state . addListener ( listener , executor ) ; } public void addListener ( Listener listener ) { state . addListener ( listener , directExecutor ( ) ) ; } public ServiceManager startAsync ( ) { for ( Service service : services ) { State state = service . state ( ) ; checkState ( state = = NEW , <str> , service , state ) ; } for ( Service service : services ) { try { state . tryStartTiming ( service ) ; service . startAsync ( ) ; } catch ( IllegalStateException e ) { logger . log ( Level . WARNING , <str> + service , e ) ; } } return this ; } public void awaitHealthy ( ) { state . awaitHealthy ( ) ; } public void awaitHealthy ( long timeout , TimeUnit unit ) throws TimeoutException { state . awaitHealthy ( timeout , unit ) ; } public ServiceManager stopAsync ( ) { for ( Service service : services ) { service . stopAsync ( ) ; } return this ; } public void awaitStopped ( ) { state . awaitStopped ( ) ; } public void awaitStopped ( long timeout , TimeUnit unit ) throws TimeoutException { state . awaitStopped ( timeout , unit ) ; } public boolean isHealthy ( ) { for ( Service service : services ) { if ( ! service . isRunning ( ) ) { return false ; } } return true ; } public ImmutableMultimap < State , Service > servicesByState ( ) { return state . servicesByState ( ) ; } public ImmutableMap < Service , Long > startupTimes ( ) { return state . startupTimes ( ) ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( ServiceManager . class ) . add ( <str> , Collections2 . filter ( services , not ( instanceOf ( NoOpService . class ) ) ) ) . toString ( ) ; } private static final class ServiceManagerState { final Monitor monitor = new Monitor ( ) ; @GuardedBy ( <str> ) final SetMultimap < State , Service > servicesByState = MultimapBuilder . enumKeys ( State . class ) . linkedHashSetValues ( ) . build ( ) ; @GuardedBy ( <str> ) final Multiset < State > states = servicesByState . keys ( ) ; @GuardedBy ( <str> ) final Map < Service , Stopwatch > startupTimers = Maps . newIdentityHashMap ( ) ; @GuardedBy ( <str> ) boolean ready ; @GuardedBy ( <str> ) boolean transitioned ; final int numberOfServices ; final Monitor . Guard awaitHealthGuard = new AwaitHealthGuard ( ) ; @WeakOuter final class AwaitHealthGuard extends Monitor . Guard { AwaitHealthGuard ( ) { super ( ServiceManagerState . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return states . count ( RUNNING ) = = numberOfServices | | states . contains ( STOPPING ) | | states . contains ( TERMINATED ) | | states . contains ( FAILED ) ; } } final Monitor . Guard stoppedGuard = new StoppedGuard ( ) ; @WeakOuter final class StoppedGuard extends Monitor . Guard { StoppedGuard ( ) { super ( ServiceManagerState . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return states . count ( TERMINATED ) + states . count ( FAILED ) = = numberOfServices ; } } @GuardedBy ( <str> ) final List < ListenerCallQueue < Listener > > listeners = Collections . synchronizedList ( new ArrayList < ListenerCallQueue < Listener > > ( ) ) ; ServiceManagerState ( ImmutableCollection < Service > services ) { this . numberOfServices = services . size ( ) ; servicesByState . putAll ( NEW , services ) ; } void tryStartTiming ( Service service ) { monitor . enter ( ) ; try { Stopwatch stopwatch = startupTimers . get ( service ) ; if ( stopwatch = = null ) { startupTimers . put ( service , Stopwatch . createStarted ( ) ) ; } } finally { monitor . leave ( ) ; } } void markReady ( ) { monitor . enter ( ) ; try { if ( ! transitioned ) { ready = true ; } else { List < Service > servicesInBadStates = Lists . newArrayList ( ) ; for ( Service service : servicesByState ( ) . values ( ) ) { if ( service . state ( ) ! = NEW ) { servicesInBadStates . add ( service ) ; } } throw new IllegalArgumentException ( <str> + <str> + servicesInBadStates ) ; } } finally { monitor . leave ( ) ; } } void addListener ( Listener listener , Executor executor ) { checkNotNull ( listener , <str> ) ; checkNotNull ( executor , <str> ) ; monitor . enter ( ) ; try { if ( ! stoppedGuard . isSatisfied ( ) ) { listeners . add ( new ListenerCallQueue < Listener > ( listener , executor ) ) ; } } finally { monitor . leave ( ) ; } } void awaitHealthy ( ) { monitor . enterWhenUninterruptibly ( awaitHealthGuard ) ; try { checkHealthy ( ) ; } finally { monitor . leave ( ) ; } } void awaitHealthy ( long timeout , TimeUnit unit ) throws TimeoutException { monitor . enter ( ) ; try { if ( ! monitor . waitForUninterruptibly ( awaitHealthGuard , timeout , unit ) ) { throw new TimeoutException ( <str> + <str> + Multimaps . filterKeys ( servicesByState , in ( ImmutableSet . of ( NEW , STARTING ) ) ) ) ; } checkHealthy ( ) ; } finally { monitor . leave ( ) ; } } void awaitStopped ( ) { monitor . enterWhenUninterruptibly ( stoppedGuard ) ; monitor . leave ( ) ; } void awaitStopped ( long timeout , TimeUnit unit ) throws TimeoutException { monitor . enter ( ) ; try { if ( ! monitor . waitForUninterruptibly ( stoppedGuard , timeout , unit ) ) { throw new TimeoutException ( <str> + <str> + Multimaps . filterKeys ( servicesByState , not ( in ( EnumSet . of ( TERMINATED , FAILED ) ) ) ) ) ; } } finally { monitor . leave ( ) ; } } ImmutableMultimap < State , Service > servicesByState ( ) { ImmutableSetMultimap . Builder < State , Service > builder = ImmutableSetMultimap . builder ( ) ; monitor . enter ( ) ; try { for ( Entry < State , Service > entry : servicesByState . entries ( ) ) { if ( ! ( entry . getValue ( ) instanceof NoOpService ) ) { builder . put ( entry ) ; } } } finally { monitor . leave ( ) ; } return builder . build ( ) ; } ImmutableMap < Service , Long > startupTimes ( ) { List < Entry < Service , Long > > loadTimes ; monitor . enter ( ) ; try { loadTimes = Lists . newArrayListWithCapacity ( startupTimers . size ( ) ) ; for ( Entry < Service , Stopwatch > entry : startupTimers . entrySet ( ) ) { Service service = entry . getKey ( ) ; Stopwatch stopWatch = entry . getValue ( ) ; if ( ! stopWatch . isRunning ( ) & & ! ( service instanceof NoOpService ) ) { loadTimes . add ( Maps . immutableEntry ( service , stopWatch . elapsed ( MILLISECONDS ) ) ) ; } } } finally { monitor . leave ( ) ; } Collections . sort ( loadTimes , Ordering . natural ( ) . onResultOf ( new Function < Entry < Service , Long > , Long > ( ) { @Override public Long apply ( Map . Entry < Service , Long > input ) { return input . getValue ( ) ; } } ) ) ; return ImmutableMap . copyOf ( loadTimes ) ; } void transitionService ( final Service service , State from , State to ) { checkNotNull ( service ) ; checkArgument ( from ! = to ) ; monitor . enter ( ) ; try { transitioned = true ; if ( ! ready ) { return ; } checkState ( servicesByState . remove ( from , service ) , <str> , service , from ) ; checkState ( servicesByState . put ( to , service ) , <str> , service , to ) ; Stopwatch stopwatch = startupTimers . get ( service ) ; if ( stopwatch = = null ) { stopwatch = Stopwatch . createStarted ( ) ; startupTimers . put ( service , stopwatch ) ; } if ( to . compareTo ( RUNNING ) > = <int> & & stopwatch . isRunning ( ) ) { stopwatch . stop ( ) ; if ( ! ( service instanceof NoOpService ) ) { logger . log ( Level . FINE , <str> , new Object [ ] { service , stopwatch } ) ; } } if ( to = = FAILED ) { fireFailedListeners ( service ) ; } if ( states . count ( RUNNING ) = = numberOfServices ) { fireHealthyListeners ( ) ; } else if ( states . count ( TERMINATED ) + states . count ( FAILED ) = = numberOfServices ) { fireStoppedListeners ( ) ; } } finally { monitor . leave ( ) ; executeListeners ( ) ; } } @GuardedBy ( <str> ) void fireStoppedListeners ( ) { STOPPED_CALLBACK . enqueueOn ( listeners ) ; } @GuardedBy ( <str> ) void fireHealthyListeners ( ) { HEALTHY_CALLBACK . enqueueOn ( listeners ) ; } @GuardedBy ( <str> ) void fireFailedListeners ( final Service service ) { new Callback < Listener > ( <str> + service + <str> ) { @Override void call ( Listener listener ) { listener . failure ( service ) ; } } . enqueueOn ( listeners ) ; } void executeListeners ( ) { checkState ( ! monitor . isOccupiedByCurrentThread ( ) , <str> ) ; for ( int i = <int> ; i < listeners . size ( ) ; i + + ) { listeners . get ( i ) . execute ( ) ; } } @GuardedBy ( <str> ) void checkHealthy ( ) { if ( states . count ( RUNNING ) ! = numberOfServices ) { IllegalStateException exception = new IllegalStateException ( <str> + Multimaps . filterKeys ( servicesByState , not ( equalTo ( RUNNING ) ) ) ) ; throw exception ; } } } private static final class ServiceListener extends Service . Listener { final Service service ; final WeakReference < ServiceManagerState > state ; ServiceListener ( Service service , WeakReference < ServiceManagerState > state ) { this . service = service ; this . state = state ; } @Override public void starting ( ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { state . transitionService ( service , NEW , STARTING ) ; if ( ! ( service instanceof NoOpService ) ) { logger . log ( Level . FINE , <str> , service ) ; } } } @Override public void running ( ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { state . transitionService ( service , STARTING , RUNNING ) ; } } @Override public void stopping ( State from ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { state . transitionService ( service , from , STOPPING ) ; } } @Override public void terminated ( State from ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { if ( ! ( service instanceof NoOpService ) ) { logger . log ( Level . FINE , <str> , new Object [ ] { service , from } ) ; } state . transitionService ( service , from , TERMINATED ) ; } } @Override public void failed ( State from , Throwable failure ) { ServiceManagerState state = this . state . get ( ) ; if ( state ! = null ) { if ( ! ( service instanceof NoOpService ) ) { logger . log ( Level . SEVERE , <str> + service + <str> + from + <str> , failure ) ; } state . transitionService ( service , from , FAILED ) ; } } } private static final class NoOpService extends AbstractService { @Override protected void doStart ( ) { notifyStarted ( ) ; } @Override protected void doStop ( ) { notifyStopped ( ) ; } } private static final class EmptyServiceManagerWarning extends Throwable { } } 
