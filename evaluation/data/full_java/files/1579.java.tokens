package org . apache . cassandra . io . util ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . EOFException ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . ReadableByteChannel ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . Random ; import org . junit . Test ; import com . google . common . base . Charsets ; import com . google . common . primitives . UnsignedBytes ; import com . google . common . primitives . UnsignedInteger ; import com . google . common . primitives . UnsignedLong ; import static org . junit . Assert . * ; public class NIODataInputStreamTest { Random r ; ByteBuffer corpus = ByteBuffer . allocate ( <int> * <int> * <int> ) ; void init ( ) { long seed = System . nanoTime ( ) ; System . out . println ( <str> + seed ) ; r = new Random ( seed ) ; r . nextBytes ( corpus . array ( ) ) ; } class FakeChannel implements ReadableByteChannel { @Override public boolean isOpen ( ) { return true ; } @Override public void close ( ) throws IOException { } @Override public int read ( ByteBuffer dst ) throws IOException { return <int> ; } } class DummyChannel implements ReadableByteChannel { boolean isOpen = true ; Queue < ByteBuffer > slices = new ArrayDeque < ByteBuffer > ( ) ; DummyChannel ( ) { slices . clear ( ) ; corpus . clear ( ) ; while ( corpus . hasRemaining ( ) ) { int sliceSize = Math . min ( corpus . remaining ( ) , r . nextInt ( <int> ) ) ; corpus . limit ( corpus . position ( ) + sliceSize ) ; slices . offer ( corpus . slice ( ) ) ; corpus . position ( corpus . limit ( ) ) ; corpus . limit ( corpus . capacity ( ) ) ; } corpus . clear ( ) ; } @Override public boolean isOpen ( ) { return isOpen ( ) ; } @Override public void close ( ) throws IOException { isOpen = false ; } @Override public int read ( ByteBuffer dst ) throws IOException { if ( ! isOpen ) throw new IOException ( <str> ) ; if ( slices . isEmpty ( ) ) return - <int> ; if ( ! slices . peek ( ) . hasRemaining ( ) ) { if ( r . nextInt ( <int> ) = = <int> ) { return <int> ; } else { slices . poll ( ) ; if ( slices . isEmpty ( ) ) return - <int> ; } } ByteBuffer slice = slices . peek ( ) ; int oldLimit = slice . limit ( ) ; int copied = <int> ; if ( slice . remaining ( ) > dst . remaining ( ) ) { slice . limit ( slice . position ( ) + dst . remaining ( ) ) ; copied = dst . remaining ( ) ; } else { copied = slice . remaining ( ) ; } dst . put ( slice ) ; slice . limit ( oldLimit ) ; return copied ; } } NIODataInputStream fakeStream = new NIODataInputStream ( new FakeChannel ( ) , <int> ) ; @Test ( expected = IOException . class ) public void testResetThrows ( ) throws Exception { fakeStream . reset ( ) ; } @Test ( expected = NullPointerException . class ) public void testNullReadBuffer ( ) throws Exception { fakeStream . read ( null , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testNegativeOffsetReadBuffer ( ) throws Exception { fakeStream . read ( new byte [ <int> ] , - <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testNegativeLengthReadBuffer ( ) throws Exception { fakeStream . read ( new byte [ <int> ] , <int> , - <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testLengthToBigReadBuffer ( ) throws Exception { fakeStream . read ( new byte [ <int> ] , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testLengthToWithOffsetBigReadBuffer ( ) throws Exception { fakeStream . read ( new byte [ <int> ] , <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void testReadLine ( ) throws Exception { fakeStream . readLine ( ) ; } @Test public void testMarkSupported ( ) throws Exception { assertFalse ( fakeStream . markSupported ( ) ) ; } @SuppressWarnings ( <str> ) @Test ( expected = NullPointerException . class ) public void testNullRBC ( ) throws Exception { new NIODataInputStream ( null , <int> ) ; } @SuppressWarnings ( <str> ) @Test public void testAvailable ( ) throws Exception { init ( ) ; DummyChannel dc = new DummyChannel ( ) ; dc . slices . clear ( ) ; dc . slices . offer ( ByteBuffer . allocate ( <int> ) ) ; NIODataInputStream is = new NIODataInputStream ( dc , <int> ) ; assertEquals ( <int> , is . available ( ) ) ; is . read ( ) ; assertEquals ( <int> , is . available ( ) ) ; is . read ( new byte [ <int> ] ) ; assertEquals ( <int> , is . available ( ) ) ; is . read ( new byte [ <int> ] ) ; assertEquals ( <int> - <int> - <int> , is . available ( ) ) ; File f = File . createTempFile ( <str> , <str> ) ; RandomAccessFile fos = new RandomAccessFile ( f , <str> ) ; fos . write ( new byte [ <int> ] ) ; fos . seek ( <int> ) ; is = new NIODataInputStream ( fos . getChannel ( ) , <int> ) ; int remaining = <int> ; assertEquals ( <int> , is . available ( ) ) ; while ( remaining > <int> ) { is . read ( ) ; remaining - - ; assertEquals ( remaining , is . available ( ) ) ; } assertEquals ( <int> , is . available ( ) ) ; } private static ReadableByteChannel wrap ( final byte bytes [ ] ) { final ByteBuffer buf = ByteBuffer . wrap ( bytes ) ; return new ReadableByteChannel ( ) { @Override public boolean isOpen ( ) { return false ; } @Override public void close ( ) throws IOException { } @Override public int read ( ByteBuffer dst ) throws IOException { int read = Math . min ( dst . remaining ( ) , buf . remaining ( ) ) ; buf . limit ( buf . position ( ) + read ) ; dst . put ( buf ) ; buf . limit ( buf . capacity ( ) ) ; return read = = <int> ? - <int> : read ; } } ; } @SuppressWarnings ( <str> ) @Test public void testReadUTF ( ) throws Exception { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream daos = new DataOutputStream ( baos ) ; String simple = <str> ; assertEquals ( <int> , BufferedDataOutputStreamTest . twoByte . getBytes ( Charsets . UTF_8 ) . length ) ; assertEquals ( <int> , BufferedDataOutputStreamTest . threeByte . getBytes ( Charsets . UTF_8 ) . length ) ; assertEquals ( <int> , BufferedDataOutputStreamTest . fourByte . getBytes ( Charsets . UTF_8 ) . length ) ; daos . writeUTF ( simple ) ; daos . writeUTF ( BufferedDataOutputStreamTest . twoByte ) ; daos . writeUTF ( BufferedDataOutputStreamTest . threeByte ) ; daos . writeUTF ( BufferedDataOutputStreamTest . fourByte ) ; NIODataInputStream is = new NIODataInputStream ( wrap ( baos . toByteArray ( ) ) , <int> ) ; assertEquals ( simple , is . readUTF ( ) ) ; assertEquals ( BufferedDataOutputStreamTest . twoByte , is . readUTF ( ) ) ; assertEquals ( BufferedDataOutputStreamTest . threeByte , is . readUTF ( ) ) ; assertEquals ( BufferedDataOutputStreamTest . fourByte , is . readUTF ( ) ) ; } @SuppressWarnings ( <str> ) @Test public void testReadVInt ( ) throws Exception { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStreamPlus daos = new WrappedDataOutputStreamPlus ( baos ) ; long values [ ] = new long [ ] { <int> , <int> , - <int> , Long . MIN_VALUE , Long . MIN_VALUE + <int> , Long . MAX_VALUE , Long . MAX_VALUE - <int> , Integer . MIN_VALUE , Integer . MIN_VALUE + <int> , Integer . MAX_VALUE , Integer . MAX_VALUE - <int> , Short . MIN_VALUE , Short . MIN_VALUE + <int> , Short . MAX_VALUE , Short . MAX_VALUE - <int> , Byte . MIN_VALUE , Byte . MIN_VALUE + <int> , Byte . MAX_VALUE , Byte . MAX_VALUE - <int> } ; values = BufferedDataOutputStreamTest . enrich ( values ) ; for ( long v : values ) daos . writeVInt ( v ) ; daos . flush ( ) ; NIODataInputStream is = new NIODataInputStream ( wrap ( baos . toByteArray ( ) ) , <int> ) ; for ( long v : values ) assertEquals ( v , is . readVInt ( ) ) ; boolean threw = false ; try { is . readVInt ( ) ; } catch ( EOFException e ) { threw = true ; } assertTrue ( threw ) ; } @SuppressWarnings ( <str> ) @Test public void testReadUnsignedVInt ( ) throws Exception { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStreamPlus daos = new WrappedDataOutputStreamPlus ( baos ) ; long values [ ] = new long [ ] { <int> , <int> , UnsignedLong . MAX_VALUE . longValue ( ) , UnsignedLong . MAX_VALUE . longValue ( ) - <int> , UnsignedLong . MAX_VALUE . longValue ( ) + <int> , UnsignedInteger . MAX_VALUE . longValue ( ) , UnsignedInteger . MAX_VALUE . longValue ( ) - <int> , UnsignedInteger . MAX_VALUE . longValue ( ) + <int> , UnsignedBytes . MAX_VALUE , UnsignedBytes . MAX_VALUE - <int> , UnsignedBytes . MAX_VALUE + <int> , <int> , <int> - <int> , <int> + <int> } ; values = BufferedDataOutputStreamTest . enrich ( values ) ; for ( long v : values ) daos . writeUnsignedVInt ( v ) ; daos . flush ( ) ; NIODataInputStream is = new NIODataInputStream ( wrap ( baos . toByteArray ( ) ) , <int> ) ; for ( long v : values ) assertEquals ( v , is . readUnsignedVInt ( ) ) ; boolean threw = false ; try { is . readUnsignedVInt ( ) ; } catch ( EOFException e ) { threw = true ; } assertTrue ( threw ) ; } @Test public void testFuzz ( ) throws Exception { for ( int ii = <int> ; ii < <int> ; ii + + ) fuzzOnce ( ) ; } void validateAgainstCorpus ( byte bytes [ ] , int offset , int length , int position ) throws Exception { assertEquals ( corpus . position ( ) , position ) ; int startPosition = corpus . position ( ) ; for ( int ii = <int> ; ii < length ; ii + + ) { byte expected = corpus . get ( ) ; byte actual = bytes [ ii + offset ] ; if ( expected ! = actual ) fail ( <str> ) ; byte canonical = dis . readByte ( ) ; if ( canonical ! = actual ) fail ( <str> ) ; } assertEquals ( length , corpus . position ( ) - startPosition ) ; } DataInputStream dis ; @SuppressWarnings ( { <str> , <str> } ) void fuzzOnce ( ) throws Exception { init ( ) ; int read = <int> ; int totalRead = <int> ; DummyChannel dc = new DummyChannel ( ) ; NIODataInputStream is = new NIODataInputStream ( dc , <int> * <int> ) ; dis = new DataInputStream ( new ByteArrayInputStream ( corpus . array ( ) ) ) ; int iteration = <int> ; while ( totalRead < corpus . capacity ( ) ) { assertEquals ( corpus . position ( ) , totalRead ) ; int action = r . nextInt ( <int> ) ; iteration + + ; switch ( action ) { case <int> : { byte bytes [ ] = new byte [ <int> ] ; int expectedBytes = corpus . capacity ( ) - totalRead ; boolean expectEOF = expectedBytes < <int> ; boolean threwEOF = false ; try { is . readFully ( bytes ) ; } catch ( EOFException e ) { threwEOF = true ; } assertEquals ( expectEOF , threwEOF ) ; if ( expectEOF ) return ; validateAgainstCorpus ( bytes , <int> , <int> , totalRead ) ; totalRead + = <int> ; break ; } case <int> : { byte bytes [ ] = new byte [ r . nextInt ( <int> * <int> + <int> ) ] ; int offset = bytes . length = = <int> ? <int> : r . nextInt ( bytes . length ) ; int length = bytes . length = = <int> ? <int> : r . nextInt ( bytes . length - offset ) ; int expectedBytes = corpus . capacity ( ) - totalRead ; boolean expectEOF = expectedBytes < length ; boolean threwEOF = false ; try { is . readFully ( bytes , offset , length ) ; } catch ( EOFException e ) { threwEOF = true ; } assertEquals ( expectEOF , threwEOF ) ; if ( expectEOF ) return ; validateAgainstCorpus ( bytes , offset , length , totalRead ) ; totalRead + = length ; break ; } case <int> : { byte bytes [ ] = new byte [ r . nextInt ( <int> * <int> + <int> ) ] ; int offset = bytes . length = = <int> ? <int> : r . nextInt ( bytes . length ) ; int length = bytes . length = = <int> ? <int> : r . nextInt ( bytes . length - offset ) ; int expectedBytes = corpus . capacity ( ) - totalRead ; boolean expectEOF = expectedBytes = = <int> ; read = is . read ( bytes , offset , length ) ; assertTrue ( ( expectEOF & & read < = <int> ) | | ( ! expectEOF & & read > = <int> ) ) ; if ( expectEOF ) return ; validateAgainstCorpus ( bytes , offset , read , totalRead ) ; totalRead + = read ; break ; } case <int> : { byte bytes [ ] = new byte [ <int> ] ; int expectedBytes = corpus . capacity ( ) - totalRead ; boolean expectEOF = expectedBytes = = <int> ; read = is . read ( bytes ) ; assertTrue ( ( expectEOF & & read < = <int> ) | | ( ! expectEOF & & read > = <int> ) ) ; if ( expectEOF ) return ; validateAgainstCorpus ( bytes , <int> , read , totalRead ) ; totalRead + = read ; break ; } case <int> : { boolean expected = corpus . get ( ) ! = <int> ; boolean canonical = dis . readBoolean ( ) ; boolean actual = is . readBoolean ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + + ; break ; } case <int> : { byte expected = corpus . get ( ) ; byte canonical = dis . readByte ( ) ; byte actual = is . readByte ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + + ; break ; } case <int> : { int expected = corpus . get ( ) & <hex> ; int canonical = dis . read ( ) ; int actual = is . read ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + + ; break ; } case <int> : { int expected = corpus . get ( ) & <hex> ; int canonical = dis . readUnsignedByte ( ) ; int actual = is . readUnsignedByte ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + + ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readShort ( ) ; } catch ( EOFException e ) { try { dis . readShort ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } short expected = corpus . getShort ( ) ; short canonical = dis . readShort ( ) ; short actual = is . readShort ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + = <int> ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readUnsignedShort ( ) ; } catch ( EOFException e ) { try { dis . readUnsignedShort ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } int ch1 = corpus . get ( ) & <hex> ; int ch2 = corpus . get ( ) & <hex> ; int expected = ( ch1 < < <int> ) + ( ch2 < < <int> ) ; int canonical = dis . readUnsignedShort ( ) ; int actual = is . readUnsignedShort ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + = <int> ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readChar ( ) ; } catch ( EOFException e ) { try { dis . readChar ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } char expected = corpus . getChar ( ) ; char canonical = dis . readChar ( ) ; char actual = is . readChar ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + = <int> ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readInt ( ) ; } catch ( EOFException e ) { try { dis . readInt ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } int expected = corpus . getInt ( ) ; int canonical = dis . readInt ( ) ; int actual = is . readInt ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + = <int> ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readFloat ( ) ; } catch ( EOFException e ) { try { dis . readFloat ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } float expected = corpus . getFloat ( ) ; float canonical = dis . readFloat ( ) ; float actual = is . readFloat ( ) ; totalRead + = <int> ; if ( Float . isNaN ( expected ) ) { assertTrue ( Float . isNaN ( canonical ) & & Float . isNaN ( actual ) ) ; } else { assertTrue ( expected = = canonical & & canonical = = actual ) ; } break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readLong ( ) ; } catch ( EOFException e ) { try { dis . readLong ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } long expected = corpus . getLong ( ) ; long canonical = dis . readLong ( ) ; long actual = is . readLong ( ) ; assertTrue ( expected = = canonical & & canonical = = actual ) ; totalRead + = <int> ; break ; } case <int> : { if ( corpus . remaining ( ) < <int> ) { boolean threw = false ; try { is . readDouble ( ) ; } catch ( EOFException e ) { try { dis . readDouble ( ) ; } catch ( EOFException e2 ) { } threw = true ; } assertTrue ( threw ) ; assertTrue ( corpus . remaining ( ) - totalRead < <int> ) ; totalRead = corpus . capacity ( ) ; break ; } double expected = corpus . getDouble ( ) ; double canonical = dis . readDouble ( ) ; double actual = is . readDouble ( ) ; totalRead + = <int> ; if ( Double . isNaN ( expected ) ) { assertTrue ( Double . isNaN ( canonical ) & & Double . isNaN ( actual ) ) ; } else { assertTrue ( expected = = canonical & & canonical = = actual ) ; } break ; } case <int> : { int skipBytes = r . nextInt ( <int> ) ; int actuallySkipped = Math . min ( skipBytes , corpus . remaining ( ) ) ; totalRead + = actuallySkipped ; corpus . position ( corpus . position ( ) + actuallySkipped ) ; int canonical = dis . skipBytes ( actuallySkipped ) ; int actual = is . skipBytes ( actuallySkipped ) ; assertEquals ( actuallySkipped , canonical ) ; assertEquals ( canonical , actual ) ; break ; } default : fail ( <str> ) ; } } assertEquals ( totalRead , corpus . capacity ( ) ) ; assertEquals ( - <int> , dis . read ( ) ) ; } @Test @SuppressWarnings ( { <str> } ) public void testVIntRemainingBytes ( ) throws Exception { for ( int ii = <int> ; ii < <int> ; ii + + ) { for ( int zz = <int> ; zz < <int> ; zz + + ) { if ( zz + ii > <int> ) continue ; ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; buf . position ( ii ) ; long value = <int> ; if ( ii > <int> ) value = ( <int> < < <int> * zz ) - <int> ; BufferedDataOutputStreamPlus out = new DataOutputBufferFixed ( buf ) ; out . writeUnsignedVInt ( value ) ; buf . position ( ii ) ; RebufferingInputStream in = new DataInputBuffer ( buf , false ) ; assertEquals ( value , in . readUnsignedVInt ( ) ) ; } } } @Test @SuppressWarnings ( { <str> } ) public void testVIntSmallBuffer ( ) throws Exception { for ( int ii = <int> ; ii < <int> ; ii + + ) { ByteBuffer buf = ByteBuffer . allocate ( Math . max ( <int> , ii ) ) ; long value = <int> ; if ( ii > <int> ) value = ( <int> < < <int> * ii ) - <int> ; BufferedDataOutputStreamPlus out = new DataOutputBufferFixed ( buf ) ; out . writeUnsignedVInt ( value ) ; buf . position ( <int> ) ; RebufferingInputStream in = new DataInputBuffer ( buf , false ) ; assertEquals ( value , in . readUnsignedVInt ( ) ) ; boolean threw = false ; try { in . readUnsignedVInt ( ) ; } catch ( EOFException e ) { threw = true ; } assertTrue ( threw ) ; } } @Test @SuppressWarnings ( { <str> } ) public void testVIntTruncationEOF ( ) throws Exception { for ( int ii = <int> ; ii < <int> ; ii + + ) { ByteBuffer buf = ByteBuffer . allocate ( Math . max ( <int> , ii ) ) ; long value = <int> ; if ( ii > <int> ) value = ( <int> < < <int> * ii ) - <int> ; BufferedDataOutputStreamPlus out = new DataOutputBufferFixed ( buf ) ; out . writeUnsignedVInt ( value ) ; buf . position ( <int> ) ; ByteBuffer truncated = ByteBuffer . allocate ( buf . capacity ( ) - <int> ) ; buf . limit ( buf . limit ( ) - <int> ) ; truncated . put ( buf ) ; truncated . flip ( ) ; RebufferingInputStream in = new DataInputBuffer ( truncated , false ) ; boolean threw = false ; try { in . readUnsignedVInt ( ) ; } catch ( EOFException e ) { threw = true ; } assertTrue ( threw ) ; } } } 
