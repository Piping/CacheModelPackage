package org . elasticsearch . index . query ; import org . apache . lucene . search . GeoPointInPolygonQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . fielddata . IndexGeoPointFieldData ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . geo . BaseGeoPointFieldMapper ; import org . elasticsearch . index . search . geo . GeoPolygonQuery ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Objects ; public class GeoPolygonQueryBuilder extends AbstractQueryBuilder < GeoPolygonQueryBuilder > { public static final String NAME = <str> ; private static final List < GeoPoint > PROTO_SHAPE = Arrays . asList ( new GeoPoint [ ] { new GeoPoint ( <float> , <float> ) , new GeoPoint ( <float> , <float> ) , new GeoPoint ( <float> , <float> ) } ) ; static final GeoPolygonQueryBuilder PROTOTYPE = new GeoPolygonQueryBuilder ( <str> , PROTO_SHAPE ) ; private final String fieldName ; private final List < GeoPoint > shell ; private GeoValidationMethod validationMethod = GeoValidationMethod . DEFAULT ; public GeoPolygonQueryBuilder ( String fieldName , List < GeoPoint > points ) { if ( Strings . isEmpty ( fieldName ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( points = = null | | points . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> ) ; } else { GeoPoint start = points . get ( <int> ) ; if ( start . equals ( points . get ( points . size ( ) - <int> ) ) ) { if ( points . size ( ) < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } else { if ( points . size ( ) < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } } this . fieldName = fieldName ; this . shell = new ArrayList < > ( points ) ; if ( ! shell . get ( shell . size ( ) - <int> ) . equals ( shell . get ( <int> ) ) ) { shell . add ( shell . get ( <int> ) ) ; } } public String fieldName ( ) { return fieldName ; } public List < GeoPoint > points ( ) { return shell ; } public GeoPolygonQueryBuilder setValidationMethod ( GeoValidationMethod method ) { this . validationMethod = method ; return this ; } public GeoValidationMethod getValidationMethod ( ) { return this . validationMethod ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { MappedFieldType fieldType = context . fieldMapper ( fieldName ) ; if ( fieldType = = null ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } if ( ! ( fieldType instanceof BaseGeoPointFieldMapper . GeoPointFieldType ) ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } List < GeoPoint > shell = new ArrayList < GeoPoint > ( ) ; for ( GeoPoint geoPoint : this . shell ) { shell . add ( new GeoPoint ( geoPoint ) ) ; } final int shellSize = shell . size ( ) ; final boolean indexCreatedBeforeV2_0 = context . indexVersionCreated ( ) . before ( Version . V_2_0_0 ) ; if ( ! indexCreatedBeforeV2_0 & & ! GeoValidationMethod . isIgnoreMalformed ( validationMethod ) ) { for ( GeoPoint point : shell ) { if ( ! GeoUtils . isValidLatitude ( point . lat ( ) ) ) { throw new QueryShardException ( context , <str> , point . lat ( ) , GeoPolygonQueryBuilder . NAME ) ; } if ( ! GeoUtils . isValidLongitude ( point . lat ( ) ) ) { throw new QueryShardException ( context , <str> , point . lon ( ) , GeoPolygonQueryBuilder . NAME ) ; } } } if ( GeoValidationMethod . isCoerce ( validationMethod ) ) { for ( GeoPoint point : shell ) { GeoUtils . normalizePoint ( point , true , true ) ; } } if ( context . indexVersionCreated ( ) . before ( Version . V_2_2_0 ) ) { IndexGeoPointFieldData indexFieldData = context . getForField ( fieldType ) ; return new GeoPolygonQuery ( indexFieldData , shell . toArray ( new GeoPoint [ shellSize ] ) ) ; } double [ ] lats = new double [ shellSize ] ; double [ ] lons = new double [ shellSize ] ; GeoPoint p ; for ( int i = <int> ; i < shellSize ; + + i ) { p = new GeoPoint ( shell . get ( i ) ) ; lats [ i ] = p . lat ( ) ; lons [ i ] = p . lon ( ) ; } return new GeoPointInPolygonQuery ( fieldType . names ( ) . fullName ( ) , lons , lats ) ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; builder . startArray ( GeoPolygonQueryParser . POINTS_FIELD . getPreferredName ( ) ) ; for ( GeoPoint point : shell ) { builder . startArray ( ) . value ( point . lon ( ) ) . value ( point . lat ( ) ) . endArray ( ) ; } builder . endArray ( ) ; builder . endObject ( ) ; builder . field ( GeoPolygonQueryParser . COERCE_FIELD . getPreferredName ( ) , GeoValidationMethod . isCoerce ( validationMethod ) ) ; builder . field ( GeoPolygonQueryParser . IGNORE_MALFORMED_FIELD . getPreferredName ( ) , GeoValidationMethod . isIgnoreMalformed ( validationMethod ) ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected GeoPolygonQueryBuilder doReadFrom ( StreamInput in ) throws IOException { String fieldName = in . readString ( ) ; List < GeoPoint > shell = new ArrayList < > ( ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { shell . add ( in . readGeoPoint ( ) ) ; } GeoPolygonQueryBuilder builder = new GeoPolygonQueryBuilder ( fieldName , shell ) ; builder . validationMethod = GeoValidationMethod . readGeoValidationMethodFrom ( in ) ; return builder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; out . writeVInt ( shell . size ( ) ) ; for ( GeoPoint point : shell ) { out . writeGeoPoint ( point ) ; } validationMethod . writeTo ( out ) ; } @Override protected boolean doEquals ( GeoPolygonQueryBuilder other ) { return Objects . equals ( validationMethod , other . validationMethod ) & & Objects . equals ( fieldName , other . fieldName ) & & Objects . equals ( shell , other . shell ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( validationMethod , fieldName , shell ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
