package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Double . NEGATIVE_INFINITY ; import static java . lang . Double . NaN ; import static java . lang . Double . POSITIVE_INFINITY ; import static org . junit . Assert . fail ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import java . math . BigInteger ; import java . util . List ; class StatsTesting { static final double ALLOWED_ERROR = <float> ; static final double ONE_VALUE = <float> ; static final double OTHER_ONE_VALUE = - <float> ; static final ImmutableList < Double > TWO_VALUES = ImmutableList . of ( <float> , - <float> ) ; static final double TWO_VALUES_MEAN = ( <float> - <float> ) / <int> ; static final double TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS = ( <float> - TWO_VALUES_MEAN ) * ( <float> - TWO_VALUES_MEAN ) + ( - <float> - TWO_VALUES_MEAN ) * ( - <float> - TWO_VALUES_MEAN ) ; static final double TWO_VALUES_MAX = <float> ; static final double TWO_VALUES_MIN = - <float> ; static final ImmutableList < Double > OTHER_TWO_VALUES = ImmutableList . of ( <float> , - <float> ) ; static final double OTHER_TWO_VALUES_MEAN = ( <float> - <float> ) / <int> ; static final double TWO_VALUES_SUM_OF_PRODUCTS_OF_DELTAS = ( <float> - TWO_VALUES_MEAN ) * ( <float> - OTHER_TWO_VALUES_MEAN ) + ( - <float> - TWO_VALUES_MEAN ) * ( - <float> - OTHER_TWO_VALUES_MEAN ) ; static class ManyValues { private final ImmutableList < Double > values ; ManyValues ( double [ ] values ) { this . values = ImmutableList . copyOf ( Doubles . asList ( values ) ) ; } ImmutableList < Double > asIterable ( ) { return values ; } double [ ] asArray ( ) { return Doubles . toArray ( values ) ; } boolean hasAnyPositiveInfinity ( ) { return Iterables . any ( values , Predicates . equalTo ( POSITIVE_INFINITY ) ) ; } boolean hasAnyNegativeInfinity ( ) { return Iterables . any ( values , Predicates . equalTo ( NEGATIVE_INFINITY ) ) ; } boolean hasAnyNaN ( ) { return Iterables . any ( values , Predicates . equalTo ( NaN ) ) ; } boolean hasAnyNonFinite ( ) { return hasAnyPositiveInfinity ( ) | | hasAnyNegativeInfinity ( ) | | hasAnyNaN ( ) ; } @Override public String toString ( ) { return values . toString ( ) ; } private static ImmutableList < ManyValues > createAll ( ) { ImmutableList . Builder < ManyValues > builder = ImmutableList . builder ( ) ; double [ ] values = new double [ <int> ] ; for ( double first : ImmutableList . of ( <float> , POSITIVE_INFINITY , NEGATIVE_INFINITY , NaN ) ) { values [ <int> ] = first ; values [ <int> ] = - <float> ; for ( double third : ImmutableList . of ( <float> , POSITIVE_INFINITY , NEGATIVE_INFINITY , NaN ) ) { values [ <int> ] = third ; values [ <int> ] = <float> ; for ( double fifth : ImmutableList . of ( - <float> , POSITIVE_INFINITY , NEGATIVE_INFINITY , NaN ) ) { values [ <int> ] = fifth ; builder . add ( new ManyValues ( values ) ) ; } } } return builder . build ( ) ; } } static final Iterable < ManyValues > ALL_MANY_VALUES = ManyValues . createAll ( ) ; static final ImmutableList < Double > MANY_VALUES = ImmutableList . of ( <float> , - <float> , <float> , <float> , - <float> ) ; static final int MANY_VALUES_COUNT = <int> ; static final double MANY_VALUES_MEAN = ( <float> - <float> + <float> + <float> - <float> ) / <int> ; static final double MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS = ( <float> - MANY_VALUES_MEAN ) * ( <float> - MANY_VALUES_MEAN ) + ( - <float> - MANY_VALUES_MEAN ) * ( - <float> - MANY_VALUES_MEAN ) + ( <float> - MANY_VALUES_MEAN ) * ( <float> - MANY_VALUES_MEAN ) + ( <float> - MANY_VALUES_MEAN ) * ( <float> - MANY_VALUES_MEAN ) + ( - <float> - MANY_VALUES_MEAN ) * ( - <float> - MANY_VALUES_MEAN ) ; static final double MANY_VALUES_MAX = <float> ; static final double MANY_VALUES_MIN = - <float> ; static final double [ ] LARGE_VALUES = { Double . MAX_VALUE , Double . MAX_VALUE / <float> } ; static final double LARGE_VALUES_MEAN = <float> * Double . MAX_VALUE ; static final ImmutableList < Double > OTHER_MANY_VALUES = ImmutableList . of ( <float> , - <float> , <float> , - <float> , <float> ) ; static final double OTHER_MANY_VALUES_MEAN = ( <float> - <float> + <float> - <float> + <float> ) / <int> ; static final double MANY_VALUES_SUM_OF_PRODUCTS_OF_DELTAS = ( <float> - MANY_VALUES_MEAN ) * ( <float> - OTHER_MANY_VALUES_MEAN ) + ( - <float> - MANY_VALUES_MEAN ) * ( - <float> - OTHER_MANY_VALUES_MEAN ) + ( <float> - MANY_VALUES_MEAN ) * ( <float> - OTHER_MANY_VALUES_MEAN ) + ( <float> - MANY_VALUES_MEAN ) * ( - <float> - OTHER_MANY_VALUES_MEAN ) + ( - <float> - MANY_VALUES_MEAN ) * ( <float> - OTHER_MANY_VALUES_MEAN ) ; static final ImmutableList < Integer > INTEGER_MANY_VALUES = ImmutableList . of ( <int> , - <int> , <int> , - <int> , <int> ) ; static final int INTEGER_MANY_VALUES_COUNT = <int> ; static final double INTEGER_MANY_VALUES_MEAN = ( <float> - <float> + <float> - <float> + <float> ) / <int> ; static final double INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS = ( <float> - INTEGER_MANY_VALUES_MEAN ) * ( <float> - INTEGER_MANY_VALUES_MEAN ) + ( - <float> - INTEGER_MANY_VALUES_MEAN ) * ( - <float> - INTEGER_MANY_VALUES_MEAN ) + ( <float> - INTEGER_MANY_VALUES_MEAN ) * ( <float> - INTEGER_MANY_VALUES_MEAN ) + ( - <float> - INTEGER_MANY_VALUES_MEAN ) * ( - <float> - INTEGER_MANY_VALUES_MEAN ) + ( <float> - INTEGER_MANY_VALUES_MEAN ) * ( <float> - INTEGER_MANY_VALUES_MEAN ) ; static final double INTEGER_MANY_VALUES_MAX = <float> ; static final double INTEGER_MANY_VALUES_MIN = - <float> ; static final int [ ] LARGE_INTEGER_VALUES = { Integer . MAX_VALUE , Integer . MAX_VALUE / <int> } ; static final double LARGE_INTEGER_VALUES_MEAN = BigInteger . valueOf ( Integer . MAX_VALUE ) . multiply ( BigInteger . valueOf ( <int> ) ) . divide ( BigInteger . valueOf ( <int> ) ) . doubleValue ( ) ; static final double LARGE_INTEGER_VALUES_POPULATION_VARIANCE = BigInteger . valueOf ( Integer . MAX_VALUE ) . multiply ( BigInteger . valueOf ( Integer . MAX_VALUE ) ) . divide ( BigInteger . valueOf ( <int> ) ) . doubleValue ( ) ; static final ImmutableList < Long > LONG_MANY_VALUES = ImmutableList . of ( <int> , - <int> , <int> , - <int> , <int> ) ; static final int LONG_MANY_VALUES_COUNT = <int> ; static final double LONG_MANY_VALUES_MEAN = ( <float> - <float> + <float> - <float> + <float> ) / <int> ; static final double LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS = ( <float> - LONG_MANY_VALUES_MEAN ) * ( <float> - LONG_MANY_VALUES_MEAN ) + ( - <float> - LONG_MANY_VALUES_MEAN ) * ( - <float> - LONG_MANY_VALUES_MEAN ) + ( <float> - LONG_MANY_VALUES_MEAN ) * ( <float> - LONG_MANY_VALUES_MEAN ) + ( - <float> - LONG_MANY_VALUES_MEAN ) * ( - <float> - LONG_MANY_VALUES_MEAN ) + ( <float> - LONG_MANY_VALUES_MEAN ) * ( <float> - LONG_MANY_VALUES_MEAN ) ; static final double LONG_MANY_VALUES_MAX = <float> ; static final double LONG_MANY_VALUES_MIN = - <float> ; static final long [ ] LARGE_LONG_VALUES = { Long . MAX_VALUE , Long . MAX_VALUE / <int> } ; static final double LARGE_LONG_VALUES_MEAN = BigInteger . valueOf ( Long . MAX_VALUE ) . multiply ( BigInteger . valueOf ( <int> ) ) . divide ( BigInteger . valueOf ( <int> ) ) . doubleValue ( ) ; static final double LARGE_LONG_VALUES_POPULATION_VARIANCE = BigInteger . valueOf ( Long . MAX_VALUE ) . multiply ( BigInteger . valueOf ( Long . MAX_VALUE ) ) . divide ( BigInteger . valueOf ( <int> ) ) . doubleValue ( ) ; static final Stats EMPTY_STATS_VARARGS = Stats . of ( ) ; static final Stats EMPTY_STATS_ITERABLE = Stats . of ( ImmutableList . < Double > of ( ) ) ; static final Stats ONE_VALUE_STATS = Stats . of ( ONE_VALUE ) ; static final Stats OTHER_ONE_VALUE_STATS = Stats . of ( OTHER_ONE_VALUE ) ; static final Stats TWO_VALUES_STATS = Stats . of ( TWO_VALUES ) ; static final Stats OTHER_TWO_VALUES_STATS = Stats . of ( OTHER_TWO_VALUES ) ; static final Stats MANY_VALUES_STATS_VARARGS = Stats . of ( <float> , - <float> , <float> , <float> , - <float> ) ; static final Stats MANY_VALUES_STATS_ITERABLE = Stats . of ( MANY_VALUES ) ; static final Stats MANY_VALUES_STATS_ITERATOR = Stats . of ( MANY_VALUES . iterator ( ) ) ; static final Stats MANY_VALUES_STATS_SNAPSHOT ; static final Stats LARGE_VALUES_STATS = Stats . of ( LARGE_VALUES ) ; static final Stats OTHER_MANY_VALUES_STATS = Stats . of ( OTHER_MANY_VALUES ) ; static final Stats INTEGER_MANY_VALUES_STATS_VARARGS = Stats . of ( Ints . toArray ( INTEGER_MANY_VALUES ) ) ; static final Stats INTEGER_MANY_VALUES_STATS_ITERABLE = Stats . of ( INTEGER_MANY_VALUES ) ; static final Stats LARGE_INTEGER_VALUES_STATS = Stats . of ( LARGE_INTEGER_VALUES ) ; static final Stats LONG_MANY_VALUES_STATS_ITERATOR = Stats . of ( LONG_MANY_VALUES . iterator ( ) ) ; static final Stats LONG_MANY_VALUES_STATS_SNAPSHOT ; static final Stats LARGE_LONG_VALUES_STATS = Stats . of ( LARGE_LONG_VALUES ) ; static { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( MANY_VALUES ) ; MANY_VALUES_STATS_SNAPSHOT = accumulator . snapshot ( ) ; accumulator . add ( <float> ) ; } static { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( LONG_MANY_VALUES ) ; LONG_MANY_VALUES_STATS_SNAPSHOT = accumulator . snapshot ( ) ; } static final List < Stats > ALL_STATS = ImmutableList . of ( EMPTY_STATS_VARARGS , EMPTY_STATS_ITERABLE , ONE_VALUE_STATS , OTHER_ONE_VALUE_STATS , TWO_VALUES_STATS , OTHER_TWO_VALUES_STATS , MANY_VALUES_STATS_VARARGS , MANY_VALUES_STATS_ITERABLE , MANY_VALUES_STATS_ITERATOR , MANY_VALUES_STATS_SNAPSHOT , LARGE_VALUES_STATS , OTHER_MANY_VALUES_STATS , INTEGER_MANY_VALUES_STATS_VARARGS , INTEGER_MANY_VALUES_STATS_ITERABLE , LARGE_INTEGER_VALUES_STATS , LONG_MANY_VALUES_STATS_ITERATOR , LONG_MANY_VALUES_STATS_SNAPSHOT , LARGE_LONG_VALUES_STATS ) ; static final PairedStats EMPTY_PAIRED_STATS = createPairedStatsOf ( ImmutableList . < Double > of ( ) , ImmutableList . < Double > of ( ) ) ; static final PairedStats ONE_VALUE_PAIRED_STATS = createPairedStatsOf ( ImmutableList . of ( ONE_VALUE ) , ImmutableList . of ( OTHER_ONE_VALUE ) ) ; static final PairedStats TWO_VALUES_PAIRED_STATS = createPairedStatsOf ( TWO_VALUES , OTHER_TWO_VALUES ) ; static final PairedStats MANY_VALUES_PAIRED_STATS ; static final PairedStats DUPLICATE_MANY_VALUES_PAIRED_STATS = createPairedStatsOf ( MANY_VALUES , OTHER_MANY_VALUES ) ; static final PairedStats HORIZONTAL_VALUES_PAIRED_STATS ; static final PairedStats VERTICAL_VALUES_PAIRED_STATS ; static final PairedStats CONSTANT_VALUES_PAIRED_STATS ; static { PairedStatsAccumulator accumulator = createFilledPairedStatsAccumulator ( MANY_VALUES , OTHER_MANY_VALUES ) ; MANY_VALUES_PAIRED_STATS = accumulator . snapshot ( ) ; accumulator . add ( <float> , <float> ) ; } static { PairedStatsAccumulator accumulator = new PairedStatsAccumulator ( ) ; for ( double x : MANY_VALUES ) { accumulator . add ( x , OTHER_ONE_VALUE ) ; } HORIZONTAL_VALUES_PAIRED_STATS = accumulator . snapshot ( ) ; } static { PairedStatsAccumulator accumulator = new PairedStatsAccumulator ( ) ; for ( double y : OTHER_MANY_VALUES ) { accumulator . add ( ONE_VALUE , y ) ; } VERTICAL_VALUES_PAIRED_STATS = accumulator . snapshot ( ) ; } static { PairedStatsAccumulator accumulator = new PairedStatsAccumulator ( ) ; for ( int i = <int> ; i < MANY_VALUES_COUNT ; + + i ) { accumulator . add ( ONE_VALUE , OTHER_ONE_VALUE ) ; } CONSTANT_VALUES_PAIRED_STATS = accumulator . snapshot ( ) ; } static void assertStatsApproxEqual ( Stats expectedStats , Stats actualStats ) { assertThat ( actualStats . count ( ) ) . isEqualTo ( expectedStats . count ( ) ) ; if ( expectedStats . count ( ) = = <int> ) { try { actualStats . mean ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { actualStats . populationVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { actualStats . min ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { actualStats . max ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } else if ( expectedStats . count ( ) = = <int> ) { assertThat ( actualStats . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . mean ( ) ) ; assertThat ( actualStats . populationVariance ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( actualStats . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . min ( ) ) ; assertThat ( actualStats . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . max ( ) ) ; } else { assertThat ( actualStats . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . mean ( ) ) ; assertThat ( actualStats . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . populationVariance ( ) ) ; assertThat ( actualStats . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . min ( ) ) ; assertThat ( actualStats . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( expectedStats . max ( ) ) ; } } static void assertDiagonalLinearTransformation ( LinearTransformation transformation , double x1 , double y1 , double xDelta , double yDelta ) { checkArgument ( xDelta ! = <float> ) ; checkArgument ( yDelta ! = <float> ) ; assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . transformX ( x1 ) ) . isWithin ( ALLOWED_ERROR ) . of ( y1 ) ; assertThat ( transformation . transformX ( x1 + xDelta ) ) . isWithin ( ALLOWED_ERROR ) . of ( y1 + yDelta ) ; assertThat ( transformation . transformY ( y1 ) ) . isWithin ( ALLOWED_ERROR ) . of ( x1 ) ; assertThat ( transformation . transformY ( y1 + yDelta ) ) . isWithin ( ALLOWED_ERROR ) . of ( x1 + xDelta ) ; assertThat ( transformation . slope ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( yDelta / xDelta ) ; } static void assertHorizontalLinearTransformation ( LinearTransformation transformation , double y ) { assertThat ( transformation . isHorizontal ( ) ) . isTrue ( ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . transformX ( - <float> ) ) . isWithin ( ALLOWED_ERROR ) . of ( y ) ; assertThat ( transformation . transformX ( <float> ) ) . isWithin ( ALLOWED_ERROR ) . of ( y ) ; try { transformation . transformY ( <float> ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( transformation . slope ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( <float> ) ; } static void assertVerticalLinearTransformation ( LinearTransformation transformation , double x ) { assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . isVertical ( ) ) . isTrue ( ) ; try { transformation . transformX ( <float> ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( transformation . transformY ( - <float> ) ) . isWithin ( ALLOWED_ERROR ) . of ( x ) ; assertThat ( transformation . transformY ( <float> ) ) . isWithin ( ALLOWED_ERROR ) . of ( x ) ; try { transformation . slope ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } static void assertLinearTransformationNaN ( LinearTransformation transformation ) { assertThat ( transformation . isHorizontal ( ) ) . isFalse ( ) ; assertThat ( transformation . isVertical ( ) ) . isFalse ( ) ; assertThat ( transformation . slope ( ) ) . isNaN ( ) ; assertThat ( transformation . transformX ( <float> ) ) . isNaN ( ) ; assertThat ( transformation . transformY ( <float> ) ) . isNaN ( ) ; } static PairedStats createPairedStatsOf ( List < Double > xValues , List < Double > yValues ) { return createFilledPairedStatsAccumulator ( xValues , yValues ) . snapshot ( ) ; } static PairedStatsAccumulator createFilledPairedStatsAccumulator ( List < Double > xValues , List < Double > yValues ) { checkArgument ( xValues . size ( ) = = yValues . size ( ) ) ; PairedStatsAccumulator accumulator = new PairedStatsAccumulator ( ) ; for ( int index = <int> ; index < xValues . size ( ) ; index + + ) { accumulator . add ( xValues . get ( index ) , yValues . get ( index ) ) ; } return accumulator ; } private StatsTesting ( ) { } } 
