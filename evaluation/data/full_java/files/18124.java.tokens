package com . badlogic . gdx . graphics . glutils ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class MipMapGenerator { private MipMapGenerator ( ) { } private static boolean useHWMipMap = true ; static public void setUseHardwareMipMap ( boolean useHWMipMap ) { MipMapGenerator . useHWMipMap = useHWMipMap ; } public static void generateMipMap ( Pixmap pixmap , int textureWidth , int textureHeight ) { generateMipMap ( GL20 . GL_TEXTURE_2D , pixmap , textureWidth , textureHeight ) ; } public static void generateMipMap ( int target , Pixmap pixmap , int textureWidth , int textureHeight ) { if ( ! useHWMipMap ) { generateMipMapCPU ( target , pixmap , textureWidth , textureHeight ) ; return ; } if ( Gdx . app . getType ( ) = = ApplicationType . Android | | Gdx . app . getType ( ) = = ApplicationType . WebGL | | Gdx . app . getType ( ) = = ApplicationType . iOS ) { generateMipMapGLES20 ( target , pixmap ) ; } else { generateMipMapDesktop ( target , pixmap , textureWidth , textureHeight ) ; } } private static void generateMipMapGLES20 ( int target , Pixmap pixmap ) { Gdx . gl . glTexImage2D ( target , <int> , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; Gdx . gl20 . glGenerateMipmap ( target ) ; } private static void generateMipMapDesktop ( int target , Pixmap pixmap , int textureWidth , int textureHeight ) { if ( Gdx . graphics . supportsExtension ( <str> ) | | Gdx . graphics . supportsExtension ( <str> ) | | Gdx . gl30 ! = null ) { Gdx . gl . glTexImage2D ( target , <int> , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; Gdx . gl20 . glGenerateMipmap ( target ) ; } else { generateMipMapCPU ( target , pixmap , textureWidth , textureHeight ) ; } } private static void generateMipMapCPU ( int target , Pixmap pixmap , int textureWidth , int textureHeight ) { Gdx . gl . glTexImage2D ( target , <int> , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; if ( ( Gdx . gl20 = = null ) & & textureWidth ! = textureHeight ) throw new GdxRuntimeException ( <str> ) ; int width = pixmap . getWidth ( ) / <int> ; int height = pixmap . getHeight ( ) / <int> ; int level = <int> ; Blending blending = Pixmap . getBlending ( ) ; Pixmap . setBlending ( Blending . None ) ; while ( width > <int> & & height > <int> ) { Pixmap tmp = new Pixmap ( width , height , pixmap . getFormat ( ) ) ; tmp . drawPixmap ( pixmap , <int> , <int> , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , <int> , width , height ) ; if ( level > <int> ) pixmap . dispose ( ) ; pixmap = tmp ; Gdx . gl . glTexImage2D ( target , level , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; width = pixmap . getWidth ( ) / <int> ; height = pixmap . getHeight ( ) / <int> ; level + + ; } Pixmap . setBlending ( blending ) ; } } 
