package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . ReduceContext ; import org . elasticsearch . search . aggregations . InternalAggregation . Type ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Map ; public abstract class PipelineAggregator implements Streamable { public static interface Parser { public static final ParseField BUCKETS_PATH = new ParseField ( <str> ) ; public static final ParseField FORMAT = new ParseField ( <str> ) ; public static final ParseField GAP_POLICY = new ParseField ( <str> ) ; String type ( ) ; PipelineAggregatorFactory parse ( String pipelineAggregatorName , XContentParser parser , SearchContext context ) throws IOException ; } private String name ; private String [ ] bucketsPaths ; private Map < String , Object > metaData ; protected PipelineAggregator ( ) { } protected PipelineAggregator ( String name , String [ ] bucketsPaths , Map < String , Object > metaData ) { this . name = name ; this . bucketsPaths = bucketsPaths ; this . metaData = metaData ; } public String name ( ) { return name ; } public String [ ] bucketsPaths ( ) { return bucketsPaths ; } public Map < String , Object > metaData ( ) { return metaData ; } public abstract Type type ( ) ; public abstract InternalAggregation reduce ( InternalAggregation aggregation , ReduceContext reduceContext ) ; @Override public final void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeStringArray ( bucketsPaths ) ; out . writeMap ( metaData ) ; doWriteTo ( out ) ; } protected abstract void doWriteTo ( StreamOutput out ) throws IOException ; @Override public final void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; bucketsPaths = in . readStringArray ( ) ; metaData = in . readMap ( ) ; doReadFrom ( in ) ; } protected abstract void doReadFrom ( StreamInput in ) throws IOException ; } 
