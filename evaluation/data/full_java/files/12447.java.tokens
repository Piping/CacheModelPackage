package org . gradle . util ; import groovy . lang . Closure ; import junit . framework . AssertionFailedError ; import org . codehaus . groovy . runtime . InvokerInvocationException ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . DefaultExecutorFactory ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . hamcrest . Matcher ; import org . junit . After ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . * ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . CopyOnWriteArraySet ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class MultithreadedTestCase { private static final Logger LOGGER = LoggerFactory . getLogger ( MultithreadedTestCase . class ) ; private static final int MAX_WAIT_TIME = <int> ; private ExecutorImpl executor ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final Set < Thread > active = new HashSet < Thread > ( ) ; private final Set < Thread > synching = new HashSet < Thread > ( ) ; private final List < Throwable > failures = new ArrayList < Throwable > ( ) ; private final Map < Integer , ClockTickImpl > ticks = new HashMap < Integer , ClockTickImpl > ( ) ; private ClockTickImpl currentTick = getTick ( <int> ) ; private boolean stopped ; private final ThreadLocal < Matcher < ? extends Throwable > > expectedFailure = new ThreadLocal < Matcher < ? extends Throwable > > ( ) ; private final SyncPoint syncPoint = new SyncPoint ( ) ; protected ExecutorService getExecutor ( ) { if ( executor = = null ) { executor = new ExecutorImpl ( ) ; } return executor ; } protected ExecutorFactory getExecutorFactory ( ) { return new DefaultExecutorFactory ( ) { @Override protected ExecutorService createExecutor ( String displayName ) { return new ExecutorImpl ( ) ; } } ; } protected ThreadHandle start ( final Closure closure ) { Runnable task = new Runnable ( ) { public void run ( ) { closure . call ( ) ; } } ; return start ( task ) ; } protected ThreadHandle run ( final Closure closure ) { Runnable task = new Runnable ( ) { public void run ( ) { closure . call ( ) ; } } ; return start ( task ) . waitFor ( ) ; } protected ThreadHandle expectTimesOut ( int value , TimeUnit units , Closure closure ) { Date start = new Date ( ) ; ThreadHandle threadHandle = start ( closure ) ; threadHandle . waitFor ( ) ; Date end = new Date ( ) ; long actual = end . getTime ( ) - start . getTime ( ) ; long expected = units . toMillis ( value ) ; if ( actual < expected - <int> ) { throw new RuntimeException ( String . format ( <str> , expected , actual ) ) ; } if ( actual > expected + <int> ) { throw new RuntimeException ( String . format ( <str> , expected , actual ) ) ; } return threadHandle ; } protected ThreadHandle start ( final Runnable task ) { final Thread thread = new Thread ( ) { @Override public String toString ( ) { return <str> + getId ( ) ; } public void run ( ) { Throwable failure = null ; try { try { task . run ( ) ; } catch ( InvokerInvocationException e ) { failure = e . getCause ( ) ; } catch ( Throwable throwable ) { failure = throwable ; } } finally { testThreadFinished ( this , failure ) ; } } } ; testThreadStarted ( thread ) ; thread . start ( ) ; return new ThreadHandleImpl ( thread ) ; } private void testThreadStarted ( Thread thread ) { lock . lock ( ) ; try { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } LOGGER . debug ( <str> , thread ) ; active . add ( thread ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private void testThreadFinished ( Thread thread , Throwable failure ) { lock . lock ( ) ; try { active . remove ( thread ) ; Matcher < ? extends Throwable > matcher = expectedFailure . get ( ) ; if ( failure ! = null ) { if ( matcher ! = null & & matcher . matches ( failure ) ) { LOGGER . debug ( <str> , thread ) ; } else { LOGGER . error ( String . format ( <str> , thread ) , failure ) ; failures . add ( failure ) ; } } else { if ( matcher ! = null ) { String message = String . format ( <str> , thread ) ; LOGGER . error ( message ) ; failures . add ( new AssertionFailedError ( message ) ) ; } else { LOGGER . debug ( <str> , thread ) ; } } condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public void waitForAll ( ) { Date expiry = new Date ( System . currentTimeMillis ( ) + <int> * MAX_WAIT_TIME ) ; lock . lock ( ) ; try { LOGGER . debug ( <str> ) ; if ( active . contains ( Thread . currentThread ( ) ) ) { throw new RuntimeException ( <str> ) ; } try { while ( ! active . isEmpty ( ) ) { boolean signaled = condition . awaitUntil ( expiry ) ; if ( ! signaled ) { failures . add ( new RuntimeException ( <str> ) ) ; break ; } } } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } LOGGER . debug ( <str> ) ; if ( ! failures . isEmpty ( ) ) { Throwable failure = failures . get ( <int> ) ; failures . clear ( ) ; if ( failure instanceof RuntimeException ) { throw ( RuntimeException ) failure ; } if ( failure instanceof Error ) { throw ( Error ) failure ; } throw new RuntimeException ( <str> , failure ) ; } } finally { lock . unlock ( ) ; } } @After public void waitForStop ( ) { lock . lock ( ) ; try { stopped = true ; } finally { lock . unlock ( ) ; } waitForAll ( ) ; } public ClockTick clockTick ( int tick ) { lock . lock ( ) ; try { return getTick ( tick ) ; } finally { lock . unlock ( ) ; } } private ClockTickImpl getTick ( int tick ) { ClockTickImpl clockTick = ticks . get ( tick ) ; if ( clockTick = = null ) { clockTick = new ClockTickImpl ( tick ) ; ticks . put ( tick , clockTick ) ; } return clockTick ; } public void syncAt ( int tick ) { LOGGER . debug ( <str> , Thread . currentThread ( ) , tick ) ; lock . lock ( ) ; try { ClockTickImpl clockTick = getTick ( tick ) ; if ( ! clockTick . isImmediatelyAfter ( currentTick ) ) { throw new RuntimeException ( String . format ( <str> , clockTick , currentTick ) ) ; } if ( ! active . contains ( Thread . currentThread ( ) ) ) { throw new RuntimeException ( <str> ) ; } Date expiry = new Date ( System . currentTimeMillis ( ) + MAX_WAIT_TIME ) ; synching . add ( Thread . currentThread ( ) ) ; condition . signalAll ( ) ; while ( failures . isEmpty ( ) & & currentTick ! = clockTick & & ! clockTick . allThreadsSynced ( synching , active ) ) { try { boolean signalled = condition . awaitUntil ( expiry ) ; if ( ! signalled ) { throw new RuntimeException ( String . format ( <str> , clockTick , currentTick ) ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } if ( ! failures . isEmpty ( ) ) { throw new RuntimeException ( String . format ( <str> , clockTick ) ) ; } if ( clockTick . isImmediatelyAfter ( currentTick ) ) { currentTick = clockTick ; synching . clear ( ) ; } } finally { lock . unlock ( ) ; } LOGGER . debug ( <str> , Thread . currentThread ( ) ) ; } public void expectLater ( final int tick ) { final Thread targetThread = Thread . currentThread ( ) ; LOGGER . debug ( <str> , targetThread , tick ) ; start ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } lock . lock ( ) ; try { ClockTickImpl clockTick = getTick ( tick ) ; if ( ! clockTick . isImmediatelyAfter ( currentTick ) ) { throw new RuntimeException ( String . format ( <str> , clockTick , currentTick ) ) ; } if ( ! active . contains ( targetThread ) ) { throw new RuntimeException ( <str> ) ; } synching . add ( targetThread ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } ) ; } public void expectBlocksUntil ( int tick , Closure closure ) { expectLater ( tick ) ; closure . call ( ) ; shouldBeAt ( tick ) ; } public void shouldBeAt ( int tick ) { lock . lock ( ) ; try { if ( currentTick ! = getTick ( tick ) ) { throw new RuntimeException ( String . format ( <str> , tick , currentTick ) ) ; } } finally { lock . unlock ( ) ; } } public void willFailWith ( Matcher < ? extends Throwable > matcher ) { expectedFailure . set ( matcher ) ; } public void expectBlocks ( Closure action ) { syncPoint . expectBlocks ( action ) ; } public void expectUnblocks ( Closure action ) { syncPoint . expectUnblocks ( action ) ; } private class ExecutorImpl extends AbstractExecutorService { private final Set < ThreadHandle > threads = new CopyOnWriteArraySet < ThreadHandle > ( ) ; public void execute ( Runnable command ) { threads . add ( start ( command ) ) ; } public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { Date expiry = new Date ( System . currentTimeMillis ( ) + unit . toMillis ( timeout ) ) ; for ( ThreadHandle thread : threads ) { if ( ! thread . waitUntil ( expiry ) ) { return false ; } } return true ; } public void shutdown ( ) { } public List < Runnable > shutdownNow ( ) { return new ArrayList < Runnable > ( ) ; } public boolean isShutdown ( ) { throw new UnsupportedOperationException ( ) ; } public boolean isTerminated ( ) { throw new UnsupportedOperationException ( ) ; } } public interface ThreadHandle { ThreadHandle waitFor ( ) ; boolean waitUntil ( Date expiry ) ; boolean isCurrentThread ( ) ; void waitUntilBlocked ( ) ; } public interface ClockTick { ClockTick hasParticipants ( int count ) ; } private static class ClockTickImpl implements ClockTick { private final int number ; private int participants ; private ClockTickImpl ( int number ) { this . number = number ; } @Override public String toString ( ) { return String . format ( <str> , number ) ; } public ClockTick hasParticipants ( int count ) { participants = count ; return this ; } public boolean allThreadsSynced ( Set < Thread > synching , Set < Thread > active ) { if ( participants > <int> ) { return synching . size ( ) = = participants ; } return synching . equals ( active ) & & synching . size ( ) > <int> ; } public boolean isImmediatelyAfter ( ClockTickImpl other ) { return number = = other . number + <int> ; } } private enum State { Idle , Blocking , Blocked , Unblocking , Unblocked , Failed } private class SyncPoint { private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private State state = State . Idle ; private ThreadHandle blockingThread ; public void expectBlocks ( Closure action ) { try { setState ( State . Idle , State . Blocking ) ; setBlockingThread ( start ( action ) ) ; setState ( State . Blocking , State . Blocked ) ; waitForState ( State . Unblocked , State . Failed ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public void expectUnblocks ( Closure action ) { try { waitForState ( State . Blocked ) ; ThreadHandle thread = getBlockingThread ( ) ; if ( thread . isCurrentThread ( ) ) { throw new IllegalStateException ( <str> ) ; } setState ( State . Blocked , State . Unblocking ) ; try { thread . waitUntilBlocked ( ) ; action . call ( ) ; boolean completed = thread . waitUntil ( new Date ( System . currentTimeMillis ( ) + <int> ) ) ; if ( ! completed ) { throw new IllegalStateException ( <str> ) ; } setState ( State . Unblocking , State . Unblocked ) ; } catch ( Throwable e ) { setState ( State . Unblocking , State . Failed ) ; throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { setBlockingThread ( null ) ; } } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } private ThreadHandle getBlockingThread ( ) { lock . lock ( ) ; try { return blockingThread ; } finally { lock . unlock ( ) ; } } private void setBlockingThread ( ThreadHandle thread ) { lock . lock ( ) ; try { blockingThread = thread ; } finally { lock . unlock ( ) ; } } private State waitForState ( State . . . states ) throws InterruptedException { Date expiry = new Date ( System . currentTimeMillis ( ) + <int> ) ; Collection < State > expectedStates = Arrays . asList ( states ) ; lock . lock ( ) ; try { while ( ! expectedStates . contains ( state ) ) { if ( ! condition . awaitUntil ( expiry ) ) { throw new IllegalStateException ( String . format ( <str> , expectedStates ) ) ; } } return state ; } finally { lock . unlock ( ) ; } } private void setState ( State expected , State newState ) { lock . lock ( ) ; try { if ( state ! = expected ) { throw new IllegalStateException ( String . format ( <str> , expected , state ) ) ; } state = newState ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } private class ThreadHandleImpl implements ThreadHandle { private final Thread thread ; private final Set < Thread . State > blockedStates = EnumSet . of ( Thread . State . BLOCKED , Thread . State . TIMED_WAITING , Thread . State . WAITING ) ; public ThreadHandleImpl ( Thread thread ) { this . thread = thread ; } public ThreadHandle waitFor ( ) { Date expiry = new Date ( System . currentTimeMillis ( ) + <int> * MAX_WAIT_TIME ) ; if ( ! waitUntil ( expiry ) ) { throw new RuntimeException ( <str> ) ; } return this ; } public boolean waitUntil ( Date expiry ) { if ( isCurrentThread ( ) ) { throw new RuntimeException ( <str> ) ; } lock . lock ( ) ; try { while ( active . contains ( thread ) ) { try { boolean signalled = condition . awaitUntil ( expiry ) ; if ( ! signalled ) { return false ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } finally { lock . unlock ( ) ; } return true ; } public boolean isCurrentThread ( ) { return Thread . currentThread ( ) = = thread ; } public boolean isBlocked ( ) { return blockedStates . contains ( thread . getState ( ) ) ; } public void waitUntilBlocked ( ) { long expiry = System . currentTimeMillis ( ) + <int> ; while ( ! isBlocked ( ) ) { if ( System . currentTimeMillis ( ) > expiry ) { throw new IllegalStateException ( <str> ) ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } } } 
