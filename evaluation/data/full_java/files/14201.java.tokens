package org . gradle . messaging . remote . internal . inet ; import org . gradle . api . Action ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . internal . id . IdGenerator ; import org . gradle . messaging . remote . Address ; import org . gradle . messaging . remote . ConnectionAcceptor ; import org . gradle . messaging . remote . internal . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . ServerSocketChannel ; import java . nio . channels . SocketChannel ; import java . util . List ; public class TcpIncomingConnector implements IncomingConnector { private static final Logger LOGGER = LoggerFactory . getLogger ( TcpIncomingConnector . class ) ; private final ExecutorFactory executorFactory ; private final InetAddressFactory addressFactory ; private final IdGenerator < ? > idGenerator ; public TcpIncomingConnector ( ExecutorFactory executorFactory , InetAddressFactory addressFactory , IdGenerator < ? > idGenerator ) { this . executorFactory = executorFactory ; this . addressFactory = addressFactory ; this . idGenerator = idGenerator ; } public ConnectionAcceptor accept ( Action < ConnectCompletion > action , boolean allowRemote ) { final ServerSocketChannel serverSocket ; int localPort ; try { serverSocket = ServerSocketChannel . open ( ) ; serverSocket . socket ( ) . bind ( new InetSocketAddress ( addressFactory . findLocalBindingAddress ( ) , <int> ) ) ; localPort = serverSocket . socket ( ) . getLocalPort ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } Object id = idGenerator . generateId ( ) ; List < InetAddress > addresses = allowRemote ? addressFactory . findRemoteAddresses ( ) : addressFactory . findLocalAddresses ( ) ; final Address address = new MultiChoiceAddress ( id , localPort , addresses ) ; LOGGER . debug ( <str> , address ) ; final StoppableExecutor executor = executorFactory . create ( String . format ( <str> , allowRemote ? <str> : <str> , localPort ) ) ; executor . execute ( new Receiver ( serverSocket , action , allowRemote ) ) ; return new ConnectionAcceptor ( ) { public Address getAddress ( ) { return address ; } public void requestStop ( ) { CompositeStoppable . stoppable ( serverSocket ) . stop ( ) ; } public void stop ( ) { requestStop ( ) ; executor . stop ( ) ; } } ; } private class Receiver implements Runnable { private final ServerSocketChannel serverSocket ; private final Action < ConnectCompletion > action ; private final boolean allowRemote ; public Receiver ( ServerSocketChannel serverSocket , Action < ConnectCompletion > action , boolean allowRemote ) { this . serverSocket = serverSocket ; this . action = action ; this . allowRemote = allowRemote ; } public void run ( ) { try { try { while ( true ) { final SocketChannel socket = serverSocket . accept ( ) ; InetSocketAddress remoteSocketAddress = ( InetSocketAddress ) socket . socket ( ) . getRemoteSocketAddress ( ) ; InetAddress remoteInetAddress = remoteSocketAddress . getAddress ( ) ; if ( ! allowRemote & & ! addressFactory . isLocal ( remoteInetAddress ) ) { LOGGER . error ( <str> , remoteInetAddress ) ; socket . close ( ) ; continue ; } LOGGER . debug ( <str> , socket . socket ( ) . getRemoteSocketAddress ( ) , socket . socket ( ) . getLocalSocketAddress ( ) ) ; try { action . execute ( new SocketConnectCompletion ( socket ) ) ; } catch ( Throwable t ) { socket . close ( ) ; throw t ; } } } catch ( ClosedChannelException e ) { } catch ( Throwable e ) { LOGGER . error ( <str> , e ) ; } } finally { CompositeStoppable . stoppable ( serverSocket ) . stop ( ) ; } } } } 
