package org . eclipse . debug . internal . ui . viewers ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . elements . adapters . AsynchronousDebugLabelAdapter ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxyFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStatusMonitor ; import org . eclipse . debug . internal . ui . viewers . provisional . AsynchronousContentAdapter ; import org . eclipse . debug . internal . ui . viewers . provisional . IAsynchronousContentAdapter ; import org . eclipse . debug . internal . ui . viewers . provisional . IAsynchronousLabelAdapter ; import org . eclipse . debug . internal . ui . viewers . provisional . IChildrenRequestMonitor ; import org . eclipse . debug . internal . ui . viewers . provisional . ILabelRequestMonitor ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . jface . viewers . ViewerSorter ; public abstract class AsynchronousModel { private ModelNode fRoot ; private Map < Object , ModelNode [ ] > fElementToNodes = new HashMap < Object , ModelNode [ ] > ( ) ; private Map < Object , IModelProxy > fModelProxies = new HashMap < Object , IModelProxy > ( ) ; private AsynchronousViewer fViewer ; private boolean fDisposed = false ; class EmptyContentAdapter extends AsynchronousContentAdapter { @Override protected Object [ ] getChildren ( Object parent , IPresentationContext context ) throws CoreException { return EMPTY ; } @Override protected boolean hasChildren ( Object element , IPresentationContext context ) throws CoreException { return false ; } @Override protected boolean supportsPartId ( String id ) { return true ; } } protected IAsynchronousContentAdapter fEmptyContentAdapter = new EmptyContentAdapter ( ) ; private List < IStatusMonitor > fPendingUpdates = new ArrayList < IStatusMonitor > ( ) ; private List < IStatusMonitor > fViewerUpdates = new ArrayList < IStatusMonitor > ( ) ; public AsynchronousModel ( AsynchronousViewer viewer ) { fViewer = viewer ; if ( DebugUIPlugin . DEBUG_MODEL ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( <str> ) ; buffer . append ( fViewer ) ; buffer . append ( <str> ) ; buffer . append ( this ) ; buffer . append ( <str> ) ; DebugUIPlugin . trace ( buffer . toString ( ) ) ; } } public void init ( Object root ) { if ( root ! = null ) { fRoot = new ModelNode ( null , root ) ; mapElement ( root , fRoot ) ; } } protected AsynchronousViewer getViewer ( ) { return fViewer ; } public synchronized void dispose ( ) { if ( DebugUIPlugin . DEBUG_MODEL ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( <str> ) ; buffer . append ( fViewer ) ; buffer . append ( <str> ) ; buffer . append ( this ) ; buffer . append ( <str> ) ; DebugUIPlugin . trace ( buffer . toString ( ) ) ; } fDisposed = true ; cancelPendingUpdates ( ) ; disposeAllModelProxies ( ) ; ModelNode rootNode = getRootNode ( ) ; if ( rootNode ! = null ) { rootNode . dispose ( ) ; } fElementToNodes . clear ( ) ; } public synchronized boolean isDisposed ( ) { return fDisposed ; } protected synchronized void cancelPendingUpdates ( ) { Iterator < IStatusMonitor > updates = fPendingUpdates . iterator ( ) ; while ( updates . hasNext ( ) ) { IStatusMonitor update = updates . next ( ) ; updates . remove ( ) ; update . setCanceled ( true ) ; } fPendingUpdates . clear ( ) ; } public synchronized void installModelProxy ( Object element ) { if ( ! fModelProxies . containsKey ( element ) ) { IModelProxyFactory modelProxyFactory = getModelProxyFactoryAdapter ( element ) ; if ( modelProxyFactory ! = null ) { final IModelProxy proxy = modelProxyFactory . createModelProxy ( element , getPresentationContext ( ) ) ; if ( proxy ! = null ) { fModelProxies . put ( element , proxy ) ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { proxy . init ( getPresentationContext ( ) ) ; getViewer ( ) . modelProxyAdded ( proxy ) ; proxy . installed ( getViewer ( ) ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } } } protected synchronized void disposeModelProxy ( Object element ) { IModelProxy proxy = fModelProxies . remove ( element ) ; if ( proxy ! = null ) { getViewer ( ) . modelProxyRemoved ( proxy ) ; proxy . dispose ( ) ; } } private void disposeAllModelProxies ( ) { synchronized ( fModelProxies ) { for ( IModelProxy proxy : fModelProxies . values ( ) ) { getViewer ( ) . modelProxyRemoved ( proxy ) ; proxy . dispose ( ) ; } fModelProxies . clear ( ) ; } } protected IPresentationContext getPresentationContext ( ) { return fViewer . getPresentationContext ( ) ; } protected IModelProxyFactory getModelProxyFactoryAdapter ( Object element ) { IModelProxyFactory adapter = null ; if ( element instanceof IModelProxyFactory ) { adapter = ( IModelProxyFactory ) element ; } else if ( element instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) element ; adapter = adaptable . getAdapter ( IModelProxyFactory . class ) ; } return adapter ; } protected synchronized void mapElement ( Object element , ModelNode node ) { ModelNode [ ] nodes = getNodes ( element ) ; node . remap ( element ) ; if ( nodes = = null ) { fElementToNodes . put ( element , new ModelNode [ ] { node } ) ; } else { for ( int i = <int> ; i < nodes . length ; i + + ) { if ( nodes [ i ] = = node ) { return ; } } ModelNode [ ] old = nodes ; ModelNode [ ] newNodes = new ModelNode [ old . length + <int> ] ; System . arraycopy ( old , <int> , newNodes , <int> , old . length ) ; newNodes [ old . length ] = node ; fElementToNodes . put ( element , newNodes ) ; } installModelProxy ( element ) ; } protected synchronized void unmapNode ( ModelNode node ) { Object element = node . getElement ( ) ; ModelNode [ ] nodes = fElementToNodes . get ( element ) ; if ( nodes = = null ) { return ; } if ( nodes . length = = <int> ) { fElementToNodes . remove ( element ) ; disposeModelProxy ( element ) ; } else { for ( int i = <int> ; i < nodes . length ; i + + ) { ModelNode node2 = nodes [ i ] ; if ( node2 = = node ) { ModelNode [ ] newNodes = new ModelNode [ nodes . length - <int> ] ; System . arraycopy ( nodes , <int> , newNodes , <int> , i ) ; if ( i < newNodes . length ) { System . arraycopy ( nodes , i + <int> , newNodes , i , newNodes . length - i ) ; } fElementToNodes . put ( element , newNodes ) ; } } } } public synchronized ModelNode [ ] getNodes ( Object element ) { return fElementToNodes . get ( element ) ; } public ModelNode getRootNode ( ) { return fRoot ; } protected void requestScheduled ( IStatusMonitor update ) { AsynchronousRequestMonitor absUpdate = ( AsynchronousRequestMonitor ) update ; synchronized ( fPendingUpdates ) { ListIterator < IStatusMonitor > updates = fPendingUpdates . listIterator ( ) ; while ( updates . hasNext ( ) ) { AsynchronousRequestMonitor pendingUpdate = ( AsynchronousRequestMonitor ) updates . next ( ) ; if ( absUpdate . contains ( pendingUpdate ) ) { updates . remove ( ) ; pendingUpdate . setCanceled ( true ) ; } } fPendingUpdates . add ( update ) ; } } protected void requestComplete ( IStatusMonitor update ) { synchronized ( fPendingUpdates ) { fPendingUpdates . remove ( update ) ; } } protected void viewerUpdateScheduled ( IStatusMonitor update ) { synchronized ( fPendingUpdates ) { fViewerUpdates . add ( update ) ; } } protected Object [ ] filter ( Object parent , Object [ ] elements ) { ViewerFilter [ ] filters = getViewer ( ) . getFilters ( ) ; if ( filters ! = null ) { ArrayList < Object > filtered = new ArrayList < Object > ( elements . length ) ; for ( int i = <int> ; i < elements . length ; i + + ) { boolean add = true ; for ( int j = <int> ; j < filters . length ; j + + ) { add = filters [ j ] . select ( getViewer ( ) , parent , elements [ i ] ) ; if ( ! add ) { break ; } } if ( add ) { filtered . add ( elements [ i ] ) ; } } return filtered . toArray ( ) ; } return elements ; } protected void updateLabel ( ModelNode node ) { Object element = node . getElement ( ) ; IAsynchronousLabelAdapter adapter = getLabelAdapter ( element ) ; if ( adapter ! = null ) { ILabelRequestMonitor labelUpdate = new LabelRequestMonitor ( node , this ) ; requestScheduled ( labelUpdate ) ; adapter . retrieveLabel ( element , getPresentationContext ( ) , labelUpdate ) ; } } protected IAsynchronousLabelAdapter getLabelAdapter ( Object element ) { IAsynchronousLabelAdapter adapter = null ; if ( element instanceof IAsynchronousLabelAdapter ) { adapter = ( IAsynchronousLabelAdapter ) element ; } else if ( element instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) element ; adapter = adaptable . getAdapter ( IAsynchronousLabelAdapter . class ) ; } if ( adapter = = null ) { return new AsynchronousDebugLabelAdapter ( ) ; } return adapter ; } protected IAsynchronousContentAdapter getContentAdapter ( Object element ) { IAsynchronousContentAdapter adapter = null ; if ( element instanceof IAsynchronousContentAdapter ) { adapter = ( IAsynchronousContentAdapter ) element ; } else if ( element instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) element ; adapter = adaptable . getAdapter ( IAsynchronousContentAdapter . class ) ; } return adapter ; } public void updateChildren ( ModelNode parent ) { Object element = parent . getElement ( ) ; IAsynchronousContentAdapter adapter = getContentAdapter ( element ) ; if ( adapter = = null ) { adapter = fEmptyContentAdapter ; } if ( adapter ! = null ) { IChildrenRequestMonitor update = new ChildrenRequestMonitor ( parent , this ) ; requestScheduled ( update ) ; adapter . retrieveChildren ( element , getPresentationContext ( ) , update ) ; } } protected void preservingSelection ( Runnable update ) { getViewer ( ) . preservingSelection ( update ) ; } protected void viewerUpdateComplete ( IStatusMonitor monitor ) { synchronized ( fPendingUpdates ) { fViewerUpdates . remove ( monitor ) ; } getViewer ( ) . updateComplete ( monitor ) ; } protected void requestCanceled ( AsynchronousRequestMonitor monitor ) { synchronized ( fPendingUpdates ) { fPendingUpdates . remove ( monitor ) ; } } protected boolean hasPendingUpdates ( ) { synchronized ( fViewerUpdates ) { return ! fPendingUpdates . isEmpty ( ) | | ! fViewerUpdates . isEmpty ( ) ; } } protected abstract void add ( ModelNode parent , Object element ) ; protected void setChildren ( final ModelNode parentNode , List < Object > kids ) { final Object [ ] children = filter ( parentNode . getElement ( ) , kids . toArray ( ) ) ; final AsynchronousViewer viewer = getViewer ( ) ; ViewerSorter sorter = viewer . getSorter ( ) ; if ( sorter ! = null ) { sorter . sort ( viewer , children ) ; } ModelNode [ ] prevKids = null ; ModelNode [ ] newChildren = null ; ModelNode [ ] unmap = null ; synchronized ( this ) { if ( isDisposed ( ) ) { return ; } prevKids = parentNode . getChildrenNodes ( ) ; if ( prevKids = = null ) { newChildren = new ModelNode [ children . length ] ; for ( int i = <int> ; i < children . length ; i + + ) { ModelNode node = new ModelNode ( parentNode , children [ i ] ) ; mapElement ( children [ i ] , node ) ; newChildren [ i ] = node ; } parentNode . setChildren ( newChildren ) ; } else { newChildren = new ModelNode [ children . length ] ; unmap = new ModelNode [ prevKids . length ] ; for ( int i = <int> ; i < prevKids . length ; i + + ) { unmap [ i ] = prevKids [ i ] ; } for ( int i = <int> ; i < children . length ; i + + ) { Object child = children [ i ] ; boolean found = false ; for ( int j = <int> ; j < prevKids . length ; j + + ) { ModelNode prevKid = prevKids [ j ] ; if ( prevKid ! = null & & child . equals ( prevKid . getElement ( ) ) ) { newChildren [ i ] = prevKid ; prevKids [ j ] = null ; found = true ; break ; } } if ( ! found ) { newChildren [ i ] = new ModelNode ( parentNode , child ) ; mapElement ( child , newChildren [ i ] ) ; } } for ( int i = <int> ; i < prevKids . length ; i + + ) { ModelNode kid = prevKids [ i ] ; if ( kid ! = null ) { kid . dispose ( ) ; unmapNode ( kid ) ; } } parentNode . setChildren ( newChildren ) ; } if ( DebugUIPlugin . DEBUG_MODEL ) { DebugUIPlugin . trace ( <str> + parentNode ) ; DebugUIPlugin . trace ( toString ( ) ) ; } } final ModelNode [ ] finalUnmap = unmap ; preservingSelection ( new Runnable ( ) { @Override public void run ( ) { if ( finalUnmap ! = null ) { for ( int i = <int> ; i < finalUnmap . length ; i + + ) { viewer . unmapNode ( finalUnmap [ i ] ) ; } } viewer . nodeChildrenChanged ( parentNode ) ; } } ) ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( fRoot ! = null ) { buf . append ( <str> ) ; append ( buf , fRoot , <int> ) ; } else { buf . append ( <str> ) ; } return buf . toString ( ) ; } private void append ( StringBuffer buf , ModelNode node , int level ) { for ( int i = <int> ; i < level ; i + + ) { buf . append ( <str> ) ; } buf . append ( node ) ; buf . append ( <str> ) ; ModelNode [ ] childrenNodes = node . getChildrenNodes ( ) ; if ( childrenNodes ! = null ) { for ( int i = <int> ; i < childrenNodes . length ; i + + ) { append ( buf , childrenNodes [ i ] , level + <int> ) ; } } } } 
