package io . netty . handler . timeout ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public class ReadTimeoutHandler extends ChannelInboundHandlerAdapter { private static final long MIN_TIMEOUT_NANOS = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; private final long timeoutNanos ; private long lastReadTime ; private volatile ScheduledFuture < ? > timeout ; private volatile int state ; private volatile boolean reading ; private boolean closed ; public ReadTimeoutHandler ( int timeoutSeconds ) { this ( timeoutSeconds , TimeUnit . SECONDS ) ; } public ReadTimeoutHandler ( long timeout , TimeUnit unit ) { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( timeout < = <int> ) { timeoutNanos = <int> ; } else { timeoutNanos = Math . max ( unit . toNanos ( timeout ) , MIN_TIMEOUT_NANOS ) ; } } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { if ( ctx . channel ( ) . isActive ( ) & & ctx . channel ( ) . isRegistered ( ) ) { initialize ( ctx ) ; } else { } } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { destroy ( ) ; } @Override public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { if ( ctx . channel ( ) . isActive ( ) ) { initialize ( ctx ) ; } super . channelRegistered ( ctx ) ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { initialize ( ctx ) ; super . channelActive ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { destroy ( ) ; super . channelInactive ( ctx ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { reading = true ; ctx . fireChannelRead ( msg ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { lastReadTime = System . nanoTime ( ) ; reading = false ; ctx . fireChannelReadComplete ( ) ; } private void initialize ( ChannelHandlerContext ctx ) { switch ( state ) { case <int> : case <int> : return ; } state = <int> ; lastReadTime = System . nanoTime ( ) ; if ( timeoutNanos > <int> ) { timeout = ctx . executor ( ) . schedule ( new ReadTimeoutTask ( ctx ) , timeoutNanos , TimeUnit . NANOSECONDS ) ; } } private void destroy ( ) { state = <int> ; if ( timeout ! = null ) { timeout . cancel ( false ) ; timeout = null ; } } protected void readTimedOut ( ChannelHandlerContext ctx ) throws Exception { if ( ! closed ) { ctx . fireExceptionCaught ( ReadTimeoutException . INSTANCE ) ; ctx . close ( ) ; closed = true ; } } private final class ReadTimeoutTask implements Runnable { private final ChannelHandlerContext ctx ; ReadTimeoutTask ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @Override public void run ( ) { if ( ! ctx . channel ( ) . isOpen ( ) ) { return ; } long nextDelay = timeoutNanos ; if ( ! reading ) { nextDelay - = System . nanoTime ( ) - lastReadTime ; } if ( nextDelay < = <int> ) { timeout = ctx . executor ( ) . schedule ( this , timeoutNanos , TimeUnit . NANOSECONDS ) ; try { readTimedOut ( ctx ) ; } catch ( Throwable t ) { ctx . fireExceptionCaught ( t ) ; } } else { timeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . NANOSECONDS ) ; } } } } 
