package io . netty . channel . pool ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . ReadOnlyIterator ; import java . io . Closeable ; import java . util . Iterator ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentMap ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public abstract class AbstractChannelPoolMap < K , P extends ChannelPool > implements ChannelPoolMap < K , P > , Iterable < Entry < K , P > > , Closeable { private final ConcurrentMap < K , P > map = PlatformDependent . newConcurrentHashMap ( ) ; @Override public final P get ( K key ) { P pool = map . get ( checkNotNull ( key , <str> ) ) ; if ( pool = = null ) { pool = newPool ( key ) ; P old = map . putIfAbsent ( key , pool ) ; if ( old ! = null ) { pool . close ( ) ; pool = old ; } } return pool ; } public final boolean remove ( K key ) { P pool = map . remove ( checkNotNull ( key , <str> ) ) ; if ( pool ! = null ) { pool . close ( ) ; return true ; } return false ; } @Override public final Iterator < Entry < K , P > > iterator ( ) { return new ReadOnlyIterator < Entry < K , P > > ( map . entrySet ( ) . iterator ( ) ) ; } public final int size ( ) { return map . size ( ) ; } public final boolean isEmpty ( ) { return map . isEmpty ( ) ; } @Override public final boolean contains ( K key ) { return map . containsKey ( checkNotNull ( key , <str> ) ) ; } protected abstract P newPool ( K key ) ; @Override public final void close ( ) { for ( K key : map . keySet ( ) ) { remove ( key ) ; } } } 
