package io . netty . buffer ; import org . easymock . EasyMock ; import org . junit . After ; import org . junit . Test ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . channels . ScatteringByteChannel ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Queue ; import static io . netty . buffer . Unpooled . * ; import static io . netty . util . internal . EmptyArrays . * ; import static org . junit . Assert . * ; public class UnpooledTest { private static final ByteBuf [ ] EMPTY_BYTE_BUFS = new ByteBuf [ <int> ] ; private static final byte [ ] [ ] EMPTY_BYTES_2D = new byte [ <int> ] [ ] ; private static final Queue < ByteBuf > freeLaterQueue = new ArrayDeque < ByteBuf > ( ) ; protected ByteBuf freeLater ( ByteBuf buf ) { freeLaterQueue . add ( buf ) ; return buf ; } @After public void tearDown ( ) { for ( ; ; ) { ByteBuf buf = freeLaterQueue . poll ( ) ; if ( buf = = null ) { break ; } if ( buf . refCnt ( ) > <int> ) { buf . release ( buf . refCnt ( ) ) ; } } } @Test public void testCompositeWrappedBuffer ( ) { ByteBuf header = buffer ( <int> ) ; ByteBuf payload = buffer ( <int> ) ; header . writeBytes ( new byte [ <int> ] ) ; payload . writeBytes ( new byte [ <int> ] ) ; ByteBuf buffer = wrappedBuffer ( header , payload ) ; assertEquals ( <int> , header . readableBytes ( ) ) ; assertEquals ( <int> , payload . readableBytes ( ) ) ; assertEquals ( <int> + <int> , buffer . readableBytes ( ) ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; buffer . release ( ) ; } @Test public void testHashCode ( ) { Map < byte [ ] , Integer > map = new LinkedHashMap < byte [ ] , Integer > ( ) ; map . put ( EMPTY_BYTES , <int> ) ; map . put ( new byte [ ] { <int> } , <int> ) ; map . put ( new byte [ ] { <int> } , <int> ) ; map . put ( new byte [ ] { <int> , <int> } , <int> ) ; map . put ( new byte [ ] { <int> , <int> } , <int> ) ; map . put ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , <int> ) ; map . put ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , ( int ) <int> ) ; map . put ( new byte [ ] { - <int> , - <int> , - <int> , ( byte ) <hex> } , <int> ) ; for ( Entry < byte [ ] , Integer > e : map . entrySet ( ) ) { assertEquals ( e . getValue ( ) . intValue ( ) , ByteBufUtil . hashCode ( wrappedBuffer ( e . getKey ( ) ) ) ) ; } } @Test public void testEquals ( ) { ByteBuf a , b ; a = wrappedBuffer ( new byte [ ] { <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> } ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; b = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; } @Test public void testCompare ( ) { List < ByteBuf > expected = new ArrayList < ByteBuf > ( ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; expected . add ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ; for ( int i = <int> ; i < expected . size ( ) ; i + + ) { for ( int j = <int> ; j < expected . size ( ) ; j + + ) { if ( i = = j ) { assertEquals ( <int> , ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) ) ; } else if ( i < j ) { assertTrue ( ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) < <int> ) ; } else { assertTrue ( ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) > <int> ) ; } } } } @Test public void shouldReturnEmptyBufferWhenLengthIsZero ( ) { assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BYTES ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ <int> ] , <int> , <int> ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ <int> ] , <int> , <int> ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( ByteBuffer . allocateDirect ( <int> ) ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BUFFER ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BYTES_2D ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ ] [ ] { EMPTY_BYTES } ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BYTE_BUFFERS ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuffer [ ] { ByteBuffer . allocate ( <int> ) } ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( ByteBuffer . allocate ( <int> ) , ByteBuffer . allocate ( <int> ) ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BYTE_BUFS ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuf [ ] { buffer ( <int> ) } ) ) ; assertSame ( EMPTY_BUFFER , wrappedBuffer ( buffer ( <int> ) , buffer ( <int> ) ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BYTES ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ <int> ] , <int> , <int> ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ <int> ] , <int> , <int> ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( ByteBuffer . allocateDirect ( <int> ) ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BUFFER ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BYTES_2D ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ ] [ ] { EMPTY_BYTES } ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BYTE_BUFFERS ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuffer [ ] { ByteBuffer . allocate ( <int> ) } ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( ByteBuffer . allocate ( <int> ) , ByteBuffer . allocate ( <int> ) ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BYTE_BUFS ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuf [ ] { buffer ( <int> ) } ) ) ; assertSame ( EMPTY_BUFFER , copiedBuffer ( buffer ( <int> ) , buffer ( <int> ) ) ) ; } @Test public void testCompare2 ( ) { assertTrue ( ByteBufUtil . compare ( wrappedBuffer ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ) , wrappedBuffer ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ) ) > <int> ) ; assertTrue ( ByteBufUtil . compare ( wrappedBuffer ( new byte [ ] { ( byte ) <hex> } ) , wrappedBuffer ( new byte [ ] { ( byte ) <hex> } ) ) > <int> ) ; } @Test public void shouldAllowEmptyBufferToCreateCompositeBuffer ( ) { ByteBuf buf = wrappedBuffer ( EMPTY_BUFFER , wrappedBuffer ( new byte [ <int> ] ) . order ( LITTLE_ENDIAN ) , EMPTY_BUFFER ) ; try { assertEquals ( <int> , buf . capacity ( ) ) ; } finally { buf . release ( ) ; } } @Test public void testWrappedBuffer ( ) { assertEquals ( <int> , freeLater ( wrappedBuffer ( ByteBuffer . allocateDirect ( <int> ) ) ) . capacity ( ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , wrappedBuffer ( new byte [ ] [ ] { new byte [ ] { <int> , <int> , <int> } } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , freeLater ( wrappedBuffer ( new byte [ ] { <int> } , new byte [ ] { <int> } , new byte [ ] { <int> } ) ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , wrappedBuffer ( new ByteBuf [ ] { wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , freeLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } ) , wrappedBuffer ( new byte [ ] { <int> } ) , wrappedBuffer ( new byte [ ] { <int> } ) ) ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , wrappedBuffer ( new ByteBuffer [ ] { ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> } ) } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , freeLater ( wrappedBuffer ( ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ) ; } @Test public void testCopiedBuffer ( ) { assertEquals ( <int> , copiedBuffer ( ByteBuffer . allocateDirect ( <int> ) ) . capacity ( ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( new byte [ ] [ ] { new byte [ ] { <int> , <int> , <int> } } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( new byte [ ] { <int> } , new byte [ ] { <int> } , new byte [ ] { <int> } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( new ByteBuf [ ] { wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( wrappedBuffer ( new byte [ ] { <int> } ) , wrappedBuffer ( new byte [ ] { <int> } ) , wrappedBuffer ( new byte [ ] { <int> } ) ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( new ByteBuffer [ ] { ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> } ) } ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) , copiedBuffer ( ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ; } @Test public void testHexDump ( ) { assertEquals ( <str> , ByteBufUtil . hexDump ( EMPTY_BUFFER ) ) ; assertEquals ( <str> , ByteBufUtil . hexDump ( wrappedBuffer ( new byte [ ] { <hex> , <hex> , <hex> } ) ) ) ; assertEquals ( <str> , ByteBufUtil . hexDump ( wrappedBuffer ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ) ) ) ; } @Test public void testSwapMedium ( ) { assertEquals ( <hex> , ByteBufUtil . swapMedium ( <hex> ) ) ; assertEquals ( <hex> , ByteBufUtil . swapMedium ( <hex> ) ) ; } @Test public void testUnmodifiableBuffer ( ) throws Exception { ByteBuf buf = unmodifiableBuffer ( buffer ( <int> ) ) ; try { buf . discardReadBytes ( ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setByte ( <int> , ( byte ) <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setBytes ( <int> , EMPTY_BUFFER , <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setBytes ( <int> , EMPTY_BYTES , <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setBytes ( <int> , ByteBuffer . allocate ( <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setShort ( <int> , ( short ) <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setMedium ( <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setInt ( <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setLong ( <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setBytes ( <int> , EasyMock . createMock ( InputStream . class ) , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { buf . setBytes ( <int> , EasyMock . createMock ( ScatteringByteChannel . class ) , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } @Test public void testWrapSingleInt ( ) { ByteBuf buffer = copyInt ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readInt ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapInt ( ) { ByteBuf buffer = copyInt ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readInt ( ) ) ; assertEquals ( <int> , buffer . readInt ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyInt ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyInt ( EMPTY_INTS ) . capacity ( ) ) ; } @Test public void testWrapSingleShort ( ) { ByteBuf buffer = copyShort ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readShort ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapShortFromShortArray ( ) { ByteBuf buffer = copyShort ( new short [ ] { <int> , <int> } ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readShort ( ) ) ; assertEquals ( <int> , buffer . readShort ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyShort ( ( short [ ] ) null ) . capacity ( ) ) ; assertEquals ( <int> , copyShort ( EMPTY_SHORTS ) . capacity ( ) ) ; } @Test public void testWrapShortFromIntArray ( ) { ByteBuf buffer = copyShort ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readShort ( ) ) ; assertEquals ( <int> , buffer . readShort ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyShort ( ( int [ ] ) null ) . capacity ( ) ) ; assertEquals ( <int> , copyShort ( EMPTY_INTS ) . capacity ( ) ) ; } @Test public void testWrapSingleMedium ( ) { ByteBuf buffer = copyMedium ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readMedium ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapMedium ( ) { ByteBuf buffer = copyMedium ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readMedium ( ) ) ; assertEquals ( <int> , buffer . readMedium ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyMedium ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyMedium ( EMPTY_INTS ) . capacity ( ) ) ; } @Test public void testWrapSingleLong ( ) { ByteBuf buffer = copyLong ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readLong ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapLong ( ) { ByteBuf buffer = copyLong ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readLong ( ) ) ; assertEquals ( <int> , buffer . readLong ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyLong ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyLong ( EMPTY_LONGS ) . capacity ( ) ) ; } @Test public void testWrapSingleFloat ( ) { ByteBuf buffer = copyFloat ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readFloat ( ) , <float> ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapFloat ( ) { ByteBuf buffer = copyFloat ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readFloat ( ) , <float> ) ; assertEquals ( <int> , buffer . readFloat ( ) , <float> ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyFloat ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyFloat ( EMPTY_FLOATS ) . capacity ( ) ) ; } @Test public void testWrapSingleDouble ( ) { ByteBuf buffer = copyDouble ( <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readDouble ( ) , <float> ) ; assertFalse ( buffer . isReadable ( ) ) ; } @Test public void testWrapDouble ( ) { ByteBuf buffer = copyDouble ( <int> , <int> ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . readDouble ( ) , <float> ) ; assertEquals ( <int> , buffer . readDouble ( ) , <float> ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyDouble ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyDouble ( EMPTY_DOUBLES ) . capacity ( ) ) ; } @Test public void testWrapBoolean ( ) { ByteBuf buffer = copyBoolean ( true , false ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertTrue ( buffer . readBoolean ( ) ) ; assertFalse ( buffer . readBoolean ( ) ) ; assertFalse ( buffer . isReadable ( ) ) ; assertEquals ( <int> , copyBoolean ( null ) . capacity ( ) ) ; assertEquals ( <int> , copyBoolean ( EMPTY_BOOLEANS ) . capacity ( ) ) ; } @Test public void wrappedReadOnlyDirectBuffer ( ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { buffer . put ( ( byte ) i ) ; } buffer . flip ( ) ; ByteBuf wrapped = wrappedBuffer ( buffer . asReadOnlyBuffer ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( ( byte ) i , wrapped . readByte ( ) ) ; } wrapped . release ( ) ; } @Test ( expected = IllegalArgumentException . class ) public void skipBytesNegativeLength ( ) { ByteBuf buf = freeLater ( buffer ( <int> ) ) ; buf . skipBytes ( - <int> ) ; } } 
