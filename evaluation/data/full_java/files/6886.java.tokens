package org . elasticsearch . monitor . fs ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; public class FsInfo implements Iterable < FsInfo . Path > , Streamable , ToXContent { public static class Path implements Streamable , ToXContent { String path ; @Nullable String mount ; @Nullable String type ; long total = - <int> ; long free = - <int> ; long available = - <int> ; Boolean spins = null ; public Path ( ) { } public Path ( String path , @Nullable String mount , long total , long free , long available ) { this . path = path ; this . mount = mount ; this . total = total ; this . free = free ; this . available = available ; } static public Path readInfoFrom ( StreamInput in ) throws IOException { Path i = new Path ( ) ; i . readFrom ( in ) ; return i ; } @Override public void readFrom ( StreamInput in ) throws IOException { path = in . readOptionalString ( ) ; mount = in . readOptionalString ( ) ; type = in . readOptionalString ( ) ; total = in . readLong ( ) ; free = in . readLong ( ) ; available = in . readLong ( ) ; spins = in . readOptionalBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeOptionalString ( path ) ; out . writeOptionalString ( mount ) ; out . writeOptionalString ( type ) ; out . writeLong ( total ) ; out . writeLong ( free ) ; out . writeLong ( available ) ; out . writeOptionalBoolean ( spins ) ; } public String getPath ( ) { return path ; } public String getMount ( ) { return mount ; } public String getType ( ) { return type ; } public ByteSizeValue getTotal ( ) { return new ByteSizeValue ( total ) ; } public ByteSizeValue getFree ( ) { return new ByteSizeValue ( free ) ; } public ByteSizeValue getAvailable ( ) { return new ByteSizeValue ( available ) ; } public Boolean getSpins ( ) { return spins ; } private long addLong ( long current , long other ) { if ( other = = - <int> ) { return current ; } if ( current = = - <int> ) { return other ; } return current + other ; } private double addDouble ( double current , double other ) { if ( other = = - <int> ) { return current ; } if ( current = = - <int> ) { return other ; } return current + other ; } public void add ( Path path ) { total = addLong ( total , path . total ) ; free = addLong ( free , path . free ) ; available = addLong ( available , path . available ) ; if ( path . spins ! = null & & path . spins . booleanValue ( ) ) { spins = Boolean . TRUE ; } } static final class Fields { static final XContentBuilderString PATH = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MOUNT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TYPE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FREE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FREE_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString AVAILABLE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString AVAILABLE_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SPINS = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( path ! = null ) { builder . field ( Fields . PATH , path , XContentBuilder . FieldCaseConversion . NONE ) ; } if ( mount ! = null ) { builder . field ( Fields . MOUNT , mount , XContentBuilder . FieldCaseConversion . NONE ) ; } if ( type ! = null ) { builder . field ( Fields . TYPE , type , XContentBuilder . FieldCaseConversion . NONE ) ; } if ( total ! = - <int> ) { builder . byteSizeField ( Fields . TOTAL_IN_BYTES , Fields . TOTAL , total ) ; } if ( free ! = - <int> ) { builder . byteSizeField ( Fields . FREE_IN_BYTES , Fields . FREE , free ) ; } if ( available ! = - <int> ) { builder . byteSizeField ( Fields . AVAILABLE_IN_BYTES , Fields . AVAILABLE , available ) ; } if ( spins ! = null ) { builder . field ( Fields . SPINS , spins . toString ( ) ) ; } builder . endObject ( ) ; return builder ; } } long timestamp ; Path total ; Path [ ] paths ; FsInfo ( ) { } public FsInfo ( long timestamp , Path [ ] paths ) { this . timestamp = timestamp ; this . paths = paths ; this . total = null ; } public Path getTotal ( ) { return total ( ) ; } public Path total ( ) { if ( total ! = null ) { return total ; } Path res = new Path ( ) ; Set < String > seenDevices = new HashSet < > ( paths . length ) ; for ( Path subPath : paths ) { if ( subPath . path ! = null ) { if ( ! seenDevices . add ( subPath . path ) ) { continue ; } } res . add ( subPath ) ; } total = res ; return res ; } public long getTimestamp ( ) { return timestamp ; } @Override public Iterator < Path > iterator ( ) { return Arrays . stream ( paths ) . iterator ( ) ; } public static FsInfo readFsInfo ( StreamInput in ) throws IOException { FsInfo stats = new FsInfo ( ) ; stats . readFrom ( in ) ; return stats ; } @Override public void readFrom ( StreamInput in ) throws IOException { timestamp = in . readVLong ( ) ; paths = new Path [ in . readVInt ( ) ] ; for ( int i = <int> ; i < paths . length ; i + + ) { paths [ i ] = Path . readInfoFrom ( in ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( timestamp ) ; out . writeVInt ( paths . length ) ; for ( Path path : paths ) { path . writeTo ( out ) ; } } static final class Fields { static final XContentBuilderString FS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIMESTAMP = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DATA = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . FS ) ; builder . field ( Fields . TIMESTAMP , timestamp ) ; builder . field ( Fields . TOTAL ) ; total ( ) . toXContent ( builder , params ) ; builder . startArray ( Fields . DATA ) ; for ( Path path : paths ) { path . toXContent ( builder , params ) ; } builder . endArray ( ) ; builder . endObject ( ) ; return builder ; } } 
