package org . gradle . messaging . remote . internal ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . AsyncStoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . messaging . dispatch . AsyncReceive ; import org . gradle . messaging . dispatch . Dispatch ; import org . gradle . messaging . dispatch . Receive ; import java . util . ArrayList ; import java . util . Collection ; import java . util . LinkedList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class EagerReceiveBuffer < T > implements Receive < T > , AsyncStoppable { private enum State { Init , Started , Stopping , Stopped } private static final int DEFAULT_BUFFER_SIZE = <int> ; private final Lock lock = new ReentrantLock ( ) ; private final Condition notFullOrStop = lock . newCondition ( ) ; private final Condition notEmptyOrNoReceivers = lock . newCondition ( ) ; private final Collection < Receive < T > > receivers ; private final CountDownLatch onReceiversExhaustedFinishedLatch = new CountDownLatch ( <int> ) ; private final AsyncReceive < T > asyncReceive ; private final LinkedList < T > queue = new LinkedList < T > ( ) ; private boolean hasActiveReceivers = true ; private State state = State . Init ; private static < T > Collection < Receive < T > > toReceiveCollection ( Receive < T > receiver ) { Collection < Receive < T > > list = new ArrayList < Receive < T > > ( <int> ) ; list . add ( receiver ) ; return list ; } public EagerReceiveBuffer ( StoppableExecutor executor , Collection < Receive < T > > receivers ) { this ( executor , DEFAULT_BUFFER_SIZE , receivers , null ) ; } public EagerReceiveBuffer ( StoppableExecutor executor , int bufferSize , Receive < T > receiver , Runnable onReceiversExhausted ) { this ( executor , bufferSize , toReceiveCollection ( receiver ) , onReceiversExhausted ) ; } public EagerReceiveBuffer ( StoppableExecutor executor , int bufferSize , Collection < Receive < T > > receivers ) { this ( executor , bufferSize , receivers , null ) ; } public EagerReceiveBuffer ( StoppableExecutor executor , final int bufferSize , Collection < Receive < T > > receivers , final Runnable onReceiversExhausted ) { if ( receivers . size ( ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( bufferSize < <int> ) { throw new IllegalArgumentException ( <str> + bufferSize + <str> ) ; } this . receivers = receivers ; Dispatch < T > dispatch = new Dispatch < T > ( ) { public void dispatch ( T message ) { lock . lock ( ) ; try { while ( queue . size ( ) = = bufferSize & & state = = State . Started ) { try { notFullOrStop . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } queue . add ( message ) ; notEmptyOrNoReceivers . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } ; this . asyncReceive = new AsyncReceive < T > ( executor , dispatch , new Runnable ( ) { public void run ( ) { lock . lock ( ) ; try { hasActiveReceivers = false ; if ( onReceiversExhausted ! = null ) { onReceiversExhausted . run ( ) ; } notEmptyOrNoReceivers . signalAll ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; } finally { lock . unlock ( ) ; onReceiversExhaustedFinishedLatch . countDown ( ) ; } } } ) ; } public void start ( ) { lock . lock ( ) ; try { if ( state ! = State . Init ) { throw new IllegalStateException ( <str> ) ; } state = State . Started ; for ( Receive < T > receiver : receivers ) { asyncReceive . receiveFrom ( receiver ) ; } } finally { lock . unlock ( ) ; } } public T receive ( ) { lock . lock ( ) ; try { while ( queue . isEmpty ( ) & & hasActiveReceivers ) { try { notEmptyOrNoReceivers . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } if ( queue . isEmpty ( ) ) { assert ! hasActiveReceivers ; return null ; } else { T message = queue . poll ( ) ; assert message ! = null ; notFullOrStop . signalAll ( ) ; return message ; } } finally { lock . unlock ( ) ; } } public void requestStop ( ) { lock . lock ( ) ; try { doRequestStop ( ) ; } finally { lock . unlock ( ) ; } } private void doRequestStop ( ) { asyncReceive . requestStop ( ) ; if ( hasActiveReceivers ) { setState ( State . Stopping ) ; } else { setState ( State . Stopped ) ; } } private void setState ( State state ) { this . state = state ; notFullOrStop . signalAll ( ) ; } public void stop ( ) { lock . lock ( ) ; try { doRequestStop ( ) ; } finally { lock . unlock ( ) ; } try { onReceiversExhaustedFinishedLatch . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } lock . lock ( ) ; try { asyncReceive . stop ( ) ; setState ( State . Stopped ) ; } finally { lock . unlock ( ) ; } } } 
