package org . elasticsearch . cluster . routing . allocation ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . cluster . ClusterInfoService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . cluster . health . ClusterStateHealth ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . AllocationId ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocators ; import org . elasticsearch . cluster . routing . allocation . command . AllocationCommands ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import java . util . * ; import java . util . function . Function ; import java . util . stream . Collectors ; public class AllocationService extends AbstractComponent { private final AllocationDeciders allocationDeciders ; private final ClusterInfoService clusterInfoService ; private final ShardsAllocators shardsAllocators ; @Inject public AllocationService ( Settings settings , AllocationDeciders allocationDeciders , ShardsAllocators shardsAllocators , ClusterInfoService clusterInfoService ) { super ( settings ) ; this . allocationDeciders = allocationDeciders ; this . shardsAllocators = shardsAllocators ; this . clusterInfoService = clusterInfoService ; } public RoutingAllocation . Result applyStartedShards ( ClusterState clusterState , List < ? extends ShardRouting > startedShards ) { return applyStartedShards ( clusterState , startedShards , true ) ; } public RoutingAllocation . Result applyStartedShards ( ClusterState clusterState , List < ? extends ShardRouting > startedShards , boolean withReroute ) { RoutingNodes routingNodes = getMutableRoutingNodes ( clusterState ) ; routingNodes . unassigned ( ) . shuffle ( ) ; StartedRerouteAllocation allocation = new StartedRerouteAllocation ( allocationDeciders , routingNodes , clusterState . nodes ( ) , startedShards , clusterInfoService . getClusterInfo ( ) ) ; boolean changed = applyStartedShards ( routingNodes , startedShards ) ; if ( ! changed ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } shardsAllocators . applyStartedShards ( allocation ) ; if ( withReroute ) { reroute ( allocation ) ; } final RoutingAllocation . Result result = buildChangedResult ( clusterState . metaData ( ) , routingNodes ) ; String startedShardsAsString = firstListElementsToCommaDelimitedString ( startedShards , s - > s . shardId ( ) . toString ( ) ) ; logClusterHealthStateChange ( new ClusterStateHealth ( clusterState ) , new ClusterStateHealth ( clusterState . metaData ( ) , result . routingTable ( ) ) , <str> + startedShardsAsString + <str> ) ; return result ; } protected RoutingAllocation . Result buildChangedResult ( MetaData metaData , RoutingNodes routingNodes ) { return buildChangedResult ( metaData , routingNodes , new RoutingExplanations ( ) ) ; } protected RoutingAllocation . Result buildChangedResult ( MetaData metaData , RoutingNodes routingNodes , RoutingExplanations explanations ) { final RoutingTable routingTable = new RoutingTable . Builder ( ) . updateNodes ( routingNodes ) . build ( ) ; MetaData newMetaData = updateMetaDataWithRoutingTable ( metaData , routingTable ) ; return new RoutingAllocation . Result ( true , routingTable . validateRaiseException ( newMetaData ) , newMetaData , explanations ) ; } static MetaData updateMetaDataWithRoutingTable ( MetaData currentMetaData , RoutingTable newRoutingTable ) { MetaData . Builder metaDataBuilder = null ; for ( IndexRoutingTable indexRoutingTable : newRoutingTable ) { final IndexMetaData indexMetaData = currentMetaData . index ( indexRoutingTable . getIndex ( ) ) ; if ( indexMetaData = = null ) { throw new IllegalStateException ( <str> + indexRoutingTable . index ( ) + <str> ) ; } IndexMetaData . Builder indexMetaDataBuilder = null ; for ( IndexShardRoutingTable shardRoutings : indexRoutingTable ) { Set < String > activeAllocationIds = shardRoutings . activeShards ( ) . stream ( ) . map ( ShardRouting : : allocationId ) . filter ( Objects : : nonNull ) . map ( AllocationId : : getId ) . collect ( Collectors . toSet ( ) ) ; if ( activeAllocationIds . isEmpty ( ) = = false ) { Set < String > storedAllocationIds = indexMetaData . activeAllocationIds ( shardRoutings . shardId ( ) . id ( ) ) ; if ( activeAllocationIds . equals ( storedAllocationIds ) = = false ) { if ( indexMetaDataBuilder = = null ) { indexMetaDataBuilder = IndexMetaData . builder ( indexMetaData ) ; } indexMetaDataBuilder . putActiveAllocationIds ( shardRoutings . shardId ( ) . id ( ) , activeAllocationIds ) ; } } } if ( indexMetaDataBuilder ! = null ) { if ( metaDataBuilder = = null ) { metaDataBuilder = MetaData . builder ( currentMetaData ) ; } metaDataBuilder . put ( indexMetaDataBuilder ) ; } } if ( metaDataBuilder ! = null ) { return metaDataBuilder . build ( ) ; } else { return currentMetaData ; } } public RoutingAllocation . Result applyFailedShard ( ClusterState clusterState , ShardRouting failedShard ) { return applyFailedShards ( clusterState , Collections . singletonList ( new FailedRerouteAllocation . FailedShard ( failedShard , null , null ) ) ) ; } public RoutingAllocation . Result applyFailedShards ( ClusterState clusterState , List < FailedRerouteAllocation . FailedShard > failedShards ) { RoutingNodes routingNodes = getMutableRoutingNodes ( clusterState ) ; routingNodes . unassigned ( ) . shuffle ( ) ; FailedRerouteAllocation allocation = new FailedRerouteAllocation ( allocationDeciders , routingNodes , clusterState . nodes ( ) , failedShards , clusterInfoService . getClusterInfo ( ) ) ; boolean changed = false ; for ( FailedRerouteAllocation . FailedShard failedShard : failedShards ) { changed | = applyFailedShard ( allocation , failedShard . shard , true , new UnassignedInfo ( UnassignedInfo . Reason . ALLOCATION_FAILED , failedShard . message , failedShard . failure , System . nanoTime ( ) , System . currentTimeMillis ( ) ) ) ; } if ( ! changed ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } shardsAllocators . applyFailedShards ( allocation ) ; reroute ( allocation ) ; final RoutingAllocation . Result result = buildChangedResult ( clusterState . metaData ( ) , routingNodes ) ; String failedShardsAsString = firstListElementsToCommaDelimitedString ( failedShards , s - > s . shard . shardId ( ) . toString ( ) ) ; logClusterHealthStateChange ( new ClusterStateHealth ( clusterState ) , new ClusterStateHealth ( clusterState . getMetaData ( ) , result . routingTable ( ) ) , <str> + failedShardsAsString + <str> ) ; return result ; } private < T > String firstListElementsToCommaDelimitedString ( List < T > elements , Function < T , String > formatter ) { final int maxNumberOfElements = <int> ; return elements . stream ( ) . limit ( maxNumberOfElements ) . map ( formatter ) . collect ( Collectors . joining ( <str> ) ) ; } public RoutingAllocation . Result reroute ( ClusterState clusterState , AllocationCommands commands ) { return reroute ( clusterState , commands , false ) ; } public RoutingAllocation . Result reroute ( ClusterState clusterState , AllocationCommands commands , boolean explain ) { RoutingNodes routingNodes = getMutableRoutingNodes ( clusterState ) ; RoutingAllocation allocation = new RoutingAllocation ( allocationDeciders , routingNodes , clusterState . nodes ( ) , clusterInfoService . getClusterInfo ( ) , currentNanoTime ( ) ) ; allocation . debugDecision ( true ) ; allocation . ignoreDisable ( true ) ; RoutingExplanations explanations = commands . execute ( allocation , explain ) ; allocation . ignoreDisable ( false ) ; reroute ( allocation ) ; RoutingAllocation . Result result = buildChangedResult ( clusterState . metaData ( ) , routingNodes , explanations ) ; logClusterHealthStateChange ( new ClusterStateHealth ( clusterState ) , new ClusterStateHealth ( clusterState . getMetaData ( ) , result . routingTable ( ) ) , <str> ) ; return result ; } public RoutingAllocation . Result reroute ( ClusterState clusterState , String reason ) { return reroute ( clusterState , reason , false ) ; } protected RoutingAllocation . Result reroute ( ClusterState clusterState , String reason , boolean debug ) { RoutingNodes routingNodes = getMutableRoutingNodes ( clusterState ) ; routingNodes . unassigned ( ) . shuffle ( ) ; RoutingAllocation allocation = new RoutingAllocation ( allocationDeciders , routingNodes , clusterState . nodes ( ) , clusterInfoService . getClusterInfo ( ) , currentNanoTime ( ) ) ; allocation . debugDecision ( debug ) ; if ( ! reroute ( allocation ) ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } RoutingAllocation . Result result = buildChangedResult ( clusterState . metaData ( ) , routingNodes ) ; logClusterHealthStateChange ( new ClusterStateHealth ( clusterState ) , new ClusterStateHealth ( clusterState . getMetaData ( ) , result . routingTable ( ) ) , reason ) ; return result ; } private void logClusterHealthStateChange ( ClusterStateHealth previousStateHealth , ClusterStateHealth newStateHealth , String reason ) { ClusterHealthStatus previousHealth = previousStateHealth . getStatus ( ) ; ClusterHealthStatus currentHealth = newStateHealth . getStatus ( ) ; if ( ! previousHealth . equals ( currentHealth ) ) { logger . info ( <str> , previousHealth , currentHealth , reason ) ; } } private boolean reroute ( RoutingAllocation allocation ) { boolean changed = false ; changed | = deassociateDeadNodes ( allocation ) ; applyNewNodes ( allocation ) ; changed | = electPrimariesAndUnassignedDanglingReplicas ( allocation ) ; if ( allocation . routingNodes ( ) . unassigned ( ) . size ( ) > <int> ) { updateLeftDelayOfUnassignedShards ( allocation , settings ) ; changed | = shardsAllocators . allocateUnassigned ( allocation ) ; } changed | = moveShards ( allocation ) ; changed | = shardsAllocators . rebalance ( allocation ) ; assert RoutingNodes . assertShardStats ( allocation . routingNodes ( ) ) ; return changed ; } public static void updateLeftDelayOfUnassignedShards ( RoutingAllocation allocation , Settings settings ) { for ( ShardRouting shardRouting : allocation . routingNodes ( ) . unassigned ( ) ) { final MetaData metaData = allocation . metaData ( ) ; final IndexMetaData indexMetaData = metaData . index ( shardRouting . index ( ) ) ; shardRouting . unassignedInfo ( ) . updateDelay ( allocation . getCurrentNanoTime ( ) , settings , indexMetaData . getSettings ( ) ) ; } } private boolean moveShards ( RoutingAllocation allocation ) { boolean changed = false ; List < ShardRouting > shards = new ArrayList < > ( ) ; int index = <int> ; boolean found = true ; final RoutingNodes routingNodes = allocation . routingNodes ( ) ; while ( found ) { found = false ; for ( RoutingNode routingNode : routingNodes ) { if ( index > = routingNode . size ( ) ) { continue ; } found = true ; shards . add ( routingNode . get ( index ) ) ; } index + + ; } for ( int i = <int> ; i < shards . size ( ) ; i + + ) { ShardRouting shardRouting = shards . get ( i ) ; if ( ! shardRouting . started ( ) ) { continue ; } final RoutingNode routingNode = routingNodes . node ( shardRouting . currentNodeId ( ) ) ; Decision decision = allocation . deciders ( ) . canRemain ( shardRouting , routingNode , allocation ) ; if ( decision . type ( ) = = Decision . Type . NO ) { logger . debug ( <str> , shardRouting . index ( ) , shardRouting . id ( ) , routingNode . node ( ) ) ; boolean moved = shardsAllocators . move ( shardRouting , routingNode , allocation ) ; if ( ! moved ) { logger . debug ( <str> , shardRouting . index ( ) , shardRouting . id ( ) ) ; } else { changed = true ; } } } return changed ; } private boolean electPrimariesAndUnassignedDanglingReplicas ( RoutingAllocation allocation ) { boolean changed = false ; RoutingNodes routingNodes = allocation . routingNodes ( ) ; if ( routingNodes . unassigned ( ) . getNumPrimaries ( ) = = <int> ) { return changed ; } List < ShardRouting > shardsToFail = new ArrayList < > ( ) ; for ( ShardRouting shardEntry : routingNodes . unassigned ( ) ) { if ( shardEntry . primary ( ) ) { for ( ShardRouting routing : routingNodes . assignedShards ( shardEntry ) ) { if ( ! routing . primary ( ) & & routing . initializing ( ) ) { shardsToFail . add ( routing ) ; } } } } for ( ShardRouting shardToFail : shardsToFail ) { changed | = applyFailedShard ( allocation , shardToFail , false , new UnassignedInfo ( UnassignedInfo . Reason . ALLOCATION_FAILED , <str> , null , allocation . getCurrentNanoTime ( ) , System . currentTimeMillis ( ) ) ) ; } for ( ShardRouting shardEntry : routingNodes . unassigned ( ) ) { if ( shardEntry . primary ( ) ) { ShardRouting candidate = allocation . routingNodes ( ) . activeReplica ( shardEntry ) ; if ( candidate ! = null ) { IndexMetaData index = allocation . metaData ( ) . index ( candidate . index ( ) ) ; routingNodes . swapPrimaryFlag ( shardEntry , candidate ) ; if ( candidate . relocatingNodeId ( ) ! = null ) { changed = true ; RoutingNode node = routingNodes . node ( candidate . relocatingNodeId ( ) ) ; if ( node ! = null ) { for ( ShardRouting shardRouting : node ) { if ( shardRouting . shardId ( ) . equals ( candidate . shardId ( ) ) & & ! shardRouting . primary ( ) ) { routingNodes . swapPrimaryFlag ( shardRouting ) ; break ; } } } } if ( IndexMetaData . isIndexUsingShadowReplicas ( index . getSettings ( ) ) ) { routingNodes . reinitShadowPrimary ( candidate ) ; changed = true ; } } } } return changed ; } private void applyNewNodes ( RoutingAllocation allocation ) { final RoutingNodes routingNodes = allocation . routingNodes ( ) ; for ( ObjectCursor < DiscoveryNode > cursor : allocation . nodes ( ) . dataNodes ( ) . values ( ) ) { DiscoveryNode node = cursor . value ; if ( ! routingNodes . isKnown ( node ) ) { routingNodes . addNode ( node ) ; } } } private boolean deassociateDeadNodes ( RoutingAllocation allocation ) { boolean changed = false ; for ( RoutingNodes . RoutingNodesIterator it = allocation . routingNodes ( ) . nodes ( ) ; it . hasNext ( ) ; ) { RoutingNode node = it . next ( ) ; if ( allocation . nodes ( ) . dataNodes ( ) . containsKey ( node . nodeId ( ) ) ) { continue ; } changed = true ; for ( ShardRouting shardRouting : node . copyShards ( ) ) { UnassignedInfo unassignedInfo = new UnassignedInfo ( UnassignedInfo . Reason . NODE_LEFT , <str> + node . nodeId ( ) + <str> , null , allocation . getCurrentNanoTime ( ) , System . currentTimeMillis ( ) ) ; applyFailedShard ( allocation , shardRouting , false , unassignedInfo ) ; } it . remove ( ) ; } return changed ; } private boolean applyStartedShards ( RoutingNodes routingNodes , Iterable < ? extends ShardRouting > startedShardEntries ) { boolean dirty = false ; for ( ShardRouting startedShard : startedShardEntries ) { assert startedShard . initializing ( ) ; if ( routingNodes . routingTable ( ) . index ( startedShard . index ( ) ) = = null ) { logger . debug ( <str> , startedShard . shardId ( ) , startedShard ) ; continue ; } RoutingNodes . RoutingNodeIterator currentRoutingNode = routingNodes . routingNodeIter ( startedShard . currentNodeId ( ) ) ; if ( currentRoutingNode = = null ) { logger . debug ( <str> , startedShard . shardId ( ) , startedShard ) ; continue ; } for ( ShardRouting shard : currentRoutingNode ) { if ( shard . isSameAllocation ( startedShard ) ) { if ( shard . active ( ) ) { logger . trace ( <str> , startedShard . shardId ( ) , startedShard ) ; } else { dirty = true ; startedShard = new ShardRouting ( shard ) ; routingNodes . started ( shard ) ; logger . trace ( <str> , startedShard . shardId ( ) , startedShard ) ; } break ; } } if ( startedShard . relocatingNodeId ( ) = = null ) { continue ; } RoutingNodes . RoutingNodeIterator sourceRoutingNode = routingNodes . routingNodeIter ( startedShard . relocatingNodeId ( ) ) ; if ( sourceRoutingNode ! = null ) { while ( sourceRoutingNode . hasNext ( ) ) { ShardRouting shard = sourceRoutingNode . next ( ) ; if ( shard . isRelocationSourceOf ( startedShard ) ) { dirty = true ; sourceRoutingNode . remove ( ) ; break ; } } } } return dirty ; } private boolean applyFailedShard ( RoutingAllocation allocation , ShardRouting failedShard , boolean addToIgnoreList , UnassignedInfo unassignedInfo ) { IndexRoutingTable indexRoutingTable = allocation . routingTable ( ) . index ( failedShard . index ( ) ) ; if ( indexRoutingTable = = null ) { logger . debug ( <str> , failedShard . shardId ( ) , failedShard , unassignedInfo . shortSummary ( ) ) ; return false ; } RoutingNodes routingNodes = allocation . routingNodes ( ) ; RoutingNodes . RoutingNodeIterator matchedNode = routingNodes . routingNodeIter ( failedShard . currentNodeId ( ) ) ; if ( matchedNode = = null ) { logger . debug ( <str> , failedShard . shardId ( ) , failedShard , unassignedInfo . shortSummary ( ) ) ; return false ; } boolean matchedShard = false ; while ( matchedNode . hasNext ( ) ) { ShardRouting routing = matchedNode . next ( ) ; if ( routing . isSameAllocation ( failedShard ) ) { matchedShard = true ; logger . debug ( <str> , failedShard . shardId ( ) , failedShard , unassignedInfo . shortSummary ( ) ) ; break ; } } if ( matchedShard = = false ) { logger . debug ( <str> , failedShard . shardId ( ) , failedShard , unassignedInfo . shortSummary ( ) ) ; return false ; } failedShard = new ShardRouting ( matchedNode . current ( ) ) ; matchedNode . remove ( ) ; if ( addToIgnoreList ) { allocation . addIgnoreShardForNode ( failedShard . shardId ( ) , failedShard . currentNodeId ( ) ) ; } if ( failedShard . relocatingNodeId ( ) ! = null & & failedShard . initializing ( ) ) { logger . trace ( <str> , failedShard , unassignedInfo . shortSummary ( ) ) ; RoutingNode relocatingFromNode = routingNodes . node ( failedShard . relocatingNodeId ( ) ) ; if ( relocatingFromNode ! = null ) { for ( ShardRouting shardRouting : relocatingFromNode ) { if ( shardRouting . isRelocationSourceOf ( failedShard ) ) { logger . trace ( <str> , failedShard . shardId ( ) , shardRouting , unassignedInfo . shortSummary ( ) ) ; routingNodes . cancelRelocation ( shardRouting ) ; break ; } } } } else { if ( failedShard . relocatingNodeId ( ) ! = null ) { assert failedShard . initializing ( ) = = false ; assert failedShard . relocating ( ) ; RoutingNodes . RoutingNodeIterator initializingNode = routingNodes . routingNodeIter ( failedShard . relocatingNodeId ( ) ) ; if ( initializingNode ! = null ) { while ( initializingNode . hasNext ( ) ) { ShardRouting shardRouting = initializingNode . next ( ) ; if ( shardRouting . isRelocationTargetOf ( failedShard ) ) { logger . trace ( <str> , shardRouting ) ; initializingNode . remove ( ) ; } } } } matchedNode . moveToUnassigned ( unassignedInfo ) ; } assert matchedNode . isRemoved ( ) : <str> + failedShard + <str> ; return true ; } private RoutingNodes getMutableRoutingNodes ( ClusterState clusterState ) { RoutingNodes routingNodes = new RoutingNodes ( clusterState , false ) ; return routingNodes ; } protected long currentNanoTime ( ) { return System . nanoTime ( ) ; } } 
