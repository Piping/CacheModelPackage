package org . gradle . integtests . fixtures . executer ; import org . apache . commons . collections . CollectionUtils ; import org . gradle . api . Action ; import org . gradle . util . TextUtil ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . StringReader ; import java . util . * ; import java . util . regex . Pattern ; import static org . gradle . util . TextUtil . normaliseLineSeparators ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . assertThat ; public class OutputScrapingExecutionResult implements ExecutionResult { private final String output ; private final String error ; private final Pattern skippedTaskPattern = Pattern . compile ( <str> ) ; private final Pattern taskPattern = Pattern . compile ( <str> ) ; public OutputScrapingExecutionResult ( String output , String error ) { this . output = output ; this . error = error ; } public String getOutput ( ) { return TextUtil . normaliseLineSeparators ( output ) ; } public ExecutionResult assertOutputEquals ( String expectedOutput , boolean ignoreExtraLines , boolean ignoreLineOrder ) { SequentialOutputMatcher matcher = ignoreLineOrder ? new AnyOrderOutputMatcher ( ) : new SequentialOutputMatcher ( ) ; matcher . assertOutputMatches ( expectedOutput , getOutput ( ) , ignoreExtraLines ) ; return this ; } @Override public ExecutionResult assertOutputContains ( String expectedOutput ) { assertThat ( <str> , getOutput ( ) , org . hamcrest . core . StringContains . containsString ( normaliseLineSeparators ( expectedOutput ) ) ) ; return this ; } public String getError ( ) { return TextUtil . normaliseLineSeparators ( error ) ; } public List < String > getExecutedTasks ( ) { return grepTasks ( taskPattern ) ; } public ExecutionResult assertTasksExecuted ( String . . . taskPaths ) { List < String > expectedTasks = Arrays . asList ( taskPaths ) ; assertThat ( String . format ( <str> , expectedTasks , getOutput ( ) ) , getExecutedTasks ( ) , equalTo ( expectedTasks ) ) ; return this ; } public Set < String > getSkippedTasks ( ) { return new HashSet < String > ( grepTasks ( skippedTaskPattern ) ) ; } public ExecutionResult assertTasksSkipped ( String . . . taskPaths ) { Set < String > expectedTasks = new HashSet < String > ( Arrays . asList ( taskPaths ) ) ; assertThat ( String . format ( <str> , expectedTasks , getOutput ( ) ) , getSkippedTasks ( ) , equalTo ( expectedTasks ) ) ; return this ; } public ExecutionResult assertTaskSkipped ( String taskPath ) { Set < String > tasks = new HashSet < String > ( getSkippedTasks ( ) ) ; assertThat ( String . format ( <str> , taskPath , getOutput ( ) ) , tasks , hasItem ( taskPath ) ) ; return this ; } public ExecutionResult assertTasksNotSkipped ( String . . . taskPaths ) { Set < String > tasks = new HashSet < String > ( getNotSkippedTasks ( ) ) ; Set < String > expectedTasks = new HashSet < String > ( Arrays . asList ( taskPaths ) ) ; assertThat ( String . format ( <str> , expectedTasks , getOutput ( ) ) , tasks , equalTo ( expectedTasks ) ) ; return this ; } private Collection < String > getNotSkippedTasks ( ) { List all = getExecutedTasks ( ) ; Set skipped = getSkippedTasks ( ) ; return CollectionUtils . subtract ( all , skipped ) ; } public ExecutionResult assertTaskNotSkipped ( String taskPath ) { Set < String > tasks = new HashSet < String > ( getNotSkippedTasks ( ) ) ; assertThat ( String . format ( <str> , taskPath , getOutput ( ) ) , tasks , hasItem ( taskPath ) ) ; return this ; } private List < String > grepTasks ( final Pattern pattern ) { final LinkedList < String > tasks = new LinkedList < String > ( ) ; eachLine ( new Action < String > ( ) { public void execute ( String s ) { java . util . regex . Matcher matcher = pattern . matcher ( s ) ; if ( matcher . matches ( ) ) { String taskName = matcher . group ( <int> ) ; if ( ! taskName . startsWith ( <str> ) ) { if ( tasks . size ( ) = = <int> | | ! tasks . getLast ( ) . equals ( taskName ) ) { tasks . add ( taskName ) ; } } } } } ) ; return tasks ; } private void eachLine ( Action < String > action ) { BufferedReader reader = new BufferedReader ( new StringReader ( getOutput ( ) ) ) ; String line ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { action . execute ( line ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } 
