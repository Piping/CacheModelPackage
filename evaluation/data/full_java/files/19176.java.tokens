package io . netty . handler . codec . http . websocketx ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpClientCodec ; import io . netty . handler . codec . http . HttpContentDecompressor ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpObjectAggregator ; import io . netty . handler . codec . http . HttpRequestEncoder ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseDecoder ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . StringUtil ; import java . net . URI ; import java . nio . channels . ClosedChannelException ; public abstract class WebSocketClientHandshaker { private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException ( ) ; static { CLOSED_CHANNEL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private final URI uri ; private final WebSocketVersion version ; private volatile boolean handshakeComplete ; private final String expectedSubprotocol ; private volatile String actualSubprotocol ; protected final HttpHeaders customHeaders ; private final int maxFramePayloadLength ; protected WebSocketClientHandshaker ( URI uri , WebSocketVersion version , String subprotocol , HttpHeaders customHeaders , int maxFramePayloadLength ) { this . uri = uri ; this . version = version ; expectedSubprotocol = subprotocol ; this . customHeaders = customHeaders ; this . maxFramePayloadLength = maxFramePayloadLength ; } public URI uri ( ) { return uri ; } public WebSocketVersion version ( ) { return version ; } public int maxFramePayloadLength ( ) { return maxFramePayloadLength ; } public boolean isHandshakeComplete ( ) { return handshakeComplete ; } private void setHandshakeComplete ( ) { handshakeComplete = true ; } public String expectedSubprotocol ( ) { return expectedSubprotocol ; } public String actualSubprotocol ( ) { return actualSubprotocol ; } private void setActualSubprotocol ( String actualSubprotocol ) { this . actualSubprotocol = actualSubprotocol ; } public ChannelFuture handshake ( Channel channel ) { if ( channel = = null ) { throw new NullPointerException ( <str> ) ; } return handshake ( channel , channel . newPromise ( ) ) ; } public final ChannelFuture handshake ( Channel channel , final ChannelPromise promise ) { FullHttpRequest request = newHandshakeRequest ( ) ; HttpResponseDecoder decoder = channel . pipeline ( ) . get ( HttpResponseDecoder . class ) ; if ( decoder = = null ) { HttpClientCodec codec = channel . pipeline ( ) . get ( HttpClientCodec . class ) ; if ( codec = = null ) { promise . setFailure ( new IllegalStateException ( <str> + <str> ) ) ; return promise ; } } channel . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) { if ( future . isSuccess ( ) ) { ChannelPipeline p = future . channel ( ) . pipeline ( ) ; ChannelHandlerContext ctx = p . context ( HttpRequestEncoder . class ) ; if ( ctx = = null ) { ctx = p . context ( HttpClientCodec . class ) ; } if ( ctx = = null ) { promise . setFailure ( new IllegalStateException ( <str> + <str> ) ) ; return ; } p . addAfter ( ctx . name ( ) , <str> , newWebSocketEncoder ( ) ) ; promise . setSuccess ( ) ; } else { promise . setFailure ( future . cause ( ) ) ; } } } ) ; return promise ; } protected abstract FullHttpRequest newHandshakeRequest ( ) ; public final void finishHandshake ( Channel channel , FullHttpResponse response ) { verify ( response ) ; String receivedProtocol = response . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL ) ; receivedProtocol = receivedProtocol ! = null ? receivedProtocol . trim ( ) : null ; String expectedProtocol = expectedSubprotocol ! = null ? expectedSubprotocol : <str> ; boolean protocolValid = false ; if ( expectedProtocol . isEmpty ( ) & & receivedProtocol = = null ) { protocolValid = true ; setActualSubprotocol ( expectedSubprotocol ) ; } else if ( ! expectedProtocol . isEmpty ( ) & & receivedProtocol ! = null & & ! receivedProtocol . isEmpty ( ) ) { for ( String protocol : StringUtil . split ( expectedSubprotocol , <str> ) ) { if ( protocol . trim ( ) . equals ( receivedProtocol ) ) { protocolValid = true ; setActualSubprotocol ( receivedProtocol ) ; break ; } } } if ( ! protocolValid ) { throw new WebSocketHandshakeException ( String . format ( <str> , receivedProtocol , expectedSubprotocol ) ) ; } setHandshakeComplete ( ) ; ChannelPipeline p = channel . pipeline ( ) ; HttpContentDecompressor decompressor = p . get ( HttpContentDecompressor . class ) ; if ( decompressor ! = null ) { p . remove ( decompressor ) ; } HttpObjectAggregator aggregator = p . get ( HttpObjectAggregator . class ) ; if ( aggregator ! = null ) { p . remove ( aggregator ) ; } ChannelHandlerContext ctx = p . context ( HttpResponseDecoder . class ) ; if ( ctx = = null ) { ctx = p . context ( HttpClientCodec . class ) ; if ( ctx = = null ) { throw new IllegalStateException ( <str> + <str> ) ; } p . replace ( ctx . name ( ) , <str> , newWebsocketDecoder ( ) ) ; } else { if ( p . get ( HttpRequestEncoder . class ) ! = null ) { p . remove ( HttpRequestEncoder . class ) ; } p . replace ( ctx . name ( ) , <str> , newWebsocketDecoder ( ) ) ; } } public final ChannelFuture processHandshake ( final Channel channel , HttpResponse response ) { return processHandshake ( channel , response , channel . newPromise ( ) ) ; } public final ChannelFuture processHandshake ( final Channel channel , HttpResponse response , final ChannelPromise promise ) { if ( response instanceof FullHttpResponse ) { try { finishHandshake ( channel , ( FullHttpResponse ) response ) ; promise . setSuccess ( ) ; } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } } else { ChannelPipeline p = channel . pipeline ( ) ; ChannelHandlerContext ctx = p . context ( HttpResponseDecoder . class ) ; if ( ctx = = null ) { ctx = p . context ( HttpClientCodec . class ) ; if ( ctx = = null ) { return promise . setFailure ( new IllegalStateException ( <str> + <str> ) ) ; } } String aggregatorName = <str> ; p . addAfter ( ctx . name ( ) , aggregatorName , new HttpObjectAggregator ( <int> ) ) ; p . addAfter ( aggregatorName , <str> , new SimpleChannelInboundHandler < FullHttpResponse > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , FullHttpResponse msg ) throws Exception { ctx . pipeline ( ) . remove ( this ) ; try { finishHandshake ( channel , msg ) ; promise . setSuccess ( ) ; } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { ctx . pipeline ( ) . remove ( this ) ; promise . setFailure ( cause ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; ctx . fireChannelInactive ( ) ; } } ) ; try { ctx . fireChannelRead ( ReferenceCountUtil . retain ( response ) ) ; } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } } return promise ; } protected abstract void verify ( FullHttpResponse response ) ; protected abstract WebSocketFrameDecoder newWebsocketDecoder ( ) ; protected abstract WebSocketFrameEncoder newWebSocketEncoder ( ) ; public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame ) { if ( channel = = null ) { throw new NullPointerException ( <str> ) ; } return close ( channel , frame , channel . newPromise ( ) ) ; } public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame , ChannelPromise promise ) { if ( channel = = null ) { throw new NullPointerException ( <str> ) ; } return channel . writeAndFlush ( frame , promise ) ; } static String rawPath ( URI wsURL ) { String path = wsURL . getRawPath ( ) ; String query = wsURL . getQuery ( ) ; if ( query ! = null & & ! query . isEmpty ( ) ) { path = path + <str> + query ; } return path = = null | | path . isEmpty ( ) ? <str> : path ; } } 
