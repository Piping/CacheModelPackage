package org . elasticsearch . index . query ; import org . apache . lucene . search . BoostQuery ; import org . apache . lucene . search . MultiTermQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . spans . SpanBoostQuery ; import org . apache . lucene . search . spans . SpanMultiTermQueryWrapper ; import org . apache . lucene . search . spans . SpanQuery ; import java . io . IOException ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; public class SpanMultiTermQueryBuilderTests extends AbstractQueryTestCase < SpanMultiTermQueryBuilder > { @Override protected SpanMultiTermQueryBuilder doCreateTestQueryBuilder ( ) { MultiTermQueryBuilder multiTermQueryBuilder = RandomQueryBuilder . createMultiTermQuery ( random ( ) ) ; return new SpanMultiTermQueryBuilder ( multiTermQueryBuilder ) ; } @Override protected void doAssertLuceneQuery ( SpanMultiTermQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( queryBuilder . innerQuery ( ) . boost ( ) ! = AbstractQueryBuilder . DEFAULT_BOOST ) { assertThat ( query , instanceOf ( SpanBoostQuery . class ) ) ; SpanBoostQuery boostQuery = ( SpanBoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( queryBuilder . innerQuery ( ) . boost ( ) ) ) ; query = boostQuery . getQuery ( ) ; } assertThat ( query , instanceOf ( SpanMultiTermQueryWrapper . class ) ) ; SpanMultiTermQueryWrapper spanMultiTermQueryWrapper = ( SpanMultiTermQueryWrapper ) query ; Query multiTermQuery = queryBuilder . innerQuery ( ) . toQuery ( context ) ; if ( queryBuilder . innerQuery ( ) . boost ( ) ! = AbstractQueryBuilder . DEFAULT_BOOST ) { assertThat ( multiTermQuery , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) multiTermQuery ; multiTermQuery = boostQuery . getQuery ( ) ; } assertThat ( multiTermQuery , instanceOf ( MultiTermQuery . class ) ) ; assertThat ( spanMultiTermQueryWrapper . getWrappedQuery ( ) , equalTo ( new SpanMultiTermQueryWrapper < > ( ( MultiTermQuery ) multiTermQuery ) . getWrappedQuery ( ) ) ) ; } public void testIllegalArgument ( ) { try { new SpanMultiTermQueryBuilder ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testUnsupportedInnerQueryType ( ) throws IOException { QueryShardContext context = createShardContext ( ) ; if ( getCurrentTypes ( ) . length > <int> & & context . fieldMapper ( DATE_FIELD_NAME ) ! = null ) { try { RangeQueryBuilder query = new RangeQueryBuilder ( DATE_FIELD_NAME ) ; new SpanMultiTermQueryBuilder ( query ) . toQuery ( createShardContext ( ) ) ; fail ( <str> + MultiTermQuery . class . getName ( ) ) ; } catch ( UnsupportedOperationException e ) { assert ( e . getMessage ( ) . contains ( <str> + MultiTermQuery . class . getName ( ) ) ) ; } } } public void testToQueryInnerSpanMultiTerm ( ) throws IOException { Query query = new SpanOrQueryBuilder ( createTestQueryBuilder ( ) ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( SpanQuery . class ) ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; SpanMultiTermQueryBuilder parsed = ( SpanMultiTermQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , ( ( PrefixQueryBuilder ) parsed . innerQuery ( ) ) . value ( ) ) ; assertEquals ( json , <float> , parsed . innerQuery ( ) . boost ( ) , <float> ) ; } } 
