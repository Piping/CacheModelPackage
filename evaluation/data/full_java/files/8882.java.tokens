package org . elasticsearch . cloud . aws ; import com . amazonaws . ClientConfiguration ; import com . amazonaws . Protocol ; import com . amazonaws . auth . * ; import com . amazonaws . http . IdleConnectionReaper ; import com . amazonaws . internal . StaticCredentialsProvider ; import com . amazonaws . services . s3 . AmazonS3 ; import com . amazonaws . services . s3 . AmazonS3Client ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; public class InternalAwsS3Service extends AbstractLifecycleComponent < AwsS3Service > implements AwsS3Service { private Map < Tuple < String , String > , AmazonS3Client > clients = new HashMap < Tuple < String , String > , AmazonS3Client > ( ) ; @Inject public InternalAwsS3Service ( Settings settings , SettingsFilter settingsFilter ) { super ( settings ) ; settingsFilter . addFilter ( CLOUD_AWS . KEY ) ; settingsFilter . addFilter ( CLOUD_AWS . SECRET ) ; settingsFilter . addFilter ( CLOUD_AWS . PROXY_PASSWORD ) ; settingsFilter . addFilter ( CLOUD_S3 . KEY ) ; settingsFilter . addFilter ( CLOUD_S3 . SECRET ) ; settingsFilter . addFilter ( CLOUD_S3 . PROXY_PASSWORD ) ; settingsFilter . addFilter ( <str> ) ; settingsFilter . addFilter ( <str> ) ; } @Override public synchronized AmazonS3 client ( ) { String endpoint = getDefaultEndpoint ( ) ; String account = settings . get ( CLOUD_S3 . KEY , settings . get ( CLOUD_AWS . KEY ) ) ; String key = settings . get ( CLOUD_S3 . SECRET , settings . get ( CLOUD_AWS . SECRET ) ) ; return getClient ( endpoint , null , account , key , null ) ; } @Override public AmazonS3 client ( String endpoint , String protocol , String region , String account , String key ) { return client ( endpoint , protocol , region , account , key , null ) ; } @Override public synchronized AmazonS3 client ( String endpoint , String protocol , String region , String account , String key , Integer maxRetries ) { if ( region ! = null & & endpoint = = null ) { endpoint = getEndpoint ( region ) ; logger . debug ( <str> , region , endpoint ) ; } else if ( endpoint = = null ) { endpoint = getDefaultEndpoint ( ) ; } if ( account = = null | | key = = null ) { account = settings . get ( CLOUD_S3 . KEY , settings . get ( CLOUD_AWS . KEY ) ) ; key = settings . get ( CLOUD_S3 . SECRET , settings . get ( CLOUD_AWS . SECRET ) ) ; } return getClient ( endpoint , protocol , account , key , maxRetries ) ; } private synchronized AmazonS3 getClient ( String endpoint , String protocol , String account , String key , Integer maxRetries ) { Tuple < String , String > clientDescriptor = new Tuple < String , String > ( endpoint , account ) ; AmazonS3Client client = clients . get ( clientDescriptor ) ; if ( client ! = null ) { return client ; } ClientConfiguration clientConfiguration = new ClientConfiguration ( ) ; clientConfiguration . setResponseMetadataCacheSize ( <int> ) ; if ( protocol = = null ) { protocol = settings . get ( CLOUD_AWS . PROTOCOL , <str> ) . toLowerCase ( Locale . ROOT ) ; protocol = settings . get ( CLOUD_S3 . PROTOCOL , protocol ) . toLowerCase ( Locale . ROOT ) ; } if ( <str> . equals ( protocol ) ) { clientConfiguration . setProtocol ( Protocol . HTTP ) ; } else if ( <str> . equals ( protocol ) ) { clientConfiguration . setProtocol ( Protocol . HTTPS ) ; } else { throw new IllegalArgumentException ( <str> + protocol + <str> ) ; } String proxyHost = settings . get ( CLOUD_AWS . PROXY_HOST , settings . get ( CLOUD_AWS . DEPRECATED_PROXY_HOST ) ) ; proxyHost = settings . get ( CLOUD_S3 . PROXY_HOST , settings . get ( CLOUD_S3 . DEPRECATED_PROXY_HOST , proxyHost ) ) ; if ( proxyHost ! = null ) { String portString = settings . get ( CLOUD_AWS . PROXY_PORT , settings . get ( CLOUD_AWS . DEPRECATED_PROXY_PORT , <str> ) ) ; portString = settings . get ( CLOUD_S3 . PROXY_PORT , settings . get ( CLOUD_S3 . DEPRECATED_PROXY_PORT , portString ) ) ; Integer proxyPort ; try { proxyPort = Integer . parseInt ( portString , <int> ) ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( <str> + portString + <str> , ex ) ; } String proxyUsername = settings . get ( CLOUD_S3 . PROXY_USERNAME , settings . get ( CLOUD_AWS . PROXY_USERNAME ) ) ; String proxyPassword = settings . get ( CLOUD_S3 . PROXY_PASSWORD , settings . get ( CLOUD_AWS . PROXY_PASSWORD ) ) ; clientConfiguration . withProxyHost ( proxyHost ) . withProxyPort ( proxyPort ) . withProxyUsername ( proxyUsername ) . withProxyPassword ( proxyPassword ) ; } if ( maxRetries ! = null ) { clientConfiguration . setMaxErrorRetry ( maxRetries ) ; } String awsSigner = settings . get ( CLOUD_S3 . SIGNER , settings . get ( CLOUD_AWS . SIGNER ) ) ; if ( awsSigner ! = null ) { logger . debug ( <str> , awsSigner ) ; AwsSigner . configureSigner ( awsSigner , clientConfiguration , endpoint ) ; } AWSCredentialsProvider credentials ; if ( account = = null & & key = = null ) { credentials = new AWSCredentialsProviderChain ( new EnvironmentVariableCredentialsProvider ( ) , new SystemPropertiesCredentialsProvider ( ) , new InstanceProfileCredentialsProvider ( ) ) ; } else { credentials = new AWSCredentialsProviderChain ( new StaticCredentialsProvider ( new BasicAWSCredentials ( account , key ) ) ) ; } client = new AmazonS3Client ( credentials , clientConfiguration ) ; if ( endpoint ! = null ) { client . setEndpoint ( endpoint ) ; } clients . put ( clientDescriptor , client ) ; return client ; } private String getDefaultEndpoint ( ) { String endpoint = null ; if ( settings . get ( CLOUD_S3 . ENDPOINT ) ! = null ) { endpoint = settings . get ( CLOUD_S3 . ENDPOINT ) ; logger . debug ( <str> , endpoint ) ; } else if ( settings . get ( CLOUD_AWS . REGION ) ! = null ) { String region = settings . get ( CLOUD_AWS . REGION ) . toLowerCase ( Locale . ROOT ) ; endpoint = getEndpoint ( region ) ; logger . debug ( <str> , region , endpoint ) ; } return endpoint ; } private static String getEndpoint ( String region ) { if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else if ( <str> . equals ( region ) | | <str> . equals ( region ) ) { return <str> ; } else { throw new IllegalArgumentException ( <str> + region + <str> ) ; } } @Override protected void doStart ( ) throws ElasticsearchException { } @Override protected void doStop ( ) throws ElasticsearchException { } @Override protected void doClose ( ) throws ElasticsearchException { for ( AmazonS3Client client : clients . values ( ) ) { client . shutdown ( ) ; } IdleConnectionReaper . shutdown ( ) ; } } 
