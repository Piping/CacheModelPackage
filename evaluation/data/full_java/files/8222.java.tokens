package org . elasticsearch . index . mapper . update ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . LinkedHashMap ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . CoreMatchers . equalTo ; public class UpdateMappingTests extends ESSingleNodeTestCase { public void testAllEnabledAfterDisabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; } public void testAllDisabledAfterEnabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; } public void testAllDisabledAfterDefaultEnabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; } public void testAllEnabledAfterEnabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; } public void testAllDisabledAfterDisabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; } private void testNoConflictWhileMergingAndMappingChanged ( XContentBuilder mapping , XContentBuilder mappingUpdate , XContentBuilder expectedMapping ) throws IOException { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mapping ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , false , false ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( <int> ) ) ; CompressedXContent mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate . toString ( ) , equalTo ( expectedMapping . string ( ) ) ) ; } public void testConflictFieldsMapping ( String fieldName ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( fieldName ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( fieldName ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; } protected void testConflictWhileMergingAndMappingUnchanged ( XContentBuilder mapping , XContentBuilder mappingUpdate ) throws IOException { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mapping ) ; CompressedXContent mappingBeforeUpdate = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , true , false ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( <int> ) ) ; CompressedXContent mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate , equalTo ( mappingBeforeUpdate ) ) ; } public void testConflictSameType ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; MapperService mapperService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mapping ) . mapperService ( ) ; XContentBuilder update = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } assertTrue ( mapperService . documentMapper ( <str> ) . mapping ( ) . root ( ) . getMapper ( <str> ) instanceof LongFieldMapper ) ; } public void testConflictNewType ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; MapperService mapperService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mapping ) . mapperService ( ) ; XContentBuilder update = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } assertTrue ( mapperService . documentMapper ( <str> ) . mapping ( ) . root ( ) . getMapper ( <str> ) instanceof LongFieldMapper ) ; assertNull ( mapperService . documentMapper ( <str> ) ) ; } public void testConflictNewTypeUpdate ( ) throws Exception { XContentBuilder mapping1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mapping2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) ; MapperService mapperService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) ) . mapperService ( ) ; mapperService . merge ( <str> , new CompressedXContent ( mapping1 . string ( ) ) , false , false ) ; mapperService . merge ( <str> , new CompressedXContent ( mapping2 . string ( ) ) , false , false ) ; XContentBuilder update = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } try { mapperService . merge ( <str> , new CompressedXContent ( update . string ( ) ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } assertTrue ( mapperService . documentMapper ( <str> ) . mapping ( ) . root ( ) . getMapper ( <str> ) instanceof LongFieldMapper ) ; assertNotNull ( mapperService . documentMapper ( <str> ) ) ; assertNull ( mapperService . documentMapper ( <str> ) . mapping ( ) . root ( ) . getMapper ( <str> ) ) ; } public void testIndexFieldParsingBackcompat ( ) throws IOException { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , enabled ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; } public void testTimestampParsing ( ) throws IOException { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , enabled ) . field ( <str> , true ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) ) ; documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; } public void testSizeTimestampIndexParsing ( ) throws IOException { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mapping ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; documentMapper = indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; } public void testDefaultApplied ( ) throws IOException { createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) ) ; createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder defaultMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( MapperService . DEFAULT_MAPPING ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( ) . setType ( MapperService . DEFAULT_MAPPING ) . setSource ( defaultMapping ) . get ( ) ; XContentBuilder typeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( typeMapping ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> , <str> ) . setType ( <str> ) . setSource ( typeMapping ) . get ( ) ; GetMappingsResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . get ( ) ; assertNotNull ( response . getMappings ( ) . get ( <str> ) . get ( <str> ) . getSourceAsMap ( ) . get ( <str> ) ) ; assertFalse ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( <str> ) . get ( <str> ) . getSourceAsMap ( ) . get ( <str> ) ) . get ( <str> ) ) ; assertNotNull ( response . getMappings ( ) . get ( <str> ) . get ( <str> ) . getSourceAsMap ( ) . get ( <str> ) ) ; assertTrue ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( <str> ) . get ( <str> ) . getSourceAsMap ( ) . get ( <str> ) ) . get ( <str> ) ) ; } } 
