package org . elasticsearch . index . query ; import org . apache . lucene . queries . ExtendedCommonTermsQuery ; import org . apache . lucene . search . * ; import org . elasticsearch . common . lucene . search . MultiPhrasePrefixQuery ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . search . MatchQuery ; import org . elasticsearch . index . search . MatchQuery . ZeroTermsQuery ; import java . io . IOException ; import java . util . Locale ; import static org . hamcrest . CoreMatchers . either ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; public class MatchQueryBuilderTests extends AbstractQueryTestCase < MatchQueryBuilder > { @Override protected MatchQueryBuilder doCreateTestQueryBuilder ( ) { String fieldName = randomFrom ( STRING_FIELD_NAME , BOOLEAN_FIELD_NAME , INT_FIELD_NAME , DOUBLE_FIELD_NAME , DATE_FIELD_NAME ) ; if ( fieldName . equals ( DATE_FIELD_NAME ) ) { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; } Object value ; if ( fieldName . equals ( STRING_FIELD_NAME ) ) { int terms = randomIntBetween ( <int> , <int> ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = <int> ; i < terms ; i + + ) { builder . append ( randomAsciiOfLengthBetween ( <int> , <int> ) ) . append ( <str> ) ; } value = builder . toString ( ) . trim ( ) ; } else { value = getRandomValueForFieldName ( fieldName ) ; } MatchQueryBuilder matchQuery = new MatchQueryBuilder ( fieldName , value ) ; matchQuery . type ( randomFrom ( MatchQuery . Type . values ( ) ) ) ; matchQuery . operator ( randomFrom ( Operator . values ( ) ) ) ; if ( randomBoolean ( ) ) { matchQuery . analyzer ( randomFrom ( <str> , <str> , <str> ) ) ; } if ( randomBoolean ( ) ) { matchQuery . slop ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { matchQuery . fuzziness ( randomFuzziness ( fieldName ) ) ; } if ( randomBoolean ( ) ) { matchQuery . prefixLength ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { matchQuery . minimumShouldMatch ( randomMinimumShouldMatch ( ) ) ; } if ( randomBoolean ( ) ) { matchQuery . fuzzyRewrite ( getRandomRewriteMethod ( ) ) ; } if ( randomBoolean ( ) ) { matchQuery . fuzzyTranspositions ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { matchQuery . lenient ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { matchQuery . zeroTermsQuery ( randomFrom ( MatchQuery . ZeroTermsQuery . values ( ) ) ) ; } if ( randomBoolean ( ) ) { matchQuery . cutoffFrequency ( ( float ) <int> / randomIntBetween ( <int> , <int> ) ) ; } return matchQuery ; } @Override protected void doAssertLuceneQuery ( MatchQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { assertThat ( query , notNullValue ( ) ) ; if ( query instanceof MatchAllDocsQuery ) { assertThat ( queryBuilder . zeroTermsQuery ( ) , equalTo ( ZeroTermsQuery . ALL ) ) ; return ; } switch ( queryBuilder . type ( ) ) { case BOOLEAN : assertThat ( query , either ( instanceOf ( BooleanQuery . class ) ) . or ( instanceOf ( ExtendedCommonTermsQuery . class ) ) . or ( instanceOf ( TermQuery . class ) ) . or ( instanceOf ( FuzzyQuery . class ) ) ) ; break ; case PHRASE : assertThat ( query , either ( instanceOf ( BooleanQuery . class ) ) . or ( instanceOf ( PhraseQuery . class ) ) . or ( instanceOf ( TermQuery . class ) ) . or ( instanceOf ( FuzzyQuery . class ) ) ) ; break ; case PHRASE_PREFIX : assertThat ( query , either ( instanceOf ( BooleanQuery . class ) ) . or ( instanceOf ( MultiPhrasePrefixQuery . class ) ) . or ( instanceOf ( TermQuery . class ) ) . or ( instanceOf ( FuzzyQuery . class ) ) ) ; break ; } MappedFieldType fieldType = context . fieldMapper ( queryBuilder . fieldName ( ) ) ; if ( query instanceof TermQuery & & fieldType ! = null ) { String queryValue = queryBuilder . value ( ) . toString ( ) ; if ( queryBuilder . analyzer ( ) = = null | | queryBuilder . analyzer ( ) . equals ( <str> ) ) { queryValue = queryValue . toLowerCase ( Locale . ROOT ) ; } Query expectedTermQuery = fieldType . termQuery ( queryValue , context ) ; assertEquals ( expectedTermQuery , query ) ; } if ( query instanceof BooleanQuery ) { BooleanQuery bq = ( BooleanQuery ) query ; if ( queryBuilder . minimumShouldMatch ( ) ! = null ) { int optionalClauses = <int> ; for ( BooleanClause c : bq . clauses ( ) ) { if ( c . getOccur ( ) = = BooleanClause . Occur . SHOULD ) { optionalClauses + + ; } } int msm = Queries . calculateMinShouldMatch ( optionalClauses , queryBuilder . minimumShouldMatch ( ) ) ; assertThat ( bq . getMinimumNumberShouldMatch ( ) , equalTo ( msm ) ) ; } if ( queryBuilder . analyzer ( ) = = null & & queryBuilder . value ( ) . toString ( ) . length ( ) > <int> ) { assertEquals ( bq . clauses ( ) . size ( ) , queryBuilder . value ( ) . toString ( ) . split ( <str> ) . length ) ; } } if ( query instanceof ExtendedCommonTermsQuery ) { assertTrue ( queryBuilder . cutoffFrequency ( ) ! = null ) ; ExtendedCommonTermsQuery ectq = ( ExtendedCommonTermsQuery ) query ; assertEquals ( queryBuilder . cutoffFrequency ( ) , ectq . getMaxTermFrequency ( ) , Float . MIN_VALUE ) ; } if ( query instanceof FuzzyQuery ) { assertTrue ( queryBuilder . fuzziness ( ) ! = null ) ; FuzzyQuery fuzzyQuery = ( FuzzyQuery ) query ; String originalTermLc = queryBuilder . value ( ) . toString ( ) . toLowerCase ( Locale . ROOT ) ; String actualTermLc = fuzzyQuery . getTerm ( ) . text ( ) . toLowerCase ( Locale . ROOT ) ; assertThat ( actualTermLc , equalTo ( originalTermLc ) ) ; assertThat ( queryBuilder . prefixLength ( ) , equalTo ( fuzzyQuery . getPrefixLength ( ) ) ) ; assertThat ( queryBuilder . fuzzyTranspositions ( ) , equalTo ( fuzzyQuery . getTranspositions ( ) ) ) ; } } public void testIllegalValues ( ) { try { new MatchQueryBuilder ( null , <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { new MatchQueryBuilder ( <str> , null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } MatchQueryBuilder matchQuery = new MatchQueryBuilder ( <str> , <str> ) ; try { matchQuery . prefixLength ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { matchQuery . maxExpansions ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { matchQuery . operator ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { matchQuery . type ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { matchQuery . zeroTermsQuery ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } public void testBadAnalyzer ( ) throws IOException { MatchQueryBuilder matchQuery = new MatchQueryBuilder ( <str> , <str> ) ; matchQuery . analyzer ( <str> ) ; try { matchQuery . toQuery ( createShardContext ( ) ) ; fail ( <str> ) ; } catch ( QueryShardException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testPhrasePrefixMatchQuery ( ) throws IOException { String json1 = <str> + <str> + <str> + <str> + <str> ; String expected = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; MatchQueryBuilder qb = ( MatchQueryBuilder ) parseQuery ( json1 ) ; checkGeneratedJson ( expected , qb ) ; String json2 = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; qb = ( MatchQueryBuilder ) parseQuery ( json2 ) ; checkGeneratedJson ( expected , qb ) ; String json3 = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; expected = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; qb = ( MatchQueryBuilder ) parseQuery ( json3 ) ; checkGeneratedJson ( expected , qb ) ; } public void testSimpleMatchQuery ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; MatchQueryBuilder qb = ( MatchQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , qb ) ; assertEquals ( json , <str> , qb . value ( ) ) ; assertEquals ( json , Operator . AND , qb . operator ( ) ) ; } } 
