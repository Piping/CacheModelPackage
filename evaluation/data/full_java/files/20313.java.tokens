package io . netty . channel . socket . nio ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPromise ; import io . netty . channel . EventLoop ; import io . netty . channel . FileRegion ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . nio . AbstractNioByteChannel ; import io . netty . channel . socket . DefaultSocketChannelConfig ; import io . netty . channel . socket . ServerSocketChannel ; import io . netty . channel . socket . SocketChannelConfig ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . netty . util . internal . OneTimeTask ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketAddress ; import java . net . SocketException ; import java . nio . ByteBuffer ; import java . nio . channels . SelectionKey ; import java . nio . channels . SocketChannel ; import java . nio . channels . spi . SelectorProvider ; import java . util . concurrent . Executor ; public class NioSocketChannel extends AbstractNioByteChannel implements io . netty . channel . socket . SocketChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( false , <int> ) ; private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider . provider ( ) ; private static SocketChannel newSocket ( SelectorProvider provider ) { try { return provider . openSocketChannel ( ) ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } } private final SocketChannelConfig config ; public NioSocketChannel ( ) { this ( DEFAULT_SELECTOR_PROVIDER ) ; } public NioSocketChannel ( SelectorProvider provider ) { this ( newSocket ( provider ) ) ; } public NioSocketChannel ( SocketChannel socket ) { this ( null , socket ) ; } public NioSocketChannel ( Channel parent , SocketChannel socket ) { super ( parent , socket ) ; config = new NioSocketChannelConfig ( this , socket . socket ( ) ) ; } @Override public ServerSocketChannel parent ( ) { return ( ServerSocketChannel ) super . parent ( ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public SocketChannelConfig config ( ) { return config ; } @Override protected SocketChannel javaChannel ( ) { return ( SocketChannel ) super . javaChannel ( ) ; } @Override public boolean isActive ( ) { SocketChannel ch = javaChannel ( ) ; return ch . isOpen ( ) & & ch . isConnected ( ) ; } @Override public boolean isInputShutdown ( ) { return super . isInputShutdown ( ) ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } @Override public boolean isOutputShutdown ( ) { return javaChannel ( ) . socket ( ) . isOutputShutdown ( ) | | ! isActive ( ) ; } @Override public ChannelFuture shutdownOutput ( ) { return shutdownOutput ( newPromise ( ) ) ; } @Override public ChannelFuture shutdownOutput ( final ChannelPromise promise ) { Executor closeExecutor = ( ( NioSocketChannelUnsafe ) unsafe ( ) ) . closeExecutor ( ) ; if ( closeExecutor ! = null ) { closeExecutor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { shutdownOutput0 ( promise ) ; } } ) ; } else { EventLoop loop = eventLoop ( ) ; if ( loop . inEventLoop ( ) ) { shutdownOutput0 ( promise ) ; } else { loop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { shutdownOutput0 ( promise ) ; } } ) ; } } return promise ; } private void shutdownOutput0 ( final ChannelPromise promise ) { try { javaChannel ( ) . socket ( ) . shutdownOutput ( ) ; promise . setSuccess ( ) ; } catch ( Throwable t ) { promise . setFailure ( t ) ; } } @Override protected SocketAddress localAddress0 ( ) { return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { return javaChannel ( ) . socket ( ) . getRemoteSocketAddress ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { javaChannel ( ) . socket ( ) . bind ( localAddress ) ; } @Override protected boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( localAddress ! = null ) { javaChannel ( ) . socket ( ) . bind ( localAddress ) ; } boolean success = false ; try { boolean connected = javaChannel ( ) . connect ( remoteAddress ) ; if ( ! connected ) { selectionKey ( ) . interestOps ( SelectionKey . OP_CONNECT ) ; } success = true ; return connected ; } finally { if ( ! success ) { doClose ( ) ; } } } @Override protected void doFinishConnect ( ) throws Exception { if ( ! javaChannel ( ) . finishConnect ( ) ) { throw new Error ( ) ; } } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected void doClose ( ) throws Exception { super . doClose ( ) ; javaChannel ( ) . close ( ) ; } @Override protected int doReadBytes ( ByteBuf byteBuf ) throws Exception { final RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; allocHandle . attemptedBytesRead ( byteBuf . writableBytes ( ) ) ; return byteBuf . writeBytes ( javaChannel ( ) , allocHandle . attemptedBytesRead ( ) ) ; } @Override protected int doWriteBytes ( ByteBuf buf ) throws Exception { final int expectedWrittenBytes = buf . readableBytes ( ) ; return buf . readBytes ( javaChannel ( ) , expectedWrittenBytes ) ; } @Override protected long doWriteFileRegion ( FileRegion region ) throws Exception { final long position = region . transfered ( ) ; return region . transferTo ( javaChannel ( ) , position ) ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { for ( ; ; ) { int size = in . size ( ) ; if ( size = = <int> ) { clearOpWrite ( ) ; break ; } long writtenBytes = <int> ; boolean done = false ; boolean setOpWrite = false ; ByteBuffer [ ] nioBuffers = in . nioBuffers ( ) ; int nioBufferCnt = in . nioBufferCount ( ) ; long expectedWrittenBytes = in . nioBufferSize ( ) ; SocketChannel ch = javaChannel ( ) ; switch ( nioBufferCnt ) { case <int> : super . doWrite ( in ) ; return ; case <int> : ByteBuffer nioBuffer = nioBuffers [ <int> ] ; for ( int i = config ( ) . getWriteSpinCount ( ) - <int> ; i > = <int> ; i - - ) { final int localWrittenBytes = ch . write ( nioBuffer ) ; if ( localWrittenBytes = = <int> ) { setOpWrite = true ; break ; } expectedWrittenBytes - = localWrittenBytes ; writtenBytes + = localWrittenBytes ; if ( expectedWrittenBytes = = <int> ) { done = true ; break ; } } break ; default : for ( int i = config ( ) . getWriteSpinCount ( ) - <int> ; i > = <int> ; i - - ) { final long localWrittenBytes = ch . write ( nioBuffers , <int> , nioBufferCnt ) ; if ( localWrittenBytes = = <int> ) { setOpWrite = true ; break ; } expectedWrittenBytes - = localWrittenBytes ; writtenBytes + = localWrittenBytes ; if ( expectedWrittenBytes = = <int> ) { done = true ; break ; } } break ; } in . removeBytes ( writtenBytes ) ; if ( ! done ) { incompleteWrite ( setOpWrite ) ; break ; } } } @Override protected AbstractNioUnsafe newUnsafe ( ) { return new NioSocketChannelUnsafe ( ) ; } private final class NioSocketChannelUnsafe extends NioByteUnsafe { @Override protected Executor closeExecutor ( ) { try { if ( javaChannel ( ) . isOpen ( ) & & config ( ) . getSoLinger ( ) > <int> ) { return GlobalEventExecutor . INSTANCE ; } } catch ( Throwable ignore ) { } return null ; } } private final class NioSocketChannelConfig extends DefaultSocketChannelConfig { private NioSocketChannelConfig ( NioSocketChannel channel , Socket javaSocket ) { super ( channel , javaSocket ) ; } @Override protected void autoReadCleared ( ) { setReadPending ( false ) ; } } } 
