package org . elasticsearch . index . shard ; import java . io . IOException ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . NodeServicesProvider ; import org . elasticsearch . index . cache . IndexCache ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . engine . EngineConfig ; import org . elasticsearch . index . engine . EngineFactory ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . merge . MergeStats ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . index . translog . TranslogStats ; public final class ShadowIndexShard extends IndexShard { public ShadowIndexShard ( ShardId shardId , IndexSettings indexSettings , ShardPath path , Store store , IndexCache indexCache , MapperService mapperService , SimilarityService similarityService , IndexFieldDataService indexFieldDataService , @Nullable EngineFactory engineFactory , IndexEventListener indexEventListener , IndexSearcherWrapper wrapper , NodeServicesProvider provider ) throws IOException { super ( shardId , indexSettings , path , store , indexCache , mapperService , similarityService , indexFieldDataService , engineFactory , indexEventListener , wrapper , provider ) ; } @Override public void updateRoutingEntry ( ShardRouting newRouting , boolean persistState ) { if ( newRouting . primary ( ) = = true ) { throw new IllegalStateException ( <str> ) ; } super . updateRoutingEntry ( newRouting , persistState ) ; } @Override public MergeStats mergeStats ( ) { return new MergeStats ( ) ; } @Override public boolean canIndex ( ) { return false ; } @Override protected Engine newEngine ( boolean skipInitialTranslogRecovery , EngineConfig config ) { assert this . shardRouting . primary ( ) = = false ; assert skipInitialTranslogRecovery : <str> ; config . setCreate ( false ) ; return engineFactory . newReadOnlyEngine ( config ) ; } @Override public boolean shouldFlush ( ) { return false ; } public boolean allowsPrimaryPromotion ( ) { return false ; } @Override public TranslogStats translogStats ( ) { return null ; } } 
