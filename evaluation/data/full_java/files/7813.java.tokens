package org . elasticsearch . cluster . allocation ; import com . carrotsearch . hppc . ObjectIntHashMap ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . decider . AwarenessAllocationDecider ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import java . util . List ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> , minNumDataNodes = <int> ) public class AwarenessAllocationIT extends ESIntegTestCase { private final ESLogger logger = Loggers . getLogger ( AwarenessAllocationIT . class ) ; @Override protected int numberOfReplicas ( ) { return <int> ; } public void testSimpleAwareness ( ) throws Exception { Settings commonSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; NumShards test1 = getNumShards ( <str> ) ; NumShards test2 = getNumShards ( <str> ) ; final int totalPrimaries = test1 . numPrimaries + test2 . numPrimaries ; ensureGreen ( ) ; logger . info ( <str> ) ; final String node3 = internalCluster ( ) . startNode ( Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) ) ; assertThat ( awaitBusy ( ( ) - > { logger . info ( <str> ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . get ( ) ; if ( clusterHealth . isTimedOut ( ) ) { return false ; } logger . info ( <str> ) ; ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; ObjectIntHashMap < String > counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } return counts . get ( node3 ) = = totalPrimaries ; } , <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } public void testAwarenessZones ( ) throws Exception { Settings commonSettings = Settings . settingsBuilder ( ) . put ( AwarenessAllocationDecider . CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP + <str> , <str> ) . put ( AwarenessAllocationDecider . CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES , <str> ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . put ( ZenDiscovery . SETTING_JOIN_TIMEOUT , <str> ) . build ( ) ; logger . info ( <str> ) ; List < String > nodes = internalCluster ( ) . startNodesAsync ( Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) , Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) , Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) , Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; String A_0 = nodes . get ( <int> ) ; String B_0 = nodes . get ( <int> ) ; String B_1 = nodes . get ( <int> ) ; String A_1 = nodes . get ( <int> ) ; logger . info ( <str> ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; ObjectIntHashMap < String > counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } assertThat ( counts . get ( A_1 ) , anyOf ( equalTo ( <int> ) , equalTo ( <int> ) ) ) ; assertThat ( counts . get ( B_1 ) , anyOf ( equalTo ( <int> ) , equalTo ( <int> ) ) ) ; assertThat ( counts . get ( A_0 ) , anyOf ( equalTo ( <int> ) , equalTo ( <int> ) ) ) ; assertThat ( counts . get ( B_0 ) , anyOf ( equalTo ( <int> ) , equalTo ( <int> ) ) ) ; } public void testAwarenessZonesIncrementalNodes ( ) throws Exception { Settings commonSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <str> ) . build ( ) ; logger . info ( <str> ) ; List < String > nodes = internalCluster ( ) . startNodesAsync ( Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) , Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; String A_0 = nodes . get ( <int> ) ; String B_0 = nodes . get ( <int> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; ObjectIntHashMap < String > counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } assertThat ( counts . get ( A_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_0 ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; String B_1 = internalCluster ( ) . startNode ( Settings . settingsBuilder ( ) . put ( commonSettings ) . put ( <str> , <str> ) . build ( ) ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForActiveShards ( <int> ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } assertThat ( counts . get ( A_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_1 ) , equalTo ( <int> ) ) ; String noZoneNode = internalCluster ( ) . startNode ( ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForActiveShards ( <int> ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } assertThat ( counts . get ( A_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_1 ) , equalTo ( <int> ) ) ; assertThat ( counts . containsKey ( noZoneNode ) , equalTo ( false ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . setWaitForNodes ( <str> ) . setWaitForActiveShards ( <int> ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; counts = new ObjectIntHashMap < > ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { counts . addTo ( clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) , <int> ) ; } } } assertThat ( counts . get ( A_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_0 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( B_1 ) , equalTo ( <int> ) ) ; assertThat ( counts . get ( noZoneNode ) , equalTo ( <int> ) ) ; } } 
