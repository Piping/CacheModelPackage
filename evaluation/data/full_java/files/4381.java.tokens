package org . eclipse . debug . internal . ui . viewers . breadcrumb ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . jface . viewers . DoubleClickEvent ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ITreePathContentProvider ; import org . eclipse . jface . viewers . ITreePathLabelProvider ; import org . eclipse . jface . viewers . OpenEvent ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . ViewerLabel ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . MenuDetectEvent ; import org . eclipse . swt . events . MenuDetectListener ; import org . eclipse . swt . events . TraverseEvent ; import org . eclipse . swt . events . TraverseListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Widget ; public abstract class BreadcrumbViewer extends StructuredViewer { private static final boolean IS_GTK = <str> . equals ( SWT . getPlatform ( ) ) ; private final int fStyle ; private final Composite fContainer ; private final ArrayList < BreadcrumbItem > fBreadcrumbItems ; private final ListenerList fMenuListeners ; private Image fGradientBackground ; private BreadcrumbItem fSelectedItem ; public BreadcrumbViewer ( Composite parent , int style ) { fStyle = style ; fBreadcrumbItems = new ArrayList < BreadcrumbItem > ( ) ; fMenuListeners = new ListenerList ( ) ; fContainer = new Composite ( parent , SWT . NONE ) ; GridData layoutData = new GridData ( SWT . FILL , SWT . TOP , true , false ) ; fContainer . setLayoutData ( layoutData ) ; fContainer . addTraverseListener ( new TraverseListener ( ) { @Override public void keyTraversed ( TraverseEvent e ) { e . doit = true ; } } ) ; fContainer . setBackgroundMode ( SWT . INHERIT_DEFAULT ) ; fContainer . addListener ( SWT . Resize , new Listener ( ) { @Override public void handleEvent ( Event event ) { int height = fContainer . getClientArea ( ) . height ; if ( fGradientBackground = = null | | fGradientBackground . getBounds ( ) . height ! = height ) { Image image = height = = <int> ? null : createGradientImage ( height , event . display ) ; fContainer . setBackgroundImage ( image ) ; if ( fGradientBackground ! = null ) { fGradientBackground . dispose ( ) ; } fGradientBackground = image ; } } } ) ; hookControl ( fContainer ) ; int columns = <int> ; if ( ( SWT . VERTICAL & style ) ! = <int> ) { columns = <int> ; } GridLayout gridLayout = new GridLayout ( columns , false ) ; gridLayout . marginWidth = <int> ; gridLayout . marginHeight = <int> ; gridLayout . verticalSpacing = <int> ; gridLayout . horizontalSpacing = <int> ; fContainer . setLayout ( gridLayout ) ; fContainer . addListener ( SWT . Resize , new Listener ( ) { @Override public void handleEvent ( Event event ) { updateSize ( ) ; fContainer . layout ( true , true ) ; } } ) ; } int getStyle ( ) { return fStyle ; } protected abstract Control createDropDown ( Composite parent , IBreadcrumbDropDownSite site , TreePath path ) ; @Override public Control getControl ( ) { return fContainer ; } @Override public void reveal ( Object element ) { } public void setFocus ( ) { fContainer . setFocus ( ) ; if ( fSelectedItem ! = null ) { fSelectedItem . setFocus ( true ) ; } else { if ( fBreadcrumbItems . size ( ) = = <int> ) { return ; } BreadcrumbItem item = fBreadcrumbItems . get ( fBreadcrumbItems . size ( ) - <int> ) ; item . setFocus ( true ) ; } } public boolean isDropDownOpen ( ) { for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem item = fBreadcrumbItems . get ( i ) ; if ( item . isMenuShown ( ) ) { return true ; } } return false ; } public Shell getDropDownShell ( ) { for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem item = fBreadcrumbItems . get ( i ) ; if ( item . isMenuShown ( ) ) { return item . getDropDownShell ( ) ; } } return null ; } public void addMenuDetectListener ( MenuDetectListener listener ) { fMenuListeners . add ( listener ) ; } public void removeMenuDetectListener ( MenuDetectListener listener ) { fMenuListeners . remove ( listener ) ; } @Override protected void assertContentProviderType ( IContentProvider provider ) { super . assertContentProviderType ( provider ) ; Assert . isTrue ( provider instanceof ITreePathContentProvider ) ; } @Override protected void inputChanged ( final Object input , Object oldInput ) { if ( fContainer . isDisposed ( ) ) { return ; } disableRedraw ( ) ; try { preservingSelection ( new Runnable ( ) { @Override public void run ( ) { buildItemChain ( input ) ; } } ) ; } finally { enableRedraw ( ) ; } } @Override protected Widget doFindInputItem ( Object element ) { if ( element = = null ) { return null ; } if ( element = = getInput ( ) | | element . equals ( getInput ( ) ) ) { return doFindItem ( element ) ; } return null ; } @Override protected Widget doFindItem ( Object element ) { if ( element = = null ) { return null ; } for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem item = fBreadcrumbItems . get ( i ) ; if ( item . getData ( ) = = element | | element . equals ( item . getData ( ) ) ) { return item ; } } return null ; } @Override protected void doUpdateItem ( Widget widget , Object element , boolean fullMap ) { myDoUpdateItem ( widget , element , fullMap ) ; } private boolean myDoUpdateItem ( Widget widget , Object element , boolean fullMap ) { if ( widget instanceof BreadcrumbItem ) { final BreadcrumbItem item = ( BreadcrumbItem ) widget ; if ( fullMap ) { associate ( element , item ) ; } else { Object data = item . getData ( ) ; if ( data ! = null ) { unmapElement ( data , item ) ; } item . setData ( element ) ; mapElement ( element , item ) ; } refreshItem ( item ) ; } return false ; } @Override public ISelection getSelection ( ) { Control control = getControl ( ) ; if ( control = = null | | control . isDisposed ( ) ) { return TreeSelection . EMPTY ; } if ( fSelectedItem ! = null ) { TreePath path = getTreePathFromItem ( fSelectedItem ) ; if ( path ! = null ) { return new TreeSelection ( new TreePath [ ] { path } ) ; } } return TreeSelection . EMPTY ; } protected TreePath getTreePathFromItem ( BreadcrumbItem item ) { List < Object > elements = new ArrayList < Object > ( fBreadcrumbItems . size ( ) ) ; for ( int i = <int> ; i < fBreadcrumbItems . size ( ) ; i + + ) { elements . add ( fBreadcrumbItems . get ( i ) . getData ( ) ) ; if ( fBreadcrumbItems . get ( i ) . equals ( item ) ) { return new TreePath ( elements . toArray ( ) ) ; } } return null ; } @Override protected List getSelectionFromWidget ( ) { if ( fSelectedItem = = null ) { return Collections . EMPTY_LIST ; } if ( fSelectedItem . getData ( ) = = null ) { return Collections . EMPTY_LIST ; } ArrayList < Object > result = new ArrayList < Object > ( ) ; result . add ( fSelectedItem . getData ( ) ) ; return result ; } @Override protected void internalRefresh ( Object element ) { disableRedraw ( ) ; try { boolean layoutChanged = false ; BreadcrumbItem item = ( BreadcrumbItem ) doFindItem ( element ) ; if ( item = = null | | element ! = null & & element . equals ( getInput ( ) ) ) { for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem item1 = fBreadcrumbItems . get ( i ) ; layoutChanged = refreshItem ( item1 ) | | layoutChanged ; } } else { layoutChanged = refreshItem ( item ) | | layoutChanged ; } if ( layoutChanged ) { updateSize ( ) ; fContainer . layout ( true , true ) ; } } finally { enableRedraw ( ) ; } } @Override protected void setSelectionToWidget ( List l , boolean reveal ) { BreadcrumbItem focusItem = null ; for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem item = fBreadcrumbItems . get ( i ) ; if ( item . hasFocus ( ) ) { focusItem = item ; } item . setSelected ( false ) ; } if ( l = = null ) { l = Collections . EMPTY_LIST ; } fSelectedItem = null ; for ( Iterator < Object > iterator = l . iterator ( ) ; iterator . hasNext ( ) ; ) { Object element = iterator . next ( ) ; BreadcrumbItem item = ( BreadcrumbItem ) doFindItem ( element ) ; if ( item ! = null ) { item . setSelected ( true ) ; fSelectedItem = item ; if ( item = = focusItem ) { focusItem = null ; } } } if ( fSelectedItem ! = null & & focusItem ! = null ) { focusItem . setFocus ( false ) ; } } void selectItem ( BreadcrumbItem item ) { if ( fSelectedItem ! = null ) { fSelectedItem . setSelected ( false ) ; } fSelectedItem = item ; setSelectionToWidget ( getSelection ( ) , false ) ; setFocus ( ) ; fireSelectionChanged ( new SelectionChangedEvent ( this , getSelection ( ) ) ) ; } int getItemCount ( ) { return fBreadcrumbItems . size ( ) ; } BreadcrumbItem getItem ( int index ) { return fBreadcrumbItems . get ( index ) ; } int getIndexOfItem ( BreadcrumbItem item ) { for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem pItem = fBreadcrumbItems . get ( i ) ; if ( pItem = = item ) { return i ; } } return - <int> ; } void fireDoubleClick ( ) { fireDoubleClick ( new DoubleClickEvent ( this , getSelection ( ) ) ) ; } void fireOpen ( ) { fireOpen ( new OpenEvent ( this , getSelection ( ) ) ) ; } void fireMenuSelection ( ISelection selection ) { fireOpen ( new OpenEvent ( this , selection ) ) ; } void fireMenuDetect ( MenuDetectEvent event ) { Object [ ] listeners = fMenuListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { ( ( MenuDetectListener ) listeners [ i ] ) . menuDetected ( event ) ; } } void doTraverse ( boolean next ) { if ( fSelectedItem = = null ) { return ; } int index = fBreadcrumbItems . indexOf ( fSelectedItem ) ; if ( next ) { if ( index = = fBreadcrumbItems . size ( ) - <int> ) { BreadcrumbItem current = fBreadcrumbItems . get ( index ) ; current . openDropDownMenu ( ) ; current . getDropDownShell ( ) . setFocus ( ) ; } else { BreadcrumbItem nextItem = fBreadcrumbItems . get ( index + <int> ) ; selectItem ( nextItem ) ; } } else { if ( index = = <int> ) { BreadcrumbItem root = fBreadcrumbItems . get ( index ) ; root . openDropDownMenu ( ) ; root . getDropDownShell ( ) . setFocus ( ) ; } else { selectItem ( fBreadcrumbItems . get ( index - <int> ) ) ; } } } private void buildItemChain ( Object input ) { if ( fBreadcrumbItems . size ( ) > <int> ) { BreadcrumbItem last = fBreadcrumbItems . get ( fBreadcrumbItems . size ( ) - <int> ) ; last . setIsLastItem ( false ) ; } int index = <int> ; boolean updateLayout = false ; if ( input ! = null ) { ITreePathContentProvider contentProvider = ( ITreePathContentProvider ) getContentProvider ( ) ; TreePath path = new TreePath ( new Object [ <int> ] ) ; Object [ ] children = contentProvider . getElements ( input ) ; Object element = children ! = null & & children . length ! = <int> ? children [ <int> ] : null ; while ( element ! = null ) { path = path . createChildPath ( element ) ; children = contentProvider . getChildren ( path ) ; if ( ( getStyle ( ) & SWT . VERTICAL ) = = <int> | | children = = null | | children . length = = <int> ) { updateLayout = updateOrCreateItem ( index + + , path , element ) | | updateLayout ; } if ( children ! = null & & children . length ! = <int> ) { element = children [ <int> ] ; } else { break ; } } } BreadcrumbItem last = null ; if ( index < = fBreadcrumbItems . size ( ) ) { last = ( fBreadcrumbItems . get ( index - <int> ) ) ; last . setIsLastItem ( true ) ; } while ( index < fBreadcrumbItems . size ( ) ) { updateLayout = true ; BreadcrumbItem item = fBreadcrumbItems . remove ( fBreadcrumbItems . size ( ) - <int> ) ; if ( item . hasFocus ( ) & & last ! = null ) { last . setFocus ( true ) ; } if ( item = = fSelectedItem ) { selectItem ( null ) ; } if ( item . getData ( ) ! = null ) { unmapElement ( item . getData ( ) ) ; } item . dispose ( ) ; } if ( updateLayout ) { updateSize ( ) ; fContainer . layout ( true , true ) ; } } private boolean refreshItem ( BreadcrumbItem item ) { boolean layoutChanged = false ; TreePath path = getTreePathFromItem ( item ) ; ViewerLabel label = new ViewerLabel ( item . getText ( ) , item . getImage ( ) ) ; ( ( ITreePathLabelProvider ) getLabelProvider ( ) ) . updateLabel ( label , path ) ; if ( label . hasNewText ( ) ) { item . setText ( label . getText ( ) ) ; layoutChanged = true ; } if ( label . hasNewImage ( ) ) { item . setImage ( label . getImage ( ) ) ; layoutChanged = true ; } if ( label . hasNewTooltipText ( ) ) { item . setToolTip ( label . getTooltipText ( ) ) ; } return layoutChanged ; } private boolean updateOrCreateItem ( int index , TreePath path , Object element ) { BreadcrumbItem item ; if ( fBreadcrumbItems . size ( ) > index ) { item = fBreadcrumbItems . get ( index ) ; if ( item . getData ( ) ! = null ) { unmapElement ( item . getData ( ) ) ; } } else { item = new BreadcrumbItem ( this , fContainer ) ; fBreadcrumbItems . add ( item ) ; } boolean updateLayout = false ; if ( equals ( element , item . getData ( ) ) ) { item . setPath ( path ) ; updateLayout = myDoUpdateItem ( item , element , false ) ; } else { item . setData ( element ) ; item . setPath ( path ) ; mapElement ( element , item ) ; updateLayout = refreshItem ( item ) ; } return updateLayout ; } private boolean updateSize ( ) { int width = fContainer . getClientArea ( ) . width ; int currentWidth = getCurrentWidth ( ) ; boolean requiresLayout = false ; if ( currentWidth > width ) { int index = <int> ; while ( currentWidth > width & & index < fBreadcrumbItems . size ( ) - <int> ) { BreadcrumbItem viewer = fBreadcrumbItems . get ( index ) ; if ( viewer . isShowText ( ) ) { viewer . setShowText ( false ) ; currentWidth = getCurrentWidth ( ) ; requiresLayout = true ; } index + + ; } } else if ( currentWidth < width ) { int index = fBreadcrumbItems . size ( ) - <int> ; while ( currentWidth < width & & index > = <int> ) { BreadcrumbItem viewer = fBreadcrumbItems . get ( index ) ; if ( ! viewer . isShowText ( ) ) { viewer . setShowText ( true ) ; currentWidth = getCurrentWidth ( ) ; if ( currentWidth > width ) { viewer . setShowText ( false ) ; index = <int> ; } else { requiresLayout = true ; } } index - - ; } } return requiresLayout ; } private int getCurrentWidth ( ) { int result = <int> ; for ( int i = <int> , size = fBreadcrumbItems . size ( ) ; i < size ; i + + ) { BreadcrumbItem viewer = fBreadcrumbItems . get ( i ) ; result + = viewer . getWidth ( ) ; } return result ; } private void enableRedraw ( ) { if ( IS_GTK ) { return ; } fContainer . setRedraw ( true ) ; } private void disableRedraw ( ) { if ( IS_GTK ) { return ; } fContainer . setRedraw ( false ) ; } private Image createGradientImage ( int height , Display display ) { int width = <int> ; Image result = new Image ( display , width , height ) ; GC gc = new GC ( result ) ; Color colorC = createColor ( SWT . COLOR_WIDGET_BACKGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; Color colorD = createColor ( SWT . COLOR_WIDGET_BACKGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; Color colorE = createColor ( SWT . COLOR_WIDGET_BACKGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; Color colorF = createColor ( SWT . COLOR_WIDGET_BACKGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; Color colorG = createColor ( SWT . COLOR_WIDGET_BACKGROUND , SWT . COLOR_WHITE , <int> , display ) ; Color colorH = createColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; try { drawLine ( width , <int> , colorC , gc ) ; drawLine ( width , <int> , colorC , gc ) ; gc . setForeground ( colorD ) ; gc . setBackground ( colorE ) ; gc . fillGradientRectangle ( <int> , <int> , width , <int> + <int> , true ) ; gc . setBackground ( colorE ) ; gc . fillRectangle ( <int> , <int> + <int> , width , height - <int> ) ; drawLine ( width , height - <int> , colorF , gc ) ; drawLine ( width , height - <int> , colorG , gc ) ; drawLine ( width , height - <int> , colorH , gc ) ; } finally { gc . dispose ( ) ; colorC . dispose ( ) ; colorD . dispose ( ) ; colorE . dispose ( ) ; colorF . dispose ( ) ; colorG . dispose ( ) ; colorH . dispose ( ) ; } return result ; } private void drawLine ( int width , int position , Color color , GC gc ) { gc . setForeground ( color ) ; gc . drawLine ( <int> , position , width , position ) ; } private Color createColor ( int color1 , int color2 , int ratio , Display display ) { RGB rgb1 = display . getSystemColor ( color1 ) . getRGB ( ) ; RGB rgb2 = display . getSystemColor ( color2 ) . getRGB ( ) ; RGB blend = blend ( rgb2 , rgb1 , ratio ) ; return new Color ( display , blend ) ; } public static RGB blend ( RGB c1 , RGB c2 , int ratio ) { int r = blend ( c1 . red , c2 . red , ratio ) ; int g = blend ( c1 . green , c2 . green , ratio ) ; int b = blend ( c1 . blue , c2 . blue , ratio ) ; return new RGB ( r , g , b ) ; } private static int blend ( int v1 , int v2 , int ratio ) { int b = ( ratio * v1 + ( <int> - ratio ) * v2 ) / <int> ; return Math . min ( <int> , b ) ; } @Override protected void handleDispose ( DisposeEvent event ) { if ( fGradientBackground ! = null ) { fGradientBackground . dispose ( ) ; fGradientBackground = null ; } if ( fBreadcrumbItems ! = null ) { for ( BreadcrumbItem item : fBreadcrumbItems ) { item . dispose ( ) ; } } super . handleDispose ( event ) ; } } 
