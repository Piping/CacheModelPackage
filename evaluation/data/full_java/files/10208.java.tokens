package com . google . common . hash ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . security . MessageDigest ; import java . util . Arrays ; import java . util . Random ; public class HashCodeBenchmark { private static final Random random = new Random ( <int> ) ; @Param ( { <str> , <str> } ) private int size ; @Param WhereToDiffer whereToDiffer ; @Param EqualsImplementation equalsImpl ; private enum WhereToDiffer { ONE_PERCENT_IN , LAST_BYTE , NOT_AT_ALL ; } private enum EqualsImplementation { ANDING_BOOLEANS { @Override boolean doEquals ( byte [ ] a , byte [ ] b ) { if ( a . length ! = b . length ) { return false ; } boolean areEqual = true ; for ( int i = <int> ; i < a . length ; i + + ) { areEqual & = ( a [ i ] = = b [ i ] ) ; } return areEqual ; } } , XORING_TO_BYTE { @Override boolean doEquals ( byte [ ] a , byte [ ] b ) { if ( a . length ! = b . length ) { return false ; } byte result = <int> ; for ( int i = <int> ; i < a . length ; i + + ) { result = ( byte ) ( result | a [ i ] ^ b [ i ] ) ; } return ( result = = <int> ) ; } } , XORING_TO_INT { @Override boolean doEquals ( byte [ ] a , byte [ ] b ) { if ( a . length ! = b . length ) { return false ; } int result = <int> ; for ( int i = <int> ; i < a . length ; i + + ) { result | = a [ i ] ^ b [ i ] ; } return ( result = = <int> ) ; } } , MESSAGE_DIGEST_IS_EQUAL { @Override boolean doEquals ( byte [ ] a , byte [ ] b ) { return MessageDigest . isEqual ( a , b ) ; } } , ARRAYS_EQUALS { @Override boolean doEquals ( byte [ ] a , byte [ ] b ) { return Arrays . equals ( a , b ) ; } } ; abstract boolean doEquals ( byte [ ] a , byte [ ] b ) ; } private byte [ ] testBytesA ; private byte [ ] testBytesB ; @BeforeExperiment void setUp ( ) { testBytesA = new byte [ size ] ; random . nextBytes ( testBytesA ) ; testBytesB = Arrays . copyOf ( testBytesA , size ) ; int indexToDifferAt = - <int> ; switch ( whereToDiffer ) { case ONE_PERCENT_IN : indexToDifferAt = ( int ) ( size * <float> ) ; break ; case LAST_BYTE : indexToDifferAt = size - <int> ; break ; case NOT_AT_ALL : } if ( indexToDifferAt ! = - <int> ) { testBytesA [ indexToDifferAt ] = ( byte ) ( testBytesB [ indexToDifferAt ] - <int> ) ; } } @Benchmark boolean hashFunction ( int reps ) { boolean result = true ; for ( int i = <int> ; i < reps ; i + + ) { result ^ = equalsImpl . doEquals ( testBytesA , testBytesB ) ; } return result ; } } 
