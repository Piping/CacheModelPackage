package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . base . Supplier ; import java . security . Key ; import java . security . MessageDigest ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import java . util . zip . Adler32 ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; import javax . crypto . spec . SecretKeySpec ; @Beta @CheckReturnValue public final class Hashing { public static HashFunction goodFastHash ( int minimumBits ) { int bits = checkPositiveAndMakeMultipleOf32 ( minimumBits ) ; if ( bits = = <int> ) { return Murmur3_32Holder . GOOD_FAST_HASH_FUNCTION_32 ; } if ( bits < = <int> ) { return Murmur3_128Holder . GOOD_FAST_HASH_FUNCTION_128 ; } int hashFunctionsNeeded = ( bits + <int> ) / <int> ; HashFunction [ ] hashFunctions = new HashFunction [ hashFunctionsNeeded ] ; hashFunctions [ <int> ] = Murmur3_128Holder . GOOD_FAST_HASH_FUNCTION_128 ; int seed = GOOD_FAST_HASH_SEED ; for ( int i = <int> ; i < hashFunctionsNeeded ; i + + ) { seed + = <int> ; hashFunctions [ i ] = murmur3_128 ( seed ) ; } return new ConcatenatedHashFunction ( hashFunctions ) ; } private static final int GOOD_FAST_HASH_SEED = ( int ) System . currentTimeMillis ( ) ; public static HashFunction murmur3_32 ( int seed ) { return new Murmur3_32HashFunction ( seed ) ; } public static HashFunction murmur3_32 ( ) { return Murmur3_32Holder . MURMUR3_32 ; } private static class Murmur3_32Holder { static final HashFunction MURMUR3_32 = new Murmur3_32HashFunction ( <int> ) ; static final HashFunction GOOD_FAST_HASH_FUNCTION_32 = murmur3_32 ( GOOD_FAST_HASH_SEED ) ; } public static HashFunction murmur3_128 ( int seed ) { return new Murmur3_128HashFunction ( seed ) ; } public static HashFunction murmur3_128 ( ) { return Murmur3_128Holder . MURMUR3_128 ; } private static class Murmur3_128Holder { static final HashFunction MURMUR3_128 = new Murmur3_128HashFunction ( <int> ) ; static final HashFunction GOOD_FAST_HASH_FUNCTION_128 = murmur3_128 ( GOOD_FAST_HASH_SEED ) ; } public static HashFunction sipHash24 ( ) { return SipHash24Holder . SIP_HASH_24 ; } private static class SipHash24Holder { static final HashFunction SIP_HASH_24 = new SipHashFunction ( <int> , <int> , <hex> , <hex> ) ; } public static HashFunction sipHash24 ( long k0 , long k1 ) { return new SipHashFunction ( <int> , <int> , k0 , k1 ) ; } public static HashFunction md5 ( ) { return Md5Holder . MD5 ; } private static class Md5Holder { static final HashFunction MD5 = new MessageDigestHashFunction ( <str> , <str> ) ; } public static HashFunction sha1 ( ) { return Sha1Holder . SHA_1 ; } private static class Sha1Holder { static final HashFunction SHA_1 = new MessageDigestHashFunction ( <str> , <str> ) ; } public static HashFunction sha256 ( ) { return Sha256Holder . SHA_256 ; } private static class Sha256Holder { static final HashFunction SHA_256 = new MessageDigestHashFunction ( <str> , <str> ) ; } public static HashFunction sha384 ( ) { return Sha384Holder . SHA_384 ; } private static class Sha384Holder { static final HashFunction SHA_384 = new MessageDigestHashFunction ( <str> , <str> ) ; } public static HashFunction sha512 ( ) { return Sha512Holder . SHA_512 ; } private static class Sha512Holder { static final HashFunction SHA_512 = new MessageDigestHashFunction ( <str> , <str> ) ; } public static HashFunction hmacMd5 ( Key key ) { return new MacHashFunction ( <str> , key , hmacToString ( <str> , key ) ) ; } public static HashFunction hmacMd5 ( byte [ ] key ) { return hmacMd5 ( new SecretKeySpec ( checkNotNull ( key ) , <str> ) ) ; } public static HashFunction hmacSha1 ( Key key ) { return new MacHashFunction ( <str> , key , hmacToString ( <str> , key ) ) ; } public static HashFunction hmacSha1 ( byte [ ] key ) { return hmacSha1 ( new SecretKeySpec ( checkNotNull ( key ) , <str> ) ) ; } public static HashFunction hmacSha256 ( Key key ) { return new MacHashFunction ( <str> , key , hmacToString ( <str> , key ) ) ; } public static HashFunction hmacSha256 ( byte [ ] key ) { return hmacSha256 ( new SecretKeySpec ( checkNotNull ( key ) , <str> ) ) ; } public static HashFunction hmacSha512 ( Key key ) { return new MacHashFunction ( <str> , key , hmacToString ( <str> , key ) ) ; } public static HashFunction hmacSha512 ( byte [ ] key ) { return hmacSha512 ( new SecretKeySpec ( checkNotNull ( key ) , <str> ) ) ; } private static String hmacToString ( String methodName , Key key ) { return String . format ( <str> , methodName , key . getAlgorithm ( ) , key . getFormat ( ) ) ; } public static HashFunction crc32c ( ) { return Crc32cHolder . CRC_32_C ; } private static final class Crc32cHolder { static final HashFunction CRC_32_C = new Crc32cHashFunction ( ) ; } public static HashFunction crc32 ( ) { return Crc32Holder . CRC_32 ; } private static class Crc32Holder { static final HashFunction CRC_32 = checksumHashFunction ( ChecksumType . CRC_32 , <str> ) ; } public static HashFunction adler32 ( ) { return Adler32Holder . ADLER_32 ; } private static class Adler32Holder { static final HashFunction ADLER_32 = checksumHashFunction ( ChecksumType . ADLER_32 , <str> ) ; } private static HashFunction checksumHashFunction ( ChecksumType type , String toString ) { return new ChecksumHashFunction ( type , type . bits , toString ) ; } enum ChecksumType implements Supplier < Checksum > { CRC_32 ( <int> ) { @Override public Checksum get ( ) { return new CRC32 ( ) ; } } , ADLER_32 ( <int> ) { @Override public Checksum get ( ) { return new Adler32 ( ) ; } } ; private final int bits ; ChecksumType ( int bits ) { this . bits = bits ; } @Override public abstract Checksum get ( ) ; } public static HashFunction farmHashFingerprint64 ( ) { return FarmHashFingerprint64Holder . FARMHASH_FINGERPRINT_64 ; } private static class FarmHashFingerprint64Holder { static final HashFunction FARMHASH_FINGERPRINT_64 = new FarmHashFingerprint64 ( ) ; } public static int consistentHash ( HashCode hashCode , int buckets ) { return consistentHash ( hashCode . padToLong ( ) , buckets ) ; } public static int consistentHash ( long input , int buckets ) { checkArgument ( buckets > <int> , <str> , buckets ) ; LinearCongruentialGenerator generator = new LinearCongruentialGenerator ( input ) ; int candidate = <int> ; int next ; while ( true ) { next = ( int ) ( ( candidate + <int> ) / generator . nextDouble ( ) ) ; if ( next > = <int> & & next < buckets ) { candidate = next ; } else { return candidate ; } } } public static HashCode combineOrdered ( Iterable < HashCode > hashCodes ) { Iterator < HashCode > iterator = hashCodes . iterator ( ) ; checkArgument ( iterator . hasNext ( ) , <str> ) ; int bits = iterator . next ( ) . bits ( ) ; byte [ ] resultBytes = new byte [ bits / <int> ] ; for ( HashCode hashCode : hashCodes ) { byte [ ] nextBytes = hashCode . asBytes ( ) ; checkArgument ( nextBytes . length = = resultBytes . length , <str> ) ; for ( int i = <int> ; i < nextBytes . length ; i + + ) { resultBytes [ i ] = ( byte ) ( resultBytes [ i ] * <int> ^ nextBytes [ i ] ) ; } } return HashCode . fromBytesNoCopy ( resultBytes ) ; } public static HashCode combineUnordered ( Iterable < HashCode > hashCodes ) { Iterator < HashCode > iterator = hashCodes . iterator ( ) ; checkArgument ( iterator . hasNext ( ) , <str> ) ; byte [ ] resultBytes = new byte [ iterator . next ( ) . bits ( ) / <int> ] ; for ( HashCode hashCode : hashCodes ) { byte [ ] nextBytes = hashCode . asBytes ( ) ; checkArgument ( nextBytes . length = = resultBytes . length , <str> ) ; for ( int i = <int> ; i < nextBytes . length ; i + + ) { resultBytes [ i ] + = nextBytes [ i ] ; } } return HashCode . fromBytesNoCopy ( resultBytes ) ; } static int checkPositiveAndMakeMultipleOf32 ( int bits ) { checkArgument ( bits > <int> , <str> ) ; return ( bits + <int> ) & ~ <int> ; } public static HashFunction concatenating ( HashFunction first , HashFunction second , HashFunction . . . rest ) { List < HashFunction > list = new ArrayList < HashFunction > ( ) ; list . add ( first ) ; list . add ( second ) ; for ( HashFunction hashFunc : rest ) { list . add ( hashFunc ) ; } return new ConcatenatedHashFunction ( list . toArray ( new HashFunction [ <int> ] ) ) ; } public static HashFunction concatenating ( Iterable < HashFunction > hashFunctions ) { checkNotNull ( hashFunctions ) ; List < HashFunction > list = new ArrayList < HashFunction > ( ) ; for ( HashFunction hashFunction : hashFunctions ) { list . add ( hashFunction ) ; } checkArgument ( list . size ( ) > <int> , <str> , list . size ( ) ) ; return new ConcatenatedHashFunction ( list . toArray ( new HashFunction [ <int> ] ) ) ; } private static final class ConcatenatedHashFunction extends AbstractCompositeHashFunction { private final int bits ; private ConcatenatedHashFunction ( HashFunction . . . functions ) { super ( functions ) ; int bitSum = <int> ; for ( HashFunction function : functions ) { bitSum + = function . bits ( ) ; checkArgument ( function . bits ( ) % <int> = = <int> , <str> , function . bits ( ) , function ) ; } this . bits = bitSum ; } @Override HashCode makeHash ( Hasher [ ] hashers ) { byte [ ] bytes = new byte [ bits / <int> ] ; int i = <int> ; for ( Hasher hasher : hashers ) { HashCode newHash = hasher . hash ( ) ; i + = newHash . writeBytesTo ( bytes , i , newHash . bits ( ) / <int> ) ; } return HashCode . fromBytesNoCopy ( bytes ) ; } @Override public int bits ( ) { return bits ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof ConcatenatedHashFunction ) { ConcatenatedHashFunction other = ( ConcatenatedHashFunction ) object ; return Arrays . equals ( functions , other . functions ) ; } return false ; } @Override public int hashCode ( ) { return Arrays . hashCode ( functions ) * <int> + bits ; } } private static final class LinearCongruentialGenerator { private long state ; public LinearCongruentialGenerator ( long seed ) { this . state = seed ; } public double nextDouble ( ) { state = <int> * state + <int> ; return ( ( double ) ( ( int ) ( state > > > <int> ) + <int> ) ) / ( <float> ) ; } } private Hashing ( ) { } } 
