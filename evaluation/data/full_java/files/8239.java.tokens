package org . elasticsearch . index . query ; import com . spatial4j . core . shape . jts . JtsGeometry ; import com . vividsolutions . jts . geom . Coordinate ; import org . apache . lucene . search . GeoPointInPolygonQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . Version ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . geo . builders . ShapeBuilder ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . search . geo . GeoPolygonQuery ; import org . elasticsearch . test . geo . RandomShapeGenerator ; import org . elasticsearch . test . geo . RandomShapeGenerator . ShapeType ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; public class GeoPolygonQueryBuilderTests extends AbstractQueryTestCase < GeoPolygonQueryBuilder > { @Override protected GeoPolygonQueryBuilder doCreateTestQueryBuilder ( ) { List < GeoPoint > polygon = randomPolygon ( randomIntBetween ( <int> , <int> ) ) ; GeoPolygonQueryBuilder builder = new GeoPolygonQueryBuilder ( GEO_POINT_FIELD_NAME , polygon ) ; if ( randomBoolean ( ) ) { builder . setValidationMethod ( randomFrom ( GeoValidationMethod . values ( ) ) ) ; } return builder ; } @Override protected void doAssertLuceneQuery ( GeoPolygonQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { Version version = context . indexVersionCreated ( ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertLegacyQuery ( queryBuilder , query ) ; } else { assertGeoPointQuery ( queryBuilder , query ) ; } } private void assertLegacyQuery ( GeoPolygonQueryBuilder queryBuilder , Query query ) { assertThat ( query , instanceOf ( GeoPolygonQuery . class ) ) ; GeoPolygonQuery geoQuery = ( GeoPolygonQuery ) query ; assertThat ( geoQuery . fieldName ( ) , equalTo ( queryBuilder . fieldName ( ) ) ) ; List < GeoPoint > queryBuilderPoints = queryBuilder . points ( ) ; GeoPoint [ ] queryPoints = geoQuery . points ( ) ; assertThat ( queryPoints . length , equalTo ( queryBuilderPoints . size ( ) ) ) ; if ( GeoValidationMethod . isCoerce ( queryBuilder . getValidationMethod ( ) ) ) { for ( int i = <int> ; i < queryBuilderPoints . size ( ) ; i + + ) { GeoPoint queryBuilderPoint = queryBuilderPoints . get ( i ) ; GeoPoint pointCopy = new GeoPoint ( queryBuilderPoint ) ; GeoUtils . normalizePoint ( pointCopy , true , true ) ; assertThat ( queryPoints [ i ] , equalTo ( pointCopy ) ) ; } } else { for ( int i = <int> ; i < queryBuilderPoints . size ( ) ; i + + ) { assertThat ( queryPoints [ i ] , equalTo ( queryBuilderPoints . get ( i ) ) ) ; } } } private void assertGeoPointQuery ( GeoPolygonQueryBuilder queryBuilder , Query query ) { assertThat ( query , instanceOf ( GeoPointInPolygonQuery . class ) ) ; GeoPointInPolygonQuery geoQuery = ( GeoPointInPolygonQuery ) query ; assertThat ( geoQuery . getField ( ) , equalTo ( queryBuilder . fieldName ( ) ) ) ; List < GeoPoint > queryBuilderPoints = queryBuilder . points ( ) ; double [ ] lats = geoQuery . getLats ( ) ; double [ ] lons = geoQuery . getLons ( ) ; assertThat ( lats . length , equalTo ( queryBuilderPoints . size ( ) ) ) ; assertThat ( lons . length , equalTo ( queryBuilderPoints . size ( ) ) ) ; for ( int i = <int> ; i < queryBuilderPoints . size ( ) ; + + i ) { final GeoPoint queryBuilderPoint = queryBuilderPoints . get ( i ) ; final GeoPoint pointCopy = new GeoPoint ( queryBuilderPoint ) ; GeoUtils . normalizePoint ( pointCopy ) ; assertThat ( lats [ i ] , closeTo ( pointCopy . getLat ( ) , <float> ) ) ; assertThat ( lons [ i ] , closeTo ( pointCopy . getLon ( ) , <float> ) ) ; } } @Override public void testToQuery ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; super . testToQuery ( ) ; } public List < GeoPoint > randomPolygon ( int numPoints ) { ShapeBuilder shapeBuilder = null ; while ( shapeBuilder = = null ) { shapeBuilder = RandomShapeGenerator . createShapeWithin ( getRandom ( ) , null , ShapeType . POLYGON ) ; } JtsGeometry shape = ( JtsGeometry ) shapeBuilder . build ( ) ; Coordinate [ ] coordinates = shape . getGeom ( ) . getCoordinates ( ) ; ArrayList < GeoPoint > polygonPoints = new ArrayList < > ( ) ; for ( Coordinate coord : coordinates ) { polygonPoints . add ( new GeoPoint ( coord . y , coord . x ) ) ; } return polygonPoints ; } public void testNullFieldName ( ) { try { new GeoPolygonQueryBuilder ( null , randomPolygon ( <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testEmptyPolygon ( ) { try { if ( randomBoolean ( ) ) { new GeoPolygonQueryBuilder ( GEO_POINT_FIELD_NAME , new ArrayList < GeoPoint > ( ) ) ; } else { new GeoPolygonQueryBuilder ( GEO_POINT_FIELD_NAME , null ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidClosedPolygon ( ) { List < GeoPoint > points = new ArrayList < > ( ) ; points . add ( new GeoPoint ( <int> , <int> ) ) ; points . add ( new GeoPoint ( <int> , <int> ) ) ; points . add ( new GeoPoint ( <int> , <int> ) ) ; try { new GeoPolygonQueryBuilder ( GEO_POINT_FIELD_NAME , points ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidOpenPolygon ( ) { List < GeoPoint > points = new ArrayList < > ( ) ; points . add ( new GeoPoint ( <int> , <int> ) ) ; points . add ( new GeoPoint ( <int> , <int> ) ) ; try { new GeoPolygonQueryBuilder ( GEO_POINT_FIELD_NAME , points ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testDeprecatedXContent ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; builder . startObject ( <str> ) ; builder . startObject ( GEO_POINT_FIELD_NAME ) ; builder . startArray ( <str> ) ; builder . value ( <str> ) ; builder . value ( <str> ) ; builder . value ( <str> ) ; builder . value ( <str> ) ; builder . endArray ( ) ; builder . endObject ( ) ; builder . field ( <str> , true ) ; builder . endObject ( ) ; builder . endObject ( ) ; try { parseQuery ( builder . string ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { assertEquals ( <str> , ex . getMessage ( ) ) ; } } public void testParsingAndToQueryParsingExceptions ( ) throws IOException { String [ ] brokenFiles = new String [ ] { <str> , <str> , <str> , <str> , <str> } ; for ( String brokenFile : brokenFiles ) { String query = copyToStringFromClasspath ( brokenFile ) ; try { parseQuery ( query ) ; fail ( <str> + brokenFile ) ; } catch ( ParsingException e ) { } } } public void testParsingAndToQuery1 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoPolygonQuery ( query ) ; } public void testParsingAndToQuery2 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoPolygonQuery ( query ) ; } public void testParsingAndToQuery3 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoPolygonQuery ( query ) ; } public void testParsingAndToQuery4 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoPolygonQuery ( query ) ; } private void assertGeoPolygonQuery ( String query ) throws IOException { QueryShardContext context = createShardContext ( ) ; Version version = context . indexVersionCreated ( ) ; Query parsedQuery = parseQuery ( query ) . toQuery ( context ) ; if ( version . before ( Version . V_2_2_0 ) ) { GeoPolygonQuery filter = ( GeoPolygonQuery ) parsedQuery ; assertThat ( filter . fieldName ( ) , equalTo ( GEO_POINT_FIELD_NAME ) ) ; assertThat ( filter . points ( ) . length , equalTo ( <int> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lon ( ) , closeTo ( - <int> , <float> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lon ( ) , closeTo ( - <int> , <float> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( filter . points ( ) [ <int> ] . lon ( ) , closeTo ( - <int> , <float> ) ) ; } else { GeoPointInPolygonQuery q = ( GeoPointInPolygonQuery ) parsedQuery ; assertThat ( q . getField ( ) , equalTo ( GEO_POINT_FIELD_NAME ) ) ; final double [ ] lats = q . getLats ( ) ; final double [ ] lons = q . getLons ( ) ; assertThat ( lats . length , equalTo ( <int> ) ) ; assertThat ( lons . length , equalTo ( <int> ) ) ; assertThat ( lats [ <int> ] , closeTo ( <int> , <float> ) ) ; assertThat ( lons [ <int> ] , closeTo ( - <int> , <float> ) ) ; assertThat ( lats [ <int> ] , closeTo ( <int> , <float> ) ) ; assertThat ( lons [ <int> ] , closeTo ( - <int> , <float> ) ) ; assertThat ( lats [ <int> ] , closeTo ( <int> , <float> ) ) ; assertThat ( lons [ <int> ] , closeTo ( - <int> , <float> ) ) ; assertThat ( lats [ <int> ] , equalTo ( lats [ <int> ] ) ) ; assertThat ( lons [ <int> ] , equalTo ( lons [ <int> ] ) ) ; } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; GeoPolygonQueryBuilder parsed = ( GeoPolygonQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <int> , parsed . points ( ) . size ( ) ) ; } } 
