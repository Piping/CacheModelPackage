package org . apache . cassandra . tools ; import java . io . File ; import java . util . * ; import java . util . concurrent . TimeUnit ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import org . apache . commons . cli . * ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . compaction . * ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . * ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . OutputHandler ; import static org . apache . cassandra . tools . BulkLoader . CmdLineOptions ; public class StandaloneScrubber { private static final String TOOL_NAME = <str> ; private static final String VERBOSE_OPTION = <str> ; private static final String DEBUG_OPTION = <str> ; private static final String HELP_OPTION = <str> ; private static final String MANIFEST_CHECK_OPTION = <str> ; private static final String SKIP_CORRUPTED_OPTION = <str> ; private static final String NO_VALIDATE_OPTION = <str> ; public static void main ( String args [ ] ) { Options options = Options . parseArgs ( args ) ; Util . initDatabaseDescriptor ( ) ; try { Schema . instance . loadFromDisk ( false ) ; if ( Schema . instance . getKSMetaData ( options . keyspaceName ) = = null ) throw new IllegalArgumentException ( String . format ( <str> , options . keyspaceName ) ) ; Keyspace keyspace = Keyspace . openWithoutSSTables ( options . keyspaceName ) ; ColumnFamilyStore cfs = null ; for ( ColumnFamilyStore c : keyspace . getValidColumnFamilies ( true , false , options . cfName ) ) { if ( c . name . equals ( options . cfName ) ) { cfs = c ; break ; } } if ( cfs = = null ) throw new IllegalArgumentException ( String . format ( <str> , options . keyspaceName , options . cfName ) ) ; String snapshotName = <str> + System . currentTimeMillis ( ) ; OutputHandler handler = new OutputHandler . SystemOutput ( options . verbose , options . debug ) ; Directories . SSTableLister lister = cfs . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) ; List < SSTableReader > sstables = new ArrayList < > ( ) ; for ( Map . Entry < Descriptor , Set < Component > > entry : lister . list ( ) . entrySet ( ) ) { Set < Component > components = entry . getValue ( ) ; if ( ! components . contains ( Component . DATA ) ) continue ; try { SSTableReader sstable = SSTableReader . openNoValidation ( entry . getKey ( ) , components , cfs ) ; sstables . add ( sstable ) ; File snapshotDirectory = Directories . getSnapshotDirectory ( sstable . descriptor , snapshotName ) ; sstable . createLinks ( snapshotDirectory . getPath ( ) ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; System . err . println ( String . format ( <str> , entry . getKey ( ) , e . getMessage ( ) ) ) ; if ( options . debug ) e . printStackTrace ( System . err ) ; } } System . out . println ( String . format ( <str> , snapshotName ) ) ; if ( ! options . manifestCheckOnly ) { for ( SSTableReader sstable : sstables ) { try ( LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . SCRUB , sstable ) ) { txn . obsoleteOriginals ( ) ; try ( Scrubber scrubber = new Scrubber ( cfs , txn , options . skipCorrupted , handler , true , ! options . noValidate ) ) { scrubber . scrub ( ) ; } catch ( Throwable t ) { if ( ! cfs . rebuildOnFailedScrub ( t ) ) { System . out . println ( t . getMessage ( ) ) ; throw t ; } } } catch ( Exception e ) { System . err . println ( String . format ( <str> , sstable , e . getMessage ( ) ) ) ; e . printStackTrace ( System . err ) ; } } } checkManifest ( cfs . getCompactionStrategyManager ( ) , cfs , sstables ) ; CompactionManager . instance . finishCompactionsAndShutdown ( <int> , TimeUnit . MINUTES ) ; LifecycleTransaction . waitForDeletions ( ) ; System . exit ( <int> ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; if ( options . debug ) e . printStackTrace ( System . err ) ; System . exit ( <int> ) ; } } private static void checkManifest ( CompactionStrategyManager strategyManager , ColumnFamilyStore cfs , Collection < SSTableReader > sstables ) { int maxSizeInMB = ( int ) ( ( cfs . getCompactionStrategyManager ( ) . getMaxSSTableBytes ( ) ) / ( <int> * <int> ) ) ; if ( strategyManager . getStrategies ( ) . size ( ) = = <int> & & strategyManager . getStrategies ( ) . get ( <int> ) instanceof LeveledCompactionStrategy ) { System . out . println ( <str> ) ; Predicate < SSTableReader > repairedPredicate = new Predicate < SSTableReader > ( ) { @Override public boolean apply ( SSTableReader sstable ) { return sstable . isRepaired ( ) ; } } ; List < SSTableReader > repaired = Lists . newArrayList ( Iterables . filter ( sstables , repairedPredicate ) ) ; List < SSTableReader > unRepaired = Lists . newArrayList ( Iterables . filter ( sstables , Predicates . not ( repairedPredicate ) ) ) ; LeveledManifest repairedManifest = LeveledManifest . create ( cfs , maxSizeInMB , repaired ) ; for ( int i = <int> ; i < repairedManifest . getLevelCount ( ) ; i + + ) { repairedManifest . repairOverlappingSSTables ( i ) ; } LeveledManifest unRepairedManifest = LeveledManifest . create ( cfs , maxSizeInMB , unRepaired ) ; for ( int i = <int> ; i < unRepairedManifest . getLevelCount ( ) ; i + + ) { unRepairedManifest . repairOverlappingSSTables ( i ) ; } } } private static class Options { public final String keyspaceName ; public final String cfName ; public boolean debug ; public boolean verbose ; public boolean manifestCheckOnly ; public boolean skipCorrupted ; public boolean noValidate ; private Options ( String keyspaceName , String cfName ) { this . keyspaceName = keyspaceName ; this . cfName = cfName ; } public static Options parseArgs ( String cmdArgs [ ] ) { CommandLineParser parser = new GnuParser ( ) ; CmdLineOptions options = getCmdLineOptions ( ) ; try { CommandLine cmd = parser . parse ( options , cmdArgs , false ) ; if ( cmd . hasOption ( HELP_OPTION ) ) { printUsage ( options ) ; System . exit ( <int> ) ; } String [ ] args = cmd . getArgs ( ) ; if ( args . length ! = <int> ) { String msg = args . length < <int> ? <str> : <str> ; System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } String keyspaceName = args [ <int> ] ; String cfName = args [ <int> ] ; Options opts = new Options ( keyspaceName , cfName ) ; opts . debug = cmd . hasOption ( DEBUG_OPTION ) ; opts . verbose = cmd . hasOption ( VERBOSE_OPTION ) ; opts . manifestCheckOnly = cmd . hasOption ( MANIFEST_CHECK_OPTION ) ; opts . skipCorrupted = cmd . hasOption ( SKIP_CORRUPTED_OPTION ) ; opts . noValidate = cmd . hasOption ( NO_VALIDATE_OPTION ) ; return opts ; } catch ( ParseException e ) { errorMsg ( e . getMessage ( ) , options ) ; return null ; } } private static void errorMsg ( String msg , CmdLineOptions options ) { System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } private static CmdLineOptions getCmdLineOptions ( ) { CmdLineOptions options = new CmdLineOptions ( ) ; options . addOption ( null , DEBUG_OPTION , <str> ) ; options . addOption ( <str> , VERBOSE_OPTION , <str> ) ; options . addOption ( <str> , HELP_OPTION , <str> ) ; options . addOption ( <str> , MANIFEST_CHECK_OPTION , <str> ) ; options . addOption ( <str> , SKIP_CORRUPTED_OPTION , <str> ) ; options . addOption ( <str> , NO_VALIDATE_OPTION , <str> ) ; return options ; } public static void printUsage ( CmdLineOptions options ) { String usage = String . format ( <str> , TOOL_NAME ) ; StringBuilder header = new StringBuilder ( ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; new HelpFormatter ( ) . printHelp ( usage , header . toString ( ) , options , <str> ) ; } } } 
