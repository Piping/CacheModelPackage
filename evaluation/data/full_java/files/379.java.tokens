package org . apache . cassandra . db . compaction ; import java . util . * ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import com . google . common . collect . Iterables ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . utils . AlwaysPresentFilter ; import org . apache . cassandra . utils . OverlapIterator ; import org . apache . cassandra . utils . concurrent . Refs ; import static org . apache . cassandra . db . lifecycle . SSTableIntervalTree . buildIntervals ; public class CompactionController implements AutoCloseable { private static final Logger logger = LoggerFactory . getLogger ( CompactionController . class ) ; public final ColumnFamilyStore cfs ; private final boolean compactingRepaired ; private Refs < SSTableReader > overlappingSSTables ; private OverlapIterator < PartitionPosition , SSTableReader > overlapIterator ; private final Iterable < SSTableReader > compacting ; public final int gcBefore ; protected CompactionController ( ColumnFamilyStore cfs , int maxValue ) { this ( cfs , null , maxValue ) ; } public CompactionController ( ColumnFamilyStore cfs , Set < SSTableReader > compacting , int gcBefore ) { assert cfs ! = null ; this . cfs = cfs ; this . gcBefore = gcBefore ; this . compacting = compacting ; compactingRepaired = compacting ! = null & & compacting . stream ( ) . allMatch ( SSTableReader : : isRepaired ) ; refreshOverlaps ( ) ; } public void maybeRefreshOverlaps ( ) { for ( SSTableReader reader : overlappingSSTables ) { if ( reader . isMarkedCompacted ( ) ) { refreshOverlaps ( ) ; return ; } } } private void refreshOverlaps ( ) { if ( this . overlappingSSTables ! = null ) overlappingSSTables . release ( ) ; if ( compacting = = null ) overlappingSSTables = Refs . tryRef ( Collections . < SSTableReader > emptyList ( ) ) ; else overlappingSSTables = cfs . getAndReferenceOverlappingSSTables ( SSTableSet . LIVE , compacting ) ; this . overlapIterator = new OverlapIterator < > ( buildIntervals ( overlappingSSTables ) ) ; } public Set < SSTableReader > getFullyExpiredSSTables ( ) { return getFullyExpiredSSTables ( cfs , compacting , overlappingSSTables , gcBefore ) ; } public static Set < SSTableReader > getFullyExpiredSSTables ( ColumnFamilyStore cfStore , Iterable < SSTableReader > compacting , Iterable < SSTableReader > overlapping , int gcBefore ) { logger . trace ( <str> , cfStore ) ; if ( compacting = = null ) return Collections . < SSTableReader > emptySet ( ) ; if ( cfStore . getCompactionStrategyManager ( ) . onlyPurgeRepairedTombstones ( ) & & ! Iterables . all ( compacting , SSTableReader : : isRepaired ) ) return Collections . emptySet ( ) ; List < SSTableReader > candidates = new ArrayList < > ( ) ; long minTimestamp = Long . MAX_VALUE ; for ( SSTableReader sstable : overlapping ) { if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime > = gcBefore ) minTimestamp = Math . min ( minTimestamp , sstable . getMinTimestamp ( ) ) ; } for ( SSTableReader candidate : compacting ) { if ( candidate . getSSTableMetadata ( ) . maxLocalDeletionTime < gcBefore ) candidates . add ( candidate ) ; else minTimestamp = Math . min ( minTimestamp , candidate . getMinTimestamp ( ) ) ; } Iterator < SSTableReader > iterator = candidates . iterator ( ) ; while ( iterator . hasNext ( ) ) { SSTableReader candidate = iterator . next ( ) ; if ( candidate . getMaxTimestamp ( ) > = minTimestamp ) { iterator . remove ( ) ; } else { logger . trace ( <str> , candidate , candidate . getSSTableMetadata ( ) . maxLocalDeletionTime , gcBefore ) ; } } return new HashSet < > ( candidates ) ; } public String getKeyspace ( ) { return cfs . keyspace . getName ( ) ; } public String getColumnFamily ( ) { return cfs . name ; } public long maxPurgeableTimestamp ( DecoratedKey key ) { if ( ! compactingRepaired ( ) ) return Long . MIN_VALUE ; long min = Long . MAX_VALUE ; overlapIterator . update ( key ) ; for ( SSTableReader sstable : overlapIterator . overlaps ( ) ) { if ( sstable . getBloomFilter ( ) instanceof AlwaysPresentFilter & & sstable . getPosition ( key , SSTableReader . Operator . EQ , false ) ! = null ) min = Math . min ( min , sstable . getMinTimestamp ( ) ) ; else if ( sstable . getBloomFilter ( ) . isPresent ( key ) ) min = Math . min ( min , sstable . getMinTimestamp ( ) ) ; } return min ; } public void close ( ) { overlappingSSTables . release ( ) ; } public boolean compactingRepaired ( ) { return ! cfs . getCompactionStrategyManager ( ) . onlyPurgeRepairedTombstones ( ) | | compactingRepaired ; } } 
