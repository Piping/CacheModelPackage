package io . netty . handler . codec . dns ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . handler . codec . UnsupportedMessageTypeException ; import io . netty . util . internal . StringUtil ; public class DefaultDnsRecordEncoder implements DnsRecordEncoder { protected DefaultDnsRecordEncoder ( ) { } @Override public final void encodeQuestion ( DnsQuestion question , ByteBuf out ) throws Exception { encodeName ( question . name ( ) , out ) ; out . writeShort ( question . type ( ) . intValue ( ) ) ; out . writeShort ( question . dnsClass ( ) ) ; } @Override public void encodeRecord ( DnsRecord record , ByteBuf out ) throws Exception { if ( record instanceof DnsQuestion ) { encodeQuestion ( ( DnsQuestion ) record , out ) ; } else if ( record instanceof DnsRawRecord ) { encodeRawRecord ( ( DnsRawRecord ) record , out ) ; } else { throw new UnsupportedMessageTypeException ( StringUtil . simpleClassName ( record ) ) ; } } private void encodeRawRecord ( DnsRawRecord record , ByteBuf out ) throws Exception { encodeName ( record . name ( ) , out ) ; out . writeShort ( record . type ( ) . intValue ( ) ) ; out . writeShort ( record . dnsClass ( ) ) ; out . writeInt ( ( int ) record . timeToLive ( ) ) ; ByteBuf content = record . content ( ) ; int contentLen = content . readableBytes ( ) ; out . writeShort ( contentLen ) ; out . writeBytes ( content , content . readerIndex ( ) , contentLen ) ; } protected void encodeName ( String name , ByteBuf buf ) throws Exception { String [ ] parts = StringUtil . split ( name , <str> ) ; for ( String part : parts ) { final int partLen = part . length ( ) ; if ( partLen = = <int> ) { continue ; } buf . writeByte ( partLen ) ; ByteBufUtil . writeAscii ( buf , part ) ; } buf . writeByte ( <int> ) ; } } 
