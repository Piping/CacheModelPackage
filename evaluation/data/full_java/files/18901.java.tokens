package io . netty . handler . codec . compression ; import com . ning . compress . BufferRecycler ; import com . ning . compress . lzf . ChunkDecoder ; import com . ning . compress . lzf . util . ChunkDecoderFactory ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import java . util . List ; import static com . ning . compress . lzf . LZFChunk . BYTE_Z ; import static com . ning . compress . lzf . LZFChunk . BYTE_V ; import static com . ning . compress . lzf . LZFChunk . HEADER_LEN_NOT_COMPRESSED ; import static com . ning . compress . lzf . LZFChunk . BLOCK_TYPE_NON_COMPRESSED ; import static com . ning . compress . lzf . LZFChunk . BLOCK_TYPE_COMPRESSED ; public class LzfDecoder extends ByteToMessageDecoder { private enum State { INIT_BLOCK , INIT_ORIGINAL_LENGTH , DECOMPRESS_DATA , CORRUPTED } private State currentState = State . INIT_BLOCK ; private static final short MAGIC_NUMBER = BYTE_Z < < <int> | BYTE_V ; private ChunkDecoder decoder ; private BufferRecycler recycler ; private int chunkLength ; private int originalLength ; private boolean isCompressed ; public LzfDecoder ( ) { this ( false ) ; } public LzfDecoder ( boolean safeInstance ) { decoder = safeInstance ? ChunkDecoderFactory . safeInstance ( ) : ChunkDecoderFactory . optimalInstance ( ) ; recycler = BufferRecycler . instance ( ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( currentState ) { case INIT_BLOCK : if ( in . readableBytes ( ) < HEADER_LEN_NOT_COMPRESSED ) { break ; } final int magic = in . readUnsignedShort ( ) ; if ( magic ! = MAGIC_NUMBER ) { throw new DecompressionException ( <str> ) ; } final int type = in . readByte ( ) ; switch ( type ) { case BLOCK_TYPE_NON_COMPRESSED : isCompressed = false ; currentState = State . DECOMPRESS_DATA ; break ; case BLOCK_TYPE_COMPRESSED : isCompressed = true ; currentState = State . INIT_ORIGINAL_LENGTH ; break ; default : throw new DecompressionException ( String . format ( <str> , type , BLOCK_TYPE_NON_COMPRESSED , BLOCK_TYPE_COMPRESSED ) ) ; } chunkLength = in . readUnsignedShort ( ) ; if ( type ! = BLOCK_TYPE_COMPRESSED ) { break ; } case INIT_ORIGINAL_LENGTH : if ( in . readableBytes ( ) < <int> ) { break ; } originalLength = in . readUnsignedShort ( ) ; currentState = State . DECOMPRESS_DATA ; case DECOMPRESS_DATA : final int chunkLength = this . chunkLength ; if ( in . readableBytes ( ) < chunkLength ) { break ; } final int originalLength = this . originalLength ; if ( isCompressed ) { final int idx = in . readerIndex ( ) ; final byte [ ] inputArray ; final int inPos ; if ( in . hasArray ( ) ) { inputArray = in . array ( ) ; inPos = in . arrayOffset ( ) + idx ; } else { inputArray = recycler . allocInputBuffer ( chunkLength ) ; in . getBytes ( idx , inputArray , <int> , chunkLength ) ; inPos = <int> ; } ByteBuf uncompressed = ctx . alloc ( ) . heapBuffer ( originalLength , originalLength ) ; final byte [ ] outputArray = uncompressed . array ( ) ; final int outPos = uncompressed . arrayOffset ( ) + uncompressed . writerIndex ( ) ; boolean success = false ; try { decoder . decodeChunk ( inputArray , inPos , outputArray , outPos , outPos + originalLength ) ; uncompressed . writerIndex ( uncompressed . writerIndex ( ) + originalLength ) ; out . add ( uncompressed ) ; in . skipBytes ( chunkLength ) ; success = true ; } finally { if ( ! success ) { uncompressed . release ( ) ; } } if ( ! in . hasArray ( ) ) { recycler . releaseInputBuffer ( inputArray ) ; } } else if ( chunkLength > <int> ) { out . add ( in . readSlice ( chunkLength ) . retain ( ) ) ; } currentState = State . INIT_BLOCK ; break ; case CORRUPTED : in . skipBytes ( in . readableBytes ( ) ) ; break ; default : throw new IllegalStateException ( ) ; } } catch ( Exception e ) { currentState = State . CORRUPTED ; decoder = null ; recycler = null ; throw e ; } } } 
