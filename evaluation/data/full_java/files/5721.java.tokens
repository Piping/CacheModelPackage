package org . elasticsearch . common . compress . deflate ; import org . apache . lucene . store . IndexInput ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressedIndexInput ; import org . elasticsearch . common . compress . Compressor ; import org . elasticsearch . common . io . stream . InputStreamStreamInput ; import org . elasticsearch . common . io . stream . OutputStreamStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . jboss . netty . buffer . ChannelBuffer ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . Inflater ; import java . util . zip . InflaterInputStream ; public class DeflateCompressor implements Compressor { private static final byte [ ] HEADER = new byte [ ] { <str> , <str> , <str> , <str> } ; private static final int LEVEL = <int> ; private static final int BUFFER_SIZE = <int> ; @Override public boolean isCompressed ( BytesReference bytes ) { if ( bytes . length ( ) < HEADER . length ) { return false ; } for ( int i = <int> ; i < HEADER . length ; + + i ) { if ( bytes . get ( i ) ! = HEADER [ i ] ) { return false ; } } return true ; } @Override public boolean isCompressed ( ChannelBuffer buffer ) { if ( buffer . readableBytes ( ) < HEADER . length ) { return false ; } final int offset = buffer . readerIndex ( ) ; for ( int i = <int> ; i < HEADER . length ; + + i ) { if ( buffer . getByte ( offset + i ) ! = HEADER [ i ] ) { return false ; } } return true ; } @Override public StreamInput streamInput ( StreamInput in ) throws IOException { final byte [ ] headerBytes = new byte [ HEADER . length ] ; int len = <int> ; while ( len < headerBytes . length ) { final int read = in . read ( headerBytes , len , headerBytes . length - len ) ; if ( read = = - <int> ) { break ; } len + = read ; } if ( len ! = HEADER . length | | Arrays . equals ( headerBytes , HEADER ) = = false ) { throw new IllegalArgumentException ( <str> ) ; } final boolean nowrap = true ; final Inflater inflater = new Inflater ( nowrap ) ; InputStream decompressedIn = new InflaterInputStream ( in , inflater , BUFFER_SIZE ) ; decompressedIn = new BufferedInputStream ( decompressedIn , BUFFER_SIZE ) ; return new InputStreamStreamInput ( decompressedIn ) { private boolean closed = false ; public void close ( ) throws IOException { try { super . close ( ) ; } finally { if ( closed = = false ) { inflater . end ( ) ; closed = true ; } } } } ; } @Override public StreamOutput streamOutput ( StreamOutput out ) throws IOException { out . writeBytes ( HEADER ) ; final boolean nowrap = true ; final Deflater deflater = new Deflater ( LEVEL , nowrap ) ; final boolean syncFlush = true ; OutputStream compressedOut = new DeflaterOutputStream ( out , deflater , BUFFER_SIZE , syncFlush ) ; compressedOut = new BufferedOutputStream ( compressedOut , BUFFER_SIZE ) ; return new OutputStreamStreamOutput ( compressedOut ) { private boolean closed = false ; public void close ( ) throws IOException { try { super . close ( ) ; } finally { if ( closed = = false ) { deflater . end ( ) ; closed = true ; } } } } ; } @Override public boolean isCompressed ( IndexInput in ) throws IOException { return false ; } @Override public CompressedIndexInput indexInput ( IndexInput in ) throws IOException { throw new UnsupportedOperationException ( ) ; } } 
