package org . elasticsearch . search . fetch . fielddata ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . index . fielddata . AtomicFieldData ; import org . elasticsearch . index . fielddata . ScriptDocValues ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . search . SearchHitField ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . fetch . FetchSubPhase ; import org . elasticsearch . search . internal . InternalSearchHit ; import org . elasticsearch . search . internal . InternalSearchHitField ; import org . elasticsearch . search . internal . SearchContext ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class FieldDataFieldsFetchSubPhase implements FetchSubPhase { public static final String [ ] NAMES = { <str> , <str> } ; public static final ContextFactory < FieldDataFieldsContext > CONTEXT_FACTORY = new ContextFactory < FieldDataFieldsContext > ( ) { @Override public String getName ( ) { return NAMES [ <int> ] ; } @Override public FieldDataFieldsContext newContextInstance ( ) { return new FieldDataFieldsContext ( ) ; } } ; @Inject public FieldDataFieldsFetchSubPhase ( ) { } @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { Map < String , SearchParseElement > parseElements = new HashMap < > ( ) ; parseElements . put ( <str> , new FieldDataFieldsParseElement ( ) ) ; parseElements . put ( <str> , new FieldDataFieldsParseElement ( ) ) ; return unmodifiableMap ( parseElements ) ; } @Override public boolean hitsExecutionNeeded ( SearchContext context ) { return false ; } @Override public void hitsExecute ( SearchContext context , InternalSearchHit [ ] hits ) { } @Override public boolean hitExecutionNeeded ( SearchContext context ) { return context . getFetchSubPhaseContext ( CONTEXT_FACTORY ) . hitExecutionNeeded ( ) ; } @Override public void hitExecute ( SearchContext context , HitContext hitContext ) { for ( FieldDataFieldsContext . FieldDataField field : context . getFetchSubPhaseContext ( CONTEXT_FACTORY ) . fields ( ) ) { if ( hitContext . hit ( ) . fieldsOrNull ( ) = = null ) { hitContext . hit ( ) . fields ( new HashMap < String , SearchHitField > ( <int> ) ) ; } SearchHitField hitField = hitContext . hit ( ) . fields ( ) . get ( field . name ( ) ) ; if ( hitField = = null ) { hitField = new InternalSearchHitField ( field . name ( ) , new ArrayList < > ( <int> ) ) ; hitContext . hit ( ) . fields ( ) . put ( field . name ( ) , hitField ) ; } MappedFieldType fieldType = context . mapperService ( ) . smartNameFieldType ( field . name ( ) ) ; if ( fieldType ! = null ) { AtomicFieldData data = context . fieldData ( ) . getForField ( fieldType ) . load ( hitContext . readerContext ( ) ) ; ScriptDocValues values = data . getScriptValues ( ) ; values . setNextDocId ( hitContext . docId ( ) ) ; hitField . values ( ) . addAll ( values . getValues ( ) ) ; } } } } 
