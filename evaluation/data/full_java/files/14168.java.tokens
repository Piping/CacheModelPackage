package org . gradle . messaging . remote . internal ; import org . gradle . messaging . remote . internal . protocol . ConsumerAvailable ; import org . gradle . messaging . remote . internal . protocol . ConsumerUnavailable ; import org . gradle . messaging . remote . internal . protocol . Request ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . List ; public class UnicastSendProtocol implements Protocol < Message > { private static final Logger LOGGER = LoggerFactory . getLogger ( UnicastSendProtocol . class ) ; private static final Object BROKEN_CONSUMER = new Object ( ) ; private final List < Object > queue = new ArrayList < Object > ( ) ; private String consumerDisplayName ; private Object consumerId ; private ProtocolContext < Message > context ; private boolean stopping ; public void start ( ProtocolContext < Message > context ) { this . context = context ; } public void handleIncoming ( Message message ) { if ( message instanceof ConsumerAvailable ) { ConsumerAvailable consumerAvailable = ( ConsumerAvailable ) message ; LOGGER . debug ( <str> , consumerAvailable ) ; consumerId = consumerAvailable . getId ( ) ; consumerDisplayName = consumerAvailable . getDisplayName ( ) ; for ( Object queued : queue ) { context . dispatchOutgoing ( new Request ( consumerId , queued ) ) ; } queue . clear ( ) ; if ( stopping ) { LOGGER . debug ( <str> ) ; context . stopped ( ) ; } } else if ( message instanceof ConsumerUnavailable ) { consumerId = BROKEN_CONSUMER ; } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } public void handleOutgoing ( Message message ) { if ( message instanceof Request ) { Request request = ( Request ) message ; if ( consumerId = = null ) { queue . add ( request . getPayload ( ) ) ; } else if ( consumerId = = BROKEN_CONSUMER ) { LOGGER . warn ( <str> , message , consumerDisplayName ) ; } else { context . dispatchOutgoing ( new Request ( consumerId , request . getPayload ( ) ) ) ; } } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } public void stopRequested ( ) { if ( queue . isEmpty ( ) ) { context . stopped ( ) ; return ; } LOGGER . debug ( <str> ) ; stopping = true ; context . stopLater ( ) ; } } 
