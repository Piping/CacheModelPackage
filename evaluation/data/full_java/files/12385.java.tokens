package org . gradle . api . internal . file . collections ; import groovy . lang . Closure ; import org . gradle . api . Task ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . file . FileCollectionInternal ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . internal . tasks . TaskResolver ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . gradle . testfixtures . internal . NativeServicesTestFixture ; import org . gradle . util . JUnit4GroovyMockery ; import org . gradle . util . TestUtil ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . File ; import java . util . List ; import java . util . Set ; import java . util . concurrent . Callable ; import static org . gradle . util . Matchers . isEmpty ; import static org . gradle . util . WrapUtil . * ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . assertThat ; @RunWith ( JMock . class ) public class DefaultConfigurableFileCollectionTest { private final JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; @Rule public TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private final FileResolver resolverMock = context . mock ( FileResolver . class ) ; private final TaskResolver taskResolverStub = context . mock ( TaskResolver . class ) ; private final DefaultConfigurableFileCollection collection = new DefaultConfigurableFileCollection ( resolverMock , taskResolverStub ) ; @Before public void setUp ( ) { NativeServicesTestFixture . initialize ( ) ; } @Test public void resolvesSpecifiedFilesUseFileResolver ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; DefaultConfigurableFileCollection collection = new DefaultConfigurableFileCollection ( resolverMock , taskResolverStub , <str> , <str> ) ; context . checking ( new Expectations ( ) { { one ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; one ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; assertThat ( collection . getFrom ( ) , equalTo ( toLinkedSet ( ( Object ) <str> , <str> ) ) ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canAddPathsToTheCollection ( ) { collection . from ( <str> , <str> ) ; assertThat ( collection . getFrom ( ) , equalTo ( toLinkedSet ( ( Object ) <str> , <str> ) ) ) ; } @Test public void canSetThePathsOfTheCollection ( ) { collection . from ( <str> ) ; collection . setFrom ( <str> , <str> ) ; assertThat ( collection . getFrom ( ) , equalTo ( toLinkedSet ( ( Object ) <str> , <str> ) ) ) ; collection . setFrom ( toList ( <str> , <str> ) ) ; assertThat ( collection . getFrom ( ) , equalTo ( toLinkedSet ( ( Object ) toList ( <str> , <str> ) ) ) ) ; } @Test public void resolvesSpecifiedPathsUseFileResolver ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; DefaultConfigurableFileCollection collection = new DefaultConfigurableFileCollection ( resolverMock , taskResolverStub , <str> , <str> ) ; context . checking ( new Expectations ( ) { { one ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; one ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseAClosureToSpecifyTheContentsOfTheCollection ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; List < Character > files = toList ( <str> ) ; Closure closure = TestUtil . returns ( files ) ; collection . from ( closure ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 ) ) ) ; files . add ( <str> ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseAClosureToSpecifyASingleFile ( ) { Closure closure = TestUtil . returns ( <str> ) ; final File file = new File ( <str> ) ; collection . from ( closure ) ; context . checking ( new Expectations ( ) { { one ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file ) ) ) ; } @Test public void closureCanReturnNull ( ) { Closure closure = TestUtil . returns ( null ) ; collection . from ( closure ) ; assertThat ( collection . getFiles ( ) , isEmpty ( ) ) ; } @Test public void canUseACollectionToSpecifyTheContentsOfTheCollection ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; List < String > files = toList ( <str> ) ; collection . from ( files ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 ) ) ) ; files . add ( <str> ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseAnArrayToSpecifyTheContentsOfTheCollection ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; collection . from ( ( Object ) toArray ( <str> , <str> ) ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseNestedObjectsToSpecifyTheContentsOfTheCollection ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; collection . from ( TestUtil . toClosure ( <str> ) ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseAFileCollectionToSpecifyTheContentsOfTheCollection ( ) { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; final FileCollectionInternal src = context . mock ( FileCollectionInternal . class ) ; collection . from ( src ) ; context . checking ( new Expectations ( ) { { one ( src ) . getFiles ( ) ; will ( returnValue ( toLinkedSet ( file1 ) ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 ) ) ) ; context . checking ( new Expectations ( ) { { one ( src ) . getFiles ( ) ; will ( returnValue ( toLinkedSet ( file1 , file2 ) ) ) ; } } ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void canUseACallableToSpecifyTheContentsOfTheCollection ( ) throws Exception { final File file1 = new File ( <str> ) ; final File file2 = new File ( <str> ) ; final Callable callable = context . mock ( Callable . class ) ; context . checking ( new Expectations ( ) { { one ( callable ) . call ( ) ; will ( returnValue ( toList ( <str> , <str> ) ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file1 ) ) ; allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( file2 ) ) ; } } ) ; collection . from ( callable ) ; assertThat ( collection . getFiles ( ) , equalTo ( toLinkedSet ( file1 , file2 ) ) ) ; } @Test public void callableCanReturnNull ( ) throws Exception { final Callable callable = context . mock ( Callable . class ) ; context . checking ( new Expectations ( ) { { one ( callable ) . call ( ) ; will ( returnValue ( null ) ) ; } } ) ; collection . from ( callable ) ; assertThat ( collection . getFiles ( ) , isEmpty ( ) ) ; } @Test public void resolveAddsEachSourceObjectAndBuildDependencies ( ) { final FileCollectionResolveContext resolveContext = context . mock ( FileCollectionResolveContext . class ) ; final FileCollectionResolveContext nestedContext = context . mock ( FileCollectionResolveContext . class ) ; final FileCollection fileCollectionMock = context . mock ( FileCollection . class ) ; collection . from ( <str> ) ; collection . from ( fileCollectionMock ) ; context . checking ( new Expectations ( ) { { one ( resolveContext ) . push ( resolverMock ) ; will ( returnValue ( nestedContext ) ) ; one ( nestedContext ) . add ( collection . getFrom ( ) ) ; } } ) ; collection . visitContents ( resolveContext ) ; } @Test public void canGetAndSetTaskDependencies ( ) { assertThat ( collection . getBuiltBy ( ) , isEmpty ( ) ) ; collection . builtBy ( <str> ) ; collection . builtBy ( <str> ) ; collection . from ( <str> ) ; assertThat ( collection . getBuiltBy ( ) , equalTo ( toSet ( ( Object ) <str> , <str> ) ) ) ; collection . setBuiltBy ( toList ( <str> ) ) ; assertThat ( collection . getBuiltBy ( ) , equalTo ( toSet ( ( Object ) <str> ) ) ) ; final Task task = context . mock ( Task . class ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( new File ( <str> ) ) ) ; allowing ( taskResolverStub ) . resolveTask ( <str> ) ; will ( returnValue ( task ) ) ; } } ) ; assertThat ( collection . getBuildDependencies ( ) . getDependencies ( null ) , equalTo ( ( Set ) toSet ( task ) ) ) ; } @Test public void taskDependenciesContainsUnionOfDependenciesOfNestedFileCollectionsPlusOwnDependencies ( ) { final FileCollectionInternal fileCollectionMock = context . mock ( FileCollectionInternal . class ) ; collection . from ( fileCollectionMock ) ; collection . from ( <str> ) ; collection . builtBy ( <str> ) ; final Task taskA = context . mock ( Task . class , <str> ) ; final Task taskB = context . mock ( Task . class , <str> ) ; context . checking ( new Expectations ( ) { { allowing ( resolverMock ) . resolve ( <str> ) ; will ( returnValue ( new File ( <str> ) ) ) ; TaskDependency dependency = context . mock ( TaskDependency . class ) ; allowing ( fileCollectionMock ) . getBuildDependencies ( ) ; will ( returnValue ( dependency ) ) ; allowing ( dependency ) . getDependencies ( null ) ; will ( returnValue ( toSet ( taskA ) ) ) ; allowing ( taskResolverStub ) . resolveTask ( <str> ) ; will ( returnValue ( taskB ) ) ; } } ) ; assertThat ( collection . getBuildDependencies ( ) . getDependencies ( null ) , equalTo ( ( Set ) toSet ( taskA , taskB ) ) ) ; } @Test public void hasSpecifiedDependenciesWhenEmpty ( ) { collection . builtBy ( <str> ) ; final Task task = context . mock ( Task . class ) ; context . checking ( new Expectations ( ) { { allowing ( taskResolverStub ) . resolveTask ( <str> ) ; will ( returnValue ( task ) ) ; } } ) ; assertThat ( collection . getBuildDependencies ( ) . getDependencies ( null ) , equalTo ( ( Set ) toSet ( task ) ) ) ; assertThat ( collection . getAsFileTree ( ) . getBuildDependencies ( ) . getDependencies ( null ) , equalTo ( ( Set ) toSet ( task ) ) ) ; assertThat ( collection . getAsFileTree ( ) . matching ( TestUtil . TEST_CLOSURE ) . getBuildDependencies ( ) . getDependencies ( null ) , equalTo ( ( Set ) toSet ( task ) ) ) ; } } 
