package org . apache . cassandra . serializers ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . regex . Pattern ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . LocalDate ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import org . apache . cassandra . utils . ByteBufferUtil ; public class SimpleDateSerializer implements TypeSerializer < Integer > { private static final DateTimeFormatter formatter = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) ; private static final long minSupportedDateMillis = TimeUnit . DAYS . toMillis ( Integer . MIN_VALUE ) ; private static final long maxSupportedDateMillis = TimeUnit . DAYS . toMillis ( Integer . MAX_VALUE ) ; private static final long maxSupportedDays = ( long ) Math . pow ( <int> , <int> ) - <int> ; private static final long byteOrderShift = ( long ) Math . pow ( <int> , <int> ) * <int> ; private static final Pattern rawPattern = Pattern . compile ( <str> ) ; public static final SimpleDateSerializer instance = new SimpleDateSerializer ( ) ; public Integer deserialize ( ByteBuffer bytes ) { return bytes . remaining ( ) = = <int> ? null : ByteBufferUtil . toInt ( bytes ) ; } public ByteBuffer serialize ( Integer value ) { return value = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : ByteBufferUtil . bytes ( value ) ; } public static int dateStringToDays ( String source ) throws MarshalException { if ( rawPattern . matcher ( source ) . matches ( ) ) { try { long result = Long . parseLong ( source ) ; if ( result < <int> | | result > maxSupportedDays ) throw new NumberFormatException ( <str> + source ) ; if ( result > = Integer . MAX_VALUE ) result - = byteOrderShift ; return ( int ) result ; } catch ( NumberFormatException e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } } try { DateTime parsed = formatter . parseDateTime ( source ) ; long millis = parsed . getMillis ( ) ; if ( millis < minSupportedDateMillis ) throw new MarshalException ( String . format ( <str> , source , new LocalDate ( minSupportedDateMillis ) . toString ( ) ) ) ; if ( millis > maxSupportedDateMillis ) throw new MarshalException ( String . format ( <str> , source , new LocalDate ( maxSupportedDateMillis ) . toString ( ) ) ) ; return timeInMillisToDay ( millis ) ; } catch ( IllegalArgumentException e1 ) { throw new MarshalException ( String . format ( <str> , source ) , e1 ) ; } } public static int timeInMillisToDay ( long millis ) { Integer result = ( int ) TimeUnit . MILLISECONDS . toDays ( millis ) ; result - = Integer . MIN_VALUE ; return result ; } public static long dayToTimeInMillis ( int days ) { return TimeUnit . DAYS . toMillis ( days - Integer . MIN_VALUE ) ; } public void validate ( ByteBuffer bytes ) throws MarshalException { if ( bytes . remaining ( ) ! = <int> ) throw new MarshalException ( String . format ( <str> , bytes . remaining ( ) ) ) ; } public String toString ( Integer value ) { if ( value = = null ) return <str> ; return formatter . print ( new LocalDate ( dayToTimeInMillis ( value ) , DateTimeZone . UTC ) ) ; } public Class < Integer > getType ( ) { return Integer . class ; } } 
