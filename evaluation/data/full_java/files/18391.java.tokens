package com . badlogic . gdx . utils ; import java . io . DataInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . utils . JsonWriter . OutputType ; public class UBJsonReader implements BaseJsonReader { public boolean oldFormat = true ; @Override public JsonValue parse ( InputStream input ) { DataInputStream din = null ; try { din = new DataInputStream ( input ) ; return parse ( din ) ; } catch ( IOException ex ) { throw new SerializationException ( ex ) ; } finally { StreamUtils . closeQuietly ( din ) ; } } @Override public JsonValue parse ( FileHandle file ) { try { return parse ( file . read ( <int> ) ) ; } catch ( Exception ex ) { throw new SerializationException ( <str> + file , ex ) ; } } public JsonValue parse ( final DataInputStream din ) throws IOException { try { return parse ( din , din . readByte ( ) ) ; } finally { StreamUtils . closeQuietly ( din ) ; } } protected JsonValue parse ( final DataInputStream din , final byte type ) throws IOException { if ( type = = <str> ) return parseArray ( din ) ; else if ( type = = <str> ) return parseObject ( din ) ; else if ( type = = <str> ) return new JsonValue ( JsonValue . ValueType . nullValue ) ; else if ( type = = <str> ) return new JsonValue ( true ) ; else if ( type = = <str> ) return new JsonValue ( false ) ; else if ( type = = <str> ) return new JsonValue ( ( long ) readUChar ( din ) ) ; else if ( type = = <str> ) return new JsonValue ( ( long ) readUChar ( din ) ) ; else if ( type = = <str> ) return new JsonValue ( oldFormat ? ( long ) din . readShort ( ) : ( long ) din . readByte ( ) ) ; else if ( type = = <str> ) return new JsonValue ( oldFormat ? ( long ) din . readInt ( ) : ( long ) din . readShort ( ) ) ; else if ( type = = <str> ) return new JsonValue ( ( long ) din . readInt ( ) ) ; else if ( type = = <str> ) return new JsonValue ( din . readLong ( ) ) ; else if ( type = = <str> ) return new JsonValue ( din . readFloat ( ) ) ; else if ( type = = <str> ) return new JsonValue ( din . readDouble ( ) ) ; else if ( type = = <str> | | type = = <str> ) return new JsonValue ( parseString ( din , type ) ) ; else if ( type = = <str> | | type = = <str> ) return parseData ( din , type ) ; else throw new GdxRuntimeException ( <str> ) ; } protected JsonValue parseArray ( final DataInputStream din ) throws IOException { JsonValue result = new JsonValue ( JsonValue . ValueType . array ) ; byte type = din . readByte ( ) ; byte valueType = <int> ; if ( type = = <str> ) { valueType = din . readByte ( ) ; type = din . readByte ( ) ; } long size = - <int> ; if ( type = = <str> ) { size = parseSize ( din , false , - <int> ) ; if ( size < <int> ) throw new GdxRuntimeException ( <str> ) ; if ( size = = <int> ) return result ; type = valueType = = <int> ? din . readByte ( ) : valueType ; } JsonValue prev = null ; long c = <int> ; while ( din . available ( ) > <int> & & type ! = <str> ) { final JsonValue val = parse ( din , type ) ; val . parent = result ; if ( prev ! = null ) { val . prev = prev ; prev . next = val ; result . size + + ; } else { result . child = val ; result . size = <int> ; } prev = val ; if ( size > <int> & & + + c > = size ) break ; type = valueType = = <int> ? din . readByte ( ) : valueType ; } return result ; } protected JsonValue parseObject ( final DataInputStream din ) throws IOException { JsonValue result = new JsonValue ( JsonValue . ValueType . object ) ; byte type = din . readByte ( ) ; byte valueType = <int> ; if ( type = = <str> ) { valueType = din . readByte ( ) ; type = din . readByte ( ) ; } long size = - <int> ; if ( type = = <str> ) { size = parseSize ( din , false , - <int> ) ; if ( size < <int> ) throw new GdxRuntimeException ( <str> ) ; if ( size = = <int> ) return result ; type = din . readByte ( ) ; } JsonValue prev = null ; long c = <int> ; while ( din . available ( ) > <int> & & type ! = <str> ) { final String key = parseString ( din , true , type ) ; final JsonValue child = parse ( din , valueType = = <int> ? din . readByte ( ) : valueType ) ; child . setName ( key ) ; child . parent = result ; if ( prev ! = null ) { child . prev = prev ; prev . next = child ; result . size + + ; } else { result . child = child ; result . size = <int> ; } prev = child ; if ( size > <int> & & + + c > = size ) break ; type = din . readByte ( ) ; } return result ; } protected JsonValue parseData ( final DataInputStream din , final byte blockType ) throws IOException { final byte dataType = din . readByte ( ) ; final long size = blockType = = <str> ? readUInt ( din ) : ( long ) readUChar ( din ) ; final JsonValue result = new JsonValue ( JsonValue . ValueType . array ) ; JsonValue prev = null ; for ( long i = <int> ; i < size ; i + + ) { final JsonValue val = parse ( din , dataType ) ; val . parent = result ; if ( prev ! = null ) { prev . next = val ; result . size + + ; } else { result . child = val ; result . size = <int> ; } prev = val ; } return result ; } protected String parseString ( final DataInputStream din , final byte type ) throws IOException { return parseString ( din , false , type ) ; } protected String parseString ( final DataInputStream din , final boolean sOptional , final byte type ) throws IOException { long size = - <int> ; if ( type = = <str> ) { size = parseSize ( din , true , - <int> ) ; } else if ( type = = <str> ) size = ( long ) readUChar ( din ) ; else if ( sOptional ) size = parseSize ( din , type , false , - <int> ) ; if ( size < <int> ) throw new GdxRuntimeException ( <str> ) ; return size > <int> ? readString ( din , size ) : <str> ; } protected long parseSize ( final DataInputStream din , final boolean useIntOnError , final long defaultValue ) throws IOException { return parseSize ( din , din . readByte ( ) , useIntOnError , defaultValue ) ; } protected long parseSize ( final DataInputStream din , final byte type , final boolean useIntOnError , final long defaultValue ) throws IOException { if ( type = = <str> ) return ( long ) readUChar ( din ) ; if ( type = = <str> ) return ( long ) readUShort ( din ) ; if ( type = = <str> ) return ( long ) readUInt ( din ) ; if ( type = = <str> ) return din . readLong ( ) ; if ( useIntOnError ) { long result = ( long ) ( ( short ) type & <hex> ) < < <int> ; result | = ( long ) ( ( short ) din . readByte ( ) & <hex> ) < < <int> ; result | = ( long ) ( ( short ) din . readByte ( ) & <hex> ) < < <int> ; result | = ( long ) ( ( short ) din . readByte ( ) & <hex> ) ; return result ; } return defaultValue ; } protected short readUChar ( final DataInputStream din ) throws IOException { return ( short ) ( ( short ) din . readByte ( ) & <hex> ) ; } protected int readUShort ( final DataInputStream din ) throws IOException { return ( ( int ) din . readShort ( ) & <hex> ) ; } protected long readUInt ( final DataInputStream din ) throws IOException { return ( ( long ) din . readInt ( ) & <hex> ) ; } protected String readString ( final DataInputStream din , final long size ) throws IOException { final byte data [ ] = new byte [ ( int ) size ] ; din . readFully ( data ) ; return new String ( data , <str> ) ; } } 
