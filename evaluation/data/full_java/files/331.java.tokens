package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . List ; import java . util . Objects ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . rows . RangeTombstoneMarker ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public class RangeTombstone { private final Slice slice ; private final DeletionTime deletion ; public RangeTombstone ( Slice slice , DeletionTime deletion ) { this . slice = slice ; this . deletion = deletion ; } public Slice deletedSlice ( ) { return slice ; } public DeletionTime deletionTime ( ) { return deletion ; } public String toString ( ClusteringComparator comparator ) { return slice . toString ( comparator ) + <str> + deletion ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof RangeTombstone ) ) return false ; RangeTombstone that = ( RangeTombstone ) other ; return this . deletedSlice ( ) . equals ( that . deletedSlice ( ) ) & & this . deletionTime ( ) . equals ( that . deletionTime ( ) ) ; } @Override public int hashCode ( ) { return Objects . hash ( deletedSlice ( ) , deletionTime ( ) ) ; } public static class Bound extends Slice . Bound { public static final Serializer serializer = new Serializer ( ) ; public static final Bound BOTTOM = new Bound ( Kind . INCL_START_BOUND , EMPTY_VALUES_ARRAY ) ; public static final Bound TOP = new Bound ( Kind . INCL_END_BOUND , EMPTY_VALUES_ARRAY ) ; public Bound ( Kind kind , ByteBuffer [ ] values ) { super ( kind , values ) ; assert values . length > <int> | | ! kind . isBoundary ( ) ; } public boolean isBoundary ( ) { return kind . isBoundary ( ) ; } public boolean isOpen ( boolean reversed ) { return kind . isOpen ( reversed ) ; } public boolean isClose ( boolean reversed ) { return kind . isClose ( reversed ) ; } public static RangeTombstone . Bound inclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . INCL_END_BOUND : Kind . INCL_START_BOUND , boundValues ) ; } public static RangeTombstone . Bound exclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . EXCL_END_BOUND : Kind . EXCL_START_BOUND , boundValues ) ; } public static RangeTombstone . Bound inclusiveClose ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . INCL_START_BOUND : Kind . INCL_END_BOUND , boundValues ) ; } public static RangeTombstone . Bound exclusiveClose ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . EXCL_START_BOUND : Kind . EXCL_END_BOUND , boundValues ) ; } public static RangeTombstone . Bound inclusiveCloseExclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . EXCL_END_INCL_START_BOUNDARY : Kind . INCL_END_EXCL_START_BOUNDARY , boundValues ) ; } public static RangeTombstone . Bound exclusiveCloseInclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues ) { return new Bound ( reversed ? Kind . INCL_END_EXCL_START_BOUNDARY : Kind . EXCL_END_INCL_START_BOUNDARY , boundValues ) ; } public static RangeTombstone . Bound fromSliceBound ( Slice . Bound sliceBound ) { return new RangeTombstone . Bound ( sliceBound . kind ( ) , sliceBound . getRawValues ( ) ) ; } public RangeTombstone . Bound copy ( AbstractAllocator allocator ) { ByteBuffer [ ] newValues = new ByteBuffer [ size ( ) ] ; for ( int i = <int> ; i < size ( ) ; i + + ) newValues [ i ] = allocator . clone ( get ( i ) ) ; return new Bound ( kind ( ) , newValues ) ; } @Override public Bound withNewKind ( Kind kind ) { return new Bound ( kind , values ) ; } public static class Serializer { public void serialize ( RangeTombstone . Bound bound , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { out . writeByte ( bound . kind ( ) . ordinal ( ) ) ; out . writeShort ( bound . size ( ) ) ; ClusteringPrefix . serializer . serializeValuesWithoutSize ( bound , out , version , types ) ; } public long serializedSize ( RangeTombstone . Bound bound , int version , List < AbstractType < ? > > types ) { return <int> + TypeSizes . sizeof ( ( short ) bound . size ( ) ) + ClusteringPrefix . serializer . valuesWithoutSizeSerializedSize ( bound , version , types ) ; } public RangeTombstone . Bound deserialize ( DataInputPlus in , int version , List < AbstractType < ? > > types ) throws IOException { Kind kind = Kind . values ( ) [ in . readByte ( ) ] ; int size = in . readUnsignedShort ( ) ; if ( size = = <int> ) return kind . isStart ( ) ? BOTTOM : TOP ; ByteBuffer [ ] values = ClusteringPrefix . serializer . deserializeValuesWithoutSize ( in , size , version , types ) ; return new RangeTombstone . Bound ( kind , values ) ; } } } } 
