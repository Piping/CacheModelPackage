package org . apache . cassandra . cql3 ; import static org . apache . cassandra . cql3 . Constants . UNSET_VALUE ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . stream . Collectors ; import com . google . common . base . Joiner ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . serializers . CollectionSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class Sets { private Sets ( ) { } public static ColumnSpecification valueSpecOf ( ColumnSpecification column ) { return new ColumnSpecification ( column . ksName , column . cfName , new ColumnIdentifier ( <str> + column . name + <str> , true ) , ( ( SetType ) column . type ) . getElementsType ( ) ) ; } public static class Literal extends Term . Raw { private final List < Term . Raw > elements ; public Literal ( List < Term . Raw > elements ) { this . elements = elements ; } public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { validateAssignableTo ( keyspace , receiver ) ; if ( receiver . type instanceof MapType & & elements . isEmpty ( ) ) return new Maps . Value ( Collections . < ByteBuffer , ByteBuffer > emptyMap ( ) ) ; ColumnSpecification valueSpec = Sets . valueSpecOf ( receiver ) ; Set < Term > values = new HashSet < > ( elements . size ( ) ) ; boolean allTerminal = true ; for ( Term . Raw rt : elements ) { Term t = rt . prepare ( keyspace , valueSpec ) ; if ( t . containsBindMarker ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; if ( t instanceof Term . NonTerminal ) allTerminal = false ; values . add ( t ) ; } DelayedValue value = new DelayedValue ( ( ( SetType ) receiver . type ) . getElementsType ( ) , values ) ; return allTerminal ? value . bind ( QueryOptions . DEFAULT ) : value ; } private void validateAssignableTo ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof SetType ) ) { if ( ( receiver . type instanceof MapType ) & & elements . isEmpty ( ) ) return ; throw new InvalidRequestException ( String . format ( <str> , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; } ColumnSpecification valueSpec = Sets . valueSpecOf ( receiver ) ; for ( Term . Raw rt : elements ) { if ( ! rt . testAssignment ( keyspace , valueSpec ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name , rt , valueSpec . type . asCQL3Type ( ) ) ) ; } } public AssignmentTestable . TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { if ( ! ( receiver . type instanceof SetType ) ) { if ( receiver . type instanceof MapType & & elements . isEmpty ( ) ) return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; } if ( elements . isEmpty ( ) ) return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; ColumnSpecification valueSpec = Sets . valueSpecOf ( receiver ) ; return AssignmentTestable . TestResult . testAll ( keyspace , valueSpec , elements ) ; } public String getText ( ) { return elements . stream ( ) . map ( Term . Raw : : getText ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } } public static class Value extends Term . Terminal { public final SortedSet < ByteBuffer > elements ; public Value ( SortedSet < ByteBuffer > elements ) { this . elements = elements ; } public static Value fromSerialized ( ByteBuffer value , SetType type , int version ) throws InvalidRequestException { try { Set < ? > s = type . getSerializer ( ) . deserializeForNativeProtocol ( value , version ) ; SortedSet < ByteBuffer > elements = new TreeSet < > ( type . getElementsType ( ) ) ; for ( Object element : s ) elements . add ( type . getElementsType ( ) . decompose ( element ) ) ; return new Value ( elements ) ; } catch ( MarshalException e ) { throw new InvalidRequestException ( e . getMessage ( ) ) ; } } public ByteBuffer get ( int protocolVersion ) { return CollectionSerializer . pack ( elements , elements . size ( ) , protocolVersion ) ; } public boolean equals ( SetType st , Value v ) { if ( elements . size ( ) ! = v . elements . size ( ) ) return false ; Iterator < ByteBuffer > thisIter = elements . iterator ( ) ; Iterator < ByteBuffer > thatIter = v . elements . iterator ( ) ; AbstractType elementsType = st . getElementsType ( ) ; while ( thisIter . hasNext ( ) ) if ( elementsType . compare ( thisIter . next ( ) , thatIter . next ( ) ) ! = <int> ) return false ; return true ; } } public static class DelayedValue extends Term . NonTerminal { private final Comparator < ByteBuffer > comparator ; private final Set < Term > elements ; public DelayedValue ( Comparator < ByteBuffer > comparator , Set < Term > elements ) { this . comparator = comparator ; this . elements = elements ; } public boolean containsBindMarker ( ) { return false ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { } public Terminal bind ( QueryOptions options ) throws InvalidRequestException { SortedSet < ByteBuffer > buffers = new TreeSet < > ( comparator ) ; for ( Term t : elements ) { ByteBuffer bytes = t . bindAndGet ( options ) ; if ( bytes = = null ) throw new InvalidRequestException ( <str> ) ; if ( bytes = = ByteBufferUtil . UNSET_BYTE_BUFFER ) return UNSET_VALUE ; buffers . add ( bytes ) ; } return new Value ( buffers ) ; } public Iterable < Function > getFunctions ( ) { return Terms . getFunctions ( elements ) ; } } public static class Marker extends AbstractMarker { protected Marker ( int bindIndex , ColumnSpecification receiver ) { super ( bindIndex , receiver ) ; assert receiver . type instanceof SetType ; } public Terminal bind ( QueryOptions options ) throws InvalidRequestException { ByteBuffer value = options . getValues ( ) . get ( bindIndex ) ; if ( value = = null ) return null ; if ( value = = ByteBufferUtil . UNSET_BYTE_BUFFER ) return UNSET_VALUE ; return Value . fromSerialized ( value , ( SetType ) receiver . type , options . getProtocolVersion ( ) ) ; } } public static class Setter extends Operation { public Setter ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { Term . Terminal value = t . bind ( params . options ) ; if ( value = = UNSET_VALUE ) return ; if ( column . type . isMultiCell ( ) ) params . setComplexDeletionTimeForOverwrite ( column ) ; Adder . doAdd ( value , column , params ) ; } } public static class Adder extends Operation { public Adder ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal value = t . bind ( params . options ) ; if ( value ! = UNSET_VALUE ) doAdd ( value , column , params ) ; } static void doAdd ( Term . Terminal value , ColumnDefinition column , UpdateParameters params ) throws InvalidRequestException { if ( column . type . isMultiCell ( ) ) { if ( value = = null ) return ; for ( ByteBuffer bb : ( ( Value ) value ) . elements ) { if ( bb = = ByteBufferUtil . UNSET_BYTE_BUFFER ) continue ; params . addCell ( column , CellPath . create ( bb ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; } } else { if ( value = = null ) params . addTombstone ( column ) ; else params . addCell ( column , value . get ( Server . CURRENT_VERSION ) ) ; } } } public static class Discarder extends Operation { public Discarder ( ColumnDefinition column , Term t ) { super ( column , t ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal value = t . bind ( params . options ) ; if ( value = = null | | value = = UNSET_VALUE ) return ; Set < ByteBuffer > toDiscard = value instanceof Sets . Value ? ( ( Sets . Value ) value ) . elements : Collections . singleton ( value . get ( params . options . getProtocolVersion ( ) ) ) ; for ( ByteBuffer bb : toDiscard ) params . addTombstone ( column , CellPath . create ( bb ) ) ; } } public static class ElementDiscarder extends Operation { public ElementDiscarder ( ColumnDefinition column , Term k ) { super ( column , k ) ; } public void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException { assert column . type . isMultiCell ( ) : <str> ; Term . Terminal elt = t . bind ( params . options ) ; if ( elt = = null ) throw new InvalidRequestException ( <str> ) ; params . addTombstone ( column , CellPath . create ( elt . get ( params . options . getProtocolVersion ( ) ) ) ) ; } } } 
