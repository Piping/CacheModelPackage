package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . transport . Event ; public abstract class AlterTypeStatement extends SchemaAlteringStatement { protected final UTName name ; protected AlterTypeStatement ( UTName name ) { super ( ) ; this . name = name ; } @Override public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( ! name . hasKeyspace ( ) ) name . setKeyspace ( state . getKeyspace ( ) ) ; if ( name . getKeyspace ( ) = = null ) throw new InvalidRequestException ( <str> ) ; } protected abstract UserType makeUpdatedType ( UserType toUpdate ) throws InvalidRequestException ; public static AlterTypeStatement addition ( UTName name , ColumnIdentifier fieldName , CQL3Type . Raw type ) { return new AddOrAlter ( name , true , fieldName , type ) ; } public static AlterTypeStatement alter ( UTName name , ColumnIdentifier fieldName , CQL3Type . Raw type ) { return new AddOrAlter ( name , false , fieldName , type ) ; } public static AlterTypeStatement renames ( UTName name , Map < ColumnIdentifier , ColumnIdentifier > renames ) { return new Renames ( name , renames ) ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . hasKeyspaceAccess ( keyspace ( ) , Permission . ALTER ) ; } public void validate ( ClientState state ) throws RequestValidationException { } @Override public String keyspace ( ) { return name . getKeyspace ( ) ; } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws InvalidRequestException , ConfigurationException { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( name . getKeyspace ( ) ) ; if ( ksm = = null ) throw new InvalidRequestException ( String . format ( <str> , name . getKeyspace ( ) ) ) ; UserType toUpdate = ksm . types . get ( name . getUserTypeName ( ) ) . orElseThrow ( ( ) - > new InvalidRequestException ( String . format ( <str> , name ) ) ) ; UserType updated = makeUpdatedType ( toUpdate ) ; MigrationManager . announceTypeUpdate ( updated , isLocalOnly ) ; for ( CFMetaData cfm : ksm . tables ) { CFMetaData copy = cfm . copy ( ) ; boolean modified = false ; for ( ColumnDefinition def : copy . allColumns ( ) ) modified | = updateDefinition ( copy , def , toUpdate . keyspace , toUpdate . name , updated ) ; if ( modified ) MigrationManager . announceColumnFamilyUpdate ( copy , false , isLocalOnly ) ; } for ( ViewDefinition view : ksm . views ) { ViewDefinition copy = view . copy ( ) ; boolean modified = false ; for ( ColumnDefinition def : copy . metadata . allColumns ( ) ) modified | = updateDefinition ( copy . metadata , def , toUpdate . keyspace , toUpdate . name , updated ) ; if ( modified ) MigrationManager . announceViewUpdate ( copy , isLocalOnly ) ; } for ( UserType ut : ksm . types ) { if ( ut . keyspace . equals ( toUpdate . keyspace ) & & ut . name . equals ( toUpdate . name ) ) { if ( ! ut . keyspace . equals ( updated . keyspace ) | | ! ut . name . equals ( updated . name ) ) MigrationManager . announceTypeDrop ( ut ) ; continue ; } AbstractType < ? > upd = updateWith ( ut , toUpdate . keyspace , toUpdate . name , updated ) ; if ( upd ! = null ) MigrationManager . announceTypeUpdate ( ( UserType ) upd , isLocalOnly ) ; } return new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TYPE , keyspace ( ) , name . getStringTypeName ( ) ) ; } private static int getIdxOfField ( UserType type , ColumnIdentifier field ) { for ( int i = <int> ; i < type . size ( ) ; i + + ) if ( field . bytes . equals ( type . fieldName ( i ) ) ) return i ; return - <int> ; } private boolean updateDefinition ( CFMetaData cfm , ColumnDefinition def , String keyspace , ByteBuffer toReplace , UserType updated ) { AbstractType < ? > t = updateWith ( def . type , keyspace , toReplace , updated ) ; if ( t = = null ) return false ; cfm . addOrReplaceColumnDefinition ( def . withNewType ( t ) ) ; return true ; } private static AbstractType < ? > updateWith ( AbstractType < ? > type , String keyspace , ByteBuffer toReplace , UserType updated ) { if ( type instanceof UserType ) { UserType ut = ( UserType ) type ; if ( keyspace . equals ( ut . keyspace ) & & toReplace . equals ( ut . name ) ) return updated ; List < AbstractType < ? > > updatedTypes = updateTypes ( ut . fieldTypes ( ) , keyspace , toReplace , updated ) ; return updatedTypes = = null ? null : new UserType ( ut . keyspace , ut . name , new ArrayList < > ( ut . fieldNames ( ) ) , updatedTypes ) ; } else if ( type instanceof TupleType ) { TupleType tt = ( TupleType ) type ; List < AbstractType < ? > > updatedTypes = updateTypes ( tt . allTypes ( ) , keyspace , toReplace , updated ) ; return updatedTypes = = null ? null : new TupleType ( updatedTypes ) ; } else if ( type instanceof CompositeType ) { CompositeType ct = ( CompositeType ) type ; List < AbstractType < ? > > updatedTypes = updateTypes ( ct . types , keyspace , toReplace , updated ) ; return updatedTypes = = null ? null : CompositeType . getInstance ( updatedTypes ) ; } else if ( type instanceof CollectionType ) { if ( type instanceof ListType ) { AbstractType < ? > t = updateWith ( ( ( ListType ) type ) . getElementsType ( ) , keyspace , toReplace , updated ) ; if ( t = = null ) return null ; return ListType . getInstance ( t , type . isMultiCell ( ) ) ; } else if ( type instanceof SetType ) { AbstractType < ? > t = updateWith ( ( ( SetType ) type ) . getElementsType ( ) , keyspace , toReplace , updated ) ; if ( t = = null ) return null ; return SetType . getInstance ( t , type . isMultiCell ( ) ) ; } else { assert type instanceof MapType ; MapType mt = ( MapType ) type ; AbstractType < ? > k = updateWith ( mt . getKeysType ( ) , keyspace , toReplace , updated ) ; AbstractType < ? > v = updateWith ( mt . getValuesType ( ) , keyspace , toReplace , updated ) ; if ( k = = null & & v = = null ) return null ; return MapType . getInstance ( k = = null ? mt . getKeysType ( ) : k , v = = null ? mt . getValuesType ( ) : v , type . isMultiCell ( ) ) ; } } else { return null ; } } private static List < AbstractType < ? > > updateTypes ( List < AbstractType < ? > > toUpdate , String keyspace , ByteBuffer toReplace , UserType updated ) { List < AbstractType < ? > > updatedTypes = null ; for ( int i = <int> ; i < toUpdate . size ( ) ; i + + ) { AbstractType < ? > t = updateWith ( toUpdate . get ( i ) , keyspace , toReplace , updated ) ; if ( t = = null ) continue ; if ( updatedTypes = = null ) updatedTypes = new ArrayList < > ( toUpdate ) ; updatedTypes . set ( i , t ) ; } return updatedTypes ; } private static class AddOrAlter extends AlterTypeStatement { private final boolean isAdd ; private final ColumnIdentifier fieldName ; private final CQL3Type . Raw type ; public AddOrAlter ( UTName name , boolean isAdd , ColumnIdentifier fieldName , CQL3Type . Raw type ) { super ( name ) ; this . isAdd = isAdd ; this . fieldName = fieldName ; this . type = type ; } private UserType doAdd ( UserType toUpdate ) throws InvalidRequestException { if ( getIdxOfField ( toUpdate , fieldName ) > = <int> ) throw new InvalidRequestException ( String . format ( <str> , fieldName , name ) ) ; List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . size ( ) + <int> ) ; newNames . addAll ( toUpdate . fieldNames ( ) ) ; newNames . add ( fieldName . bytes ) ; AbstractType < ? > addType = type . prepare ( keyspace ( ) ) . getType ( ) ; if ( addType . references ( toUpdate ) ) throw new InvalidRequestException ( String . format ( <str> , fieldName , type , name ) ) ; List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . size ( ) + <int> ) ; newTypes . addAll ( toUpdate . fieldTypes ( ) ) ; newTypes . add ( addType ) ; return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; } private UserType doAlter ( UserType toUpdate ) throws InvalidRequestException { int idx = getIdxOfField ( toUpdate , fieldName ) ; if ( idx < <int> ) throw new InvalidRequestException ( String . format ( <str> , fieldName , name ) ) ; AbstractType < ? > previous = toUpdate . fieldType ( idx ) ; if ( ! type . prepare ( keyspace ( ) ) . getType ( ) . isCompatibleWith ( previous ) ) throw new InvalidRequestException ( String . format ( <str> , type , previous . asCQL3Type ( ) , fieldName , name ) ) ; List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ( ) ) ; List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ( ) ) ; newTypes . set ( idx , type . prepare ( keyspace ( ) ) . getType ( ) ) ; return new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; } protected UserType makeUpdatedType ( UserType toUpdate ) throws InvalidRequestException { return isAdd ? doAdd ( toUpdate ) : doAlter ( toUpdate ) ; } } private static class Renames extends AlterTypeStatement { private final Map < ColumnIdentifier , ColumnIdentifier > renames ; public Renames ( UTName name , Map < ColumnIdentifier , ColumnIdentifier > renames ) { super ( name ) ; this . renames = renames ; } protected UserType makeUpdatedType ( UserType toUpdate ) throws InvalidRequestException { List < ByteBuffer > newNames = new ArrayList < > ( toUpdate . fieldNames ( ) ) ; List < AbstractType < ? > > newTypes = new ArrayList < > ( toUpdate . fieldTypes ( ) ) ; for ( Map . Entry < ColumnIdentifier , ColumnIdentifier > entry : renames . entrySet ( ) ) { ColumnIdentifier from = entry . getKey ( ) ; ColumnIdentifier to = entry . getValue ( ) ; int idx = getIdxOfField ( toUpdate , from ) ; if ( idx < <int> ) throw new InvalidRequestException ( String . format ( <str> , from , name ) ) ; newNames . set ( idx , to . bytes ) ; } UserType updated = new UserType ( toUpdate . keyspace , toUpdate . name , newNames , newTypes ) ; CreateTypeStatement . checkForDuplicateNames ( updated ) ; return updated ; } } } 
