package org . nd4j . linalg . convolution ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; public class OldConvolution { public static INDArray col2im ( INDArray col , int [ ] stride , int [ ] padding , int height , int width ) { return col2im ( col , stride [ <int> ] , stride [ <int> ] , padding [ <int> ] , padding [ <int> ] , height , width ) ; } public static INDArray col2im ( INDArray col , int sy , int sx , int ph , int pw , int h , int w ) { int n = col . size ( <int> ) ; int c = col . size ( <int> ) ; int kh = col . size ( <int> ) ; int kw = col . size ( <int> ) ; int outH = col . size ( <int> ) ; int outW = col . size ( <int> ) ; INDArray img = Nd4j . create ( n , c , h + <int> * ph + sy - <int> , w + <int> * pw + sx - <int> ) ; for ( int i = <int> ; i < kh ; i + + ) { int iLim = i + sy * outH ; for ( int j = <int> ; j < kw ; j + + ) { int jLim = j + sx * outW ; INDArrayIndex [ ] indices = new INDArrayIndex [ ] { NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( i , sy , iLim ) , NDArrayIndex . interval ( j , sx , jLim ) } ; INDArray get = img . get ( indices ) ; INDArray colAdd = col . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . point ( i ) , NDArrayIndex . point ( j ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; get . addi ( colAdd ) ; img . put ( indices , get ) ; } } return img . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( ph , ph + h ) , NDArrayIndex . interval ( pw , pw + w ) ) ; } public static INDArray im2col ( INDArray img , int [ ] kernel , int [ ] stride , int [ ] padding ) { return im2col ( img , kernel [ <int> ] , kernel [ <int> ] , stride [ <int> ] , stride [ <int> ] , padding [ <int> ] , padding [ <int> ] , <int> , false ) ; } public static INDArray im2col ( INDArray img , int kh , int kw , int sy , int sx , int ph , int pw , int pval , boolean coverAll ) { int n = img . size ( <int> ) ; int c = img . size ( <int> ) ; int h = img . size ( <int> ) ; int w = img . size ( <int> ) ; int outHeight = outSize ( h , kh , sy , ph , coverAll ) ; int outWidth = outSize ( w , kw , sx , pw , coverAll ) ; INDArray padded = Nd4j . pad ( img , new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { ph , ph + sy - <int> } , { pw , pw + sx - <int> } } , Nd4j . PadMode . CONSTANT ) ; INDArray ret = Nd4j . create ( n , c , kh , kw , outHeight , outWidth ) ; for ( int i = <int> ; i < kh ; i + + ) { int iLim = i + sy * outHeight ; for ( int j = <int> ; j < kw ; j + + ) { int jLim = j + sx * outWidth ; INDArray get = padded . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( i , sy , iLim ) , NDArrayIndex . interval ( j , sx , jLim ) ) ; ret . put ( new INDArrayIndex [ ] { NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . point ( i ) , NDArrayIndex . point ( j ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) } , get ) ; } } return ret ; } public static int outSize ( int size , int k , int s , int p , boolean coverAll ) { if ( coverAll ) return ( size + p * <int> - k + s - <int> ) / s + <int> ; else return ( size + p * <int> - k ) / s + <int> ; } } 
