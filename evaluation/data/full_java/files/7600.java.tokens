package org . elasticsearch . search . suggest . phrase ; import java . io . IOException ; import java . util . Arrays ; import org . apache . lucene . util . PriorityQueue ; import org . elasticsearch . search . suggest . phrase . DirectCandidateGenerator . Candidate ; import org . elasticsearch . search . suggest . phrase . DirectCandidateGenerator . CandidateSet ; final class CandidateScorer { private final WordScorer scorer ; private final int maxNumCorrections ; private final int gramSize ; public CandidateScorer ( WordScorer scorer , int maxNumCorrections , int gramSize ) { this . scorer = scorer ; this . maxNumCorrections = maxNumCorrections ; this . gramSize = gramSize ; } public Correction [ ] findBestCandiates ( CandidateSet [ ] sets , float errorFraction , double cutoffScore ) throws IOException { if ( sets . length = = <int> ) { return Correction . EMPTY ; } PriorityQueue < Correction > corrections = new PriorityQueue < Correction > ( maxNumCorrections ) { @Override protected boolean lessThan ( Correction a , Correction b ) { return a . compareTo ( b ) < <int> ; } } ; int numMissspellings = <int> ; if ( errorFraction > = <float> ) { numMissspellings = ( int ) errorFraction ; } else { numMissspellings = Math . round ( errorFraction * sets . length ) ; } findCandidates ( sets , new Candidate [ sets . length ] , <int> , Math . max ( <int> , numMissspellings ) , corrections , cutoffScore , <float> ) ; Correction [ ] result = new Correction [ corrections . size ( ) ] ; for ( int i = result . length - <int> ; i > = <int> ; i - - ) { result [ i ] = corrections . pop ( ) ; } assert corrections . size ( ) = = <int> ; return result ; } public void findCandidates ( CandidateSet [ ] candidates , Candidate [ ] path , int ord , int numMissspellingsLeft , PriorityQueue < Correction > corrections , double cutoffScore , final double pathScore ) throws IOException { CandidateSet current = candidates [ ord ] ; if ( ord = = candidates . length - <int> ) { path [ ord ] = current . originalTerm ; updateTop ( candidates , path , corrections , cutoffScore , pathScore + scorer . score ( path , candidates , ord , gramSize ) ) ; if ( numMissspellingsLeft > <int> ) { for ( int i = <int> ; i < current . candidates . length ; i + + ) { path [ ord ] = current . candidates [ i ] ; updateTop ( candidates , path , corrections , cutoffScore , pathScore + scorer . score ( path , candidates , ord , gramSize ) ) ; } } } else { if ( numMissspellingsLeft > <int> ) { path [ ord ] = current . originalTerm ; findCandidates ( candidates , path , ord + <int> , numMissspellingsLeft , corrections , cutoffScore , pathScore + scorer . score ( path , candidates , ord , gramSize ) ) ; for ( int i = <int> ; i < current . candidates . length ; i + + ) { path [ ord ] = current . candidates [ i ] ; findCandidates ( candidates , path , ord + <int> , numMissspellingsLeft - <int> , corrections , cutoffScore , pathScore + scorer . score ( path , candidates , ord , gramSize ) ) ; } } else { path [ ord ] = current . originalTerm ; findCandidates ( candidates , path , ord + <int> , <int> , corrections , cutoffScore , pathScore + scorer . score ( path , candidates , ord , gramSize ) ) ; } } } private void updateTop ( CandidateSet [ ] candidates , Candidate [ ] path , PriorityQueue < Correction > corrections , double cutoffScore , double score ) throws IOException { score = Math . exp ( score ) ; assert Math . abs ( score - score ( path , candidates ) ) < <float> ; if ( score > cutoffScore ) { if ( corrections . size ( ) < maxNumCorrections ) { Candidate [ ] c = new Candidate [ candidates . length ] ; System . arraycopy ( path , <int> , c , <int> , path . length ) ; corrections . add ( new Correction ( score , c ) ) ; } else if ( corrections . top ( ) . compareTo ( score , path ) < <int> ) { Correction top = corrections . top ( ) ; System . arraycopy ( path , <int> , top . candidates , <int> , path . length ) ; top . score = score ; corrections . updateTop ( ) ; } } } public double score ( Candidate [ ] path , CandidateSet [ ] candidates ) throws IOException { double score = <float> ; for ( int i = <int> ; i < candidates . length ; i + + ) { score + = scorer . score ( path , candidates , i , gramSize ) ; } return Math . exp ( score ) ; } } 
