package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . NinePatch ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . graphics . g2d . TextureAtlas . AtlasRegion ; import com . badlogic . gdx . graphics . g2d . TextureAtlas . AtlasSprite ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . utils . BaseDrawable ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . NinePatchDrawable ; import com . badlogic . gdx . scenes . scene2d . utils . SpriteDrawable ; import com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ; import com . badlogic . gdx . scenes . scene2d . utils . TiledDrawable ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . Json . ReadOnlySerializer ; import com . badlogic . gdx . utils . JsonValue ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . SerializationException ; import com . badlogic . gdx . utils . reflect . ClassReflection ; import com . badlogic . gdx . utils . reflect . Method ; import com . badlogic . gdx . utils . reflect . ReflectionException ; public class Skin implements Disposable { ObjectMap < Class , ObjectMap < String , Object > > resources = new ObjectMap ( ) ; TextureAtlas atlas ; public Skin ( ) { } public Skin ( FileHandle skinFile ) { FileHandle atlasFile = skinFile . sibling ( skinFile . nameWithoutExtension ( ) + <str> ) ; if ( atlasFile . exists ( ) ) { atlas = new TextureAtlas ( atlasFile ) ; addRegions ( atlas ) ; } load ( skinFile ) ; } public Skin ( FileHandle skinFile , TextureAtlas atlas ) { this . atlas = atlas ; addRegions ( atlas ) ; load ( skinFile ) ; } public Skin ( TextureAtlas atlas ) { this . atlas = atlas ; addRegions ( atlas ) ; } public void load ( FileHandle skinFile ) { try { getJsonLoader ( skinFile ) . fromJson ( Skin . class , skinFile ) ; } catch ( SerializationException ex ) { throw new SerializationException ( <str> + skinFile , ex ) ; } } public void addRegions ( TextureAtlas atlas ) { Array < AtlasRegion > regions = atlas . getRegions ( ) ; for ( int i = <int> , n = regions . size ; i < n ; i + + ) { AtlasRegion region = regions . get ( i ) ; add ( region . name , region , TextureRegion . class ) ; } } public void add ( String name , Object resource ) { add ( name , resource , resource . getClass ( ) ) ; } public void add ( String name , Object resource , Class type ) { if ( name = = null ) throw new IllegalArgumentException ( <str> ) ; if ( resource = = null ) throw new IllegalArgumentException ( <str> ) ; ObjectMap < String , Object > typeResources = resources . get ( type ) ; if ( typeResources = = null ) { typeResources = new ObjectMap ( type = = TextureRegion . class | | type = = Drawable . class | | type = = Sprite . class ? <int> : <int> ) ; resources . put ( type , typeResources ) ; } typeResources . put ( name , resource ) ; } public void remove ( String name , Class type ) { if ( name = = null ) throw new IllegalArgumentException ( <str> ) ; ObjectMap < String , Object > typeResources = resources . get ( type ) ; typeResources . remove ( name ) ; } public < T > T get ( Class < T > type ) { return get ( <str> , type ) ; } public < T > T get ( String name , Class < T > type ) { if ( name = = null ) throw new IllegalArgumentException ( <str> ) ; if ( type = = null ) throw new IllegalArgumentException ( <str> ) ; if ( type = = Drawable . class ) return ( T ) getDrawable ( name ) ; if ( type = = TextureRegion . class ) return ( T ) getRegion ( name ) ; if ( type = = NinePatch . class ) return ( T ) getPatch ( name ) ; if ( type = = Sprite . class ) return ( T ) getSprite ( name ) ; ObjectMap < String , Object > typeResources = resources . get ( type ) ; if ( typeResources = = null ) throw new GdxRuntimeException ( <str> + type . getName ( ) + <str> + name ) ; Object resource = typeResources . get ( name ) ; if ( resource = = null ) throw new GdxRuntimeException ( <str> + type . getName ( ) + <str> + name ) ; return ( T ) resource ; } public < T > T optional ( String name , Class < T > type ) { if ( name = = null ) throw new IllegalArgumentException ( <str> ) ; if ( type = = null ) throw new IllegalArgumentException ( <str> ) ; ObjectMap < String , Object > typeResources = resources . get ( type ) ; if ( typeResources = = null ) return null ; return ( T ) typeResources . get ( name ) ; } public boolean has ( String name , Class type ) { ObjectMap < String , Object > typeResources = resources . get ( type ) ; if ( typeResources = = null ) return false ; return typeResources . containsKey ( name ) ; } public < T > ObjectMap < String , T > getAll ( Class < T > type ) { return ( ObjectMap < String , T > ) resources . get ( type ) ; } public Color getColor ( String name ) { return get ( name , Color . class ) ; } public BitmapFont getFont ( String name ) { return get ( name , BitmapFont . class ) ; } public TextureRegion getRegion ( String name ) { TextureRegion region = optional ( name , TextureRegion . class ) ; if ( region ! = null ) return region ; Texture texture = optional ( name , Texture . class ) ; if ( texture = = null ) throw new GdxRuntimeException ( <str> + name ) ; region = new TextureRegion ( texture ) ; add ( name , region , TextureRegion . class ) ; return region ; } public TiledDrawable getTiledDrawable ( String name ) { TiledDrawable tiled = optional ( name , TiledDrawable . class ) ; if ( tiled ! = null ) return tiled ; tiled = new TiledDrawable ( getRegion ( name ) ) ; tiled . setName ( name ) ; add ( name , tiled , TiledDrawable . class ) ; return tiled ; } public NinePatch getPatch ( String name ) { NinePatch patch = optional ( name , NinePatch . class ) ; if ( patch ! = null ) return patch ; try { TextureRegion region = getRegion ( name ) ; if ( region instanceof AtlasRegion ) { int [ ] splits = ( ( AtlasRegion ) region ) . splits ; if ( splits ! = null ) { patch = new NinePatch ( region , splits [ <int> ] , splits [ <int> ] , splits [ <int> ] , splits [ <int> ] ) ; int [ ] pads = ( ( AtlasRegion ) region ) . pads ; if ( pads ! = null ) patch . setPadding ( pads [ <int> ] , pads [ <int> ] , pads [ <int> ] , pads [ <int> ] ) ; } } if ( patch = = null ) patch = new NinePatch ( region ) ; add ( name , patch , NinePatch . class ) ; return patch ; } catch ( GdxRuntimeException ex ) { throw new GdxRuntimeException ( <str> + name ) ; } } public Sprite getSprite ( String name ) { Sprite sprite = optional ( name , Sprite . class ) ; if ( sprite ! = null ) return sprite ; try { TextureRegion textureRegion = getRegion ( name ) ; if ( textureRegion instanceof AtlasRegion ) { AtlasRegion region = ( AtlasRegion ) textureRegion ; if ( region . rotate | | region . packedWidth ! = region . originalWidth | | region . packedHeight ! = region . originalHeight ) sprite = new AtlasSprite ( region ) ; } if ( sprite = = null ) sprite = new Sprite ( textureRegion ) ; add ( name , sprite , Sprite . class ) ; return sprite ; } catch ( GdxRuntimeException ex ) { throw new GdxRuntimeException ( <str> + name ) ; } } public Drawable getDrawable ( String name ) { Drawable drawable = optional ( name , Drawable . class ) ; if ( drawable ! = null ) return drawable ; try { TextureRegion textureRegion = getRegion ( name ) ; if ( textureRegion instanceof AtlasRegion ) { AtlasRegion region = ( AtlasRegion ) textureRegion ; if ( region . splits ! = null ) drawable = new NinePatchDrawable ( getPatch ( name ) ) ; else if ( region . rotate | | region . packedWidth ! = region . originalWidth | | region . packedHeight ! = region . originalHeight ) drawable = new SpriteDrawable ( getSprite ( name ) ) ; } if ( drawable = = null ) drawable = new TextureRegionDrawable ( textureRegion ) ; } catch ( GdxRuntimeException ignored ) { } if ( drawable = = null ) { NinePatch patch = optional ( name , NinePatch . class ) ; if ( patch ! = null ) drawable = new NinePatchDrawable ( patch ) ; else { Sprite sprite = optional ( name , Sprite . class ) ; if ( sprite ! = null ) drawable = new SpriteDrawable ( sprite ) ; else throw new GdxRuntimeException ( <str> + name ) ; } } if ( drawable instanceof BaseDrawable ) ( ( BaseDrawable ) drawable ) . setName ( name ) ; add ( name , drawable , Drawable . class ) ; return drawable ; } public String find ( Object resource ) { if ( resource = = null ) throw new IllegalArgumentException ( <str> ) ; ObjectMap < String , Object > typeResources = resources . get ( resource . getClass ( ) ) ; if ( typeResources = = null ) return null ; return typeResources . findKey ( resource , true ) ; } public Drawable newDrawable ( String name ) { return newDrawable ( getDrawable ( name ) ) ; } public Drawable newDrawable ( String name , float r , float g , float b , float a ) { return newDrawable ( getDrawable ( name ) , new Color ( r , g , b , a ) ) ; } public Drawable newDrawable ( String name , Color tint ) { return newDrawable ( getDrawable ( name ) , tint ) ; } public Drawable newDrawable ( Drawable drawable ) { if ( drawable instanceof TiledDrawable ) return new TiledDrawable ( ( TiledDrawable ) drawable ) ; if ( drawable instanceof TextureRegionDrawable ) return new TextureRegionDrawable ( ( TextureRegionDrawable ) drawable ) ; if ( drawable instanceof NinePatchDrawable ) return new NinePatchDrawable ( ( NinePatchDrawable ) drawable ) ; if ( drawable instanceof SpriteDrawable ) return new SpriteDrawable ( ( SpriteDrawable ) drawable ) ; throw new GdxRuntimeException ( <str> + drawable . getClass ( ) ) ; } public Drawable newDrawable ( Drawable drawable , float r , float g , float b , float a ) { return newDrawable ( drawable , new Color ( r , g , b , a ) ) ; } public Drawable newDrawable ( Drawable drawable , Color tint ) { Drawable newDrawable ; if ( drawable instanceof TextureRegionDrawable ) newDrawable = ( ( TextureRegionDrawable ) drawable ) . tint ( tint ) ; else if ( drawable instanceof NinePatchDrawable ) newDrawable = ( ( NinePatchDrawable ) drawable ) . tint ( tint ) ; else if ( drawable instanceof SpriteDrawable ) newDrawable = ( ( SpriteDrawable ) drawable ) . tint ( tint ) ; else throw new GdxRuntimeException ( <str> + drawable . getClass ( ) ) ; if ( newDrawable instanceof BaseDrawable ) { BaseDrawable named = ( BaseDrawable ) newDrawable ; if ( drawable instanceof BaseDrawable ) named . setName ( ( ( BaseDrawable ) drawable ) . getName ( ) + <str> + tint + <str> ) ; else named . setName ( <str> + tint + <str> ) ; } return newDrawable ; } public void setEnabled ( Actor actor , boolean enabled ) { Method method = findMethod ( actor . getClass ( ) , <str> ) ; if ( method = = null ) return ; Object style ; try { style = method . invoke ( actor ) ; } catch ( Exception ignored ) { return ; } String name = find ( style ) ; if ( name = = null ) return ; name = name . replace ( <str> , <str> ) + ( enabled ? <str> : <str> ) ; style = get ( name , style . getClass ( ) ) ; method = findMethod ( actor . getClass ( ) , <str> ) ; if ( method = = null ) return ; try { method . invoke ( actor , style ) ; } catch ( Exception ignored ) { } } public TextureAtlas getAtlas ( ) { return atlas ; } public void dispose ( ) { if ( atlas ! = null ) atlas . dispose ( ) ; for ( ObjectMap < String , Object > entry : resources . values ( ) ) { for ( Object resource : entry . values ( ) ) if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } protected Json getJsonLoader ( final FileHandle skinFile ) { final Skin skin = this ; final Json json = new Json ( ) { public < T > T readValue ( Class < T > type , Class elementType , JsonValue jsonData ) { if ( jsonData . isString ( ) & & ! ClassReflection . isAssignableFrom ( CharSequence . class , type ) ) return get ( jsonData . asString ( ) , type ) ; return super . readValue ( type , elementType , jsonData ) ; } } ; json . setTypeName ( null ) ; json . setUsePrototypes ( false ) ; json . setSerializer ( Skin . class , new ReadOnlySerializer < Skin > ( ) { public Skin read ( Json json , JsonValue typeToValueMap , Class ignored ) { for ( JsonValue valueMap = typeToValueMap . child ; valueMap ! = null ; valueMap = valueMap . next ) { try { readNamedObjects ( json , ClassReflection . forName ( valueMap . name ( ) ) , valueMap ) ; } catch ( ReflectionException ex ) { throw new SerializationException ( ex ) ; } } return skin ; } private void readNamedObjects ( Json json , Class type , JsonValue valueMap ) { Class addType = type = = TintedDrawable . class ? Drawable . class : type ; for ( JsonValue valueEntry = valueMap . child ; valueEntry ! = null ; valueEntry = valueEntry . next ) { Object object = json . readValue ( type , valueEntry ) ; if ( object = = null ) continue ; try { add ( valueEntry . name , object , addType ) ; if ( addType ! = Drawable . class & & ClassReflection . isAssignableFrom ( Drawable . class , addType ) ) add ( valueEntry . name , object , Drawable . class ) ; } catch ( Exception ex ) { throw new SerializationException ( <str> + ClassReflection . getSimpleName ( type ) + <str> + valueEntry . name , ex ) ; } } } } ) ; json . setSerializer ( BitmapFont . class , new ReadOnlySerializer < BitmapFont > ( ) { public BitmapFont read ( Json json , JsonValue jsonData , Class type ) { String path = json . readValue ( <str> , String . class , jsonData ) ; int scaledSize = json . readValue ( <str> , int . class , - <int> , jsonData ) ; Boolean flip = json . readValue ( <str> , Boolean . class , false , jsonData ) ; Boolean markupEnabled = json . readValue ( <str> , Boolean . class , false , jsonData ) ; FileHandle fontFile = skinFile . parent ( ) . child ( path ) ; if ( ! fontFile . exists ( ) ) fontFile = Gdx . files . internal ( path ) ; if ( ! fontFile . exists ( ) ) throw new SerializationException ( <str> + fontFile ) ; String regionName = fontFile . nameWithoutExtension ( ) ; try { BitmapFont font ; TextureRegion region = skin . optional ( regionName , TextureRegion . class ) ; if ( region ! = null ) font = new BitmapFont ( fontFile , region , flip ) ; else { FileHandle imageFile = fontFile . parent ( ) . child ( regionName + <str> ) ; if ( imageFile . exists ( ) ) font = new BitmapFont ( fontFile , imageFile , flip ) ; else font = new BitmapFont ( fontFile , flip ) ; } font . getData ( ) . markupEnabled = markupEnabled ; if ( scaledSize ! = - <int> ) font . getData ( ) . setScale ( scaledSize / font . getCapHeight ( ) ) ; return font ; } catch ( RuntimeException ex ) { throw new SerializationException ( <str> + fontFile , ex ) ; } } } ) ; json . setSerializer ( Color . class , new ReadOnlySerializer < Color > ( ) { public Color read ( Json json , JsonValue jsonData , Class type ) { if ( jsonData . isString ( ) ) return get ( jsonData . asString ( ) , Color . class ) ; String hex = json . readValue ( <str> , String . class , ( String ) null , jsonData ) ; if ( hex ! = null ) return Color . valueOf ( hex ) ; float r = json . readValue ( <str> , float . class , <float> , jsonData ) ; float g = json . readValue ( <str> , float . class , <float> , jsonData ) ; float b = json . readValue ( <str> , float . class , <float> , jsonData ) ; float a = json . readValue ( <str> , float . class , <float> , jsonData ) ; return new Color ( r , g , b , a ) ; } } ) ; json . setSerializer ( TintedDrawable . class , new ReadOnlySerializer ( ) { public Object read ( Json json , JsonValue jsonData , Class type ) { String name = json . readValue ( <str> , String . class , jsonData ) ; Color color = json . readValue ( <str> , Color . class , jsonData ) ; Drawable drawable = newDrawable ( name , color ) ; if ( drawable instanceof BaseDrawable ) { BaseDrawable named = ( BaseDrawable ) drawable ; named . setName ( jsonData . name + <str> + name + <str> + color + <str> ) ; } return drawable ; } } ) ; return json ; } static private Method findMethod ( Class type , String name ) { Method [ ] methods = ClassReflection . getMethods ( type ) ; for ( int i = <int> , n = methods . length ; i < n ; i + + ) { Method method = methods [ i ] ; if ( method . getName ( ) . equals ( name ) ) return method ; } return null ; } static public class TintedDrawable { public String name ; public Color color ; } } 
