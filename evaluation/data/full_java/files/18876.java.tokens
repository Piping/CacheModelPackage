package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; final class Bzip2BlockCompressor { private final Bzip2BitWriter writer ; private final Crc32 crc = new Crc32 ( ) ; private final byte [ ] block ; private int blockLength ; private final int blockLengthLimit ; private final boolean [ ] blockValuesPresent = new boolean [ <int> ] ; private final int [ ] bwtBlock ; private int rleCurrentValue = - <int> ; private int rleLength ; Bzip2BlockCompressor ( final Bzip2BitWriter writer , final int blockSize ) { this . writer = writer ; block = new byte [ blockSize + <int> ] ; bwtBlock = new int [ blockSize + <int> ] ; blockLengthLimit = blockSize - <int> ; } private void writeSymbolMap ( ByteBuf out ) { Bzip2BitWriter writer = this . writer ; final boolean [ ] blockValuesPresent = this . blockValuesPresent ; final boolean [ ] condensedInUse = new boolean [ <int> ] ; for ( int i = <int> ; i < condensedInUse . length ; i + + ) { for ( int j = <int> , k = i < < <int> ; j < HUFFMAN_SYMBOL_RANGE_SIZE ; j + + , k + + ) { if ( blockValuesPresent [ k ] ) { condensedInUse [ i ] = true ; } } } for ( int i = <int> ; i < condensedInUse . length ; i + + ) { writer . writeBoolean ( out , condensedInUse [ i ] ) ; } for ( int i = <int> ; i < condensedInUse . length ; i + + ) { if ( condensedInUse [ i ] ) { for ( int j = <int> , k = i < < <int> ; j < HUFFMAN_SYMBOL_RANGE_SIZE ; j + + , k + + ) { writer . writeBoolean ( out , blockValuesPresent [ k ] ) ; } } } } private void writeRun ( final int value , int runLength ) { final int blockLength = this . blockLength ; final byte [ ] block = this . block ; blockValuesPresent [ value ] = true ; crc . updateCRC ( value , runLength ) ; final byte byteValue = ( byte ) value ; switch ( runLength ) { case <int> : block [ blockLength ] = byteValue ; this . blockLength = blockLength + <int> ; break ; case <int> : block [ blockLength ] = byteValue ; block [ blockLength + <int> ] = byteValue ; this . blockLength = blockLength + <int> ; break ; case <int> : block [ blockLength ] = byteValue ; block [ blockLength + <int> ] = byteValue ; block [ blockLength + <int> ] = byteValue ; this . blockLength = blockLength + <int> ; break ; default : runLength - = <int> ; blockValuesPresent [ runLength ] = true ; block [ blockLength ] = byteValue ; block [ blockLength + <int> ] = byteValue ; block [ blockLength + <int> ] = byteValue ; block [ blockLength + <int> ] = byteValue ; block [ blockLength + <int> ] = ( byte ) runLength ; this . blockLength = blockLength + <int> ; break ; } } boolean write ( final int value ) { if ( blockLength > blockLengthLimit ) { return false ; } final int rleCurrentValue = this . rleCurrentValue ; final int rleLength = this . rleLength ; if ( rleLength = = <int> ) { this . rleCurrentValue = value ; this . rleLength = <int> ; } else if ( rleCurrentValue ! = value ) { writeRun ( rleCurrentValue & <hex> , rleLength ) ; this . rleCurrentValue = value ; this . rleLength = <int> ; } else { if ( rleLength = = <int> ) { writeRun ( rleCurrentValue & <hex> , <int> ) ; this . rleLength = <int> ; } else { this . rleLength = rleLength + <int> ; } } return true ; } int write ( final byte [ ] data , int offset , int length ) { int written = <int> ; while ( length - - > <int> ) { if ( ! write ( data [ offset + + ] ) ) { break ; } written + + ; } return written ; } void close ( ByteBuf out ) { if ( rleLength > <int> ) { writeRun ( rleCurrentValue & <hex> , rleLength ) ; } block [ blockLength ] = block [ <int> ] ; Bzip2DivSufSort divSufSort = new Bzip2DivSufSort ( block , bwtBlock , blockLength ) ; int bwtStartPointer = divSufSort . bwt ( ) ; Bzip2BitWriter writer = this . writer ; writer . writeBits ( out , <int> , BLOCK_HEADER_MAGIC_1 ) ; writer . writeBits ( out , <int> , BLOCK_HEADER_MAGIC_2 ) ; writer . writeInt ( out , crc . getCRC ( ) ) ; writer . writeBoolean ( out , false ) ; writer . writeBits ( out , <int> , bwtStartPointer ) ; writeSymbolMap ( out ) ; Bzip2MTFAndRLE2StageEncoder mtfEncoder = new Bzip2MTFAndRLE2StageEncoder ( bwtBlock , blockLength , blockValuesPresent ) ; mtfEncoder . encode ( ) ; Bzip2HuffmanStageEncoder huffmanEncoder = new Bzip2HuffmanStageEncoder ( writer , mtfEncoder . mtfBlock ( ) , mtfEncoder . mtfLength ( ) , mtfEncoder . mtfAlphabetSize ( ) , mtfEncoder . mtfSymbolFrequencies ( ) ) ; huffmanEncoder . encode ( out ) ; } int availableSize ( ) { if ( blockLength = = <int> ) { return blockLengthLimit + <int> ; } return blockLengthLimit - blockLength + <int> ; } boolean isFull ( ) { return blockLength > blockLengthLimit ; } boolean isEmpty ( ) { return blockLength = = <int> & & rleLength = = <int> ; } int crc ( ) { return crc . getCRC ( ) ; } } 
