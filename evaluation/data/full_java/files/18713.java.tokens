package com . badlogic . gdx . tests . superkoalio ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . Animation ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . maps . tiled . TiledMap ; import com . badlogic . gdx . maps . tiled . TiledMapTileLayer ; import com . badlogic . gdx . maps . tiled . TiledMapTileLayer . Cell ; import com . badlogic . gdx . maps . tiled . TmxMapLoader ; import com . badlogic . gdx . maps . tiled . renderers . OrthogonalTiledMapRenderer ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; public class SuperKoalio extends GdxTest { static class Koala { static float WIDTH ; static float HEIGHT ; static float MAX_VELOCITY = <int> f ; static float JUMP_VELOCITY = <int> f ; static float DAMPING = <float> ; enum State { Standing , Walking , Jumping } final Vector2 position = new Vector2 ( ) ; final Vector2 velocity = new Vector2 ( ) ; State state = State . Walking ; float stateTime = <int> ; boolean facesRight = true ; boolean grounded = false ; } private TiledMap map ; private OrthogonalTiledMapRenderer renderer ; private OrthographicCamera camera ; private Texture koalaTexture ; private Animation stand ; private Animation walk ; private Animation jump ; private Koala koala ; private Pool < Rectangle > rectPool = new Pool < Rectangle > ( ) { @Override protected Rectangle newObject ( ) { return new Rectangle ( ) ; } } ; private Array < Rectangle > tiles = new Array < Rectangle > ( ) ; private static final float GRAVITY = - <float> ; @Override public void create ( ) { koalaTexture = new Texture ( <str> ) ; TextureRegion [ ] regions = TextureRegion . split ( koalaTexture , <int> , <int> ) [ <int> ] ; stand = new Animation ( <int> , regions [ <int> ] ) ; jump = new Animation ( <int> , regions [ <int> ] ) ; walk = new Animation ( <float> , regions [ <int> ] , regions [ <int> ] , regions [ <int> ] ) ; walk . setPlayMode ( Animation . PlayMode . LOOP_PINGPONG ) ; Koala . WIDTH = <int> / <int> f * regions [ <int> ] . getRegionWidth ( ) ; Koala . HEIGHT = <int> / <int> f * regions [ <int> ] . getRegionHeight ( ) ; map = new TmxMapLoader ( ) . load ( <str> ) ; renderer = new OrthogonalTiledMapRenderer ( map , <int> / <int> f ) ; camera = new OrthographicCamera ( ) ; camera . setToOrtho ( false , <int> , <int> ) ; camera . update ( ) ; koala = new Koala ( ) ; koala . position . set ( <int> , <int> ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float deltaTime = Gdx . graphics . getDeltaTime ( ) ; updateKoala ( deltaTime ) ; camera . position . x = koala . position . x ; camera . update ( ) ; renderer . setView ( camera ) ; renderer . render ( ) ; renderKoala ( deltaTime ) ; } private Vector2 tmp = new Vector2 ( ) ; private void updateKoala ( float deltaTime ) { if ( deltaTime = = <int> ) return ; koala . stateTime + = deltaTime ; if ( ( Gdx . input . isKeyPressed ( Keys . SPACE ) | | isTouched ( <float> , <int> ) ) & & koala . grounded ) { koala . velocity . y + = Koala . JUMP_VELOCITY ; koala . state = Koala . State . Jumping ; koala . grounded = false ; } if ( Gdx . input . isKeyPressed ( Keys . LEFT ) | | Gdx . input . isKeyPressed ( Keys . A ) | | isTouched ( <int> , <float> ) ) { koala . velocity . x = - Koala . MAX_VELOCITY ; if ( koala . grounded ) koala . state = Koala . State . Walking ; koala . facesRight = false ; } if ( Gdx . input . isKeyPressed ( Keys . RIGHT ) | | Gdx . input . isKeyPressed ( Keys . D ) | | isTouched ( <float> , <float> ) ) { koala . velocity . x = Koala . MAX_VELOCITY ; if ( koala . grounded ) koala . state = Koala . State . Walking ; koala . facesRight = true ; } koala . velocity . add ( <int> , GRAVITY ) ; if ( Math . abs ( koala . velocity . x ) > Koala . MAX_VELOCITY ) { koala . velocity . x = Math . signum ( koala . velocity . x ) * Koala . MAX_VELOCITY ; } if ( Math . abs ( koala . velocity . x ) < <int> ) { koala . velocity . x = <int> ; if ( koala . grounded ) koala . state = Koala . State . Standing ; } koala . velocity . scl ( deltaTime ) ; Rectangle koalaRect = rectPool . obtain ( ) ; koalaRect . set ( koala . position . x , koala . position . y , Koala . WIDTH , Koala . HEIGHT ) ; int startX , startY , endX , endY ; if ( koala . velocity . x > <int> ) { startX = endX = ( int ) ( koala . position . x + Koala . WIDTH + koala . velocity . x ) ; } else { startX = endX = ( int ) ( koala . position . x + koala . velocity . x ) ; } startY = ( int ) ( koala . position . y ) ; endY = ( int ) ( koala . position . y + Koala . HEIGHT ) ; getTiles ( startX , startY , endX , endY , tiles ) ; koalaRect . x + = koala . velocity . x ; for ( Rectangle tile : tiles ) { if ( koalaRect . overlaps ( tile ) ) { koala . velocity . x = <int> ; break ; } } koalaRect . x = koala . position . x ; if ( koala . velocity . y > <int> ) { startY = endY = ( int ) ( koala . position . y + Koala . HEIGHT + koala . velocity . y ) ; } else { startY = endY = ( int ) ( koala . position . y + koala . velocity . y ) ; } startX = ( int ) ( koala . position . x ) ; endX = ( int ) ( koala . position . x + Koala . WIDTH ) ; getTiles ( startX , startY , endX , endY , tiles ) ; koalaRect . y + = koala . velocity . y ; for ( Rectangle tile : tiles ) { if ( koalaRect . overlaps ( tile ) ) { if ( koala . velocity . y > <int> ) { koala . position . y = tile . y - Koala . HEIGHT ; TiledMapTileLayer layer = ( TiledMapTileLayer ) map . getLayers ( ) . get ( <str> ) ; layer . setCell ( ( int ) tile . x , ( int ) tile . y , null ) ; } else { koala . position . y = tile . y + tile . height ; koala . grounded = true ; } koala . velocity . y = <int> ; break ; } } rectPool . free ( koalaRect ) ; koala . position . add ( koala . velocity ) ; koala . velocity . scl ( <int> / deltaTime ) ; koala . velocity . x * = Koala . DAMPING ; } private boolean isTouched ( float startX , float endX ) { for ( int i = <int> ; i < <int> ; i + + ) { float x = Gdx . input . getX ( i ) / ( float ) Gdx . graphics . getWidth ( ) ; if ( Gdx . input . isTouched ( i ) & & ( x > = startX & & x < = endX ) ) { return true ; } } return false ; } private void getTiles ( int startX , int startY , int endX , int endY , Array < Rectangle > tiles ) { TiledMapTileLayer layer = ( TiledMapTileLayer ) map . getLayers ( ) . get ( <str> ) ; rectPool . freeAll ( tiles ) ; tiles . clear ( ) ; for ( int y = startY ; y < = endY ; y + + ) { for ( int x = startX ; x < = endX ; x + + ) { Cell cell = layer . getCell ( x , y ) ; if ( cell ! = null ) { Rectangle rect = rectPool . obtain ( ) ; rect . set ( x , y , <int> , <int> ) ; tiles . add ( rect ) ; } } } } private void renderKoala ( float deltaTime ) { TextureRegion frame = null ; switch ( koala . state ) { case Standing : frame = stand . getKeyFrame ( koala . stateTime ) ; break ; case Walking : frame = walk . getKeyFrame ( koala . stateTime ) ; break ; case Jumping : frame = jump . getKeyFrame ( koala . stateTime ) ; break ; } Batch batch = renderer . getBatch ( ) ; batch . begin ( ) ; if ( koala . facesRight ) { batch . draw ( frame , koala . position . x , koala . position . y , Koala . WIDTH , Koala . HEIGHT ) ; } else { batch . draw ( frame , koala . position . x + Koala . WIDTH , koala . position . y , - Koala . WIDTH , Koala . HEIGHT ) ; } batch . end ( ) ; } @Override public void dispose ( ) { } } 
