package org . elasticsearch . index ; import org . elasticsearch . cluster . ClusterModule ; import org . elasticsearch . cluster . settings . Validator ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import java . util . Collection ; import java . util . Collections ; import java . util . function . Consumer ; import static org . elasticsearch . test . ESIntegTestCase . Scope . SUITE ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; @ClusterScope ( scope = SUITE , numDataNodes = <int> , numClientNodes = <int> ) public class SettingsListenerIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( SettingsListenerPlugin . class ) ; } public static class SettingsListenerPlugin extends Plugin { private final SettingsTestingService service = new SettingsTestingService ( ) ; @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( ClusterModule clusterModule ) { clusterModule . registerIndexDynamicSetting ( <str> , Validator . INTEGER ) ; } @Override public void onIndexModule ( IndexModule module ) { if ( module . getIndex ( ) . getName ( ) . equals ( <str> ) ) { module . addIndexSettingsListener ( service ) ; service . accept ( module . getSettings ( ) ) ; } } @Override public Collection < Module > nodeModules ( ) { return Collections . < Module > singletonList ( new SettingsListenerModule ( service ) ) ; } } public static class SettingsListenerModule extends AbstractModule { private final SettingsTestingService service ; public SettingsListenerModule ( SettingsTestingService service ) { this . service = service ; } @Override protected void configure ( ) { bind ( SettingsTestingService . class ) . toInstance ( service ) ; } } public static class SettingsTestingService implements Consumer < Settings > { public volatile int value ; @Override public void accept ( Settings settings ) { value = settings . getAsInt ( <str> , - <int> ) ; } } public void testListener ( ) { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) . build ( ) ) . get ( ) ) ; for ( SettingsTestingService instance : internalCluster ( ) . getInstances ( SettingsTestingService . class ) ) { assertEquals ( <int> , instance . value ) ; } client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) ) . get ( ) ; for ( SettingsTestingService instance : internalCluster ( ) . getInstances ( SettingsTestingService . class ) ) { assertEquals ( <int> , instance . value ) ; } assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) . build ( ) ) . get ( ) ) ; for ( SettingsTestingService instance : internalCluster ( ) . getInstances ( SettingsTestingService . class ) ) { assertEquals ( <int> , instance . value ) ; } client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) ) . get ( ) ; for ( SettingsTestingService instance : internalCluster ( ) . getInstances ( SettingsTestingService . class ) ) { assertEquals ( <int> , instance . value ) ; } } } 
