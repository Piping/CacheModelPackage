package com . google . common . base ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . VisibleForTesting ; import java . util . Formatter ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @CheckReturnValue @GwtCompatible public final class Strings { private Strings ( ) { } public static String nullToEmpty ( @Nullable String string ) { return ( string = = null ) ? <str> : string ; } @Nullable public static String emptyToNull ( @Nullable String string ) { return isNullOrEmpty ( string ) ? null : string ; } public static boolean isNullOrEmpty ( @Nullable String string ) { return string = = null | | string . length ( ) = = <int> ; } public static String padStart ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string . length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; for ( int i = string . length ( ) ; i < minLength ; i + + ) { sb . append ( padChar ) ; } sb . append ( string ) ; return sb . toString ( ) ; } public static String padEnd ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string . length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; sb . append ( string ) ; for ( int i = string . length ( ) ; i < minLength ; i + + ) { sb . append ( padChar ) ; } return sb . toString ( ) ; } public static String repeat ( String string , int count ) { checkNotNull ( string ) ; if ( count < = <int> ) { checkArgument ( count > = <int> , <str> , count ) ; return ( count = = <int> ) ? <str> : string ; } final int len = string . length ( ) ; final long longSize = ( long ) len * ( long ) count ; final int size = ( int ) longSize ; if ( size ! = longSize ) { throw new ArrayIndexOutOfBoundsException ( <str> + longSize ) ; } final char [ ] array = new char [ size ] ; string . getChars ( <int> , len , array , <int> ) ; int n ; for ( n = len ; n < size - n ; n < < = <int> ) { System . arraycopy ( array , <int> , array , n , n ) ; } System . arraycopy ( array , <int> , array , n , size - n ) ; return new String ( array ) ; } public static String commonPrefix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxPrefixLength = Math . min ( a . length ( ) , b . length ( ) ) ; int p = <int> ; while ( p < maxPrefixLength & & a . charAt ( p ) = = b . charAt ( p ) ) { p + + ; } if ( validSurrogatePairAt ( a , p - <int> ) | | validSurrogatePairAt ( b , p - <int> ) ) { p - - ; } return a . subSequence ( <int> , p ) . toString ( ) ; } public static String commonSuffix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxSuffixLength = Math . min ( a . length ( ) , b . length ( ) ) ; int s = <int> ; while ( s < maxSuffixLength & & a . charAt ( a . length ( ) - s - <int> ) = = b . charAt ( b . length ( ) - s - <int> ) ) { s + + ; } if ( validSurrogatePairAt ( a , a . length ( ) - s - <int> ) | | validSurrogatePairAt ( b , b . length ( ) - s - <int> ) ) { s - - ; } return a . subSequence ( a . length ( ) - s , a . length ( ) ) . toString ( ) ; } @VisibleForTesting static boolean validSurrogatePairAt ( CharSequence string , int index ) { return index > = <int> & & index < = ( string . length ( ) - <int> ) & & Character . isHighSurrogate ( string . charAt ( index ) ) & & Character . isLowSurrogate ( string . charAt ( index + <int> ) ) ; } } 
