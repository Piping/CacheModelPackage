package org . elasticsearch . common . util ; import java . nio . charset . StandardCharsets ; import org . apache . lucene . util . CollectionUtil ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . bwcompat . OldIndexBackwardsCompatibilityIT ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . AllocationId ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . gateway . MetaDataStateFormat ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardPath ; import org . elasticsearch . index . shard . ShardStateMetaData ; import org . elasticsearch . test . ESTestCase ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStream ; import java . net . URISyntaxException ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Locale ; import java . util . Map ; @LuceneTestCase.SuppressFileSystems ( <str> ) public class MultiDataPathUpgraderTests extends ESTestCase { public void testUpgradeRandomPaths ( ) throws IOException { try ( NodeEnvironment nodeEnvironment = newNodeEnvironment ( ) ) { final String uuid = Strings . base64UUID ( ) ; final ShardId shardId = new ShardId ( <str> , <int> ) ; final Path [ ] shardDataPaths = nodeEnvironment . availableShardPaths ( shardId ) ; if ( nodeEnvironment . nodeDataPaths ( ) . length = = <int> ) { MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; assertFalse ( helper . needsUpgrading ( shardId ) ) ; return ; } int numIdxFiles = <int> ; int numTranslogFiles = <int> ; int metaStateVersion = <int> ; for ( Path shardPath : shardDataPaths ) { final Path translog = shardPath . resolve ( ShardPath . TRANSLOG_FOLDER_NAME ) ; final Path idx = shardPath . resolve ( ShardPath . INDEX_FOLDER_NAME ) ; Files . createDirectories ( translog ) ; Files . createDirectories ( idx ) ; int numFiles = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numFiles ; i + + , numIdxFiles + + ) { String filename = Integer . toString ( numIdxFiles ) ; try ( BufferedWriter w = Files . newBufferedWriter ( idx . resolve ( filename + <str> ) , StandardCharsets . UTF_8 ) ) { w . write ( filename ) ; } } numFiles = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numFiles ; i + + , numTranslogFiles + + ) { String filename = Integer . toString ( numTranslogFiles ) ; try ( BufferedWriter w = Files . newBufferedWriter ( translog . resolve ( filename + <str> ) , StandardCharsets . UTF_8 ) ) { w . write ( filename ) ; } } + + metaStateVersion ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( metaStateVersion , true , uuid , AllocationId . newInitializing ( ) ) , metaStateVersion , shardDataPaths ) ; } final Path path = randomFrom ( shardDataPaths ) ; ShardPath targetPath = new ShardPath ( false , path , path , uuid , new ShardId ( <str> , <int> ) ) ; MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; helper . upgrade ( shardId , targetPath ) ; assertFalse ( helper . needsUpgrading ( shardId ) ) ; if ( shardDataPaths . length > <int> ) { for ( Path shardPath : shardDataPaths ) { if ( shardPath . equals ( targetPath . getDataPath ( ) ) ) { continue ; } final Path translog = shardPath . resolve ( ShardPath . TRANSLOG_FOLDER_NAME ) ; final Path idx = shardPath . resolve ( ShardPath . INDEX_FOLDER_NAME ) ; final Path state = shardPath . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ; assertFalse ( Files . exists ( translog ) ) ; assertFalse ( Files . exists ( idx ) ) ; assertFalse ( Files . exists ( state ) ) ; assertFalse ( Files . exists ( shardPath ) ) ; } } final ShardStateMetaData stateMetaData = ShardStateMetaData . FORMAT . loadLatestState ( logger , targetPath . getShardStatePath ( ) ) ; assertEquals ( metaStateVersion , stateMetaData . version ) ; assertTrue ( stateMetaData . primary ) ; assertEquals ( uuid , stateMetaData . indexUUID ) ; final Path translog = targetPath . getDataPath ( ) . resolve ( ShardPath . TRANSLOG_FOLDER_NAME ) ; final Path idx = targetPath . getDataPath ( ) . resolve ( ShardPath . INDEX_FOLDER_NAME ) ; Files . deleteIfExists ( idx . resolve ( <str> ) ) ; assertEquals ( numTranslogFiles , FileSystemUtils . files ( translog ) . length ) ; assertEquals ( numIdxFiles , FileSystemUtils . files ( idx ) . length ) ; final HashSet < Path > translogFiles = Sets . newHashSet ( FileSystemUtils . files ( translog ) ) ; for ( int i = <int> ; i < numTranslogFiles ; i + + ) { final String name = Integer . toString ( i ) ; translogFiles . contains ( translog . resolve ( name + <str> ) ) ; byte [ ] content = Files . readAllBytes ( translog . resolve ( name + <str> ) ) ; assertEquals ( name , new String ( content , StandardCharsets . UTF_8 ) ) ; } final HashSet < Path > idxFiles = Sets . newHashSet ( FileSystemUtils . files ( idx ) ) ; for ( int i = <int> ; i < numIdxFiles ; i + + ) { final String name = Integer . toString ( i ) ; idxFiles . contains ( idx . resolve ( name + <str> ) ) ; byte [ ] content = Files . readAllBytes ( idx . resolve ( name + <str> ) ) ; assertEquals ( name , new String ( content , StandardCharsets . UTF_8 ) ) ; } } } public void testUpgradeRealIndex ( ) throws IOException , URISyntaxException { List < Path > indexes = new ArrayList < > ( ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( getBwcIndicesPath ( ) , <str> ) ) { for ( Path path : stream ) { indexes . add ( path ) ; } } CollectionUtil . introSort ( indexes , new Comparator < Path > ( ) { @Override public int compare ( Path o1 , Path o2 ) { return o1 . getFileName ( ) . compareTo ( o2 . getFileName ( ) ) ; } } ) ; final ShardId shardId = new ShardId ( <str> , <int> ) ; final Path path = randomFrom ( indexes ) ; final Path indexFile = path ; final String indexName = indexFile . getFileName ( ) . toString ( ) . replace ( <str> , <str> ) . toLowerCase ( Locale . ROOT ) ; try ( NodeEnvironment nodeEnvironment = newNodeEnvironment ( ) ) { if ( nodeEnvironment . nodeDataPaths ( ) . length = = <int> ) { MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; assertFalse ( helper . needsUpgrading ( shardId ) ) ; return ; } Path unzipDir = createTempDir ( ) ; Path unzipDataDir = unzipDir . resolve ( <str> ) ; try ( InputStream stream = Files . newInputStream ( indexFile ) ) { TestUtil . unzip ( stream , unzipDir ) ; } assertTrue ( Files . exists ( unzipDataDir ) ) ; Path [ ] list = FileSystemUtils . files ( unzipDataDir ) ; if ( list . length ! = <int> ) { throw new IllegalStateException ( <str> + list . length ) ; } Path src = list [ <int> ] . resolve ( <str> + indexName ) ; assertTrue ( <str> + indexFile + <str> + src . toString ( ) , Files . exists ( src ) ) ; Path [ ] multiDataPath = new Path [ nodeEnvironment . nodeDataPaths ( ) . length ] ; int i = <int> ; for ( NodeEnvironment . NodePath nodePath : nodeEnvironment . nodePaths ( ) ) { multiDataPath [ i + + ] = nodePath . indicesPath ; } logger . info ( <str> , indexName ) ; OldIndexBackwardsCompatibilityIT . copyIndex ( logger , src , indexName , multiDataPath ) ; final ShardPath shardPath = new ShardPath ( false , nodeEnvironment . availableShardPaths ( new ShardId ( indexName , <int> ) ) [ <int> ] , nodeEnvironment . availableShardPaths ( new ShardId ( indexName , <int> ) ) [ <int> ] , IndexMetaData . INDEX_UUID_NA_VALUE , new ShardId ( indexName , <int> ) ) ; logger . info ( <str> , ( Object ) FileSystemUtils . files ( shardPath . resolveIndex ( ) ) ) ; MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; helper . upgrade ( new ShardId ( indexName , <int> ) , shardPath ) ; helper . checkIndex ( shardPath ) ; assertFalse ( helper . needsUpgrading ( new ShardId ( indexName , <int> ) ) ) ; } } public void testNeedsUpgrade ( ) throws IOException { try ( NodeEnvironment nodeEnvironment = newNodeEnvironment ( ) ) { String uuid = Strings . randomBase64UUID ( ) ; final ShardId shardId = new ShardId ( <str> , <int> ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( <int> , true , uuid , AllocationId . newInitializing ( ) ) , <int> , nodeEnvironment . availableShardPaths ( shardId ) ) ; MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; boolean multiDataPaths = nodeEnvironment . nodeDataPaths ( ) . length > <int> ; boolean needsUpgrading = helper . needsUpgrading ( shardId ) ; if ( multiDataPaths ) { assertTrue ( needsUpgrading ) ; } else { assertFalse ( needsUpgrading ) ; } } } public void testPickTargetShardPath ( ) throws IOException { try ( NodeEnvironment nodeEnvironment = newNodeEnvironment ( ) ) { final ShardId shard = new ShardId ( <str> , <int> ) ; final Path [ ] paths = nodeEnvironment . availableShardPaths ( shard ) ; if ( paths . length = = <int> ) { MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) ; try { helper . pickShardPath ( new ShardId ( <str> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } else { final Map < Path , Tuple < Long , Long > > pathToSpace = new HashMap < > ( ) ; final Path expectedPath ; if ( randomBoolean ( ) ) { expectedPath = randomFrom ( paths ) ; long [ ] used = new long [ paths . length ] ; long sumSpaceUsed = <int> ; for ( int i = <int> ; i < used . length ; i + + ) { long spaceUsed = paths [ i ] = = expectedPath ? randomIntBetween ( <int> , <int> ) : randomIntBetween ( <int> , <int> ) ; sumSpaceUsed + = spaceUsed ; used [ i ] = spaceUsed ; } for ( int i = <int> ; i < used . length ; i + + ) { long availalbe = randomIntBetween ( ( int ) ( <int> * sumSpaceUsed - used [ i ] ) , <int> * ( int ) sumSpaceUsed ) ; pathToSpace . put ( paths [ i ] , new Tuple < > ( availalbe , used [ i ] ) ) ; } } else { expectedPath = randomFrom ( paths ) ; long [ ] used = new long [ paths . length ] ; long sumSpaceUsed = <int> ; for ( int i = <int> ; i < used . length ; i + + ) { long spaceUsed = randomIntBetween ( <int> , <int> ) ; sumSpaceUsed + = spaceUsed ; used [ i ] = spaceUsed ; } for ( int i = <int> ; i < used . length ; i + + ) { long availalbe = paths [ i ] = = expectedPath ? randomIntBetween ( ( int ) ( sumSpaceUsed ) , ( int ) ( <int> * sumSpaceUsed ) ) : randomIntBetween ( <int> , ( int ) ( sumSpaceUsed ) - <int> ) ; pathToSpace . put ( paths [ i ] , new Tuple < > ( availalbe , used [ i ] ) ) ; } } MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) { @Override protected long getUsabelSpace ( NodeEnvironment . NodePath path ) throws IOException { return pathToSpace . get ( path . resolve ( shard ) ) . v1 ( ) ; } @Override protected long getSpaceUsedByShard ( Path path ) throws IOException { return pathToSpace . get ( path ) . v2 ( ) ; } } ; String uuid = Strings . randomBase64UUID ( ) ; ShardStateMetaData . FORMAT . write ( new ShardStateMetaData ( <int> , true , uuid , AllocationId . newInitializing ( ) ) , <int> , paths ) ; final ShardPath shardPath = helper . pickShardPath ( new ShardId ( <str> , <int> ) ) ; assertEquals ( expectedPath , shardPath . getDataPath ( ) ) ; assertEquals ( expectedPath , shardPath . getShardStatePath ( ) ) ; } MultiDataPathUpgrader helper = new MultiDataPathUpgrader ( nodeEnvironment ) { @Override protected long getUsabelSpace ( NodeEnvironment . NodePath path ) throws IOException { return randomIntBetween ( <int> , <int> ) ; } @Override protected long getSpaceUsedByShard ( Path path ) throws IOException { return randomIntBetween ( <int> , <int> ) ; } } ; try { helper . pickShardPath ( new ShardId ( <str> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } } } 
