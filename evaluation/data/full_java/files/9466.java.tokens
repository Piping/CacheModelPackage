package com . google . common . math ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . math . DoubleUtils . ensureNonNegative ; import static com . google . common . primitives . Doubles . isFinite ; import static java . lang . Double . NaN ; import static java . lang . Double . isNaN ; import com . google . common . annotations . Beta ; import java . util . Iterator ; @Beta public final class StatsAccumulator { private long count = <int> ; private double mean = <float> ; private double sumOfSquaresOfDeltas = <float> ; private double min = NaN ; private double max = NaN ; public void add ( double value ) { count + + ; if ( count = = <int> ) { mean = value ; min = value ; max = value ; if ( ! isFinite ( value ) ) { sumOfSquaresOfDeltas = NaN ; } } else { if ( isFinite ( value ) & & isFinite ( mean ) ) { double nextMean = mean + ( value - mean ) / count ; sumOfSquaresOfDeltas + = ( value - mean ) * ( value - nextMean ) ; mean = nextMean ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; sumOfSquaresOfDeltas = NaN ; } if ( value < min | | isNaN ( value ) ) { min = value ; } if ( value > max | | isNaN ( value ) ) { max = value ; } } } public void addAll ( Iterable < ? extends Number > values ) { for ( Number value : values ) { add ( value . doubleValue ( ) ) ; } } public void addAll ( Iterator < ? extends Number > values ) { while ( values . hasNext ( ) ) { add ( values . next ( ) . doubleValue ( ) ) ; } } public void addAll ( double . . . values ) { for ( double value : values ) { add ( value ) ; } } public void addAll ( int . . . values ) { for ( int value : values ) { add ( value ) ; } } public void addAll ( long . . . values ) { for ( long value : values ) { add ( value ) ; } } public Stats snapshot ( ) { return new Stats ( count , mean , sumOfSquaresOfDeltas , min , max ) ; } public long count ( ) { return count ; } public double mean ( ) { checkState ( count ! = <int> ) ; return mean ; } public final double sum ( ) { return mean * count ; } public final double populationVariance ( ) { checkState ( count ! = <int> ) ; if ( isNaN ( sumOfSquaresOfDeltas ) ) { return NaN ; } if ( count = = <int> ) { return <float> ; } return ensureNonNegative ( sumOfSquaresOfDeltas ) / count ; } public final double populationStandardDeviation ( ) { return Math . sqrt ( populationVariance ( ) ) ; } public final double sampleVariance ( ) { checkState ( count > <int> ) ; if ( isNaN ( sumOfSquaresOfDeltas ) ) { return NaN ; } return ensureNonNegative ( sumOfSquaresOfDeltas ) / ( count - <int> ) ; } public final double sampleStandardDeviation ( ) { return Math . sqrt ( sampleVariance ( ) ) ; } public double min ( ) { checkState ( count ! = <int> ) ; return min ; } public double max ( ) { checkState ( count ! = <int> ) ; return max ; } double sumOfSquaresOfDeltas ( ) { return sumOfSquaresOfDeltas ; } static double calculateNewMeanNonFinite ( double previousMean , double value ) { if ( isFinite ( previousMean ) ) { return value ; } else if ( isFinite ( value ) | | previousMean = = value ) { return previousMean ; } else { return NaN ; } } } 
