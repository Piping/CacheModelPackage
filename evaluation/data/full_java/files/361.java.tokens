package org . apache . cassandra . db . columniterator ; import java . io . IOException ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . sstable . IndexHelper ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . io . util . FileMark ; import org . apache . cassandra . utils . ByteBufferUtil ; abstract class AbstractSSTableIterator implements SliceableUnfilteredRowIterator { protected final SSTableReader sstable ; protected final DecoratedKey key ; protected final DeletionTime partitionLevelDeletion ; protected final ColumnFilter columns ; protected final SerializationHelper helper ; protected final Row staticRow ; protected final Reader reader ; private final boolean isForThrift ; private boolean isClosed ; @SuppressWarnings ( <str> ) protected AbstractSSTableIterator ( SSTableReader sstable , FileDataInput file , DecoratedKey key , RowIndexEntry indexEntry , ColumnFilter columnFilter , boolean isForThrift ) { this . sstable = sstable ; this . key = key ; this . columns = columnFilter ; this . helper = new SerializationHelper ( sstable . metadata , sstable . descriptor . version . correspondingMessagingVersion ( ) , SerializationHelper . Flag . LOCAL , columnFilter ) ; this . isForThrift = isForThrift ; if ( indexEntry = = null ) { this . partitionLevelDeletion = DeletionTime . LIVE ; this . reader = null ; this . staticRow = Rows . EMPTY_STATIC_ROW ; } else { boolean shouldCloseFile = file = = null ; try { boolean needSeekAtPartitionStart = ! indexEntry . isIndexed ( ) | | ! columns . fetchedColumns ( ) . statics . isEmpty ( ) ; boolean needsReader = sstable . descriptor . version . storeRows ( ) | | isForThrift | | ! sstable . metadata . isStaticCompactTable ( ) ; if ( needSeekAtPartitionStart ) { if ( file = = null ) file = sstable . getFileDataInput ( indexEntry . position ) ; else file . seek ( indexEntry . position ) ; ByteBufferUtil . skipShortLength ( file ) ; this . partitionLevelDeletion = DeletionTime . serializer . deserialize ( file ) ; this . reader = needsReader ? createReader ( indexEntry , file , true , shouldCloseFile ) : null ; this . staticRow = readStaticRow ( sstable , file , helper , columns . fetchedColumns ( ) . statics , isForThrift , reader = = null ? null : reader . deserializer ) ; } else { this . partitionLevelDeletion = indexEntry . deletionTime ( ) ; this . staticRow = Rows . EMPTY_STATIC_ROW ; this . reader = needsReader ? createReader ( indexEntry , file , false , shouldCloseFile ) : null ; } if ( reader = = null & & file ! = null & & shouldCloseFile ) file . close ( ) ; } catch ( IOException e ) { sstable . markSuspect ( ) ; String filePath = file . getPath ( ) ; if ( shouldCloseFile ) { try { file . close ( ) ; } catch ( IOException suppressed ) { e . addSuppressed ( suppressed ) ; } } throw new CorruptSSTableException ( e , filePath ) ; } } } private static Row readStaticRow ( SSTableReader sstable , FileDataInput file , SerializationHelper helper , Columns statics , boolean isForThrift , UnfilteredDeserializer deserializer ) throws IOException { if ( ! sstable . descriptor . version . storeRows ( ) ) { if ( ! sstable . metadata . isCompactTable ( ) ) { assert deserializer ! = null ; return deserializer . hasNext ( ) & & deserializer . nextIsStatic ( ) ? ( Row ) deserializer . readNext ( ) : Rows . EMPTY_STATIC_ROW ; } if ( statics . isEmpty ( ) | | isForThrift ) return Rows . EMPTY_STATIC_ROW ; assert sstable . metadata . isStaticCompactTable ( ) ; return LegacyLayout . extractStaticColumns ( sstable . metadata , file , statics ) ; } if ( ! sstable . header . hasStatic ( ) ) return Rows . EMPTY_STATIC_ROW ; if ( statics . isEmpty ( ) ) { UnfilteredSerializer . serializer . skipStaticRow ( file , sstable . header , helper ) ; return Rows . EMPTY_STATIC_ROW ; } else { return UnfilteredSerializer . serializer . deserializeStaticRow ( file , sstable . header , helper ) ; } } protected abstract Reader createReader ( RowIndexEntry indexEntry , FileDataInput file , boolean isAtPartitionStart , boolean shouldCloseFile ) ; public CFMetaData metadata ( ) { return sstable . metadata ; } public PartitionColumns columns ( ) { return columns . fetchedColumns ( ) ; } public DecoratedKey partitionKey ( ) { return key ; } public DeletionTime partitionLevelDeletion ( ) { return partitionLevelDeletion ; } public Row staticRow ( ) { return staticRow ; } public EncodingStats stats ( ) { return new EncodingStats ( sstable . getMinTimestamp ( ) , sstable . getMinLocalDeletionTime ( ) , sstable . getMinTTL ( ) ) ; } public boolean hasNext ( ) { return reader ! = null & & reader . hasNext ( ) ; } public Unfiltered next ( ) { assert reader ! = null ; return reader . next ( ) ; } public Iterator < Unfiltered > slice ( Slice slice ) { try { if ( reader = = null ) return Collections . emptyIterator ( ) ; reader . setForSlice ( slice ) ; return reader ; } catch ( IOException e ) { try { closeInternal ( ) ; } catch ( IOException suppressed ) { e . addSuppressed ( suppressed ) ; } sstable . markSuspect ( ) ; throw new CorruptSSTableException ( e , reader . file . getPath ( ) ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } private void closeInternal ( ) throws IOException { if ( isClosed ) return ; if ( reader ! = null ) reader . close ( ) ; isClosed = true ; } public void close ( ) { try { closeInternal ( ) ; } catch ( IOException e ) { sstable . markSuspect ( ) ; throw new CorruptSSTableException ( e , reader . file . getPath ( ) ) ; } } protected abstract class Reader implements Iterator < Unfiltered > { private final boolean shouldCloseFile ; public FileDataInput file ; protected UnfilteredDeserializer deserializer ; protected DeletionTime openMarker = null ; protected boolean isInit ; protected Reader ( FileDataInput file , boolean isInit , boolean shouldCloseFile ) { this . file = file ; this . isInit = isInit ; this . shouldCloseFile = shouldCloseFile ; if ( file ! = null ) createDeserializer ( ) ; else assert ! isInit ; } private void createDeserializer ( ) { assert file ! = null & & deserializer = = null ; deserializer = UnfilteredDeserializer . create ( sstable . metadata , file , sstable . header , helper , partitionLevelDeletion , isForThrift ) ; } protected void seekToPosition ( long position ) throws IOException { if ( file = = null ) { file = sstable . getFileDataInput ( position ) ; createDeserializer ( ) ; } else { file . seek ( position ) ; } } protected void updateOpenMarker ( RangeTombstoneMarker marker ) { openMarker = marker . isOpen ( false ) ? marker . openDeletionTime ( false ) : null ; } protected DeletionTime getAndClearOpenMarker ( ) { DeletionTime toReturn = openMarker ; openMarker = null ; return toReturn ; } public boolean hasNext ( ) { try { if ( ! isInit ) { init ( ) ; isInit = true ; } return hasNextInternal ( ) ; } catch ( IOException e ) { try { closeInternal ( ) ; } catch ( IOException suppressed ) { e . addSuppressed ( suppressed ) ; } sstable . markSuspect ( ) ; throw new CorruptSSTableException ( e , reader . file . getPath ( ) ) ; } } public Unfiltered next ( ) { try { return nextInternal ( ) ; } catch ( IOException e ) { try { closeInternal ( ) ; } catch ( IOException suppressed ) { e . addSuppressed ( suppressed ) ; } sstable . markSuspect ( ) ; throw new CorruptSSTableException ( e , reader . file . getPath ( ) ) ; } } protected abstract void init ( ) throws IOException ; public abstract void setForSlice ( Slice slice ) throws IOException ; protected abstract boolean hasNextInternal ( ) throws IOException ; protected abstract Unfiltered nextInternal ( ) throws IOException ; public void close ( ) throws IOException { if ( shouldCloseFile & & file ! = null ) file . close ( ) ; } } protected static class IndexState { private final Reader reader ; private final ClusteringComparator comparator ; private final RowIndexEntry indexEntry ; private final List < IndexHelper . IndexInfo > indexes ; private final boolean reversed ; private int currentIndexIdx ; private FileMark mark ; public IndexState ( Reader reader , ClusteringComparator comparator , RowIndexEntry indexEntry , boolean reversed ) { this . reader = reader ; this . comparator = comparator ; this . indexEntry = indexEntry ; this . indexes = indexEntry . columnsIndex ( ) ; this . reversed = reversed ; this . currentIndexIdx = reversed ? indexEntry . columnsIndex ( ) . size ( ) : - <int> ; } public boolean isDone ( ) { return reversed ? currentIndexIdx < <int> : currentIndexIdx > = indexes . size ( ) ; } public void setToBlock ( int blockIdx ) throws IOException { if ( blockIdx > = <int> & & blockIdx < indexes . size ( ) ) { reader . seekToPosition ( columnOffset ( blockIdx ) ) ; reader . deserializer . clearState ( ) ; } currentIndexIdx = blockIdx ; reader . openMarker = blockIdx > <int> ? indexes . get ( blockIdx - <int> ) . endOpenMarker : null ; mark = reader . file . mark ( ) ; } private long columnOffset ( int i ) { return indexEntry . position + indexes . get ( i ) . offset ; } public int blocksCount ( ) { return indexes . size ( ) ; } public void updateBlock ( ) throws IOException { assert currentIndexIdx > = <int> ; while ( currentIndexIdx + <int> < indexes . size ( ) & & isPastCurrentBlock ( ) ) { reader . openMarker = currentIndex ( ) . endOpenMarker ; + + currentIndexIdx ; long startOfBlock = columnOffset ( currentIndexIdx ) ; long currentFilePointer = reader . file . getFilePointer ( ) ; if ( startOfBlock = = currentFilePointer ) { mark = reader . file . mark ( ) ; } else { reader . seekToPosition ( startOfBlock ) ; mark = reader . file . mark ( ) ; reader . seekToPosition ( currentFilePointer ) ; } } } public boolean isPastCurrentBlock ( ) { assert reader . deserializer ! = null ; long correction = reader . deserializer . bytesReadForUnconsumedData ( ) ; return reader . file . bytesPastMark ( mark ) - correction > = currentIndex ( ) . width ; } public int currentBlockIdx ( ) { return currentIndexIdx ; } public IndexHelper . IndexInfo currentIndex ( ) { return index ( currentIndexIdx ) ; } public IndexHelper . IndexInfo index ( int i ) { return indexes . get ( i ) ; } public int findBlockIndex ( Slice . Bound bound , int fromIdx ) { if ( bound = = Slice . Bound . BOTTOM ) return - <int> ; if ( bound = = Slice . Bound . TOP ) return blocksCount ( ) ; return IndexHelper . indexFor ( bound , indexes , comparator , reversed , fromIdx ) ; } @Override public String toString ( ) { return String . format ( <str> , indexes . size ( ) , currentIndexIdx , reversed ) ; } } } 
