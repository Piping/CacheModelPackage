package org . gradle . util ; import com . google . common . base . Equivalence ; import com . google . common . base . Function ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableListMultimap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import org . gradle . api . Action ; import org . gradle . api . Nullable ; import org . gradle . api . Transformer ; import org . gradle . api . specs . Spec ; import org . gradle . internal . Cast ; import org . gradle . internal . Factory ; import org . gradle . internal . Pair ; import org . gradle . internal . Transformers ; import java . lang . reflect . Array ; import java . util . * ; import static org . gradle . internal . Cast . cast ; public abstract class CollectionUtils { @Nullable public static < T > T findSingle ( Collection < T > source ) { return source . isEmpty ( ) ? null : single ( source ) ; } public static < T > T single ( Iterable < ? extends T > source ) { Iterator < ? extends T > iterator = source . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { throw new NoSuchElementException ( <str> ) ; } T element = iterator . next ( ) ; if ( iterator . hasNext ( ) ) { throw new IllegalArgumentException ( <str> ) ; } return element ; } public static < T > Collection < ? extends T > checkedCast ( Class < T > type , Collection < ? > input ) { for ( Object o : input ) { cast ( type , o ) ; } return Cast . uncheckedCast ( input ) ; } public static < T > T findFirst ( Iterable < ? extends T > source , Spec < ? super T > filter ) { for ( T item : source ) { if ( filter . isSatisfiedBy ( item ) ) { return item ; } } return null ; } public static < T > T findFirst ( T [ ] source , Spec < ? super T > filter ) { for ( T thing : source ) { if ( filter . isSatisfiedBy ( thing ) ) { return thing ; } } return null ; } public static < T > T first ( Iterable < ? extends T > source ) { return source . iterator ( ) . next ( ) ; } public static < T > boolean any ( Iterable < ? extends T > source , Spec < ? super T > filter ) { return findFirst ( source , filter ) ! = null ; } public static < T > boolean any ( T [ ] source , Spec < ? super T > filter ) { return findFirst ( source , filter ) ! = null ; } public static < T > Set < T > filter ( Set < ? extends T > set , Spec < ? super T > filter ) { return filter ( set , new LinkedHashSet < T > ( ) , filter ) ; } public static < T > List < T > filter ( List < ? extends T > list , Spec < ? super T > filter ) { return filter ( list , new LinkedList < T > ( ) , filter ) ; } public static < T > List < T > filter ( T [ ] array , Spec < ? super T > filter ) { return filter ( Arrays . asList ( array ) , new LinkedList < T > ( ) , filter ) ; } public static < T > List < T > sort ( Iterable < ? extends T > things , Comparator < ? super T > comparator ) { List < T > copy = toMutableList ( things ) ; Collections . sort ( copy , comparator ) ; return copy ; } public static < T extends Comparable > List < T > sort ( Iterable < T > things ) { List < T > copy = toMutableList ( things ) ; Collections . sort ( copy ) ; return copy ; } public static < T , C extends Collection < T > > C filter ( Iterable < ? extends T > source , C destination , Spec < ? super T > filter ) { for ( T item : source ) { if ( filter . isSatisfiedBy ( item ) ) { destination . add ( item ) ; } } return destination ; } public static < K , V > Map < K , V > filter ( Map < K , V > map , Spec < Map . Entry < K , V > > filter ) { return filter ( map , new HashMap < K , V > ( ) , filter ) ; } public static < K , V > Map < K , V > filter ( Map < K , V > map , Map < K , V > destination , Spec < Map . Entry < K , V > > filter ) { for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { if ( filter . isSatisfiedBy ( entry ) ) { destination . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return destination ; } public static < R , I > R [ ] collectArray ( I [ ] list , Class < R > newType , Transformer < ? extends R , ? super I > transformer ) { @SuppressWarnings ( <str> ) R [ ] destination = ( R [ ] ) Array . newInstance ( newType , list . length ) ; return collectArray ( list , destination , transformer ) ; } public static < R , I > R [ ] collectArray ( I [ ] list , R [ ] destination , Transformer < ? extends R , ? super I > transformer ) { assert list . length < = destination . length ; for ( int i = <int> ; i < list . length ; + + i ) { destination [ i ] = transformer . transform ( list [ i ] ) ; } return destination ; } public static < R , I > List < R > collect ( List < ? extends I > list , Transformer < ? extends R , ? super I > transformer ) { return collect ( list , new ArrayList < R > ( list . size ( ) ) , transformer ) ; } public static < R , I > List < R > collect ( I [ ] list , Transformer < ? extends R , ? super I > transformer ) { return collect ( Arrays . asList ( list ) , transformer ) ; } public static < R , I > Set < R > collect ( Set < ? extends I > set , Transformer < ? extends R , ? super I > transformer ) { return collect ( set , new HashSet < R > ( ) , transformer ) ; } public static < R , I > List < R > collect ( Iterable < ? extends I > source , Transformer < ? extends R , ? super I > transformer ) { return collect ( source , new LinkedList < R > ( ) , transformer ) ; } public static < R , I , C extends Collection < R > > C collect ( Iterable < ? extends I > source , C destination , Transformer < ? extends R , ? super I > transformer ) { for ( I item : source ) { destination . add ( transformer . transform ( item ) ) ; } return destination ; } public static List < String > toStringList ( Iterable < ? > iterable ) { return collect ( iterable , new LinkedList < String > ( ) , Transformers . asString ( ) ) ; } public static List < ? > flattenCollections ( Object . . . things ) { return flattenCollections ( Object . class , things ) ; } public static < T > List < T > flattenCollections ( Class < T > type , Object . . . things ) { if ( things = = null ) { return Collections . singletonList ( null ) ; } else if ( things . length = = <int> ) { return Collections . emptyList ( ) ; } else if ( things . length = = <int> ) { Object thing = things [ <int> ] ; if ( thing = = null ) { return Collections . singletonList ( null ) ; } if ( thing . getClass ( ) . isArray ( ) ) { Object [ ] thingArray = ( Object [ ] ) thing ; List < T > list = new ArrayList < T > ( thingArray . length ) ; for ( Object thingThing : thingArray ) { list . addAll ( flattenCollections ( type , thingThing ) ) ; } return list ; } if ( thing instanceof Collection ) { Collection < ? > collection = ( Collection < ? > ) thing ; List < T > list = new ArrayList < T > ( ) ; for ( Object element : collection ) { list . addAll ( flattenCollections ( type , element ) ) ; } return list ; } return Collections . singletonList ( cast ( type , thing ) ) ; } else { List < T > list = new ArrayList < T > ( ) ; for ( Object thing : things ) { list . addAll ( flattenCollections ( type , thing ) ) ; } return list ; } } public static < T > List < T > toList ( Iterable < ? extends T > things ) { if ( things instanceof List ) { @SuppressWarnings ( <str> ) List < T > castThings = ( List < T > ) things ; return castThings ; } return toMutableList ( things ) ; } public static < T > List < T > toList ( Enumeration < ? extends T > things ) { AbstractList < T > list = new ArrayList < T > ( ) ; while ( things . hasMoreElements ( ) ) { list . add ( things . nextElement ( ) ) ; } return list ; } private static < T > List < T > toMutableList ( Iterable < ? extends T > things ) { if ( things = = null ) { return new ArrayList < T > ( <int> ) ; } List < T > list = new ArrayList < T > ( ) ; for ( T thing : things ) { list . add ( thing ) ; } return list ; } public static < T > List < T > intersection ( Collection < ? extends Collection < T > > availableValuesByDescriptor ) { List < T > result = new ArrayList < T > ( ) ; Iterator < ? extends Collection < T > > iterator = availableValuesByDescriptor . iterator ( ) ; if ( iterator . hasNext ( ) ) { Collection < T > firstSet = iterator . next ( ) ; result . addAll ( firstSet ) ; while ( iterator . hasNext ( ) ) { Collection < T > next = iterator . next ( ) ; result . retainAll ( next ) ; } } return result ; } public static < T > List < T > toList ( T [ ] things ) { if ( things = = null | | things . length = = <int> ) { return new ArrayList < T > ( <int> ) ; } List < T > list = new ArrayList < T > ( things . length ) ; Collections . addAll ( list , things ) ; return list ; } public static < T > Set < T > toSet ( Iterable < ? extends T > things ) { if ( things = = null ) { return new HashSet < T > ( <int> ) ; } if ( things instanceof Set ) { @SuppressWarnings ( <str> ) Set < T > castThings = ( Set < T > ) things ; return castThings ; } Set < T > set = new LinkedHashSet < T > ( ) ; for ( T thing : things ) { set . add ( thing ) ; } return set ; } public static < E > List < E > compact ( List < E > list ) { boolean foundAtLeastOneNull = false ; List < E > compacted = null ; int i = <int> ; for ( E element : list ) { if ( element = = null ) { if ( ! foundAtLeastOneNull ) { compacted = new ArrayList < E > ( list . size ( ) ) ; if ( i > <int> ) { compacted . addAll ( list . subList ( <int> , i ) ) ; } } foundAtLeastOneNull = true ; } else if ( foundAtLeastOneNull ) { compacted . add ( element ) ; } + + i ; } return foundAtLeastOneNull ? compacted : list ; } public static < C extends Collection < String > > C stringize ( Iterable < ? > source , C destination ) { return collect ( source , destination , Transformers . asString ( ) ) ; } public static List < String > stringize ( Collection < ? > source ) { return stringize ( source , new ArrayList < String > ( source . size ( ) ) ) ; } public static < E > boolean replace ( List < E > list , Spec < ? super E > filter , Transformer < ? extends E , ? super E > transformer ) { boolean replaced = false ; int i = <int> ; for ( E it : list ) { if ( filter . isSatisfiedBy ( it ) ) { list . set ( i , transformer . transform ( it ) ) ; replaced = true ; } + + i ; } return replaced ; } public static < K , V > void collectMap ( Map < K , V > destination , Iterable < ? extends V > items , Transformer < ? extends K , ? super V > keyGenerator ) { for ( V item : items ) { destination . put ( keyGenerator . transform ( item ) , item ) ; } } public static < K , V > Map < K , V > collectMap ( Iterable < ? extends V > items , Transformer < ? extends K , ? super V > keyGenerator ) { Map < K , V > map = new LinkedHashMap < K , V > ( ) ; collectMap ( map , items , keyGenerator ) ; return map ; } public static < K , V > void collectMapValues ( Map < K , V > destination , Iterable < ? extends K > keys , Transformer < ? extends V , ? super K > keyGenerator ) { for ( K item : keys ) { destination . put ( item , keyGenerator . transform ( item ) ) ; } } public static < K , V > Map < K , V > collectMapValues ( Iterable < ? extends K > keys , Transformer < ? extends V , ? super K > keyGenerator ) { Map < K , V > map = new LinkedHashMap < K , V > ( ) ; collectMapValues ( map , keys , keyGenerator ) ; return map ; } public static < T > boolean every ( Iterable < ? extends T > things , Spec < ? super T > predicate ) { for ( T thing : things ) { if ( ! predicate . isSatisfiedBy ( thing ) ) { return false ; } } return true ; } public static < T > Collection < T > addAll ( Collection < T > t1 , Iterable < ? extends T > t2 ) { for ( T t : t2 ) { t1 . add ( t ) ; } return t1 ; } public static < T > Collection < T > addAll ( Collection < T > t1 , T . . . t2 ) { Collections . addAll ( t1 , t2 ) ; return t1 ; } public static class SetDiff < T > { public Set < T > leftOnly = new HashSet < T > ( ) ; public Set < Pair < T , T > > common = new HashSet < Pair < T , T > > ( ) ; public Set < T > rightOnly = new HashSet < T > ( ) ; } public static < T > SetDiff < T > diffSetsBy ( Set < ? extends T > left , Set < ? extends T > right , Transformer < ? , T > compareBy ) { if ( left = = null ) { throw new NullPointerException ( <str> ) ; } if ( right = = null ) { throw new NullPointerException ( <str> ) ; } SetDiff < T > setDiff = new SetDiff < T > ( ) ; Map < Object , T > indexedLeft = collectMap ( left , compareBy ) ; Map < Object , T > indexedRight = collectMap ( right , compareBy ) ; for ( Map . Entry < Object , T > leftEntry : indexedLeft . entrySet ( ) ) { T rightValue = indexedRight . remove ( leftEntry . getKey ( ) ) ; if ( rightValue = = null ) { setDiff . leftOnly . add ( leftEntry . getValue ( ) ) ; } else { Pair < T , T > pair = Pair . of ( leftEntry . getValue ( ) , rightValue ) ; setDiff . common . add ( pair ) ; } } for ( T rightValue : indexedRight . values ( ) ) { setDiff . rightOnly . add ( rightValue ) ; } return setDiff ; } public static String join ( String separator , Object [ ] objects ) { return join ( separator , objects = = null ? null : Arrays . asList ( objects ) ) ; } public static String join ( String separator , Iterable < ? > objects ) { if ( separator = = null ) { throw new NullPointerException ( <str> ) ; } if ( objects = = null ) { throw new NullPointerException ( <str> ) ; } StringBuilder string = new StringBuilder ( ) ; Iterator < ? > iterator = objects . iterator ( ) ; if ( iterator . hasNext ( ) ) { string . append ( iterator . next ( ) . toString ( ) ) ; while ( iterator . hasNext ( ) ) { string . append ( separator ) ; string . append ( iterator . next ( ) . toString ( ) ) ; } } return string . toString ( ) ; } public static class InjectionStep < T , I > { private final T target ; private final I item ; public InjectionStep ( T target , I item ) { this . target = target ; this . item = item ; } public T getTarget ( ) { return target ; } public I getItem ( ) { return item ; } } public static < T , I > T inject ( T target , Iterable < ? extends I > items , Action < InjectionStep < T , I > > action ) { if ( target = = null ) { throw new NullPointerException ( <str> ) ; } if ( items = = null ) { throw new NullPointerException ( <str> ) ; } if ( action = = null ) { throw new NullPointerException ( <str> ) ; } for ( I item : items ) { action . execute ( new InjectionStep < T , I > ( target , item ) ) ; } return target ; } public static < K , V > ImmutableListMultimap < K , V > groupBy ( Iterable < ? extends V > iterable , Transformer < ? extends K , V > grouper ) { ImmutableListMultimap . Builder < K , V > builder = ImmutableListMultimap . builder ( ) ; for ( V element : iterable ) { K key = grouper . transform ( element ) ; builder . put ( key , element ) ; } return builder . build ( ) ; } public static < T > Iterable < ? extends T > unpack ( final Iterable < ? extends Factory < ? extends T > > factories ) { return new Iterable < T > ( ) { private final Iterator < ? extends Factory < ? extends T > > delegate = factories . iterator ( ) ; public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { public boolean hasNext ( ) { return delegate . hasNext ( ) ; } public T next ( ) { return delegate . next ( ) . create ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; } @Nullable public static < T > List < T > nonEmptyOrNull ( Iterable < T > iterable ) { ImmutableList < T > list = ImmutableList . copyOf ( iterable ) ; return list . isEmpty ( ) ? null : list ; } public static < T > List < T > dedup ( Iterable < T > source , final Equivalence < T > equivalence ) { Iterable < Equivalence . Wrapper < T > > wrappers = Iterables . transform ( source , new Function < T , Equivalence . Wrapper < T > > ( ) { public Equivalence . Wrapper < T > apply ( @Nullable T input ) { return equivalence . wrap ( input ) ; } } ) ; Set < Equivalence . Wrapper < T > > deduped = ImmutableSet . copyOf ( wrappers ) ; return ImmutableList . copyOf ( Iterables . transform ( deduped , new Function < Equivalence . Wrapper < T > , T > ( ) { public T apply ( Equivalence . Wrapper < T > input ) { return input . get ( ) ; } } ) ) ; } } 
