package clojure . asm . commons ; import java . util . HashMap ; import java . util . Map ; import clojure . asm . Type ; public class Method { private final String name ; private final String desc ; private static final Map < String , String > DESCRIPTORS ; static { DESCRIPTORS = new HashMap < String , String > ( ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; DESCRIPTORS . put ( <str> , <str> ) ; } public Method ( final String name , final String desc ) { this . name = name ; this . desc = desc ; } public Method ( final String name , final Type returnType , final Type [ ] argumentTypes ) { this ( name , Type . getMethodDescriptor ( returnType , argumentTypes ) ) ; } public static Method getMethod ( java . lang . reflect . Method m ) { return new Method ( m . getName ( ) , Type . getMethodDescriptor ( m ) ) ; } public static Method getMethod ( java . lang . reflect . Constructor < ? > c ) { return new Method ( <str> , Type . getConstructorDescriptor ( c ) ) ; } public static Method getMethod ( final String method ) throws IllegalArgumentException { return getMethod ( method , false ) ; } public static Method getMethod ( final String method , final boolean defaultPackage ) throws IllegalArgumentException { int space = method . indexOf ( <str> ) ; int start = method . indexOf ( <str> , space ) + <int> ; int end = method . indexOf ( <str> , start ) ; if ( space = = - <int> | | start = = - <int> | | end = = - <int> ) { throw new IllegalArgumentException ( ) ; } String returnType = method . substring ( <int> , space ) ; String methodName = method . substring ( space + <int> , start - <int> ) . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; int p ; do { String s ; p = method . indexOf ( <str> , start ) ; if ( p = = - <int> ) { s = map ( method . substring ( start , end ) . trim ( ) , defaultPackage ) ; } else { s = map ( method . substring ( start , p ) . trim ( ) , defaultPackage ) ; start = p + <int> ; } sb . append ( s ) ; } while ( p ! = - <int> ) ; sb . append ( <str> ) ; sb . append ( map ( returnType , defaultPackage ) ) ; return new Method ( methodName , sb . toString ( ) ) ; } private static String map ( final String type , final boolean defaultPackage ) { if ( <str> . equals ( type ) ) { return type ; } StringBuffer sb = new StringBuffer ( ) ; int index = <int> ; while ( ( index = type . indexOf ( <str> , index ) + <int> ) > <int> ) { sb . append ( <str> ) ; } String t = type . substring ( <int> , type . length ( ) - sb . length ( ) * <int> ) ; String desc = DESCRIPTORS . get ( t ) ; if ( desc ! = null ) { sb . append ( desc ) ; } else { sb . append ( <str> ) ; if ( t . indexOf ( <str> ) < <int> ) { if ( ! defaultPackage ) { sb . append ( <str> ) ; } sb . append ( t ) ; } else { sb . append ( t . replace ( <str> , <str> ) ) ; } sb . append ( <str> ) ; } return sb . toString ( ) ; } public String getName ( ) { return name ; } public String getDescriptor ( ) { return desc ; } public Type getReturnType ( ) { return Type . getReturnType ( desc ) ; } public Type [ ] getArgumentTypes ( ) { return Type . getArgumentTypes ( desc ) ; } @Override public String toString ( ) { return name + desc ; } @Override public boolean equals ( final Object o ) { if ( ! ( o instanceof Method ) ) { return false ; } Method other = ( Method ) o ; return name . equals ( other . name ) & & desc . equals ( other . desc ) ; } @Override public int hashCode ( ) { return name . hashCode ( ) ^ desc . hashCode ( ) ; } } 
