package com . google . common . testing ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . testing . GcFinalization . FinalizationPredicate ; import com . google . common . util . concurrent . SettableFuture ; import junit . framework . TestCase ; import java . lang . ref . WeakReference ; import java . util . WeakHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; public class GcFinalizationTest extends TestCase { public void testAwait_CountDownLatch ( ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; Object x = new Object ( ) { @Override protected void finalize ( ) { latch . countDown ( ) ; } } ; x = null ; GcFinalization . await ( latch ) ; assertEquals ( <int> , latch . getCount ( ) ) ; } public void testAwaitDone_Future ( ) { final SettableFuture < Void > future = SettableFuture . create ( ) ; Object x = new Object ( ) { @Override protected void finalize ( ) { future . set ( null ) ; } } ; x = null ; GcFinalization . awaitDone ( future ) ; assertTrue ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; } public void testAwaitDone_Future_Cancel ( ) { final SettableFuture < Void > future = SettableFuture . create ( ) ; Object x = new Object ( ) { @Override protected void finalize ( ) { future . cancel ( false ) ; } } ; x = null ; GcFinalization . awaitDone ( future ) ; assertTrue ( future . isDone ( ) ) ; assertTrue ( future . isCancelled ( ) ) ; } public void testAwaitClear ( ) { final WeakReference < Object > ref = new WeakReference < Object > ( new Object ( ) ) ; GcFinalization . awaitClear ( ref ) ; assertNull ( ref . get ( ) ) ; } public void testAwaitDone_FinalizationPredicate ( ) { final WeakHashMap < Object , Object > map = new WeakHashMap < Object , Object > ( ) ; map . put ( new Object ( ) , Boolean . TRUE ) ; GcFinalization . awaitDone ( new FinalizationPredicate ( ) { public boolean isDone ( ) { return map . isEmpty ( ) ; } } ) ; assertTrue ( map . isEmpty ( ) ) ; } class Interruptenator extends Thread { final AtomicBoolean shutdown ; Interruptenator ( final Thread interruptee ) { this ( interruptee , new AtomicBoolean ( false ) ) ; } Interruptenator ( final Thread interruptee , final AtomicBoolean shutdown ) { super ( new Runnable ( ) { public void run ( ) { while ( ! shutdown . get ( ) ) { interruptee . interrupt ( ) ; Thread . yield ( ) ; } } } ) ; this . shutdown = shutdown ; start ( ) ; } void shutdown ( ) { shutdown . set ( true ) ; while ( this . isAlive ( ) ) { Thread . yield ( ) ; } } } void assertWrapsInterruptedException ( RuntimeException e ) { assertThat ( e . getMessage ( ) ) . contains ( <str> ) ; assertThat ( e . getCause ( ) ) . isInstanceOf ( InterruptedException . class ) ; } public void testAwait_CountDownLatch_Interrupted ( ) { Interruptenator interruptenator = new Interruptenator ( Thread . currentThread ( ) ) ; try { final CountDownLatch latch = new CountDownLatch ( <int> ) ; try { GcFinalization . await ( latch ) ; fail ( <str> ) ; } catch ( RuntimeException expected ) { assertWrapsInterruptedException ( expected ) ; } } finally { interruptenator . shutdown ( ) ; Thread . interrupted ( ) ; } } public void testAwaitDone_Future_Interrupted_Interrupted ( ) { Interruptenator interruptenator = new Interruptenator ( Thread . currentThread ( ) ) ; try { final SettableFuture < Void > future = SettableFuture . create ( ) ; try { GcFinalization . awaitDone ( future ) ; fail ( <str> ) ; } catch ( RuntimeException expected ) { assertWrapsInterruptedException ( expected ) ; } } finally { interruptenator . shutdown ( ) ; Thread . interrupted ( ) ; } } public void testAwaitClear_Interrupted ( ) { Interruptenator interruptenator = new Interruptenator ( Thread . currentThread ( ) ) ; try { final WeakReference < Object > ref = new WeakReference < Object > ( Boolean . TRUE ) ; try { GcFinalization . awaitClear ( ref ) ; fail ( <str> ) ; } catch ( RuntimeException expected ) { assertWrapsInterruptedException ( expected ) ; } } finally { interruptenator . shutdown ( ) ; Thread . interrupted ( ) ; } } public void testAwaitDone_FinalizationPredicate_Interrupted ( ) { Interruptenator interruptenator = new Interruptenator ( Thread . currentThread ( ) ) ; try { try { GcFinalization . awaitDone ( new FinalizationPredicate ( ) { public boolean isDone ( ) { return false ; } } ) ; fail ( <str> ) ; } catch ( RuntimeException expected ) { assertWrapsInterruptedException ( expected ) ; } } finally { interruptenator . shutdown ( ) ; Thread . interrupted ( ) ; } } public void testAwaitFullGc ( ) { final CountDownLatch finalizerRan = new CountDownLatch ( <int> ) ; final WeakReference < Object > ref = new WeakReference < Object > ( new Object ( ) { @Override protected void finalize ( ) { finalizerRan . countDown ( ) ; } } ) ; GcFinalization . awaitFullGc ( ) ; assertEquals ( <int> , finalizerRan . getCount ( ) ) ; assertNull ( ref . get ( ) ) ; } } 
