package io . netty . channel ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . channel . group . ChannelGroup ; import io . netty . channel . group . DefaultChannelGroup ; import io . netty . util . concurrent . DefaultPromise ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . netty . util . concurrent . Promise ; import io . netty . util . concurrent . SingleThreadEventExecutor ; import org . junit . Test ; import java . lang . reflect . Field ; import java . util . concurrent . TimeUnit ; import static org . junit . Assert . * ; public class ThreadPerChannelEventLoopGroupTest { private static final ChannelHandler NOOP_HANDLER = new ChannelHandlerAdapter ( ) { @Override public boolean isSharable ( ) { return true ; } } ; @Test public void testTerminationFutureSuccessInLog ( ) throws Exception { for ( int i = <int> ; i < <int> ; i + + ) { ThreadPerChannelEventLoopGroup loopGroup = new ThreadPerChannelEventLoopGroup ( <int> ) ; runTest ( loopGroup ) ; } } @Test public void testTerminationFutureSuccessReflectively ( ) throws Exception { Field terminationFutureField = ThreadPerChannelEventLoopGroup . class . getDeclaredField ( <str> ) ; terminationFutureField . setAccessible ( true ) ; final Exception [ ] exceptionHolder = new Exception [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { ThreadPerChannelEventLoopGroup loopGroup = new ThreadPerChannelEventLoopGroup ( <int> ) ; Promise < ? > promise = new DefaultPromise < Void > ( GlobalEventExecutor . INSTANCE ) { @Override public Promise < Void > setSuccess ( Void result ) { try { return super . setSuccess ( result ) ; } catch ( IllegalStateException e ) { exceptionHolder [ <int> ] = e ; throw e ; } } } ; terminationFutureField . set ( loopGroup , promise ) ; runTest ( loopGroup ) ; } GlobalEventExecutor . INSTANCE . awaitTermination ( <int> , TimeUnit . MILLISECONDS ) ; assertNull ( exceptionHolder [ <int> ] ) ; } private static void runTest ( ThreadPerChannelEventLoopGroup loopGroup ) throws InterruptedException { int taskCount = <int> ; EventExecutor testExecutor = new TestEventExecutor ( ) ; ChannelGroup channelGroup = new DefaultChannelGroup ( testExecutor ) ; while ( taskCount - - > <int> ) { Channel channel = new EmbeddedChannel ( NOOP_HANDLER ) ; loopGroup . register ( channel , new DefaultChannelPromise ( channel , testExecutor ) ) ; channelGroup . add ( channel ) ; } channelGroup . close ( ) . sync ( ) ; loopGroup . shutdownGracefully ( <int> , <int> , TimeUnit . MILLISECONDS ) . sync ( ) ; assertTrue ( loopGroup . isTerminated ( ) ) ; } private static class TestEventExecutor extends SingleThreadEventExecutor { TestEventExecutor ( ) { super ( null , new DefaultThreadFactory ( <str> ) , false ) ; } @Override protected void run ( ) { for ( ; ; ) { Runnable task = takeTask ( ) ; if ( task ! = null ) { task . run ( ) ; updateLastExecutionTime ( ) ; } if ( confirmShutdown ( ) ) { break ; } } } } } 
