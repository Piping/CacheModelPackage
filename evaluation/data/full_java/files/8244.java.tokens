package org . elasticsearch . index . query ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . ParsingException ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . is ; public class IdsQueryBuilderTests extends AbstractQueryTestCase < IdsQueryBuilder > { public void testIdsNotProvided ( ) throws IOException { String noIdsFieldQuery = <str> ; try { parseQuery ( noIdsFieldQuery ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } @Override protected IdsQueryBuilder doCreateTestQueryBuilder ( ) { String [ ] types ; if ( getCurrentTypes ( ) . length > <int> & & randomBoolean ( ) ) { int numberOfTypes = randomIntBetween ( <int> , getCurrentTypes ( ) . length ) ; types = new String [ numberOfTypes ] ; for ( int i = <int> ; i < numberOfTypes ; i + + ) { if ( frequently ( ) ) { types [ i ] = randomFrom ( getCurrentTypes ( ) ) ; } else { types [ i ] = randomAsciiOfLengthBetween ( <int> , <int> ) ; } } } else { if ( randomBoolean ( ) ) { types = new String [ ] { MetaData . ALL } ; } else { types = new String [ <int> ] ; } } int numberOfIds = randomIntBetween ( <int> , <int> ) ; String [ ] ids = new String [ numberOfIds ] ; for ( int i = <int> ; i < numberOfIds ; i + + ) { ids [ i ] = randomAsciiOfLengthBetween ( <int> , <int> ) ; } IdsQueryBuilder query ; if ( types . length > <int> | | randomBoolean ( ) ) { query = new IdsQueryBuilder ( types ) ; query . addIds ( ids ) ; } else { query = new IdsQueryBuilder ( ) ; query . addIds ( ids ) ; } return query ; } @Override protected void doAssertLuceneQuery ( IdsQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( queryBuilder . ids ( ) . size ( ) = = <int> ) { assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; assertThat ( ( ( BooleanQuery ) query ) . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; } else { assertThat ( query , instanceOf ( TermsQuery . class ) ) ; } } @Override protected Map < String , IdsQueryBuilder > getAlternateVersions ( ) { Map < String , IdsQueryBuilder > alternateVersions = new HashMap < > ( ) ; IdsQueryBuilder tempQuery = createTestQueryBuilder ( ) ; if ( tempQuery . types ( ) ! = null & & tempQuery . types ( ) . length > <int> ) { String type = tempQuery . types ( ) [ <int> ] ; IdsQueryBuilder testQuery = new IdsQueryBuilder ( type ) ; String contentString1 = <str> + <str> + <str> + type + <str> + <str> + <str> + <str> ; alternateVersions . put ( contentString1 , testQuery ) ; String contentString2 = <str> + <str> + <str> + type + <str> + <str> + <str> + <str> ; alternateVersions . put ( contentString2 , testQuery ) ; } return alternateVersions ; } public void testIllegalArguments ( ) { try { new IdsQueryBuilder ( ( String [ ] ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { new IdsQueryBuilder ( ) . addIds ( ( String [ ] ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testIdsQueryWithInvalidValues ( ) throws Exception { String query = <str> ; try { parseQuery ( query ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; IdsQueryBuilder parsed = ( IdsQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <int> , parsed . ids ( ) . size ( ) ) ; assertEquals ( json , <str> , parsed . types ( ) [ <int> ] ) ; } } 
