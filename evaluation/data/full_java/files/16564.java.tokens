package org . junit . runner . notification ; import org . junit . Test ; import org . junit . runner . Description ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Executors ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; public final class ConcurrentRunNotifierTest { private static final long TIMEOUT = <int> ; private final RunNotifier fNotifier = new RunNotifier ( ) ; private static class ConcurrentRunListener extends RunListener { final AtomicInteger fTestStarted = new AtomicInteger ( <int> ) ; @Override public void testStarted ( Description description ) throws Exception { fTestStarted . incrementAndGet ( ) ; } } @Test public void realUsage ( ) throws Exception { ConcurrentRunListener listener1 = new ConcurrentRunListener ( ) ; ConcurrentRunListener listener2 = new ConcurrentRunListener ( ) ; fNotifier . addListener ( listener1 ) ; fNotifier . addListener ( listener2 ) ; final int numParallelTests = <int> ; ExecutorService pool = Executors . newFixedThreadPool ( numParallelTests ) ; for ( int i = <int> ; i < numParallelTests ; + + i ) { pool . submit ( new Runnable ( ) { public void run ( ) { fNotifier . fireTestStarted ( null ) ; } } ) ; } pool . shutdown ( ) ; assertTrue ( pool . awaitTermination ( TIMEOUT , TimeUnit . SECONDS ) ) ; fNotifier . removeListener ( listener1 ) ; fNotifier . removeListener ( listener2 ) ; assertThat ( listener1 . fTestStarted . get ( ) , is ( numParallelTests ) ) ; assertThat ( listener2 . fTestStarted . get ( ) , is ( numParallelTests ) ) ; } private static class ExaminedListener extends RunListener { final boolean throwFromTestStarted ; volatile boolean hasTestFailure = false ; ExaminedListener ( boolean throwFromTestStarted ) { this . throwFromTestStarted = throwFromTestStarted ; } @Override public void testStarted ( Description description ) throws Exception { if ( throwFromTestStarted ) { throw new Exception ( ) ; } } @Override public void testFailure ( Failure failure ) throws Exception { hasTestFailure = true ; } } private abstract class AbstractConcurrentFailuresTest { protected abstract void addListener ( ExaminedListener listener ) ; public void test ( ) throws Exception { int totalListenersFailures = <int> ; Random random = new Random ( <int> ) ; ExaminedListener [ ] examinedListeners = new ExaminedListener [ <int> ] ; for ( int i = <int> ; i < examinedListeners . length ; + + i ) { boolean fail = random . nextDouble ( ) > = <float> ; if ( fail ) { + + totalListenersFailures ; } examinedListeners [ i ] = new ExaminedListener ( fail ) ; } final AtomicBoolean condition = new AtomicBoolean ( true ) ; final CyclicBarrier trigger = new CyclicBarrier ( <int> ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; ExecutorService notificationsPool = Executors . newFixedThreadPool ( <int> ) ; notificationsPool . submit ( new Callable < Void > ( ) { public Void call ( ) throws Exception { trigger . await ( ) ; while ( condition . get ( ) ) { fNotifier . fireTestStarted ( null ) ; latch . countDown ( ) ; } fNotifier . fireTestStarted ( null ) ; return null ; } } ) ; trigger . await ( TIMEOUT , TimeUnit . SECONDS ) ; latch . await ( TIMEOUT , TimeUnit . SECONDS ) ; for ( ExaminedListener examinedListener : examinedListeners ) { addListener ( examinedListener ) ; } notificationsPool . shutdown ( ) ; condition . set ( false ) ; assertTrue ( notificationsPool . awaitTermination ( TIMEOUT , TimeUnit . SECONDS ) ) ; if ( totalListenersFailures ! = <int> ) { int countTestFailures = examinedListeners . length - countReportedTestFailures ( examinedListeners ) ; assertThat ( totalListenersFailures , is ( countTestFailures ) ) ; } } } @Test public void reportConcurrentFailuresAfterAddListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @Override protected void addListener ( ExaminedListener listener ) { fNotifier . addListener ( listener ) ; } } . test ( ) ; } @Test public void reportConcurrentFailuresAfterAddFirstListener ( ) throws Exception { new AbstractConcurrentFailuresTest ( ) { @Override protected void addListener ( ExaminedListener listener ) { fNotifier . addFirstListener ( listener ) ; } } . test ( ) ; } private static int countReportedTestFailures ( ExaminedListener [ ] listeners ) { int count = <int> ; for ( ExaminedListener listener : listeners ) { if ( listener . hasTestFailure ) { + + count ; } } return count ; } } 
