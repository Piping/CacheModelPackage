package org . elasticsearch . search . basic ; import org . apache . lucene . util . English ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . indices . refresh . RefreshResponse ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . store . MockFSDirectoryService ; import org . elasticsearch . test . store . MockFSIndexStore ; import java . io . IOException ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; public class SearchWithRandomIOExceptionsIT extends ESIntegTestCase { @TestLogging ( <str> ) public void testRandomDirectoryIOExceptions ( ) throws IOException , InterruptedException , ExecutionException { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; final double exceptionRate ; final double exceptionOnOpenRate ; if ( frequently ( ) ) { if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { exceptionOnOpenRate = <float> / between ( <int> , <int> ) ; exceptionRate = <float> ; } else { exceptionRate = <float> / between ( <int> , <int> ) ; exceptionOnOpenRate = <float> ; } } else { exceptionOnOpenRate = <float> / between ( <int> , <int> ) ; exceptionRate = <float> / between ( <int> , <int> ) ; } } else { exceptionRate = <float> ; exceptionOnOpenRate = <float> ; } final boolean createIndexWithoutErrors = randomBoolean ( ) ; int numInitialDocs = <int> ; if ( createIndexWithoutErrors ) { Settings . Builder settings = settingsBuilder ( ) . put ( <str> , numberOfReplicas ( ) ) ; logger . info ( <str> , settings . build ( ) . getAsMap ( ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) . execute ( ) . actionGet ( ) ; numInitialDocs = between ( <int> , <int> ) ; ensureGreen ( ) ; for ( int i = <int> ; i < numInitialDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , <str> ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( <str> ) . setWaitIfOngoing ( true ) . execute ( ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( settingsBuilder ( ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE , exceptionRate ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE_ON_OPEN , exceptionOnOpenRate ) ) ; client ( ) . admin ( ) . indices ( ) . prepareOpen ( <str> ) . execute ( ) . get ( ) ; } else { Settings . Builder settings = settingsBuilder ( ) . put ( <str> , randomIntBetween ( <int> , <int> ) ) . put ( MockFSIndexStore . CHECK_INDEX_ON_CLOSE , false ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE , exceptionRate ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE_ON_OPEN , exceptionOnOpenRate ) ; logger . info ( <str> , settings . build ( ) . getAsMap ( ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) . execute ( ) . actionGet ( ) ; } ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . health ( Requests . clusterHealthRequest ( ) . waitForYellowStatus ( ) . timeout ( TimeValue . timeValueSeconds ( <int> ) ) ) . get ( ) ; final int numDocs ; final boolean expectAllShardsFailed ; if ( clusterHealthResponse . isTimedOut ( ) ) { logger . info ( <str> ) ; numDocs = <int> ; expectAllShardsFailed = true ; } else { numDocs = between ( <int> , <int> ) ; expectAllShardsFailed = false ; } int numCreated = <int> ; boolean [ ] added = new boolean [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { added [ i ] = false ; try { IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setTimeout ( TimeValue . timeValueSeconds ( <int> ) ) . setSource ( <str> , English . intToEnglish ( i ) ) . get ( ) ; if ( indexResponse . isCreated ( ) ) { numCreated + + ; added [ i ] = true ; } } catch ( ElasticsearchException ex ) { } } ESIntegTestCase . NumShards numShards = getNumShards ( <str> ) ; logger . info ( <str> ) ; final RefreshResponse refreshResponse = client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . get ( ) ; final boolean refreshFailed = refreshResponse . getShardFailures ( ) . length ! = <int> | | refreshResponse . getFailedShards ( ) ! = <int> ; logger . info ( <str> , refreshFailed , refreshResponse . getFailedShards ( ) , refreshResponse . getShardFailures ( ) . length , refreshResponse . getSuccessfulShards ( ) , refreshResponse . getTotalShards ( ) ) ; final int numSearches = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numSearches ; i + + ) { try { int docToQuery = between ( <int> , numDocs - <int> ) ; int expectedResults = added [ docToQuery ] ? <int> : <int> ; logger . info ( <str> , English . intToEnglish ( docToQuery ) ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setTypes ( <str> ) . setQuery ( QueryBuilders . matchQuery ( <str> , English . intToEnglish ( docToQuery ) ) ) . setSize ( expectedResults ) . get ( ) ; logger . info ( <str> , searchResponse . getSuccessfulShards ( ) , numShards . numPrimaries ) ; if ( searchResponse . getSuccessfulShards ( ) = = numShards . numPrimaries & & ! refreshFailed ) { assertResultsAndLogOnFailure ( expectedResults , searchResponse ) ; } searchResponse = client ( ) . prepareSearch ( ) . setTypes ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . setSize ( numCreated + numInitialDocs ) . addSort ( <str> , SortOrder . ASC ) . get ( ) ; logger . info ( <str> , searchResponse . getSuccessfulShards ( ) , numShards . numPrimaries ) ; if ( searchResponse . getSuccessfulShards ( ) = = numShards . numPrimaries & & ! refreshFailed ) { assertResultsAndLogOnFailure ( numCreated + numInitialDocs , searchResponse ) ; } } catch ( SearchPhaseExecutionException ex ) { logger . info ( <str> , ex . getMessage ( ) ) ; if ( ! ( expectAllShardsFailed | | refreshResponse . getSuccessfulShards ( ) = = <int> | | ex . getMessage ( ) . contains ( <str> ) ) ) { throw ex ; } } } if ( createIndexWithoutErrors ) { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( settingsBuilder ( ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE , <int> ) . put ( MockFSDirectoryService . RANDOM_IO_EXCEPTION_RATE_ON_OPEN , <int> ) ) ; client ( ) . admin ( ) . indices ( ) . prepareOpen ( <str> ) . execute ( ) . get ( ) ; ensureGreen ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setTypes ( <str> ) . setQuery ( QueryBuilders . matchQuery ( <str> , <str> ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , numInitialDocs ) ; } } } 
