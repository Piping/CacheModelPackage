package io . netty . channel . epoll ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . CompositeByteBuf ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultAddressedEnvelope ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . DatagramChannelConfig ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . unix . DatagramSocketAddress ; import io . netty . channel . unix . FileDescriptor ; import io . netty . channel . unix . Socket ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . NetworkInterface ; import java . net . SocketAddress ; import java . net . SocketException ; import java . nio . ByteBuffer ; import java . nio . channels . NotYetConnectedException ; import java . util . ArrayList ; import java . util . List ; import static io . netty . channel . unix . Socket . newSocketDgram ; public final class EpollDatagramChannel extends AbstractEpollChannel implements DatagramChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( true ) ; private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( DatagramPacket . class ) + <str> + StringUtil . simpleClassName ( AddressedEnvelope . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( InetSocketAddress . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> ; private volatile InetSocketAddress local ; private volatile InetSocketAddress remote ; private volatile boolean connected ; private final EpollDatagramChannelConfig config ; public EpollDatagramChannel ( ) { super ( newSocketDgram ( ) , Native . EPOLLIN ) ; config = new EpollDatagramChannelConfig ( this ) ; } @Deprecated public EpollDatagramChannel ( FileDescriptor fd ) { this ( new Socket ( fd . intValue ( ) ) ) ; } public EpollDatagramChannel ( Socket fd ) { super ( null , fd , Native . EPOLLIN , true ) ; local = fd . localAddress ( ) ; config = new EpollDatagramChannelConfig ( this ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override @SuppressWarnings ( <str> ) public boolean isActive ( ) { return fd ( ) . isOpen ( ) & & ( config . getOption ( ChannelOption . DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION ) & & isRegistered ( ) | | active ) ; } @Override public boolean isConnected ( ) { return connected ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress ) { return joinGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelPromise promise ) { try { return joinGroup ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , null , promise ) ; } catch ( SocketException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return joinGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { return joinGroup ( multicastAddress . getAddress ( ) , networkInterface , null , promise ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return joinGroup ( multicastAddress , networkInterface , source , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( final InetAddress multicastAddress , final NetworkInterface networkInterface , final InetAddress source , final ChannelPromise promise ) { if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } promise . setFailure ( new UnsupportedOperationException ( <str> ) ) ; return promise ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress ) { return leaveGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelPromise promise ) { try { return leaveGroup ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , null , promise ) ; } catch ( SocketException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return leaveGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { return leaveGroup ( multicastAddress . getAddress ( ) , networkInterface , null , promise ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return leaveGroup ( multicastAddress , networkInterface , source , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( final InetAddress multicastAddress , final NetworkInterface networkInterface , final InetAddress source , final ChannelPromise promise ) { if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } promise . setFailure ( new UnsupportedOperationException ( <str> ) ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress sourceToBlock ) { return block ( multicastAddress , networkInterface , sourceToBlock , newPromise ( ) ) ; } @Override public ChannelFuture block ( final InetAddress multicastAddress , final NetworkInterface networkInterface , final InetAddress sourceToBlock , final ChannelPromise promise ) { if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( sourceToBlock = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } promise . setFailure ( new UnsupportedOperationException ( <str> ) ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock ) { return block ( multicastAddress , sourceToBlock , newPromise ( ) ) ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock , ChannelPromise promise ) { try { return block ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , sourceToBlock , promise ) ; } catch ( Throwable e ) { promise . setFailure ( e ) ; } return promise ; } @Override protected AbstractEpollUnsafe newUnsafe ( ) { return new EpollDatagramChannelUnsafe ( ) ; } @Override protected InetSocketAddress localAddress0 ( ) { return local ; } @Override protected InetSocketAddress remoteAddress0 ( ) { return remote ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { InetSocketAddress addr = ( InetSocketAddress ) localAddress ; checkResolvable ( addr ) ; fd ( ) . bind ( addr ) ; local = fd ( ) . localAddress ( ) ; active = true ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { clearFlag ( Native . EPOLLOUT ) ; break ; } try { if ( Native . IS_SUPPORTING_SENDMMSG & & in . size ( ) > <int> ) { NativeDatagramPacketArray array = NativeDatagramPacketArray . getInstance ( in ) ; int cnt = array . count ( ) ; if ( cnt > = <int> ) { int offset = <int> ; NativeDatagramPacketArray . NativeDatagramPacket [ ] packets = array . packets ( ) ; while ( cnt > <int> ) { int send = Native . sendmmsg ( fd ( ) . intValue ( ) , packets , offset , cnt ) ; if ( send = = <int> ) { setFlag ( Native . EPOLLOUT ) ; return ; } for ( int i = <int> ; i < send ; i + + ) { in . remove ( ) ; } cnt - = send ; offset + = send ; } continue ; } } boolean done = false ; for ( int i = config ( ) . getWriteSpinCount ( ) - <int> ; i > = <int> ; i - - ) { if ( doWriteMessage ( msg ) ) { done = true ; break ; } } if ( done ) { in . remove ( ) ; } else { setFlag ( Native . EPOLLOUT ) ; break ; } } catch ( IOException e ) { in . remove ( e ) ; } } } private boolean doWriteMessage ( Object msg ) throws Exception { final ByteBuf data ; InetSocketAddress remoteAddress ; if ( msg instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < ByteBuf , InetSocketAddress > envelope = ( AddressedEnvelope < ByteBuf , InetSocketAddress > ) msg ; data = envelope . content ( ) ; remoteAddress = envelope . recipient ( ) ; } else { data = ( ByteBuf ) msg ; remoteAddress = null ; } final int dataLen = data . readableBytes ( ) ; if ( dataLen = = <int> ) { return true ; } if ( remoteAddress = = null ) { remoteAddress = remote ; if ( remoteAddress = = null ) { throw new NotYetConnectedException ( ) ; } } final int writtenBytes ; if ( data . hasMemoryAddress ( ) ) { long memoryAddress = data . memoryAddress ( ) ; writtenBytes = fd ( ) . sendToAddress ( memoryAddress , data . readerIndex ( ) , data . writerIndex ( ) , remoteAddress . getAddress ( ) , remoteAddress . getPort ( ) ) ; } else if ( data instanceof CompositeByteBuf ) { IovArray array = ( ( EpollEventLoop ) eventLoop ( ) ) . cleanArray ( ) ; array . add ( data ) ; int cnt = array . count ( ) ; assert cnt ! = <int> ; writtenBytes = fd ( ) . sendToAddresses ( array . memoryAddress ( <int> ) , cnt , remoteAddress . getAddress ( ) , remoteAddress . getPort ( ) ) ; } else { ByteBuffer nioData = data . internalNioBuffer ( data . readerIndex ( ) , data . readableBytes ( ) ) ; writtenBytes = fd ( ) . sendTo ( nioData , nioData . position ( ) , nioData . limit ( ) , remoteAddress . getAddress ( ) , remoteAddress . getPort ( ) ) ; } return writtenBytes > <int> ; } @Override protected Object filterOutboundMessage ( Object msg ) { if ( msg instanceof DatagramPacket ) { DatagramPacket packet = ( DatagramPacket ) msg ; ByteBuf content = packet . content ( ) ; if ( content . hasMemoryAddress ( ) ) { return msg ; } if ( content . isDirect ( ) & & content instanceof CompositeByteBuf ) { CompositeByteBuf comp = ( CompositeByteBuf ) content ; if ( comp . isDirect ( ) & & comp . nioBufferCount ( ) < = Native . IOV_MAX ) { return msg ; } } return new DatagramPacket ( newDirectBuffer ( packet , content ) , packet . recipient ( ) ) ; } if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; if ( ! buf . hasMemoryAddress ( ) & & ( PlatformDependent . hasUnsafe ( ) | | ! buf . isDirect ( ) ) ) { if ( buf instanceof CompositeByteBuf ) { CompositeByteBuf comp = ( CompositeByteBuf ) buf ; if ( ! comp . isDirect ( ) | | comp . nioBufferCount ( ) > Native . IOV_MAX ) { buf = newDirectBuffer ( buf ) ; assert buf . hasMemoryAddress ( ) ; } } else { buf = newDirectBuffer ( buf ) ; assert buf . hasMemoryAddress ( ) ; } } return buf ; } if ( msg instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < Object , SocketAddress > e = ( AddressedEnvelope < Object , SocketAddress > ) msg ; if ( e . content ( ) instanceof ByteBuf & & ( e . recipient ( ) = = null | | e . recipient ( ) instanceof InetSocketAddress ) ) { ByteBuf content = ( ByteBuf ) e . content ( ) ; if ( content . hasMemoryAddress ( ) ) { return e ; } if ( content instanceof CompositeByteBuf ) { CompositeByteBuf comp = ( CompositeByteBuf ) content ; if ( comp . isDirect ( ) & & comp . nioBufferCount ( ) < = Native . IOV_MAX ) { return e ; } } return new DefaultAddressedEnvelope < ByteBuf , InetSocketAddress > ( newDirectBuffer ( e , content ) , ( InetSocketAddress ) e . recipient ( ) ) ; } } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } @Override public EpollDatagramChannelConfig config ( ) { return config ; } @Override protected void doDisconnect ( ) throws Exception { connected = false ; } final class EpollDatagramChannelUnsafe extends AbstractEpollUnsafe { private final List < Object > readBuf = new ArrayList < Object > ( ) ; @Override public void connect ( SocketAddress remote , SocketAddress local , ChannelPromise channelPromise ) { boolean success = false ; try { try { boolean wasActive = isActive ( ) ; InetSocketAddress remoteAddress = ( InetSocketAddress ) remote ; if ( local ! = null ) { InetSocketAddress localAddress = ( InetSocketAddress ) local ; doBind ( localAddress ) ; } checkResolvable ( remoteAddress ) ; EpollDatagramChannel . this . remote = remoteAddress ; EpollDatagramChannel . this . local = fd ( ) . localAddress ( ) ; success = true ; if ( ! wasActive & & isActive ( ) ) { pipeline ( ) . fireChannelActive ( ) ; } } finally { if ( ! success ) { doClose ( ) ; } else { channelPromise . setSuccess ( ) ; connected = true ; } } } catch ( Throwable cause ) { channelPromise . setFailure ( cause ) ; } } @Override protected EpollRecvByteAllocatorHandle newEpollHandle ( RecvByteBufAllocator . Handle handle ) { return new EpollRecvByteAllocatorMessageHandle ( handle , isFlagSet ( Native . EPOLLET ) ) ; } @Override void epollInReady ( ) { assert eventLoop ( ) . inEventLoop ( ) ; if ( fd ( ) . isInputShutdown ( ) ) { return ; } DatagramChannelConfig config = config ( ) ; boolean edgeTriggered = isFlagSet ( Native . EPOLLET ) ; if ( ! readPending & & ! edgeTriggered & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final ByteBufAllocator allocator = config . getAllocator ( ) ; final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; Throwable exception = null ; try { ByteBuf data = null ; try { do { data = allocHandle . allocate ( allocator ) ; allocHandle . attemptedBytesRead ( data . writableBytes ( ) ) ; final DatagramSocketAddress remoteAddress ; if ( data . hasMemoryAddress ( ) ) { remoteAddress = fd ( ) . recvFromAddress ( data . memoryAddress ( ) , data . writerIndex ( ) , data . capacity ( ) ) ; } else { ByteBuffer nioData = data . internalNioBuffer ( data . writerIndex ( ) , data . writableBytes ( ) ) ; remoteAddress = fd ( ) . recvFrom ( nioData , nioData . position ( ) , nioData . limit ( ) ) ; } if ( remoteAddress = = null ) { data . release ( ) ; data = null ; break ; } allocHandle . incMessagesRead ( <int> ) ; allocHandle . lastBytesRead ( remoteAddress . receivedAmount ( ) ) ; data . writerIndex ( data . writerIndex ( ) + allocHandle . lastBytesRead ( ) ) ; readPending = false ; readBuf . add ( new DatagramPacket ( data , ( InetSocketAddress ) localAddress ( ) , remoteAddress ) ) ; data = null ; } while ( allocHandle . continueReading ( ) ) ; } catch ( Throwable t ) { if ( data ! = null ) { data . release ( ) ; data = null ; } exception = t ; } int size = readBuf . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { pipeline . fireChannelRead ( readBuf . get ( i ) ) ; } readBuf . clear ( ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( exception ! = null ) { pipeline . fireExceptionCaught ( exception ) ; checkResetEpollIn ( edgeTriggered ) ; } } finally { if ( ! readPending & & ! config . isAutoRead ( ) ) { clearEpollIn ( ) ; } } } } } 
