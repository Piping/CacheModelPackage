package org . elasticsearch . index . cache . bitset ; import org . apache . lucene . index . IndexReaderContext ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . ReaderUtil ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Weight ; import org . apache . lucene . search . join . BitSetProducer ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . BitDocIdSet ; import org . apache . lucene . util . BitSet ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . common . cache . Cache ; import org . elasticsearch . common . cache . CacheBuilder ; import org . elasticsearch . common . cache . RemovalListener ; import org . elasticsearch . common . cache . RemovalNotification ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . AbstractIndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardUtils ; import org . elasticsearch . indices . IndicesWarmer ; import org . elasticsearch . indices . IndicesWarmer . TerminationHandle ; import java . io . Closeable ; import java . io . IOException ; import java . util . HashSet ; import java . util . Objects ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; public final class BitsetFilterCache extends AbstractIndexComponent implements LeafReader . CoreClosedListener , RemovalListener < Object , Cache < Query , BitsetFilterCache . Value > > , Closeable { public static final String LOAD_RANDOM_ACCESS_FILTERS_EAGERLY = <str> ; private final boolean loadRandomAccessFiltersEagerly ; private final Cache < Object , Cache < Query , Value > > loadedFilters ; private final Listener listener ; private final BitSetProducerWarmer warmer ; private final IndicesWarmer indicesWarmer ; public BitsetFilterCache ( IndexSettings indexSettings , IndicesWarmer indicesWarmer , Listener listener ) { super ( indexSettings ) ; if ( listener = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . loadRandomAccessFiltersEagerly = this . indexSettings . getSettings ( ) . getAsBoolean ( LOAD_RANDOM_ACCESS_FILTERS_EAGERLY , true ) ; this . loadedFilters = CacheBuilder . < Object , Cache < Query , Value > > builder ( ) . removalListener ( this ) . build ( ) ; this . warmer = new BitSetProducerWarmer ( ) ; this . indicesWarmer = indicesWarmer ; indicesWarmer . addListener ( warmer ) ; this . listener = listener ; } public BitSetProducer getBitSetProducer ( Query query ) { return new QueryWrapperBitSetProducer ( query ) ; } @Override public void onClose ( Object ownerCoreCacheKey ) { loadedFilters . invalidate ( ownerCoreCacheKey ) ; } @Override public void close ( ) { try { indicesWarmer . removeListener ( warmer ) ; } finally { clear ( <str> ) ; } } public void clear ( String reason ) { logger . debug ( <str> , reason ) ; loadedFilters . invalidateAll ( ) ; } private BitSet getAndLoadIfNotPresent ( final Query query , final LeafReaderContext context ) throws IOException , ExecutionException { final Object coreCacheReader = context . reader ( ) . getCoreCacheKey ( ) ; final ShardId shardId = ShardUtils . extractShardId ( context . reader ( ) ) ; Cache < Query , Value > filterToFbs = loadedFilters . computeIfAbsent ( coreCacheReader , key - > { context . reader ( ) . addCoreClosedListener ( BitsetFilterCache . this ) ; return CacheBuilder . < Query , Value > builder ( ) . build ( ) ; } ) ; return filterToFbs . computeIfAbsent ( query , key - > { final IndexReaderContext topLevelContext = ReaderUtil . getTopLevelContext ( context ) ; final IndexSearcher searcher = new IndexSearcher ( topLevelContext ) ; searcher . setQueryCache ( null ) ; final Weight weight = searcher . createNormalizedWeight ( query , false ) ; final DocIdSetIterator it = weight . scorer ( context ) ; final BitSet bitSet ; if ( it = = null ) { bitSet = null ; } else { bitSet = BitSet . of ( it , context . reader ( ) . maxDoc ( ) ) ; } Value value = new Value ( bitSet , shardId ) ; listener . onCache ( shardId , value . bitset ) ; return value ; } ) . bitset ; } @Override public void onRemoval ( RemovalNotification < Object , Cache < Query , Value > > notification ) { if ( notification . getKey ( ) = = null ) { return ; } Cache < Query , Value > valueCache = notification . getValue ( ) ; if ( valueCache = = null ) { return ; } for ( Value value : valueCache . values ( ) ) { listener . onRemoval ( value . shardId , value . bitset ) ; } } public static final class Value { final BitSet bitset ; final ShardId shardId ; public Value ( BitSet bitset , ShardId shardId ) { this . bitset = bitset ; this . shardId = shardId ; } } final class QueryWrapperBitSetProducer implements BitSetProducer { final Query query ; QueryWrapperBitSetProducer ( Query query ) { this . query = Objects . requireNonNull ( query ) ; } @Override public BitSet getBitSet ( LeafReaderContext context ) throws IOException { try { return getAndLoadIfNotPresent ( query , context ) ; } catch ( ExecutionException e ) { throw ExceptionsHelper . convertToElastic ( e ) ; } } @Override public String toString ( ) { return <str> + query + <str> ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof QueryWrapperBitSetProducer ) ) return false ; return this . query . equals ( ( ( QueryWrapperBitSetProducer ) o ) . query ) ; } @Override public int hashCode ( ) { return <int> * getClass ( ) . hashCode ( ) + query . hashCode ( ) ; } } final class BitSetProducerWarmer implements IndicesWarmer . Listener { @Override public IndicesWarmer . TerminationHandle warmNewReaders ( final IndexShard indexShard , final Engine . Searcher searcher ) { if ( ! loadRandomAccessFiltersEagerly ) { return TerminationHandle . NO_WAIT ; } boolean hasNested = false ; final Set < Query > warmUp = new HashSet < > ( ) ; final MapperService mapperService = indexShard . mapperService ( ) ; for ( DocumentMapper docMapper : mapperService . docMappers ( false ) ) { if ( docMapper . hasNestedObjects ( ) ) { hasNested = true ; for ( ObjectMapper objectMapper : docMapper . objectMappers ( ) . values ( ) ) { if ( objectMapper . nested ( ) . isNested ( ) ) { ObjectMapper parentObjectMapper = docMapper . findParentObjectMapper ( objectMapper ) ; if ( parentObjectMapper ! = null & & parentObjectMapper . nested ( ) . isNested ( ) ) { warmUp . add ( parentObjectMapper . nestedTypeFilter ( ) ) ; } } } } } if ( hasNested ) { warmUp . add ( Queries . newNonNestedFilter ( ) ) ; } final Executor executor = indicesWarmer . getExecutor ( ) ; final CountDownLatch latch = new CountDownLatch ( searcher . reader ( ) . leaves ( ) . size ( ) * warmUp . size ( ) ) ; for ( final LeafReaderContext ctx : searcher . reader ( ) . leaves ( ) ) { for ( final Query filterToWarm : warmUp ) { executor . execute ( ( ) - > { try { final long start = System . nanoTime ( ) ; getAndLoadIfNotPresent ( filterToWarm , ctx ) ; if ( indexShard . warmerService ( ) . logger ( ) . isTraceEnabled ( ) ) { indexShard . warmerService ( ) . logger ( ) . trace ( <str> , filterToWarm , TimeValue . timeValueNanos ( System . nanoTime ( ) - start ) ) ; } } catch ( Throwable t ) { indexShard . warmerService ( ) . logger ( ) . warn ( <str> , t , filterToWarm ) ; } finally { latch . countDown ( ) ; } } ) ; } } return ( ) - > latch . await ( ) ; } @Override public TerminationHandle warmTopReader ( IndexShard indexShard , Engine . Searcher searcher ) { return TerminationHandle . NO_WAIT ; } } Cache < Object , Cache < Query , Value > > getLoadedFilters ( ) { return loadedFilters ; } public interface Listener { void onCache ( ShardId shardId , Accountable accountable ) ; void onRemoval ( ShardId shardId , Accountable accountable ) ; } } 
