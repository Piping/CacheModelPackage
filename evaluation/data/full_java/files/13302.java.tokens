package org . gradle . test . fixtures . file ; import groovy . lang . Closure ; import org . apache . commons . io . FileUtils ; import org . apache . commons . lang . StringUtils ; import org . gradle . test . fixtures . ConcurrentTestUtil ; import org . junit . rules . TestRule ; import org . junit . runner . Description ; import org . junit . runners . model . Statement ; import java . io . IOException ; import java . util . Random ; import java . util . regex . Pattern ; abstract class AbstractTestDirectoryProvider implements TestRule , TestDirectoryProvider { protected static TestFile root ; private static final Random RANDOM = new Random ( ) ; private static final int ALL_DIGITS_AND_LETTERS_RADIX = <int> ; private static final int MAX_RANDOM_PART_VALUE = Integer . valueOf ( <str> , ALL_DIGITS_AND_LETTERS_RADIX ) ; private static final Pattern WINDOWS_RESERVED_NAMES = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; private TestFile dir ; private String prefix ; private boolean cleanup = true ; private boolean suppressCleanupErrors ; private String determinePrefix ( ) { StackTraceElement [ ] stackTrace = new RuntimeException ( ) . getStackTrace ( ) ; for ( StackTraceElement element : stackTrace ) { if ( element . getClassName ( ) . endsWith ( <str> ) | | element . getClassName ( ) . endsWith ( <str> ) ) { return StringUtils . substringAfterLast ( element . getClassName ( ) , <str> ) + <str> ; } } return <str> ; } @Override public void suppressCleanup ( ) { cleanup = false ; } public Statement apply ( final Statement base , Description description ) { Class < ? > testClass = description . getTestClass ( ) ; init ( description . getMethodName ( ) , testClass . getSimpleName ( ) ) ; suppressCleanupErrors = testClass . getAnnotation ( LeaksFileHandles . class ) ! = null | | description . getAnnotation ( LeaksFileHandles . class ) ! = null | | <str> . equals ( System . getProperty ( <str> ) ) ; return new TestDirectoryCleaningStatement ( base , description . getDisplayName ( ) ) ; } private class TestDirectoryCleaningStatement extends Statement { private final Statement base ; private final String displayName ; public TestDirectoryCleaningStatement ( Statement base , String displayName ) { this . base = base ; this . displayName = displayName ; } @Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; try { if ( cleanup & & dir ! = null & & dir . exists ( ) ) { ConcurrentTestUtil . poll ( new Closure ( null , null ) { @SuppressWarnings ( <str> ) void doCall ( ) throws IOException { FileUtils . forceDelete ( dir ) ; } } ) ; } } catch ( Exception e ) { if ( suppressCleanupErrors ) { System . err . println ( <str> + displayName + <str> ) ; e . printStackTrace ( System . err ) ; } else { throw e ; } } } } protected void init ( String methodName , String className ) { if ( methodName = = null ) { methodName = getClass ( ) . getSimpleName ( ) ; } if ( prefix = = null ) { String safeMethodName = methodName . replaceAll ( <str> , <str> ) ; if ( safeMethodName . length ( ) > <int> ) { safeMethodName = safeMethodName . substring ( <int> , <int> ) + <str> + safeMethodName . substring ( safeMethodName . length ( ) - <int> ) ; } prefix = String . format ( <str> , className , safeMethodName ) ; } } public TestFile getTestDirectory ( ) { if ( dir = = null ) { if ( prefix = = null ) { prefix = determinePrefix ( ) ; } while ( true ) { String prefix = Integer . toString ( RANDOM . nextInt ( MAX_RANDOM_PART_VALUE ) , ALL_DIGITS_AND_LETTERS_RADIX ) ; if ( WINDOWS_RESERVED_NAMES . matcher ( prefix ) . matches ( ) ) { continue ; } dir = root . file ( this . prefix , prefix ) ; if ( dir . mkdirs ( ) ) { break ; } } } return dir ; } public TestFile file ( Object . . . path ) { return getTestDirectory ( ) . file ( ( Object [ ] ) path ) ; } public TestFile createFile ( Object . . . path ) { return file ( ( Object [ ] ) path ) . createFile ( ) ; } public TestFile createDir ( Object . . . path ) { return file ( ( Object [ ] ) path ) . createDir ( ) ; } } 
