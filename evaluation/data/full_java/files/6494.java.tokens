package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . IndexReader ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexFieldDataCache ; import org . elasticsearch . index . fielddata . IndexNumericFieldData . NumericType ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . internal . IdFieldMapper ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; public abstract class DocValuesIndexFieldData { protected final Index index ; protected final Names fieldNames ; protected final FieldDataType fieldDataType ; protected final ESLogger logger ; public DocValuesIndexFieldData ( Index index , Names fieldNames , FieldDataType fieldDataType ) { super ( ) ; this . index = index ; this . fieldNames = fieldNames ; this . fieldDataType = fieldDataType ; this . logger = Loggers . getLogger ( getClass ( ) ) ; } public final Names getFieldNames ( ) { return fieldNames ; } public final FieldDataType getFieldDataType ( ) { return fieldDataType ; } public final void clear ( ) { } public final void clear ( IndexReader reader ) { } public final Index index ( ) { return index ; } public static class Builder implements IndexFieldData . Builder { private static final Set < String > BINARY_INDEX_FIELD_NAMES = unmodifiableSet ( newHashSet ( UidFieldMapper . NAME , IdFieldMapper . NAME ) ) ; private NumericType numericType ; public Builder numericType ( NumericType type ) { this . numericType = type ; return this ; } @Override public IndexFieldData < ? > build ( IndexSettings indexSettings , MappedFieldType fieldType , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService ) { final Names fieldNames = fieldType . names ( ) ; final Settings fdSettings = fieldType . fieldDataType ( ) . getSettings ( ) ; final Map < String , Settings > filter = fdSettings . getGroups ( <str> ) ; if ( filter ! = null & & ! filter . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + fieldNames . fullName ( ) + <str> ) ; } if ( BINARY_INDEX_FIELD_NAMES . contains ( fieldNames . indexName ( ) ) ) { assert numericType = = null ; return new BinaryDVIndexFieldData ( indexSettings . getIndex ( ) , fieldNames , fieldType . fieldDataType ( ) ) ; } else if ( numericType ! = null ) { return new SortedNumericDVIndexFieldData ( indexSettings . getIndex ( ) , fieldNames , numericType , fieldType . fieldDataType ( ) ) ; } else { return new SortedSetDVOrdinalsIndexFieldData ( indexSettings , cache , fieldNames , breakerService , fieldType . fieldDataType ( ) ) ; } } } } 
