package org . elasticsearch . index . fielddata . ordinals ; import org . apache . lucene . index . DocValues ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . MultiDocValues . OrdinalMap ; import org . apache . lucene . index . RandomAccessOrds ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . packed . PackedInts ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . * ; import org . elasticsearch . index . fielddata . plain . AbstractAtomicOrdinalsFieldData ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import java . io . IOException ; import java . util . Collection ; import java . util . Collections ; public enum GlobalOrdinalsBuilder { ; public static IndexOrdinalsFieldData build ( final IndexReader indexReader , IndexOrdinalsFieldData indexFieldData , IndexSettings indexSettings , CircuitBreakerService breakerService , ESLogger logger ) throws IOException { assert indexReader . leaves ( ) . size ( ) > <int> ; long startTimeNS = System . nanoTime ( ) ; final AtomicOrdinalsFieldData [ ] atomicFD = new AtomicOrdinalsFieldData [ indexReader . leaves ( ) . size ( ) ] ; final RandomAccessOrds [ ] subs = new RandomAccessOrds [ indexReader . leaves ( ) . size ( ) ] ; for ( int i = <int> ; i < indexReader . leaves ( ) . size ( ) ; + + i ) { atomicFD [ i ] = indexFieldData . load ( indexReader . leaves ( ) . get ( i ) ) ; subs [ i ] = atomicFD [ i ] . getOrdinalsValues ( ) ; } final OrdinalMap ordinalMap = OrdinalMap . build ( null , subs , PackedInts . DEFAULT ) ; final long memorySizeInBytes = ordinalMap . ramBytesUsed ( ) ; breakerService . getBreaker ( CircuitBreaker . FIELDDATA ) . addWithoutBreaking ( memorySizeInBytes ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , indexFieldData . getFieldNames ( ) . fullName ( ) , ordinalMap . getValueCount ( ) , TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ) ; } return new InternalGlobalOrdinalsIndexFieldData ( indexSettings , indexFieldData . getFieldNames ( ) , indexFieldData . getFieldDataType ( ) , atomicFD , ordinalMap , memorySizeInBytes ) ; } public static IndexOrdinalsFieldData buildEmpty ( IndexSettings indexSettings , final IndexReader indexReader , IndexOrdinalsFieldData indexFieldData ) throws IOException { assert indexReader . leaves ( ) . size ( ) > <int> ; final AtomicOrdinalsFieldData [ ] atomicFD = new AtomicOrdinalsFieldData [ indexReader . leaves ( ) . size ( ) ] ; final RandomAccessOrds [ ] subs = new RandomAccessOrds [ indexReader . leaves ( ) . size ( ) ] ; for ( int i = <int> ; i < indexReader . leaves ( ) . size ( ) ; + + i ) { atomicFD [ i ] = new AbstractAtomicOrdinalsFieldData ( ) { @Override public RandomAccessOrds getOrdinalsValues ( ) { return DocValues . emptySortedSet ( ) ; } @Override public long ramBytesUsed ( ) { return <int> ; } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } @Override public void close ( ) { } } ; subs [ i ] = atomicFD [ i ] . getOrdinalsValues ( ) ; } final OrdinalMap ordinalMap = OrdinalMap . build ( null , subs , PackedInts . DEFAULT ) ; return new InternalGlobalOrdinalsIndexFieldData ( indexSettings , indexFieldData . getFieldNames ( ) , indexFieldData . getFieldDataType ( ) , atomicFD , ordinalMap , <int> ) ; } } 
