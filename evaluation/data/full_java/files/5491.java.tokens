package org . elasticsearch . bootstrap ; import org . elasticsearch . SecureSM ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . http . netty . NettyHttpServerTransport ; import org . elasticsearch . plugins . PluginInfo ; import org . elasticsearch . transport . netty . NettyTransport ; import java . io . * ; import java . net . SocketPermission ; import java . net . URISyntaxException ; import java . net . URL ; import java . nio . file . AccessMode ; import java . nio . file . DirectoryStream ; import java . nio . file . FileAlreadyExistsException ; import java . nio . file . Files ; import java . nio . file . NotDirectoryException ; import java . nio . file . Path ; import java . security . NoSuchAlgorithmException ; import java . security . Permissions ; import java . security . Policy ; import java . security . URIParameter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; final class Security { private Security ( ) { } static void configure ( Environment environment , boolean filterBadDefaults ) throws Exception { Policy . setPolicy ( new ESPolicy ( createPermissions ( environment ) , getPluginPermissions ( environment ) , filterBadDefaults ) ) ; System . setSecurityManager ( new SecureSM ( ) ) ; selfTest ( ) ; } @SuppressForbidden ( reason = <str> ) static Map < String , Policy > getPluginPermissions ( Environment environment ) throws IOException , NoSuchAlgorithmException { Map < String , Policy > map = new HashMap < > ( ) ; List < Path > pluginsAndModules = new ArrayList < > ( ) ; if ( Files . exists ( environment . pluginsFile ( ) ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( environment . pluginsFile ( ) ) ) { for ( Path plugin : stream ) { pluginsAndModules . add ( plugin ) ; } } } if ( Files . exists ( environment . modulesFile ( ) ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( environment . modulesFile ( ) ) ) { for ( Path plugin : stream ) { pluginsAndModules . add ( plugin ) ; } } } for ( Path plugin : pluginsAndModules ) { Path policyFile = plugin . resolve ( PluginInfo . ES_PLUGIN_POLICY ) ; if ( Files . exists ( policyFile ) ) { List < URL > codebases = new ArrayList < > ( ) ; try ( DirectoryStream < Path > jarStream = Files . newDirectoryStream ( plugin , <str> ) ) { for ( Path jar : jarStream ) { codebases . add ( jar . toRealPath ( ) . toUri ( ) . toURL ( ) ) ; } } Policy policy = readPolicy ( policyFile . toUri ( ) . toURL ( ) , codebases . toArray ( new URL [ codebases . size ( ) ] ) ) ; for ( URL url : codebases ) { if ( map . put ( url . getFile ( ) , policy ) ! = null ) { throw new IllegalStateException ( <str> + url ) ; } } } } return Collections . unmodifiableMap ( map ) ; } @SuppressForbidden ( reason = <str> ) static Policy readPolicy ( URL policyFile , URL codebases [ ] ) { try { try { for ( URL url : codebases ) { String shortName = PathUtils . get ( url . toURI ( ) ) . getFileName ( ) . toString ( ) ; System . setProperty ( <str> + shortName , url . toString ( ) ) ; } return Policy . getInstance ( <str> , new URIParameter ( policyFile . toURI ( ) ) ) ; } finally { for ( URL url : codebases ) { String shortName = PathUtils . get ( url . toURI ( ) ) . getFileName ( ) . toString ( ) ; System . clearProperty ( <str> + shortName ) ; } } } catch ( NoSuchAlgorithmException | URISyntaxException e ) { throw new IllegalArgumentException ( <str> + policyFile + <str> , e ) ; } } static Permissions createPermissions ( Environment environment ) throws IOException { Permissions policy = new Permissions ( ) ; addClasspathPermissions ( policy ) ; addFilePermissions ( policy , environment ) ; addBindPermissions ( policy , environment . settings ( ) ) ; return policy ; } @SuppressForbidden ( reason = <str> ) static void addClasspathPermissions ( Permissions policy ) throws IOException { for ( URL url : JarHell . parseClassPath ( ) ) { Path path ; try { path = PathUtils . get ( url . toURI ( ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } policy . add ( new FilePermission ( path . toString ( ) , <str> ) ) ; if ( Files . isDirectory ( path ) ) { policy . add ( new FilePermission ( path . toString ( ) + path . getFileSystem ( ) . getSeparator ( ) + <str> , <str> ) ) ; } } } static void addFilePermissions ( Permissions policy , Environment environment ) { addPath ( policy , <str> , environment . binFile ( ) , <str> ) ; addPath ( policy , <str> , environment . libFile ( ) , <str> ) ; addPath ( policy , <str> , environment . modulesFile ( ) , <str> ) ; addPath ( policy , <str> , environment . pluginsFile ( ) , <str> ) ; addPath ( policy , <str> , environment . configFile ( ) , <str> ) ; addPath ( policy , <str> , environment . scriptsFile ( ) , <str> ) ; addPath ( policy , <str> , environment . tmpFile ( ) , <str> ) ; addPath ( policy , <str> , environment . logsFile ( ) , <str> ) ; if ( environment . sharedDataFile ( ) ! = null ) { addPath ( policy , <str> , environment . sharedDataFile ( ) , <str> ) ; } for ( Path path : environment . dataFiles ( ) ) { addPath ( policy , <str> , path , <str> ) ; } for ( Path path : environment . dataWithClusterFiles ( ) ) { addPath ( policy , <str> , path , <str> ) ; } for ( Path path : environment . repoFiles ( ) ) { addPath ( policy , <str> , path , <str> ) ; } if ( environment . pidFile ( ) ! = null ) { policy . add ( new FilePermission ( environment . pidFile ( ) . toString ( ) , <str> ) ) ; } } static void addBindPermissions ( Permissions policy , Settings settings ) throws IOException { String httpRange = settings . get ( <str> , settings . get ( <str> , NettyHttpServerTransport . DEFAULT_PORT_RANGE ) ) ; policy . add ( new SocketPermission ( <str> + httpRange , <str> ) ) ; Map < String , Settings > profiles = settings . getGroups ( <str> , true ) ; if ( ! profiles . containsKey ( NettyTransport . DEFAULT_PROFILE ) ) { profiles = new HashMap < > ( profiles ) ; profiles . put ( NettyTransport . DEFAULT_PROFILE , Settings . EMPTY ) ; } for ( Map . Entry < String , Settings > entry : profiles . entrySet ( ) ) { Settings profileSettings = entry . getValue ( ) ; String name = entry . getKey ( ) ; String transportRange = profileSettings . get ( <str> , settings . get ( <str> , NettyTransport . DEFAULT_PORT_RANGE ) ) ; boolean valid = NettyTransport . DEFAULT_PROFILE . equals ( name ) | | ( Strings . hasLength ( name ) & & profileSettings . get ( <str> ) ! = null ) ; if ( valid ) { policy . add ( new SocketPermission ( <str> + transportRange , <str> ) ) ; } } } static void addPath ( Permissions policy , String configurationName , Path path , String permissions ) { try { ensureDirectoryExists ( path ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> + configurationName + <str> + path + <str> , e ) ; } policy . add ( new FilePermission ( path . toString ( ) , permissions ) ) ; policy . add ( new FilePermission ( path . toString ( ) + path . getFileSystem ( ) . getSeparator ( ) + <str> , permissions ) ) ; } static void ensureDirectoryExists ( Path path ) throws IOException { if ( Files . isDirectory ( path ) ) { path . getFileSystem ( ) . provider ( ) . checkAccess ( path . toRealPath ( ) , AccessMode . READ ) ; } else { try { Files . createDirectories ( path ) ; } catch ( FileAlreadyExistsException e ) { IOException e2 = new NotDirectoryException ( path . toString ( ) ) ; e2 . addSuppressed ( e ) ; throw e2 ; } } } @SuppressForbidden ( reason = <str> ) static void selfTest ( ) throws IOException { try { Path p = Files . createTempFile ( null , null ) ; try { Files . delete ( p ) ; } catch ( IOException ignored ) { } } catch ( SecurityException problem ) { throw new SecurityException ( <str> , problem ) ; } } } 
