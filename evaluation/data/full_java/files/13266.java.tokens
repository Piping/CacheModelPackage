package org . gradle . integtests . fixtures . executer ; import org . gradle . api . Action ; import org . gradle . internal . Factory ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . process . internal . ExecHandleBuilder ; import org . gradle . process . internal . JvmOptions ; import org . gradle . test . fixtures . file . TestDirectoryProvider ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . testfixtures . internal . NativeServicesTestFixture ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import static org . junit . Assert . fail ; public class ForkingGradleExecuter extends AbstractGradleExecuter { public ForkingGradleExecuter ( GradleDistribution distribution , TestDirectoryProvider testDirectoryProvider ) { super ( distribution , testDirectoryProvider ) ; } public void assertCanExecute ( ) throws AssertionError { if ( ! getDistribution ( ) . isSupportsSpacesInGradleAndJavaOpts ( ) ) { Map < String , String > environmentVars = buildInvocation ( ) . environmentVars ; for ( String envVarName : Arrays . asList ( <str> , <str> ) ) { String envVarValue = environmentVars . get ( envVarName ) ; if ( envVarValue = = null ) { continue ; } for ( String arg : JvmOptions . fromString ( envVarValue ) ) { if ( arg . contains ( <str> ) ) { throw new AssertionError ( String . format ( <str> , envVarName , arg , getDistribution ( ) . getVersion ( ) . getVersion ( ) ) ) ; } } } } } @Override protected void transformInvocation ( GradleInvocation invocation ) { if ( getDistribution ( ) . isSupportsSpacesInGradleAndJavaOpts ( ) ) { invocation . launcherJvmArgs . addAll ( invocation . implicitLauncherJvmArgs ) ; } else { for ( String jvmArg : invocation . implicitLauncherJvmArgs ) { if ( ! jvmArg . contains ( <str> ) ) { invocation . launcherJvmArgs . add ( jvmArg ) ; } else if ( jvmArg . startsWith ( <str> ) ) { invocation . args . add ( jvmArg ) ; } else { throw new UnsupportedOperationException ( String . format ( <str> , jvmArg , getDistribution ( ) . getVersion ( ) . getVersion ( ) ) ) ; } } } invocation . implicitLauncherJvmArgs . clear ( ) ; Map < String , String > environmentVars = invocation . environmentVars ; String jvmOptsEnvVar ; if ( ! environmentVars . containsKey ( <str> ) ) { jvmOptsEnvVar = <str> ; } else if ( ! environmentVars . containsKey ( <str> ) ) { jvmOptsEnvVar = <str> ; } else { throw new UnsupportedOperationException ( String . format ( <str> , invocation . launcherJvmArgs ) ) ; } environmentVars . put ( jvmOptsEnvVar , toJvmArgsString ( invocation . launcherJvmArgs ) ) ; if ( ! environmentVars . containsKey ( <str> ) ) { environmentVars . put ( <str> , getJavaHome ( ) . getAbsolutePath ( ) ) ; } } @Override protected List < String > getAllArgs ( ) { List < String > args = new ArrayList < String > ( ) ; args . addAll ( super . getAllArgs ( ) ) ; args . add ( <str> ) ; addPropagatedSystemProperties ( args ) ; return args ; } private void addPropagatedSystemProperties ( List < String > args ) { for ( String propName : propagatedSystemProperties ) { String propValue = System . getProperty ( propName ) ; if ( propValue ! = null ) { args . add ( <str> + propName + <str> + propValue ) ; } } } private ExecHandleBuilder createExecHandleBuilder ( ) { TestFile gradleHomeDir = getDistribution ( ) . getGradleHomeDir ( ) ; if ( ! gradleHomeDir . isDirectory ( ) ) { fail ( gradleHomeDir + <str> + <str> ) ; } NativeServicesTestFixture . initialize ( ) ; ExecHandleBuilder builder = new ExecHandleBuilder ( ) { @Override public File getWorkingDir ( ) { return ForkingGradleExecuter . this . getWorkingDir ( ) ; } } ; builder . environment ( <str> , <str> ) ; builder . environment ( <str> , <str> ) ; builder . environment ( <str> , <str> ) ; builder . environment ( <str> , <str> ) ; GradleInvocation invocation = buildInvocation ( ) ; builder . environment ( invocation . environmentVars ) ; builder . workingDir ( getWorkingDir ( ) ) ; builder . setStandardInput ( connectStdIn ( ) ) ; builder . args ( invocation . args ) ; ExecHandlerConfigurer configurer = OperatingSystem . current ( ) . isWindows ( ) ? new WindowsConfigurer ( ) : new UnixConfigurer ( ) ; configurer . configure ( builder ) ; getLogger ( ) . info ( String . format ( <str> , builder . getWorkingDir ( ) , builder . getExecutable ( ) , builder . getArgs ( ) ) ) ; return builder ; } @Override public GradleHandle doStart ( ) { return createGradleHandle ( getResultAssertion ( ) , getDefaultCharacterEncoding ( ) , new Factory < ExecHandleBuilder > ( ) { public ExecHandleBuilder create ( ) { return createExecHandleBuilder ( ) ; } } ) . start ( ) ; } protected ForkingGradleHandle createGradleHandle ( Action < ExecutionResult > resultAssertion , String encoding , Factory < ExecHandleBuilder > execHandleFactory ) { return new ForkingGradleHandle ( getStdinPipe ( ) , isUseDaemon ( ) , resultAssertion , encoding , execHandleFactory ) ; } protected ExecutionResult doRun ( ) { return start ( ) . waitForFinish ( ) ; } protected ExecutionFailure doRunWithFailure ( ) { return start ( ) . waitForFailure ( ) ; } private interface ExecHandlerConfigurer { void configure ( ExecHandleBuilder builder ) ; } private class WindowsConfigurer implements ExecHandlerConfigurer { public void configure ( ExecHandleBuilder builder ) { String cmd ; if ( getExecutable ( ) ! = null ) { cmd = getExecutable ( ) . replace ( <str> , File . separatorChar ) ; } else { cmd = <str> ; } builder . executable ( <str> ) ; List < String > allArgs = builder . getArgs ( ) ; builder . setArgs ( Arrays . asList ( <str> , cmd ) ) ; builder . args ( allArgs ) ; String gradleHome = getDistribution ( ) . getGradleHomeDir ( ) . getAbsolutePath ( ) ; Object path = builder . getEnvironment ( ) . get ( <str> ) ; if ( path = = null ) { path = builder . getEnvironment ( ) . get ( <str> ) ; } path = String . format ( <str> , gradleHome , path ) ; builder . environment ( <str> , path ) ; builder . environment ( <str> , path ) ; builder . environment ( <str> , <str> ) ; } } private class UnixConfigurer implements ExecHandlerConfigurer { public void configure ( ExecHandleBuilder builder ) { if ( getExecutable ( ) ! = null ) { File exe = new File ( getExecutable ( ) ) ; if ( exe . isAbsolute ( ) ) { builder . executable ( exe . getAbsolutePath ( ) ) ; } else { builder . executable ( String . format ( <str> , getWorkingDir ( ) . getAbsolutePath ( ) , getExecutable ( ) ) ) ; } } else { builder . executable ( String . format ( <str> , getDistribution ( ) . getGradleHomeDir ( ) . getAbsolutePath ( ) ) ) ; } } } } 
