package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . charset . StandardCharsets ; import java . util . Arrays ; import java . util . zip . CRC32 ; import org . junit . Test ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . io . util . SequentialWriter ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertTrue ; import static org . junit . Assert . assertFalse ; public class ChecksummedDataInputTest { @Test public void testReadMethods ( ) throws IOException { byte [ ] b = new byte [ RandomAccessReader . DEFAULT_BUFFER_SIZE * <int> ] ; for ( int i = <int> ; i < b . length ; i + + ) b [ i ] = ( byte ) i ; ByteBuffer buffer ; try ( DataOutputBuffer out = new DataOutputBuffer ( ) ) { out . write ( <int> ) ; out . write ( b ) ; out . writeBoolean ( false ) ; out . writeByte ( <int> ) ; out . writeChar ( <str> ) ; out . writeDouble ( <float> ) ; out . writeFloat ( <float> ) ; out . writeInt ( <int> ) ; out . writeLong ( Long . MAX_VALUE ) ; out . writeShort ( Short . MIN_VALUE ) ; out . writeUTF ( <str> ) ; out . writeVInt ( <int> ) ; out . writeUnsignedVInt ( <int> ) ; out . writeBytes ( <str> ) ; buffer = out . buffer ( ) ; } CRC32 crc = new CRC32 ( ) ; FBUtilities . updateChecksum ( crc , buffer ) ; File file = File . createTempFile ( <str> , <str> ) ; file . deleteOnExit ( ) ; try ( SequentialWriter writer = SequentialWriter . open ( file ) ) { writer . write ( buffer ) ; writer . writeInt ( ( int ) crc . getValue ( ) ) ; writer . finish ( ) ; } assertTrue ( file . exists ( ) ) ; assertEquals ( buffer . remaining ( ) + <int> , file . length ( ) ) ; try ( ChecksummedDataInput reader = ChecksummedDataInput . open ( file ) ) { reader . limit ( buffer . remaining ( ) + <int> ) ; assertEquals ( <int> , reader . read ( ) ) ; byte [ ] bytes = new byte [ b . length ] ; reader . readFully ( bytes ) ; assertTrue ( Arrays . equals ( bytes , b ) ) ; assertEquals ( false , reader . readBoolean ( ) ) ; assertEquals ( <int> , reader . readByte ( ) ) ; assertEquals ( <str> , reader . readChar ( ) ) ; assertEquals ( <float> , reader . readDouble ( ) ) ; assertEquals ( <float> , reader . readFloat ( ) ) ; assertEquals ( <int> , reader . readInt ( ) ) ; assertEquals ( Long . MAX_VALUE , reader . readLong ( ) ) ; assertEquals ( Short . MIN_VALUE , reader . readShort ( ) ) ; assertEquals ( <str> , reader . readUTF ( ) ) ; assertEquals ( <int> , reader . readVInt ( ) ) ; assertEquals ( <int> , reader . readUnsignedVInt ( ) ) ; assertEquals ( <str> , new String ( ByteBufferUtil . read ( reader , <int> ) . array ( ) , StandardCharsets . UTF_8 ) ) ; assertTrue ( reader . checkCrc ( ) ) ; assertEquals ( <int> , reader . bytesRemaining ( ) ) ; reader . checkLimit ( <int> ) ; } } @Test public void testResetCrc ( ) throws IOException { CRC32 crc = new CRC32 ( ) ; ByteBuffer buffer ; try ( DataOutputBuffer out = new DataOutputBuffer ( ) ) { out . write ( <int> ) ; out . writeBoolean ( false ) ; out . writeByte ( <int> ) ; out . writeChar ( <str> ) ; buffer = out . buffer ( ) ; FBUtilities . updateChecksum ( crc , buffer ) ; out . writeInt ( ( int ) crc . getValue ( ) ) ; int bufferPos = out . getLength ( ) ; out . writeDouble ( <float> ) ; out . writeFloat ( <float> ) ; out . writeInt ( <int> ) ; buffer = out . buffer ( ) ; buffer . position ( bufferPos ) ; crc . reset ( ) ; FBUtilities . updateChecksum ( crc , buffer ) ; out . writeInt ( ( int ) crc . getValue ( ) ) ; buffer = out . buffer ( ) ; } File file = File . createTempFile ( <str> , <str> ) ; file . deleteOnExit ( ) ; try ( SequentialWriter writer = SequentialWriter . open ( file ) ) { writer . write ( buffer ) ; writer . finish ( ) ; } assertTrue ( file . exists ( ) ) ; assertEquals ( buffer . remaining ( ) , file . length ( ) ) ; try ( ChecksummedDataInput reader = ChecksummedDataInput . open ( file ) ) { reader . limit ( buffer . remaining ( ) ) ; assertEquals ( <int> , reader . read ( ) ) ; assertEquals ( false , reader . readBoolean ( ) ) ; assertEquals ( <int> , reader . readByte ( ) ) ; assertEquals ( <str> , reader . readChar ( ) ) ; assertTrue ( reader . checkCrc ( ) ) ; reader . resetCrc ( ) ; assertEquals ( <float> , reader . readDouble ( ) ) ; assertEquals ( <float> , reader . readFloat ( ) ) ; assertEquals ( <int> , reader . readInt ( ) ) ; assertTrue ( reader . checkCrc ( ) ) ; assertEquals ( <int> , reader . bytesRemaining ( ) ) ; } } @Test public void testFailedCrc ( ) throws IOException { CRC32 crc = new CRC32 ( ) ; ByteBuffer buffer ; try ( DataOutputBuffer out = new DataOutputBuffer ( ) ) { out . write ( <int> ) ; out . writeBoolean ( false ) ; out . writeByte ( <int> ) ; out . writeChar ( <str> ) ; buffer = out . buffer ( ) ; FBUtilities . updateChecksum ( crc , buffer ) ; FBUtilities . updateChecksum ( crc , buffer ) ; out . writeInt ( ( int ) crc . getValue ( ) ) ; buffer = out . buffer ( ) ; } File file = File . createTempFile ( <str> , <str> ) ; file . deleteOnExit ( ) ; try ( SequentialWriter writer = SequentialWriter . open ( file ) ) { writer . write ( buffer ) ; writer . finish ( ) ; } assertTrue ( file . exists ( ) ) ; assertEquals ( buffer . remaining ( ) , file . length ( ) ) ; try ( ChecksummedDataInput reader = ChecksummedDataInput . open ( file ) ) { reader . limit ( buffer . remaining ( ) ) ; assertEquals ( <int> , reader . read ( ) ) ; assertEquals ( false , reader . readBoolean ( ) ) ; assertEquals ( <int> , reader . readByte ( ) ) ; assertEquals ( <str> , reader . readChar ( ) ) ; assertFalse ( reader . checkCrc ( ) ) ; assertEquals ( <int> , reader . bytesRemaining ( ) ) ; } } } 
