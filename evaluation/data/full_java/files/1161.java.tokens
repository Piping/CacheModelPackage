package org . apache . cassandra . transport ; import java . io . IOException ; import java . util . EnumSet ; import java . util . List ; import io . netty . buffer . ByteBuf ; import io . netty . channel . * ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . MessageToMessageDecoder ; import io . netty . handler . codec . MessageToMessageEncoder ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . transport . messages . ErrorMessage ; public class Frame { public static final byte PROTOCOL_VERSION_MASK = <hex> ; public final Header header ; public final ByteBuf body ; private Frame ( Header header , ByteBuf body ) { this . header = header ; this . body = body ; } public void retain ( ) { body . retain ( ) ; } public boolean release ( ) { return body . release ( ) ; } public static Frame create ( Message . Type type , int streamId , int version , EnumSet < Header . Flag > flags , ByteBuf body ) { Header header = new Header ( version , flags , streamId , type ) ; return new Frame ( header , body ) ; } public static class Header { public static final int LENGTH = <int> ; public static final int BODY_LENGTH_SIZE = <int> ; public final int version ; public final EnumSet < Flag > flags ; public final int streamId ; public final Message . Type type ; private Header ( int version , int flags , int streamId , Message . Type type ) { this ( version , Flag . deserialize ( flags ) , streamId , type ) ; } private Header ( int version , EnumSet < Flag > flags , int streamId , Message . Type type ) { this . version = version ; this . flags = flags ; this . streamId = streamId ; this . type = type ; } public static enum Flag { COMPRESSED , TRACING , CUSTOM_PAYLOAD , WARNING ; private static final Flag [ ] ALL_VALUES = values ( ) ; public static EnumSet < Flag > deserialize ( int flags ) { EnumSet < Flag > set = EnumSet . noneOf ( Flag . class ) ; for ( int n = <int> ; n < ALL_VALUES . length ; n + + ) { if ( ( flags & ( <int> < < n ) ) ! = <int> ) set . add ( ALL_VALUES [ n ] ) ; } return set ; } public static int serialize ( EnumSet < Flag > flags ) { int i = <int> ; for ( Flag flag : flags ) i | = <int> < < flag . ordinal ( ) ; return i ; } } } public Frame with ( ByteBuf newBody ) { return new Frame ( header , newBody ) ; } public static class Decoder extends ByteToMessageDecoder { private static final int MAX_FRAME_LENGTH = DatabaseDescriptor . getNativeTransportMaxFrameSize ( ) ; private boolean discardingTooLongFrame ; private long tooLongFrameLength ; private long bytesToDiscard ; private int tooLongStreamId ; private final Connection . Factory factory ; public Decoder ( Connection . Factory factory ) { this . factory = factory ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buffer , List < Object > results ) throws Exception { if ( discardingTooLongFrame ) { bytesToDiscard = discard ( buffer , bytesToDiscard ) ; if ( bytesToDiscard < = <int> ) fail ( ) ; return ; } if ( buffer . readableBytes ( ) < Header . LENGTH ) return ; int idx = buffer . readerIndex ( ) ; int firstByte = buffer . getByte ( idx + + ) ; Message . Direction direction = Message . Direction . extractFromVersion ( firstByte ) ; int version = firstByte & PROTOCOL_VERSION_MASK ; if ( version < Server . MIN_SUPPORTED_VERSION | | version > Server . CURRENT_VERSION ) throw new ProtocolException ( String . format ( <str> , version , Server . MIN_SUPPORTED_VERSION , Server . CURRENT_VERSION ) ) ; int flags = buffer . getByte ( idx + + ) ; int streamId = buffer . getShort ( idx ) ; idx + = <int> ; Message . Type type ; try { type = Message . Type . fromOpcode ( buffer . getByte ( idx + + ) , direction ) ; } catch ( ProtocolException e ) { throw ErrorMessage . wrap ( e , streamId ) ; } long bodyLength = buffer . getUnsignedInt ( idx ) ; idx + = Header . BODY_LENGTH_SIZE ; long frameLength = bodyLength + Header . LENGTH ; if ( frameLength > MAX_FRAME_LENGTH ) { discardingTooLongFrame = true ; tooLongStreamId = streamId ; tooLongFrameLength = frameLength ; bytesToDiscard = discard ( buffer , frameLength ) ; if ( bytesToDiscard < = <int> ) fail ( ) ; return ; } if ( buffer . readableBytes ( ) < frameLength ) return ; ByteBuf body = buffer . slice ( idx , ( int ) bodyLength ) ; body . retain ( ) ; idx + = bodyLength ; buffer . readerIndex ( idx ) ; Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; if ( connection = = null ) { connection = factory . newConnection ( ctx . channel ( ) , version ) ; ctx . channel ( ) . attr ( Connection . attributeKey ) . set ( connection ) ; } else if ( connection . getVersion ( ) ! = version ) { throw ErrorMessage . wrap ( new ProtocolException ( String . format ( <str> , version , connection . getVersion ( ) ) ) , streamId ) ; } results . add ( new Frame ( new Header ( version , flags , streamId , type ) , body ) ) ; } private void fail ( ) { long tooLongFrameLength = this . tooLongFrameLength ; this . tooLongFrameLength = <int> ; discardingTooLongFrame = false ; String msg = String . format ( <str> , tooLongFrameLength , MAX_FRAME_LENGTH ) ; throw ErrorMessage . wrap ( new InvalidRequestException ( msg ) , tooLongStreamId ) ; } } private static long discard ( ByteBuf buffer , long remainingToDiscard ) { int availableToDiscard = ( int ) Math . min ( remainingToDiscard , buffer . readableBytes ( ) ) ; buffer . skipBytes ( availableToDiscard ) ; return remainingToDiscard - availableToDiscard ; } @ChannelHandler.Sharable public static class Encoder extends MessageToMessageEncoder < Frame > { public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) throws IOException { ByteBuf header = CBUtil . allocator . buffer ( Header . LENGTH ) ; Message . Type type = frame . header . type ; header . writeByte ( type . direction . addToVersion ( frame . header . version ) ) ; header . writeByte ( Header . Flag . serialize ( frame . header . flags ) ) ; if ( frame . header . version > = Server . VERSION_3 ) header . writeShort ( frame . header . streamId ) ; else header . writeByte ( frame . header . streamId ) ; header . writeByte ( type . opcode ) ; header . writeInt ( frame . body . readableBytes ( ) ) ; results . add ( header ) ; results . add ( frame . body ) ; } } @ChannelHandler.Sharable public static class Decompressor extends MessageToMessageDecoder < Frame > { public void decode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) throws IOException { Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; if ( ! frame . header . flags . contains ( Header . Flag . COMPRESSED ) | | connection = = null ) { results . add ( frame ) ; return ; } FrameCompressor compressor = connection . getCompressor ( ) ; if ( compressor = = null ) { results . add ( frame ) ; return ; } results . add ( compressor . decompress ( frame ) ) ; } } @ChannelHandler.Sharable public static class Compressor extends MessageToMessageEncoder < Frame > { public void encode ( ChannelHandlerContext ctx , Frame frame , List < Object > results ) throws IOException { Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; if ( frame . header . type = = Message . Type . STARTUP | | connection = = null ) { results . add ( frame ) ; return ; } FrameCompressor compressor = connection . getCompressor ( ) ; if ( compressor = = null ) { results . add ( frame ) ; return ; } frame . header . flags . add ( Header . Flag . COMPRESSED ) ; results . add ( compressor . compress ( frame ) ) ; } } } 
