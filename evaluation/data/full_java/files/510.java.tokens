package org . apache . cassandra . db . rows ; import java . util . * ; import com . google . common . collect . Iterators ; import com . google . common . collect . PeekingIterator ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . PartitionStatisticsCollector ; import org . apache . cassandra . utils . MergeIterator ; public abstract class Rows { private Rows ( ) { } public static final Row EMPTY_STATIC_ROW = BTreeRow . emptyRow ( Clustering . STATIC_CLUSTERING ) ; public static Row . Builder copy ( Row row , Row . Builder builder ) { builder . newRow ( row . clustering ( ) ) ; builder . addPrimaryKeyLivenessInfo ( row . primaryKeyLivenessInfo ( ) ) ; builder . addRowDeletion ( row . deletion ( ) ) ; for ( ColumnData cd : row ) { if ( cd . column ( ) . isSimple ( ) ) { builder . addCell ( ( Cell ) cd ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; builder . addComplexDeletion ( complexData . column ( ) , complexData . complexDeletion ( ) ) ; for ( Cell cell : complexData ) builder . addCell ( cell ) ; } } return builder ; } public static int collectStats ( Row row , PartitionStatisticsCollector collector ) { assert ! row . isEmpty ( ) ; collector . update ( row . primaryKeyLivenessInfo ( ) ) ; collector . update ( row . deletion ( ) . time ( ) ) ; int columnCount = <int> ; int cellCount = <int> ; for ( ColumnData cd : row ) { if ( cd . column ( ) . isSimple ( ) ) { + + columnCount ; + + cellCount ; Cells . collectStats ( ( Cell ) cd , collector ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; collector . update ( complexData . complexDeletion ( ) ) ; if ( complexData . hasCells ( ) ) { + + columnCount ; for ( Cell cell : complexData ) { + + cellCount ; Cells . collectStats ( cell , collector ) ; } } } } collector . updateColumnSetPerRow ( columnCount ) ; return cellCount ; } public static void diff ( RowDiffListener diffListener , Row merged , Row . . . inputs ) { Clustering clustering = merged . clustering ( ) ; LivenessInfo mergedInfo = merged . primaryKeyLivenessInfo ( ) . isEmpty ( ) ? null : merged . primaryKeyLivenessInfo ( ) ; Row . Deletion mergedDeletion = merged . deletion ( ) . isLive ( ) ? null : merged . deletion ( ) ; for ( int i = <int> ; i < inputs . length ; i + + ) { Row input = inputs [ i ] ; LivenessInfo inputInfo = input = = null | | input . primaryKeyLivenessInfo ( ) . isEmpty ( ) ? null : input . primaryKeyLivenessInfo ( ) ; Row . Deletion inputDeletion = input = = null | | input . deletion ( ) . isLive ( ) ? null : input . deletion ( ) ; if ( mergedInfo ! = null | | inputInfo ! = null ) diffListener . onPrimaryKeyLivenessInfo ( i , clustering , mergedInfo , inputInfo ) ; if ( mergedDeletion ! = null | | inputDeletion ! = null ) diffListener . onDeletion ( i , clustering , mergedDeletion , inputDeletion ) ; } List < Iterator < ColumnData > > inputIterators = new ArrayList < > ( <int> + inputs . length ) ; inputIterators . add ( merged . iterator ( ) ) ; for ( Row row : inputs ) inputIterators . add ( row = = null ? Collections . emptyIterator ( ) : row . iterator ( ) ) ; Iterator < ? > iter = MergeIterator . get ( inputIterators , ColumnData . comparator , new MergeIterator . Reducer < ColumnData , Object > ( ) { ColumnData mergedData ; ColumnData [ ] inputDatas = new ColumnData [ inputs . length ] ; public void reduce ( int idx , ColumnData current ) { if ( idx = = <int> ) mergedData = current ; else inputDatas [ idx - <int> ] = current ; } protected Object getReduced ( ) { for ( int i = <int> ; i ! = inputDatas . length ; i + + ) { ColumnData input = inputDatas [ i ] ; if ( mergedData ! = null | | input ! = null ) { ColumnDefinition column = ( mergedData ! = null ? mergedData : input ) . column ; if ( column . isSimple ( ) ) { diffListener . onCell ( i , clustering , ( Cell ) mergedData , ( Cell ) input ) ; } else { ComplexColumnData mergedData = ( ComplexColumnData ) this . mergedData ; ComplexColumnData inputData = ( ComplexColumnData ) input ; if ( mergedData = = null ) { if ( ! inputData . complexDeletion ( ) . isLive ( ) ) diffListener . onComplexDeletion ( i , clustering , column , null , inputData . complexDeletion ( ) ) ; for ( Cell inputCell : inputData ) diffListener . onCell ( i , clustering , null , inputCell ) ; } else if ( inputData = = null ) { if ( ! mergedData . complexDeletion ( ) . isLive ( ) ) diffListener . onComplexDeletion ( i , clustering , column , mergedData . complexDeletion ( ) , null ) ; for ( Cell mergedCell : mergedData ) diffListener . onCell ( i , clustering , mergedCell , null ) ; } else { if ( ! mergedData . complexDeletion ( ) . isLive ( ) | | ! inputData . complexDeletion ( ) . isLive ( ) ) diffListener . onComplexDeletion ( i , clustering , column , mergedData . complexDeletion ( ) , inputData . complexDeletion ( ) ) ; PeekingIterator < Cell > mergedCells = Iterators . peekingIterator ( mergedData . iterator ( ) ) ; PeekingIterator < Cell > inputCells = Iterators . peekingIterator ( inputData . iterator ( ) ) ; while ( mergedCells . hasNext ( ) & & inputCells . hasNext ( ) ) { int cmp = column . cellPathComparator ( ) . compare ( mergedCells . peek ( ) . path ( ) , inputCells . peek ( ) . path ( ) ) ; if ( cmp = = <int> ) diffListener . onCell ( i , clustering , mergedCells . next ( ) , inputCells . next ( ) ) ; else if ( cmp < <int> ) diffListener . onCell ( i , clustering , mergedCells . next ( ) , null ) ; else diffListener . onCell ( i , clustering , null , inputCells . next ( ) ) ; } while ( mergedCells . hasNext ( ) ) diffListener . onCell ( i , clustering , mergedCells . next ( ) , null ) ; while ( inputCells . hasNext ( ) ) diffListener . onCell ( i , clustering , null , inputCells . next ( ) ) ; } } } } return null ; } protected void onKeyChange ( ) { mergedData = null ; Arrays . fill ( inputDatas , null ) ; } } ) ; while ( iter . hasNext ( ) ) iter . next ( ) ; } public static Row merge ( Row row1 , Row row2 , int nowInSec ) { Row . Builder builder = BTreeRow . sortedBuilder ( ) ; merge ( row1 , row2 , builder , nowInSec ) ; return builder . build ( ) ; } public static long merge ( Row existing , Row update , Row . Builder builder , int nowInSec ) { Clustering clustering = existing . clustering ( ) ; builder . newRow ( clustering ) ; LivenessInfo existingInfo = existing . primaryKeyLivenessInfo ( ) ; LivenessInfo updateInfo = update . primaryKeyLivenessInfo ( ) ; LivenessInfo mergedInfo = existingInfo . supersedes ( updateInfo ) ? existingInfo : updateInfo ; long timeDelta = Math . abs ( existingInfo . timestamp ( ) - mergedInfo . timestamp ( ) ) ; Row . Deletion rowDeletion = existing . deletion ( ) . supersedes ( update . deletion ( ) ) ? existing . deletion ( ) : update . deletion ( ) ; if ( rowDeletion . deletes ( mergedInfo ) ) mergedInfo = LivenessInfo . EMPTY ; else if ( rowDeletion . isShadowedBy ( mergedInfo ) ) rowDeletion = Row . Deletion . LIVE ; builder . addPrimaryKeyLivenessInfo ( mergedInfo ) ; builder . addRowDeletion ( rowDeletion ) ; DeletionTime deletion = rowDeletion . time ( ) ; Iterator < ColumnData > a = existing . iterator ( ) ; Iterator < ColumnData > b = update . iterator ( ) ; ColumnData nexta = a . hasNext ( ) ? a . next ( ) : null , nextb = b . hasNext ( ) ? b . next ( ) : null ; while ( nexta ! = null | nextb ! = null ) { int comparison = nexta = = null ? <int> : nextb = = null ? - <int> : nexta . column . compareTo ( nextb . column ) ; ColumnData cura = comparison < = <int> ? nexta : null ; ColumnData curb = comparison > = <int> ? nextb : null ; ColumnDefinition column = ( cura ! = null ? cura : curb ) . column ; if ( column . isSimple ( ) ) { timeDelta = Math . min ( timeDelta , Cells . reconcile ( ( Cell ) cura , ( Cell ) curb , deletion , builder , nowInSec ) ) ; } else { ComplexColumnData existingData = ( ComplexColumnData ) cura ; ComplexColumnData updateData = ( ComplexColumnData ) curb ; DeletionTime existingDt = existingData = = null ? DeletionTime . LIVE : existingData . complexDeletion ( ) ; DeletionTime updateDt = updateData = = null ? DeletionTime . LIVE : updateData . complexDeletion ( ) ; DeletionTime maxDt = existingDt . supersedes ( updateDt ) ? existingDt : updateDt ; if ( maxDt . supersedes ( deletion ) ) builder . addComplexDeletion ( column , maxDt ) ; else maxDt = deletion ; Iterator < Cell > existingCells = existingData = = null ? null : existingData . iterator ( ) ; Iterator < Cell > updateCells = updateData = = null ? null : updateData . iterator ( ) ; timeDelta = Math . min ( timeDelta , Cells . reconcileComplex ( column , existingCells , updateCells , maxDt , builder , nowInSec ) ) ; } if ( cura ! = null ) nexta = a . hasNext ( ) ? a . next ( ) : null ; if ( curb ! = null ) nextb = b . hasNext ( ) ? b . next ( ) : null ; } return timeDelta ; } } 
