package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; public class RenderingsUtil { public static final int LITTLE_ENDIAN = <int> ; public static final int BIG_ENDIAN = <int> ; public static final int ENDIANESS_UNKNOWN = <int> ; protected static byte [ ] fillArray ( byte [ ] array , int size , int endianess ) { if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { byte [ ] temp = new byte [ size ] ; for ( int i = <int> ; i < array . length ; i + + ) { temp [ i ] = array [ i ] ; } for ( int i = array . length ; i < size ; i + + ) { temp [ i ] = <int> ; } array = temp ; return array ; } byte [ ] temp = new byte [ size ] ; for ( int i = <int> ; i < size - array . length ; i + + ) { temp [ i ] = <int> ; } int j = <int> ; for ( int i = size - array . length ; i < size ; i + + ) { temp [ i ] = array [ j ] ; j + + ; } array = temp ; return array ; } static public BigInteger convertByteArrayToUnsignedLong ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } BigInteger value = new BigInteger ( <str> ) ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( i * <int> ) ; value = value . or ( b ) ; } } else { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( ( <int> - i ) * <int> ) ; value = value . or ( b ) ; } } return value ; } static public long convertByteArrayToLong ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { long value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { long b = array [ i ] ; b & = <hex> ; value | = ( b < < ( i * <int> ) ) ; } return value ; } long value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { long b = array [ i ] ; b & = <hex> ; value | = ( b < < ( ( <int> - i ) * <int> ) ) ; } return value ; } static public BigInteger convertByteArrayToSignedBigInt ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { byte [ ] holder = new byte [ <int> ] ; int j = <int> ; for ( int i = <int> ; i < <int> ; i + + , j - - ) { holder [ i ] = array [ j ] ; } BigInteger value = new BigInteger ( holder ) ; return value ; } BigInteger value = new BigInteger ( array ) ; return value ; } static public BigInteger convertByteArrayToSignedBigInt ( byte [ ] array , int endianess , int arraySize ) { if ( array . length < arraySize ) { array = fillArray ( array , arraySize , endianess ) ; } if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { byte [ ] holder = new byte [ arraySize ] ; int j = arraySize - <int> ; for ( int i = <int> ; i < arraySize ; i + + , j - - ) { holder [ i ] = array [ j ] ; } BigInteger value = new BigInteger ( holder ) ; return value ; } BigInteger value = new BigInteger ( array ) ; return value ; } static public BigInteger convertByteArrayToUnsignedBigInt ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } BigInteger value = new BigInteger ( <str> ) ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( i * <int> ) ; value = value . or ( b ) ; } } else { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( ( <int> - i ) * <int> ) ; value = value . or ( b ) ; } } return value ; } static public BigInteger convertByteArrayToUnsignedBigInt ( byte [ ] array , int endianess , int arraySize ) { if ( array . length < arraySize ) { array = fillArray ( array , arraySize , endianess ) ; } BigInteger value = new BigInteger ( <str> ) ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int i = <int> ; i < arraySize ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( i * <int> ) ; value = value . or ( b ) ; } } else { for ( int i = <int> ; i < arraySize ; i + + ) { byte [ ] temp = new byte [ <int> ] ; temp [ <int> ] = array [ i ] ; BigInteger b = new BigInteger ( temp ) ; b = b . and ( new BigInteger ( <str> , <int> ) ) ; b = b . shiftLeft ( ( arraySize - <int> - i ) * <int> ) ; value = value . or ( b ) ; } } return value ; } static public int convertByteArrayToInt ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { int value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { int b = array [ i ] ; b & = <hex> ; value | = ( b < < ( i * <int> ) ) ; } return value ; } int value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { int b = array [ i ] ; b & = <hex> ; value | = ( b < < ( ( <int> - i ) * <int> ) ) ; } return value ; } static public short convertByteArrayToShort ( byte [ ] array , int endianess ) { if ( array . length < <int> ) { array = fillArray ( array , <int> , endianess ) ; } if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { short value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { short b = array [ i ] ; b & = <hex> ; value | = ( b < < ( i * <int> ) ) ; } return value ; } short value = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { short b = array [ i ] ; b & = <hex> ; value | = ( b < < ( ( <int> - i ) * <int> ) ) ; } return value ; } static public byte [ ] convertBigIntegerToByteArray ( BigInteger i , int endianess ) { byte buf [ ] = new byte [ <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < <int> ; j + + ) { BigInteger x = i . shiftRight ( j * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } for ( int j = <int> ; j > = <int> ; j - - ) { BigInteger x = i . shiftRight ( ( <int> - j ) * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } static public byte [ ] convertSignedBigIntToByteArray ( BigInteger i , int endianess , int arraySize ) { byte buf [ ] = new byte [ arraySize ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < arraySize ; j + + ) { BigInteger x = i . shiftRight ( j * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } for ( int j = arraySize - <int> ; j > = <int> ; j - - ) { BigInteger x = i . shiftRight ( ( arraySize - <int> - j ) * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } static public byte [ ] convertUnsignedBigIntegerToByteArray ( BigInteger i , int endianess ) { byte buf [ ] = new byte [ <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < <int> ; j + + ) { BigInteger x = i . shiftRight ( j * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } for ( int j = <int> ; j > = <int> ; j - - ) { BigInteger x = i . shiftRight ( ( <int> - j ) * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } static public byte [ ] convertUnsignedBigIntToByteArray ( BigInteger i , int endianess , int arraySize ) { byte buf [ ] = new byte [ arraySize * <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < arraySize * <int> ; j + + ) { BigInteger x = i . shiftRight ( j * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } for ( int j = ( arraySize * <int> ) - <int> ; j > = <int> ; j - - ) { BigInteger x = i . shiftRight ( ( ( arraySize * <int> ) - <int> - j ) * <int> ) ; buf [ j ] = x . byteValue ( ) ; } return buf ; } static public byte [ ] convertLongToByteArray ( long i , int endianess ) { byte buf [ ] = new byte [ <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < <int> ; j + + ) { buf [ j ] = new Long ( i > > j * <int> ) . byteValue ( ) ; } return buf ; } for ( int j = <int> ; j > = <int> ; j - - ) { buf [ j ] = new Long ( i > > ( <int> - j ) * <int> ) . byteValue ( ) ; } return buf ; } static public byte [ ] convertIntToByteArray ( int i , int endianess ) { byte buf [ ] = new byte [ <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( int j = <int> ; j < <int> ; j + + ) { buf [ j ] = Integer . valueOf ( i > > j * <int> ) . byteValue ( ) ; } return buf ; } for ( int j = <int> ; j > = <int> ; j - - ) { buf [ j ] = Integer . valueOf ( i > > ( <int> - j ) * <int> ) . byteValue ( ) ; } return buf ; } static public byte [ ] convertShortToByteArray ( short i , int endianess ) { byte buf [ ] = new byte [ <int> ] ; if ( endianess = = RenderingsUtil . LITTLE_ENDIAN ) { for ( short j = <int> ; j < <int> ; j + + ) { buf [ j ] = Integer . valueOf ( i > > j * <int> ) . byteValue ( ) ; } return buf ; } for ( short j = <int> ; j > = <int> ; j - - ) { buf [ j ] = Integer . valueOf ( i > > ( <int> - j ) * <int> ) . byteValue ( ) ; } return buf ; } static public String convertByteArrayToHexString ( byte [ ] byteArray ) { StringBuffer strBuffer = new StringBuffer ( ) ; char charArray [ ] ; for ( int i = <int> ; i < byteArray . length ; i + + ) { charArray = RenderingsUtil . convertByteToCharArray ( byteArray [ i ] ) ; strBuffer . append ( charArray ) ; } return strBuffer . toString ( ) ; } static public char [ ] convertByteToCharArray ( byte aByte ) { char charArray [ ] = new char [ <int> ] ; int val = aByte ; if ( val < <int> ) val + = <int> ; charArray [ <int> ] = Character . forDigit ( val / <int> , <int> ) ; charArray [ <int> ] = Character . forDigit ( val % <int> , <int> ) ; return charArray ; } public static byte [ ] convertHexStringToByteArray ( String str , int numBytes , int numCharsPerByte ) throws NumberFormatException { if ( str . length ( ) = = <int> ) return null ; StringBuffer buf = new StringBuffer ( str ) ; int requiredPadding = numBytes * numCharsPerByte - str . length ( ) ; while ( requiredPadding > <int> ) { buf . insert ( <int> , <str> ) ; requiredPadding - - ; } byte [ ] bytes = new byte [ numBytes ] ; str = buf . toString ( ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { String oneByte = str . substring ( i * <int> , i * <int> + <int> ) ; Integer number = Integer . valueOf ( oneByte , <int> ) ; if ( number . compareTo ( Integer . valueOf ( Byte . toString ( Byte . MAX_VALUE ) ) ) > <int> ) { int temp = number . intValue ( ) ; temp = temp - <int> ; String tempStr = Integer . toString ( temp ) ; Byte myByte = Byte . valueOf ( tempStr ) ; bytes [ i ] = myByte . byteValue ( ) ; } else { Byte myByte = Byte . valueOf ( oneByte , <int> ) ; bytes [ i ] = myByte . byteValue ( ) ; } } return bytes ; } } 
