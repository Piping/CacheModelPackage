package org . elasticsearch . messy . tests ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . Accountable ; import org . elasticsearch . Version ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . inject . multibindings . Multibinder ; import org . elasticsearch . common . inject . util . Providers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . settings . SettingsModule ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . EnvironmentModule ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . AnalysisRegistry ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . cache . bitset . BitsetFilterCache ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . query . TemplateQueryParser ; import org . elasticsearch . index . query . functionscore . ScoreFunctionParser ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . indices . IndicesModule ; import org . elasticsearch . indices . IndicesWarmer ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . indices . fielddata . cache . IndicesFieldDataCache ; import org . elasticsearch . indices . mapper . MapperRegistry ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . script . ScriptModule ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . script . mustache . MustacheScriptEngineService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolModule ; import org . junit . After ; import org . junit . Before ; import java . io . IOException ; import java . lang . reflect . Proxy ; import java . util . Collections ; import static org . hamcrest . Matchers . containsString ; public class TemplateQueryParserTests extends ESTestCase { private Injector injector ; private QueryShardContext context ; @Before public void setup ( ) throws IOException { Settings settings = Settings . settingsBuilder ( ) . put ( <str> , createTempDir ( ) . toString ( ) ) . put ( <str> , this . getDataPath ( <str> ) ) . put ( <str> , getClass ( ) . getName ( ) ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; final Client proxy = ( Client ) Proxy . newProxyInstance ( Client . class . getClassLoader ( ) , new Class < ? > [ ] { Client . class } , ( proxy1 , method , args ) - > { throw new UnsupportedOperationException ( <str> ) ; } ) ; Index index = new Index ( <str> ) ; IndexSettings idxSettings = IndexSettingsModule . newIndexSettings ( index , settings ) ; ScriptModule scriptModule = new ScriptModule ( settings ) ; scriptModule . addScriptEngine ( MustacheScriptEngineService . class ) ; injector = new ModulesBuilder ( ) . add ( new EnvironmentModule ( new Environment ( settings ) ) , new SettingsModule ( settings , new SettingsFilter ( settings ) ) , new ThreadPoolModule ( new ThreadPool ( settings ) ) , new IndicesModule ( ) { @Override public void configure ( ) { bindQueryParsersExtension ( ) ; } } , scriptModule , new IndexSettingsModule ( index , settings ) , new AbstractModule ( ) { @Override protected void configure ( ) { bind ( Client . class ) . toInstance ( proxy ) ; Multibinder . newSetBinder ( binder ( ) , ScoreFunctionParser . class ) ; bind ( ClusterService . class ) . toProvider ( Providers . of ( ( ClusterService ) null ) ) ; bind ( CircuitBreakerService . class ) . to ( NoneCircuitBreakerService . class ) ; } } ) . createInjector ( ) ; AnalysisService analysisService = new AnalysisRegistry ( null , new Environment ( settings ) ) . build ( idxSettings ) ; ScriptService scriptService = injector . getInstance ( ScriptService . class ) ; SimilarityService similarityService = new SimilarityService ( idxSettings , Collections . emptyMap ( ) ) ; MapperRegistry mapperRegistry = new IndicesModule ( ) . getMapperRegistry ( ) ; MapperService mapperService = new MapperService ( idxSettings , analysisService , similarityService , mapperRegistry ) ; IndexFieldDataService indexFieldDataService = new IndexFieldDataService ( idxSettings , injector . getInstance ( IndicesFieldDataCache . class ) , injector . getInstance ( CircuitBreakerService . class ) , mapperService ) ; BitsetFilterCache bitsetFilterCache = new BitsetFilterCache ( idxSettings , new IndicesWarmer ( idxSettings . getNodeSettings ( ) , null ) , new BitsetFilterCache . Listener ( ) { @Override public void onCache ( ShardId shardId , Accountable accountable ) { } @Override public void onRemoval ( ShardId shardId , Accountable accountable ) { } } ) ; IndicesQueriesRegistry indicesQueriesRegistry = injector . getInstance ( IndicesQueriesRegistry . class ) ; context = new QueryShardContext ( idxSettings , proxy , bitsetFilterCache , indexFieldDataService , mapperService , similarityService , scriptService , indicesQueriesRegistry ) ; } @Override @After public void tearDown ( ) throws Exception { super . tearDown ( ) ; terminate ( injector . getInstance ( ThreadPool . class ) ) ; } public void testParser ( ) throws IOException { String templateString = <str> + <str> + <str> + <str> ; XContentParser templateSourceParser = XContentFactory . xContent ( templateString ) . createParser ( templateString ) ; context . reset ( templateSourceParser ) ; templateSourceParser . nextToken ( ) ; TemplateQueryParser parser = injector . getInstance ( TemplateQueryParser . class ) ; Query query = parser . fromXContent ( context . parseContext ( ) ) . toQuery ( context ) ; assertTrue ( <str> , query instanceof MatchAllDocsQuery ) ; } public void testParseTemplateAsSingleStringWithConditionalClause ( ) throws IOException { String templateString = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; XContentParser templateSourceParser = XContentFactory . xContent ( templateString ) . createParser ( templateString ) ; context . reset ( templateSourceParser ) ; TemplateQueryParser parser = injector . getInstance ( TemplateQueryParser . class ) ; Query query = parser . fromXContent ( context . parseContext ( ) ) . toQuery ( context ) ; assertTrue ( <str> , query instanceof MatchAllDocsQuery ) ; } public void testParseTemplateFailsToParseCompleteQueryAsSingleString ( ) throws IOException { String templateString = <str> + <str> + <str> + <str> + <str> + <str> ; XContentParser templateSourceParser = XContentFactory . xContent ( templateString ) . createParser ( templateString ) ; context . reset ( templateSourceParser ) ; TemplateQueryParser parser = injector . getInstance ( TemplateQueryParser . class ) ; try { parser . fromXContent ( context . parseContext ( ) ) . toQuery ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testParserCanExtractTemplateNames ( ) throws Exception { String templateString = <str> ; XContentParser templateSourceParser = XContentFactory . xContent ( templateString ) . createParser ( templateString ) ; context . reset ( templateSourceParser ) ; templateSourceParser . nextToken ( ) ; TemplateQueryParser parser = injector . getInstance ( TemplateQueryParser . class ) ; Query query = parser . fromXContent ( context . parseContext ( ) ) . toQuery ( context ) ; assertTrue ( <str> , query instanceof MatchAllDocsQuery ) ; } } 
