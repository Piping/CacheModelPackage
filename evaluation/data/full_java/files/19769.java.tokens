package io . netty . util . internal ; import org . junit . Test ; import static io . netty . util . internal . StringUtil . * ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class StringUtilTest { @Test public void ensureNewlineExists ( ) { assertNotNull ( NEWLINE ) ; } @Test public void testToHexString ( ) { assertThat ( toHexString ( new byte [ ] { <int> } ) , is ( <str> ) ) ; assertThat ( toHexString ( new byte [ ] { <int> } ) , is ( <str> ) ) ; assertThat ( toHexString ( new byte [ ] { <int> , <int> } ) , is ( <str> ) ) ; assertThat ( toHexString ( new byte [ ] { <int> , <int> } ) , is ( <str> ) ) ; assertThat ( toHexString ( EmptyArrays . EMPTY_BYTES ) , is ( <str> ) ) ; } @Test public void testToHexStringPadded ( ) { assertThat ( toHexStringPadded ( new byte [ ] { <int> } ) , is ( <str> ) ) ; assertThat ( toHexStringPadded ( new byte [ ] { <int> } ) , is ( <str> ) ) ; assertThat ( toHexStringPadded ( new byte [ ] { <int> , <int> } ) , is ( <str> ) ) ; assertThat ( toHexStringPadded ( new byte [ ] { <int> , <int> } ) , is ( <str> ) ) ; assertThat ( toHexStringPadded ( EmptyArrays . EMPTY_BYTES ) , is ( <str> ) ) ; } @Test public void splitSimple ( ) { assertArrayEquals ( new String [ ] { <str> , <str> } , split ( <str> , <str> ) ) ; } @Test public void splitWithTrailingDelimiter ( ) { assertArrayEquals ( new String [ ] { <str> , <str> } , split ( <str> , <str> ) ) ; } @Test public void splitWithTrailingDelimiters ( ) { assertArrayEquals ( new String [ ] { <str> , <str> } , split ( <str> , <str> ) ) ; } @Test public void splitWithConsecutiveDelimiters ( ) { assertArrayEquals ( new String [ ] { <str> , <str> , <str> } , split ( <str> , <str> ) ) ; } @Test public void splitWithDelimiterAtBeginning ( ) { assertArrayEquals ( new String [ ] { <str> , <str> , <str> } , split ( <str> , <str> ) ) ; } @Test public void splitMaxPart ( ) { assertArrayEquals ( new String [ ] { <str> , <str> } , split ( <str> , <str> , <int> ) ) ; assertArrayEquals ( new String [ ] { <str> , <str> , <str> } , split ( <str> , <str> , <int> ) ) ; } @Test public void substringAfterTest ( ) { assertEquals ( <str> , substringAfter ( <str> , <str> ) ) ; } @Test ( expected = NullPointerException . class ) public void escapeCsvNull ( ) { StringUtil . escapeCsv ( null ) ; } @Test public void escapeCsvEmpty ( ) { CharSequence value = <str> ; CharSequence expected = value ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvUnquoted ( ) { CharSequence value = <str> ; CharSequence expected = value ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvAlreadyQuoted ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuote ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuoteInMiddle ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuoteInMiddleAlreadyQuoted ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuotedWords ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithAlreadyEscapedQuote ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvEndingWithQuote ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithSingleQuote ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithSingleQuoteAndCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvAlreadyEscapedQuote ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvQuoted ( ) { CharSequence value = <str> ; CharSequence expected = value ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithLineFeed ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithSingleLineFeedCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithMultipleLineFeedCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuotedAndLineFeedCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithLineFeedAtEnd ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithComma ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithSingleComma ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithSingleCarriageReturn ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithMultipleCarriageReturn ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithCarriageReturn ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithQuotedAndCarriageReturnCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithCarriageReturnAtEnd ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } @Test public void escapeCsvWithCRLFCharacter ( ) { CharSequence value = <str> ; CharSequence expected = <str> ; escapeCsv ( value , expected ) ; } private static void escapeCsv ( CharSequence value , CharSequence expected ) { CharSequence escapedValue = value ; for ( int i = <int> ; i < <int> ; + + i ) { escapedValue = StringUtil . escapeCsv ( escapedValue ) ; assertEquals ( expected , escapedValue . toString ( ) ) ; } } @Test public void testSimpleClassName ( ) throws Exception { testSimpleClassName ( String . class ) ; } @Test public void testSimpleInnerClassName ( ) throws Exception { testSimpleClassName ( TestClass . class ) ; } private static void testSimpleClassName ( Class < ? > clazz ) throws Exception { Package pkg = clazz . getPackage ( ) ; String name ; if ( pkg ! = null ) { name = clazz . getName ( ) . substring ( pkg . getName ( ) . length ( ) + <int> ) ; } else { name = clazz . getName ( ) ; } assertEquals ( name , simpleClassName ( clazz ) ) ; } private static final class TestClass { } } 
