package org . eclipse . debug . internal . ui . views . breakpoints ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . Platform ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; public class BreakpointOrganizerManager { private static BreakpointOrganizerManager fgManager ; private Map < String , IBreakpointOrganizer > fOrganizers = new HashMap < String , IBreakpointOrganizer > ( ) ; private List < IBreakpointOrganizer > fSorted = null ; public static BreakpointOrganizerManager getDefault ( ) { if ( fgManager = = null ) { fgManager = new BreakpointOrganizerManager ( ) ; } return fgManager ; } private BreakpointOrganizerManager ( ) { loadOrganizers ( ) ; start ( <str> ) ; start ( <str> ) ; } private void start ( String organizerId ) { IBreakpointOrganizer organizer = getOrganizer ( organizerId ) ; IPropertyChangeListener listener = new IPropertyChangeListener ( ) { @Override public void propertyChange ( PropertyChangeEvent event ) { } } ; organizer . addPropertyChangeListener ( listener ) ; organizer . removePropertyChangeListener ( listener ) ; } private void loadOrganizers ( ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugUIPlugin . getUniqueIdentifier ( ) , IDebugUIConstants . EXTENSION_POINT_BREAKPOINT_ORGANIZERS ) ; IConfigurationElement [ ] configurationElements = extensionPoint . getConfigurationElements ( ) ; for ( int i = <int> ; i < configurationElements . length ; i + + ) { IConfigurationElement element = configurationElements [ i ] ; IBreakpointOrganizer organizer = new BreakpointOrganizerExtension ( element ) ; if ( validateOrganizer ( organizer ) ) { fOrganizers . put ( organizer . getIdentifier ( ) , organizer ) ; } } } protected static boolean validateOrganizer ( IBreakpointOrganizer organizer ) { String id = organizer . getIdentifier ( ) ; String label = organizer . getLabel ( ) ; return id ! = null & & id . length ( ) > <int> & & label ! = null & & label . length ( ) > <int> ; } public IBreakpointOrganizer [ ] getOrganizers ( ) { if ( fSorted = = null ) { Collection < IBreakpointOrganizer > collection = fOrganizers . values ( ) ; fSorted = new ArrayList < IBreakpointOrganizer > ( ) ; fSorted . addAll ( collection ) ; Collections . sort ( fSorted , new Comparator < Object > ( ) { @Override public int compare ( Object o1 , Object o2 ) { IBreakpointOrganizer b1 = ( IBreakpointOrganizer ) o1 ; IBreakpointOrganizer b2 = ( IBreakpointOrganizer ) o2 ; return b1 . getLabel ( ) . compareTo ( b2 . getLabel ( ) ) ; } } ) ; } return fSorted . toArray ( new IBreakpointOrganizer [ fSorted . size ( ) ] ) ; } public IBreakpointOrganizer getOrganizer ( String id ) { return fOrganizers . get ( id ) ; } public void shutdown ( ) { IBreakpointOrganizer [ ] organizers = getOrganizers ( ) ; for ( int i = <int> ; i < organizers . length ; i + + ) { IBreakpointOrganizer organizer = organizers [ i ] ; organizer . dispose ( ) ; } } } 
