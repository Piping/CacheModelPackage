package org . elasticsearch . search . suggest . completion . context ; import org . apache . lucene . search . suggest . document . CompletionQuery ; import org . apache . lucene . search . suggest . document . ContextQuery ; import org . apache . lucene . search . suggest . document . ContextSuggestField ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . CompletionFieldMapper ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . search . suggest . completion . context . ContextMapping . * ; public class ContextMappings implements ToXContent { private final List < ContextMapping > contextMappings ; private final Map < String , ContextMapping > contextNameMap ; public ContextMappings ( List < ContextMapping > contextMappings ) { if ( contextMappings . size ( ) > <int> ) { throw new UnsupportedOperationException ( <str> + contextMappings . size ( ) ) ; } this . contextMappings = contextMappings ; contextNameMap = new HashMap < > ( contextMappings . size ( ) ) ; for ( ContextMapping mapping : contextMappings ) { contextNameMap . put ( mapping . name ( ) , mapping ) ; } } public int size ( ) { return contextMappings . size ( ) ; } public ContextMapping get ( String name ) { ContextMapping contextMapping = contextNameMap . get ( name ) ; if ( contextMapping = = null ) { throw new IllegalArgumentException ( <str> + name + <str> + contextNameMap . size ( ) ) ; } return contextMapping ; } public void addField ( ParseContext . Document document , String name , String input , int weight , Map < String , Set < CharSequence > > contexts ) { document . add ( new TypedContextField ( name , input , weight , contexts , document ) ) ; } private class TypedContextField extends ContextSuggestField { private final Map < String , Set < CharSequence > > contexts ; private final ParseContext . Document document ; public TypedContextField ( String name , String value , int weight , Map < String , Set < CharSequence > > contexts , ParseContext . Document document ) { super ( name , value , weight ) ; this . contexts = contexts ; this . document = document ; } @Override protected Iterable < CharSequence > contexts ( ) { Set < CharSequence > typedContexts = new HashSet < > ( ) ; final CharsRefBuilder scratch = new CharsRefBuilder ( ) ; scratch . grow ( <int> ) ; for ( int typeId = <int> ; typeId < contextMappings . size ( ) ; typeId + + ) { scratch . setCharAt ( <int> , ( char ) typeId ) ; scratch . setLength ( <int> ) ; ContextMapping mapping = contextMappings . get ( typeId ) ; Set < CharSequence > contexts = new HashSet < > ( mapping . parseContext ( document ) ) ; if ( this . contexts . get ( mapping . name ( ) ) ! = null ) { contexts . addAll ( this . contexts . get ( mapping . name ( ) ) ) ; } for ( CharSequence context : contexts ) { scratch . append ( context ) ; typedContexts . add ( scratch . toCharsRef ( ) ) ; scratch . setLength ( <int> ) ; } } return typedContexts ; } } public ContextQuery toContextQuery ( CompletionQuery query , Map < String , List < QueryContext > > queryContexts ) { ContextQuery typedContextQuery = new ContextQuery ( query ) ; if ( queryContexts . isEmpty ( ) = = false ) { CharsRefBuilder scratch = new CharsRefBuilder ( ) ; scratch . grow ( <int> ) ; for ( int typeId = <int> ; typeId < contextMappings . size ( ) ; typeId + + ) { scratch . setCharAt ( <int> , ( char ) typeId ) ; scratch . setLength ( <int> ) ; ContextMapping mapping = contextMappings . get ( typeId ) ; List < QueryContext > queryContext = queryContexts . get ( mapping . name ( ) ) ; if ( queryContext ! = null ) { for ( QueryContext context : queryContext ) { scratch . append ( context . context ) ; typedContextQuery . addContext ( scratch . toCharsRef ( ) , context . boost , ! context . isPrefix ) ; scratch . setLength ( <int> ) ; } } } } return typedContextQuery ; } public Map < String , Set < CharSequence > > getNamedContexts ( List < CharSequence > contexts ) { Map < String , Set < CharSequence > > contextMap = new HashMap < > ( contexts . size ( ) ) ; for ( CharSequence typedContext : contexts ) { int typeId = typedContext . charAt ( <int> ) ; assert typeId < contextMappings . size ( ) : <str> ; ContextMapping mapping = contextMappings . get ( typeId ) ; Set < CharSequence > contextEntries = contextMap . get ( mapping . name ( ) ) ; if ( contextEntries = = null ) { contextEntries = new HashSet < > ( ) ; contextMap . put ( mapping . name ( ) , contextEntries ) ; } contextEntries . add ( typedContext . subSequence ( <int> , typedContext . length ( ) ) ) ; } return contextMap ; } public static ContextMappings load ( Object configuration , Version indexVersionCreated ) throws ElasticsearchParseException { final List < ContextMapping > contextMappings ; if ( configuration instanceof List ) { contextMappings = new ArrayList < > ( ) ; List < Object > configurations = ( List < Object > ) configuration ; for ( Object contextConfig : configurations ) { contextMappings . add ( load ( ( Map < String , Object > ) contextConfig , indexVersionCreated ) ) ; } if ( contextMappings . size ( ) = = <int> ) { throw new ElasticsearchParseException ( <str> ) ; } } else if ( configuration instanceof Map ) { contextMappings = Collections . singletonList ( load ( ( ( Map < String , Object > ) configuration ) , indexVersionCreated ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } return new ContextMappings ( contextMappings ) ; } private static ContextMapping load ( Map < String , Object > contextConfig , Version indexVersionCreated ) { String name = extractRequiredValue ( contextConfig , FIELD_NAME ) ; String type = extractRequiredValue ( contextConfig , FIELD_TYPE ) ; final ContextMapping contextMapping ; switch ( Type . fromString ( type ) ) { case CATEGORY : contextMapping = CategoryContextMapping . load ( name , contextConfig ) ; break ; case GEO : contextMapping = GeoContextMapping . load ( name , contextConfig ) ; break ; default : throw new ElasticsearchParseException ( <str> + type + <str> ) ; } DocumentMapperParser . checkNoRemainingFields ( name , contextConfig , indexVersionCreated ) ; return contextMapping ; } private static String extractRequiredValue ( Map < String , Object > contextConfig , String paramName ) { final Object paramValue = contextConfig . get ( paramName ) ; if ( paramValue = = null ) { throw new ElasticsearchParseException ( <str> + paramName + <str> ) ; } contextConfig . remove ( paramName ) ; return paramValue . toString ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { for ( ContextMapping contextMapping : contextMappings ) { builder . startObject ( ) ; contextMapping . toXContent ( builder , params ) ; builder . endObject ( ) ; } return builder ; } @Override public int hashCode ( ) { return Objects . hash ( contextMappings ) ; } @Override public boolean equals ( Object obj ) { if ( obj = = null | | ( obj instanceof ContextMappings ) = = false ) { return false ; } ContextMappings other = ( ( ContextMappings ) obj ) ; return contextMappings . equals ( other . contextMappings ) ; } } 
