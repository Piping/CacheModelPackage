package org . eclipse . debug . tests . viewer . model ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenCountUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IHasChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDeltaVisitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; import org . junit . Assert ; abstract public class UpdateTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public UpdateTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } abstract protected ITreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } public void testRemoveElements ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement root = model . getRootElement ( ) ; TreePath rootPath = new TreePath ( new Object [ ] { } ) ; TestElement [ ] newElements = new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ; model . setElementChildren ( rootPath , newElements ) ; fListener . reset ( rootPath , root , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( root , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testAddNewChildren ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = model . getRootElement ( ) . getChildren ( ) [ <int> ] ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; TestElement [ ] newChildren = new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ; model . setElementChildren ( elementPath , newChildren ) ; TreePath rootPath = TreePath . EMPTY ; TestElement rootElement = model . getRootElement ( ) ; fListener . reset ( rootPath , rootElement , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( rootElement , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } private void removeElement ( TestModel model , int index , boolean validate ) throws InterruptedException { ModelDelta delta = model . removeElementChild ( TreePath . EMPTY , index ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } if ( validate ) { model . validateData ( fViewer , TreePath . EMPTY ) ; } } private void addElement ( TestModel model , String label , int position , boolean validate ) throws InterruptedException { ModelDelta delta = model . addElementChild ( TreePath . EMPTY , null , position , new TestElement ( model , label , new TestElement [ <int> ] ) ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; if ( validate ) { while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_SEQUENCE_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } else { while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } } private void insertElement ( TestModel model , String label , int position , boolean validate ) throws InterruptedException { ModelDelta delta = model . insertElementChild ( TreePath . EMPTY , position , new TestElement ( model , label , new TestElement [ <int> ] ) ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; if ( validate ) { while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_SEQUENCE_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } else { while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } } public void testRepeatedAddRemoveElement ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; removeElement ( model , <int> , true ) ; addElement ( model , <str> , <int> , true ) ; removeElement ( model , <int> , true ) ; addElement ( model , <str> , <int> , true ) ; removeElement ( model , <int> , true ) ; addElement ( model , <str> , <int> , true ) ; removeElement ( model , <int> , true ) ; addElement ( model , <str> , <int> , true ) ; } public void testNotifyUpdatesTartedOnModelChanged ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } Assert . assertTrue ( fListener . isFinished ( CONTENT_SEQUENCE_STARTED ) ) ; } public void testContentPlusAddRemoveUpdateRaceConditionsElement ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestModelUpdatesListener childrenCountUpdateListener = new TestModelUpdatesListener ( fViewer , false , false ) ; for ( int i = <int> ; i < <int> ; i + + ) { String pass = <str> + i ; childrenCountUpdateListener . reset ( ) ; childrenCountUpdateListener . addChildreCountUpdate ( TreePath . EMPTY ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } removeElement ( model , <int> , false ) ; removeElement ( model , <int> , false ) ; removeElement ( model , <int> , false ) ; removeElement ( model , <int> , false ) ; removeElement ( model , <int> , false ) ; removeElement ( model , <int> , false ) ; while ( ! childrenCountUpdateListener . isFinished ( CHILD_COUNT_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } insertElement ( model , <str> + pass , <int> , false ) ; insertElement ( model , <str> + pass , <int> , false ) ; insertElement ( model , <str> + pass , <int> , false ) ; insertElement ( model , <str> + pass , <int> , false ) ; insertElement ( model , <str> + pass , <int> , false ) ; insertElement ( model , <str> + pass , <int> , false ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } childrenCountUpdateListener . dispose ( ) ; } public void testInsertAtInvalidIndex ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; final int insertIndex = model . getRootElement ( ) . getChildren ( ) . length ; ModelDelta delta = model . insertElementChild ( TreePath . EMPTY , insertIndex , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; delta . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta visitorDelta , int depth ) { if ( ( visitorDelta . getFlags ( ) & IModelDelta . INSERTED ) ! = <int> ) { ( ( ModelDelta ) visitorDelta ) . setIndex ( insertIndex + <int> ) ; return false ; } return true ; } } ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_SEQUENCE_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testRescheduleUpdates ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; for ( int i = <int> ; i < <int> ; i + + ) { TestElement rootElement = model . getRootElement ( ) ; fListener . reset ( ) ; fListener . addUpdates ( TreePath . EMPTY , model . getRootElement ( ) , <int> , CHILD_COUNT_UPDATES ) ; model . postDelta ( new ModelDelta ( rootElement , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES | CHILDREN_UPDATES_STARTED ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } removeElement ( model , <int> , true ) ; addElement ( model , <str> , <int> , true ) ; } } public void testCanceledUpdates1 ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( true ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES_STARTED ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } model . setQeueueingUpdate ( false ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCanceledUpdates2 ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( true ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES_STARTED ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } ArrayList < IViewerUpdate > updates = new ArrayList < IViewerUpdate > ( model . getQueuedUpdates ( ) ) ; model . getQueuedUpdates ( ) . clear ( ) ; for ( int i = updates . size ( ) - <int> ; i > = <int> ; i - - ) { model . processUpdate ( updates . get ( i ) ) ; } model . setQeueueingUpdate ( false ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCanceledUpdates3 ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( true ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILDREN_UPDATES_STARTED ) ) { completeQueuedUpdatesOfType ( model , IChildrenCountUpdate . class ) ; completeQueuedUpdatesOfType ( model , IHasChildrenUpdate . class ) ; if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } model . setQeueueingUpdate ( false ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCanceledUpdates4 ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( true ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILDREN_UPDATES_STARTED ) ) { completeQueuedUpdatesOfType ( model , IChildrenCountUpdate . class ) ; completeQueuedUpdatesOfType ( model , IHasChildrenUpdate . class ) ; if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } ArrayList < IViewerUpdate > updates = new ArrayList < IViewerUpdate > ( model . getQueuedUpdates ( ) ) ; model . getQueuedUpdates ( ) . clear ( ) ; for ( int i = updates . size ( ) - <int> ; i > = <int> ; i - - ) { model . processUpdate ( updates . get ( i ) ) ; } model . setQeueueingUpdate ( false ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCancelUpdatesOnRemoveElementWhileUpdatingSubTree ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; fListener . reset ( ) ; TreePath path = model . findElement ( <str> ) ; fListener . addUpdates ( path , model . getElement ( path ) , <int> , CHILD_COUNT_UPDATES ) ; fListener . addChildreUpdate ( path , <int> ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES | CHILDREN_UPDATES_RUNNING ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } removeElement ( model , <int> , true ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCanceledUpdatesOnSetInput ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( false ) ; fListener . reset ( ) ; fListener . addChildreCountUpdate ( TreePath . EMPTY ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestModel model2 = new TestModel ( ) ; model2 . setRoot ( new TestElement ( model2 , <str> , new TestElement [ <int> ] ) ) ; fViewer . setInput ( model2 . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_COMPLETE | VIEWER_UPDATES_RUNNING ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testCanceledUpdatesOnSetNullInput ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; model . setQeueueingUpdate ( false ) ; fListener . reset ( ) ; fListener . addChildreCountUpdate ( TreePath . EMPTY ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILD_COUNT_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( CONTENT_COMPLETE | VIEWER_UPDATES_RUNNING ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } private void completeQueuedUpdatesOfType ( TestModel model , Class < ? > updateClass ) { List < IViewerUpdate > updatesToComplete = new LinkedList < IViewerUpdate > ( ) ; for ( Iterator < IViewerUpdate > itr = model . getQueuedUpdates ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { IViewerUpdate update = itr . next ( ) ; if ( updateClass . isInstance ( update ) ) { updatesToComplete . add ( update ) ; itr . remove ( ) ; } } if ( updatesToComplete ! = null ) { for ( Iterator < IViewerUpdate > itr = updatesToComplete . iterator ( ) ; itr . hasNext ( ) ; ) { model . processUpdate ( itr . next ( ) ) ; } } } } 
