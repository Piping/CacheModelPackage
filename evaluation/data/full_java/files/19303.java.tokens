package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpObjectAggregator ; import io . netty . handler . codec . http . HttpRequestDecoder ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseDecoder ; import io . netty . handler . codec . http . HttpResponseEncoder ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import org . junit . Assert ; import org . junit . Test ; import static io . netty . handler . codec . http . HttpVersion . * ; public class WebSocketServerHandshaker00Test { @Test public void testPerformOpeningHandshake ( ) { testPerformOpeningHandshake0 ( true ) ; } @Test public void testPerformOpeningHandshakeSubProtocolNotSupported ( ) { testPerformOpeningHandshake0 ( false ) ; } private static void testPerformOpeningHandshake0 ( boolean subProtocol ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpObjectAggregator ( <int> ) , new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) ) ; FullHttpRequest req = ReferenceCountUtil . releaseLater ( new DefaultFullHttpRequest ( HTTP_1_1 , HttpMethod . GET , <str> , Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; req . headers ( ) . set ( HttpHeaderNames . HOST , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . UPGRADE , HttpHeaderValues . WEBSOCKET ) ; req . headers ( ) . set ( HttpHeaderNames . CONNECTION , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . ORIGIN , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . SEC_WEBSOCKET_KEY1 , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . SEC_WEBSOCKET_KEY2 , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL , <str> ) ; if ( subProtocol ) { new WebSocketServerHandshaker00 ( <str> , <str> , Integer . MAX_VALUE ) . handshake ( ch , req ) ; } else { new WebSocketServerHandshaker00 ( <str> , null , Integer . MAX_VALUE ) . handshake ( ch , req ) ; } EmbeddedChannel ch2 = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch2 . writeInbound ( ch . readOutbound ( ) ) ; HttpResponse res = ch2 . readInbound ( ) ; Assert . assertEquals ( <str> , res . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_LOCATION ) ) ; if ( subProtocol ) { Assert . assertEquals ( <str> , res . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL ) ) ; } else { Assert . assertNull ( res . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL ) ) ; } LastHttpContent content = ch2 . readInbound ( ) ; Assert . assertEquals ( <str> , content . content ( ) . toString ( CharsetUtil . US_ASCII ) ) ; content . release ( ) ; } } 
