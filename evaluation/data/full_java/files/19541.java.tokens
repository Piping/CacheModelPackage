package io . netty . handler . codec . socksx . v5 ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . EncoderException ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; public interface Socks5AddressEncoder { Socks5AddressEncoder DEFAULT = new Socks5AddressEncoder ( ) { @Override public void encodeAddress ( Socks5AddressType addrType , String addrValue , ByteBuf out ) throws Exception { final byte typeVal = addrType . byteValue ( ) ; if ( typeVal = = Socks5AddressType . IPv4 . byteValue ( ) ) { if ( addrValue ! = null ) { out . writeBytes ( NetUtil . createByteArrayFromIpAddressString ( addrValue ) ) ; } else { out . writeInt ( <int> ) ; } } else if ( typeVal = = Socks5AddressType . DOMAIN . byteValue ( ) ) { if ( addrValue ! = null ) { byte [ ] bndAddr = addrValue . getBytes ( CharsetUtil . US_ASCII ) ; out . writeByte ( bndAddr . length ) ; out . writeBytes ( bndAddr ) ; } else { out . writeByte ( <int> ) ; out . writeByte ( <int> ) ; } } else if ( typeVal = = Socks5AddressType . IPv6 . byteValue ( ) ) { if ( addrValue ! = null ) { out . writeBytes ( NetUtil . createByteArrayFromIpAddressString ( addrValue ) ) ; } else { out . writeLong ( <int> ) ; out . writeLong ( <int> ) ; } } else { throw new EncoderException ( <str> + ( addrType . byteValue ( ) & <hex> ) ) ; } } } ; void encodeAddress ( Socks5AddressType addrType , String addrValue , ByteBuf out ) throws Exception ; } 
