package clojure . asm ; public class Label { static final int DEBUG = <int> ; static final int RESOLVED = <int> ; static final int RESIZED = <int> ; static final int PUSHED = <int> ; static final int TARGET = <int> ; static final int STORE = <int> ; static final int REACHABLE = <int> ; static final int JSR = <int> ; static final int RET = <int> ; static final int SUBROUTINE = <int> ; static final int VISITED = <int> ; static final int VISITED2 = <int> ; public Object info ; int status ; int line ; int position ; private int referenceCount ; private int [ ] srcAndRefPositions ; int inputStackTop ; int outputStackMax ; Frame frame ; Label successor ; Edge successors ; Label next ; public Label ( ) { } public int getOffset ( ) { if ( ( status & RESOLVED ) = = <int> ) { throw new IllegalStateException ( <str> ) ; } return position ; } void put ( final MethodWriter owner , final ByteVector out , final int source , final boolean wideOffset ) { if ( ( status & RESOLVED ) = = <int> ) { if ( wideOffset ) { addReference ( - <int> - source , out . length ) ; out . putInt ( - <int> ) ; } else { addReference ( source , out . length ) ; out . putShort ( - <int> ) ; } } else { if ( wideOffset ) { out . putInt ( position - source ) ; } else { out . putShort ( position - source ) ; } } } private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions = = null ) { srcAndRefPositions = new int [ <int> ] ; } if ( referenceCount > = srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + <int> ] ; System . arraycopy ( srcAndRefPositions , <int> , a , <int> , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount + + ] = sourcePosition ; srcAndRefPositions [ referenceCount + + ] = referencePosition ; } boolean resolve ( final MethodWriter owner , final int position , final byte [ ] data ) { boolean needUpdate = false ; this . status | = RESOLVED ; this . position = position ; int i = <int> ; while ( i < referenceCount ) { int source = srcAndRefPositions [ i + + ] ; int reference = srcAndRefPositions [ i + + ] ; int offset ; if ( source > = <int> ) { offset = position - source ; if ( offset < Short . MIN_VALUE | | offset > Short . MAX_VALUE ) { int opcode = data [ reference - <int> ] & <hex> ; if ( opcode < = Opcodes . JSR ) { data [ reference - <int> ] = ( byte ) ( opcode + <int> ) ; } else { data [ reference - <int> ] = ( byte ) ( opcode + <int> ) ; } needUpdate = true ; } data [ reference + + ] = ( byte ) ( offset > > > <int> ) ; data [ reference ] = ( byte ) offset ; } else { offset = position + source + <int> ; data [ reference + + ] = ( byte ) ( offset > > > <int> ) ; data [ reference + + ] = ( byte ) ( offset > > > <int> ) ; data [ reference + + ] = ( byte ) ( offset > > > <int> ) ; data [ reference ] = ( byte ) offset ; } } return needUpdate ; } Label getFirst ( ) { return ! ClassReader . FRAMES | | frame = = null ? this : frame . owner ; } boolean inSubroutine ( final long id ) { if ( ( status & Label . VISITED ) ! = <int> ) { return ( srcAndRefPositions [ ( int ) ( id > > > <int> ) ] & ( int ) id ) ! = <int> ; } return false ; } boolean inSameSubroutine ( final Label block ) { if ( ( status & VISITED ) = = <int> | | ( block . status & VISITED ) = = <int> ) { return false ; } for ( int i = <int> ; i < srcAndRefPositions . length ; + + i ) { if ( ( srcAndRefPositions [ i ] & block . srcAndRefPositions [ i ] ) ! = <int> ) { return true ; } } return false ; } void addToSubroutine ( final long id , final int nbSubroutines ) { if ( ( status & VISITED ) = = <int> ) { status | = VISITED ; srcAndRefPositions = new int [ ( nbSubroutines - <int> ) / <int> + <int> ] ; } srcAndRefPositions [ ( int ) ( id > > > <int> ) ] | = ( int ) id ; } void visitSubroutine ( final Label JSR , final long id , final int nbSubroutines ) { Label stack = this ; while ( stack ! = null ) { Label l = stack ; stack = l . next ; l . next = null ; if ( JSR ! = null ) { if ( ( l . status & VISITED2 ) ! = <int> ) { continue ; } l . status | = VISITED2 ; if ( ( l . status & RET ) ! = <int> ) { if ( ! l . inSameSubroutine ( JSR ) ) { Edge e = new Edge ( ) ; e . info = l . inputStackTop ; e . successor = JSR . successors . successor ; e . next = l . successors ; l . successors = e ; } } } else { if ( l . inSubroutine ( id ) ) { continue ; } l . addToSubroutine ( id , nbSubroutines ) ; } Edge e = l . successors ; while ( e ! = null ) { if ( ( l . status & Label . JSR ) = = <int> | | e ! = l . successors . next ) { if ( e . successor . next = = null ) { e . successor . next = stack ; stack = e . successor ; } } e = e . next ; } } } @Override public String toString ( ) { return <str> + System . identityHashCode ( this ) ; } } 
