package org . apache . cassandra . utils ; import java . nio . ByteBuffer ; public class MurmurHash { public static int hash32 ( ByteBuffer data , int offset , int length , int seed ) { int m = <hex> ; int r = <int> ; int h = seed ^ length ; int len_4 = length > > <int> ; for ( int i = <int> ; i < len_4 ; i + + ) { int i_4 = i < < <int> ; int k = data . get ( offset + i_4 + <int> ) ; k = k < < <int> ; k = k | ( data . get ( offset + i_4 + <int> ) & <hex> ) ; k = k < < <int> ; k = k | ( data . get ( offset + i_4 + <int> ) & <hex> ) ; k = k < < <int> ; k = k | ( data . get ( offset + i_4 + <int> ) & <hex> ) ; k * = m ; k ^ = k > > > r ; k * = m ; h * = m ; h ^ = k ; } int len_m = len_4 < < <int> ; int left = length - len_m ; if ( left ! = <int> ) { if ( left > = <int> ) { h ^ = ( int ) data . get ( offset + length - <int> ) < < <int> ; } if ( left > = <int> ) { h ^ = ( int ) data . get ( offset + length - <int> ) < < <int> ; } if ( left > = <int> ) { h ^ = ( int ) data . get ( offset + length - <int> ) ; } h * = m ; } h ^ = h > > > <int> ; h * = m ; h ^ = h > > > <int> ; return h ; } public static long hash2_64 ( ByteBuffer key , int offset , int length , long seed ) { long m64 = <hex> ; int r64 = <int> ; long h64 = ( seed & <hex> ) ^ ( m64 * length ) ; int lenLongs = length > > <int> ; for ( int i = <int> ; i < lenLongs ; + + i ) { int i_8 = i < < <int> ; long k64 = ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( offset + i_8 + <int> ) & <hex> ) < < <int> ) ; k64 * = m64 ; k64 ^ = k64 > > > r64 ; k64 * = m64 ; h64 ^ = k64 ; h64 * = m64 ; } int rem = length & <hex> ; switch ( rem ) { case <int> : break ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem + <int> ) < < <int> ; case <int> : h64 ^ = ( long ) key . get ( offset + length - rem ) ; h64 * = m64 ; } h64 ^ = h64 > > > r64 ; h64 * = m64 ; h64 ^ = h64 > > > r64 ; return h64 ; } protected static long getblock ( ByteBuffer key , int offset , int index ) { int i_8 = index < < <int> ; int blockOffset = offset + i_8 ; return ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) + ( ( ( long ) key . get ( blockOffset + <int> ) & <hex> ) < < <int> ) ; } protected static long rotl64 ( long v , int n ) { return ( ( v < < n ) | ( v > > > ( <int> - n ) ) ) ; } protected static long fmix ( long k ) { k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; return k ; } public static void hash3_x64_128 ( ByteBuffer key , int offset , int length , long seed , long [ ] result ) { final int nblocks = length > > <int> ; long h1 = seed ; long h2 = seed ; long c1 = <hex> ; long c2 = <hex> ; for ( int i = <int> ; i < nblocks ; i + + ) { long k1 = getblock ( key , offset , i * <int> + <int> ) ; long k2 = getblock ( key , offset , i * <int> + <int> ) ; k1 * = c1 ; k1 = rotl64 ( k1 , <int> ) ; k1 * = c2 ; h1 ^ = k1 ; h1 = rotl64 ( h1 , <int> ) ; h1 + = h2 ; h1 = h1 * <int> + <hex> ; k2 * = c2 ; k2 = rotl64 ( k2 , <int> ) ; k2 * = c1 ; h2 ^ = k2 ; h2 = rotl64 ( h2 , <int> ) ; h2 + = h1 ; h2 = h2 * <int> + <hex> ; } offset + = nblocks * <int> ; long k1 = <int> ; long k2 = <int> ; switch ( length & <int> ) { case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k2 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; k2 * = c2 ; k2 = rotl64 ( k2 , <int> ) ; k2 * = c1 ; h2 ^ = k2 ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset + <int> ) ) < < <int> ; case <int> : k1 ^ = ( ( long ) key . get ( offset ) ) ; k1 * = c1 ; k1 = rotl64 ( k1 , <int> ) ; k1 * = c2 ; h1 ^ = k1 ; } ; h1 ^ = length ; h2 ^ = length ; h1 + = h2 ; h2 + = h1 ; h1 = fmix ( h1 ) ; h2 = fmix ( h2 ) ; h1 + = h2 ; h2 + = h1 ; result [ <int> ] = h1 ; result [ <int> ] = h2 ; } } 
