package io . netty . example . http2 . tiles ; import static io . netty . buffer . Unpooled . EMPTY_BUFFER ; import static io . netty . example . http2 . Http2ExampleUtil . firstValue ; import static io . netty . example . http2 . Http2ExampleUtil . toInt ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_TYPE ; import static io . netty . handler . codec . http . HttpUtil . setContentLength ; import static io . netty . handler . codec . http . HttpResponseStatus . BAD_REQUEST ; import static io . netty . handler . codec . http . HttpResponseStatus . OK ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; import static java . lang . Integer . valueOf ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . QueryStringDecoder ; import io . netty . handler . codec . http2 . HttpConversionUtil ; import io . netty . handler . codec . http2 . InboundHttp2ToHttpAdapter ; import java . util . concurrent . TimeUnit ; public class Http2RequestHandler extends SimpleChannelInboundHandler < FullHttpRequest > { private static final String LATENCY_FIELD_NAME = <str> ; private static final int MIN_LATENCY = <int> ; private static final int MAX_LATENCY = <int> ; private static final String IMAGE_COORDINATE_Y = <str> ; private static final String IMAGE_COORDINATE_X = <str> ; @Override protected void channelRead0 ( ChannelHandlerContext ctx , FullHttpRequest request ) throws Exception { QueryStringDecoder queryString = new QueryStringDecoder ( request . uri ( ) ) ; String streamId = streamId ( request ) ; int latency = toInt ( firstValue ( queryString , LATENCY_FIELD_NAME ) , <int> ) ; if ( latency < MIN_LATENCY | | latency > MAX_LATENCY ) { sendBadRequest ( ctx , streamId ) ; return ; } String x = firstValue ( queryString , IMAGE_COORDINATE_X ) ; String y = firstValue ( queryString , IMAGE_COORDINATE_Y ) ; if ( x = = null | | y = = null ) { handlePage ( ctx , streamId , latency , request ) ; } else { handleImage ( x , y , ctx , streamId , latency , request ) ; } } private void sendBadRequest ( ChannelHandlerContext ctx , String streamId ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , BAD_REQUEST , EMPTY_BUFFER ) ; streamId ( response , streamId ) ; ctx . writeAndFlush ( response ) ; } private void handleImage ( String x , String y , ChannelHandlerContext ctx , String streamId , int latency , FullHttpRequest request ) { ByteBuf image = ImageCache . INSTANCE . image ( valueOf ( x ) , valueOf ( y ) ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , OK , image . duplicate ( ) ) ; response . headers ( ) . set ( CONTENT_TYPE , <str> ) ; sendResponse ( ctx , streamId , latency , response , request ) ; } private void handlePage ( ChannelHandlerContext ctx , String streamId , int latency , FullHttpRequest request ) { byte [ ] body = Html . body ( latency ) ; ByteBuf content = ctx . alloc ( ) . buffer ( Html . HEADER . length + body . length + Html . FOOTER . length ) ; content . writeBytes ( Html . HEADER ) ; content . writeBytes ( body ) ; content . writeBytes ( Html . FOOTER ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , OK , content ) ; response . headers ( ) . set ( CONTENT_TYPE , <str> ) ; sendResponse ( ctx , streamId , latency , response , request ) ; } protected void sendResponse ( final ChannelHandlerContext ctx , String streamId , int latency , final FullHttpResponse response , final FullHttpRequest request ) { setContentLength ( response , response . content ( ) . readableBytes ( ) ) ; streamId ( response , streamId ) ; ctx . executor ( ) . schedule ( new Runnable ( ) { @Override public void run ( ) { ctx . writeAndFlush ( response ) ; } } , latency , TimeUnit . MILLISECONDS ) ; } private String streamId ( FullHttpRequest request ) { return request . headers ( ) . get ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) ) ; } private void streamId ( FullHttpResponse response , String streamId ) { response . headers ( ) . set ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , streamId ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { cause . printStackTrace ( ) ; ctx . close ( ) ; } } 
