package org . gradle . api . file ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . internal . cache . StringInterner ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . ListIterator ; public class RelativePath implements Serializable , Comparable < RelativePath > { private static final StringInterner PATH_SEGMENT_STRING_INTERNER = new StringInterner ( ) ; private final boolean endsWithFile ; private final String [ ] segments ; public RelativePath ( boolean endsWithFile , String . . . segments ) { this ( endsWithFile , null , segments ) ; } private RelativePath ( boolean endsWithFile , RelativePath parentPath , String . . . childSegments ) { this . endsWithFile = endsWithFile ; int targetOffsetForChildSegments ; if ( parentPath ! = null ) { String [ ] sourceSegments = parentPath . getSegments ( ) ; segments = new String [ sourceSegments . length + childSegments . length ] ; copySegments ( segments , sourceSegments , sourceSegments . length ) ; targetOffsetForChildSegments = sourceSegments . length ; } else { segments = new String [ childSegments . length ] ; targetOffsetForChildSegments = <int> ; } copyAndInternSegments ( segments , targetOffsetForChildSegments , childSegments ) ; } private static void copySegments ( String [ ] target , String [ ] source ) { copySegments ( target , source , target . length ) ; } private static void copySegments ( String [ ] target , String [ ] source , int length ) { System . arraycopy ( source , <int> , target , <int> , length ) ; } private static void copyAndInternSegments ( String [ ] target , int targetOffset , String [ ] source ) { for ( int i = <int> ; i < source . length ; i + + ) { target [ targetOffset + i ] = internPathSegment ( source [ i ] ) ; } } private static String internPathSegment ( String sample ) { return PATH_SEGMENT_STRING_INTERNER . intern ( sample ) ; } public String [ ] getSegments ( ) { return segments ; } public ListIterator < String > segmentIterator ( ) { ArrayList < String > content = new ArrayList < String > ( Arrays . asList ( segments ) ) ; return content . listIterator ( ) ; } public boolean isFile ( ) { return endsWithFile ; } public String getPathString ( ) { return CollectionUtils . join ( <str> , segments ) ; } public File getFile ( File baseDir ) { return new File ( baseDir , getPathString ( ) ) ; } public String getLastName ( ) { if ( segments . length > <int> ) { return segments [ segments . length - <int> ] ; } else { return null ; } } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } RelativePath that = ( RelativePath ) o ; if ( endsWithFile ! = that . endsWithFile ) { return false ; } if ( ! Arrays . equals ( segments , that . segments ) ) { return false ; } return true ; } @Override public int hashCode ( ) { int result = endsWithFile ? <int> : <int> ; result = <int> * result + Arrays . hashCode ( segments ) ; return result ; } @Override public String toString ( ) { return getPathString ( ) ; } public RelativePath getParent ( ) { if ( segments . length = = <int> ) { return null ; } String [ ] parentSegments = new String [ segments . length - <int> ] ; copySegments ( parentSegments , segments ) ; return new RelativePath ( false , parentSegments ) ; } public static RelativePath parse ( boolean isFile , String path ) { return parse ( isFile , null , path ) ; } public static RelativePath parse ( boolean isFile , RelativePath parent , String path ) { String [ ] names = StringUtils . split ( path , <str> + File . separator ) ; return new RelativePath ( isFile , parent , names ) ; } public RelativePath replaceLastName ( String name ) { String [ ] newSegments = new String [ segments . length ] ; copySegments ( newSegments , segments , segments . length - <int> ) ; newSegments [ segments . length - <int> ] = internPathSegment ( name ) ; return new RelativePath ( endsWithFile , newSegments ) ; } public RelativePath append ( RelativePath other ) { return new RelativePath ( other . endsWithFile , this , other . segments ) ; } public RelativePath plus ( RelativePath other ) { return append ( other ) ; } public RelativePath append ( boolean endsWithFile , String . . . segments ) { return new RelativePath ( endsWithFile , this , segments ) ; } public RelativePath prepend ( String . . . segments ) { return new RelativePath ( false , segments ) . append ( this ) ; } @Override public int compareTo ( RelativePath o ) { int len1 = segments . length ; int len2 = o . segments . length ; int lim = Math . min ( len1 , len2 ) ; String v1 [ ] = segments ; String v2 [ ] = o . segments ; int k = <int> ; while ( k < lim ) { String c1 = v1 [ k ] ; String c2 = v2 [ k ] ; int compareResult = c1 . compareTo ( c2 ) ; if ( compareResult ! = <int> ) { return compareResult ; } k + + ; } return len1 - len2 ; } } 
