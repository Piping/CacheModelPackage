package org . apache . cassandra . dht ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ThreadLocalRandom ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . PreHashedDecoratedKey ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . PartitionerDefinedOrder ; import org . apache . cassandra . db . marshal . LongType ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . MurmurHash ; import org . apache . cassandra . utils . ObjectSizes ; import com . google . common . primitives . Longs ; public class Murmur3Partitioner implements IPartitioner { public static final LongToken MINIMUM = new LongToken ( Long . MIN_VALUE ) ; public static final long MAXIMUM = Long . MAX_VALUE ; private static final int HEAP_SIZE = ( int ) ObjectSizes . measureDeep ( MINIMUM ) ; public static final Murmur3Partitioner instance = new Murmur3Partitioner ( ) ; public static final AbstractType < ? > partitionOrdering = new PartitionerDefinedOrder ( instance ) ; public DecoratedKey decorateKey ( ByteBuffer key ) { long [ ] hash = getHash ( key ) ; return new PreHashedDecoratedKey ( getToken ( key , hash ) , key , hash [ <int> ] , hash [ <int> ] ) ; } public Token midpoint ( Token lToken , Token rToken ) { BigInteger l = BigInteger . valueOf ( ( ( LongToken ) lToken ) . token ) , r = BigInteger . valueOf ( ( ( LongToken ) rToken ) . token ) , midpoint ; if ( l . compareTo ( r ) < <int> ) { BigInteger sum = l . add ( r ) ; midpoint = sum . shiftRight ( <int> ) ; } else { BigInteger max = BigInteger . valueOf ( MAXIMUM ) ; BigInteger min = BigInteger . valueOf ( MINIMUM . token ) ; midpoint = ( max . subtract ( min ) . add ( l ) . add ( r ) ) . shiftRight ( <int> ) ; if ( midpoint . compareTo ( max ) > <int> ) midpoint = min . add ( midpoint . subtract ( max ) ) ; } return new LongToken ( midpoint . longValue ( ) ) ; } public LongToken getMinimumToken ( ) { return MINIMUM ; } public static class LongToken extends Token { static final long serialVersionUID = - <int> ; final long token ; public LongToken ( long token ) { this . token = token ; } public String toString ( ) { return Long . toString ( token ) ; } public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null | | this . getClass ( ) ! = obj . getClass ( ) ) return false ; return token = = ( ( ( LongToken ) obj ) . token ) ; } public int hashCode ( ) { return Longs . hashCode ( token ) ; } public int compareTo ( Token o ) { return Long . compare ( token , ( ( LongToken ) o ) . token ) ; } @Override public IPartitioner getPartitioner ( ) { return instance ; } @Override public long getHeapSize ( ) { return HEAP_SIZE ; } @Override public Object getTokenValue ( ) { return token ; } @Override public double size ( Token next ) { LongToken n = ( LongToken ) next ; long v = n . token - token ; double d = Math . scalb ( ( double ) v , - Long . SIZE ) ; return d > <float> ? d : ( d + <float> ) ; } @Override public Token increaseSlightly ( ) { return new LongToken ( token + <int> ) ; } } public LongToken getToken ( ByteBuffer key ) { return getToken ( key , getHash ( key ) ) ; } private LongToken getToken ( ByteBuffer key , long [ ] hash ) { if ( key . remaining ( ) = = <int> ) return MINIMUM ; return new LongToken ( normalize ( hash [ <int> ] ) ) ; } private long [ ] getHash ( ByteBuffer key ) { long [ ] hash = new long [ <int> ] ; MurmurHash . hash3_x64_128 ( key , key . position ( ) , key . remaining ( ) , <int> , hash ) ; return hash ; } public LongToken getRandomToken ( ) { return getRandomToken ( ThreadLocalRandom . current ( ) ) ; } public LongToken getRandomToken ( Random r ) { return new LongToken ( normalize ( r . nextLong ( ) ) ) ; } private long normalize ( long v ) { return v = = Long . MIN_VALUE ? Long . MAX_VALUE : v ; } public boolean preservesOrder ( ) { return false ; } public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) { Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; Iterator < Token > i = sortedTokens . iterator ( ) ; if ( ! i . hasNext ( ) ) throw new RuntimeException ( <str> ) ; if ( sortedTokens . size ( ) = = <int> ) ownerships . put ( i . next ( ) , new Float ( <float> ) ) ; else { final BigInteger ri = BigInteger . valueOf ( MAXIMUM ) . subtract ( BigInteger . valueOf ( MINIMUM . token + <int> ) ) ; final BigDecimal r = new BigDecimal ( ri ) ; Token start = i . next ( ) ; BigInteger ti = BigInteger . valueOf ( ( ( LongToken ) start ) . token ) ; Token t ; BigInteger tim1 = ti ; while ( i . hasNext ( ) ) { t = i . next ( ) ; ti = BigInteger . valueOf ( ( ( LongToken ) t ) . token ) ; float age = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r , <int> , BigDecimal . ROUND_HALF_EVEN ) . floatValue ( ) ; ownerships . put ( t , age ) ; tim1 = ti ; } float x = new BigDecimal ( BigInteger . valueOf ( ( ( LongToken ) start ) . token ) . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r , <int> , BigDecimal . ROUND_HALF_EVEN ) . floatValue ( ) ; ownerships . put ( start , x ) ; } return ownerships ; } public Token . TokenFactory getTokenFactory ( ) { return tokenFactory ; } private final Token . TokenFactory tokenFactory = new Token . TokenFactory ( ) { public ByteBuffer toByteArray ( Token token ) { LongToken longToken = ( LongToken ) token ; return ByteBufferUtil . bytes ( longToken . token ) ; } public Token fromByteArray ( ByteBuffer bytes ) { return new LongToken ( ByteBufferUtil . toLong ( bytes ) ) ; } public String toString ( Token token ) { return token . toString ( ) ; } public void validate ( String token ) throws ConfigurationException { try { Long . valueOf ( token ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( e . getMessage ( ) ) ; } } public Token fromString ( String string ) { try { return new LongToken ( Long . parseLong ( string ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( String . format ( <str> , string ) ) ; } } } ; public AbstractType < ? > getTokenValidator ( ) { return LongType . instance ; } public AbstractType < ? > partitionOrdering ( ) { return partitionOrdering ; } } 
