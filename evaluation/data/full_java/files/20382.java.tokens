package io . netty . channel . epoll ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . channel . ChannelOutboundBuffer . MessageProcessor ; import io . netty . util . internal . PlatformDependent ; import java . nio . ByteBuffer ; final class IovArray implements MessageProcessor { private static final int ADDRESS_SIZE = PlatformDependent . addressSize ( ) ; private static final int IOV_SIZE = <int> * ADDRESS_SIZE ; private static final int CAPACITY = Native . IOV_MAX * IOV_SIZE ; private final long memoryAddress ; private int count ; private long size ; IovArray ( ) { memoryAddress = PlatformDependent . allocateMemory ( CAPACITY ) ; } void clear ( ) { count = <int> ; size = <int> ; } boolean add ( ByteBuf buf ) { if ( count = = Native . IOV_MAX ) { return false ; } final int len = buf . readableBytes ( ) ; if ( len = = <int> ) { return true ; } final long addr = buf . memoryAddress ( ) ; final int offset = buf . readerIndex ( ) ; return add ( addr , offset , len ) ; } private boolean add ( long addr , int offset , int len ) { if ( len = = <int> ) { return true ; } final long baseOffset = memoryAddress ( count + + ) ; final long lengthOffset = baseOffset + ADDRESS_SIZE ; if ( Native . SSIZE_MAX - len < size ) { return false ; } size + = len ; if ( ADDRESS_SIZE = = <int> ) { PlatformDependent . putLong ( baseOffset , addr + offset ) ; PlatformDependent . putLong ( lengthOffset , len ) ; } else { assert ADDRESS_SIZE = = <int> ; PlatformDependent . putInt ( baseOffset , ( int ) addr + offset ) ; PlatformDependent . putInt ( lengthOffset , len ) ; } return true ; } boolean add ( CompositeByteBuf buf ) { ByteBuffer [ ] buffers = buf . nioBuffers ( ) ; if ( count + buffers . length > = Native . IOV_MAX ) { return false ; } for ( int i = <int> ; i < buffers . length ; i + + ) { ByteBuffer nioBuffer = buffers [ i ] ; int offset = nioBuffer . position ( ) ; int len = nioBuffer . limit ( ) - nioBuffer . position ( ) ; if ( len = = <int> ) { continue ; } long addr = PlatformDependent . directBufferAddress ( nioBuffer ) ; if ( ! add ( addr , offset , len ) ) { return false ; } } return true ; } long processWritten ( int index , long written ) { long baseOffset = memoryAddress ( index ) ; long lengthOffset = baseOffset + ADDRESS_SIZE ; if ( ADDRESS_SIZE = = <int> ) { long len = PlatformDependent . getLong ( lengthOffset ) ; if ( len > written ) { long offset = PlatformDependent . getLong ( baseOffset ) ; PlatformDependent . putLong ( baseOffset , offset + written ) ; PlatformDependent . putLong ( lengthOffset , len - written ) ; return - <int> ; } return len ; } else { assert ADDRESS_SIZE = = <int> ; long len = PlatformDependent . getInt ( lengthOffset ) ; if ( len > written ) { int offset = PlatformDependent . getInt ( baseOffset ) ; PlatformDependent . putInt ( baseOffset , ( int ) ( offset + written ) ) ; PlatformDependent . putInt ( lengthOffset , ( int ) ( len - written ) ) ; return - <int> ; } return len ; } } int count ( ) { return count ; } long size ( ) { return size ; } long memoryAddress ( int offset ) { return memoryAddress + IOV_SIZE * offset ; } void release ( ) { PlatformDependent . freeMemory ( memoryAddress ) ; } @Override public boolean processMessage ( Object msg ) throws Exception { if ( msg instanceof ByteBuf ) { if ( msg instanceof CompositeByteBuf ) { return add ( ( CompositeByteBuf ) msg ) ; } else { return add ( ( ByteBuf ) msg ) ; } } return false ; } } 
