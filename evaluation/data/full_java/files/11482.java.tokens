package org . gradle . api . internal . file ; import com . google . common . base . Function ; import com . google . common . collect . ImmutableCollection ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import net . jcip . annotations . ThreadSafe ; import org . gradle . api . file . DirectoryTree ; import org . gradle . api . internal . file . collections . DirectoryTrees ; import org . gradle . api . tasks . util . PatternSet ; import org . gradle . internal . FileUtils ; import org . gradle . internal . nativeintegration . services . FileSystems ; import java . io . File ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; @ThreadSafe public class FileSystemSubset { private final ImmutableCollection < File > files ; private final ImmutableCollection < ImmutableDirectoryTree > trees ; public static Builder builder ( ) { return new Builder ( ) ; } public FileSystemSubset ( ImmutableCollection < File > files , ImmutableCollection < ImmutableDirectoryTree > trees ) { this . files = files ; this . trees = trees ; } public Iterable < ? extends File > getRoots ( ) { return FileUtils . calculateRoots ( Iterables . concat ( files , Iterables . transform ( trees , new Function < DirectoryTree , File > ( ) { @Override public File apply ( DirectoryTree input ) { return input . getDir ( ) ; } } ) ) ) ; } public FileSystemSubset unfiltered ( ) { return new FileSystemSubset ( ImmutableList . copyOf ( getRoots ( ) ) , ImmutableList . < ImmutableDirectoryTree > of ( ) ) ; } public boolean isEmpty ( ) { return files . isEmpty ( ) & & trees . isEmpty ( ) ; } public boolean contains ( File file ) { File absoluteFile = file . getAbsoluteFile ( ) ; String pathWithSeparator = file . getAbsolutePath ( ) + File . separator ; for ( File candidateFile : files ) { String candidateFilePathWithSeparator = candidateFile . getPath ( ) + File . separator ; if ( pathWithSeparator . startsWith ( candidateFilePathWithSeparator ) ) { return true ; } } for ( DirectoryTree tree : trees ) { if ( tree . getDir ( ) . getAbsoluteFile ( ) . equals ( absoluteFile ) | | DirectoryTrees . contains ( FileSystems . getDefault ( ) , tree , absoluteFile ) ) { return true ; } } return false ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( files ) ; sb . append ( <str> ) . append ( trees ) ; return sb . toString ( ) ; } @ThreadSafe public static class Builder { private final ImmutableSet . Builder < File > files = ImmutableSet . builder ( ) ; private final ImmutableSet . Builder < ImmutableDirectoryTree > trees = ImmutableSet . builder ( ) ; private final Lock lock = new ReentrantLock ( ) ; private Builder ( ) { } public Builder add ( File file ) { lock . lock ( ) ; try { files . add ( file . getAbsoluteFile ( ) ) ; return this ; } finally { lock . unlock ( ) ; } } public Builder add ( DirectoryTree directoryTree ) { lock . lock ( ) ; try { trees . add ( ImmutableDirectoryTree . of ( directoryTree ) ) ; return this ; } finally { lock . unlock ( ) ; } } public Builder add ( File dir , PatternSet patternSet ) { lock . lock ( ) ; try { trees . add ( ImmutableDirectoryTree . of ( dir , patternSet ) ) ; return this ; } finally { lock . unlock ( ) ; } } public FileSystemSubset build ( ) { lock . lock ( ) ; try { return new FileSystemSubset ( files . build ( ) , trees . build ( ) ) ; } finally { lock . unlock ( ) ; } } } } 
