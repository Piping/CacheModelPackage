package io . netty . handler . codec . mqtt ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . mqtt . MqttDecoder . DecoderState ; import io . netty . util . CharsetUtil ; import java . util . ArrayList ; import java . util . List ; import static io . netty . handler . codec . mqtt . MqttCodecUtil . * ; public class MqttDecoder extends ReplayingDecoder < DecoderState > { private static final int DEFAULT_MAX_BYTES_IN_MESSAGE = <int> ; enum DecoderState { READ_FIXED_HEADER , READ_VARIABLE_HEADER , READ_PAYLOAD , BAD_MESSAGE , } private MqttFixedHeader mqttFixedHeader ; private Object variableHeader ; private Object payload ; private int bytesRemainingInVariablePart ; private final int maxBytesInMessage ; public MqttDecoder ( ) { this ( DEFAULT_MAX_BYTES_IN_MESSAGE ) ; } public MqttDecoder ( int maxBytesInMessage ) { super ( DecoderState . READ_FIXED_HEADER ) ; this . maxBytesInMessage = maxBytesInMessage ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buffer , List < Object > out ) throws Exception { switch ( state ( ) ) { case READ_FIXED_HEADER : mqttFixedHeader = decodeFixedHeader ( buffer ) ; bytesRemainingInVariablePart = mqttFixedHeader . remainingLength ( ) ; checkpoint ( DecoderState . READ_VARIABLE_HEADER ) ; case READ_VARIABLE_HEADER : try { if ( bytesRemainingInVariablePart > maxBytesInMessage ) { throw new DecoderException ( <str> + bytesRemainingInVariablePart + <str> ) ; } final Result < ? > decodedVariableHeader = decodeVariableHeader ( buffer , mqttFixedHeader ) ; variableHeader = decodedVariableHeader . value ; bytesRemainingInVariablePart - = decodedVariableHeader . numberOfBytesConsumed ; checkpoint ( DecoderState . READ_PAYLOAD ) ; } catch ( Exception cause ) { out . add ( invalidMessage ( cause ) ) ; return ; } case READ_PAYLOAD : try { final Result < ? > decodedPayload = decodePayload ( buffer , mqttFixedHeader . messageType ( ) , bytesRemainingInVariablePart , variableHeader ) ; payload = decodedPayload . value ; bytesRemainingInVariablePart - = decodedPayload . numberOfBytesConsumed ; if ( bytesRemainingInVariablePart ! = <int> ) { throw new DecoderException ( <str> + bytesRemainingInVariablePart + <str> + mqttFixedHeader . messageType ( ) + <str> ) ; } checkpoint ( DecoderState . READ_FIXED_HEADER ) ; MqttMessage message = MqttMessageFactory . newMessage ( mqttFixedHeader , variableHeader , payload ) ; mqttFixedHeader = null ; variableHeader = null ; payload = null ; out . add ( message ) ; break ; } catch ( Exception cause ) { out . add ( invalidMessage ( cause ) ) ; return ; } case BAD_MESSAGE : buffer . skipBytes ( actualReadableBytes ( ) ) ; break ; default: throw new Error ( ) ; } } private MqttMessage invalidMessage ( Throwable cause ) { checkpoint ( DecoderState . BAD_MESSAGE ) ; return MqttMessageFactory . newInvalidMessage ( cause ) ; } private static MqttFixedHeader decodeFixedHeader ( ByteBuf buffer ) { short b1 = buffer . readUnsignedByte ( ) ; MqttMessageType messageType = MqttMessageType . valueOf ( b1 > > <int> ) ; boolean dupFlag = ( b1 & <hex> ) = = <hex> ; int qosLevel = ( b1 & <hex> ) > > <int> ; boolean retain = ( b1 & <hex> ) ! = <int> ; int remainingLength = <int> ; int multiplier = <int> ; short digit ; int loops = <int> ; do { digit = buffer . readUnsignedByte ( ) ; remainingLength + = ( digit & <int> ) * multiplier ; multiplier * = <int> ; loops + + ; } while ( ( digit & <int> ) ! = <int> & & loops < <int> ) ; if ( loops = = <int> & & ( digit & <int> ) ! = <int> ) { throw new DecoderException ( <str> + messageType + <str> ) ; } MqttFixedHeader decodedFixedHeader = new MqttFixedHeader ( messageType , dupFlag , MqttQoS . valueOf ( qosLevel ) , retain , remainingLength ) ; return validateFixedHeader ( resetUnusedFields ( decodedFixedHeader ) ) ; } private static Result < ? > decodeVariableHeader ( ByteBuf buffer , MqttFixedHeader mqttFixedHeader ) { switch ( mqttFixedHeader . messageType ( ) ) { case CONNECT : return decodeConnectionVariableHeader ( buffer ) ; case CONNACK : return decodeConnAckVariableHeader ( buffer ) ; case SUBSCRIBE : case UNSUBSCRIBE : case SUBACK : case UNSUBACK : case PUBACK : case PUBREC : case PUBCOMP : case PUBREL : return decodeMessageIdVariableHeader ( buffer ) ; case PUBLISH : return decodePublishVariableHeader ( buffer , mqttFixedHeader ) ; case PINGREQ : case PINGRESP : case DISCONNECT : return new Result < Object > ( null , <int> ) ; } return new Result < Object > ( null , <int> ) ; } private static Result < MqttConnectVariableHeader > decodeConnectionVariableHeader ( ByteBuf buffer ) { final Result < String > protoString = decodeString ( buffer ) ; int numberOfBytesConsumed = protoString . numberOfBytesConsumed ; final byte protocolLevel = buffer . readByte ( ) ; numberOfBytesConsumed + = <int> ; final MqttVersion mqttVersion = MqttVersion . fromProtocolNameAndLevel ( protoString . value , protocolLevel ) ; final int b1 = buffer . readUnsignedByte ( ) ; numberOfBytesConsumed + = <int> ; final Result < Integer > keepAlive = decodeMsbLsb ( buffer ) ; numberOfBytesConsumed + = keepAlive . numberOfBytesConsumed ; final boolean hasUserName = ( b1 & <hex> ) = = <hex> ; final boolean hasPassword = ( b1 & <hex> ) = = <hex> ; final boolean willRetain = ( b1 & <hex> ) = = <hex> ; final int willQos = ( b1 & <hex> ) > > <int> ; final boolean willFlag = ( b1 & <hex> ) = = <hex> ; final boolean cleanSession = ( b1 & <hex> ) = = <hex> ; final MqttConnectVariableHeader mqttConnectVariableHeader = new MqttConnectVariableHeader ( mqttVersion . protocolName ( ) , mqttVersion . protocolLevel ( ) , hasUserName , hasPassword , willRetain , willQos , willFlag , cleanSession , keepAlive . value ) ; return new Result < MqttConnectVariableHeader > ( mqttConnectVariableHeader , numberOfBytesConsumed ) ; } private static Result < MqttConnAckVariableHeader > decodeConnAckVariableHeader ( ByteBuf buffer ) { final boolean sessionPresent = ( buffer . readUnsignedByte ( ) & <hex> ) = = <hex> ; byte returnCode = buffer . readByte ( ) ; final int numberOfBytesConsumed = <int> ; final MqttConnAckVariableHeader mqttConnAckVariableHeader = new MqttConnAckVariableHeader ( MqttConnectReturnCode . valueOf ( returnCode ) , sessionPresent ) ; return new Result < MqttConnAckVariableHeader > ( mqttConnAckVariableHeader , numberOfBytesConsumed ) ; } private static Result < MqttMessageIdVariableHeader > decodeMessageIdVariableHeader ( ByteBuf buffer ) { final Result < Integer > messageId = decodeMessageId ( buffer ) ; return new Result < MqttMessageIdVariableHeader > ( MqttMessageIdVariableHeader . from ( messageId . value ) , messageId . numberOfBytesConsumed ) ; } private static Result < MqttPublishVariableHeader > decodePublishVariableHeader ( ByteBuf buffer , MqttFixedHeader mqttFixedHeader ) { final Result < String > decodedTopic = decodeString ( buffer ) ; if ( ! isValidPublishTopicName ( decodedTopic . value ) ) { throw new DecoderException ( <str> + decodedTopic . value + <str> ) ; } int numberOfBytesConsumed = decodedTopic . numberOfBytesConsumed ; int messageId = - <int> ; if ( mqttFixedHeader . qosLevel ( ) . value ( ) > <int> ) { final Result < Integer > decodedMessageId = decodeMessageId ( buffer ) ; messageId = decodedMessageId . value ; numberOfBytesConsumed + = decodedMessageId . numberOfBytesConsumed ; } final MqttPublishVariableHeader mqttPublishVariableHeader = new MqttPublishVariableHeader ( decodedTopic . value , messageId ) ; return new Result < MqttPublishVariableHeader > ( mqttPublishVariableHeader , numberOfBytesConsumed ) ; } private static Result < Integer > decodeMessageId ( ByteBuf buffer ) { final Result < Integer > messageId = decodeMsbLsb ( buffer ) ; if ( ! isValidMessageId ( messageId . value ) ) { throw new DecoderException ( <str> + messageId . value ) ; } return messageId ; } private static Result < ? > decodePayload ( ByteBuf buffer , MqttMessageType messageType , int bytesRemainingInVariablePart , Object variableHeader ) { switch ( messageType ) { case CONNECT : return decodeConnectionPayload ( buffer , ( MqttConnectVariableHeader ) variableHeader ) ; case SUBSCRIBE : return decodeSubscribePayload ( buffer , bytesRemainingInVariablePart ) ; case SUBACK : return decodeSubackPayload ( buffer , bytesRemainingInVariablePart ) ; case UNSUBSCRIBE : return decodeUnsubscribePayload ( buffer , bytesRemainingInVariablePart ) ; case PUBLISH : return decodePublishPayload ( buffer , bytesRemainingInVariablePart ) ; default: return new Result < Object > ( null , <int> ) ; } } private static Result < MqttConnectPayload > decodeConnectionPayload ( ByteBuf buffer , MqttConnectVariableHeader mqttConnectVariableHeader ) { final Result < String > decodedClientId = decodeString ( buffer ) ; final String decodedClientIdValue = decodedClientId . value ; final MqttVersion mqttVersion = MqttVersion . fromProtocolNameAndLevel ( mqttConnectVariableHeader . name ( ) , ( byte ) mqttConnectVariableHeader . version ( ) ) ; if ( ! isValidClientId ( mqttVersion , decodedClientIdValue ) ) { throw new MqttIdentifierRejectedException ( <str> + decodedClientIdValue ) ; } int numberOfBytesConsumed = decodedClientId . numberOfBytesConsumed ; Result < String > decodedWillTopic = null ; Result < String > decodedWillMessage = null ; if ( mqttConnectVariableHeader . isWillFlag ( ) ) { decodedWillTopic = decodeString ( buffer , <int> , <int> ) ; numberOfBytesConsumed + = decodedWillTopic . numberOfBytesConsumed ; decodedWillMessage = decodeAsciiString ( buffer ) ; numberOfBytesConsumed + = decodedWillMessage . numberOfBytesConsumed ; } Result < String > decodedUserName = null ; Result < String > decodedPassword = null ; if ( mqttConnectVariableHeader . hasUserName ( ) ) { decodedUserName = decodeString ( buffer ) ; numberOfBytesConsumed + = decodedUserName . numberOfBytesConsumed ; } if ( mqttConnectVariableHeader . hasPassword ( ) ) { decodedPassword = decodeString ( buffer ) ; numberOfBytesConsumed + = decodedPassword . numberOfBytesConsumed ; } final MqttConnectPayload mqttConnectPayload = new MqttConnectPayload ( decodedClientId . value , decodedWillTopic ! = null ? decodedWillTopic . value : null , decodedWillMessage ! = null ? decodedWillMessage . value : null , decodedUserName ! = null ? decodedUserName . value : null , decodedPassword ! = null ? decodedPassword . value : null ) ; return new Result < MqttConnectPayload > ( mqttConnectPayload , numberOfBytesConsumed ) ; } private static Result < MqttSubscribePayload > decodeSubscribePayload ( ByteBuf buffer , int bytesRemainingInVariablePart ) { final List < MqttTopicSubscription > subscribeTopics = new ArrayList < MqttTopicSubscription > ( ) ; int numberOfBytesConsumed = <int> ; while ( numberOfBytesConsumed < bytesRemainingInVariablePart ) { final Result < String > decodedTopicName = decodeString ( buffer ) ; numberOfBytesConsumed + = decodedTopicName . numberOfBytesConsumed ; int qos = buffer . readUnsignedByte ( ) & <hex> ; numberOfBytesConsumed + + ; subscribeTopics . add ( new MqttTopicSubscription ( decodedTopicName . value , MqttQoS . valueOf ( qos ) ) ) ; } return new Result < MqttSubscribePayload > ( new MqttSubscribePayload ( subscribeTopics ) , numberOfBytesConsumed ) ; } private static Result < MqttSubAckPayload > decodeSubackPayload ( ByteBuf buffer , int bytesRemainingInVariablePart ) { final List < Integer > grantedQos = new ArrayList < Integer > ( ) ; int numberOfBytesConsumed = <int> ; while ( numberOfBytesConsumed < bytesRemainingInVariablePart ) { int qos = buffer . readUnsignedByte ( ) & <hex> ; numberOfBytesConsumed + + ; grantedQos . add ( qos ) ; } return new Result < MqttSubAckPayload > ( new MqttSubAckPayload ( grantedQos ) , numberOfBytesConsumed ) ; } private static Result < MqttUnsubscribePayload > decodeUnsubscribePayload ( ByteBuf buffer , int bytesRemainingInVariablePart ) { final List < String > unsubscribeTopics = new ArrayList < String > ( ) ; int numberOfBytesConsumed = <int> ; while ( numberOfBytesConsumed < bytesRemainingInVariablePart ) { final Result < String > decodedTopicName = decodeString ( buffer ) ; numberOfBytesConsumed + = decodedTopicName . numberOfBytesConsumed ; unsubscribeTopics . add ( decodedTopicName . value ) ; } return new Result < MqttUnsubscribePayload > ( new MqttUnsubscribePayload ( unsubscribeTopics ) , numberOfBytesConsumed ) ; } private static Result < ByteBuf > decodePublishPayload ( ByteBuf buffer , int bytesRemainingInVariablePart ) { ByteBuf b = buffer . readSlice ( bytesRemainingInVariablePart ) . retain ( ) ; return new Result < ByteBuf > ( b , bytesRemainingInVariablePart ) ; } private static Result < String > decodeString ( ByteBuf buffer ) { return decodeString ( buffer , <int> , Integer . MAX_VALUE ) ; } private static Result < String > decodeAsciiString ( ByteBuf buffer ) { Result < String > result = decodeString ( buffer , <int> , Integer . MAX_VALUE ) ; final String s = result . value ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { if ( s . charAt ( i ) > <int> ) { return new Result < String > ( null , result . numberOfBytesConsumed ) ; } } return new Result < String > ( s , result . numberOfBytesConsumed ) ; } private static Result < String > decodeString ( ByteBuf buffer , int minBytes , int maxBytes ) { final Result < Integer > decodedSize = decodeMsbLsb ( buffer ) ; int size = decodedSize . value ; int numberOfBytesConsumed = decodedSize . numberOfBytesConsumed ; if ( size < minBytes | | size > maxBytes ) { buffer . skipBytes ( size ) ; numberOfBytesConsumed + = size ; return new Result < String > ( null , numberOfBytesConsumed ) ; } ByteBuf buf = buffer . readBytes ( size ) ; numberOfBytesConsumed + = size ; return new Result < String > ( buf . toString ( CharsetUtil . UTF_8 ) , numberOfBytesConsumed ) ; } private static Result < Integer > decodeMsbLsb ( ByteBuf buffer ) { return decodeMsbLsb ( buffer , <int> , <int> ) ; } private static Result < Integer > decodeMsbLsb ( ByteBuf buffer , int min , int max ) { short msbSize = buffer . readUnsignedByte ( ) ; short lsbSize = buffer . readUnsignedByte ( ) ; final int numberOfBytesConsumed = <int> ; int result = msbSize < < <int> | lsbSize ; if ( result < min | | result > max ) { result = - <int> ; } return new Result < Integer > ( result , numberOfBytesConsumed ) ; } private static final class Result < T > { private final T value ; private final int numberOfBytesConsumed ; Result ( T value , int numberOfBytesConsumed ) { this . value = value ; this . numberOfBytesConsumed = numberOfBytesConsumed ; } } } 
