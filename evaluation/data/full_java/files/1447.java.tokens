package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; import com . google . common . base . Joiner ; import org . junit . Test ; import static org . junit . Assert . * ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . utils . ByteBufferUtil ; public class RangeTombstoneListTest { private static final ClusteringComparator cmp = new ClusteringComparator ( Int32Type . instance ) ; @Test public void sortedAdditionTest ( ) { sortedAdditionTest ( <int> ) ; sortedAdditionTest ( <int> ) ; } private void sortedAdditionTest ( int initialCapacity ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , initialCapacity ) ; RangeTombstone rt1 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt2 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt3 = rt ( <int> , <int> , <int> ) ; l . add ( rt1 ) ; l . add ( rt2 ) ; l . add ( rt3 ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rt1 , iter . next ( ) ) ; assertRT ( rt2 , iter . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void nonSortedAdditionTest ( ) { nonSortedAdditionTest ( <int> ) ; nonSortedAdditionTest ( <int> ) ; } private void nonSortedAdditionTest ( int initialCapacity ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , initialCapacity ) ; RangeTombstone rt1 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt2 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt3 = rt ( <int> , <int> , <int> ) ; l . add ( rt2 ) ; l . add ( rt1 ) ; l . add ( rt3 ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rt1 , iter . next ( ) ) ; assertRT ( rt2 , iter . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void overlappingAdditionTest ( ) { overlappingAdditionTest ( <int> ) ; overlappingAdditionTest ( <int> ) ; } private void overlappingAdditionTest ( int initialCapacity ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , initialCapacity ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; RangeTombstoneList l2 = new RangeTombstoneList ( cmp , initialCapacity ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , l2 . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; } @Test public void largeAdditionTest ( ) { int N = <int> ; RangeTombstoneList l = new RangeTombstoneList ( cmp , N ) ; for ( int i = <int> ; i < N ; i + + ) l . add ( rt ( <int> * i + <int> , <int> * i + <int> , <int> ) ) ; assertEquals ( l . size ( ) , N ) ; l . add ( rt ( <int> , <int> * N + <int> , <int> ) ) ; } @Test public void simpleOverlapTest ( ) { RangeTombstoneList l1 = new RangeTombstoneList ( cmp , <int> ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter1 = l1 . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter1 . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter1 . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter1 . next ( ) ) ; assert ! iter1 . hasNext ( ) ; RangeTombstoneList l2 = new RangeTombstoneList ( cmp , <int> ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter2 = l2 . iterator ( ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter2 . next ( ) ) ; assert ! iter2 . hasNext ( ) ; } @Test public void overlappingPreviousEndEqualsStartTest ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . size ( ) ) ; } @Test public void searchTest ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( - <int> ) ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( <int> ) ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( <int> ) ) ) ; } @Test public void addAllTest ( ) { RangeTombstoneList l1 = new RangeTombstoneList ( cmp , <int> ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; RangeTombstoneList l2 = new RangeTombstoneList ( cmp , <int> ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . addAll ( l2 ) ; Iterator < RangeTombstone > iter = l1 . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rtei ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void addAllSequentialTest ( ) { RangeTombstoneList l1 = new RangeTombstoneList ( cmp , <int> ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; RangeTombstoneList l2 = new RangeTombstoneList ( cmp , <int> ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . addAll ( l2 ) ; Iterator < RangeTombstone > iter = l1 . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void addAllIncludedTest ( ) { RangeTombstoneList l1 = new RangeTombstoneList ( cmp , <int> ) ; l1 . add ( rt ( <int> , <int> , <int> ) ) ; RangeTombstoneList l2 = new RangeTombstoneList ( cmp , <int> ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l2 . add ( rt ( <int> , <int> , <int> ) ) ; l1 . addAll ( l2 ) ; Iterator < RangeTombstone > iter = l1 . iterator ( ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void addAllBugFrom9799 ( ) { RangeTombstoneList l1 = fromString ( <str> ) ; RangeTombstoneList l2 = fromString ( <str> ) ; l1 . addAll ( l2 ) ; assertValid ( l1 ) ; } private RangeTombstoneList makeRandom ( Random rand , int size , int maxItSize , int maxItDistance , int maxMarkedAt ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , size ) ; int prevStart = - <int> ; int prevEnd = <int> ; boolean prevStartInclusive = false ; boolean prevEndInclusive = false ; for ( int i = <int> ; i < size ; i + + ) { int nextStart = prevEnd + rand . nextInt ( maxItDistance ) ; int nextEnd = nextStart + rand . nextInt ( maxItSize ) ; boolean startInclusive = rand . nextBoolean ( ) ; boolean endInclusive = rand . nextBoolean ( ) ; if ( prevEnd = = nextStart ) startInclusive = ! prevEndInclusive ; if ( nextStart = = nextEnd ) { if ( startInclusive ) endInclusive = true ; else nextEnd + = <int> ; } l . add ( rt ( nextStart , startInclusive , nextEnd , endInclusive , rand . nextInt ( maxMarkedAt ) ) ) ; prevStart = nextStart ; prevEnd = nextEnd ; prevStartInclusive = startInclusive ; prevEndInclusive = endInclusive ; } return l ; } @Test public void addAllRandomTest ( ) throws Throwable { int TEST_COUNT = <int> ; int MAX_LIST_SIZE = <int> ; int MAX_IT_SIZE = <int> ; int MAX_IT_DISTANCE = <int> ; int MAX_MARKEDAT = <int> ; long seed = System . nanoTime ( ) ; Random rand = new Random ( seed ) ; for ( int i = <int> ; i < TEST_COUNT ; i + + ) { RangeTombstoneList l1 = makeRandom ( rand , rand . nextInt ( MAX_LIST_SIZE ) + <int> , rand . nextInt ( MAX_IT_SIZE ) + <int> , rand . nextInt ( MAX_IT_DISTANCE ) + <int> , rand . nextInt ( MAX_MARKEDAT ) + <int> ) ; RangeTombstoneList l2 = makeRandom ( rand , rand . nextInt ( MAX_LIST_SIZE ) + <int> , rand . nextInt ( MAX_IT_SIZE ) + <int> , rand . nextInt ( MAX_IT_DISTANCE ) + <int> , rand . nextInt ( MAX_MARKEDAT ) + <int> ) ; RangeTombstoneList l1Initial = l1 . copy ( ) ; try { l1 . addAll ( l2 ) ; assertValid ( l1 ) ; } catch ( Throwable e ) { System . out . println ( <str> ) ; System . out . println ( <str> + toString ( l1Initial ) ) ; System . out . println ( <str> + toString ( l2 ) ) ; System . out . println ( <str> + seed ) ; throw e ; } } } @Test public void nonSortedAdditionTestWithOneTombstoneWithEmptyEnd ( ) { nonSortedAdditionTestWithOneRangeWithEmptyEnd ( <int> ) ; nonSortedAdditionTestWithOneRangeWithEmptyEnd ( <int> ) ; } private static void nonSortedAdditionTestWithOneRangeWithEmptyEnd ( int initialCapacity ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , initialCapacity ) ; RangeTombstone rt1 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt2 = rt ( <int> , <int> , <int> ) ; RangeTombstone rt3 = atLeast ( <int> , <int> , <int> ) ; l . add ( rt2 ) ; l . add ( rt3 ) ; l . add ( rt1 ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rt1 , iter . next ( ) ) ; assertRT ( rt2 , iter . next ( ) ) ; assertRT ( rt3 , iter . next ( ) ) ; assert ! iter . hasNext ( ) ; } @Test public void addRangeWithEmptyEndWitchIncludeExistingRange ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( atLeast ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addRangeWithEmptyStartAndEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( atMost ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( atMost ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addRangeWithEmptyEndToRangeWithEmptyStartAndEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( new RangeTombstone ( Slice . ALL , new DeletionTime ( <int> , <int> ) ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( lessThan ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( atLeast ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addRangeWithEmptyEndWitchIncludeExistingRangeWithEmptyEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( atLeast ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addIncludedRangeToRangeWithEmptyEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( greaterThan ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addIncludedRangeWithEmptyEndToRangeWithEmptyEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( atLeast ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addRangeWithEmptyEndWitchOverlapExistingRange ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rtie ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( atLeast ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void addOverlappingRangeToRangeWithEmptyEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; Iterator < RangeTombstone > iter = l . iterator ( ) ; assertRT ( rt ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertRT ( greaterThan ( <int> , <int> , <int> ) , iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; } @Test public void searchTestWithEmptyStart ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( atMost ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( - <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( <int> ) ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( <int> ) ) ) ; } @Test public void searchTestWithRangeWithEmptyEnd ( ) { RangeTombstoneList l = new RangeTombstoneList ( cmp , <int> ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( rt ( <int> , <int> , <int> ) ) ; l . add ( atLeast ( <int> , <int> , <int> ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( - <int> ) ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( null , l . searchDeletionTime ( clustering ( <int> ) ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; assertEquals ( <int> , l . searchDeletionTime ( clustering ( <int> ) ) . markedForDeleteAt ( ) ) ; } private static void assertRT ( RangeTombstone expected , RangeTombstone actual ) { assertTrue ( String . format ( <str> , toString ( expected ) , toString ( actual ) ) , cmp . compare ( expected . deletedSlice ( ) . start ( ) , actual . deletedSlice ( ) . start ( ) ) = = <int> ) ; assertTrue ( String . format ( <str> , toString ( expected ) , toString ( actual ) ) , cmp . compare ( expected . deletedSlice ( ) . end ( ) , actual . deletedSlice ( ) . end ( ) ) = = <int> ) ; assertEquals ( String . format ( <str> , toString ( expected ) , toString ( actual ) ) , expected . deletionTime ( ) , actual . deletionTime ( ) ) ; } private static void assertValid ( RangeTombstoneList l ) { if ( l . isEmpty ( ) ) return ; Iterator < RangeTombstone > iter = l . iterator ( ) ; Slice prev = iter . next ( ) . deletedSlice ( ) ; assertFalse ( <str> + prev . toString ( cmp ) , prev . isEmpty ( cmp ) ) ; while ( iter . hasNext ( ) ) { Slice curr = iter . next ( ) . deletedSlice ( ) ; assertFalse ( <str> + curr . toString ( cmp ) , curr . isEmpty ( cmp ) ) ; assertTrue ( <str> + prev . toString ( cmp ) + curr . toString ( cmp ) , cmp . compare ( prev . end ( ) , curr . start ( ) ) < = <int> ) ; } } private static String toString ( RangeTombstone rt ) { return String . format ( <str> , rt . deletedSlice ( ) . toString ( cmp ) , rt . deletionTime ( ) . markedForDeleteAt ( ) ) ; } private static String toString ( RangeTombstoneList l ) { String [ ] ranges = new String [ l . size ( ) ] ; int i = <int> ; for ( RangeTombstone rt : l ) ranges [ i + + ] = toString ( rt ) ; return <str> + Joiner . on ( <str> ) . join ( ranges ) + <str> ; } private static RangeTombstone rangeFromString ( String range ) { Matcher matcher = Pattern . compile ( <str> ) . matcher ( range . trim ( ) ) ; matcher . matches ( ) ; boolean isOpenInclusive = matcher . group ( <int> ) . equals ( <str> ) ; int start = Integer . valueOf ( matcher . group ( <int> ) ) ; int end = Integer . valueOf ( matcher . group ( <int> ) ) ; boolean isCloseInclusive = matcher . group ( <int> ) . equals ( <str> ) ; long timestamp = Long . valueOf ( matcher . group ( <int> ) ) ; return rt ( start , isOpenInclusive , end , isCloseInclusive , timestamp ) ; } private static RangeTombstoneList fromString ( String str ) { str = str . trim ( ) ; String [ ] ranges = str . substring ( <int> , str . length ( ) - <int> ) . split ( <str> , <int> ) ; RangeTombstoneList l = new RangeTombstoneList ( cmp , ranges . length ) ; for ( String range : ranges ) l . add ( rangeFromString ( range ) ) ; return l ; } private static Clustering clustering ( int i ) { return new Clustering ( bb ( i ) ) ; } private static ByteBuffer bb ( int i ) { return ByteBufferUtil . bytes ( i ) ; } private static RangeTombstone rt ( int start , int end , long tstamp ) { return rt ( start , end , tstamp , <int> ) ; } private static RangeTombstone rt ( int start , boolean startInclusive , int end , boolean endInclusive , long tstamp ) { return new RangeTombstone ( Slice . make ( Slice . Bound . create ( cmp , true , startInclusive , start ) , Slice . Bound . create ( cmp , false , endInclusive , end ) ) , new DeletionTime ( tstamp , <int> ) ) ; } private static RangeTombstone rt ( int start , int end , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . inclusiveStartOf ( bb ( start ) ) , Slice . Bound . inclusiveEndOf ( bb ( end ) ) ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone rtei ( int start , int end , long tstamp ) { return rtei ( start , end , tstamp , <int> ) ; } private static RangeTombstone rtei ( int start , int end , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . exclusiveStartOf ( bb ( start ) ) , Slice . Bound . inclusiveEndOf ( bb ( end ) ) ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone rtie ( int start , int end , long tstamp ) { return rtie ( start , end , tstamp , <int> ) ; } private static RangeTombstone rtie ( int start , int end , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . inclusiveStartOf ( bb ( start ) ) , Slice . Bound . exclusiveEndOf ( bb ( end ) ) ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone atLeast ( int start , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . inclusiveStartOf ( bb ( start ) ) , Slice . Bound . TOP ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone atMost ( int end , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . BOTTOM , Slice . Bound . inclusiveEndOf ( bb ( end ) ) ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone lessThan ( int end , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . BOTTOM , Slice . Bound . exclusiveEndOf ( bb ( end ) ) ) , new DeletionTime ( tstamp , delTime ) ) ; } private static RangeTombstone greaterThan ( int start , long tstamp , int delTime ) { return new RangeTombstone ( Slice . make ( Slice . Bound . exclusiveStartOf ( bb ( start ) ) , Slice . Bound . TOP ) , new DeletionTime ( tstamp , delTime ) ) ; } } 
