package org . elasticsearch . plugins ; import org . apache . lucene . analysis . util . CharFilterFactory ; import org . apache . lucene . analysis . util . TokenFilterFactory ; import org . apache . lucene . analysis . util . TokenizerFactory ; import org . apache . lucene . codecs . Codec ; import org . apache . lucene . codecs . DocValuesFormat ; import org . apache . lucene . codecs . PostingsFormat ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . cluster . node . info . PluginsAndModules ; import org . elasticsearch . bootstrap . JarHell ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . component . LifecycleComponent ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexModule ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . net . URL ; import java . net . URLClassLoader ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . common . io . FileSystemUtils . isAccessibleDirectory ; public class PluginsService extends AbstractComponent { private final List < Tuple < PluginInfo , Plugin > > plugins ; private final PluginsAndModules info ; private final Map < Plugin , List < OnModuleReference > > onModuleReferences ; static class OnModuleReference { public final Class < ? extends Module > moduleClass ; public final Method onModuleMethod ; OnModuleReference ( Class < ? extends Module > moduleClass , Method onModuleMethod ) { this . moduleClass = moduleClass ; this . onModuleMethod = onModuleMethod ; } } public PluginsService ( Settings settings , Path modulesDirectory , Path pluginsDirectory , Collection < Class < ? extends Plugin > > classpathPlugins ) { super ( settings ) ; info = new PluginsAndModules ( ) ; List < Tuple < PluginInfo , Plugin > > pluginsLoaded = new ArrayList < > ( ) ; for ( Class < ? extends Plugin > pluginClass : classpathPlugins ) { Plugin plugin = loadPlugin ( pluginClass , settings ) ; PluginInfo pluginInfo = new PluginInfo ( plugin . name ( ) , plugin . description ( ) , false , <str> , true , pluginClass . getName ( ) , false ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , pluginInfo ) ; } pluginsLoaded . add ( new Tuple < > ( pluginInfo , plugin ) ) ; info . addPlugin ( pluginInfo ) ; } if ( modulesDirectory ! = null ) { try { List < Bundle > bundles = getModuleBundles ( modulesDirectory ) ; List < Tuple < PluginInfo , Plugin > > loaded = loadBundles ( bundles ) ; pluginsLoaded . addAll ( loaded ) ; for ( Tuple < PluginInfo , Plugin > module : loaded ) { info . addModule ( module . v1 ( ) ) ; } } catch ( IOException ex ) { throw new IllegalStateException ( <str> , ex ) ; } } if ( pluginsDirectory ! = null ) { try { List < Bundle > bundles = getPluginBundles ( pluginsDirectory ) ; List < Tuple < PluginInfo , Plugin > > loaded = loadBundles ( bundles ) ; pluginsLoaded . addAll ( loaded ) ; for ( Tuple < PluginInfo , Plugin > plugin : loaded ) { info . addPlugin ( plugin . v1 ( ) ) ; } } catch ( IOException ex ) { throw new IllegalStateException ( <str> , ex ) ; } } plugins = Collections . unmodifiableList ( pluginsLoaded ) ; Map < String , Plugin > jvmPlugins = new HashMap < > ( ) ; List < String > sitePlugins = new ArrayList < > ( ) ; for ( Tuple < PluginInfo , Plugin > tuple : plugins ) { PluginInfo info = tuple . v1 ( ) ; if ( info . isJvm ( ) ) { jvmPlugins . put ( info . getName ( ) , tuple . v2 ( ) ) ; } if ( info . isSite ( ) ) { sitePlugins . add ( info . getName ( ) ) ; } } String [ ] mandatoryPlugins = settings . getAsArray ( <str> , null ) ; if ( mandatoryPlugins ! = null ) { Set < String > missingPlugins = new HashSet < > ( ) ; for ( String mandatoryPlugin : mandatoryPlugins ) { if ( ! jvmPlugins . containsKey ( mandatoryPlugin ) & & ! sitePlugins . contains ( mandatoryPlugin ) & & ! missingPlugins . contains ( mandatoryPlugin ) ) { missingPlugins . add ( mandatoryPlugin ) ; } } if ( ! missingPlugins . isEmpty ( ) ) { throw new ElasticsearchException ( <str> + Strings . collectionToDelimitedString ( missingPlugins , <str> ) + <str> ) ; } } Set < String > moduleNames = new HashSet < > ( ) ; Set < String > jvmPluginNames = new HashSet < > ( ) ; for ( PluginInfo moduleInfo : info . getModuleInfos ( ) ) { moduleNames . add ( moduleInfo . getName ( ) ) ; } for ( PluginInfo pluginInfo : info . getPluginInfos ( ) ) { jvmPluginNames . add ( pluginInfo . getName ( ) ) ; } logger . info ( <str> , moduleNames , jvmPluginNames , sitePlugins ) ; Map < Plugin , List < OnModuleReference > > onModuleReferences = new HashMap < > ( ) ; for ( Plugin plugin : jvmPlugins . values ( ) ) { List < OnModuleReference > list = new ArrayList < > ( ) ; for ( Method method : plugin . getClass ( ) . getMethods ( ) ) { if ( ! method . getName ( ) . equals ( <str> ) ) { continue ; } if ( method . getParameterTypes ( ) . length = = <int> & & method . getParameterTypes ( ) [ <int> ] . equals ( IndexModule . class ) ) { continue ; } if ( method . getParameterTypes ( ) . length = = <int> | | method . getParameterTypes ( ) . length > <int> ) { logger . warn ( <str> , plugin . name ( ) ) ; continue ; } Class moduleClass = method . getParameterTypes ( ) [ <int> ] ; if ( ! Module . class . isAssignableFrom ( moduleClass ) ) { logger . warn ( <str> , plugin . name ( ) , moduleClass ) ; continue ; } list . add ( new OnModuleReference ( moduleClass , method ) ) ; } if ( ! list . isEmpty ( ) ) { onModuleReferences . put ( plugin , list ) ; } } this . onModuleReferences = Collections . unmodifiableMap ( onModuleReferences ) ; } private List < Tuple < PluginInfo , Plugin > > plugins ( ) { return plugins ; } public void processModules ( Iterable < Module > modules ) { for ( Module module : modules ) { processModule ( module ) ; } } public void processModule ( Module module ) { for ( Tuple < PluginInfo , Plugin > plugin : plugins ( ) ) { List < OnModuleReference > references = onModuleReferences . get ( plugin . v2 ( ) ) ; if ( references ! = null ) { for ( OnModuleReference reference : references ) { if ( reference . moduleClass . isAssignableFrom ( module . getClass ( ) ) ) { try { reference . onModuleMethod . invoke ( plugin . v2 ( ) , module ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { logger . warn ( <str> , e , plugin . v2 ( ) . name ( ) ) ; throw new ElasticsearchException ( <str> , e ) ; } catch ( Exception e ) { logger . warn ( <str> , e , plugin . v2 ( ) . name ( ) ) ; throw e ; } } } } } } public Settings updatedSettings ( ) { Map < String , String > foundSettings = new HashMap < > ( ) ; final Settings . Builder builder = Settings . settingsBuilder ( ) ; for ( Tuple < PluginInfo , Plugin > plugin : plugins ) { Settings settings = plugin . v2 ( ) . additionalSettings ( ) ; for ( String setting : settings . getAsMap ( ) . keySet ( ) ) { String oldPlugin = foundSettings . put ( setting , plugin . v1 ( ) . getName ( ) ) ; if ( oldPlugin ! = null ) { throw new IllegalArgumentException ( <str> + setting + <str> + <str> + plugin . v1 ( ) . getName ( ) + <str> + oldPlugin + <str> ) ; } } builder . put ( settings ) ; } return builder . put ( this . settings ) . build ( ) ; } public Collection < Module > nodeModules ( ) { List < Module > modules = new ArrayList < > ( ) ; for ( Tuple < PluginInfo , Plugin > plugin : plugins ) { modules . addAll ( plugin . v2 ( ) . nodeModules ( ) ) ; } return modules ; } public Collection < Class < ? extends LifecycleComponent > > nodeServices ( ) { List < Class < ? extends LifecycleComponent > > services = new ArrayList < > ( ) ; for ( Tuple < PluginInfo , Plugin > plugin : plugins ) { services . addAll ( plugin . v2 ( ) . nodeServices ( ) ) ; } return services ; } public void onIndexModule ( IndexModule indexModule ) { for ( Tuple < PluginInfo , Plugin > plugin : plugins ) { plugin . v2 ( ) . onIndexModule ( indexModule ) ; } } public PluginsAndModules info ( ) { return info ; } static class Bundle { List < PluginInfo > plugins = new ArrayList < > ( ) ; List < URL > urls = new ArrayList < > ( ) ; } static List < Bundle > getModuleBundles ( Path modulesDirectory ) throws IOException { if ( Files . notExists ( modulesDirectory ) ) { return Collections . emptyList ( ) ; } List < Bundle > bundles = new ArrayList < > ( ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( modulesDirectory ) ) { for ( Path module : stream ) { if ( FileSystemUtils . isHidden ( module ) ) { continue ; } PluginInfo info = PluginInfo . readFromProperties ( module ) ; if ( ! info . isJvm ( ) ) { throw new IllegalStateException ( <str> + info ) ; } if ( ! info . isIsolated ( ) ) { throw new IllegalStateException ( <str> + info ) ; } Bundle bundle = new Bundle ( ) ; bundle . plugins . add ( info ) ; try ( DirectoryStream < Path > jarStream = Files . newDirectoryStream ( module , <str> ) ) { for ( Path jar : jarStream ) { bundle . urls . add ( jar . toRealPath ( ) . toUri ( ) . toURL ( ) ) ; } } bundles . add ( bundle ) ; } } return bundles ; } static List < Bundle > getPluginBundles ( Path pluginsDirectory ) throws IOException { ESLogger logger = Loggers . getLogger ( PluginsService . class ) ; if ( ! isAccessibleDirectory ( pluginsDirectory , logger ) ) { return Collections . emptyList ( ) ; } List < Bundle > bundles = new ArrayList < > ( ) ; bundles . add ( new Bundle ( ) ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( pluginsDirectory ) ) { for ( Path plugin : stream ) { if ( FileSystemUtils . isHidden ( plugin ) ) { logger . trace ( <str> , plugin . toAbsolutePath ( ) ) ; continue ; } logger . trace ( <str> , plugin . toAbsolutePath ( ) ) ; final PluginInfo info ; try { info = PluginInfo . readFromProperties ( plugin ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> + plugin . getFileName ( ) + <str> , e ) ; } List < URL > urls = new ArrayList < > ( ) ; if ( info . isJvm ( ) ) { try ( DirectoryStream < Path > jarStream = Files . newDirectoryStream ( plugin , <str> ) ) { for ( Path jar : jarStream ) { urls . add ( jar . toRealPath ( ) . toUri ( ) . toURL ( ) ) ; } } } final Bundle bundle ; if ( info . isJvm ( ) & & info . isIsolated ( ) = = false ) { bundle = bundles . get ( <int> ) ; } else { bundle = new Bundle ( ) ; bundles . add ( bundle ) ; } bundle . plugins . add ( info ) ; bundle . urls . addAll ( urls ) ; } } return bundles ; } private List < Tuple < PluginInfo , Plugin > > loadBundles ( List < Bundle > bundles ) { List < Tuple < PluginInfo , Plugin > > plugins = new ArrayList < > ( ) ; for ( Bundle bundle : bundles ) { try { final List < URL > jars = new ArrayList < > ( ) ; jars . addAll ( Arrays . asList ( JarHell . parseClassPath ( ) ) ) ; jars . addAll ( bundle . urls ) ; JarHell . checkJarHell ( jars . toArray ( new URL [ <int> ] ) ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> + bundle . urls + <str> , e ) ; } ClassLoader loader = URLClassLoader . newInstance ( bundle . urls . toArray ( new URL [ <int> ] ) , getClass ( ) . getClassLoader ( ) ) ; for ( PluginInfo pluginInfo : bundle . plugins ) { final Plugin plugin ; if ( pluginInfo . isJvm ( ) ) { reloadLuceneSPI ( loader ) ; Class < ? extends Plugin > pluginClass = loadPluginClass ( pluginInfo . getClassname ( ) , loader ) ; plugin = loadPlugin ( pluginClass , settings ) ; } else { plugin = new SitePlugin ( pluginInfo . getName ( ) , pluginInfo . getDescription ( ) ) ; } plugins . add ( new Tuple < > ( pluginInfo , plugin ) ) ; } } return Collections . unmodifiableList ( plugins ) ; } static void reloadLuceneSPI ( ClassLoader loader ) { PostingsFormat . reloadPostingsFormats ( loader ) ; DocValuesFormat . reloadDocValuesFormats ( loader ) ; Codec . reloadCodecs ( loader ) ; CharFilterFactory . reloadCharFilters ( loader ) ; TokenFilterFactory . reloadTokenFilters ( loader ) ; TokenizerFactory . reloadTokenizers ( loader ) ; } private Class < ? extends Plugin > loadPluginClass ( String className , ClassLoader loader ) { try { return loader . loadClass ( className ) . asSubclass ( Plugin . class ) ; } catch ( ClassNotFoundException e ) { throw new ElasticsearchException ( <str> + className + <str> , e ) ; } } private Plugin loadPlugin ( Class < ? extends Plugin > pluginClass , Settings settings ) { try { try { return pluginClass . getConstructor ( Settings . class ) . newInstance ( settings ) ; } catch ( NoSuchMethodException e ) { try { return pluginClass . getConstructor ( ) . newInstance ( ) ; } catch ( NoSuchMethodException e1 ) { throw new ElasticsearchException ( <str> + pluginClass + <str> + <str> + <str> ) ; } } } catch ( Throwable e ) { throw new ElasticsearchException ( <str> + pluginClass . getName ( ) + <str> , e ) ; } } } 
