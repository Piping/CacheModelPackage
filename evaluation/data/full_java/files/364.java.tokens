package org . apache . cassandra . db . commitlog ; import org . apache . cassandra . utils . NoSpamLogger ; import org . apache . cassandra . utils . concurrent . WaitQueue ; import org . slf4j . * ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import static org . apache . cassandra . db . commitlog . CommitLogSegment . Allocation ; public abstract class AbstractCommitLogService { private Thread thread ; private volatile boolean shutdown = false ; protected volatile long lastSyncedAt = System . currentTimeMillis ( ) ; private final AtomicLong written = new AtomicLong ( <int> ) ; protected final AtomicLong pending = new AtomicLong ( <int> ) ; protected final WaitQueue syncComplete = new WaitQueue ( ) ; protected final Semaphore haveWork = new Semaphore ( <int> ) ; final CommitLog commitLog ; private final String name ; private final long pollIntervalMillis ; private static final Logger logger = LoggerFactory . getLogger ( AbstractCommitLogService . class ) ; AbstractCommitLogService ( final CommitLog commitLog , final String name , final long pollIntervalMillis ) { this . commitLog = commitLog ; this . name = name ; this . pollIntervalMillis = pollIntervalMillis ; } void start ( ) { if ( pollIntervalMillis < <int> ) throw new IllegalArgumentException ( String . format ( <str> , pollIntervalMillis ) ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { long firstLagAt = <int> ; long totalSyncDuration = <int> ; long syncExceededIntervalBy = <int> ; int lagCount = <int> ; int syncCount = <int> ; boolean run = true ; while ( run ) { try { run = ! shutdown ; long syncStarted = System . currentTimeMillis ( ) ; commitLog . sync ( shutdown ) ; lastSyncedAt = syncStarted ; syncComplete . signalAll ( ) ; long now = System . currentTimeMillis ( ) ; long sleep = syncStarted + pollIntervalMillis - now ; if ( sleep < <int> ) { if ( firstLagAt = = <int> ) { firstLagAt = now ; totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = <int> ; } syncExceededIntervalBy - = sleep ; lagCount + + ; } syncCount + + ; totalSyncDuration + = now - syncStarted ; if ( firstLagAt > <int> ) { boolean logged = NoSpamLogger . log ( logger , NoSpamLogger . Level . WARN , <int> , TimeUnit . MINUTES , <str> , syncCount , ( now - firstLagAt ) / <int> , String . format ( <str> , ( double ) totalSyncDuration / syncCount ) , lagCount , String . format ( <str> , ( double ) syncExceededIntervalBy / lagCount ) ) ; if ( logged ) firstLagAt = <int> ; } if ( sleep < <int> | | ! run ) continue ; try { haveWork . tryAcquire ( sleep , TimeUnit . MILLISECONDS ) ; haveWork . drainPermits ( ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } } catch ( Throwable t ) { if ( ! CommitLog . handleCommitError ( <str> , t ) ) break ; try { haveWork . tryAcquire ( pollIntervalMillis , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } } } } } ; thread = new Thread ( runnable , name ) ; thread . start ( ) ; } public void finishWriteFor ( Allocation alloc ) { maybeWaitForSync ( alloc ) ; written . incrementAndGet ( ) ; } protected abstract void maybeWaitForSync ( Allocation alloc ) ; public WaitQueue . Signal requestExtraSync ( ) { WaitQueue . Signal signal = syncComplete . register ( ) ; haveWork . release ( <int> ) ; return signal ; } public void shutdown ( ) { shutdown = true ; haveWork . release ( <int> ) ; } public void restartUnsafe ( ) { while ( haveWork . availablePermits ( ) < <int> ) haveWork . release ( ) ; while ( haveWork . availablePermits ( ) > <int> ) { try { haveWork . acquire ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } shutdown = false ; start ( ) ; } public void awaitTermination ( ) throws InterruptedException { thread . join ( ) ; } public long getCompletedTasks ( ) { return written . get ( ) ; } public long getPendingTasks ( ) { return pending . get ( ) ; } } 
