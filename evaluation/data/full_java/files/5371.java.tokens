package org . elasticsearch . action . search ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . search . type . ScrollIdForNode ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . CountDown ; import org . elasticsearch . search . action . SearchServiceTransportAction ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . action . search . type . TransportSearchHelper . parseScrollId ; public class TransportClearScrollAction extends HandledTransportAction < ClearScrollRequest , ClearScrollResponse > { private final ClusterService clusterService ; private final SearchServiceTransportAction searchServiceTransportAction ; @Inject public TransportClearScrollAction ( Settings settings , TransportService transportService , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchServiceTransportAction , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , ClearScrollAction . NAME , threadPool , transportService , actionFilters , indexNameExpressionResolver , ClearScrollRequest : : new ) ; this . clusterService = clusterService ; this . searchServiceTransportAction = searchServiceTransportAction ; } @Override protected void doExecute ( ClearScrollRequest request , final ActionListener < ClearScrollResponse > listener ) { new Async ( request , listener , clusterService . state ( ) ) . run ( ) ; } private class Async { final DiscoveryNodes nodes ; final CountDown expectedOps ; final ClearScrollRequest request ; final List < ScrollIdForNode [ ] > contexts = new ArrayList < > ( ) ; final ActionListener < ClearScrollResponse > listener ; final AtomicReference < Throwable > expHolder ; final AtomicInteger numberOfFreedSearchContexts = new AtomicInteger ( <int> ) ; private Async ( ClearScrollRequest request , ActionListener < ClearScrollResponse > listener , ClusterState clusterState ) { int expectedOps = <int> ; this . nodes = clusterState . nodes ( ) ; if ( request . getScrollIds ( ) . size ( ) = = <int> & & <str> . equals ( request . getScrollIds ( ) . get ( <int> ) ) ) { expectedOps = nodes . size ( ) ; } else { for ( String parsedScrollId : request . getScrollIds ( ) ) { ScrollIdForNode [ ] context = parseScrollId ( parsedScrollId ) . getContext ( ) ; expectedOps + = context . length ; this . contexts . add ( context ) ; } } this . request = request ; this . listener = listener ; this . expHolder = new AtomicReference < > ( ) ; this . expectedOps = new CountDown ( expectedOps ) ; } public void run ( ) { if ( expectedOps . isCountedDown ( ) ) { listener . onResponse ( new ClearScrollResponse ( true , <int> ) ) ; return ; } if ( contexts . isEmpty ( ) ) { for ( final DiscoveryNode node : nodes ) { searchServiceTransportAction . sendClearAllScrollContexts ( node , request , new ActionListener < TransportResponse > ( ) { @Override public void onResponse ( TransportResponse response ) { onFreedContext ( true ) ; } @Override public void onFailure ( Throwable e ) { onFailedFreedContext ( e , node ) ; } } ) ; } } else { for ( ScrollIdForNode [ ] context : contexts ) { for ( ScrollIdForNode target : context ) { final DiscoveryNode node = nodes . get ( target . getNode ( ) ) ; if ( node = = null ) { onFreedContext ( false ) ; continue ; } searchServiceTransportAction . sendFreeContext ( node , target . getScrollId ( ) , request , new ActionListener < SearchServiceTransportAction . SearchFreeContextResponse > ( ) { @Override public void onResponse ( SearchServiceTransportAction . SearchFreeContextResponse freed ) { onFreedContext ( freed . isFreed ( ) ) ; } @Override public void onFailure ( Throwable e ) { onFailedFreedContext ( e , node ) ; } } ) ; } } } } void onFreedContext ( boolean freed ) { if ( freed ) { numberOfFreedSearchContexts . incrementAndGet ( ) ; } if ( expectedOps . countDown ( ) ) { boolean succeeded = expHolder . get ( ) = = null ; listener . onResponse ( new ClearScrollResponse ( succeeded , numberOfFreedSearchContexts . get ( ) ) ) ; } } void onFailedFreedContext ( Throwable e , DiscoveryNode node ) { logger . warn ( <str> , e , node ) ; if ( expectedOps . countDown ( ) ) { listener . onResponse ( new ClearScrollResponse ( false , numberOfFreedSearchContexts . get ( ) ) ) ; } else { expHolder . set ( e ) ; } } } } 
