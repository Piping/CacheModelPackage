package io . netty . buffer ; final class PoolSubpage < T > implements PoolSubpageMetric { final PoolChunk < T > chunk ; private final int memoryMapIdx ; private final int runOffset ; private final int pageSize ; private final long [ ] bitmap ; PoolSubpage < T > prev ; PoolSubpage < T > next ; boolean doNotDestroy ; int elemSize ; private int maxNumElems ; private int bitmapLength ; private int nextAvail ; private int numAvail ; PoolSubpage ( int pageSize ) { chunk = null ; memoryMapIdx = - <int> ; runOffset = - <int> ; elemSize = - <int> ; this . pageSize = pageSize ; bitmap = null ; } PoolSubpage ( PoolSubpage < T > head , PoolChunk < T > chunk , int memoryMapIdx , int runOffset , int pageSize , int elemSize ) { this . chunk = chunk ; this . memoryMapIdx = memoryMapIdx ; this . runOffset = runOffset ; this . pageSize = pageSize ; bitmap = new long [ pageSize > > > <int> ] ; init ( head , elemSize ) ; } void init ( PoolSubpage < T > head , int elemSize ) { doNotDestroy = true ; this . elemSize = elemSize ; if ( elemSize ! = <int> ) { maxNumElems = numAvail = pageSize / elemSize ; nextAvail = <int> ; bitmapLength = maxNumElems > > > <int> ; if ( ( maxNumElems & <int> ) ! = <int> ) { bitmapLength + + ; } for ( int i = <int> ; i < bitmapLength ; i + + ) { bitmap [ i ] = <int> ; } } addToPool ( head ) ; } long allocate ( ) { if ( elemSize = = <int> ) { return toHandle ( <int> ) ; } if ( numAvail = = <int> | | ! doNotDestroy ) { return - <int> ; } final int bitmapIdx = getNextAvail ( ) ; int q = bitmapIdx > > > <int> ; int r = bitmapIdx & <int> ; assert ( bitmap [ q ] > > > r & <int> ) = = <int> ; bitmap [ q ] | = <int> < < r ; if ( - - numAvail = = <int> ) { removeFromPool ( ) ; } return toHandle ( bitmapIdx ) ; } boolean free ( PoolSubpage < T > head , int bitmapIdx ) { if ( elemSize = = <int> ) { return true ; } int q = bitmapIdx > > > <int> ; int r = bitmapIdx & <int> ; assert ( bitmap [ q ] > > > r & <int> ) ! = <int> ; bitmap [ q ] ^ = <int> < < r ; setNextAvail ( bitmapIdx ) ; if ( numAvail + + = = <int> ) { addToPool ( head ) ; return true ; } if ( numAvail ! = maxNumElems ) { return true ; } else { if ( prev = = next ) { return true ; } doNotDestroy = false ; removeFromPool ( ) ; return false ; } } private void addToPool ( PoolSubpage < T > head ) { assert prev = = null & & next = = null ; prev = head ; next = head . next ; next . prev = this ; head . next = this ; } private void removeFromPool ( ) { assert prev ! = null & & next ! = null ; prev . next = next ; next . prev = prev ; next = null ; prev = null ; } private void setNextAvail ( int bitmapIdx ) { nextAvail = bitmapIdx ; } private int getNextAvail ( ) { int nextAvail = this . nextAvail ; if ( nextAvail > = <int> ) { this . nextAvail = - <int> ; return nextAvail ; } return findNextAvail ( ) ; } private int findNextAvail ( ) { final long [ ] bitmap = this . bitmap ; final int bitmapLength = this . bitmapLength ; for ( int i = <int> ; i < bitmapLength ; i + + ) { long bits = bitmap [ i ] ; if ( ~ bits ! = <int> ) { return findNextAvail0 ( i , bits ) ; } } return - <int> ; } private int findNextAvail0 ( int i , long bits ) { final int maxNumElems = this . maxNumElems ; final int baseVal = i < < <int> ; for ( int j = <int> ; j < <int> ; j + + ) { if ( ( bits & <int> ) = = <int> ) { int val = baseVal | j ; if ( val < maxNumElems ) { return val ; } else { break ; } } bits > > > = <int> ; } return - <int> ; } private long toHandle ( int bitmapIdx ) { return <hex> | ( long ) bitmapIdx < < <int> | memoryMapIdx ; } @Override public String toString ( ) { if ( ! doNotDestroy ) { return <str> + memoryMapIdx + <str> ; } return String . valueOf ( <str> ) + memoryMapIdx + <str> + ( maxNumElems - numAvail ) + <str> + maxNumElems + <str> + runOffset + <str> + pageSize + <str> + elemSize + <str> ; } @Override public int maxNumElements ( ) { return maxNumElems ; } @Override public int numAvailable ( ) { return numAvail ; } @Override public int elementSize ( ) { return elemSize ; } @Override public int pageSize ( ) { return pageSize ; } } 
