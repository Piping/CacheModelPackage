package com . badlogic . gdx . graphics . g2d ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Colors ; import com . badlogic . gdx . graphics . g2d . BitmapFont . BitmapFontData ; import com . badlogic . gdx . graphics . g2d . BitmapFont . Glyph ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . Pool . Poolable ; import com . badlogic . gdx . utils . Pools ; public class GlyphLayout implements Poolable { public final Array < GlyphRun > runs = new Array ( ) ; public float width , height ; private final Array < Color > colorStack = new Array ( <int> ) ; public GlyphLayout ( ) { } public GlyphLayout ( BitmapFont font , CharSequence str ) { setText ( font , str ) ; } public GlyphLayout ( BitmapFont font , CharSequence str , Color color , float targetWidth , int halign , boolean wrap ) { setText ( font , str , color , targetWidth , halign , wrap ) ; } public GlyphLayout ( BitmapFont font , CharSequence str , int start , int end , Color color , float targetWidth , int halign , boolean wrap , String truncate ) { setText ( font , str , start , end , color , targetWidth , halign , wrap , truncate ) ; } public void setText ( BitmapFont font , CharSequence str ) { setText ( font , str , <int> , str . length ( ) , font . getColor ( ) , <int> , Align . left , false , null ) ; } public void setText ( BitmapFont font , CharSequence str , Color color , float targetWidth , int halign , boolean wrap ) { setText ( font , str , <int> , str . length ( ) , color , targetWidth , halign , wrap , null ) ; } public void setText ( BitmapFont font , CharSequence str , int start , int end , Color color , float targetWidth , int halign , boolean wrap , String truncate ) { if ( truncate ! = null ) wrap = true ; else if ( targetWidth < = font . data . spaceWidth ) wrap = false ; BitmapFontData fontData = font . data ; boolean markupEnabled = fontData . markupEnabled ; Pool < GlyphRun > glyphRunPool = Pools . get ( GlyphRun . class ) ; Array < GlyphRun > runs = this . runs ; glyphRunPool . freeAll ( runs ) ; runs . clear ( ) ; float x = <int> , y = <int> , width = <int> ; int lines = <int> ; Array < Color > colorStack = this . colorStack ; Color nextColor = color ; colorStack . add ( color ) ; Pool < Color > colorPool = Pools . get ( Color . class ) ; int runStart = start ; outer : while ( true ) { int runEnd = - <int> ; boolean newline = false , colorRun = false ; if ( start = = end ) { if ( runStart = = end ) break ; runEnd = end ; } else { switch ( str . charAt ( start + + ) ) { case <str> : runEnd = start - <int> ; newline = true ; break ; case <str> : if ( markupEnabled ) { int length = parseColorMarkup ( str , start , end , colorPool ) ; if ( length > = <int> ) { runEnd = start - <int> ; start + = length + <int> ; nextColor = colorStack . peek ( ) ; colorRun = true ; } } break ; } } if ( runEnd ! = - <int> ) { if ( runEnd ! = runStart ) { GlyphRun run = glyphRunPool . obtain ( ) ; runs . add ( run ) ; run . color . set ( color ) ; run . x = x ; run . y = y ; fontData . getGlyphs ( run , str , runStart , runEnd , colorRun ) ; float [ ] xAdvances = run . xAdvances . items ; for ( int i = <int> , n = run . xAdvances . size ; i < n ; i + + ) { float xAdvance = xAdvances [ i ] ; x + = xAdvance ; if ( wrap & & x > targetWidth & & i > <int> & & x - xAdvance + ( run . glyphs . get ( i - <int> ) . xoffset + run . glyphs . get ( i - <int> ) . width ) * fontData . scaleX - <float> > targetWidth ) { if ( truncate ! = null ) { truncate ( fontData , run , targetWidth , truncate , i , glyphRunPool ) ; x = run . x + run . width ; break outer ; } int wrapIndex = fontData . getWrapIndex ( run . glyphs , i ) ; if ( ( run . x = = <int> & & wrapIndex = = <int> ) | | wrapIndex > = run . glyphs . size ) { wrapIndex = i - <int> ; } GlyphRun next = wrap ( fontData , run , glyphRunPool , wrapIndex , i ) ; runs . add ( next ) ; width = Math . max ( width , run . x + run . width ) ; x = <int> ; y + = fontData . down ; lines + + ; next . x = <int> ; next . y = y ; i = - <int> ; n = next . xAdvances . size ; xAdvances = next . xAdvances . items ; run = next ; } else run . width + = xAdvance ; } } if ( newline ) { width = Math . max ( width , x ) ; x = <int> ; y + = fontData . down ; lines + + ; } runStart = start ; color = nextColor ; } } width = Math . max ( width , x ) ; for ( int i = <int> , n = colorStack . size ; i < n ; i + + ) colorPool . free ( colorStack . get ( i ) ) ; colorStack . clear ( ) ; if ( ( halign & Align . left ) = = <int> ) { boolean center = ( halign & Align . center ) ! = <int> ; float lineWidth = <int> , lineY = Integer . MIN_VALUE ; int lineStart = <int> , n = runs . size ; for ( int i = <int> ; i < n ; i + + ) { GlyphRun run = runs . get ( i ) ; if ( run . y ! = lineY ) { lineY = run . y ; float shift = targetWidth - lineWidth ; if ( center ) shift / = <int> ; while ( lineStart < i ) runs . get ( lineStart + + ) . x + = shift ; lineWidth = <int> ; } lineWidth + = run . width ; } float shift = targetWidth - lineWidth ; if ( center ) shift / = <int> ; while ( lineStart < n ) runs . get ( lineStart + + ) . x + = shift ; } this . width = width ; this . height = fontData . capHeight + lines * fontData . lineHeight ; } private void truncate ( BitmapFontData fontData , GlyphRun run , float targetWidth , String truncate , int widthIndex , Pool < GlyphRun > glyphRunPool ) { GlyphRun truncateRun = glyphRunPool . obtain ( ) ; fontData . getGlyphs ( truncateRun , truncate , <int> , truncate . length ( ) , true ) ; float truncateWidth = <int> ; for ( int i = <int> , n = truncateRun . xAdvances . size ; i < n ; i + + ) truncateWidth + = truncateRun . xAdvances . get ( i ) ; targetWidth - = truncateWidth ; int count = <int> ; float width = run . x ; while ( count < run . xAdvances . size ) { float xAdvance = run . xAdvances . get ( count ) ; width + = xAdvance ; if ( width > targetWidth ) { run . width = width - run . x - xAdvance ; break ; } count + + ; } if ( count > <int> ) { run . glyphs . truncate ( count - <int> ) ; run . xAdvances . truncate ( count ) ; adjustLastGlyph ( fontData , run ) ; if ( truncateRun . xAdvances . size > <int> ) run . xAdvances . addAll ( truncateRun . xAdvances , <int> , truncateRun . xAdvances . size - <int> ) ; } else { run . glyphs . clear ( ) ; run . xAdvances . clear ( ) ; run . xAdvances . addAll ( truncateRun . xAdvances ) ; if ( truncateRun . xAdvances . size > <int> ) run . width + = truncateRun . xAdvances . get ( <int> ) ; } run . glyphs . addAll ( truncateRun . glyphs ) ; run . width + = truncateWidth ; glyphRunPool . free ( truncateRun ) ; } private GlyphRun wrap ( BitmapFontData fontData , GlyphRun first , Pool < GlyphRun > glyphRunPool , int wrapIndex , int widthIndex ) { GlyphRun second = glyphRunPool . obtain ( ) ; second . color . set ( first . color ) ; int glyphCount = first . glyphs . size ; if ( wrapIndex < glyphCount ) { second . glyphs . addAll ( first . glyphs , wrapIndex , glyphCount - wrapIndex ) ; second . xAdvances . add ( - second . glyphs . first ( ) . xoffset * fontData . scaleX - fontData . padLeft ) ; second . xAdvances . addAll ( first . xAdvances , wrapIndex + <int> , first . xAdvances . size - ( wrapIndex + <int> ) ) ; } while ( widthIndex < wrapIndex ) first . width + = first . xAdvances . get ( widthIndex + + ) ; while ( widthIndex > wrapIndex + <int> ) first . width - = first . xAdvances . get ( - - widthIndex ) ; if ( wrapIndex = = <int> ) { glyphRunPool . free ( first ) ; runs . pop ( ) ; } else { first . glyphs . truncate ( wrapIndex ) ; first . xAdvances . truncate ( wrapIndex + <int> ) ; adjustLastGlyph ( fontData , first ) ; } return second ; } private void adjustLastGlyph ( BitmapFontData fontData , GlyphRun run ) { Glyph last = run . glyphs . peek ( ) ; if ( fontData . isWhitespace ( ( char ) last . id ) ) return ; float width = ( last . xoffset + last . width ) * fontData . scaleX - fontData . padRight ; run . width + = width - run . xAdvances . peek ( ) ; run . xAdvances . set ( run . xAdvances . size - <int> , width ) ; } private int parseColorMarkup ( CharSequence str , int start , int end , Pool < Color > colorPool ) { if ( start = = end ) return - <int> ; switch ( str . charAt ( start ) ) { case <str> : int colorInt = <int> ; for ( int i = start + <int> ; i < end ; i + + ) { char ch = str . charAt ( i ) ; if ( ch = = <str> ) { if ( i < start + <int> | | i > start + <int> ) break ; if ( i - start < = <int> ) { for ( int ii = <int> , nn = <int> - ( i - start ) ; ii < nn ; ii + + ) colorInt = colorInt < < <int> ; colorInt | = <hex> ; } Color color = colorPool . obtain ( ) ; colorStack . add ( color ) ; Color . rgba8888ToColor ( color , colorInt ) ; return i - start ; } if ( ch > = <str> & & ch < = <str> ) colorInt = colorInt * <int> + ( ch - <str> ) ; else if ( ch > = <str> & & ch < = <str> ) colorInt = colorInt * <int> + ( ch - ( <str> - <int> ) ) ; else if ( ch > = <str> & & ch < = <str> ) colorInt = colorInt * <int> + ( ch - ( <str> - <int> ) ) ; else break ; } return - <int> ; case <str> : return - <int> ; case <str> : if ( colorStack . size > <int> ) colorPool . free ( colorStack . pop ( ) ) ; return <int> ; } int colorStart = start ; for ( int i = start + <int> ; i < end ; i + + ) { char ch = str . charAt ( i ) ; if ( ch ! = <str> ) continue ; Color namedColor = Colors . get ( str . subSequence ( colorStart , i ) . toString ( ) ) ; if ( namedColor = = null ) return - <int> ; Color color = colorPool . obtain ( ) ; colorStack . add ( color ) ; color . set ( namedColor ) ; return i - start ; } return - <int> ; } public void reset ( ) { Pools . get ( GlyphRun . class ) . freeAll ( runs ) ; runs . clear ( ) ; width = <int> ; height = <int> ; } public String toString ( ) { if ( runs . size = = <int> ) return <str> ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( width ) ; buffer . append ( <str> ) ; buffer . append ( height ) ; buffer . append ( <str> ) ; for ( int i = <int> , n = runs . size ; i < n ; i + + ) { buffer . append ( runs . get ( i ) . toString ( ) ) ; buffer . append ( <str> ) ; } buffer . setLength ( buffer . length ( ) - <int> ) ; return buffer . toString ( ) ; } static public class GlyphRun implements Poolable { public final Array < Glyph > glyphs = new Array ( ) ; public final FloatArray xAdvances = new FloatArray ( ) ; public float x , y , width ; public final Color color = new Color ( ) ; public void reset ( ) { glyphs . clear ( ) ; xAdvances . clear ( ) ; width = <int> ; } public String toString ( ) { StringBuilder buffer = new StringBuilder ( glyphs . size ) ; Array < Glyph > glyphs = this . glyphs ; for ( int i = <int> , n = glyphs . size ; i < n ; i + + ) { Glyph g = glyphs . get ( i ) ; buffer . append ( ( char ) g . id ) ; } buffer . append ( <str> ) ; buffer . append ( color ) ; buffer . append ( <str> ) ; buffer . append ( x ) ; buffer . append ( <str> ) ; buffer . append ( y ) ; buffer . append ( <str> ) ; buffer . append ( width ) ; return buffer . toString ( ) ; } } } 
