package org . gradle . api . internal . project . antbuilder ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import org . gradle . api . Action ; import org . gradle . api . internal . classloading . GroovySystemLoader ; import org . gradle . api . internal . classloading . GroovySystemLoaderFactory ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . concurrent . Stoppable ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class ClassPathToClassLoaderCache implements Stoppable { private final static Logger LOG = Logging . getLogger ( ClassPathToClassLoaderCache . class ) ; private final FinalizerThread finalizerThread ; private final Lock lock = new ReentrantLock ( ) ; private final Map < ClassPath , CacheEntry > cacheEntries = Maps . newConcurrentMap ( ) ; private final Set < CachedClassLoader > inUseClassLoaders = Sets . newHashSet ( ) ; private final GroovySystemLoaderFactory groovySystemLoaderFactory ; public ClassPathToClassLoaderCache ( GroovySystemLoaderFactory groovySystemLoaderFactory ) { this . groovySystemLoaderFactory = groovySystemLoaderFactory ; this . finalizerThread = new FinalizerThread ( cacheEntries , lock ) ; this . finalizerThread . start ( ) ; } public void stop ( ) { finalizerThread . exit ( ) ; try { finalizerThread . join ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public int size ( ) { return cacheEntries . size ( ) ; } public boolean isEmpty ( ) { return cacheEntries . isEmpty ( ) ; } public void withCachedClassLoader ( ClassPath libClasspath , GroovySystemLoader gradleApiGroovy , GroovySystemLoader antBuilderAdapterGroovy , Factory < ? extends ClassLoader > factory , Action < ? super CachedClassLoader > action ) { CachedClassLoader cachedClassLoader ; lock . lock ( ) ; try { CacheEntry cacheEntry = cacheEntries . get ( libClasspath ) ; cachedClassLoader = maybeGet ( cacheEntry ) ; if ( cachedClassLoader = = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , libClasspath . getAsURIs ( ) ) ) ; } ClassLoader classLoader = factory . create ( ) ; cachedClassLoader = new CachedClassLoader ( libClasspath , classLoader ) ; cacheEntry = new CacheEntry ( libClasspath , cachedClassLoader ) ; GroovySystemLoader groovySystemForLoader = groovySystemLoaderFactory . forClassLoader ( classLoader ) ; Cleanup cleanup = new Cleanup ( libClasspath , cachedClassLoader , finalizerThread . getReferenceQueue ( ) , classLoader , groovySystemForLoader , gradleApiGroovy , antBuilderAdapterGroovy ) ; finalizerThread . putCleanup ( libClasspath , cleanup ) ; cacheEntries . put ( libClasspath , cacheEntry ) ; } else { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , libClasspath . getAsURIs ( ) ) ) ; } } inUseClassLoaders . add ( cachedClassLoader ) ; } finally { lock . unlock ( ) ; } try { action . execute ( cachedClassLoader ) ; } finally { lock . lock ( ) ; try { inUseClassLoaders . remove ( cachedClassLoader ) ; } finally { lock . unlock ( ) ; } } } private CachedClassLoader maybeGet ( CacheEntry cacheEntry ) { return cacheEntry ! = null ? cacheEntry . get ( ) : null ; } } 
