package com . google . common . collect ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . api . SkipThisScenarioException ; import java . util . Random ; public class MultipleSetContainsBenchmark { @Param ( { <str> , <str> , <str> , <str> } ) double emptySetProportion ; @Param ( { <str> , <str> , <str> , <str> } ) double singletonSetProportion ; @Param ( { <str> , <str> } ) double hitRate ; static final Object PRESENT = new Object ( ) ; static final Object ABSENT = new Object ( ) ; @SuppressWarnings ( <str> ) private final ImmutableSet < Object > [ ] sets = new ImmutableSet [ <hex> ] ; private final Object [ ] queries = new Object [ <hex> ] ; @BeforeExperiment void setUp ( ) { if ( emptySetProportion + singletonSetProportion > <float> ) { throw new SkipThisScenarioException ( ) ; } Random rng = new Random ( ) ; for ( int i = <int> ; i < <hex> ; i + + ) { double setSize = rng . nextDouble ( ) ; if ( setSize < emptySetProportion ) { sets [ i ] = ImmutableSet . of ( ) ; } else if ( setSize < emptySetProportion + singletonSetProportion ) { sets [ i ] = ImmutableSet . of ( PRESENT ) ; } else { sets [ i ] = ImmutableSet . of ( PRESENT , new Object ( ) ) ; } if ( rng . nextDouble ( ) < hitRate ) { queries [ i ] = PRESENT ; } else { queries [ i ] = ABSENT ; } } } @Benchmark public boolean contains ( int reps ) { ImmutableSet < Object > [ ] sets = this . sets ; Object [ ] queries = this . queries ; boolean result = false ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & <hex> ; result ^ = sets [ j ] . contains ( queries [ j ] ) ; } return result ; } } 
