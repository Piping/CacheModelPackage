package org . eclipse . debug . internal . ui . viewers . model ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . jface . viewers . TreePath ; public class ChildrenUpdate extends ViewerUpdateMonitor implements IChildrenUpdate { private Object [ ] fElements ; private int fIndex ; private int fLength ; public ChildrenUpdate ( TreeModelContentProvider provider , Object viewerInput , TreePath elementPath , Object element , int index , IElementContentProvider elementContentProvider ) { super ( provider , viewerInput , elementPath , element , elementContentProvider , provider . getPresentationContext ( ) ) ; fIndex = index ; fLength = <int> ; } public ChildrenUpdate ( TreeModelContentProvider provider , Object viewerInput , TreePath elementPath , Object element , int index , int length , IElementContentProvider elementContentProvider ) { super ( provider , viewerInput , elementPath , element , elementContentProvider , provider . getPresentationContext ( ) ) ; fIndex = index ; fLength = length ; } protected void performUpdate ( boolean updateFilterOnly ) { TreeModelContentProvider provider = getContentProvider ( ) ; TreePath elementPath = getElementPath ( ) ; if ( fElements ! = null ) { IInternalTreeModelViewer viewer = provider . getViewer ( ) ; for ( int i = <int> ; i < fElements . length ; i + + ) { int modelIndex = fIndex + i ; Object element = fElements [ i ] ; if ( element ! = null ) { int viewIndex = provider . modelToViewIndex ( elementPath , modelIndex ) ; if ( provider . shouldFilter ( elementPath , element ) ) { if ( provider . addFilteredIndex ( elementPath , modelIndex , element ) ) { if ( ! updateFilterOnly ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( ) + <str> + modelIndex + <str> + viewIndex + <str> + element + <str> ) ; } viewer . remove ( elementPath , viewIndex ) ; } } } else { if ( provider . isFiltered ( elementPath , modelIndex ) ) { provider . clearFilteredChild ( elementPath , modelIndex ) ; if ( ! updateFilterOnly ) { int insertIndex = provider . modelToViewIndex ( elementPath , modelIndex ) ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER ) { DebugUIPlugin . trace ( <str> + getElement ( ) + <str> + modelIndex + <str> + insertIndex + <str> + element + <str> ) ; } viewer . insert ( elementPath , element , insertIndex ) ; } } else if ( ! updateFilterOnly ) { if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + getElement ( ) + <str> + modelIndex + <str> + viewIndex + <str> + element + <str> ) ; } viewer . replace ( elementPath , viewIndex , element ) ; } if ( ! updateFilterOnly ) { TreePath childPath = elementPath . createChildPath ( element ) ; provider . updateHasChildren ( childPath ) ; provider . getStateTracker ( ) . restorePendingStateOnUpdate ( childPath , modelIndex , false , false , false ) ; } } } } if ( ! updateFilterOnly ) { provider . getStateTracker ( ) . restorePendingStateOnUpdate ( elementPath , - <int> , true , true , true ) ; } } else if ( ! updateFilterOnly ) { provider . updateHasChildren ( elementPath ) ; } } @Override protected void performUpdate ( ) { performUpdate ( false ) ; } @Override public void setChild ( Object child , int index ) { if ( fElements = = null ) { fElements = new Object [ fLength ] ; } fElements [ index - fIndex ] = child ; } @Override public synchronized boolean coalesce ( ViewerUpdateMonitor request ) { if ( request instanceof ChildrenUpdate ) { ChildrenUpdate cu = ( ChildrenUpdate ) request ; if ( getElement ( ) . equals ( cu . getElement ( ) ) & & getElementPath ( ) . equals ( cu . getElementPath ( ) ) ) { int end = fIndex + fLength ; int otherStart = cu . getOffset ( ) ; int otherEnd = otherStart + cu . getLength ( ) ; if ( ( otherStart > = fIndex & & otherStart < = end ) | | ( otherEnd > = fIndex & & otherEnd < = end ) ) { fIndex = Math . min ( fIndex , otherStart ) ; end = Math . max ( end , otherEnd ) ; fLength = end - fIndex ; if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + this . toString ( ) ) ; } return true ; } } } return false ; } @Override boolean containsUpdate ( TreePath path ) { return getElementPath ( ) . equals ( path ) ; } @Override public int getLength ( ) { return fLength ; } @Override public int getOffset ( ) { return fIndex ; } @Override void startRequest ( ) { getElementContentProvider ( ) . update ( new IChildrenUpdate [ ] { this } ) ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; buf . append ( getElement ( ) ) ; buf . append ( <str> ) ; buf . append ( getOffset ( ) ) ; buf . append ( <str> ) ; buf . append ( getOffset ( ) + getLength ( ) - <int> ) ; buf . append ( <str> ) ; return buf . toString ( ) ; } @Override int getPriority ( ) { return <int> ; } @Override TreePath getSchedulingPath ( ) { return getElementPath ( ) ; } void setOffset ( int offset ) { fIndex = offset ; } Object [ ] getElements ( ) { return fElements ; } @Override protected boolean doEquals ( ViewerUpdateMonitor update ) { return update instanceof ChildrenUpdate & & ( ( ChildrenUpdate ) update ) . getOffset ( ) = = getOffset ( ) & & ( ( ChildrenUpdate ) update ) . getLength ( ) = = getLength ( ) & & getViewerInput ( ) . equals ( update . getViewerInput ( ) ) & & getElementPath ( ) . equals ( update . getElementPath ( ) ) ; } @Override protected int doHashCode ( ) { return ( int ) Math . pow ( ( getClass ( ) . hashCode ( ) + getViewerInput ( ) . hashCode ( ) + getElementPath ( ) . hashCode ( ) ) * ( getOffset ( ) + <int> ) , getLength ( ) + <int> ) ; } } 
