package io . netty . handler . ssl ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . UnsupportedMessageTypeException ; import org . junit . Test ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLProtocolException ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class SslHandlerTest { @Test public void testTruncatedPacket ( ) throws Exception { SSLEngine engine = SSLContext . getDefault ( ) . createSSLEngine ( ) ; engine . setUseClientMode ( false ) ; EmbeddedChannel ch = new EmbeddedChannel ( new SslHandler ( engine ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; try { ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) ) ; fail ( ) ; } catch ( DecoderException e ) { assertThat ( e . getCause ( ) , is ( instanceOf ( SSLProtocolException . class ) ) ) ; } } @Test ( expected = UnsupportedMessageTypeException . class ) public void testNonByteBufNotPassThrough ( ) throws Exception { SSLEngine engine = SSLContext . getDefault ( ) . createSSLEngine ( ) ; engine . setUseClientMode ( false ) ; EmbeddedChannel ch = new EmbeddedChannel ( new SslHandler ( engine ) ) ; ch . writeOutbound ( new Object ( ) ) ; } } 
