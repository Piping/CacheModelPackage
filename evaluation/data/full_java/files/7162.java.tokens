package org . elasticsearch . search . aggregations . bucket . filter ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Weight ; import org . apache . lucene . util . Bits ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class FilterAggregator extends SingleBucketAggregator { private final Weight filter ; public FilterAggregator ( String name , Query filter , AggregatorFactories factories , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . filter = aggregationContext . searchContext ( ) . searcher ( ) . createNormalizedWeight ( filter , false ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { final Bits bits = Lucene . asSequentialAccessBits ( ctx . reader ( ) . maxDoc ( ) , filter . scorer ( ctx ) ) ; return new LeafBucketCollectorBase ( sub , null ) { @Override public void collect ( int doc , long bucket ) throws IOException { if ( bits . get ( doc ) ) { collectBucket ( sub , doc , bucket ) ; } } } ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { return new InternalFilter ( name , bucketDocCount ( owningBucketOrdinal ) , bucketAggregations ( owningBucketOrdinal ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalFilter ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } public static class Factory extends AggregatorFactory { private final Query filter ; public Factory ( String name , Query filter ) { super ( name , InternalFilter . TYPE . name ( ) ) ; this . filter = filter ; } @Override public Aggregator createInternal ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new FilterAggregator ( name , filter , factories , context , parent , pipelineAggregators , metaData ) ; } } } 
