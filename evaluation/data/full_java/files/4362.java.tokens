package org . eclipse . debug . internal . ui . viewers ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicyFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStatusMonitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . PresentationContext ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . ui . progress . WorkbenchJob ; public abstract class AsynchronousViewer extends StructuredViewer implements Listener { private AsynchronousModel fModel ; private Map < ImageDescriptor , Image > fImageCache = new HashMap < ImageDescriptor , Image > ( ) ; private Map < FontData , Font > fFontCache = new HashMap < FontData , Font > ( ) ; private Map < RGB , Color > fColorCache = new HashMap < RGB , Color > ( ) ; private IPresentationContext fContext ; private ISelection fPendingSelection ; private ISelection fCurrentSelection ; private int [ ] fSetDataIndicies = new int [ <int> ] ; private AbstractUpdatePolicy fUpdatePolicy ; protected static final String OLD_LABEL = <str> ; protected static final String OLD_IMAGE = <str> ; protected AsynchronousViewer ( ) { setContentProvider ( new NullContentProvider ( ) ) ; setUseHashlookup ( true ) ; } @Override public final void setUseHashlookup ( boolean enable ) { Assert . isTrue ( enable ) ; super . setUseHashlookup ( enable ) ; } @Override protected void hookControl ( Control control ) { super . hookControl ( control ) ; control . addListener ( SWT . SetData , this ) ; } public synchronized void dispose ( ) { for ( Image image : fImageCache . values ( ) ) { image . dispose ( ) ; } fImageCache . clear ( ) ; for ( Font font : fFontCache . values ( ) ) { font . dispose ( ) ; } fFontCache . clear ( ) ; for ( Color color : fColorCache . values ( ) ) { color . dispose ( ) ; } fColorCache . clear ( ) ; if ( fModel ! = null ) { fModel . dispose ( ) ; } if ( fUpdatePolicy ! = null ) { fUpdatePolicy . dispose ( ) ; } if ( fContext ! = null ) { ( ( PresentationContext ) fContext ) . dispose ( ) ; } } public void update ( Object element ) { ModelNode [ ] nodes = getModel ( ) . getNodes ( element ) ; if ( nodes ! = null ) { for ( int i = <int> ; i < nodes . length ; i + + ) { updateLabel ( nodes [ i ] ) ; } } } protected void updateLabel ( ModelNode node ) { if ( ! node . getElement ( ) . equals ( getInput ( ) ) ) { getModel ( ) . updateLabel ( node ) ; } } public IPresentationContext getPresentationContext ( ) { return fContext ; } @Override protected synchronized void unmapAllElements ( ) { super . unmapAllElements ( ) ; AsynchronousModel model = getModel ( ) ; if ( model ! = null ) { model . dispose ( ) ; } } @Override protected synchronized void inputChanged ( Object input , Object oldInput ) { fPendingSelection = null ; if ( fCurrentSelection ! = null ) { updateSelection ( new StructuredSelection ( ) ) ; fCurrentSelection = null ; } if ( fUpdatePolicy = = null ) { fUpdatePolicy = createUpdatePolicy ( ) ; fUpdatePolicy . init ( this ) ; } if ( fModel ! = null ) { fModel . dispose ( ) ; } fModel = createModel ( ) ; fModel . init ( input ) ; if ( input ! = null ) { mapElement ( fModel . getRootNode ( ) , getControl ( ) ) ; getControl ( ) . setData ( fModel . getRootNode ( ) . getElement ( ) ) ; } else { unmapAllElements ( ) ; getControl ( ) . setData ( null ) ; } refresh ( ) ; } protected abstract AsynchronousModel createModel ( ) ; public abstract AbstractUpdatePolicy createUpdatePolicy ( ) ; Image [ ] getImages ( ImageDescriptor [ ] descriptors ) { if ( descriptors = = null | | descriptors . length = = <int> ) { String [ ] columns = getPresentationContext ( ) . getColumns ( ) ; if ( columns = = null ) { return new Image [ <int> ] ; } else { return new Image [ columns . length ] ; } } Image [ ] images = new Image [ descriptors . length ] ; for ( int i = <int> ; i < images . length ; i + + ) { images [ i ] = getImage ( descriptors [ i ] ) ; } return images ; } protected Image getImage ( ImageDescriptor descriptor ) { if ( descriptor = = null ) { return null ; } Image image = fImageCache . get ( descriptor ) ; if ( image = = null ) { image = new Image ( getControl ( ) . getDisplay ( ) , descriptor . getImageData ( ) ) ; fImageCache . put ( descriptor , image ) ; } return image ; } protected Font [ ] getFonts ( FontData [ ] fontDatas ) { if ( fontDatas = = null | | fontDatas . length = = <int> ) { String [ ] columns = getPresentationContext ( ) . getColumns ( ) ; if ( columns = = null ) { return new Font [ <int> ] ; } else { return new Font [ columns . length ] ; } } Font [ ] fonts = new Font [ fontDatas . length ] ; for ( int i = <int> ; i < fonts . length ; i + + ) { fonts [ i ] = getFont ( fontDatas [ i ] ) ; } return fonts ; } protected Font getFont ( FontData fontData ) { if ( fontData = = null ) { return null ; } Font font = fFontCache . get ( fontData ) ; if ( font = = null ) { font = new Font ( getControl ( ) . getDisplay ( ) , fontData ) ; fFontCache . put ( fontData , font ) ; } return font ; } protected Color [ ] getColors ( RGB [ ] rgb ) { if ( rgb = = null | | rgb . length = = <int> ) { String [ ] columns = getPresentationContext ( ) . getColumns ( ) ; if ( columns = = null ) { return new Color [ <int> ] ; } else { return new Color [ columns . length ] ; } } Color [ ] colors = new Color [ rgb . length ] ; for ( int i = <int> ; i < colors . length ; i + + ) { colors [ i ] = getColor ( rgb [ i ] ) ; } return colors ; } protected Color getColor ( RGB rgb ) { if ( rgb = = null ) { return null ; } Color color = fColorCache . get ( rgb ) ; if ( color = = null ) { color = new Color ( getControl ( ) . getDisplay ( ) , rgb ) ; fColorCache . put ( rgb , color ) ; } return color ; } public void setContext ( IPresentationContext context ) { fContext = context ; } @Override protected Widget doFindItem ( Object element ) { AsynchronousModel model = getModel ( ) ; if ( model ! = null ) { if ( element . equals ( model . getRootNode ( ) ) ) { return doFindInputItem ( element ) ; } Widget [ ] widgets = findItems ( element ) ; if ( widgets . length > <int> ) { return widgets [ <int> ] ; } } return null ; } @Override protected Widget doFindInputItem ( Object element ) { if ( element instanceof ModelNode ) { ModelNode node = ( ModelNode ) element ; if ( node . getElement ( ) . equals ( getInput ( ) ) ) { return getControl ( ) ; } } return null ; } @Override protected void doUpdateItem ( Widget item , Object element , boolean fullMap ) { } @Override protected void internalRefresh ( Object element ) { AsynchronousModel model = getModel ( ) ; if ( model ! = null ) { ModelNode [ ] nodes = model . getNodes ( element ) ; if ( nodes ! = null ) { for ( int i = <int> ; i < nodes . length ; i + + ) { ModelNode node = nodes [ i ] ; Widget item = findItem ( node ) ; if ( item ! = null ) { internalRefresh ( node ) ; } } } } } protected void internalRefresh ( ModelNode node ) { updateLabel ( node ) ; } @Override public synchronized void setSelection ( ISelection selection , boolean reveal ) { setSelection ( selection , reveal , false ) ; } public synchronized void setSelection ( ISelection selection , final boolean reveal , boolean force ) { Control control = getControl ( ) ; if ( control = = null | | control . isDisposed ( ) ) { return ; } if ( ! acceptsSelection ( selection ) ) { selection = getEmptySelection ( ) ; } if ( ! force & & ! overrideSelection ( fCurrentSelection , selection ) ) { return ; } fPendingSelection = selection ; if ( getControl ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) { attemptSelection ( reveal ) ; } else { WorkbenchJob job = new WorkbenchJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { attemptSelection ( reveal ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } protected boolean overrideSelection ( ISelection current , ISelection candidate ) { IModelSelectionPolicy selectionPolicy = getSelectionPolicy ( current ) ; if ( selectionPolicy = = null ) { return true ; } if ( selectionPolicy . contains ( candidate , getPresentationContext ( ) ) ) { return selectionPolicy . overrides ( current , candidate , getPresentationContext ( ) ) ; } return ! selectionPolicy . isSticky ( current , getPresentationContext ( ) ) ; } @Override public ISelection getSelection ( ) { Control control = getControl ( ) ; if ( control = = null | | control . isDisposed ( ) | | fCurrentSelection = = null ) { return StructuredSelection . EMPTY ; } return fCurrentSelection ; } @Override protected void handleSelect ( SelectionEvent event ) { Control control = getControl ( ) ; if ( control ! = null & & ! control . isDisposed ( ) ) { updateSelection ( newSelectionFromWidget ( ) ) ; } } @Override protected void handlePostSelect ( SelectionEvent e ) { SelectionChangedEvent event = new SelectionChangedEvent ( this , newSelectionFromWidget ( ) ) ; firePostSelectionChanged ( event ) ; } protected abstract ISelection newSelectionFromWidget ( ) ; protected IModelSelectionPolicy getSelectionPolicy ( ISelection selection ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection ss = ( IStructuredSelection ) selection ; Object element = ss . getFirstElement ( ) ; if ( element instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) element ; IModelSelectionPolicyFactory factory = adaptable . getAdapter ( IModelSelectionPolicyFactory . class ) ; if ( factory ! = null ) { return factory . createModelSelectionPolicyAdapter ( adaptable , getPresentationContext ( ) ) ; } } } return null ; } @Override final protected void setSelectionToWidget ( ISelection selection , final boolean reveal ) { throw new IllegalArgumentException ( <str> ) ; } @Override final protected void setSelectionToWidget ( List l , boolean reveal ) { throw new IllegalArgumentException ( <str> ) ; } protected void attemptSelection ( boolean reveal ) { ISelection currentSelection = null ; synchronized ( this ) { if ( fPendingSelection ! = null ) { ISelection remaining = doAttemptSelectionToWidget ( fPendingSelection , reveal ) ; if ( remaining . isEmpty ( ) ) { remaining = null ; } if ( ! fPendingSelection . equals ( remaining ) ) { fPendingSelection = remaining ; currentSelection = newSelectionFromWidget ( ) ; if ( isSuppressEqualSelections ( ) & & currentSelection . equals ( fCurrentSelection ) ) { return ; } } } } if ( currentSelection ! = null ) { updateSelection ( currentSelection ) ; firePostSelectionChanged ( new SelectionChangedEvent ( this , currentSelection ) ) ; } } protected boolean isSuppressEqualSelections ( ) { return true ; } protected abstract ISelection doAttemptSelectionToWidget ( ISelection selection , boolean reveal ) ; protected abstract boolean acceptsSelection ( ISelection selection ) ; protected abstract ISelection getEmptySelection ( ) ; private class NullContentProvider implements IStructuredContentProvider { @Override public void dispose ( ) { } @Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { } @Override public Object [ ] getElements ( Object inputElement ) { return null ; } } protected void handlePresentationFailure ( IStatusMonitor monitor , IStatus status ) { } @Override protected synchronized void preservingSelection ( Runnable updateCode ) { if ( fPendingSelection = = null | | fPendingSelection . isEmpty ( ) ) { ISelection oldSelection = null ; try { oldSelection = fCurrentSelection ; updateCode . run ( ) ; } finally { if ( oldSelection = = null ) { oldSelection = new StructuredSelection ( ) ; } if ( getControl ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) { if ( ! oldSelection . equals ( newSelectionFromWidget ( ) ) ) { restoreSelection ( oldSelection ) ; } } else { WorkbenchJob job = new WorkbenchJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { synchronized ( AsynchronousViewer . this ) { if ( ! getControl ( ) . isDisposed ( ) ) { if ( fPendingSelection = = null | | fPendingSelection . isEmpty ( ) ) { ISelection tempSelection = fCurrentSelection ; if ( tempSelection = = null ) { tempSelection = new StructuredSelection ( ) ; } if ( ! tempSelection . equals ( newSelectionFromWidget ( ) ) ) { restoreSelection ( tempSelection ) ; } } } } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } } else { updateCode . run ( ) ; } } protected synchronized void restoreSelection ( ISelection oldSelection ) { ISelection remaining = doAttemptSelectionToWidget ( oldSelection , false ) ; fCurrentSelection = newSelectionFromWidget ( ) ; if ( ! selectionExists ( fCurrentSelection ) ) { if ( selectionExists ( oldSelection ) ) { fCurrentSelection = oldSelection ; } else { fCurrentSelection = getEmptySelection ( ) ; } } if ( ! fCurrentSelection . equals ( oldSelection ) ) { handleInvalidSelection ( oldSelection , fCurrentSelection ) ; if ( selectionExists ( remaining ) ) { setSelection ( remaining ) ; } } } protected boolean selectionExists ( ISelection selection ) { if ( selection . isEmpty ( ) ) { return false ; } if ( selection instanceof IStructuredSelection ) { IStructuredSelection ss = ( IStructuredSelection ) selection ; Iterator < ? > iterator = ss . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object element = iterator . next ( ) ; if ( getModel ( ) . getNodes ( element ) = = null ) { return false ; } } } return true ; } protected abstract void setColors ( Widget widget , RGB foreground [ ] , RGB background [ ] ) ; protected abstract void setLabels ( Widget widget , String [ ] text , ImageDescriptor [ ] image ) ; protected abstract void setFonts ( Widget widget , FontData [ ] font ) ; @Override protected synchronized void updateSelection ( ISelection selection ) { fCurrentSelection = selection ; super . updateSelection ( selection ) ; } protected void modelProxyAdded ( IModelProxy proxy ) { if ( fUpdatePolicy instanceof IModelChangedListener ) { proxy . addModelChangedListener ( ( IModelChangedListener ) fUpdatePolicy ) ; } } protected void modelProxyRemoved ( IModelProxy proxy ) { if ( fUpdatePolicy instanceof IModelChangedListener ) { proxy . removeModelChangedListener ( ( IModelChangedListener ) fUpdatePolicy ) ; } } protected AsynchronousModel getModel ( ) { return fModel ; } protected void nodeChanged ( ModelNode node ) { Widget widget = findItem ( node ) ; if ( widget ! = null ) { clear ( widget ) ; attemptPendingUpdates ( ) ; } } public synchronized boolean hasPendingUpdates ( ) { return getModel ( ) . hasPendingUpdates ( ) ; } protected void updateComplete ( IStatusMonitor monitor ) { } protected abstract void clear ( Widget item ) ; protected abstract void clearChildren ( Widget item ) ; protected abstract void clearChild ( Widget parent , int childIndex ) ; protected abstract Widget getChildWidget ( Widget parent , int index ) ; protected abstract void setItemCount ( Widget parent , int itemCount ) ; protected void attemptPendingUpdates ( ) { attemptSelection ( false ) ; } protected void nodeChildrenChanged ( ModelNode parentNode ) { Widget widget = findItem ( parentNode ) ; if ( widget ! = null & & ! widget . isDisposed ( ) ) { int childCount = parentNode . getChildCount ( ) ; setItemCount ( widget , childCount ) ; clearChildren ( widget ) ; attemptPendingUpdates ( ) ; } } protected void nodeChildrenAdded ( ModelNode parentNode ) { Widget widget = findItem ( parentNode ) ; if ( widget ! = null & & ! widget . isDisposed ( ) ) { int childCount = parentNode . getChildCount ( ) ; setItemCount ( widget , childCount ) ; attemptPendingUpdates ( ) ; } } protected void nodeChildRemoved ( ModelNode parentNode , int index ) { Widget widget = findItem ( parentNode ) ; if ( widget ! = null & & ! widget . isDisposed ( ) ) { Widget childWidget = getChildWidget ( widget , index ) ; int childCount = parentNode . getChildCount ( ) ; if ( childWidget = = null ) { setItemCount ( widget , childCount ) ; } else { childWidget . dispose ( ) ; } for ( int i = index ; i < childCount ; i + + ) { clearChild ( widget , i ) ; } attemptPendingUpdates ( ) ; } } protected void unmapNode ( ModelNode node ) { unmapElement ( node ) ; ModelNode [ ] childrenNodes = node . getChildrenNodes ( ) ; if ( childrenNodes ! = null ) { for ( int i = <int> ; i < childrenNodes . length ; i + + ) { unmapNode ( childrenNodes [ i ] ) ; } } } protected ModelNode findNode ( Widget widget ) { ModelNode [ ] nodes = getModel ( ) . getNodes ( widget . getData ( ) ) ; if ( nodes ! = null ) { for ( int i = <int> ; i < nodes . length ; i + + ) { ModelNode node = nodes [ i ] ; Widget item = findItem ( node ) ; if ( widget = = item ) { return node ; } } } return null ; } protected Widget findItem ( ModelNode node ) { return findItem ( ( Object ) node ) ; } @Override public void handleEvent ( final Event event ) { update ( ( Item ) event . item , event . index ) ; } protected void update ( Item item , int index ) { restoreLabels ( item ) ; int level = <int> ; Widget parentItem = getParentWidget ( item ) ; if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> + index + <str> + parentItem ) ; } ModelNode node = null ; if ( parentItem ! = null ) { ModelNode [ ] nodes = getModel ( ) . getNodes ( parentItem . getData ( ) ) ; if ( nodes ! = null ) { for ( int i = <int> ; i < nodes . length ; i + + ) { ModelNode parentNode = nodes [ i ] ; Widget parentWidget = findItem ( parentNode ) ; if ( parentWidget = = parentItem ) { ModelNode [ ] childrenNodes = parentNode . getChildrenNodes ( ) ; if ( childrenNodes ! = null & & index < childrenNodes . length ) { node = childrenNodes [ index ] ; } } } } } if ( node = = null ) { setNodeIndex ( index , level ) ; while ( parentItem instanceof Item ) { level + + ; Widget parent = getParentWidget ( parentItem ) ; int pindex = indexOf ( parent , parentItem ) ; if ( pindex < <int> ) { return ; } setNodeIndex ( pindex , level ) ; parentItem = parent ; } node = getModel ( ) . getRootNode ( ) ; if ( node = = null ) { if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> ) ; } return ; } for ( int i = level ; i > = <int> ; i - - ) { ModelNode [ ] childrenNodes = node . getChildrenNodes ( ) ; if ( childrenNodes = = null ) { if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> + node ) ; } return ; } int pindex = getNodeIndex ( i ) ; if ( pindex < childrenNodes . length ) { node = childrenNodes [ pindex ] ; } else { if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> + node ) ; } return ; } } } if ( node ! = null ) { mapElement ( node , item ) ; item . setData ( node . getElement ( ) ) ; if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> + node ) ; } internalRefresh ( node ) ; } else { if ( DebugUIPlugin . DEBUG_VIEWER ) { DebugUIPlugin . trace ( <str> ) ; } } } private void setNodeIndex ( int nodeIndex , int level ) { if ( level > ( fSetDataIndicies . length - <int> ) ) { int [ ] next = new int [ level + <int> ] ; System . arraycopy ( fSetDataIndicies , <int> , next , <int> , fSetDataIndicies . length ) ; fSetDataIndicies = next ; } fSetDataIndicies [ level ] = nodeIndex ; } private int getNodeIndex ( int level ) { return fSetDataIndicies [ level ] ; } protected abstract int indexOf ( Widget parent , Widget child ) ; protected abstract void restoreLabels ( Item item ) ; protected abstract Widget getParentWidget ( Widget widget ) ; protected void updateChildren ( ModelNode parent ) { getModel ( ) . updateChildren ( parent ) ; } } 
