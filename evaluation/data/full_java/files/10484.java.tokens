package com . google . common . hash ; import static com . google . common . base . Charsets . UTF_16LE ; import static org . junit . Assert . assertArrayEquals ; import junit . framework . TestCase ; import java . io . ByteArrayOutputStream ; import java . util . Random ; public class AbstractByteHasherTest extends TestCase { public void testBytes ( ) { TestHasher hasher = new TestHasher ( ) ; byte [ ] expected = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; hasher . putByte ( ( byte ) <int> ) ; hasher . putBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) ; hasher . putByte ( ( byte ) <int> ) ; hasher . putBytes ( new byte [ ] { } ) ; hasher . putBytes ( new byte [ ] { <int> } ) ; hasher . assertBytes ( expected ) ; } public void testShort ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putShort ( ( short ) <hex> ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> } ) ; } public void testInt ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putInt ( <hex> ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testLong ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putLong ( <hex> ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; } public void testChar ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putChar ( ( char ) <hex> ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> } ) ; } public void testString ( ) { Random random = new Random ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] bytes = new byte [ <int> ] ; random . nextBytes ( bytes ) ; String s = new String ( bytes , UTF_16LE ) ; assertEquals ( new TestHasher ( ) . putUnencodedChars ( s ) . hash ( ) , new TestHasher ( ) . putBytes ( s . getBytes ( UTF_16LE ) ) . hash ( ) ) ; assertEquals ( new TestHasher ( ) . putUnencodedChars ( s ) . hash ( ) , new TestHasher ( ) . putString ( s , UTF_16LE ) . hash ( ) ) ; } } public void testFloat ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putFloat ( Float . intBitsToFloat ( <hex> ) ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testDouble ( ) { TestHasher hasher = new TestHasher ( ) ; hasher . putDouble ( Double . longBitsToDouble ( <hex> ) ) ; hasher . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; } public void testCorrectExceptions ( ) { TestHasher hasher = new TestHasher ( ) ; try { hasher . putBytes ( new byte [ <int> ] , - <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } try { hasher . putBytes ( new byte [ <int> ] , <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } try { hasher . putBytes ( new byte [ <int> ] , <int> , - <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } private class TestHasher extends AbstractByteHasher { private final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; @Override protected void update ( byte b ) { out . write ( b ) ; } @Override protected void update ( byte [ ] b , int off , int len ) { out . write ( b , off , len ) ; } byte [ ] bytes ( ) { return out . toByteArray ( ) ; } void assertBytes ( byte [ ] expected ) { assertArrayEquals ( expected , bytes ( ) ) ; } @Override public HashCode hash ( ) { return HashCode . fromBytesNoCopy ( bytes ( ) ) ; } } } 
