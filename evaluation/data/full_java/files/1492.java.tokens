package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . file . Files ; import java . util . * ; import java . util . function . BiConsumer ; import java . util . function . Consumer ; import java . util . stream . Collectors ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Sets ; import org . junit . BeforeClass ; import org . junit . Test ; import static junit . framework . Assert . assertNotNull ; import static junit . framework . Assert . assertNull ; import static junit . framework . Assert . fail ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import junit . framework . Assert ; import org . apache . cassandra . MockSchema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . compaction . * ; import org . apache . cassandra . io . sstable . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . io . sstable . metadata . MetadataType ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . io . util . BufferedSegmentedFile ; import org . apache . cassandra . io . util . ChannelProxy ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . io . util . SegmentedFile ; import org . apache . cassandra . utils . AlwaysPresentFilter ; import org . apache . cassandra . utils . concurrent . AbstractTransactionalTest ; import org . apache . cassandra . utils . concurrent . Transactional ; public class LogTransactionTest extends AbstractTransactionalTest { private static final String KEYSPACE = <str> ; @BeforeClass public static void setUp ( ) { MockSchema . cleanup ( ) ; } protected AbstractTransactionalTest . TestableTransaction newTest ( ) throws Exception { LogTransaction . waitForDeletions ( ) ; SSTableReader . resetTidying ( ) ; return new TxnTest ( ) ; } private static final class TxnTest extends TestableTransaction { private final static class Transaction extends Transactional . AbstractTransactional implements Transactional { final ColumnFamilyStore cfs ; final LogTransaction txnLogs ; final File dataFolder ; final SSTableReader sstableOld ; final SSTableReader sstableNew ; final LogTransaction . SSTableTidier tidier ; Transaction ( ColumnFamilyStore cfs , LogTransaction txnLogs ) throws IOException { this . cfs = cfs ; this . txnLogs = txnLogs ; this . dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; this . sstableOld = sstable ( dataFolder , cfs , <int> , <int> ) ; this . sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; assertNotNull ( txnLogs ) ; assertNotNull ( txnLogs . id ( ) ) ; Assert . assertEquals ( OperationType . COMPACTION , txnLogs . type ( ) ) ; txnLogs . trackNew ( sstableNew ) ; tidier = txnLogs . obsoleted ( sstableOld ) ; assertNotNull ( tidier ) ; } protected Throwable doCommit ( Throwable accumulate ) { sstableOld . markObsolete ( tidier ) ; sstableOld . selfRef ( ) . release ( ) ; LogTransaction . waitForDeletions ( ) ; Throwable ret = txnLogs . commit ( accumulate ) ; sstableNew . selfRef ( ) . release ( ) ; return ret ; } protected Throwable doAbort ( Throwable accumulate ) { tidier . abort ( ) ; LogTransaction . waitForDeletions ( ) ; Throwable ret = txnLogs . abort ( accumulate ) ; sstableNew . selfRef ( ) . release ( ) ; sstableOld . selfRef ( ) . release ( ) ; return ret ; } protected void doPrepare ( ) { txnLogs . prepareToCommit ( ) ; } void assertInProgress ( ) throws Exception { assertFiles ( dataFolder . getPath ( ) , Sets . newHashSet ( Iterables . concat ( sstableNew . getAllFilePaths ( ) , sstableOld . getAllFilePaths ( ) , txnLogs . logFilePaths ( ) ) ) ) ; } void assertPrepared ( ) throws Exception { } void assertAborted ( ) throws Exception { assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstableOld . getAllFilePaths ( ) ) ) ; } void assertCommitted ( ) throws Exception { assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstableNew . getAllFilePaths ( ) ) ) ; } } final Transaction txn ; private TxnTest ( ) throws IOException { this ( MockSchema . newCFS ( KEYSPACE ) ) ; } private TxnTest ( ColumnFamilyStore cfs ) throws IOException { this ( cfs , new LogTransaction ( OperationType . COMPACTION ) ) ; } private TxnTest ( ColumnFamilyStore cfs , LogTransaction txnLogs ) throws IOException { this ( new Transaction ( cfs , txnLogs ) ) ; } private TxnTest ( Transaction txn ) { super ( txn ) ; this . txn = txn ; } protected void assertInProgress ( ) throws Exception { txn . assertInProgress ( ) ; } protected void assertPrepared ( ) throws Exception { txn . assertPrepared ( ) ; } protected void assertAborted ( ) throws Exception { txn . assertAborted ( ) ; } protected void assertCommitted ( ) throws Exception { txn . assertCommitted ( ) ; } } @Test public void testUntrack ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; log . untrackNew ( sstableNew ) ; log . finish ( ) ; sstableNew . selfRef ( ) . release ( ) ; Thread . sleep ( <int> ) ; LogTransaction . waitForDeletions ( ) ; assertFiles ( dataFolder . getPath ( ) , Collections . < String > emptySet ( ) ) ; } @Test public void testCommitSameDesc ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableOld1 = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableOld2 = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; sstableOld1 . setReplaced ( ) ; LogTransaction . SSTableTidier tidier = log . obsoleted ( sstableOld2 ) ; assertNotNull ( tidier ) ; log . finish ( ) ; sstableOld2 . markObsolete ( tidier ) ; sstableOld1 . selfRef ( ) . release ( ) ; sstableOld2 . selfRef ( ) . release ( ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstableNew . getAllFilePaths ( ) ) ) ; sstableNew . selfRef ( ) . release ( ) ; } @Test public void testCommitOnlyNew ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstable ) ; log . finish ( ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstable . getAllFilePaths ( ) ) ) ; sstable . selfRef ( ) . release ( ) ; } @Test public void testCommitOnlyOld ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier tidier = log . obsoleted ( sstable ) ; assertNotNull ( tidier ) ; log . finish ( ) ; sstable . markObsolete ( tidier ) ; sstable . selfRef ( ) . release ( ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( ) ) ; } @Test public void testCommitMultipleFolders ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File origiFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; File dataFolder1 = new File ( origiFolder , <str> ) ; File dataFolder2 = new File ( origiFolder , <str> ) ; Files . createDirectories ( dataFolder1 . toPath ( ) ) ; Files . createDirectories ( dataFolder2 . toPath ( ) ) ; SSTableReader [ ] sstables = { sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) } ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier [ ] tidiers = { log . obsoleted ( sstables [ <int> ] ) , log . obsoleted ( sstables [ <int> ] ) } ; log . trackNew ( sstables [ <int> ] ) ; log . trackNew ( sstables [ <int> ] ) ; log . finish ( ) ; sstables [ <int> ] . markObsolete ( tidiers [ <int> ] ) ; sstables [ <int> ] . markObsolete ( tidiers [ <int> ] ) ; Arrays . stream ( sstables ) . forEach ( s - > s . selfRef ( ) . release ( ) ) ; LogTransaction . waitForDeletions ( ) ; assertFiles ( dataFolder1 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; } @Test public void testAbortOnlyNew ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstable ) ; log . abort ( ) ; sstable . selfRef ( ) . release ( ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( ) ) ; } @Test public void testAbortOnlyOld ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier tidier = log . obsoleted ( sstable ) ; assertNotNull ( tidier ) ; tidier . abort ( ) ; log . abort ( ) ; sstable . selfRef ( ) . release ( ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstable . getAllFilePaths ( ) ) ) ; } @Test public void testAbortMultipleFolders ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File origiFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; File dataFolder1 = new File ( origiFolder , <str> ) ; File dataFolder2 = new File ( origiFolder , <str> ) ; Files . createDirectories ( dataFolder1 . toPath ( ) ) ; Files . createDirectories ( dataFolder2 . toPath ( ) ) ; SSTableReader [ ] sstables = { sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) } ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier [ ] tidiers = { log . obsoleted ( sstables [ <int> ] ) , log . obsoleted ( sstables [ <int> ] ) } ; log . trackNew ( sstables [ <int> ] ) ; log . trackNew ( sstables [ <int> ] ) ; Arrays . stream ( tidiers ) . forEach ( LogTransaction . SSTableTidier : : abort ) ; log . abort ( ) ; Arrays . stream ( sstables ) . forEach ( s - > s . selfRef ( ) . release ( ) ) ; LogTransaction . waitForDeletions ( ) ; assertFiles ( dataFolder1 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; } @Test public void testRemoveUnfinishedLeftovers_abort ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableOld = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; LogTransaction . SSTableTidier tidier = log . obsoleted ( sstableOld ) ; Set < File > tmpFiles = sstableNew . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) ; sstableNew . selfRef ( ) . release ( ) ; sstableOld . selfRef ( ) . release ( ) ; Assert . assertEquals ( tmpFiles , LogAwareFileLister . getTemporaryFiles ( sstableNew . descriptor . directory ) ) ; LogTransaction . removeUnfinishedLeftovers ( cfs . metadata ) ; Directories directories = new Directories ( cfs . metadata ) ; Map < Descriptor , Set < Component > > sstables = directories . sstableLister ( Directories . OnTxnErr . THROW ) . list ( ) ; assertEquals ( <int> , sstables . size ( ) ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstableOld . getAllFilePaths ( ) ) ) ; tidier . run ( ) ; log . close ( ) ; } @Test public void testRemoveUnfinishedLeftovers_commit ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableOld = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; LogTransaction . SSTableTidier tidier = log . obsoleted ( sstableOld ) ; log . txnFile ( ) . commit ( ) ; Set < File > tmpFiles = sstableOld . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) ; sstableNew . selfRef ( ) . release ( ) ; sstableOld . selfRef ( ) . release ( ) ; Assert . assertEquals ( tmpFiles , LogAwareFileLister . getTemporaryFiles ( sstableOld . descriptor . directory ) ) ; LogTransaction . removeUnfinishedLeftovers ( cfs . metadata ) ; Directories directories = new Directories ( cfs . metadata ) ; Map < Descriptor , Set < Component > > sstables = directories . sstableLister ( Directories . OnTxnErr . THROW ) . list ( ) ; assertEquals ( <int> , sstables . size ( ) ) ; assertFiles ( dataFolder . getPath ( ) , new HashSet < > ( sstableNew . getAllFilePaths ( ) ) ) ; tidier . run ( ) ; assertNull ( log . complete ( null ) ) ; } @Test public void testRemoveUnfinishedLeftovers_commit_multipleFolders ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File origiFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; File dataFolder1 = new File ( origiFolder , <str> ) ; File dataFolder2 = new File ( origiFolder , <str> ) ; Files . createDirectories ( dataFolder1 . toPath ( ) ) ; Files . createDirectories ( dataFolder2 . toPath ( ) ) ; SSTableReader [ ] sstables = { sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) } ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier [ ] tidiers = { log . obsoleted ( sstables [ <int> ] ) , log . obsoleted ( sstables [ <int> ] ) } ; log . trackNew ( sstables [ <int> ] ) ; log . trackNew ( sstables [ <int> ] ) ; Collection < File > logFiles = log . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; log . txnFile ( ) . commit ( ) ; Arrays . stream ( sstables ) . forEach ( s - > s . selfRef ( ) . release ( ) ) ; Assert . assertEquals ( sstables [ <int> ] . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) , LogAwareFileLister . getTemporaryFiles ( dataFolder1 ) ) ; Assert . assertEquals ( sstables [ <int> ] . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) , LogAwareFileLister . getTemporaryFiles ( dataFolder2 ) ) ; LogTransaction . removeUnfinishedLeftovers ( Arrays . asList ( dataFolder1 , dataFolder2 ) ) ; assertFiles ( dataFolder1 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; Arrays . stream ( tidiers ) . forEach ( LogTransaction . SSTableTidier : : run ) ; assertNull ( log . complete ( null ) ) ; } @Test public void testRemoveUnfinishedLeftovers_abort_multipleFolders ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File origiFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; File dataFolder1 = new File ( origiFolder , <str> ) ; File dataFolder2 = new File ( origiFolder , <str> ) ; Files . createDirectories ( dataFolder1 . toPath ( ) ) ; Files . createDirectories ( dataFolder2 . toPath ( ) ) ; SSTableReader [ ] sstables = { sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) } ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier [ ] tidiers = { log . obsoleted ( sstables [ <int> ] ) , log . obsoleted ( sstables [ <int> ] ) } ; log . trackNew ( sstables [ <int> ] ) ; log . trackNew ( sstables [ <int> ] ) ; Collection < File > logFiles = log . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; log . txnFile ( ) . abort ( ) ; Arrays . stream ( sstables ) . forEach ( s - > s . selfRef ( ) . release ( ) ) ; Assert . assertEquals ( sstables [ <int> ] . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) , LogAwareFileLister . getTemporaryFiles ( dataFolder1 ) ) ; Assert . assertEquals ( sstables [ <int> ] . getAllFilePaths ( ) . stream ( ) . map ( File : : new ) . collect ( Collectors . toSet ( ) ) , LogAwareFileLister . getTemporaryFiles ( dataFolder2 ) ) ; LogTransaction . removeUnfinishedLeftovers ( Arrays . asList ( dataFolder1 , dataFolder2 ) ) ; assertFiles ( dataFolder1 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; Arrays . stream ( tidiers ) . forEach ( LogTransaction . SSTableTidier : : run ) ; assertNull ( log . complete ( null ) ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_mismatchedFinalRecords ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeAbort ( System . currentTimeMillis ( ) ) . raw ) ; } , false ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_partialFinalRecords_first ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; String finalRecord = LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ; int toChop = finalRecord . length ( ) / <int> ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord . substring ( <int> , finalRecord . length ( ) - toChop ) ) ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; } , true ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_partialFinalRecords_second ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; String finalRecord = LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ; int toChop = finalRecord . length ( ) / <int> ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord . substring ( <int> , finalRecord . length ( ) - toChop ) ) ; } , true ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_partialNonFinalRecord_first ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; String sstableRecord = LogRecord . make ( LogRecord . Type . ADD , Collections . emptyList ( ) , <int> , <str> ) . raw ; int toChop = sstableRecord . length ( ) / <int> ; FileUtils . append ( logFiles . get ( <int> ) , sstableRecord . substring ( <int> , sstableRecord . length ( ) - toChop ) ) ; FileUtils . append ( logFiles . get ( <int> ) , sstableRecord ) ; String finalRecord = LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; } , false ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_partialNonFinalRecord_second ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; String sstableRecord = LogRecord . make ( LogRecord . Type . ADD , Collections . emptyList ( ) , <int> , <str> ) . raw ; int toChop = sstableRecord . length ( ) / <int> ; FileUtils . append ( logFiles . get ( <int> ) , sstableRecord ) ; FileUtils . append ( logFiles . get ( <int> ) , sstableRecord . substring ( <int> , sstableRecord . length ( ) - toChop ) ) ; String finalRecord = LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; FileUtils . append ( logFiles . get ( <int> ) , finalRecord ) ; } , false ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_missingFinalRecords_first ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; } , true ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_missingFinalRecords_second ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; } , true ) ; } @Test public void testRemoveUnfinishedLeftovers_multipleFolders_tooManyFinalRecords ( ) throws Throwable { testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( txn - > { List < File > logFiles = txn . logFiles ( ) ; Assert . assertEquals ( <int> , logFiles . size ( ) ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; FileUtils . append ( logFiles . get ( <int> ) , LogRecord . makeCommit ( System . currentTimeMillis ( ) ) . raw ) ; } , false ) ; } private static void testRemoveUnfinishedLeftovers_multipleFolders_errorConditions ( Consumer < LogTransaction > modifier , boolean shouldCommit ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File origiFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; File dataFolder1 = new File ( origiFolder , <str> ) ; File dataFolder2 = new File ( origiFolder , <str> ) ; Files . createDirectories ( dataFolder1 . toPath ( ) ) ; Files . createDirectories ( dataFolder2 . toPath ( ) ) ; SSTableReader [ ] sstables = { sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder1 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) , sstable ( dataFolder2 , cfs , <int> , <int> ) } ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; LogTransaction . SSTableTidier [ ] tidiers = { log . obsoleted ( sstables [ <int> ] ) , log . obsoleted ( sstables [ <int> ] ) } ; log . trackNew ( sstables [ <int> ] ) ; log . trackNew ( sstables [ <int> ] ) ; modifier . accept ( log ) ; Arrays . stream ( sstables ) . forEach ( s - > s . selfRef ( ) . release ( ) ) ; LogTransaction . removeUnfinishedLeftovers ( Arrays . asList ( dataFolder1 , dataFolder2 ) ) ; LogTransaction . waitForDeletions ( ) ; if ( shouldCommit ) { assertFiles ( dataFolder1 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , new HashSet < > ( sstables [ <int> ] . getAllFilePaths ( ) ) ) ; } else { assertFiles ( dataFolder1 . getPath ( ) , Sets . newHashSet ( Iterables . concat ( sstables [ <int> ] . getAllFilePaths ( ) , sstables [ <int> ] . getAllFilePaths ( ) , Collections . singleton ( log . logFilePaths ( ) . get ( <int> ) ) ) ) ) ; assertFiles ( dataFolder2 . getPath ( ) , Sets . newHashSet ( Iterables . concat ( sstables [ <int> ] . getAllFilePaths ( ) , sstables [ <int> ] . getAllFilePaths ( ) , Collections . singleton ( log . logFilePaths ( ) . get ( <int> ) ) ) ) ) ; } Arrays . stream ( tidiers ) . forEach ( LogTransaction . SSTableTidier : : run ) ; log . txnFile ( ) . commit ( ) ; assertNull ( log . complete ( null ) ) ; } @Test public void testGetTemporaryFiles ( ) throws IOException { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable1 = sstable ( dataFolder , cfs , <int> , <int> ) ; Set < File > tmpFiles = LogAwareFileLister . getTemporaryFiles ( dataFolder ) ; assertNotNull ( tmpFiles ) ; assertEquals ( <int> , tmpFiles . size ( ) ) ; try ( LogTransaction log = new LogTransaction ( OperationType . WRITE ) ) { Directories directories = new Directories ( cfs . metadata ) ; File [ ] beforeSecondSSTable = dataFolder . listFiles ( pathname - > ! pathname . isDirectory ( ) ) ; SSTableReader sstable2 = sstable ( dataFolder , cfs , <int> , <int> ) ; log . trackNew ( sstable2 ) ; Map < Descriptor , Set < Component > > sstables = directories . sstableLister ( Directories . OnTxnErr . THROW ) . list ( ) ; assertEquals ( <int> , sstables . size ( ) ) ; File [ ] afterSecondSSTable = dataFolder . listFiles ( pathname - > ! pathname . isDirectory ( ) ) ; int numNewFiles = afterSecondSSTable . length - beforeSecondSSTable . length ; assertEquals ( numNewFiles - <int> , sstable2 . getAllFilePaths ( ) . size ( ) ) ; tmpFiles = LogAwareFileLister . getTemporaryFiles ( dataFolder ) ; assertNotNull ( tmpFiles ) ; assertEquals ( numNewFiles - <int> , tmpFiles . size ( ) ) ; File ssTable2DataFile = new File ( sstable2 . descriptor . filenameFor ( Component . DATA ) ) ; File ssTable2IndexFile = new File ( sstable2 . descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) ; assertTrue ( tmpFiles . contains ( ssTable2DataFile ) ) ; assertTrue ( tmpFiles . contains ( ssTable2IndexFile ) ) ; List < File > files = directories . sstableLister ( Directories . OnTxnErr . THROW ) . listFiles ( ) ; List < File > filesNoTmp = directories . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) . listFiles ( ) ; assertNotNull ( files ) ; assertNotNull ( filesNoTmp ) ; assertTrue ( files . contains ( ssTable2DataFile ) ) ; assertTrue ( files . contains ( ssTable2IndexFile ) ) ; assertFalse ( filesNoTmp . contains ( ssTable2DataFile ) ) ; assertFalse ( filesNoTmp . contains ( ssTable2IndexFile ) ) ; log . finish ( ) ; tmpFiles = LogAwareFileLister . getTemporaryFiles ( dataFolder ) ; assertNotNull ( tmpFiles ) ; assertEquals ( <int> , tmpFiles . size ( ) ) ; filesNoTmp = directories . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) . listFiles ( ) ; assertNotNull ( filesNoTmp ) ; assertTrue ( filesNoTmp . contains ( ssTable2DataFile ) ) ; assertTrue ( filesNoTmp . contains ( ssTable2IndexFile ) ) ; sstable1 . selfRef ( ) . release ( ) ; sstable2 . selfRef ( ) . release ( ) ; } } @Test public void testWrongChecksumLastLine ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now , <int> ) ) ) ; } , true ) ; } @Test public void testWrongChecksumSecondFromLastLine ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now , <int> ) ) ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now , <int> ) ) ) ; } , false ) ; } @Test public void testWrongChecksumLastLineMissingFile ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { for ( String filePath : s . getAllFilePaths ( ) ) { if ( filePath . endsWith ( <str> ) ) { assertTrue ( FileUtils . delete ( filePath ) ) ; assertNull ( t . txnFile ( ) . syncFolder ( null ) ) ; break ; } } long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now , <int> ) ) ) ; } , false ) ; } @Test public void testWrongChecksumLastLineWrongRecordFormat ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now , <int> ) ) ) ; } , true ) ; } @Test public void testMissingChecksumLastLine ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now ) ) ) ; } , true ) ; } @Test public void testMissingChecksumSecondFromLastLine ( ) throws IOException { testCorruptRecord ( ( t , s ) - > { long now = System . currentTimeMillis ( ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now ) ) ) ; t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , String . format ( <str> , now ) ) ) ; } , false ) ; } @Test public void testUnparsableLastRecord ( ) throws IOException { testCorruptRecord ( ( t , s ) - > t . logFiles ( ) . forEach ( f - > FileUtils . append ( f , <str> ) ) , true ) ; } @Test public void testUnparsableFirstRecord ( ) throws IOException { testCorruptRecord ( ( t , s ) - > t . logFiles ( ) . forEach ( f - > { List < String > lines = FileUtils . readLines ( f ) ; lines . add ( <int> , <str> ) ; FileUtils . replace ( f , lines . toArray ( new String [ lines . size ( ) ] ) ) ; } ) , false ) ; } private static void testCorruptRecord ( BiConsumer < LogTransaction , SSTableReader > modifier , boolean isRecoverable ) throws IOException { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableOld = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; log . obsoleted ( sstableOld ) ; modifier . accept ( log , sstableOld ) ; assertNull ( log . complete ( null ) ) ; sstableOld . selfRef ( ) . release ( ) ; sstableNew . selfRef ( ) . release ( ) ; Set < String > newFiles = sstableNew . getAllFilePaths ( ) . stream ( ) . collect ( Collectors . toSet ( ) ) ; Set < String > oldFiles = sstableOld . getAllFilePaths ( ) . stream ( ) . filter ( p - > new File ( p ) . exists ( ) ) . collect ( Collectors . toSet ( ) ) ; assertFiles ( newFiles , LogAwareFileLister . getTemporaryFiles ( dataFolder ) ) ; assertFiles ( oldFiles , LogAwareFileLister . getFinalFiles ( dataFolder ) ) ; if ( isRecoverable ) { LogTransaction . removeUnfinishedLeftovers ( cfs . metadata ) ; assertFiles ( dataFolder . getPath ( ) , oldFiles ) ; } else { LogTransaction . removeUnfinishedLeftovers ( cfs . metadata ) ; assertFiles ( dataFolder . getPath ( ) , Sets . newHashSet ( Iterables . concat ( newFiles , oldFiles , log . logFilePaths ( ) ) ) ) ; } } @Test public void testObsoletedDataFileUpdateTimeChanged ( ) throws IOException { testObsoletedFilesChanged ( sstable - > { for ( String filePath : sstable . getAllFilePaths ( ) ) { if ( filePath . endsWith ( <str> ) ) assertTrue ( new File ( filePath ) . setLastModified ( System . currentTimeMillis ( ) + <int> ) ) ; } } ) ; } private static void testObsoletedFilesChanged ( Consumer < SSTableReader > modifier ) throws IOException { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstableOld = sstable ( dataFolder , cfs , <int> , <int> ) ; SSTableReader sstableNew = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction log = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( log ) ; log . trackNew ( sstableNew ) ; log . obsoleted ( sstableOld ) ; modifier . accept ( sstableOld ) ; log . txnFile ( ) . commit ( ) ; LogTransaction . removeUnfinishedLeftovers ( cfs . metadata ) ; assertFiles ( dataFolder . getPath ( ) , Sets . newHashSet ( Iterables . concat ( sstableNew . getAllFilePaths ( ) , sstableOld . getAllFilePaths ( ) , log . logFilePaths ( ) ) ) ) ; sstableOld . selfRef ( ) . release ( ) ; sstableNew . selfRef ( ) . release ( ) ; assertNull ( log . complete ( null ) ) ; assertFiles ( dataFolder . getPath ( ) , Sets . newHashSet ( Iterables . concat ( sstableNew . getAllFilePaths ( ) , sstableOld . getAllFilePaths ( ) , log . logFilePaths ( ) ) ) ) ; } @Test public void testGetTemporaryFilesSafeAfterObsoletion ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction logs = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( logs ) ; LogTransaction . SSTableTidier tidier = logs . obsoleted ( sstable ) ; logs . finish ( ) ; sstable . markObsolete ( tidier ) ; sstable . selfRef ( ) . release ( ) ; for ( int i = <int> ; i < <int> ; i + + ) LogAwareFileLister . getTemporaryFiles ( dataFolder ) ; } @Test public void testGetTemporaryFilesThrowsIfCompletingAfterObsoletion ( ) throws Throwable { ColumnFamilyStore cfs = MockSchema . newCFS ( KEYSPACE ) ; File dataFolder = new Directories ( cfs . metadata ) . getDirectoryForNewSSTables ( ) ; SSTableReader sstable = sstable ( dataFolder , cfs , <int> , <int> ) ; LogTransaction logs = new LogTransaction ( OperationType . COMPACTION ) ; assertNotNull ( logs ) ; LogTransaction . SSTableTidier tidier = logs . obsoleted ( sstable ) ; sstable . markObsolete ( tidier ) ; sstable . selfRef ( ) . release ( ) ; LogTransaction . waitForDeletions ( ) ; try { LogAwareFileLister . getTemporaryFiles ( dataFolder ) ; fail ( <str> ) ; } catch ( RuntimeException e ) { } logs . finish ( ) ; } private static SSTableReader sstable ( File dataFolder , ColumnFamilyStore cfs , int generation , int size ) throws IOException { Descriptor descriptor = new Descriptor ( dataFolder , cfs . keyspace . getName ( ) , cfs . getTableName ( ) , generation ) ; Set < Component > components = ImmutableSet . of ( Component . DATA , Component . PRIMARY_INDEX , Component . FILTER , Component . TOC ) ; for ( Component component : components ) { File file = new File ( descriptor . filenameFor ( component ) ) ; if ( ! file . exists ( ) ) assertTrue ( file . createNewFile ( ) ) ; try ( RandomAccessFile raf = new RandomAccessFile ( file , <str> ) ) { raf . setLength ( size ) ; } } SegmentedFile dFile = new BufferedSegmentedFile ( new ChannelProxy ( new File ( descriptor . filenameFor ( Component . DATA ) ) ) , RandomAccessReader . DEFAULT_BUFFER_SIZE , <int> ) ; SegmentedFile iFile = new BufferedSegmentedFile ( new ChannelProxy ( new File ( descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) ) , RandomAccessReader . DEFAULT_BUFFER_SIZE , <int> ) ; SerializationHeader header = SerializationHeader . make ( cfs . metadata , Collections . emptyList ( ) ) ; StatsMetadata metadata = ( StatsMetadata ) new MetadataCollector ( cfs . metadata . comparator ) . finalizeMetadata ( cfs . metadata . partitioner . getClass ( ) . getCanonicalName ( ) , <float> , - <int> , header ) . get ( MetadataType . STATS ) ; SSTableReader reader = SSTableReader . internalOpen ( descriptor , components , cfs . metadata , dFile , iFile , MockSchema . indexSummary . sharedCopy ( ) , new AlwaysPresentFilter ( ) , <int> , metadata , SSTableReader . OpenReason . NORMAL , header ) ; reader . first = reader . last = MockSchema . readerBounds ( generation ) ; return reader ; } private static void assertFiles ( String dirPath , Set < String > expectedFiles ) { assertFiles ( dirPath , expectedFiles , false ) ; } private static void assertFiles ( String dirPath , Set < String > expectedFiles , boolean excludeNonExistingFiles ) { LogTransaction . waitForDeletions ( ) ; File dir = new File ( dirPath ) ; File [ ] files = dir . listFiles ( ) ; if ( files ! = null ) { for ( File file : files ) { if ( file . isDirectory ( ) ) continue ; String filePath = file . getPath ( ) ; assertTrue ( String . format ( <str> , filePath , expectedFiles ) , expectedFiles . contains ( filePath ) ) ; expectedFiles . remove ( filePath ) ; } } if ( excludeNonExistingFiles ) { for ( String filePath : expectedFiles ) { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) expectedFiles . remove ( filePath ) ; } } assertTrue ( expectedFiles . toString ( ) , expectedFiles . isEmpty ( ) ) ; } private static void assertFiles ( Iterable < String > existingFiles , Set < File > temporaryFiles ) { for ( String filePath : existingFiles ) { File file = new File ( filePath ) ; assertTrue ( filePath , temporaryFiles . contains ( file ) ) ; temporaryFiles . remove ( file ) ; } for ( File file : temporaryFiles ) { if ( ! file . exists ( ) ) temporaryFiles . remove ( file ) ; } assertTrue ( temporaryFiles . toString ( ) , temporaryFiles . isEmpty ( ) ) ; } } 
