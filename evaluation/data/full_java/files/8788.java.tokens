package org . elasticsearch . plan . a ; import java . util . Set ; import org . antlr . v4 . runtime . Lexer ; import org . antlr . v4 . runtime . CharStream ; import org . antlr . v4 . runtime . Token ; import org . antlr . v4 . runtime . TokenStream ; import org . antlr . v4 . runtime . * ; import org . antlr . v4 . runtime . atn . * ; import org . antlr . v4 . runtime . dfa . DFA ; import org . antlr . v4 . runtime . misc . * ; @SuppressWarnings ( { <str> , <str> , <str> , <str> , <str> } ) class PlanALexer extends Lexer { static { RuntimeMetaData . checkVersion ( <str> , RuntimeMetaData . VERSION ) ; } protected static final DFA [ ] _decisionToDFA ; protected static final PredictionContextCache _sharedContextCache = new PredictionContextCache ( ) ; public static final int WS = <int> , COMMENT = <int> , LBRACK = <int> , RBRACK = <int> , LBRACE = <int> , RBRACE = <int> , LP = <int> , RP = <int> , DOT = <int> , COMMA = <int> , SEMICOLON = <int> , IF = <int> , ELSE = <int> , WHILE = <int> , DO = <int> , FOR = <int> , CONTINUE = <int> , BREAK = <int> , RETURN = <int> , NEW = <int> , TRY = <int> , CATCH = <int> , THROW = <int> , BOOLNOT = <int> , BWNOT = <int> , MUL = <int> , DIV = <int> , REM = <int> , ADD = <int> , SUB = <int> , LSH = <int> , RSH = <int> , USH = <int> , LT = <int> , LTE = <int> , GT = <int> , GTE = <int> , EQ = <int> , EQR = <int> , NE = <int> , NER = <int> , BWAND = <int> , BWXOR = <int> , BWOR = <int> , BOOLAND = <int> , BOOLOR = <int> , COND = <int> , COLON = <int> , INCR = <int> , DECR = <int> , ASSIGN = <int> , AADD = <int> , ASUB = <int> , AMUL = <int> , ADIV = <int> , AREM = <int> , AAND = <int> , AXOR = <int> , AOR = <int> , ALSH = <int> , ARSH = <int> , AUSH = <int> , ACAT = <int> , OCTAL = <int> , HEX = <int> , INTEGER = <int> , DECIMAL = <int> , STRING = <int> , CHAR = <int> , TRUE = <int> , FALSE = <int> , NULL = <int> , TYPE = <int> , ID = <int> , EXTINTEGER = <int> , EXTID = <int> ; public static final int EXT = <int> ; public static String [ ] modeNames = { <str> , <str> } ; public static final String [ ] ruleNames = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static final String [ ] _LITERAL_NAMES = { null , null , null , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , null , null , null , null , null , null , <str> , <str> , <str> } ; private static final String [ ] _SYMBOLIC_NAMES = { null , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public static final Vocabulary VOCABULARY = new VocabularyImpl ( _LITERAL_NAMES , _SYMBOLIC_NAMES ) ; @Deprecated public static final String [ ] tokenNames ; static { tokenNames = new String [ _SYMBOLIC_NAMES . length ] ; for ( int i = <int> ; i < tokenNames . length ; i + + ) { tokenNames [ i ] = VOCABULARY . getLiteralName ( i ) ; if ( tokenNames [ i ] = = null ) { tokenNames [ i ] = VOCABULARY . getSymbolicName ( i ) ; } if ( tokenNames [ i ] = = null ) { tokenNames [ i ] = <str> ; } } } @Override @Deprecated public String [ ] getTokenNames ( ) { return tokenNames ; } @Override public Vocabulary getVocabulary ( ) { return VOCABULARY ; } private Set < String > types = null ; void setTypes ( Set < String > types ) { this . types = types ; } public PlanALexer ( CharStream input ) { super ( input ) ; _interp = new LexerATNSimulator ( this , _ATN , _decisionToDFA , _sharedContextCache ) ; } @Override public String getGrammarFileName ( ) { return <str> ; } @Override public String [ ] getRuleNames ( ) { return ruleNames ; } @Override public String getSerializedATN ( ) { return _serializedATN ; } @Override public String [ ] getModeNames ( ) { return modeNames ; } @Override public ATN getATN ( ) { return _ATN ; } @Override public void action ( RuleContext _localctx , int ruleIndex , int actionIndex ) { switch ( ruleIndex ) { case <int> : STRING_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; case <int> : CHAR_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; case <int> : TYPE_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; } } private void STRING_action ( RuleContext _localctx , int actionIndex ) { switch ( actionIndex ) { case <int> : setText ( getText ( ) . substring ( <int> , getText ( ) . length ( ) - <int> ) ) ; break ; } } private void CHAR_action ( RuleContext _localctx , int actionIndex ) { switch ( actionIndex ) { case <int> : setText ( getText ( ) . substring ( <int> , getText ( ) . length ( ) - <int> ) ) ; break ; } } private void TYPE_action ( RuleContext _localctx , int actionIndex ) { switch ( actionIndex ) { case <int> : setText ( getText ( ) . replace ( <str> , <str> ) ) ; break ; } } @Override public boolean sempred ( RuleContext _localctx , int ruleIndex , int predIndex ) { switch ( ruleIndex ) { case <int> : return TYPE_sempred ( ( RuleContext ) _localctx , predIndex ) ; } return true ; } private boolean TYPE_sempred ( RuleContext _localctx , int predIndex ) { switch ( predIndex ) { case <int> : return types . contains ( getText ( ) . replace ( <str> , <str> ) ) ; } return true ; } public static final String _serializedATN = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; public static final ATN _ATN = new ATNDeserializer ( ) . deserialize ( _serializedATN . toCharArray ( ) ) ; static { _decisionToDFA = new DFA [ _ATN . getNumberOfDecisions ( ) ] ; for ( int i = <int> ; i < _ATN . getNumberOfDecisions ( ) ; i + + ) { _decisionToDFA [ i ] = new DFA ( _ATN . getDecisionState ( i ) , i ) ; } } } 
