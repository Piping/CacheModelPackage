package org . elasticsearch . action . admin . cluster . snapshots . create ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . master . MasterNodeRequest ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; import static org . elasticsearch . common . Strings . EMPTY_ARRAY ; import static org . elasticsearch . common . Strings . hasLength ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; import static org . elasticsearch . common . settings . Settings . readSettingsFromStream ; import static org . elasticsearch . common . settings . Settings . writeSettingsToStream ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeBooleanValue ; public class CreateSnapshotRequest extends MasterNodeRequest < CreateSnapshotRequest > implements IndicesRequest . Replaceable { private String snapshot ; private String repository ; private String [ ] indices = EMPTY_ARRAY ; private IndicesOptions indicesOptions = IndicesOptions . strictExpandOpen ( ) ; private boolean partial = false ; private Settings settings = EMPTY_SETTINGS ; private boolean includeGlobalState = true ; private boolean waitForCompletion ; public CreateSnapshotRequest ( ) { } public CreateSnapshotRequest ( String repository , String snapshot ) { this . snapshot = snapshot ; this . repository = repository ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( snapshot = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( repository = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( indices = = null ) { validationException = addValidationError ( <str> , validationException ) ; } else { for ( String index : indices ) { if ( index = = null ) { validationException = addValidationError ( <str> , validationException ) ; break ; } } } if ( indicesOptions = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( settings = = null ) { validationException = addValidationError ( <str> , validationException ) ; } return validationException ; } public CreateSnapshotRequest snapshot ( String snapshot ) { this . snapshot = snapshot ; return this ; } public String snapshot ( ) { return this . snapshot ; } public CreateSnapshotRequest repository ( String repository ) { this . repository = repository ; return this ; } public String repository ( ) { return this . repository ; } @Override public CreateSnapshotRequest indices ( String . . . indices ) { this . indices = indices ; return this ; } public CreateSnapshotRequest indices ( List < String > indices ) { this . indices = indices . toArray ( new String [ indices . size ( ) ] ) ; return this ; } @Override public String [ ] indices ( ) { return indices ; } @Override public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public CreateSnapshotRequest indicesOptions ( IndicesOptions indicesOptions ) { this . indicesOptions = indicesOptions ; return this ; } public boolean partial ( ) { return partial ; } public CreateSnapshotRequest partial ( boolean partial ) { this . partial = partial ; return this ; } public CreateSnapshotRequest waitForCompletion ( boolean waitForCompletion ) { this . waitForCompletion = waitForCompletion ; return this ; } public boolean waitForCompletion ( ) { return waitForCompletion ; } public CreateSnapshotRequest settings ( Settings settings ) { this . settings = settings ; return this ; } public CreateSnapshotRequest settings ( Settings . Builder settings ) { this . settings = settings . build ( ) ; return this ; } public CreateSnapshotRequest settings ( String source ) { this . settings = Settings . settingsBuilder ( ) . loadFromSource ( source ) . build ( ) ; return this ; } public CreateSnapshotRequest settings ( Map < String , Object > source ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( source ) ; settings ( builder . string ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } return this ; } public Settings settings ( ) { return this . settings ; } public CreateSnapshotRequest includeGlobalState ( boolean includeGlobalState ) { this . includeGlobalState = includeGlobalState ; return this ; } public boolean includeGlobalState ( ) { return includeGlobalState ; } public CreateSnapshotRequest source ( XContentBuilder source ) { return source ( source . bytes ( ) ) ; } public CreateSnapshotRequest source ( Map source ) { for ( Map . Entry < String , Object > entry : ( ( Map < String , Object > ) source ) . entrySet ( ) ) { String name = entry . getKey ( ) ; if ( name . equals ( <str> ) ) { if ( entry . getValue ( ) instanceof String ) { indices ( Strings . splitStringByCommaToArray ( ( String ) entry . getValue ( ) ) ) ; } else if ( entry . getValue ( ) instanceof ArrayList ) { indices ( ( ArrayList < String > ) entry . getValue ( ) ) ; } else { throw new IllegalArgumentException ( <str> ) ; } } else if ( name . equals ( <str> ) ) { partial ( nodeBooleanValue ( entry . getValue ( ) ) ) ; } else if ( name . equals ( <str> ) ) { if ( ! ( entry . getValue ( ) instanceof Map ) ) { throw new IllegalArgumentException ( <str> ) ; } settings ( ( Map < String , Object > ) entry . getValue ( ) ) ; } else if ( name . equals ( <str> ) ) { includeGlobalState = nodeBooleanValue ( entry . getValue ( ) ) ; } } indicesOptions ( IndicesOptions . fromMap ( ( Map < String , Object > ) source , IndicesOptions . lenientExpandOpen ( ) ) ) ; return this ; } public CreateSnapshotRequest source ( String source ) { if ( hasLength ( source ) ) { try ( XContentParser parser = XContentFactory . xContent ( source ) . createParser ( source ) ) { return source ( parser . mapOrdered ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + source + <str> , e ) ; } } return this ; } public CreateSnapshotRequest source ( byte [ ] source ) { return source ( source , <int> , source . length ) ; } public CreateSnapshotRequest source ( byte [ ] source , int offset , int length ) { if ( length > <int> ) { try ( XContentParser parser = XContentFactory . xContent ( source , offset , length ) . createParser ( source , offset , length ) ) { return source ( parser . mapOrdered ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } return this ; } public CreateSnapshotRequest source ( BytesReference source ) { try ( XContentParser parser = XContentFactory . xContent ( source ) . createParser ( source ) ) { return source ( parser . mapOrdered ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; snapshot = in . readString ( ) ; repository = in . readString ( ) ; indices = in . readStringArray ( ) ; indicesOptions = IndicesOptions . readIndicesOptions ( in ) ; settings = readSettingsFromStream ( in ) ; includeGlobalState = in . readBoolean ( ) ; waitForCompletion = in . readBoolean ( ) ; partial = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( snapshot ) ; out . writeString ( repository ) ; out . writeStringArray ( indices ) ; indicesOptions . writeIndicesOptions ( out ) ; writeSettingsToStream ( settings , out ) ; out . writeBoolean ( includeGlobalState ) ; out . writeBoolean ( waitForCompletion ) ; out . writeBoolean ( partial ) ; } } 
