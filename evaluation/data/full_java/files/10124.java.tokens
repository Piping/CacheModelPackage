package com . google . common . testing ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . annotations . Beta ; import com . google . j2objc . annotations . J2ObjCIncompatible ; import java . lang . ref . WeakReference ; import java . util . Locale ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeoutException ; @Beta @J2ObjCIncompatible public final class GcFinalization { private GcFinalization ( ) { } private static long timeoutSeconds ( ) { return Math . max ( <int> , Runtime . getRuntime ( ) . totalMemory ( ) / ( <int> * <int> * <int> ) ) ; } public static void awaitDone ( Future < ? > future ) { if ( future . isDone ( ) ) { return ; } final long timeoutSeconds = timeoutSeconds ( ) ; final long deadline = System . nanoTime ( ) + SECONDS . toNanos ( timeoutSeconds ) ; do { System . runFinalization ( ) ; if ( future . isDone ( ) ) { return ; } System . gc ( ) ; try { future . get ( <int> , SECONDS ) ; return ; } catch ( CancellationException ok ) { return ; } catch ( ExecutionException ok ) { return ; } catch ( InterruptedException ie ) { throw new RuntimeException ( <str> , ie ) ; } catch ( TimeoutException tryHarder ) { } } while ( System . nanoTime ( ) - deadline < <int> ) ; throw formatRuntimeException ( <str> , timeoutSeconds ) ; } public static void await ( CountDownLatch latch ) { if ( latch . getCount ( ) = = <int> ) { return ; } final long timeoutSeconds = timeoutSeconds ( ) ; final long deadline = System . nanoTime ( ) + SECONDS . toNanos ( timeoutSeconds ) ; do { System . runFinalization ( ) ; if ( latch . getCount ( ) = = <int> ) { return ; } System . gc ( ) ; try { if ( latch . await ( <int> , SECONDS ) ) { return ; } } catch ( InterruptedException ie ) { throw new RuntimeException ( <str> , ie ) ; } } while ( System . nanoTime ( ) - deadline < <int> ) ; throw formatRuntimeException ( <str> , timeoutSeconds ) ; } private static void createUnreachableLatchFinalizer ( final CountDownLatch latch ) { new Object ( ) { @Override protected void finalize ( ) { latch . countDown ( ) ; } } ; } public interface FinalizationPredicate { boolean isDone ( ) ; } public static void awaitDone ( FinalizationPredicate predicate ) { if ( predicate . isDone ( ) ) { return ; } final long timeoutSeconds = timeoutSeconds ( ) ; final long deadline = System . nanoTime ( ) + SECONDS . toNanos ( timeoutSeconds ) ; do { System . runFinalization ( ) ; if ( predicate . isDone ( ) ) { return ; } CountDownLatch done = new CountDownLatch ( <int> ) ; createUnreachableLatchFinalizer ( done ) ; await ( done ) ; if ( predicate . isDone ( ) ) { return ; } } while ( System . nanoTime ( ) - deadline < <int> ) ; throw formatRuntimeException ( <str> , timeoutSeconds ) ; } public static void awaitClear ( final WeakReference < ? > ref ) { awaitDone ( new FinalizationPredicate ( ) { public boolean isDone ( ) { return ref . get ( ) = = null ; } } ) ; } public static void awaitFullGc ( ) { final CountDownLatch finalizerRan = new CountDownLatch ( <int> ) ; WeakReference < Object > ref = new WeakReference < Object > ( new Object ( ) { @Override protected void finalize ( ) { finalizerRan . countDown ( ) ; } } ) ; await ( finalizerRan ) ; awaitClear ( ref ) ; System . runFinalization ( ) ; } private static RuntimeException formatRuntimeException ( String format , Object . . . args ) { return new RuntimeException ( String . format ( Locale . ROOT , format , args ) ) ; } } 
