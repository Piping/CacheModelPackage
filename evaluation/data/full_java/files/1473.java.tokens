package org . apache . cassandra . db . commitlog ; import java . io . * ; import java . nio . ByteBuffer ; import java . util . Properties ; import java . util . UUID ; import junit . framework . Assert ; import com . google . common . base . Predicate ; import org . junit . After ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . KillerForTests ; import org . apache . cassandra . db . commitlog . CommitLogReplayer . CommitLogReplayException ; public class CommitLogUpgradeTest { static final String DATA_DIR = <str> ; static final String PROPERTIES_FILE = <str> ; static final String CFID_PROPERTY = <str> ; static final String CELLS_PROPERTY = <str> ; static final String HASH_PROPERTY = <str> ; static final String TABLE = <str> ; static final String KEYSPACE = <str> ; static final String CELLNAME = <str> ; private JVMStabilityInspector . Killer originalKiller ; private KillerForTests killerForTests ; private boolean shouldBeKilled = false ; @Before public void prepareToBeKilled ( ) { killerForTests = new KillerForTests ( ) ; originalKiller = JVMStabilityInspector . replaceKiller ( killerForTests ) ; } @After public void cleanUp ( ) { JVMStabilityInspector . replaceKiller ( originalKiller ) ; Assert . assertEquals ( <str> , shouldBeKilled , killerForTests . wasKilled ( ) ) ; } @Test public void test20 ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } @Test public void test21 ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } @Test public void test22 ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } @Test public void test22_LZ4 ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } @Test public void test22_Snappy ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } public void test22_truncated ( ) throws Exception { testRestore ( DATA_DIR + <str> ) ; } @Test ( expected = CommitLogReplayException . class ) public void test22_bitrot ( ) throws Exception { shouldBeKilled = true ; testRestore ( DATA_DIR + <str> ) ; } @Test public void test22_bitrot_ignored ( ) throws Exception { try { System . setProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY , <str> ) ; testRestore ( DATA_DIR + <str> ) ; } finally { System . clearProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY ) ; } } @Test ( expected = CommitLogReplayException . class ) public void test22_bitrot2 ( ) throws Exception { shouldBeKilled = true ; testRestore ( DATA_DIR + <str> ) ; } @Test public void test22_bitrot2_ignored ( ) throws Exception { try { System . setProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY , <str> ) ; testRestore ( DATA_DIR + <str> ) ; } finally { System . clearProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY ) ; } } @BeforeClass static public void initialize ( ) throws FileNotFoundException , IOException , InterruptedException { CFMetaData metadata = CFMetaData . Builder . createDense ( KEYSPACE , TABLE , false , false ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , BytesType . instance ) . build ( ) . compression ( SchemaLoader . getCompressionParameters ( ) ) ; SchemaLoader . loadSchema ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , metadata ) ; } public void testRestore ( String location ) throws IOException , InterruptedException { Properties prop = new Properties ( ) ; prop . load ( new FileInputStream ( new File ( location + File . separatorChar + PROPERTIES_FILE ) ) ) ; int hash = Integer . parseInt ( prop . getProperty ( HASH_PROPERTY ) ) ; int cells = Integer . parseInt ( prop . getProperty ( CELLS_PROPERTY ) ) ; String cfidString = prop . getProperty ( CFID_PROPERTY ) ; if ( cfidString ! = null ) { UUID cfid = UUID . fromString ( cfidString ) ; if ( Schema . instance . getCF ( cfid ) = = null ) { CFMetaData cfm = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; Schema . instance . unload ( cfm ) ; Schema . instance . load ( cfm . copy ( cfid ) ) ; } } Hasher hasher = new Hasher ( ) ; CommitLogTestReplayer replayer = new CommitLogTestReplayer ( CommitLog . instance , hasher ) ; File [ ] files = new File ( location ) . listFiles ( ( file , name ) - > name . endsWith ( <str> ) ) ; replayer . recover ( files ) ; Assert . assertEquals ( cells , hasher . cells ) ; Assert . assertEquals ( hash , hasher . hash ) ; } public static int hash ( int hash , ByteBuffer bytes ) { int shift = <int> ; for ( int i = <int> ; i < bytes . limit ( ) ; i + + ) { hash + = ( bytes . get ( i ) & <hex> ) < < shift ; shift = ( shift + <int> ) & <hex> ; } return hash ; } class Hasher implements Predicate < Mutation > { int hash = <int> ; int cells = <int> ; @Override public boolean apply ( Mutation mutation ) { for ( PartitionUpdate update : mutation . getPartitionUpdates ( ) ) { for ( Row row : update ) if ( row . clustering ( ) . size ( ) > <int> & & AsciiType . instance . compose ( row . clustering ( ) . get ( <int> ) ) . startsWith ( CELLNAME ) ) { for ( Cell cell : row . cells ( ) ) { hash = hash ( hash , cell . value ( ) ) ; + + cells ; } } } return true ; } } } 
