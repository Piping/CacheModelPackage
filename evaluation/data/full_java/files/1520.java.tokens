package org . apache . cassandra . dht ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import com . google . common . collect . Lists ; import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . tokenallocator . TokenAllocation ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . IFailureDetectionEventListener ; import org . apache . cassandra . gms . IFailureDetector ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class BootStrapperTest { static IPartitioner oldPartitioner ; @BeforeClass public static void setup ( ) throws ConfigurationException { oldPartitioner = StorageService . instance . setPartitionerUnsafe ( Murmur3Partitioner . instance ) ; SchemaLoader . startGossiper ( ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . schemaDefinition ( <str> ) ; } @AfterClass public static void tearDown ( ) { DatabaseDescriptor . setPartitionerUnsafe ( oldPartitioner ) ; } @Test public void testSourceTargetComputation ( ) throws UnknownHostException { final int [ ] clusterSizes = new int [ ] { <int> , <int> , <int> , <int> , <int> } ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { int replicationFactor = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) . getReplicationFactor ( ) ; for ( int clusterSize : clusterSizes ) if ( clusterSize > = replicationFactor ) testSourceTargetComputation ( keyspaceName , clusterSize , replicationFactor ) ; } } private RangeStreamer testSourceTargetComputation ( String keyspaceName , int numOldNodes , int replicationFactor ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; generateFakeEndpoints ( numOldNodes ) ; Token myToken = tmd . partitioner . getRandomToken ( ) ; InetAddress myEndpoint = InetAddress . getByName ( <str> ) ; assertEquals ( numOldNodes , tmd . sortedTokens ( ) . size ( ) ) ; RangeStreamer s = new RangeStreamer ( tmd , null , myEndpoint , <str> , true , DatabaseDescriptor . getEndpointSnitch ( ) , new StreamStateStore ( ) ) ; IFailureDetector mockFailureDetector = new IFailureDetector ( ) { public boolean isAlive ( InetAddress ep ) { return true ; } public void interpret ( InetAddress ep ) { throw new UnsupportedOperationException ( ) ; } public void report ( InetAddress ep ) { throw new UnsupportedOperationException ( ) ; } public void registerFailureDetectionEventListener ( IFailureDetectionEventListener listener ) { throw new UnsupportedOperationException ( ) ; } public void unregisterFailureDetectionEventListener ( IFailureDetectionEventListener listener ) { throw new UnsupportedOperationException ( ) ; } public void remove ( InetAddress ep ) { throw new UnsupportedOperationException ( ) ; } public void forceConviction ( InetAddress ep ) { throw new UnsupportedOperationException ( ) ; } } ; s . addSourceFilter ( new RangeStreamer . FailureDetectorSourceFilter ( mockFailureDetector ) ) ; s . addRanges ( keyspaceName , Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) . getPendingAddressRanges ( tmd , myToken , myEndpoint ) ) ; Collection < Map . Entry < InetAddress , Collection < Range < Token > > > > toFetch = s . toFetch ( ) . get ( keyspaceName ) ; Set < Range < Token > > ranges = new HashSet < > ( ) ; for ( Map . Entry < InetAddress , Collection < Range < Token > > > e : toFetch ) ranges . addAll ( e . getValue ( ) ) ; assertEquals ( replicationFactor , ranges . size ( ) ) ; assert toFetch . iterator ( ) . next ( ) . getValue ( ) . size ( ) > <int> ; assert ! toFetch . iterator ( ) . next ( ) . getKey ( ) . equals ( myEndpoint ) ; return s ; } private void generateFakeEndpoints ( int numOldNodes ) throws UnknownHostException { generateFakeEndpoints ( StorageService . instance . getTokenMetadata ( ) , numOldNodes , <int> ) ; } private void generateFakeEndpoints ( TokenMetadata tmd , int numOldNodes , int numVNodes ) throws UnknownHostException { tmd . clearUnsafe ( ) ; IPartitioner p = tmd . partitioner ; for ( int i = <int> ; i < = numOldNodes ; i + + ) { InetAddress addr = InetAddress . getByName ( <str> + ( i + <int> ) ) ; List < Token > tokens = Lists . newArrayListWithCapacity ( numVNodes ) ; for ( int j = <int> ; j < numVNodes ; + + j ) tokens . add ( p . getRandomToken ( ) ) ; tmd . updateNormalTokens ( tokens , addr ) ; } } @Test public void testAllocateTokens ( ) throws UnknownHostException { int vn = <int> ; String ks = <str> ; TokenMetadata tm = new TokenMetadata ( ) ; generateFakeEndpoints ( tm , <int> , vn ) ; InetAddress addr = FBUtilities . getBroadcastAddress ( ) ; allocateTokensForNode ( vn , ks , tm , addr ) ; } private void allocateTokensForNode ( int vn , String ks , TokenMetadata tm , InetAddress addr ) { SummaryStatistics os = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ; Collection < Token > tokens = BootStrapper . allocateTokens ( tm , addr , ks , vn ) ; assertEquals ( vn , tokens . size ( ) ) ; tm . updateNormalTokens ( tokens , addr ) ; SummaryStatistics ns = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks ) . getReplicationStrategy ( ) , addr ) ; verifyImprovement ( os , ns ) ; } private void verifyImprovement ( SummaryStatistics os , SummaryStatistics ns ) { if ( ns . getStandardDeviation ( ) > os . getStandardDeviation ( ) ) { fail ( String . format ( <str> , os , ns ) ) ; } } @Test public void testAllocateTokensMultipleKeyspaces ( ) throws UnknownHostException { int vn = <int> ; String ks3 = <str> ; String ks2 = <str> ; TokenMetadata tm = new TokenMetadata ( ) ; generateFakeEndpoints ( tm , <int> , vn ) ; InetAddress dcaddr = FBUtilities . getBroadcastAddress ( ) ; SummaryStatistics os3 = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks3 ) . getReplicationStrategy ( ) , dcaddr ) ; SummaryStatistics os2 = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks2 ) . getReplicationStrategy ( ) , dcaddr ) ; String cks = ks3 ; String nks = ks2 ; for ( int i = <int> ; i < = <int> ; + + i ) { allocateTokensForNode ( vn , cks , tm , InetAddress . getByName ( <str> + ( i + <int> ) ) ) ; String t = cks ; cks = nks ; nks = t ; } SummaryStatistics ns3 = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks3 ) . getReplicationStrategy ( ) , dcaddr ) ; SummaryStatistics ns2 = TokenAllocation . replicatedOwnershipStats ( tm , Keyspace . open ( ks2 ) . getReplicationStrategy ( ) , dcaddr ) ; verifyImprovement ( os3 , ns3 ) ; verifyImprovement ( os2 , ns2 ) ; } } 
