package org . elasticsearch . client . transport ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . client . support . Headers ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BaseTransportResponseHandler ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . io . Closeable ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; public class TransportClientNodesServiceTests extends ESTestCase { private static class TestIteration implements Closeable { private final ThreadPool threadPool ; private final FailAndRetryMockTransport < TestResponse > transport ; private final TransportService transportService ; private final TransportClientNodesService transportClientNodesService ; private final int nodesCount ; TestIteration ( ) { threadPool = new ThreadPool ( <str> ) ; transport = new FailAndRetryMockTransport < TestResponse > ( getRandom ( ) ) { @Override public List < String > getLocalAddresses ( ) { return Collections . emptyList ( ) ; } @Override protected TestResponse newResponse ( ) { return new TestResponse ( ) ; } } ; transportService = new TransportService ( Settings . EMPTY , transport , threadPool ) ; transportService . start ( ) ; transportClientNodesService = new TransportClientNodesService ( Settings . EMPTY , ClusterName . DEFAULT , transportService , threadPool , Headers . EMPTY , Version . CURRENT ) ; nodesCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < nodesCount ; i + + ) { transportClientNodesService . addTransportAddresses ( new LocalTransportAddress ( <str> + i ) ) ; } transport . endConnectMode ( ) ; } @Override public void close ( ) { transportService . stop ( ) ; transportClientNodesService . close ( ) ; try { terminate ( threadPool ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } } } public void testListenerFailures ( ) throws InterruptedException { int iters = iterations ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { try ( final TestIteration iteration = new TestIteration ( ) ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicInteger finalFailures = new AtomicInteger ( ) ; final AtomicReference < Throwable > finalFailure = new AtomicReference < > ( ) ; final AtomicReference < TestResponse > response = new AtomicReference < > ( ) ; ActionListener < TestResponse > actionListener = new ActionListener < TestResponse > ( ) { @Override public void onResponse ( TestResponse testResponse ) { response . set ( testResponse ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable e ) { finalFailures . incrementAndGet ( ) ; finalFailure . set ( e ) ; latch . countDown ( ) ; } } ; final AtomicInteger preSendFailures = new AtomicInteger ( ) ; iteration . transportClientNodesService . execute ( new TransportClientNodesService . NodeListenerCallback < TestResponse > ( ) { @Override public void doWithNode ( DiscoveryNode node , final ActionListener < TestResponse > retryListener ) { if ( rarely ( ) ) { preSendFailures . incrementAndGet ( ) ; throw new IllegalArgumentException ( ) ; } iteration . transportService . sendRequest ( node , <str> , new TestRequest ( ) , TransportRequestOptions . EMPTY , new BaseTransportResponseHandler < TestResponse > ( ) { @Override public TestResponse newInstance ( ) { return new TestResponse ( ) ; } @Override public void handleResponse ( TestResponse response ) { retryListener . onResponse ( response ) ; } @Override public void handleException ( TransportException exp ) { retryListener . onFailure ( exp ) ; } @Override public String executor ( ) { return randomBoolean ( ) ? ThreadPool . Names . SAME : ThreadPool . Names . GENERIC ; } } ) ; } } , actionListener ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; assertThat ( preSendFailures . get ( ) + iteration . transport . failures ( ) + iteration . transport . successes ( ) , lessThanOrEqualTo ( <int> ) ) ; if ( iteration . transport . successes ( ) = = <int> ) { assertThat ( finalFailures . get ( ) , equalTo ( <int> ) ) ; assertThat ( finalFailure . get ( ) , nullValue ( ) ) ; assertThat ( response . get ( ) , notNullValue ( ) ) ; } else { assertThat ( finalFailures . get ( ) , equalTo ( <int> ) ) ; assertThat ( finalFailure . get ( ) , notNullValue ( ) ) ; assertThat ( response . get ( ) , nullValue ( ) ) ; if ( preSendFailures . get ( ) = = <int> & & iteration . transport . failures ( ) = = <int> ) { assertThat ( finalFailure . get ( ) , instanceOf ( NoNodeAvailableException . class ) ) ; } } assertThat ( iteration . transport . triedNodes ( ) . size ( ) , lessThanOrEqualTo ( iteration . nodesCount ) ) ; assertThat ( iteration . transport . triedNodes ( ) . size ( ) , equalTo ( iteration . transport . connectTransportExceptions ( ) + iteration . transport . failures ( ) + iteration . transport . successes ( ) ) ) ; } } } public static class TestRequest extends TransportRequest { } private static class TestResponse extends TransportResponse { } } 
