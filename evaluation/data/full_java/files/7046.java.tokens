package org . elasticsearch . rest . action . index ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import org . elasticsearch . rest . action . support . RestStatusToXContentListener ; import java . io . IOException ; import static org . elasticsearch . rest . RestRequest . Method . POST ; import static org . elasticsearch . rest . RestRequest . Method . PUT ; import static org . elasticsearch . rest . RestStatus . * ; public class RestIndexAction extends BaseRestHandler { @Inject public RestIndexAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( PUT , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; CreateHandler createHandler = new CreateHandler ( settings , controller , client ) ; controller . registerHandler ( PUT , <str> , createHandler ) ; controller . registerHandler ( POST , <str> , createHandler ) ; } final class CreateHandler extends BaseRestHandler { protected CreateHandler ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; } @Override public void handleRequest ( RestRequest request , RestChannel channel , final Client client ) { request . params ( ) . put ( <str> , <str> ) ; RestIndexAction . this . handleRequest ( request , channel , client ) ; } } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { IndexRequest indexRequest = new IndexRequest ( request . param ( <str> ) , request . param ( <str> ) , request . param ( <str> ) ) ; indexRequest . routing ( request . param ( <str> ) ) ; indexRequest . parent ( request . param ( <str> ) ) ; indexRequest . timestamp ( request . param ( <str> ) ) ; if ( request . hasParam ( <str> ) ) { indexRequest . ttl ( request . param ( <str> ) ) ; } indexRequest . source ( request . content ( ) ) ; indexRequest . timeout ( request . paramAsTime ( <str> , IndexRequest . DEFAULT_TIMEOUT ) ) ; indexRequest . refresh ( request . paramAsBoolean ( <str> , indexRequest . refresh ( ) ) ) ; indexRequest . version ( RestActions . parseVersion ( request ) ) ; indexRequest . versionType ( VersionType . fromString ( request . param ( <str> ) , indexRequest . versionType ( ) ) ) ; String sOpType = request . param ( <str> ) ; if ( sOpType ! = null ) { try { indexRequest . opType ( IndexRequest . OpType . fromString ( sOpType ) ) ; } catch ( IllegalArgumentException eia ) { try { XContentBuilder builder = channel . newErrorBuilder ( ) ; channel . sendResponse ( new BytesRestResponse ( BAD_REQUEST , builder . startObject ( ) . field ( <str> , eia . getMessage ( ) ) . endObject ( ) ) ) ; } catch ( IOException e1 ) { logger . warn ( <str> , e1 ) ; return ; } } } String consistencyLevel = request . param ( <str> ) ; if ( consistencyLevel ! = null ) { indexRequest . consistencyLevel ( WriteConsistencyLevel . fromString ( consistencyLevel ) ) ; } client . index ( indexRequest , new RestStatusToXContentListener < > ( channel ) ) ; } } 
