package com . google . common . collect ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Objects ; import com . google . j2objc . annotations . WeakOuter ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . Arrays ; import java . util . Collection ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) public final class LinkedHashMultimap < K , V > extends AbstractSetMultimap < K , V > { public static < K , V > LinkedHashMultimap < K , V > create ( ) { return new LinkedHashMultimap < K , V > ( DEFAULT_KEY_CAPACITY , DEFAULT_VALUE_SET_CAPACITY ) ; } public static < K , V > LinkedHashMultimap < K , V > create ( int expectedKeys , int expectedValuesPerKey ) { return new LinkedHashMultimap < K , V > ( Maps . capacity ( expectedKeys ) , Maps . capacity ( expectedValuesPerKey ) ) ; } public static < K , V > LinkedHashMultimap < K , V > create ( Multimap < ? extends K , ? extends V > multimap ) { LinkedHashMultimap < K , V > result = create ( multimap . keySet ( ) . size ( ) , DEFAULT_VALUE_SET_CAPACITY ) ; result . putAll ( multimap ) ; return result ; } private interface ValueSetLink < K , V > { ValueSetLink < K , V > getPredecessorInValueSet ( ) ; ValueSetLink < K , V > getSuccessorInValueSet ( ) ; void setPredecessorInValueSet ( ValueSetLink < K , V > entry ) ; void setSuccessorInValueSet ( ValueSetLink < K , V > entry ) ; } private static < K , V > void succeedsInValueSet ( ValueSetLink < K , V > pred , ValueSetLink < K , V > succ ) { pred . setSuccessorInValueSet ( succ ) ; succ . setPredecessorInValueSet ( pred ) ; } private static < K , V > void succeedsInMultimap ( ValueEntry < K , V > pred , ValueEntry < K , V > succ ) { pred . setSuccessorInMultimap ( succ ) ; succ . setPredecessorInMultimap ( pred ) ; } private static < K , V > void deleteFromValueSet ( ValueSetLink < K , V > entry ) { succeedsInValueSet ( entry . getPredecessorInValueSet ( ) , entry . getSuccessorInValueSet ( ) ) ; } private static < K , V > void deleteFromMultimap ( ValueEntry < K , V > entry ) { succeedsInMultimap ( entry . getPredecessorInMultimap ( ) , entry . getSuccessorInMultimap ( ) ) ; } @VisibleForTesting static final class ValueEntry < K , V > extends ImmutableEntry < K , V > implements ValueSetLink < K , V > { final int smearedValueHash ; @Nullable ValueEntry < K , V > nextInValueBucket ; ValueSetLink < K , V > predecessorInValueSet ; ValueSetLink < K , V > successorInValueSet ; ValueEntry < K , V > predecessorInMultimap ; ValueEntry < K , V > successorInMultimap ; ValueEntry ( @Nullable K key , @Nullable V value , int smearedValueHash , @Nullable ValueEntry < K , V > nextInValueBucket ) { super ( key , value ) ; this . smearedValueHash = smearedValueHash ; this . nextInValueBucket = nextInValueBucket ; } boolean matchesValue ( @Nullable Object v , int smearedVHash ) { return smearedValueHash = = smearedVHash & & Objects . equal ( getValue ( ) , v ) ; } @Override public ValueSetLink < K , V > getPredecessorInValueSet ( ) { return predecessorInValueSet ; } @Override public ValueSetLink < K , V > getSuccessorInValueSet ( ) { return successorInValueSet ; } @Override public void setPredecessorInValueSet ( ValueSetLink < K , V > entry ) { predecessorInValueSet = entry ; } @Override public void setSuccessorInValueSet ( ValueSetLink < K , V > entry ) { successorInValueSet = entry ; } public ValueEntry < K , V > getPredecessorInMultimap ( ) { return predecessorInMultimap ; } public ValueEntry < K , V > getSuccessorInMultimap ( ) { return successorInMultimap ; } public void setSuccessorInMultimap ( ValueEntry < K , V > multimapSuccessor ) { this . successorInMultimap = multimapSuccessor ; } public void setPredecessorInMultimap ( ValueEntry < K , V > multimapPredecessor ) { this . predecessorInMultimap = multimapPredecessor ; } } private static final int DEFAULT_KEY_CAPACITY = <int> ; private static final int DEFAULT_VALUE_SET_CAPACITY = <int> ; @VisibleForTesting static final double VALUE_SET_LOAD_FACTOR = <float> ; @VisibleForTesting transient int valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY ; private transient ValueEntry < K , V > multimapHeaderEntry ; private LinkedHashMultimap ( int keyCapacity , int valueSetCapacity ) { super ( new LinkedHashMap < K , Collection < V > > ( keyCapacity ) ) ; checkNonnegative ( valueSetCapacity , <str> ) ; this . valueSetCapacity = valueSetCapacity ; this . multimapHeaderEntry = new ValueEntry < K , V > ( null , null , <int> , null ) ; succeedsInMultimap ( multimapHeaderEntry , multimapHeaderEntry ) ; } @Override Set < V > createCollection ( ) { return new LinkedHashSet < V > ( valueSetCapacity ) ; } @Override Collection < V > createCollection ( K key ) { return new ValueSet ( key , valueSetCapacity ) ; } @Override public Set < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { return super . replaceValues ( key , values ) ; } @Override public Set < Map . Entry < K , V > > entries ( ) { return super . entries ( ) ; } @Override public Collection < V > values ( ) { return super . values ( ) ; } @VisibleForTesting @WeakOuter final class ValueSet extends Sets . ImprovedAbstractSet < V > implements ValueSetLink < K , V > { private final K key ; @VisibleForTesting ValueEntry < K , V > [ ] hashTable ; private int size = <int> ; private int modCount = <int> ; private ValueSetLink < K , V > firstEntry ; private ValueSetLink < K , V > lastEntry ; ValueSet ( K key , int expectedValues ) { this . key = key ; this . firstEntry = this ; this . lastEntry = this ; int tableSize = Hashing . closedTableSize ( expectedValues , VALUE_SET_LOAD_FACTOR ) ; @SuppressWarnings ( <str> ) ValueEntry < K , V > [ ] hashTable = new ValueEntry [ tableSize ] ; this . hashTable = hashTable ; } private int mask ( ) { return hashTable . length - <int> ; } @Override public ValueSetLink < K , V > getPredecessorInValueSet ( ) { return lastEntry ; } @Override public ValueSetLink < K , V > getSuccessorInValueSet ( ) { return firstEntry ; } @Override public void setPredecessorInValueSet ( ValueSetLink < K , V > entry ) { lastEntry = entry ; } @Override public void setSuccessorInValueSet ( ValueSetLink < K , V > entry ) { firstEntry = entry ; } @Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { ValueSetLink < K , V > nextEntry = firstEntry ; ValueEntry < K , V > toRemove ; int expectedModCount = modCount ; private void checkForComodification ( ) { if ( modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } } @Override public boolean hasNext ( ) { checkForComodification ( ) ; return nextEntry ! = ValueSet . this ; } @Override public V next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } ValueEntry < K , V > entry = ( ValueEntry < K , V > ) nextEntry ; V result = entry . getValue ( ) ; toRemove = entry ; nextEntry = entry . getSuccessorInValueSet ( ) ; return result ; } @Override public void remove ( ) { checkForComodification ( ) ; checkRemove ( toRemove ! = null ) ; ValueSet . this . remove ( toRemove . getValue ( ) ) ; expectedModCount = modCount ; toRemove = null ; } } ; } @Override public int size ( ) { return size ; } @Override public boolean contains ( @Nullable Object o ) { int smearedHash = Hashing . smearedHash ( o ) ; for ( ValueEntry < K , V > entry = hashTable [ smearedHash & mask ( ) ] ; entry ! = null ; entry = entry . nextInValueBucket ) { if ( entry . matchesValue ( o , smearedHash ) ) { return true ; } } return false ; } @Override public boolean add ( @Nullable V value ) { int smearedHash = Hashing . smearedHash ( value ) ; int bucket = smearedHash & mask ( ) ; ValueEntry < K , V > rowHead = hashTable [ bucket ] ; for ( ValueEntry < K , V > entry = rowHead ; entry ! = null ; entry = entry . nextInValueBucket ) { if ( entry . matchesValue ( value , smearedHash ) ) { return false ; } } ValueEntry < K , V > newEntry = new ValueEntry < K , V > ( key , value , smearedHash , rowHead ) ; succeedsInValueSet ( lastEntry , newEntry ) ; succeedsInValueSet ( newEntry , this ) ; succeedsInMultimap ( multimapHeaderEntry . getPredecessorInMultimap ( ) , newEntry ) ; succeedsInMultimap ( newEntry , multimapHeaderEntry ) ; hashTable [ bucket ] = newEntry ; size + + ; modCount + + ; rehashIfNecessary ( ) ; return true ; } private void rehashIfNecessary ( ) { if ( Hashing . needsResizing ( size , hashTable . length , VALUE_SET_LOAD_FACTOR ) ) { @SuppressWarnings ( <str> ) ValueEntry < K , V > [ ] hashTable = new ValueEntry [ this . hashTable . length * <int> ] ; this . hashTable = hashTable ; int mask = hashTable . length - <int> ; for ( ValueSetLink < K , V > entry = firstEntry ; entry ! = this ; entry = entry . getSuccessorInValueSet ( ) ) { ValueEntry < K , V > valueEntry = ( ValueEntry < K , V > ) entry ; int bucket = valueEntry . smearedValueHash & mask ; valueEntry . nextInValueBucket = hashTable [ bucket ] ; hashTable [ bucket ] = valueEntry ; } } } @Override public boolean remove ( @Nullable Object o ) { int smearedHash = Hashing . smearedHash ( o ) ; int bucket = smearedHash & mask ( ) ; ValueEntry < K , V > prev = null ; for ( ValueEntry < K , V > entry = hashTable [ bucket ] ; entry ! = null ; prev = entry , entry = entry . nextInValueBucket ) { if ( entry . matchesValue ( o , smearedHash ) ) { if ( prev = = null ) { hashTable [ bucket ] = entry . nextInValueBucket ; } else { prev . nextInValueBucket = entry . nextInValueBucket ; } deleteFromValueSet ( entry ) ; deleteFromMultimap ( entry ) ; size - - ; modCount + + ; return true ; } } return false ; } @Override public void clear ( ) { Arrays . fill ( hashTable , null ) ; size = <int> ; for ( ValueSetLink < K , V > entry = firstEntry ; entry ! = this ; entry = entry . getSuccessorInValueSet ( ) ) { ValueEntry < K , V > valueEntry = ( ValueEntry < K , V > ) entry ; deleteFromMultimap ( valueEntry ) ; } succeedsInValueSet ( this , this ) ; modCount + + ; } } @Override Iterator < Map . Entry < K , V > > entryIterator ( ) { return new Iterator < Map . Entry < K , V > > ( ) { ValueEntry < K , V > nextEntry = multimapHeaderEntry . successorInMultimap ; ValueEntry < K , V > toRemove ; @Override public boolean hasNext ( ) { return nextEntry ! = multimapHeaderEntry ; } @Override public Map . Entry < K , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } ValueEntry < K , V > result = nextEntry ; toRemove = result ; nextEntry = nextEntry . successorInMultimap ; return result ; } @Override public void remove ( ) { checkRemove ( toRemove ! = null ) ; LinkedHashMultimap . this . remove ( toRemove . getKey ( ) , toRemove . getValue ( ) ) ; toRemove = null ; } } ; } @Override Iterator < V > valueIterator ( ) { return Maps . valueIterator ( entryIterator ( ) ) ; } @Override public void clear ( ) { super . clear ( ) ; succeedsInMultimap ( multimapHeaderEntry , multimapHeaderEntry ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeInt ( keySet ( ) . size ( ) ) ; for ( K key : keySet ( ) ) { stream . writeObject ( key ) ; } stream . writeInt ( size ( ) ) ; for ( Map . Entry < K , V > entry : entries ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } } @GwtIncompatible ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; multimapHeaderEntry = new ValueEntry < K , V > ( null , null , <int> , null ) ; succeedsInMultimap ( multimapHeaderEntry , multimapHeaderEntry ) ; valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY ; int distinctKeys = stream . readInt ( ) ; Map < K , Collection < V > > map = new LinkedHashMap < K , Collection < V > > ( ) ; for ( int i = <int> ; i < distinctKeys ; i + + ) { @SuppressWarnings ( <str> ) K key = ( K ) stream . readObject ( ) ; map . put ( key , createCollection ( key ) ) ; } int entries = stream . readInt ( ) ; for ( int i = <int> ; i < entries ; i + + ) { @SuppressWarnings ( <str> ) K key = ( K ) stream . readObject ( ) ; @SuppressWarnings ( <str> ) V value = ( V ) stream . readObject ( ) ; map . get ( key ) . add ( value ) ; } setMap ( map ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } 
