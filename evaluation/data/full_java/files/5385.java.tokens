package org . elasticsearch . action . search . type ; import com . carrotsearch . hppc . IntArrayList ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . TopDocs ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . NoShardAvailableActionException ; import org . elasticsearch . action . search . ReduceSearchPhaseException ; import org . elasticsearch . action . search . SearchAction ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . ShardSearchFailure ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . TransportAction ; import org . elasticsearch . action . support . TransportActions ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . AtomicArray ; import org . elasticsearch . search . SearchPhaseResult ; import org . elasticsearch . search . SearchShardTarget ; import org . elasticsearch . search . action . SearchServiceTransportAction ; import org . elasticsearch . search . controller . SearchPhaseController ; import org . elasticsearch . search . fetch . ShardFetchSearchRequest ; import org . elasticsearch . search . internal . InternalSearchResponse ; import org . elasticsearch . search . internal . ShardSearchTransportRequest ; import org . elasticsearch . search . query . QuerySearchResult ; import org . elasticsearch . search . query . QuerySearchResultProvider ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . action . search . type . TransportSearchHelper . internalSearchRequest ; public abstract class TransportSearchTypeAction extends TransportAction < SearchRequest , SearchResponse > { protected final ClusterService clusterService ; protected final SearchServiceTransportAction searchService ; protected final SearchPhaseController searchPhaseController ; public TransportSearchTypeAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , SearchAction . NAME , threadPool , actionFilters , indexNameExpressionResolver ) ; this . clusterService = clusterService ; this . searchService = searchService ; this . searchPhaseController = searchPhaseController ; } protected abstract class BaseAsyncAction < FirstResult extends SearchPhaseResult > extends AbstractAsyncAction { protected final ActionListener < SearchResponse > listener ; protected final GroupShardsIterator shardsIts ; protected final SearchRequest request ; protected final ClusterState clusterState ; protected final DiscoveryNodes nodes ; protected final int expectedSuccessfulOps ; private final int expectedTotalOps ; protected final AtomicInteger successfulOps = new AtomicInteger ( ) ; private final AtomicInteger totalOps = new AtomicInteger ( ) ; protected final AtomicArray < FirstResult > firstResults ; private volatile AtomicArray < ShardSearchFailure > shardFailures ; private final Object shardFailuresMutex = new Object ( ) ; protected volatile ScoreDoc [ ] sortedShardList ; protected BaseAsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { this . request = request ; this . listener = listener ; this . clusterState = clusterService . state ( ) ; nodes = clusterState . nodes ( ) ; clusterState . blocks ( ) . globalBlockedRaiseException ( ClusterBlockLevel . READ ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request . indicesOptions ( ) , startTime ( ) , request . indices ( ) ) ; for ( String index : concreteIndices ) { clusterState . blocks ( ) . indexBlockedRaiseException ( ClusterBlockLevel . READ , index ) ; } Map < String , Set < String > > routingMap = indexNameExpressionResolver . resolveSearchRouting ( clusterState , request . routing ( ) , request . indices ( ) ) ; shardsIts = clusterService . operationRouting ( ) . searchShards ( clusterState , concreteIndices , routingMap , request . preference ( ) ) ; expectedSuccessfulOps = shardsIts . size ( ) ; expectedTotalOps = shardsIts . totalSizeWith1ForEmpty ( ) ; firstResults = new AtomicArray < > ( shardsIts . size ( ) ) ; } public void start ( ) { if ( expectedSuccessfulOps = = <int> ) { listener . onResponse ( new SearchResponse ( InternalSearchResponse . empty ( ) , null , <int> , <int> , buildTookInMillis ( ) , ShardSearchFailure . EMPTY_ARRAY ) ) ; return ; } int shardIndex = - <int> ; for ( final ShardIterator shardIt : shardsIts ) { shardIndex + + ; final ShardRouting shard = shardIt . nextOrNull ( ) ; if ( shard ! = null ) { performFirstPhase ( shardIndex , shardIt , shard ) ; } else { onFirstPhaseResult ( shardIndex , null , null , shardIt , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } } } void performFirstPhase ( final int shardIndex , final ShardIterator shardIt , final ShardRouting shard ) { if ( shard = = null ) { onFirstPhaseResult ( shardIndex , null , null , shardIt , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } else { final DiscoveryNode node = nodes . get ( shard . currentNodeId ( ) ) ; if ( node = = null ) { onFirstPhaseResult ( shardIndex , shard , null , shardIt , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } else { String [ ] filteringAliases = indexNameExpressionResolver . filteringAliases ( clusterState , shard . index ( ) , request . indices ( ) ) ; sendExecuteFirstPhase ( node , internalSearchRequest ( shard , shardsIts . size ( ) , request , filteringAliases , startTime ( ) ) , new ActionListener < FirstResult > ( ) { @Override public void onResponse ( FirstResult result ) { onFirstPhaseResult ( shardIndex , shard , result , shardIt ) ; } @Override public void onFailure ( Throwable t ) { onFirstPhaseResult ( shardIndex , shard , node . id ( ) , shardIt , t ) ; } } ) ; } } } void onFirstPhaseResult ( int shardIndex , ShardRouting shard , FirstResult result , ShardIterator shardIt ) { result . shardTarget ( new SearchShardTarget ( shard . currentNodeId ( ) , shard . index ( ) , shard . id ( ) ) ) ; processFirstPhaseResult ( shardIndex , result ) ; successfulOps . incrementAndGet ( ) ; final int xTotalOps = totalOps . addAndGet ( shardIt . remaining ( ) + <int> ) ; if ( xTotalOps = = expectedTotalOps ) { try { innerMoveToSecondPhase ( ) ; } catch ( Throwable e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( shardIt . shardId ( ) + <str> + request + <str> , e ) ; } raiseEarlyFailure ( new ReduceSearchPhaseException ( firstPhaseName ( ) , <str> , e , buildShardFailures ( ) ) ) ; } } else if ( xTotalOps > expectedTotalOps ) { raiseEarlyFailure ( new IllegalStateException ( <str> + xTotalOps + <str> + expectedTotalOps + <str> ) ) ; } } void onFirstPhaseResult ( final int shardIndex , @Nullable ShardRouting shard , @Nullable String nodeId , final ShardIterator shardIt , Throwable t ) { SearchShardTarget shardTarget = new SearchShardTarget ( nodeId , shardIt . shardId ( ) . getIndex ( ) , shardIt . shardId ( ) . getId ( ) ) ; addShardFailure ( shardIndex , shardTarget , t ) ; if ( totalOps . incrementAndGet ( ) = = expectedTotalOps ) { if ( logger . isDebugEnabled ( ) ) { if ( t ! = null & & ! TransportActions . isShardNotAvailableException ( t ) ) { if ( shard ! = null ) { logger . debug ( shard . shortSummary ( ) + <str> + request + <str> , t ) ; } else { logger . debug ( shardIt . shardId ( ) + <str> + request + <str> , t ) ; } } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , t , shard , request ) ; } } final ShardSearchFailure [ ] shardSearchFailures = buildShardFailures ( ) ; if ( successfulOps . get ( ) = = <int> ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , t , firstPhaseName ( ) ) ; } raiseEarlyFailure ( new SearchPhaseExecutionException ( firstPhaseName ( ) , <str> , t , shardSearchFailures ) ) ; } else { try { innerMoveToSecondPhase ( ) ; } catch ( Throwable e ) { raiseEarlyFailure ( new ReduceSearchPhaseException ( firstPhaseName ( ) , <str> , e , shardSearchFailures ) ) ; } } } else { final ShardRouting nextShard = shardIt . nextOrNull ( ) ; final boolean lastShard = nextShard = = null ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( executionFailureMsg ( shard , shardIt , request , lastShard ) , t ) ; } if ( ! lastShard ) { try { performFirstPhase ( shardIndex , shardIt , nextShard ) ; } catch ( Throwable t1 ) { onFirstPhaseResult ( shardIndex , shard , shard . currentNodeId ( ) , shardIt , t1 ) ; } } else { if ( logger . isDebugEnabled ( ) & & ! logger . isTraceEnabled ( ) ) { if ( t ! = null & & ! TransportActions . isShardNotAvailableException ( t ) ) { logger . debug ( executionFailureMsg ( shard , shardIt , request , lastShard ) , t ) ; } } } } } private String executionFailureMsg ( @Nullable ShardRouting shard , final ShardIterator shardIt , SearchRequest request , boolean lastShard ) { if ( shard ! = null ) { return shard . shortSummary ( ) + <str> + request + <str> + lastShard + <str> ; } else { return shardIt . shardId ( ) + <str> + request + <str> + lastShard + <str> ; } } protected final ShardSearchFailure [ ] buildShardFailures ( ) { AtomicArray < ShardSearchFailure > shardFailures = this . shardFailures ; if ( shardFailures = = null ) { return ShardSearchFailure . EMPTY_ARRAY ; } List < AtomicArray . Entry < ShardSearchFailure > > entries = shardFailures . asList ( ) ; ShardSearchFailure [ ] failures = new ShardSearchFailure [ entries . size ( ) ] ; for ( int i = <int> ; i < failures . length ; i + + ) { failures [ i ] = entries . get ( i ) . value ; } return failures ; } protected final void addShardFailure ( final int shardIndex , @Nullable SearchShardTarget shardTarget , Throwable t ) { if ( TransportActions . isShardNotAvailableException ( t ) ) { return ; } if ( shardFailures = = null ) { synchronized ( shardFailuresMutex ) { if ( shardFailures = = null ) { shardFailures = new AtomicArray < > ( shardsIts . size ( ) ) ; } } } ShardSearchFailure failure = shardFailures . get ( shardIndex ) ; if ( failure = = null ) { shardFailures . set ( shardIndex , new ShardSearchFailure ( t , shardTarget ) ) ; } else { if ( TransportActions . isReadOverrideException ( t ) ) { shardFailures . set ( shardIndex , new ShardSearchFailure ( t , shardTarget ) ) ; } } } private void raiseEarlyFailure ( Throwable t ) { for ( AtomicArray . Entry < FirstResult > entry : firstResults . asList ( ) ) { try { DiscoveryNode node = nodes . get ( entry . value . shardTarget ( ) . nodeId ( ) ) ; sendReleaseSearchContext ( entry . value . id ( ) , node ) ; } catch ( Throwable t1 ) { logger . trace ( <str> , t1 ) ; } } listener . onFailure ( t ) ; } protected void releaseIrrelevantSearchContexts ( AtomicArray < ? extends QuerySearchResultProvider > queryResults , AtomicArray < IntArrayList > docIdsToLoad ) { if ( docIdsToLoad = = null ) { return ; } if ( request . scroll ( ) = = null ) { for ( AtomicArray . Entry < ? extends QuerySearchResultProvider > entry : queryResults . asList ( ) ) { final TopDocs topDocs = entry . value . queryResult ( ) . queryResult ( ) . topDocs ( ) ; if ( topDocs ! = null & & topDocs . scoreDocs . length > <int> & & docIdsToLoad . get ( entry . index ) = = null ) { try { DiscoveryNode node = nodes . get ( entry . value . queryResult ( ) . shardTarget ( ) . nodeId ( ) ) ; sendReleaseSearchContext ( entry . value . queryResult ( ) . id ( ) , node ) ; } catch ( Throwable t1 ) { logger . trace ( <str> , t1 ) ; } } } } } protected void sendReleaseSearchContext ( long contextId , DiscoveryNode node ) { if ( node ! = null ) { searchService . sendFreeContext ( node , contextId , request ) ; } } protected ShardFetchSearchRequest createFetchRequest ( QuerySearchResult queryResult , AtomicArray . Entry < IntArrayList > entry , ScoreDoc [ ] lastEmittedDocPerShard ) { if ( lastEmittedDocPerShard ! = null ) { ScoreDoc lastEmittedDoc = lastEmittedDocPerShard [ entry . index ] ; return new ShardFetchSearchRequest ( request , queryResult . id ( ) , entry . value , lastEmittedDoc ) ; } else { return new ShardFetchSearchRequest ( request , queryResult . id ( ) , entry . value ) ; } } protected abstract void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchTransportRequest request , ActionListener < FirstResult > listener ) ; protected final void processFirstPhaseResult ( int shardIndex , FirstResult result ) { firstResults . set ( shardIndex , result ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , result ! = null ? result . shardTarget ( ) : null ) ; } AtomicArray < ShardSearchFailure > shardFailures = this . shardFailures ; if ( shardFailures ! = null ) { shardFailures . set ( shardIndex , null ) ; } } final void innerMoveToSecondPhase ( ) throws Exception { if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; boolean hadOne = false ; for ( int i = <int> ; i < firstResults . length ( ) ; i + + ) { FirstResult result = firstResults . get ( i ) ; if ( result = = null ) { continue ; } if ( hadOne ) { sb . append ( <str> ) ; } else { hadOne = true ; } sb . append ( result . shardTarget ( ) ) ; } logger . trace ( <str> , sb , clusterState . version ( ) ) ; } moveToSecondPhase ( ) ; } protected abstract void moveToSecondPhase ( ) throws Exception ; protected abstract String firstPhaseName ( ) ; } } 
