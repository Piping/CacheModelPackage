package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . DecoderResultProvider ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . util . CharsetUtil ; import org . easymock . EasyMock ; import org . junit . Test ; import java . nio . channels . ClosedChannelException ; import java . util . List ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static io . netty . util . ReferenceCountUtil . releaseLater ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class HttpObjectAggregatorTest { @Test public void testAggregate ( ) { HttpObjectAggregator aggr = new HttpObjectAggregator ( <int> * <int> ) ; EmbeddedChannel embedder = new EmbeddedChannel ( aggr ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ; message . headers ( ) . set ( of ( <str> ) , true ) ; HttpContent chunk1 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk2 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk3 = new DefaultLastHttpContent ( Unpooled . EMPTY_BUFFER ) ; assertFalse ( embedder . writeInbound ( message ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; assertTrue ( embedder . writeInbound ( chunk3 ) ) ; assertTrue ( embedder . finish ( ) ) ; FullHttpRequest aggratedMessage = embedder . readInbound ( ) ; assertNotNull ( aggratedMessage ) ; assertEquals ( chunk1 . content ( ) . readableBytes ( ) + chunk2 . content ( ) . readableBytes ( ) , HttpUtil . getContentLength ( aggratedMessage ) ) ; assertEquals ( aggratedMessage . headers ( ) . get ( of ( <str> ) ) , Boolean . TRUE . toString ( ) ) ; checkContentBuffer ( aggratedMessage ) ; assertNull ( embedder . readInbound ( ) ) ; } private static void checkContentBuffer ( FullHttpRequest aggregatedMessage ) { CompositeByteBuf buffer = ( CompositeByteBuf ) aggregatedMessage . content ( ) ; assertEquals ( <int> , buffer . numComponents ( ) ) ; List < ByteBuf > buffers = buffer . decompose ( <int> , buffer . capacity ( ) ) ; assertEquals ( <int> , buffers . size ( ) ) ; for ( ByteBuf buf : buffers ) { assertFalse ( buf instanceof CompositeByteBuf ) ; } aggregatedMessage . release ( ) ; } @Test public void testAggregateWithTrailer ( ) { HttpObjectAggregator aggr = new HttpObjectAggregator ( <int> * <int> ) ; EmbeddedChannel embedder = new EmbeddedChannel ( aggr ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ; message . headers ( ) . set ( of ( <str> ) , true ) ; HttpUtil . setTransferEncodingChunked ( message , true ) ; HttpContent chunk1 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk2 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; LastHttpContent trailer = new DefaultLastHttpContent ( ) ; trailer . trailingHeaders ( ) . set ( of ( <str> ) , true ) ; assertFalse ( embedder . writeInbound ( message ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; assertTrue ( embedder . writeInbound ( trailer ) ) ; assertTrue ( embedder . finish ( ) ) ; FullHttpRequest aggratedMessage = embedder . readInbound ( ) ; assertNotNull ( aggratedMessage ) ; assertEquals ( chunk1 . content ( ) . readableBytes ( ) + chunk2 . content ( ) . readableBytes ( ) , HttpUtil . getContentLength ( aggratedMessage ) ) ; assertEquals ( aggratedMessage . headers ( ) . get ( of ( <str> ) ) , Boolean . TRUE . toString ( ) ) ; assertEquals ( aggratedMessage . trailingHeaders ( ) . get ( of ( <str> ) ) , Boolean . TRUE . toString ( ) ) ; checkContentBuffer ( aggratedMessage ) ; assertNull ( embedder . readInbound ( ) ) ; } @Test public void testOversizedRequest ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpObjectAggregator ( <int> ) ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; HttpContent chunk1 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk2 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk3 = LastHttpContent . EMPTY_LAST_CONTENT ; assertFalse ( embedder . writeInbound ( message ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; FullHttpResponse response = embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . REQUEST_ENTITY_TOO_LARGE , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; assertFalse ( embedder . isOpen ( ) ) ; try { assertFalse ( embedder . writeInbound ( chunk3 ) ) ; fail ( ) ; } catch ( Exception e ) { assertTrue ( e instanceof ClosedChannelException ) ; } assertFalse ( embedder . finish ( ) ) ; } @Test public void testOversizedRequestWithoutKeepAlive ( ) { HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_0 , HttpMethod . PUT , <str> ) ; HttpUtil . setContentLength ( message , <int> ) ; checkOversizedRequest ( message ) ; } @Test public void testOversizedRequestWithContentLength ( ) { HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; HttpUtil . setContentLength ( message , <int> ) ; checkOversizedRequest ( message ) ; } private static void checkOversizedRequest ( HttpRequest message ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpObjectAggregator ( <int> ) ) ; assertFalse ( embedder . writeInbound ( message ) ) ; HttpResponse response = embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . REQUEST_ENTITY_TOO_LARGE , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; if ( serverShouldCloseConnection ( message ) ) { assertFalse ( embedder . isOpen ( ) ) ; assertFalse ( embedder . finish ( ) ) ; } else { assertTrue ( embedder . isOpen ( ) ) ; } } private static boolean serverShouldCloseConnection ( HttpRequest message ) { if ( HttpUtil . is100ContinueExpected ( message ) ) { return false ; } if ( HttpUtil . isKeepAlive ( message ) ) { return false ; } return true ; } @Test public void testOversizedResponse ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpObjectAggregator ( <int> ) ) ; HttpResponse message = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; HttpContent chunk1 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk2 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; assertFalse ( embedder . writeInbound ( message ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; try { embedder . writeInbound ( chunk2 ) ; fail ( ) ; } catch ( TooLongFrameException expected ) { } assertFalse ( embedder . isOpen ( ) ) ; assertFalse ( embedder . finish ( ) ) ; } @Test ( expected = IllegalArgumentException . class ) public void testInvalidConstructorUsage ( ) { new HttpObjectAggregator ( - <int> ) ; } @Test ( expected = IllegalArgumentException . class ) public void testInvalidMaxCumulationBufferComponents ( ) { HttpObjectAggregator aggr = new HttpObjectAggregator ( Integer . MAX_VALUE ) ; aggr . setMaxCumulationBufferComponents ( <int> ) ; } @Test ( expected = IllegalStateException . class ) public void testSetMaxCumulationBufferComponentsAfterInit ( ) throws Exception { HttpObjectAggregator aggr = new HttpObjectAggregator ( Integer . MAX_VALUE ) ; ChannelHandlerContext ctx = EasyMock . createMock ( ChannelHandlerContext . class ) ; EasyMock . replay ( ctx ) ; aggr . handlerAdded ( ctx ) ; aggr . setMaxCumulationBufferComponents ( <int> ) ; } @Test public void testAggregateTransferEncodingChunked ( ) { HttpObjectAggregator aggr = new HttpObjectAggregator ( <int> * <int> ) ; EmbeddedChannel embedder = new EmbeddedChannel ( aggr ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; message . headers ( ) . set ( of ( <str> ) , true ) ; message . headers ( ) . set ( of ( <str> ) , of ( <str> ) ) ; HttpContent chunk1 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk2 = new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpContent chunk3 = LastHttpContent . EMPTY_LAST_CONTENT ; assertFalse ( embedder . writeInbound ( message ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; assertTrue ( embedder . writeInbound ( chunk3 ) ) ; assertTrue ( embedder . finish ( ) ) ; FullHttpRequest aggratedMessage = embedder . readInbound ( ) ; assertNotNull ( aggratedMessage ) ; assertEquals ( chunk1 . content ( ) . readableBytes ( ) + chunk2 . content ( ) . readableBytes ( ) , HttpUtil . getContentLength ( aggratedMessage ) ) ; assertEquals ( aggratedMessage . headers ( ) . get ( of ( <str> ) ) , Boolean . TRUE . toString ( ) ) ; checkContentBuffer ( aggratedMessage ) ; assertNull ( embedder . readInbound ( ) ) ; } @Test public void testBadRequest ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpRequestDecoder ( ) , new HttpObjectAggregator ( <int> * <int> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . UTF_8 ) ) ; Object inbound = ch . readInbound ( ) ; assertThat ( inbound , is ( instanceOf ( FullHttpRequest . class ) ) ) ; assertTrue ( ( ( DecoderResultProvider ) inbound ) . decoderResult ( ) . isFailure ( ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . finish ( ) ; } @Test public void testBadResponse ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) , new HttpObjectAggregator ( <int> * <int> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . UTF_8 ) ) ; Object inbound = ch . readInbound ( ) ; assertThat ( inbound , is ( instanceOf ( FullHttpResponse . class ) ) ) ; assertTrue ( ( ( DecoderResultProvider ) inbound ) . decoderResult ( ) . isFailure ( ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . finish ( ) ; } @Test public void testOversizedRequestWith100Continue ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpObjectAggregator ( <int> ) ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; HttpUtil . set100ContinueExpected ( message , true ) ; HttpUtil . setContentLength ( message , <int> ) ; HttpContent chunk1 = releaseLater ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; HttpContent chunk2 = releaseLater ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; HttpContent chunk3 = LastHttpContent . EMPTY_LAST_CONTENT ; assertFalse ( embedder . writeInbound ( message ) ) ; FullHttpResponse response = ( FullHttpResponse ) embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . EXPECTATION_FAILED , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertTrue ( embedder . isOpen ( ) ) ; HttpRequest message2 = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; assertFalse ( embedder . writeInbound ( message2 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; assertTrue ( embedder . writeInbound ( chunk3 ) ) ; FullHttpRequest fullMsg = ( FullHttpRequest ) embedder . readInbound ( ) ; assertNotNull ( fullMsg ) ; assertEquals ( chunk2 . content ( ) . readableBytes ( ) + chunk3 . content ( ) . readableBytes ( ) , HttpUtil . getContentLength ( fullMsg ) ) ; assertEquals ( HttpUtil . getContentLength ( fullMsg ) , fullMsg . content ( ) . readableBytes ( ) ) ; fullMsg . release ( ) ; assertFalse ( embedder . finish ( ) ) ; } @Test public void testOversizedRequestWith100ContinueAndDecoder ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpRequestDecoder ( ) , new HttpObjectAggregator ( <int> ) ) ; embedder . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + <str> , CharsetUtil . US_ASCII ) ) ; assertNull ( embedder . readInbound ( ) ) ; FullHttpResponse response = ( FullHttpResponse ) embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . EXPECTATION_FAILED , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; assertTrue ( embedder . isOpen ( ) ) ; embedder . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; FullHttpRequest request = ( FullHttpRequest ) embedder . readInbound ( ) ; assertThat ( request . method ( ) , is ( HttpMethod . GET ) ) ; assertThat ( request . uri ( ) , is ( <str> ) ) ; assertThat ( request . content ( ) . readableBytes ( ) , is ( <int> ) ) ; request . release ( ) ; assertFalse ( embedder . finish ( ) ) ; } @Test public void testOversizedRequestWith100ContinueAndDecoderCloseConnection ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpRequestDecoder ( ) , new HttpObjectAggregator ( <int> , true ) ) ; embedder . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + <str> , CharsetUtil . US_ASCII ) ) ; assertNull ( embedder . readInbound ( ) ) ; FullHttpResponse response = ( FullHttpResponse ) embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . EXPECTATION_FAILED , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; assertFalse ( embedder . isOpen ( ) ) ; assertFalse ( embedder . finish ( ) ) ; } @Test public void testRequestAfterOversized100ContinueAndDecoder ( ) { EmbeddedChannel embedder = new EmbeddedChannel ( new HttpRequestDecoder ( ) , new HttpObjectAggregator ( <int> ) ) ; HttpRequest message = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; HttpUtil . set100ContinueExpected ( message , true ) ; HttpUtil . setContentLength ( message , <int> ) ; HttpContent chunk1 = releaseLater ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; HttpContent chunk2 = releaseLater ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; HttpContent chunk3 = LastHttpContent . EMPTY_LAST_CONTENT ; assertFalse ( embedder . writeInbound ( message ) ) ; FullHttpResponse response = ( FullHttpResponse ) embedder . readOutbound ( ) ; assertEquals ( HttpResponseStatus . EXPECTATION_FAILED , response . status ( ) ) ; assertEquals ( <str> , response . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) ) ; assertFalse ( embedder . writeInbound ( chunk1 ) ) ; assertTrue ( embedder . isOpen ( ) ) ; HttpRequest message2 = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> ) ; assertFalse ( embedder . writeInbound ( message2 ) ) ; assertFalse ( embedder . writeInbound ( chunk2 ) ) ; assertTrue ( embedder . writeInbound ( chunk3 ) ) ; FullHttpRequest fullMsg = ( FullHttpRequest ) embedder . readInbound ( ) ; assertNotNull ( fullMsg ) ; assertEquals ( chunk2 . content ( ) . readableBytes ( ) + chunk3 . content ( ) . readableBytes ( ) , HttpUtil . getContentLength ( fullMsg ) ) ; assertEquals ( HttpUtil . getContentLength ( fullMsg ) , fullMsg . content ( ) . readableBytes ( ) ) ; fullMsg . release ( ) ; assertFalse ( embedder . finish ( ) ) ; } } 
