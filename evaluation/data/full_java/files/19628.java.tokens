package io . netty . util ; import io . netty . util . internal . PlatformDependent ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public abstract class AbstractReferenceCounted implements ReferenceCounted { private static final AtomicIntegerFieldUpdater < AbstractReferenceCounted > refCntUpdater ; static { AtomicIntegerFieldUpdater < AbstractReferenceCounted > updater = PlatformDependent . newAtomicIntegerFieldUpdater ( AbstractReferenceCounted . class , <str> ) ; if ( updater = = null ) { updater = AtomicIntegerFieldUpdater . newUpdater ( AbstractReferenceCounted . class , <str> ) ; } refCntUpdater = updater ; } private volatile int refCnt = <int> ; @Override public final int refCnt ( ) { return refCnt ; } protected final void setRefCnt ( int refCnt ) { this . refCnt = refCnt ; } @Override public ReferenceCounted retain ( ) { for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , <int> ) ; } if ( refCnt = = Integer . MAX_VALUE ) { throw new IllegalReferenceCountException ( Integer . MAX_VALUE , <int> ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt + <int> ) ) { break ; } } return this ; } @Override public ReferenceCounted retain ( int increment ) { if ( increment < = <int> ) { throw new IllegalArgumentException ( <str> + increment + <str> ) ; } for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , <int> ) ; } if ( refCnt > Integer . MAX_VALUE - increment ) { throw new IllegalReferenceCountException ( refCnt , increment ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt + increment ) ) { break ; } } return this ; } @Override public ReferenceCounted touch ( ) { return touch ( null ) ; } @Override public boolean release ( ) { for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , - <int> ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt - <int> ) ) { if ( refCnt = = <int> ) { deallocate ( ) ; return true ; } return false ; } } } @Override public boolean release ( int decrement ) { if ( decrement < = <int> ) { throw new IllegalArgumentException ( <str> + decrement + <str> ) ; } for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt < decrement ) { throw new IllegalReferenceCountException ( refCnt , - decrement ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt - decrement ) ) { if ( refCnt = = decrement ) { deallocate ( ) ; return true ; } return false ; } } } protected abstract void deallocate ( ) ; } 
