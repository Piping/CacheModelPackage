package org . apache . cassandra . cql3 . statements ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . marshal . BooleanType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . transport . messages . ResultMessage ; public class ListRolesStatement extends AuthorizationStatement { private static final String KS = AuthKeyspace . NAME ; private static final String CF = AuthKeyspace . ROLES ; private static final MapType optionsType = MapType . getInstance ( UTF8Type . instance , UTF8Type . instance , false ) ; private static final List < ColumnSpecification > metadata = ImmutableList . of ( new ColumnSpecification ( KS , CF , new ColumnIdentifier ( <str> , true ) , UTF8Type . instance ) , new ColumnSpecification ( KS , CF , new ColumnIdentifier ( <str> , true ) , BooleanType . instance ) , new ColumnSpecification ( KS , CF , new ColumnIdentifier ( <str> , true ) , BooleanType . instance ) , new ColumnSpecification ( KS , CF , new ColumnIdentifier ( <str> , true ) , optionsType ) ) ; private final RoleResource grantee ; private final boolean recursive ; public ListRolesStatement ( ) { this ( new RoleName ( ) , false ) ; } public ListRolesStatement ( RoleName grantee , boolean recursive ) { this . grantee = grantee . hasName ( ) ? RoleResource . role ( grantee . getName ( ) ) : null ; this . recursive = recursive ; } public void validate ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . ensureNotAnonymous ( ) ; if ( ( grantee ! = null ) & & ! DatabaseDescriptor . getRoleManager ( ) . isExistingRole ( grantee ) ) throw new InvalidRequestException ( String . format ( <str> , grantee ) ) ; } public void checkAccess ( ClientState state ) throws InvalidRequestException { } public ResultMessage execute ( ClientState state ) throws RequestValidationException , RequestExecutionException { boolean hasRootLevelSelect = DatabaseDescriptor . getAuthorizer ( ) . authorize ( state . getUser ( ) , RoleResource . root ( ) ) . contains ( Permission . DESCRIBE ) ; if ( hasRootLevelSelect ) { if ( grantee = = null ) return resultMessage ( DatabaseDescriptor . getRoleManager ( ) . getAllRoles ( ) ) ; else return resultMessage ( DatabaseDescriptor . getRoleManager ( ) . getRoles ( grantee , recursive ) ) ; } else { RoleResource currentUser = RoleResource . role ( state . getUser ( ) . getName ( ) ) ; if ( grantee = = null ) return resultMessage ( DatabaseDescriptor . getRoleManager ( ) . getRoles ( currentUser , recursive ) ) ; if ( DatabaseDescriptor . getRoleManager ( ) . getRoles ( currentUser , true ) . contains ( grantee ) ) return resultMessage ( DatabaseDescriptor . getRoleManager ( ) . getRoles ( grantee , recursive ) ) ; else throw new UnauthorizedException ( String . format ( <str> , grantee . getRoleName ( ) ) ) ; } } private ResultMessage resultMessage ( Set < RoleResource > roles ) { if ( roles . isEmpty ( ) ) return new ResultMessage . Void ( ) ; List < RoleResource > sorted = Lists . newArrayList ( roles ) ; Collections . sort ( sorted ) ; return formatResults ( sorted ) ; } protected ResultMessage formatResults ( List < RoleResource > sortedRoles ) { ResultSet result = new ResultSet ( metadata ) ; IRoleManager roleManager = DatabaseDescriptor . getRoleManager ( ) ; for ( RoleResource role : sortedRoles ) { result . addColumnValue ( UTF8Type . instance . decompose ( role . getRoleName ( ) ) ) ; result . addColumnValue ( BooleanType . instance . decompose ( roleManager . isSuper ( role ) ) ) ; result . addColumnValue ( BooleanType . instance . decompose ( roleManager . canLogin ( role ) ) ) ; result . addColumnValue ( optionsType . decompose ( roleManager . getCustomOptions ( role ) ) ) ; } return new ResultMessage . Rows ( result ) ; } } 
