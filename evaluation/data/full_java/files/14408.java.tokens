package org . gradle . model . internal . manage . schema . extract ; import com . google . common . base . Equivalence ; import com . google . common . base . Function ; import com . google . common . collect . * ; import groovy . lang . GroovyObject ; import org . gradle . api . Nullable ; import org . gradle . internal . Cast ; import org . gradle . internal . reflect . MethodSignatureEquivalence ; import org . gradle . model . Managed ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . Proxy ; import java . util . * ; public class ModelSchemaUtils { private static final Equivalence < Method > METHOD_EQUIVALENCE = new MethodSignatureEquivalence ( ) ; private static final Set < Equivalence . Wrapper < Method > > IGNORED_METHODS = ImmutableSet . copyOf ( Iterables . transform ( Iterables . concat ( Arrays . asList ( Object . class . getMethods ( ) ) , Arrays . asList ( GroovyObject . class . getMethods ( ) ) ) , new Function < Method , Equivalence . Wrapper < Method > > ( ) { public Equivalence . Wrapper < Method > apply ( @Nullable Method input ) { return METHOD_EQUIVALENCE . wrap ( input ) ; } } ) ) ; public static < T > CandidateMethods getCandidateMethods ( Class < T > clazz ) { final ImmutableListMultimap . Builder < String , Method > methodsByNameBuilder = ImmutableListMultimap . builder ( ) ; ModelSchemaUtils . walkTypeHierarchy ( clazz , new ModelSchemaUtils . TypeVisitor < T > ( ) { @Override public void visitType ( Class < ? super T > type ) { Method [ ] declaredMethods = type . getDeclaredMethods ( ) ; Arrays . sort ( declaredMethods , Ordering . usingToString ( ) ) ; for ( Method method : declaredMethods ) { if ( ModelSchemaUtils . isIgnoredMethod ( method ) ) { continue ; } methodsByNameBuilder . put ( method . getName ( ) , method ) ; } } } ) ; ImmutableListMultimap < String , Method > methodsByName = methodsByNameBuilder . build ( ) ; ImmutableSortedMap . Builder < String , Map < Equivalence . Wrapper < Method > , Collection < Method > > > candidatesBuilder = ImmutableSortedMap . naturalOrder ( ) ; for ( String methodName : methodsByName . keySet ( ) ) { ImmutableList < Method > methodsWithSameName = methodsByName . get ( methodName ) ; ListMultimap < Equivalence . Wrapper < Method > , Method > equivalenceIndex = Multimaps . index ( methodsWithSameName , new Function < Method , Equivalence . Wrapper < Method > > ( ) { @Override public Equivalence . Wrapper < Method > apply ( Method method ) { return METHOD_EQUIVALENCE . wrap ( method ) ; } } ) ; candidatesBuilder . put ( methodName , equivalenceIndex . asMap ( ) ) ; } return new CandidateMethods ( candidatesBuilder . build ( ) ) ; } public static boolean isIgnoredMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; if ( method . isSynthetic ( ) | | Modifier . isStatic ( modifiers ) | | ! Modifier . isPublic ( modifiers ) ) { return true ; } return IGNORED_METHODS . contains ( METHOD_EQUIVALENCE . wrap ( method ) ) ; } public static < T > void walkTypeHierarchy ( Class < T > clazz , TypeVisitor < ? extends T > visitor ) { Set < Class < ? > > seenInterfaces = Sets . newHashSet ( ) ; Queue < Class < ? super T > > queue = new ArrayDeque < Class < ? super T > > ( ) ; queue . add ( clazz ) ; Class < ? super T > type ; while ( ( type = queue . poll ( ) ) ! = null ) { if ( type . equals ( Object . class ) | | type . equals ( GroovyObject . class ) ) { continue ; } visitor . visitType ( type ) ; Class < ? super T > superclass = type . getSuperclass ( ) ; if ( superclass ! = null ) { queue . add ( superclass ) ; } for ( Class < ? > iface : type . getInterfaces ( ) ) { if ( seenInterfaces . add ( iface ) ) { queue . add ( Cast . < Class < ? super T > > uncheckedCast ( iface ) ) ; } } } } public interface TypeVisitor < T > { void visitType ( Class < ? super T > type ) ; } public static Method findMostSpecificMethod ( Iterable < Method > declaringMethods ) { for ( Method method : declaringMethods ) { if ( Proxy . isProxyClass ( method . getDeclaringClass ( ) ) ) { continue ; } return method ; } throw new IllegalArgumentException ( <str> + declaringMethods ) ; } public static boolean isMethodDeclaredInManagedType ( Iterable < Method > declarations ) { Method mostSpecificDeclaration = findMostSpecificMethod ( declarations ) ; return isMethodDeclaredInManagedType ( mostSpecificDeclaration ) ; } public static boolean isMethodDeclaredInManagedType ( Method method ) { return method . getDeclaringClass ( ) . isAnnotationPresent ( Managed . class ) ; } } 
