package org . apache . cassandra . dht ; import java . io . DataInput ; import java . io . IOException ; import java . io . Serializable ; import java . util . Collection ; import java . util . List ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . Pair ; public abstract class AbstractBounds < T extends RingPosition < T > > implements Serializable { private static final long serialVersionUID = <int> ; public static final IPartitionerDependentSerializer < AbstractBounds < Token > > tokenSerializer = new AbstractBoundsSerializer < Token > ( Token . serializer ) ; public static final IPartitionerDependentSerializer < AbstractBounds < PartitionPosition > > rowPositionSerializer = new AbstractBoundsSerializer < PartitionPosition > ( PartitionPosition . serializer ) ; private enum Type { RANGE , BOUNDS } public final T left ; public final T right ; public AbstractBounds ( T left , T right ) { assert left . getPartitioner ( ) = = right . getPartitioner ( ) ; this . left = left ; this . right = right ; } public abstract Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) ; public abstract boolean inclusiveLeft ( ) ; public abstract boolean inclusiveRight ( ) ; public static < T extends RingPosition < T > > boolean strictlyWrapsAround ( T left , T right ) { return ! ( left . compareTo ( right ) < = <int> | | right . isMinimum ( ) ) ; } public static < T extends RingPosition < T > > boolean noneStrictlyWrapsAround ( Collection < AbstractBounds < T > > bounds ) { for ( AbstractBounds < T > b : bounds ) { if ( strictlyWrapsAround ( b . left , b . right ) ) return false ; } return true ; } @Override public int hashCode ( ) { return <int> * left . hashCode ( ) + right . hashCode ( ) ; } public boolean intersects ( Iterable < Range < T > > ranges ) { for ( Range < T > range2 : ranges ) { if ( range2 . intersects ( this ) ) return true ; } return false ; } public abstract boolean contains ( T start ) ; public abstract List < ? extends AbstractBounds < T > > unwrap ( ) ; public String getString ( AbstractType < ? > keyValidator ) { return getOpeningString ( ) + format ( left , keyValidator ) + <str> + format ( right , keyValidator ) + getClosingString ( ) ; } private String format ( T value , AbstractType < ? > keyValidator ) { if ( value instanceof DecoratedKey ) { return keyValidator . getString ( ( ( DecoratedKey ) value ) . getKey ( ) ) ; } else { return value . toString ( ) ; } } protected abstract String getOpeningString ( ) ; protected abstract String getClosingString ( ) ; public abstract boolean isStartInclusive ( ) ; public abstract boolean isEndInclusive ( ) ; public abstract AbstractBounds < T > withNewRight ( T newRight ) ; public static class AbstractBoundsSerializer < T extends RingPosition < T > > implements IPartitionerDependentSerializer < AbstractBounds < T > > { private static final int IS_TOKEN_FLAG = <hex> ; private static final int START_INCLUSIVE_FLAG = <hex> ; private static final int END_INCLUSIVE_FLAG = <hex> ; IPartitionerDependentSerializer < T > serializer ; private static int kindInt ( AbstractBounds < ? > ab ) { int kind = ab instanceof Range ? Type . RANGE . ordinal ( ) : Type . BOUNDS . ordinal ( ) ; if ( ! ( ab . left instanceof Token ) ) kind = - ( kind + <int> ) ; return kind ; } private static int kindFlags ( AbstractBounds < ? > ab ) { int flags = <int> ; if ( ab . left instanceof Token ) flags | = IS_TOKEN_FLAG ; if ( ab . isStartInclusive ( ) ) flags | = START_INCLUSIVE_FLAG ; if ( ab . isEndInclusive ( ) ) flags | = END_INCLUSIVE_FLAG ; return flags ; } public AbstractBoundsSerializer ( IPartitionerDependentSerializer < T > serializer ) { this . serializer = serializer ; } public void serialize ( AbstractBounds < T > range , DataOutputPlus out , int version ) throws IOException { if ( version < MessagingService . VERSION_30 ) out . writeInt ( kindInt ( range ) ) ; else out . writeByte ( kindFlags ( range ) ) ; serializer . serialize ( range . left , out , version ) ; serializer . serialize ( range . right , out , version ) ; } public AbstractBounds < T > deserialize ( DataInput in , IPartitioner p , int version ) throws IOException { boolean isToken , startInclusive , endInclusive ; if ( version < MessagingService . VERSION_30 ) { int kind = in . readInt ( ) ; isToken = kind > = <int> ; if ( ! isToken ) kind = - ( kind + <int> ) ; startInclusive = kind ! = Type . RANGE . ordinal ( ) ; endInclusive = true ; } else { int flags = in . readUnsignedByte ( ) ; isToken = ( flags & IS_TOKEN_FLAG ) ! = <int> ; startInclusive = ( flags & START_INCLUSIVE_FLAG ) ! = <int> ; endInclusive = ( flags & END_INCLUSIVE_FLAG ) ! = <int> ; } T left = serializer . deserialize ( in , p , version ) ; T right = serializer . deserialize ( in , p , version ) ; assert isToken = = left instanceof Token ; if ( startInclusive ) return endInclusive ? new Bounds < T > ( left , right ) : new IncludingExcludingBounds < T > ( left , right ) ; else return endInclusive ? new Range < T > ( left , right ) : new ExcludingBounds < T > ( left , right ) ; } public long serializedSize ( AbstractBounds < T > ab , int version ) { int size = version < MessagingService . VERSION_30 ? TypeSizes . sizeof ( kindInt ( ab ) ) : <int> ; size + = serializer . serializedSize ( ab . left , version ) ; size + = serializer . serializedSize ( ab . right , version ) ; return size ; } } public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( Boundary < T > min , Boundary < T > max ) { return bounds ( min . boundary , min . inclusive , max . boundary , max . inclusive ) ; } public static < T extends RingPosition < T > > AbstractBounds < T > bounds ( T min , boolean inclusiveMin , T max , boolean inclusiveMax ) { if ( inclusiveMin & & inclusiveMax ) return new Bounds < T > ( min , max ) ; else if ( inclusiveMax ) return new Range < T > ( min , max ) ; else if ( inclusiveMin ) return new IncludingExcludingBounds < T > ( min , max ) ; else return new ExcludingBounds < T > ( min , max ) ; } public static class Boundary < T extends RingPosition < T > > { public final T boundary ; public final boolean inclusive ; public Boundary ( T boundary , boolean inclusive ) { this . boundary = boundary ; this . inclusive = inclusive ; } } public Boundary < T > leftBoundary ( ) { return new Boundary < > ( left , inclusiveLeft ( ) ) ; } public Boundary < T > rightBoundary ( ) { return new Boundary < > ( right , inclusiveRight ( ) ) ; } public static < T extends RingPosition < T > > boolean isEmpty ( Boundary < T > left , Boundary < T > right ) { int c = left . boundary . compareTo ( right . boundary ) ; return c > <int> | | ( c = = <int> & & ! ( left . inclusive & & right . inclusive ) ) ; } public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , T right2 , boolean isInclusiveRight2 ) { return minRight ( right1 , new Boundary < T > ( right2 , isInclusiveRight2 ) ) ; } public static < T extends RingPosition < T > > Boundary < T > minRight ( Boundary < T > right1 , Boundary < T > right2 ) { int c = right1 . boundary . compareTo ( right2 . boundary ) ; if ( c ! = <int> ) return c < <int> ? right1 : right2 ; return right2 . inclusive ? right1 : right2 ; } public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , T left2 , boolean isInclusiveLeft2 ) { return maxLeft ( left1 , new Boundary < T > ( left2 , isInclusiveLeft2 ) ) ; } public static < T extends RingPosition < T > > Boundary < T > maxLeft ( Boundary < T > left1 , Boundary < T > left2 ) { int c = left1 . boundary . compareTo ( left2 . boundary ) ; if ( c ! = <int> ) return c > <int> ? left1 : left2 ; return left2 . inclusive ? left1 : left2 ; } } 
