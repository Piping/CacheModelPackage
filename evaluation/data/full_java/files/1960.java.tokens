package org . nd4j . linalg . api . blas . impl ; import org . nd4j . linalg . api . blas . Level3 ; import org . nd4j . linalg . api . blas . params . GemmParams ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . NDArrayFactory ; import org . nd4j . linalg . util . ArrayUtil ; public abstract class BaseLevel3 extends BaseLevel implements Level3 { @Override public void gemm ( char Order , char TransA , char TransB , double alpha , INDArray A , INDArray B , double beta , INDArray C ) { GemmParams params = new GemmParams ( A , B , C ) ; if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) dgemm ( Order , params . getAOrdering ( ) , params . getBOrdering ( ) , params . getM ( ) , params . getN ( ) , params . getK ( ) , <float> , params . getA ( ) , params . getLda ( ) , params . getB ( ) , params . getLdb ( ) , <int> , C , params . getLdc ( ) ) ; else sgemm ( Order , params . getAOrdering ( ) , params . getBOrdering ( ) , params . getM ( ) , params . getN ( ) , params . getK ( ) , <float> , params . getA ( ) , params . getLda ( ) , params . getB ( ) , params . getLdb ( ) , <int> , C , params . getLdc ( ) ) ; } @Override public void gemm ( INDArray A , INDArray B , INDArray C , boolean transposeA , boolean transposeB , double alpha , double beta ) { GemmParams params = new GemmParams ( A , B , C , transposeA , transposeB ) ; char Order = <str> ; if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) dgemm ( Order , params . getAOrdering ( ) , params . getBOrdering ( ) , params . getM ( ) , params . getN ( ) , params . getK ( ) , alpha , params . getA ( ) , params . getLda ( ) , params . getB ( ) , params . getLdb ( ) , beta , C , params . getLdc ( ) ) ; else sgemm ( Order , params . getAOrdering ( ) , params . getBOrdering ( ) , params . getM ( ) , params . getN ( ) , params . getK ( ) , ( float ) alpha , params . getA ( ) , params . getLda ( ) , params . getB ( ) , params . getLdb ( ) , ( float ) beta , C , params . getLdc ( ) ) ; } @Override public void symm ( char Order , char Side , char Uplo , double alpha , INDArray A , INDArray B , double beta , INDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) dsymm ( Order , Side , Uplo , C . rows ( ) , C . columns ( ) , alpha , A , A . size ( <int> ) , B , B . size ( <int> ) , beta , C , C . size ( <int> ) ) ; else ssymm ( Order , Side , Uplo , C . rows ( ) , C . columns ( ) , ( float ) alpha , A , A . size ( <int> ) , B , B . size ( <int> ) , ( float ) beta , C , C . size ( <int> ) ) ; } @Override public void syrk ( char Order , char Uplo , char Trans , double alpha , INDArray A , double beta , INDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) dsyrk ( Order , Uplo , Trans , C . rows ( ) , <int> , alpha , A , A . size ( <int> ) , beta , C , C . size ( <int> ) ) ; else ssyrk ( Order , Uplo , Trans , C . rows ( ) , <int> , ( float ) alpha , A , A . size ( <int> ) , ( float ) beta , C , C . size ( <int> ) ) ; } @Override public void syr2k ( char Order , char Uplo , char Trans , double alpha , INDArray A , INDArray B , double beta , INDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) { dsyr2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha , A , A . size ( <int> ) , B , B . size ( <int> ) , beta , C , C . size ( <int> ) ) ; } else ssyr2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , ( float ) alpha , A , A . size ( <int> ) , B , B . size ( <int> ) , ( float ) beta , C , C . size ( <int> ) ) ; } @Override public void trmm ( char Order , char Side , char Uplo , char TransA , char Diag , double alpha , INDArray A , INDArray B , INDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) { dtrmm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; } else strmm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , ( float ) alpha , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; } @Override public void trsm ( char Order , char Side , char Uplo , char TransA , char Diag , double alpha , INDArray A , INDArray B ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) { dtrsm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; } else strsm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , ( float ) alpha , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; } @Override public void gemm ( char Order , char TransA , char TransB , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNumber beta , IComplexNDArray C ) { GemmParams params = new GemmParams ( A , B , C ) ; if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) { zgemm ( Order , TransA , TransB , params . getM ( ) , params . getN ( ) , params . getK ( ) , alpha . asDouble ( ) , A . ordering ( ) = = NDArrayFactory . C ? B : A , params . getLda ( ) , B . ordering ( ) = = NDArrayFactory . C ? A : B , params . getLdb ( ) , beta . asDouble ( ) , C , params . getLdc ( ) ) ; } else cgemm ( Order , TransA , TransB , params . getM ( ) , params . getN ( ) , params . getK ( ) , alpha . asFloat ( ) , A . ordering ( ) = = NDArrayFactory . C ? B : A , params . getLda ( ) , B . ordering ( ) = = NDArrayFactory . C ? A : B , params . getLdb ( ) , beta . asFloat ( ) , C , params . getLdc ( ) ) ; } @Override public void hemm ( char Order , char Side , char Uplo , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zhemm ( Order , Side , Uplo , B . rows ( ) , B . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else chemm ( Order , Side , Uplo , B . rows ( ) , B . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void herk ( char Order , char Uplo , char Trans , IComplexNumber alpha , IComplexNDArray A , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zherk ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else cherk ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void her2k ( char Order , char Uplo , char Trans , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zher2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else cher2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void symm ( char Order , char Side , char Uplo , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zsymm ( Order , Side , Uplo , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else csymm ( Order , Side , Uplo , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void syrk ( char Order , char Uplo , char Trans , IComplexNumber alpha , IComplexNDArray A , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zsyrk ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else csyrk ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void syr2k ( char Order , char Uplo , char Trans , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNumber beta , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) zsyr2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asDouble ( ) , C , C . size ( <int> ) ) ; else csyr2k ( Order , Uplo , Trans , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , beta . asFloat ( ) , C , C . size ( <int> ) ) ; } @Override public void trmm ( char Order , char Side , char Uplo , char TransA , char Diag , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B , IComplexNDArray C ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) ztrmm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , C , C . size ( <int> ) ) ; else ctrmm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) , C , C . size ( <int> ) ) ; } @Override public void trsm ( char Order , char Side , char Uplo , char TransA , char Diag , IComplexNumber alpha , IComplexNDArray A , IComplexNDArray B ) { if ( A . data ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) ztrsm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha . asDouble ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; else ctrsm ( Order , Side , Uplo , TransA , Diag , A . rows ( ) , A . columns ( ) , alpha . asFloat ( ) , A , A . size ( <int> ) , B , B . size ( <int> ) ) ; } protected abstract void sgemm ( char Order , char TransA , char TransB , int M , int N , int K , float alpha , INDArray A , int lda , INDArray B , int ldb , float beta , INDArray C , int ldc ) ; protected abstract void ssymm ( char Order , char Side , char Uplo , int M , int N , float alpha , INDArray A , int lda , INDArray B , int ldb , float beta , INDArray C , int ldc ) ; protected abstract void ssyrk ( char Order , char Uplo , char Trans , int N , int K , float alpha , INDArray A , int lda , float beta , INDArray C , int ldc ) ; protected abstract void ssyr2k ( char Order , char Uplo , char Trans , int N , int K , float alpha , INDArray A , int lda , INDArray B , int ldb , float beta , INDArray C , int ldc ) ; protected abstract void strmm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , float alpha , INDArray A , int lda , INDArray B , int ldb ) ; protected abstract void strsm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , float alpha , INDArray A , int lda , INDArray B , int ldb ) ; protected abstract void dgemm ( char Order , char TransA , char TransB , int M , int N , int K , double alpha , INDArray A , int lda , INDArray B , int ldb , double beta , INDArray C , int ldc ) ; protected abstract void dsymm ( char Order , char Side , char Uplo , int M , int N , double alpha , INDArray A , int lda , INDArray B , int ldb , double beta , INDArray C , int ldc ) ; protected abstract void dsyrk ( char Order , char Uplo , char Trans , int N , int K , double alpha , INDArray A , int lda , double beta , INDArray C , int ldc ) ; protected abstract void dsyr2k ( char Order , char Uplo , char Trans , int N , int K , double alpha , INDArray A , int lda , INDArray B , int ldb , double beta , INDArray C , int ldc ) ; protected abstract void dtrmm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , double alpha , INDArray A , int lda , INDArray B , int ldb ) ; protected abstract void dtrsm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , double alpha , INDArray A , int lda , INDArray B , int ldb ) ; protected abstract void cgemm ( char Order , char TransA , char TransB , int M , int N , int K , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void csymm ( char Order , char Side , char Uplo , int M , int N , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void csyrk ( char Order , char Uplo , char Trans , int N , int K , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void csyr2k ( char Order , char Uplo , char Trans , int N , int K , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void ctrmm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexNDArray C , int ldc ) ; protected abstract void ctrsm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb ) ; protected abstract void zgemm ( char Order , char TransA , char TransB , int M , int N , int K , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void zsymm ( char Order , char Side , char Uplo , int M , int N , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void zsyrk ( char Order , char Uplo , char Trans , int N , int K , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void zsyr2k ( char Order , char Uplo , char Trans , int N , int K , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void ztrmm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexNDArray C , int ldc ) ; protected abstract void ztrsm ( char Order , char Side , char Uplo , char TransA , char Diag , int M , int N , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb ) ; protected abstract void chemm ( char Order , char Side , char Uplo , int M , int N , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void cherk ( char Order , char Uplo , char Trans , int N , int K , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void cher2k ( char Order , char Uplo , char Trans , int N , int K , IComplexFloat alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexFloat beta , IComplexNDArray C , int ldc ) ; protected abstract void zhemm ( char Order , char Side , char Uplo , int M , int N , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void zherk ( char Order , char Uplo , char Trans , int N , int K , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexDouble beta , IComplexNDArray C , int ldc ) ; protected abstract void zher2k ( char Order , char Uplo , char Trans , int N , int K , IComplexDouble alpha , IComplexNDArray A , int lda , IComplexNDArray B , int ldb , IComplexDouble beta , IComplexNDArray C , int ldc ) ; } 
