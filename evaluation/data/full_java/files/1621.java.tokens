package org . apache . cassandra . service ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . * ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . RowIterator ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . partitions . FilteredPartition ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . pager . QueryPager ; import org . apache . cassandra . service . pager . PagingState ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . transport . Server ; import static org . apache . cassandra . cql3 . QueryProcessor . executeInternal ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . junit . Assert . * ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class QueryPagerTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; public static final String KEYSPACE_CQL = <str> ; public static final String CF_CQL = <str> ; public static final int nowInSec = FBUtilities . nowInSeconds ( ) ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) ) ; SchemaLoader . createKeyspace ( KEYSPACE_CQL , KeyspaceParams . simple ( <int> ) , CFMetaData . compile ( <str> + CF_CQL + <str> + <str> + <str> + <str> + <str> , KEYSPACE_CQL ) ) ; addData ( ) ; } private static String string ( ByteBuffer bb ) { try { return ByteBufferUtil . string ( bb ) ; } catch ( CharacterCodingException e ) { throw new RuntimeException ( e ) ; } } public static void addData ( ) { cfs ( ) . clearUnsafe ( ) ; int nbKeys = <int> ; int nbCols = <int> ; for ( int i = <int> ; i < nbKeys ; i + + ) { for ( int j = <int> ; j < nbCols ; j + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs ( ) . metadata , FBUtilities . timestampMicros ( ) , <str> + i ) ; builder . clustering ( <str> + j ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; } } } private static ColumnFamilyStore cfs ( ) { return Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD ) ; } private static List < FilteredPartition > query ( QueryPager pager , int expectedSize ) { return query ( pager , expectedSize , expectedSize ) ; } private static List < FilteredPartition > query ( QueryPager pager , int toQuery , int expectedSize ) { StringBuilder sb = new StringBuilder ( ) ; List < FilteredPartition > partitionList = new ArrayList < > ( ) ; int rows = <int> ; try ( ReadExecutionController executionController = pager . executionController ( ) ; PartitionIterator iterator = pager . fetchPageInternal ( toQuery , executionController ) ) { while ( iterator . hasNext ( ) ) { try ( RowIterator rowIter = iterator . next ( ) ) { FilteredPartition partition = FilteredPartition . create ( rowIter ) ; sb . append ( partition ) ; partitionList . add ( partition ) ; rows + = partition . rowCount ( ) ; } } } assertEquals ( sb . toString ( ) , expectedSize , rows ) ; return partitionList ; } private static ReadCommand namesQuery ( String key , String . . . names ) { AbstractReadCommandBuilder builder = Util . cmd ( cfs ( ) , key ) ; for ( String name : names ) builder . includeRow ( name ) ; return builder . withPagingLimit ( <int> ) . build ( ) ; } private static SinglePartitionReadCommand sliceQuery ( String key , String start , String end , int count ) { return sliceQuery ( key , start , end , false , count ) ; } private static SinglePartitionReadCommand sliceQuery ( String key , String start , String end , boolean reversed , int count ) { ClusteringComparator cmp = cfs ( ) . getComparator ( ) ; CFMetaData metadata = cfs ( ) . metadata ; Slice slice = Slice . make ( cmp . make ( start ) , cmp . make ( end ) ) ; ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter ( Slices . with ( cmp , slice ) , reversed ) ; return SinglePartitionReadCommand . create ( cfs ( ) . metadata , nowInSec , ColumnFilter . all ( metadata ) , RowFilter . NONE , DataLimits . NONE , Util . dk ( key ) , filter ) ; } private static ReadCommand rangeNamesQuery ( String keyStart , String keyEnd , int count , String . . . names ) { AbstractReadCommandBuilder builder = Util . cmd ( cfs ( ) ) . fromKeyExcl ( keyStart ) . toKeyIncl ( keyEnd ) . withPagingLimit ( count ) ; for ( String name : names ) builder . includeRow ( name ) ; return builder . build ( ) ; } private static ReadCommand rangeSliceQuery ( String keyStart , String keyEnd , int count , String start , String end ) { return Util . cmd ( cfs ( ) ) . fromKeyExcl ( keyStart ) . toKeyIncl ( keyEnd ) . fromIncl ( start ) . toIncl ( end ) . withPagingLimit ( count ) . build ( ) ; } private static void assertRow ( FilteredPartition r , String key , String . . . names ) { ByteBuffer [ ] bbs = new ByteBuffer [ names . length ] ; for ( int i = <int> ; i < names . length ; i + + ) bbs [ i ] = bytes ( names [ i ] ) ; assertRow ( r , key , bbs ) ; } private static void assertRow ( FilteredPartition partition , String key , ByteBuffer . . . names ) { assertEquals ( key , string ( partition . partitionKey ( ) . getKey ( ) ) ) ; assertFalse ( partition . isEmpty ( ) ) ; int i = <int> ; for ( Row row : Util . once ( partition . iterator ( ) ) ) { ByteBuffer expected = names [ i + + ] ; assertEquals ( <str> + i + <str> + string ( expected ) + <str> + string ( row . clustering ( ) . get ( <int> ) ) , expected , row . clustering ( ) . get ( <int> ) ) ; } } private QueryPager maybeRecreate ( QueryPager pager , ReadQuery command , boolean testPagingState , int protocolVersion ) { if ( ! testPagingState ) return pager ; PagingState state = PagingState . deserialize ( pager . state ( ) . serialize ( protocolVersion ) , protocolVersion ) ; return command . getPager ( state , protocolVersion ) ; } @Test public void namesQueryTest ( ) throws Exception { QueryPager pager = namesQuery ( <str> , <str> , <str> , <str> , <str> ) . getPager ( null , Server . CURRENT_VERSION ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partition = query ( pager , <int> , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void sliceQueryTest ( ) throws Exception { sliceQueryTest ( false , Server . VERSION_3 ) ; sliceQueryTest ( true , Server . VERSION_4 ) ; sliceQueryTest ( false , Server . VERSION_3 ) ; sliceQueryTest ( true , Server . VERSION_4 ) ; } public void sliceQueryTest ( boolean testPagingState , int protocolVersion ) throws Exception { ReadCommand command = sliceQuery ( <str> , <str> , <str> , <int> ) ; QueryPager pager = command . getPager ( null , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void reversedSliceQueryTest ( ) throws Exception { reversedSliceQueryTest ( false , Server . VERSION_3 ) ; reversedSliceQueryTest ( true , Server . VERSION_4 ) ; reversedSliceQueryTest ( false , Server . VERSION_3 ) ; reversedSliceQueryTest ( true , Server . VERSION_4 ) ; } public void reversedSliceQueryTest ( boolean testPagingState , int protocolVersion ) throws Exception { ReadCommand command = sliceQuery ( <str> , <str> , <str> , true , <int> ) ; QueryPager pager = command . getPager ( null , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void multiQueryTest ( ) throws Exception { multiQueryTest ( false , Server . VERSION_3 ) ; multiQueryTest ( true , Server . VERSION_4 ) ; multiQueryTest ( false , Server . VERSION_3 ) ; multiQueryTest ( true , Server . VERSION_4 ) ; } public void multiQueryTest ( boolean testPagingState , int protocolVersion ) throws Exception { ReadQuery command = new SinglePartitionReadCommand . Group ( new ArrayList < SinglePartitionReadCommand > ( ) { { add ( sliceQuery ( <str> , <str> , <str> , <int> ) ) ; add ( sliceQuery ( <str> , <str> , <str> , <int> ) ) ; } } , DataLimits . NONE ) ; QueryPager pager = command . getPager ( null , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partition = query ( pager , <int> , <int> ) ; assertRow ( partition . get ( <int> ) , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void rangeNamesQueryTest ( ) throws Exception { rangeNamesQueryTest ( false , Server . VERSION_3 ) ; rangeNamesQueryTest ( true , Server . VERSION_4 ) ; rangeNamesQueryTest ( false , Server . VERSION_3 ) ; rangeNamesQueryTest ( true , Server . VERSION_4 ) ; } public void rangeNamesQueryTest ( boolean testPagingState , int protocolVersion ) throws Exception { ReadCommand command = rangeNamesQuery ( <str> , <str> , <int> , <str> , <str> , <str> ) ; QueryPager pager = command . getPager ( null , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partitions = query ( pager , <int> * <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) assertRow ( partitions . get ( i - <int> ) , <str> + i , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> * <int> , <int> * <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) assertRow ( partitions . get ( i - <int> ) , <str> + i , <str> , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void rangeSliceQueryTest ( ) throws Exception { rangeSliceQueryTest ( false , Server . VERSION_3 ) ; rangeSliceQueryTest ( true , Server . VERSION_4 ) ; rangeSliceQueryTest ( false , Server . VERSION_3 ) ; rangeSliceQueryTest ( true , Server . VERSION_4 ) ; } public void rangeSliceQueryTest ( boolean testPagingState , int protocolVersion ) throws Exception { ReadCommand command = rangeSliceQuery ( <str> , <str> , <int> , <str> , <str> ) ; QueryPager pager = command . getPager ( null , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; List < FilteredPartition > partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> , <str> , <str> ) ; assertFalse ( pager . isExhausted ( ) ) ; pager = maybeRecreate ( pager , command , testPagingState , protocolVersion ) ; assertFalse ( pager . isExhausted ( ) ) ; partitions = query ( pager , <int> , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> , <str> , <str> ) ; assertTrue ( pager . isExhausted ( ) ) ; } @Test public void SliceQueryWithTombstoneTest ( ) throws Exception { String keyspace = <str> ; String table = <str> ; ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( table ) ; for ( int i = <int> ; i < <int> ; i + + ) executeInternal ( String . format ( <str> , keyspace , table , <int> , i ) ) ; ReadCommand command = SinglePartitionReadCommand . create ( cfs . metadata , nowInSec , Util . dk ( <str> ) , Slice . ALL ) ; QueryPager pager = command . getPager ( null , Server . CURRENT_VERSION ) ; for ( int i = <int> ; i < <int> ; i + + ) { List < FilteredPartition > partitions = query ( pager , <int> ) ; assertRow ( partitions . get ( <int> ) , <str> , <str> + i ) ; } } } 
