package io . netty . handler . ssl . util ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . base64 . Base64 ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . NoSuchAlgorithmException ; import java . security . PrivateKey ; import java . security . SecureRandom ; import java . security . cert . CertificateEncodingException ; import java . security . cert . CertificateException ; import java . security . cert . CertificateFactory ; import java . security . cert . X509Certificate ; import java . util . Date ; public final class SelfSignedCertificate { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( SelfSignedCertificate . class ) ; private static final Date DEFAULT_NOT_BEFORE = new Date ( SystemPropertyUtil . getLong ( <str> , System . currentTimeMillis ( ) - <int> * <int> ) ) ; private static final Date DEFAULT_NOT_AFTER = new Date ( SystemPropertyUtil . getLong ( <str> , <int> ) ) ; private final File certificate ; private final File privateKey ; private final X509Certificate cert ; private final PrivateKey key ; public SelfSignedCertificate ( ) throws CertificateException { this ( DEFAULT_NOT_BEFORE , DEFAULT_NOT_AFTER ) ; } public SelfSignedCertificate ( Date notBefore , Date notAfter ) throws CertificateException { this ( <str> , notBefore , notAfter ) ; } public SelfSignedCertificate ( String fqdn ) throws CertificateException { this ( fqdn , DEFAULT_NOT_BEFORE , DEFAULT_NOT_AFTER ) ; } public SelfSignedCertificate ( String fqdn , Date notBefore , Date notAfter ) throws CertificateException { this ( fqdn , ThreadLocalInsecureRandom . current ( ) , <int> , notBefore , notAfter ) ; } public SelfSignedCertificate ( String fqdn , SecureRandom random , int bits ) throws CertificateException { this ( fqdn , random , bits , DEFAULT_NOT_BEFORE , DEFAULT_NOT_AFTER ) ; } public SelfSignedCertificate ( String fqdn , SecureRandom random , int bits , Date notBefore , Date notAfter ) throws CertificateException { final KeyPair keypair ; try { KeyPairGenerator keyGen = KeyPairGenerator . getInstance ( <str> ) ; keyGen . initialize ( bits , random ) ; keypair = keyGen . generateKeyPair ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new Error ( e ) ; } String [ ] paths ; try { paths = OpenJdkSelfSignedCertGenerator . generate ( fqdn , keypair , random , notBefore , notAfter ) ; } catch ( Throwable t ) { logger . debug ( <str> , t ) ; try { paths = BouncyCastleSelfSignedCertGenerator . generate ( fqdn , keypair , random , notBefore , notAfter ) ; } catch ( Throwable t2 ) { logger . debug ( <str> , t2 ) ; throw new CertificateException ( <str> + <str> ) ; } } certificate = new File ( paths [ <int> ] ) ; privateKey = new File ( paths [ <int> ] ) ; key = keypair . getPrivate ( ) ; try { cert = ( X509Certificate ) CertificateFactory . getInstance ( <str> ) . generateCertificate ( new FileInputStream ( certificate ) ) ; } catch ( Exception e ) { throw new CertificateEncodingException ( e ) ; } } public File certificate ( ) { return certificate ; } public File privateKey ( ) { return privateKey ; } public X509Certificate cert ( ) { return cert ; } public PrivateKey key ( ) { return key ; } public void delete ( ) { safeDelete ( certificate ) ; safeDelete ( privateKey ) ; } static String [ ] newSelfSignedCertificate ( String fqdn , PrivateKey key , X509Certificate cert ) throws IOException , CertificateEncodingException { String keyText = <str> + Base64 . encode ( Unpooled . wrappedBuffer ( key . getEncoded ( ) ) , true ) . toString ( CharsetUtil . US_ASCII ) + <str> ; File keyFile = File . createTempFile ( <str> + fqdn + <str> , <str> ) ; keyFile . deleteOnExit ( ) ; OutputStream keyOut = new FileOutputStream ( keyFile ) ; try { keyOut . write ( keyText . getBytes ( CharsetUtil . US_ASCII ) ) ; keyOut . close ( ) ; keyOut = null ; } finally { if ( keyOut ! = null ) { safeClose ( keyFile , keyOut ) ; safeDelete ( keyFile ) ; } } String certText = <str> + Base64 . encode ( Unpooled . wrappedBuffer ( cert . getEncoded ( ) ) , true ) . toString ( CharsetUtil . US_ASCII ) + <str> ; File certFile = File . createTempFile ( <str> + fqdn + <str> , <str> ) ; certFile . deleteOnExit ( ) ; OutputStream certOut = new FileOutputStream ( certFile ) ; try { certOut . write ( certText . getBytes ( CharsetUtil . US_ASCII ) ) ; certOut . close ( ) ; certOut = null ; } finally { if ( certOut ! = null ) { safeClose ( certFile , certOut ) ; safeDelete ( certFile ) ; safeDelete ( keyFile ) ; } } return new String [ ] { certFile . getPath ( ) , keyFile . getPath ( ) } ; } private static void safeDelete ( File certFile ) { if ( ! certFile . delete ( ) ) { logger . warn ( <str> + certFile ) ; } } private static void safeClose ( File keyFile , OutputStream keyOut ) { try { keyOut . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> + keyFile , e ) ; } } } 
