package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapper ; import java . io . IOException ; public class GeoDistanceRangeQueryParser implements QueryParser < GeoDistanceRangeQueryBuilder > { public static final ParseField FROM_FIELD = new ParseField ( <str> ) ; public static final ParseField TO_FIELD = new ParseField ( <str> ) ; public static final ParseField INCLUDE_LOWER_FIELD = new ParseField ( <str> ) ; public static final ParseField INCLUDE_UPPER_FIELD = new ParseField ( <str> ) ; public static final ParseField GT_FIELD = new ParseField ( <str> ) ; public static final ParseField GTE_FIELD = new ParseField ( <str> , <str> ) ; public static final ParseField LT_FIELD = new ParseField ( <str> ) ; public static final ParseField LTE_FIELD = new ParseField ( <str> , <str> ) ; public static final ParseField UNIT_FIELD = new ParseField ( <str> ) ; public static final ParseField DISTANCE_TYPE_FIELD = new ParseField ( <str> ) ; public static final ParseField NAME_FIELD = new ParseField ( <str> ) ; public static final ParseField BOOST_FIELD = new ParseField ( <str> ) ; public static final ParseField OPTIMIZE_BBOX_FIELD = new ParseField ( <str> ) ; public static final ParseField COERCE_FIELD = new ParseField ( <str> , <str> ) ; public static final ParseField IGNORE_MALFORMED_FIELD = new ParseField ( <str> ) ; public static final ParseField VALIDATION_METHOD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { GeoDistanceRangeQueryBuilder . NAME , <str> } ; } @Override public GeoDistanceRangeQueryBuilder getBuilderPrototype ( ) { return GeoDistanceRangeQueryBuilder . PROTOTYPE ; } @Override public GeoDistanceRangeQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; XContentParser . Token token ; Float boost = null ; String queryName = null ; String currentFieldName = null ; GeoPoint point = null ; String fieldName = null ; Object vFrom = null ; Object vTo = null ; Boolean includeLower = null ; Boolean includeUpper = null ; DistanceUnit unit = null ; GeoDistance geoDistance = null ; String optimizeBbox = null ; boolean coerce = GeoValidationMethod . DEFAULT_LENIENT_PARSING ; boolean ignoreMalformed = GeoValidationMethod . DEFAULT_LENIENT_PARSING ; GeoValidationMethod validationMethod = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( parseContext . isDeprecatedSetting ( currentFieldName ) ) { } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( fieldName = = null ) { if ( point = = null ) { point = new GeoPoint ( ) ; } GeoUtils . parseGeoPoint ( parser , point ) ; fieldName = currentFieldName ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( fieldName = = null ) { fieldName = currentFieldName ; if ( point = = null ) { point = new GeoPoint ( ) ; } GeoUtils . parseGeoPoint ( parser , point ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } } else if ( token . isValue ( ) ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , FROM_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vFrom = parser . text ( ) ; } else { vFrom = parser . numberValue ( ) ; } } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , TO_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vTo = parser . text ( ) ; } else { vTo = parser . numberValue ( ) ; } } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , INCLUDE_LOWER_FIELD ) ) { includeLower = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , INCLUDE_UPPER_FIELD ) ) { includeUpper = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , GT_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vFrom = parser . text ( ) ; } else { vFrom = parser . numberValue ( ) ; } includeLower = false ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , GTE_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vFrom = parser . text ( ) ; } else { vFrom = parser . numberValue ( ) ; } includeLower = true ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , LT_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vTo = parser . text ( ) ; } else { vTo = parser . numberValue ( ) ; } includeUpper = false ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , LTE_FIELD ) ) { if ( token = = XContentParser . Token . VALUE_NULL ) { } else if ( token = = XContentParser . Token . VALUE_STRING ) { vTo = parser . text ( ) ; } else { vTo = parser . numberValue ( ) ; } includeUpper = true ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , UNIT_FIELD ) ) { unit = DistanceUnit . fromString ( parser . text ( ) ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , DISTANCE_TYPE_FIELD ) ) { geoDistance = GeoDistance . fromString ( parser . text ( ) ) ; } else if ( currentFieldName . endsWith ( GeoPointFieldMapper . Names . LAT_SUFFIX ) ) { String maybeFieldName = currentFieldName . substring ( <int> , currentFieldName . length ( ) - GeoPointFieldMapper . Names . LAT_SUFFIX . length ( ) ) ; if ( fieldName = = null | | fieldName . equals ( maybeFieldName ) ) { fieldName = maybeFieldName ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } if ( point = = null ) { point = new GeoPoint ( ) ; } point . resetLat ( parser . doubleValue ( ) ) ; } else if ( currentFieldName . endsWith ( GeoPointFieldMapper . Names . LON_SUFFIX ) ) { String maybeFieldName = currentFieldName . substring ( <int> , currentFieldName . length ( ) - GeoPointFieldMapper . Names . LON_SUFFIX . length ( ) ) ; if ( fieldName = = null | | fieldName . equals ( maybeFieldName ) ) { fieldName = maybeFieldName ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } if ( point = = null ) { point = new GeoPoint ( ) ; } point . resetLon ( parser . doubleValue ( ) ) ; } else if ( currentFieldName . endsWith ( GeoPointFieldMapper . Names . GEOHASH_SUFFIX ) ) { String maybeFieldName = currentFieldName . substring ( <int> , currentFieldName . length ( ) - GeoPointFieldMapper . Names . GEOHASH_SUFFIX . length ( ) ) ; if ( fieldName = = null | | fieldName . equals ( maybeFieldName ) ) { fieldName = maybeFieldName ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } point = GeoPoint . fromGeohash ( parser . text ( ) ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , NAME_FIELD ) ) { queryName = parser . text ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , BOOST_FIELD ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , OPTIMIZE_BBOX_FIELD ) ) { optimizeBbox = parser . textOrNull ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , COERCE_FIELD ) ) { coerce = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , IGNORE_MALFORMED_FIELD ) ) { ignoreMalformed = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , VALIDATION_METHOD ) ) { validationMethod = GeoValidationMethod . fromString ( parser . text ( ) ) ; } else { if ( fieldName = = null ) { if ( point = = null ) { point = new GeoPoint ( ) ; } point . resetFromString ( parser . text ( ) ) ; fieldName = currentFieldName ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + GeoDistanceRangeQueryBuilder . NAME + <str> + fieldName + <str> + currentFieldName + <str> ) ; } } } } GeoDistanceRangeQueryBuilder queryBuilder = new GeoDistanceRangeQueryBuilder ( fieldName , point ) ; if ( boost ! = null ) { queryBuilder . boost ( boost ) ; } if ( queryName ! = null ) { queryBuilder . queryName ( queryName ) ; } if ( vFrom ! = null ) { if ( vFrom instanceof Number ) { queryBuilder . from ( ( Number ) vFrom ) ; } else { queryBuilder . from ( ( String ) vFrom ) ; } } if ( vTo ! = null ) { if ( vTo instanceof Number ) { queryBuilder . to ( ( Number ) vTo ) ; } else { queryBuilder . to ( ( String ) vTo ) ; } } if ( includeUpper ! = null ) { queryBuilder . includeUpper ( includeUpper ) ; } if ( includeLower ! = null ) { queryBuilder . includeLower ( includeLower ) ; } if ( unit ! = null ) { queryBuilder . unit ( unit ) ; } if ( geoDistance ! = null ) { queryBuilder . geoDistance ( geoDistance ) ; } if ( optimizeBbox ! = null ) { queryBuilder . optimizeBbox ( optimizeBbox ) ; } if ( validationMethod ! = null ) { queryBuilder . setValidationMethod ( validationMethod ) ; } else { queryBuilder . setValidationMethod ( GeoValidationMethod . infer ( coerce , ignoreMalformed ) ) ; } return queryBuilder ; } } 
