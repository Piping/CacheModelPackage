package org . elasticsearch . deps . joda ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . mapper . object . RootObjectMapper ; import org . elasticsearch . test . ESTestCase ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . LocalDateTime ; import org . joda . time . MutableDateTime ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import org . joda . time . format . DateTimeFormatterBuilder ; import org . joda . time . format . DateTimeParser ; import org . joda . time . format . ISODateTimeFormat ; import java . util . Date ; import java . util . Locale ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . endsWith ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class SimpleJodaTests extends ESTestCase { public void testMultiParsers ( ) { DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( ) ; DateTimeParser [ ] parsers = new DateTimeParser [ <int> ] ; parsers [ <int> ] = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . getParser ( ) ; parsers [ <int> ] = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . getParser ( ) ; parsers [ <int> ] = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . getParser ( ) ; builder . append ( DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . getPrinter ( ) , parsers ) ; DateTimeFormatter formatter = builder . toFormatter ( ) ; formatter . parseMillis ( <str> ) ; } public void testIsoDateFormatDateTimeNoMillisUTC ( ) { DateTimeFormatter formatter = ISODateTimeFormat . dateTimeNoMillis ( ) . withZone ( DateTimeZone . UTC ) ; long millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; } public void testUpperBound ( ) { MutableDateTime dateTime = new MutableDateTime ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; DateTimeFormatter formatter = ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) ; String value = <str> ; int i = formatter . parseInto ( dateTime , value , <int> ) ; assertThat ( i , equalTo ( value . length ( ) ) ) ; assertThat ( dateTime . toString ( ) , equalTo ( <str> ) ) ; } public void testIsoDateFormatDateOptionalTimeUTC ( ) { DateTimeFormatter formatter = ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) ; long millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; try { formatter . parseMillis ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( TimeValue . timeValueHours ( <int> ) . millis ( ) ) ) ; } public void testIsoVsCustom ( ) { DateTimeFormatter formatter = ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) ; long millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; formatter = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) ; millis = formatter . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; FormatDateTimeFormatter formatter2 = Joda . forPattern ( <str> ) ; millis = formatter2 . parser ( ) . parseMillis ( <str> ) ; assertThat ( millis , equalTo ( <int> l ) ) ; } public void testWriteAndParse ( ) { DateTimeFormatter dateTimeWriter = ISODateTimeFormat . dateTime ( ) . withZone ( DateTimeZone . UTC ) ; DateTimeFormatter formatter = ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) ; Date date = new Date ( ) ; assertThat ( formatter . parseMillis ( dateTimeWriter . print ( date . getTime ( ) ) ) , equalTo ( date . getTime ( ) ) ) ; } public void testSlashInFormat ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; formatter . parser ( ) . parseMillis ( <str> ) ; formatter = Joda . forPattern ( <str> ) ; long millis = formatter . parser ( ) . parseMillis ( <str> ) ; formatter . printer ( ) . print ( millis ) ; try { millis = formatter . parser ( ) . parseMillis ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } } public void testMultipleFormats ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; long millis = formatter . parser ( ) . parseMillis ( <str> ) ; assertThat ( <str> , is ( formatter . printer ( ) . print ( millis ) ) ) ; } public void testMultipleDifferentFormats ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; String input = <str> ; long millis = formatter . parser ( ) . parseMillis ( input ) ; assertThat ( input , is ( formatter . printer ( ) . print ( millis ) ) ) ; Joda . forPattern ( <str> ) ; Joda . forPattern ( <str> ) ; Joda . forPattern ( <str> ) ; Joda . forPattern ( <str> ) ; Joda . forPattern ( <str> ) ; } public void testInvalidPatterns ( ) { expectInvalidPattern ( <str> , <str> ) ; expectInvalidPattern ( <str> , <str> ) ; expectInvalidPattern ( null , <str> ) ; expectInvalidPattern ( <str> , <str> ) ; expectInvalidPattern ( <str> , <str> ) ; expectInvalidPattern ( <str> , <str> ) ; expectInvalidPattern ( <str> , <str> ) ; } private void expectInvalidPattern ( String pattern , String errorMessage ) { try { Joda . forPattern ( pattern ) ; fail ( <str> + pattern + <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( errorMessage ) ) ; } } public void testRounding ( ) { long TIME = utcTimeInMillis ( <str> ) ; MutableDateTime time = new MutableDateTime ( DateTimeZone . UTC ) ; time . setMillis ( TIME ) ; assertThat ( time . monthOfYear ( ) . roundFloor ( ) . toString ( ) , equalTo ( <str> ) ) ; time . setMillis ( TIME ) ; assertThat ( time . hourOfDay ( ) . roundFloor ( ) . toString ( ) , equalTo ( <str> ) ) ; time . setMillis ( TIME ) ; assertThat ( time . dayOfMonth ( ) . roundFloor ( ) . toString ( ) , equalTo ( <str> ) ) ; } public void testRoundingSetOnTime ( ) { MutableDateTime time = new MutableDateTime ( DateTimeZone . UTC ) ; time . setRounding ( time . getChronology ( ) . monthOfYear ( ) , MutableDateTime . ROUND_FLOOR ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTimeInMillis ( <str> ) ) ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTimeInMillis ( <str> ) ) ) ; time = new MutableDateTime ( DateTimeZone . UTC ) ; time . setRounding ( time . getChronology ( ) . dayOfMonth ( ) , MutableDateTime . ROUND_FLOOR ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTimeInMillis ( <str> ) ) ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTimeInMillis ( <str> ) ) ) ; time = new MutableDateTime ( DateTimeZone . UTC ) ; time . setRounding ( time . getChronology ( ) . weekOfWeekyear ( ) , MutableDateTime . ROUND_FLOOR ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTimeInMillis ( <str> ) ) ) ; } public void testRoundingWithTimeZone ( ) { MutableDateTime time = new MutableDateTime ( DateTimeZone . UTC ) ; time . setZone ( DateTimeZone . forOffsetHours ( - <int> ) ) ; time . setRounding ( time . getChronology ( ) . dayOfMonth ( ) , MutableDateTime . ROUND_FLOOR ) ; MutableDateTime utcTime = new MutableDateTime ( DateTimeZone . UTC ) ; utcTime . setRounding ( utcTime . getChronology ( ) . dayOfMonth ( ) , MutableDateTime . ROUND_FLOOR ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; utcTime . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( utcTime . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTime . getMillis ( ) - TimeValue . timeValueHours ( <int> ) . millis ( ) ) ) ; time . setMillis ( utcTimeInMillis ( <str> ) ) ; utcTime . setMillis ( utcTimeInMillis ( <str> ) ) ; assertThat ( time . toString ( ) , equalTo ( <str> ) ) ; assertThat ( utcTime . toString ( ) , equalTo ( <str> ) ) ; assertThat ( time . getMillis ( ) , equalTo ( utcTime . getMillis ( ) - TimeValue . timeValueHours ( <int> ) . millis ( ) ) ) ; } public void testThatEpochsCanBeParsed ( ) { boolean parseMilliSeconds = randomBoolean ( ) ; FormatDateTimeFormatter formatter = Joda . forPattern ( parseMilliSeconds ? <str> : <str> ) ; DateTime dateTime = formatter . parser ( ) . parseDateTime ( parseMilliSeconds ? <str> : <str> ) ; assertThat ( dateTime . getYear ( ) , is ( <int> ) ) ; assertThat ( dateTime . getDayOfMonth ( ) , is ( <int> ) ) ; assertThat ( dateTime . getMonthOfYear ( ) , is ( <int> ) ) ; assertThat ( dateTime . getHourOfDay ( ) , is ( <int> ) ) ; assertThat ( dateTime . getMinuteOfHour ( ) , is ( <int> ) ) ; assertThat ( dateTime . getSecondOfMinute ( ) , is ( <int> ) ) ; if ( parseMilliSeconds ) { assertThat ( dateTime . getMillisOfSecond ( ) , is ( <int> ) ) ; } else { assertThat ( dateTime . getMillisOfSecond ( ) , is ( <int> ) ) ; } } public void testThatNegativeEpochsCanBeParsed ( ) { boolean parseMilliSeconds = randomBoolean ( ) ; FormatDateTimeFormatter formatter = Joda . forPattern ( parseMilliSeconds ? <str> : <str> ) ; DateTime dateTime = formatter . parser ( ) . parseDateTime ( <str> ) ; assertThat ( dateTime . getYear ( ) , is ( <int> ) ) ; assertThat ( dateTime . getMonthOfYear ( ) , is ( <int> ) ) ; assertThat ( dateTime . getDayOfMonth ( ) , is ( <int> ) ) ; if ( parseMilliSeconds ) { assertThat ( dateTime . getHourOfDay ( ) , is ( <int> ) ) ; assertThat ( dateTime . getMinuteOfHour ( ) , is ( <int> ) ) ; assertThat ( dateTime . getSecondOfMinute ( ) , is ( <int> ) ) ; } else { assertThat ( dateTime . getHourOfDay ( ) , is ( <int> ) ) ; assertThat ( dateTime . getMinuteOfHour ( ) , is ( <int> ) ) ; assertThat ( dateTime . getSecondOfMinute ( ) , is ( <int> ) ) ; } if ( parseMilliSeconds ) { formatter . parser ( ) . parseDateTime ( <str> ) ; formatter . parser ( ) . parseDateTime ( <str> ) ; formatter . parser ( ) . parseDateTime ( <str> ) ; } else { formatter . parser ( ) . parseDateTime ( <str> ) ; formatter . parser ( ) . parseDateTime ( <str> ) ; } } public void testForInvalidDatesInEpochSecond ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; try { formatter . parser ( ) . parseDateTime ( randomFrom ( <str> , <str> , <str> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testForInvalidDatesInEpochMillis ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; try { formatter . parser ( ) . parseDateTime ( randomFrom ( <str> , <str> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testThatEpochParserIsPrinter ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; assertThat ( formatter . parser ( ) . isPrinter ( ) , is ( true ) ) ; assertThat ( formatter . printer ( ) . isPrinter ( ) , is ( true ) ) ; FormatDateTimeFormatter epochSecondFormatter = Joda . forPattern ( <str> ) ; assertThat ( epochSecondFormatter . parser ( ) . isPrinter ( ) , is ( true ) ) ; assertThat ( epochSecondFormatter . printer ( ) . isPrinter ( ) , is ( true ) ) ; } public void testThatEpochTimePrinterWorks ( ) { StringBuffer buffer = new StringBuffer ( ) ; LocalDateTime now = LocalDateTime . now ( ) ; Joda . EpochTimePrinter epochTimePrinter = new Joda . EpochTimePrinter ( false ) ; epochTimePrinter . printTo ( buffer , now , Locale . ROOT ) ; assertThat ( buffer . length ( ) , is ( <int> ) ) ; assertThat ( buffer . toString ( ) , endsWith ( String . valueOf ( now . getSecondOfMinute ( ) % <int> ) ) ) ; buffer = new StringBuffer ( ) ; Joda . EpochTimePrinter epochMilliSecondTimePrinter = new Joda . EpochTimePrinter ( true ) ; epochMilliSecondTimePrinter . printTo ( buffer , now , Locale . ROOT ) ; assertThat ( buffer . length ( ) , is ( <int> ) ) ; assertThat ( buffer . toString ( ) , endsWith ( String . valueOf ( now . getMillisOfSecond ( ) ) ) ) ; } public void testThatEpochParserIsIdempotent ( ) { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; DateTime dateTime = formatter . parser ( ) . parseDateTime ( <str> ) ; assertThat ( dateTime . getMillis ( ) , is ( <int> ) ) ; dateTime = formatter . printer ( ) . parseDateTime ( <str> ) ; assertThat ( dateTime . getMillis ( ) , is ( <int> ) ) ; dateTime = formatter . parser ( ) . parseDateTime ( <str> ) ; assertThat ( dateTime . getMillis ( ) , is ( <int> ) ) ; FormatDateTimeFormatter secondsFormatter = Joda . forPattern ( <str> ) ; DateTime secondsDateTime = secondsFormatter . parser ( ) . parseDateTime ( <str> ) ; assertThat ( secondsDateTime . getMillis ( ) , is ( <int> ) ) ; secondsDateTime = secondsFormatter . printer ( ) . parseDateTime ( <str> ) ; assertThat ( secondsDateTime . getMillis ( ) , is ( <int> ) ) ; secondsDateTime = secondsFormatter . parser ( ) . parseDateTime ( <str> ) ; assertThat ( secondsDateTime . getMillis ( ) , is ( <int> ) ) ; } public void testThatDefaultFormatterChecksForCorrectYearLength ( ) throws Exception { assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> , <str> ) ; assertValidDateFormatParsing ( <str> , <str> ) ; assertDateFormatParsingThrowingException ( <str> , <str> ) ; } public void testThatRootObjectParsingIsStrict ( ) throws Exception { String [ ] datesThatWork = new String [ ] { <str> , <str> , <str> , <str> } ; String [ ] datesThatShouldNotWork = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String date : datesThatWork ) { boolean dateParsingSuccessful = false ; for ( FormatDateTimeFormatter dateTimeFormatter : RootObjectMapper . Defaults . DYNAMIC_DATE_TIME_FORMATTERS ) { try { dateTimeFormatter . parser ( ) . parseMillis ( date ) ; dateParsingSuccessful = true ; break ; } catch ( Exception e ) { } } if ( ! dateParsingSuccessful ) { fail ( <str> + date + <str> ) ; } } for ( String date : datesThatShouldNotWork ) { for ( FormatDateTimeFormatter dateTimeFormatter : RootObjectMapper . Defaults . DYNAMIC_DATE_TIME_FORMATTERS ) { try { dateTimeFormatter . parser ( ) . parseMillis ( date ) ; fail ( String . format ( Locale . ROOT , <str> , date ) ) ; } catch ( Exception e ) { } } } } private void assertValidDateFormatParsing ( String pattern , String dateToParse ) { assertValidDateFormatParsing ( pattern , dateToParse , dateToParse ) ; } private void assertValidDateFormatParsing ( String pattern , String dateToParse , String expectedDate ) { FormatDateTimeFormatter formatter = Joda . forPattern ( pattern ) ; assertThat ( formatter . printer ( ) . print ( formatter . parser ( ) . parseMillis ( dateToParse ) ) , is ( expectedDate ) ) ; } private void assertDateFormatParsingThrowingException ( String pattern , String invalidDate ) { try { FormatDateTimeFormatter formatter = Joda . forPattern ( pattern ) ; DateTimeFormatter parser = formatter . parser ( ) ; parser . parseMillis ( invalidDate ) ; fail ( String . format ( Locale . ROOT , <str> , pattern , invalidDate ) ) ; } catch ( IllegalArgumentException e ) { } } private long utcTimeInMillis ( String time ) { return ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) . parseMillis ( time ) ; } } 
