package org . elasticsearch . search . aggregations . metrics . stats ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . metrics . InternalNumericMetricsAggregation ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . aggregations . support . format . ValueFormatterStreams ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class InternalStats extends InternalNumericMetricsAggregation . MultiValue implements Stats { public final static Type TYPE = new Type ( <str> ) ; public final static AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public InternalStats readResult ( StreamInput in ) throws IOException { InternalStats result = new InternalStats ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } enum Metrics { count , sum , min , max , avg ; public static Metrics resolve ( String name ) { return Metrics . valueOf ( name ) ; } } protected long count ; protected double min ; protected double max ; protected double sum ; protected InternalStats ( ) { } public InternalStats ( String name , long count , double sum , double min , double max , ValueFormatter formatter , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; this . count = count ; this . sum = sum ; this . min = min ; this . max = max ; this . valueFormatter = formatter ; } @Override public long getCount ( ) { return count ; } @Override public double getMin ( ) { return min ; } @Override public double getMax ( ) { return max ; } @Override public double getAvg ( ) { return sum / count ; } @Override public double getSum ( ) { return sum ; } @Override public String getCountAsString ( ) { return valueAsString ( Metrics . count . name ( ) ) ; } @Override public String getMinAsString ( ) { return valueAsString ( Metrics . min . name ( ) ) ; } @Override public String getMaxAsString ( ) { return valueAsString ( Metrics . max . name ( ) ) ; } @Override public String getAvgAsString ( ) { return valueAsString ( Metrics . avg . name ( ) ) ; } @Override public String getSumAsString ( ) { return valueAsString ( Metrics . sum . name ( ) ) ; } @Override public Type type ( ) { return TYPE ; } @Override public double value ( String name ) { Metrics metrics = Metrics . valueOf ( name ) ; switch ( metrics ) { case min : return this . min ; case max : return this . max ; case avg : return this . getAvg ( ) ; case count : return this . count ; case sum : return this . sum ; default : throw new IllegalArgumentException ( <str> + name + <str> ) ; } } @Override public InternalStats doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { long count = <int> ; double min = Double . POSITIVE_INFINITY ; double max = Double . NEGATIVE_INFINITY ; double sum = <int> ; for ( InternalAggregation aggregation : aggregations ) { InternalStats stats = ( InternalStats ) aggregation ; count + = stats . getCount ( ) ; min = Math . min ( min , stats . getMin ( ) ) ; max = Math . max ( max , stats . getMax ( ) ) ; sum + = stats . getSum ( ) ; } return new InternalStats ( name , count , sum , min , max , valueFormatter , pipelineAggregators ( ) , getMetaData ( ) ) ; } @Override protected void doReadFrom ( StreamInput in ) throws IOException { valueFormatter = ValueFormatterStreams . readOptional ( in ) ; count = in . readVLong ( ) ; min = in . readDouble ( ) ; max = in . readDouble ( ) ; sum = in . readDouble ( ) ; readOtherStatsFrom ( in ) ; } public void readOtherStatsFrom ( StreamInput in ) throws IOException { } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { ValueFormatterStreams . writeOptional ( valueFormatter , out ) ; out . writeVLong ( count ) ; out . writeDouble ( min ) ; out . writeDouble ( max ) ; out . writeDouble ( sum ) ; writeOtherStatsTo ( out ) ; } protected void writeOtherStatsTo ( StreamOutput out ) throws IOException { } static class Fields { public static final XContentBuilderString COUNT = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString MIN = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString MIN_AS_STRING = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString MAX = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString MAX_AS_STRING = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString AVG = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString AVG_AS_STRING = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString SUM = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString SUM_AS_STRING = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . COUNT , count ) ; builder . field ( Fields . MIN , count ! = <int> ? min : null ) ; builder . field ( Fields . MAX , count ! = <int> ? max : null ) ; builder . field ( Fields . AVG , count ! = <int> ? getAvg ( ) : null ) ; builder . field ( Fields . SUM , count ! = <int> ? sum : null ) ; if ( count ! = <int> & & ! ( valueFormatter instanceof ValueFormatter . Raw ) ) { builder . field ( Fields . MIN_AS_STRING , valueFormatter . format ( min ) ) ; builder . field ( Fields . MAX_AS_STRING , valueFormatter . format ( max ) ) ; builder . field ( Fields . AVG_AS_STRING , valueFormatter . format ( getAvg ( ) ) ) ; builder . field ( Fields . SUM_AS_STRING , valueFormatter . format ( sum ) ) ; } otherStatsToXCotent ( builder , params ) ; return builder ; } protected XContentBuilder otherStatsToXCotent ( XContentBuilder builder , Params params ) throws IOException { return builder ; } } 
