package io . netty . channel . local ; import io . netty . channel . AbstractServerChannel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . DefaultChannelConfig ; import io . netty . channel . EventLoop ; import io . netty . channel . ServerChannel ; import io . netty . channel . SingleThreadEventLoop ; import io . netty . util . concurrent . SingleThreadEventExecutor ; import java . net . SocketAddress ; import java . util . ArrayDeque ; import java . util . Queue ; public class LocalServerChannel extends AbstractServerChannel { private final ChannelConfig config = new DefaultChannelConfig ( this ) ; private final Queue < Object > inboundBuffer = new ArrayDeque < Object > ( ) ; private final Runnable shutdownHook = new Runnable ( ) { @Override public void run ( ) { unsafe ( ) . close ( unsafe ( ) . voidPromise ( ) ) ; } } ; private volatile int state ; private volatile LocalAddress localAddress ; private volatile boolean acceptInProgress ; @Override public ChannelConfig config ( ) { return config ; } @Override public LocalAddress localAddress ( ) { return ( LocalAddress ) super . localAddress ( ) ; } @Override public LocalAddress remoteAddress ( ) { return ( LocalAddress ) super . remoteAddress ( ) ; } @Override public boolean isOpen ( ) { return state < <int> ; } @Override public boolean isActive ( ) { return state = = <int> ; } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof SingleThreadEventLoop ; } @Override protected SocketAddress localAddress0 ( ) { return localAddress ; } @Override protected void doRegister ( ) throws Exception { ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . addShutdownHook ( shutdownHook ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { this . localAddress = LocalChannelRegistry . register ( this , this . localAddress , localAddress ) ; state = <int> ; } @Override protected void doClose ( ) throws Exception { if ( state < = <int> ) { if ( localAddress ! = null ) { LocalChannelRegistry . unregister ( localAddress ) ; localAddress = null ; } state = <int> ; } } @Override protected void doDeregister ( ) throws Exception { ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . removeShutdownHook ( shutdownHook ) ; } @Override protected void doBeginRead ( ) throws Exception { if ( acceptInProgress ) { return ; } Queue < Object > inboundBuffer = this . inboundBuffer ; if ( inboundBuffer . isEmpty ( ) ) { acceptInProgress = true ; return ; } ChannelPipeline pipeline = pipeline ( ) ; for ( ; ; ) { Object m = inboundBuffer . poll ( ) ; if ( m = = null ) { break ; } pipeline . fireChannelRead ( m ) ; } pipeline . fireChannelReadComplete ( ) ; } LocalChannel serve ( final LocalChannel peer ) { final LocalChannel child = new LocalChannel ( this , peer ) ; if ( eventLoop ( ) . inEventLoop ( ) ) { serve0 ( child ) ; } else { eventLoop ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { serve0 ( child ) ; } } ) ; } return child ; } private void serve0 ( final LocalChannel child ) { inboundBuffer . add ( child ) ; if ( acceptInProgress ) { acceptInProgress = false ; ChannelPipeline pipeline = pipeline ( ) ; for ( ; ; ) { Object m = inboundBuffer . poll ( ) ; if ( m = = null ) { break ; } pipeline . fireChannelRead ( m ) ; } pipeline . fireChannelReadComplete ( ) ; } } } 
