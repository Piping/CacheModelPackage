package org . elasticsearch . common . util . concurrent ; import java . util . concurrent . BrokenBarrierException ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class ThreadBarrier extends CyclicBarrier { private Throwable cause ; public ThreadBarrier ( int parties ) { super ( parties ) ; } public ThreadBarrier ( int parties , Runnable barrierAction ) { super ( parties , barrierAction ) ; } @Override public int await ( ) throws InterruptedException , BrokenBarrierException { try { breakIfBroken ( ) ; return super . await ( ) ; } catch ( BrokenBarrierException bbe ) { initCause ( bbe ) ; throw bbe ; } } @Override public int await ( long timeout , TimeUnit unit ) throws InterruptedException , BrokenBarrierException , TimeoutException { try { breakIfBroken ( ) ; return super . await ( timeout , unit ) ; } catch ( BrokenBarrierException bbe ) { initCause ( bbe ) ; throw bbe ; } catch ( TimeoutException te ) { initCause ( te ) ; throw te ; } } public synchronized void reset ( Throwable cause ) { if ( ! isBroken ( ) ) { super . reset ( ) ; } if ( this . cause = = null ) { this . cause = cause ; } } @Override public synchronized boolean isBroken ( ) { return this . cause ! = null | | super . isBroken ( ) ; } public synchronized void inspect ( ) throws BrokenBarrierException { try { breakIfBroken ( ) ; } catch ( BrokenBarrierException bbe ) { initCause ( bbe ) ; throw bbe ; } } private synchronized void breakIfBroken ( ) throws BrokenBarrierException { if ( isBroken ( ) ) { throw new BrokenBarrierException ( ) ; } } private synchronized void initCause ( Throwable t ) { t . initCause ( this . cause ) ; } public static class BarrierTimer implements Runnable { volatile boolean started ; volatile long startTime ; volatile long endTime ; @Override public void run ( ) { long t = System . nanoTime ( ) ; if ( ! started ) { started = true ; startTime = t ; } else endTime = t ; } public void reset ( ) { started = false ; } public long getTimeInNanos ( ) { return endTime - startTime ; } public double getTimeInSeconds ( ) { long time = endTime - startTime ; return ( time ) / <float> ; } } } 
