package org . apache . lucene . store ; import org . apache . lucene . store . RateLimiter . SimpleRateLimiter ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . unit . ByteSizeValue ; public class StoreRateLimiting { public static interface Provider { StoreRateLimiting rateLimiting ( ) ; } public interface Listener { void onPause ( long nanos ) ; } public enum Type { NONE , MERGE , ALL ; public static Type fromString ( String type ) { if ( <str> . equalsIgnoreCase ( type ) ) { return NONE ; } else if ( <str> . equalsIgnoreCase ( type ) ) { return MERGE ; } else if ( <str> . equalsIgnoreCase ( type ) ) { return ALL ; } throw new IllegalArgumentException ( <str> + type + <str> ) ; } } private final SimpleRateLimiter rateLimiter = new SimpleRateLimiter ( <int> ) ; private volatile SimpleRateLimiter actualRateLimiter ; private volatile Type type ; public StoreRateLimiting ( ) { } @Nullable public RateLimiter getRateLimiter ( ) { return actualRateLimiter ; } public void setMaxRate ( ByteSizeValue rate ) { if ( rate . bytes ( ) < = <int> ) { actualRateLimiter = null ; } else if ( actualRateLimiter = = null ) { actualRateLimiter = rateLimiter ; actualRateLimiter . setMBPerSec ( rate . mbFrac ( ) ) ; } else { assert rateLimiter = = actualRateLimiter ; rateLimiter . setMBPerSec ( rate . mbFrac ( ) ) ; } } public Type getType ( ) { return type ; } public void setType ( Type type ) { this . type = type ; } public void setType ( String type ) { this . type = Type . fromString ( type ) ; } } 
