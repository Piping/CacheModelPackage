package org . elasticsearch . index . search . geo ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . RandomAccessWeight ; import org . apache . lucene . search . Weight ; import org . apache . lucene . util . Bits ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . index . fielddata . IndexGeoPointFieldData ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import java . io . IOException ; import java . util . Arrays ; public class GeoPolygonQuery extends Query { private final GeoPoint [ ] points ; private final IndexGeoPointFieldData indexFieldData ; public GeoPolygonQuery ( IndexGeoPointFieldData indexFieldData , GeoPoint . . . points ) { this . points = points ; this . indexFieldData = indexFieldData ; } public GeoPoint [ ] points ( ) { return points ; } public String fieldName ( ) { return indexFieldData . getFieldNames ( ) . indexName ( ) ; } @Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores ) throws IOException { return new RandomAccessWeight ( this ) { @Override protected Bits getMatchingDocs ( LeafReaderContext context ) throws IOException { final int maxDoc = context . reader ( ) . maxDoc ( ) ; final MultiGeoPointValues values = indexFieldData . load ( context ) . getGeoPointValues ( ) ; return new Bits ( ) { private boolean pointInPolygon ( GeoPoint [ ] points , double lat , double lon ) { boolean inPoly = false ; for ( int i = <int> ; i < points . length ; i + + ) { if ( points [ i ] . lon ( ) < lon & & points [ i - <int> ] . lon ( ) > = lon | | points [ i - <int> ] . lon ( ) < lon & & points [ i ] . lon ( ) > = lon ) { if ( points [ i ] . lat ( ) + ( lon - points [ i ] . lon ( ) ) / ( points [ i - <int> ] . lon ( ) - points [ i ] . lon ( ) ) * ( points [ i - <int> ] . lat ( ) - points [ i ] . lat ( ) ) < lat ) { inPoly = ! inPoly ; } } } return inPoly ; } @Override public boolean get ( int doc ) { values . setDocument ( doc ) ; final int length = values . count ( ) ; for ( int i = <int> ; i < length ; i + + ) { GeoPoint point = values . valueAt ( i ) ; if ( pointInPolygon ( points , point . lat ( ) , point . lon ( ) ) ) { return true ; } } return false ; } @Override public int length ( ) { return maxDoc ; } } ; } } ; } @Override public String toString ( String field ) { StringBuilder sb = new StringBuilder ( <str> ) ; sb . append ( indexFieldData . getFieldNames ( ) . indexName ( ) ) ; sb . append ( <str> ) . append ( Arrays . toString ( points ) ) . append ( <str> ) ; return sb . toString ( ) ; } @Override public boolean equals ( Object obj ) { if ( super . equals ( obj ) = = false ) { return false ; } GeoPolygonQuery that = ( GeoPolygonQuery ) obj ; return indexFieldData . getFieldNames ( ) . indexName ( ) . equals ( that . indexFieldData . getFieldNames ( ) . indexName ( ) ) & & Arrays . equals ( points , that . points ) ; } @Override public int hashCode ( ) { int h = super . hashCode ( ) ; h = <int> * h + indexFieldData . getFieldNames ( ) . indexName ( ) . hashCode ( ) ; h = <int> * h + Arrays . hashCode ( points ) ; return h ; } } 
