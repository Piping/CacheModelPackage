package org . elasticsearch . snapshots ; import com . carrotsearch . hppc . IntHashSet ; import com . carrotsearch . hppc . IntSet ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . RestoreInProgress . ShardRestoreStatus ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . * ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . settings . ClusterDynamicSettings ; import org . elasticsearch . cluster . settings . DynamicSettings ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . repositories . RepositoriesService ; import org . elasticsearch . repositories . Repository ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CopyOnWriteArrayList ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . cluster . metadata . IndexMetaData . * ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; public class RestoreService extends AbstractComponent implements ClusterStateListener { public static final String UPDATE_RESTORE_ACTION_NAME = <str> ; private static final Set < String > UNMODIFIABLE_SETTINGS = unmodifiableSet ( newHashSet ( SETTING_NUMBER_OF_SHARDS , SETTING_VERSION_CREATED , SETTING_INDEX_UUID , SETTING_CREATION_DATE ) ) ; private static final Set < String > UNREMOVABLE_SETTINGS ; static { Set < String > unremovable = new HashSet < > ( UNMODIFIABLE_SETTINGS . size ( ) + <int> ) ; unremovable . addAll ( UNMODIFIABLE_SETTINGS ) ; unremovable . add ( SETTING_NUMBER_OF_REPLICAS ) ; unremovable . add ( SETTING_AUTO_EXPAND_REPLICAS ) ; unremovable . add ( SETTING_VERSION_UPGRADED ) ; unremovable . add ( SETTING_VERSION_MINIMUM_COMPATIBLE ) ; UNREMOVABLE_SETTINGS = unmodifiableSet ( unremovable ) ; } private final ClusterService clusterService ; private final RepositoriesService repositoriesService ; private final TransportService transportService ; private final AllocationService allocationService ; private final MetaDataCreateIndexService createIndexService ; private final DynamicSettings dynamicSettings ; private final MetaDataIndexUpgradeService metaDataIndexUpgradeService ; private final CopyOnWriteArrayList < ActionListener < RestoreCompletionResponse > > listeners = new CopyOnWriteArrayList < > ( ) ; private final BlockingQueue < UpdateIndexShardRestoreStatusRequest > updatedSnapshotStateQueue = ConcurrentCollections . newBlockingQueue ( ) ; @Inject public RestoreService ( Settings settings , ClusterService clusterService , RepositoriesService repositoriesService , TransportService transportService , AllocationService allocationService , MetaDataCreateIndexService createIndexService , @ClusterDynamicSettings DynamicSettings dynamicSettings , MetaDataIndexUpgradeService metaDataIndexUpgradeService ) { super ( settings ) ; this . clusterService = clusterService ; this . repositoriesService = repositoriesService ; this . transportService = transportService ; this . allocationService = allocationService ; this . createIndexService = createIndexService ; this . dynamicSettings = dynamicSettings ; this . metaDataIndexUpgradeService = metaDataIndexUpgradeService ; transportService . registerRequestHandler ( UPDATE_RESTORE_ACTION_NAME , UpdateIndexShardRestoreStatusRequest : : new , ThreadPool . Names . SAME , new UpdateRestoreStateRequestHandler ( ) ) ; clusterService . add ( this ) ; } public void restoreSnapshot ( final RestoreRequest request , final ActionListener < RestoreInfo > listener ) { try { Repository repository = repositoriesService . repository ( request . repository ( ) ) ; final SnapshotId snapshotId = new SnapshotId ( request . repository ( ) , request . name ( ) ) ; final Snapshot snapshot = repository . readSnapshot ( snapshotId ) ; List < String > filteredIndices = SnapshotUtils . filterIndices ( snapshot . indices ( ) , request . indices ( ) , request . indicesOptions ( ) ) ; MetaData metaDataIn = repository . readSnapshotMetaData ( snapshotId , snapshot , filteredIndices ) ; final MetaData metaData ; if ( snapshot . version ( ) . before ( Version . V_2_0_0_beta1 ) ) { metaData = MetaData . addDefaultUnitsIfNeeded ( logger , metaDataIn ) ; } else { metaData = metaDataIn ; } validateSnapshotRestorable ( snapshotId , snapshot ) ; final Map < String , String > renamedIndices = renamedIndices ( request , filteredIndices ) ; clusterService . submitStateUpdateTask ( request . cause ( ) , new ClusterStateUpdateTask ( ) { RestoreInfo restoreInfo = null ; @Override public ClusterState execute ( ClusterState currentState ) { RestoreInProgress restoreInProgress = currentState . custom ( RestoreInProgress . TYPE ) ; if ( restoreInProgress ! = null & & ! restoreInProgress . entries ( ) . isEmpty ( ) ) { throw new ConcurrentSnapshotExecutionException ( snapshotId , <str> ) ; } ClusterState . Builder builder = ClusterState . builder ( currentState ) ; MetaData . Builder mdBuilder = MetaData . builder ( currentState . metaData ( ) ) ; ClusterBlocks . Builder blocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) ; RoutingTable . Builder rtBuilder = RoutingTable . builder ( currentState . routingTable ( ) ) ; ImmutableOpenMap < ShardId , RestoreInProgress . ShardRestoreStatus > shards ; Set < String > aliases = new HashSet < > ( ) ; if ( ! renamedIndices . isEmpty ( ) ) { ImmutableOpenMap . Builder < ShardId , RestoreInProgress . ShardRestoreStatus > shardsBuilder = ImmutableOpenMap . builder ( ) ; for ( Map . Entry < String , String > indexEntry : renamedIndices . entrySet ( ) ) { String index = indexEntry . getValue ( ) ; boolean partial = checkPartial ( index ) ; RestoreSource restoreSource = new RestoreSource ( snapshotId , snapshot . version ( ) , index ) ; String renamedIndex = indexEntry . getKey ( ) ; IndexMetaData snapshotIndexMetaData = metaData . index ( index ) ; snapshotIndexMetaData = updateIndexSettings ( snapshotIndexMetaData , request . indexSettings , request . ignoreIndexSettings ) ; try { snapshotIndexMetaData = metaDataIndexUpgradeService . upgradeIndexMetaData ( snapshotIndexMetaData ) ; } catch ( Exception ex ) { throw new SnapshotRestoreException ( snapshotId , <str> + index + <str> , ex ) ; } IndexMetaData currentIndexMetaData = currentState . metaData ( ) . index ( renamedIndex ) ; IntSet ignoreShards = new IntHashSet ( ) ; if ( currentIndexMetaData = = null ) { createIndexService . validateIndexName ( renamedIndex , currentState ) ; createIndexService . validateIndexSettings ( renamedIndex , snapshotIndexMetaData . getSettings ( ) ) ; IndexMetaData . Builder indexMdBuilder = IndexMetaData . builder ( snapshotIndexMetaData ) . state ( IndexMetaData . State . OPEN ) . index ( renamedIndex ) ; indexMdBuilder . settings ( Settings . settingsBuilder ( ) . put ( snapshotIndexMetaData . getSettings ( ) ) . put ( IndexMetaData . SETTING_INDEX_UUID , Strings . randomBase64UUID ( ) ) ) ; if ( ! request . includeAliases ( ) & & ! snapshotIndexMetaData . getAliases ( ) . isEmpty ( ) ) { indexMdBuilder . removeAllAliases ( ) ; } else { for ( ObjectCursor < String > alias : snapshotIndexMetaData . getAliases ( ) . keys ( ) ) { aliases . add ( alias . value ) ; } } IndexMetaData updatedIndexMetaData = indexMdBuilder . build ( ) ; if ( partial ) { populateIgnoredShards ( index , ignoreShards ) ; } rtBuilder . addAsNewRestore ( updatedIndexMetaData , restoreSource , ignoreShards ) ; blocks . addBlocks ( updatedIndexMetaData ) ; mdBuilder . put ( updatedIndexMetaData , true ) ; } else { validateExistingIndex ( currentIndexMetaData , snapshotIndexMetaData , renamedIndex , partial ) ; IndexMetaData . Builder indexMdBuilder = IndexMetaData . builder ( snapshotIndexMetaData ) . state ( IndexMetaData . State . OPEN ) ; indexMdBuilder . version ( Math . max ( snapshotIndexMetaData . getVersion ( ) , currentIndexMetaData . getVersion ( ) + <int> ) ) ; if ( ! request . includeAliases ( ) ) { if ( ! snapshotIndexMetaData . getAliases ( ) . isEmpty ( ) ) { indexMdBuilder . removeAllAliases ( ) ; } for ( ObjectCursor < AliasMetaData > alias : currentIndexMetaData . getAliases ( ) . values ( ) ) { indexMdBuilder . putAlias ( alias . value ) ; } } else { for ( ObjectCursor < String > alias : snapshotIndexMetaData . getAliases ( ) . keys ( ) ) { aliases . add ( alias . value ) ; } } indexMdBuilder . settings ( Settings . settingsBuilder ( ) . put ( snapshotIndexMetaData . getSettings ( ) ) . put ( IndexMetaData . SETTING_INDEX_UUID , currentIndexMetaData . getIndexUUID ( ) ) ) ; IndexMetaData updatedIndexMetaData = indexMdBuilder . index ( renamedIndex ) . build ( ) ; rtBuilder . addAsRestore ( updatedIndexMetaData , restoreSource ) ; blocks . updateBlocks ( updatedIndexMetaData ) ; mdBuilder . put ( updatedIndexMetaData , true ) ; } for ( int shard = <int> ; shard < snapshotIndexMetaData . getNumberOfShards ( ) ; shard + + ) { if ( ! ignoreShards . contains ( shard ) ) { shardsBuilder . put ( new ShardId ( renamedIndex , shard ) , new RestoreInProgress . ShardRestoreStatus ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) ) ) ; } else { shardsBuilder . put ( new ShardId ( renamedIndex , shard ) , new RestoreInProgress . ShardRestoreStatus ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) , RestoreInProgress . State . FAILURE ) ) ; } } } shards = shardsBuilder . build ( ) ; RestoreInProgress . Entry restoreEntry = new RestoreInProgress . Entry ( snapshotId , RestoreInProgress . State . INIT , Collections . unmodifiableList ( new ArrayList < > ( renamedIndices . keySet ( ) ) ) , shards ) ; builder . putCustom ( RestoreInProgress . TYPE , new RestoreInProgress ( restoreEntry ) ) ; } else { shards = ImmutableOpenMap . of ( ) ; } checkAliasNameConflicts ( renamedIndices , aliases ) ; restoreGlobalStateIfRequested ( mdBuilder ) ; if ( completed ( shards ) ) { restoreInfo = new RestoreInfo ( request . name ( ) , Collections . unmodifiableList ( new ArrayList < > ( renamedIndices . keySet ( ) ) ) , shards . size ( ) , shards . size ( ) - failedShards ( shards ) ) ; } RoutingTable rt = rtBuilder . build ( ) ; ClusterState updatedState = builder . metaData ( mdBuilder ) . blocks ( blocks ) . routingTable ( rt ) . build ( ) ; RoutingAllocation . Result routingResult = allocationService . reroute ( ClusterState . builder ( updatedState ) . routingTable ( rt ) . build ( ) , <str> + snapshotId + <str> ) ; return ClusterState . builder ( updatedState ) . routingResult ( routingResult ) . build ( ) ; } private void checkAliasNameConflicts ( Map < String , String > renamedIndices , Set < String > aliases ) { for ( Map . Entry < String , String > renamedIndex : renamedIndices . entrySet ( ) ) { if ( aliases . contains ( renamedIndex . getKey ( ) ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + renamedIndex . getValue ( ) + <str> + renamedIndex . getKey ( ) + <str> ) ; } } } private void populateIgnoredShards ( String index , IntSet ignoreShards ) { for ( SnapshotShardFailure failure : snapshot . shardFailures ( ) ) { if ( index . equals ( failure . index ( ) ) ) { ignoreShards . add ( failure . shardId ( ) ) ; } } } private boolean checkPartial ( String index ) { if ( failed ( snapshot , index ) ) { if ( request . partial ( ) ) { return true ; } else { throw new SnapshotRestoreException ( snapshotId , <str> + index + <str> ) ; } } else { return false ; } } private void validateExistingIndex ( IndexMetaData currentIndexMetaData , IndexMetaData snapshotIndexMetaData , String renamedIndex , boolean partial ) { if ( currentIndexMetaData . getState ( ) ! = IndexMetaData . State . CLOSE ) { throw new SnapshotRestoreException ( snapshotId , <str> + renamedIndex + <str> ) ; } if ( partial ) { throw new SnapshotRestoreException ( snapshotId , <str> + renamedIndex + <str> ) ; } if ( currentIndexMetaData . getNumberOfShards ( ) ! = snapshotIndexMetaData . getNumberOfShards ( ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + renamedIndex + <str> + currentIndexMetaData . getNumberOfShards ( ) + <str> + snapshotIndexMetaData . getNumberOfShards ( ) + <str> ) ; } } private IndexMetaData updateIndexSettings ( IndexMetaData indexMetaData , Settings changeSettings , String [ ] ignoreSettings ) { if ( changeSettings . names ( ) . isEmpty ( ) & & ignoreSettings . length = = <int> ) { return indexMetaData ; } Settings normalizedChangeSettings = Settings . settingsBuilder ( ) . put ( changeSettings ) . normalizePrefix ( IndexMetaData . INDEX_SETTING_PREFIX ) . build ( ) ; IndexMetaData . Builder builder = IndexMetaData . builder ( indexMetaData ) ; Map < String , String > settingsMap = new HashMap < > ( indexMetaData . getSettings ( ) . getAsMap ( ) ) ; List < String > simpleMatchPatterns = new ArrayList < > ( ) ; for ( String ignoredSetting : ignoreSettings ) { if ( ! Regex . isSimpleMatchPattern ( ignoredSetting ) ) { if ( UNREMOVABLE_SETTINGS . contains ( ignoredSetting ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + ignoredSetting + <str> ) ; } else { settingsMap . remove ( ignoredSetting ) ; } } else { simpleMatchPatterns . add ( ignoredSetting ) ; } } if ( ! simpleMatchPatterns . isEmpty ( ) ) { String [ ] removePatterns = simpleMatchPatterns . toArray ( new String [ simpleMatchPatterns . size ( ) ] ) ; Iterator < Map . Entry < String , String > > iterator = settingsMap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , String > entry = iterator . next ( ) ; if ( UNREMOVABLE_SETTINGS . contains ( entry . getKey ( ) ) = = false ) { if ( Regex . simpleMatch ( removePatterns , entry . getKey ( ) ) ) { iterator . remove ( ) ; } } } } for ( Map . Entry < String , String > entry : normalizedChangeSettings . getAsMap ( ) . entrySet ( ) ) { if ( UNMODIFIABLE_SETTINGS . contains ( entry . getKey ( ) ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + entry . getKey ( ) + <str> ) ; } else { settingsMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return builder . settings ( Settings . builder ( ) . put ( settingsMap ) ) . build ( ) ; } private void restoreGlobalStateIfRequested ( MetaData . Builder mdBuilder ) { if ( request . includeGlobalState ( ) ) { if ( metaData . persistentSettings ( ) ! = null ) { boolean changed = false ; Settings . Builder persistentSettings = Settings . settingsBuilder ( ) . put ( ) ; for ( Map . Entry < String , String > entry : metaData . persistentSettings ( ) . getAsMap ( ) . entrySet ( ) ) { if ( dynamicSettings . isDynamicOrLoggingSetting ( entry . getKey ( ) ) ) { String error = dynamicSettings . validateDynamicSetting ( entry . getKey ( ) , entry . getValue ( ) , clusterService . state ( ) ) ; if ( error = = null ) { persistentSettings . put ( entry . getKey ( ) , entry . getValue ( ) ) ; changed = true ; } else { logger . warn ( <str> , entry . getKey ( ) , error ) ; } } else { logger . warn ( <str> , entry . getKey ( ) ) ; } } if ( changed ) { mdBuilder . persistentSettings ( persistentSettings . build ( ) ) ; } } if ( metaData . templates ( ) ! = null ) { for ( ObjectCursor < IndexTemplateMetaData > cursor : metaData . templates ( ) . values ( ) ) { mdBuilder . put ( cursor . value ) ; } } if ( metaData . customs ( ) ! = null ) { for ( ObjectObjectCursor < String , MetaData . Custom > cursor : metaData . customs ( ) ) { if ( ! RepositoriesMetaData . TYPE . equals ( cursor . key ) ) { mdBuilder . putCustom ( cursor . key , cursor . value ) ; } } } } } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , snapshotId ) ; listener . onFailure ( t ) ; } @Override public TimeValue timeout ( ) { return request . masterNodeTimeout ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { listener . onResponse ( restoreInfo ) ; } } ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , request . repository ( ) , request . name ( ) ) ; listener . onFailure ( e ) ; } } public void indexShardRestoreCompleted ( SnapshotId snapshotId , ShardId shardId ) { logger . trace ( <str> , snapshotId , shardId ) ; UpdateIndexShardRestoreStatusRequest request = new UpdateIndexShardRestoreStatusRequest ( snapshotId , shardId , new ShardRestoreStatus ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) , RestoreInProgress . State . SUCCESS ) ) ; transportService . sendRequest ( clusterService . state ( ) . nodes ( ) . masterNode ( ) , UPDATE_RESTORE_ACTION_NAME , request , EmptyTransportResponseHandler . INSTANCE_SAME ) ; } public final static class RestoreCompletionResponse { private final SnapshotId snapshotId ; private final RestoreInfo restoreInfo ; private RestoreCompletionResponse ( SnapshotId snapshotId , RestoreInfo restoreInfo ) { this . snapshotId = snapshotId ; this . restoreInfo = restoreInfo ; } public SnapshotId getSnapshotId ( ) { return snapshotId ; } public RestoreInfo getRestoreInfo ( ) { return restoreInfo ; } } private void updateRestoreStateOnMaster ( final UpdateIndexShardRestoreStatusRequest request ) { logger . trace ( <str> , request ) ; updatedSnapshotStateQueue . add ( request ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { private final List < UpdateIndexShardRestoreStatusRequest > drainedRequests = new ArrayList < > ( ) ; private Map < SnapshotId , Tuple < RestoreInfo , ImmutableOpenMap < ShardId , ShardRestoreStatus > > > batchedRestoreInfo = null ; @Override public ClusterState execute ( ClusterState currentState ) { if ( request . processed ) { return currentState ; } updatedSnapshotStateQueue . drainTo ( drainedRequests ) ; final int batchSize = drainedRequests . size ( ) ; if ( batchSize = = <int> ) { return currentState ; } final RestoreInProgress restore = currentState . custom ( RestoreInProgress . TYPE ) ; if ( restore ! = null ) { int changedCount = <int> ; final List < RestoreInProgress . Entry > entries = new ArrayList < > ( ) ; for ( RestoreInProgress . Entry entry : restore . entries ( ) ) { ImmutableOpenMap . Builder < ShardId , ShardRestoreStatus > shardsBuilder = null ; for ( int i = <int> ; i < batchSize ; i + + ) { final UpdateIndexShardRestoreStatusRequest updateSnapshotState = drainedRequests . get ( i ) ; updateSnapshotState . processed = true ; if ( entry . snapshotId ( ) . equals ( updateSnapshotState . snapshotId ( ) ) ) { logger . trace ( <str> , updateSnapshotState . snapshotId ( ) , updateSnapshotState . shardId ( ) , updateSnapshotState . status ( ) . state ( ) ) ; if ( shardsBuilder = = null ) { shardsBuilder = ImmutableOpenMap . builder ( entry . shards ( ) ) ; } shardsBuilder . put ( updateSnapshotState . shardId ( ) , updateSnapshotState . status ( ) ) ; changedCount + + ; } } if ( shardsBuilder ! = null ) { ImmutableOpenMap < ShardId , ShardRestoreStatus > shards = shardsBuilder . build ( ) ; if ( ! completed ( shards ) ) { entries . add ( new RestoreInProgress . Entry ( entry . snapshotId ( ) , RestoreInProgress . State . STARTED , entry . indices ( ) , shards ) ) ; } else { logger . info ( <str> , entry . snapshotId ( ) ) ; if ( batchedRestoreInfo = = null ) { batchedRestoreInfo = new HashMap < > ( ) ; } assert ! batchedRestoreInfo . containsKey ( entry . snapshotId ( ) ) ; batchedRestoreInfo . put ( entry . snapshotId ( ) , new Tuple < > ( new RestoreInfo ( entry . snapshotId ( ) . getSnapshot ( ) , entry . indices ( ) , shards . size ( ) , shards . size ( ) - failedShards ( shards ) ) , shards ) ) ; } } else { entries . add ( entry ) ; } } if ( changedCount > <int> ) { logger . trace ( <str> , changedCount ) ; final RestoreInProgress updatedRestore = new RestoreInProgress ( entries . toArray ( new RestoreInProgress . Entry [ entries . size ( ) ] ) ) ; return ClusterState . builder ( currentState ) . putCustom ( RestoreInProgress . TYPE , updatedRestore ) . build ( ) ; } } return currentState ; } @Override public void onFailure ( String source , @Nullable Throwable t ) { for ( UpdateIndexShardRestoreStatusRequest request : drainedRequests ) { logger . warn ( <str> , t , request . snapshotId ( ) , request . shardId ( ) , request . status ( ) ) ; } } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { if ( batchedRestoreInfo ! = null ) { for ( final Entry < SnapshotId , Tuple < RestoreInfo , ImmutableOpenMap < ShardId , ShardRestoreStatus > > > entry : batchedRestoreInfo . entrySet ( ) ) { final SnapshotId snapshotId = entry . getKey ( ) ; final RestoreInfo restoreInfo = entry . getValue ( ) . v1 ( ) ; final ImmutableOpenMap < ShardId , ShardRestoreStatus > shards = entry . getValue ( ) . v2 ( ) ; RoutingTable routingTable = newState . getRoutingTable ( ) ; final List < ShardId > waitForStarted = new ArrayList < > ( ) ; for ( ObjectObjectCursor < ShardId , ShardRestoreStatus > shard : shards ) { if ( shard . value . state ( ) = = RestoreInProgress . State . SUCCESS ) { ShardId shardId = shard . key ; ShardRouting shardRouting = findPrimaryShard ( routingTable , shardId ) ; if ( shardRouting ! = null & & ! shardRouting . active ( ) ) { logger . trace ( <str> , snapshotId , shardId ) ; waitForStarted . add ( shardId ) ; } } } if ( waitForStarted . isEmpty ( ) ) { notifyListeners ( snapshotId , restoreInfo ) ; } else { clusterService . addLast ( new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . routingTableChanged ( ) ) { RoutingTable routingTable = event . state ( ) . getRoutingTable ( ) ; for ( Iterator < ShardId > iterator = waitForStarted . iterator ( ) ; iterator . hasNext ( ) ; ) { ShardId shardId = iterator . next ( ) ; ShardRouting shardRouting = findPrimaryShard ( routingTable , shardId ) ; if ( shardRouting = = null | | shardRouting . active ( ) ) { iterator . remove ( ) ; logger . trace ( <str> , snapshotId , shardId ) ; } } } if ( waitForStarted . isEmpty ( ) ) { notifyListeners ( snapshotId , restoreInfo ) ; clusterService . remove ( this ) ; } } } ) ; } } } } private ShardRouting findPrimaryShard ( RoutingTable routingTable , ShardId shardId ) { IndexRoutingTable indexRoutingTable = routingTable . index ( shardId . getIndex ( ) ) ; if ( indexRoutingTable ! = null ) { IndexShardRoutingTable indexShardRoutingTable = indexRoutingTable . shard ( shardId . id ( ) ) ; if ( indexShardRoutingTable ! = null ) { return indexShardRoutingTable . primaryShard ( ) ; } } return null ; } private void notifyListeners ( SnapshotId snapshotId , RestoreInfo restoreInfo ) { for ( ActionListener < RestoreCompletionResponse > listener : listeners ) { try { listener . onResponse ( new RestoreCompletionResponse ( snapshotId , restoreInfo ) ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , listener ) ; } } } } ) ; } private boolean completed ( ImmutableOpenMap < ShardId , RestoreInProgress . ShardRestoreStatus > shards ) { for ( ObjectCursor < RestoreInProgress . ShardRestoreStatus > status : shards . values ( ) ) { if ( ! status . value . state ( ) . completed ( ) ) { return false ; } } return true ; } private int failedShards ( ImmutableOpenMap < ShardId , RestoreInProgress . ShardRestoreStatus > shards ) { int failedShards = <int> ; for ( ObjectCursor < RestoreInProgress . ShardRestoreStatus > status : shards . values ( ) ) { if ( status . value . state ( ) = = RestoreInProgress . State . FAILURE ) { failedShards + + ; } } return failedShards ; } private Map < String , String > renamedIndices ( RestoreRequest request , List < String > filteredIndices ) { Map < String , String > renamedIndices = new HashMap < > ( ) ; for ( String index : filteredIndices ) { String renamedIndex = index ; if ( request . renameReplacement ( ) ! = null & & request . renamePattern ( ) ! = null ) { renamedIndex = index . replaceAll ( request . renamePattern ( ) , request . renameReplacement ( ) ) ; } String previousIndex = renamedIndices . put ( renamedIndex , index ) ; if ( previousIndex ! = null ) { throw new SnapshotRestoreException ( new SnapshotId ( request . repository ( ) , request . name ( ) ) , <str> + index + <str> + previousIndex + <str> + renamedIndex + <str> ) ; } } return renamedIndices ; } private void validateSnapshotRestorable ( SnapshotId snapshotId , Snapshot snapshot ) { if ( ! snapshot . state ( ) . restorable ( ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + snapshot . state ( ) + <str> ) ; } if ( Version . CURRENT . before ( snapshot . version ( ) ) ) { throw new SnapshotRestoreException ( snapshotId , <str> + snapshot . version ( ) + <str> + Version . CURRENT + <str> ) ; } } private void processDeletedIndices ( ClusterChangedEvent event ) { RestoreInProgress restore = event . state ( ) . custom ( RestoreInProgress . TYPE ) ; if ( restore = = null ) { return ; } if ( ! event . indicesDeleted ( ) . isEmpty ( ) ) { for ( RestoreInProgress . Entry entry : restore . entries ( ) ) { List < ShardId > shardsToFail = null ; for ( ObjectObjectCursor < ShardId , ShardRestoreStatus > shard : entry . shards ( ) ) { if ( ! shard . value . state ( ) . completed ( ) ) { if ( ! event . state ( ) . metaData ( ) . hasIndex ( shard . key . getIndex ( ) ) ) { if ( shardsToFail = = null ) { shardsToFail = new ArrayList < > ( ) ; } shardsToFail . add ( shard . key ) ; } } } if ( shardsToFail ! = null ) { for ( ShardId shardId : shardsToFail ) { logger . trace ( <str> , entry . snapshotId ( ) , shardId ) ; updateRestoreStateOnMaster ( new UpdateIndexShardRestoreStatusRequest ( entry . snapshotId ( ) , shardId , new ShardRestoreStatus ( null , RestoreInProgress . State . FAILURE , <str> ) ) ) ; } } } } } public void failRestore ( SnapshotId snapshotId , ShardId shardId ) { logger . debug ( <str> , snapshotId , shardId ) ; UpdateIndexShardRestoreStatusRequest request = new UpdateIndexShardRestoreStatusRequest ( snapshotId , shardId , new ShardRestoreStatus ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) , RestoreInProgress . State . FAILURE ) ) ; transportService . sendRequest ( clusterService . state ( ) . nodes ( ) . masterNode ( ) , UPDATE_RESTORE_ACTION_NAME , request , EmptyTransportResponseHandler . INSTANCE_SAME ) ; } private boolean failed ( Snapshot snapshot , String index ) { for ( SnapshotShardFailure failure : snapshot . shardFailures ( ) ) { if ( index . equals ( failure . index ( ) ) ) { return true ; } } return false ; } public void addListener ( ActionListener < RestoreCompletionResponse > listener ) { this . listeners . add ( listener ) ; } public void removeListener ( ActionListener < RestoreCompletionResponse > listener ) { this . listeners . remove ( listener ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { try { if ( event . localNodeMaster ( ) ) { processDeletedIndices ( event ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } public static boolean isRepositoryInUse ( ClusterState clusterState , String repository ) { RestoreInProgress snapshots = clusterState . custom ( RestoreInProgress . TYPE ) ; if ( snapshots ! = null ) { for ( RestoreInProgress . Entry snapshot : snapshots . entries ( ) ) { if ( repository . equals ( snapshot . snapshotId ( ) . getRepository ( ) ) ) { return true ; } } } return false ; } public static class RestoreRequest { final private String cause ; final private String name ; final private String repository ; final private String [ ] indices ; final private String renamePattern ; final private String renameReplacement ; final private IndicesOptions indicesOptions ; final private Settings settings ; final private TimeValue masterNodeTimeout ; final private boolean includeGlobalState ; final private boolean partial ; final private boolean includeAliases ; final private Settings indexSettings ; final private String [ ] ignoreIndexSettings ; public RestoreRequest ( String cause , String repository , String name , String [ ] indices , IndicesOptions indicesOptions , String renamePattern , String renameReplacement , Settings settings , TimeValue masterNodeTimeout , boolean includeGlobalState , boolean partial , boolean includeAliases , Settings indexSettings , String [ ] ignoreIndexSettings ) { this . cause = cause ; this . name = name ; this . repository = repository ; this . indices = indices ; this . renamePattern = renamePattern ; this . renameReplacement = renameReplacement ; this . indicesOptions = indicesOptions ; this . settings = settings ; this . masterNodeTimeout = masterNodeTimeout ; this . includeGlobalState = includeGlobalState ; this . partial = partial ; this . includeAliases = includeAliases ; this . indexSettings = indexSettings ; this . ignoreIndexSettings = ignoreIndexSettings ; } public String cause ( ) { return cause ; } public String name ( ) { return name ; } public String repository ( ) { return repository ; } public String [ ] indices ( ) { return indices ; } public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public String renamePattern ( ) { return renamePattern ; } public String renameReplacement ( ) { return renameReplacement ; } public Settings settings ( ) { return settings ; } public boolean includeGlobalState ( ) { return includeGlobalState ; } public boolean partial ( ) { return partial ; } public boolean includeAliases ( ) { return includeAliases ; } public Settings indexSettings ( ) { return indexSettings ; } public String [ ] ignoreIndexSettings ( ) { return ignoreIndexSettings ; } public TimeValue masterNodeTimeout ( ) { return masterNodeTimeout ; } } public static class UpdateIndexShardRestoreStatusRequest extends TransportRequest { private SnapshotId snapshotId ; private ShardId shardId ; private ShardRestoreStatus status ; volatile boolean processed ; public UpdateIndexShardRestoreStatusRequest ( ) { } private UpdateIndexShardRestoreStatusRequest ( SnapshotId snapshotId , ShardId shardId , ShardRestoreStatus status ) { this . snapshotId = snapshotId ; this . shardId = shardId ; this . status = status ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; snapshotId = SnapshotId . readSnapshotId ( in ) ; shardId = ShardId . readShardId ( in ) ; status = ShardRestoreStatus . readShardRestoreStatus ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; snapshotId . writeTo ( out ) ; shardId . writeTo ( out ) ; status . writeTo ( out ) ; } public SnapshotId snapshotId ( ) { return snapshotId ; } public ShardId shardId ( ) { return shardId ; } public ShardRestoreStatus status ( ) { return status ; } @Override public String toString ( ) { return <str> + snapshotId + <str> + shardId + <str> + status . state ( ) + <str> ; } } class UpdateRestoreStateRequestHandler implements TransportRequestHandler < UpdateIndexShardRestoreStatusRequest > { @Override public void messageReceived ( UpdateIndexShardRestoreStatusRequest request , final TransportChannel channel ) throws Exception { updateRestoreStateOnMaster ( request ) ; channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } } 
