package org . gradle . api . plugins . buildcomparison . gradle . internal ; import org . gradle . api . plugins . buildcomparison . gradle . GradleBuildInvocationSpec ; import org . gradle . tooling . BuildLauncher ; import org . gradle . tooling . ModelBuilder ; import org . gradle . tooling . ProjectConnection ; import org . gradle . tooling . model . internal . outcomes . ProjectOutcomes ; import org . gradle . util . GradleVersion ; import java . util . ArrayList ; import java . util . List ; public class ComparableGradleBuildExecuter { public static final GradleVersion PROJECT_OUTCOMES_MINIMUM_VERSION = GradleVersion . version ( <str> ) ; public static final GradleVersion EXEC_MINIMUM_VERSION = GradleVersion . version ( <str> ) ; private final GradleBuildInvocationSpec spec ; public ComparableGradleBuildExecuter ( GradleBuildInvocationSpec spec ) { this . spec = spec ; } public GradleBuildInvocationSpec getSpec ( ) { return spec ; } public boolean isExecutable ( ) { return getGradleVersion ( ) . compareTo ( EXEC_MINIMUM_VERSION ) > = <int> ; } public GradleVersion getGradleVersion ( ) { return GradleVersion . version ( getSpec ( ) . getGradleVersion ( ) ) ; } public boolean isCanObtainProjectOutcomesModel ( ) { GradleVersion version = getGradleVersion ( ) ; boolean isMinimumVersionOrHigher = version . compareTo ( PROJECT_OUTCOMES_MINIMUM_VERSION ) > = <int> ; if ( isMinimumVersionOrHigher ) { return true ; } else { return version . getBaseVersion ( ) . equals ( PROJECT_OUTCOMES_MINIMUM_VERSION ) ; } } private List < String > getImpliedArguments ( ) { List < String > rawArgs = getSpec ( ) . getArguments ( ) ; if ( rawArgs . contains ( <str> ) | | rawArgs . contains ( <str> ) ) { return rawArgs ; } else { List < String > ammendedArgs = new ArrayList < String > ( rawArgs . size ( ) + <int> ) ; ammendedArgs . add ( <str> ) ; ammendedArgs . addAll ( rawArgs ) ; return ammendedArgs ; } } public ProjectOutcomes executeWith ( ProjectConnection connection ) { List < String > tasksList = getSpec ( ) . getTasks ( ) ; String [ ] tasks = tasksList . toArray ( new String [ tasksList . size ( ) ] ) ; List < String > argumentsList = getImpliedArguments ( ) ; String [ ] arguments = argumentsList . toArray ( new String [ argumentsList . size ( ) ] ) ; if ( isCanObtainProjectOutcomesModel ( ) ) { ModelBuilder < ProjectOutcomes > modelBuilder = connection . model ( ProjectOutcomes . class ) ; return modelBuilder . withArguments ( arguments ) . forTasks ( tasks ) . get ( ) ; } else { BuildLauncher buildLauncher = connection . newBuild ( ) ; buildLauncher . withArguments ( arguments ) . forTasks ( tasks ) . run ( ) ; return null ; } } } 
