package org . elasticsearch . index . query ; import com . spatial4j . core . shape . Point ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapper ; import org . elasticsearch . index . query . GeohashCellQuery . Builder ; import org . elasticsearch . test . geo . RandomShapeGenerator ; import java . io . IOException ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; public class GeohashCellQueryBuilderTests extends AbstractQueryTestCase < Builder > { @Override protected Builder doCreateTestQueryBuilder ( ) { GeohashCellQuery . Builder builder = new Builder ( GEO_POINT_FIELD_NAME , randomGeohash ( <int> , <int> ) ) ; if ( randomBoolean ( ) ) { builder . neighbors ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { builder . precision ( randomIntBetween ( <int> , <int> ) ) ; } else { builder . precision ( randomIntBetween ( <int> , <int> ) + randomFrom ( DistanceUnit . values ( ) ) . toString ( ) ) ; } } return builder ; } @Override protected void doAssertLuceneQuery ( Builder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( queryBuilder . neighbors ( ) ) { assertThat ( query , instanceOf ( TermsQuery . class ) ) ; } else { assertThat ( query , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) query ; Term term = termQuery . getTerm ( ) ; assertThat ( term . field ( ) , equalTo ( queryBuilder . fieldName ( ) + GeoPointFieldMapper . Names . GEOHASH_SUFFIX ) ) ; String geohash = queryBuilder . geohash ( ) ; if ( queryBuilder . precision ( ) ! = null ) { int len = Math . min ( queryBuilder . precision ( ) , geohash . length ( ) ) ; geohash = geohash . substring ( <int> , len ) ; } assertThat ( term . text ( ) , equalTo ( geohash ) ) ; } } @Override public void testToQuery ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; super . testToQuery ( ) ; } public void testNullField ( ) { try { if ( randomBoolean ( ) ) { new Builder ( null , new GeoPoint ( ) ) ; } else { new Builder ( <str> , new GeoPoint ( ) ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testNullGeoPoint ( ) { try { if ( randomBoolean ( ) ) { new Builder ( GEO_POINT_FIELD_NAME , ( GeoPoint ) null ) ; } else { new Builder ( GEO_POINT_FIELD_NAME , <str> ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidPrecision ( ) { GeohashCellQuery . Builder builder = new Builder ( GEO_POINT_FIELD_NAME , new GeoPoint ( ) ) ; try { builder . precision ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testLocationParsing ( ) throws IOException { Point point = RandomShapeGenerator . xRandomPoint ( getRandom ( ) ) ; Builder pointTestBuilder = new GeohashCellQuery . Builder ( <str> , new GeoPoint ( point . getY ( ) , point . getX ( ) ) ) ; String pointTest1 = <str> + point . getY ( ) + <str> + point . getX ( ) + <str> ; assertParsedQuery ( pointTest1 , pointTestBuilder ) ; String pointTest2 = <str> + point . getY ( ) + <str> + point . getX ( ) + <str> ; assertParsedQuery ( pointTest2 , pointTestBuilder ) ; String pointTest3 = <str> + point . getX ( ) + <str> + point . getY ( ) + <str> ; assertParsedQuery ( pointTest3 , pointTestBuilder ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; GeohashCellQuery . Builder parsed = ( GeohashCellQuery . Builder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <int> , parsed . precision ( ) . intValue ( ) ) ; } } 
