package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . zip . CRC32 ; import org . apache . cassandra . io . util . ChannelProxy ; import org . apache . cassandra . io . util . FileMark ; import org . apache . cassandra . io . util . RandomAccessReader ; public final class ChecksummedDataInput extends RandomAccessReader . RandomAccessReaderWithOwnChannel { private final CRC32 crc ; private int crcPosition ; private boolean crcUpdateDisabled ; private long limit ; private FileMark limitMark ; private ChecksummedDataInput ( Builder builder ) { super ( builder ) ; crc = new CRC32 ( ) ; crcPosition = <int> ; crcUpdateDisabled = false ; resetLimit ( ) ; } @SuppressWarnings ( <str> ) public static ChecksummedDataInput open ( File file ) { return new Builder ( new ChannelProxy ( file ) ) . build ( ) ; } public void resetCrc ( ) { crc . reset ( ) ; crcPosition = buffer . position ( ) ; } public void limit ( long newLimit ) { limit = newLimit ; limitMark = mark ( ) ; } public void resetLimit ( ) { limit = Long . MAX_VALUE ; limitMark = null ; } public void checkLimit ( int length ) throws IOException { if ( limitMark = = null ) return ; if ( ( bytesPastLimit ( ) + length ) > limit ) throw new IOException ( <str> ) ; } public long bytesPastLimit ( ) { assert limitMark ! = null ; return bytesPastMark ( limitMark ) ; } public boolean checkCrc ( ) throws IOException { try { updateCrc ( ) ; crcUpdateDisabled = true ; return ( ( int ) crc . getValue ( ) ) = = readInt ( ) ; } finally { crcPosition = buffer . position ( ) ; crcUpdateDisabled = false ; } } @Override public void readFully ( byte [ ] b ) throws IOException { checkLimit ( b . length ) ; super . readFully ( b ) ; } @Override public int read ( byte [ ] b , int off , int len ) throws IOException { checkLimit ( len ) ; return super . read ( b , off , len ) ; } @Override public void reBuffer ( ) { updateCrc ( ) ; super . reBuffer ( ) ; crcPosition = buffer . position ( ) ; } private void updateCrc ( ) { if ( crcPosition = = buffer . position ( ) | | crcUpdateDisabled ) return ; assert crcPosition > = <int> & & crcPosition < buffer . position ( ) ; ByteBuffer unprocessed = buffer . duplicate ( ) ; unprocessed . position ( crcPosition ) . limit ( buffer . position ( ) ) ; crc . update ( unprocessed ) ; } public final static class Builder extends RandomAccessReader . Builder { public Builder ( ChannelProxy channel ) { super ( channel ) ; } public ChecksummedDataInput build ( ) { return new ChecksummedDataInput ( this ) ; } } } 
