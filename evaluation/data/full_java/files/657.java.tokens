package org . apache . cassandra . index . internal . composites ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . CompositeType ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . IndexEntry ; import org . apache . cassandra . schema . IndexMetadata ; public class PartitionKeyIndex extends CassandraIndex { public PartitionKeyIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexDef ) { super ( baseCfs , indexDef ) ; } public ByteBuffer getIndexedValue ( ByteBuffer partitionKey , Clustering clustering , CellPath path , ByteBuffer cellValue ) { CompositeType keyComparator = ( CompositeType ) baseCfs . metadata . getKeyValidator ( ) ; ByteBuffer [ ] components = keyComparator . split ( partitionKey ) ; return components [ indexedColumn . position ( ) ] ; } public CBuilder buildIndexClusteringPrefix ( ByteBuffer partitionKey , ClusteringPrefix prefix , CellPath path ) { CBuilder builder = CBuilder . create ( getIndexComparator ( ) ) ; builder . add ( partitionKey ) ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) builder . add ( prefix . get ( i ) ) ; return builder ; } public IndexEntry decodeEntry ( DecoratedKey indexedValue , Row indexEntry ) { int ckCount = baseCfs . metadata . clusteringColumns ( ) . size ( ) ; Clustering clustering = indexEntry . clustering ( ) ; CBuilder builder = CBuilder . create ( baseCfs . getComparator ( ) ) ; for ( int i = <int> ; i < ckCount ; i + + ) builder . add ( clustering . get ( i + <int> ) ) ; return new IndexEntry ( indexedValue , clustering , indexEntry . primaryKeyLivenessInfo ( ) . timestamp ( ) , clustering . get ( <int> ) , builder . build ( ) ) ; } public boolean isStale ( Row data , ByteBuffer indexValue , int nowInSec ) { return ! data . hasLiveData ( nowInSec ) ; } } 
