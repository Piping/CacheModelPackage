package com . google . common . hash ; import static com . google . common . io . BaseEncoding . base16 ; import com . google . common . base . Charsets ; import com . google . common . collect . ImmutableList ; import com . google . common . io . BaseEncoding ; import com . google . common . testing . ClassSanityTester ; import junit . framework . TestCase ; import java . util . Arrays ; public class HashCodeTest extends TestCase { private static final ImmutableList < ExpectedHashCode > expectedHashCodes = ImmutableList . of ( new ExpectedHashCode ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , <hex> , <hex> , <str> ) , new ExpectedHashCode ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , <hex> , <hex> , <str> ) , new ExpectedHashCode ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , <hex> , null , <str> ) , new ExpectedHashCode ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , <hex> , null , <str> ) , new ExpectedHashCode ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , <hex> , <hex> , <str> ) ) ; public void testFromInt ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { if ( expected . bytes . length = = <int> ) { HashCode fromInt = HashCode . fromInt ( expected . asInt ) ; assertExpectedHashCode ( expected , fromInt ) ; } } } public void testFromLong ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { if ( expected . bytes . length = = <int> ) { HashCode fromLong = HashCode . fromLong ( expected . asLong ) ; assertExpectedHashCode ( expected , fromLong ) ; } } } public void testFromBytes ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { HashCode fromBytes = HashCode . fromBytes ( expected . bytes ) ; assertExpectedHashCode ( expected , fromBytes ) ; } } public void testFromBytes_copyOccurs ( ) { byte [ ] bytes = new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; HashCode hashCode = HashCode . fromBytes ( bytes ) ; int expectedInt = <hex> ; String expectedToString = <str> ; assertEquals ( expectedInt , hashCode . asInt ( ) ) ; assertEquals ( expectedToString , hashCode . toString ( ) ) ; bytes [ <int> ] = ( byte ) <hex> ; assertEquals ( expectedInt , hashCode . asInt ( ) ) ; assertEquals ( expectedToString , hashCode . toString ( ) ) ; } public void testFromBytesNoCopy_noCopyOccurs ( ) { byte [ ] bytes = new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; HashCode hashCode = HashCode . fromBytesNoCopy ( bytes ) ; assertEquals ( <hex> , hashCode . asInt ( ) ) ; assertEquals ( <str> , hashCode . toString ( ) ) ; bytes [ <int> ] = ( byte ) <hex> ; assertEquals ( <hex> , hashCode . asInt ( ) ) ; assertEquals ( <str> , hashCode . toString ( ) ) ; } public void testGetBytesInternal_noCloneOccurs ( ) { byte [ ] bytes = new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; HashCode hashCode = HashCode . fromBytes ( bytes ) ; assertEquals ( <hex> , hashCode . asInt ( ) ) ; assertEquals ( <str> , hashCode . toString ( ) ) ; hashCode . getBytesInternal ( ) [ <int> ] = ( byte ) <hex> ; assertEquals ( <hex> , hashCode . asInt ( ) ) ; assertEquals ( <str> , hashCode . toString ( ) ) ; } public void testPadToLong ( ) { assertEquals ( <hex> , HashCode . fromLong ( <hex> ) . padToLong ( ) ) ; assertEquals ( <hex> , HashCode . fromLong ( <hex> ) . padToLong ( ) ) ; assertEquals ( <hex> , HashCode . fromInt ( <hex> ) . padToLong ( ) ) ; assertEquals ( <hex> , HashCode . fromInt ( <hex> ) . padToLong ( ) ) ; } public void testPadToLongWith4Bytes ( ) { assertEquals ( <hex> , HashCode . fromBytesNoCopy ( byteArrayWith9s ( <int> ) ) . padToLong ( ) ) ; } public void testPadToLongWith6Bytes ( ) { assertEquals ( <hex> , HashCode . fromBytesNoCopy ( byteArrayWith9s ( <int> ) ) . padToLong ( ) ) ; } public void testPadToLongWith8Bytes ( ) { assertEquals ( <hex> , HashCode . fromBytesNoCopy ( byteArrayWith9s ( <int> ) ) . padToLong ( ) ) ; } private static byte [ ] byteArrayWith9s ( int size ) { byte [ ] bytez = new byte [ size ] ; Arrays . fill ( bytez , ( byte ) <hex> ) ; return bytez ; } public void testToString ( ) { byte [ ] data = new byte [ ] { <int> , - <int> , <int> , - <int> , <int> } ; assertEquals ( <str> , HashCode . fromBytes ( data ) . toString ( ) ) ; assertEquals ( <str> , base16 ( ) . lowerCase ( ) . encode ( data ) ) ; } public void testHashCode_nulls ( ) throws Exception { sanityTester ( ) . testNulls ( ) ; } public void testHashCode_equalsAndSerializable ( ) throws Exception { sanityTester ( ) . testEqualsAndSerializable ( ) ; } public void testRoundTripHashCodeUsingBaseEncoding ( ) { HashCode hash1 = Hashing . sha1 ( ) . hashString ( <str> , Charsets . US_ASCII ) ; HashCode hash2 = HashCode . fromBytes ( BaseEncoding . base16 ( ) . lowerCase ( ) . decode ( hash1 . toString ( ) ) ) ; assertEquals ( hash1 , hash2 ) ; } public void testObjectHashCode ( ) { HashCode hashCode42 = HashCode . fromInt ( <int> ) ; assertEquals ( <int> , hashCode42 . hashCode ( ) ) ; } public void testObjectHashCodeWithSameLowOrderBytes ( ) { byte [ ] bytesA = new byte [ <int> ] ; byte [ ] bytesB = new byte [ <int> ] ; bytesA [ <int> ] = ( byte ) <hex> ; bytesB [ <int> ] = ( byte ) <hex> ; HashCode hashCodeA = HashCode . fromBytes ( bytesA ) ; HashCode hashCodeB = HashCode . fromBytes ( bytesB ) ; assertFalse ( hashCodeA . equals ( hashCodeB ) ) ; assertEquals ( hashCodeA . hashCode ( ) , hashCodeB . hashCode ( ) ) ; } public void testRoundTripHashCodeUsingFromString ( ) { HashCode hash1 = Hashing . sha1 ( ) . hashString ( <str> , Charsets . US_ASCII ) ; HashCode hash2 = HashCode . fromString ( hash1 . toString ( ) ) ; assertEquals ( hash1 , hash2 ) ; } public void testRoundTrip ( ) { for ( ExpectedHashCode expected : expectedHashCodes ) { String string = HashCode . fromBytes ( expected . bytes ) . toString ( ) ; assertEquals ( expected . toString , string ) ; assertEquals ( expected . toString , HashCode . fromBytes ( BaseEncoding . base16 ( ) . lowerCase ( ) . decode ( string ) ) . toString ( ) ) ; } } @SuppressWarnings ( <str> ) public void testFromStringFailsWithInvalidHexChar ( ) { try { HashCode . fromString ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testFromStringFailsWithUpperCaseString ( ) { String string = Hashing . sha1 ( ) . hashString ( <str> , Charsets . US_ASCII ) . toString ( ) . toUpperCase ( ) ; try { HashCode . fromString ( string ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testFromStringFailsWithShortInputs ( ) { try { HashCode . fromString ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { HashCode . fromString ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } HashCode . fromString ( <str> ) ; } @SuppressWarnings ( <str> ) public void testFromStringFailsWithOddLengthInput ( ) { try { HashCode . fromString ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testIntWriteBytesTo ( ) { byte [ ] dest = new byte [ <int> ] ; HashCode . fromInt ( <int> ) . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( HashCode . fromInt ( <int> ) . asBytes ( ) , dest ) ) ; } public void testLongWriteBytesTo ( ) { byte [ ] dest = new byte [ <int> ] ; HashCode . fromLong ( <int> ) . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( HashCode . fromLong ( <int> ) . asBytes ( ) , dest ) ) ; } private static final HashCode HASH_ABCD = HashCode . fromBytes ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ) ; public void testWriteBytesTo ( ) { byte [ ] dest = new byte [ <int> ] ; HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , dest ) ) ; } public void testWriteBytesToOversizedArray ( ) { byte [ ] dest = new byte [ <int> ] ; HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , dest ) ) ; } public void testWriteBytesToOversizedArrayLongMaxLength ( ) { byte [ ] dest = new byte [ <int> ] ; HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , dest ) ) ; } public void testWriteBytesToOversizedArrayShortMaxLength ( ) { byte [ ] dest = new byte [ <int> ] ; HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , dest ) ) ; } public void testWriteBytesToUndersizedArray ( ) { byte [ ] dest = new byte [ <int> ] ; try { HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } public void testWriteBytesToUndersizedArrayLongMaxLength ( ) { byte [ ] dest = new byte [ <int> ] ; try { HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } public void testWriteBytesToUndersizedArrayShortMaxLength ( ) { byte [ ] dest = new byte [ <int> ] ; HASH_ABCD . writeBytesTo ( dest , <int> , <int> ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , dest ) ) ; } private static ClassSanityTester . FactoryMethodReturnValueTester sanityTester ( ) { return new ClassSanityTester ( ) . setDefault ( byte [ ] . class , new byte [ ] { <int> , <int> , <int> , <int> } ) . setDistinctValues ( byte [ ] . class , new byte [ ] { <int> , <int> , <int> , <int> } , new byte [ ] { <int> , <int> , <int> , <int> } ) . setDistinctValues ( String . class , <str> , <str> ) . forAllPublicStaticMethods ( HashCode . class ) ; } @SuppressWarnings ( <str> ) private static void assertExpectedHashCode ( ExpectedHashCode expectedHashCode , HashCode hash ) { assertTrue ( Arrays . equals ( expectedHashCode . bytes , hash . asBytes ( ) ) ) ; byte [ ] bb = new byte [ hash . bits ( ) / <int> ] ; hash . writeBytesTo ( bb , <int> , bb . length ) ; assertTrue ( Arrays . equals ( expectedHashCode . bytes , bb ) ) ; assertEquals ( expectedHashCode . asInt , hash . asInt ( ) ) ; if ( expectedHashCode . asLong = = null ) { try { hash . asLong ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } else { assertEquals ( expectedHashCode . asLong . longValue ( ) , hash . asLong ( ) ) ; } assertEquals ( expectedHashCode . toString , hash . toString ( ) ) ; assertSideEffectFree ( hash ) ; assertReadableBytes ( hash ) ; } private static void assertSideEffectFree ( HashCode hash ) { byte [ ] original = hash . asBytes ( ) ; byte [ ] mutated = hash . asBytes ( ) ; mutated [ <int> ] + + ; assertTrue ( Arrays . equals ( original , hash . asBytes ( ) ) ) ; } private static void assertReadableBytes ( HashCode hashCode ) { assertTrue ( hashCode . bits ( ) > = <int> ) ; byte [ ] hashBytes = hashCode . asBytes ( ) ; int totalBytes = hashCode . bits ( ) / <int> ; for ( int bytes = <int> ; bytes < totalBytes ; bytes + + ) { byte [ ] bb = new byte [ bytes ] ; hashCode . writeBytesTo ( bb , <int> , bb . length ) ; assertTrue ( Arrays . equals ( Arrays . copyOf ( hashBytes , bytes ) , bb ) ) ; } } private static class ExpectedHashCode { final byte [ ] bytes ; final int asInt ; final Long asLong ; final String toString ; ExpectedHashCode ( byte [ ] bytes , int asInt , Long asLong , String toString ) { this . bytes = bytes ; this . asInt = asInt ; this . asLong = asLong ; this . toString = toString ; } } } 
