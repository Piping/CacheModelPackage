package org . elasticsearch . threadpool ; import org . apache . lucene . util . Counter ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . settings . Validator ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsException ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsAbortPolicy ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . util . concurrent . EsThreadPoolExecutor ; import org . elasticsearch . common . util . concurrent . XRejectedExecutionHandler ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . * ; import java . util . function . Function ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . unit . SizeValue . parseSizeValue ; import static org . elasticsearch . common . unit . TimeValue . timeValueMinutes ; public class ThreadPool extends AbstractComponent { public static class Names { public static final String SAME = <str> ; public static final String GENERIC = <str> ; public static final String LISTENER = <str> ; public static final String GET = <str> ; public static final String INDEX = <str> ; public static final String BULK = <str> ; public static final String SEARCH = <str> ; public static final String SUGGEST = <str> ; public static final String PERCOLATE = <str> ; public static final String MANAGEMENT = <str> ; public static final String FLUSH = <str> ; public static final String REFRESH = <str> ; public static final String WARMER = <str> ; public static final String SNAPSHOT = <str> ; public static final String FORCE_MERGE = <str> ; public static final String FETCH_SHARD_STARTED = <str> ; public static final String FETCH_SHARD_STORE = <str> ; } public enum ThreadPoolType { CACHED ( <str> ) , DIRECT ( <str> ) , FIXED ( <str> ) , SCALING ( <str> ) ; private final String type ; public String getType ( ) { return type ; } ThreadPoolType ( String type ) { this . type = type ; } private final static Map < String , ThreadPoolType > TYPE_MAP ; static { Map < String , ThreadPoolType > typeMap = new HashMap < > ( ) ; for ( ThreadPoolType threadPoolType : ThreadPoolType . values ( ) ) { typeMap . put ( threadPoolType . getType ( ) , threadPoolType ) ; } TYPE_MAP = Collections . unmodifiableMap ( typeMap ) ; } public static ThreadPoolType fromType ( String type ) { ThreadPoolType threadPoolType = TYPE_MAP . get ( type ) ; if ( threadPoolType = = null ) { throw new IllegalArgumentException ( <str> + type ) ; } return threadPoolType ; } } public static Map < String , ThreadPoolType > THREAD_POOL_TYPES ; static { HashMap < String , ThreadPoolType > map = new HashMap < > ( ) ; map . put ( Names . SAME , ThreadPoolType . DIRECT ) ; map . put ( Names . GENERIC , ThreadPoolType . CACHED ) ; map . put ( Names . LISTENER , ThreadPoolType . FIXED ) ; map . put ( Names . GET , ThreadPoolType . FIXED ) ; map . put ( Names . INDEX , ThreadPoolType . FIXED ) ; map . put ( Names . BULK , ThreadPoolType . FIXED ) ; map . put ( Names . SEARCH , ThreadPoolType . FIXED ) ; map . put ( Names . SUGGEST , ThreadPoolType . FIXED ) ; map . put ( Names . PERCOLATE , ThreadPoolType . FIXED ) ; map . put ( Names . MANAGEMENT , ThreadPoolType . SCALING ) ; map . put ( Names . FLUSH , ThreadPoolType . SCALING ) ; map . put ( Names . REFRESH , ThreadPoolType . SCALING ) ; map . put ( Names . WARMER , ThreadPoolType . SCALING ) ; map . put ( Names . SNAPSHOT , ThreadPoolType . SCALING ) ; map . put ( Names . FORCE_MERGE , ThreadPoolType . FIXED ) ; map . put ( Names . FETCH_SHARD_STARTED , ThreadPoolType . SCALING ) ; map . put ( Names . FETCH_SHARD_STORE , ThreadPoolType . SCALING ) ; THREAD_POOL_TYPES = Collections . unmodifiableMap ( map ) ; } private static void add ( Map < String , Settings > executorSettings , ExecutorSettingsBuilder builder ) { Settings settings = builder . build ( ) ; String name = settings . get ( <str> ) ; executorSettings . put ( name , settings ) ; } private static class ExecutorSettingsBuilder { Map < String , String > settings = new HashMap < > ( ) ; public ExecutorSettingsBuilder ( String name ) { settings . put ( <str> , name ) ; settings . put ( <str> , THREAD_POOL_TYPES . get ( name ) . getType ( ) ) ; } public ExecutorSettingsBuilder size ( int availableProcessors ) { return add ( <str> , Integer . toString ( availableProcessors ) ) ; } public ExecutorSettingsBuilder queueSize ( int queueSize ) { return add ( <str> , Integer . toString ( queueSize ) ) ; } public ExecutorSettingsBuilder keepAlive ( String keepAlive ) { return add ( <str> , keepAlive ) ; } private ExecutorSettingsBuilder add ( String key , String value ) { settings . put ( key , value ) ; return this ; } public Settings build ( ) { return settingsBuilder ( ) . put ( settings ) . build ( ) ; } } public static final String THREADPOOL_GROUP = <str> ; private volatile Map < String , ExecutorHolder > executors ; private final Map < String , Settings > defaultExecutorTypeSettings ; private final Queue < ExecutorHolder > retiredExecutors = new ConcurrentLinkedQueue < > ( ) ; private final ScheduledThreadPoolExecutor scheduler ; private final EstimatedTimeThread estimatedTimeThread ; private boolean settingsListenerIsSet = false ; static final Executor DIRECT_EXECUTOR = command - > command . run ( ) ; public ThreadPool ( String name ) { this ( Settings . builder ( ) . put ( <str> , name ) . build ( ) ) ; } public ThreadPool ( Settings settings ) { super ( settings ) ; assert settings . get ( <str> ) ! = null : <str> ; Map < String , Settings > groupSettings = getThreadPoolSettingsGroup ( settings ) ; int availableProcessors = EsExecutors . boundedNumberOfProcessors ( settings ) ; int halfProcMaxAt5 = Math . min ( ( ( availableProcessors + <int> ) / <int> ) , <int> ) ; int halfProcMaxAt10 = Math . min ( ( ( availableProcessors + <int> ) / <int> ) , <int> ) ; Map < String , Settings > defaultExecutorTypeSettings = new HashMap < > ( ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . GENERIC ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . INDEX ) . size ( availableProcessors ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . BULK ) . size ( availableProcessors ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . GET ) . size ( availableProcessors ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . SEARCH ) . size ( ( ( availableProcessors * <int> ) / <int> ) + <int> ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . SUGGEST ) . size ( availableProcessors ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . PERCOLATE ) . size ( availableProcessors ) . queueSize ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . MANAGEMENT ) . size ( <int> ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . LISTENER ) . size ( halfProcMaxAt10 ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . FLUSH ) . size ( halfProcMaxAt5 ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . REFRESH ) . size ( halfProcMaxAt10 ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . WARMER ) . size ( halfProcMaxAt5 ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . SNAPSHOT ) . size ( halfProcMaxAt5 ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . FORCE_MERGE ) . size ( <int> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . FETCH_SHARD_STARTED ) . size ( availableProcessors * <int> ) . keepAlive ( <str> ) ) ; add ( defaultExecutorTypeSettings , new ExecutorSettingsBuilder ( Names . FETCH_SHARD_STORE ) . size ( availableProcessors * <int> ) . keepAlive ( <str> ) ) ; this . defaultExecutorTypeSettings = unmodifiableMap ( defaultExecutorTypeSettings ) ; Map < String , ExecutorHolder > executors = new HashMap < > ( ) ; for ( Map . Entry < String , Settings > executor : defaultExecutorTypeSettings . entrySet ( ) ) { executors . put ( executor . getKey ( ) , build ( executor . getKey ( ) , groupSettings . get ( executor . getKey ( ) ) , executor . getValue ( ) ) ) ; } for ( Map . Entry < String , Settings > entry : groupSettings . entrySet ( ) ) { if ( executors . containsKey ( entry . getKey ( ) ) ) { continue ; } executors . put ( entry . getKey ( ) , build ( entry . getKey ( ) , entry . getValue ( ) , Settings . EMPTY ) ) ; } executors . put ( Names . SAME , new ExecutorHolder ( DIRECT_EXECUTOR , new Info ( Names . SAME , ThreadPoolType . DIRECT ) ) ) ; if ( ! executors . get ( Names . GENERIC ) . info . getThreadPoolType ( ) . equals ( ThreadPoolType . CACHED ) ) { throw new IllegalArgumentException ( <str> ) ; } this . executors = unmodifiableMap ( executors ) ; this . scheduler = new ScheduledThreadPoolExecutor ( <int> , EsExecutors . daemonThreadFactory ( settings , <str> ) , new EsAbortPolicy ( ) ) ; this . scheduler . setExecuteExistingDelayedTasksAfterShutdownPolicy ( false ) ; this . scheduler . setContinueExistingPeriodicTasksAfterShutdownPolicy ( false ) ; this . scheduler . setRemoveOnCancelPolicy ( true ) ; TimeValue estimatedTimeInterval = settings . getAsTime ( <str> , TimeValue . timeValueMillis ( <int> ) ) ; this . estimatedTimeThread = new EstimatedTimeThread ( EsExecutors . threadName ( settings , <str> ) , estimatedTimeInterval . millis ( ) ) ; this . estimatedTimeThread . start ( ) ; } private Map < String , Settings > getThreadPoolSettingsGroup ( Settings settings ) { Map < String , Settings > groupSettings = settings . getGroups ( THREADPOOL_GROUP ) ; validate ( groupSettings ) ; return groupSettings ; } public void setNodeSettingsService ( NodeSettingsService nodeSettingsService ) { if ( settingsListenerIsSet ) { throw new IllegalStateException ( <str> ) ; } nodeSettingsService . addListener ( new ApplySettings ( ) ) ; settingsListenerIsSet = true ; } public long estimatedTimeInMillis ( ) { return estimatedTimeThread . estimatedTimeInMillis ( ) ; } public Counter estimatedTimeInMillisCounter ( ) { return estimatedTimeThread . counter ; } public ThreadPoolInfo info ( ) { List < Info > infos = new ArrayList < > ( ) ; for ( ExecutorHolder holder : executors . values ( ) ) { String name = holder . info . getName ( ) ; if ( <str> . equals ( name ) ) { continue ; } infos . add ( holder . info ) ; } return new ThreadPoolInfo ( infos ) ; } public Info info ( String name ) { ExecutorHolder holder = executors . get ( name ) ; if ( holder = = null ) { return null ; } return holder . info ; } public ThreadPoolStats stats ( ) { List < ThreadPoolStats . Stats > stats = new ArrayList < > ( ) ; for ( ExecutorHolder holder : executors . values ( ) ) { String name = holder . info . getName ( ) ; if ( <str> . equals ( name ) ) { continue ; } int threads = - <int> ; int queue = - <int> ; int active = - <int> ; long rejected = - <int> ; int largest = - <int> ; long completed = - <int> ; if ( holder . executor ( ) instanceof ThreadPoolExecutor ) { ThreadPoolExecutor threadPoolExecutor = ( ThreadPoolExecutor ) holder . executor ( ) ; threads = threadPoolExecutor . getPoolSize ( ) ; queue = threadPoolExecutor . getQueue ( ) . size ( ) ; active = threadPoolExecutor . getActiveCount ( ) ; largest = threadPoolExecutor . getLargestPoolSize ( ) ; completed = threadPoolExecutor . getCompletedTaskCount ( ) ; RejectedExecutionHandler rejectedExecutionHandler = threadPoolExecutor . getRejectedExecutionHandler ( ) ; if ( rejectedExecutionHandler instanceof XRejectedExecutionHandler ) { rejected = ( ( XRejectedExecutionHandler ) rejectedExecutionHandler ) . rejected ( ) ; } } stats . add ( new ThreadPoolStats . Stats ( name , threads , queue , active , rejected , largest , completed ) ) ; } return new ThreadPoolStats ( stats ) ; } public Executor generic ( ) { return executor ( Names . GENERIC ) ; } public Executor executor ( String name ) { Executor executor = executors . get ( name ) . executor ( ) ; if ( executor = = null ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } return executor ; } public ScheduledExecutorService scheduler ( ) { return this . scheduler ; } public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , TimeValue interval ) { return scheduler . scheduleWithFixedDelay ( new LoggingRunnable ( command ) , interval . millis ( ) , interval . millis ( ) , TimeUnit . MILLISECONDS ) ; } public ScheduledFuture < ? > schedule ( TimeValue delay , String name , Runnable command ) { if ( ! Names . SAME . equals ( name ) ) { command = new ThreadedRunnable ( command , executor ( name ) ) ; } return scheduler . schedule ( command , delay . millis ( ) , TimeUnit . MILLISECONDS ) ; } public void shutdown ( ) { estimatedTimeThread . running = false ; estimatedTimeThread . interrupt ( ) ; scheduler . shutdown ( ) ; for ( ExecutorHolder executor : executors . values ( ) ) { if ( executor . executor ( ) instanceof ThreadPoolExecutor ) { ( ( ThreadPoolExecutor ) executor . executor ( ) ) . shutdown ( ) ; } } } public void shutdownNow ( ) { estimatedTimeThread . running = false ; estimatedTimeThread . interrupt ( ) ; scheduler . shutdownNow ( ) ; for ( ExecutorHolder executor : executors . values ( ) ) { if ( executor . executor ( ) instanceof ThreadPoolExecutor ) { ( ( ThreadPoolExecutor ) executor . executor ( ) ) . shutdownNow ( ) ; } } while ( ! retiredExecutors . isEmpty ( ) ) { ( ( ThreadPoolExecutor ) retiredExecutors . remove ( ) . executor ( ) ) . shutdownNow ( ) ; } } public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { boolean result = scheduler . awaitTermination ( timeout , unit ) ; for ( ExecutorHolder executor : executors . values ( ) ) { if ( executor . executor ( ) instanceof ThreadPoolExecutor ) { result & = ( ( ThreadPoolExecutor ) executor . executor ( ) ) . awaitTermination ( timeout , unit ) ; } } while ( ! retiredExecutors . isEmpty ( ) ) { ThreadPoolExecutor executor = ( ThreadPoolExecutor ) retiredExecutors . remove ( ) . executor ( ) ; result & = executor . awaitTermination ( timeout , unit ) ; } estimatedTimeThread . join ( unit . toMillis ( timeout ) ) ; return result ; } private ExecutorHolder build ( String name , @Nullable Settings settings , Settings defaultSettings ) { return rebuild ( name , null , settings , defaultSettings ) ; } private ExecutorHolder rebuild ( String name , ExecutorHolder previousExecutorHolder , @Nullable Settings settings , Settings defaultSettings ) { if ( Names . SAME . equals ( name ) ) { return previousExecutorHolder ; } if ( settings = = null ) { settings = Settings . Builder . EMPTY_SETTINGS ; } Info previousInfo = previousExecutorHolder ! = null ? previousExecutorHolder . info : null ; String type = settings . get ( <str> , previousInfo ! = null ? previousInfo . getThreadPoolType ( ) . getType ( ) : defaultSettings . get ( <str> ) ) ; ThreadPoolType threadPoolType = ThreadPoolType . fromType ( type ) ; ThreadFactory threadFactory = EsExecutors . daemonThreadFactory ( this . settings , name ) ; if ( ThreadPoolType . DIRECT = = threadPoolType ) { if ( previousExecutorHolder ! = null ) { logger . debug ( <str> , name , type ) ; } else { logger . debug ( <str> , name , type ) ; } return new ExecutorHolder ( DIRECT_EXECUTOR , new Info ( name , threadPoolType ) ) ; } else if ( ThreadPoolType . CACHED = = threadPoolType ) { if ( ! Names . GENERIC . equals ( name ) ) { throw new IllegalArgumentException ( <str> + name + <str> ) ; } TimeValue defaultKeepAlive = defaultSettings . getAsTime ( <str> , timeValueMinutes ( <int> ) ) ; if ( previousExecutorHolder ! = null ) { if ( ThreadPoolType . CACHED = = previousInfo . getThreadPoolType ( ) ) { TimeValue updatedKeepAlive = settings . getAsTime ( <str> , previousInfo . getKeepAlive ( ) ) ; if ( ! previousInfo . getKeepAlive ( ) . equals ( updatedKeepAlive ) ) { logger . debug ( <str> , name , type , updatedKeepAlive ) ; ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setKeepAliveTime ( updatedKeepAlive . millis ( ) , TimeUnit . MILLISECONDS ) ; return new ExecutorHolder ( previousExecutorHolder . executor ( ) , new Info ( name , threadPoolType , - <int> , - <int> , updatedKeepAlive , null ) ) ; } return previousExecutorHolder ; } if ( previousInfo . getKeepAlive ( ) ! = null ) { defaultKeepAlive = previousInfo . getKeepAlive ( ) ; } } TimeValue keepAlive = settings . getAsTime ( <str> , defaultKeepAlive ) ; if ( previousExecutorHolder ! = null ) { logger . debug ( <str> , name , type , keepAlive ) ; } else { logger . debug ( <str> , name , type , keepAlive ) ; } Executor executor = EsExecutors . newCached ( name , keepAlive . millis ( ) , TimeUnit . MILLISECONDS , threadFactory ) ; return new ExecutorHolder ( executor , new Info ( name , threadPoolType , - <int> , - <int> , keepAlive , null ) ) ; } else if ( ThreadPoolType . FIXED = = threadPoolType ) { int defaultSize = defaultSettings . getAsInt ( <str> , EsExecutors . boundedNumberOfProcessors ( settings ) ) ; SizeValue defaultQueueSize = getAsSizeOrUnbounded ( defaultSettings , <str> , getAsSizeOrUnbounded ( defaultSettings , <str> , null ) ) ; if ( previousExecutorHolder ! = null ) { if ( ThreadPoolType . FIXED = = previousInfo . getThreadPoolType ( ) ) { SizeValue updatedQueueSize = getAsSizeOrUnbounded ( settings , <str> , getAsSizeOrUnbounded ( settings , <str> , getAsSizeOrUnbounded ( settings , <str> , previousInfo . getQueueSize ( ) ) ) ) ; if ( Objects . equals ( previousInfo . getQueueSize ( ) , updatedQueueSize ) ) { int updatedSize = settings . getAsInt ( <str> , previousInfo . getMax ( ) ) ; if ( previousInfo . getMax ( ) ! = updatedSize ) { logger . debug ( <str> , name , type , updatedSize , updatedQueueSize ) ; if ( updatedSize > previousInfo . getMax ( ) ) { ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setMaximumPoolSize ( updatedSize ) ; ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setCorePoolSize ( updatedSize ) ; } else { ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setCorePoolSize ( updatedSize ) ; ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setMaximumPoolSize ( updatedSize ) ; } return new ExecutorHolder ( previousExecutorHolder . executor ( ) , new Info ( name , threadPoolType , updatedSize , updatedSize , null , updatedQueueSize ) ) ; } return previousExecutorHolder ; } } if ( previousInfo . getMax ( ) > = <int> ) { defaultSize = previousInfo . getMax ( ) ; } defaultQueueSize = previousInfo . getQueueSize ( ) ; } int size = settings . getAsInt ( <str> , defaultSize ) ; SizeValue queueSize = getAsSizeOrUnbounded ( settings , <str> , getAsSizeOrUnbounded ( settings , <str> , getAsSizeOrUnbounded ( settings , <str> , defaultQueueSize ) ) ) ; logger . debug ( <str> , name , type , size , queueSize ) ; Executor executor = EsExecutors . newFixed ( name , size , queueSize = = null ? - <int> : ( int ) queueSize . singles ( ) , threadFactory ) ; return new ExecutorHolder ( executor , new Info ( name , threadPoolType , size , size , null , queueSize ) ) ; } else if ( ThreadPoolType . SCALING = = threadPoolType ) { TimeValue defaultKeepAlive = defaultSettings . getAsTime ( <str> , timeValueMinutes ( <int> ) ) ; int defaultMin = defaultSettings . getAsInt ( <str> , <int> ) ; int defaultSize = defaultSettings . getAsInt ( <str> , EsExecutors . boundedNumberOfProcessors ( settings ) ) ; if ( previousExecutorHolder ! = null ) { if ( ThreadPoolType . SCALING = = previousInfo . getThreadPoolType ( ) ) { TimeValue updatedKeepAlive = settings . getAsTime ( <str> , previousInfo . getKeepAlive ( ) ) ; int updatedMin = settings . getAsInt ( <str> , previousInfo . getMin ( ) ) ; int updatedSize = settings . getAsInt ( <str> , settings . getAsInt ( <str> , previousInfo . getMax ( ) ) ) ; if ( ! previousInfo . getKeepAlive ( ) . equals ( updatedKeepAlive ) | | previousInfo . getMin ( ) ! = updatedMin | | previousInfo . getMax ( ) ! = updatedSize ) { logger . debug ( <str> , name , type , updatedKeepAlive ) ; if ( ! previousInfo . getKeepAlive ( ) . equals ( updatedKeepAlive ) ) { ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setKeepAliveTime ( updatedKeepAlive . millis ( ) , TimeUnit . MILLISECONDS ) ; } if ( previousInfo . getMin ( ) ! = updatedMin ) { ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setCorePoolSize ( updatedMin ) ; } if ( previousInfo . getMax ( ) ! = updatedSize ) { ( ( EsThreadPoolExecutor ) previousExecutorHolder . executor ( ) ) . setMaximumPoolSize ( updatedSize ) ; } return new ExecutorHolder ( previousExecutorHolder . executor ( ) , new Info ( name , threadPoolType , updatedMin , updatedSize , updatedKeepAlive , null ) ) ; } return previousExecutorHolder ; } if ( previousInfo . getKeepAlive ( ) ! = null ) { defaultKeepAlive = previousInfo . getKeepAlive ( ) ; } if ( previousInfo . getMin ( ) > = <int> ) { defaultMin = previousInfo . getMin ( ) ; } if ( previousInfo . getMax ( ) > = <int> ) { defaultSize = previousInfo . getMax ( ) ; } } TimeValue keepAlive = settings . getAsTime ( <str> , defaultKeepAlive ) ; int min = settings . getAsInt ( <str> , defaultMin ) ; int size = settings . getAsInt ( <str> , settings . getAsInt ( <str> , defaultSize ) ) ; if ( previousExecutorHolder ! = null ) { logger . debug ( <str> , name , type , min , size , keepAlive ) ; } else { logger . debug ( <str> , name , type , min , size , keepAlive ) ; } Executor executor = EsExecutors . newScaling ( name , min , size , keepAlive . millis ( ) , TimeUnit . MILLISECONDS , threadFactory ) ; return new ExecutorHolder ( executor , new Info ( name , threadPoolType , min , size , keepAlive , null ) ) ; } throw new IllegalArgumentException ( <str> + type + <str> + name + <str> ) ; } public void updateSettings ( Settings settings ) { Map < String , Settings > groupSettings = getThreadPoolSettingsGroup ( settings ) ; if ( groupSettings . isEmpty ( ) ) { return ; } for ( Map . Entry < String , Settings > executor : defaultExecutorTypeSettings . entrySet ( ) ) { Settings updatedSettings = groupSettings . get ( executor . getKey ( ) ) ; if ( updatedSettings = = null ) { continue ; } ExecutorHolder oldExecutorHolder = executors . get ( executor . getKey ( ) ) ; ExecutorHolder newExecutorHolder = rebuild ( executor . getKey ( ) , oldExecutorHolder , updatedSettings , executor . getValue ( ) ) ; if ( ! oldExecutorHolder . equals ( newExecutorHolder ) ) { Map < String , ExecutorHolder > newExecutors = new HashMap < > ( executors ) ; newExecutors . put ( executor . getKey ( ) , newExecutorHolder ) ; executors = unmodifiableMap ( newExecutors ) ; if ( ! oldExecutorHolder . executor ( ) . equals ( newExecutorHolder . executor ( ) ) & & oldExecutorHolder . executor ( ) instanceof EsThreadPoolExecutor ) { retiredExecutors . add ( oldExecutorHolder ) ; ( ( EsThreadPoolExecutor ) oldExecutorHolder . executor ( ) ) . shutdown ( new ExecutorShutdownListener ( oldExecutorHolder ) ) ; } } } for ( Map . Entry < String , Settings > entry : groupSettings . entrySet ( ) ) { if ( defaultExecutorTypeSettings . containsKey ( entry . getKey ( ) ) ) { continue ; } ExecutorHolder oldExecutorHolder = executors . get ( entry . getKey ( ) ) ; ExecutorHolder newExecutorHolder = rebuild ( entry . getKey ( ) , oldExecutorHolder , entry . getValue ( ) , Settings . EMPTY ) ; if ( ! newExecutorHolder . equals ( oldExecutorHolder ) ) { Map < String , ExecutorHolder > newExecutors = new HashMap < > ( executors ) ; newExecutors . put ( entry . getKey ( ) , newExecutorHolder ) ; executors = unmodifiableMap ( newExecutors ) ; if ( ! oldExecutorHolder . executor ( ) . equals ( newExecutorHolder . executor ( ) ) & & oldExecutorHolder . executor ( ) instanceof EsThreadPoolExecutor ) { retiredExecutors . add ( oldExecutorHolder ) ; ( ( EsThreadPoolExecutor ) oldExecutorHolder . executor ( ) ) . shutdown ( new ExecutorShutdownListener ( oldExecutorHolder ) ) ; } } } } private void validate ( Map < String , Settings > groupSettings ) { for ( String key : groupSettings . keySet ( ) ) { if ( ! THREAD_POOL_TYPES . containsKey ( key ) ) { continue ; } String type = groupSettings . get ( key ) . get ( <str> ) ; ThreadPoolType correctThreadPoolType = THREAD_POOL_TYPES . get ( key ) ; if ( type ! = null & & ! correctThreadPoolType . getType ( ) . equals ( type ) ) { throw new IllegalArgumentException ( <str> + THREADPOOL_GROUP + key + <str> + type + <str> + correctThreadPoolType . getType ( ) ) ; } } } private SizeValue getAsSizeOrUnbounded ( Settings settings , String setting , SizeValue defaultValue ) throws SettingsException { if ( <str> . equals ( settings . get ( setting ) ) ) { return null ; } return parseSizeValue ( settings . get ( setting ) , defaultValue ) ; } class ExecutorShutdownListener implements EsThreadPoolExecutor . ShutdownListener { private ExecutorHolder holder ; public ExecutorShutdownListener ( ExecutorHolder holder ) { this . holder = holder ; } @Override public void onTerminated ( ) { retiredExecutors . remove ( holder ) ; } } class LoggingRunnable implements Runnable { private final Runnable runnable ; LoggingRunnable ( Runnable runnable ) { this . runnable = runnable ; } @Override public void run ( ) { try { runnable . run ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , runnable . toString ( ) ) ; } } @Override public int hashCode ( ) { return runnable . hashCode ( ) ; } @Override public boolean equals ( Object obj ) { return runnable . equals ( obj ) ; } @Override public String toString ( ) { return <str> + runnable . toString ( ) ; } } class ThreadedRunnable implements Runnable { private final Runnable runnable ; private final Executor executor ; ThreadedRunnable ( Runnable runnable , Executor executor ) { this . runnable = runnable ; this . executor = executor ; } @Override public void run ( ) { executor . execute ( runnable ) ; } @Override public int hashCode ( ) { return runnable . hashCode ( ) ; } @Override public boolean equals ( Object obj ) { return runnable . equals ( obj ) ; } @Override public String toString ( ) { return <str> + runnable . toString ( ) ; } } static class EstimatedTimeThread extends Thread { final long interval ; final TimeCounter counter ; volatile boolean running = true ; volatile long estimatedTimeInMillis ; EstimatedTimeThread ( String name , long interval ) { super ( name ) ; this . interval = interval ; this . estimatedTimeInMillis = TimeValue . nsecToMSec ( System . nanoTime ( ) ) ; this . counter = new TimeCounter ( ) ; setDaemon ( true ) ; } public long estimatedTimeInMillis ( ) { return this . estimatedTimeInMillis ; } @Override public void run ( ) { while ( running ) { estimatedTimeInMillis = TimeValue . nsecToMSec ( System . nanoTime ( ) ) ; try { Thread . sleep ( interval ) ; } catch ( InterruptedException e ) { running = false ; return ; } } } private class TimeCounter extends Counter { @Override public long addAndGet ( long delta ) { throw new UnsupportedOperationException ( ) ; } @Override public long get ( ) { return estimatedTimeInMillis ; } } } static class ExecutorHolder { private final Executor executor ; public final Info info ; ExecutorHolder ( Executor executor , Info info ) { assert executor instanceof EsThreadPoolExecutor | | executor = = DIRECT_EXECUTOR ; this . executor = executor ; this . info = info ; } Executor executor ( ) { return executor ; } } public static class Info implements Streamable , ToXContent { private String name ; private ThreadPoolType type ; private int min ; private int max ; private TimeValue keepAlive ; private SizeValue queueSize ; Info ( ) { } public Info ( String name , ThreadPoolType type ) { this ( name , type , - <int> ) ; } public Info ( String name , ThreadPoolType type , int size ) { this ( name , type , size , size , null , null ) ; } public Info ( String name , ThreadPoolType type , int min , int max , @Nullable TimeValue keepAlive , @Nullable SizeValue queueSize ) { this . name = name ; this . type = type ; this . min = min ; this . max = max ; this . keepAlive = keepAlive ; this . queueSize = queueSize ; } public String getName ( ) { return this . name ; } public ThreadPoolType getThreadPoolType ( ) { return this . type ; } public int getMin ( ) { return this . min ; } public int getMax ( ) { return this . max ; } @Nullable public TimeValue getKeepAlive ( ) { return this . keepAlive ; } @Nullable public SizeValue getQueueSize ( ) { return this . queueSize ; } @Override public void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; type = ThreadPoolType . fromType ( in . readString ( ) ) ; min = in . readInt ( ) ; max = in . readInt ( ) ; if ( in . readBoolean ( ) ) { keepAlive = TimeValue . readTimeValue ( in ) ; } if ( in . readBoolean ( ) ) { queueSize = SizeValue . readSizeValue ( in ) ; } in . readBoolean ( ) ; in . readBoolean ( ) ; in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeString ( type . getType ( ) ) ; out . writeInt ( min ) ; out . writeInt ( max ) ; if ( keepAlive = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; keepAlive . writeTo ( out ) ; } if ( queueSize = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; queueSize . writeTo ( out ) ; } out . writeBoolean ( false ) ; out . writeBoolean ( false ) ; out . writeBoolean ( false ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( name , XContentBuilder . FieldCaseConversion . NONE ) ; builder . field ( Fields . TYPE , type . getType ( ) ) ; if ( min ! = - <int> ) { builder . field ( Fields . MIN , min ) ; } if ( max ! = - <int> ) { builder . field ( Fields . MAX , max ) ; } if ( keepAlive ! = null ) { builder . field ( Fields . KEEP_ALIVE , keepAlive . toString ( ) ) ; } if ( queueSize = = null ) { builder . field ( Fields . QUEUE_SIZE , - <int> ) ; } else { builder . field ( Fields . QUEUE_SIZE , queueSize . singles ( ) ) ; } builder . endObject ( ) ; return builder ; } static final class Fields { static final XContentBuilderString TYPE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MIN = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MAX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString KEEP_ALIVE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString QUEUE_SIZE = new XContentBuilderString ( <str> ) ; } } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { updateSettings ( settings ) ; } } public static boolean terminate ( ExecutorService service , long timeout , TimeUnit timeUnit ) { if ( service ! = null ) { service . shutdown ( ) ; try { if ( service . awaitTermination ( timeout , timeUnit ) ) { return true ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } service . shutdownNow ( ) ; } return false ; } public static boolean terminate ( ThreadPool pool , long timeout , TimeUnit timeUnit ) { if ( pool ! = null ) { pool . shutdown ( ) ; try { if ( pool . awaitTermination ( timeout , timeUnit ) ) { return true ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } pool . shutdownNow ( ) ; } return false ; } public static ThreadPoolTypeSettingsValidator THREAD_POOL_TYPE_SETTINGS_VALIDATOR = new ThreadPoolTypeSettingsValidator ( ) ; private static class ThreadPoolTypeSettingsValidator implements Validator { @Override public String validate ( String setting , String value , ClusterState clusterState ) { Matcher matcher = Pattern . compile ( <str> ) . matcher ( setting ) ; if ( ! matcher . matches ( ) ) { return null ; } else { String threadPool = matcher . group ( <int> ) ; ThreadPool . ThreadPoolType defaultThreadPoolType = ThreadPool . THREAD_POOL_TYPES . get ( threadPool ) ; ThreadPool . ThreadPoolType threadPoolType ; try { threadPoolType = ThreadPool . ThreadPoolType . fromType ( value ) ; } catch ( IllegalArgumentException e ) { return e . getMessage ( ) ; } if ( defaultThreadPoolType . equals ( threadPoolType ) ) { return null ; } else { return String . format ( Locale . ROOT , <str> , threadPool , defaultThreadPoolType . getType ( ) , threadPoolType . getType ( ) ) ; } } } } } 
