package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . GlyphLayout ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; public class BitmapFontDistanceFieldTest extends GdxTest { private static final String TEXT = <str> ; private static final Color COLOR = Color . BLACK ; private static final float [ ] SCALES = { <float> , <float> , <int> , <int> , <int> } ; private static class DistanceFieldShader extends ShaderProgram { public DistanceFieldShader ( ) { super ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) ) ; if ( ! isCompiled ( ) ) { throw new RuntimeException ( <str> + getLog ( ) ) ; } } public void setSmoothing ( float smoothing ) { float delta = <float> * MathUtils . clamp ( smoothing , <int> , <int> ) ; setUniformf ( <str> , <float> - delta ) ; setUniformf ( <str> , <float> + delta ) ; } } private OrthographicCamera camera ; private SpriteBatch spriteBatch ; private Texture regularTexture ; private Texture distanceFieldTexture ; private BitmapFont descriptionFont ; private BitmapFont regularFont ; private BitmapFont distanceFieldFont ; private DistanceFieldShader distanceFieldShader ; private GlyphLayout layout = new GlyphLayout ( ) ; @Override public void create ( ) { camera = new OrthographicCamera ( ) ; spriteBatch = new SpriteBatch ( ) ; descriptionFont = new BitmapFont ( Gdx . files . internal ( <str> ) , true ) ; descriptionFont . setColor ( Color . RED ) ; regularTexture = new Texture ( Gdx . files . internal ( <str> ) , true ) ; regularFont = new BitmapFont ( Gdx . files . internal ( <str> ) , new TextureRegion ( regularTexture ) , true ) ; regularFont . setColor ( COLOR ) ; distanceFieldTexture = new Texture ( Gdx . files . internal ( <str> ) , true ) ; distanceFieldFont = new BitmapFont ( Gdx . files . internal ( <str> ) , new TextureRegion ( distanceFieldTexture ) , true ) ; distanceFieldFont . setColor ( COLOR ) ; distanceFieldShader = new DistanceFieldShader ( ) ; ShaderProgram . pedantic = false ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; int x = <int> ; x + = drawFont ( regularFont , <str> , false , false , <int> , x ) ; x + = drawFont ( regularFont , <str> , true , false , <int> , x ) ; x + = drawFont ( regularFont , <str> , true , true , <float> , x ) ; x + = drawFont ( distanceFieldFont , <str> , true , true , <int> / <float> , x ) ; x + = drawFont ( distanceFieldFont , <str> , false , false , <int> , x ) ; spriteBatch . end ( ) ; } private int drawFont ( BitmapFont font , String description , boolean linearFiltering , boolean useShader , float smoothing , int x ) { int y = <int> ; float maxWidth = <int> ; spriteBatch . setShader ( null ) ; descriptionFont . draw ( spriteBatch , description , x , y ) ; spriteBatch . flush ( ) ; y + = <int> + <int> * descriptionFont . getLineHeight ( ) ; TextureFilter minFilter = linearFiltering ? TextureFilter . MipMapLinearNearest : TextureFilter . Nearest ; TextureFilter magFilter = linearFiltering ? TextureFilter . Linear : TextureFilter . Nearest ; for ( int i = <int> ; i < font . getRegions ( ) . size ; i + + ) { font . getRegion ( i ) . getTexture ( ) . setFilter ( minFilter , magFilter ) ; } if ( useShader ) { spriteBatch . setShader ( distanceFieldShader ) ; } else { spriteBatch . setShader ( null ) ; } for ( float scale : SCALES ) { font . getData ( ) . setScale ( scale ) ; layout . setText ( font , TEXT ) ; maxWidth = Math . max ( maxWidth , layout . width ) ; if ( useShader ) { distanceFieldShader . setSmoothing ( smoothing / scale ) ; } font . draw ( spriteBatch , layout , x , y ) ; y + = font . getLineHeight ( ) ; spriteBatch . flush ( ) ; } return ( int ) Math . ceil ( maxWidth ) ; } private float getBaselineShift ( float shift ) { return shift ; } @Override public void resize ( int width , int height ) { super . resize ( width , height ) ; camera . setToOrtho ( true , width , height ) ; spriteBatch . setTransformMatrix ( camera . view ) ; spriteBatch . setProjectionMatrix ( camera . projection ) ; } @Override public void dispose ( ) { spriteBatch . dispose ( ) ; regularTexture . dispose ( ) ; distanceFieldTexture . dispose ( ) ; descriptionFont . dispose ( ) ; regularFont . dispose ( ) ; distanceFieldFont . dispose ( ) ; distanceFieldShader . dispose ( ) ; } } 
