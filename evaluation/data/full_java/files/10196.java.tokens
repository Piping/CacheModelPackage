package com . google . common . collect ; import static com . google . common . collect . Lists . newArrayList ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . collect . CollectionBenchmarkSampleData . Element ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentSkipListMap ; public class MapBenchmark { @Param ( { <str> , <str> , <str> , <str> } ) private Impl impl ; public enum Impl { Hash { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = Maps . newHashMap ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , LinkedHM { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = Maps . newLinkedHashMap ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , UnmodHM { @Override Map < Element , Element > create ( Collection < Element > keys ) { return Collections . unmodifiableMap ( Hash . create ( keys ) ) ; } } , SyncHM { @Override Map < Element , Element > create ( Collection < Element > keys ) { return Collections . synchronizedMap ( Hash . create ( keys ) ) ; } } , Tree { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = Maps . newTreeMap ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , SkipList { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = new ConcurrentSkipListMap < Element , Element > ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , ConcurrentHM1 { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = new ConcurrentHashMap < Element , Element > ( keys . size ( ) , <float> , <int> ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , ConcurrentHM16 { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = new ConcurrentHashMap < Element , Element > ( keys . size ( ) , <float> , <int> ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , MapMaker1 { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = new MapMaker ( ) . concurrencyLevel ( <int> ) . makeMap ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , MapMaker16 { @Override Map < Element , Element > create ( Collection < Element > keys ) { Map < Element , Element > map = new MapMaker ( ) . concurrencyLevel ( <int> ) . makeMap ( ) ; for ( Element element : keys ) { map . put ( element , element ) ; } return map ; } } , Immutable { @Override Map < Element , Element > create ( Collection < Element > keys ) { ImmutableMap . Builder < Element , Element > builder = ImmutableMap . builder ( ) ; for ( Element element : keys ) { builder . put ( element , element ) ; } return builder . build ( ) ; } } , ImmutableSorted { @Override Map < Element , Element > create ( Collection < Element > keys ) { ImmutableSortedMap . Builder < Element , Element > builder = ImmutableSortedMap . naturalOrder ( ) ; for ( Element element : keys ) { builder . put ( element , element ) ; } return builder . build ( ) ; } } ; abstract Map < Element , Element > create ( Collection < Element > contents ) ; } @Param ( { <str> , <str> , <str> , <str> , <str> } ) private int size ; @Param ( <str> ) private double hitRate ; @Param ( <str> ) private boolean isUserTypeFast ; @Param ( <str> ) private SpecialRandom random ; @Param ( <str> ) private boolean sortedData ; private Element [ ] queries ; private Map < Element , Element > mapToTest ; private Collection < Element > values ; @BeforeExperiment void setUp ( ) { CollectionBenchmarkSampleData sampleData = new CollectionBenchmarkSampleData ( isUserTypeFast , random , hitRate , size ) ; if ( sortedData ) { List < Element > valueList = newArrayList ( sampleData . getValuesInSet ( ) ) ; Collections . sort ( valueList ) ; values = valueList ; } else { values = sampleData . getValuesInSet ( ) ; } this . mapToTest = impl . create ( values ) ; this . queries = sampleData . getQueries ( ) ; } @Benchmark boolean get ( int reps ) { Map < Element , Element > map = mapToTest ; Element [ ] queries = this . queries ; int mask = queries . length - <int> ; boolean dummy = false ; for ( int i = <int> ; i < reps ; i + + ) { dummy ^ = map . get ( queries [ i & mask ] ) ! = null ; } return dummy ; } @Benchmark int createAndPopulate ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { dummy + = impl . create ( values ) . size ( ) ; } return dummy ; } @Benchmark boolean iterateWithEntrySet ( int reps ) { Map < Element , Element > map = mapToTest ; boolean dummy = false ; for ( int i = <int> ; i < reps ; i + + ) { for ( Map . Entry < Element , Element > entry : map . entrySet ( ) ) { dummy ^ = entry . getKey ( ) ! = entry . getValue ( ) ; } } return dummy ; } @Benchmark boolean iterateWithKeySetAndGet ( int reps ) { Map < Element , Element > map = mapToTest ; boolean dummy = false ; for ( int i = <int> ; i < reps ; i + + ) { for ( Element key : map . keySet ( ) ) { Element value = map . get ( key ) ; dummy ^ = key ! = value ; } } return dummy ; } } 
