package org . elasticsearch . common . util . concurrent ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class PrioritizedExecutorsTests extends ESTestCase { public void testPriorityQueue ( ) throws Exception { PriorityBlockingQueue < Priority > queue = new PriorityBlockingQueue < > ( ) ; List < Priority > priorities = Arrays . asList ( Priority . values ( ) ) ; Collections . shuffle ( priorities , random ( ) ) ; for ( Priority priority : priorities ) { queue . add ( priority ) ; } Priority prevPriority = null ; while ( ! queue . isEmpty ( ) ) { if ( prevPriority = = null ) { prevPriority = queue . poll ( ) ; } else { assertThat ( queue . poll ( ) . after ( prevPriority ) , is ( true ) ) ; } } } public void testSubmitPrioritizedExecutorWithRunnables ( ) throws Exception { ExecutorService executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; List < Integer > results = new ArrayList < > ( <int> ) ; CountDownLatch awaitingLatch = new CountDownLatch ( <int> ) ; CountDownLatch finishedLatch = new CountDownLatch ( <int> ) ; executor . submit ( new AwaitingJob ( awaitingLatch ) ) ; executor . submit ( new Job ( <int> , Priority . LANGUID , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . URGENT , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . NORMAL , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . IMMEDIATE , results , finishedLatch ) ) ; awaitingLatch . countDown ( ) ; finishedLatch . await ( ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; terminate ( executor ) ; } public void testExecutePrioritizedExecutorWithRunnables ( ) throws Exception { ExecutorService executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; List < Integer > results = new ArrayList < > ( <int> ) ; CountDownLatch awaitingLatch = new CountDownLatch ( <int> ) ; CountDownLatch finishedLatch = new CountDownLatch ( <int> ) ; executor . execute ( new AwaitingJob ( awaitingLatch ) ) ; executor . execute ( new Job ( <int> , Priority . LANGUID , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . URGENT , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . NORMAL , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . execute ( new Job ( <int> , Priority . IMMEDIATE , results , finishedLatch ) ) ; awaitingLatch . countDown ( ) ; finishedLatch . await ( ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; terminate ( executor ) ; } public void testSubmitPrioritizedExecutorWithCallables ( ) throws Exception { ExecutorService executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; List < Integer > results = new ArrayList < > ( <int> ) ; CountDownLatch awaitingLatch = new CountDownLatch ( <int> ) ; CountDownLatch finishedLatch = new CountDownLatch ( <int> ) ; executor . submit ( new AwaitingJob ( awaitingLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . LANGUID , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . URGENT , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . NORMAL , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . IMMEDIATE , results , finishedLatch ) ) ; awaitingLatch . countDown ( ) ; finishedLatch . await ( ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; terminate ( executor ) ; } public void testSubmitPrioritizedExecutorWithMixed ( ) throws Exception { ExecutorService executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; List < Integer > results = new ArrayList < > ( <int> ) ; CountDownLatch awaitingLatch = new CountDownLatch ( <int> ) ; CountDownLatch finishedLatch = new CountDownLatch ( <int> ) ; executor . submit ( new AwaitingJob ( awaitingLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . LANGUID , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . LOW , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . URGENT , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . NORMAL , results , finishedLatch ) ) ; executor . submit ( new CallableJob ( <int> , Priority . HIGH , results , finishedLatch ) ) ; executor . submit ( new Job ( <int> , Priority . IMMEDIATE , results , finishedLatch ) ) ; awaitingLatch . countDown ( ) ; finishedLatch . await ( ) ; assertThat ( results . size ( ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; assertThat ( results . get ( <int> ) , equalTo ( <int> ) ) ; terminate ( executor ) ; } public void testTimeout ( ) throws Exception { ScheduledExecutorService timer = Executors . newSingleThreadScheduledExecutor ( EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; PrioritizedEsThreadPoolExecutor executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; final CountDownLatch invoked = new CountDownLatch ( <int> ) ; final CountDownLatch block = new CountDownLatch ( <int> ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { try { invoked . countDown ( ) ; block . await ( ) ; } catch ( InterruptedException e ) { fail ( ) ; } } @Override public String toString ( ) { return <str> ; } } ) ; invoked . await ( ) ; PrioritizedEsThreadPoolExecutor . Pending [ ] pending = executor . getPending ( ) ; assertThat ( pending . length , equalTo ( <int> ) ) ; assertThat ( pending [ <int> ] . task . toString ( ) , equalTo ( <str> ) ) ; assertThat ( pending [ <int> ] . executing , equalTo ( true ) ) ; final AtomicBoolean executeCalled = new AtomicBoolean ( ) ; final CountDownLatch timedOut = new CountDownLatch ( <int> ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { executeCalled . set ( true ) ; } @Override public String toString ( ) { return <str> ; } } , timer , TimeValue . timeValueMillis ( <int> ) , new Runnable ( ) { @Override public void run ( ) { timedOut . countDown ( ) ; } } ) ; pending = executor . getPending ( ) ; assertThat ( pending . length , equalTo ( <int> ) ) ; assertThat ( pending [ <int> ] . task . toString ( ) , equalTo ( <str> ) ) ; assertThat ( pending [ <int> ] . executing , equalTo ( true ) ) ; assertThat ( pending [ <int> ] . task . toString ( ) , equalTo ( <str> ) ) ; assertThat ( pending [ <int> ] . executing , equalTo ( false ) ) ; assertThat ( timedOut . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; block . countDown ( ) ; Thread . sleep ( <int> ) ; assertThat ( executeCalled . get ( ) , equalTo ( false ) ) ; assertTrue ( terminate ( timer , executor ) ) ; } public void testTimeoutCleanup ( ) throws Exception { ThreadPool threadPool = new ThreadPool ( <str> ) ; final ScheduledThreadPoolExecutor timer = ( ScheduledThreadPoolExecutor ) threadPool . scheduler ( ) ; final AtomicBoolean timeoutCalled = new AtomicBoolean ( ) ; PrioritizedEsThreadPoolExecutor executor = EsExecutors . newSinglePrioritizing ( getTestName ( ) , EsExecutors . daemonThreadFactory ( getTestName ( ) ) ) ; final CountDownLatch invoked = new CountDownLatch ( <int> ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { invoked . countDown ( ) ; } } , timer , TimeValue . timeValueHours ( <int> ) , new Runnable ( ) { @Override public void run ( ) { timeoutCalled . set ( true ) ; } } ) ; invoked . await ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( timer . getQueue ( ) . size ( ) , equalTo ( <int> ) ) ; } } , <int> , TimeUnit . SECONDS ) ; assertThat ( timeoutCalled . get ( ) , equalTo ( false ) ) ; assertTrue ( terminate ( executor ) ) ; assertTrue ( terminate ( threadPool ) ) ; } static class AwaitingJob extends PrioritizedRunnable { private final CountDownLatch latch ; private AwaitingJob ( CountDownLatch latch ) { super ( Priority . URGENT ) ; this . latch = latch ; } @Override public void run ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } static class Job extends PrioritizedRunnable { private final int result ; private final List < Integer > results ; private final CountDownLatch latch ; Job ( int result , Priority priority , List < Integer > results , CountDownLatch latch ) { super ( priority ) ; this . result = result ; this . results = results ; this . latch = latch ; } @Override public void run ( ) { results . add ( result ) ; latch . countDown ( ) ; } } static class CallableJob extends PrioritizedCallable < Integer > { private final int result ; private final List < Integer > results ; private final CountDownLatch latch ; CallableJob ( int result , Priority priority , List < Integer > results , CountDownLatch latch ) { super ( priority ) ; this . result = result ; this . results = results ; this . latch = latch ; } @Override public Integer call ( ) throws Exception { results . add ( result ) ; latch . countDown ( ) ; return result ; } } } 
