package org . gradle . performance . fixture ; import org . gradle . api . Action ; import org . gradle . internal . UncheckedException ; import org . gradle . performance . measure . MeasuredOperation ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public class BuildExperimentRunner { private final GCLoggingCollector gcCollector = new GCLoggingCollector ( ) ; private final DataCollector dataCollector ; private final GradleSessionProvider executerProvider ; private final OperationTimer timer = new OperationTimer ( ) ; public enum Phase { WARMUP , MEASUREMENT } public BuildExperimentRunner ( GradleSessionProvider executerProvider ) { this . executerProvider = executerProvider ; MemoryInfoCollector memoryInfoCollector = new MemoryInfoCollector ( ) ; memoryInfoCollector . setOutputFileName ( <str> ) ; BuildEventTimestampCollector buildEventTimestampCollector = new BuildEventTimestampCollector ( <str> ) ; dataCollector = new CompositeDataCollector ( memoryInfoCollector , gcCollector , buildEventTimestampCollector , new CompilationLoggingCollector ( ) ) ; } public void run ( BuildExperimentSpec experiment , MeasuredOperationList results ) { System . out . println ( ) ; System . out . println ( String . format ( <str> , experiment . getDisplayName ( ) ) ) ; System . out . println ( ) ; File workingDirectory = experiment . getInvocation ( ) . getWorkingDirectory ( ) ; final List < String > additionalJvmOpts = dataCollector . getAdditionalJvmOpts ( workingDirectory ) ; final List < String > additionalArgs = new ArrayList < String > ( dataCollector . getAdditionalArgs ( workingDirectory ) ) ; additionalArgs . add ( <str> + experiment . getDisplayName ( ) ) ; if ( System . getProperty ( <str> ) ! = null ) { additionalArgs . add ( <str> ) ; } GradleInvocationSpec buildSpec = experiment . getInvocation ( ) . withAdditionalJvmOpts ( additionalJvmOpts ) . withAdditionalArgs ( additionalArgs ) ; File projectDir = buildSpec . getWorkingDirectory ( ) ; GradleSession session = executerProvider . session ( buildSpec ) ; session . prepare ( ) ; try { for ( int i = <int> ; i < experiment . getWarmUpCount ( ) ; i + + ) { System . out . println ( ) ; System . out . println ( String . format ( <str> , i + <int> ) ) ; runOnce ( session , experiment , new MeasuredOperationList ( ) , projectDir , Phase . WARMUP , i + <int> , experiment . getWarmUpCount ( ) ) ; } waitForMillis ( experiment . getSleepAfterWarmUpMillis ( ) ) ; for ( int i = <int> ; i < experiment . getInvocationCount ( ) ; i + + ) { if ( i > <int> ) { waitForMillis ( experiment . getSleepAfterTestRoundMillis ( ) ) ; } System . out . println ( ) ; System . out . println ( String . format ( <str> , i + <int> ) ) ; runOnce ( session , experiment , results , projectDir , Phase . MEASUREMENT , i + <int> , experiment . getInvocationCount ( ) ) ; } } finally { session . cleanup ( ) ; } } private void waitForMillis ( Long sleepTimeMillis ) { if ( sleepTimeMillis > <int> L ) { System . out . println ( ) ; System . out . println ( String . format ( <str> , sleepTimeMillis ) ) ; try { Thread . sleep ( sleepTimeMillis ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } private void runOnce ( final GradleSession session , final BuildExperimentSpec experiment , MeasuredOperationList results , final File projectDir , final Phase phase , final int iterationNumber , final int iterationMax ) { final BuildExperimentInvocationInfo invocationInfo = new BuildExperimentInvocationInfo ( ) { @Override public BuildExperimentSpec getBuildExperimentSpec ( ) { return experiment ; } @Override public File getProjectDir ( ) { return projectDir ; } @Override public Phase getPhase ( ) { return phase ; } @Override public int getIterationNumber ( ) { return iterationNumber ; } @Override public int getIterationMax ( ) { return iterationMax ; } } ; final Runnable runner = session . runner ( new GradleInvocationCustomizer ( ) { @Override public GradleInvocationSpec customize ( GradleInvocationSpec invocationSpec ) { GradleInvocationSpec customizedInvocation = invocationSpec . withAdditionalArgs ( createIterationInfoArguments ( phase , iterationNumber , iterationMax ) ) ; if ( experiment . getListener ( ) ! = null ) { GradleInvocationCustomizer customizer = experiment . getListener ( ) . createInvocationCustomizer ( invocationInfo ) ; customizedInvocation = customizer . customize ( customizedInvocation ) ; } return customizedInvocation ; } } ) ; if ( experiment . getListener ( ) ! = null ) { experiment . getListener ( ) . beforeInvocation ( invocationInfo ) ; } MeasuredOperation operation = timer . measure ( new Action < MeasuredOperation > ( ) { @Override public void execute ( MeasuredOperation measuredOperation ) { runner . run ( ) ; } } ) ; final AtomicBoolean omitMeasurement = new AtomicBoolean ( ) ; if ( experiment . getListener ( ) ! = null ) { experiment . getListener ( ) . afterInvocation ( invocationInfo , operation , new BuildExperimentListener . MeasurementCallback ( ) { @Override public void omitMeasurement ( ) { omitMeasurement . set ( true ) ; } } ) ; } if ( ! omitMeasurement . get ( ) ) { if ( operation . getException ( ) = = null ) { dataCollector . collect ( invocationInfo , operation ) ; } results . add ( operation ) ; } } private List < String > createIterationInfoArguments ( Phase phase , int iterationNumber , int iterationMax ) { List < String > args = new ArrayList < String > ( <int> ) ; args . add ( <str> + phase . toString ( ) . toLowerCase ( ) ) ; args . add ( <str> + iterationNumber ) ; args . add ( <str> + iterationMax ) ; return args ; } } 
