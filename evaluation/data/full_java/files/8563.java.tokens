package org . elasticsearch . transport ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . threadpool . ThreadPool ; import org . junit . After ; import org . junit . Before ; import java . io . IOException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import static java . util . Collections . emptyMap ; import static org . hamcrest . Matchers . endsWith ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . notNullValue ; public abstract class AbstractSimpleTransportTestCase extends ESTestCase { protected ThreadPool threadPool ; protected static final Version version0 = Version . fromId ( <int> ) ; protected DiscoveryNode nodeA ; protected MockTransportService serviceA ; protected static final Version version1 = Version . fromId ( <int> ) ; protected DiscoveryNode nodeB ; protected MockTransportService serviceB ; protected abstract MockTransportService build ( Settings settings , Version version , NamedWriteableRegistry namedWriteableRegistry ) ; @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; threadPool = new ThreadPool ( getClass ( ) . getName ( ) ) ; serviceA = build ( Settings . builder ( ) . put ( <str> , <str> , TransportService . SETTING_TRACE_LOG_INCLUDE , <str> , TransportService . SETTING_TRACE_LOG_EXCLUDE , <str> ) . build ( ) , version0 , new NamedWriteableRegistry ( ) ) ; nodeA = new DiscoveryNode ( <str> , <str> , serviceA . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , version0 ) ; serviceB = build ( Settings . builder ( ) . put ( <str> , <str> , TransportService . SETTING_TRACE_LOG_INCLUDE , <str> , TransportService . SETTING_TRACE_LOG_EXCLUDE , <str> ) . build ( ) , version1 , new NamedWriteableRegistry ( ) ) ; nodeB = new DiscoveryNode ( <str> , <str> , serviceB . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , version1 ) ; final boolean useLocalNode = randomBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( useLocalNode ? <int> : <int> ) ; TransportConnectionListener waitForConnection = new TransportConnectionListener ( ) { @Override public void onNodeConnected ( DiscoveryNode node ) { latch . countDown ( ) ; } @Override public void onNodeDisconnected ( DiscoveryNode node ) { fail ( <str> + node ) ; } } ; serviceA . addConnectionListener ( waitForConnection ) ; serviceB . addConnectionListener ( waitForConnection ) ; if ( useLocalNode ) { logger . info ( <str> ) ; serviceA . setLocalNode ( nodeA ) ; serviceB . setLocalNode ( nodeB ) ; } else { logger . info ( <str> ) ; serviceA . connectToNode ( nodeA ) ; serviceB . connectToNode ( nodeB ) ; } serviceA . connectToNode ( nodeB ) ; serviceB . connectToNode ( nodeA ) ; assertThat ( <str> , latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; serviceA . removeConnectionListener ( waitForConnection ) ; serviceB . removeConnectionListener ( waitForConnection ) ; } @Override @After public void tearDown ( ) throws Exception { super . tearDown ( ) ; serviceA . close ( ) ; serviceB . close ( ) ; terminate ( threadPool ) ; } public void testHelloWorld ( ) { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { assertThat ( <str> , equalTo ( request . message ) ) ; try { channel . sendResponse ( new StringMessageResponse ( <str> + request . message ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { assertThat ( <str> , equalTo ( response . message ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( <str> + exp . getMessage ( ) , false , equalTo ( true ) ) ; } } ) ; try { StringMessageResponse message = res . get ( ) ; assertThat ( <str> , equalTo ( message . message ) ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . builder ( ) . withCompress ( true ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { assertThat ( <str> , equalTo ( response . message ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( <str> + exp . getMessage ( ) , false , equalTo ( true ) ) ; } } ) ; try { StringMessageResponse message = res . get ( ) ; assertThat ( <str> , equalTo ( message . message ) ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } serviceA . removeHandler ( <str> ) ; } public void testLocalNodeConnection ( ) throws InterruptedException { assertTrue ( <str> , serviceA . nodeConnected ( nodeA ) ) ; if ( ( ( TransportService ) serviceA ) . getLocalNode ( ) ! = null ) { serviceA . disconnectFromNode ( nodeA ) ; } final AtomicReference < Exception > exception = new AtomicReference < > ( ) ; serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { try { channel . sendResponse ( new StringMessageResponse ( request . message ) ) ; } catch ( IOException e ) { exception . set ( e ) ; } } } ) ; final AtomicReference < String > responseString = new AtomicReference < > ( ) ; final CountDownLatch responseLatch = new CountDownLatch ( <int> ) ; serviceA . sendRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , new TransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public void handleResponse ( StringMessageResponse response ) { responseString . set ( response . message ) ; responseLatch . countDown ( ) ; } @Override public void handleException ( TransportException exp ) { exception . set ( exp ) ; responseLatch . countDown ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } } ) ; responseLatch . await ( ) ; assertNull ( exception . get ( ) ) ; assertThat ( responseString . get ( ) , equalTo ( <str> ) ) ; } public void testVoidMessageCompressed ( ) { serviceA . registerRequestHandler ( <str> , TransportRequest . Empty : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < TransportRequest . Empty > ( ) { @Override public void messageReceived ( TransportRequest . Empty request , TransportChannel channel ) { try { channel . sendResponse ( TransportResponse . Empty . INSTANCE , TransportResponseOptions . builder ( ) . withCompress ( true ) . build ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; TransportFuture < TransportResponse . Empty > res = serviceB . submitRequest ( nodeA , <str> , TransportRequest . Empty . INSTANCE , TransportRequestOptions . builder ( ) . withCompress ( true ) . build ( ) , new BaseTransportResponseHandler < TransportResponse . Empty > ( ) { @Override public TransportResponse . Empty newInstance ( ) { return TransportResponse . Empty . INSTANCE ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( TransportResponse . Empty response ) { } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( <str> + exp . getMessage ( ) , false , equalTo ( true ) ) ; } } ) ; try { TransportResponse . Empty message = res . get ( ) ; assertThat ( message , notNullValue ( ) ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } serviceA . removeHandler ( <str> ) ; } public void testHelloWorldCompressed ( ) { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { assertThat ( <str> , equalTo ( request . message ) ) ; try { channel . sendResponse ( new StringMessageResponse ( <str> + request . message ) , TransportResponseOptions . builder ( ) . withCompress ( true ) . build ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . builder ( ) . withCompress ( true ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { assertThat ( <str> , equalTo ( response . message ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; assertThat ( <str> + exp . getMessage ( ) , false , equalTo ( true ) ) ; } } ) ; try { StringMessageResponse message = res . get ( ) ; assertThat ( <str> , equalTo ( message . message ) ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } serviceA . removeHandler ( <str> ) ; } public void testErrorMessage ( ) { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) throws Exception { assertThat ( <str> , equalTo ( request . message ) ) ; throw new RuntimeException ( <str> ) ; } } ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { fail ( <str> ) ; } @Override public void handleException ( TransportException exp ) { assertThat ( <str> , equalTo ( exp . getCause ( ) . getMessage ( ) ) ) ; } } ) ; try { res . txGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e . getCause ( ) . getMessage ( ) , equalTo ( <str> ) ) ; } serviceA . removeHandler ( <str> ) ; } public void testDisconnectListener ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( <int> ) ; TransportConnectionListener disconnectListener = new TransportConnectionListener ( ) { @Override public void onNodeConnected ( DiscoveryNode node ) { fail ( <str> + node ) ; } @Override public void onNodeDisconnected ( DiscoveryNode node ) { latch . countDown ( ) ; } } ; serviceA . addConnectionListener ( disconnectListener ) ; serviceB . close ( ) ; assertThat ( latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; } public void testNotifyOnShutdown ( ) throws Exception { final CountDownLatch latch2 = new CountDownLatch ( <int> ) ; serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { try { latch2 . await ( ) ; logger . info ( <str> ) ; serviceB . stop ( ) ; } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } } } ) ; TransportFuture < TransportResponse . Empty > foobar = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . EMPTY , EmptyTransportResponseHandler . INSTANCE_SAME ) ; latch2 . countDown ( ) ; try { foobar . txGet ( ) ; fail ( <str> ) ; } catch ( TransportException ex ) { } serviceA . removeHandler ( <str> ) ; } public void testTimeoutSendExceptionWithNeverSendingBackResponse ( ) throws Exception { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { assertThat ( <str> , equalTo ( request . message ) ) ; } } ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . builder ( ) . withTimeout ( <int> ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { fail ( <str> ) ; } @Override public void handleException ( TransportException exp ) { assertThat ( exp , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } } ) ; try { StringMessageResponse message = res . txGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } serviceA . removeHandler ( <str> ) ; } public void testTimeoutSendExceptionWithDelayedResponse ( ) throws Exception { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) { TimeValue sleep = TimeValue . parseTimeValue ( request . message , null , <str> ) ; try { Thread . sleep ( sleep . millis ( ) ) ; } catch ( InterruptedException e ) { } try { channel . sendResponse ( new StringMessageResponse ( <str> + request . message ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; assertThat ( e . getMessage ( ) , false , equalTo ( true ) ) ; } } } ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . builder ( ) . withTimeout ( <int> ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { latch . countDown ( ) ; fail ( <str> ) ; } @Override public void handleException ( TransportException exp ) { latch . countDown ( ) ; assertThat ( exp , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } } ) ; try { StringMessageResponse message = res . txGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } latch . await ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { final int counter = i ; res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( counter + <str> ) , TransportRequestOptions . builder ( ) . withTimeout ( <int> ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { assertThat ( <str> + counter + <str> , equalTo ( response . message ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; fail ( <str> + counter + <str> + exp . getDetailedMessage ( ) ) ; } } ) ; StringMessageResponse message = res . txGet ( ) ; assertThat ( message . message , equalTo ( <str> + counter + <str> ) ) ; } serviceA . removeHandler ( <str> ) ; } @TestLogging ( value = <str> ) public void testTracerLog ( ) throws InterruptedException { TransportRequestHandler handler = new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) throws Exception { channel . sendResponse ( new StringMessageResponse ( <str> ) ) ; } } ; TransportRequestHandler handlerWithError = new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) throws Exception { if ( request . timeout ( ) > <int> ) { Thread . sleep ( request . timeout ) ; } channel . sendResponse ( new RuntimeException ( <str> ) ) ; } } ; final Semaphore requestCompleted = new Semaphore ( <int> ) ; TransportResponseHandler noopResponseHandler = new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public void handleResponse ( StringMessageResponse response ) { requestCompleted . release ( ) ; } @Override public void handleException ( TransportException exp ) { requestCompleted . release ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ; serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . SAME , handler ) ; serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . SAME , handlerWithError ) ; serviceB . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . SAME , handler ) ; serviceB . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . SAME , handlerWithError ) ; final Tracer tracer = new Tracer ( ) ; serviceA . addTracer ( tracer ) ; serviceB . addTracer ( tracer ) ; tracer . reset ( <int> ) ; boolean timeout = randomBoolean ( ) ; TransportRequestOptions options = timeout ? TransportRequestOptions . builder ( ) . withTimeout ( <int> ) . build ( ) : TransportRequestOptions . EMPTY ; serviceA . sendRequest ( nodeB , <str> , new StringMessageRequest ( <str> , <int> ) , options , noopResponseHandler ) ; requestCompleted . acquire ( ) ; tracer . expectedEvents . get ( ) . await ( ) ; assertThat ( <str> , tracer . sawRequestSent , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawRequestReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseSent , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawErrorSent , equalTo ( false ) ) ; tracer . reset ( <int> ) ; serviceA . sendRequest ( nodeB , <str> , new StringMessageRequest ( <str> ) , noopResponseHandler ) ; requestCompleted . acquire ( ) ; tracer . expectedEvents . get ( ) . await ( ) ; assertThat ( <str> , tracer . sawRequestSent , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawRequestReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseSent , equalTo ( false ) ) ; assertThat ( <str> , tracer . sawResponseReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawErrorSent , equalTo ( true ) ) ; String includeSettings ; String excludeSettings ; if ( randomBoolean ( ) ) { includeSettings = randomBoolean ( ) ? <str> : <str> ; excludeSettings = <str> ; } else { includeSettings = <str> ; excludeSettings = <str> ; } serviceA . applySettings ( Settings . builder ( ) . put ( TransportService . SETTING_TRACE_LOG_INCLUDE , includeSettings , TransportService . SETTING_TRACE_LOG_EXCLUDE , excludeSettings ) . build ( ) ) ; tracer . reset ( <int> ) ; serviceA . sendRequest ( nodeB , <str> , new StringMessageRequest ( <str> ) , noopResponseHandler ) ; requestCompleted . acquire ( ) ; tracer . expectedEvents . get ( ) . await ( ) ; assertThat ( <str> , tracer . sawRequestSent , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawRequestReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseSent , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawErrorSent , equalTo ( false ) ) ; tracer . reset ( <int> ) ; serviceA . sendRequest ( nodeB , <str> , new StringMessageRequest ( <str> ) , noopResponseHandler ) ; requestCompleted . acquire ( ) ; tracer . expectedEvents . get ( ) . await ( ) ; assertThat ( <str> , tracer . sawRequestSent , equalTo ( false ) ) ; assertThat ( <str> , tracer . sawRequestReceived , equalTo ( true ) ) ; assertThat ( <str> , tracer . sawResponseSent , equalTo ( false ) ) ; assertThat ( <str> , tracer . sawResponseReceived , equalTo ( false ) ) ; assertThat ( <str> , tracer . sawErrorSent , equalTo ( true ) ) ; } private static class Tracer extends MockTransportService . Tracer { public volatile boolean sawRequestSent ; public volatile boolean sawRequestReceived ; public volatile boolean sawResponseSent ; public volatile boolean sawErrorSent ; public volatile boolean sawResponseReceived ; public AtomicReference < CountDownLatch > expectedEvents = new AtomicReference < > ( ) ; @Override public void receivedRequest ( long requestId , String action ) { super . receivedRequest ( requestId , action ) ; sawRequestReceived = true ; expectedEvents . get ( ) . countDown ( ) ; } @Override public void requestSent ( DiscoveryNode node , long requestId , String action , TransportRequestOptions options ) { super . requestSent ( node , requestId , action , options ) ; sawRequestSent = true ; expectedEvents . get ( ) . countDown ( ) ; } @Override public void responseSent ( long requestId , String action ) { super . responseSent ( requestId , action ) ; sawResponseSent = true ; expectedEvents . get ( ) . countDown ( ) ; } @Override public void responseSent ( long requestId , String action , Throwable t ) { super . responseSent ( requestId , action , t ) ; sawErrorSent = true ; expectedEvents . get ( ) . countDown ( ) ; } @Override public void receivedResponse ( long requestId , DiscoveryNode sourceNode , String action ) { super . receivedResponse ( requestId , sourceNode , action ) ; sawResponseReceived = true ; expectedEvents . get ( ) . countDown ( ) ; } public void reset ( int expectedCount ) { sawRequestSent = false ; sawRequestReceived = false ; sawResponseSent = false ; sawErrorSent = false ; sawResponseReceived = false ; expectedEvents . set ( new CountDownLatch ( expectedCount ) ) ; } } public static class StringMessageRequest extends TransportRequest { private String message ; private long timeout ; StringMessageRequest ( String message , long timeout ) { this . message = message ; this . timeout = timeout ; } public StringMessageRequest ( ) { } public StringMessageRequest ( String message ) { this ( message , - <int> ) ; } public long timeout ( ) { return timeout ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; message = in . readString ( ) ; timeout = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( message ) ; out . writeLong ( timeout ) ; } } static class StringMessageResponse extends TransportResponse { private String message ; StringMessageResponse ( String message ) { this . message = message ; } StringMessageResponse ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; message = in . readString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( message ) ; } } public static class Version0Request extends TransportRequest { int value1 ; @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; value1 = in . readInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( value1 ) ; } } public static class Version1Request extends Version0Request { int value2 ; @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; if ( in . getVersion ( ) . onOrAfter ( version1 ) ) { value2 = in . readInt ( ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; if ( out . getVersion ( ) . onOrAfter ( version1 ) ) { out . writeInt ( value2 ) ; } } } static class Version0Response extends TransportResponse { int value1 ; @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; value1 = in . readInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( value1 ) ; } } static class Version1Response extends Version0Response { int value2 ; @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; if ( in . getVersion ( ) . onOrAfter ( version1 ) ) { value2 = in . readInt ( ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; if ( out . getVersion ( ) . onOrAfter ( version1 ) ) { out . writeInt ( value2 ) ; } } } public void testVersionFrom0to1 ( ) throws Exception { serviceB . registerRequestHandler ( <str> , Version1Request : : new , ThreadPool . Names . SAME , new TransportRequestHandler < Version1Request > ( ) { @Override public void messageReceived ( Version1Request request , TransportChannel channel ) throws Exception { assertThat ( request . value1 , equalTo ( <int> ) ) ; assertThat ( request . value2 , equalTo ( <int> ) ) ; Version1Response response = new Version1Response ( ) ; response . value1 = <int> ; response . value2 = <int> ; channel . sendResponse ( response ) ; } } ) ; Version0Request version0Request = new Version0Request ( ) ; version0Request . value1 = <int> ; Version0Response version0Response = serviceA . submitRequest ( nodeB , <str> , version0Request , new BaseTransportResponseHandler < Version0Response > ( ) { @Override public Version0Response newInstance ( ) { return new Version0Response ( ) ; } @Override public void handleResponse ( Version0Response response ) { assertThat ( response . value1 , equalTo ( <int> ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; fail ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) . txGet ( ) ; assertThat ( version0Response . value1 , equalTo ( <int> ) ) ; } public void testVersionFrom1to0 ( ) throws Exception { serviceA . registerRequestHandler ( <str> , Version0Request : : new , ThreadPool . Names . SAME , new TransportRequestHandler < Version0Request > ( ) { @Override public void messageReceived ( Version0Request request , TransportChannel channel ) throws Exception { assertThat ( request . value1 , equalTo ( <int> ) ) ; Version0Response response = new Version0Response ( ) ; response . value1 = <int> ; channel . sendResponse ( response ) ; } } ) ; Version1Request version1Request = new Version1Request ( ) ; version1Request . value1 = <int> ; version1Request . value2 = <int> ; Version1Response version1Response = serviceB . submitRequest ( nodeA , <str> , version1Request , new BaseTransportResponseHandler < Version1Response > ( ) { @Override public Version1Response newInstance ( ) { return new Version1Response ( ) ; } @Override public void handleResponse ( Version1Response response ) { assertThat ( response . value1 , equalTo ( <int> ) ) ; assertThat ( response . value2 , equalTo ( <int> ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; fail ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) . txGet ( ) ; assertThat ( version1Response . value1 , equalTo ( <int> ) ) ; assertThat ( version1Response . value2 , equalTo ( <int> ) ) ; } public void testVersionFrom1to1 ( ) throws Exception { serviceB . registerRequestHandler ( <str> , Version1Request : : new , ThreadPool . Names . SAME , new TransportRequestHandler < Version1Request > ( ) { @Override public void messageReceived ( Version1Request request , TransportChannel channel ) throws Exception { assertThat ( request . value1 , equalTo ( <int> ) ) ; assertThat ( request . value2 , equalTo ( <int> ) ) ; Version1Response response = new Version1Response ( ) ; response . value1 = <int> ; response . value2 = <int> ; channel . sendResponse ( response ) ; } } ) ; Version1Request version1Request = new Version1Request ( ) ; version1Request . value1 = <int> ; version1Request . value2 = <int> ; Version1Response version1Response = serviceB . submitRequest ( nodeB , <str> , version1Request , new BaseTransportResponseHandler < Version1Response > ( ) { @Override public Version1Response newInstance ( ) { return new Version1Response ( ) ; } @Override public void handleResponse ( Version1Response response ) { assertThat ( response . value1 , equalTo ( <int> ) ) ; assertThat ( response . value2 , equalTo ( <int> ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; fail ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) . txGet ( ) ; assertThat ( version1Response . value1 , equalTo ( <int> ) ) ; assertThat ( version1Response . value2 , equalTo ( <int> ) ) ; } public void testVersionFrom0to0 ( ) throws Exception { serviceA . registerRequestHandler ( <str> , Version0Request : : new , ThreadPool . Names . SAME , new TransportRequestHandler < Version0Request > ( ) { @Override public void messageReceived ( Version0Request request , TransportChannel channel ) throws Exception { assertThat ( request . value1 , equalTo ( <int> ) ) ; Version0Response response = new Version0Response ( ) ; response . value1 = <int> ; channel . sendResponse ( response ) ; } } ) ; Version0Request version0Request = new Version0Request ( ) ; version0Request . value1 = <int> ; Version0Response version0Response = serviceA . submitRequest ( nodeA , <str> , version0Request , new BaseTransportResponseHandler < Version0Response > ( ) { @Override public Version0Response newInstance ( ) { return new Version0Response ( ) ; } @Override public void handleResponse ( Version0Response response ) { assertThat ( response . value1 , equalTo ( <int> ) ) ; } @Override public void handleException ( TransportException exp ) { exp . printStackTrace ( ) ; fail ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) . txGet ( ) ; assertThat ( version0Response . value1 , equalTo ( <int> ) ) ; } public void testMockFailToSendNoConnectRule ( ) { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) throws Exception { assertThat ( <str> , equalTo ( request . message ) ) ; throw new RuntimeException ( <str> ) ; } } ) ; serviceB . addFailToSendNoConnectRule ( serviceA ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { fail ( <str> ) ; } @Override public void handleException ( TransportException exp ) { assertThat ( exp . getCause ( ) . getMessage ( ) , endsWith ( <str> ) ) ; } } ) ; try { res . txGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e . getCause ( ) . getMessage ( ) , endsWith ( <str> ) ) ; } try { serviceB . connectToNode ( nodeA ) ; fail ( <str> ) ; } catch ( ConnectTransportException e ) { } try { serviceB . connectToNodeLight ( nodeA ) ; fail ( <str> ) ; } catch ( ConnectTransportException e ) { } serviceA . removeHandler ( <str> ) ; } public void testMockUnresponsiveRule ( ) { serviceA . registerRequestHandler ( <str> , StringMessageRequest : : new , ThreadPool . Names . GENERIC , new TransportRequestHandler < StringMessageRequest > ( ) { @Override public void messageReceived ( StringMessageRequest request , TransportChannel channel ) throws Exception { assertThat ( <str> , equalTo ( request . message ) ) ; throw new RuntimeException ( <str> ) ; } } ) ; serviceB . addUnresponsiveRule ( serviceA ) ; TransportFuture < StringMessageResponse > res = serviceB . submitRequest ( nodeA , <str> , new StringMessageRequest ( <str> ) , TransportRequestOptions . builder ( ) . withTimeout ( <int> ) . build ( ) , new BaseTransportResponseHandler < StringMessageResponse > ( ) { @Override public StringMessageResponse newInstance ( ) { return new StringMessageResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . GENERIC ; } @Override public void handleResponse ( StringMessageResponse response ) { fail ( <str> ) ; } @Override public void handleException ( TransportException exp ) { assertThat ( exp , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } } ) ; try { res . txGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e , instanceOf ( ReceiveTimeoutTransportException . class ) ) ; } try { serviceB . connectToNode ( nodeA ) ; fail ( <str> ) ; } catch ( ConnectTransportException e ) { } try { serviceB . connectToNodeLight ( nodeA ) ; fail ( <str> ) ; } catch ( ConnectTransportException e ) { } serviceA . removeHandler ( <str> ) ; } public void testHostOnMessages ( ) throws InterruptedException { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicReference < TransportAddress > addressA = new AtomicReference < > ( ) ; final AtomicReference < TransportAddress > addressB = new AtomicReference < > ( ) ; serviceB . registerRequestHandler ( <str> , TestRequest : : new , ThreadPool . Names . SAME , new TransportRequestHandler < TestRequest > ( ) { @Override public void messageReceived ( TestRequest request , TransportChannel channel ) throws Exception { addressA . set ( request . remoteAddress ( ) ) ; channel . sendResponse ( new TestResponse ( ) ) ; latch . countDown ( ) ; } } ) ; serviceA . sendRequest ( nodeB , <str> , new TestRequest ( ) , new TransportResponseHandler < TestResponse > ( ) { @Override public TestResponse newInstance ( ) { return new TestResponse ( ) ; } @Override public void handleResponse ( TestResponse response ) { addressB . set ( response . remoteAddress ( ) ) ; latch . countDown ( ) ; } @Override public void handleException ( TransportException exp ) { latch . countDown ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } assertTrue ( nodeA . address ( ) . sameHost ( addressA . get ( ) ) ) ; assertTrue ( nodeB . address ( ) . sameHost ( addressB . get ( ) ) ) ; } public static class TestRequest extends TransportRequest { } private static class TestResponse extends TransportResponse { } } 
