package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . InternalContext ; import org . elasticsearch . common . inject . internal . InternalFactory ; import org . elasticsearch . common . inject . internal . PrivateElementsImpl ; import org . elasticsearch . common . inject . internal . ProviderInstanceBindingImpl ; import org . elasticsearch . common . inject . internal . Scoping ; import org . elasticsearch . common . inject . internal . SourceProvider ; import org . elasticsearch . common . inject . internal . Stopwatch ; import org . elasticsearch . common . inject . spi . Dependency ; import org . elasticsearch . common . inject . spi . Element ; import org . elasticsearch . common . inject . spi . Elements ; import org . elasticsearch . common . inject . spi . InjectionPoint ; import org . elasticsearch . common . inject . spi . PrivateElements ; import org . elasticsearch . common . inject . spi . TypeListenerBinding ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; import java . util . logging . Logger ; import static java . util . Collections . emptySet ; import static org . elasticsearch . common . inject . Scopes . SINGLETON ; class InjectorShell { private final List < Element > elements ; private final InjectorImpl injector ; private final PrivateElements privateElements ; private InjectorShell ( Builder builder , List < Element > elements , InjectorImpl injector ) { this . privateElements = builder . privateElements ; this . elements = elements ; this . injector = injector ; } PrivateElements getPrivateElements ( ) { return privateElements ; } InjectorImpl getInjector ( ) { return injector ; } List < Element > getElements ( ) { return elements ; } static class Builder { private final List < Element > elements = new ArrayList < > ( ) ; private final List < Module > modules = new ArrayList < > ( ) ; private State state ; private InjectorImpl parent ; private Stage stage ; private PrivateElementsImpl privateElements ; Builder parent ( InjectorImpl parent ) { this . parent = parent ; this . state = new InheritingState ( parent . state ) ; return this ; } Builder stage ( Stage stage ) { this . stage = stage ; return this ; } Builder privateElements ( PrivateElements privateElements ) { this . privateElements = ( PrivateElementsImpl ) privateElements ; this . elements . addAll ( privateElements . getElements ( ) ) ; return this ; } void addModules ( Iterable < ? extends Module > modules ) { for ( Module module : modules ) { this . modules . add ( module ) ; } } Object lock ( ) { return getState ( ) . lock ( ) ; } List < InjectorShell > build ( Initializer initializer , BindingProcessor bindingProcessor , Stopwatch stopwatch , Errors errors ) { if ( stage = = null ) { throw new IllegalStateException ( <str> ) ; } if ( privateElements ! = null & & parent = = null ) { throw new IllegalStateException ( <str> ) ; } if ( state = = null ) { throw new IllegalStateException ( <str> ) ; } InjectorImpl injector = new InjectorImpl ( parent , state , initializer ) ; if ( privateElements ! = null ) { privateElements . initInjector ( injector ) ; } if ( parent = = null ) { modules . add ( <int> , new RootModule ( stage ) ) ; new TypeConverterBindingProcessor ( errors ) . prepareBuiltInConverters ( injector ) ; } elements . addAll ( Elements . getElements ( stage , modules ) ) ; stopwatch . resetAndLog ( <str> ) ; new MessageProcessor ( errors ) . process ( injector , elements ) ; new TypeListenerBindingProcessor ( errors ) . process ( injector , elements ) ; List < TypeListenerBinding > listenerBindings = injector . state . getTypeListenerBindings ( ) ; injector . membersInjectorStore = new MembersInjectorStore ( injector , listenerBindings ) ; stopwatch . resetAndLog ( <str> ) ; new ScopeBindingProcessor ( errors ) . process ( injector , elements ) ; stopwatch . resetAndLog ( <str> ) ; new TypeConverterBindingProcessor ( errors ) . process ( injector , elements ) ; stopwatch . resetAndLog ( <str> ) ; bindInjector ( injector ) ; bindLogger ( injector ) ; bindingProcessor . process ( injector , elements ) ; stopwatch . resetAndLog ( <str> ) ; List < InjectorShell > injectorShells = new ArrayList < > ( ) ; injectorShells . add ( new InjectorShell ( this , elements , injector ) ) ; PrivateElementProcessor processor = new PrivateElementProcessor ( errors , stage ) ; processor . process ( injector , elements ) ; for ( Builder builder : processor . getInjectorShellBuilders ( ) ) { injectorShells . addAll ( builder . build ( initializer , bindingProcessor , stopwatch , errors ) ) ; } stopwatch . resetAndLog ( <str> ) ; return injectorShells ; } private State getState ( ) { if ( state = = null ) { state = new InheritingState ( State . NONE ) ; } return state ; } } private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , emptySet ( ) ) ) ; } private static class InjectorFactory implements InternalFactory < Injector > , Provider < Injector > { private final Injector injector ; private InjectorFactory ( Injector injector ) { this . injector = injector ; } @Override public Injector get ( Errors errors , InternalContext context , Dependency < ? > dependency ) throws ErrorsException { return injector ; } @Override public Injector get ( ) { return injector ; } @Override public String toString ( ) { return <str> ; } } private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , emptySet ( ) ) ) ; } private static class LoggerFactory implements InternalFactory < Logger > , Provider < Logger > { @Override public Logger get ( Errors errors , InternalContext context , Dependency < ? > dependency ) { InjectionPoint injectionPoint = dependency . getInjectionPoint ( ) ; return injectionPoint = = null ? Logger . getAnonymousLogger ( ) : Logger . getLogger ( injectionPoint . getMember ( ) . getDeclaringClass ( ) . getName ( ) ) ; } @Override public Logger get ( ) { return Logger . getAnonymousLogger ( ) ; } @Override public String toString ( ) { return <str> ; } } private static class RootModule implements Module { final Stage stage ; private RootModule ( Stage stage ) { this . stage = Objects . requireNonNull ( stage , <str> ) ; } @Override public void configure ( Binder binder ) { binder = binder . withSource ( SourceProvider . UNKNOWN_SOURCE ) ; binder . bind ( Stage . class ) . toInstance ( stage ) ; binder . bindScope ( Singleton . class , SINGLETON ) ; } } } 
