package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . DerivedComparable ; import com . google . common . collect . testing . Helpers ; import com . google . common . collect . testing . NavigableMapTestSuiteBuilder ; import com . google . common . collect . testing . NavigableSetTestSuiteBuilder ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . TestSortedMapGenerator ; import com . google . common . collect . testing . TestStringSetGenerator ; import com . google . common . collect . testing . TestStringSortedSetGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . SortedSetMultimapTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringSetMultimapGenerator ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NavigableMap ; import java . util . NavigableSet ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; @GwtCompatible ( emulated = true ) public class TreeMultimapNaturalTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SortedSetMultimapTestSuiteBuilder . using ( new TestStringSetMultimapGenerator ( ) { @Override protected SetMultimap < String , String > create ( Entry < String , String > [ ] entries ) { SetMultimap < String , String > multimap = TreeMultimap . create ( Ordering . natural ( ) . nullsFirst ( ) , Ordering . natural ( ) . nullsFirst ( ) ) ; for ( Entry < String , String > entry : entries ) { multimap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return multimap ; } @Override public Iterable < Entry < String , String > > order ( List < Entry < String , String > > insertionOrder ) { return new Ordering < Entry < String , String > > ( ) { @Override public int compare ( Entry < String , String > left , Entry < String , String > right ) { return ComparisonChain . start ( ) . compare ( left . getKey ( ) , right . getKey ( ) , Ordering . natural ( ) . nullsFirst ( ) ) . compare ( left . getValue ( ) , right . getValue ( ) , Ordering . natural ( ) . nullsFirst ( ) ) . result ( ) ; } } . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( MapFeature . ALLOWS_NULL_KEYS , MapFeature . ALLOWS_NULL_VALUES , MapFeature . ALLOWS_ANY_NULL_QUERIES , MapFeature . GENERAL_PURPOSE , MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new TestStringSortedSetGenerator ( ) { @Override protected NavigableSet < String > create ( String [ ] elements ) { TreeMultimap < String , Integer > multimap = TreeMultimap . create ( Ordering . natural ( ) . nullsFirst ( ) , Ordering . natural ( ) ) ; for ( int i = <int> ; i < elements . length ; i + + ) { multimap . put ( elements [ i ] , i ) ; } return multimap . keySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . nullsFirst ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . REMOVE_OPERATIONS , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTest ( NavigableMapTestSuiteBuilder . using ( new TestSortedMapGenerator < String , Collection < String > > ( ) { @Override public String [ ] createKeyArray ( int length ) { return new String [ length ] ; } @SuppressWarnings ( <str> ) @Override public Collection < String > [ ] createValueArray ( int length ) { return new Collection [ length ] ; } @Override public SampleElements < Entry < String , Collection < String > > > samples ( ) { return new SampleElements < Entry < String , Collection < String > > > ( Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> ) ) , Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> , <str> ) ) , Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> , <str> ) ) , Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> , <str> ) ) , Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> , <str> ) ) ) ; } @SuppressWarnings ( <str> ) @Override public Entry < String , Collection < String > > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < String , Collection < String > > > order ( List < Entry < String , Collection < String > > > insertionOrder ) { return new Ordering < Entry < String , ? > > ( ) { @Override public int compare ( Entry < String , ? > left , Entry < String , ? > right ) { return left . getKey ( ) . compareTo ( right . getKey ( ) ) ; } } . sortedCopy ( insertionOrder ) ; } @Override public NavigableMap < String , Collection < String > > create ( Object . . . elements ) { TreeMultimap < String , String > multimap = TreeMultimap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( <str> ) Entry < String , Collection < String > > entry = ( Entry < String , Collection < String > > ) o ; checkArgument ( ! multimap . containsKey ( entry . getKey ( ) ) ) ; multimap . putAll ( entry . getKey ( ) , entry . getValue ( ) ) ; } return multimap . asMap ( ) ; } @Override public Entry < String , Collection < String > > belowSamplesLesser ( ) { return Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> ) ) ; } @Override public Entry < String , Collection < String > > belowSamplesGreater ( ) { return Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> ) ) ; } @Override public Entry < String , Collection < String > > aboveSamplesLesser ( ) { return Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> ) ) ; } @Override public Entry < String , Collection < String > > aboveSamplesGreater ( ) { return Helpers . mapEntry ( <str> , ( Collection < String > ) ImmutableSortedSet . of ( <str> ) ) ; } } ) . named ( <str> ) . withFeatures ( MapFeature . SUPPORTS_REMOVE , MapFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { TreeMultimap < Integer , String > multimap = TreeMultimap . create ( Ordering . natural ( ) , Ordering . natural ( ) . nullsFirst ( ) ) ; multimap . putAll ( <int> , Arrays . asList ( elements ) ) ; return multimap . get ( <int> ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . nullsFirst ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { TreeMultimap < Integer , String > multimap = TreeMultimap . create ( Ordering . natural ( ) , Ordering . natural ( ) . nullsFirst ( ) ) ; multimap . putAll ( <int> , Arrays . asList ( elements ) ) ; return ( Set < String > ) multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . nullsFirst ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . KNOWN_ORDER , CollectionSize . ONE , CollectionSize . SEVERAL ) . createTestSuite ( ) ) ; suite . addTestSuite ( TreeMultimapNaturalTest . class ) ; return suite ; } protected SetMultimap < String , Integer > create ( ) { return TreeMultimap . create ( ) ; } private TreeMultimap < String , Integer > createPopulate ( ) { TreeMultimap < String , Integer > multimap = TreeMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; return multimap ; } public void testToString ( ) { SetMultimap < String , Integer > multimap = create ( ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> , - <int> , <int> ) ) ; assertEquals ( <str> , multimap . toString ( ) ) ; } public void testOrderedGet ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testOrderedKeySet ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testOrderedAsMapEntries ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; Iterator < Map . Entry < String , Collection < Integer > > > iterator = multimap . asMap ( ) . entrySet ( ) . iterator ( ) ; Map . Entry < String , Collection < Integer > > entry = iterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> , <int> ) ; entry = iterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> ) ; entry = iterator . next ( ) ; assertEquals ( <str> , entry . getKey ( ) ) ; assertThat ( entry . getValue ( ) ) . containsExactly ( <int> , <int> ) ; } public void testOrderedEntries ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; assertThat ( multimap . entries ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } public void testOrderedValues ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testMultimapConstructor ( ) { SetMultimap < String , Integer > multimap = create ( ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> , - <int> , <int> ) ) ; TreeMultimap < String , Integer > copy = TreeMultimap . create ( multimap ) ; assertEquals ( multimap , copy ) ; } private static final Comparator < Double > KEY_COMPARATOR = Ordering . natural ( ) ; private static final Comparator < Double > VALUE_COMPARATOR = Ordering . natural ( ) . reverse ( ) . nullsFirst ( ) ; public void testCreateFromTreeMultimap ( ) { Multimap < Double , Double > tree = TreeMultimap . create ( KEY_COMPARATOR , VALUE_COMPARATOR ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; TreeMultimap < Double , Double > copyFromTree = TreeMultimap . create ( tree ) ; assertEquals ( tree , copyFromTree ) ; assertSame ( Ordering . natural ( ) , copyFromTree . keyComparator ( ) ) ; assertSame ( Ordering . natural ( ) , copyFromTree . valueComparator ( ) ) ; assertSame ( Ordering . natural ( ) , copyFromTree . get ( <float> ) . comparator ( ) ) ; } public void testCreateFromHashMultimap ( ) { Multimap < Double , Double > hash = HashMultimap . create ( ) ; hash . put ( <float> , <float> ) ; hash . put ( <float> , <float> ) ; hash . put ( <float> , <float> ) ; hash . put ( <float> , <float> ) ; TreeMultimap < Double , Double > copyFromHash = TreeMultimap . create ( hash ) ; assertEquals ( hash , copyFromHash ) ; assertEquals ( Ordering . natural ( ) , copyFromHash . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , copyFromHash . valueComparator ( ) ) ; } public void testCreateFromSortedSetMultimap ( ) { SortedSetMultimap < Double , Double > tree = TreeMultimap . create ( KEY_COMPARATOR , VALUE_COMPARATOR ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; tree . put ( <float> , <float> ) ; SortedSetMultimap < Double , Double > sorted = Multimaps . unmodifiableSortedSetMultimap ( tree ) ; TreeMultimap < Double , Double > copyFromSorted = TreeMultimap . create ( sorted ) ; assertEquals ( tree , copyFromSorted ) ; assertSame ( Ordering . natural ( ) , copyFromSorted . keyComparator ( ) ) ; assertSame ( Ordering . natural ( ) , copyFromSorted . valueComparator ( ) ) ; assertSame ( Ordering . natural ( ) , copyFromSorted . get ( <float> ) . comparator ( ) ) ; } public void testComparators ( ) { TreeMultimap < String , Integer > multimap = TreeMultimap . create ( ) ; assertEquals ( Ordering . natural ( ) , multimap . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , multimap . valueComparator ( ) ) ; } @GwtIncompatible ( <str> ) public void testExplicitComparatorSerialization ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; TreeMultimap < String , Integer > copy = SerializableTester . reserializeAndAssert ( multimap ) ; assertThat ( copy . values ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( copy . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertEquals ( multimap . keyComparator ( ) , copy . keyComparator ( ) ) ; assertEquals ( multimap . valueComparator ( ) , copy . valueComparator ( ) ) ; } @GwtIncompatible ( <str> ) public void testTreeMultimapDerived ( ) { TreeMultimap < DerivedComparable , DerivedComparable > multimap = TreeMultimap . create ( ) ; assertEquals ( ImmutableMultimap . of ( ) , multimap ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; multimap . put ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) . inOrder ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) , new DerivedComparable ( <str> ) ) . inOrder ( ) ; assertEquals ( Ordering . natural ( ) , multimap . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , multimap . valueComparator ( ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; } @GwtIncompatible ( <str> ) public void testTreeMultimapNonGeneric ( ) { TreeMultimap < LegacyComparable , LegacyComparable > multimap = TreeMultimap . create ( ) ; assertEquals ( ImmutableMultimap . of ( ) , multimap ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; multimap . put ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; assertThat ( multimap . keySet ( ) ) . containsExactly ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) . inOrder ( ) ; assertThat ( multimap . values ( ) ) . containsExactly ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) . inOrder ( ) ; assertEquals ( Ordering . natural ( ) , multimap . keyComparator ( ) ) ; assertEquals ( Ordering . natural ( ) , multimap . valueComparator ( ) ) ; SerializableTester . reserializeAndAssert ( multimap ) ; } public void testTreeMultimapAsMapSorted ( ) { TreeMultimap < String , Integer > multimap = createPopulate ( ) ; SortedMap < String , Collection < Integer > > asMap = multimap . asMap ( ) ; assertEquals ( Ordering . natural ( ) , asMap . comparator ( ) ) ; assertEquals ( <str> , asMap . firstKey ( ) ) ; assertEquals ( <str> , asMap . lastKey ( ) ) ; Set < Integer > fooValues = ImmutableSet . of ( <int> , <int> , <int> ) ; Set < Integer > googleValues = ImmutableSet . of ( <int> , <int> ) ; Set < Integer > treeValues = ImmutableSet . of ( <int> , <int> ) ; assertEquals ( ImmutableMap . of ( <str> , googleValues , <str> , treeValues ) , asMap . tailMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , googleValues , <str> , fooValues ) , asMap . headMap ( <str> ) ) ; assertEquals ( ImmutableMap . of ( <str> , googleValues ) , asMap . subMap ( <str> , <str> ) ) ; } public void testTailSetClear ( ) { TreeMultimap < String , Integer > multimap = TreeMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . keySet ( ) . tailSet ( <str> ) . clear ( ) ; assertEquals ( ImmutableSet . of ( <str> , <str> , <str> ) , multimap . keySet ( ) ) ; assertEquals ( <int> , multimap . size ( ) ) ; assertEquals ( <int> , multimap . values ( ) . size ( ) ) ; assertEquals ( <int> , multimap . keys ( ) . size ( ) ) ; } @GwtIncompatible ( <str> ) public void testKeySetBridgeMethods ( ) { for ( Method m : TreeMultimap . class . getMethods ( ) ) { if ( m . getName ( ) . equals ( <str> ) & & m . getReturnType ( ) . equals ( SortedSet . class ) ) { return ; } } fail ( <str> ) ; } @GwtIncompatible ( <str> ) public void testAsMapBridgeMethods ( ) { for ( Method m : TreeMultimap . class . getMethods ( ) ) { if ( m . getName ( ) . equals ( <str> ) & & m . getReturnType ( ) . equals ( SortedMap . class ) ) { return ; } } } @GwtIncompatible ( <str> ) public void testGetBridgeMethods ( ) { for ( Method m : TreeMultimap . class . getMethods ( ) ) { if ( m . getName ( ) . equals ( <str> ) & & m . getReturnType ( ) . equals ( SortedSet . class ) ) { return ; } } fail ( <str> ) ; } } 
