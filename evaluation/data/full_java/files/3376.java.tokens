package org . nd4j . linalg . jcublas . context ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import com . google . common . collect . * ; import jcuda . jcublas . JCublas2 ; import jcuda . jcublas . cublasHandle ; import jcuda . CudaException ; import jcuda . driver . CUcontext ; import jcuda . driver . CUdevice ; import jcuda . driver . CUresult ; import jcuda . driver . CUstream ; import jcuda . driver . CUstream_flags ; import jcuda . driver . JCudaDriver ; import jcuda . jcufft . JCufft ; import jcuda . runtime . JCuda ; import jcuda . runtime . cudaStream_t ; import org . nd4j . linalg . api . buffer . allocation . MemoryStrategy ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . jcublas . device . conf . DeviceConfiguration ; import org . nd4j . linalg . jcublas . fft . JcudaFft ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . nd4j . linalg . io . ClassPathResource ; import static jcuda . driver . JCudaDriver . * ; public class ContextHolder { private Map < Integer , CUdevice > devices = new ConcurrentHashMap < > ( ) ; private Map < Integer , GpuInformation > info = new ConcurrentHashMap < > ( ) ; private Map < Integer , CUcontext > deviceIDContexts = new ConcurrentHashMap < > ( ) ; private Map < String , Integer > threadNameToDeviceNumber = new ConcurrentHashMap < > ( ) ; private Table < CUcontext , String , CUstream > contextStreams = HashBasedTable . create ( ) ; private Table < CUcontext , String , cudaStream_t > cudaStreams = HashBasedTable . create ( ) ; private Map < String , cublasHandle > handleMap = new ConcurrentHashMap < > ( ) ; private List < Integer > bannedDevices ; private int numDevices = <int> ; private Map < Integer , DeviceConfiguration > confs = new ConcurrentHashMap < > ( ) ; private static ContextHolder INSTANCE ; public final static String DEVICES_TO_BAN = <str> ; public final static String SYNC_THREADS = <str> ; private static boolean syncThreads = true ; private boolean confCalled = false ; private static Logger log = LoggerFactory . getLogger ( ContextHolder . class ) ; private AtomicBoolean shutdown = new AtomicBoolean ( false ) ; private ContextHolder ( ) { try { getNumDevices ( ) ; } catch ( Exception e ) { log . warn ( <str> , e ) ; } } public static synchronized ContextHolder getInstance ( ) { if ( INSTANCE = = null ) { Properties props = new Properties ( ) ; try { props . load ( new ClassPathResource ( <str> , ContextHolder . class . getClassLoader ( ) ) . getInputStream ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } INSTANCE = new ContextHolder ( ) ; INSTANCE . configure ( ) ; for ( String pair : props . stringPropertyNames ( ) ) System . getProperties ( ) . put ( pair , props . getProperty ( pair ) ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { @Override public void run ( ) { INSTANCE . destroy ( ) ; } } ) ) ; } return INSTANCE ; } public int deviceNum ( ) { return numDevices ; } public DeviceConfiguration getConf ( ) { return getConf ( getDeviceForThread ( ) ) ; } public MemoryStrategy getMemoryStrategy ( ) { return getConf ( ) . getMemoryStrategy ( ) ; } public void configure ( ) { if ( confCalled ) return ; syncThreads = Boolean . parseBoolean ( System . getProperty ( SYNC_THREADS , <str> ) ) ; if ( numDevices = = <int> ) { getNumDevices ( ) ; } for ( int i = <int> ; i < numDevices ; i + + ) { ClassPathResource confFile = new ClassPathResource ( <str> + i , ContextHolder . class . getClassLoader ( ) ) ; if ( confFile . exists ( ) ) { Properties props = new Properties ( ) ; try { props . load ( confFile . getInputStream ( ) ) ; confs . put ( i , new DeviceConfiguration ( i , props ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else confs . put ( i , new DeviceConfiguration ( i ) ) ; } confCalled = true ; } public void setNumDevices ( int numDevices ) { this . numDevices = numDevices ; } public DeviceConfiguration getConf ( int device ) { return confs . get ( device ) ; } private void getNumDevices ( ) { JCudaDriver . setExceptionsEnabled ( true ) ; JCudaDriver . cuInit ( <int> ) ; int count [ ] = new int [ <int> ] ; cuDeviceGetCount ( count ) ; numDevices = count [ <int> ] ; log . debug ( <str> + numDevices + <str> ) ; if ( numDevices < <int> ) numDevices = <int> ; bannedDevices = new ArrayList < > ( ) ; String props = System . getProperty ( DEVICES_TO_BAN , <str> ) ; String [ ] split = props . split ( <str> ) ; if ( split . length > = <int> ) for ( String s : split ) { Integer i = Integer . parseInt ( s ) ; if ( i > = <int> ) bannedDevices . add ( Integer . parseInt ( s ) ) ; } } public static void syncStream ( ) { JCudaDriver . cuCtxSetCurrent ( getInstance ( ) . getContext ( ) ) ; JCublas2 . cublasSetStream ( getInstance ( ) . getHandle ( ) , getInstance ( ) . getCudaStream ( ) ) ; JCuda . cudaStreamSynchronize ( getInstance ( ) . getCudaStream ( ) ) ; JCudaDriver . cuStreamSynchronize ( getInstance ( ) . getStream ( ) ) ; } public int getDeviceForThread ( ) { if ( numDevices > <int> ) { Integer device = threadNameToDeviceNumber . get ( Thread . currentThread ( ) . getName ( ) ) ; if ( device = = null ) { org . nd4j . linalg . api . rng . Random random = Nd4j . getRandom ( ) ; if ( random = = null ) throw new IllegalStateException ( <str> ) ; device = Nd4j . getRandom ( ) . nextInt ( numDevices ) ; while ( bannedDevices ! = null & & bannedDevices . contains ( device ) ) device = Nd4j . getRandom ( ) . nextInt ( numDevices ) ; threadNameToDeviceNumber . put ( Thread . currentThread ( ) . getName ( ) , device ) ; return device ; } } return <int> ; } public cublasHandle getHandle ( ) { cublasHandle handle = handleMap . get ( Thread . currentThread ( ) . getName ( ) ) ; if ( handle ! = null ) return handle ; handle = new cublasHandle ( ) ; JCublas2 . cublasCreate ( handle ) ; handleMap . put ( Thread . currentThread ( ) . getName ( ) , handle ) ; return handle ; } public CUcontext getContext ( ) { return getContext ( getDeviceForThread ( ) ) ; } public synchronized cudaStream_t getCudaStream ( ) { Thread currentThread = Thread . currentThread ( ) ; CUcontext ctx = getContext ( getDeviceForThread ( ) ) ; cudaStream_t stream = cudaStreams . get ( ctx , currentThread . getName ( ) ) ; if ( stream = = null ) { stream = new cudaStream_t ( ) ; checkResult ( JCudaDriver . cuCtxSetCurrent ( ctx ) ) ; JCuda . cudaStreamCreate ( stream ) ; checkResult ( JCuda . cudaStreamCreate ( stream ) ) ; cudaStreams . put ( ctx , currentThread . getName ( ) , stream ) ; } return stream ; } public CUstream getStream ( ) { Thread currentThread = Thread . currentThread ( ) ; CUcontext ctx = getContext ( getDeviceForThread ( ) ) ; CUstream stream = contextStreams . get ( ctx , currentThread . getName ( ) ) ; if ( stream = = null ) { stream = new CUstream ( ) ; checkResult ( JCudaDriver . cuCtxSetCurrent ( ctx ) ) ; checkResult ( JCudaDriver . cuStreamCreate ( stream , CUstream_flags . CU_STREAM_NON_BLOCKING ) ) ; contextStreams . put ( ctx , currentThread . getName ( ) , stream ) ; } return stream ; } private void checkResult ( int result ) { if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } } public synchronized CUcontext getContext ( int deviceToUse ) { CUcontext ctx = deviceIDContexts . get ( deviceToUse ) ; if ( ctx = = null ) { ctx = new CUcontext ( ) ; for ( int device = <int> ; device < numDevices ; device + + ) { initialize ( ctx , device ) ; CUdevice currDevice = createDevice ( ctx , device ) ; devices . put ( device , currDevice ) ; info . put ( device , new GpuInformation ( currDevice ) ) ; deviceIDContexts . put ( device , ctx ) ; } } return ctx ; } private void initialize ( CUcontext context , int deviceNumber ) { cuInit ( <int> ) ; cuCtxGetCurrent ( context ) ; CUcontext nullContext = new CUcontext ( ) ; if ( context . equals ( nullContext ) ) createContext ( context , deviceNumber ) ; } private void createContext ( CUcontext context , int deviceNumber ) { CUdevice device = new CUdevice ( ) ; int result = cuDeviceGet ( device , deviceNumber ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } result = cuCtxCreate ( context , <int> , device ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } } public static CUdevice createDevice ( CUcontext context , int deviceNumber ) { CUdevice device = new CUdevice ( ) ; int result = cuDeviceGet ( device , deviceNumber ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } result = cuCtxCreate ( context , <int> , device ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } return device ; } public GpuInformation getInfoFor ( int cUdevice ) { getContext ( cUdevice ) ; return info . get ( cUdevice ) ; } public Map < Integer , CUdevice > getDevices ( ) { return devices ; } public Map < Integer , CUcontext > getDeviceIDContexts ( ) { return deviceIDContexts ; } public synchronized void destroy ( ) { if ( shutdown . get ( ) ) return ; shutdown . set ( true ) ; } } 
