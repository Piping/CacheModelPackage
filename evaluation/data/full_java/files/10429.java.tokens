package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . collect . Table . Cell ; import com . google . common . collect . testing . CollectionTestSuiteBuilder ; import com . google . common . collect . testing . MapInterfaceTest ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . SetTestSuiteBuilder ; import com . google . common . collect . testing . SortedSetTestSuiteBuilder ; import com . google . common . collect . testing . TestSetGenerator ; import com . google . common . collect . testing . TestStringCollectionGenerator ; import com . google . common . collect . testing . TestStringSetGenerator ; import com . google . common . collect . testing . TestStringSortedSetGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . Feature ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; @GwtCompatible ( emulated = true ) public class TableCollectionTest extends TestCase { private static final Feature < ? > [ ] COLLECTION_FEATURES = { CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES } ; private static final Feature < ? > [ ] COLLECTION_FEATURES_ORDER = { CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES } ; private static final Feature < ? > [ ] COLLECTION_FEATURES_REMOVE = { CollectionSize . ANY , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . ALLOWS_NULL_QUERIES } ; private static final Feature < ? > [ ] COLLECTION_FEATURES_REMOVE_ORDER = { CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . ALLOWS_NULL_QUERIES } ; @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ArrayRowTests . class ) ; suite . addTestSuite ( HashRowTests . class ) ; suite . addTestSuite ( TreeRowTests . class ) ; suite . addTestSuite ( TransposeRowTests . class ) ; suite . addTestSuite ( TransformValueRowTests . class ) ; suite . addTestSuite ( UnmodifiableHashRowTests . class ) ; suite . addTestSuite ( UnmodifiableTreeRowTests . class ) ; suite . addTestSuite ( ArrayColumnTests . class ) ; suite . addTestSuite ( HashColumnTests . class ) ; suite . addTestSuite ( TreeColumnTests . class ) ; suite . addTestSuite ( TransposeColumnTests . class ) ; suite . addTestSuite ( TransformValueColumnTests . class ) ; suite . addTestSuite ( UnmodifiableHashColumnTests . class ) ; suite . addTestSuite ( UnmodifiableTreeColumnTests . class ) ; suite . addTestSuite ( ArrayRowMapTests . class ) ; suite . addTestSuite ( HashRowMapTests . class ) ; suite . addTestSuite ( TreeRowMapTests . class ) ; suite . addTestSuite ( TreeRowMapHeadMapTests . class ) ; suite . addTestSuite ( TreeRowMapTailMapTests . class ) ; suite . addTestSuite ( TreeRowMapSubMapTests . class ) ; suite . addTestSuite ( TransformValueRowMapTests . class ) ; suite . addTestSuite ( UnmodifiableHashRowMapTests . class ) ; suite . addTestSuite ( UnmodifiableTreeRowMapTests . class ) ; suite . addTestSuite ( ArrayColumnMapTests . class ) ; suite . addTestSuite ( HashColumnMapTests . class ) ; suite . addTestSuite ( TreeColumnMapTests . class ) ; suite . addTestSuite ( TransformValueColumnMapTests . class ) ; suite . addTestSuite ( UnmodifiableHashColumnMapTests . class ) ; suite . addTestSuite ( UnmodifiableTreeColumnMapTests . class ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = ArrayTable . create ( ImmutableList . copyOf ( elements ) , ImmutableList . of ( <int> , <int> ) ) ; populateForRowKeySet ( table , elements ) ; return table . rowKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . KNOWN_ORDER , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return table . rowKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . withFeatures ( CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( SortedSetTestSuiteBuilder . using ( new TestStringSortedSetGenerator ( ) { @Override protected SortedSet < String > create ( String [ ] elements ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return table . rowKeySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE_ORDER ) . withFeatures ( CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return Tables . unmodifiableTable ( table ) . rowKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { RowSortedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return Tables . unmodifiableRowSortedTable ( table ) . rowKeySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < Integer , String , Character > table = ArrayTable . create ( ImmutableList . of ( <int> , <int> ) , ImmutableList . copyOf ( elements ) ) ; populateForColumnKeySet ( table , elements ) ; return table . columnKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . KNOWN_ORDER , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < Integer , String , Character > table = HashBasedTable . create ( ) ; populateForColumnKeySet ( table , elements ) ; return table . columnKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < Integer , String , Character > table = TreeBasedTable . create ( ) ; populateForColumnKeySet ( table , elements ) ; return table . columnKeySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < Integer , String , Character > table = HashBasedTable . create ( ) ; populateForColumnKeySet ( table , elements ) ; return Tables . unmodifiableTable ( table ) . columnKeySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { RowSortedTable < Integer , String , Character > table = TreeBasedTable . create ( ) ; populateForColumnKeySet ( table , elements ) ; return Tables . unmodifiableRowSortedTable ( table ) . columnKeySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { List < Integer > rowKeys = Lists . newArrayList ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { rowKeys . add ( i ) ; } Table < Integer , Character , String > table = ArrayTable . create ( rowKeys , ImmutableList . of ( <str> ) ) ; populateForValues ( table , elements ) ; return table . values ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . KNOWN_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { Table < Integer , Character , String > table = HashBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . clear ( ) ; populateForValues ( table , elements ) ; return table . values ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . withFeatures ( CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { Table < Integer , Character , String > table = TreeBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . clear ( ) ; populateForValues ( table , elements ) ; return table . values ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE_ORDER ) . withFeatures ( CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; final Function < String , String > removeFirstCharacter = new Function < String , String > ( ) { @Override public String apply ( String input ) { return input . substring ( <int> ) ; } } ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { Table < Integer , Character , String > table = HashBasedTable . create ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { table . put ( i , <str> , <str> + checkNotNull ( elements [ i ] ) ) ; } return Tables . transformValues ( table , removeFirstCharacter ) . values ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . withFeatures ( CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { Table < Integer , Character , String > table = HashBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . clear ( ) ; populateForValues ( table , elements ) ; return Tables . unmodifiableTable ( table ) . values ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new TestStringCollectionGenerator ( ) { @Override protected Collection < String > create ( String [ ] elements ) { RowSortedTable < Integer , Character , String > table = TreeBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . clear ( ) ; populateForValues ( table , elements ) ; return Tables . unmodifiableRowSortedTable ( table ) . values ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override public SampleElements < Cell < String , Integer , Character > > samples ( ) { return new SampleElements < Cell < String , Integer , Character > > ( Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , ( Character ) null ) , Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) ) ; } @Override public Set < Cell < String , Integer , Character > > create ( Object . . . elements ) { List < Integer > columnKeys = Lists . newArrayList ( ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; columnKeys . add ( cell . getColumnKey ( ) ) ; } Table < String , Integer , Character > table = ArrayTable . create ( ImmutableList . of ( <str> ) , columnKeys ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; table . put ( cell . getRowKey ( ) , cell . getColumnKey ( ) , cell . getValue ( ) ) ; } return table . cellSet ( ) ; } @Override Table < String , Integer , Character > createTable ( ) { throw new UnsupportedOperationException ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . KNOWN_ORDER , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override Table < String , Integer , Character > createTable ( ) { return HashBasedTable . create ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REMOVE_OPERATIONS , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override Table < String , Integer , Character > createTable ( ) { return TreeBasedTable . create ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REMOVE_OPERATIONS , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override Table < String , Integer , Character > createTable ( ) { Table < Integer , String , Character > original = TreeBasedTable . create ( ) ; return Tables . transpose ( original ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REMOVE_OPERATIONS , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override Table < String , Integer , Character > createTable ( ) { return HashBasedTable . create ( ) ; } @Override public Set < Cell < String , Integer , Character > > create ( Object . . . elements ) { Table < String , Integer , Character > table = createTable ( ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; table . put ( cell . getRowKey ( ) , cell . getColumnKey ( ) , cell . getValue ( ) ) ; } return Tables . transformValues ( table , Functions . < Character > identity ( ) ) . cellSet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES , CollectionFeature . REMOVE_OPERATIONS ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override Table < String , Integer , Character > createTable ( ) { return Tables . unmodifiableTable ( HashBasedTable . < String , Integer , Character > create ( ) ) ; } @Override public Set < Cell < String , Integer , Character > > create ( Object . . . elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; table . put ( cell . getRowKey ( ) , cell . getColumnKey ( ) , cell . getValue ( ) ) ; } return Tables . unmodifiableTable ( table ) . cellSet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestCellSetGenerator ( ) { @Override RowSortedTable < String , Integer , Character > createTable ( ) { return Tables . unmodifiableRowSortedTable ( TreeBasedTable . < String , Integer , Character > create ( ) ) ; } @Override public Set < Cell < String , Integer , Character > > create ( Object . . . elements ) { RowSortedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; table . put ( cell . getRowKey ( ) , cell . getColumnKey ( ) , cell . getValue ( ) ) ; } return Tables . unmodifiableRowSortedTable ( table ) . cellSet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Iterable < String > rowKeys = ImmutableSet . copyOf ( elements ) ; Iterable < Integer > columnKeys = ImmutableList . of ( <int> , <int> , <int> ) ; Table < String , Integer , Character > table = ArrayTable . create ( rowKeys , columnKeys ) ; populateForRowKeySet ( table , elements ) ; return table . column ( <int> ) . keySet ( ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return table . column ( <int> ) . keySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = TreeBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return table . column ( <int> ) . keySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return Tables . transformValues ( table , Functions . toStringFunction ( ) ) . column ( <int> ) . keySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return Tables . unmodifiableTable ( table ) . column ( <int> ) . keySet ( ) ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { RowSortedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; populateForRowKeySet ( table , elements ) ; return Tables . unmodifiableRowSortedTable ( table ) . column ( <int> ) . keySet ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { Collections . sort ( insertionOrder ) ; return insertionOrder ; } } ) . named ( <str> ) . withFeatures ( COLLECTION_FEATURES_ORDER ) . createTestSuite ( ) ) ; return suite ; } private static void populateForRowKeySet ( Table < String , Integer , Character > table , String [ ] elements ) { for ( String row : elements ) { table . put ( row , <int> , <str> ) ; table . put ( row , <int> , <str> ) ; } } private static void populateForColumnKeySet ( Table < Integer , String , Character > table , String [ ] elements ) { for ( String column : elements ) { table . put ( <int> , column , <str> ) ; table . put ( <int> , column , <str> ) ; } } private static void populateForValues ( Table < Integer , Character , String > table , String [ ] elements ) { for ( int i = <int> ; i < elements . length ; i + + ) { table . put ( i , <str> , elements [ i ] ) ; } } private static abstract class TestCellSetGenerator implements TestSetGenerator < Cell < String , Integer , Character > > { @Override public SampleElements < Cell < String , Integer , Character > > samples ( ) { return new SampleElements < Cell < String , Integer , Character > > ( Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) , Tables . immutableCell ( <str> , <int> , <str> ) ) ; } @Override public Set < Cell < String , Integer , Character > > create ( Object . . . elements ) { Table < String , Integer , Character > table = createTable ( ) ; for ( Object element : elements ) { @SuppressWarnings ( <str> ) Cell < String , Integer , Character > cell = ( Cell < String , Integer , Character > ) element ; table . put ( cell . getRowKey ( ) , cell . getColumnKey ( ) , cell . getValue ( ) ) ; } return table . cellSet ( ) ; } abstract Table < String , Integer , Character > createTable ( ) ; @Override @SuppressWarnings ( <str> ) public Cell < String , Integer , Character > [ ] createArray ( int length ) { return ( Cell < String , Integer , Character > [ ] ) new Cell < ? , ? , ? > [ length ] ; } @Override public List < Cell < String , Integer , Character > > order ( List < Cell < String , Integer , Character > > insertionOrder ) { return insertionOrder ; } } private static abstract class MapTests extends MapInterfaceTest < String , Integer > { MapTests ( boolean allowsNullValues , boolean supportsPut , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( false , allowsNullValues , supportsPut , supportsRemove , supportsClear , supportsIteratorRemove ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } private static abstract class RowTests extends MapTests { RowTests ( boolean allowsNullValues , boolean supportsPut , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( allowsNullValues , supportsPut , supportsRemove , supportsClear , supportsIteratorRemove ) ; } abstract Table < Character , String , Integer > makeTable ( ) ; @Override protected Map < String , Integer > makeEmptyMap ( ) { return makeTable ( ) . row ( <str> ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < Character , String , Integer > table = makeTable ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return table . row ( <str> ) ; } } @GwtIncompatible ( <str> ) public static class ArrayRowTests extends RowTests { public ArrayRowTests ( ) { super ( true , true , false , false , false ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected Map < String , Integer > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected Table < Character , String , Integer > makeTable ( ) { return ArrayTable . create ( Arrays . asList ( <str> , <str> , <str> ) , Arrays . asList ( <str> , <str> , <str> , <str> ) ) ; } } public static class HashRowTests extends RowTests { public HashRowTests ( ) { super ( false , true , true , true , true ) ; } @Override Table < Character , String , Integer > makeTable ( ) { return HashBasedTable . create ( ) ; } } public static class TreeRowTests extends RowTests { public TreeRowTests ( ) { super ( false , true , true , true , true ) ; } @Override Table < Character , String , Integer > makeTable ( ) { return TreeBasedTable . create ( ) ; } } public static class TransposeRowTests extends RowTests { public TransposeRowTests ( ) { super ( false , true , true , true , false ) ; } @Override Table < Character , String , Integer > makeTable ( ) { Table < String , Character , Integer > original = TreeBasedTable . create ( ) ; return Tables . transpose ( original ) ; } } private static final Function < Integer , Integer > DIVIDE_BY_2 = new Function < Integer , Integer > ( ) { @Override public Integer apply ( Integer input ) { return ( input = = null ) ? null : input / <int> ; } } ; public static class TransformValueRowTests extends RowTests { public TransformValueRowTests ( ) { super ( false , false , true , true , true ) ; } @Override Table < Character , String , Integer > makeTable ( ) { Table < Character , String , Integer > table = HashBasedTable . create ( ) ; return Tables . transformValues ( table , DIVIDE_BY_2 ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < Character , String , Integer > table = HashBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . transformValues ( table , DIVIDE_BY_2 ) . row ( <str> ) ; } } public static class UnmodifiableHashRowTests extends RowTests { public UnmodifiableHashRowTests ( ) { super ( false , false , false , false , false ) ; } @Override Table < Character , String , Integer > makeTable ( ) { Table < Character , String , Integer > table = HashBasedTable . create ( ) ; return Tables . unmodifiableTable ( table ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < Character , String , Integer > table = HashBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . unmodifiableTable ( table ) . row ( <str> ) ; } } public static class UnmodifiableTreeRowTests extends RowTests { public UnmodifiableTreeRowTests ( ) { super ( false , false , false , false , false ) ; } @Override Table < Character , String , Integer > makeTable ( ) { RowSortedTable < Character , String , Integer > table = TreeBasedTable . create ( ) ; return Tables . unmodifiableRowSortedTable ( table ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { RowSortedTable < Character , String , Integer > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . unmodifiableRowSortedTable ( table ) . row ( <str> ) ; } } private static abstract class ColumnTests extends MapTests { ColumnTests ( boolean allowsNullValues , boolean supportsPut , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( allowsNullValues , supportsPut , supportsRemove , supportsClear , supportsIteratorRemove ) ; } abstract Table < String , Character , Integer > makeTable ( ) ; @Override protected Map < String , Integer > makeEmptyMap ( ) { return makeTable ( ) . column ( <str> ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < String , Character , Integer > table = makeTable ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return table . column ( <str> ) ; } } @GwtIncompatible ( <str> ) public static class ArrayColumnTests extends ColumnTests { public ArrayColumnTests ( ) { super ( true , true , false , false , false ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected Map < String , Integer > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } @Override Table < String , Character , Integer > makeTable ( ) { return ArrayTable . create ( Arrays . asList ( <str> , <str> , <str> , <str> ) , Arrays . asList ( <str> , <str> , <str> ) ) ; } } public static class HashColumnTests extends ColumnTests { public HashColumnTests ( ) { super ( false , true , true , true , false ) ; } @Override Table < String , Character , Integer > makeTable ( ) { return HashBasedTable . create ( ) ; } } public static class TreeColumnTests extends ColumnTests { public TreeColumnTests ( ) { super ( false , true , true , true , false ) ; } @Override Table < String , Character , Integer > makeTable ( ) { return TreeBasedTable . create ( ) ; } } public static class TransposeColumnTests extends ColumnTests { public TransposeColumnTests ( ) { super ( false , true , true , true , true ) ; } @Override Table < String , Character , Integer > makeTable ( ) { Table < Character , String , Integer > original = TreeBasedTable . create ( ) ; return Tables . transpose ( original ) ; } } public static class TransformValueColumnTests extends ColumnTests { public TransformValueColumnTests ( ) { super ( false , false , true , true , false ) ; } @Override Table < String , Character , Integer > makeTable ( ) { Table < String , Character , Integer > table = HashBasedTable . create ( ) ; return Tables . transformValues ( table , DIVIDE_BY_2 ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < String , Character , Integer > table = HashBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . transformValues ( table , DIVIDE_BY_2 ) . column ( <str> ) ; } } public static class UnmodifiableHashColumnTests extends ColumnTests { public UnmodifiableHashColumnTests ( ) { super ( false , false , false , false , false ) ; } @Override Table < String , Character , Integer > makeTable ( ) { Table < String , Character , Integer > table = HashBasedTable . create ( ) ; return Tables . unmodifiableTable ( table ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { Table < String , Character , Integer > table = HashBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . unmodifiableTable ( table ) . column ( <str> ) ; } } public static class UnmodifiableTreeColumnTests extends ColumnTests { public UnmodifiableTreeColumnTests ( ) { super ( false , false , false , false , false ) ; } @Override Table < String , Character , Integer > makeTable ( ) { RowSortedTable < String , Character , Integer > table = TreeBasedTable . create ( ) ; return Tables . unmodifiableRowSortedTable ( table ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { RowSortedTable < String , Character , Integer > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; table . put ( <str> , <str> , <int> ) ; return Tables . unmodifiableRowSortedTable ( table ) . column ( <str> ) ; } } private static abstract class MapMapTests extends MapInterfaceTest < String , Map < Integer , Character > > { MapMapTests ( boolean allowsNullValues , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( false , allowsNullValues , false , supportsRemove , supportsClear , supportsIteratorRemove ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Map < Integer , Character > getValueNotInPopulatedMap ( ) { return ImmutableMap . of ( ) ; } @Override public void testRemove ( ) { final Map < String , Map < Integer , Character > > map ; final String keyToRemove ; try { map = makePopulatedMap ( ) ; } catch ( UnsupportedOperationException e ) { return ; } keyToRemove = map . keySet ( ) . iterator ( ) . next ( ) ; if ( supportsRemove ) { int initialSize = map . size ( ) ; map . get ( keyToRemove ) ; map . remove ( keyToRemove ) ; assertFalse ( map . containsKey ( keyToRemove ) ) ; assertEquals ( initialSize - <int> , map . size ( ) ) ; } else { try { map . remove ( keyToRemove ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException e ) { } } assertInvariants ( map ) ; } } private static abstract class RowMapTests extends MapMapTests { RowMapTests ( boolean allowsNullValues , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( allowsNullValues , supportsRemove , supportsClear , supportsIteratorRemove ) ; } abstract Table < String , Integer , Character > makeTable ( ) ; @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < String , Integer , Character > table = makeTable ( ) ; populateTable ( table ) ; return table . rowMap ( ) ; } void populateTable ( Table < String , Integer , Character > table ) { table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { return makeTable ( ) . rowMap ( ) ; } } @GwtIncompatible ( <str> ) public static class ArrayRowMapTests extends RowMapTests { public ArrayRowMapTests ( ) { super ( true , false , false , false ) ; } @Override Table < String , Integer , Character > makeTable ( ) { return ArrayTable . create ( Arrays . asList ( <str> , <str> , <str> ) , Arrays . asList ( <int> , <int> , <int> ) ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } } public static class HashRowMapTests extends RowMapTests { public HashRowMapTests ( ) { super ( false , true , true , true ) ; } @Override Table < String , Integer , Character > makeTable ( ) { return HashBasedTable . create ( ) ; } } public static class TreeRowMapTests extends RowMapTests { public TreeRowMapTests ( ) { super ( false , true , true , true ) ; } @Override Table < String , Integer , Character > makeTable ( ) { return TreeBasedTable . create ( ) ; } } public static class TreeRowMapHeadMapTests extends RowMapTests { public TreeRowMapHeadMapTests ( ) { super ( false , true , true , true ) ; } @Override TreeBasedTable < String , Integer , Character > makeTable ( ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; return table ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { TreeBasedTable < String , Integer , Character > table = makeTable ( ) ; populateTable ( table ) ; return table . rowMap ( ) . headMap ( <str> ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { return makeTable ( ) . rowMap ( ) . headMap ( <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } } public static class TreeRowMapTailMapTests extends RowMapTests { public TreeRowMapTailMapTests ( ) { super ( false , true , true , true ) ; } @Override TreeBasedTable < String , Integer , Character > makeTable ( ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; return table ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { TreeBasedTable < String , Integer , Character > table = makeTable ( ) ; populateTable ( table ) ; return table . rowMap ( ) . tailMap ( <str> ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { return makeTable ( ) . rowMap ( ) . tailMap ( <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } } public static class TreeRowMapSubMapTests extends RowMapTests { public TreeRowMapSubMapTests ( ) { super ( false , true , true , true ) ; } @Override TreeBasedTable < String , Integer , Character > makeTable ( ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; return table ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { TreeBasedTable < String , Integer , Character > table = makeTable ( ) ; populateTable ( table ) ; return table . rowMap ( ) . subMap ( <str> , <str> ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { return makeTable ( ) . rowMap ( ) . subMap ( <str> , <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } } private static final Function < String , Character > FIRST_CHARACTER = new Function < String , Character > ( ) { @Override public Character apply ( String input ) { return input = = null ? null : input . charAt ( <int> ) ; } } ; public static class TransformValueRowMapTests extends RowMapTests { public TransformValueRowMapTests ( ) { super ( false , true , true , true ) ; } @Override Table < String , Integer , Character > makeTable ( ) { Table < String , Integer , String > original = HashBasedTable . create ( ) ; return Tables . transformValues ( original , FIRST_CHARACTER ) ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < String , Integer , String > table = HashBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; return Tables . transformValues ( table , FIRST_CHARACTER ) . rowMap ( ) ; } } public static class UnmodifiableHashRowMapTests extends RowMapTests { public UnmodifiableHashRowMapTests ( ) { super ( false , false , false , false ) ; } @Override Table < String , Integer , Character > makeTable ( ) { Table < String , Integer , Character > original = HashBasedTable . create ( ) ; return Tables . unmodifiableTable ( original ) ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < String , Integer , Character > table = HashBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; return Tables . unmodifiableTable ( table ) . rowMap ( ) ; } } public static class UnmodifiableTreeRowMapTests extends RowMapTests { public UnmodifiableTreeRowMapTests ( ) { super ( false , false , false , false ) ; } @Override RowSortedTable < String , Integer , Character > makeTable ( ) { RowSortedTable < String , Integer , Character > original = TreeBasedTable . create ( ) ; return Tables . unmodifiableRowSortedTable ( original ) ; } @Override protected SortedMap < String , Map < Integer , Character > > makePopulatedMap ( ) { RowSortedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; return Tables . unmodifiableRowSortedTable ( table ) . rowMap ( ) ; } } private static abstract class ColumnMapTests extends MapMapTests { ColumnMapTests ( boolean allowsNullValues , boolean supportsRemove , boolean supportsClear , boolean supportsIteratorRemove ) { super ( allowsNullValues , supportsRemove , supportsClear , supportsIteratorRemove ) ; } abstract Table < Integer , String , Character > makeTable ( ) ; @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < Integer , String , Character > table = makeTable ( ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; return table . columnMap ( ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { return makeTable ( ) . columnMap ( ) ; } } @GwtIncompatible ( <str> ) public static class ArrayColumnMapTests extends ColumnMapTests { public ArrayColumnMapTests ( ) { super ( true , false , false , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { return ArrayTable . create ( Arrays . asList ( <int> , <int> , <int> ) , Arrays . asList ( <str> , <str> , <str> ) ) ; } @Override protected Map < String , Map < Integer , Character > > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } } public static class HashColumnMapTests extends ColumnMapTests { public HashColumnMapTests ( ) { super ( false , true , true , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { return HashBasedTable . create ( ) ; } } public static class TreeColumnMapTests extends ColumnMapTests { public TreeColumnMapTests ( ) { super ( false , true , true , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { return TreeBasedTable . create ( ) ; } } public static class TransformValueColumnMapTests extends ColumnMapTests { public TransformValueColumnMapTests ( ) { super ( false , true , true , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { Table < Integer , String , String > original = HashBasedTable . create ( ) ; return Tables . transformValues ( original , FIRST_CHARACTER ) ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < Integer , String , String > table = HashBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; return Tables . transformValues ( table , FIRST_CHARACTER ) . columnMap ( ) ; } } public static class UnmodifiableHashColumnMapTests extends ColumnMapTests { public UnmodifiableHashColumnMapTests ( ) { super ( false , false , false , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { Table < Integer , String , Character > original = HashBasedTable . create ( ) ; return Tables . unmodifiableTable ( original ) ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { Table < Integer , String , Character > table = HashBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; return Tables . unmodifiableTable ( table ) . columnMap ( ) ; } } public static class UnmodifiableTreeColumnMapTests extends ColumnMapTests { public UnmodifiableTreeColumnMapTests ( ) { super ( false , false , false , false ) ; } @Override Table < Integer , String , Character > makeTable ( ) { RowSortedTable < Integer , String , Character > original = TreeBasedTable . create ( ) ; return Tables . unmodifiableRowSortedTable ( original ) ; } @Override protected Map < String , Map < Integer , Character > > makePopulatedMap ( ) { RowSortedTable < Integer , String , Character > table = TreeBasedTable . create ( ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; table . put ( <int> , <str> , <str> ) ; return Tables . unmodifiableRowSortedTable ( table ) . columnMap ( ) ; } } } 
