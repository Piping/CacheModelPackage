package com . badlogic . gdx . tools . texturepacker ; import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Set ; import javax . imageio . IIOImage ; import javax . imageio . ImageIO ; import javax . imageio . ImageWriteParam ; import javax . imageio . ImageWriter ; import javax . imageio . stream . ImageOutputStream ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . Texture . TextureWrap ; import com . badlogic . gdx . graphics . g2d . TextureAtlas . TextureAtlasData ; import com . badlogic . gdx . graphics . g2d . TextureAtlas . TextureAtlasData . Region ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . Json ; public class TexturePacker { private final Settings settings ; private final Packer packer ; private final ImageProcessor imageProcessor ; private final Array < InputImage > inputImages = new Array ( ) ; private File rootDir ; public TexturePacker ( File rootDir , Settings settings ) { this . rootDir = rootDir ; this . settings = settings ; if ( settings . pot ) { if ( settings . maxWidth ! = MathUtils . nextPowerOfTwo ( settings . maxWidth ) ) throw new RuntimeException ( <str> + settings . maxWidth ) ; if ( settings . maxHeight ! = MathUtils . nextPowerOfTwo ( settings . maxHeight ) ) throw new RuntimeException ( <str> + settings . maxHeight ) ; } if ( settings . grid ) packer = new GridPacker ( settings ) ; else packer = new MaxRectsPacker ( settings ) ; imageProcessor = new ImageProcessor ( rootDir , settings ) ; } public TexturePacker ( Settings settings ) { this ( null , settings ) ; } public void addImage ( File file ) { InputImage inputImage = new InputImage ( ) ; inputImage . file = file ; inputImages . add ( inputImage ) ; } public void addImage ( BufferedImage image , String name ) { InputImage inputImage = new InputImage ( ) ; inputImage . image = image ; inputImage . name = name ; inputImages . add ( inputImage ) ; } public void pack ( File outputDir , String packFileName ) { if ( packFileName . endsWith ( settings . atlasExtension ) ) packFileName = packFileName . substring ( <int> , packFileName . length ( ) - settings . atlasExtension . length ( ) ) ; outputDir . mkdirs ( ) ; for ( int i = <int> , n = settings . scale . length ; i < n ; i + + ) { imageProcessor . setScale ( settings . scale [ i ] ) ; for ( InputImage inputImage : inputImages ) { if ( inputImage . file ! = null ) imageProcessor . addImage ( inputImage . file ) ; else imageProcessor . addImage ( inputImage . image , inputImage . name ) ; } Array < Page > pages = packer . pack ( imageProcessor . getImages ( ) ) ; String scaledPackFileName = settings . getScaledPackFileName ( packFileName , i ) ; writeImages ( outputDir , scaledPackFileName , pages ) ; try { writePackFile ( outputDir , scaledPackFileName , pages ) ; } catch ( IOException ex ) { throw new RuntimeException ( <str> , ex ) ; } imageProcessor . clear ( ) ; } } private void writeImages ( File outputDir , String scaledPackFileName , Array < Page > pages ) { File packFileNoExt = new File ( outputDir , scaledPackFileName ) ; File packDir = packFileNoExt . getParentFile ( ) ; String imageName = packFileNoExt . getName ( ) ; int fileIndex = <int> ; for ( Page page : pages ) { int width = page . width , height = page . height ; int paddingX = settings . paddingX ; int paddingY = settings . paddingY ; if ( settings . duplicatePadding ) { paddingX / = <int> ; paddingY / = <int> ; } width - = settings . paddingX ; height - = settings . paddingY ; if ( settings . edgePadding ) { page . x = paddingX ; page . y = paddingY ; width + = paddingX * <int> ; height + = paddingY * <int> ; } if ( settings . pot ) { width = MathUtils . nextPowerOfTwo ( width ) ; height = MathUtils . nextPowerOfTwo ( height ) ; } width = Math . max ( settings . minWidth , width ) ; height = Math . max ( settings . minHeight , height ) ; page . imageWidth = width ; page . imageHeight = height ; File outputFile ; while ( true ) { outputFile = new File ( packDir , imageName + ( fileIndex + + = = <int> ? <str> : fileIndex ) + <str> + settings . outputFormat ) ; if ( ! outputFile . exists ( ) ) break ; } new FileHandle ( outputFile ) . parent ( ) . mkdirs ( ) ; page . imageName = outputFile . getName ( ) ; BufferedImage canvas = new BufferedImage ( width , height , getBufferedImageType ( settings . format ) ) ; Graphics2D g = ( Graphics2D ) canvas . getGraphics ( ) ; if ( ! settings . silent ) System . out . println ( <str> + canvas . getWidth ( ) + <str> + canvas . getHeight ( ) + <str> + outputFile ) ; for ( Rect rect : page . outputRects ) { BufferedImage image = rect . getImage ( imageProcessor ) ; int iw = image . getWidth ( ) ; int ih = image . getHeight ( ) ; int rectX = page . x + rect . x , rectY = page . y + page . height - rect . y - rect . height ; if ( settings . duplicatePadding ) { int amountX = settings . paddingX / <int> ; int amountY = settings . paddingY / <int> ; if ( rect . rotated ) { for ( int i = <int> ; i < = amountX ; i + + ) { for ( int j = <int> ; j < = amountY ; j + + ) { plot ( canvas , rectX - j , rectY + iw - <int> + i , image . getRGB ( <int> , <int> ) ) ; plot ( canvas , rectX + ih - <int> + j , rectY + iw - <int> + i , image . getRGB ( <int> , ih - <int> ) ) ; plot ( canvas , rectX - j , rectY - i , image . getRGB ( iw - <int> , <int> ) ) ; plot ( canvas , rectX + ih - <int> + j , rectY - i , image . getRGB ( iw - <int> , ih - <int> ) ) ; } } for ( int i = <int> ; i < = amountY ; i + + ) { for ( int j = <int> ; j < iw ; j + + ) { plot ( canvas , rectX - i , rectY + iw - <int> - j , image . getRGB ( j , <int> ) ) ; plot ( canvas , rectX + ih - <int> + i , rectY + iw - <int> - j , image . getRGB ( j , ih - <int> ) ) ; } } for ( int i = <int> ; i < = amountX ; i + + ) { for ( int j = <int> ; j < ih ; j + + ) { plot ( canvas , rectX + j , rectY - i , image . getRGB ( iw - <int> , j ) ) ; plot ( canvas , rectX + j , rectY + iw - <int> + i , image . getRGB ( <int> , j ) ) ; } } } else { for ( int i = <int> ; i < = amountX ; i + + ) { for ( int j = <int> ; j < = amountY ; j + + ) { plot ( canvas , rectX - i , rectY - j , image . getRGB ( <int> , <int> ) ) ; plot ( canvas , rectX - i , rectY + ih - <int> + j , image . getRGB ( <int> , ih - <int> ) ) ; plot ( canvas , rectX + iw - <int> + i , rectY - j , image . getRGB ( iw - <int> , <int> ) ) ; plot ( canvas , rectX + iw - <int> + i , rectY + ih - <int> + j , image . getRGB ( iw - <int> , ih - <int> ) ) ; } } for ( int i = <int> ; i < = amountY ; i + + ) { copy ( image , <int> , <int> , iw , <int> , canvas , rectX , rectY - i , rect . rotated ) ; copy ( image , <int> , ih - <int> , iw , <int> , canvas , rectX , rectY + ih - <int> + i , rect . rotated ) ; } for ( int i = <int> ; i < = amountX ; i + + ) { copy ( image , <int> , <int> , <int> , ih , canvas , rectX - i , rectY , rect . rotated ) ; copy ( image , iw - <int> , <int> , <int> , ih , canvas , rectX + iw - <int> + i , rectY , rect . rotated ) ; } } } copy ( image , <int> , <int> , iw , ih , canvas , rectX , rectY , rect . rotated ) ; if ( settings . debug ) { g . setColor ( Color . magenta ) ; g . drawRect ( rectX , rectY , rect . width - settings . paddingX - <int> , rect . height - settings . paddingY - <int> ) ; } } if ( settings . bleed & & ! settings . premultiplyAlpha & & ! ( settings . outputFormat . equalsIgnoreCase ( <str> ) | | settings . outputFormat . equalsIgnoreCase ( <str> ) ) ) { canvas = new ColorBleedEffect ( ) . processImage ( canvas , <int> ) ; g = ( Graphics2D ) canvas . getGraphics ( ) ; } if ( settings . debug ) { g . setColor ( Color . magenta ) ; g . drawRect ( <int> , <int> , width - <int> , height - <int> ) ; } ImageOutputStream ios = null ; try { if ( settings . outputFormat . equalsIgnoreCase ( <str> ) | | settings . outputFormat . equalsIgnoreCase ( <str> ) ) { BufferedImage newImage = new BufferedImage ( canvas . getWidth ( ) , canvas . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; newImage . getGraphics ( ) . drawImage ( canvas , <int> , <int> , null ) ; canvas = newImage ; Iterator < ImageWriter > writers = ImageIO . getImageWritersByFormatName ( <str> ) ; ImageWriter writer = writers . next ( ) ; ImageWriteParam param = writer . getDefaultWriteParam ( ) ; param . setCompressionMode ( ImageWriteParam . MODE_EXPLICIT ) ; param . setCompressionQuality ( settings . jpegQuality ) ; ios = ImageIO . createImageOutputStream ( outputFile ) ; writer . setOutput ( ios ) ; writer . write ( null , new IIOImage ( canvas , null , null ) , param ) ; } else { if ( settings . premultiplyAlpha ) canvas . getColorModel ( ) . coerceData ( canvas . getRaster ( ) , true ) ; ImageIO . write ( canvas , <str> , outputFile ) ; } } catch ( IOException ex ) { throw new RuntimeException ( <str> + outputFile , ex ) ; } finally { if ( ios ! = null ) { try { ios . close ( ) ; } catch ( Exception ignored ) { } } } } } static private void plot ( BufferedImage dst , int x , int y , int argb ) { if ( <int> < = x & & x < dst . getWidth ( ) & & <int> < = y & & y < dst . getHeight ( ) ) dst . setRGB ( x , y , argb ) ; } static private void copy ( BufferedImage src , int x , int y , int w , int h , BufferedImage dst , int dx , int dy , boolean rotated ) { if ( rotated ) { for ( int i = <int> ; i < w ; i + + ) for ( int j = <int> ; j < h ; j + + ) plot ( dst , dx + j , dy + w - i - <int> , src . getRGB ( x + i , y + j ) ) ; } else { for ( int i = <int> ; i < w ; i + + ) for ( int j = <int> ; j < h ; j + + ) plot ( dst , dx + i , dy + j , src . getRGB ( x + i , y + j ) ) ; } } private void writePackFile ( File outputDir , String scaledPackFileName , Array < Page > pages ) throws IOException { File packFile = new File ( outputDir , scaledPackFileName + settings . atlasExtension ) ; File packDir = packFile . getParentFile ( ) ; packDir . mkdirs ( ) ; if ( packFile . exists ( ) ) { TextureAtlasData textureAtlasData = new TextureAtlasData ( new FileHandle ( packFile ) , new FileHandle ( packFile ) , false ) ; for ( Page page : pages ) { for ( Rect rect : page . outputRects ) { String rectName = Rect . getAtlasName ( rect . name , settings . flattenPaths ) ; for ( Region region : textureAtlasData . getRegions ( ) ) { if ( region . name . equals ( rectName ) ) { throw new GdxRuntimeException ( <str> + rectName + <str> + rect . name ) ; } } } } } FileWriter writer = new FileWriter ( packFile , true ) ; for ( Page page : pages ) { writer . write ( <str> + page . imageName + <str> ) ; writer . write ( <str> + page . imageWidth + <str> + page . imageHeight + <str> ) ; writer . write ( <str> + settings . format + <str> ) ; writer . write ( <str> + settings . filterMin + <str> + settings . filterMag + <str> ) ; writer . write ( <str> + getRepeatValue ( ) + <str> ) ; page . outputRects . sort ( ) ; for ( Rect rect : page . outputRects ) { writeRect ( writer , page , rect , rect . name ) ; Array < Alias > aliases = new Array ( rect . aliases . toArray ( ) ) ; aliases . sort ( ) ; for ( Alias alias : aliases ) { Rect aliasRect = new Rect ( ) ; aliasRect . set ( rect ) ; alias . apply ( aliasRect ) ; writeRect ( writer , page , aliasRect , alias . name ) ; } } } writer . close ( ) ; } private void writeRect ( FileWriter writer , Page page , Rect rect , String name ) throws IOException { writer . write ( Rect . getAtlasName ( name , settings . flattenPaths ) + <str> ) ; writer . write ( <str> + rect . rotated + <str> ) ; writer . write ( <str> + ( page . x + rect . x ) + <str> + ( page . y + page . height - rect . height - rect . y ) + <str> ) ; writer . write ( <str> + rect . regionWidth + <str> + rect . regionHeight + <str> ) ; if ( rect . splits ! = null ) { writer . write ( <str> + rect . splits [ <int> ] + <str> + rect . splits [ <int> ] + <str> + rect . splits [ <int> ] + <str> + rect . splits [ <int> ] + <str> ) ; } if ( rect . pads ! = null ) { if ( rect . splits = = null ) writer . write ( <str> ) ; writer . write ( <str> + rect . pads [ <int> ] + <str> + rect . pads [ <int> ] + <str> + rect . pads [ <int> ] + <str> + rect . pads [ <int> ] + <str> ) ; } writer . write ( <str> + rect . originalWidth + <str> + rect . originalHeight + <str> ) ; writer . write ( <str> + rect . offsetX + <str> + ( rect . originalHeight - rect . regionHeight - rect . offsetY ) + <str> ) ; writer . write ( <str> + rect . index + <str> ) ; } private String getRepeatValue ( ) { if ( settings . wrapX = = TextureWrap . Repeat & & settings . wrapY = = TextureWrap . Repeat ) return <str> ; if ( settings . wrapX = = TextureWrap . Repeat & & settings . wrapY = = TextureWrap . ClampToEdge ) return <str> ; if ( settings . wrapX = = TextureWrap . ClampToEdge & & settings . wrapY = = TextureWrap . Repeat ) return <str> ; return <str> ; } private int getBufferedImageType ( Format format ) { switch ( settings . format ) { case RGBA8888 : case RGBA4444 : return BufferedImage . TYPE_INT_ARGB ; case RGB565 : case RGB888 : return BufferedImage . TYPE_INT_RGB ; case Alpha : return BufferedImage . TYPE_BYTE_GRAY ; default : throw new RuntimeException ( <str> + settings . format ) ; } } static public class Page { public String imageName ; public Array < Rect > outputRects , remainingRects ; public float occupancy ; public int x , y , width , height , imageWidth , imageHeight ; } static public class Alias implements Comparable < Alias > { public String name ; public int index ; public int [ ] splits ; public int [ ] pads ; public int offsetX , offsetY , originalWidth , originalHeight ; public Alias ( Rect rect ) { name = rect . name ; index = rect . index ; splits = rect . splits ; pads = rect . pads ; offsetX = rect . offsetX ; offsetY = rect . offsetY ; originalWidth = rect . originalWidth ; originalHeight = rect . originalHeight ; } public void apply ( Rect rect ) { rect . name = name ; rect . index = index ; rect . splits = splits ; rect . pads = pads ; rect . offsetX = offsetX ; rect . offsetY = offsetY ; rect . originalWidth = originalWidth ; rect . originalHeight = originalHeight ; } public int compareTo ( Alias o ) { return name . compareTo ( o . name ) ; } } static public class Rect implements Comparable < Rect > { public String name ; public int offsetX , offsetY , regionWidth , regionHeight , originalWidth , originalHeight ; public int x , y ; public int width , height ; public int index ; public boolean rotated ; public Set < Alias > aliases = new HashSet < Alias > ( ) ; public int [ ] splits ; public int [ ] pads ; public boolean canRotate = true ; private boolean isPatch ; private BufferedImage image ; private File file ; int score1 , score2 ; Rect ( BufferedImage source , int left , int top , int newWidth , int newHeight , boolean isPatch ) { image = new BufferedImage ( source . getColorModel ( ) , source . getRaster ( ) . createWritableChild ( left , top , newWidth , newHeight , <int> , <int> , null ) , source . getColorModel ( ) . isAlphaPremultiplied ( ) , null ) ; offsetX = left ; offsetY = top ; regionWidth = newWidth ; regionHeight = newHeight ; originalWidth = source . getWidth ( ) ; originalHeight = source . getHeight ( ) ; width = newWidth ; height = newHeight ; this . isPatch = isPatch ; } public void unloadImage ( File file ) { this . file = file ; image = null ; } public BufferedImage getImage ( ImageProcessor imageProcessor ) { if ( image ! = null ) return image ; BufferedImage image ; try { image = ImageIO . read ( file ) ; } catch ( IOException ex ) { throw new RuntimeException ( <str> + file , ex ) ; } if ( image = = null ) throw new RuntimeException ( <str> + file ) ; String name = this . name ; if ( isPatch ) name + = <str> ; return imageProcessor . processImage ( image , name ) . getImage ( null ) ; } Rect ( ) { } Rect ( Rect rect ) { x = rect . x ; y = rect . y ; width = rect . width ; height = rect . height ; } void set ( Rect rect ) { name = rect . name ; image = rect . image ; offsetX = rect . offsetX ; offsetY = rect . offsetY ; regionWidth = rect . regionWidth ; regionHeight = rect . regionHeight ; originalWidth = rect . originalWidth ; originalHeight = rect . originalHeight ; x = rect . x ; y = rect . y ; width = rect . width ; height = rect . height ; index = rect . index ; rotated = rect . rotated ; aliases = rect . aliases ; splits = rect . splits ; pads = rect . pads ; canRotate = rect . canRotate ; score1 = rect . score1 ; score2 = rect . score2 ; file = rect . file ; isPatch = rect . isPatch ; } public int compareTo ( Rect o ) { return name . compareTo ( o . name ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Rect other = ( Rect ) obj ; if ( name = = null ) { if ( other . name ! = null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; return true ; } @Override public String toString ( ) { return name + <str> + x + <str> + y + <str> + width + <str> + height + <str> ; } static public String getAtlasName ( String name , boolean flattenPaths ) { return flattenPaths ? new FileHandle ( name ) . name ( ) : name ; } } static public class Settings { public boolean pot = true ; public int paddingX = <int> , paddingY = <int> ; public boolean edgePadding = true ; public boolean duplicatePadding = false ; public boolean rotation ; public int minWidth = <int> , minHeight = <int> ; public int maxWidth = <int> , maxHeight = <int> ; public boolean square = false ; public boolean stripWhitespaceX , stripWhitespaceY ; public int alphaThreshold ; public TextureFilter filterMin = TextureFilter . Nearest , filterMag = TextureFilter . Nearest ; public TextureWrap wrapX = TextureWrap . ClampToEdge , wrapY = TextureWrap . ClampToEdge ; public Format format = Format . RGBA8888 ; public boolean alias = true ; public String outputFormat = <str> ; public float jpegQuality = <float> ; public boolean ignoreBlankImages = true ; public boolean fast ; public boolean debug ; public boolean silent ; public boolean combineSubdirectories ; public boolean flattenPaths ; public boolean premultiplyAlpha ; public boolean useIndexes = true ; public boolean bleed = true ; public boolean limitMemory = true ; public boolean grid ; public float [ ] scale = { <int> } ; public String [ ] scaleSuffix = { <str> } ; public String atlasExtension = <str> ; public Settings ( ) { } public Settings ( Settings settings ) { fast = settings . fast ; rotation = settings . rotation ; pot = settings . pot ; minWidth = settings . minWidth ; minHeight = settings . minHeight ; maxWidth = settings . maxWidth ; maxHeight = settings . maxHeight ; paddingX = settings . paddingX ; paddingY = settings . paddingY ; edgePadding = settings . edgePadding ; duplicatePadding = settings . duplicatePadding ; alphaThreshold = settings . alphaThreshold ; ignoreBlankImages = settings . ignoreBlankImages ; stripWhitespaceX = settings . stripWhitespaceX ; stripWhitespaceY = settings . stripWhitespaceY ; alias = settings . alias ; format = settings . format ; jpegQuality = settings . jpegQuality ; outputFormat = settings . outputFormat ; filterMin = settings . filterMin ; filterMag = settings . filterMag ; wrapX = settings . wrapX ; wrapY = settings . wrapY ; debug = settings . debug ; silent = settings . silent ; combineSubdirectories = settings . combineSubdirectories ; flattenPaths = settings . flattenPaths ; premultiplyAlpha = settings . premultiplyAlpha ; square = settings . square ; useIndexes = settings . useIndexes ; bleed = settings . bleed ; limitMemory = settings . limitMemory ; grid = settings . grid ; scale = settings . scale ; scaleSuffix = settings . scaleSuffix ; atlasExtension = settings . atlasExtension ; } public String getScaledPackFileName ( String packFileName , int scaleIndex ) { if ( scaleSuffix [ scaleIndex ] . length ( ) > <int> ) packFileName + = scaleSuffix [ scaleIndex ] ; else { float scaleValue = scale [ scaleIndex ] ; if ( scale . length ! = <int> ) { packFileName = ( scaleValue = = ( int ) scaleValue ? Integer . toString ( ( int ) scaleValue ) : Float . toString ( scaleValue ) ) + <str> + packFileName ; } } return packFileName ; } } static public void process ( String input , String output , String packFileName ) { process ( new Settings ( ) , input , output , packFileName ) ; } static public void process ( Settings settings , String input , String output , String packFileName ) { try { TexturePackerFileProcessor processor = new TexturePackerFileProcessor ( settings , packFileName ) ; processor . setComparator ( new Comparator < File > ( ) { public int compare ( File file1 , File file2 ) { return file1 . getName ( ) . compareTo ( file2 . getName ( ) ) ; } } ) ; processor . process ( new File ( input ) , new File ( output ) ) ; } catch ( Exception ex ) { throw new RuntimeException ( <str> , ex ) ; } } static public boolean isModified ( String input , String output , String packFileName , Settings settings ) { String packFullFileName = output ; if ( ! packFullFileName . endsWith ( <str> ) ) { packFullFileName + = <str> ; } packFullFileName + = packFileName ; packFullFileName + = settings . atlasExtension ; File outputFile = new File ( packFullFileName ) ; if ( ! outputFile . exists ( ) ) { return true ; } File inputFile = new File ( input ) ; if ( ! inputFile . exists ( ) ) { throw new IllegalArgumentException ( <str> + inputFile . getAbsolutePath ( ) ) ; } return inputFile . lastModified ( ) > outputFile . lastModified ( ) ; } static public void processIfModified ( String input , String output , String packFileName ) { Settings settings = new Settings ( ) ; if ( isModified ( input , output , packFileName , settings ) ) { process ( settings , input , output , packFileName ) ; } } static public void processIfModified ( Settings settings , String input , String output , String packFileName ) { if ( isModified ( input , output , packFileName , settings ) ) { process ( settings , input , output , packFileName ) ; } } static public interface Packer { public Array < Page > pack ( Array < Rect > inputRects ) ; } static final class InputImage { File file ; String name ; BufferedImage image ; } static public void main ( String [ ] args ) throws Exception { Settings settings = null ; String input = null , output = null , packFileName = <str> ; switch ( args . length ) { case <int> : settings = new Json ( ) . fromJson ( Settings . class , new FileReader ( args [ <int> ] ) ) ; case <int> : packFileName = args [ <int> ] ; case <int> : output = args [ <int> ] ; case <int> : input = args [ <int> ] ; break ; default : System . out . println ( <str> ) ; System . exit ( <int> ) ; } if ( output = = null ) { File inputFile = new File ( input ) ; output = new File ( inputFile . getParentFile ( ) , inputFile . getName ( ) + <str> ) . getAbsolutePath ( ) ; } if ( settings = = null ) settings = new Settings ( ) ; process ( settings , input , output , packFileName ) ; } } 
