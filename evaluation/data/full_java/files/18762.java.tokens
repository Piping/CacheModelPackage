package io . netty . buffer ; import io . netty . util . internal . LongCounter ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; abstract class PoolArena < T > implements PoolArenaMetric { static final boolean HAS_UNSAFE = PlatformDependent . hasUnsafe ( ) ; enum SizeClass { Tiny , Small , Normal } static final int numTinySubpagePools = <int> > > > <int> ; final PooledByteBufAllocator parent ; private final int maxOrder ; final int pageSize ; final int pageShifts ; final int chunkSize ; final int subpageOverflowMask ; final int numSmallSubpagePools ; private final PoolSubpage < T > [ ] tinySubpagePools ; private final PoolSubpage < T > [ ] smallSubpagePools ; private final PoolChunkList < T > q050 ; private final PoolChunkList < T > q025 ; private final PoolChunkList < T > q000 ; private final PoolChunkList < T > qInit ; private final PoolChunkList < T > q075 ; private final PoolChunkList < T > q100 ; private final List < PoolChunkListMetric > chunkListMetrics ; private long allocationsTiny ; private long allocationsSmall ; private long allocationsNormal ; private final LongCounter allocationsHuge = PlatformDependent . newLongCounter ( ) ; private long deallocationsTiny ; private long deallocationsSmall ; private long deallocationsNormal ; private final LongCounter deallocationsHuge = PlatformDependent . newLongCounter ( ) ; protected PoolArena ( PooledByteBufAllocator parent , int pageSize , int maxOrder , int pageShifts , int chunkSize ) { this . parent = parent ; this . pageSize = pageSize ; this . maxOrder = maxOrder ; this . pageShifts = pageShifts ; this . chunkSize = chunkSize ; subpageOverflowMask = ~ ( pageSize - <int> ) ; tinySubpagePools = newSubpagePoolArray ( numTinySubpagePools ) ; for ( int i = <int> ; i < tinySubpagePools . length ; i + + ) { tinySubpagePools [ i ] = newSubpagePoolHead ( pageSize ) ; } numSmallSubpagePools = pageShifts - <int> ; smallSubpagePools = newSubpagePoolArray ( numSmallSubpagePools ) ; for ( int i = <int> ; i < smallSubpagePools . length ; i + + ) { smallSubpagePools [ i ] = newSubpagePoolHead ( pageSize ) ; } q100 = new PoolChunkList < T > ( null , <int> , Integer . MAX_VALUE ) ; q075 = new PoolChunkList < T > ( q100 , <int> , <int> ) ; q050 = new PoolChunkList < T > ( q075 , <int> , <int> ) ; q025 = new PoolChunkList < T > ( q050 , <int> , <int> ) ; q000 = new PoolChunkList < T > ( q025 , <int> , <int> ) ; qInit = new PoolChunkList < T > ( q000 , Integer . MIN_VALUE , <int> ) ; q100 . prevList ( q075 ) ; q075 . prevList ( q050 ) ; q050 . prevList ( q025 ) ; q025 . prevList ( q000 ) ; q000 . prevList ( null ) ; qInit . prevList ( qInit ) ; List < PoolChunkListMetric > metrics = new ArrayList < PoolChunkListMetric > ( <int> ) ; metrics . add ( qInit ) ; metrics . add ( q000 ) ; metrics . add ( q025 ) ; metrics . add ( q050 ) ; metrics . add ( q075 ) ; metrics . add ( q100 ) ; chunkListMetrics = Collections . unmodifiableList ( metrics ) ; } private PoolSubpage < T > newSubpagePoolHead ( int pageSize ) { PoolSubpage < T > head = new PoolSubpage < T > ( pageSize ) ; head . prev = head ; head . next = head ; return head ; } @SuppressWarnings ( <str> ) private PoolSubpage < T > [ ] newSubpagePoolArray ( int size ) { return new PoolSubpage [ size ] ; } abstract boolean isDirect ( ) ; PooledByteBuf < T > allocate ( PoolThreadCache cache , int reqCapacity , int maxCapacity ) { PooledByteBuf < T > buf = newByteBuf ( maxCapacity ) ; allocate ( cache , buf , reqCapacity ) ; return buf ; } static int tinyIdx ( int normCapacity ) { return normCapacity > > > <int> ; } static int smallIdx ( int normCapacity ) { int tableIdx = <int> ; int i = normCapacity > > > <int> ; while ( i ! = <int> ) { i > > > = <int> ; tableIdx + + ; } return tableIdx ; } boolean isTinyOrSmall ( int normCapacity ) { return ( normCapacity & subpageOverflowMask ) = = <int> ; } static boolean isTiny ( int normCapacity ) { return ( normCapacity & <hex> ) = = <int> ; } private void allocate ( PoolThreadCache cache , PooledByteBuf < T > buf , final int reqCapacity ) { final int normCapacity = normalizeCapacity ( reqCapacity ) ; if ( isTinyOrSmall ( normCapacity ) ) { int tableIdx ; PoolSubpage < T > [ ] table ; boolean tiny = isTiny ( normCapacity ) ; if ( tiny ) { if ( cache . allocateTiny ( this , buf , reqCapacity , normCapacity ) ) { return ; } tableIdx = tinyIdx ( normCapacity ) ; table = tinySubpagePools ; } else { if ( cache . allocateSmall ( this , buf , reqCapacity , normCapacity ) ) { return ; } tableIdx = smallIdx ( normCapacity ) ; table = smallSubpagePools ; } final PoolSubpage < T > head = table [ tableIdx ] ; synchronized ( head ) { final PoolSubpage < T > s = head . next ; if ( s ! = head ) { assert s . doNotDestroy & & s . elemSize = = normCapacity ; long handle = s . allocate ( ) ; assert handle > = <int> ; s . chunk . initBufWithSubpage ( buf , handle , reqCapacity ) ; if ( tiny ) { + + allocationsTiny ; } else { + + allocationsSmall ; } return ; } } allocateNormal ( buf , reqCapacity , normCapacity ) ; return ; } if ( normCapacity < = chunkSize ) { if ( cache . allocateNormal ( this , buf , reqCapacity , normCapacity ) ) { return ; } allocateNormal ( buf , reqCapacity , normCapacity ) ; } else { allocateHuge ( buf , reqCapacity ) ; } } private synchronized void allocateNormal ( PooledByteBuf < T > buf , int reqCapacity , int normCapacity ) { + + allocationsNormal ; if ( q050 . allocate ( buf , reqCapacity , normCapacity ) | | q025 . allocate ( buf , reqCapacity , normCapacity ) | | q000 . allocate ( buf , reqCapacity , normCapacity ) | | qInit . allocate ( buf , reqCapacity , normCapacity ) | | q075 . allocate ( buf , reqCapacity , normCapacity ) | | q100 . allocate ( buf , reqCapacity , normCapacity ) ) { return ; } PoolChunk < T > c = newChunk ( pageSize , maxOrder , pageShifts , chunkSize ) ; long handle = c . allocate ( normCapacity ) ; assert handle > <int> ; c . initBuf ( buf , handle , reqCapacity ) ; qInit . add ( c ) ; } private void allocateHuge ( PooledByteBuf < T > buf , int reqCapacity ) { allocationsHuge . increment ( ) ; buf . initUnpooled ( newUnpooledChunk ( reqCapacity ) , reqCapacity ) ; } void free ( PoolChunk < T > chunk , long handle , int normCapacity , PoolThreadCache cache ) { if ( chunk . unpooled ) { allocationsHuge . decrement ( ) ; destroyChunk ( chunk ) ; } else { SizeClass sizeClass = sizeClass ( normCapacity ) ; if ( cache ! = null & & cache . add ( this , chunk , handle , normCapacity , sizeClass ) ) { return ; } freeChunk ( chunk , handle , sizeClass ) ; } } private SizeClass sizeClass ( int normCapacity ) { if ( ! isTinyOrSmall ( normCapacity ) ) { return SizeClass . Normal ; } return isTiny ( normCapacity ) ? SizeClass . Tiny : SizeClass . Small ; } void freeChunk ( PoolChunk < T > chunk , long handle , SizeClass sizeClass ) { final boolean destroyChunk ; synchronized ( this ) { switch ( sizeClass ) { case Normal : + + deallocationsNormal ; break ; case Small : + + deallocationsSmall ; break ; case Tiny : + + deallocationsTiny ; break ; default : throw new Error ( ) ; } destroyChunk = ! chunk . parent . free ( chunk , handle ) ; } if ( destroyChunk ) { destroyChunk ( chunk ) ; } } PoolSubpage < T > findSubpagePoolHead ( int elemSize ) { int tableIdx ; PoolSubpage < T > [ ] table ; if ( isTiny ( elemSize ) ) { tableIdx = elemSize > > > <int> ; table = tinySubpagePools ; } else { tableIdx = <int> ; elemSize > > > = <int> ; while ( elemSize ! = <int> ) { elemSize > > > = <int> ; tableIdx + + ; } table = smallSubpagePools ; } return table [ tableIdx ] ; } int normalizeCapacity ( int reqCapacity ) { if ( reqCapacity < <int> ) { throw new IllegalArgumentException ( <str> + reqCapacity + <str> ) ; } if ( reqCapacity > = chunkSize ) { return reqCapacity ; } if ( ! isTiny ( reqCapacity ) ) { int normalizedCapacity = reqCapacity ; normalizedCapacity - - ; normalizedCapacity | = normalizedCapacity > > > <int> ; normalizedCapacity | = normalizedCapacity > > > <int> ; normalizedCapacity | = normalizedCapacity > > > <int> ; normalizedCapacity | = normalizedCapacity > > > <int> ; normalizedCapacity | = normalizedCapacity > > > <int> ; normalizedCapacity + + ; if ( normalizedCapacity < <int> ) { normalizedCapacity > > > = <int> ; } return normalizedCapacity ; } if ( ( reqCapacity & <int> ) = = <int> ) { return reqCapacity ; } return ( reqCapacity & ~ <int> ) + <int> ; } void reallocate ( PooledByteBuf < T > buf , int newCapacity , boolean freeOldMemory ) { if ( newCapacity < <int> | | newCapacity > buf . maxCapacity ( ) ) { throw new IllegalArgumentException ( <str> + newCapacity ) ; } int oldCapacity = buf . length ; if ( oldCapacity = = newCapacity ) { return ; } PoolChunk < T > oldChunk = buf . chunk ; long oldHandle = buf . handle ; T oldMemory = buf . memory ; int oldOffset = buf . offset ; int oldMaxLength = buf . maxLength ; int readerIndex = buf . readerIndex ( ) ; int writerIndex = buf . writerIndex ( ) ; allocate ( parent . threadCache ( ) , buf , newCapacity ) ; if ( newCapacity > oldCapacity ) { memoryCopy ( oldMemory , oldOffset , buf . memory , buf . offset , oldCapacity ) ; } else if ( newCapacity < oldCapacity ) { if ( readerIndex < newCapacity ) { if ( writerIndex > newCapacity ) { writerIndex = newCapacity ; } memoryCopy ( oldMemory , oldOffset + readerIndex , buf . memory , buf . offset + readerIndex , writerIndex - readerIndex ) ; } else { readerIndex = writerIndex = newCapacity ; } } buf . setIndex ( readerIndex , writerIndex ) ; if ( freeOldMemory ) { free ( oldChunk , oldHandle , oldMaxLength , buf . cache ) ; } } @Override public int numTinySubpages ( ) { return tinySubpagePools . length ; } @Override public int numSmallSubpages ( ) { return smallSubpagePools . length ; } @Override public int numChunkLists ( ) { return chunkListMetrics . size ( ) ; } @Override public List < PoolSubpageMetric > tinySubpages ( ) { return subPageMetricList ( tinySubpagePools ) ; } @Override public List < PoolSubpageMetric > smallSubpages ( ) { return subPageMetricList ( smallSubpagePools ) ; } @Override public List < PoolChunkListMetric > chunkLists ( ) { return chunkListMetrics ; } private static List < PoolSubpageMetric > subPageMetricList ( PoolSubpage < ? > [ ] pages ) { List < PoolSubpageMetric > metrics = new ArrayList < PoolSubpageMetric > ( ) ; for ( int i = <int> ; i < pages . length ; i + + ) { PoolSubpage < ? > head = pages [ i ] ; if ( head . next = = head ) { continue ; } PoolSubpage < ? > s = head . next ; for ( ; ; ) { metrics . add ( s ) ; s = s . next ; if ( s = = head ) { break ; } } } return metrics ; } @Override public long numAllocations ( ) { return allocationsTiny + allocationsSmall + allocationsNormal + allocationsHuge . value ( ) ; } @Override public long numTinyAllocations ( ) { return allocationsTiny ; } @Override public long numSmallAllocations ( ) { return allocationsSmall ; } @Override public long numNormalAllocations ( ) { return allocationsNormal ; } @Override public long numDeallocations ( ) { return deallocationsTiny + deallocationsSmall + allocationsNormal + deallocationsHuge . value ( ) ; } @Override public long numTinyDeallocations ( ) { return deallocationsTiny ; } @Override public long numSmallDeallocations ( ) { return deallocationsSmall ; } @Override public long numNormalDeallocations ( ) { return deallocationsNormal ; } @Override public long numHugeAllocations ( ) { return allocationsHuge . value ( ) ; } @Override public long numHugeDeallocations ( ) { return deallocationsHuge . value ( ) ; } @Override public long numActiveAllocations ( ) { long val = numAllocations ( ) - numDeallocations ( ) ; return val > = <int> ? val : <int> ; } @Override public long numActiveTinyAllocations ( ) { long val = numTinyAllocations ( ) - numTinyDeallocations ( ) ; return val > = <int> ? val : <int> ; } @Override public long numActiveSmallAllocations ( ) { long val = numSmallAllocations ( ) - numSmallDeallocations ( ) ; return val > = <int> ? val : <int> ; } @Override public long numActiveNormalAllocations ( ) { long val = numNormalAllocations ( ) - numNormalDeallocations ( ) ; return val > = <int> ? val : <int> ; } @Override public long numActiveHugeAllocations ( ) { long val = numHugeAllocations ( ) - numHugeDeallocations ( ) ; return val > = <int> ? val : <int> ; } protected abstract PoolChunk < T > newChunk ( int pageSize , int maxOrder , int pageShifts , int chunkSize ) ; protected abstract PoolChunk < T > newUnpooledChunk ( int capacity ) ; protected abstract PooledByteBuf < T > newByteBuf ( int maxCapacity ) ; protected abstract void memoryCopy ( T src , int srcOffset , T dst , int dstOffset , int length ) ; protected abstract void destroyChunk ( PoolChunk < T > chunk ) ; @Override public synchronized String toString ( ) { StringBuilder buf = new StringBuilder ( ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( qInit ) . append ( StringUtil . NEWLINE ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( q000 ) . append ( StringUtil . NEWLINE ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( q025 ) . append ( StringUtil . NEWLINE ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( q050 ) . append ( StringUtil . NEWLINE ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( q075 ) . append ( StringUtil . NEWLINE ) . append ( <str> ) . append ( StringUtil . NEWLINE ) . append ( q100 ) . append ( StringUtil . NEWLINE ) . append ( <str> ) ; for ( int i = <int> ; i < tinySubpagePools . length ; i + + ) { PoolSubpage < T > head = tinySubpagePools [ i ] ; if ( head . next = = head ) { continue ; } buf . append ( StringUtil . NEWLINE ) . append ( i ) . append ( <str> ) ; PoolSubpage < T > s = head . next ; for ( ; ; ) { buf . append ( s ) ; s = s . next ; if ( s = = head ) { break ; } } } buf . append ( StringUtil . NEWLINE ) . append ( <str> ) ; for ( int i = <int> ; i < smallSubpagePools . length ; i + + ) { PoolSubpage < T > head = smallSubpagePools [ i ] ; if ( head . next = = head ) { continue ; } buf . append ( StringUtil . NEWLINE ) . append ( i ) . append ( <str> ) ; PoolSubpage < T > s = head . next ; for ( ; ; ) { buf . append ( s ) ; s = s . next ; if ( s = = head ) { break ; } } } buf . append ( StringUtil . NEWLINE ) ; return buf . toString ( ) ; } static final class HeapArena extends PoolArena < byte [ ] > { HeapArena ( PooledByteBufAllocator parent , int pageSize , int maxOrder , int pageShifts , int chunkSize ) { super ( parent , pageSize , maxOrder , pageShifts , chunkSize ) ; } @Override boolean isDirect ( ) { return false ; } @Override protected PoolChunk < byte [ ] > newChunk ( int pageSize , int maxOrder , int pageShifts , int chunkSize ) { return new PoolChunk < byte [ ] > ( this , new byte [ chunkSize ] , pageSize , maxOrder , pageShifts , chunkSize ) ; } @Override protected PoolChunk < byte [ ] > newUnpooledChunk ( int capacity ) { return new PoolChunk < byte [ ] > ( this , new byte [ capacity ] , capacity ) ; } @Override protected void destroyChunk ( PoolChunk < byte [ ] > chunk ) { } @Override protected PooledByteBuf < byte [ ] > newByteBuf ( int maxCapacity ) { return HAS_UNSAFE ? PooledUnsafeHeapByteBuf . newUnsafeInstance ( maxCapacity ) : PooledHeapByteBuf . newInstance ( maxCapacity ) ; } @Override protected void memoryCopy ( byte [ ] src , int srcOffset , byte [ ] dst , int dstOffset , int length ) { if ( length = = <int> ) { return ; } System . arraycopy ( src , srcOffset , dst , dstOffset , length ) ; } } static final class DirectArena extends PoolArena < ByteBuffer > { DirectArena ( PooledByteBufAllocator parent , int pageSize , int maxOrder , int pageShifts , int chunkSize ) { super ( parent , pageSize , maxOrder , pageShifts , chunkSize ) ; } @Override boolean isDirect ( ) { return true ; } @Override protected PoolChunk < ByteBuffer > newChunk ( int pageSize , int maxOrder , int pageShifts , int chunkSize ) { return new PoolChunk < ByteBuffer > ( this , ByteBuffer . allocateDirect ( chunkSize ) , pageSize , maxOrder , pageShifts , chunkSize ) ; } @Override protected PoolChunk < ByteBuffer > newUnpooledChunk ( int capacity ) { return new PoolChunk < ByteBuffer > ( this , ByteBuffer . allocateDirect ( capacity ) , capacity ) ; } @Override protected void destroyChunk ( PoolChunk < ByteBuffer > chunk ) { PlatformDependent . freeDirectBuffer ( chunk . memory ) ; } @Override protected PooledByteBuf < ByteBuffer > newByteBuf ( int maxCapacity ) { if ( HAS_UNSAFE ) { return PooledUnsafeDirectByteBuf . newInstance ( maxCapacity ) ; } else { return PooledDirectByteBuf . newInstance ( maxCapacity ) ; } } @Override protected void memoryCopy ( ByteBuffer src , int srcOffset , ByteBuffer dst , int dstOffset , int length ) { if ( length = = <int> ) { return ; } if ( HAS_UNSAFE ) { PlatformDependent . copyMemory ( PlatformDependent . directBufferAddress ( src ) + srcOffset , PlatformDependent . directBufferAddress ( dst ) + dstOffset , length ) ; } else { src = src . duplicate ( ) ; dst = dst . duplicate ( ) ; src . position ( srcOffset ) . limit ( srcOffset + length ) ; dst . position ( dstOffset ) ; dst . put ( src ) ; } } } } 
