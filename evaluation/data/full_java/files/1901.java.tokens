package clojure . lang ; import java . io . Serializable ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class LongRange extends ASeq implements Counted , IChunkedSeq , IReduce { private static final int CHUNK_SIZE = <int> ; final long start ; final long end ; final long step ; final BoundsCheck boundsCheck ; private volatile LongChunk _chunk ; private volatile ISeq _chunkNext ; private volatile ISeq _next ; private static interface BoundsCheck extends Serializable { boolean exceededBounds ( long val ) ; } private static BoundsCheck positiveStep ( final long end ) { return new BoundsCheck ( ) { public boolean exceededBounds ( long val ) { return ( val > = end ) ; } } ; } private static BoundsCheck negativeStep ( final long end ) { return new BoundsCheck ( ) { public boolean exceededBounds ( long val ) { return ( val < = end ) ; } } ; } private LongRange ( long start , long end , long step , BoundsCheck boundsCheck ) { this . start = start ; this . end = end ; this . step = step ; this . boundsCheck = boundsCheck ; } private LongRange ( long start , long end , long step , BoundsCheck boundsCheck , LongChunk chunk , ISeq chunkNext ) { this . start = start ; this . end = end ; this . step = step ; this . boundsCheck = boundsCheck ; this . _chunk = chunk ; this . _chunkNext = chunkNext ; } private LongRange ( IPersistentMap meta , long start , long end , long step , BoundsCheck boundsCheck , LongChunk chunk , ISeq chunkNext ) { super ( meta ) ; this . start = start ; this . end = end ; this . step = step ; this . boundsCheck = boundsCheck ; this . _chunk = chunk ; this . _chunkNext = chunkNext ; } public static ISeq create ( long end ) { if ( end > <int> ) return new LongRange ( <int> L , end , <int> , positiveStep ( end ) ) ; return PersistentList . EMPTY ; } public static ISeq create ( long start , long end ) { if ( start > = end ) return PersistentList . EMPTY ; return new LongRange ( start , end , <int> , positiveStep ( end ) ) ; } public static ISeq create ( final long start , long end , long step ) { if ( step > <int> ) { if ( end < = start ) return PersistentList . EMPTY ; return new LongRange ( start , end , step , positiveStep ( end ) ) ; } else if ( step < <int> ) { if ( end > = start ) return PersistentList . EMPTY ; return new LongRange ( start , end , step , negativeStep ( end ) ) ; } else { if ( end = = start ) return PersistentList . EMPTY ; return Repeat . create ( start ) ; } } public Obj withMeta ( IPersistentMap meta ) { if ( meta = = _meta ) return this ; return new LongRange ( meta , start , end , step , boundsCheck , _chunk , _chunkNext ) ; } public Object first ( ) { return start ; } public void forceChunk ( ) { if ( _chunk ! = null ) return ; long count ; try { count = rangeCount ( start , end , step ) ; } catch ( ArithmeticException e ) { count = steppingCount ( start , end , step ) ; } if ( count > CHUNK_SIZE ) { long nextStart = start + ( step * CHUNK_SIZE ) ; _chunk = new LongChunk ( start , step , CHUNK_SIZE ) ; _chunkNext = new LongRange ( nextStart , end , step , boundsCheck ) ; } else { _chunk = new LongChunk ( start , step , ( int ) count ) ; } } public ISeq next ( ) { if ( _next ! = null ) return _next ; forceChunk ( ) ; if ( _chunk . count ( ) > <int> ) { LongChunk smallerChunk = _chunk . dropFirst ( ) ; _next = new LongRange ( smallerChunk . first ( ) , end , step , boundsCheck , smallerChunk , _chunkNext ) ; return _next ; } return chunkedNext ( ) ; } public IChunk chunkedFirst ( ) { forceChunk ( ) ; return _chunk ; } public ISeq chunkedNext ( ) { return chunkedMore ( ) . seq ( ) ; } public ISeq chunkedMore ( ) { forceChunk ( ) ; if ( _chunkNext = = null ) return PersistentList . EMPTY ; return _chunkNext ; } long steppingCount ( long start , long end , long step ) { long count = <int> ; long s = start ; while ( count < = CHUNK_SIZE ) { try { s = Numbers . add ( s , step ) ; if ( boundsCheck . exceededBounds ( s ) ) break ; else count + + ; } catch ( ArithmeticException e ) { break ; } } return count ; } long rangeCount ( long start , long end , long step ) { return Numbers . add ( Numbers . add ( Numbers . minus ( end , start ) , step ) , this . step > <int> ? - <int> : <int> ) / step ; } public int count ( ) { try { long c = rangeCount ( start , end , step ) ; if ( c > Integer . MAX_VALUE ) { return Numbers . throwIntOverflow ( ) ; } else { return ( int ) c ; } } catch ( ArithmeticException e ) { Iterator iter = this . iterator ( ) ; long count = <int> ; while ( iter . hasNext ( ) ) { iter . next ( ) ; count + + ; } if ( count > Integer . MAX_VALUE ) return Numbers . throwIntOverflow ( ) ; else return ( int ) count ; } } public Object reduce ( IFn f ) { Object acc = start ; long i = start + step ; while ( ! boundsCheck . exceededBounds ( i ) ) { acc = f . invoke ( acc , i ) ; if ( acc instanceof Reduced ) return ( ( Reduced ) acc ) . deref ( ) ; i + = step ; } return acc ; } public Object reduce ( IFn f , Object val ) { Object acc = val ; long i = start ; do { acc = f . invoke ( acc , i ) ; if ( RT . isReduced ( acc ) ) return ( ( Reduced ) acc ) . deref ( ) ; i + = step ; } while ( ! boundsCheck . exceededBounds ( i ) ) ; return acc ; } public Iterator iterator ( ) { return new LongRangeIterator ( ) ; } class LongRangeIterator implements Iterator { private long next ; private boolean hasNext ; public LongRangeIterator ( ) { this . next = start ; this . hasNext = true ; } public boolean hasNext ( ) { return hasNext ; } public Object next ( ) { if ( hasNext ) { long ret = next ; try { next = Numbers . add ( next , step ) ; hasNext = ! boundsCheck . exceededBounds ( next ) ; } catch ( ArithmeticException e ) { hasNext = false ; } return ret ; } else { throw new NoSuchElementException ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private static class LongChunk implements IChunk , Serializable { final long start ; final long step ; final int count ; public LongChunk ( long start , long step , int count ) { this . start = start ; this . step = step ; this . count = count ; } public long first ( ) { return start ; } public Object nth ( int i ) { return start + ( i * step ) ; } public Object nth ( int i , Object notFound ) { if ( i > = <int> & & i < count ) return start + ( i * step ) ; return notFound ; } public int count ( ) { return count ; } public LongChunk dropFirst ( ) { if ( count < = <int> ) throw new IllegalStateException ( <str> ) ; return new LongChunk ( start + step , step , count - <int> ) ; } public Object reduce ( IFn f , Object init ) { long x = start ; Object ret = init ; for ( int i = <int> ; i < count ; i + + ) { ret = f . invoke ( ret , x ) ; if ( RT . isReduced ( ret ) ) return ret ; x + = step ; } return ret ; } } } 
