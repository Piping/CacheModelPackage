package org . elasticsearch . action . admin . indices . alias ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . AliasesRequest ; import org . elasticsearch . action . CompositeIndicesRequest ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . master . AcknowledgedRequest ; import org . elasticsearch . cluster . metadata . AliasAction ; import org . elasticsearch . cluster . metadata . AliasAction . Type ; import org . elasticsearch . cluster . metadata . AliasMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . index . query . QueryBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; import static org . elasticsearch . cluster . metadata . AliasAction . readAliasAction ; public class IndicesAliasesRequest extends AcknowledgedRequest < IndicesAliasesRequest > implements CompositeIndicesRequest { private List < AliasActions > allAliasActions = new ArrayList < > ( ) ; private static final IndicesOptions INDICES_OPTIONS = IndicesOptions . fromOptions ( false , false , true , false ) ; public IndicesAliasesRequest ( ) { } public static class AliasActions implements AliasesRequest { private String [ ] indices = Strings . EMPTY_ARRAY ; private String [ ] aliases = Strings . EMPTY_ARRAY ; private AliasAction aliasAction ; public AliasActions ( AliasAction . Type type , String [ ] indices , String [ ] aliases ) { aliasAction = new AliasAction ( type ) ; indices ( indices ) ; aliases ( aliases ) ; } public AliasActions ( AliasAction . Type type , String index , String alias ) { aliasAction = new AliasAction ( type ) ; indices ( index ) ; aliases ( alias ) ; } AliasActions ( AliasAction . Type type , String [ ] index , String alias ) { aliasAction = new AliasAction ( type ) ; indices ( index ) ; aliases ( alias ) ; } public AliasActions ( AliasAction action ) { this . aliasAction = action ; indices ( action . index ( ) ) ; aliases ( action . alias ( ) ) ; } public AliasActions ( Type type , String index , String [ ] aliases ) { aliasAction = new AliasAction ( type ) ; indices ( index ) ; aliases ( aliases ) ; } public AliasActions ( ) { } public AliasActions filter ( Map < String , Object > filter ) { aliasAction . filter ( filter ) ; return this ; } public AliasActions filter ( QueryBuilder filter ) { aliasAction . filter ( filter ) ; return this ; } public Type actionType ( ) { return aliasAction . actionType ( ) ; } public void routing ( String routing ) { aliasAction . routing ( routing ) ; } public void searchRouting ( String searchRouting ) { aliasAction . searchRouting ( searchRouting ) ; } public void indexRouting ( String indexRouting ) { aliasAction . indexRouting ( indexRouting ) ; } public AliasActions filter ( String filter ) { aliasAction . filter ( filter ) ; return this ; } @Override public AliasActions indices ( String . . . indices ) { this . indices = indices ; return this ; } @Override public AliasActions aliases ( String . . . aliases ) { this . aliases = aliases ; return this ; } @Override public String [ ] aliases ( ) { return aliases ; } @Override public boolean expandAliasesWildcards ( ) { return aliasAction . actionType ( ) = = Type . REMOVE ; } @Override public String [ ] indices ( ) { return indices ; } @Override public IndicesOptions indicesOptions ( ) { return INDICES_OPTIONS ; } public AliasAction aliasAction ( ) { return aliasAction ; } public String [ ] concreteAliases ( MetaData metaData , String concreteIndex ) { if ( expandAliasesWildcards ( ) ) { String [ ] indexAsArray = { concreteIndex } ; ImmutableOpenMap < String , List < AliasMetaData > > aliasMetaData = metaData . findAliases ( aliases , indexAsArray ) ; List < String > finalAliases = new ArrayList < > ( ) ; for ( ObjectCursor < List < AliasMetaData > > curAliases : aliasMetaData . values ( ) ) { for ( AliasMetaData aliasMeta : curAliases . value ) { finalAliases . add ( aliasMeta . alias ( ) ) ; } } return finalAliases . toArray ( new String [ finalAliases . size ( ) ] ) ; } else { return aliases ; } } public AliasActions readFrom ( StreamInput in ) throws IOException { indices = in . readStringArray ( ) ; aliases = in . readStringArray ( ) ; aliasAction = readAliasAction ( in ) ; return this ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeStringArray ( indices ) ; out . writeStringArray ( aliases ) ; this . aliasAction . writeTo ( out ) ; } } public IndicesAliasesRequest addAlias ( String alias , String . . . indices ) { addAliasAction ( new AliasActions ( AliasAction . Type . ADD , indices , alias ) ) ; return this ; } public void addAliasAction ( AliasActions aliasAction ) { allAliasActions . add ( aliasAction ) ; } public IndicesAliasesRequest addAliasAction ( AliasAction action ) { addAliasAction ( new AliasActions ( action ) ) ; return this ; } public IndicesAliasesRequest addAlias ( String alias , Map < String , Object > filter , String . . . indices ) { addAliasAction ( new AliasActions ( AliasAction . Type . ADD , indices , alias ) . filter ( filter ) ) ; return this ; } public IndicesAliasesRequest addAlias ( String alias , QueryBuilder filterBuilder , String . . . indices ) { addAliasAction ( new AliasActions ( AliasAction . Type . ADD , indices , alias ) . filter ( filterBuilder ) ) ; return this ; } public IndicesAliasesRequest removeAlias ( String [ ] indices , String . . . aliases ) { addAliasAction ( new AliasActions ( AliasAction . Type . REMOVE , indices , aliases ) ) ; return this ; } public IndicesAliasesRequest removeAlias ( String index , String . . . aliases ) { addAliasAction ( new AliasActions ( AliasAction . Type . REMOVE , index , aliases ) ) ; return this ; } List < AliasActions > aliasActions ( ) { return this . allAliasActions ; } public List < AliasActions > getAliasActions ( ) { return aliasActions ( ) ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( allAliasActions . isEmpty ( ) ) { return addValidationError ( <str> , validationException ) ; } for ( AliasActions aliasAction : allAliasActions ) { if ( aliasAction . aliases . length = = <int> ) { validationException = addValidationError ( <str> + aliasAction . actionType ( ) . name ( ) . toLowerCase ( Locale . ENGLISH ) + <str> , validationException ) ; } for ( String alias : aliasAction . aliases ) { if ( ! Strings . hasText ( alias ) ) { validationException = addValidationError ( <str> + aliasAction . actionType ( ) . name ( ) . toLowerCase ( Locale . ENGLISH ) + <str> , validationException ) ; } } if ( CollectionUtils . isEmpty ( aliasAction . indices ) ) { validationException = addValidationError ( <str> + aliasAction . actionType ( ) . name ( ) . toLowerCase ( Locale . ENGLISH ) + <str> , validationException ) ; } else { for ( String index : aliasAction . indices ) { if ( ! Strings . hasText ( index ) ) { validationException = addValidationError ( <str> + aliasAction . actionType ( ) . name ( ) . toLowerCase ( Locale . ENGLISH ) + <str> , validationException ) ; } } } } return validationException ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { allAliasActions . add ( readAliasActions ( in ) ) ; } readTimeout ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( allAliasActions . size ( ) ) ; for ( AliasActions aliasAction : allAliasActions ) { aliasAction . writeTo ( out ) ; } writeTimeout ( out ) ; } public IndicesOptions indicesOptions ( ) { return INDICES_OPTIONS ; } private static AliasActions readAliasActions ( StreamInput in ) throws IOException { AliasActions actions = new AliasActions ( ) ; return actions . readFrom ( in ) ; } @Override public List < ? extends IndicesRequest > subRequests ( ) { return allAliasActions ; } } 
