package org . elasticsearch . index . translog ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TwoPhaseCommit ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . bytes . ReleasablePagedBytesReference ; import org . elasticsearch . common . io . stream . ReleasableBytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . Callback ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . shard . AbstractIndexShardComponent ; import org . elasticsearch . index . shard . IndexShardComponent ; import org . elasticsearch . threadpool . ThreadPool ; import java . io . Closeable ; import java . io . EOFException ; import java . io . IOException ; import java . nio . channels . FileChannel ; import java . nio . file . * ; import java . util . * ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class Translog extends AbstractIndexShardComponent implements IndexShardComponent , Closeable , TwoPhaseCommit { public static final String TRANSLOG_GENERATION_KEY = <str> ; public static final String TRANSLOG_UUID_KEY = <str> ; public static final String TRANSLOG_FILE_PREFIX = <str> ; public static final String TRANSLOG_FILE_SUFFIX = <str> ; public static final String CHECKPOINT_SUFFIX = <str> ; public static final String CHECKPOINT_FILE_NAME = <str> + CHECKPOINT_SUFFIX ; static final Pattern PARSE_STRICT_ID_PATTERN = Pattern . compile ( <str> + TRANSLOG_FILE_PREFIX + <str> ) ; private final List < ImmutableTranslogReader > recoveredTranslogs ; private volatile ScheduledFuture < ? > syncScheduler ; private final Set < View > outstandingViews = ConcurrentCollections . newConcurrentSet ( ) ; private BigArrays bigArrays ; protected final ReleasableLock readLock ; protected final ReleasableLock writeLock ; private final Path location ; private TranslogWriter current ; private volatile ImmutableTranslogReader currentCommittingTranslog ; private long lastCommittedTranslogFileGeneration = - <int> ; private final AtomicBoolean closed = new AtomicBoolean ( ) ; private final TranslogConfig config ; private final String translogUUID ; private Callback < View > onViewClose = new Callback < View > ( ) { @Override public void handle ( View view ) { logger . trace ( <str> , view . minTranslogGeneration ( ) ) ; boolean removed = outstandingViews . remove ( view ) ; assert removed : <str> ; } } ; public Translog ( TranslogConfig config ) throws IOException { super ( config . getShardId ( ) , config . getIndexSettings ( ) ) ; this . config = config ; TranslogGeneration translogGeneration = config . getTranslogGeneration ( ) ; if ( translogGeneration = = null | | translogGeneration . translogUUID = = null ) { translogUUID = Strings . randomBase64UUID ( ) ; } else { translogUUID = translogGeneration . translogUUID ; } bigArrays = config . getBigArrays ( ) ; ReadWriteLock rwl = new ReentrantReadWriteLock ( ) ; readLock = new ReleasableLock ( rwl . readLock ( ) ) ; writeLock = new ReleasableLock ( rwl . writeLock ( ) ) ; this . location = config . getTranslogPath ( ) ; Files . createDirectories ( this . location ) ; if ( config . getSyncInterval ( ) . millis ( ) > <int> & & config . getThreadPool ( ) ! = null ) { syncScheduler = config . getThreadPool ( ) . schedule ( config . getSyncInterval ( ) , ThreadPool . Names . SAME , new Sync ( ) ) ; } try { if ( translogGeneration ! = null ) { final Checkpoint checkpoint = Checkpoint . read ( location . resolve ( CHECKPOINT_FILE_NAME ) ) ; this . recoveredTranslogs = recoverFromFiles ( translogGeneration , checkpoint ) ; if ( recoveredTranslogs . isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } current = createWriter ( checkpoint . generation + <int> ) ; this . lastCommittedTranslogFileGeneration = translogGeneration . translogFileGeneration ; } else { this . recoveredTranslogs = Collections . emptyList ( ) ; IOUtils . rm ( location ) ; logger . debug ( <str> ) ; Files . createDirectories ( location ) ; final long generation = <int> ; Checkpoint checkpoint = new Checkpoint ( <int> , <int> , generation ) ; Checkpoint . write ( location . resolve ( CHECKPOINT_FILE_NAME ) , checkpoint , StandardOpenOption . WRITE , StandardOpenOption . CREATE_NEW ) ; current = createWriter ( generation ) ; this . lastCommittedTranslogFileGeneration = - <int> ; } } catch ( Throwable t ) { IOUtils . closeWhileHandlingException ( currentCommittingTranslog , current ) ; throw t ; } } private final ArrayList < ImmutableTranslogReader > recoverFromFiles ( TranslogGeneration translogGeneration , Checkpoint checkpoint ) throws IOException { boolean success = false ; ArrayList < ImmutableTranslogReader > foundTranslogs = new ArrayList < > ( ) ; final Path tempFile = Files . createTempFile ( location , TRANSLOG_FILE_PREFIX , TRANSLOG_FILE_SUFFIX ) ; boolean tempFileRenamed = false ; try ( ReleasableLock lock = writeLock . acquire ( ) ) { logger . debug ( <str> , checkpoint ) ; final String checkpointTranslogFile = getFilename ( checkpoint . generation ) ; for ( long i = translogGeneration . translogFileGeneration ; i < checkpoint . generation ; i + + ) { Path committedTranslogFile = location . resolve ( getFilename ( i ) ) ; if ( Files . exists ( committedTranslogFile ) = = false ) { throw new IllegalStateException ( <str> + i + <str> + lastCommittedTranslogFileGeneration + <str> + checkpoint . generation + <str> ) ; } final ImmutableTranslogReader reader = openReader ( committedTranslogFile , Checkpoint . read ( location . resolve ( getCommitCheckpointFileName ( i ) ) ) ) ; foundTranslogs . add ( reader ) ; logger . debug ( <str> , checkpoint ) ; } foundTranslogs . add ( openReader ( location . resolve ( checkpointTranslogFile ) , checkpoint ) ) ; Path commitCheckpoint = location . resolve ( getCommitCheckpointFileName ( checkpoint . generation ) ) ; if ( Files . exists ( commitCheckpoint ) ) { Checkpoint checkpointFromDisk = Checkpoint . read ( commitCheckpoint ) ; if ( checkpoint . equals ( checkpointFromDisk ) = = false ) { throw new IllegalStateException ( <str> + commitCheckpoint . getFileName ( ) + <str> + checkpoint + <str> + checkpointFromDisk ) ; } } else { Files . copy ( location . resolve ( CHECKPOINT_FILE_NAME ) , tempFile , StandardCopyOption . REPLACE_EXISTING ) ; IOUtils . fsync ( tempFile , false ) ; Files . move ( tempFile , commitCheckpoint , StandardCopyOption . ATOMIC_MOVE ) ; tempFileRenamed = true ; IOUtils . fsync ( commitCheckpoint . getParent ( ) , true ) ; } success = true ; } finally { if ( success = = false ) { IOUtils . closeWhileHandlingException ( foundTranslogs ) ; } if ( tempFileRenamed = = false ) { try { Files . delete ( tempFile ) ; } catch ( IOException ex ) { logger . warn ( <str> , ex , tempFile ) ; } } } return foundTranslogs ; } ImmutableTranslogReader openReader ( Path path , Checkpoint checkpoint ) throws IOException { final long generation ; try { generation = parseIdFromFileName ( path ) ; } catch ( IllegalArgumentException ex ) { throw new TranslogException ( shardId , <str> + path , ex ) ; } FileChannel channel = FileChannel . open ( path , StandardOpenOption . READ ) ; try { final ChannelReference raf = new ChannelReference ( path , generation , channel , new OnCloseRunnable ( ) ) ; ImmutableTranslogReader reader = ImmutableTranslogReader . open ( raf , checkpoint , translogUUID ) ; channel = null ; return reader ; } finally { IOUtils . close ( channel ) ; } } public static long parseIdFromFileName ( Path translogFile ) { final String fileName = translogFile . getFileName ( ) . toString ( ) ; final Matcher matcher = PARSE_STRICT_ID_PATTERN . matcher ( fileName ) ; if ( matcher . matches ( ) ) { try { return Long . parseLong ( matcher . group ( <int> ) ) ; } catch ( NumberFormatException e ) { throw new IllegalStateException ( <str> + fileName + <str> , e ) ; } } throw new IllegalArgumentException ( <str> + fileName ) ; } public void updateBuffer ( ByteSizeValue bufferSize ) { config . setBufferSize ( bufferSize . bytesAsInt ( ) ) ; try ( ReleasableLock lock = writeLock . acquire ( ) ) { current . updateBufferSize ( config . getBufferSize ( ) ) ; } } boolean isOpen ( ) { return closed . get ( ) = = false ; } @Override public void close ( ) throws IOException { if ( closed . compareAndSet ( false , true ) ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { try { IOUtils . close ( current , currentCommittingTranslog ) ; } finally { IOUtils . close ( recoveredTranslogs ) ; recoveredTranslogs . clear ( ) ; } } finally { FutureUtils . cancel ( syncScheduler ) ; logger . debug ( <str> ) ; } } } public Path location ( ) { return location ; } public long currentFileGeneration ( ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { return current . getGeneration ( ) ; } } public int totalOperations ( ) { int ops = <int> ; try ( ReleasableLock lock = readLock . acquire ( ) ) { ops + = current . totalOperations ( ) ; if ( currentCommittingTranslog ! = null ) { int tops = currentCommittingTranslog . totalOperations ( ) ; assert tops ! = TranslogReader . UNKNOWN_OP_COUNT ; assert tops > = <int> ; ops + = tops ; } } return ops ; } public long sizeInBytes ( ) { long size = <int> ; try ( ReleasableLock lock = readLock . acquire ( ) ) { size + = current . sizeInBytes ( ) ; if ( currentCommittingTranslog ! = null ) { size + = currentCommittingTranslog . sizeInBytes ( ) ; } } return size ; } TranslogWriter createWriter ( long fileGeneration ) throws IOException { TranslogWriter newFile ; try { newFile = TranslogWriter . create ( config . getType ( ) , shardId , translogUUID , fileGeneration , location . resolve ( getFilename ( fileGeneration ) ) , new OnCloseRunnable ( ) , config . getBufferSize ( ) ) ; } catch ( IOException e ) { throw new TranslogException ( shardId , <str> , e ) ; } return newFile ; } public Translog . Operation read ( Location location ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { final TranslogReader reader ; final long currentGeneration = current . getGeneration ( ) ; if ( currentGeneration = = location . generation ) { reader = current ; } else if ( currentCommittingTranslog ! = null & & currentCommittingTranslog . getGeneration ( ) = = location . generation ) { reader = currentCommittingTranslog ; } else if ( currentGeneration < location . generation ) { throw new IllegalStateException ( <str> + location . generation + <str> + currentGeneration + <str> ) ; } else { return null ; } return reader . read ( location ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> + location , e ) ; } } public Location add ( Operation operation ) throws TranslogException { final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput ( bigArrays ) ; try { final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput ( out ) ; final long start = out . position ( ) ; out . skip ( RamUsageEstimator . NUM_BYTES_INT ) ; writeOperationNoSize ( checksumStreamOutput , operation ) ; final long end = out . position ( ) ; final int operationSize = ( int ) ( end - RamUsageEstimator . NUM_BYTES_INT - start ) ; out . seek ( start ) ; out . writeInt ( operationSize ) ; out . seek ( end ) ; final ReleasablePagedBytesReference bytes = out . bytes ( ) ; try ( ReleasableLock lock = readLock . acquire ( ) ) { ensureOpen ( ) ; Location location = current . add ( bytes ) ; if ( config . isSyncOnEachOperation ( ) ) { current . sync ( ) ; } assert current . assertBytesAtLocation ( location , bytes ) ; return location ; } } catch ( AlreadyClosedException ex ) { throw ex ; } catch ( Throwable e ) { throw new TranslogException ( shardId , <str> + operation + <str> , e ) ; } finally { Releasables . close ( out . bytes ( ) ) ; } } public Snapshot newSnapshot ( ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { ArrayList < TranslogReader > toOpen = new ArrayList < > ( ) ; toOpen . addAll ( recoveredTranslogs ) ; if ( currentCommittingTranslog ! = null ) { toOpen . add ( currentCommittingTranslog ) ; } toOpen . add ( current ) ; return createSnapshot ( toOpen . toArray ( new TranslogReader [ toOpen . size ( ) ] ) ) ; } } private static Snapshot createSnapshot ( TranslogReader . . . translogs ) { Snapshot [ ] snapshots = new Snapshot [ translogs . length ] ; boolean success = false ; try { for ( int i = <int> ; i < translogs . length ; i + + ) { snapshots [ i ] = translogs [ i ] . newSnapshot ( ) ; } Snapshot snapshot = new MultiSnapshot ( snapshots ) ; success = true ; return snapshot ; } finally { if ( success = = false ) { Releasables . close ( snapshots ) ; } } } public Translog . View newView ( ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { ArrayList < TranslogReader > translogs = new ArrayList < > ( ) ; try { if ( currentCommittingTranslog ! = null ) { translogs . add ( currentCommittingTranslog . clone ( ) ) ; } translogs . add ( current . newReaderFromWriter ( ) ) ; View view = new View ( translogs , onViewClose ) ; outstandingViews . add ( view ) ; translogs . clear ( ) ; return view ; } finally { IOUtils . closeWhileHandlingException ( translogs ) ; } } } public void sync ( ) throws IOException { try ( ReleasableLock lock = readLock . acquire ( ) ) { if ( closed . get ( ) = = false ) { current . sync ( ) ; } } } public boolean syncNeeded ( ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { return current . syncNeeded ( ) ; } } public static String getFilename ( long generation ) { return TRANSLOG_FILE_PREFIX + generation + TRANSLOG_FILE_SUFFIX ; } static String getCommitCheckpointFileName ( long generation ) { return TRANSLOG_FILE_PREFIX + generation + CHECKPOINT_SUFFIX ; } public boolean ensureSynced ( Location location ) throws IOException { try ( ReleasableLock lock = readLock . acquire ( ) ) { if ( location . generation = = current . generation ) { return current . syncUpTo ( location . translogLocation + location . size ) ; } } return false ; } public TranslogStats stats ( ) { try ( ReleasableLock lock = readLock . acquire ( ) ) { return new TranslogStats ( totalOperations ( ) , sizeInBytes ( ) ) ; } } private boolean isReferencedGeneration ( long generation ) { return generation > = lastCommittedTranslogFileGeneration ; } public TranslogConfig getConfig ( ) { return config ; } private final class OnCloseRunnable implements Callback < ChannelReference > { @Override public void handle ( ChannelReference channelReference ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { if ( isReferencedGeneration ( channelReference . getGeneration ( ) ) = = false ) { Path translogPath = channelReference . getPath ( ) ; assert channelReference . getPath ( ) . getParent ( ) . equals ( location ) : <str> + location + <str> + translogPath ; logger . trace ( <str> , translogPath ) ; IOUtils . deleteFilesIgnoringExceptions ( translogPath ) ; IOUtils . deleteFilesIgnoringExceptions ( translogPath . resolveSibling ( getCommitCheckpointFileName ( channelReference . getGeneration ( ) ) ) ) ; } try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( location ) ) { for ( Path path : stream ) { Matcher matcher = PARSE_STRICT_ID_PATTERN . matcher ( path . getFileName ( ) . toString ( ) ) ; if ( matcher . matches ( ) ) { long generation = Long . parseLong ( matcher . group ( <int> ) ) ; if ( isReferencedGeneration ( generation ) = = false ) { logger . trace ( <str> , path ) ; IOUtils . deleteFilesIgnoringExceptions ( path ) ; IOUtils . deleteFilesIgnoringExceptions ( path . resolveSibling ( getCommitCheckpointFileName ( channelReference . getGeneration ( ) ) ) ) ; } } } } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } } } public static final class View implements Closeable { public static final Translog . View EMPTY_VIEW = new View ( Collections . emptyList ( ) , null ) ; boolean closed ; final List < TranslogReader > orderedTranslogs ; private final Callback < View > onClose ; View ( List < TranslogReader > orderedTranslogs , Callback < View > onClose ) { this . orderedTranslogs = new ArrayList < > ( orderedTranslogs ) ; this . onClose = onClose ; } synchronized void onNewTranslog ( TranslogReader oldCurrent , TranslogReader newCurrent ) throws IOException { if ( closed ) { IOUtils . close ( oldCurrent , newCurrent ) ; return ; } orderedTranslogs . remove ( orderedTranslogs . size ( ) - <int> ) . close ( ) ; orderedTranslogs . add ( oldCurrent ) ; orderedTranslogs . add ( newCurrent ) ; } public synchronized long minTranslogGeneration ( ) { ensureOpen ( ) ; return orderedTranslogs . get ( <int> ) . getGeneration ( ) ; } public synchronized int totalOperations ( ) { int ops = <int> ; for ( TranslogReader translog : orderedTranslogs ) { int tops = translog . totalOperations ( ) ; if ( tops = = TranslogReader . UNKNOWN_OP_COUNT ) { return - <int> ; } assert tops > = <int> ; ops + = tops ; } return ops ; } public synchronized long sizeInBytes ( ) { long size = <int> ; for ( TranslogReader translog : orderedTranslogs ) { size + = translog . sizeInBytes ( ) ; } return size ; } public synchronized Snapshot snapshot ( ) { ensureOpen ( ) ; return createSnapshot ( orderedTranslogs . toArray ( new TranslogReader [ orderedTranslogs . size ( ) ] ) ) ; } void ensureOpen ( ) { if ( closed ) { throw new ElasticsearchException ( <str> ) ; } } @Override public void close ( ) { final List < TranslogReader > toClose = new ArrayList < > ( ) ; try { synchronized ( this ) { if ( closed = = false ) { try { if ( onClose ! = null ) { onClose . handle ( this ) ; } } finally { closed = true ; toClose . addAll ( orderedTranslogs ) ; orderedTranslogs . clear ( ) ; } } } } finally { try { IOUtils . close ( toClose ) ; } catch ( Exception e ) { throw new ElasticsearchException ( <str> , e ) ; } } } } class Sync implements Runnable { @Override public void run ( ) { if ( closed . get ( ) ) { return ; } final ThreadPool threadPool = config . getThreadPool ( ) ; if ( syncNeeded ( ) ) { threadPool . executor ( ThreadPool . Names . FLUSH ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { sync ( ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } if ( closed . get ( ) = = false ) { syncScheduler = threadPool . schedule ( config . getSyncInterval ( ) , ThreadPool . Names . SAME , Sync . this ) ; } } } ) ; } else { syncScheduler = threadPool . schedule ( config . getSyncInterval ( ) , ThreadPool . Names . SAME , Sync . this ) ; } } } public static class Location implements Accountable , Comparable < Location > { public final long generation ; public final long translogLocation ; public final int size ; Location ( long generation , long translogLocation , int size ) { this . generation = generation ; this . translogLocation = translogLocation ; this . size = size ; } @Override public long ramBytesUsed ( ) { return RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + <int> * RamUsageEstimator . NUM_BYTES_LONG + RamUsageEstimator . NUM_BYTES_INT ; } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } @Override public String toString ( ) { return <str> + generation + <str> + translogLocation + <str> + size + <str> ; } @Override public int compareTo ( Location o ) { if ( generation = = o . generation ) { return Long . compare ( translogLocation , o . translogLocation ) ; } return Long . compare ( generation , o . generation ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } Location location = ( Location ) o ; if ( generation ! = location . generation ) { return false ; } if ( translogLocation ! = location . translogLocation ) { return false ; } return size = = location . size ; } @Override public int hashCode ( ) { int result = Long . hashCode ( generation ) ; result = <int> * result + Long . hashCode ( translogLocation ) ; result = <int> * result + size ; return result ; } } public interface Snapshot extends Releasable { int estimatedTotalOperations ( ) ; Translog . Operation next ( ) throws IOException ; } public interface Operation extends Streamable { enum Type { @Deprecated CREATE ( ( byte ) <int> ) , INDEX ( ( byte ) <int> ) , DELETE ( ( byte ) <int> ) ; private final byte id ; private Type ( byte id ) { this . id = id ; } public byte id ( ) { return this . id ; } public static Type fromId ( byte id ) { switch ( id ) { case <int> : return CREATE ; case <int> : return INDEX ; case <int> : return DELETE ; default : throw new IllegalArgumentException ( <str> + id + <str> ) ; } } } Type opType ( ) ; long estimateSize ( ) ; Source getSource ( ) ; } public static class Source { public final BytesReference source ; public final String routing ; public final String parent ; public final long timestamp ; public final long ttl ; public Source ( BytesReference source , String routing , String parent , long timestamp , long ttl ) { this . source = source ; this . routing = routing ; this . parent = parent ; this . timestamp = timestamp ; this . ttl = ttl ; } } public static class Index implements Operation { public static final int SERIALIZATION_FORMAT = <int> ; private String id ; private String type ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; private BytesReference source ; private String routing ; private String parent ; private long timestamp ; private long ttl ; public Index ( ) { } public Index ( Engine . Index index ) { this . id = index . id ( ) ; this . type = index . type ( ) ; this . source = index . source ( ) ; this . routing = index . routing ( ) ; this . parent = index . parent ( ) ; this . version = index . version ( ) ; this . timestamp = index . timestamp ( ) ; this . ttl = index . ttl ( ) ; this . versionType = index . versionType ( ) ; } public Index ( String type , String id , byte [ ] source ) { this . type = type ; this . id = id ; this . source = new BytesArray ( source ) ; } @Override public Type opType ( ) { return Type . INDEX ; } @Override public long estimateSize ( ) { return ( ( id . length ( ) + type . length ( ) ) * <int> ) + source . length ( ) + <int> ; } public String type ( ) { return this . type ; } public String id ( ) { return this . id ; } public String routing ( ) { return this . routing ; } public String parent ( ) { return this . parent ; } public long timestamp ( ) { return this . timestamp ; } public long ttl ( ) { return this . ttl ; } public BytesReference source ( ) { return this . source ; } public long version ( ) { return this . version ; } public VersionType versionType ( ) { return versionType ; } @Override public Source getSource ( ) { return new Source ( source , routing , parent , timestamp , ttl ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { int version = in . readVInt ( ) ; id = in . readString ( ) ; type = in . readString ( ) ; source = in . readBytesReference ( ) ; try { if ( version > = <int> ) { if ( in . readBoolean ( ) ) { routing = in . readString ( ) ; } } if ( version > = <int> ) { if ( in . readBoolean ( ) ) { parent = in . readString ( ) ; } } if ( version > = <int> ) { this . version = in . readLong ( ) ; } if ( version > = <int> ) { this . timestamp = in . readLong ( ) ; } if ( version > = <int> ) { this . ttl = in . readLong ( ) ; } if ( version > = <int> ) { this . versionType = VersionType . fromValue ( in . readByte ( ) ) ; } } catch ( Exception e ) { throw new ElasticsearchException ( <str> + type + <str> + id + <str> , e ) ; } assert versionType . validateVersionForWrites ( version ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( SERIALIZATION_FORMAT ) ; out . writeString ( id ) ; out . writeString ( type ) ; out . writeBytesReference ( source ) ; if ( routing = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( routing ) ; } if ( parent = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( parent ) ; } out . writeLong ( version ) ; out . writeLong ( timestamp ) ; out . writeLong ( ttl ) ; out . writeByte ( versionType . getValue ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } Index index = ( Index ) o ; if ( version ! = index . version | | timestamp ! = index . timestamp | | ttl ! = index . ttl | | id . equals ( index . id ) = = false | | type . equals ( index . type ) = = false | | versionType ! = index . versionType | | source . equals ( index . source ) = = false ) { return false ; } if ( routing ! = null ? ! routing . equals ( index . routing ) : index . routing ! = null ) { return false ; } return ! ( parent ! = null ? ! parent . equals ( index . parent ) : index . parent ! = null ) ; } @Override public int hashCode ( ) { int result = id . hashCode ( ) ; result = <int> * result + type . hashCode ( ) ; result = <int> * result + Long . hashCode ( version ) ; result = <int> * result + versionType . hashCode ( ) ; result = <int> * result + source . hashCode ( ) ; result = <int> * result + ( routing ! = null ? routing . hashCode ( ) : <int> ) ; result = <int> * result + ( parent ! = null ? parent . hashCode ( ) : <int> ) ; result = <int> * result + Long . hashCode ( timestamp ) ; result = <int> * result + Long . hashCode ( ttl ) ; return result ; } @Override public String toString ( ) { return <str> + <str> + id + <str> + <str> + type + <str> + <str> ; } } public static class Delete implements Operation { public static final int SERIALIZATION_FORMAT = <int> ; private Term uid ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; public Delete ( ) { } public Delete ( Engine . Delete delete ) { this ( delete . uid ( ) ) ; this . version = delete . version ( ) ; this . versionType = delete . versionType ( ) ; } public Delete ( Term uid ) { this . uid = uid ; } public Delete ( Term uid , long version , VersionType versionType ) { this . uid = uid ; this . version = version ; this . versionType = versionType ; } @Override public Type opType ( ) { return Type . DELETE ; } @Override public long estimateSize ( ) { return ( ( uid . field ( ) . length ( ) + uid . text ( ) . length ( ) ) * <int> ) + <int> ; } public Term uid ( ) { return this . uid ; } public long version ( ) { return this . version ; } public VersionType versionType ( ) { return this . versionType ; } @Override public Source getSource ( ) { throw new IllegalStateException ( <str> ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { int version = in . readVInt ( ) ; uid = new Term ( in . readString ( ) , in . readString ( ) ) ; if ( version > = <int> ) { this . version = in . readLong ( ) ; } if ( version > = <int> ) { this . versionType = VersionType . fromValue ( in . readByte ( ) ) ; } assert versionType . validateVersionForWrites ( version ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( SERIALIZATION_FORMAT ) ; out . writeString ( uid . field ( ) ) ; out . writeString ( uid . text ( ) ) ; out . writeLong ( version ) ; out . writeByte ( versionType . getValue ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } Delete delete = ( Delete ) o ; return version = = delete . version & & uid . equals ( delete . uid ) & & versionType = = delete . versionType ; } @Override public int hashCode ( ) { int result = uid . hashCode ( ) ; result = <int> * result + Long . hashCode ( version ) ; result = <int> * result + versionType . hashCode ( ) ; return result ; } @Override public String toString ( ) { return <str> + <str> + uid + <str> ; } } public enum Durabilty { ASYNC , REQUEST ; } private static void verifyChecksum ( BufferedChecksumStreamInput in ) throws IOException { long expectedChecksum = in . getChecksum ( ) ; long readChecksum = in . readInt ( ) & <hex> ; if ( readChecksum ! = expectedChecksum ) { throw new TranslogCorruptedException ( <str> + Long . toHexString ( expectedChecksum ) + <str> + Long . toHexString ( readChecksum ) ) ; } } public static List < Operation > readOperations ( StreamInput input ) throws IOException { ArrayList < Operation > operations = new ArrayList < > ( ) ; int numOps = input . readInt ( ) ; final BufferedChecksumStreamInput checksumStreamInput = new BufferedChecksumStreamInput ( input ) ; for ( int i = <int> ; i < numOps ; i + + ) { operations . add ( readOperation ( checksumStreamInput ) ) ; } return operations ; } static Translog . Operation readOperation ( BufferedChecksumStreamInput in ) throws IOException { Translog . Operation operation ; try { final int opSize = in . readInt ( ) ; if ( opSize < <int> ) { throw new AssertionError ( <str> + opSize ) ; } in . resetDigest ( ) ; if ( in . markSupported ( ) ) { in . mark ( opSize ) ; in . skip ( opSize - <int> ) ; verifyChecksum ( in ) ; in . reset ( ) ; } Translog . Operation . Type type = Translog . Operation . Type . fromId ( in . readByte ( ) ) ; operation = newOperationFromType ( type ) ; operation . readFrom ( in ) ; verifyChecksum ( in ) ; } catch ( EOFException e ) { throw new TruncatedTranslogException ( <str> , e ) ; } catch ( AssertionError | Exception e ) { throw new TranslogCorruptedException ( <str> , e ) ; } return operation ; } public static void writeOperations ( StreamOutput outStream , List < Operation > toWrite ) throws IOException { final ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput ( BigArrays . NON_RECYCLING_INSTANCE ) ; try { outStream . writeInt ( toWrite . size ( ) ) ; final BufferedChecksumStreamOutput checksumStreamOutput = new BufferedChecksumStreamOutput ( out ) ; for ( Operation op : toWrite ) { out . reset ( ) ; final long start = out . position ( ) ; out . skip ( RamUsageEstimator . NUM_BYTES_INT ) ; writeOperationNoSize ( checksumStreamOutput , op ) ; long end = out . position ( ) ; int operationSize = ( int ) ( out . position ( ) - RamUsageEstimator . NUM_BYTES_INT - start ) ; out . seek ( start ) ; out . writeInt ( operationSize ) ; out . seek ( end ) ; ReleasablePagedBytesReference bytes = out . bytes ( ) ; bytes . writeTo ( outStream ) ; } } finally { Releasables . close ( out . bytes ( ) ) ; } } public static void writeOperationNoSize ( BufferedChecksumStreamOutput out , Translog . Operation op ) throws IOException { out . resetDigest ( ) ; out . writeByte ( op . opType ( ) . id ( ) ) ; op . writeTo ( out ) ; long checksum = out . getChecksum ( ) ; out . writeInt ( ( int ) checksum ) ; } static Translog . Operation newOperationFromType ( Translog . Operation . Type type ) throws IOException { switch ( type ) { case CREATE : return new Index ( ) ; case DELETE : return new Translog . Delete ( ) ; case INDEX : return new Index ( ) ; default : throw new IOException ( <str> + type + <str> ) ; } } @Override public void prepareCommit ( ) throws IOException { try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; if ( currentCommittingTranslog ! = null ) { throw new IllegalStateException ( <str> + currentCommittingTranslog . getGeneration ( ) ) ; } final TranslogWriter oldCurrent = current ; oldCurrent . sync ( ) ; currentCommittingTranslog = current . immutableReader ( ) ; Path checkpoint = location . resolve ( CHECKPOINT_FILE_NAME ) ; assert Checkpoint . read ( checkpoint ) . generation = = currentCommittingTranslog . getGeneration ( ) ; Path commitCheckpoint = location . resolve ( getCommitCheckpointFileName ( currentCommittingTranslog . getGeneration ( ) ) ) ; Files . copy ( checkpoint , commitCheckpoint ) ; IOUtils . fsync ( commitCheckpoint , false ) ; IOUtils . fsync ( commitCheckpoint . getParent ( ) , true ) ; current = createWriter ( current . getGeneration ( ) + <int> ) ; for ( View view : outstandingViews ) { view . onNewTranslog ( currentCommittingTranslog . clone ( ) , current . newReaderFromWriter ( ) ) ; } IOUtils . close ( oldCurrent ) ; logger . trace ( <str> , current . getGeneration ( ) ) ; assert oldCurrent . syncNeeded ( ) = = false : <str> ; } catch ( Throwable t ) { IOUtils . closeWhileHandlingException ( this ) ; throw t ; } } @Override public void commit ( ) throws IOException { ImmutableTranslogReader toClose = null ; try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; if ( currentCommittingTranslog = = null ) { prepareCommit ( ) ; } lastCommittedTranslogFileGeneration = current . getGeneration ( ) ; if ( recoveredTranslogs . isEmpty ( ) = = false ) { IOUtils . close ( recoveredTranslogs ) ; recoveredTranslogs . clear ( ) ; } toClose = this . currentCommittingTranslog ; this . currentCommittingTranslog = null ; } finally { IOUtils . close ( toClose ) ; } } @Override public void rollback ( ) throws IOException { ensureOpen ( ) ; close ( ) ; } public final static class TranslogGeneration { public final String translogUUID ; public final long translogFileGeneration ; public TranslogGeneration ( String translogUUID , long translogFileGeneration ) { this . translogUUID = translogUUID ; this . translogFileGeneration = translogFileGeneration ; } } public TranslogGeneration getGeneration ( ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { return new TranslogGeneration ( translogUUID , currentFileGeneration ( ) ) ; } } public boolean isCurrent ( TranslogGeneration generation ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { if ( generation ! = null ) { if ( generation . translogUUID . equals ( translogUUID ) = = false ) { throw new IllegalArgumentException ( <str> + generation . translogUUID + <str> + translogUUID ) ; } return generation . translogFileGeneration = = currentFileGeneration ( ) ; } } return false ; } long getFirstOperationPosition ( ) { return current . getFirstOperationOffset ( ) ; } private void ensureOpen ( ) { if ( closed . get ( ) ) { throw new AlreadyClosedException ( <str> ) ; } } int getNumOpenViews ( ) { return outstandingViews . size ( ) ; } } 
