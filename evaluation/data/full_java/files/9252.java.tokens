package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . primitives . Primitives ; import java . io . Serializable ; import java . util . Map ; import javax . annotation . Nullable ; public final class ImmutableClassToInstanceMap < B > extends ForwardingMap < Class < ? extends B > , B > implements ClassToInstanceMap < B > , Serializable { private static final ImmutableClassToInstanceMap < Object > EMPTY = new ImmutableClassToInstanceMap < Object > ( ImmutableMap . < Class < ? > , Object > of ( ) ) ; @SuppressWarnings ( <str> ) public static < B > ImmutableClassToInstanceMap < B > of ( ) { return ( ImmutableClassToInstanceMap < B > ) EMPTY ; } public static < B , T extends B > ImmutableClassToInstanceMap < B > of ( Class < T > type , T value ) { ImmutableMap < Class < ? extends B > , B > map = ImmutableMap . < Class < ? extends B > , B > of ( type , value ) ; return new ImmutableClassToInstanceMap < B > ( map ) ; } public static < B > Builder < B > builder ( ) { return new Builder < B > ( ) ; } public static final class Builder < B > { private final ImmutableMap . Builder < Class < ? extends B > , B > mapBuilder = ImmutableMap . builder ( ) ; public < T extends B > Builder < B > put ( Class < T > key , T value ) { mapBuilder . put ( key , value ) ; return this ; } public < T extends B > Builder < B > putAll ( Map < ? extends Class < ? extends T > , ? extends T > map ) { for ( Entry < ? extends Class < ? extends T > , ? extends T > entry : map . entrySet ( ) ) { Class < ? extends T > type = entry . getKey ( ) ; T value = entry . getValue ( ) ; mapBuilder . put ( type , cast ( type , value ) ) ; } return this ; } private static < B , T extends B > T cast ( Class < T > type , B value ) { return Primitives . wrap ( type ) . cast ( value ) ; } public ImmutableClassToInstanceMap < B > build ( ) { ImmutableMap < Class < ? extends B > , B > map = mapBuilder . build ( ) ; if ( map . isEmpty ( ) ) { return of ( ) ; } else { return new ImmutableClassToInstanceMap < B > ( map ) ; } } } public static < B , S extends B > ImmutableClassToInstanceMap < B > copyOf ( Map < ? extends Class < ? extends S > , ? extends S > map ) { if ( map instanceof ImmutableClassToInstanceMap ) { @SuppressWarnings ( <str> ) ImmutableClassToInstanceMap < B > cast = ( ImmutableClassToInstanceMap ) map ; return cast ; } return new Builder < B > ( ) . putAll ( map ) . build ( ) ; } private final ImmutableMap < Class < ? extends B > , B > delegate ; private ImmutableClassToInstanceMap ( ImmutableMap < Class < ? extends B > , B > delegate ) { this . delegate = delegate ; } @Override protected Map < Class < ? extends B > , B > delegate ( ) { return delegate ; } @Override @SuppressWarnings ( <str> ) @Nullable public < T extends B > T getInstance ( Class < T > type ) { return ( T ) delegate . get ( checkNotNull ( type ) ) ; } @Deprecated @Override public < T extends B > T putInstance ( Class < T > type , T value ) { throw new UnsupportedOperationException ( ) ; } Object readResolve ( ) { return isEmpty ( ) ? of ( ) : this ; } } 
