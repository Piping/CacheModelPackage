package org . elasticsearch . common . recycler ; import java . util . Deque ; public class DequeRecycler < T > extends AbstractRecycler < T > { final Deque < T > deque ; final int maxSize ; public DequeRecycler ( C < T > c , Deque < T > queue , int maxSize ) { super ( c ) ; this . deque = queue ; this . maxSize = maxSize ; } @Override public void close ( ) { for ( T t : deque ) { c . destroy ( t ) ; } deque . clear ( ) ; } @Override public V < T > obtain ( int sizing ) { final T v = deque . pollFirst ( ) ; if ( v = = null ) { return new DV ( c . newInstance ( sizing ) , false ) ; } return new DV ( v , true ) ; } protected boolean beforeRelease ( ) { return deque . size ( ) < maxSize ; } protected void afterRelease ( boolean recycled ) { } private class DV implements Recycler . V < T > { T value ; final boolean recycled ; DV ( T value , boolean recycled ) { this . value = value ; this . recycled = recycled ; } @Override public T v ( ) { return value ; } @Override public boolean isRecycled ( ) { return recycled ; } @Override public void close ( ) { if ( value = = null ) { throw new IllegalStateException ( <str> ) ; } final boolean recycle = beforeRelease ( ) ; if ( recycle ) { c . recycle ( value ) ; deque . addFirst ( value ) ; } else { c . destroy ( value ) ; } value = null ; afterRelease ( recycle ) ; } } } 
