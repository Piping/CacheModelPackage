package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . miscellaneous . Lucene47WordDelimiterFilter ; import org . apache . lucene . analysis . miscellaneous . WordDelimiterFilter ; import org . apache . lucene . analysis . miscellaneous . WordDelimiterIterator ; import org . apache . lucene . analysis . util . CharArraySet ; import org . apache . lucene . util . Version ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . env . Environment ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . IndexSettings ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static org . apache . lucene . analysis . miscellaneous . WordDelimiterFilter . * ; public class WordDelimiterTokenFilterFactory extends AbstractTokenFilterFactory { private final byte [ ] charTypeTable ; private final int flags ; private final CharArraySet protoWords ; public WordDelimiterTokenFilterFactory ( IndexSettings indexSettings , Environment env , String name , Settings settings ) { super ( indexSettings , name , settings ) ; List < String > charTypeTableValues = Analysis . getWordList ( env , settings , <str> ) ; if ( charTypeTableValues = = null ) { this . charTypeTable = WordDelimiterIterator . DEFAULT_WORD_DELIM_TABLE ; } else { this . charTypeTable = parseTypes ( charTypeTableValues ) ; } int flags = <int> ; flags | = getFlag ( GENERATE_WORD_PARTS , settings , <str> , true ) ; flags | = getFlag ( GENERATE_NUMBER_PARTS , settings , <str> , true ) ; flags | = getFlag ( CATENATE_WORDS , settings , <str> , false ) ; flags | = getFlag ( CATENATE_NUMBERS , settings , <str> , false ) ; flags | = getFlag ( CATENATE_ALL , settings , <str> , false ) ; flags | = getFlag ( SPLIT_ON_CASE_CHANGE , settings , <str> , true ) ; flags | = getFlag ( PRESERVE_ORIGINAL , settings , <str> , false ) ; flags | = getFlag ( SPLIT_ON_NUMERICS , settings , <str> , true ) ; flags | = getFlag ( STEM_ENGLISH_POSSESSIVE , settings , <str> , true ) ; Set < ? > protectedWords = Analysis . getWordSet ( env , settings , <str> ) ; this . protoWords = protectedWords = = null ? null : CharArraySet . copy ( protectedWords ) ; this . flags = flags ; } @Override public TokenStream create ( TokenStream tokenStream ) { if ( version . onOrAfter ( Version . LUCENE_4_8 ) ) { return new WordDelimiterFilter ( tokenStream , charTypeTable , flags , protoWords ) ; } else { return new Lucene47WordDelimiterFilter ( tokenStream , charTypeTable , flags , protoWords ) ; } } public int getFlag ( int flag , Settings settings , String key , boolean defaultValue ) { if ( settings . getAsBoolean ( key , defaultValue ) ) { return flag ; } return <int> ; } private static Pattern typePattern = Pattern . compile ( <str> ) ; private byte [ ] parseTypes ( Collection < String > rules ) { SortedMap < Character , Byte > typeMap = new TreeMap < > ( ) ; for ( String rule : rules ) { Matcher m = typePattern . matcher ( rule ) ; if ( ! m . find ( ) ) throw new RuntimeException ( <str> + rule + <str> ) ; String lhs = parseString ( m . group ( <int> ) . trim ( ) ) ; Byte rhs = parseType ( m . group ( <int> ) . trim ( ) ) ; if ( lhs . length ( ) ! = <int> ) throw new RuntimeException ( <str> + rule + <str> ) ; if ( rhs = = null ) throw new RuntimeException ( <str> + rule + <str> ) ; typeMap . put ( lhs . charAt ( <int> ) , rhs ) ; } byte types [ ] = new byte [ Math . max ( typeMap . lastKey ( ) + <int> , WordDelimiterIterator . DEFAULT_WORD_DELIM_TABLE . length ) ] ; for ( int i = <int> ; i < types . length ; i + + ) types [ i ] = WordDelimiterIterator . getType ( i ) ; for ( Map . Entry < Character , Byte > mapping : typeMap . entrySet ( ) ) types [ mapping . getKey ( ) ] = mapping . getValue ( ) ; return types ; } private Byte parseType ( String s ) { if ( s . equals ( <str> ) ) return WordDelimiterFilter . LOWER ; else if ( s . equals ( <str> ) ) return WordDelimiterFilter . UPPER ; else if ( s . equals ( <str> ) ) return WordDelimiterFilter . ALPHA ; else if ( s . equals ( <str> ) ) return WordDelimiterFilter . DIGIT ; else if ( s . equals ( <str> ) ) return WordDelimiterFilter . ALPHANUM ; else if ( s . equals ( <str> ) ) return WordDelimiterFilter . SUBWORD_DELIM ; else return null ; } char [ ] out = new char [ <int> ] ; private String parseString ( String s ) { int readPos = <int> ; int len = s . length ( ) ; int writePos = <int> ; while ( readPos < len ) { char c = s . charAt ( readPos + + ) ; if ( c = = <str> ) { if ( readPos > = len ) throw new RuntimeException ( <str> + s + <str> ) ; c = s . charAt ( readPos + + ) ; switch ( c ) { case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : if ( readPos + <int> > = len ) throw new RuntimeException ( <str> + s + <str> ) ; c = ( char ) Integer . parseInt ( s . substring ( readPos , readPos + <int> ) , <int> ) ; readPos + = <int> ; break ; } } out [ writePos + + ] = c ; } return new String ( out , <int> , writePos ) ; } } 
