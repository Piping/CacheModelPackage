package com . google . common . base ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . ImmutableMap ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . regex . Pattern ; @GwtCompatible ( emulated = true ) public class SplitterTest extends TestCase { private static final Splitter COMMA_SPLITTER = Splitter . on ( <str> ) ; @SuppressWarnings ( <str> ) public void testSplitNullString ( ) { try { COMMA_SPLITTER . split ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCharacterSimpleSplit ( ) { String simple = <str> ; Iterable < String > letters = COMMA_SPLITTER . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSimpleSplitToList ( ) { String simple = <str> ; List < String > letters = COMMA_SPLITTER . splitToList ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testToString ( ) { assertEquals ( <str> , Splitter . on ( <str> ) . split ( <str> ) . toString ( ) ) ; assertEquals ( <str> , Splitter . on ( <str> ) . split ( <str> ) . toString ( ) ) ; assertEquals ( <str> , Splitter . on ( <str> ) . split ( <str> ) . toString ( ) ) ; } public void testCharacterSimpleSplitWithNoDelimiter ( ) { String simple = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testCharacterSplitWithDoubleDelimiter ( ) { String doubled = <str> ; Iterable < String > letters = COMMA_SPLITTER . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithDoubleDelimiterAndSpace ( ) { String doubled = <str> ; Iterable < String > letters = COMMA_SPLITTER . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithTrailingDelimiter ( ) { String trailing = <str> ; Iterable < String > letters = COMMA_SPLITTER . split ( trailing ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithLeadingDelimiter ( ) { String leading = <str> ; Iterable < String > letters = COMMA_SPLITTER . split ( leading ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithMulitpleLetters ( ) { Iterable < String > testCharacteringMotto = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( testCharacteringMotto ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithMatcherDelimiter ( ) { Iterable < String > testCharacteringMotto = Splitter . on ( CharMatcher . WHITESPACE ) . split ( <str> ) ; assertThat ( testCharacteringMotto ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitWithDoubleDelimiterOmitEmptyStrings ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitEmptyToken ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitEmptyTokenOmitEmptyStrings ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitOnEmptyString ( ) { Iterable < String > nothing = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( nothing ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testCharacterSplitOnEmptyStringOmitEmptyStrings ( ) { assertThat ( Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( <str> ) ) . isEmpty ( ) ; } public void testCharacterSplitOnOnlyDelimiter ( ) { Iterable < String > blankblank = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( blankblank ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testCharacterSplitOnOnlyDelimitersOmitEmptyStrings ( ) { Iterable < String > empty = Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( <str> ) ; assertThat ( empty ) . isEmpty ( ) ; } public void testCharacterSplitWithTrim ( ) { String jacksons = <str> + <str> ; Iterable < String > family = COMMA_SPLITTER . trimResults ( CharMatcher . anyOf ( <str> ) . or ( CharMatcher . WHITESPACE ) ) . split ( jacksons ) ; assertThat ( family ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSimpleSplit ( ) { String simple = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSimpleSplitWithNoDelimiter ( ) { String simple = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testStringSplitWithDoubleDelimiter ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithDoubleDelimiterAndSpace ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithTrailingDelimiter ( ) { String trailing = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( trailing ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithLeadingDelimiter ( ) { String leading = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( leading ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithMultipleLetters ( ) { Iterable < String > testStringingMotto = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( testStringingMotto ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithDoubleDelimiterOmitEmptyStrings ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitEmptyToken ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitEmptyTokenOmitEmptyStrings ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithLongDelimiter ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithLongLeadingDelimiter ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithLongTrailingDelimiter ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( <str> ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testStringSplitWithDelimiterSubstringInValue ( ) { String fourCommasAndFourSpaces = <str> ; Iterable < String > threeCommasThenThreeSpaces = Splitter . on ( <str> ) . split ( fourCommasAndFourSpaces ) ; assertThat ( threeCommasThenThreeSpaces ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testStringSplitWithEmptyString ( ) { try { Splitter . on ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testStringSplitOnEmptyString ( ) { Iterable < String > notMuch = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( notMuch ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testStringSplitOnEmptyStringOmitEmptyString ( ) { assertThat ( Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( <str> ) ) . isEmpty ( ) ; } public void testStringSplitOnOnlyDelimiter ( ) { Iterable < String > blankblank = Splitter . on ( <str> ) . split ( <str> ) ; assertThat ( blankblank ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testStringSplitOnOnlyDelimitersOmitEmptyStrings ( ) { Iterable < String > empty = Splitter . on ( <str> ) . omitEmptyStrings ( ) . split ( <str> ) ; assertThat ( empty ) . isEmpty ( ) ; } public void testStringSplitWithTrim ( ) { String jacksons = <str> + <str> ; Iterable < String > family = Splitter . on ( <str> ) . trimResults ( CharMatcher . anyOf ( <str> ) . or ( CharMatcher . WHITESPACE ) ) . split ( jacksons ) ; assertThat ( family ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSimpleSplit ( ) { String simple = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSimpleSplitWithNoDelimiter ( ) { String simple = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithDoubleDelimiter ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithDoubleDelimiterAndSpace ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithTrailingDelimiter ( ) { String trailing = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( trailing ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithLeadingDelimiter ( ) { String leading = <str> ; Iterable < String > letters = Splitter . onPattern ( <str> ) . split ( leading ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithMultipleLetters ( ) { Iterable < String > testPatterningMotto = Splitter . onPattern ( <str> ) . split ( <str> ) ; assertThat ( testPatterningMotto ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) private static Pattern literalDotPattern ( ) { return Pattern . compile ( <str> ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithDoubleDelimiterOmitEmptyStrings ( ) { String doubled = <str> ; Iterable < String > letters = Splitter . on ( literalDotPattern ( ) ) . omitEmptyStrings ( ) . split ( doubled ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testPatternSplitLookBehind ( ) { String toSplit = <str> ; String regexPattern = <str> ; Iterable < String > split = Splitter . onPattern ( regexPattern ) . split ( toSplit ) ; assertThat ( split ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testPatternSplitWordBoundary ( ) { String string = <str> ; Iterable < String > words = Splitter . on ( Pattern . compile ( <str> ) ) . split ( string ) ; assertThat ( words ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitEmptyToken ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( literalDotPattern ( ) ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitEmptyTokenOmitEmptyStrings ( ) { String emptyToken = <str> ; Iterable < String > letters = Splitter . on ( literalDotPattern ( ) ) . omitEmptyStrings ( ) . trimResults ( ) . split ( emptyToken ) ; assertThat ( letters ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitOnOnlyDelimiter ( ) { Iterable < String > blankblank = Splitter . on ( literalDotPattern ( ) ) . split ( <str> ) ; assertThat ( blankblank ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitOnOnlyDelimitersOmitEmptyStrings ( ) { Iterable < String > empty = Splitter . on ( literalDotPattern ( ) ) . omitEmptyStrings ( ) . split ( <str> ) ; assertThat ( empty ) . isEmpty ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitMatchingIsGreedy ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( Pattern . compile ( <str> ) ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithLongLeadingDelimiter ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( Pattern . compile ( <str> ) ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testPatternSplitWithLongTrailingDelimiter ( ) { String longDelimiter = <str> ; Iterable < String > letters = Splitter . on ( Pattern . compile ( <str> ) ) . split ( longDelimiter ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) public void testPatternSplitInvalidPattern ( ) { try { Splitter . on ( Pattern . compile ( <str> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testPatternSplitWithTrim ( ) { String jacksons = <str> + <str> ; Iterable < String > family = Splitter . on ( Pattern . compile ( <str> ) ) . trimResults ( CharMatcher . anyOf ( <str> ) . or ( CharMatcher . WHITESPACE ) ) . split ( jacksons ) ; assertThat ( family ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testSplitterIterableIsUnmodifiable_char ( ) { assertIteratorIsUnmodifiable ( COMMA_SPLITTER . split ( <str> ) . iterator ( ) ) ; } public void testSplitterIterableIsUnmodifiable_string ( ) { assertIteratorIsUnmodifiable ( Splitter . on ( <str> ) . split ( <str> ) . iterator ( ) ) ; } @GwtIncompatible ( <str> ) public void testSplitterIterableIsUnmodifiable_pattern ( ) { assertIteratorIsUnmodifiable ( Splitter . on ( Pattern . compile ( <str> ) ) . split ( <str> ) . iterator ( ) ) ; } private void assertIteratorIsUnmodifiable ( Iterator < ? > iterator ) { iterator . next ( ) ; try { iterator . remove ( ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testSplitterIterableIsLazy_char ( ) { assertSplitterIterableIsLazy ( COMMA_SPLITTER ) ; } public void testSplitterIterableIsLazy_string ( ) { assertSplitterIterableIsLazy ( Splitter . on ( <str> ) ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testSplitterIterableIsLazy_pattern ( ) { assertSplitterIterableIsLazy ( Splitter . onPattern ( <str> ) ) ; } private void assertSplitterIterableIsLazy ( Splitter splitter ) { StringBuilder builder = new StringBuilder ( ) ; Iterator < String > iterator = splitter . split ( builder ) . iterator ( ) ; builder . append ( <str> ) ; assertEquals ( <str> , iterator . next ( ) ) ; builder . append ( <str> ) ; assertEquals ( <str> , iterator . next ( ) ) ; builder . append ( <str> ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testFixedLengthSimpleSplit ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testFixedLengthSplitEqualChunkLength ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testFixedLengthSplitOnlyOneChunk ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testFixedLengthSplitSmallerString ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testFixedLengthSplitEmptyString ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testFixedLengthSplitEmptyStringWithOmitEmptyStrings ( ) { assertThat ( Splitter . fixedLength ( <int> ) . omitEmptyStrings ( ) . split ( <str> ) ) . isEmpty ( ) ; } public void testFixedLengthSplitIntoChars ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testFixedLengthSplitZeroChunkLen ( ) { try { Splitter . fixedLength ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testFixedLengthSplitNegativeChunkLen ( ) { try { Splitter . fixedLength ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testLimitLarge ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . limit ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testLimitOne ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . limit ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testLimitFixedLength ( ) { String simple = <str> ; Iterable < String > letters = Splitter . fixedLength ( <int> ) . limit ( <int> ) . split ( simple ) ; assertThat ( letters ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testLimitSeparator ( ) { String simple = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . split ( simple ) ; assertThat ( items ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparators ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsOmitEmpty ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . omitEmptyStrings ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsOmitEmpty3 ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . omitEmptyStrings ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim3 ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim1 ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim1NoOmit ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . trimResults ( ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim1Empty ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . limit ( <int> ) . split ( text ) ; assertThat ( items ) . containsExactly ( <str> ) . inOrder ( ) ; } public void testLimitExtraSeparatorsTrim1EmptyOmit ( ) { String text = <str> ; Iterable < String > items = COMMA_SPLITTER . omitEmptyStrings ( ) . limit ( <int> ) . split ( text ) ; assertThat ( items ) . isEmpty ( ) ; } @SuppressWarnings ( <str> ) public void testInvalidZeroLimit ( ) { try { COMMA_SPLITTER . limit ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( Splitter . class ) ; tester . testAllPublicInstanceMethods ( Splitter . on ( <str> ) ) ; tester . testAllPublicInstanceMethods ( Splitter . on ( <str> ) . trimResults ( ) ) ; } public void testMapSplitter_trimmedBoth ( ) { Map < String , String > m = COMMA_SPLITTER . trimResults ( ) . withKeyValueSeparator ( Splitter . on ( <str> ) . trimResults ( ) ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } public void testMapSplitter_trimmedEntries ( ) { Map < String , String > m = COMMA_SPLITTER . trimResults ( ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } public void testMapSplitter_trimmedKeyValue ( ) { Map < String , String > m = COMMA_SPLITTER . withKeyValueSeparator ( Splitter . on ( <str> ) . trimResults ( ) ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } public void testMapSplitter_notTrimmed ( ) { Map < String , String > m = COMMA_SPLITTER . withKeyValueSeparator ( <str> ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } public void testMapSplitter_CharacterSeparator ( ) { Map < String , String > m = Splitter . on ( <str> ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } public void testMapSplitter_multiCharacterSeparator ( ) { Map < String , String > m = Splitter . on ( <str> ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; ImmutableMap < String , String > expected = ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( m ) . isEqualTo ( expected ) ; assertThat ( m . entrySet ( ) ) . containsExactlyElementsIn ( expected . entrySet ( ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testMapSplitter_emptySeparator ( ) { try { COMMA_SPLITTER . withKeyValueSeparator ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testMapSplitter_malformedEntry ( ) { try { COMMA_SPLITTER . withKeyValueSeparator ( <str> ) . split ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMapSplitter_orderedResults ( ) { Map < String , String > m = Splitter . on ( <str> ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; assertThat ( m . keySet ( ) ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( m ) . isEqualTo ( ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; m = Splitter . on ( <str> ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; assertThat ( m . keySet ( ) ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( m ) . isEqualTo ( ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; } @SuppressWarnings ( <str> ) public void testMapSplitter_duplicateKeys ( ) { try { Splitter . on ( <str> ) . withKeyValueSeparator ( <str> ) . split ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } } 
