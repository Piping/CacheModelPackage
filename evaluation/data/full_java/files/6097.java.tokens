package org . elasticsearch . common . util ; import org . elasticsearch . common . inject . Binder ; import org . elasticsearch . common . inject . multibindings . MapBinder ; import org . elasticsearch . common . inject . multibindings . Multibinder ; import org . elasticsearch . common . settings . Settings ; import java . util . * ; public abstract class ExtensionPoint { protected final String name ; protected final Class < ? > [ ] singletons ; public ExtensionPoint ( String name , Class < ? > . . . singletons ) { this . name = name ; this . singletons = singletons ; } public final void bind ( Binder binder ) { for ( Class < ? > c : singletons ) { binder . bind ( c ) . asEagerSingleton ( ) ; } bindExtensions ( binder ) ; } protected abstract void bindExtensions ( Binder binder ) ; public static class ClassMap < T > extends ExtensionPoint { protected final Class < T > extensionClass ; private final Map < String , Class < ? extends T > > extensions = new HashMap < > ( ) ; private final Set < String > reservedKeys ; public ClassMap ( String name , Class < T > extensionClass , Set < String > reservedKeys , Class < ? > . . . singletons ) { super ( name , singletons ) ; this . extensionClass = extensionClass ; this . reservedKeys = reservedKeys ; } public Class < ? extends T > getExtension ( String type ) { return extensions . get ( type ) ; } public final void registerExtension ( String key , Class < ? extends T > extension ) { if ( extensions . containsKey ( key ) | | reservedKeys . contains ( key ) ) { throw new IllegalArgumentException ( <str> + this . name + <str> + key + <str> ) ; } extensions . put ( key , extension ) ; } @Override protected final void bindExtensions ( Binder binder ) { MapBinder < String , T > parserMapBinder = MapBinder . newMapBinder ( binder , String . class , extensionClass ) ; for ( Map . Entry < String , Class < ? extends T > > clazz : extensions . entrySet ( ) ) { parserMapBinder . addBinding ( clazz . getKey ( ) ) . to ( clazz . getValue ( ) ) ; } } } public static final class SelectedType < T > extends ClassMap < T > { public SelectedType ( String name , Class < T > extensionClass ) { super ( name , extensionClass , Collections . emptySet ( ) ) ; } public String bindType ( Binder binder , Settings settings , String settingsKey , String defaultValue ) { final String type = settings . get ( settingsKey , defaultValue ) ; if ( type = = null ) { throw new IllegalArgumentException ( <str> + settingsKey + <str> ) ; } final Class < ? extends T > instance = getExtension ( type ) ; if ( instance = = null ) { throw new IllegalArgumentException ( <str> + this . name + <str> + type + <str> ) ; } if ( extensionClass = = instance ) { binder . bind ( extensionClass ) . asEagerSingleton ( ) ; } else { binder . bind ( extensionClass ) . to ( instance ) . asEagerSingleton ( ) ; } return type ; } } public final static class ClassSet < T > extends ExtensionPoint { protected final Class < T > extensionClass ; private final Set < Class < ? extends T > > extensions = new HashSet < > ( ) ; public ClassSet ( String name , Class < T > extensionClass , Class < ? > . . . singletons ) { super ( name , singletons ) ; this . extensionClass = extensionClass ; } public final void registerExtension ( Class < ? extends T > extension ) { if ( extensions . contains ( extension ) ) { throw new IllegalArgumentException ( <str> + this . name + <str> + extension . getName ( ) + <str> ) ; } extensions . add ( extension ) ; } @Override protected final void bindExtensions ( Binder binder ) { Multibinder < T > allocationMultibinder = Multibinder . newSetBinder ( binder , extensionClass ) ; for ( Class < ? extends T > clazz : extensions ) { binder . bind ( clazz ) . asEagerSingleton ( ) ; allocationMultibinder . addBinding ( ) . to ( clazz ) ; } } } public final static class InstanceMap < K , V > extends ExtensionPoint { private final Map < K , V > map = new HashMap < > ( ) ; private final Class < K > keyType ; private final Class < V > valueType ; public InstanceMap ( String name , Class < K > keyType , Class < V > valueType , Class < ? > . . . singletons ) { super ( name , singletons ) ; this . keyType = keyType ; this . valueType = valueType ; } public final void registerExtension ( K key , V value ) { V old = map . put ( key , value ) ; if ( old ! = null ) { throw new IllegalArgumentException ( <str> + this . name + <str> + key + <str> + value + <str> + old + <str> ) ; } } @Override protected void bindExtensions ( Binder binder ) { MapBinder < K , V > mapBinder = MapBinder . newMapBinder ( binder , keyType , valueType ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { mapBinder . addBinding ( entry . getKey ( ) ) . toInstance ( entry . getValue ( ) ) ; } } } } 
