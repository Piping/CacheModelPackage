package org . elasticsearch . recovery ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . recovery . RecoveriesCollection ; import org . elasticsearch . indices . recovery . RecoveryFailedException ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . indices . recovery . RecoveryStatus ; import org . elasticsearch . indices . recovery . RecoveryTarget ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . ArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Predicate ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . lessThan ; public class RecoveriesCollectionTests extends ESSingleNodeTestCase { final static RecoveryTarget . RecoveryListener listener = new RecoveryTarget . RecoveryListener ( ) { @Override public void onRecoveryDone ( RecoveryState state ) { } @Override public void onRecoveryFailure ( RecoveryState state , RecoveryFailedException e , boolean sendShardFailure ) { } } ; public void testLastAccessTimeUpdate ( ) throws Exception { createIndex ( ) ; final RecoveriesCollection collection = new RecoveriesCollection ( logger , getInstanceFromNode ( ThreadPool . class ) ) ; final long recoveryId = startRecovery ( collection ) ; try ( RecoveriesCollection . StatusRef status = collection . getStatus ( recoveryId ) ) { final long lastSeenTime = status . status ( ) . lastAccessTime ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { try ( RecoveriesCollection . StatusRef currentStatus = collection . getStatus ( recoveryId ) ) { assertThat ( <str> , lastSeenTime , lessThan ( currentStatus . status ( ) . lastAccessTime ( ) ) ) ; } } } ) ; } finally { collection . cancelRecovery ( recoveryId , <str> ) ; } } public void testRecoveryTimeout ( ) throws InterruptedException { createIndex ( ) ; final RecoveriesCollection collection = new RecoveriesCollection ( logger , getInstanceFromNode ( ThreadPool . class ) ) ; final AtomicBoolean failed = new AtomicBoolean ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final long recoveryId = startRecovery ( collection , new RecoveryTarget . RecoveryListener ( ) { @Override public void onRecoveryDone ( RecoveryState state ) { latch . countDown ( ) ; } @Override public void onRecoveryFailure ( RecoveryState state , RecoveryFailedException e , boolean sendShardFailure ) { failed . set ( true ) ; latch . countDown ( ) ; } } , TimeValue . timeValueMillis ( <int> ) ) ; try { latch . await ( <int> , TimeUnit . SECONDS ) ; assertTrue ( <str> , failed . get ( ) ) ; } finally { collection . cancelRecovery ( recoveryId , <str> ) ; } } public void testRecoveryCancellationNoPredicate ( ) throws Exception { createIndex ( ) ; final RecoveriesCollection collection = new RecoveriesCollection ( logger , getInstanceFromNode ( ThreadPool . class ) ) ; final long recoveryId = startRecovery ( collection ) ; final long recoveryId2 = startRecovery ( collection ) ; try ( RecoveriesCollection . StatusRef statusRef = collection . getStatus ( recoveryId ) ) { ShardId shardId = statusRef . status ( ) . shardId ( ) ; assertTrue ( <str> , collection . cancelRecoveriesForShard ( shardId , <str> ) ) ; assertThat ( <str> , collection . size ( ) , equalTo ( <int> ) ) ; } finally { collection . cancelRecovery ( recoveryId , <str> ) ; collection . cancelRecovery ( recoveryId2 , <str> ) ; } } public void testRecoveryCancellationPredicate ( ) throws Exception { createIndex ( ) ; final RecoveriesCollection collection = new RecoveriesCollection ( logger , getInstanceFromNode ( ThreadPool . class ) ) ; final long recoveryId = startRecovery ( collection ) ; final long recoveryId2 = startRecovery ( collection ) ; final ArrayList < AutoCloseable > toClose = new ArrayList < > ( ) ; try { RecoveriesCollection . StatusRef statusRef = collection . getStatus ( recoveryId ) ; toClose . add ( statusRef ) ; ShardId shardId = statusRef . status ( ) . shardId ( ) ; assertFalse ( <str> , collection . cancelRecoveriesForShard ( shardId , <str> , status - > false ) ) ; final Predicate < RecoveryStatus > shouldCancel = status - > status . recoveryId ( ) = = recoveryId ; assertTrue ( <str> , collection . cancelRecoveriesForShard ( shardId , <str> , shouldCancel ) ) ; assertThat ( <str> , collection . size ( ) , equalTo ( <int> ) ) ; statusRef = collection . getStatus ( recoveryId ) ; toClose . add ( statusRef ) ; assertNull ( <str> , statusRef ) ; statusRef = collection . getStatus ( recoveryId2 ) ; toClose . add ( statusRef ) ; assertNotNull ( <str> , statusRef ) ; } finally { for ( AutoCloseable closeable : toClose ) { if ( closeable ! = null ) { closeable . close ( ) ; } } collection . cancelRecovery ( recoveryId , <str> ) ; collection . cancelRecovery ( recoveryId2 , <str> ) ; } } protected void createIndex ( ) { createIndex ( <str> , Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> , IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ) ; ensureGreen ( ) ; } long startRecovery ( RecoveriesCollection collection ) { return startRecovery ( collection , listener , TimeValue . timeValueMinutes ( <int> ) ) ; } long startRecovery ( RecoveriesCollection collection , RecoveryTarget . RecoveryListener listener , TimeValue timeValue ) { IndicesService indexServices = getInstanceFromNode ( IndicesService . class ) ; IndexShard indexShard = indexServices . indexServiceSafe ( <str> ) . getShardOrNull ( <int> ) ; final DiscoveryNode sourceNode = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; return collection . startRecovery ( indexShard , sourceNode , listener , timeValue ) ; } } 
