package io . netty . handler . codec . http ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . EncoderException ; import io . netty . handler . codec . compression . ZlibWrapper ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import org . junit . Test ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class HttpContentCompressorTest { @Test public void testGetTargetContentEncoding ( ) throws Exception { HttpContentCompressor compressor = new HttpContentCompressor ( ) ; String [ ] tests = { <str> , null , <str> , <str> , <str> , null , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , } ; for ( int i = <int> ; i < tests . length ; i + = <int> ) { String acceptEncoding = tests [ i ] ; String contentEncoding = tests [ i + <int> ] ; ZlibWrapper targetWrapper = compressor . determineWrapper ( acceptEncoding ) ; String targetEncoding = null ; if ( targetWrapper ! = null ) { switch ( targetWrapper ) { case GZIP : targetEncoding = <str> ; break ; case ZLIB : targetEncoding = <str> ; break ; default : fail ( ) ; } } assertEquals ( contentEncoding , targetEncoding ) ; } } @Test public void testSplitContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; ch . writeOutbound ( new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; ch . writeOutbound ( new DefaultLastHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; assertEncodedResponse ( ch ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testChunkedContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; ch . writeOutbound ( new DefaultLastHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testChunkedContentWithTrailingHeader ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; LastHttpContent content = new DefaultLastHttpContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; content . trailingHeaders ( ) . set ( of ( <str> ) , of ( <str> ) ) ; ch . writeOutbound ( content ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; assertEquals ( <str> , ( ( LastHttpContent ) chunk ) . trailingHeaders ( ) . get ( of ( <str> ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testFullContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; res . headers ( ) . set ( HttpHeaderNames . CONTENT_LENGTH , res . content ( ) . readableBytes ( ) ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; HttpContent c = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( c . content ( ) ) , is ( <str> ) ) ; c . release ( ) ; c = ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( c . content ( ) ) , is ( <str> ) ) ; c . release ( ) ; LastHttpContent last = ch . readOutbound ( ) ; assertThat ( last . content ( ) . readableBytes ( ) , is ( <int> ) ) ; last . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptySplitContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; ch . writeOutbound ( new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; HttpContent chunk = ( HttpContent ) ch . readOutbound ( ) ; assertThat ( ByteBufUtil . hexDump ( chunk . content ( ) ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptyFullContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ; ch . writeOutbound ( res ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( res . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; res . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptyFullContentWithTrailer ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( newRequest ( ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ; res . trailingHeaders ( ) . set ( of ( <str> ) , of ( <str> ) ) ; ch . writeOutbound ( res ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( res . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertEquals ( <str> , res . trailingHeaders ( ) . get ( of ( <str> ) ) ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void test100Continue ( ) throws Exception { FullHttpRequest request = newRequest ( ) ; HttpUtil . set100ContinueExpected ( request , true ) ; EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( request ) ; FullHttpResponse continueResponse = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . CONTINUE , Unpooled . EMPTY_BUFFER ) ; ch . writeOutbound ( continueResponse ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ; res . trailingHeaders ( ) . set ( of ( <str> ) , of ( <str> ) ) ; ch . writeOutbound ( res ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertSame ( continueResponse , res ) ; res . release ( ) ; o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( res . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertEquals ( <str> , res . trailingHeaders ( ) . get ( of ( <str> ) ) ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testTooManyResponses ( ) throws Exception { FullHttpRequest request = newRequest ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new HttpContentCompressor ( ) ) ; ch . writeInbound ( request ) ; ch . writeOutbound ( new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ) ; try { ch . writeOutbound ( new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ) ; fail ( ) ; } catch ( EncoderException e ) { assertTrue ( e . getCause ( ) instanceof IllegalStateException ) ; } assertTrue ( ch . finish ( ) ) ; for ( ; ; ) { Object message = ch . readOutbound ( ) ; if ( message = = null ) { break ; } ReferenceCountUtil . release ( message ) ; } for ( ; ; ) { Object message = ch . readInbound ( ) ; if ( message = = null ) { break ; } ReferenceCountUtil . release ( message ) ; } } private static FullHttpRequest newRequest ( ) { FullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . ACCEPT_ENCODING , <str> ) ; return req ; } private static void assertEncodedResponse ( EmbeddedChannel ch ) { Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( HttpResponse . class ) ) ) ; HttpResponse res = ( HttpResponse ) o ; assertThat ( res , is ( not ( instanceOf ( HttpContent . class ) ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( <str> ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( <str> ) ) ; } } 
