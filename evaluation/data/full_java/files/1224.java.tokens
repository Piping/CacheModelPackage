package org . apache . cassandra . utils ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . * ; import com . google . common . base . Joiner ; import org . apache . cassandra . utils . AbstractIterator ; import com . google . common . collect . Iterators ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . AsymmetricOrdering . Op ; public class IntervalTree < C extends Comparable < ? super C > , D , I extends Interval < C , D > > implements Iterable < I > { private static final Logger logger = LoggerFactory . getLogger ( IntervalTree . class ) ; @SuppressWarnings ( <str> ) private static final IntervalTree EMPTY_TREE = new IntervalTree ( null ) ; private final IntervalNode head ; private final int count ; protected IntervalTree ( Collection < I > intervals ) { this . head = intervals = = null | | intervals . isEmpty ( ) ? null : new IntervalNode ( intervals ) ; this . count = intervals = = null ? <int> : intervals . size ( ) ; } public static < C extends Comparable < ? super C > , D , I extends Interval < C , D > > IntervalTree < C , D , I > build ( Collection < I > intervals ) { if ( intervals = = null | | intervals . isEmpty ( ) ) return emptyTree ( ) ; return new IntervalTree < C , D , I > ( intervals ) ; } public static < C extends Comparable < ? super C > , D , I extends Interval < C , D > > Serializer < C , D , I > serializer ( ISerializer < C > pointSerializer , ISerializer < D > dataSerializer , Constructor < I > constructor ) { return new Serializer < > ( pointSerializer , dataSerializer , constructor ) ; } @SuppressWarnings ( <str> ) public static < C extends Comparable < ? super C > , D , I extends Interval < C , D > > IntervalTree < C , D , I > emptyTree ( ) { return EMPTY_TREE ; } public int intervalCount ( ) { return count ; } public boolean isEmpty ( ) { return head = = null ; } public C max ( ) { if ( head = = null ) throw new IllegalStateException ( ) ; return head . high ; } public C min ( ) { if ( head = = null ) throw new IllegalStateException ( ) ; return head . low ; } public List < D > search ( Interval < C , D > searchInterval ) { if ( head = = null ) return Collections . < D > emptyList ( ) ; List < D > results = new ArrayList < D > ( ) ; head . searchInternal ( searchInterval , results ) ; return results ; } public List < D > search ( C point ) { return search ( Interval . < C , D > create ( point , point , null ) ) ; } public Iterator < I > iterator ( ) { if ( head = = null ) return Iterators . < I > emptyIterator ( ) ; return new TreeIterator ( head ) ; } @Override public String toString ( ) { return <str> + Joiner . on ( <str> ) . join ( this ) + <str> ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof IntervalTree ) ) return false ; IntervalTree that = ( IntervalTree ) o ; return Iterators . elementsEqual ( iterator ( ) , that . iterator ( ) ) ; } @Override public final int hashCode ( ) { int result = <int> ; for ( Interval < C , D > interval : this ) result = <int> * result + interval . hashCode ( ) ; return result ; } private class IntervalNode { final C center ; final C low ; final C high ; final List < I > intersectsLeft ; final List < I > intersectsRight ; final IntervalNode left ; final IntervalNode right ; public IntervalNode ( Collection < I > toBisect ) { assert ! toBisect . isEmpty ( ) ; logger . trace ( <str> , toBisect ) ; if ( toBisect . size ( ) = = <int> ) { I interval = toBisect . iterator ( ) . next ( ) ; low = interval . min ; center = interval . max ; high = interval . max ; List < I > l = Collections . singletonList ( interval ) ; intersectsLeft = l ; intersectsRight = l ; left = null ; right = null ; } else { List < C > allEndpoints = new ArrayList < C > ( toBisect . size ( ) * <int> ) ; for ( I interval : toBisect ) { allEndpoints . add ( interval . min ) ; allEndpoints . add ( interval . max ) ; } Collections . sort ( allEndpoints ) ; low = allEndpoints . get ( <int> ) ; center = allEndpoints . get ( toBisect . size ( ) ) ; high = allEndpoints . get ( allEndpoints . size ( ) - <int> ) ; List < I > intersects = new ArrayList < I > ( ) ; List < I > leftSegment = new ArrayList < I > ( ) ; List < I > rightSegment = new ArrayList < I > ( ) ; for ( I candidate : toBisect ) { if ( candidate . max . compareTo ( center ) < <int> ) leftSegment . add ( candidate ) ; else if ( candidate . min . compareTo ( center ) > <int> ) rightSegment . add ( candidate ) ; else intersects . add ( candidate ) ; } intersectsLeft = Interval . < C , D > minOrdering ( ) . sortedCopy ( intersects ) ; intersectsRight = Interval . < C , D > maxOrdering ( ) . sortedCopy ( intersects ) ; left = leftSegment . isEmpty ( ) ? null : new IntervalNode ( leftSegment ) ; right = rightSegment . isEmpty ( ) ? null : new IntervalNode ( rightSegment ) ; assert ( intersects . size ( ) + leftSegment . size ( ) + rightSegment . size ( ) ) = = toBisect . size ( ) : <str> + String . valueOf ( intersects . size ( ) ) + <str> + String . valueOf ( leftSegment . size ( ) ) + <str> + String . valueOf ( rightSegment . size ( ) ) + <str> + String . valueOf ( toBisect . size ( ) ) + <str> ; } } void searchInternal ( Interval < C , D > searchInterval , List < D > results ) { if ( center . compareTo ( searchInterval . min ) < <int> ) { int i = Interval . < C , D > maxOrdering ( ) . binarySearchAsymmetric ( intersectsRight , searchInterval . min , Op . CEIL ) ; if ( i = = intersectsRight . size ( ) & & high . compareTo ( searchInterval . min ) < <int> ) return ; while ( i < intersectsRight . size ( ) ) results . add ( intersectsRight . get ( i + + ) . data ) ; if ( right ! = null ) right . searchInternal ( searchInterval , results ) ; } else if ( center . compareTo ( searchInterval . max ) > <int> ) { int j = Interval . < C , D > minOrdering ( ) . binarySearchAsymmetric ( intersectsLeft , searchInterval . max , Op . HIGHER ) ; if ( j = = <int> & & low . compareTo ( searchInterval . max ) > <int> ) return ; for ( int i = <int> ; i < j ; i + + ) results . add ( intersectsLeft . get ( i ) . data ) ; if ( left ! = null ) left . searchInternal ( searchInterval , results ) ; } else { for ( Interval < C , D > interval : intersectsLeft ) results . add ( interval . data ) ; if ( left ! = null ) left . searchInternal ( searchInterval , results ) ; if ( right ! = null ) right . searchInternal ( searchInterval , results ) ; } } } private class TreeIterator extends AbstractIterator < I > { private final Deque < IntervalNode > stack = new ArrayDeque < IntervalNode > ( ) ; private Iterator < I > current ; TreeIterator ( IntervalNode node ) { super ( ) ; gotoMinOf ( node ) ; } protected I computeNext ( ) { if ( current ! = null & & current . hasNext ( ) ) return current . next ( ) ; IntervalNode node = stack . pollFirst ( ) ; if ( node = = null ) return endOfData ( ) ; current = node . intersectsLeft . iterator ( ) ; gotoMinOf ( node . right ) ; return computeNext ( ) ; } private void gotoMinOf ( IntervalNode node ) { while ( node ! = null ) { stack . offerFirst ( node ) ; node = node . left ; } } } public static class Serializer < C extends Comparable < ? super C > , D , I extends Interval < C , D > > implements IVersionedSerializer < IntervalTree < C , D , I > > { private final ISerializer < C > pointSerializer ; private final ISerializer < D > dataSerializer ; private final Constructor < I > constructor ; private Serializer ( ISerializer < C > pointSerializer , ISerializer < D > dataSerializer , Constructor < I > constructor ) { this . pointSerializer = pointSerializer ; this . dataSerializer = dataSerializer ; this . constructor = constructor ; } public void serialize ( IntervalTree < C , D , I > it , DataOutputPlus out , int version ) throws IOException { out . writeInt ( it . count ) ; for ( Interval < C , D > interval : it ) { pointSerializer . serialize ( interval . min , out ) ; pointSerializer . serialize ( interval . max , out ) ; dataSerializer . serialize ( interval . data , out ) ; } } public IntervalTree < C , D , I > deserialize ( DataInputPlus in , int version ) throws IOException { return deserialize ( in , version , null ) ; } public IntervalTree < C , D , I > deserialize ( DataInputPlus in , int version , Comparator < C > comparator ) throws IOException { try { int count = in . readInt ( ) ; List < I > intervals = new ArrayList < I > ( count ) ; for ( int i = <int> ; i < count ; i + + ) { C min = pointSerializer . deserialize ( in ) ; C max = pointSerializer . deserialize ( in ) ; D data = dataSerializer . deserialize ( in ) ; intervals . add ( constructor . newInstance ( min , max , data ) ) ; } return new IntervalTree < C , D , I > ( intervals ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } public long serializedSize ( IntervalTree < C , D , I > it , int version ) { long size = TypeSizes . sizeof ( <int> ) ; for ( Interval < C , D > interval : it ) { size + = pointSerializer . serializedSize ( interval . min ) ; size + = pointSerializer . serializedSize ( interval . max ) ; size + = dataSerializer . serializedSize ( interval . data ) ; } return size ; } } } 
