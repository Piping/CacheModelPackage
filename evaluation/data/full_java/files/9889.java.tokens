package com . google . common . collect . testing ; import static java . util . Collections . sort ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertFalse ; import static junit . framework . Assert . assertTrue ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import junit . framework . Assert ; import junit . framework . AssertionFailedError ; import java . io . Serializable ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; @GwtCompatible ( emulated = true ) public class Helpers { static boolean equal ( Object a , Object b ) { return a = = b | | ( a ! = null & & a . equals ( b ) ) ; } public static < E > List < E > copyToList ( Iterable < ? extends E > elements ) { List < E > list = new ArrayList < E > ( ) ; addAll ( list , elements ) ; return list ; } public static < E > List < E > copyToList ( E [ ] elements ) { return copyToList ( Arrays . asList ( elements ) ) ; } public static < E > Set < E > copyToSet ( Iterable < ? extends E > elements ) { Set < E > set = new LinkedHashSet < E > ( ) ; addAll ( set , elements ) ; return set ; } public static < E > Set < E > copyToSet ( E [ ] elements ) { return copyToSet ( Arrays . asList ( elements ) ) ; } public static < K , V > Entry < K , V > mapEntry ( K key , V value ) { return Collections . singletonMap ( key , value ) . entrySet ( ) . iterator ( ) . next ( ) ; } private static boolean isEmpty ( Iterable < ? > iterable ) { return iterable instanceof Collection ? ( ( Collection < ? > ) iterable ) . isEmpty ( ) : iterable . iterator ( ) . hasNext ( ) ; } public static void assertEmpty ( Iterable < ? > iterable ) { if ( ! isEmpty ( iterable ) ) { Assert . fail ( <str> + iterable + <str> ) ; } } public static void assertEmpty ( Map < ? , ? > map ) { if ( ! map . isEmpty ( ) ) { Assert . fail ( <str> + map + <str> ) ; } } public static void assertEqualInOrder ( Iterable < ? > expected , Iterable < ? > actual ) { Iterator < ? > expectedIter = expected . iterator ( ) ; Iterator < ? > actualIter = actual . iterator ( ) ; while ( expectedIter . hasNext ( ) & & actualIter . hasNext ( ) ) { if ( ! equal ( expectedIter . next ( ) , actualIter . next ( ) ) ) { Assert . fail ( <str> + <str> + expected + <str> + actual ) ; } } if ( expectedIter . hasNext ( ) | | actualIter . hasNext ( ) ) { Assert . fail ( <str> + <str> + expected + <str> + actual ) ; } } public static void assertContentsInOrder ( Iterable < ? > actual , Object . . . expected ) { assertEqualInOrder ( Arrays . asList ( expected ) , actual ) ; } public static void assertEqualIgnoringOrder ( Iterable < ? > expected , Iterable < ? > actual ) { List < ? > exp = copyToList ( expected ) ; List < ? > act = copyToList ( actual ) ; String actString = act . toString ( ) ; for ( Object object : exp ) { if ( ! act . remove ( object ) ) { Assert . fail ( <str> + object + <str> + <str> + exp + <str> + actString ) ; } } assertTrue ( <str> + act , act . isEmpty ( ) ) ; } public static void assertContentsAnyOrder ( Iterable < ? > actual , Object . . . expected ) { assertEqualIgnoringOrder ( Arrays . asList ( expected ) , actual ) ; } public static void assertContains ( Iterable < ? > actual , Object expected ) { boolean contained = false ; if ( actual instanceof Collection ) { contained = ( ( Collection < ? > ) actual ) . contains ( expected ) ; } else { for ( Object o : actual ) { if ( equal ( o , expected ) ) { contained = true ; break ; } } } if ( ! contained ) { Assert . fail ( <str> + actual + <str> + expected ) ; } } public static void assertContainsAllOf ( Iterable < ? > actual , Object . . . expected ) { List < Object > expectedList = new ArrayList < Object > ( ) ; expectedList . addAll ( Arrays . asList ( expected ) ) ; for ( Object o : actual ) { expectedList . remove ( o ) ; } if ( ! expectedList . isEmpty ( ) ) { Assert . fail ( <str> + actual + <str> + Arrays . asList ( expected ) ) ; } } public static < E > boolean addAll ( Collection < E > addTo , Iterable < ? extends E > elementsToAdd ) { boolean modified = false ; for ( E e : elementsToAdd ) { modified | = addTo . add ( e ) ; } return modified ; } static < T > Iterable < T > reverse ( final List < T > list ) { return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { final ListIterator < T > listIter = list . listIterator ( list . size ( ) ) ; return new Iterator < T > ( ) { @Override public boolean hasNext ( ) { return listIter . hasPrevious ( ) ; } @Override public T next ( ) { return listIter . previous ( ) ; } @Override public void remove ( ) { listIter . remove ( ) ; } } ; } } ; } static < T > Iterator < T > cycle ( final Iterable < T > iterable ) { return new Iterator < T > ( ) { Iterator < T > iterator = Collections . < T > emptySet ( ) . iterator ( ) ; @Override public boolean hasNext ( ) { return true ; } @Override public T next ( ) { if ( ! iterator . hasNext ( ) ) { iterator = iterable . iterator ( ) ; } return iterator . next ( ) ; } @Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } static < T > T get ( Iterator < T > iterator , int position ) { for ( int i = <int> ; i < position ; i + + ) { iterator . next ( ) ; } return iterator . next ( ) ; } static void fail ( Throwable cause , Object message ) { AssertionFailedError assertionFailedError = new AssertionFailedError ( String . valueOf ( message ) ) ; assertionFailedError . initCause ( cause ) ; throw assertionFailedError ; } public static < K , V > Comparator < Entry < K , V > > entryComparator ( final Comparator < ? super K > keyComparator ) { return new Comparator < Entry < K , V > > ( ) { @Override @SuppressWarnings ( <str> ) public int compare ( Entry < K , V > a , Entry < K , V > b ) { return ( keyComparator = = null ) ? ( ( Comparable ) a . getKey ( ) ) . compareTo ( b . getKey ( ) ) : keyComparator . compare ( a . getKey ( ) , b . getKey ( ) ) ; } } ; } public static < T > void testComparator ( Comparator < ? super T > comparator , T . . . valuesInExpectedOrder ) { testComparator ( comparator , Arrays . asList ( valuesInExpectedOrder ) ) ; } public static < T > void testComparator ( Comparator < ? super T > comparator , List < T > valuesInExpectedOrder ) { for ( int i = <int> ; i < valuesInExpectedOrder . size ( ) ; i + + ) { T t = valuesInExpectedOrder . get ( i ) ; for ( int j = <int> ; j < i ; j + + ) { T lesser = valuesInExpectedOrder . get ( j ) ; assertTrue ( comparator + <str> + lesser + <str> + t + <str> , comparator . compare ( lesser , t ) < <int> ) ; } assertEquals ( comparator + <str> + t + <str> + t + <str> , <int> , comparator . compare ( t , t ) ) ; for ( int j = i + <int> ; j < valuesInExpectedOrder . size ( ) ; j + + ) { T greater = valuesInExpectedOrder . get ( j ) ; assertTrue ( comparator + <str> + greater + <str> + t + <str> , comparator . compare ( greater , t ) > <int> ) ; } } } public static < T extends Comparable < ? super T > > void testCompareToAndEquals ( List < T > valuesInExpectedOrder ) { for ( int i = <int> ; i < valuesInExpectedOrder . size ( ) ; i + + ) { T t = valuesInExpectedOrder . get ( i ) ; for ( int j = <int> ; j < i ; j + + ) { T lesser = valuesInExpectedOrder . get ( j ) ; assertTrue ( lesser + <str> + t + <str> , lesser . compareTo ( t ) < <int> ) ; assertFalse ( lesser . equals ( t ) ) ; } assertEquals ( t + <str> + t + <str> , <int> , t . compareTo ( t ) ) ; assertTrue ( t . equals ( t ) ) ; for ( int j = i + <int> ; j < valuesInExpectedOrder . size ( ) ; j + + ) { T greater = valuesInExpectedOrder . get ( j ) ; assertTrue ( greater + <str> + t + <str> , greater . compareTo ( t ) > <int> ) ; assertFalse ( greater . equals ( t ) ) ; } } } public static < T > Collection < T > misleadingSizeCollection ( final int delta ) { return new ArrayList < T > ( ) { @Override public int size ( ) { return Math . max ( <int> , super . size ( ) + delta ) ; } } ; } public static < K , V > Map . Entry < K , V > nefariousMapEntry ( final K key , final V value ) { return new Map . Entry < K , V > ( ) { @Override public K getKey ( ) { return key ; } @Override public V getValue ( ) { return value ; } @Override public V setValue ( V value ) { throw new UnsupportedOperationException ( ) ; } @SuppressWarnings ( <str> ) @Override public boolean equals ( Object o ) { if ( o instanceof Map . Entry ) { Map . Entry < K , V > e = ( Map . Entry < K , V > ) o ; e . setValue ( value ) ; return equal ( this . getKey ( ) , e . getKey ( ) ) & & equal ( this . getValue ( ) , e . getValue ( ) ) ; } return false ; } @Override public int hashCode ( ) { K k = getKey ( ) ; V v = getValue ( ) ; return ( ( k = = null ) ? <int> : k . hashCode ( ) ) ^ ( ( v = = null ) ? <int> : v . hashCode ( ) ) ; } @Override public String toString ( ) { return getKey ( ) + <str> + getValue ( ) ; } } ; } static < E > List < E > castOrCopyToList ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > list = new ArrayList < E > ( ) ; for ( E e : iterable ) { list . add ( e ) ; } return list ; } private static final Comparator < Comparable > NATURAL_ORDER = new Comparator < Comparable > ( ) { @SuppressWarnings ( <str> ) @Override public int compare ( Comparable left , Comparable right ) { return left . compareTo ( right ) ; } } ; public static < K extends Comparable , V > Iterable < Entry < K , V > > orderEntriesByKey ( List < Entry < K , V > > insertionOrder ) { sort ( insertionOrder , Helpers . < K , V > entryComparator ( NATURAL_ORDER ) ) ; return insertionOrder ; } private @interface GwtTransient { } public abstract static class NullsBefore implements Comparator < String > , Serializable { @GwtTransient private final String justAfterNull ; protected NullsBefore ( String justAfterNull ) { if ( justAfterNull = = null ) { throw new NullPointerException ( ) ; } this . justAfterNull = justAfterNull ; } @Override public int compare ( String lhs , String rhs ) { if ( lhs = = rhs ) { return <int> ; } if ( lhs = = null ) { if ( rhs . equals ( justAfterNull ) ) { return - <int> ; } return justAfterNull . compareTo ( rhs ) ; } if ( rhs = = null ) { if ( lhs . equals ( justAfterNull ) ) { return <int> ; } return lhs . compareTo ( justAfterNull ) ; } return lhs . compareTo ( rhs ) ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof NullsBefore ) { NullsBefore other = ( NullsBefore ) obj ; return justAfterNull . equals ( other . justAfterNull ) ; } return false ; } @Override public int hashCode ( ) { return justAfterNull . hashCode ( ) ; } } public static final class NullsBeforeB extends NullsBefore { public static final NullsBeforeB INSTANCE = new NullsBeforeB ( ) ; private NullsBeforeB ( ) { super ( <str> ) ; } } public static final class NullsBeforeTwo extends NullsBefore { public static final NullsBeforeTwo INSTANCE = new NullsBeforeTwo ( ) ; private NullsBeforeTwo ( ) { super ( <str> ) ; } } @GwtIncompatible ( <str> ) public static Method getMethod ( Class < ? > clazz , String name ) { try { return clazz . getMethod ( name ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } } 
