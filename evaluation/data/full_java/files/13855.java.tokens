package org . gradle . launcher . daemon . server ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . launcher . daemon . protocol . * ; import org . gradle . launcher . daemon . server . api . DaemonConnection ; import org . gradle . launcher . daemon . server . api . StdinHandler ; import org . gradle . logging . internal . OutputEvent ; import org . gradle . messaging . remote . internal . Connection ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . LinkedList ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultDaemonConnection implements DaemonConnection { private static final Logger LOGGER = LoggerFactory . getLogger ( DefaultDaemonConnection . class ) ; private final Connection < Message > connection ; private final StoppableExecutor executor ; private final StdinQueue stdinQueue ; private final DisconnectQueue disconnectQueue ; private final CancelQueue cancelQueue ; private final ReceiveQueue receiveQueue ; public DefaultDaemonConnection ( final Connection < Message > connection , ExecutorFactory executorFactory ) { this . connection = connection ; stdinQueue = new StdinQueue ( executorFactory ) ; disconnectQueue = new DisconnectQueue ( ) ; cancelQueue = new CancelQueue ( executorFactory ) ; receiveQueue = new ReceiveQueue ( ) ; executor = executorFactory . create ( <str> + connection . toString ( ) ) ; executor . execute ( new Runnable ( ) { public void run ( ) { Throwable failure = null ; try { while ( true ) { Object message ; try { message = connection . receive ( ) ; } catch ( Exception e ) { LOGGER . debug ( <str> , e ) ; failure = e ; return ; } if ( message = = null ) { LOGGER . debug ( <str> ) ; return ; } if ( message instanceof InputMessage ) { LOGGER . debug ( <str> , message ) ; stdinQueue . add ( ( InputMessage ) message ) ; } else if ( message instanceof Cancel ) { LOGGER . debug ( <str> , message ) ; cancelQueue . add ( ( Cancel ) message ) ; } else { LOGGER . debug ( <str> , message ) ; receiveQueue . add ( message ) ; } } } finally { stdinQueue . disconnect ( ) ; cancelQueue . disconnect ( ) ; disconnectQueue . disconnect ( ) ; receiveQueue . disconnect ( failure ) ; } } } ) ; } public void onStdin ( StdinHandler handler ) { stdinQueue . useHandler ( handler ) ; } public void onDisconnect ( Runnable handler ) { disconnectQueue . useHandler ( handler ) ; } public void onCancel ( Runnable handler ) { cancelQueue . useHandler ( handler ) ; } public Object receive ( long timeoutValue , TimeUnit timeoutUnits ) { return receiveQueue . take ( timeoutValue , timeoutUnits ) ; } public void daemonUnavailable ( DaemonUnavailable unavailable ) { connection . dispatch ( unavailable ) ; } public void buildStarted ( BuildStarted buildStarted ) { connection . dispatch ( buildStarted ) ; } public void logEvent ( OutputEvent logEvent ) { connection . dispatch ( new OutputMessage ( logEvent ) ) ; } @Override public void event ( Object event ) { connection . dispatch ( new BuildEvent ( event ) ) ; } public void completed ( Result result ) { connection . dispatch ( result ) ; } public void stop ( ) { CompositeStoppable . stoppable ( disconnectQueue , connection , executor , receiveQueue , stdinQueue , cancelQueue ) . stop ( ) ; } private static abstract class CommandQueue < C extends Message , H > implements Stoppable { private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; protected final LinkedList < C > queue = new LinkedList < C > ( ) ; private final String name ; private StoppableExecutor executor ; private boolean removed ; private final ExecutorFactory executorFactory ; private CommandQueue ( ExecutorFactory executorFactory , String name ) { this . executorFactory = executorFactory ; this . name = name ; } public void stop ( ) { StoppableExecutor executor ; lock . lock ( ) ; try { executor = this . executor ; } finally { lock . unlock ( ) ; } if ( executor ! = null ) { executor . stop ( ) ; } } public void add ( C command ) { lock . lock ( ) ; try { queue . add ( command ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public void useHandler ( final H handler ) { if ( handler ! = null ) { startConsuming ( handler ) ; } else { stopConsuming ( ) ; } } protected void stopConsuming ( ) { StoppableExecutor executor ; lock . lock ( ) ; try { queue . clear ( ) ; removed = true ; condition . signalAll ( ) ; executor = this . executor ; } finally { lock . unlock ( ) ; } if ( executor ! = null ) { executor . stop ( ) ; } } protected void startConsuming ( final H handler ) { lock . lock ( ) ; try { if ( executor ! = null ) { throw new UnsupportedOperationException ( <str> + name + <str> ) ; } executor = executorFactory . create ( name ) ; executor . execute ( new Runnable ( ) { public void run ( ) { while ( true ) { C command ; lock . lock ( ) ; try { while ( ! removed & & queue . isEmpty ( ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } if ( removed ) { return ; } command = queue . removeFirst ( ) ; } finally { lock . unlock ( ) ; } if ( doHandleCommand ( handler , command ) ) { return ; } } } } ) ; } finally { lock . unlock ( ) ; } } protected abstract boolean doHandleCommand ( final H handler , C command ) ; protected abstract void doHandleDisconnect ( ) ; public void disconnect ( ) { lock . lock ( ) ; try { doHandleDisconnect ( ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } private static class StdinQueue extends CommandQueue < InputMessage , StdinHandler > { private StdinQueue ( ExecutorFactory executorFactory ) { super ( executorFactory , <str> ) ; } protected boolean doHandleCommand ( final StdinHandler handler , InputMessage command ) { try { if ( command instanceof CloseInput ) { handler . onEndOfInput ( ) ; return true ; } else { handler . onInput ( ( ForwardInput ) command ) ; } } catch ( Exception e ) { LOGGER . warn ( <str> , e ) ; return true ; } return false ; } @Override protected void doHandleDisconnect ( ) { queue . clear ( ) ; queue . add ( new CloseInput ( ) ) ; } } private static class CancelQueue extends CommandQueue < Cancel , Runnable > { private CancelQueue ( ExecutorFactory executorFactory ) { super ( executorFactory , <str> ) ; } @Override protected boolean doHandleCommand ( Runnable handler , Cancel command ) { try { handler . run ( ) ; } catch ( Exception e ) { LOGGER . warn ( <str> , e ) ; } return true ; } @Override protected void doHandleDisconnect ( ) { queue . clear ( ) ; } } private static class DisconnectQueue implements Stoppable { private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private Runnable handler ; private boolean notifying ; private boolean disconnected ; public void disconnect ( ) { Runnable action ; lock . lock ( ) ; try { disconnected = true ; if ( handler = = null ) { return ; } action = handler ; notifying = true ; } finally { lock . unlock ( ) ; } runAction ( action ) ; } private void runAction ( Runnable action ) { try { action . run ( ) ; } catch ( Exception e ) { LOGGER . warn ( <str> , e ) ; } finally { lock . lock ( ) ; try { notifying = false ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } public void stop ( ) { useHandler ( null ) ; } public void useHandler ( Runnable handler ) { if ( handler ! = null ) { startMonitoring ( handler ) ; } else { stopMonitoring ( ) ; } } private void startMonitoring ( Runnable handler ) { Runnable action ; lock . lock ( ) ; try { if ( this . handler ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } this . handler = handler ; if ( ! disconnected ) { return ; } action = handler ; notifying = true ; } finally { lock . unlock ( ) ; } runAction ( action ) ; } private void stopMonitoring ( ) { lock . lock ( ) ; try { while ( notifying ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } handler = null ; } finally { lock . unlock ( ) ; } } } private static class ReceiveQueue implements Stoppable { private static final Object END = new Object ( ) ; private final BlockingQueue < Object > queue = new LinkedBlockingQueue < Object > ( ) ; public void stop ( ) { } public void disconnect ( Throwable failure ) { queue . clear ( ) ; if ( failure ! = null ) { add ( failure ) ; } add ( END ) ; } public void add ( Object message ) { try { queue . put ( message ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public Object take ( long timeoutValue , TimeUnit timeoutUnits ) { Object result ; try { result = queue . poll ( timeoutValue , timeoutUnits ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } if ( result instanceof Throwable ) { Throwable failure = ( Throwable ) result ; throw UncheckedException . throwAsUncheckedException ( failure ) ; } return result = = END ? null : result ; } } } 
