package org . elasticsearch . rest . action . admin . indices . flush ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . indices . flush . IndicesSyncedFlushResult ; import org . elasticsearch . indices . flush . SyncedFlushService ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestRequest . Method . POST ; public class RestSyncedFlushAction extends BaseRestHandler { private final SyncedFlushService syncedFlushService ; @Inject public RestSyncedFlushAction ( Settings settings , RestController controller , Client client , SyncedFlushService syncedFlushService ) { super ( settings , controller , client ) ; this . syncedFlushService = syncedFlushService ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; IndicesOptions indicesOptions = IndicesOptions . fromRequest ( request , IndicesOptions . lenientExpandOpen ( ) ) ; syncedFlushService . attemptSyncedFlush ( indices , indicesOptions , new RestBuilderListener < IndicesSyncedFlushResult > ( channel ) { @Override public RestResponse buildResponse ( IndicesSyncedFlushResult results , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; results . toXContent ( builder , request ) ; builder . endObject ( ) ; return new BytesRestResponse ( results . restStatus ( ) , builder ) ; } } ) ; } } 
