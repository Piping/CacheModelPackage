package com . badlogic . gdx . jnigen ; import java . util . ArrayList ; import com . badlogic . gdx . jnigen . BuildTarget . TargetOs ; import com . badlogic . gdx . jnigen . FileDescriptor . FileType ; public class AntScriptGenerator { public void generate ( BuildConfig config , BuildTarget . . . targets ) { if ( ! config . libsDir . exists ( ) ) { if ( ! config . libsDir . mkdirs ( ) ) throw new RuntimeException ( <str> + config . libsDir + <str> ) ; } if ( ! config . jniDir . exists ( ) ) { if ( ! config . jniDir . mkdirs ( ) ) throw new RuntimeException ( <str> + config . jniDir + <str> ) ; } copyJniHeaders ( config . jniDir . path ( ) ) ; if ( config . jniDir . child ( <str> ) . exists ( ) = = false ) { new FileDescriptor ( <str> , FileType . Classpath ) . copyTo ( config . jniDir . child ( <str> ) ) ; } ArrayList < String > buildFiles = new ArrayList < String > ( ) ; ArrayList < String > libsDirs = new ArrayList < String > ( ) ; ArrayList < String > sharedLibFiles = new ArrayList < String > ( ) ; for ( BuildTarget target : targets ) { String buildFile = generateBuildTargetTemplate ( config , target ) ; FileDescriptor libsDir = new FileDescriptor ( getLibsDirectory ( config , target ) ) ; if ( ! libsDir . exists ( ) ) { if ( ! libsDir . mkdirs ( ) ) throw new RuntimeException ( <str> + libsDir + <str> ) ; } String buildFileName = <str> + target . os . toString ( ) . toLowerCase ( ) + ( target . is64Bit ? <str> : <str> ) + <str> ; if ( target . buildFileName ! = null ) buildFileName = target . buildFileName ; config . jniDir . child ( buildFileName ) . writeString ( buildFile , false ) ; System . out . println ( <str> + target . os + ( target . is64Bit ? <str> : <str> ) + <str> + config . jniDir . child ( buildFileName ) + <str> ) ; if ( ! target . excludeFromMasterBuildFile ) { if ( target . os ! = TargetOs . MacOsX & & target . os ! = TargetOs . IOS ) { buildFiles . add ( buildFileName ) ; } String sharedLibFilename = target . libName ; if ( sharedLibFilename = = null ) sharedLibFilename = getSharedLibFilename ( target . os , target . is64Bit , config . sharedLibName ) ; sharedLibFiles . add ( sharedLibFilename ) ; if ( target . os ! = TargetOs . Android & & target . os ! = TargetOs . IOS ) { libsDirs . add ( <str> + libsDir . path ( ) . replace ( <str> , <str> ) ) ; } } } String template = new FileDescriptor ( <str> , FileType . Classpath ) . readString ( ) ; StringBuffer clean = new StringBuffer ( ) ; StringBuffer compile = new StringBuffer ( ) ; StringBuffer pack = new StringBuffer ( ) ; for ( int i = <int> ; i < buildFiles . size ( ) ; i + + ) { clean . append ( <str> + buildFiles . get ( i ) + <str> ) ; compile . append ( <str> + buildFiles . get ( i ) + <str> ) ; } for ( int i = <int> ; i < libsDirs . size ( ) ; i + + ) { pack . append ( <str> + libsDirs . get ( i ) + <str> + sharedLibFiles . get ( i ) + <str> ) ; } if ( config . sharedLibs ! = null ) { for ( String sharedLib : config . sharedLibs ) { pack . append ( <str> + sharedLib + <str> ) ; } } template = template . replace ( <str> , config . sharedLibName + <str> ) ; template = template . replace ( <str> , clean . toString ( ) ) ; template = template . replace ( <str> , compile . toString ( ) ) ; template = template . replace ( <str> , <str> + config . libsDir . path ( ) . replace ( <str> , <str> ) + <str> + config . sharedLibName + <str> ) ; template = template . replace ( <str> , pack ) ; config . jniDir . child ( <str> ) . writeString ( template , false ) ; System . out . println ( <str> + config . jniDir . child ( <str> ) + <str> ) ; } private void copyJniHeaders ( String jniDir ) { final String pack = <str> ; String files [ ] = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String file : files ) { new FileDescriptor ( pack , FileType . Classpath ) . child ( file ) . copyTo ( new FileDescriptor ( jniDir ) . child ( <str> ) . child ( file ) ) ; } } private String getSharedLibFilename ( TargetOs os , boolean is64Bit , String sharedLibName ) { String libPrefix = <str> ; String libSuffix = <str> ; if ( os = = TargetOs . Windows ) { libSuffix = ( is64Bit ? <str> : <str> ) + <str> ; } if ( os = = TargetOs . Linux | | os = = TargetOs . Android ) { libPrefix = <str> ; libSuffix = ( is64Bit ? <str> : <str> ) + <str> ; } if ( os = = TargetOs . MacOsX ) { libPrefix = <str> ; libSuffix = ( is64Bit ? <str> : <str> ) + <str> ; } if ( os = = TargetOs . IOS ) { libPrefix = <str> ; libSuffix = <str> ; } return libPrefix + sharedLibName + libSuffix ; } private String getJniPlatform ( TargetOs os ) { if ( os = = TargetOs . Windows ) return <str> ; if ( os = = TargetOs . Linux ) return <str> ; if ( os = = TargetOs . MacOsX ) return <str> ; return <str> ; } private String getLibsDirectory ( BuildConfig config , BuildTarget target ) { String targetName = target . osFileName ; if ( targetName = = null ) targetName = target . os . toString ( ) . toLowerCase ( ) + ( target . is64Bit ? <str> : <str> ) ; return config . libsDir . child ( targetName ) . path ( ) . replace ( <str> , <str> ) ; } private String generateBuildTargetTemplate ( BuildConfig config , BuildTarget target ) { if ( target . os = = TargetOs . Android ) { new AndroidNdkScriptGenerator ( ) . generate ( config , target ) ; String template = new FileDescriptor ( <str> , FileType . Classpath ) . readString ( ) ; template = template . replace ( <str> , target . preCompileTask = = null ? <str> : target . preCompileTask ) ; template = template . replace ( <str> , target . postCompileTask = = null ? <str> : target . postCompileTask ) ; return template ; } String template = null ; if ( target . os = = TargetOs . IOS ) { template = new FileDescriptor ( <str> , FileType . Classpath ) . readString ( ) ; } else { template = new FileDescriptor ( <str> , FileType . Classpath ) . readString ( ) ; } String libName = target . libName ; if ( libName = = null ) libName = getSharedLibFilename ( target . os , target . is64Bit , config . sharedLibName ) ; String jniPlatform = getJniPlatform ( target . os ) ; StringBuffer cIncludes = new StringBuffer ( ) ; cIncludes . append ( <str> ) ; for ( String cInclude : target . cIncludes ) { cIncludes . append ( <str> + cInclude + <str> ) ; } StringBuffer cppIncludes = new StringBuffer ( ) ; for ( String cppInclude : target . cppIncludes ) { cppIncludes . append ( <str> + cppInclude + <str> ) ; } StringBuffer cExcludes = new StringBuffer ( ) ; for ( String cExclude : target . cExcludes ) { cExcludes . append ( <str> + cExclude + <str> ) ; } StringBuffer cppExcludes = new StringBuffer ( ) ; for ( String cppExclude : target . cppExcludes ) { cppExcludes . append ( <str> + cppExclude + <str> ) ; } StringBuffer headerDirs = new StringBuffer ( ) ; for ( String headerDir : target . headerDirs ) { headerDirs . append ( <str> + headerDir + <str> ) ; } String targetFolder = target . osFileName ; if ( targetFolder = = null ) targetFolder = target . os . toString ( ) . toLowerCase ( ) + ( target . is64Bit ? <str> : <str> ) ; template = template . replace ( <str> , config . sharedLibName + <str> + target . os + <str> + ( target . is64Bit ? <str> : <str> ) ) ; template = template . replace ( <str> , config . buildDir . child ( targetFolder ) . path ( ) . replace ( <str> , <str> ) ) ; template = template . replace ( <str> , <str> + getLibsDirectory ( config , target ) ) ; template = template . replace ( <str> , libName ) ; template = template . replace ( <str> , jniPlatform ) ; template = template . replace ( <str> , target . compilerPrefix ) ; template = template . replace ( <str> , target . cFlags ) ; template = template . replace ( <str> , target . cppFlags ) ; template = template . replace ( <str> , target . linkerFlags ) ; template = template . replace ( <str> , target . libraries ) ; template = template . replace ( <str> , cIncludes ) ; template = template . replace ( <str> , cExcludes ) ; template = template . replace ( <str> , cppIncludes ) ; template = template . replace ( <str> , cppExcludes ) ; template = template . replace ( <str> , headerDirs ) ; template = template . replace ( <str> , target . preCompileTask = = null ? <str> : target . preCompileTask ) ; template = template . replace ( <str> , target . postCompileTask = = null ? <str> : target . postCompileTask ) ; return template ; } } 
