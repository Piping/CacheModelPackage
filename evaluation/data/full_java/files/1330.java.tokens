package org . apache . cassandra ; import java . io . File ; import java . io . IOException ; import java . util . * ; import org . junit . After ; import org . junit . BeforeClass ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . index . StubIndex ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . * ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public class SchemaLoader { @BeforeClass public static void loadSchema ( ) throws ConfigurationException { prepareServer ( ) ; startGossiper ( ) ; } @After public void leakDetect ( ) throws InterruptedException { System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; Thread . sleep ( <int> ) ; } public static void prepareServer ( ) { CQLTester . prepareServer ( ) ; } public static void startGossiper ( ) { if ( ! Gossiper . instance . isEnabled ( ) ) Gossiper . instance . start ( ( int ) ( System . currentTimeMillis ( ) / <int> ) ) ; } public static void schemaDefinition ( String testName ) throws ConfigurationException { List < KeyspaceMetadata > schema = new ArrayList < KeyspaceMetadata > ( ) ; String ks1 = testName + <str> ; String ks2 = testName + <str> ; String ks3 = testName + <str> ; String ks4 = testName + <str> ; String ks5 = testName + <str> ; String ks6 = testName + <str> ; String ks_kcs = testName + <str> ; String ks_rcs = testName + <str> ; String ks_ccs = testName + <str> ; String ks_nocommit = testName + <str> ; String ks_prsi = testName + <str> ; String ks_cql = testName + <str> ; AbstractType bytes = BytesType . instance ; AbstractType < ? > composite = CompositeType . getInstance ( Arrays . asList ( new AbstractType < ? > [ ] { BytesType . instance , TimeUUIDType . instance , IntegerType . instance } ) ) ; AbstractType < ? > compositeMaxMin = CompositeType . getInstance ( Arrays . asList ( new AbstractType < ? > [ ] { BytesType . instance , IntegerType . instance } ) ) ; Map < Byte , AbstractType < ? > > aliases = new HashMap < Byte , AbstractType < ? > > ( ) ; aliases . put ( ( byte ) <str> , BytesType . instance ) ; aliases . put ( ( byte ) <str> , TimeUUIDType . instance ) ; aliases . put ( ( byte ) <str> , ReversedType . getInstance ( BytesType . instance ) ) ; aliases . put ( ( byte ) <str> , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; AbstractType < ? > dynamicComposite = DynamicCompositeType . getInstance ( aliases ) ; Map < String , String > compactionOptions = new HashMap < String , String > ( ) ; compactionOptions . put ( <str> , <str> ) ; Map < String , String > leveledOptions = new HashMap < String , String > ( ) ; leveledOptions . put ( <str> , <str> ) ; schema . add ( KeyspaceMetadata . create ( ks1 , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . scts ( compactionOptions ) ) , standardCFMD ( ks1 , <str> ) , standardCFMD ( ks1 , <str> ) , standardCFMD ( ks1 , <str> ) , standardCFMD ( ks1 , <str> ) . gcGraceSeconds ( <int> ) , standardCFMD ( ks1 , <str> ) , standardCFMD ( ks1 , <str> ) , superCFMD ( ks1 , <str> , LongType . instance ) , superCFMD ( ks1 , <str> , LongType . instance ) , superCFMD ( ks1 , <str> , LongType . instance ) , superCFMD ( ks1 , <str> , UTF8Type . instance ) , superCFMD ( ks1 , <str> , bytes ) , superCFMD ( ks1 , <str> , LexicalUUIDType . instance , UTF8Type . instance ) , keysIndexCFMD ( ks1 , <str> , true ) , keysIndexCFMD ( ks1 , <str> , false ) , superCFMD ( ks1 , <str> , BytesType . instance ) . gcGraceSeconds ( <int> ) , jdbcCFMD ( ks1 , <str> , UTF8Type . instance ) . addColumnDefinition ( utf8Column ( ks1 , <str> ) ) , jdbcCFMD ( ks1 , <str> , LongType . instance ) , jdbcCFMD ( ks1 , <str> , bytes ) , jdbcCFMD ( ks1 , <str> , AsciiType . instance ) , standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . lcs ( leveledOptions ) ) , standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . lcs ( leveledOptions ) ) , standardCFMD ( ks1 , <str> ) . minIndexInterval ( <int> ) . maxIndexInterval ( <int> ) . caching ( CachingParams . CACHE_NOTHING ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks2 , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks2 , <str> ) , standardCFMD ( ks2 , <str> ) , superCFMD ( ks2 , <str> , bytes ) , superCFMD ( ks2 , <str> , TimeUUIDType . instance ) , keysIndexCFMD ( ks2 , <str> , true ) , compositeIndexCFMD ( ks2 , <str> , true ) , compositeIndexCFMD ( ks2 , <str> , true ) . gcGraceSeconds ( <int> ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks3 , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks3 , <str> ) , keysIndexCFMD ( ks3 , <str> , true ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks4 , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks4 , <str> ) , standardCFMD ( ks4 , <str> ) , superCFMD ( ks4 , <str> , bytes ) , superCFMD ( ks4 , <str> , TimeUUIDType . instance ) , superCFMD ( ks4 , <str> , TimeUUIDType . instance , BytesType . instance ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks5 , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks5 , <str> ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks6 , KeyspaceParams . simple ( <int> ) , Tables . of ( keysIndexCFMD ( ks6 , <str> , true ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks_kcs , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks_kcs , <str> ) , standardCFMD ( ks_kcs , <str> ) , standardCFMD ( ks_kcs , <str> ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks_rcs , KeyspaceParams . simple ( <int> ) , Tables . of ( standardCFMD ( ks_rcs , <str> ) . caching ( CachingParams . CACHE_NOTHING ) , standardCFMD ( ks_rcs , <str> ) . caching ( CachingParams . CACHE_EVERYTHING ) , standardCFMD ( ks_rcs , <str> ) . caching ( new CachingParams ( true , <int> ) ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks_nocommit , KeyspaceParams . simpleTransient ( <int> ) , Tables . of ( standardCFMD ( ks_nocommit , <str> ) ) ) ) ; schema . add ( KeyspaceMetadata . create ( ks_cql , KeyspaceParams . simple ( <int> ) , Tables . of ( CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> , ks_cql ) ) ) ) ; if ( Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ) useCompression ( schema ) ; for ( KeyspaceMetadata ksm : schema ) MigrationManager . announceNewKeyspace ( ksm , false ) ; } public static void createKeyspace ( String name , KeyspaceParams params , CFMetaData . . . tables ) { MigrationManager . announceNewKeyspace ( KeyspaceMetadata . create ( name , params , Tables . of ( tables ) ) , true ) ; } public static ColumnDefinition integerColumn ( String ksName , String cfName ) { return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( IntegerType . instance . fromString ( <str> ) , IntegerType . instance ) , UTF8Type . instance , ColumnDefinition . NO_POSITION , ColumnDefinition . Kind . REGULAR ) ; } public static ColumnDefinition utf8Column ( String ksName , String cfName ) { return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( <str> , true ) , UTF8Type . instance , ColumnDefinition . NO_POSITION , ColumnDefinition . Kind . REGULAR ) ; } public static CFMetaData perRowIndexedCFMD ( String ksName , String cfName ) { final Map < String , String > indexOptions = Collections . singletonMap ( IndexTarget . CUSTOM_INDEX_OPTION_NAME , StubIndex . class . getName ( ) ) ; CFMetaData cfm = CFMetaData . Builder . create ( ksName , cfName ) . addPartitionKey ( <str> , AsciiType . instance ) . build ( ) ; ColumnDefinition indexedColumn = ColumnDefinition . regularDef ( ksName , cfName , <str> , AsciiType . instance ) ; cfm . addOrReplaceColumnDefinition ( indexedColumn ) ; cfm . indexes ( cfm . getIndexes ( ) . with ( IndexMetadata . fromIndexTargets ( cfm , Collections . singletonList ( new IndexTarget ( indexedColumn . name , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . CUSTOM , indexOptions ) ) ) ; return cfm ; } private static void useCompression ( List < KeyspaceMetadata > schema ) { for ( KeyspaceMetadata ksm : schema ) for ( CFMetaData cfm : ksm . tablesAndViews ( ) ) cfm . compression ( CompressionParams . snappy ( ) ) ; } public static CFMetaData counterCFMD ( String ksName , String cfName ) { return CFMetaData . Builder . create ( ksName , cfName , false , true , true ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , CounterColumnType . instance ) . addRegularColumn ( <str> , CounterColumnType . instance ) . build ( ) . compression ( getCompressionParameters ( ) ) ; } public static CFMetaData standardCFMD ( String ksName , String cfName ) { return standardCFMD ( ksName , cfName , <int> , AsciiType . instance ) ; } public static CFMetaData standardCFMD ( String ksName , String cfName , int columnCount , AbstractType < ? > keyType ) { return standardCFMD ( ksName , cfName , columnCount , keyType , AsciiType . instance ) ; } public static CFMetaData standardCFMD ( String ksName , String cfName , int columnCount , AbstractType < ? > keyType , AbstractType < ? > valType ) { return standardCFMD ( ksName , cfName , columnCount , keyType , valType , AsciiType . instance ) ; } public static CFMetaData standardCFMD ( String ksName , String cfName , int columnCount , AbstractType < ? > keyType , AbstractType < ? > valType , AbstractType < ? > clusteringType ) { CFMetaData . Builder builder = CFMetaData . Builder . create ( ksName , cfName ) . addPartitionKey ( <str> , keyType ) . addClusteringColumn ( <str> , clusteringType ) . addRegularColumn ( <str> , valType ) ; for ( int i = <int> ; i < columnCount ; i + + ) builder . addRegularColumn ( <str> + i , AsciiType . instance ) ; return builder . build ( ) . compression ( getCompressionParameters ( ) ) ; } public static CFMetaData denseCFMD ( String ksName , String cfName ) { return denseCFMD ( ksName , cfName , AsciiType . instance ) ; } public static CFMetaData denseCFMD ( String ksName , String cfName , AbstractType cc ) { return denseCFMD ( ksName , cfName , cc , null ) ; } public static CFMetaData denseCFMD ( String ksName , String cfName , AbstractType cc , AbstractType subcc ) { AbstractType comp = cc ; if ( subcc ! = null ) comp = CompositeType . getInstance ( Arrays . asList ( new AbstractType < ? > [ ] { cc , subcc } ) ) ; return CFMetaData . Builder . createDense ( ksName , cfName , subcc ! = null , false ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , comp ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) . compression ( getCompressionParameters ( ) ) ; } public static CFMetaData superCFMD ( String ksName , String cfName , AbstractType subcc ) { return superCFMD ( ksName , cfName , BytesType . instance , subcc ) ; } public static CFMetaData superCFMD ( String ksName , String cfName , AbstractType cc , AbstractType subcc ) { return superCFMD ( ksName , cfName , <str> , cc , subcc ) ; } public static CFMetaData superCFMD ( String ksName , String cfName , String ccName , AbstractType cc , AbstractType subcc ) { return standardCFMD ( ksName , cfName ) ; } public static CFMetaData compositeIndexCFMD ( String ksName , String cfName , boolean withIndex ) throws ConfigurationException { CFMetaData cfm = CFMetaData . Builder . create ( ksName , cfName ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , LongType . instance ) . addRegularColumn ( <str> , LongType . instance ) . build ( ) ; if ( withIndex ) cfm . indexes ( cfm . getIndexes ( ) . with ( IndexMetadata . fromIndexTargets ( cfm , Collections . singletonList ( new IndexTarget ( new ColumnIdentifier ( <str> , true ) , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . COMPOSITES , Collections . EMPTY_MAP ) ) ) ; return cfm . compression ( getCompressionParameters ( ) ) ; } public static CFMetaData keysIndexCFMD ( String ksName , String cfName , boolean withIndex ) throws ConfigurationException { CFMetaData cfm = CFMetaData . Builder . createDense ( ksName , cfName , false , false ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addStaticColumn ( <str> , LongType . instance ) . addStaticColumn ( <str> , LongType . instance ) . addRegularColumn ( <str> , LongType . instance ) . build ( ) ; if ( withIndex ) cfm . indexes ( cfm . getIndexes ( ) . with ( IndexMetadata . fromIndexTargets ( cfm , Collections . singletonList ( new IndexTarget ( new ColumnIdentifier ( <str> , true ) , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . KEYS , Collections . EMPTY_MAP ) ) ) ; return cfm . compression ( getCompressionParameters ( ) ) ; } public static CFMetaData jdbcCFMD ( String ksName , String cfName , AbstractType comp ) { return CFMetaData . Builder . create ( ksName , cfName ) . addPartitionKey ( <str> , BytesType . instance ) . build ( ) . compression ( getCompressionParameters ( ) ) ; } public static CompressionParams getCompressionParameters ( ) { return getCompressionParameters ( null ) ; } public static CompressionParams getCompressionParameters ( Integer chunkSize ) { if ( Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ) return CompressionParams . snappy ( chunkSize ) ; return CompressionParams . noCompression ( ) ; } public static void cleanupAndLeaveDirs ( ) throws IOException { CommitLog . instance . stopUnsafe ( true ) ; mkdirs ( ) ; cleanup ( ) ; mkdirs ( ) ; CommitLog . instance . restartUnsafe ( ) ; } public static void cleanup ( ) { String [ ] directoryNames = { DatabaseDescriptor . getCommitLogLocation ( ) , } ; for ( String dirName : directoryNames ) { File dir = new File ( dirName ) ; if ( ! dir . exists ( ) ) throw new RuntimeException ( <str> + dir . getAbsolutePath ( ) ) ; String [ ] children = dir . list ( ) ; for ( String child : children ) FileUtils . deleteRecursive ( new File ( dir , child ) ) ; } cleanupSavedCaches ( ) ; for ( String dirName : DatabaseDescriptor . getAllDataFileLocations ( ) ) { File dir = new File ( dirName ) ; if ( ! dir . exists ( ) ) throw new RuntimeException ( <str> + dir . getAbsolutePath ( ) ) ; String [ ] children = dir . list ( ) ; for ( String child : children ) FileUtils . deleteRecursive ( new File ( dir , child ) ) ; } } public static void mkdirs ( ) { DatabaseDescriptor . createAllDirectories ( ) ; } public static void insertData ( String keyspace , String columnFamily , int offset , int numberOfRows ) { CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace , columnFamily ) ; for ( int i = offset ; i < offset + numberOfRows ; i + + ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( <str> + i ) ) ; builder . clustering ( ByteBufferUtil . bytes ( <str> + i ) ) . add ( <str> , ByteBufferUtil . bytes ( <str> + i ) ) ; builder . build ( ) . apply ( ) ; } } public static void cleanupSavedCaches ( ) { File cachesDir = new File ( DatabaseDescriptor . getSavedCachesLocation ( ) ) ; if ( ! cachesDir . exists ( ) | | ! cachesDir . isDirectory ( ) ) return ; FileUtils . delete ( cachesDir . listFiles ( ) ) ; } } 
