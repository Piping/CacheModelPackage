package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . SocketChannel ; import org . junit . Test ; import java . net . ServerSocket ; import java . net . Socket ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import static org . junit . Assert . * ; public class SocketShutdownOutputBySelfTest extends AbstractClientSocketTest { @Test ( timeout = <int> ) public void testShutdownOutput ( ) throws Throwable { run ( ) ; } public void testShutdownOutput ( Bootstrap cb ) throws Throwable { TestHandler h = new TestHandler ( ) ; ServerSocket ss = new ServerSocket ( ) ; Socket s = null ; try { ss . bind ( addr ) ; SocketChannel ch = ( SocketChannel ) cb . handler ( h ) . connect ( ) . sync ( ) . channel ( ) ; assertTrue ( ch . isActive ( ) ) ; assertFalse ( ch . isOutputShutdown ( ) ) ; s = ss . accept ( ) ; ch . writeAndFlush ( Unpooled . wrappedBuffer ( new byte [ ] { <int> } ) ) . sync ( ) ; assertEquals ( <int> , s . getInputStream ( ) . read ( ) ) ; assertTrue ( h . ch . isOpen ( ) ) ; assertTrue ( h . ch . isActive ( ) ) ; assertFalse ( h . ch . isInputShutdown ( ) ) ; assertFalse ( h . ch . isOutputShutdown ( ) ) ; ch . shutdownOutput ( ) . sync ( ) ; assertEquals ( - <int> , s . getInputStream ( ) . read ( ) ) ; assertTrue ( h . ch . isOpen ( ) ) ; assertTrue ( h . ch . isActive ( ) ) ; assertFalse ( h . ch . isInputShutdown ( ) ) ; assertTrue ( h . ch . isOutputShutdown ( ) ) ; s . getOutputStream ( ) . write ( <int> ) ; assertEquals ( <int> , ( int ) h . queue . take ( ) ) ; } finally { if ( s ! = null ) { s . close ( ) ; } ss . close ( ) ; } } private static class TestHandler extends SimpleChannelInboundHandler < ByteBuf > { volatile SocketChannel ch ; final BlockingQueue < Byte > queue = new LinkedBlockingQueue < Byte > ( ) ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { ch = ( SocketChannel ) ctx . channel ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { queue . offer ( msg . readByte ( ) ) ; } } } 
