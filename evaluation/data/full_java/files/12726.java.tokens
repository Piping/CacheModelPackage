package org . gradle . api . internal . artifacts . ivyservice . resolveengine . store ; import org . gradle . api . artifacts . result . ResolvedComponentResult ; import org . gradle . api . internal . artifacts . ivyservice . resolveengine . oldresult . TransientConfigurationResults ; import org . gradle . api . internal . cache . Store ; import org . gradle . api . internal . file . TemporaryFileProvider ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . util . Clock ; import java . io . Closeable ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; public class ResolutionResultsStoreFactory implements Closeable { private final static Logger LOG = Logging . getLogger ( ResolutionResultsStoreFactory . class ) ; private static final int DEFAULT_MAX_SIZE = <int> ; private final TemporaryFileProvider temp ; private int maxSize ; private CachedStoreFactory < TransientConfigurationResults > oldModelCache ; private CachedStoreFactory < ResolvedComponentResult > newModelCache ; private AtomicInteger storeSetBaseId = new AtomicInteger ( <int> ) ; public ResolutionResultsStoreFactory ( TemporaryFileProvider temp ) { this ( temp , DEFAULT_MAX_SIZE ) ; } ResolutionResultsStoreFactory ( TemporaryFileProvider temp , int maxSize ) { this . temp = temp ; this . maxSize = maxSize ; } private final Map < String , DefaultBinaryStore > stores = new HashMap < String , DefaultBinaryStore > ( ) ; private final CompositeStoppable cleanUpLater = new CompositeStoppable ( ) ; private synchronized DefaultBinaryStore createBinaryStore ( String storeKey ) { DefaultBinaryStore store = stores . get ( storeKey ) ; if ( store = = null | | isFull ( store ) ) { File storeFile = temp . createTemporaryFile ( <str> , <str> ) ; storeFile . deleteOnExit ( ) ; store = new DefaultBinaryStore ( storeFile ) ; stores . put ( storeKey , store ) ; cleanUpLater . add ( store ) ; } return store ; } private synchronized CachedStoreFactory < TransientConfigurationResults > getOldModelCache ( ) { if ( oldModelCache = = null ) { oldModelCache = new CachedStoreFactory < TransientConfigurationResults > ( <str> ) ; cleanUpLater . add ( oldModelCache ) ; } return oldModelCache ; } private synchronized CachedStoreFactory < ResolvedComponentResult > getNewModelCache ( ) { if ( newModelCache = = null ) { newModelCache = new CachedStoreFactory < ResolvedComponentResult > ( <str> ) ; cleanUpLater . add ( newModelCache ) ; } return newModelCache ; } public StoreSet createStoreSet ( ) { return new StoreSet ( ) { int storeSetId = storeSetBaseId . getAndIncrement ( ) ; int binaryStoreId ; public DefaultBinaryStore nextBinaryStore ( ) { String storeKey = Thread . currentThread ( ) . getId ( ) + <str> + binaryStoreId + + ; return createBinaryStore ( storeKey ) ; } public Store < ResolvedComponentResult > newModelCache ( ) { return getNewModelCache ( ) . createCachedStore ( storeSetId ) ; } public Store < TransientConfigurationResults > oldModelCache ( ) { return getOldModelCache ( ) . createCachedStore ( storeSetId ) ; } } ; } private boolean isFull ( DefaultBinaryStore store ) { return store . getSize ( ) > maxSize ; } public void close ( ) { try { Clock clock = new Clock ( ) ; cleanUpLater . stop ( ) ; LOG . debug ( <str> , stores . size ( ) , clock . getTime ( ) ) ; } finally { oldModelCache = null ; newModelCache = null ; stores . clear ( ) ; } } } 
