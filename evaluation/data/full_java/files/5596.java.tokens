package org . elasticsearch . cluster . routing ; import com . carrotsearch . hppc . ObjectIntHashMap ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . index . shard . ShardId ; import java . util . * ; import java . util . function . Predicate ; public class RoutingNodes implements Iterable < RoutingNode > { private final MetaData metaData ; private final ClusterBlocks blocks ; private final RoutingTable routingTable ; private final Map < String , RoutingNode > nodesToShards = new HashMap < > ( ) ; private final UnassignedShards unassignedShards = new UnassignedShards ( this ) ; private final Map < ShardId , List < ShardRouting > > assignedShards = new HashMap < > ( ) ; private final ImmutableOpenMap < String , ClusterState . Custom > customs ; private final boolean readOnly ; private int inactivePrimaryCount = <int> ; private int inactiveShardCount = <int> ; private int relocatingShards = <int> ; private final Map < String , ObjectIntHashMap < String > > nodesPerAttributeNames = new HashMap < > ( ) ; public RoutingNodes ( ClusterState clusterState ) { this ( clusterState , true ) ; } public RoutingNodes ( ClusterState clusterState , boolean readOnly ) { this . readOnly = readOnly ; this . metaData = clusterState . metaData ( ) ; this . blocks = clusterState . blocks ( ) ; this . routingTable = clusterState . routingTable ( ) ; this . customs = clusterState . customs ( ) ; Map < String , List < ShardRouting > > nodesToShards = new HashMap < > ( ) ; for ( ObjectCursor < DiscoveryNode > cursor : clusterState . nodes ( ) . dataNodes ( ) . values ( ) ) { nodesToShards . put ( cursor . value . id ( ) , new ArrayList < ShardRouting > ( ) ) ; } for ( ObjectCursor < IndexRoutingTable > indexRoutingTable : routingTable . indicesRouting ( ) . values ( ) ) { for ( IndexShardRoutingTable indexShard : indexRoutingTable . value ) { for ( ShardRouting shard : indexShard ) { if ( shard . assignedToNode ( ) ) { List < ShardRouting > entries = nodesToShards . get ( shard . currentNodeId ( ) ) ; if ( entries = = null ) { entries = new ArrayList < > ( ) ; nodesToShards . put ( shard . currentNodeId ( ) , entries ) ; } final ShardRouting sr = getRouting ( shard , readOnly ) ; entries . add ( sr ) ; assignedShardsAdd ( sr ) ; if ( shard . relocating ( ) ) { entries = nodesToShards . get ( shard . relocatingNodeId ( ) ) ; relocatingShards + + ; if ( entries = = null ) { entries = new ArrayList < > ( ) ; nodesToShards . put ( shard . relocatingNodeId ( ) , entries ) ; } ShardRouting targetShardRouting = shard . buildTargetRelocatingShard ( ) ; if ( readOnly ) { targetShardRouting . freeze ( ) ; } entries . add ( targetShardRouting ) ; assignedShardsAdd ( targetShardRouting ) ; } else if ( ! shard . active ( ) ) { if ( shard . primary ( ) ) { inactivePrimaryCount + + ; } inactiveShardCount + + ; } } else { final ShardRouting sr = getRouting ( shard , readOnly ) ; assignedShardsAdd ( sr ) ; unassignedShards . add ( sr ) ; } } } } for ( Map . Entry < String , List < ShardRouting > > entry : nodesToShards . entrySet ( ) ) { String nodeId = entry . getKey ( ) ; this . nodesToShards . put ( nodeId , new RoutingNode ( nodeId , clusterState . nodes ( ) . get ( nodeId ) , entry . getValue ( ) ) ) ; } } private static ShardRouting getRouting ( ShardRouting src , boolean readOnly ) { if ( readOnly ) { src . freeze ( ) ; } else { src = new ShardRouting ( src ) ; } return src ; } @Override public Iterator < RoutingNode > iterator ( ) { return Collections . unmodifiableCollection ( nodesToShards . values ( ) ) . iterator ( ) ; } public RoutingTable routingTable ( ) { return routingTable ; } public RoutingTable getRoutingTable ( ) { return routingTable ( ) ; } public MetaData metaData ( ) { return this . metaData ; } public MetaData getMetaData ( ) { return metaData ( ) ; } public ClusterBlocks blocks ( ) { return this . blocks ; } public ClusterBlocks getBlocks ( ) { return this . blocks ; } public ImmutableOpenMap < String , ClusterState . Custom > customs ( ) { return this . customs ; } public < T extends ClusterState . Custom > T custom ( String type ) { return ( T ) customs . get ( type ) ; } public UnassignedShards unassigned ( ) { return this . unassignedShards ; } public RoutingNodesIterator nodes ( ) { return new RoutingNodesIterator ( nodesToShards . values ( ) . iterator ( ) ) ; } public RoutingNode node ( String nodeId ) { return nodesToShards . get ( nodeId ) ; } public ObjectIntHashMap < String > nodesPerAttributesCounts ( String attributeName ) { ObjectIntHashMap < String > nodesPerAttributesCounts = nodesPerAttributeNames . get ( attributeName ) ; if ( nodesPerAttributesCounts ! = null ) { return nodesPerAttributesCounts ; } nodesPerAttributesCounts = new ObjectIntHashMap < > ( ) ; for ( RoutingNode routingNode : this ) { String attrValue = routingNode . node ( ) . attributes ( ) . get ( attributeName ) ; nodesPerAttributesCounts . addTo ( attrValue , <int> ) ; } nodesPerAttributeNames . put ( attributeName , nodesPerAttributesCounts ) ; return nodesPerAttributesCounts ; } public boolean hasUnassignedPrimaries ( ) { return unassignedShards . getNumPrimaries ( ) + unassignedShards . getNumIgnoredPrimaries ( ) > <int> ; } public boolean hasUnassignedShards ( ) { return unassignedShards . isEmpty ( ) = = false | | unassignedShards . isIgnoredEmpty ( ) = = false ; } public boolean hasInactivePrimaries ( ) { return inactivePrimaryCount > <int> ; } public boolean hasInactiveShards ( ) { return inactiveShardCount > <int> ; } public int getRelocatingShardCount ( ) { return relocatingShards ; } public ShardRouting activePrimary ( ShardRouting shard ) { for ( ShardRouting shardRouting : assignedShards ( shard . shardId ( ) ) ) { if ( shardRouting . primary ( ) & & shardRouting . active ( ) ) { return shardRouting ; } } return null ; } public ShardRouting activeReplica ( ShardRouting shard ) { for ( ShardRouting shardRouting : assignedShards ( shard . shardId ( ) ) ) { if ( ! shardRouting . primary ( ) & & shardRouting . active ( ) ) { return shardRouting ; } } return null ; } public Iterable < ShardRouting > assignedShards ( ShardRouting shard ) { return assignedShards ( shard . shardId ( ) ) ; } public boolean allReplicasActive ( ShardRouting shardRouting ) { final List < ShardRouting > shards = assignedShards ( shardRouting . shardId ( ) ) ; if ( shards . isEmpty ( ) | | shards . size ( ) < this . routingTable . index ( shardRouting . index ( ) ) . shard ( shardRouting . id ( ) ) . size ( ) ) { return false ; } for ( ShardRouting shard : shards ) { if ( ! shard . active ( ) ) { return false ; } } return true ; } public List < ShardRouting > shards ( Predicate < ShardRouting > predicate ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( RoutingNode routingNode : this ) { for ( ShardRouting shardRouting : routingNode ) { if ( predicate . test ( shardRouting ) ) { shards . add ( shardRouting ) ; } } } return shards ; } public List < ShardRouting > shardsWithState ( ShardRoutingState . . . state ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( RoutingNode routingNode : this ) { shards . addAll ( routingNode . shardsWithState ( state ) ) ; } for ( ShardRoutingState s : state ) { if ( s = = ShardRoutingState . UNASSIGNED ) { unassigned ( ) . forEach ( shards : : add ) ; break ; } } return shards ; } public List < ShardRouting > shardsWithState ( String index , ShardRoutingState . . . state ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( RoutingNode routingNode : this ) { shards . addAll ( routingNode . shardsWithState ( index , state ) ) ; } for ( ShardRoutingState s : state ) { if ( s = = ShardRoutingState . UNASSIGNED ) { for ( ShardRouting unassignedShard : unassignedShards ) { if ( unassignedShard . index ( ) . equals ( index ) ) { shards . add ( unassignedShard ) ; } } break ; } } return shards ; } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( RoutingNode routingNode : this ) { sb . append ( routingNode . prettyPrint ( ) ) ; } sb . append ( <str> ) ; for ( ShardRouting shardEntry : unassignedShards ) { sb . append ( <str> ) . append ( shardEntry . shortSummary ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } public void initialize ( ShardRouting shard , String nodeId , long expectedSize ) { ensureMutable ( ) ; assert shard . unassigned ( ) : shard ; shard . initialize ( nodeId , expectedSize ) ; node ( nodeId ) . add ( shard ) ; inactiveShardCount + + ; if ( shard . primary ( ) ) { inactivePrimaryCount + + ; } assignedShardsAdd ( shard ) ; } public ShardRouting relocate ( ShardRouting shard , String nodeId , long expectedShardSize ) { ensureMutable ( ) ; relocatingShards + + ; shard . relocate ( nodeId , expectedShardSize ) ; ShardRouting target = shard . buildTargetRelocatingShard ( ) ; node ( target . currentNodeId ( ) ) . add ( target ) ; assignedShardsAdd ( target ) ; return target ; } public void started ( ShardRouting shard ) { ensureMutable ( ) ; assert ! shard . active ( ) : <str> + shard ; if ( shard . relocatingNodeId ( ) = = null ) { inactiveShardCount - - ; if ( shard . primary ( ) ) { inactivePrimaryCount - - ; } } shard . moveToStarted ( ) ; } public void cancelRelocation ( ShardRouting shard ) { ensureMutable ( ) ; relocatingShards - - ; shard . cancelRelocation ( ) ; } public void swapPrimaryFlag ( ShardRouting . . . shards ) { ensureMutable ( ) ; for ( ShardRouting shard : shards ) { if ( shard . primary ( ) ) { shard . moveFromPrimary ( ) ; if ( shard . unassigned ( ) ) { unassignedShards . primaries - - ; } } else { shard . moveToPrimary ( ) ; if ( shard . unassigned ( ) ) { unassignedShards . primaries + + ; } } } } private static final List < ShardRouting > EMPTY = Collections . emptyList ( ) ; private List < ShardRouting > assignedShards ( ShardId shardId ) { final List < ShardRouting > replicaSet = assignedShards . get ( shardId ) ; return replicaSet = = null ? EMPTY : Collections . unmodifiableList ( replicaSet ) ; } private void remove ( ShardRouting shard ) { ensureMutable ( ) ; if ( ! shard . active ( ) & & shard . relocatingNodeId ( ) = = null ) { inactiveShardCount - - ; assert inactiveShardCount > = <int> ; if ( shard . primary ( ) ) { inactivePrimaryCount - - ; } } else if ( shard . relocating ( ) ) { cancelRelocation ( shard ) ; } assignedShardsRemove ( shard ) ; } private void assignedShardsAdd ( ShardRouting shard ) { if ( shard . unassigned ( ) ) { return ; } List < ShardRouting > shards = assignedShards . get ( shard . shardId ( ) ) ; if ( shards = = null ) { shards = new ArrayList < > ( ) ; assignedShards . put ( shard . shardId ( ) , shards ) ; } assert assertInstanceNotInList ( shard , shards ) ; shards . add ( shard ) ; } private boolean assertInstanceNotInList ( ShardRouting shard , List < ShardRouting > shards ) { for ( ShardRouting s : shards ) { assert s ! = shard ; } return true ; } private void assignedShardsRemove ( ShardRouting shard ) { ensureMutable ( ) ; final List < ShardRouting > replicaSet = assignedShards . get ( shard . shardId ( ) ) ; if ( replicaSet ! = null ) { final Iterator < ShardRouting > iterator = replicaSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { if ( shard = = iterator . next ( ) ) { iterator . remove ( ) ; return ; } } assert false : <str> ; } } public boolean isKnown ( DiscoveryNode node ) { return nodesToShards . containsKey ( node . getId ( ) ) ; } public void addNode ( DiscoveryNode node ) { ensureMutable ( ) ; RoutingNode routingNode = new RoutingNode ( node . id ( ) , node ) ; nodesToShards . put ( routingNode . nodeId ( ) , routingNode ) ; } public RoutingNodeIterator routingNodeIter ( String nodeId ) { final RoutingNode routingNode = nodesToShards . get ( nodeId ) ; if ( routingNode = = null ) { return null ; } return new RoutingNodeIterator ( routingNode ) ; } public RoutingNode [ ] toArray ( ) { return nodesToShards . values ( ) . toArray ( new RoutingNode [ nodesToShards . size ( ) ] ) ; } public void reinitShadowPrimary ( ShardRouting candidate ) { ensureMutable ( ) ; if ( candidate . relocating ( ) ) { cancelRelocation ( candidate ) ; } candidate . reinitializeShard ( ) ; inactivePrimaryCount + + ; inactiveShardCount + + ; } public static final class UnassignedShards implements Iterable < ShardRouting > { private final RoutingNodes nodes ; private final List < ShardRouting > unassigned ; private final List < ShardRouting > ignored ; private int primaries = <int> ; private int ignoredPrimaries = <int> ; public UnassignedShards ( RoutingNodes nodes ) { this . nodes = nodes ; unassigned = new ArrayList < > ( ) ; ignored = new ArrayList < > ( ) ; } public void add ( ShardRouting shardRouting ) { if ( shardRouting . primary ( ) ) { primaries + + ; } unassigned . add ( shardRouting ) ; } public void sort ( Comparator < ShardRouting > comparator ) { CollectionUtil . timSort ( unassigned , comparator ) ; } public int size ( ) { return unassigned . size ( ) ; } public int ignoredSize ( ) { return ignored . size ( ) ; } public int getNumPrimaries ( ) { return primaries ; } public int getNumIgnoredPrimaries ( ) { return ignoredPrimaries ; } @Override public UnassignedIterator iterator ( ) { return new UnassignedIterator ( ) ; } public List < ShardRouting > ignored ( ) { return Collections . unmodifiableList ( ignored ) ; } public void ignoreShard ( ShardRouting shard ) { if ( shard . primary ( ) ) { ignoredPrimaries + + ; } ignored . add ( shard ) ; } public class UnassignedIterator implements Iterator < ShardRouting > { private final Iterator < ShardRouting > iterator ; private ShardRouting current ; public UnassignedIterator ( ) { this . iterator = unassigned . iterator ( ) ; } @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public ShardRouting next ( ) { return current = iterator . next ( ) ; } public void initialize ( String nodeId , long version , long expectedShardSize ) { innerRemove ( ) ; nodes . initialize ( new ShardRouting ( current , version ) , nodeId , expectedShardSize ) ; } public void removeAndIgnore ( ) { innerRemove ( ) ; ignoreShard ( current ) ; } @Override public void remove ( ) { throw new UnsupportedOperationException ( <str> ) ; } private void innerRemove ( ) { nodes . ensureMutable ( ) ; iterator . remove ( ) ; if ( current . primary ( ) ) { primaries - - ; } } } public boolean isEmpty ( ) { return unassigned . isEmpty ( ) ; } public boolean isIgnoredEmpty ( ) { return ignored . isEmpty ( ) ; } public void shuffle ( ) { Randomness . shuffle ( unassigned ) ; } public ShardRouting [ ] drain ( ) { ShardRouting [ ] mutableShardRoutings = unassigned . toArray ( new ShardRouting [ unassigned . size ( ) ] ) ; unassigned . clear ( ) ; primaries = <int> ; return mutableShardRoutings ; } } public static boolean assertShardStats ( RoutingNodes routingNodes ) { boolean run = false ; assert ( run = true ) ; if ( ! run ) { return true ; } int unassignedPrimaryCount = <int> ; int unassignedIgnoredPrimaryCount = <int> ; int inactivePrimaryCount = <int> ; int inactiveShardCount = <int> ; int relocating = <int> ; Map < String , Integer > indicesAndShards = new HashMap < > ( ) ; for ( RoutingNode node : routingNodes ) { for ( ShardRouting shard : node ) { if ( ! shard . active ( ) & & shard . relocatingNodeId ( ) = = null ) { if ( ! shard . relocating ( ) ) { inactiveShardCount + + ; if ( shard . primary ( ) ) { inactivePrimaryCount + + ; } } } if ( shard . relocating ( ) ) { relocating + + ; } Integer i = indicesAndShards . get ( shard . index ( ) ) ; if ( i = = null ) { i = shard . id ( ) ; } indicesAndShards . put ( shard . index ( ) , Math . max ( i , shard . id ( ) ) ) ; } } Set < Map . Entry < String , Integer > > entries = indicesAndShards . entrySet ( ) ; final List < ShardRouting > shards = new ArrayList < > ( ) ; for ( Map . Entry < String , Integer > e : entries ) { String index = e . getKey ( ) ; for ( int i = <int> ; i < e . getValue ( ) ; i + + ) { for ( RoutingNode routingNode : routingNodes ) { for ( ShardRouting shardRouting : routingNode ) { if ( shardRouting . index ( ) . equals ( index ) & & shardRouting . id ( ) = = i ) { shards . add ( shardRouting ) ; } } } List < ShardRouting > mutableShardRoutings = routingNodes . assignedShards ( new ShardId ( index , i ) ) ; assert mutableShardRoutings . size ( ) = = shards . size ( ) ; for ( ShardRouting r : mutableShardRoutings ) { assert shards . contains ( r ) ; shards . remove ( r ) ; } assert shards . isEmpty ( ) ; } } for ( ShardRouting shard : routingNodes . unassigned ( ) ) { if ( shard . primary ( ) ) { unassignedPrimaryCount + + ; } } for ( ShardRouting shard : routingNodes . unassigned ( ) . ignored ( ) ) { if ( shard . primary ( ) ) { unassignedIgnoredPrimaryCount + + ; } } assert unassignedPrimaryCount = = routingNodes . unassignedShards . getNumPrimaries ( ) : <str> + unassignedPrimaryCount + <str> + routingNodes . unassigned ( ) . getNumPrimaries ( ) + <str> ; assert unassignedIgnoredPrimaryCount = = routingNodes . unassignedShards . getNumIgnoredPrimaries ( ) : <str> + unassignedIgnoredPrimaryCount + <str> + routingNodes . unassigned ( ) . getNumIgnoredPrimaries ( ) + <str> ; assert inactivePrimaryCount = = routingNodes . inactivePrimaryCount : <str> + inactivePrimaryCount + <str> + routingNodes . inactivePrimaryCount + <str> ; assert inactiveShardCount = = routingNodes . inactiveShardCount : <str> + inactiveShardCount + <str> + routingNodes . inactiveShardCount + <str> ; assert routingNodes . getRelocatingShardCount ( ) = = relocating : <str> + routingNodes . getRelocatingShardCount ( ) + <str> + relocating + <str> ; return true ; } public class RoutingNodesIterator implements Iterator < RoutingNode > , Iterable < ShardRouting > { private RoutingNode current ; private final Iterator < RoutingNode > delegate ; public RoutingNodesIterator ( Iterator < RoutingNode > iterator ) { delegate = iterator ; } @Override public boolean hasNext ( ) { return delegate . hasNext ( ) ; } @Override public RoutingNode next ( ) { return current = delegate . next ( ) ; } public RoutingNodeIterator nodeShards ( ) { return new RoutingNodeIterator ( current ) ; } @Override public void remove ( ) { delegate . remove ( ) ; } @Override public Iterator < ShardRouting > iterator ( ) { return nodeShards ( ) ; } } public final class RoutingNodeIterator implements Iterator < ShardRouting > , Iterable < ShardRouting > { private final RoutingNode iterable ; private ShardRouting shard ; private final Iterator < ShardRouting > delegate ; private boolean removed = false ; public RoutingNodeIterator ( RoutingNode iterable ) { this . delegate = iterable . mutableIterator ( ) ; this . iterable = iterable ; } @Override public boolean hasNext ( ) { return delegate . hasNext ( ) ; } @Override public ShardRouting next ( ) { removed = false ; return shard = delegate . next ( ) ; } @Override public void remove ( ) { ensureMutable ( ) ; delegate . remove ( ) ; RoutingNodes . this . remove ( shard ) ; removed = true ; } public boolean isRemoved ( ) { return removed ; } @Override public Iterator < ShardRouting > iterator ( ) { return iterable . iterator ( ) ; } public void moveToUnassigned ( UnassignedInfo unassignedInfo ) { ensureMutable ( ) ; if ( isRemoved ( ) = = false ) { remove ( ) ; } ShardRouting unassigned = new ShardRouting ( shard ) ; unassigned . moveToUnassigned ( unassignedInfo ) ; unassigned ( ) . add ( unassigned ) ; } public ShardRouting current ( ) { return shard ; } } private void ensureMutable ( ) { if ( readOnly ) { throw new IllegalStateException ( <str> ) ; } } } 
