package org . apache . cassandra . db . rows ; import java . security . MessageDigest ; import java . util . Objects ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . FBUtilities ; public abstract class AbstractCell extends Cell { protected AbstractCell ( ColumnDefinition column ) { super ( column ) ; } public void digest ( MessageDigest digest ) { digest . update ( value ( ) . duplicate ( ) ) ; FBUtilities . updateWithLong ( digest , timestamp ( ) ) ; FBUtilities . updateWithInt ( digest , ttl ( ) ) ; FBUtilities . updateWithBoolean ( digest , isCounterCell ( ) ) ; if ( path ( ) ! = null ) path ( ) . digest ( digest ) ; } public void validate ( ) { column ( ) . validateCellValue ( value ( ) ) ; if ( ttl ( ) < <int> ) throw new MarshalException ( <str> ) ; if ( localDeletionTime ( ) < <int> ) throw new MarshalException ( <str> ) ; if ( isExpiring ( ) & & localDeletionTime ( ) = = NO_DELETION_TIME ) throw new MarshalException ( <str> ) ; if ( isTombstone ( ) & & value ( ) . hasRemaining ( ) ) throw new MarshalException ( <str> ) ; if ( path ( ) ! = null ) column ( ) . validateCellPath ( path ( ) ) ; } @Override public boolean equals ( Object other ) { if ( this = = other ) return true ; if ( ! ( other instanceof Cell ) ) return false ; Cell that = ( Cell ) other ; return this . column ( ) . equals ( that . column ( ) ) & & this . isCounterCell ( ) = = that . isCounterCell ( ) & & this . timestamp ( ) = = that . timestamp ( ) & & this . ttl ( ) = = that . ttl ( ) & & this . localDeletionTime ( ) = = that . localDeletionTime ( ) & & Objects . equals ( this . value ( ) , that . value ( ) ) & & Objects . equals ( this . path ( ) , that . path ( ) ) ; } @Override public int hashCode ( ) { return Objects . hash ( column ( ) , isCounterCell ( ) , timestamp ( ) , ttl ( ) , localDeletionTime ( ) , value ( ) , path ( ) ) ; } @Override public String toString ( ) { if ( isCounterCell ( ) ) return String . format ( <str> , column ( ) . name , CounterContext . instance ( ) . total ( value ( ) ) , timestamp ( ) ) ; AbstractType < ? > type = column ( ) . type ; if ( type instanceof CollectionType & & type . isMultiCell ( ) ) { CollectionType ct = ( CollectionType ) type ; return String . format ( <str> , column ( ) . name , ct . nameComparator ( ) . getString ( path ( ) . get ( <int> ) ) , ct . valueComparator ( ) . getString ( value ( ) ) , livenessInfoString ( ) ) ; } if ( isTombstone ( ) ) return String . format ( <str> , column ( ) . name , livenessInfoString ( ) ) ; else return String . format ( <str> , column ( ) . name , type . getString ( value ( ) ) , livenessInfoString ( ) ) ; } private String livenessInfoString ( ) { if ( isExpiring ( ) ) return String . format ( <str> , timestamp ( ) , ttl ( ) , localDeletionTime ( ) ) ; else if ( isTombstone ( ) ) return String . format ( <str> , timestamp ( ) , localDeletionTime ( ) ) ; else return String . format ( <str> , timestamp ( ) ) ; } } 
