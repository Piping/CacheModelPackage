package org . elasticsearch . cluster . metadata ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . joda . DateMathParser ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . IndexClosedException ; import org . joda . time . DateTimeZone ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . Callable ; import java . util . stream . Collectors ; public class IndexNameExpressionResolver extends AbstractComponent { private final List < ExpressionResolver > expressionResolvers ; private final DateMathExpressionResolver dateMathExpressionResolver ; @Inject public IndexNameExpressionResolver ( Settings settings ) { super ( settings ) ; expressionResolvers = Arrays . asList ( dateMathExpressionResolver = new DateMathExpressionResolver ( settings ) , new WildcardExpressionResolver ( ) ) ; } public String [ ] concreteIndices ( ClusterState state , IndicesRequest request ) { Context context = new Context ( state , request . indicesOptions ( ) ) ; return concreteIndices ( context , request . indices ( ) ) ; } public String [ ] concreteIndices ( ClusterState state , IndicesOptions options , String . . . indexExpressions ) { Context context = new Context ( state , options ) ; return concreteIndices ( context , indexExpressions ) ; } public String [ ] concreteIndices ( ClusterState state , IndicesOptions options , long startTime , String . . . indexExpressions ) { Context context = new Context ( state , options , startTime ) ; return concreteIndices ( context , indexExpressions ) ; } String [ ] concreteIndices ( Context context , String . . . indexExpressions ) { if ( indexExpressions = = null | | indexExpressions . length = = <int> ) { indexExpressions = new String [ ] { MetaData . ALL } ; } MetaData metaData = context . getState ( ) . metaData ( ) ; IndicesOptions options = context . getOptions ( ) ; boolean failClosed = options . forbidClosedIndices ( ) & & options . ignoreUnavailable ( ) = = false ; boolean failNoIndices = options . ignoreUnavailable ( ) = = false ; if ( indexExpressions . length = = <int> ) { failNoIndices = options . allowNoIndices ( ) = = false ; } List < String > expressions = Arrays . asList ( indexExpressions ) ; for ( ExpressionResolver expressionResolver : expressionResolvers ) { expressions = expressionResolver . resolve ( context , expressions ) ; } if ( expressions . isEmpty ( ) ) { if ( ! options . allowNoIndices ( ) ) { IndexNotFoundException infe = new IndexNotFoundException ( ( String ) null ) ; infe . setResources ( <str> , indexExpressions ) ; throw infe ; } else { return Strings . EMPTY_ARRAY ; } } final Set < String > concreteIndices = new HashSet < > ( expressions . size ( ) ) ; for ( String expression : expressions ) { AliasOrIndex aliasOrIndex = metaData . getAliasAndIndexLookup ( ) . get ( expression ) ; if ( aliasOrIndex = = null ) { if ( failNoIndices ) { IndexNotFoundException infe = new IndexNotFoundException ( expression ) ; infe . setResources ( <str> , expression ) ; throw infe ; } else { continue ; } } Collection < IndexMetaData > resolvedIndices = aliasOrIndex . getIndices ( ) ; if ( resolvedIndices . size ( ) > <int> & & ! options . allowAliasesToMultipleIndices ( ) ) { String [ ] indexNames = new String [ resolvedIndices . size ( ) ] ; int i = <int> ; for ( IndexMetaData indexMetaData : resolvedIndices ) { indexNames [ i + + ] = indexMetaData . getIndex ( ) ; } throw new IllegalArgumentException ( <str> + expression + <str> + Arrays . toString ( indexNames ) + <str> ) ; } for ( IndexMetaData index : resolvedIndices ) { if ( index . getState ( ) = = IndexMetaData . State . CLOSE ) { if ( failClosed ) { throw new IndexClosedException ( new Index ( index . getIndex ( ) ) ) ; } else { if ( options . forbidClosedIndices ( ) = = false ) { concreteIndices . add ( index . getIndex ( ) ) ; } } } else if ( index . getState ( ) = = IndexMetaData . State . OPEN ) { concreteIndices . add ( index . getIndex ( ) ) ; } else { throw new IllegalStateException ( <str> + index . getState ( ) + <str> ) ; } } } if ( options . allowNoIndices ( ) = = false & & concreteIndices . isEmpty ( ) ) { IndexNotFoundException infe = new IndexNotFoundException ( ( String ) null ) ; infe . setResources ( <str> , indexExpressions ) ; throw infe ; } return concreteIndices . toArray ( new String [ concreteIndices . size ( ) ] ) ; } public String concreteSingleIndex ( ClusterState state , IndicesRequest request ) { String indexExpression = request . indices ( ) ! = null & & request . indices ( ) . length > <int> ? request . indices ( ) [ <int> ] : null ; String [ ] indices = concreteIndices ( state , request . indicesOptions ( ) , indexExpression ) ; if ( indices . length ! = <int> ) { throw new IllegalArgumentException ( <str> ) ; } return indices [ <int> ] ; } public boolean hasIndexOrAlias ( String aliasOrIndex , ClusterState state ) { Context context = new Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; String resolvedAliasOrIndex = dateMathExpressionResolver . resolveExpression ( aliasOrIndex , context ) ; return state . metaData ( ) . getAliasAndIndexLookup ( ) . containsKey ( resolvedAliasOrIndex ) ; } public String resolveDateMathExpression ( String dateExpression ) { return dateMathExpressionResolver . resolveExpression ( dateExpression , new Context ( null , null ) ) ; } public String [ ] filteringAliases ( ClusterState state , String index , String . . . expressions ) { List < String > resolvedExpressions = expressions ! = null ? Arrays . asList ( expressions ) : Collections . < String > emptyList ( ) ; Context context = new Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; for ( ExpressionResolver expressionResolver : expressionResolvers ) { resolvedExpressions = expressionResolver . resolve ( context , resolvedExpressions ) ; } if ( isAllIndices ( resolvedExpressions ) ) { return null ; } if ( resolvedExpressions . size ( ) = = <int> ) { String alias = resolvedExpressions . get ( <int> ) ; IndexMetaData indexMetaData = state . metaData ( ) . getIndices ( ) . get ( index ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( index ) ; } AliasMetaData aliasMetaData = indexMetaData . getAliases ( ) . get ( alias ) ; boolean filteringRequired = aliasMetaData ! = null & & aliasMetaData . filteringRequired ( ) ; if ( ! filteringRequired ) { return null ; } return new String [ ] { alias } ; } List < String > filteringAliases = null ; for ( String alias : resolvedExpressions ) { if ( alias . equals ( index ) ) { return null ; } IndexMetaData indexMetaData = state . metaData ( ) . getIndices ( ) . get ( index ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( index ) ; } AliasMetaData aliasMetaData = indexMetaData . getAliases ( ) . get ( alias ) ; if ( aliasMetaData ! = null ) { boolean filteringRequired = aliasMetaData . filteringRequired ( ) ; if ( filteringRequired ) { if ( filteringAliases = = null ) { filteringAliases = new ArrayList < > ( ) ; } filteringAliases . add ( alias ) ; } else { return null ; } } } if ( filteringAliases = = null ) { return null ; } return filteringAliases . toArray ( new String [ filteringAliases . size ( ) ] ) ; } public Map < String , Set < String > > resolveSearchRouting ( ClusterState state , @Nullable String routing , String . . . expressions ) { List < String > resolvedExpressions = expressions ! = null ? Arrays . asList ( expressions ) : Collections . < String > emptyList ( ) ; Context context = new Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; for ( ExpressionResolver expressionResolver : expressionResolvers ) { resolvedExpressions = expressionResolver . resolve ( context , resolvedExpressions ) ; } if ( isAllIndices ( resolvedExpressions ) ) { return resolveSearchRoutingAllIndices ( state . metaData ( ) , routing ) ; } Map < String , Set < String > > routings = null ; Set < String > paramRouting = null ; Set < String > norouting = new HashSet < > ( ) ; if ( routing ! = null ) { paramRouting = Strings . splitStringByCommaToSet ( routing ) ; } for ( String expression : resolvedExpressions ) { AliasOrIndex aliasOrIndex = state . metaData ( ) . getAliasAndIndexLookup ( ) . get ( expression ) ; if ( aliasOrIndex ! = null & & aliasOrIndex . isAlias ( ) ) { AliasOrIndex . Alias alias = ( AliasOrIndex . Alias ) aliasOrIndex ; for ( Tuple < String , AliasMetaData > item : alias . getConcreteIndexAndAliasMetaDatas ( ) ) { String concreteIndex = item . v1 ( ) ; AliasMetaData aliasMetaData = item . v2 ( ) ; if ( ! norouting . contains ( concreteIndex ) ) { if ( ! aliasMetaData . searchRoutingValues ( ) . isEmpty ( ) ) { if ( routings = = null ) { routings = new HashMap < > ( ) ; } Set < String > r = routings . get ( concreteIndex ) ; if ( r = = null ) { r = new HashSet < > ( ) ; routings . put ( concreteIndex , r ) ; } r . addAll ( aliasMetaData . searchRoutingValues ( ) ) ; if ( paramRouting ! = null ) { r . retainAll ( paramRouting ) ; } if ( r . isEmpty ( ) ) { routings . remove ( concreteIndex ) ; } } else { if ( ! norouting . contains ( concreteIndex ) ) { norouting . add ( concreteIndex ) ; if ( paramRouting ! = null ) { Set < String > r = new HashSet < > ( paramRouting ) ; if ( routings = = null ) { routings = new HashMap < > ( ) ; } routings . put ( concreteIndex , r ) ; } else { if ( routings ! = null ) { routings . remove ( concreteIndex ) ; } } } } } } } else { if ( ! norouting . contains ( expression ) ) { norouting . add ( expression ) ; if ( paramRouting ! = null ) { Set < String > r = new HashSet < > ( paramRouting ) ; if ( routings = = null ) { routings = new HashMap < > ( ) ; } routings . put ( expression , r ) ; } else { if ( routings ! = null ) { routings . remove ( expression ) ; } } } } } if ( routings = = null | | routings . isEmpty ( ) ) { return null ; } return routings ; } private Map < String , Set < String > > resolveSearchRoutingAllIndices ( MetaData metaData , String routing ) { if ( routing ! = null ) { Set < String > r = Strings . splitStringByCommaToSet ( routing ) ; Map < String , Set < String > > routings = new HashMap < > ( ) ; String [ ] concreteIndices = metaData . concreteAllIndices ( ) ; for ( String index : concreteIndices ) { routings . put ( index , r ) ; } return routings ; } return null ; } public static boolean isAllIndices ( List < String > aliasesOrIndices ) { return aliasesOrIndices = = null | | aliasesOrIndices . isEmpty ( ) | | isExplicitAllPattern ( aliasesOrIndices ) ; } static boolean isExplicitAllPattern ( List < String > aliasesOrIndices ) { return aliasesOrIndices ! = null & & aliasesOrIndices . size ( ) = = <int> & & MetaData . ALL . equals ( aliasesOrIndices . get ( <int> ) ) ; } boolean isPatternMatchingAllIndices ( MetaData metaData , String [ ] indicesOrAliases , String [ ] concreteIndices ) { if ( concreteIndices . length = = metaData . concreteAllIndices ( ) . length & & indicesOrAliases . length > <int> ) { if ( indicesOrAliases [ <int> ] . charAt ( <int> ) = = <str> ) { return true ; } for ( String indexOrAlias : indicesOrAliases ) { if ( Regex . isSimpleMatchPattern ( indexOrAlias ) ) { return true ; } } } return false ; } final static class Context { private final ClusterState state ; private final IndicesOptions options ; private final long startTime ; Context ( ClusterState state , IndicesOptions options ) { this . state = state ; this . options = options ; startTime = System . currentTimeMillis ( ) ; } public Context ( ClusterState state , IndicesOptions options , long startTime ) { this . state = state ; this . options = options ; this . startTime = startTime ; } public ClusterState getState ( ) { return state ; } public IndicesOptions getOptions ( ) { return options ; } public long getStartTime ( ) { return startTime ; } } private interface ExpressionResolver { List < String > resolve ( Context context , List < String > expressions ) ; } final static class WildcardExpressionResolver implements ExpressionResolver { @Override public List < String > resolve ( Context context , List < String > expressions ) { IndicesOptions options = context . getOptions ( ) ; MetaData metaData = context . getState ( ) . metaData ( ) ; if ( options . expandWildcardsClosed ( ) = = false & & options . expandWildcardsOpen ( ) = = false ) { return expressions ; } if ( expressions . isEmpty ( ) | | ( expressions . size ( ) = = <int> & & ( MetaData . ALL . equals ( expressions . get ( <int> ) ) ) | | Regex . isMatchAllPattern ( expressions . get ( <int> ) ) ) ) { if ( options . expandWildcardsOpen ( ) & & options . expandWildcardsClosed ( ) ) { return Arrays . asList ( metaData . concreteAllIndices ( ) ) ; } else if ( options . expandWildcardsOpen ( ) ) { return Arrays . asList ( metaData . concreteAllOpenIndices ( ) ) ; } else if ( options . expandWildcardsClosed ( ) ) { return Arrays . asList ( metaData . concreteAllClosedIndices ( ) ) ; } else { return Collections . emptyList ( ) ; } } Set < String > result = null ; for ( int i = <int> ; i < expressions . size ( ) ; i + + ) { String expression = expressions . get ( i ) ; if ( metaData . getAliasAndIndexLookup ( ) . containsKey ( expression ) ) { if ( result ! = null ) { result . add ( expression ) ; } continue ; } boolean add = true ; if ( expression . charAt ( <int> ) = = <str> ) { if ( i = = <int> ) { result = new HashSet < > ( ) ; } add = true ; expression = expression . substring ( <int> ) ; } else if ( expression . charAt ( <int> ) = = <str> ) { if ( i = = <int> ) { String [ ] concreteIndices ; if ( options . expandWildcardsOpen ( ) & & options . expandWildcardsClosed ( ) ) { concreteIndices = metaData . concreteAllIndices ( ) ; } else if ( options . expandWildcardsOpen ( ) ) { concreteIndices = metaData . concreteAllOpenIndices ( ) ; } else if ( options . expandWildcardsClosed ( ) ) { concreteIndices = metaData . concreteAllClosedIndices ( ) ; } else { assert false : <str> ; concreteIndices = Strings . EMPTY_ARRAY ; } result = new HashSet < > ( Arrays . asList ( concreteIndices ) ) ; } add = false ; expression = expression . substring ( <int> ) ; } if ( ! Regex . isSimpleMatchPattern ( expression ) ) { if ( ! options . ignoreUnavailable ( ) & & ! metaData . getAliasAndIndexLookup ( ) . containsKey ( expression ) ) { IndexNotFoundException infe = new IndexNotFoundException ( expression ) ; infe . setResources ( <str> , expression ) ; throw infe ; } if ( result ! = null ) { if ( add ) { result . add ( expression ) ; } else { result . remove ( expression ) ; } } continue ; } if ( result = = null ) { result = new HashSet < > ( ) ; result . addAll ( expressions . subList ( <int> , i ) ) ; } final IndexMetaData . State excludeState ; if ( options . expandWildcardsOpen ( ) & & options . expandWildcardsClosed ( ) ) { excludeState = null ; } else if ( options . expandWildcardsOpen ( ) & & options . expandWildcardsClosed ( ) = = false ) { excludeState = IndexMetaData . State . CLOSE ; } else if ( options . expandWildcardsClosed ( ) & & options . expandWildcardsOpen ( ) = = false ) { excludeState = IndexMetaData . State . OPEN ; } else { assert false : <str> ; excludeState = null ; } final Map < String , AliasOrIndex > matches ; if ( Regex . isMatchAllPattern ( expression ) ) { matches = metaData . getAliasAndIndexLookup ( ) ; } else if ( expression . indexOf ( <str> ) = = expression . length ( ) - <int> ) { assert expression . length ( ) > = <int> : <str> + expression + <str> ; String fromPrefix = expression . substring ( <int> , expression . length ( ) - <int> ) ; char [ ] toPrefixCharArr = fromPrefix . toCharArray ( ) ; toPrefixCharArr [ toPrefixCharArr . length - <int> ] + + ; String toPrefix = new String ( toPrefixCharArr ) ; matches = metaData . getAliasAndIndexLookup ( ) . subMap ( fromPrefix , toPrefix ) ; } else { final String pattern = expression ; matches = metaData . getAliasAndIndexLookup ( ) . entrySet ( ) . stream ( ) . filter ( e - > Regex . simpleMatch ( pattern , e . getKey ( ) ) ) . collect ( Collectors . toMap ( Map . Entry : : getKey , Map . Entry : : getValue ) ) ; } for ( Map . Entry < String , AliasOrIndex > entry : matches . entrySet ( ) ) { AliasOrIndex aliasOrIndex = entry . getValue ( ) ; if ( aliasOrIndex . isAlias ( ) = = false ) { AliasOrIndex . Index index = ( AliasOrIndex . Index ) aliasOrIndex ; if ( excludeState ! = null & & index . getIndex ( ) . getState ( ) = = excludeState ) { continue ; } } if ( add ) { result . add ( entry . getKey ( ) ) ; } else { result . remove ( entry . getKey ( ) ) ; } } if ( matches . isEmpty ( ) & & options . allowNoIndices ( ) = = false ) { IndexNotFoundException infe = new IndexNotFoundException ( expression ) ; infe . setResources ( <str> , expression ) ; throw infe ; } } if ( result = = null ) { return expressions ; } if ( result . isEmpty ( ) & & ! options . allowNoIndices ( ) ) { IndexNotFoundException infe = new IndexNotFoundException ( ( String ) null ) ; infe . setResources ( <str> , expressions . toArray ( new String [ <int> ] ) ) ; throw infe ; } return new ArrayList < > ( result ) ; } } final static class DateMathExpressionResolver implements ExpressionResolver { private static final String EXPRESSION_LEFT_BOUND = <str> ; private static final String EXPRESSION_RIGHT_BOUND = <str> ; private static final char LEFT_BOUND = <str> ; private static final char RIGHT_BOUND = <str> ; private static final char ESCAPE_CHAR = <str> ; private static final char TIME_ZONE_BOUND = <str> ; private final DateTimeZone defaultTimeZone ; private final String defaultDateFormatterPattern ; private final DateTimeFormatter defaultDateFormatter ; public DateMathExpressionResolver ( Settings settings ) { String defaultTimeZoneId = settings . get ( <str> , <str> ) ; this . defaultTimeZone = DateTimeZone . forID ( defaultTimeZoneId ) ; defaultDateFormatterPattern = settings . get ( <str> , <str> ) ; this . defaultDateFormatter = DateTimeFormat . forPattern ( defaultDateFormatterPattern ) ; } @Override public List < String > resolve ( final Context context , List < String > expressions ) { List < String > result = new ArrayList < > ( expressions . size ( ) ) ; for ( String expression : expressions ) { result . add ( resolveExpression ( expression , context ) ) ; } return result ; } @SuppressWarnings ( <str> ) String resolveExpression ( String expression , final Context context ) { if ( expression . startsWith ( EXPRESSION_LEFT_BOUND ) = = false | | expression . endsWith ( EXPRESSION_RIGHT_BOUND ) = = false ) { return expression ; } boolean escape = false ; boolean inDateFormat = false ; boolean inPlaceHolder = false ; final StringBuilder beforePlaceHolderSb = new StringBuilder ( ) ; StringBuilder inPlaceHolderSb = new StringBuilder ( ) ; final char [ ] text = expression . toCharArray ( ) ; final int from = <int> ; final int length = text . length - <int> ; for ( int i = from ; i < length ; i + + ) { boolean escapedChar = escape ; if ( escape ) { escape = false ; } char c = text [ i ] ; if ( c = = ESCAPE_CHAR ) { if ( escapedChar ) { beforePlaceHolderSb . append ( c ) ; escape = false ; } else { escape = true ; } continue ; } if ( inPlaceHolder ) { switch ( c ) { case LEFT_BOUND : if ( inDateFormat & & escapedChar ) { inPlaceHolderSb . append ( c ) ; } else if ( ! inDateFormat ) { inDateFormat = true ; inPlaceHolderSb . append ( c ) ; } else { throw new ElasticsearchParseException ( <str> , new String ( text , from , length ) , i ) ; } break ; case RIGHT_BOUND : if ( inDateFormat & & escapedChar ) { inPlaceHolderSb . append ( c ) ; } else if ( inDateFormat ) { inDateFormat = false ; inPlaceHolderSb . append ( c ) ; } else { String inPlaceHolderString = inPlaceHolderSb . toString ( ) ; int dateTimeFormatLeftBoundIndex = inPlaceHolderString . indexOf ( LEFT_BOUND ) ; String mathExpression ; String dateFormatterPattern ; DateTimeFormatter dateFormatter ; final DateTimeZone timeZone ; if ( dateTimeFormatLeftBoundIndex < <int> ) { mathExpression = inPlaceHolderString ; dateFormatterPattern = defaultDateFormatterPattern ; dateFormatter = defaultDateFormatter ; timeZone = defaultTimeZone ; } else { if ( inPlaceHolderString . lastIndexOf ( RIGHT_BOUND ) ! = inPlaceHolderString . length ( ) - <int> ) { throw new ElasticsearchParseException ( <str> , inPlaceHolderString ) ; } if ( dateTimeFormatLeftBoundIndex = = inPlaceHolderString . length ( ) - <int> ) { throw new ElasticsearchParseException ( <str> , inPlaceHolderString ) ; } mathExpression = inPlaceHolderString . substring ( <int> , dateTimeFormatLeftBoundIndex ) ; String dateFormatterPatternAndTimeZoneId = inPlaceHolderString . substring ( dateTimeFormatLeftBoundIndex + <int> , inPlaceHolderString . length ( ) - <int> ) ; int formatPatternTimeZoneSeparatorIndex = dateFormatterPatternAndTimeZoneId . indexOf ( TIME_ZONE_BOUND ) ; if ( formatPatternTimeZoneSeparatorIndex ! = - <int> ) { dateFormatterPattern = dateFormatterPatternAndTimeZoneId . substring ( <int> , formatPatternTimeZoneSeparatorIndex ) ; timeZone = DateTimeZone . forID ( dateFormatterPatternAndTimeZoneId . substring ( formatPatternTimeZoneSeparatorIndex + <int> ) ) ; } else { dateFormatterPattern = dateFormatterPatternAndTimeZoneId ; timeZone = defaultTimeZone ; } dateFormatter = DateTimeFormat . forPattern ( dateFormatterPattern ) ; } DateTimeFormatter parser = dateFormatter . withZone ( timeZone ) ; FormatDateTimeFormatter formatter = new FormatDateTimeFormatter ( dateFormatterPattern , parser , Locale . ROOT ) ; DateMathParser dateMathParser = new DateMathParser ( formatter ) ; long millis = dateMathParser . parse ( mathExpression , new Callable < Long > ( ) { @Override public Long call ( ) throws Exception { return context . getStartTime ( ) ; } } , false , timeZone ) ; String time = formatter . printer ( ) . print ( millis ) ; beforePlaceHolderSb . append ( time ) ; inPlaceHolderSb = new StringBuilder ( ) ; inPlaceHolder = false ; } break ; default: inPlaceHolderSb . append ( c ) ; } } else { switch ( c ) { case LEFT_BOUND : if ( escapedChar ) { beforePlaceHolderSb . append ( c ) ; } else { inPlaceHolder = true ; } break ; case RIGHT_BOUND : if ( ! escapedChar ) { throw new ElasticsearchParseException ( <str> + <str> , new String ( text , from , length ) , i ) ; } default : beforePlaceHolderSb . append ( c ) ; } } } if ( inPlaceHolder ) { throw new ElasticsearchParseException ( <str> , new String ( text , from , length ) ) ; } if ( beforePlaceHolderSb . length ( ) = = <int> ) { throw new ElasticsearchParseException ( <str> ) ; } return beforePlaceHolderSb . toString ( ) ; } } public final boolean matchesIndex ( String indexName , String expression , ClusterState state ) { final String [ ] concreteIndices = concreteIndices ( state , IndicesOptions . lenientExpandOpen ( ) , expression ) ; for ( String index : concreteIndices ) { if ( Regex . simpleMatch ( index , indexName ) ) { return true ; } } return indexName . equals ( expression ) ; } } 
