package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . TimeUtils ; public class SpriteBatchTest extends GdxTest implements InputProcessor { int SPRITES = <int> / <int> ; long startTime = TimeUtils . nanoTime ( ) ; int frames = <int> ; Texture texture ; Texture texture2 ; SpriteBatch spriteBatch ; float sprites [ ] = new float [ SPRITES * <int> ] ; float sprites2 [ ] = new float [ SPRITES * <int> ] ; Sprite [ ] sprites3 = new Sprite [ SPRITES * <int> ] ; float angle = <int> ; float ROTATION_SPEED = <int> ; float scale = <int> ; float SCALE_SPEED = - <int> ; int renderMethod = <int> ; @Override public void render ( ) { if ( renderMethod = = <int> ) renderNormal ( ) ; ; if ( renderMethod = = <int> ) renderSprites ( ) ; } private void renderNormal ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float begin = <int> ; float end = <int> ; float draw1 = <int> ; float draw2 = <int> ; float drawText = <int> ; angle + = ROTATION_SPEED * Gdx . graphics . getDeltaTime ( ) ; scale + = SCALE_SPEED * Gdx . graphics . getDeltaTime ( ) ; if ( scale < <float> ) { scale = <float> ; SCALE_SPEED = <int> ; } if ( scale > <float> ) { scale = <float> ; SCALE_SPEED = - <int> ; } long start = TimeUtils . nanoTime ( ) ; spriteBatch . begin ( ) ; begin = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < sprites . length ; i + = <int> ) spriteBatch . draw ( texture , sprites [ i ] , sprites [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; draw1 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < sprites2 . length ; i + = <int> ) spriteBatch . draw ( texture2 , sprites2 [ i ] , sprites2 [ i + <int> ] , <int> , <int> , <int> , <int> , scale , scale , angle , <int> , <int> , <int> , <int> , false , false ) ; draw2 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; drawText = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteBatch . end ( ) ; end = ( TimeUtils . nanoTime ( ) - start ) / <float> ; if ( TimeUtils . nanoTime ( ) - startTime > <int> ) { Gdx . app . log ( <str> , <str> + frames + <str> + spriteBatch . renderCalls + <str> + begin + <str> + draw1 + <str> + draw2 + <str> + drawText + <str> + end ) ; frames = <int> ; startTime = TimeUtils . nanoTime ( ) ; } frames + + ; } private void renderSprites ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float begin = <int> ; float end = <int> ; float draw1 = <int> ; float draw2 = <int> ; float drawText = <int> ; long start = TimeUtils . nanoTime ( ) ; spriteBatch . begin ( ) ; begin = ( TimeUtils . nanoTime ( ) - start ) / <float> ; float angleInc = ROTATION_SPEED * Gdx . graphics . getDeltaTime ( ) ; scale + = SCALE_SPEED * Gdx . graphics . getDeltaTime ( ) ; if ( scale < <float> ) { scale = <float> ; SCALE_SPEED = <int> ; } if ( scale > <float> ) { scale = <float> ; SCALE_SPEED = - <int> ; } start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < SPRITES ; i + + ) { if ( angleInc ! = <int> ) sprites3 [ i ] . rotate ( angleInc ) ; if ( scale ! = <int> ) sprites3 [ i ] . setScale ( scale ) ; sprites3 [ i ] . draw ( spriteBatch ) ; } draw1 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; for ( int i = SPRITES ; i < SPRITES < < <int> ; i + + ) { if ( angleInc ! = <int> ) sprites3 [ i ] . rotate ( angleInc ) ; if ( scale ! = <int> ) sprites3 [ i ] . setScale ( scale ) ; sprites3 [ i ] . draw ( spriteBatch ) ; } draw2 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; drawText = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteBatch . end ( ) ; end = ( TimeUtils . nanoTime ( ) - start ) / <float> ; if ( TimeUtils . nanoTime ( ) - startTime > <int> ) { Gdx . app . log ( <str> , <str> + frames + <str> + spriteBatch . renderCalls + <str> + begin + <str> + draw1 + <str> + draw2 + <str> + drawText + <str> + end ) ; frames = <int> ; startTime = TimeUtils . nanoTime ( ) ; } frames + + ; } @Override public void create ( ) { spriteBatch = new SpriteBatch ( <int> ) ; Pixmap pixmap = new Pixmap ( Gdx . files . internal ( <str> ) ) ; texture = new Texture ( <int> , <int> , Format . RGB565 ) ; texture . setFilter ( TextureFilter . Linear , TextureFilter . Linear ) ; texture . draw ( pixmap , <int> , <int> ) ; pixmap . dispose ( ) ; pixmap = new Pixmap ( <int> , <int> , Format . RGBA8888 ) ; pixmap . setColor ( <int> , <int> , <int> , <float> ) ; pixmap . fill ( ) ; texture2 = new Texture ( pixmap ) ; pixmap . dispose ( ) ; for ( int i = <int> ; i < sprites . length ; i + = <int> ) { sprites [ i ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; sprites [ i + <int> ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites [ i + <int> ] = <int> ; sprites2 [ i ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; sprites2 [ i + <int> ] = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; sprites2 [ i + <int> ] = <int> ; } for ( int i = <int> ; i < SPRITES * <int> ; i + + ) { int x = ( int ) ( Math . random ( ) * ( Gdx . graphics . getWidth ( ) - <int> ) ) ; int y = ( int ) ( Math . random ( ) * ( Gdx . graphics . getHeight ( ) - <int> ) ) ; if ( i > = SPRITES ) sprites3 [ i ] = new Sprite ( texture2 , <int> , <int> ) ; else sprites3 [ i ] = new Sprite ( texture , <int> , <int> ) ; sprites3 [ i ] . setPosition ( x , y ) ; sprites3 [ i ] . setOrigin ( <int> , <int> ) ; } Gdx . input . setInputProcessor ( this ) ; } @Override public void resize ( int width , int height ) { Gdx . app . log ( <str> , <str> + width + <str> + height ) ; } @Override public boolean keyDown ( int keycode ) { return false ; } @Override public boolean keyTyped ( char character ) { return false ; } @Override public boolean keyUp ( int keycode ) { return false ; } @Override public boolean touchDown ( int x , int y , int pointer , int newParam ) { return false ; } @Override public boolean touchDragged ( int x , int y , int pointer ) { return false ; } @Override public boolean touchUp ( int x , int y , int pointer , int button ) { renderMethod = ( renderMethod + <int> ) % <int> ; return false ; } @Override public boolean mouseMoved ( int x , int y ) { return false ; } @Override public boolean scrolled ( int amount ) { return false ; } } 
