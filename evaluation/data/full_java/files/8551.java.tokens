package org . elasticsearch . snapshots . mockstore ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . blobstore . BlobContainer ; import org . elasticsearch . common . blobstore . BlobMetaData ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . BlobStore ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . snapshots . blobstore . BlobStoreIndexShardRepository ; import org . elasticsearch . repositories . RepositoriesModule ; import org . elasticsearch . repositories . RepositoryName ; import org . elasticsearch . repositories . RepositorySettings ; import org . elasticsearch . repositories . fs . FsRepository ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . nio . file . Path ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicLong ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class MockRepository extends FsRepository { public static class Plugin extends org . elasticsearch . plugins . Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( RepositoriesModule repositoriesModule ) { repositoriesModule . registerRepository ( <str> , MockRepository . class , BlobStoreIndexShardRepository . class ) ; } @Override public Collection < Module > nodeModules ( ) { return Collections . < Module > singletonList ( new SettingsFilteringModule ( ) ) ; } public static class SettingsFilteringModule extends AbstractModule { @Override protected void configure ( ) { bind ( SettingsFilteringService . class ) . asEagerSingleton ( ) ; } } public static class SettingsFilteringService { @Inject public SettingsFilteringService ( SettingsFilter settingsFilter ) { settingsFilter . addFilter ( <str> ) ; } } } private final AtomicLong failureCounter = new AtomicLong ( ) ; public long getFailureCount ( ) { return failureCounter . get ( ) ; } private final double randomControlIOExceptionRate ; private final double randomDataFileIOExceptionRate ; private final long maximumNumberOfFailures ; private final long waitAfterUnblock ; private final MockBlobStore mockBlobStore ; private final String randomPrefix ; private volatile boolean blockOnInitialization ; private volatile boolean blockOnControlFiles ; private volatile boolean blockOnDataFiles ; private volatile boolean blocked = false ; @Inject public MockRepository ( RepositoryName name , RepositorySettings repositorySettings , IndexShardRepository indexShardRepository , ClusterService clusterService , Environment environment ) throws IOException { super ( name , overrideSettings ( repositorySettings , clusterService ) , indexShardRepository , environment ) ; randomControlIOExceptionRate = repositorySettings . settings ( ) . getAsDouble ( <str> , <float> ) ; randomDataFileIOExceptionRate = repositorySettings . settings ( ) . getAsDouble ( <str> , <float> ) ; maximumNumberOfFailures = repositorySettings . settings ( ) . getAsLong ( <str> , <int> ) ; blockOnControlFiles = repositorySettings . settings ( ) . getAsBoolean ( <str> , false ) ; blockOnDataFiles = repositorySettings . settings ( ) . getAsBoolean ( <str> , false ) ; blockOnInitialization = repositorySettings . settings ( ) . getAsBoolean ( <str> , false ) ; randomPrefix = repositorySettings . settings ( ) . get ( <str> , <str> ) ; waitAfterUnblock = repositorySettings . settings ( ) . getAsLong ( <str> , <int> L ) ; logger . info ( <str> + randomPrefix ) ; mockBlobStore = new MockBlobStore ( super . blobStore ( ) ) ; } @Override public void initializeSnapshot ( SnapshotId snapshotId , List < String > indices , MetaData metaData ) { if ( blockOnInitialization ) { blockExecution ( ) ; } super . initializeSnapshot ( snapshotId , indices , metaData ) ; } private static RepositorySettings overrideSettings ( RepositorySettings repositorySettings , ClusterService clusterService ) { if ( repositorySettings . settings ( ) . getAsBoolean ( <str> , false ) ) { return new RepositorySettings ( repositorySettings . globalSettings ( ) , localizeLocation ( repositorySettings . settings ( ) , clusterService ) ) ; } else { return repositorySettings ; } } private static Settings localizeLocation ( Settings settings , ClusterService clusterService ) { Path location = PathUtils . get ( settings . get ( <str> ) ) ; location = location . resolve ( clusterService . localNode ( ) . getId ( ) ) ; return settingsBuilder ( ) . put ( settings ) . put ( <str> , location . toAbsolutePath ( ) ) . build ( ) ; } private long incrementAndGetFailureCount ( ) { return failureCounter . incrementAndGet ( ) ; } @Override protected void doStop ( ) { unblock ( ) ; super . doStop ( ) ; } @Override protected BlobStore blobStore ( ) { return mockBlobStore ; } public void unblock ( ) { unblockExecution ( ) ; } public void blockOnDataFiles ( boolean blocked ) { blockOnDataFiles = blocked ; } public void blockOnControlFiles ( boolean blocked ) { blockOnControlFiles = blocked ; } public synchronized void unblockExecution ( ) { if ( blocked ) { blocked = false ; blockOnDataFiles = false ; blockOnControlFiles = false ; blockOnInitialization = false ; this . notifyAll ( ) ; } } public boolean blocked ( ) { return blocked ; } private synchronized boolean blockExecution ( ) { logger . debug ( <str> ) ; boolean wasBlocked = false ; try { while ( blockOnDataFiles | | blockOnControlFiles | | blockOnInitialization ) { blocked = true ; this . wait ( ) ; wasBlocked = true ; } } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } logger . debug ( <str> ) ; return wasBlocked ; } public class MockBlobStore extends BlobStoreWrapper { ConcurrentMap < String , AtomicLong > accessCounts = new ConcurrentHashMap < > ( ) ; private long incrementAndGet ( String path ) { AtomicLong value = accessCounts . get ( path ) ; if ( value = = null ) { value = accessCounts . putIfAbsent ( path , new AtomicLong ( <int> ) ) ; } if ( value ! = null ) { return value . incrementAndGet ( ) ; } return <int> ; } public MockBlobStore ( BlobStore delegate ) { super ( delegate ) ; } @Override public BlobContainer blobContainer ( BlobPath path ) { return new MockBlobContainer ( super . blobContainer ( path ) ) ; } private class MockBlobContainer extends BlobContainerWrapper { private MessageDigest digest ; private boolean shouldFail ( String blobName , double probability ) { if ( probability > <float> ) { String path = path ( ) . add ( blobName ) . buildAsString ( <str> ) + <str> + randomPrefix ; path + = <str> + incrementAndGet ( path ) ; logger . info ( <str> , path , Math . abs ( hashCode ( path ) ) < Integer . MAX_VALUE * probability ) ; return Math . abs ( hashCode ( path ) ) < Integer . MAX_VALUE * probability ; } else { return false ; } } private int hashCode ( String path ) { try { digest = MessageDigest . getInstance ( <str> ) ; byte [ ] bytes = digest . digest ( path . getBytes ( <str> ) ) ; int i = <int> ; return ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( bytes [ i + + ] & <hex> ) ; } catch ( NoSuchAlgorithmException | UnsupportedEncodingException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } private void maybeIOExceptionOrBlock ( String blobName ) throws IOException { if ( blobName . startsWith ( <str> ) ) { if ( shouldFail ( blobName , randomDataFileIOExceptionRate ) & & ( incrementAndGetFailureCount ( ) < maximumNumberOfFailures ) ) { logger . info ( <str> , blobName , path ( ) ) ; throw new IOException ( <str> ) ; } else if ( blockOnDataFiles ) { logger . info ( <str> , blobName , path ( ) ) ; if ( blockExecution ( ) & & waitAfterUnblock > <int> ) { try { Thread . sleep ( waitAfterUnblock ) ; } catch ( InterruptedException ex ) { } } } } else { if ( shouldFail ( blobName , randomControlIOExceptionRate ) & & ( incrementAndGetFailureCount ( ) < maximumNumberOfFailures ) ) { logger . info ( <str> , blobName , path ( ) ) ; throw new IOException ( <str> ) ; } else if ( blockOnControlFiles ) { logger . info ( <str> , blobName , path ( ) ) ; if ( blockExecution ( ) & & waitAfterUnblock > <int> ) { try { Thread . sleep ( waitAfterUnblock ) ; } catch ( InterruptedException ex ) { } } } } } public MockBlobContainer ( BlobContainer delegate ) { super ( delegate ) ; } @Override public boolean blobExists ( String blobName ) { return super . blobExists ( blobName ) ; } @Override public InputStream readBlob ( String name ) throws IOException { maybeIOExceptionOrBlock ( name ) ; return super . readBlob ( name ) ; } @Override public void deleteBlob ( String blobName ) throws IOException { maybeIOExceptionOrBlock ( blobName ) ; super . deleteBlob ( blobName ) ; } @Override public void deleteBlobsByPrefix ( String blobNamePrefix ) throws IOException { maybeIOExceptionOrBlock ( blobNamePrefix ) ; super . deleteBlobsByPrefix ( blobNamePrefix ) ; } @Override public Map < String , BlobMetaData > listBlobs ( ) throws IOException { maybeIOExceptionOrBlock ( <str> ) ; return super . listBlobs ( ) ; } @Override public Map < String , BlobMetaData > listBlobsByPrefix ( String blobNamePrefix ) throws IOException { maybeIOExceptionOrBlock ( blobNamePrefix ) ; return super . listBlobsByPrefix ( blobNamePrefix ) ; } @Override public void move ( String sourceBlob , String targetBlob ) throws IOException { maybeIOExceptionOrBlock ( targetBlob ) ; super . move ( sourceBlob , targetBlob ) ; } @Override public void writeBlob ( String blobName , BytesReference bytes ) throws IOException { maybeIOExceptionOrBlock ( blobName ) ; super . writeBlob ( blobName , bytes ) ; } @Override public void writeBlob ( String blobName , InputStream inputStream , long blobSize ) throws IOException { maybeIOExceptionOrBlock ( blobName ) ; super . writeBlob ( blobName , inputStream , blobSize ) ; } } } } 
