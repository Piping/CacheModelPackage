package io . netty . handler . codec . socksx . v4 ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socksx . SocksVersion ; import io . netty . handler . codec . socksx . v4 . Socks4ServerDecoder . State ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import java . util . List ; public class Socks4ServerDecoder extends ReplayingDecoder < State > { private static final int MAX_FIELD_LENGTH = <int> ; enum State { START , READ_USERID , READ_DOMAIN , SUCCESS , FAILURE } private Socks4CommandType type ; private String dstAddr ; private int dstPort ; private String userId ; public Socks4ServerDecoder ( ) { super ( State . START ) ; setSingleDecode ( true ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( state ( ) ) { case START : { final int version = in . readUnsignedByte ( ) ; if ( version ! = SocksVersion . SOCKS4a . byteValue ( ) ) { throw new DecoderException ( <str> + version ) ; } type = Socks4CommandType . valueOf ( in . readByte ( ) ) ; dstPort = in . readUnsignedShort ( ) ; dstAddr = NetUtil . intToIpAddress ( in . readInt ( ) ) ; checkpoint ( State . READ_USERID ) ; } case READ_USERID : { userId = readString ( <str> , in ) ; checkpoint ( State . READ_DOMAIN ) ; } case READ_DOMAIN : { if ( ! <str> . equals ( dstAddr ) & & dstAddr . startsWith ( <str> ) ) { dstAddr = readString ( <str> , in ) ; } out . add ( new DefaultSocks4CommandRequest ( type , dstAddr , dstPort , userId ) ) ; checkpoint ( State . SUCCESS ) ; } case SUCCESS : { int readableBytes = actualReadableBytes ( ) ; if ( readableBytes > <int> ) { out . add ( in . readSlice ( readableBytes ) . retain ( ) ) ; } break ; } case FAILURE : { in . skipBytes ( actualReadableBytes ( ) ) ; break ; } } } catch ( Exception e ) { fail ( out , e ) ; } } private void fail ( List < Object > out , Throwable cause ) { if ( ! ( cause instanceof DecoderException ) ) { cause = new DecoderException ( cause ) ; } Socks4CommandRequest m = new DefaultSocks4CommandRequest ( type ! = null ? type : Socks4CommandType . CONNECT , dstAddr ! = null ? dstAddr : <str> , dstPort ! = <int> ? dstPort : <int> , userId ! = null ? userId : <str> ) ; m . setDecoderResult ( DecoderResult . failure ( cause ) ) ; out . add ( m ) ; checkpoint ( State . FAILURE ) ; } private static String readString ( String fieldName , ByteBuf in ) { int length = in . bytesBefore ( MAX_FIELD_LENGTH + <int> , ( byte ) <int> ) ; if ( length < <int> ) { throw new DecoderException ( <str> + fieldName + <str> + MAX_FIELD_LENGTH + <str> ) ; } String value = in . readSlice ( length ) . toString ( CharsetUtil . US_ASCII ) ; in . skipBytes ( <int> ) ; return value ; } } 
