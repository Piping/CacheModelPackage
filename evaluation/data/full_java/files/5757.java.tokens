package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . FailableCache ; import org . elasticsearch . common . inject . spi . InjectionPoint ; class ConstructorInjectorStore { private final InjectorImpl injector ; private final FailableCache < TypeLiteral < ? > , ConstructorInjector < ? > > cache = new FailableCache < TypeLiteral < ? > , ConstructorInjector < ? > > ( ) { @Override @SuppressWarnings ( <str> ) protected ConstructorInjector < ? > create ( TypeLiteral < ? > type , Errors errors ) throws ErrorsException { return createConstructor ( type , errors ) ; } } ; ConstructorInjectorStore ( InjectorImpl injector ) { this . injector = injector ; } @SuppressWarnings ( <str> ) public < T > ConstructorInjector < T > get ( TypeLiteral < T > key , Errors errors ) throws ErrorsException { return ( ConstructorInjector < T > ) cache . get ( key , errors ) ; } private < T > ConstructorInjector < T > createConstructor ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; InjectionPoint injectionPoint ; try { injectionPoint = InjectionPoint . forConstructorOf ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; throw errors . toException ( ) ; } SingleParameterInjector < ? > [ ] constructorParameterInjectors = injector . getParametersInjectors ( injectionPoint . getDependencies ( ) , errors ) ; MembersInjectorImpl < T > membersInjector = injector . membersInjectorStore . get ( type , errors ) ; ConstructionProxyFactory < T > factory = new DefaultConstructionProxyFactory < > ( injectionPoint ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new ConstructorInjector < > ( membersInjector . getInjectionPoints ( ) , factory . create ( ) , constructorParameterInjectors , membersInjector ) ; } } 
