package org . apache . cassandra . stress . operations . userdefined ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; import com . datastax . driver . core . * ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . stress . Operation ; import org . apache . cassandra . stress . generate . * ; import org . apache . cassandra . stress . generate . Row ; import org . apache . cassandra . stress . settings . StressSettings ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . stress . util . ThriftClient ; import org . apache . cassandra . stress . util . Timer ; import org . apache . cassandra . thrift . Compression ; import org . apache . cassandra . thrift . CqlResult ; import org . apache . cassandra . thrift . CqlRow ; import org . apache . cassandra . thrift . ThriftConversion ; import org . apache . cassandra . transport . SimpleClient ; import org . apache . cassandra . utils . Pair ; import org . apache . thrift . TException ; public class ValidatingSchemaQuery extends Operation { final Random random = new Random ( ) ; private Pair < Row , Row > bounds ; final int clusteringComponents ; final ValidatingStatement [ ] statements ; final ConsistencyLevel cl ; final int [ ] argumentIndex ; final Object [ ] bindBuffer ; @Override public void run ( SimpleClient client ) throws IOException { throw new UnsupportedOperationException ( ) ; } private ValidatingSchemaQuery ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , ValidatingStatement [ ] statements , ConsistencyLevel cl , int clusteringComponents ) { super ( timer , settings , new DataSpec ( generator , seedManager , new DistributionFixed ( <int> ) , settings . insert . rowPopulationRatio . get ( ) , <int> ) ) ; this . statements = statements ; this . cl = cl ; argumentIndex = new int [ statements [ <int> ] . statement . getVariables ( ) . size ( ) ] ; bindBuffer = new Object [ argumentIndex . length ] ; int i = <int> ; for ( ColumnDefinitions . Definition definition : statements [ <int> ] . statement . getVariables ( ) ) argumentIndex [ i + + ] = spec . partitionGenerator . indexOf ( definition . getName ( ) ) ; for ( ValidatingStatement statement : statements ) statement . statement . setConsistencyLevel ( JavaDriverClient . from ( cl ) ) ; this . clusteringComponents = clusteringComponents ; } protected boolean reset ( Seed seed , PartitionIterator iterator ) { bounds = iterator . resetToBounds ( seed , clusteringComponents ) ; return true ; } abstract class Runner implements RunOp { int partitionCount ; int rowCount ; final PartitionIterator iter ; final int statementIndex ; protected Runner ( PartitionIterator iter ) { this . iter = iter ; statementIndex = ThreadLocalRandom . current ( ) . nextInt ( statements . length ) ; } @Override public int partitionCount ( ) { return partitionCount ; } @Override public int rowCount ( ) { return rowCount ; } } private class JavaDriverRun extends Runner { final JavaDriverClient client ; private JavaDriverRun ( JavaDriverClient client , PartitionIterator iter ) { super ( iter ) ; this . client = client ; } public boolean run ( ) throws Exception { ResultSet rs = client . getSession ( ) . execute ( bind ( statementIndex ) ) ; int [ ] valueIndex = new int [ rs . getColumnDefinitions ( ) . size ( ) ] ; { int i = <int> ; for ( ColumnDefinitions . Definition definition : rs . getColumnDefinitions ( ) ) valueIndex [ i + + ] = spec . partitionGenerator . indexOf ( definition . getName ( ) ) ; } rowCount = <int> ; Iterator < com . datastax . driver . core . Row > results = rs . iterator ( ) ; if ( ! statements [ statementIndex ] . inclusiveStart & & iter . hasNext ( ) ) iter . next ( ) ; while ( iter . hasNext ( ) ) { Row expectedRow = iter . next ( ) ; if ( ! statements [ statementIndex ] . inclusiveEnd & & ! iter . hasNext ( ) ) break ; if ( ! results . hasNext ( ) ) return false ; rowCount + + ; com . datastax . driver . core . Row actualRow = results . next ( ) ; for ( int i = <int> ; i < actualRow . getColumnDefinitions ( ) . size ( ) ; i + + ) { Object expectedValue = expectedRow . get ( valueIndex [ i ] ) ; Object actualValue = spec . partitionGenerator . convert ( valueIndex [ i ] , actualRow . getBytesUnsafe ( i ) ) ; if ( ! expectedValue . equals ( actualValue ) ) return false ; } } partitionCount = Math . min ( <int> , rowCount ) ; return rs . isExhausted ( ) ; } } private class ThriftRun extends Runner { final ThriftClient client ; private ThriftRun ( ThriftClient client , PartitionIterator iter ) { super ( iter ) ; this . client = client ; } public boolean run ( ) throws Exception { CqlResult rs = client . execute_prepared_cql3_query ( statements [ statementIndex ] . thriftId , partitions . get ( <int> ) . getToken ( ) , thriftArgs ( ) , ThriftConversion . toThrift ( cl ) ) ; int [ ] valueIndex = new int [ rs . getSchema ( ) . name_types . size ( ) ] ; for ( int i = <int> ; i < valueIndex . length ; i + + ) valueIndex [ i ] = spec . partitionGenerator . indexOf ( rs . fieldForId ( i ) . getFieldName ( ) ) ; int r = <int> ; if ( ! statements [ statementIndex ] . inclusiveStart & & iter . hasNext ( ) ) iter . next ( ) ; while ( iter . hasNext ( ) ) { Row expectedRow = iter . next ( ) ; if ( ! statements [ statementIndex ] . inclusiveEnd & & ! iter . hasNext ( ) ) break ; if ( r = = rs . num ) return false ; rowCount + + ; CqlRow actualRow = rs . getRows ( ) . get ( r + + ) ; for ( int i = <int> ; i < actualRow . getColumnsSize ( ) ; i + + ) { ByteBuffer expectedValue = spec . partitionGenerator . convert ( valueIndex [ i ] , expectedRow . get ( valueIndex [ i ] ) ) ; ByteBuffer actualValue = actualRow . getColumns ( ) . get ( i ) . value ; if ( ! expectedValue . equals ( actualValue ) ) return false ; } } assert r = = rs . num ; partitionCount = Math . min ( <int> , rowCount ) ; return true ; } } BoundStatement bind ( int statementIndex ) { int pkc = bounds . left . partitionKey . length ; System . arraycopy ( bounds . left . partitionKey , <int> , bindBuffer , <int> , pkc ) ; int ccc = bounds . left . row . length ; System . arraycopy ( bounds . left . row , <int> , bindBuffer , pkc , ccc ) ; System . arraycopy ( bounds . right . row , <int> , bindBuffer , pkc + ccc , ccc ) ; return statements [ statementIndex ] . statement . bind ( bindBuffer ) ; } List < ByteBuffer > thriftArgs ( ) { List < ByteBuffer > args = new ArrayList < > ( ) ; int pkc = bounds . left . partitionKey . length ; for ( int i = <int> ; i < pkc ; i + + ) args . add ( spec . partitionGenerator . convert ( - i , bounds . left . partitionKey [ i ] ) ) ; int ccc = bounds . left . row . length ; for ( int i = <int> ; i < ccc ; i + + ) args . add ( spec . partitionGenerator . convert ( i , bounds . left . get ( i ) ) ) ; for ( int i = <int> ; i < ccc ; i + + ) args . add ( spec . partitionGenerator . convert ( i , bounds . right . get ( i ) ) ) ; return args ; } @Override public void run ( JavaDriverClient client ) throws IOException { timeWithRetry ( new JavaDriverRun ( client , partitions . get ( <int> ) ) ) ; } @Override public void run ( ThriftClient client ) throws IOException { timeWithRetry ( new ThriftRun ( client , partitions . get ( <int> ) ) ) ; } public static class Factory { final ValidatingStatement [ ] statements ; final int clusteringComponents ; public Factory ( ValidatingStatement [ ] statements , int clusteringComponents ) { this . statements = statements ; this . clusteringComponents = clusteringComponents ; } public ValidatingSchemaQuery create ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , ConsistencyLevel cl ) { return new ValidatingSchemaQuery ( timer , settings , generator , seedManager , statements , cl , clusteringComponents ) ; } } public static List < Factory > create ( TableMetadata metadata , StressSettings settings ) { List < Factory > factories = new ArrayList < > ( ) ; StringBuilder sb = new StringBuilder ( ) ; boolean first = true ; sb . append ( <str> ) ; sb . append ( metadata . getName ( ) ) ; sb . append ( <str> ) ; for ( ColumnMetadata pk : metadata . getPartitionKey ( ) ) { sb . append ( first ? <str> : <str> ) ; sb . append ( pk . getName ( ) ) ; sb . append ( <str> ) ; first = false ; } String base = sb . toString ( ) ; factories . add ( new Factory ( new ValidatingStatement [ ] { prepare ( settings , base , true , true ) } , <int> ) ) ; int maxDepth = metadata . getClusteringColumns ( ) . size ( ) - <int> ; for ( int depth = <int> ; depth < = maxDepth ; depth + + ) { StringBuilder cc = new StringBuilder ( ) ; StringBuilder arg = new StringBuilder ( ) ; cc . append ( <str> ) ; arg . append ( <str> ) ; for ( int d = <int> ; d < = depth ; d + + ) { if ( d > <int> ) { cc . append ( <str> ) ; arg . append ( <str> ) ; } cc . append ( metadata . getClusteringColumns ( ) . get ( d ) . getName ( ) ) ; arg . append ( <str> ) ; } cc . append ( <str> ) ; arg . append ( <str> ) ; ValidatingStatement [ ] statements = new ValidatingStatement [ depth < maxDepth ? <int> : <int> ] ; int i = <int> ; for ( boolean incLb : depth < maxDepth ? new boolean [ ] { true } : new boolean [ ] { true , false } ) { for ( boolean incUb : depth < maxDepth ? new boolean [ ] { false } : new boolean [ ] { true , false } ) { String lb = incLb ? <str> : <str> ; String ub = incUb ? <str> : <str> ; sb . setLength ( <int> ) ; sb . append ( base ) ; sb . append ( <str> ) ; sb . append ( cc ) ; sb . append ( lb ) ; sb . append ( arg ) ; sb . append ( <str> ) ; sb . append ( cc ) ; sb . append ( ub ) ; sb . append ( arg ) ; statements [ i + + ] = prepare ( settings , sb . toString ( ) , incLb , incUb ) ; } } factories . add ( new Factory ( statements , depth + <int> ) ) ; } return factories ; } private static class ValidatingStatement { final PreparedStatement statement ; final Integer thriftId ; final boolean inclusiveStart ; final boolean inclusiveEnd ; private ValidatingStatement ( PreparedStatement statement , Integer thriftId , boolean inclusiveStart , boolean inclusiveEnd ) { this . statement = statement ; this . thriftId = thriftId ; this . inclusiveStart = inclusiveStart ; this . inclusiveEnd = inclusiveEnd ; } } private static ValidatingStatement prepare ( StressSettings settings , String cql , boolean incLb , boolean incUb ) { JavaDriverClient jclient = settings . getJavaDriverClient ( ) ; ThriftClient tclient = settings . getThriftClient ( ) ; PreparedStatement statement = jclient . prepare ( cql ) ; try { Integer thriftId = tclient . prepare_cql3_query ( cql , Compression . NONE ) ; return new ValidatingStatement ( statement , thriftId , incLb , incUb ) ; } catch ( TException e ) { throw new RuntimeException ( e ) ; } } } 
