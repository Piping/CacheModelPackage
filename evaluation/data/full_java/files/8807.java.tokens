package org . elasticsearch . plan . a ; import org . elasticsearch . common . settings . Settings ; public class FloatOverflowEnabledTests extends ScriptTestCase { @Override protected Settings getSettings ( ) { Settings . Builder builder = Settings . builder ( ) ; builder . put ( super . getSettings ( ) ) ; builder . put ( PlanAScriptEngineService . NUMERIC_OVERFLOW , true ) ; return builder . build ( ) ; } public void testAssignmentAdditionOverflow ( ) { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; } public void testAssignmentSubtractionOverflow ( ) { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; } public void testAssignmentMultiplicationOverflow ( ) { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; } public void testAssignmentDivisionOverflow ( ) { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testAddition ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testAdditionConst ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testSubtraction ( ) throws Exception { assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; } public void testSubtractionConst ( ) throws Exception { assertEquals ( Float . NEGATIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . NEGATIVE_INFINITY , exec ( <str> ) ) ; } public void testMultiplication ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testMultiplicationConst ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testDivision ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testDivisionConst ( ) throws Exception { assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Float . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; assertEquals ( Double . POSITIVE_INFINITY , exec ( <str> ) ) ; } public void testDivisionNaN ( ) throws Exception { assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; } public void testRemainderNaN ( ) throws Exception { assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Float . isNaN ( ( Float ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; assertTrue ( Double . isNaN ( ( Double ) exec ( <str> ) ) ) ; } } 
