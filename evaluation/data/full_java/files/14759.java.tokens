package org . gradle . platform . base . internal . registry ; import com . google . common . collect . ImmutableList ; import org . gradle . api . Action ; import org . gradle . api . Task ; import org . gradle . api . internal . project . taskfactory . ITaskFactory ; import org . gradle . internal . Cast ; import org . gradle . language . base . plugins . ComponentModelBasePlugin ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . inspect . MethodRuleDefinition ; import org . gradle . model . internal . inspect . ValidationProblemCollector ; import org . gradle . model . internal . type . ModelType ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . BinaryTasks ; import org . gradle . platform . base . InvalidModelException ; import java . util . ArrayList ; import java . util . List ; import static org . gradle . model . internal . core . NodePredicate . allLinks ; public class BinaryTasksModelRuleExtractor extends AbstractAnnotationDrivenComponentModelRuleExtractor < BinaryTasks > { @Override public < R , S > ExtractedModelRule registration ( MethodRuleDefinition < R , S > ruleDefinition , ValidationProblemCollector problems ) { return createRegistration ( ruleDefinition ) ; } private < R , S extends BinarySpec > ExtractedModelRule createRegistration ( MethodRuleDefinition < R , ? > ruleDefinition ) { try { RuleMethodDataCollector dataCollector = new RuleMethodDataCollector ( ) ; verifyMethodSignature ( dataCollector , ruleDefinition ) ; final Class < S > binaryType = dataCollector . getParameterType ( BinarySpec . class ) ; final BinaryTaskRule < R , S > binaryTaskRule = new BinaryTaskRule < R , S > ( binaryType , ruleDefinition ) ; return new ExtractedModelAction ( ModelActionRole . Defaults , ImmutableList . of ( ComponentModelBasePlugin . class ) , DirectNodeNoInputsModelAction . of ( ModelReference . of ( <str> ) , new SimpleModelRuleDescriptor ( <str> ) , new Action < MutableModelNode > ( ) { @Override public void execute ( MutableModelNode modelNode ) { modelNode . applyTo ( allLinks ( ) , ModelActionRole . Finalize , binaryTaskRule ) ; } } ) ) ; } catch ( InvalidModelException e ) { throw invalidModelRule ( ruleDefinition , e ) ; } } private void verifyMethodSignature ( RuleMethodDataCollector taskDataCollector , MethodRuleDefinition < ? , ? > ruleDefinition ) { assertIsVoidMethod ( ruleDefinition ) ; visitSubject ( taskDataCollector , ruleDefinition , Task . class ) ; visitDependency ( taskDataCollector , ruleDefinition , ModelType . of ( BinarySpec . class ) ) ; } protected InvalidModelRuleDeclarationException invalidModelRule ( MethodRuleDefinition < ? , ? > ruleDefinition , InvalidModelException e ) { StringBuilder sb = new StringBuilder ( ) ; ruleDefinition . getDescriptor ( ) . describeTo ( sb ) ; sb . append ( <str> ) ; return new InvalidModelRuleDeclarationException ( sb . toString ( ) , e ) ; } private class BinaryTaskRule < R , T extends BinarySpec > extends ModelMapBasedRule < R , Task , T , T > { public BinaryTaskRule ( Class < T > binaryType , MethodRuleDefinition < R , ? > ruleDefinition ) { super ( ModelReference . of ( binaryType ) , binaryType , ruleDefinition , ModelReference . of ( ITaskFactory . class ) ) ; } protected void execute ( final MutableModelNode modelNode , final T binary , List < ModelView < ? > > inputs ) { NamedEntityInstantiator < Task > taskFactory = Cast . uncheckedCast ( ModelViews . getInstance ( inputs . get ( <int> ) , ITaskFactory . class ) ) ; ModelMap < Task > cast = DomainObjectCollectionBackedModelMap . wrap ( Task . class , binary . getTasks ( ) , taskFactory , new Task . Namer ( ) , new Action < Task > ( ) { @Override public void execute ( Task task ) { binary . getTasks ( ) . add ( task ) ; binary . builtBy ( task ) ; } } ) ; List < ModelView < ? > > inputsWithBinary = new ArrayList < ModelView < ? > > ( inputs . size ( ) ) ; inputsWithBinary . addAll ( inputs . subList ( <int> , inputs . size ( ) ) ) ; inputsWithBinary . add ( InstanceModelView . of ( getSubject ( ) . getPath ( ) , getSubject ( ) . getType ( ) , binary ) ) ; invoke ( inputsWithBinary , cast , binary , binary ) ; } } } 
