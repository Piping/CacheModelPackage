package org . elasticsearch . index . fielddata ; import com . carrotsearch . hppc . ObjectArrayList ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . ParsedDocument ; import static org . hamcrest . Matchers . equalTo ; public class BinaryDVFieldDataTests extends AbstractFieldDataTestCase { @Override protected boolean hasDocValues ( ) { return true ; } public void testDocValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; final DocumentMapper mapper = mapperService . documentMapperParser ( ) . parse ( mapping ) ; ObjectArrayList < byte [ ] > bytesList1 = new ObjectArrayList < > ( <int> ) ; bytesList1 . add ( randomBytes ( ) ) ; bytesList1 . add ( randomBytes ( ) ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( bytesList1 . get ( <int> ) ) . value ( bytesList1 . get ( <int> ) ) . endArray ( ) . endObject ( ) ; ParsedDocument d = mapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) ; writer . addDocument ( d . rootDoc ( ) ) ; byte [ ] bytes1 = randomBytes ( ) ; doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , bytes1 ) . endObject ( ) ; d = mapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) ; writer . addDocument ( d . rootDoc ( ) ) ; doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . endObject ( ) ; d = mapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) ; writer . addDocument ( d . rootDoc ( ) ) ; ObjectArrayList < byte [ ] > bytesList2 = new ObjectArrayList < > ( <int> ) ; bytesList2 . add ( randomBytes ( ) ) ; bytesList2 . add ( randomBytes ( ) ) ; doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( bytesList2 . get ( <int> ) ) . value ( bytesList2 . get ( <int> ) ) . value ( bytesList2 . get ( <int> ) ) . endArray ( ) . endObject ( ) ; d = mapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) ; writer . addDocument ( d . rootDoc ( ) ) ; LeafReaderContext reader = refreshReader ( ) ; IndexFieldData < ? > indexFieldData = getForField ( <str> ) ; AtomicFieldData fieldData = indexFieldData . load ( reader ) ; SortedBinaryDocValues bytesValues = fieldData . getBytesValues ( ) ; CollectionUtils . sortAndDedup ( bytesList1 ) ; bytesValues . setDocument ( <int> ) ; assertThat ( bytesValues . count ( ) , equalTo ( <int> ) ) ; assertThat ( bytesValues . valueAt ( <int> ) , equalTo ( new BytesRef ( bytesList1 . get ( <int> ) ) ) ) ; assertThat ( bytesValues . valueAt ( <int> ) , equalTo ( new BytesRef ( bytesList1 . get ( <int> ) ) ) ) ; bytesValues . setDocument ( <int> ) ; assertThat ( bytesValues . count ( ) , equalTo ( <int> ) ) ; assertThat ( bytesValues . valueAt ( <int> ) , equalTo ( new BytesRef ( bytes1 ) ) ) ; bytesValues . setDocument ( <int> ) ; assertThat ( bytesValues . count ( ) , equalTo ( <int> ) ) ; CollectionUtils . sortAndDedup ( bytesList2 ) ; bytesValues . setDocument ( <int> ) ; assertThat ( bytesValues . count ( ) , equalTo ( <int> ) ) ; assertThat ( bytesValues . valueAt ( <int> ) , equalTo ( new BytesRef ( bytesList2 . get ( <int> ) ) ) ) ; assertThat ( bytesValues . valueAt ( <int> ) , equalTo ( new BytesRef ( bytesList2 . get ( <int> ) ) ) ) ; } private byte [ ] randomBytes ( ) { int size = randomIntBetween ( <int> , <int> ) ; byte [ ] bytes = new byte [ size ] ; getRandom ( ) . nextBytes ( bytes ) ; return bytes ; } @Override protected FieldDataType getFieldDataType ( ) { return new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , <str> ) ) ; } } 
