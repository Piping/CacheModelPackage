package org . gradle . messaging . remote . internal ; import org . gradle . messaging . dispatch . Dispatch ; import org . gradle . messaging . remote . internal . protocol . EndOfStreamEvent ; import org . gradle . messaging . remote . internal . protocol . MessageCredits ; import org . gradle . messaging . remote . internal . protocol . Request ; import org . gradle . messaging . remote . internal . protocol . WorkerStopping ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class WorkerProtocol implements Protocol < Message > { private static final Logger LOGGER = LoggerFactory . getLogger ( WorkerProtocol . class ) ; private final Dispatch < Object > worker ; private ProtocolContext < Message > context ; public WorkerProtocol ( Dispatch < Object > worker ) { this . worker = worker ; } public void start ( ProtocolContext < Message > context ) { this . context = context ; context . dispatchOutgoing ( new MessageCredits ( <int> ) ) ; } public void handleIncoming ( Message message ) { if ( message instanceof EndOfStreamEvent ) { LOGGER . debug ( <str> , message ) ; context . stopped ( ) ; } else if ( message instanceof Request ) { Request request = ( Request ) message ; LOGGER . debug ( <str> , message ) ; try { worker . dispatch ( request . getPayload ( ) ) ; } finally { context . dispatchOutgoing ( new MessageCredits ( <int> ) ) ; } } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } public void handleOutgoing ( Message message ) { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } public void stopRequested ( ) { context . dispatchOutgoing ( new WorkerStopping ( ) ) ; context . stopLater ( ) ; } } 
