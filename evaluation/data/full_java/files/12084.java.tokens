package org . gradle . internal . graph ; import org . gradle . api . Action ; import org . gradle . logging . StyledTextOutput ; import org . gradle . logging . internal . StreamingStyledTextOutput ; import java . util . * ; import static org . gradle . logging . StyledTextOutput . Style . Info ; public class DirectedGraphRenderer < N > { private final GraphNodeRenderer < N > nodeRenderer ; private final DirectedGraph < N , ? > graph ; private boolean omittedDetails ; public DirectedGraphRenderer ( GraphNodeRenderer < N > nodeRenderer , DirectedGraph < N , ? > graph ) { this . nodeRenderer = nodeRenderer ; this . graph = graph ; } public void renderTo ( N root , Appendable output ) { renderTo ( root , new StreamingStyledTextOutput ( output ) ) ; } public void renderTo ( N root , StyledTextOutput output ) { GraphRenderer renderer = new GraphRenderer ( output ) ; Set < N > rendered = new HashSet < N > ( ) ; omittedDetails = false ; renderTo ( root , renderer , rendered , false ) ; if ( omittedDetails ) { output . println ( ) ; output . withStyle ( Info ) . println ( <str> ) ; } } private void renderTo ( final N node , GraphRenderer graphRenderer , Collection < N > rendered , boolean lastChild ) { final boolean alreadySeen = ! rendered . add ( node ) ; graphRenderer . visit ( new Action < StyledTextOutput > ( ) { public void execute ( StyledTextOutput output ) { nodeRenderer . renderTo ( node , output ) ; if ( alreadySeen ) { output . text ( <str> ) ; } } } , lastChild ) ; if ( alreadySeen ) { omittedDetails = true ; return ; } List < N > children = new ArrayList < N > ( ) ; graph . getNodeValues ( node , new HashSet < Object > ( ) , children ) ; if ( children . isEmpty ( ) ) { return ; } graphRenderer . startChildren ( ) ; for ( int i = <int> ; i < children . size ( ) ; i + + ) { N child = children . get ( i ) ; renderTo ( child , graphRenderer , rendered , i = = children . size ( ) - <int> ) ; } graphRenderer . completeChildren ( ) ; } } 
