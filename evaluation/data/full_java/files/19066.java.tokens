package io . netty . handler . codec . http ; import static io . netty . handler . codec . http . CookieUtil . firstInvalidCookieNameOctet ; import static io . netty . handler . codec . http . CookieUtil . firstInvalidCookieValueOctet ; import static io . netty . handler . codec . http . CookieUtil . unwrapValue ; import io . netty . handler . codec . http . cookie . CookieHeaderNames ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . TreeSet ; @Deprecated public final class CookieDecoder { private final InternalLogger logger = InternalLoggerFactory . getInstance ( getClass ( ) ) ; private static final CookieDecoder STRICT = new CookieDecoder ( true ) ; private static final CookieDecoder LAX = new CookieDecoder ( false ) ; private static final String COMMENT = <str> ; private static final String COMMENTURL = <str> ; private static final String DISCARD = <str> ; private static final String PORT = <str> ; private static final String VERSION = <str> ; private static final char COMMA = <str> ; private final boolean strict ; public static Set < Cookie > decode ( String header ) { return decode ( header , true ) ; } public static Set < Cookie > decode ( String header , boolean strict ) { return ( strict ? STRICT : LAX ) . doDecode ( header ) ; } private Set < Cookie > doDecode ( String header ) { List < String > names = new ArrayList < String > ( <int> ) ; List < String > values = new ArrayList < String > ( <int> ) ; extractKeyValuePairs ( header , names , values ) ; if ( names . isEmpty ( ) ) { return Collections . emptySet ( ) ; } int i ; int version = <int> ; if ( names . get ( <int> ) . equalsIgnoreCase ( VERSION ) ) { try { version = Integer . parseInt ( values . get ( <int> ) ) ; } catch ( NumberFormatException e ) { } i = <int> ; } else { i = <int> ; } if ( names . size ( ) < = i ) { return Collections . emptySet ( ) ; } Set < Cookie > cookies = new TreeSet < Cookie > ( ) ; for ( ; i < names . size ( ) ; i + + ) { String name = names . get ( i ) ; String value = values . get ( i ) ; if ( value = = null ) { value = <str> ; } Cookie c = initCookie ( name , value ) ; if ( c = = null ) { break ; } boolean discard = false ; boolean secure = false ; boolean httpOnly = false ; String comment = null ; String commentURL = null ; String domain = null ; String path = null ; long maxAge = Long . MIN_VALUE ; List < Integer > ports = new ArrayList < Integer > ( <int> ) ; for ( int j = i + <int> ; j < names . size ( ) ; j + + , i + + ) { name = names . get ( j ) ; value = values . get ( j ) ; if ( DISCARD . equalsIgnoreCase ( name ) ) { discard = true ; } else if ( CookieHeaderNames . SECURE . equalsIgnoreCase ( name ) ) { secure = true ; } else if ( CookieHeaderNames . HTTPONLY . equalsIgnoreCase ( name ) ) { httpOnly = true ; } else if ( COMMENT . equalsIgnoreCase ( name ) ) { comment = value ; } else if ( COMMENTURL . equalsIgnoreCase ( name ) ) { commentURL = value ; } else if ( CookieHeaderNames . DOMAIN . equalsIgnoreCase ( name ) ) { domain = value ; } else if ( CookieHeaderNames . PATH . equalsIgnoreCase ( name ) ) { path = value ; } else if ( CookieHeaderNames . EXPIRES . equalsIgnoreCase ( name ) ) { try { long maxAgeMillis = HttpHeaderDateFormat . get ( ) . parse ( value ) . getTime ( ) - System . currentTimeMillis ( ) ; maxAge = maxAgeMillis / <int> + ( maxAgeMillis % <int> ! = <int> ? <int> : <int> ) ; } catch ( ParseException e ) { } } else if ( CookieHeaderNames . MAX_AGE . equalsIgnoreCase ( name ) ) { maxAge = Integer . parseInt ( value ) ; } else if ( VERSION . equalsIgnoreCase ( name ) ) { version = Integer . parseInt ( value ) ; } else if ( PORT . equalsIgnoreCase ( name ) ) { String [ ] portList = StringUtil . split ( value , COMMA ) ; for ( String s1 : portList ) { try { ports . add ( Integer . valueOf ( s1 ) ) ; } catch ( NumberFormatException e ) { } } } else { break ; } } c . setVersion ( version ) ; c . setMaxAge ( maxAge ) ; c . setPath ( path ) ; c . setDomain ( domain ) ; c . setSecure ( secure ) ; c . setHttpOnly ( httpOnly ) ; if ( version > <int> ) { c . setComment ( comment ) ; } if ( version > <int> ) { c . setCommentUrl ( commentURL ) ; c . setPorts ( ports ) ; c . setDiscard ( discard ) ; } cookies . add ( c ) ; } return cookies ; } private static void extractKeyValuePairs ( final String header , final List < String > names , final List < String > values ) { final int headerLen = header . length ( ) ; loop : for ( int i = <int> ; ; ) { for ( ; ; ) { if ( i = = headerLen ) { break loop ; } switch ( header . charAt ( i ) ) { case <str> : case <str> : case <hex> : case <str> : case <str> : case <str> : case <str> : case <str> : i + + ; continue ; } break ; } for ( ; ; ) { if ( i = = headerLen ) { break loop ; } if ( header . charAt ( i ) = = <str> ) { i + + ; continue ; } break ; } String name ; String value ; if ( i = = headerLen ) { name = null ; value = null ; } else { int newNameStart = i ; keyValLoop : for ( ; ; ) { switch ( header . charAt ( i ) ) { case <str> : name = header . substring ( newNameStart , i ) ; value = null ; break keyValLoop ; case <str> : name = header . substring ( newNameStart , i ) ; i + + ; if ( i = = headerLen ) { value = <str> ; break keyValLoop ; } int newValueStart = i ; char c = header . charAt ( i ) ; if ( c = = <str> | | c = = <str> ) { StringBuilder newValueBuf = new StringBuilder ( header . length ( ) - i ) ; final char q = c ; boolean hadBackslash = false ; i + + ; for ( ; ; ) { if ( i = = headerLen ) { value = newValueBuf . toString ( ) ; break keyValLoop ; } if ( hadBackslash ) { hadBackslash = false ; c = header . charAt ( i + + ) ; switch ( c ) { case <str> : case <str> : case <str> : newValueBuf . setCharAt ( newValueBuf . length ( ) - <int> , c ) ; break ; default : newValueBuf . append ( c ) ; } } else { c = header . charAt ( i + + ) ; if ( c = = q ) { value = newValueBuf . toString ( ) ; break keyValLoop ; } newValueBuf . append ( c ) ; if ( c = = <str> ) { hadBackslash = true ; } } } } else { int semiPos = header . indexOf ( <str> , i ) ; if ( semiPos > <int> ) { value = header . substring ( newValueStart , semiPos ) ; i = semiPos ; } else { value = header . substring ( newValueStart ) ; i = headerLen ; } } break keyValLoop ; default : i + + ; } if ( i = = headerLen ) { name = header . substring ( newNameStart ) ; value = null ; break ; } } } names . add ( name ) ; values . add ( value ) ; } } private CookieDecoder ( boolean strict ) { this . strict = strict ; } private DefaultCookie initCookie ( String name , String value ) { if ( name = = null | | name . length ( ) = = <int> ) { logger . debug ( <str> ) ; return null ; } if ( value = = null ) { logger . debug ( <str> ) ; return null ; } CharSequence unwrappedValue = unwrapValue ( value ) ; if ( unwrappedValue = = null ) { logger . debug ( <str> , unwrappedValue ) ; return null ; } int invalidOctetPos ; if ( strict & & ( invalidOctetPos = firstInvalidCookieNameOctet ( name ) ) > = <int> ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , name , name . charAt ( invalidOctetPos ) ) ; } return null ; } final boolean wrap = unwrappedValue . length ( ) ! = value . length ( ) ; if ( strict & & ( invalidOctetPos = firstInvalidCookieValueOctet ( unwrappedValue ) ) > = <int> ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , unwrappedValue , unwrappedValue . charAt ( invalidOctetPos ) ) ; } return null ; } DefaultCookie cookie = new DefaultCookie ( name , unwrappedValue . toString ( ) ) ; cookie . setWrap ( wrap ) ; return cookie ; } } 
