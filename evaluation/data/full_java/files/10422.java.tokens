package com . google . common . collect ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . Deque ; import java . util . Iterator ; public class SynchronizedDequeTest extends TestCase { protected Deque < String > create ( ) { TestDeque < String > inner = new TestDeque < String > ( ) ; Deque < String > outer = Synchronized . deque ( inner , inner . mutex ) ; outer . add ( <str> ) ; return outer ; } private static final class TestDeque < E > implements Deque < E > { private final Deque < E > delegate = Lists . newLinkedList ( ) ; public final Object mutex = new Integer ( <int> ) ; @Override public boolean offer ( E o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . offer ( o ) ; } @Override public E poll ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . poll ( ) ; } @Override public E remove ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . remove ( ) ; } @Override public E peek ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . peek ( ) ; } @Override public E element ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . element ( ) ; } @Override public Iterator < E > iterator ( ) { assertFalse ( Thread . holdsLock ( mutex ) ) ; return delegate . iterator ( ) ; } @Override public int size ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . size ( ) ; } @Override public boolean removeAll ( Collection < ? > collection ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . removeAll ( collection ) ; } @Override public boolean isEmpty ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . isEmpty ( ) ; } @Override public boolean contains ( Object object ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . contains ( object ) ; } @Override public boolean add ( E element ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . add ( element ) ; } @Override public boolean remove ( Object object ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . remove ( object ) ; } @Override public boolean containsAll ( Collection < ? > collection ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . containsAll ( collection ) ; } @Override public boolean addAll ( Collection < ? extends E > collection ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . addAll ( collection ) ; } @Override public boolean retainAll ( Collection < ? > collection ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . retainAll ( collection ) ; } @Override public void clear ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; delegate . clear ( ) ; } @Override public Object [ ] toArray ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . toArray ( array ) ; } @Override public void addFirst ( E e ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; delegate . addFirst ( e ) ; } @Override public void addLast ( E e ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; delegate . addLast ( e ) ; } @Override public boolean offerFirst ( E e ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . offerFirst ( e ) ; } @Override public boolean offerLast ( E e ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . offerLast ( e ) ; } @Override public E removeFirst ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . removeFirst ( ) ; } @Override public E removeLast ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . removeLast ( ) ; } @Override public E pollFirst ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . pollFirst ( ) ; } @Override public E pollLast ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . pollLast ( ) ; } @Override public E getFirst ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . getFirst ( ) ; } @Override public E getLast ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . getLast ( ) ; } @Override public E peekFirst ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . peekFirst ( ) ; } @Override public E peekLast ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . peekLast ( ) ; } @Override public boolean removeFirstOccurrence ( Object o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . removeFirstOccurrence ( o ) ; } @Override public boolean removeLastOccurrence ( Object o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . removeLastOccurrence ( o ) ; } @Override public void push ( E e ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; delegate . push ( e ) ; } @Override public E pop ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . pop ( ) ; } @Override public Iterator < E > descendingIterator ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return delegate . descendingIterator ( ) ; } private static final long serialVersionUID = <int> ; } public void testHoldsLockOnAllOperations ( ) { create ( ) . element ( ) ; create ( ) . offer ( <str> ) ; create ( ) . peek ( ) ; create ( ) . poll ( ) ; create ( ) . remove ( ) ; create ( ) . add ( <str> ) ; create ( ) . addAll ( ImmutableList . of ( <str> ) ) ; create ( ) . clear ( ) ; create ( ) . contains ( <str> ) ; create ( ) . containsAll ( ImmutableList . of ( <str> ) ) ; create ( ) . equals ( ImmutableList . of ( <str> ) ) ; create ( ) . hashCode ( ) ; create ( ) . isEmpty ( ) ; create ( ) . iterator ( ) ; create ( ) . remove ( <str> ) ; create ( ) . removeAll ( ImmutableList . of ( <str> ) ) ; create ( ) . retainAll ( ImmutableList . of ( <str> ) ) ; create ( ) . size ( ) ; create ( ) . toArray ( ) ; create ( ) . toArray ( new String [ ] { <str> } ) ; create ( ) . addFirst ( <str> ) ; create ( ) . addLast ( <str> ) ; create ( ) . offerFirst ( <str> ) ; create ( ) . offerLast ( <str> ) ; create ( ) . removeFirst ( ) ; create ( ) . removeLast ( ) ; create ( ) . pollFirst ( ) ; create ( ) . pollLast ( ) ; create ( ) . getFirst ( ) ; create ( ) . getLast ( ) ; create ( ) . peekFirst ( ) ; create ( ) . peekLast ( ) ; create ( ) . removeFirstOccurrence ( <str> ) ; create ( ) . removeLastOccurrence ( <str> ) ; create ( ) . push ( <str> ) ; create ( ) . pop ( ) ; create ( ) . descendingIterator ( ) ; } } 
