package com . badlogic . gdx . tests . extensions ; import java . io . IOException ; import java . io . InputStream ; import java . util . zip . GZIPInputStream ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandleStream ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . BitmapFont . Glyph ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g2d . freetype . FreeTypeFontGenerator ; import com . badlogic . gdx . graphics . g2d . freetype . FreeTypeFontGenerator . FreeTypeBitmapFontData ; import com . badlogic . gdx . graphics . g2d . freetype . FreeTypeFontGenerator . FreeTypeFontParameter ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; public class FreeTypeIncrementalTest extends GdxTest { SpriteBatch batch ; ShapeRenderer shapes ; BitmapFont font ; FreeTypeFontGenerator generator ; public void create ( ) { batch = new SpriteBatch ( ) ; shapes = new ShapeRenderer ( ) ; shapes . setColor ( Color . RED ) ; FreeTypeFontGenerator . setMaxTextureSize ( <int> ) ; FileHandleStream file = new FileHandleStream ( <str> ) { public InputStream read ( ) { try { return new GZIPInputStream ( Gdx . files . internal ( <str> ) . read ( ) , <int> ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } } public long length ( ) { return <int> ; } } ; generator = new FreeTypeFontGenerator ( file ) ; FreeTypeFontParameter param = new FreeTypeFontParameter ( ) ; param . incremental = true ; param . size = <int> ; param . characters = <str> ; FreeTypeBitmapFontData data = new FreeTypeBitmapFontData ( ) { public int getWrapIndex ( Array < Glyph > glyphs , int start ) { return SimplifiedChinese . getWrapIndex ( glyphs , start ) ; } } ; data . xChars = new char [ ] { <str> } ; data . capChars = new char [ ] { <str> } ; font = generator . generateFont ( param , data ) ; } public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; shapes . begin ( ShapeType . Line ) ; float x = <int> , y = Gdx . graphics . getHeight ( ) - font . getRegion ( ) . getRegionHeight ( ) - <int> ; for ( int i = <int> , n = font . getRegions ( ) . size ; i < n ; i + + ) { TextureRegion region = font . getRegions ( ) . get ( i ) ; shapes . rect ( x , y , region . getRegionWidth ( ) , region . getRegionHeight ( ) ) ; x + = region . getRegionWidth ( ) + <int> ; } shapes . rect ( <int> , <int> , Gdx . graphics . getWidth ( ) - <int> , - <int> ) ; shapes . end ( ) ; batch . begin ( ) ; x = <int> ; for ( int i = <int> , n = font . getRegions ( ) . size ; i < n ; i + + ) { TextureRegion region = font . getRegions ( ) . get ( i ) ; batch . draw ( region , x , y ) ; x + = region . getRegionWidth ( ) + <int> ; } font . draw ( batch , <str> , <int> , <int> ) ; font . draw ( batch , <str> , <int> , <int> ) ; font . draw ( batch , <str> + <str> , <int> , <int> , Gdx . graphics . getWidth ( ) - <int> , Align . left , true ) ; batch . end ( ) ; } public void resize ( int width , int height ) { batch . getProjectionMatrix ( ) . setToOrtho2D ( <int> , <int> , width , height ) ; shapes . setProjectionMatrix ( batch . getProjectionMatrix ( ) ) ; } static public class SimplifiedChinese { public static int getWrapIndex ( Array < Glyph > glyphs , int start ) { for ( int i = start ; i > <int> ; i - - ) { int startChar = glyphs . get ( i ) . id ; if ( ! SimplifiedChinese . legalAtStart ( startChar ) ) continue ; int endChar = glyphs . get ( i - <int> ) . id ; if ( ! SimplifiedChinese . legalAtEnd ( endChar ) ) continue ; if ( startChar < <int> & & endChar < <int> ) continue ; return i ; } return start ; } static private boolean legalAtStart ( int ch ) { switch ( ch ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return false ; } return true ; } static private boolean legalAtEnd ( int ch ) { switch ( ch ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return false ; } return true ; } } } 
