package org . elasticsearch . index . shard ; import org . apache . lucene . index . * ; import org . apache . lucene . search . QueryCachingPolicy ; import org . apache . lucene . search . UsageTrackingQueryCachingPolicy ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . util . CloseableThreadLocal ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . ThreadInterruptedException ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . indices . flush . FlushRequest ; import org . elasticsearch . action . admin . indices . forcemerge . ForceMergeRequest ; import org . elasticsearch . action . admin . indices . upgrade . post . UpgradeRequest ; import org . elasticsearch . action . termvectors . TermVectorsRequest ; import org . elasticsearch . action . termvectors . TermVectorsResponse ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . support . LoggerMessageFormat ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . metrics . MeanMetric ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . Callback ; import org . elasticsearch . common . util . concurrent . AbstractRefCounted ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . gateway . MetaDataStateFormat ; import org . elasticsearch . index . IndexModule ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . NodeServicesProvider ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . cache . IndexCache ; import org . elasticsearch . index . cache . bitset . ShardBitsetFilterCache ; import org . elasticsearch . index . cache . query . QueryCacheStats ; import org . elasticsearch . index . cache . request . ShardRequestCache ; import org . elasticsearch . index . codec . CodecService ; import org . elasticsearch . index . engine . * ; import org . elasticsearch . index . fielddata . FieldDataStats ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . fielddata . ShardFieldData ; import org . elasticsearch . index . flush . FlushStats ; import org . elasticsearch . index . get . GetStats ; import org . elasticsearch . index . get . ShardGetService ; import org . elasticsearch . index . indexing . IndexingStats ; import org . elasticsearch . index . indexing . ShardIndexingService ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . index . merge . MergeStats ; import org . elasticsearch . index . percolator . PercolateStats ; import org . elasticsearch . index . percolator . PercolatorQueriesRegistry ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . recovery . RecoveryStats ; import org . elasticsearch . index . refresh . RefreshStats ; import org . elasticsearch . index . search . stats . SearchStats ; import org . elasticsearch . index . search . stats . ShardSearchStats ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . index . store . Store . MetadataSnapshot ; import org . elasticsearch . index . store . StoreFileMetaData ; import org . elasticsearch . index . store . StoreStats ; import org . elasticsearch . index . suggest . stats . ShardSuggestMetric ; import org . elasticsearch . index . suggest . stats . SuggestStats ; import org . elasticsearch . index . termvectors . TermVectorsService ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . index . translog . TranslogConfig ; import org . elasticsearch . index . translog . TranslogStats ; import org . elasticsearch . index . translog . TranslogWriter ; import org . elasticsearch . index . warmer . ShardIndexWarmerService ; import org . elasticsearch . index . warmer . WarmerStats ; import org . elasticsearch . indices . IndicesWarmer ; import org . elasticsearch . indices . cache . query . IndicesQueryCache ; import org . elasticsearch . indices . memory . IndexingMemoryController ; import org . elasticsearch . indices . recovery . RecoveryFailedException ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . percolator . PercolatorService ; import org . elasticsearch . search . suggest . completion . CompletionFieldStats ; import org . elasticsearch . search . suggest . completion . CompletionStats ; import org . elasticsearch . threadpool . ThreadPool ; import java . io . IOException ; import java . io . PrintStream ; import java . nio . channels . ClosedByInterruptException ; import java . nio . charset . StandardCharsets ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; public class IndexShard extends AbstractIndexShardComponent { private final ThreadPool threadPool ; private final MapperService mapperService ; private final IndexCache indexCache ; private final Store store ; private final MergeSchedulerConfig mergeSchedulerConfig ; private final ShardIndexingService indexingService ; private final ShardSearchStats searchService ; private final ShardGetService getService ; private final ShardIndexWarmerService shardWarmerService ; private final ShardRequestCache shardQueryCache ; private final ShardFieldData shardFieldData ; private final PercolatorQueriesRegistry percolatorQueriesRegistry ; private final TermVectorsService termVectorsService ; private final IndexFieldDataService indexFieldDataService ; private final ShardSuggestMetric shardSuggestMetric = new ShardSuggestMetric ( ) ; private final ShardBitsetFilterCache shardBitsetFilterCache ; private final Object mutex = new Object ( ) ; private final String checkIndexOnStartup ; private final CodecService codecService ; private final IndicesWarmer warmer ; private final SnapshotDeletionPolicy deletionPolicy ; private final SimilarityService similarityService ; private final EngineConfig engineConfig ; private final TranslogConfig translogConfig ; private final MergePolicyConfig mergePolicyConfig ; private final IndicesQueryCache indicesQueryCache ; private final IndexEventListener indexEventListener ; private final IndexSettings idxSettings ; private final NodeServicesProvider provider ; private TimeValue refreshInterval ; private volatile ScheduledFuture < ? > refreshScheduledFuture ; private volatile ScheduledFuture < ? > mergeScheduleFuture ; protected volatile ShardRouting shardRouting ; protected volatile IndexShardState state ; protected final AtomicReference < Engine > currentEngineReference = new AtomicReference < > ( ) ; protected final EngineFactory engineFactory ; @Nullable private RecoveryState recoveryState ; private final RecoveryStats recoveryStats = new RecoveryStats ( ) ; private final MeanMetric refreshMetric = new MeanMetric ( ) ; private final MeanMetric flushMetric = new MeanMetric ( ) ; private final ShardEventListener shardEventListener = new ShardEventListener ( ) ; private volatile boolean flushOnClose = true ; private volatile int flushThresholdOperations ; private volatile ByteSizeValue flushThresholdSize ; private volatile boolean disableFlush ; public static final String INDEX_FLUSH_ON_CLOSE = <str> ; public static final String INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS = <str> ; public static final String INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE = <str> ; public static final String INDEX_TRANSLOG_DISABLE_FLUSH = <str> ; public static final String INDEX_SHARD_INACTIVE_TIME_SETTING = <str> ; private static final String INDICES_INACTIVE_TIME_SETTING = <str> ; private final ShardPath path ; private final IndexShardOperationCounter indexShardOperationCounter ; private final EnumSet < IndexShardState > readAllowedStates = EnumSet . of ( IndexShardState . STARTED , IndexShardState . RELOCATED , IndexShardState . POST_RECOVERY ) ; private final IndexSearcherWrapper searcherWrapper ; private final TimeValue inactiveTime ; private final AtomicBoolean active = new AtomicBoolean ( ) ; public IndexShard ( ShardId shardId , IndexSettings indexSettings , ShardPath path , Store store , IndexCache indexCache , MapperService mapperService , SimilarityService similarityService , IndexFieldDataService indexFieldDataService , @Nullable EngineFactory engineFactory , IndexEventListener indexEventListener , IndexSearcherWrapper indexSearcherWrapper , NodeServicesProvider provider ) { super ( shardId , indexSettings ) ; final Settings settings = indexSettings . getSettings ( ) ; this . inactiveTime = settings . getAsTime ( INDEX_SHARD_INACTIVE_TIME_SETTING , settings . getAsTime ( INDICES_INACTIVE_TIME_SETTING , TimeValue . timeValueMinutes ( <int> ) ) ) ; this . idxSettings = indexSettings ; this . codecService = new CodecService ( mapperService , logger ) ; this . warmer = provider . getWarmer ( ) ; this . deletionPolicy = new SnapshotDeletionPolicy ( new KeepOnlyLastCommitDeletionPolicy ( ) ) ; this . similarityService = similarityService ; Objects . requireNonNull ( store , <str> ) ; this . engineFactory = engineFactory = = null ? new InternalEngineFactory ( ) : engineFactory ; this . store = store ; this . indexEventListener = indexEventListener ; this . mergeSchedulerConfig = new MergeSchedulerConfig ( indexSettings ) ; this . threadPool = provider . getThreadPool ( ) ; this . mapperService = mapperService ; this . indexCache = indexCache ; this . indexingService = new ShardIndexingService ( shardId , indexSettings ) ; this . getService = new ShardGetService ( indexSettings , this , mapperService ) ; this . termVectorsService = provider . getTermVectorsService ( ) ; this . searchService = new ShardSearchStats ( settings ) ; this . shardWarmerService = new ShardIndexWarmerService ( shardId , indexSettings ) ; this . indicesQueryCache = provider . getIndicesQueryCache ( ) ; this . shardQueryCache = new ShardRequestCache ( shardId , indexSettings ) ; this . shardFieldData = new ShardFieldData ( ) ; this . indexFieldDataService = indexFieldDataService ; this . shardBitsetFilterCache = new ShardBitsetFilterCache ( shardId , indexSettings ) ; state = IndexShardState . CREATED ; this . refreshInterval = settings . getAsTime ( INDEX_REFRESH_INTERVAL , EngineConfig . DEFAULT_REFRESH_INTERVAL ) ; this . flushOnClose = settings . getAsBoolean ( INDEX_FLUSH_ON_CLOSE , true ) ; this . path = path ; this . mergePolicyConfig = new MergePolicyConfig ( logger , settings ) ; logger . debug ( <str> ) ; this . checkIndexOnStartup = settings . get ( <str> , <str> ) ; this . translogConfig = new TranslogConfig ( shardId , shardPath ( ) . resolveTranslog ( ) , indexSettings , getFromSettings ( logger , settings , Translog . Durabilty . REQUEST ) , provider . getBigArrays ( ) , threadPool ) ; final QueryCachingPolicy cachingPolicy ; if ( settings . getAsBoolean ( IndexModule . QUERY_CACHE_EVERYTHING , false ) ) { cachingPolicy = QueryCachingPolicy . ALWAYS_CACHE ; } else { cachingPolicy = new UsageTrackingQueryCachingPolicy ( ) ; } this . engineConfig = newEngineConfig ( translogConfig , cachingPolicy ) ; this . flushThresholdOperations = settings . getAsInt ( INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS , settings . getAsInt ( <str> , Integer . MAX_VALUE ) ) ; this . flushThresholdSize = settings . getAsBytesSize ( INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; this . disableFlush = settings . getAsBoolean ( INDEX_TRANSLOG_DISABLE_FLUSH , false ) ; this . indexShardOperationCounter = new IndexShardOperationCounter ( logger , shardId ) ; this . provider = provider ; this . searcherWrapper = indexSearcherWrapper ; this . percolatorQueriesRegistry = new PercolatorQueriesRegistry ( shardId , indexSettings , indexingService , mapperService , newQueryShardContext ( ) , indexFieldDataService ) ; if ( mapperService . hasMapping ( PercolatorService . TYPE_NAME ) ) { percolatorQueriesRegistry . enableRealTimePercolator ( ) ; } active . set ( false ) ; } public Store store ( ) { return this . store ; } public IndexSettings getIndexSettings ( ) { return idxSettings ; } public boolean canIndex ( ) { return true ; } public ShardIndexingService indexingService ( ) { return this . indexingService ; } public ShardGetService getService ( ) { return this . getService ; } public ShardSuggestMetric getSuggestMetric ( ) { return shardSuggestMetric ; } public ShardBitsetFilterCache shardBitsetFilterCache ( ) { return shardBitsetFilterCache ; } public IndexFieldDataService indexFieldDataService ( ) { return indexFieldDataService ; } public MapperService mapperService ( ) { return mapperService ; } public ShardSearchStats searchService ( ) { return this . searchService ; } public ShardIndexWarmerService warmerService ( ) { return this . shardWarmerService ; } public ShardRequestCache requestCache ( ) { return this . shardQueryCache ; } public ShardFieldData fieldData ( ) { return this . shardFieldData ; } public ShardRouting routingEntry ( ) { return this . shardRouting ; } public QueryCachingPolicy getQueryCachingPolicy ( ) { return this . engineConfig . getQueryCachingPolicy ( ) ; } public void updateRoutingEntry ( final ShardRouting newRouting , final boolean persistState ) { final ShardRouting currentRouting = this . shardRouting ; if ( ! newRouting . shardId ( ) . equals ( shardId ( ) ) ) { throw new IllegalArgumentException ( <str> + newRouting . shardId ( ) + <str> + shardId ( ) + <str> ) ; } if ( ( currentRouting = = null | | newRouting . isSameAllocation ( currentRouting ) ) = = false ) { throw new IllegalArgumentException ( <str> + currentRouting + <str> + newRouting ) ; } try { if ( currentRouting ! = null ) { if ( ! newRouting . primary ( ) & & currentRouting . primary ( ) ) { logger . warn ( <str> ) ; } if ( currentRouting . equalsIgnoringMetaData ( newRouting ) ) { this . shardRouting = newRouting ; return ; } } if ( state = = IndexShardState . POST_RECOVERY ) { if ( newRouting . state ( ) = = ShardRoutingState . STARTED | | newRouting . state ( ) = = ShardRoutingState . RELOCATING ) { try { getEngine ( ) . refresh ( <str> ) ; } catch ( Throwable t ) { logger . debug ( <str> , t ) ; } boolean movedToStarted = false ; synchronized ( mutex ) { if ( state = = IndexShardState . POST_RECOVERY ) { changeState ( IndexShardState . STARTED , <str> + newRouting . state ( ) + <str> ) ; movedToStarted = true ; } else { logger . debug ( <str> , state , newRouting . state ( ) ) ; } } if ( movedToStarted ) { indexEventListener . afterIndexShardStarted ( this ) ; } } } this . shardRouting = newRouting ; indexEventListener . shardRoutingChanged ( this , currentRouting , newRouting ) ; } finally { if ( persistState ) { persistMetadata ( newRouting , currentRouting ) ; } } } public IndexShardState markAsRecovering ( String reason , RecoveryState recoveryState ) throws IndexShardStartedException , IndexShardRelocatedException , IndexShardRecoveringException , IndexShardClosedException { synchronized ( mutex ) { if ( state = = IndexShardState . CLOSED ) { throw new IndexShardClosedException ( shardId ) ; } if ( state = = IndexShardState . STARTED ) { throw new IndexShardStartedException ( shardId ) ; } if ( state = = IndexShardState . RELOCATED ) { throw new IndexShardRelocatedException ( shardId ) ; } if ( state = = IndexShardState . RECOVERING ) { throw new IndexShardRecoveringException ( shardId ) ; } if ( state = = IndexShardState . POST_RECOVERY ) { throw new IndexShardRecoveringException ( shardId ) ; } this . recoveryState = recoveryState ; return changeState ( IndexShardState . RECOVERING , reason ) ; } } public IndexShard relocated ( String reason ) throws IndexShardNotStartedException { synchronized ( mutex ) { if ( state ! = IndexShardState . STARTED ) { throw new IndexShardNotStartedException ( shardId , state ) ; } changeState ( IndexShardState . RELOCATED , reason ) ; } return this ; } public IndexShardState state ( ) { return state ; } private IndexShardState changeState ( IndexShardState newState , String reason ) { logger . debug ( <str> , state , newState , reason ) ; IndexShardState previousState = state ; state = newState ; this . indexEventListener . indexShardStateChanged ( this , previousState , newState , reason ) ; return previousState ; } public Engine . Index prepareIndexOnPrimary ( SourceToParse source , long version , VersionType versionType ) { try { if ( shardRouting . primary ( ) = = false ) { throw new IllegalIndexShardStateException ( shardId , state , <str> ) ; } return prepareIndex ( docMapper ( source . type ( ) ) , source , version , versionType , Engine . Operation . Origin . PRIMARY ) ; } catch ( Throwable t ) { verifyNotClosed ( t ) ; throw t ; } } public Engine . Index prepareIndexOnReplica ( SourceToParse source , long version , VersionType versionType ) { try { return prepareIndex ( docMapper ( source . type ( ) ) , source , version , versionType , Engine . Operation . Origin . REPLICA ) ; } catch ( Throwable t ) { verifyNotClosed ( t ) ; throw t ; } } static Engine . Index prepareIndex ( DocumentMapperForType docMapper , SourceToParse source , long version , VersionType versionType , Engine . Operation . Origin origin ) { long startTime = System . nanoTime ( ) ; ParsedDocument doc = docMapper . getDocumentMapper ( ) . parse ( source ) ; if ( docMapper . getMapping ( ) ! = null ) { doc . addDynamicMappingsUpdate ( docMapper . getMapping ( ) ) ; } return new Engine . Index ( docMapper . getDocumentMapper ( ) . uidMapper ( ) . term ( doc . uid ( ) . stringValue ( ) ) , doc , version , versionType , origin , startTime ) ; } public boolean index ( Engine . Index index ) { ensureWriteAllowed ( index ) ; markLastWrite ( ) ; index = indexingService . preIndex ( index ) ; final boolean created ; try { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , index . type ( ) , index . id ( ) , index . docs ( ) ) ; } created = getEngine ( ) . index ( index ) ; index . endTime ( System . nanoTime ( ) ) ; } catch ( Throwable ex ) { indexingService . postIndex ( index , ex ) ; throw ex ; } indexingService . postIndex ( index ) ; return created ; } public Engine . Delete prepareDeleteOnPrimary ( String type , String id , long version , VersionType versionType ) { if ( shardRouting . primary ( ) = = false ) { throw new IllegalIndexShardStateException ( shardId , state , <str> ) ; } final DocumentMapper documentMapper = docMapper ( type ) . getDocumentMapper ( ) ; return prepareDelete ( type , id , documentMapper . uidMapper ( ) . term ( Uid . createUid ( type , id ) ) , version , versionType , Engine . Operation . Origin . PRIMARY ) ; } public Engine . Delete prepareDeleteOnReplica ( String type , String id , long version , VersionType versionType ) { final DocumentMapper documentMapper = docMapper ( type ) . getDocumentMapper ( ) ; return prepareDelete ( type , id , documentMapper . uidMapper ( ) . term ( Uid . createUid ( type , id ) ) , version , versionType , Engine . Operation . Origin . REPLICA ) ; } static Engine . Delete prepareDelete ( String type , String id , Term uid , long version , VersionType versionType , Engine . Operation . Origin origin ) { long startTime = System . nanoTime ( ) ; return new Engine . Delete ( type , id , uid , version , versionType , origin , startTime , false ) ; } public void delete ( Engine . Delete delete ) { ensureWriteAllowed ( delete ) ; markLastWrite ( ) ; delete = indexingService . preDelete ( delete ) ; try { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , delete . uid ( ) . text ( ) ) ; } getEngine ( ) . delete ( delete ) ; delete . endTime ( System . nanoTime ( ) ) ; } catch ( Throwable ex ) { indexingService . postDelete ( delete , ex ) ; throw ex ; } indexingService . postDelete ( delete ) ; } public Engine . GetResult get ( Engine . Get get ) { readAllowed ( ) ; return getEngine ( ) . get ( get , this : : acquireSearcher ) ; } public void refresh ( String source ) { verifyNotClosed ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , source ) ; } long time = System . nanoTime ( ) ; getEngine ( ) . refresh ( source ) ; refreshMetric . inc ( System . nanoTime ( ) - time ) ; } public RefreshStats refreshStats ( ) { return new RefreshStats ( refreshMetric . count ( ) , TimeUnit . NANOSECONDS . toMillis ( refreshMetric . sum ( ) ) ) ; } public FlushStats flushStats ( ) { return new FlushStats ( flushMetric . count ( ) , TimeUnit . NANOSECONDS . toMillis ( flushMetric . sum ( ) ) ) ; } public DocsStats docStats ( ) { try ( Engine . Searcher searcher = acquireSearcher ( <str> ) ) { return new DocsStats ( searcher . reader ( ) . numDocs ( ) , searcher . reader ( ) . numDeletedDocs ( ) ) ; } } @Nullable public CommitStats commitStats ( ) { Engine engine = getEngineOrNull ( ) ; return engine = = null ? null : engine . commitStats ( ) ; } public IndexingStats indexingStats ( String . . . types ) { return indexingService . stats ( types ) ; } public SearchStats searchStats ( String . . . groups ) { return searchService . stats ( groups ) ; } public GetStats getStats ( ) { return getService . stats ( ) ; } public StoreStats storeStats ( ) { try { return store . stats ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } catch ( AlreadyClosedException ex ) { return null ; } } public MergeStats mergeStats ( ) { final Engine engine = getEngineOrNull ( ) ; if ( engine = = null ) { return new MergeStats ( ) ; } return engine . getMergeStats ( ) ; } public SegmentsStats segmentStats ( ) { SegmentsStats segmentsStats = getEngine ( ) . segmentsStats ( ) ; segmentsStats . addBitsetMemoryInBytes ( shardBitsetFilterCache . getMemorySizeInBytes ( ) ) ; return segmentsStats ; } public TermVectorsResponse getTermVectors ( TermVectorsRequest request ) { return this . termVectorsService . getTermVectors ( this , request ) ; } public WarmerStats warmerStats ( ) { return shardWarmerService . stats ( ) ; } public QueryCacheStats queryCacheStats ( ) { return indicesQueryCache . getStats ( shardId ) ; } public FieldDataStats fieldDataStats ( String . . . fields ) { return shardFieldData . stats ( fields ) ; } public PercolatorQueriesRegistry percolateRegistry ( ) { return percolatorQueriesRegistry ; } public TranslogStats translogStats ( ) { return getEngine ( ) . getTranslog ( ) . stats ( ) ; } public SuggestStats suggestStats ( ) { return shardSuggestMetric . stats ( ) ; } public CompletionStats completionStats ( String . . . fields ) { CompletionStats completionStats = new CompletionStats ( ) ; try ( final Engine . Searcher currentSearcher = acquireSearcher ( <str> ) ) { completionStats . add ( CompletionFieldStats . completionStats ( currentSearcher . reader ( ) , fields ) ) ; } return completionStats ; } public Engine . SyncedFlushResult syncFlush ( String syncId , Engine . CommitId expectedCommitId ) { verifyStartedOrRecovering ( ) ; logger . trace ( <str> , syncId , expectedCommitId ) ; return getEngine ( ) . syncFlush ( syncId , expectedCommitId ) ; } public Engine . CommitId flush ( FlushRequest request ) throws ElasticsearchException { boolean waitIfOngoing = request . waitIfOngoing ( ) ; boolean force = request . force ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , request ) ; } verifyStartedOrRecovering ( ) ; long time = System . nanoTime ( ) ; Engine . CommitId commitId = getEngine ( ) . flush ( force , waitIfOngoing ) ; flushMetric . inc ( System . nanoTime ( ) - time ) ; return commitId ; } public void forceMerge ( ForceMergeRequest forceMerge ) throws IOException { verifyStarted ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , forceMerge ) ; } getEngine ( ) . forceMerge ( forceMerge . flush ( ) , forceMerge . maxNumSegments ( ) , forceMerge . onlyExpungeDeletes ( ) , false , false ) ; } public org . apache . lucene . util . Version upgrade ( UpgradeRequest upgrade ) throws IOException { verifyStarted ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , upgrade ) ; } org . apache . lucene . util . Version previousVersion = minimumCompatibleVersion ( ) ; getEngine ( ) . forceMerge ( true , Integer . MAX_VALUE , false , true , upgrade . upgradeOnlyAncientSegments ( ) ) ; org . apache . lucene . util . Version version = minimumCompatibleVersion ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , previousVersion , version ) ; } return version ; } public org . apache . lucene . util . Version minimumCompatibleVersion ( ) { org . apache . lucene . util . Version luceneVersion = null ; for ( Segment segment : getEngine ( ) . segments ( false ) ) { if ( luceneVersion = = null | | luceneVersion . onOrAfter ( segment . getVersion ( ) ) ) { luceneVersion = segment . getVersion ( ) ; } } return luceneVersion = = null ? idxSettings . getIndexVersionCreated ( ) . luceneVersion : luceneVersion ; } public IndexCommit snapshotIndex ( boolean flushFirst ) throws EngineException { IndexShardState state = this . state ; if ( state = = IndexShardState . STARTED | | state = = IndexShardState . RELOCATED | | state = = IndexShardState . CLOSED ) { return getEngine ( ) . snapshotIndex ( flushFirst ) ; } else { throw new IllegalIndexShardStateException ( shardId , state , <str> ) ; } } public void releaseSnapshot ( IndexCommit snapshot ) throws IOException { deletionPolicy . release ( snapshot ) ; } public void failShard ( String reason , @Nullable Throwable e ) { getEngine ( ) . failEngine ( reason , e ) ; } public Engine . Searcher acquireSearcher ( String source ) { readAllowed ( ) ; final Engine engine = getEngine ( ) ; final Engine . Searcher searcher = engine . acquireSearcher ( source ) ; boolean success = false ; try { final Engine . Searcher wrappedSearcher = searcherWrapper = = null ? searcher : searcherWrapper . wrap ( searcher ) ; assert wrappedSearcher ! = null ; success = true ; return wrappedSearcher ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } finally { if ( success = = false ) { Releasables . close ( success , searcher ) ; } } } public void close ( String reason , boolean flushEngine ) throws IOException { synchronized ( mutex ) { try { if ( state ! = IndexShardState . CLOSED ) { FutureUtils . cancel ( refreshScheduledFuture ) ; refreshScheduledFuture = null ; FutureUtils . cancel ( mergeScheduleFuture ) ; mergeScheduleFuture = null ; } changeState ( IndexShardState . CLOSED , reason ) ; indexShardOperationCounter . decRef ( ) ; } finally { final Engine engine = this . currentEngineReference . getAndSet ( null ) ; try { if ( engine ! = null & & flushEngine & & this . flushOnClose ) { engine . flushAndClose ( ) ; } } finally { IOUtils . close ( engine , percolatorQueriesRegistry , queryShardContextCache ) ; } } } } public IndexShard postRecovery ( String reason ) throws IndexShardStartedException , IndexShardRelocatedException , IndexShardClosedException { if ( mapperService . hasMapping ( PercolatorService . TYPE_NAME ) ) { refresh ( <str> ) ; try ( Engine . Searcher searcher = getEngine ( ) . acquireSearcher ( <str> ) ) { this . percolatorQueriesRegistry . loadQueries ( searcher . reader ( ) ) ; } } synchronized ( mutex ) { if ( state = = IndexShardState . CLOSED ) { throw new IndexShardClosedException ( shardId ) ; } if ( state = = IndexShardState . STARTED ) { throw new IndexShardStartedException ( shardId ) ; } if ( state = = IndexShardState . RELOCATED ) { throw new IndexShardRelocatedException ( shardId ) ; } recoveryState . setStage ( RecoveryState . Stage . DONE ) ; changeState ( IndexShardState . POST_RECOVERY , reason ) ; } return this ; } public void prepareForIndexRecovery ( ) { if ( state ! = IndexShardState . RECOVERING ) { throw new IndexShardNotRecoveringException ( shardId , state ) ; } recoveryState . setStage ( RecoveryState . Stage . INDEX ) ; assert currentEngineReference . get ( ) = = null ; } public int performBatchRecovery ( Iterable < Translog . Operation > operations ) { if ( state ! = IndexShardState . RECOVERING ) { throw new IndexShardNotRecoveringException ( shardId , state ) ; } return engineConfig . getTranslogRecoveryPerformer ( ) . performBatchRecovery ( getEngine ( ) , operations ) ; } public void performTranslogRecovery ( boolean indexExists ) { internalPerformTranslogRecovery ( false , indexExists ) ; assert recoveryState . getStage ( ) = = RecoveryState . Stage . TRANSLOG : <str> + recoveryState . getStage ( ) ; } private void internalPerformTranslogRecovery ( boolean skipTranslogRecovery , boolean indexExists ) { if ( state ! = IndexShardState . RECOVERING ) { throw new IndexShardNotRecoveringException ( shardId , state ) ; } recoveryState . setStage ( RecoveryState . Stage . VERIFY_INDEX ) ; if ( Booleans . parseBoolean ( checkIndexOnStartup , false ) ) { try { checkIndex ( ) ; } catch ( IOException ex ) { throw new RecoveryFailedException ( recoveryState , <str> , ex ) ; } } recoveryState . setStage ( RecoveryState . Stage . TRANSLOG ) ; engineConfig . setEnableGcDeletes ( false ) ; engineConfig . setCreate ( indexExists = = false ) ; createNewEngine ( skipTranslogRecovery , engineConfig ) ; } public void skipTranslogRecovery ( ) throws IOException { assert getEngineOrNull ( ) = = null : <str> ; internalPerformTranslogRecovery ( true , true ) ; assert recoveryState . getTranslog ( ) . recoveredOperations ( ) = = <int> ; } public void performRecoveryRestart ( ) throws IOException { synchronized ( mutex ) { if ( state ! = IndexShardState . RECOVERING ) { throw new IndexShardNotRecoveringException ( shardId , state ) ; } final Engine engine = this . currentEngineReference . getAndSet ( null ) ; IOUtils . close ( engine ) ; recoveryState ( ) . setStage ( RecoveryState . Stage . INIT ) ; } } public RecoveryStats recoveryStats ( ) { return recoveryStats ; } public RecoveryState recoveryState ( ) { return this . recoveryState ; } public void finalizeRecovery ( ) { recoveryState ( ) . setStage ( RecoveryState . Stage . FINALIZE ) ; getEngine ( ) . refresh ( <str> ) ; startScheduledTasksIfNeeded ( ) ; engineConfig . setEnableGcDeletes ( true ) ; } public boolean ignoreRecoveryAttempt ( ) { IndexShardState state = state ( ) ; return state = = IndexShardState . POST_RECOVERY | | state = = IndexShardState . RECOVERING | | state = = IndexShardState . STARTED | | state = = IndexShardState . RELOCATED | | state = = IndexShardState . CLOSED ; } public void readAllowed ( ) throws IllegalIndexShardStateException { IndexShardState state = this . state ; if ( readAllowedStates . contains ( state ) = = false ) { throw new IllegalIndexShardStateException ( shardId , state , <str> + readAllowedStates . toString ( ) ) ; } } private void markLastWrite ( ) { if ( active . getAndSet ( true ) = = false ) { indexEventListener . onShardActive ( this ) ; } } private void ensureWriteAllowed ( Engine . Operation op ) throws IllegalIndexShardStateException { Engine . Operation . Origin origin = op . origin ( ) ; IndexShardState state = this . state ; if ( origin = = Engine . Operation . Origin . PRIMARY ) { if ( state ! = IndexShardState . STARTED & & state ! = IndexShardState . RELOCATED ) { throw new IllegalIndexShardStateException ( shardId , state , <str> + origin + <str> ) ; } } else { if ( state ! = IndexShardState . STARTED & & state ! = IndexShardState . RELOCATED & & state ! = IndexShardState . RECOVERING & & state ! = IndexShardState . POST_RECOVERY ) { throw new IllegalIndexShardStateException ( shardId , state , <str> + origin + <str> ) ; } } } protected final void verifyStartedOrRecovering ( ) throws IllegalIndexShardStateException { IndexShardState state = this . state ; if ( state ! = IndexShardState . STARTED & & state ! = IndexShardState . RECOVERING & & state ! = IndexShardState . POST_RECOVERY ) { throw new IllegalIndexShardStateException ( shardId , state , <str> ) ; } } private void verifyNotClosed ( ) throws IllegalIndexShardStateException { verifyNotClosed ( null ) ; } private void verifyNotClosed ( Throwable suppressed ) throws IllegalIndexShardStateException { IndexShardState state = this . state ; if ( state = = IndexShardState . CLOSED ) { final IllegalIndexShardStateException exc = new IllegalIndexShardStateException ( shardId , state , <str> ) ; if ( suppressed ! = null ) { exc . addSuppressed ( suppressed ) ; } throw exc ; } } protected final void verifyStarted ( ) throws IllegalIndexShardStateException { IndexShardState state = this . state ; if ( state ! = IndexShardState . STARTED ) { throw new IndexShardNotStartedException ( shardId , state ) ; } } private void startScheduledTasksIfNeeded ( ) { if ( refreshInterval . millis ( ) > <int> ) { refreshScheduledFuture = threadPool . schedule ( refreshInterval , ThreadPool . Names . SAME , new EngineRefresher ( ) ) ; logger . debug ( <str> , refreshInterval ) ; } else { logger . debug ( <str> ) ; } } public static final String INDEX_REFRESH_INTERVAL = <str> ; public void addShardFailureCallback ( Callback < ShardFailure > onShardFailure ) { this . shardEventListener . delegates . add ( onShardFailure ) ; } public void updateBufferSize ( ByteSizeValue shardIndexingBufferSize , ByteSizeValue shardTranslogBufferSize ) { final EngineConfig config = engineConfig ; final ByteSizeValue preValue = config . getIndexingBufferSize ( ) ; config . setIndexingBufferSize ( shardIndexingBufferSize ) ; Engine engine = getEngineOrNull ( ) ; if ( engine = = null ) { logger . debug ( <str> ) ; return ; } if ( preValue . bytes ( ) ! = shardIndexingBufferSize . bytes ( ) ) { engine . onSettingsChanged ( ) ; long iwBytesUsed = engine . indexWriterRAMBytesUsed ( ) ; String message = LoggerMessageFormat . format ( <str> , preValue , shardIndexingBufferSize , iwBytesUsed ) ; if ( iwBytesUsed > shardIndexingBufferSize . bytes ( ) ) { logger . debug ( message + <str> ) ; try { refresh ( <str> ) ; } catch ( Throwable e ) { logger . warn ( <str> , e ) ; } } else { logger . debug ( message ) ; } } engine . getTranslog ( ) . updateBuffer ( shardTranslogBufferSize ) ; } public boolean checkIdle ( ) { return checkIdle ( inactiveTime . nanos ( ) ) ; } final boolean checkIdle ( long inactiveTimeNS ) { Engine engineOrNull = getEngineOrNull ( ) ; if ( engineOrNull ! = null & & System . nanoTime ( ) - engineOrNull . getLastWriteNanos ( ) > = inactiveTimeNS ) { boolean wasActive = active . getAndSet ( false ) ; if ( wasActive ) { updateBufferSize ( IndexingMemoryController . INACTIVE_SHARD_INDEXING_BUFFER , IndexingMemoryController . INACTIVE_SHARD_TRANSLOG_BUFFER ) ; logger . debug ( <str> , inactiveTime ) ; indexEventListener . onShardInactive ( this ) ; } } return active . get ( ) = = false ; } public boolean getActive ( ) { return active . get ( ) ; } public final boolean isFlushOnClose ( ) { return flushOnClose ; } public void deleteShardState ( ) throws IOException { if ( this . routingEntry ( ) ! = null & & this . routingEntry ( ) . active ( ) ) { throw new IllegalStateException ( <str> ) ; } MetaDataStateFormat . deleteMetaState ( shardPath ( ) . getDataPath ( ) ) ; } public ShardPath shardPath ( ) { return path ; } public boolean recoverFromStore ( DiscoveryNode localNode ) { assert shardRouting . primary ( ) : <str> ; final boolean shouldExist = shardRouting . allocatedPostIndexCreate ( ) ; StoreRecovery storeRecovery = new StoreRecovery ( shardId , logger ) ; return storeRecovery . recoverFromStore ( this , shouldExist , localNode ) ; } public boolean restoreFromRepository ( IndexShardRepository repository , DiscoveryNode localNode ) { assert shardRouting . primary ( ) : <str> ; StoreRecovery storeRecovery = new StoreRecovery ( shardId , logger ) ; return storeRecovery . recoverFromRepository ( this , repository , localNode ) ; } boolean shouldFlush ( ) { if ( disableFlush = = false ) { Engine engine = getEngineOrNull ( ) ; if ( engine ! = null ) { try { Translog translog = engine . getTranslog ( ) ; return translog . totalOperations ( ) > flushThresholdOperations | | translog . sizeInBytes ( ) > flushThresholdSize . bytes ( ) ; } catch ( AlreadyClosedException | EngineClosedException ex ) { } } } return false ; } public void onRefreshSettings ( Settings settings ) { boolean change = false ; synchronized ( mutex ) { if ( state ( ) = = IndexShardState . CLOSED ) { return ; } int flushThresholdOperations = settings . getAsInt ( INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS , this . flushThresholdOperations ) ; if ( flushThresholdOperations ! = this . flushThresholdOperations ) { logger . info ( <str> , this . flushThresholdOperations , flushThresholdOperations ) ; this . flushThresholdOperations = flushThresholdOperations ; } ByteSizeValue flushThresholdSize = settings . getAsBytesSize ( INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE , this . flushThresholdSize ) ; if ( ! flushThresholdSize . equals ( this . flushThresholdSize ) ) { logger . info ( <str> , this . flushThresholdSize , flushThresholdSize ) ; this . flushThresholdSize = flushThresholdSize ; } boolean disableFlush = settings . getAsBoolean ( INDEX_TRANSLOG_DISABLE_FLUSH , this . disableFlush ) ; if ( disableFlush ! = this . disableFlush ) { logger . info ( <str> , this . disableFlush , disableFlush ) ; this . disableFlush = disableFlush ; } final EngineConfig config = engineConfig ; final boolean flushOnClose = settings . getAsBoolean ( INDEX_FLUSH_ON_CLOSE , this . flushOnClose ) ; if ( flushOnClose ! = this . flushOnClose ) { logger . info ( <str> , INDEX_FLUSH_ON_CLOSE , this . flushOnClose , flushOnClose ) ; this . flushOnClose = flushOnClose ; } TranslogWriter . Type type = TranslogWriter . Type . fromString ( settings . get ( TranslogConfig . INDEX_TRANSLOG_FS_TYPE , translogConfig . getType ( ) . name ( ) ) ) ; if ( type ! = translogConfig . getType ( ) ) { logger . info ( <str> , translogConfig . getType ( ) , type ) ; translogConfig . setType ( type ) ; } final Translog . Durabilty durabilty = getFromSettings ( logger , settings , translogConfig . getDurabilty ( ) ) ; if ( durabilty ! = translogConfig . getDurabilty ( ) ) { logger . info ( <str> , translogConfig . getDurabilty ( ) , durabilty ) ; translogConfig . setDurabilty ( durabilty ) ; } TimeValue refreshInterval = settings . getAsTime ( INDEX_REFRESH_INTERVAL , this . refreshInterval ) ; if ( ! refreshInterval . equals ( this . refreshInterval ) ) { logger . info ( <str> , this . refreshInterval , refreshInterval ) ; if ( refreshScheduledFuture ! = null ) { FutureUtils . cancel ( refreshScheduledFuture ) ; refreshScheduledFuture = null ; } this . refreshInterval = refreshInterval ; if ( refreshInterval . millis ( ) > <int> ) { refreshScheduledFuture = threadPool . schedule ( refreshInterval , ThreadPool . Names . SAME , new EngineRefresher ( ) ) ; } } long gcDeletesInMillis = settings . getAsTime ( EngineConfig . INDEX_GC_DELETES_SETTING , TimeValue . timeValueMillis ( config . getGcDeletesInMillis ( ) ) ) . millis ( ) ; if ( gcDeletesInMillis ! = config . getGcDeletesInMillis ( ) ) { logger . info ( <str> , EngineConfig . INDEX_GC_DELETES_SETTING , TimeValue . timeValueMillis ( config . getGcDeletesInMillis ( ) ) , TimeValue . timeValueMillis ( gcDeletesInMillis ) ) ; config . setGcDeletesInMillis ( gcDeletesInMillis ) ; change = true ; } final boolean compoundOnFlush = settings . getAsBoolean ( EngineConfig . INDEX_COMPOUND_ON_FLUSH , config . isCompoundOnFlush ( ) ) ; if ( compoundOnFlush ! = config . isCompoundOnFlush ( ) ) { logger . info ( <str> , EngineConfig . INDEX_COMPOUND_ON_FLUSH , config . isCompoundOnFlush ( ) , compoundOnFlush ) ; config . setCompoundOnFlush ( compoundOnFlush ) ; change = true ; } final String versionMapSize = settings . get ( EngineConfig . INDEX_VERSION_MAP_SIZE , config . getVersionMapSizeSetting ( ) ) ; if ( config . getVersionMapSizeSetting ( ) . equals ( versionMapSize ) = = false ) { config . setVersionMapSizeSetting ( versionMapSize ) ; } final int maxThreadCount = settings . getAsInt ( MergeSchedulerConfig . MAX_THREAD_COUNT , mergeSchedulerConfig . getMaxThreadCount ( ) ) ; if ( maxThreadCount ! = mergeSchedulerConfig . getMaxThreadCount ( ) ) { logger . info ( <str> , MergeSchedulerConfig . MAX_THREAD_COUNT , mergeSchedulerConfig . getMaxMergeCount ( ) , maxThreadCount ) ; mergeSchedulerConfig . setMaxThreadCount ( maxThreadCount ) ; change = true ; } final int maxMergeCount = settings . getAsInt ( MergeSchedulerConfig . MAX_MERGE_COUNT , mergeSchedulerConfig . getMaxMergeCount ( ) ) ; if ( maxMergeCount ! = mergeSchedulerConfig . getMaxMergeCount ( ) ) { logger . info ( <str> , MergeSchedulerConfig . MAX_MERGE_COUNT , mergeSchedulerConfig . getMaxMergeCount ( ) , maxMergeCount ) ; mergeSchedulerConfig . setMaxMergeCount ( maxMergeCount ) ; change = true ; } final boolean autoThrottle = settings . getAsBoolean ( MergeSchedulerConfig . AUTO_THROTTLE , mergeSchedulerConfig . isAutoThrottle ( ) ) ; if ( autoThrottle ! = mergeSchedulerConfig . isAutoThrottle ( ) ) { logger . info ( <str> , MergeSchedulerConfig . AUTO_THROTTLE , mergeSchedulerConfig . isAutoThrottle ( ) , autoThrottle ) ; mergeSchedulerConfig . setAutoThrottle ( autoThrottle ) ; change = true ; } } mergePolicyConfig . onRefreshSettings ( settings ) ; searchService . onRefreshSettings ( settings ) ; indexingService . onRefreshSettings ( settings ) ; if ( change ) { getEngine ( ) . onSettingsChanged ( ) ; } } public Translog . View acquireTranslogView ( ) { Engine engine = getEngine ( ) ; assert engine . getTranslog ( ) ! = null : <str> ; return engine . getTranslog ( ) . newView ( ) ; } public List < Segment > segments ( boolean verbose ) { return getEngine ( ) . segments ( verbose ) ; } public void flushAndCloseEngine ( ) throws IOException { getEngine ( ) . flushAndClose ( ) ; } public Translog getTranslog ( ) { return getEngine ( ) . getTranslog ( ) ; } public PercolateStats percolateStats ( ) { return percolatorQueriesRegistry . stats ( ) ; } public IndexEventListener getIndexEventListener ( ) { return indexEventListener ; } public TimeValue getInactiveTime ( ) { return inactiveTime ; } class EngineRefresher implements Runnable { @Override public void run ( ) { if ( ! getEngine ( ) . refreshNeeded ( ) ) { reschedule ( ) ; return ; } threadPool . executor ( ThreadPool . Names . REFRESH ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { if ( getEngine ( ) . refreshNeeded ( ) ) { refresh ( <str> ) ; } } catch ( EngineClosedException e ) { } catch ( RefreshFailedEngineException e ) { if ( e . getCause ( ) instanceof InterruptedException ) { } else if ( e . getCause ( ) instanceof ClosedByInterruptException ) { } else if ( e . getCause ( ) instanceof ThreadInterruptedException ) { } else { if ( state ! = IndexShardState . CLOSED ) { logger . warn ( <str> , e ) ; } } } catch ( Exception e ) { if ( state ! = IndexShardState . CLOSED ) { logger . warn ( <str> , e ) ; } } reschedule ( ) ; } } ) ; } private void reschedule ( ) { synchronized ( mutex ) { if ( state ! = IndexShardState . CLOSED & & refreshInterval . millis ( ) > <int> ) { refreshScheduledFuture = threadPool . schedule ( refreshInterval , ThreadPool . Names . SAME , this ) ; } } } } private void checkIndex ( ) throws IOException { if ( store . tryIncRef ( ) ) { try { doCheckIndex ( ) ; } finally { store . decRef ( ) ; } } } private void doCheckIndex ( ) throws IOException { long timeNS = System . nanoTime ( ) ; if ( ! Lucene . indexExists ( store . directory ( ) ) ) { return ; } BytesStreamOutput os = new BytesStreamOutput ( ) ; PrintStream out = new PrintStream ( os , false , StandardCharsets . UTF_8 . name ( ) ) ; if ( <str> . equalsIgnoreCase ( checkIndexOnStartup ) ) { IOException corrupt = null ; MetadataSnapshot metadata = store . getMetadata ( ) ; for ( Map . Entry < String , StoreFileMetaData > entry : metadata . asMap ( ) . entrySet ( ) ) { try { Store . checkIntegrity ( entry . getValue ( ) , store . directory ( ) ) ; out . println ( <str> + entry . getKey ( ) ) ; } catch ( IOException exc ) { out . println ( <str> + entry . getKey ( ) ) ; exc . printStackTrace ( out ) ; corrupt = exc ; } } out . flush ( ) ; if ( corrupt ! = null ) { logger . warn ( <str> , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; throw corrupt ; } } else { try ( CheckIndex checkIndex = new CheckIndex ( store . directory ( ) ) ) { checkIndex . setInfoStream ( out ) ; CheckIndex . Status status = checkIndex . checkIndex ( ) ; out . flush ( ) ; if ( ! status . clean ) { if ( state = = IndexShardState . CLOSED ) { return ; } logger . warn ( <str> , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; if ( <str> . equalsIgnoreCase ( checkIndexOnStartup ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> ) ; } checkIndex . exorciseIndex ( status ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , status . segmentsFileName ) ; } } else { throw new IllegalStateException ( <str> ) ; } } } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; } recoveryState . getVerifyIndex ( ) . checkIndexTime ( Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - timeNS ) ) ) ; } Engine getEngine ( ) { Engine engine = getEngineOrNull ( ) ; if ( engine = = null ) { throw new EngineClosedException ( shardId ) ; } return engine ; } protected Engine getEngineOrNull ( ) { return this . currentEngineReference . get ( ) ; } class ShardEventListener implements Engine . EventListener { private final CopyOnWriteArrayList < Callback < ShardFailure > > delegates = new CopyOnWriteArrayList < > ( ) ; @Override public void onFailedEngine ( String reason , @Nullable Throwable failure ) { final ShardFailure shardFailure = new ShardFailure ( shardRouting , reason , failure , getIndexUUID ( ) ) ; for ( Callback < ShardFailure > listener : delegates ) { try { listener . handle ( shardFailure ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } } } private void createNewEngine ( boolean skipTranslogRecovery , EngineConfig config ) { synchronized ( mutex ) { if ( state = = IndexShardState . CLOSED ) { throw new EngineClosedException ( shardId ) ; } assert this . currentEngineReference . get ( ) = = null ; this . currentEngineReference . set ( newEngine ( skipTranslogRecovery , config ) ) ; } } protected Engine newEngine ( boolean skipTranslogRecovery , EngineConfig config ) { return engineFactory . newReadWriteEngine ( config , skipTranslogRecovery ) ; } public boolean allowsPrimaryPromotion ( ) { return true ; } void persistMetadata ( ShardRouting newRouting , ShardRouting currentRouting ) { assert newRouting ! = null : <str> ; if ( newRouting . active ( ) ) { try { final String writeReason ; if ( currentRouting = = null ) { writeReason = <str> + newRouting . version ( ) + <str> ; } else if ( currentRouting . version ( ) < newRouting . version ( ) ) { writeReason = <str> + currentRouting . version ( ) + <str> + newRouting . version ( ) + <str> ; } else if ( currentRouting . equals ( newRouting ) = = false ) { writeReason = <str> + currentRouting + <str> + newRouting ; } else { logger . trace ( <str> + currentRouting . version ( ) + <str> + newRouting . version ( ) + <str> ) ; assert currentRouting . version ( ) < = newRouting . version ( ) : <str> + shardId + <str> + currentRouting . version ( ) + <str> + newRouting . version ( ) + <str> ; return ; } final ShardStateMetaData newShardStateMetadata = new ShardStateMetaData ( newRouting . version ( ) , newRouting . primary ( ) , getIndexUUID ( ) , newRouting . allocationId ( ) ) ; logger . trace ( <str> , shardId , writeReason ) ; ShardStateMetaData . FORMAT . write ( newShardStateMetadata , newShardStateMetadata . version , shardPath ( ) . getShardStatePath ( ) ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } } private String getIndexUUID ( ) { return indexSettings . getUUID ( ) ; } private DocumentMapperForType docMapper ( String type ) { return mapperService . documentMapperWithAutoCreate ( type ) ; } private final EngineConfig newEngineConfig ( TranslogConfig translogConfig , QueryCachingPolicy cachingPolicy ) { final TranslogRecoveryPerformer translogRecoveryPerformer = new TranslogRecoveryPerformer ( shardId , mapperService , logger ) { @Override protected void operationProcessed ( ) { assert recoveryState ! = null ; recoveryState . getTranslog ( ) . incrementRecoveredOperations ( ) ; } } ; final Engine . Warmer engineWarmer = ( searcher , toLevel ) - > warmer . warm ( searcher , this , idxSettings , toLevel ) ; return new EngineConfig ( shardId , threadPool , indexingService , indexSettings , engineWarmer , store , deletionPolicy , mergePolicyConfig . getMergePolicy ( ) , mergeSchedulerConfig , mapperService . indexAnalyzer ( ) , similarityService . similarity ( mapperService ) , codecService , shardEventListener , translogRecoveryPerformer , indexCache . query ( ) , cachingPolicy , translogConfig , inactiveTime ) ; } private static class IndexShardOperationCounter extends AbstractRefCounted { final private ESLogger logger ; private final ShardId shardId ; public IndexShardOperationCounter ( ESLogger logger , ShardId shardId ) { super ( <str> ) ; this . logger = logger ; this . shardId = shardId ; } @Override protected void closeInternal ( ) { logger . debug ( <str> ) ; } @Override protected void alreadyClosed ( ) { throw new IndexShardClosedException ( shardId , <str> ) ; } } public void incrementOperationCounter ( ) { indexShardOperationCounter . incRef ( ) ; } public void decrementOperationCounter ( ) { indexShardOperationCounter . decRef ( ) ; } public int getOperationsCount ( ) { return Math . max ( <int> , indexShardOperationCounter . refCount ( ) - <int> ) ; } public void sync ( Translog . Location location ) { try { final Engine engine = getEngine ( ) ; engine . getTranslog ( ) . ensureSynced ( location ) ; } catch ( EngineClosedException ex ) { } catch ( IOException ex ) { logger . debug ( <str> , ex ) ; throw new ElasticsearchException ( <str> , ex ) ; } } public Translog . Durabilty getTranslogDurability ( ) { return translogConfig . getDurabilty ( ) ; } private static Translog . Durabilty getFromSettings ( ESLogger logger , Settings settings , Translog . Durabilty defaultValue ) { final String value = settings . get ( TranslogConfig . INDEX_TRANSLOG_DURABILITY , defaultValue . name ( ) ) ; try { return Translog . Durabilty . valueOf ( value . toUpperCase ( Locale . ROOT ) ) ; } catch ( IllegalArgumentException ex ) { logger . warn ( <str> , TranslogConfig . INDEX_TRANSLOG_DURABILITY , value , defaultValue , Arrays . toString ( Translog . Durabilty . values ( ) ) ) ; return defaultValue ; } } private final AtomicBoolean asyncFlushRunning = new AtomicBoolean ( ) ; public boolean maybeFlush ( ) { if ( shouldFlush ( ) ) { if ( asyncFlushRunning . compareAndSet ( false , true ) ) { if ( shouldFlush ( ) = = false ) { asyncFlushRunning . compareAndSet ( true , false ) ; } else { logger . debug ( <str> ) ; final AbstractRunnable abstractRunnable = new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { if ( state ! = IndexShardState . CLOSED ) { logger . warn ( <str> , t ) ; } } @Override protected void doRun ( ) throws Exception { flush ( new FlushRequest ( ) ) ; } @Override public void onAfter ( ) { asyncFlushRunning . compareAndSet ( true , false ) ; maybeFlush ( ) ; } } ; threadPool . executor ( ThreadPool . Names . FLUSH ) . execute ( abstractRunnable ) ; return true ; } } } return false ; } public static final class ShardFailure { public final ShardRouting routing ; public final String reason ; @Nullable public final Throwable cause ; public final String indexUUID ; public ShardFailure ( ShardRouting routing , String reason , @Nullable Throwable cause , String indexUUID ) { this . routing = routing ; this . reason = reason ; this . cause = cause ; this . indexUUID = indexUUID ; } } private CloseableThreadLocal < QueryShardContext > queryShardContextCache = new CloseableThreadLocal < QueryShardContext > ( ) { @Override protected QueryShardContext initialValue ( ) { return newQueryShardContext ( ) ; } } ; private QueryShardContext newQueryShardContext ( ) { return new QueryShardContext ( idxSettings , provider . getClient ( ) , indexCache . bitsetFilterCache ( ) , indexFieldDataService , mapperService , similarityService , provider . getScriptService ( ) , provider . getIndicesQueriesRegistry ( ) ) ; } public QueryShardContext getQueryShardContext ( ) { return queryShardContextCache . get ( ) ; } EngineFactory getEngineFactory ( ) { return engineFactory ; } } 
