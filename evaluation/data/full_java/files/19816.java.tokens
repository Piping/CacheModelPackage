package io . netty . example . http . upload ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpObject ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . QueryStringDecoder ; import io . netty . handler . codec . http . cookie . Cookie ; import io . netty . handler . codec . http . cookie . ServerCookieDecoder ; import io . netty . handler . codec . http . cookie . ServerCookieEncoder ; import io . netty . handler . codec . http . multipart . Attribute ; import io . netty . handler . codec . http . multipart . DefaultHttpDataFactory ; import io . netty . handler . codec . http . multipart . DiskAttribute ; import io . netty . handler . codec . http . multipart . DiskFileUpload ; import io . netty . handler . codec . http . multipart . FileUpload ; import io . netty . handler . codec . http . multipart . HttpData ; import io . netty . handler . codec . http . multipart . HttpDataFactory ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . EndOfDataDecoderException ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . ErrorDataDecoderException ; import io . netty . handler . codec . http . multipart . InterfaceHttpData ; import io . netty . handler . codec . http . multipart . InterfaceHttpData . HttpDataType ; import io . netty . util . CharsetUtil ; import java . io . IOException ; import java . net . URI ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . logging . Level ; import java . util . logging . Logger ; import static io . netty . buffer . Unpooled . * ; public class HttpUploadServerHandler extends SimpleChannelInboundHandler < HttpObject > { private static final Logger logger = Logger . getLogger ( HttpUploadServerHandler . class . getName ( ) ) ; private HttpRequest request ; private boolean readingChunks ; private HttpData partialContent ; private final StringBuilder responseContent = new StringBuilder ( ) ; private static final HttpDataFactory factory = new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) ; private HttpPostRequestDecoder decoder ; static { DiskFileUpload . deleteOnExitTemporaryFile = true ; DiskFileUpload . baseDirectory = null ; DiskAttribute . deleteOnExitTemporaryFile = true ; DiskAttribute . baseDirectory = null ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { if ( decoder ! = null ) { decoder . cleanFiles ( ) ; } } @Override public void channelRead0 ( ChannelHandlerContext ctx , HttpObject msg ) throws Exception { if ( msg instanceof HttpRequest ) { HttpRequest request = this . request = ( HttpRequest ) msg ; URI uri = new URI ( request . uri ( ) ) ; if ( ! uri . getPath ( ) . startsWith ( <str> ) ) { writeMenu ( ctx ) ; return ; } responseContent . setLength ( <int> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> + request . protocolVersion ( ) . text ( ) + <str> ) ; responseContent . append ( <str> + request . uri ( ) + <str> ) ; responseContent . append ( <str> ) ; for ( Entry < String , String > entry : request . headers ( ) ) { responseContent . append ( <str> + entry . getKey ( ) + <str> + entry . getValue ( ) + <str> ) ; } responseContent . append ( <str> ) ; Set < Cookie > cookies ; String value = request . headers ( ) . get ( HttpHeaderNames . COOKIE ) ; if ( value = = null ) { cookies = Collections . emptySet ( ) ; } else { cookies = ServerCookieDecoder . STRICT . decode ( value ) ; } for ( Cookie cookie : cookies ) { responseContent . append ( <str> + cookie + <str> ) ; } responseContent . append ( <str> ) ; QueryStringDecoder decoderQuery = new QueryStringDecoder ( request . uri ( ) ) ; Map < String , List < String > > uriAttributes = decoderQuery . parameters ( ) ; for ( Entry < String , List < String > > attr : uriAttributes . entrySet ( ) ) { for ( String attrVal : attr . getValue ( ) ) { responseContent . append ( <str> + attr . getKey ( ) + <str> + attrVal + <str> ) ; } } responseContent . append ( <str> ) ; if ( request . method ( ) . equals ( HttpMethod . GET ) ) { responseContent . append ( <str> ) ; return ; } try { decoder = new HttpPostRequestDecoder ( factory , request ) ; } catch ( ErrorDataDecoderException e1 ) { e1 . printStackTrace ( ) ; responseContent . append ( e1 . getMessage ( ) ) ; writeResponse ( ctx . channel ( ) ) ; ctx . channel ( ) . close ( ) ; return ; } readingChunks = HttpUtil . isTransferEncodingChunked ( request ) ; responseContent . append ( <str> + readingChunks + <str> ) ; responseContent . append ( <str> + decoder . isMultipart ( ) + <str> ) ; if ( readingChunks ) { responseContent . append ( <str> ) ; readingChunks = true ; } } if ( decoder ! = null ) { if ( msg instanceof HttpContent ) { HttpContent chunk = ( HttpContent ) msg ; try { decoder . offer ( chunk ) ; } catch ( ErrorDataDecoderException e1 ) { e1 . printStackTrace ( ) ; responseContent . append ( e1 . getMessage ( ) ) ; writeResponse ( ctx . channel ( ) ) ; ctx . channel ( ) . close ( ) ; return ; } responseContent . append ( <str> ) ; readHttpDataChunkByChunk ( ) ; if ( chunk instanceof LastHttpContent ) { writeResponse ( ctx . channel ( ) ) ; readingChunks = false ; reset ( ) ; } } } else { writeResponse ( ctx . channel ( ) ) ; } } private void reset ( ) { request = null ; decoder . destroy ( ) ; decoder = null ; } private void readHttpDataChunkByChunk ( ) { try { while ( decoder . hasNext ( ) ) { InterfaceHttpData data = decoder . next ( ) ; if ( data ! = null ) { if ( partialContent = = data ) { logger . info ( <str> + partialContent . length ( ) + <str> ) ; partialContent = null ; } try { writeHttpData ( data ) ; } finally { data . release ( ) ; } } } InterfaceHttpData data = decoder . currentPartialHttpData ( ) ; if ( data ! = null ) { StringBuilder builder = new StringBuilder ( ) ; if ( partialContent = = null ) { partialContent = ( HttpData ) data ; if ( partialContent instanceof FileUpload ) { builder . append ( <str> ) . append ( ( ( FileUpload ) partialContent ) . getFilename ( ) ) . append ( <str> ) ; } else { builder . append ( <str> ) . append ( partialContent . getName ( ) ) . append ( <str> ) ; } builder . append ( <str> ) . append ( partialContent . definedLength ( ) ) . append ( <str> ) ; } if ( partialContent . definedLength ( ) > <int> ) { builder . append ( <str> ) . append ( partialContent . length ( ) * <int> / partialContent . definedLength ( ) ) . append ( <str> ) ; logger . info ( builder . toString ( ) ) ; } else { builder . append ( <str> ) . append ( partialContent . length ( ) ) . append ( <str> ) ; logger . info ( builder . toString ( ) ) ; } } } catch ( EndOfDataDecoderException e1 ) { responseContent . append ( <str> ) ; } } private void writeHttpData ( InterfaceHttpData data ) { if ( data . getHttpDataType ( ) = = HttpDataType . Attribute ) { Attribute attribute = ( Attribute ) data ; String value ; try { value = attribute . getValue ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; responseContent . append ( <str> + attribute . getHttpDataType ( ) . name ( ) + <str> + attribute . getName ( ) + <str> + e1 . getMessage ( ) + <str> ) ; return ; } if ( value . length ( ) > <int> ) { responseContent . append ( <str> + attribute . getHttpDataType ( ) . name ( ) + <str> + attribute . getName ( ) + <str> ) ; } else { responseContent . append ( <str> + attribute . getHttpDataType ( ) . name ( ) + <str> + attribute + <str> ) ; } } else { responseContent . append ( <str> + data . getHttpDataType ( ) . name ( ) + <str> + data + <str> ) ; if ( data . getHttpDataType ( ) = = HttpDataType . FileUpload ) { FileUpload fileUpload = ( FileUpload ) data ; if ( fileUpload . isCompleted ( ) ) { if ( fileUpload . length ( ) < <int> ) { responseContent . append ( <str> ) ; try { responseContent . append ( fileUpload . getString ( fileUpload . getCharset ( ) ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } responseContent . append ( <str> ) ; } else { responseContent . append ( <str> + fileUpload . length ( ) + <str> ) ; } } else { responseContent . append ( <str> ) ; } } } } private void writeResponse ( Channel channel ) { ByteBuf buf = copiedBuffer ( responseContent . toString ( ) , CharsetUtil . UTF_8 ) ; responseContent . setLength ( <int> ) ; boolean close = request . headers ( ) . contains ( HttpHeaderNames . CONNECTION , HttpHeaderValues . CLOSE , true ) | | request . protocolVersion ( ) . equals ( HttpVersion . HTTP_1_0 ) & & ! request . headers ( ) . contains ( HttpHeaderNames . CONNECTION , HttpHeaderValues . KEEP_ALIVE , true ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , buf ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; if ( ! close ) { response . headers ( ) . setInt ( HttpHeaderNames . CONTENT_LENGTH , buf . readableBytes ( ) ) ; } Set < Cookie > cookies ; String value = request . headers ( ) . get ( HttpHeaderNames . COOKIE ) ; if ( value = = null ) { cookies = Collections . emptySet ( ) ; } else { cookies = ServerCookieDecoder . STRICT . decode ( value ) ; } if ( ! cookies . isEmpty ( ) ) { for ( Cookie cookie : cookies ) { response . headers ( ) . add ( HttpHeaderNames . SET_COOKIE , ServerCookieEncoder . STRICT . encode ( cookie ) ) ; } } ChannelFuture future = channel . writeAndFlush ( response ) ; if ( close ) { future . addListener ( ChannelFutureListener . CLOSE ) ; } } private void writeMenu ( ChannelHandlerContext ctx ) { responseContent . setLength ( <int> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> + <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; responseContent . append ( <str> ) ; ByteBuf buf = copiedBuffer ( responseContent . toString ( ) , CharsetUtil . UTF_8 ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , buf ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; response . headers ( ) . setInt ( HttpHeaderNames . CONTENT_LENGTH , buf . readableBytes ( ) ) ; ctx . channel ( ) . writeAndFlush ( response ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . log ( Level . WARNING , responseContent . toString ( ) , cause ) ; ctx . channel ( ) . close ( ) ; } } 
