package org . gradle . testkit . runner . internal ; import org . apache . commons . io . output . TeeOutputStream ; import org . gradle . internal . SystemProperties ; import org . gradle . testkit . runner . BuildTask ; import org . gradle . testkit . runner . InvalidRunnerConfigurationException ; import org . gradle . testkit . runner . TaskOutcome ; import org . gradle . testkit . runner . internal . dist . GradleDistribution ; import org . gradle . testkit . runner . internal . dist . InstalledGradleDistribution ; import org . gradle . testkit . runner . internal . dist . URILocatedGradleDistribution ; import org . gradle . testkit . runner . internal . dist . VersionBasedGradleDistribution ; import org . gradle . testkit . runner . internal . io . NoCloseOutputStream ; import org . gradle . testkit . runner . internal . io . SynchronizedOutputStream ; import org . gradle . tooling . * ; import org . gradle . tooling . events . ProgressEvent ; import org . gradle . tooling . events . ProgressListener ; import org . gradle . tooling . events . task . * ; import org . gradle . tooling . internal . consumer . DefaultBuildLauncher ; import org . gradle . tooling . internal . consumer . DefaultGradleConnector ; import org . gradle . util . CollectionUtils ; import org . gradle . wrapper . GradleUserHomeLookup ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . gradle . testkit . runner . TaskOutcome . * ; public class ToolingApiGradleExecutor implements GradleExecutor { public static final String TEST_KIT_DAEMON_DIR_NAME = <str> ; private static final String CLEANUP_THREAD_NAME = <str> ; private final static AtomicBoolean SHUTDOWN_REGISTERED = new AtomicBoolean ( ) ; private static void maybeRegisterCleanup ( ) { if ( SHUTDOWN_REGISTERED . compareAndSet ( false , true ) ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { public void run ( ) { DefaultGradleConnector . close ( ) ; } } , CLEANUP_THREAD_NAME ) ) ; } } public GradleExecutionResult run ( GradleExecutionParameters parameters ) { final ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; final OutputStream syncOutput = new SynchronizedOutputStream ( output ) ; final List < BuildTask > tasks = new ArrayList < BuildTask > ( ) ; maybeRegisterCleanup ( ) ; GradleConnector gradleConnector = buildConnector ( parameters . getGradleUserHome ( ) , parameters . getProjectDir ( ) , parameters . isEmbedded ( ) , parameters . getGradleDistribution ( ) ) ; ProjectConnection connection = null ; try { connection = gradleConnector . connect ( ) ; DefaultBuildLauncher launcher = ( DefaultBuildLauncher ) connection . newBuild ( ) ; launcher . setStandardOutput ( new NoCloseOutputStream ( teeOutput ( syncOutput , parameters . getStandardOutput ( ) ) ) ) ; launcher . setStandardError ( new NoCloseOutputStream ( teeOutput ( syncOutput , parameters . getStandardError ( ) ) ) ) ; launcher . addProgressListener ( new TaskExecutionProgressListener ( tasks ) ) ; launcher . withArguments ( parameters . getBuildArgs ( ) . toArray ( new String [ parameters . getBuildArgs ( ) . size ( ) ] ) ) ; launcher . setJvmArguments ( parameters . getJvmArgs ( ) . toArray ( new String [ parameters . getJvmArgs ( ) . size ( ) ] ) ) ; launcher . withInjectedClassPath ( parameters . getInjectedClassPath ( ) ) ; launcher . run ( ) ; } catch ( UnsupportedVersionException e ) { throw new InvalidRunnerConfigurationException ( <str> , e ) ; } catch ( BuildException t ) { return new GradleExecutionResult ( output . toString ( ) , tasks , t ) ; } catch ( GradleConnectionException t ) { StringBuilder message = new StringBuilder ( <str> ) ; if ( parameters . getBuildArgs ( ) . isEmpty ( ) ) { message . append ( <str> ) ; } else { message . append ( <str> ) ; message . append ( CollectionUtils . join ( <str> , parameters . getBuildArgs ( ) ) ) ; message . append ( <str> ) ; } message . append ( <str> ) . append ( parameters . getProjectDir ( ) . getAbsolutePath ( ) ) . append ( <str> ) ; String capturedOutput = output . toString ( ) ; if ( ! capturedOutput . isEmpty ( ) ) { message . append ( <str> ) . append ( SystemProperties . getInstance ( ) . getLineSeparator ( ) ) . append ( capturedOutput ) ; } throw new IllegalStateException ( message . toString ( ) , t ) ; } finally { if ( connection ! = null ) { connection . close ( ) ; } } return new GradleExecutionResult ( output . toString ( ) , tasks ) ; } private static OutputStream teeOutput ( OutputStream capture , OutputStream user ) { if ( user = = null ) { return capture ; } else { return new TeeOutputStream ( capture , user ) ; } } private GradleConnector buildConnector ( File gradleUserHome , File projectDir , boolean embedded , GradleDistribution gradleDistribution ) { DefaultGradleConnector gradleConnector = ( DefaultGradleConnector ) GradleConnector . newConnector ( ) ; useGradleDistribution ( gradleConnector , gradleDistribution ) ; gradleConnector . useGradleUserHomeDir ( gradleUserHome ) ; gradleConnector . daemonBaseDir ( new File ( gradleUserHome , TEST_KIT_DAEMON_DIR_NAME ) ) ; gradleConnector . forProjectDirectory ( projectDir ) ; gradleConnector . searchUpwards ( false ) ; gradleConnector . daemonMaxIdleTime ( <int> , TimeUnit . SECONDS ) ; gradleConnector . embedded ( embedded ) ; return gradleConnector ; } private void useGradleDistribution ( DefaultGradleConnector gradleConnector , GradleDistribution gradleDistribution ) { gradleConnector . useDistributionBaseDir ( GradleUserHomeLookup . gradleUserHome ( ) ) ; if ( gradleDistribution instanceof InstalledGradleDistribution ) { gradleConnector . useInstallation ( ( ( InstalledGradleDistribution ) gradleDistribution ) . getGradleHome ( ) ) ; } else if ( gradleDistribution instanceof URILocatedGradleDistribution ) { gradleConnector . useDistribution ( ( ( URILocatedGradleDistribution ) gradleDistribution ) . getLocation ( ) ) ; } else if ( gradleDistribution instanceof VersionBasedGradleDistribution ) { gradleConnector . useGradleVersion ( ( ( VersionBasedGradleDistribution ) gradleDistribution ) . getGradleVersion ( ) ) ; } } private class TaskExecutionProgressListener implements ProgressListener { private final List < BuildTask > tasks ; private final Map < String , Integer > order = new HashMap < String , Integer > ( ) ; public TaskExecutionProgressListener ( List < BuildTask > tasks ) { this . tasks = tasks ; } public void statusChanged ( ProgressEvent event ) { if ( event instanceof TaskStartEvent ) { TaskStartEvent taskStartEvent = ( TaskStartEvent ) event ; order . put ( taskStartEvent . getDescriptor ( ) . getTaskPath ( ) , tasks . size ( ) ) ; tasks . add ( null ) ; } if ( event instanceof TaskFinishEvent ) { TaskFinishEvent taskFinishEvent = ( TaskFinishEvent ) event ; String taskPath = taskFinishEvent . getDescriptor ( ) . getTaskPath ( ) ; TaskOperationResult result = taskFinishEvent . getResult ( ) ; final Integer index = order . get ( taskPath ) ; if ( index = = null ) { throw new IllegalStateException ( <str> + taskPath + <str> ) ; } tasks . set ( index , determineBuildTask ( result , taskPath ) ) ; } } private BuildTask determineBuildTask ( TaskOperationResult result , String taskPath ) { if ( isFailed ( result ) ) { return createBuildTask ( taskPath , FAILED ) ; } else if ( isSkipped ( result ) ) { return createBuildTask ( taskPath , SKIPPED ) ; } else if ( isUpToDate ( result ) ) { return createBuildTask ( taskPath , UP_TO_DATE ) ; } return createBuildTask ( taskPath , SUCCESS ) ; } private BuildTask createBuildTask ( String taskPath , TaskOutcome outcome ) { return new DefaultBuildTask ( taskPath , outcome ) ; } private boolean isFailed ( TaskOperationResult result ) { return result instanceof TaskFailureResult ; } private boolean isSkipped ( TaskOperationResult result ) { return result instanceof TaskSkippedResult ; } private boolean isUpToDate ( TaskOperationResult result ) { return result instanceof TaskSuccessResult & & ( ( TaskSuccessResult ) result ) . isUpToDate ( ) ; } } } 
