package org . eclipse . debug . internal . ui . actions . breakpoints ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . internal . ui . DebugPluginImages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IDebugHelpContextIds ; import org . eclipse . debug . internal . ui . actions . ActionMessages ; import org . eclipse . debug . internal . ui . actions . ToggleFilterAction ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointContainer ; import org . eclipse . debug . ui . AbstractDebugView ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . ui . ISelectionListener ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . PlatformUI ; public class ShowSupportedBreakpointsAction extends ToggleFilterAction implements ISelectionListener { private AbstractDebugView fView ; private List < IDebugTarget > fDebugTargets = new ArrayList < IDebugTarget > ( <int> ) ; class BreakpointFilter extends ViewerFilter { @Override public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( element instanceof IBreakpointContainer ) { IBreakpoint [ ] breakpoints = ( ( IBreakpointContainer ) element ) . getBreakpoints ( ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { if ( select ( viewer , element , breakpoints [ i ] ) ) { return true ; } } return false ; } IBreakpoint breakpoint = ( IBreakpoint ) element ; if ( fDebugTargets . isEmpty ( ) ) { return true ; } for ( IDebugTarget target : fDebugTargets ) { if ( target . supportsBreakpoint ( breakpoint ) ) { return true ; } } return false ; } } public ShowSupportedBreakpointsAction ( StructuredViewer viewer , IViewPart view ) { super ( ) ; setText ( ActionMessages . ShowSupportedBreakpointsAction_Show_For_Selected ) ; setToolTipText ( ActionMessages . ShowSupportedBreakpointsAction_tooltip ) ; setViewerFilter ( new BreakpointFilter ( ) ) ; setViewer ( viewer ) ; setImageDescriptor ( DebugPluginImages . getImageDescriptor ( IDebugUIConstants . IMG_OBJS_DEBUG_TARGET ) ) ; setChecked ( false ) ; setId ( DebugUIPlugin . getUniqueIdentifier ( ) + <str> ) ; setView ( view ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( this , IDebugHelpContextIds . SHOW_BREAKPOINTS_FOR_MODEL_ACTION ) ; } public void dispose ( ) { if ( isChecked ( ) ) { getView ( ) . getSite ( ) . getPage ( ) . removeSelectionListener ( IDebugUIConstants . ID_DEBUG_VIEW , this ) ; } } @Override public void selectionChanged ( IWorkbenchPart part , ISelection selection ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection ss = ( IStructuredSelection ) selection ; List < IDebugTarget > debugTargets = getDebugTargets ( ss ) ; if ( ! isChecked ( ) ) { fDebugTargets = debugTargets ; return ; } if ( debugTargets . isEmpty ( ) ) { if ( fDebugTargets . isEmpty ( ) ) { return ; } reapplyFilters ( debugTargets ) ; return ; } if ( fDebugTargets . isEmpty ( ) ) { reapplyFilters ( debugTargets ) ; return ; } if ( debugTargets . size ( ) = = fDebugTargets . size ( ) ) { List < IDebugTarget > copy = new ArrayList < IDebugTarget > ( debugTargets . size ( ) ) ; for ( IDebugTarget target : fDebugTargets ) { Iterator < IDebugTarget > newDebugTargets = debugTargets . iterator ( ) ; while ( newDebugTargets . hasNext ( ) ) { IDebugTarget newTarget = newDebugTargets . next ( ) ; copy . add ( newTarget ) ; if ( target . equals ( newTarget ) ) { newDebugTargets . remove ( ) ; } } } if ( debugTargets . isEmpty ( ) ) { return ; } reapplyFilters ( copy ) ; } } } protected void reapplyFilters ( List < IDebugTarget > debugTargets ) { fDebugTargets = debugTargets ; getViewer ( ) . refresh ( ) ; } protected IViewPart getView ( ) { return fView ; } protected void setView ( IViewPart view ) { fView = ( AbstractDebugView ) view ; } protected List < IDebugTarget > getDebugTargets ( IStructuredSelection ss ) { List < IDebugTarget > debugTargets = new ArrayList < IDebugTarget > ( <int> ) ; Iterator < ? > i = ss . iterator ( ) ; while ( i . hasNext ( ) ) { Object next = i . next ( ) ; if ( next instanceof IDebugElement ) { debugTargets . add ( ( ( IDebugElement ) next ) . getDebugTarget ( ) ) ; } else if ( next instanceof ILaunch ) { IDebugTarget [ ] targets = ( ( ILaunch ) next ) . getDebugTargets ( ) ; for ( int j = <int> ; j < targets . length ; j + + ) { debugTargets . add ( targets [ j ] ) ; } } else if ( next instanceof IProcess ) { IDebugTarget target = ( ( IProcess ) next ) . getAdapter ( IDebugTarget . class ) ; if ( target ! = null ) { debugTargets . add ( target ) ; } } } return debugTargets ; } @Override protected void valueChanged ( boolean on ) { if ( getViewer ( ) . getControl ( ) . isDisposed ( ) ) { return ; } if ( on ) { getView ( ) . getSite ( ) . getPage ( ) . addSelectionListener ( IDebugUIConstants . ID_DEBUG_VIEW , this ) ; ISelection selection = getView ( ) . getSite ( ) . getPage ( ) . getSelection ( IDebugUIConstants . ID_DEBUG_VIEW ) ; selectionChanged ( null , selection ) ; } else { getView ( ) . getSite ( ) . getPage ( ) . removeSelectionListener ( IDebugUIConstants . ID_DEBUG_VIEW , this ) ; } super . valueChanged ( on ) ; fView . getViewer ( ) . refresh ( ) ; } } 
