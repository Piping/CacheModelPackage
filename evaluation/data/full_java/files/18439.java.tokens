package com . badlogic . gdx . tests ; import com . badlogic . gdx . math . Affine2 ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class Affine2Test extends GdxTest { static public final float TOLERANCE = <float> ; @Override public void create ( ) { Vector2 trn = new Vector2 ( <int> , <int> ) ; float rot = <int> ; float cos = ( float ) Math . cos ( MathUtils . degreesToRadians * rot ) ; float sin = ( float ) Math . sin ( MathUtils . degreesToRadians * rot ) ; Vector2 scl = new Vector2 ( <float> , <float> ) ; Vector2 shear = new Vector2 ( <float> , <float> ) ; Matrix3 mat1 = new Matrix3 ( ) ; Matrix3 mat2 = new Matrix3 ( ) ; Affine2 afn1 = new Affine2 ( ) ; Affine2 afn2 = new Affine2 ( ) ; checkEqual ( mat1 , new float [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; checkEqual ( mat1 , mat2 . idt ( ) ) ; checkEqual ( mat1 , afn1 ) ; checkEqual ( mat1 , afn1 . idt ( ) ) ; mat1 . setToTranslation ( trn ) ; checkEqual ( mat1 , new float [ ] { <int> , <int> , <int> , <int> , <int> , <int> , trn . x , trn . y , <int> } ) ; afn1 . setToTranslation ( trn ) ; checkEqual ( mat1 , afn1 ) ; mat1 . setToScaling ( scl ) ; checkEqual ( mat1 , new float [ ] { scl . x , <int> , <int> , <int> , scl . y , <int> , <int> , <int> , <int> } ) ; afn1 . setToScaling ( scl ) ; checkEqual ( mat1 , afn1 ) ; mat1 . setToRotation ( rot ) ; checkEqual ( mat1 , new float [ ] { cos , sin , <int> , - sin , cos , <int> , <int> , <int> , <int> } ) ; afn1 . setToRotation ( rot ) ; checkEqual ( mat1 , afn1 ) ; mat1 . setToRotationRad ( MathUtils . degreesToRadians * rot ) ; checkEqual ( mat1 , afn1 ) ; afn1 . setToRotationRad ( MathUtils . degreesToRadians * rot ) ; checkEqual ( mat1 , afn1 ) ; afn1 . setToShearing ( shear ) ; checkEqual ( mat1 . set ( afn1 ) , new float [ ] { <int> , shear . y , <int> , shear . x , <int> , <int> , <int> , <int> , <int> } ) ; afn1 . setToTrnRotScl ( trn , rot , scl ) ; afn2 . setToTrnRotRadScl ( trn , MathUtils . degreesToRadians * rot , scl ) ; checkEqual ( afn1 , afn2 ) ; afn2 . setToTranslation ( trn ) . rotate ( rot ) . scale ( scl ) ; checkEqual ( afn1 , afn2 ) ; afn1 . setToTrnRotScl ( trn , <int> , scl ) ; afn2 . setToTrnScl ( trn , scl ) ; checkEqual ( afn1 , afn2 ) ; mat1 . idt ( ) . scale ( scl ) . rotate ( rot ) . translate ( trn ) . mul ( mat2 . set ( afn2 . setToShearing ( shear ) ) ) ; afn1 . idt ( ) . scale ( scl ) . rotate ( rot ) . translate ( trn ) . shear ( shear ) ; checkEqual ( mat1 , afn1 ) ; afn1 . idt ( ) . mul ( afn2 . setToScaling ( scl ) ) . mul ( afn2 . setToRotation ( rot ) ) . mul ( afn2 . setToTranslation ( trn ) ) . mul ( afn2 . setToShearing ( shear ) ) ; checkEqual ( mat1 , afn1 ) ; afn1 . idt ( ) . preShear ( shear ) . preTranslate ( trn ) . preRotate ( rot ) . preScale ( scl ) ; checkEqual ( mat1 , afn1 ) ; afn1 . idt ( ) . preMul ( afn2 . setToShearing ( shear ) ) . preMul ( afn2 . setToTranslation ( trn ) ) . preMul ( afn2 . setToRotation ( rot ) ) . preMul ( afn2 . setToScaling ( scl ) ) ; checkEqual ( mat1 , afn1 ) ; mat1 . set ( afn2 . setToShearing ( shear ) ) . trn ( trn ) . mulLeft ( mat2 . setToRotation ( rot ) ) . mulLeft ( mat2 . setToScaling ( scl ) ) ; checkEqual ( mat1 , afn1 ) ; checkEqual ( mat1 . det ( ) , afn1 . det ( ) ) ; check ( afn1 . det ( ) = = ( afn1 . m00 * afn1 . m11 - afn1 . m01 * afn1 . m10 ) ) ; mat1 . inv ( ) ; afn2 . set ( afn1 ) . inv ( ) ; checkEqual ( mat1 , afn2 ) ; checkEqual ( afn1 . det ( ) , <int> / afn2 . det ( ) ) ; boolean didThrow = false ; afn1 . setToShearing ( <int> , <int> ) ; try { afn1 . inv ( ) ; } catch ( GdxRuntimeException e ) { didThrow = true ; } check ( didThrow ) ; System . out . println ( <str> ) ; } private static void check ( boolean condition ) { if ( ! condition ) throw new GdxRuntimeException ( <str> ) ; } private static void check ( boolean condition , String msg ) { if ( ! condition ) throw new GdxRuntimeException ( msg ) ; } private static void checkEqual ( Matrix3 matrix , Affine2 affine ) { checkEqual ( matrix , new Matrix3 ( ) . set ( affine ) ) ; } private static void checkEqual ( Affine2 a , Affine2 b ) { checkEqual ( new Matrix3 ( ) . set ( a ) , new Matrix3 ( ) . set ( b ) ) ; } private static void checkEqual ( Matrix3 a , Matrix3 b ) { for ( int i = <int> ; i < <int> ; i + + ) check ( MathUtils . isEqual ( a . val [ i ] , b . val [ i ] , TOLERANCE ) , <str> ) ; } private static void checkEqual ( Matrix3 matrix , float [ ] vals ) { for ( int i = <int> ; i < <int> ; i + + ) check ( MathUtils . isEqual ( matrix . val [ i ] , vals [ i ] , TOLERANCE ) , <str> ) ; } private static void checkEqual ( float a , float b ) { check ( MathUtils . isEqual ( a , b , TOLERANCE ) ) ; } } 
