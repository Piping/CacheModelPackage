package org . gradle . api . internal ; import groovy . lang . Closure ; import org . gradle . api . * ; import org . gradle . internal . Actions ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . util . ConfigureUtil ; public abstract class AbstractNamedDomainObjectContainer < T > extends DefaultNamedDomainObjectSet < T > implements NamedDomainObjectContainer < T > { protected AbstractNamedDomainObjectContainer ( Class < T > type , Instantiator instantiator , Namer < ? super T > namer ) { super ( type , instantiator , namer ) ; } protected AbstractNamedDomainObjectContainer ( Class < T > type , Instantiator instantiator ) { super ( type , instantiator , Named . Namer . forType ( type ) ) ; } protected abstract T doCreate ( String name ) ; public T create ( String name ) { return create ( name , Actions . doNothing ( ) ) ; } public T maybeCreate ( String name ) { T item = findByName ( name ) ; if ( item ! = null ) { return item ; } return create ( name ) ; } public T create ( String name , Closure configureClosure ) { return create ( name , new ClosureBackedAction < T > ( configureClosure ) ) ; } public T create ( String name , Action < ? super T > configureAction ) throws InvalidUserDataException { assertCanAdd ( name ) ; T object = doCreate ( name ) ; add ( object ) ; configureAction . execute ( object ) ; return object ; } protected Object createConfigureDelegate ( Closure configureClosure ) { return new NamedDomainObjectContainerConfigureDelegate ( configureClosure . getOwner ( ) , this ) ; } public AbstractNamedDomainObjectContainer < T > configure ( Closure configureClosure ) { ConfigureUtil . configure ( configureClosure , createConfigureDelegate ( configureClosure ) ) ; return this ; } public String getDisplayName ( ) { return String . format ( <str> , getTypeDisplayName ( ) ) ; } } 
