package org . elasticsearch . search . aggregations . bucket . terms ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . bucket . BucketsAggregator ; import org . elasticsearch . search . aggregations . bucket . terms . InternalOrder . Aggregation ; import org . elasticsearch . search . aggregations . bucket . terms . InternalOrder . CompoundOrder ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import java . io . IOException ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; public abstract class TermsAggregator extends BucketsAggregator { public static class BucketCountThresholds { private Explicit < Long > minDocCount ; private Explicit < Long > shardMinDocCount ; private Explicit < Integer > requiredSize ; private Explicit < Integer > shardSize ; public BucketCountThresholds ( long minDocCount , long shardMinDocCount , int requiredSize , int shardSize ) { this . minDocCount = new Explicit < > ( minDocCount , false ) ; this . shardMinDocCount = new Explicit < > ( shardMinDocCount , false ) ; this . requiredSize = new Explicit < > ( requiredSize , false ) ; this . shardSize = new Explicit < > ( shardSize , false ) ; } public BucketCountThresholds ( ) { this ( - <int> , - <int> , - <int> , - <int> ) ; } public BucketCountThresholds ( BucketCountThresholds bucketCountThresholds ) { this ( bucketCountThresholds . minDocCount . value ( ) , bucketCountThresholds . shardMinDocCount . value ( ) , bucketCountThresholds . requiredSize . value ( ) , bucketCountThresholds . shardSize . value ( ) ) ; } public void ensureValidity ( ) { if ( shardSize . value ( ) = = <int> ) { setShardSize ( Integer . MAX_VALUE ) ; } if ( requiredSize . value ( ) = = <int> ) { setRequiredSize ( Integer . MAX_VALUE ) ; } if ( shardSize . value ( ) < requiredSize . value ( ) ) { setShardSize ( requiredSize . value ( ) ) ; } if ( shardMinDocCount . value ( ) > minDocCount . value ( ) ) { setShardMinDocCount ( minDocCount . value ( ) ) ; } if ( requiredSize . value ( ) < <int> | | minDocCount . value ( ) < <int> ) { throw new ElasticsearchException ( <str> ) ; } } public long getShardMinDocCount ( ) { return shardMinDocCount . value ( ) ; } public void setShardMinDocCount ( long shardMinDocCount ) { this . shardMinDocCount = new Explicit < > ( shardMinDocCount , true ) ; } public long getMinDocCount ( ) { return minDocCount . value ( ) ; } public void setMinDocCount ( long minDocCount ) { this . minDocCount = new Explicit < > ( minDocCount , true ) ; } public int getRequiredSize ( ) { return requiredSize . value ( ) ; } public void setRequiredSize ( int requiredSize ) { this . requiredSize = new Explicit < > ( requiredSize , true ) ; } public int getShardSize ( ) { return shardSize . value ( ) ; } public void setShardSize ( int shardSize ) { this . shardSize = new Explicit < > ( shardSize , true ) ; } public void toXContent ( XContentBuilder builder ) throws IOException { if ( requiredSize . explicit ( ) ) { builder . field ( AbstractTermsParametersParser . REQUIRED_SIZE_FIELD_NAME . getPreferredName ( ) , requiredSize . value ( ) ) ; } if ( shardSize . explicit ( ) ) { builder . field ( AbstractTermsParametersParser . SHARD_SIZE_FIELD_NAME . getPreferredName ( ) , shardSize . value ( ) ) ; } if ( minDocCount . explicit ( ) ) { builder . field ( AbstractTermsParametersParser . MIN_DOC_COUNT_FIELD_NAME . getPreferredName ( ) , minDocCount . value ( ) ) ; } if ( shardMinDocCount . explicit ( ) ) { builder . field ( AbstractTermsParametersParser . SHARD_MIN_DOC_COUNT_FIELD_NAME . getPreferredName ( ) , shardMinDocCount . value ( ) ) ; } } } protected final BucketCountThresholds bucketCountThresholds ; protected final Terms . Order order ; protected final Set < Aggregator > aggsUsedForSorting = new HashSet < > ( ) ; protected final SubAggCollectionMode collectMode ; public TermsAggregator ( String name , AggregatorFactories factories , AggregationContext context , Aggregator parent , BucketCountThresholds bucketCountThresholds , Terms . Order order , SubAggCollectionMode collectMode , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , context , parent , pipelineAggregators , metaData ) ; this . bucketCountThresholds = bucketCountThresholds ; this . order = InternalOrder . validate ( order , this ) ; this . collectMode = collectMode ; if ( order instanceof Aggregation ) { AggregationPath path = ( ( Aggregation ) order ) . path ( ) ; aggsUsedForSorting . add ( path . resolveTopmostAggregator ( this ) ) ; } else if ( order instanceof CompoundOrder ) { CompoundOrder compoundOrder = ( CompoundOrder ) order ; for ( Terms . Order orderElement : compoundOrder . orderElements ( ) ) { if ( orderElement instanceof Aggregation ) { AggregationPath path = ( ( Aggregation ) orderElement ) . path ( ) ; aggsUsedForSorting . add ( path . resolveTopmostAggregator ( this ) ) ; } } } } @Override protected boolean shouldDefer ( Aggregator aggregator ) { return collectMode = = SubAggCollectionMode . BREADTH_FIRST & & aggregator . needsScores ( ) = = false & & ! aggsUsedForSorting . contains ( aggregator ) ; } } 
