package org . elasticsearch . indices . recovery ; import org . apache . lucene . store . IOContext ; import org . apache . lucene . store . IndexOutput ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . util . CancellableThreads ; import org . elasticsearch . common . util . concurrent . AbstractRefCounted ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . index . store . StoreFileMetaData ; import java . io . IOException ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicLong ; public class RecoveryStatus extends AbstractRefCounted { private final ESLogger logger ; private final static AtomicLong idGenerator = new AtomicLong ( ) ; private final String RECOVERY_PREFIX = <str> ; private final ShardId shardId ; private final long recoveryId ; private final IndexShard indexShard ; private final DiscoveryNode sourceNode ; private final String tempFilePrefix ; private final Store store ; private final RecoveryTarget . RecoveryListener listener ; private final AtomicBoolean finished = new AtomicBoolean ( ) ; private final ConcurrentMap < String , IndexOutput > openIndexOutputs = ConcurrentCollections . newConcurrentMap ( ) ; private final Store . LegacyChecksums legacyChecksums = new Store . LegacyChecksums ( ) ; private final CancellableThreads cancellableThreads = new CancellableThreads ( ) ; private volatile long lastAccessTime = System . nanoTime ( ) ; public RecoveryStatus ( IndexShard indexShard , DiscoveryNode sourceNode , RecoveryTarget . RecoveryListener listener ) { super ( <str> ) ; this . recoveryId = idGenerator . incrementAndGet ( ) ; this . listener = listener ; this . logger = Loggers . getLogger ( getClass ( ) , indexShard . indexSettings ( ) . getSettings ( ) , indexShard . shardId ( ) ) ; this . indexShard = indexShard ; this . sourceNode = sourceNode ; this . shardId = indexShard . shardId ( ) ; this . tempFilePrefix = RECOVERY_PREFIX + indexShard . recoveryState ( ) . getTimer ( ) . startTime ( ) + <str> ; this . store = indexShard . store ( ) ; store . incRef ( ) ; indexShard . recoveryStats ( ) . incCurrentAsTarget ( ) ; } private final Map < String , String > tempFileNames = ConcurrentCollections . newConcurrentMap ( ) ; public long recoveryId ( ) { return recoveryId ; } public ShardId shardId ( ) { return shardId ; } public IndexShard indexShard ( ) { ensureRefCount ( ) ; return indexShard ; } public DiscoveryNode sourceNode ( ) { return this . sourceNode ; } public RecoveryState state ( ) { return indexShard . recoveryState ( ) ; } public CancellableThreads CancellableThreads ( ) { return cancellableThreads ; } public long lastAccessTime ( ) { return lastAccessTime ; } public void setLastAccessTime ( ) { lastAccessTime = System . nanoTime ( ) ; } public Store store ( ) { ensureRefCount ( ) ; return store ; } public RecoveryState . Stage stage ( ) { return state ( ) . getStage ( ) ; } public Store . LegacyChecksums legacyChecksums ( ) { return legacyChecksums ; } public void renameAllTempFiles ( ) throws IOException { ensureRefCount ( ) ; store . renameTempFilesSafe ( tempFileNames ) ; } public void cancel ( String reason ) { if ( finished . compareAndSet ( false , true ) ) { try { logger . debug ( <str> , reason ) ; cancellableThreads . cancel ( reason ) ; } finally { decRef ( ) ; } } } public void fail ( RecoveryFailedException e , boolean sendShardFailure ) { if ( finished . compareAndSet ( false , true ) ) { try { listener . onRecoveryFailure ( state ( ) , e , sendShardFailure ) ; } finally { try { cancellableThreads . cancel ( <str> + ExceptionsHelper . stackTrace ( e ) + <str> ) ; } finally { decRef ( ) ; } } } } public void markAsDone ( ) { if ( finished . compareAndSet ( false , true ) ) { assert tempFileNames . isEmpty ( ) : <str> ; try { indexShard . postRecovery ( <str> ) ; } finally { decRef ( ) ; } listener . onRecoveryDone ( state ( ) ) ; } } public String getTempNameForFile ( String origFile ) { return tempFilePrefix + origFile ; } public IndexOutput getOpenIndexOutput ( String key ) { ensureRefCount ( ) ; return openIndexOutputs . get ( key ) ; } public IndexOutput removeOpenIndexOutputs ( String name ) { ensureRefCount ( ) ; return openIndexOutputs . remove ( name ) ; } public IndexOutput openAndPutIndexOutput ( String fileName , StoreFileMetaData metaData , Store store ) throws IOException { ensureRefCount ( ) ; String tempFileName = getTempNameForFile ( fileName ) ; if ( tempFileNames . containsKey ( tempFileName ) ) { throw new IllegalStateException ( <str> + fileName + <str> ) ; } tempFileNames . put ( tempFileName , fileName ) ; IndexOutput indexOutput = store . createVerifyingOutput ( tempFileName , metaData , IOContext . DEFAULT ) ; openIndexOutputs . put ( fileName , indexOutput ) ; return indexOutput ; } public void resetRecovery ( ) throws IOException { cleanOpenFiles ( ) ; indexShard ( ) . performRecoveryRestart ( ) ; } @Override protected void closeInternal ( ) { try { cleanOpenFiles ( ) ; } finally { store . decRef ( ) ; indexShard . recoveryStats ( ) . decCurrentAsTarget ( ) ; } } protected void cleanOpenFiles ( ) { Iterator < Entry < String , IndexOutput > > iterator = openIndexOutputs . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , IndexOutput > entry = iterator . next ( ) ; logger . trace ( <str> , entry . getValue ( ) ) ; try { entry . getValue ( ) . close ( ) ; } catch ( Throwable t ) { logger . debug ( <str> , t , entry . getValue ( ) ) ; } iterator . remove ( ) ; } for ( String file : tempFileNames . keySet ( ) ) { logger . trace ( <str> , file ) ; store . deleteQuiet ( file ) ; } legacyChecksums . clear ( ) ; } @Override public String toString ( ) { return shardId + <str> + recoveryId + <str> ; } private void ensureRefCount ( ) { if ( refCount ( ) < = <int> ) { throw new ElasticsearchException ( <str> ) ; } } } 
