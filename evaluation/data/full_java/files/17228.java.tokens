package org . jbox2d . dynamics . joints ; import org . jbox2d . common . Mat22 ; import org . jbox2d . common . Mat33 ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Vec2 ; import org . jbox2d . common . Vec3 ; import org . jbox2d . dynamics . Body ; import org . jbox2d . dynamics . SolverData ; import org . jbox2d . pooling . IWorldPool ; public class PrismaticJoint extends Joint { protected final Vec2 m_localAnchorA ; protected final Vec2 m_localAnchorB ; protected final Vec2 m_localXAxisA ; protected final Vec2 m_localYAxisA ; protected float m_referenceAngle ; private final Vec3 m_impulse ; private float m_motorImpulse ; private float m_lowerTranslation ; private float m_upperTranslation ; private float m_maxMotorForce ; private float m_motorSpeed ; private boolean m_enableLimit ; private boolean m_enableMotor ; private LimitState m_limitState ; private int m_indexA ; private int m_indexB ; private final Vec2 m_localCenterA = new Vec2 ( ) ; private final Vec2 m_localCenterB = new Vec2 ( ) ; private float m_invMassA ; private float m_invMassB ; private float m_invIA ; private float m_invIB ; private final Vec2 m_axis , m_perp ; private float m_s1 , m_s2 ; private float m_a1 , m_a2 ; private final Mat33 m_K ; private float m_motorMass ; protected PrismaticJoint ( IWorldPool argWorld , PrismaticJointDef def ) { super ( argWorld , def ) ; m_localAnchorA = new Vec2 ( def . localAnchorA ) ; m_localAnchorB = new Vec2 ( def . localAnchorB ) ; m_localXAxisA = new Vec2 ( def . localAxisA ) ; m_localXAxisA . normalize ( ) ; m_localYAxisA = new Vec2 ( ) ; Vec2 . crossToOutUnsafe ( <float> , m_localXAxisA , m_localYAxisA ) ; m_referenceAngle = def . referenceAngle ; m_impulse = new Vec3 ( ) ; m_motorMass = <float> ; m_motorImpulse = <float> ; m_lowerTranslation = def . lowerTranslation ; m_upperTranslation = def . upperTranslation ; m_maxMotorForce = def . maxMotorForce ; m_motorSpeed = def . motorSpeed ; m_enableLimit = def . enableLimit ; m_enableMotor = def . enableMotor ; m_limitState = LimitState . INACTIVE ; m_K = new Mat33 ( ) ; m_axis = new Vec2 ( ) ; m_perp = new Vec2 ( ) ; } public Vec2 getLocalAnchorA ( ) { return m_localAnchorA ; } public Vec2 getLocalAnchorB ( ) { return m_localAnchorB ; } @Override public void getAnchorA ( Vec2 argOut ) { m_bodyA . getWorldPointToOut ( m_localAnchorA , argOut ) ; } @Override public void getAnchorB ( Vec2 argOut ) { m_bodyB . getWorldPointToOut ( m_localAnchorB , argOut ) ; } @Override public void getReactionForce ( float inv_dt , Vec2 argOut ) { Vec2 temp = pool . popVec2 ( ) ; temp . set ( m_axis ) . mulLocal ( m_motorImpulse + m_impulse . z ) ; argOut . set ( m_perp ) . mulLocal ( m_impulse . x ) . addLocal ( temp ) . mulLocal ( inv_dt ) ; pool . pushVec2 ( <int> ) ; } @Override public float getReactionTorque ( float inv_dt ) { return inv_dt * m_impulse . y ; } public float getJointSpeed ( ) { Body bA = m_bodyA ; Body bB = m_bodyB ; Vec2 temp = pool . popVec2 ( ) ; Vec2 rA = pool . popVec2 ( ) ; Vec2 rB = pool . popVec2 ( ) ; Vec2 p1 = pool . popVec2 ( ) ; Vec2 p2 = pool . popVec2 ( ) ; Vec2 d = pool . popVec2 ( ) ; Vec2 axis = pool . popVec2 ( ) ; Vec2 temp2 = pool . popVec2 ( ) ; Vec2 temp3 = pool . popVec2 ( ) ; temp . set ( m_localAnchorA ) . subLocal ( bA . m_sweep . localCenter ) ; Rot . mulToOutUnsafe ( bA . m_xf . q , temp , rA ) ; temp . set ( m_localAnchorB ) . subLocal ( bB . m_sweep . localCenter ) ; Rot . mulToOutUnsafe ( bB . m_xf . q , temp , rB ) ; p1 . set ( bA . m_sweep . c ) . addLocal ( rA ) ; p2 . set ( bB . m_sweep . c ) . addLocal ( rB ) ; d . set ( p2 ) . subLocal ( p1 ) ; Rot . mulToOutUnsafe ( bA . m_xf . q , m_localXAxisA , axis ) ; Vec2 vA = bA . m_linearVelocity ; Vec2 vB = bB . m_linearVelocity ; float wA = bA . m_angularVelocity ; float wB = bB . m_angularVelocity ; Vec2 . crossToOutUnsafe ( wA , axis , temp ) ; Vec2 . crossToOutUnsafe ( wB , rB , temp2 ) ; Vec2 . crossToOutUnsafe ( wA , rA , temp3 ) ; temp2 . addLocal ( vB ) . subLocal ( vA ) . subLocal ( temp3 ) ; float speed = Vec2 . dot ( d , temp ) + Vec2 . dot ( axis , temp2 ) ; pool . pushVec2 ( <int> ) ; return speed ; } public float getJointTranslation ( ) { Vec2 pA = pool . popVec2 ( ) , pB = pool . popVec2 ( ) , axis = pool . popVec2 ( ) ; m_bodyA . getWorldPointToOut ( m_localAnchorA , pA ) ; m_bodyB . getWorldPointToOut ( m_localAnchorB , pB ) ; m_bodyA . getWorldVectorToOutUnsafe ( m_localXAxisA , axis ) ; pB . subLocal ( pA ) ; float translation = Vec2 . dot ( pB , axis ) ; pool . pushVec2 ( <int> ) ; return translation ; } public boolean isLimitEnabled ( ) { return m_enableLimit ; } public void enableLimit ( boolean flag ) { if ( flag ! = m_enableLimit ) { m_bodyA . setAwake ( true ) ; m_bodyB . setAwake ( true ) ; m_enableLimit = flag ; m_impulse . z = <float> ; } } public float getLowerLimit ( ) { return m_lowerTranslation ; } public float getUpperLimit ( ) { return m_upperTranslation ; } public void setLimits ( float lower , float upper ) { assert ( lower < = upper ) ; if ( lower ! = m_lowerTranslation | | upper ! = m_upperTranslation ) { m_bodyA . setAwake ( true ) ; m_bodyB . setAwake ( true ) ; m_lowerTranslation = lower ; m_upperTranslation = upper ; m_impulse . z = <float> ; } } public boolean isMotorEnabled ( ) { return m_enableMotor ; } public void enableMotor ( boolean flag ) { m_bodyA . setAwake ( true ) ; m_bodyB . setAwake ( true ) ; m_enableMotor = flag ; } public void setMotorSpeed ( float speed ) { m_bodyA . setAwake ( true ) ; m_bodyB . setAwake ( true ) ; m_motorSpeed = speed ; } public float getMotorSpeed ( ) { return m_motorSpeed ; } public void setMaxMotorForce ( float force ) { m_bodyA . setAwake ( true ) ; m_bodyB . setAwake ( true ) ; m_maxMotorForce = force ; } public float getMotorForce ( float inv_dt ) { return m_motorImpulse * inv_dt ; } public float getMaxMotorForce ( ) { return m_maxMotorForce ; } public float getReferenceAngle ( ) { return m_referenceAngle ; } public Vec2 getLocalAxisA ( ) { return m_localXAxisA ; } @Override public void initVelocityConstraints ( final SolverData data ) { m_indexA = m_bodyA . m_islandIndex ; m_indexB = m_bodyB . m_islandIndex ; m_localCenterA . set ( m_bodyA . m_sweep . localCenter ) ; m_localCenterB . set ( m_bodyB . m_sweep . localCenter ) ; m_invMassA = m_bodyA . m_invMass ; m_invMassB = m_bodyB . m_invMass ; m_invIA = m_bodyA . m_invI ; m_invIB = m_bodyB . m_invI ; Vec2 cA = data . positions [ m_indexA ] . c ; float aA = data . positions [ m_indexA ] . a ; Vec2 vA = data . velocities [ m_indexA ] . v ; float wA = data . velocities [ m_indexA ] . w ; Vec2 cB = data . positions [ m_indexB ] . c ; float aB = data . positions [ m_indexB ] . a ; Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; final Rot qA = pool . popRot ( ) ; final Rot qB = pool . popRot ( ) ; final Vec2 d = pool . popVec2 ( ) ; final Vec2 temp = pool . popVec2 ( ) ; final Vec2 rA = pool . popVec2 ( ) ; final Vec2 rB = pool . popVec2 ( ) ; qA . set ( aA ) ; qB . set ( aB ) ; Rot . mulToOutUnsafe ( qA , d . set ( m_localAnchorA ) . subLocal ( m_localCenterA ) , rA ) ; Rot . mulToOutUnsafe ( qB , d . set ( m_localAnchorB ) . subLocal ( m_localCenterB ) , rB ) ; d . set ( cB ) . subLocal ( cA ) . addLocal ( rB ) . subLocal ( rA ) ; float mA = m_invMassA , mB = m_invMassB ; float iA = m_invIA , iB = m_invIB ; { Rot . mulToOutUnsafe ( qA , m_localXAxisA , m_axis ) ; temp . set ( d ) . addLocal ( rA ) ; m_a1 = Vec2 . cross ( temp , m_axis ) ; m_a2 = Vec2 . cross ( rB , m_axis ) ; m_motorMass = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2 ; if ( m_motorMass > <float> ) { m_motorMass = <float> / m_motorMass ; } } { Rot . mulToOutUnsafe ( qA , m_localYAxisA , m_perp ) ; temp . set ( d ) . addLocal ( rA ) ; m_s1 = Vec2 . cross ( temp , m_perp ) ; m_s2 = Vec2 . cross ( rB , m_perp ) ; float k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2 ; float k12 = iA * m_s1 + iB * m_s2 ; float k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2 ; float k22 = iA + iB ; if ( k22 = = <float> ) { k22 = <float> ; } float k23 = iA * m_a1 + iB * m_a2 ; float k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2 ; m_K . ex . set ( k11 , k12 , k13 ) ; m_K . ey . set ( k12 , k22 , k23 ) ; m_K . ez . set ( k13 , k23 , k33 ) ; } if ( m_enableLimit ) { float jointTranslation = Vec2 . dot ( m_axis , d ) ; if ( MathUtils . abs ( m_upperTranslation - m_lowerTranslation ) < <float> * Settings . linearSlop ) { m_limitState = LimitState . EQUAL ; } else if ( jointTranslation < = m_lowerTranslation ) { if ( m_limitState ! = LimitState . AT_LOWER ) { m_limitState = LimitState . AT_LOWER ; m_impulse . z = <float> ; } } else if ( jointTranslation > = m_upperTranslation ) { if ( m_limitState ! = LimitState . AT_UPPER ) { m_limitState = LimitState . AT_UPPER ; m_impulse . z = <float> ; } } else { m_limitState = LimitState . INACTIVE ; m_impulse . z = <float> ; } } else { m_limitState = LimitState . INACTIVE ; m_impulse . z = <float> ; } if ( m_enableMotor = = false ) { m_motorImpulse = <float> ; } if ( data . step . warmStarting ) { m_impulse . mulLocal ( data . step . dtRatio ) ; m_motorImpulse * = data . step . dtRatio ; final Vec2 P = pool . popVec2 ( ) ; temp . set ( m_axis ) . mulLocal ( m_motorImpulse + m_impulse . z ) ; P . set ( m_perp ) . mulLocal ( m_impulse . x ) . addLocal ( temp ) ; float LA = m_impulse . x * m_s1 + m_impulse . y + ( m_motorImpulse + m_impulse . z ) * m_a1 ; float LB = m_impulse . x * m_s2 + m_impulse . y + ( m_motorImpulse + m_impulse . z ) * m_a2 ; vA . x - = mA * P . x ; vA . y - = mA * P . y ; wA - = iA * LA ; vB . x + = mB * P . x ; vB . y + = mB * P . y ; wB + = iB * LB ; pool . pushVec2 ( <int> ) ; } else { m_impulse . setZero ( ) ; m_motorImpulse = <float> ; } data . velocities [ m_indexA ] . w = wA ; data . velocities [ m_indexB ] . w = wB ; pool . pushRot ( <int> ) ; pool . pushVec2 ( <int> ) ; } @Override public void solveVelocityConstraints ( final SolverData data ) { Vec2 vA = data . velocities [ m_indexA ] . v ; float wA = data . velocities [ m_indexA ] . w ; Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; float mA = m_invMassA , mB = m_invMassB ; float iA = m_invIA , iB = m_invIB ; final Vec2 temp = pool . popVec2 ( ) ; if ( m_enableMotor & & m_limitState ! = LimitState . EQUAL ) { temp . set ( vB ) . subLocal ( vA ) ; float Cdot = Vec2 . dot ( m_axis , temp ) + m_a2 * wB - m_a1 * wA ; float impulse = m_motorMass * ( m_motorSpeed - Cdot ) ; float oldImpulse = m_motorImpulse ; float maxImpulse = data . step . dt * m_maxMotorForce ; m_motorImpulse = MathUtils . clamp ( m_motorImpulse + impulse , - maxImpulse , maxImpulse ) ; impulse = m_motorImpulse - oldImpulse ; final Vec2 P = pool . popVec2 ( ) ; P . set ( m_axis ) . mulLocal ( impulse ) ; float LA = impulse * m_a1 ; float LB = impulse * m_a2 ; vA . x - = mA * P . x ; vA . y - = mA * P . y ; wA - = iA * LA ; vB . x + = mB * P . x ; vB . y + = mB * P . y ; wB + = iB * LB ; pool . pushVec2 ( <int> ) ; } final Vec2 Cdot1 = pool . popVec2 ( ) ; temp . set ( vB ) . subLocal ( vA ) ; Cdot1 . x = Vec2 . dot ( m_perp , temp ) + m_s2 * wB - m_s1 * wA ; Cdot1 . y = wB - wA ; if ( m_enableLimit & & m_limitState ! = LimitState . INACTIVE ) { float Cdot2 ; temp . set ( vB ) . subLocal ( vA ) ; Cdot2 = Vec2 . dot ( m_axis , temp ) + m_a2 * wB - m_a1 * wA ; final Vec3 Cdot = pool . popVec3 ( ) ; Cdot . set ( Cdot1 . x , Cdot1 . y , Cdot2 ) ; final Vec3 f1 = pool . popVec3 ( ) ; final Vec3 df = pool . popVec3 ( ) ; f1 . set ( m_impulse ) ; m_K . solve33ToOut ( Cdot . negateLocal ( ) , df ) ; m_impulse . addLocal ( df ) ; if ( m_limitState = = LimitState . AT_LOWER ) { m_impulse . z = MathUtils . max ( m_impulse . z , <float> ) ; } else if ( m_limitState = = LimitState . AT_UPPER ) { m_impulse . z = MathUtils . min ( m_impulse . z , <float> ) ; } final Vec2 b = pool . popVec2 ( ) ; final Vec2 f2r = pool . popVec2 ( ) ; temp . set ( m_K . ez . x , m_K . ez . y ) . mulLocal ( m_impulse . z - f1 . z ) ; b . set ( Cdot1 ) . negateLocal ( ) . subLocal ( temp ) ; m_K . solve22ToOut ( b , f2r ) ; f2r . addLocal ( f1 . x , f1 . y ) ; m_impulse . x = f2r . x ; m_impulse . y = f2r . y ; df . set ( m_impulse ) . subLocal ( f1 ) ; final Vec2 P = pool . popVec2 ( ) ; temp . set ( m_axis ) . mulLocal ( df . z ) ; P . set ( m_perp ) . mulLocal ( df . x ) . addLocal ( temp ) ; float LA = df . x * m_s1 + df . y + df . z * m_a1 ; float LB = df . x * m_s2 + df . y + df . z * m_a2 ; vA . x - = mA * P . x ; vA . y - = mA * P . y ; wA - = iA * LA ; vB . x + = mB * P . x ; vB . y + = mB * P . y ; wB + = iB * LB ; pool . pushVec2 ( <int> ) ; pool . pushVec3 ( <int> ) ; } else { final Vec2 df = pool . popVec2 ( ) ; m_K . solve22ToOut ( Cdot1 . negateLocal ( ) , df ) ; Cdot1 . negateLocal ( ) ; m_impulse . x + = df . x ; m_impulse . y + = df . y ; final Vec2 P = pool . popVec2 ( ) ; P . set ( m_perp ) . mulLocal ( df . x ) ; float LA = df . x * m_s1 + df . y ; float LB = df . x * m_s2 + df . y ; vA . x - = mA * P . x ; vA . y - = mA * P . y ; wA - = iA * LA ; vB . x + = mB * P . x ; vB . y + = mB * P . y ; wB + = iB * LB ; pool . pushVec2 ( <int> ) ; } data . velocities [ m_indexA ] . w = wA ; data . velocities [ m_indexB ] . w = wB ; pool . pushVec2 ( <int> ) ; } @Override public boolean solvePositionConstraints ( final SolverData data ) { final Rot qA = pool . popRot ( ) ; final Rot qB = pool . popRot ( ) ; final Vec2 rA = pool . popVec2 ( ) ; final Vec2 rB = pool . popVec2 ( ) ; final Vec2 d = pool . popVec2 ( ) ; final Vec2 axis = pool . popVec2 ( ) ; final Vec2 perp = pool . popVec2 ( ) ; final Vec2 temp = pool . popVec2 ( ) ; final Vec2 C1 = pool . popVec2 ( ) ; final Vec3 impulse = pool . popVec3 ( ) ; Vec2 cA = data . positions [ m_indexA ] . c ; float aA = data . positions [ m_indexA ] . a ; Vec2 cB = data . positions [ m_indexB ] . c ; float aB = data . positions [ m_indexB ] . a ; qA . set ( aA ) ; qB . set ( aB ) ; float mA = m_invMassA , mB = m_invMassB ; float iA = m_invIA , iB = m_invIB ; Rot . mulToOutUnsafe ( qA , temp . set ( m_localAnchorA ) . subLocal ( m_localCenterA ) , rA ) ; Rot . mulToOutUnsafe ( qB , temp . set ( m_localAnchorB ) . subLocal ( m_localCenterB ) , rB ) ; d . set ( cB ) . addLocal ( rB ) . subLocal ( cA ) . subLocal ( rA ) ; Rot . mulToOutUnsafe ( qA , m_localXAxisA , axis ) ; float a1 = Vec2 . cross ( temp . set ( d ) . addLocal ( rA ) , axis ) ; float a2 = Vec2 . cross ( rB , axis ) ; Rot . mulToOutUnsafe ( qA , m_localYAxisA , perp ) ; float s1 = Vec2 . cross ( temp . set ( d ) . addLocal ( rA ) , perp ) ; float s2 = Vec2 . cross ( rB , perp ) ; C1 . x = Vec2 . dot ( perp , d ) ; C1 . y = aB - aA - m_referenceAngle ; float linearError = MathUtils . abs ( C1 . x ) ; float angularError = MathUtils . abs ( C1 . y ) ; boolean active = false ; float C2 = <float> ; if ( m_enableLimit ) { float translation = Vec2 . dot ( axis , d ) ; if ( MathUtils . abs ( m_upperTranslation - m_lowerTranslation ) < <float> * Settings . linearSlop ) { C2 = MathUtils . clamp ( translation , - Settings . maxLinearCorrection , Settings . maxLinearCorrection ) ; linearError = MathUtils . max ( linearError , MathUtils . abs ( translation ) ) ; active = true ; } else if ( translation < = m_lowerTranslation ) { C2 = MathUtils . clamp ( translation - m_lowerTranslation + Settings . linearSlop , - Settings . maxLinearCorrection , <float> ) ; linearError = MathUtils . max ( linearError , m_lowerTranslation - translation ) ; active = true ; } else if ( translation > = m_upperTranslation ) { C2 = MathUtils . clamp ( translation - m_upperTranslation - Settings . linearSlop , <float> , Settings . maxLinearCorrection ) ; linearError = MathUtils . max ( linearError , translation - m_upperTranslation ) ; active = true ; } } if ( active ) { float k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2 ; float k12 = iA * s1 + iB * s2 ; float k13 = iA * s1 * a1 + iB * s2 * a2 ; float k22 = iA + iB ; if ( k22 = = <float> ) { k22 = <float> ; } float k23 = iA * a1 + iB * a2 ; float k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2 ; final Mat33 K = pool . popMat33 ( ) ; K . ex . set ( k11 , k12 , k13 ) ; K . ey . set ( k12 , k22 , k23 ) ; K . ez . set ( k13 , k23 , k33 ) ; final Vec3 C = pool . popVec3 ( ) ; C . x = C1 . x ; C . y = C1 . y ; C . z = C2 ; K . solve33ToOut ( C . negateLocal ( ) , impulse ) ; pool . pushVec3 ( <int> ) ; pool . pushMat33 ( <int> ) ; } else { float k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2 ; float k12 = iA * s1 + iB * s2 ; float k22 = iA + iB ; if ( k22 = = <float> ) { k22 = <float> ; } final Mat22 K = pool . popMat22 ( ) ; K . ex . set ( k11 , k12 ) ; K . ey . set ( k12 , k22 ) ; K . solveToOut ( C1 . negateLocal ( ) , temp ) ; C1 . negateLocal ( ) ; impulse . x = temp . x ; impulse . y = temp . y ; impulse . z = <float> ; pool . pushMat22 ( <int> ) ; } float Px = impulse . x * perp . x + impulse . z * axis . x ; float Py = impulse . x * perp . y + impulse . z * axis . y ; float LA = impulse . x * s1 + impulse . y + impulse . z * a1 ; float LB = impulse . x * s2 + impulse . y + impulse . z * a2 ; cA . x - = mA * Px ; cA . y - = mA * Py ; aA - = iA * LA ; cB . x + = mB * Px ; cB . y + = mB * Py ; aB + = iB * LB ; data . positions [ m_indexA ] . a = aA ; data . positions [ m_indexB ] . a = aB ; pool . pushVec2 ( <int> ) ; pool . pushVec3 ( <int> ) ; pool . pushRot ( <int> ) ; return linearError < = Settings . linearSlop & & angularError < = Settings . angularSlop ; } } 
