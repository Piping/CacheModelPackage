package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import com . google . common . base . Equivalence ; import com . google . common . base . Function ; import com . google . common . collect . MapMaker . RemovalCause ; import com . google . common . collect . MapMaker . RemovalListener ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . lang . ref . ReferenceQueue ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicReferenceArray ; import javax . annotation . Nullable ; import javax . annotation . concurrent . GuardedBy ; class ComputingConcurrentHashMap < K , V > extends MapMakerInternalMap < K , V > { final Function < ? super K , ? extends V > computingFunction ; ComputingConcurrentHashMap ( MapMaker builder , Function < ? super K , ? extends V > computingFunction ) { super ( builder ) ; this . computingFunction = checkNotNull ( computingFunction ) ; } @Override Segment < K , V > createSegment ( int initialCapacity , int maxSegmentSize ) { return new ComputingSegment < K , V > ( this , initialCapacity , maxSegmentSize ) ; } @Override ComputingSegment < K , V > segmentFor ( int hash ) { return ( ComputingSegment < K , V > ) super . segmentFor ( hash ) ; } V getOrCompute ( K key ) throws ExecutionException { int hash = hash ( checkNotNull ( key ) ) ; return segmentFor ( hash ) . getOrCompute ( key , hash , computingFunction ) ; } @SuppressWarnings ( <str> ) static final class ComputingSegment < K , V > extends Segment < K , V > { ComputingSegment ( MapMakerInternalMap < K , V > map , int initialCapacity , int maxSegmentSize ) { super ( map , initialCapacity , maxSegmentSize ) ; } V getOrCompute ( K key , int hash , Function < ? super K , ? extends V > computingFunction ) throws ExecutionException { try { outer : while ( true ) { ReferenceEntry < K , V > e = getEntry ( key , hash ) ; if ( e ! = null ) { V value = getLiveValue ( e ) ; if ( value ! = null ) { recordRead ( e ) ; return value ; } } if ( e = = null | | ! e . getValueReference ( ) . isComputingReference ( ) ) { boolean createNewEntry = true ; ComputingValueReference < K , V > computingValueReference = null ; lock ( ) ; try { preWriteCleanup ( ) ; int newCount = this . count - <int> ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this . table ; int index = hash & ( table . length ( ) - <int> ) ; ReferenceEntry < K , V > first = table . get ( index ) ; for ( e = first ; e ! = null ; e = e . getNext ( ) ) { K entryKey = e . getKey ( ) ; if ( e . getHash ( ) = = hash & & entryKey ! = null & & map . keyEquivalence . equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e . getValueReference ( ) ; if ( valueReference . isComputingReference ( ) ) { createNewEntry = false ; } else { V value = e . getValueReference ( ) . get ( ) ; if ( value = = null ) { enqueueNotification ( entryKey , hash , value , RemovalCause . COLLECTED ) ; } else if ( map . expires ( ) & & map . isExpired ( e ) ) { enqueueNotification ( entryKey , hash , value , RemovalCause . EXPIRED ) ; } else { recordLockedRead ( e ) ; return value ; } evictionQueue . remove ( e ) ; expirationQueue . remove ( e ) ; this . count = newCount ; } break ; } } if ( createNewEntry ) { computingValueReference = new ComputingValueReference < K , V > ( computingFunction ) ; if ( e = = null ) { e = newEntry ( key , hash , first ) ; e . setValueReference ( computingValueReference ) ; table . set ( index , e ) ; } else { e . setValueReference ( computingValueReference ) ; } } } finally { unlock ( ) ; postWriteCleanup ( ) ; } if ( createNewEntry ) { return compute ( key , hash , e , computingValueReference ) ; } } checkState ( ! Thread . holdsLock ( e ) , <str> ) ; V value = e . getValueReference ( ) . waitForValue ( ) ; if ( value ! = null ) { recordRead ( e ) ; return value ; } continue outer ; } } finally { postReadCleanup ( ) ; } } V compute ( K key , int hash , ReferenceEntry < K , V > e , ComputingValueReference < K , V > computingValueReference ) throws ExecutionException { V value = null ; long start = System . nanoTime ( ) ; long end = <int> ; try { synchronized ( e ) { value = computingValueReference . compute ( key , hash ) ; end = System . nanoTime ( ) ; } if ( value ! = null ) { V oldValue = put ( key , hash , value , true ) ; if ( oldValue ! = null ) { enqueueNotification ( key , hash , value , RemovalCause . REPLACED ) ; } } return value ; } finally { if ( end = = <int> ) { end = System . nanoTime ( ) ; } if ( value = = null ) { clearValue ( key , hash , computingValueReference ) ; } } } } private static final class ComputationExceptionReference < K , V > implements ValueReference < K , V > { final Throwable t ; ComputationExceptionReference ( Throwable t ) { this . t = t ; } @Override public V get ( ) { return null ; } @Override public ReferenceEntry < K , V > getEntry ( ) { return null ; } @Override public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return this ; } @Override public boolean isComputingReference ( ) { return false ; } @Override public V waitForValue ( ) throws ExecutionException { throw new ExecutionException ( t ) ; } @Override public void clear ( ValueReference < K , V > newValue ) { } } private static final class ComputedReference < K , V > implements ValueReference < K , V > { final V value ; ComputedReference ( @Nullable V value ) { this . value = value ; } @Override public V get ( ) { return value ; } @Override public ReferenceEntry < K , V > getEntry ( ) { return null ; } @Override public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return this ; } @Override public boolean isComputingReference ( ) { return false ; } @Override public V waitForValue ( ) { return get ( ) ; } @Override public void clear ( ValueReference < K , V > newValue ) { } } private static final class ComputingValueReference < K , V > implements ValueReference < K , V > { final Function < ? super K , ? extends V > computingFunction ; @GuardedBy ( <str> ) volatile ValueReference < K , V > computedReference = unset ( ) ; public ComputingValueReference ( Function < ? super K , ? extends V > computingFunction ) { this . computingFunction = computingFunction ; } @Override public V get ( ) { return null ; } @Override public ReferenceEntry < K , V > getEntry ( ) { return null ; } @Override public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , @Nullable V value , ReferenceEntry < K , V > entry ) { return this ; } @Override public boolean isComputingReference ( ) { return true ; } @Override public V waitForValue ( ) throws ExecutionException { if ( computedReference = = UNSET ) { boolean interrupted = false ; try { synchronized ( this ) { while ( computedReference = = UNSET ) { try { wait ( ) ; } catch ( InterruptedException ie ) { interrupted = true ; } } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } return computedReference . waitForValue ( ) ; } @Override public void clear ( ValueReference < K , V > newValue ) { setValueReference ( newValue ) ; } V compute ( K key , int hash ) throws ExecutionException { V value ; try { value = computingFunction . apply ( key ) ; } catch ( Throwable t ) { setValueReference ( new ComputationExceptionReference < K , V > ( t ) ) ; throw new ExecutionException ( t ) ; } setValueReference ( new ComputedReference < K , V > ( value ) ) ; return value ; } void setValueReference ( ValueReference < K , V > valueReference ) { synchronized ( this ) { if ( computedReference = = UNSET ) { computedReference = valueReference ; notifyAll ( ) ; } } } } private static final long serialVersionUID = <int> ; @Override Object writeReplace ( ) { return new ComputingSerializationProxy < K , V > ( keyStrength , valueStrength , keyEquivalence , valueEquivalence , expireAfterWriteNanos , expireAfterAccessNanos , maximumSize , concurrencyLevel , removalListener , this , computingFunction ) ; } static final class ComputingSerializationProxy < K , V > extends AbstractSerializationProxy < K , V > { final Function < ? super K , ? extends V > computingFunction ; ComputingSerializationProxy ( Strength keyStrength , Strength valueStrength , Equivalence < Object > keyEquivalence , Equivalence < Object > valueEquivalence , long expireAfterWriteNanos , long expireAfterAccessNanos , int maximumSize , int concurrencyLevel , RemovalListener < ? super K , ? super V > removalListener , ConcurrentMap < K , V > delegate , Function < ? super K , ? extends V > computingFunction ) { super ( keyStrength , valueStrength , keyEquivalence , valueEquivalence , expireAfterWriteNanos , expireAfterAccessNanos , maximumSize , concurrencyLevel , removalListener , delegate ) ; this . computingFunction = computingFunction ; } private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; writeMapTo ( out ) ; } @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; MapMaker mapMaker = readMapMaker ( in ) ; delegate = mapMaker . makeComputingMap ( computingFunction ) ; readEntries ( in ) ; } Object readResolve ( ) { return delegate ; } private static final long serialVersionUID = <int> ; } } 
