package io . netty . util . internal ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . chmv8 . ConcurrentHashMapV8 ; import io . netty . util . internal . chmv8 . LongAdderV8 ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . Deque ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Queue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentLinkedDeque ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static io . netty . util . internal . PlatformDependent0 . HASH_CODE_ASCII_SEED ; import static io . netty . util . internal . PlatformDependent0 . hashCodeAsciiCompute ; import static io . netty . util . internal . PlatformDependent0 . hashCodeAsciiSanitize ; import static io . netty . util . internal . PlatformDependent0 . hashCodeAsciiSanitizeAsByte ; public final class PlatformDependent { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PlatformDependent . class ) ; private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern . compile ( <str> ) ; private static final boolean IS_ANDROID = isAndroid0 ( ) ; private static final boolean IS_WINDOWS = isWindows0 ( ) ; private static volatile Boolean IS_ROOT ; private static final int JAVA_VERSION = javaVersion0 ( ) ; private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = ! isAndroid ( ) ; private static final boolean HAS_UNSAFE = hasUnsafe0 ( ) ; private static final boolean CAN_USE_CHM_V8 = HAS_UNSAFE & & JAVA_VERSION < <int> ; private static final boolean DIRECT_BUFFER_PREFERRED = HAS_UNSAFE & & ! SystemPropertyUtil . getBoolean ( <str> , false ) ; private static final long MAX_DIRECT_MEMORY = maxDirectMemory0 ( ) ; private static final long BYTE_ARRAY_BASE_OFFSET = PlatformDependent0 . byteArrayBaseOffset ( ) ; private static final boolean HAS_JAVASSIST = hasJavassist0 ( ) ; private static final File TMPDIR = tmpdir0 ( ) ; private static final int BIT_MODE = bitMode0 ( ) ; private static final int ADDRESS_SIZE = addressSize0 ( ) ; public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder . nativeOrder ( ) = = ByteOrder . BIG_ENDIAN ; static { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ! DIRECT_BUFFER_PREFERRED ) ; } if ( ! hasUnsafe ( ) & & ! isAndroid ( ) ) { logger . info ( <str> + <str> + <str> ) ; } } public static boolean isAndroid ( ) { return IS_ANDROID ; } public static boolean isWindows ( ) { return IS_WINDOWS ; } public static boolean isRoot ( ) { if ( IS_ROOT = = null ) { synchronized ( PlatformDependent . class ) { if ( IS_ROOT = = null ) { IS_ROOT = isRoot0 ( ) ; } } } return IS_ROOT ; } public static int javaVersion ( ) { return JAVA_VERSION ; } public static boolean canEnableTcpNoDelayByDefault ( ) { return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT ; } public static boolean hasUnsafe ( ) { return HAS_UNSAFE ; } public static boolean isUnaligned ( ) { return PlatformDependent0 . isUnaligned ( ) ; } public static boolean directBufferPreferred ( ) { return DIRECT_BUFFER_PREFERRED ; } public static long maxDirectMemory ( ) { return MAX_DIRECT_MEMORY ; } public static boolean hasJavassist ( ) { return HAS_JAVASSIST ; } public static File tmpdir ( ) { return TMPDIR ; } public static int bitMode ( ) { return BIT_MODE ; } public static int addressSize ( ) { return ADDRESS_SIZE ; } public static long allocateMemory ( long size ) { return PlatformDependent0 . allocateMemory ( size ) ; } public static void freeMemory ( long address ) { PlatformDependent0 . freeMemory ( address ) ; } public static void throwException ( Throwable t ) { if ( hasUnsafe ( ) ) { PlatformDependent0 . throwException ( t ) ; } else { PlatformDependent . < RuntimeException > throwException0 ( t ) ; } } @SuppressWarnings ( <str> ) private static < E extends Throwable > void throwException0 ( Throwable t ) throws E { throw ( E ) t ; } public static < K , V > ConcurrentMap < K , V > newConcurrentHashMap ( ) { if ( CAN_USE_CHM_V8 ) { return new ConcurrentHashMapV8 < K , V > ( ) ; } else { return new ConcurrentHashMap < K , V > ( ) ; } } public static LongCounter newLongCounter ( ) { if ( HAS_UNSAFE ) { return new LongAdderV8 ( ) ; } else { return new AtomicLongCounter ( ) ; } } public static < K , V > ConcurrentMap < K , V > newConcurrentHashMap ( int initialCapacity ) { if ( CAN_USE_CHM_V8 ) { return new ConcurrentHashMapV8 < K , V > ( initialCapacity ) ; } else { return new ConcurrentHashMap < K , V > ( initialCapacity ) ; } } public static < K , V > ConcurrentMap < K , V > newConcurrentHashMap ( int initialCapacity , float loadFactor ) { if ( CAN_USE_CHM_V8 ) { return new ConcurrentHashMapV8 < K , V > ( initialCapacity , loadFactor ) ; } else { return new ConcurrentHashMap < K , V > ( initialCapacity , loadFactor ) ; } } public static < K , V > ConcurrentMap < K , V > newConcurrentHashMap ( int initialCapacity , float loadFactor , int concurrencyLevel ) { if ( CAN_USE_CHM_V8 ) { return new ConcurrentHashMapV8 < K , V > ( initialCapacity , loadFactor , concurrencyLevel ) ; } else { return new ConcurrentHashMap < K , V > ( initialCapacity , loadFactor , concurrencyLevel ) ; } } public static < K , V > ConcurrentMap < K , V > newConcurrentHashMap ( Map < ? extends K , ? extends V > map ) { if ( CAN_USE_CHM_V8 ) { return new ConcurrentHashMapV8 < K , V > ( map ) ; } else { return new ConcurrentHashMap < K , V > ( map ) ; } } public static void freeDirectBuffer ( ByteBuffer buffer ) { if ( hasUnsafe ( ) & & ! isAndroid ( ) ) { PlatformDependent0 . freeDirectBuffer ( buffer ) ; } } public static long directBufferAddress ( ByteBuffer buffer ) { return PlatformDependent0 . directBufferAddress ( buffer ) ; } public static Object getObject ( Object object , long fieldOffset ) { return PlatformDependent0 . getObject ( object , fieldOffset ) ; } public static Object getObjectVolatile ( Object object , long fieldOffset ) { return PlatformDependent0 . getObjectVolatile ( object , fieldOffset ) ; } public static int getInt ( Object object , long fieldOffset ) { return PlatformDependent0 . getInt ( object , fieldOffset ) ; } public static long objectFieldOffset ( Field field ) { return PlatformDependent0 . objectFieldOffset ( field ) ; } public static byte getByte ( long address ) { return PlatformDependent0 . getByte ( address ) ; } public static short getShort ( long address ) { return PlatformDependent0 . getShort ( address ) ; } public static int getInt ( long address ) { return PlatformDependent0 . getInt ( address ) ; } public static long getLong ( long address ) { return PlatformDependent0 . getLong ( address ) ; } public static byte getByte ( byte [ ] data , int index ) { return PlatformDependent0 . getByte ( data , index ) ; } public static short getShort ( byte [ ] data , int index ) { return PlatformDependent0 . getShort ( data , index ) ; } public static int getInt ( byte [ ] data , int index ) { return PlatformDependent0 . getInt ( data , index ) ; } public static long getLong ( byte [ ] data , int index ) { return PlatformDependent0 . getLong ( data , index ) ; } private static long getLongSafe ( byte [ ] bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return ( long ) bytes [ offset ] < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( long ) bytes [ offset + <int> ] & <hex> ; } return ( long ) bytes [ offset ] & <hex> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> | ( ( long ) bytes [ offset + <int> ] & <hex> ) < < <int> ; } private static long getLongFromBytesSafe ( CharSequence bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return ( long ) bytes . charAt ( offset ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( long ) bytes . charAt ( offset + <int> ) & <hex> ; } return ( long ) bytes . charAt ( offset ) & <hex> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( ( long ) bytes . charAt ( offset + <int> ) & <hex> ) < < <int> ; } private static int getIntSafe ( byte [ ] bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return bytes [ offset ] < < <int> | ( bytes [ offset + <int> ] & <hex> ) < < <int> | ( bytes [ offset + <int> ] & <hex> ) < < <int> | bytes [ offset + <int> ] & <hex> ; } return bytes [ offset ] & <hex> | ( bytes [ offset + <int> ] & <hex> ) < < <int> | ( bytes [ offset + <int> ] & <hex> ) < < <int> | bytes [ offset + <int> ] < < <int> ; } private static int getIntFromBytesSafe ( CharSequence bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return bytes . charAt ( offset ) < < <int> | ( bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | bytes . charAt ( offset + <int> ) & <hex> ; } return bytes . charAt ( offset ) & <hex> | ( bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | ( bytes . charAt ( offset + <int> ) & <hex> ) < < <int> | bytes . charAt ( offset + <int> ) < < <int> ; } private static short getShortSafe ( byte [ ] bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return ( short ) ( bytes [ offset ] < < <int> | ( bytes [ offset + <int> ] & <hex> ) ) ; } return ( short ) ( bytes [ offset ] & <hex> | ( bytes [ offset + <int> ] < < <int> ) ) ; } private static short getShortFromBytesSafe ( CharSequence bytes , int offset ) { if ( BIG_ENDIAN_NATIVE_ORDER ) { return ( short ) ( bytes . charAt ( offset ) < < <int> | ( bytes . charAt ( offset + <int> ) & <hex> ) ) ; } return ( short ) ( bytes . charAt ( offset ) & <hex> | ( bytes . charAt ( offset + <int> ) < < <int> ) ) ; } public static void putOrderedObject ( Object object , long address , Object value ) { PlatformDependent0 . putOrderedObject ( object , address , value ) ; } public static void putByte ( long address , byte value ) { PlatformDependent0 . putByte ( address , value ) ; } public static void putShort ( long address , short value ) { PlatformDependent0 . putShort ( address , value ) ; } public static void putInt ( long address , int value ) { PlatformDependent0 . putInt ( address , value ) ; } public static void putLong ( long address , long value ) { PlatformDependent0 . putLong ( address , value ) ; } public static void putByte ( byte [ ] data , int index , byte value ) { PlatformDependent0 . putByte ( data , index , value ) ; } public static void putShort ( byte [ ] data , int index , short value ) { PlatformDependent0 . putShort ( data , index , value ) ; } public static void putInt ( byte [ ] data , int index , int value ) { PlatformDependent0 . putInt ( data , index , value ) ; } public static void putLong ( byte [ ] data , int index , long value ) { PlatformDependent0 . putLong ( data , index , value ) ; } public static void copyMemory ( long srcAddr , long dstAddr , long length ) { PlatformDependent0 . copyMemory ( srcAddr , dstAddr , length ) ; } public static void copyMemory ( byte [ ] src , int srcIndex , long dstAddr , long length ) { PlatformDependent0 . copyMemory ( src , BYTE_ARRAY_BASE_OFFSET + srcIndex , null , dstAddr , length ) ; } public static void copyMemory ( long srcAddr , byte [ ] dst , int dstIndex , long length ) { PlatformDependent0 . copyMemory ( null , srcAddr , dst , BYTE_ARRAY_BASE_OFFSET + dstIndex , length ) ; } public static boolean equals ( byte [ ] bytes1 , int startPos1 , byte [ ] bytes2 , int startPos2 , int length ) { if ( ! hasUnsafe ( ) | | ! PlatformDependent0 . unalignedAccess ( ) ) { return equalsSafe ( bytes1 , startPos1 , bytes2 , startPos2 , length ) ; } return PlatformDependent0 . equals ( bytes1 , startPos1 , bytes2 , startPos2 , length ) ; } public static int hashCodeAscii ( byte [ ] bytes , int startPos , int length ) { if ( ! hasUnsafe ( ) | | ! PlatformDependent0 . unalignedAccess ( ) ) { return hashCodeAsciiSafe ( bytes , startPos , length ) ; } return PlatformDependent0 . hashCodeAscii ( bytes , startPos , length ) ; } public static int hashCodeAscii ( CharSequence bytes ) { char [ ] array ; if ( ! hasUnsafe ( ) | | ! PlatformDependent0 . unalignedAccess ( ) | | ( array = PlatformDependent0 . array ( bytes ) ) = = null ) { return hashCodeAsciiSafe ( bytes ) ; } return PlatformDependent0 . hashCodeAscii ( array ) ; } public static < U , W > AtomicReferenceFieldUpdater < U , W > newAtomicReferenceFieldUpdater ( Class < U > tclass , String fieldName ) { if ( hasUnsafe ( ) ) { try { return PlatformDependent0 . newAtomicReferenceFieldUpdater ( tclass , fieldName ) ; } catch ( Throwable ignore ) { } } return null ; } public static < T > AtomicIntegerFieldUpdater < T > newAtomicIntegerFieldUpdater ( Class < ? > tclass , String fieldName ) { if ( hasUnsafe ( ) ) { try { return PlatformDependent0 . newAtomicIntegerFieldUpdater ( tclass , fieldName ) ; } catch ( Throwable ignore ) { } } return null ; } public static < T > AtomicLongFieldUpdater < T > newAtomicLongFieldUpdater ( Class < ? > tclass , String fieldName ) { if ( hasUnsafe ( ) ) { try { return PlatformDependent0 . newAtomicLongFieldUpdater ( tclass , fieldName ) ; } catch ( Throwable ignore ) { } } return null ; } public static < T > Queue < T > newMpscQueue ( ) { return new MpscLinkedQueue < T > ( ) ; } public static < T > Queue < T > newFixedMpscQueue ( int capacity ) { if ( hasUnsafe ( ) ) { return new MpscArrayQueue < T > ( capacity ) ; } else { return new LinkedBlockingQueue < T > ( capacity ) ; } } public static ClassLoader getClassLoader ( final Class < ? > clazz ) { return PlatformDependent0 . getClassLoader ( clazz ) ; } public static ClassLoader getContextClassLoader ( ) { return PlatformDependent0 . getContextClassLoader ( ) ; } public static ClassLoader getSystemClassLoader ( ) { return PlatformDependent0 . getSystemClassLoader ( ) ; } public static < C > Deque < C > newConcurrentDeque ( ) { if ( javaVersion ( ) < <int> ) { return new LinkedBlockingDeque < C > ( ) ; } else { return new ConcurrentLinkedDeque < C > ( ) ; } } private static boolean isAndroid0 ( ) { boolean android ; try { Class . forName ( <str> , false , getSystemClassLoader ( ) ) ; android = true ; } catch ( Exception e ) { android = false ; } if ( android ) { logger . debug ( <str> ) ; } return android ; } private static boolean isWindows0 ( ) { boolean windows = SystemPropertyUtil . get ( <str> , <str> ) . toLowerCase ( Locale . US ) . contains ( <str> ) ; if ( windows ) { logger . debug ( <str> ) ; } return windows ; } private static boolean isRoot0 ( ) { if ( isWindows ( ) ) { return false ; } String [ ] ID_COMMANDS = { <str> , <str> , <str> , <str> } ; Pattern UID_PATTERN = Pattern . compile ( <str> ) ; for ( String idCmd : ID_COMMANDS ) { Process p = null ; BufferedReader in = null ; String uid = null ; try { p = Runtime . getRuntime ( ) . exec ( new String [ ] { idCmd , <str> } ) ; in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) , CharsetUtil . US_ASCII ) ) ; uid = in . readLine ( ) ; in . close ( ) ; for ( ; ; ) { try { int exitCode = p . waitFor ( ) ; if ( exitCode ! = <int> ) { uid = null ; } break ; } catch ( InterruptedException e ) { } } } catch ( Exception e ) { uid = null ; } finally { if ( in ! = null ) { try { in . close ( ) ; } catch ( IOException e ) { } } if ( p ! = null ) { try { p . destroy ( ) ; } catch ( Exception e ) { } } } if ( uid ! = null & & UID_PATTERN . matcher ( uid ) . matches ( ) ) { logger . debug ( <str> , uid ) ; return <str> . equals ( uid ) ; } } logger . debug ( <str> ) ; Pattern PERMISSION_DENIED = Pattern . compile ( <str> ) ; for ( int i = <int> ; i > <int> ; i - - ) { ServerSocket ss = null ; try { ss = new ServerSocket ( ) ; ss . setReuseAddress ( true ) ; ss . bind ( new InetSocketAddress ( i ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , i ) ; } return true ; } catch ( Exception e ) { String message = e . getMessage ( ) ; if ( message = = null ) { message = <str> ; } message = message . toLowerCase ( ) ; if ( PERMISSION_DENIED . matcher ( message ) . matches ( ) ) { break ; } } finally { if ( ss ! = null ) { try { ss . close ( ) ; } catch ( Exception e ) { } } } } logger . debug ( <str> ) ; return false ; } @SuppressWarnings ( <str> ) private static int javaVersion0 ( ) { int javaVersion ; for ( ; ; ) { if ( isAndroid ( ) ) { javaVersion = <int> ; break ; } try { Class . forName ( <str> , false , getClassLoader ( Object . class ) ) ; javaVersion = <int> ; break ; } catch ( Exception e ) { } try { Class . forName ( <str> , false , getClassLoader ( BlockingQueue . class ) ) ; javaVersion = <int> ; break ; } catch ( Exception e ) { } javaVersion = <int> ; break ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , javaVersion ) ; } return javaVersion ; } private static boolean hasUnsafe0 ( ) { boolean noUnsafe = SystemPropertyUtil . getBoolean ( <str> , false ) ; logger . debug ( <str> , noUnsafe ) ; if ( isAndroid ( ) ) { logger . debug ( <str> ) ; return false ; } if ( noUnsafe ) { logger . debug ( <str> ) ; return false ; } boolean tryUnsafe ; if ( SystemPropertyUtil . contains ( <str> ) ) { tryUnsafe = SystemPropertyUtil . getBoolean ( <str> , true ) ; } else { tryUnsafe = SystemPropertyUtil . getBoolean ( <str> , true ) ; } if ( ! tryUnsafe ) { logger . debug ( <str> ) ; return false ; } try { boolean hasUnsafe = PlatformDependent0 . hasUnsafe ( ) ; logger . debug ( <str> , hasUnsafe ? <str> : <str> ) ; return hasUnsafe ; } catch ( Throwable t ) { return false ; } } private static long maxDirectMemory0 ( ) { long maxDirectMemory = <int> ; try { Class < ? > vmClass = Class . forName ( <str> , true , getSystemClassLoader ( ) ) ; Method m = vmClass . getDeclaredMethod ( <str> ) ; maxDirectMemory = ( ( Number ) m . invoke ( null ) ) . longValue ( ) ; } catch ( Throwable t ) { } if ( maxDirectMemory > <int> ) { return maxDirectMemory ; } try { Class < ? > mgmtFactoryClass = Class . forName ( <str> , true , getSystemClassLoader ( ) ) ; Class < ? > runtimeClass = Class . forName ( <str> , true , getSystemClassLoader ( ) ) ; Object runtime = mgmtFactoryClass . getDeclaredMethod ( <str> ) . invoke ( null ) ; @SuppressWarnings ( <str> ) List < String > vmArgs = ( List < String > ) runtimeClass . getDeclaredMethod ( <str> ) . invoke ( runtime ) ; for ( int i = vmArgs . size ( ) - <int> ; i > = <int> ; i - - ) { Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN . matcher ( vmArgs . get ( i ) ) ; if ( ! m . matches ( ) ) { continue ; } maxDirectMemory = Long . parseLong ( m . group ( <int> ) ) ; switch ( m . group ( <int> ) . charAt ( <int> ) ) { case <str> : case <str> : maxDirectMemory * = <int> ; break ; case <str> : case <str> : maxDirectMemory * = <int> * <int> ; break ; case <str> : case <str> : maxDirectMemory * = <int> * <int> * <int> ; break ; } break ; } } catch ( Throwable t ) { } if ( maxDirectMemory < = <int> ) { maxDirectMemory = Runtime . getRuntime ( ) . maxMemory ( ) ; logger . debug ( <str> , maxDirectMemory ) ; } else { logger . debug ( <str> , maxDirectMemory ) ; } return maxDirectMemory ; } private static boolean hasJavassist0 ( ) { if ( isAndroid ( ) ) { return false ; } boolean noJavassist = SystemPropertyUtil . getBoolean ( <str> , false ) ; logger . debug ( <str> , noJavassist ) ; if ( noJavassist ) { logger . debug ( <str> ) ; return false ; } try { JavassistTypeParameterMatcherGenerator . generate ( Object . class , getClassLoader ( PlatformDependent . class ) ) ; logger . debug ( <str> ) ; return true ; } catch ( Throwable t ) { logger . debug ( <str> ) ; logger . debug ( <str> + <str> ) ; return false ; } } private static File tmpdir0 ( ) { File f ; try { f = toDirectory ( SystemPropertyUtil . get ( <str> ) ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } f = toDirectory ( SystemPropertyUtil . get ( <str> ) ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } if ( isWindows ( ) ) { f = toDirectory ( System . getenv ( <str> ) ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } String userprofile = System . getenv ( <str> ) ; if ( userprofile ! = null ) { f = toDirectory ( userprofile + <str> ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } f = toDirectory ( userprofile + <str> ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } } } else { f = toDirectory ( System . getenv ( <str> ) ) ; if ( f ! = null ) { logger . debug ( <str> , f ) ; return f ; } } } catch ( Exception ignored ) { } if ( isWindows ( ) ) { f = new File ( <str> ) ; } else { f = new File ( <str> ) ; } logger . warn ( <str> , f ) ; return f ; } @SuppressWarnings ( <str> ) private static File toDirectory ( String path ) { if ( path = = null ) { return null ; } File f = new File ( path ) ; f . mkdirs ( ) ; if ( ! f . isDirectory ( ) ) { return null ; } try { return f . getAbsoluteFile ( ) ; } catch ( Exception ignored ) { return f ; } } private static int bitMode0 ( ) { int bitMode = SystemPropertyUtil . getInt ( <str> , <int> ) ; if ( bitMode > <int> ) { logger . debug ( <str> , bitMode ) ; return bitMode ; } bitMode = SystemPropertyUtil . getInt ( <str> , <int> ) ; if ( bitMode > <int> ) { logger . debug ( <str> , bitMode ) ; return bitMode ; } bitMode = SystemPropertyUtil . getInt ( <str> , <int> ) ; if ( bitMode > <int> ) { logger . debug ( <str> , bitMode ) ; return bitMode ; } String arch = SystemPropertyUtil . get ( <str> , <str> ) . toLowerCase ( Locale . US ) . trim ( ) ; if ( <str> . equals ( arch ) | | <str> . equals ( arch ) ) { bitMode = <int> ; } else if ( <str> . equals ( arch ) | | <str> . equals ( arch ) | | <str> . equals ( arch ) | | <str> . equals ( arch ) ) { bitMode = <int> ; } if ( bitMode > <int> ) { logger . debug ( <str> , bitMode , arch ) ; } String vm = SystemPropertyUtil . get ( <str> , <str> ) . toLowerCase ( Locale . US ) ; Pattern BIT_PATTERN = Pattern . compile ( <str> ) ; Matcher m = BIT_PATTERN . matcher ( vm ) ; if ( m . find ( ) ) { return Integer . parseInt ( m . group ( <int> ) ) ; } else { return <int> ; } } private static int addressSize0 ( ) { if ( ! hasUnsafe ( ) ) { return - <int> ; } return PlatformDependent0 . addressSize ( ) ; } private static boolean equalsSafe ( byte [ ] bytes1 , int startPos1 , byte [ ] bytes2 , int startPos2 , int length ) { final int end = startPos1 + length ; for ( int i = startPos1 , j = startPos2 ; i < end ; + + i , + + j ) { if ( bytes1 [ i ] ! = bytes2 [ j ] ) { return false ; } } return true ; } static int hashCodeAsciiSafe ( byte [ ] bytes , int startPos , int length ) { int hash = HASH_CODE_ASCII_SEED ; final int remainingBytes = length & <int> ; final int end = startPos + remainingBytes ; for ( int i = startPos - <int> + length ; i > = end ; i - = <int> ) { hash = hashCodeAsciiCompute ( getLongSafe ( bytes , i ) , hash ) ; } switch ( remainingBytes ) { case <int> : return ( ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntSafe ( bytes , startPos + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( getShortSafe ( bytes , startPos + <int> ) ) ) * <int> + hashCodeAsciiSanitize ( bytes [ startPos ] ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntSafe ( bytes , startPos + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( getShortSafe ( bytes , startPos ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntSafe ( bytes , startPos + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( bytes [ startPos ] ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( getIntSafe ( bytes , startPos ) ) ; case <int> : return ( hash * <int> + hashCodeAsciiSanitize ( getShortSafe ( bytes , startPos + <int> ) ) ) * <int> + hashCodeAsciiSanitize ( bytes [ startPos ] ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( getShortSafe ( bytes , startPos ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( bytes [ startPos ] ) ; default : return hash ; } } static int hashCodeAsciiSafe ( CharSequence bytes ) { int hash = HASH_CODE_ASCII_SEED ; final int remainingBytes = bytes . length ( ) & <int> ; for ( int i = bytes . length ( ) - <int> ; i > = remainingBytes ; i - = <int> ) { hash = hashCodeAsciiCompute ( getLongFromBytesSafe ( bytes , i ) , hash ) ; } switch ( remainingBytes ) { case <int> : return ( ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntFromBytesSafe ( bytes , <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( getShortFromBytesSafe ( bytes , <int> ) ) ) * <int> + hashCodeAsciiSanitizeAsByte ( bytes . charAt ( <int> ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntFromBytesSafe ( bytes , <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( getShortFromBytesSafe ( bytes , <int> ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( getIntFromBytesSafe ( bytes , <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitizeAsByte ( bytes . charAt ( <int> ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( getIntFromBytesSafe ( bytes , <int> ) ) ; case <int> : return ( hash * <int> + hashCodeAsciiSanitize ( getShortFromBytesSafe ( bytes , <int> ) ) ) * <int> + hashCodeAsciiSanitizeAsByte ( bytes . charAt ( <int> ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( getShortFromBytesSafe ( bytes , <int> ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitizeAsByte ( bytes . charAt ( <int> ) ) ; default : return hash ; } } private static final class AtomicLongCounter extends AtomicLong implements LongCounter { private static final long serialVersionUID = <int> ; @Override public void add ( long delta ) { addAndGet ( delta ) ; } @Override public void increment ( ) { incrementAndGet ( ) ; } @Override public void decrement ( ) { decrementAndGet ( ) ; } @Override public long value ( ) { return get ( ) ; } } private PlatformDependent ( ) { } } 
