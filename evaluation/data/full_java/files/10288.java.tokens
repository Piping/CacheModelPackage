package com . google . common . cache ; import static com . google . common . cache . CacheTesting . checkEmpty ; import static com . google . common . cache . CacheTesting . checkValidState ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static com . google . common . truth . Truth . assertThat ; import static java . util . concurrent . TimeUnit . DAYS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . base . Function ; import com . google . common . cache . CacheBuilderFactory . DurationSpec ; import com . google . common . cache . LocalCache . Strength ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public class PopulatedCachesTest extends TestCase { static final int WARMUP_MIN = <int> ; static final int WARMUP_MAX = <int> ; static final int WARMUP_SIZE = WARMUP_MAX - WARMUP_MIN ; public void testSize_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; assertEquals ( WARMUP_SIZE , cache . size ( ) ) ; assertMapSize ( cache . asMap ( ) , WARMUP_SIZE ) ; checkValidState ( cache ) ; } } public void testContainsKey_found ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > entry = warmed . get ( i - WARMUP_MIN ) ; assertTrue ( cache . asMap ( ) . containsKey ( entry . getKey ( ) ) ) ; assertTrue ( cache . asMap ( ) . containsValue ( entry . getValue ( ) ) ) ; assertEquals ( entry . getValue ( ) , cache . getUnchecked ( entry . getKey ( ) ) ) ; } assertEquals ( WARMUP_SIZE , cache . stats ( ) . missCount ( ) ) ; checkValidState ( cache ) ; } } public void testPut_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > entry = warmed . get ( i - WARMUP_MIN ) ; Object newValue = new Object ( ) ; assertSame ( entry . getValue ( ) , cache . asMap ( ) . put ( entry . getKey ( ) , newValue ) ) ; warmed . add ( entryOf ( entry . getKey ( ) , newValue ) ) ; Object newKey = new Object ( ) ; assertNull ( cache . asMap ( ) . put ( newKey , entry . getValue ( ) ) ) ; assertEquals ( newValue , cache . getUnchecked ( entry . getKey ( ) ) ) ; assertEquals ( entry . getValue ( ) , cache . getUnchecked ( newKey ) ) ; warmed . add ( entryOf ( newKey , entry . getValue ( ) ) ) ; } assertEquals ( WARMUP_SIZE , cache . stats ( ) . missCount ( ) ) ; checkValidState ( cache ) ; } } public void testPutIfAbsent_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > entry = warmed . get ( i - WARMUP_MIN ) ; Object newValue = new Object ( ) ; assertSame ( entry . getValue ( ) , cache . asMap ( ) . putIfAbsent ( entry . getKey ( ) , newValue ) ) ; Object newKey = new Object ( ) ; assertNull ( cache . asMap ( ) . putIfAbsent ( newKey , entry . getValue ( ) ) ) ; assertEquals ( entry . getValue ( ) , cache . getUnchecked ( entry . getKey ( ) ) ) ; assertEquals ( entry . getValue ( ) , cache . getUnchecked ( newKey ) ) ; warmed . add ( entryOf ( newKey , entry . getValue ( ) ) ) ; } assertEquals ( WARMUP_SIZE , cache . stats ( ) . missCount ( ) ) ; checkValidState ( cache ) ; } } public void testPutAll_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; Object newKey = new Object ( ) ; Object newValue = new Object ( ) ; cache . asMap ( ) . putAll ( ImmutableMap . of ( newKey , newValue ) ) ; assertEquals ( newValue , cache . getUnchecked ( newKey ) ) ; assertEquals ( WARMUP_SIZE , cache . stats ( ) . missCount ( ) ) ; checkValidState ( cache ) ; } } public void testReplace_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > entry = warmed . get ( i - WARMUP_MIN ) ; Object newValue = new Object ( ) ; assertSame ( entry . getValue ( ) , cache . asMap ( ) . replace ( entry . getKey ( ) , newValue ) ) ; assertTrue ( cache . asMap ( ) . replace ( entry . getKey ( ) , newValue , entry . getValue ( ) ) ) ; Object newKey = new Object ( ) ; assertNull ( cache . asMap ( ) . replace ( newKey , entry . getValue ( ) ) ) ; assertFalse ( cache . asMap ( ) . replace ( newKey , entry . getValue ( ) , newValue ) ) ; assertEquals ( entry . getValue ( ) , cache . getUnchecked ( entry . getKey ( ) ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( newKey ) ) ; } assertEquals ( WARMUP_SIZE , cache . stats ( ) . missCount ( ) ) ; checkValidState ( cache ) ; } } public void testRemove_byKey ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > entry = warmed . get ( i - WARMUP_MIN ) ; Object key = entry . getKey ( ) ; assertEquals ( entry . getValue ( ) , cache . asMap ( ) . remove ( key ) ) ; assertNull ( cache . asMap ( ) . remove ( key ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( key ) ) ; } checkEmpty ( cache ) ; } } public void testRemove_byKeyAndValue ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { List < Entry < Object , Object > > warmed = warmUp ( cache ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Object key = warmed . get ( i - WARMUP_MIN ) . getKey ( ) ; Object value = warmed . get ( i - WARMUP_MIN ) . getValue ( ) ; assertFalse ( cache . asMap ( ) . remove ( key , - <int> ) ) ; assertTrue ( cache . asMap ( ) . remove ( key , value ) ) ; assertFalse ( cache . asMap ( ) . remove ( key , - <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( key ) ) ; } checkEmpty ( cache ) ; } } public void testKeySet_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Object > keys = cache . asMap ( ) . keySet ( ) ; List < Entry < Object , Object > > warmed = warmUp ( cache ) ; Set < Object > expected = Maps . newHashMap ( cache . asMap ( ) ) . keySet ( ) ; assertThat ( keys ) . containsExactlyElementsIn ( expected ) ; assertThat ( keys . toArray ( ) ) . asList ( ) . containsExactlyElementsIn ( expected ) ; assertThat ( keys . toArray ( new Object [ <int> ] ) ) . asList ( ) . containsExactlyElementsIn ( expected ) ; new EqualsTester ( ) . addEqualityGroup ( cache . asMap ( ) . keySet ( ) , keys ) . addEqualityGroup ( ImmutableSet . of ( ) ) . testEquals ( ) ; assertEquals ( WARMUP_SIZE , keys . size ( ) ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Object key = warmed . get ( i - WARMUP_MIN ) . getKey ( ) ; assertTrue ( keys . contains ( key ) ) ; assertTrue ( keys . remove ( key ) ) ; assertFalse ( keys . remove ( key ) ) ; assertFalse ( keys . contains ( key ) ) ; } checkEmpty ( keys ) ; checkEmpty ( cache ) ; } } public void testValues_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Collection < Object > values = cache . asMap ( ) . values ( ) ; List < Entry < Object , Object > > warmed = warmUp ( cache ) ; Collection < Object > expected = Maps . newHashMap ( cache . asMap ( ) ) . values ( ) ; assertThat ( values ) . containsExactlyElementsIn ( expected ) ; assertThat ( values . toArray ( ) ) . asList ( ) . containsExactlyElementsIn ( expected ) ; assertThat ( values . toArray ( new Object [ <int> ] ) ) . asList ( ) . containsExactlyElementsIn ( expected ) ; assertEquals ( WARMUP_SIZE , values . size ( ) ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Object value = warmed . get ( i - WARMUP_MIN ) . getValue ( ) ; assertTrue ( values . contains ( value ) ) ; assertTrue ( values . remove ( value ) ) ; assertFalse ( values . remove ( value ) ) ; assertFalse ( values . contains ( value ) ) ; } checkEmpty ( values ) ; checkEmpty ( cache ) ; } } @SuppressWarnings ( <str> ) public void testEntrySet_populated ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Entry < Object , Object > > entries = cache . asMap ( ) . entrySet ( ) ; List < Entry < Object , Object > > warmed = warmUp ( cache , WARMUP_MIN , WARMUP_MAX ) ; Set < ? > expected = Maps . newHashMap ( cache . asMap ( ) ) . entrySet ( ) ; assertThat ( entries ) . containsExactlyElementsIn ( ( Collection < Entry < Object , Object > > ) expected ) ; assertThat ( entries . toArray ( ) ) . asList ( ) . containsExactlyElementsIn ( ( Collection < Object > ) expected ) ; assertThat ( entries . toArray ( new Entry [ <int> ] ) ) . asList ( ) . containsExactlyElementsIn ( ( Collection < Entry > ) expected ) ; new EqualsTester ( ) . addEqualityGroup ( cache . asMap ( ) . entrySet ( ) , entries ) . addEqualityGroup ( ImmutableSet . of ( ) ) . testEquals ( ) ; assertEquals ( WARMUP_SIZE , entries . size ( ) ) ; for ( int i = WARMUP_MIN ; i < WARMUP_MAX ; i + + ) { Entry < Object , Object > newEntry = warmed . get ( i - WARMUP_MIN ) ; assertTrue ( entries . contains ( newEntry ) ) ; assertTrue ( entries . remove ( newEntry ) ) ; assertFalse ( entries . remove ( newEntry ) ) ; assertFalse ( entries . contains ( newEntry ) ) ; } checkEmpty ( entries ) ; checkEmpty ( cache ) ; } } public void testWriteThroughEntry ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <int> ) ; Entry < Object , Object > entry = Iterables . getOnlyElement ( cache . asMap ( ) . entrySet ( ) ) ; try { entry . setValue ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { entry . setValue ( null ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } checkValidState ( cache ) ; } } private Iterable < LoadingCache < Object , Object > > caches ( ) { CacheBuilderFactory factory = cacheFactory ( ) ; return Iterables . transform ( factory . buildAllPermutations ( ) , new Function < CacheBuilder < Object , Object > , LoadingCache < Object , Object > > ( ) { @Override public LoadingCache < Object , Object > apply ( CacheBuilder < Object , Object > builder ) { return builder . recordStats ( ) . build ( identityLoader ( ) ) ; } } ) ; } private CacheBuilderFactory cacheFactory ( ) { return new CacheBuilderFactory ( ) . withKeyStrengths ( ImmutableSet . of ( Strength . STRONG , Strength . WEAK ) ) . withValueStrengths ( ImmutableSet . copyOf ( Strength . values ( ) ) ) . withConcurrencyLevels ( ImmutableSet . of ( <int> , <int> , <int> , <int> ) ) . withMaximumSizes ( ImmutableSet . of ( <int> , <int> ) ) . withInitialCapacities ( ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> ) ) . withExpireAfterWrites ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) . withExpireAfterAccesses ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) . withRefreshes ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) ; } private List < Map . Entry < Object , Object > > warmUp ( LoadingCache < Object , Object > cache ) { return warmUp ( cache , WARMUP_MIN , WARMUP_MAX ) ; } private List < Map . Entry < Object , Object > > warmUp ( LoadingCache < Object , Object > cache , int minimum , int maximum ) { List < Map . Entry < Object , Object > > entries = Lists . newArrayList ( ) ; for ( int i = minimum ; i < maximum ; i + + ) { Object key = i ; Object value = cache . getUnchecked ( key ) ; entries . add ( entryOf ( key , value ) ) ; } return entries ; } private Entry < Object , Object > entryOf ( Object key , Object value ) { return Maps . immutableEntry ( key , value ) ; } private void assertMapSize ( Map < ? , ? > map , int size ) { assertEquals ( size , map . size ( ) ) ; if ( size > <int> ) { assertFalse ( map . isEmpty ( ) ) ; } else { assertTrue ( map . isEmpty ( ) ) ; } assertCollectionSize ( map . keySet ( ) , size ) ; assertCollectionSize ( map . entrySet ( ) , size ) ; assertCollectionSize ( map . values ( ) , size ) ; } private void assertCollectionSize ( Collection < ? > collection , int size ) { assertEquals ( size , collection . size ( ) ) ; if ( size > <int> ) { assertFalse ( collection . isEmpty ( ) ) ; } else { assertTrue ( collection . isEmpty ( ) ) ; } assertEquals ( size , Iterables . size ( collection ) ) ; assertEquals ( size , Iterators . size ( collection . iterator ( ) ) ) ; } } 
