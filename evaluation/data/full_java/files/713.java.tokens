package org . apache . cassandra . io . sstable . format . big ; import com . google . common . util . concurrent . RateLimiter ; import org . apache . cassandra . cache . KeyCacheKey ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . SliceableUnfilteredRowIterator ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . columniterator . SSTableIterator ; import org . apache . cassandra . db . columniterator . SSTableReversedIterator ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; public class BigTableReader extends SSTableReader { private static final Logger logger = LoggerFactory . getLogger ( BigTableReader . class ) ; BigTableReader ( Descriptor desc , Set < Component > components , CFMetaData metadata , Long maxDataAge , StatsMetadata sstableMetadata , OpenReason openReason , SerializationHeader header ) { super ( desc , components , metadata , maxDataAge , sstableMetadata , openReason , header ) ; } public SliceableUnfilteredRowIterator iterator ( DecoratedKey key , ColumnFilter selectedColumns , boolean reversed , boolean isForThrift ) { return reversed ? new SSTableReversedIterator ( this , key , selectedColumns , isForThrift ) : new SSTableIterator ( this , key , selectedColumns , isForThrift ) ; } public SliceableUnfilteredRowIterator iterator ( FileDataInput file , DecoratedKey key , RowIndexEntry indexEntry , ColumnFilter selectedColumns , boolean reversed , boolean isForThrift ) { return reversed ? new SSTableReversedIterator ( this , file , key , indexEntry , selectedColumns , isForThrift ) : new SSTableIterator ( this , file , key , indexEntry , selectedColumns , isForThrift ) ; } public ISSTableScanner getScanner ( ColumnFilter columns , DataRange dataRange , RateLimiter limiter , boolean isForThrift ) { return BigTableScanner . getScanner ( this , columns , dataRange , limiter , isForThrift ) ; } public ISSTableScanner getScanner ( RateLimiter limiter ) { return BigTableScanner . getScanner ( this , limiter ) ; } public ISSTableScanner getScanner ( Collection < Range < Token > > ranges , RateLimiter limiter ) { return BigTableScanner . getScanner ( this , ranges , limiter ) ; } protected RowIndexEntry getPosition ( PartitionPosition key , Operator op , boolean updateCacheAndStats , boolean permitMatchPastLast ) { if ( op = = Operator . EQ ) { assert key instanceof DecoratedKey ; if ( ! bf . isPresent ( ( DecoratedKey ) key ) ) { Tracing . trace ( <str> , descriptor . generation ) ; return null ; } } if ( ( op = = Operator . EQ | | op = = Operator . GE ) & & ( key instanceof DecoratedKey ) ) { DecoratedKey decoratedKey = ( DecoratedKey ) key ; KeyCacheKey cacheKey = new KeyCacheKey ( metadata . ksAndCFName , descriptor , decoratedKey . getKey ( ) ) ; RowIndexEntry cachedPosition = getCachedPosition ( cacheKey , updateCacheAndStats ) ; if ( cachedPosition ! = null ) { Tracing . trace ( <str> , descriptor . generation ) ; return cachedPosition ; } } boolean skip = false ; if ( key . compareTo ( first ) < <int> ) { if ( op = = Operator . EQ ) skip = true ; else key = first ; op = Operator . EQ ; } else { int l = last . compareTo ( key ) ; skip = l < = <int> & & ( l < <int> | | ( ! permitMatchPastLast & & op = = Operator . GT ) ) ; } if ( skip ) { if ( op = = Operator . EQ & & updateCacheAndStats ) bloomFilterTracker . addFalsePositive ( ) ; Tracing . trace ( <str> , descriptor . generation ) ; return null ; } int binarySearchResult = indexSummary . binarySearch ( key ) ; long sampledPosition = getIndexScanPositionFromBinarySearchResult ( binarySearchResult , indexSummary ) ; int sampledIndex = getIndexSummaryIndexFromBinarySearchResult ( binarySearchResult ) ; int effectiveInterval = indexSummary . getEffectiveIndexIntervalAfterIndex ( sampledIndex ) ; if ( ifile = = null ) return null ; int i = <int> ; String path = null ; try ( FileDataInput in = ifile . createReader ( sampledPosition ) ) { path = in . getPath ( ) ; while ( ! in . isEOF ( ) ) { i + + ; ByteBuffer indexKey = ByteBufferUtil . readWithShortLength ( in ) ; boolean opSatisfied ; boolean exactMatch ; if ( op = = Operator . EQ & & i < = effectiveInterval ) { opSatisfied = exactMatch = indexKey . equals ( ( ( DecoratedKey ) key ) . getKey ( ) ) ; } else { DecoratedKey indexDecoratedKey = decorateKey ( indexKey ) ; int comparison = indexDecoratedKey . compareTo ( key ) ; int v = op . apply ( comparison ) ; opSatisfied = ( v = = <int> ) ; exactMatch = ( comparison = = <int> ) ; if ( v < <int> ) { Tracing . trace ( <str> , descriptor . generation ) ; return null ; } } if ( opSatisfied ) { RowIndexEntry indexEntry = rowIndexEntrySerializer . deserialize ( in ) ; if ( exactMatch & & updateCacheAndStats ) { assert key instanceof DecoratedKey ; DecoratedKey decoratedKey = ( DecoratedKey ) key ; if ( logger . isTraceEnabled ( ) ) { try ( FileDataInput fdi = dfile . createReader ( indexEntry . position ) ) { DecoratedKey keyInDisk = decorateKey ( ByteBufferUtil . readWithShortLength ( fdi ) ) ; if ( ! keyInDisk . equals ( key ) ) throw new AssertionError ( String . format ( <str> , keyInDisk , key , fdi . getPath ( ) ) ) ; } } cacheKey ( decoratedKey , indexEntry ) ; } if ( op = = Operator . EQ & & updateCacheAndStats ) bloomFilterTracker . addTruePositive ( ) ; Tracing . trace ( <str> , indexEntry . columnsIndex ( ) . size ( ) , descriptor . generation ) ; return indexEntry ; } RowIndexEntry . Serializer . skip ( in , descriptor . version ) ; } } catch ( IOException e ) { markSuspect ( ) ; throw new CorruptSSTableException ( e , path ) ; } if ( op = = SSTableReader . Operator . EQ & & updateCacheAndStats ) bloomFilterTracker . addFalsePositive ( ) ; Tracing . trace ( <str> , descriptor . generation ) ; return null ; } } 
