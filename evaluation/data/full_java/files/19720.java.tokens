package io . netty . util . internal ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import sun . misc . Unsafe ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; final class PlatformDependent0 { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PlatformDependent0 . class ) ; static final Unsafe UNSAFE ; private static final long ADDRESS_FIELD_OFFSET ; private static final long BYTE_ARRAY_BASE_OFFSET ; private static final long CHAR_ARRAY_BASE_OFFSET ; private static final long CHAR_ARRAY_INDEX_SCALE ; private static final long STRING_VALUE_FIELD_OFFSET ; static final int HASH_CODE_ASCII_SEED = <hex> ; private static final long UNSAFE_COPY_THRESHOLD = <int> * <int> ; private static final boolean UNALIGNED ; static { ByteBuffer direct = ByteBuffer . allocateDirect ( <int> ) ; Field addressField ; try { addressField = Buffer . class . getDeclaredField ( <str> ) ; addressField . setAccessible ( true ) ; if ( addressField . getLong ( ByteBuffer . allocate ( <int> ) ) ! = <int> ) { addressField = null ; } else { if ( addressField . getLong ( direct ) = = <int> ) { addressField = null ; } } } catch ( Throwable t ) { addressField = null ; } logger . debug ( <str> , addressField ! = null ? <str> : <str> ) ; Unsafe unsafe ; if ( addressField ! = null ) { try { Field unsafeField = Unsafe . class . getDeclaredField ( <str> ) ; unsafeField . setAccessible ( true ) ; unsafe = ( Unsafe ) unsafeField . get ( null ) ; logger . debug ( <str> , unsafe ! = null ? <str> : <str> ) ; try { if ( unsafe ! = null ) { unsafe . getClass ( ) . getDeclaredMethod ( <str> , Object . class , long . class , Object . class , long . class , long . class ) ; logger . debug ( <str> ) ; } } catch ( NoSuchMethodError t ) { logger . debug ( <str> ) ; throw t ; } catch ( NoSuchMethodException e ) { logger . debug ( <str> ) ; throw e ; } } catch ( Throwable cause ) { unsafe = null ; } } else { unsafe = null ; } UNSAFE = unsafe ; if ( unsafe = = null ) { ADDRESS_FIELD_OFFSET = - <int> ; BYTE_ARRAY_BASE_OFFSET = CHAR_ARRAY_BASE_OFFSET = CHAR_ARRAY_INDEX_SCALE = - <int> ; UNALIGNED = false ; STRING_VALUE_FIELD_OFFSET = - <int> ; } else { ADDRESS_FIELD_OFFSET = objectFieldOffset ( addressField ) ; BYTE_ARRAY_BASE_OFFSET = UNSAFE . arrayBaseOffset ( byte [ ] . class ) ; CHAR_ARRAY_BASE_OFFSET = UNSAFE . arrayBaseOffset ( char [ ] . class ) ; CHAR_ARRAY_INDEX_SCALE = UNSAFE . arrayIndexScale ( char [ ] . class ) ; boolean unaligned ; try { Class < ? > bitsClass = Class . forName ( <str> , false , ClassLoader . getSystemClassLoader ( ) ) ; Method unalignedMethod = bitsClass . getDeclaredMethod ( <str> ) ; unalignedMethod . setAccessible ( true ) ; unaligned = Boolean . TRUE . equals ( unalignedMethod . invoke ( null ) ) ; } catch ( Throwable t ) { String arch = SystemPropertyUtil . get ( <str> , <str> ) ; unaligned = arch . matches ( <str> ) ; } UNALIGNED = unaligned ; logger . debug ( <str> , UNALIGNED ) ; Field stringValueField = AccessController . doPrivileged ( new PrivilegedAction < Field > ( ) { @Override public Field run ( ) { try { Field f = String . class . getDeclaredField ( <str> ) ; f . setAccessible ( true ) ; return f ; } catch ( NoSuchFieldException e ) { logger . warn ( <str> + <str> , e ) ; } catch ( SecurityException e ) { logger . info ( <str> + <str> , e ) ; } return null ; } } ) ; STRING_VALUE_FIELD_OFFSET = stringValueField = = null ? - <int> : UNSAFE . objectFieldOffset ( stringValueField ) ; } } static boolean isUnaligned ( ) { return UNALIGNED ; } static boolean hasUnsafe ( ) { return UNSAFE ! = null ; } static boolean unalignedAccess ( ) { return UNALIGNED ; } static void throwException ( Throwable cause ) { UNSAFE . throwException ( checkNotNull ( cause , <str> ) ) ; } static void freeDirectBuffer ( ByteBuffer buffer ) { Cleaner0 . freeDirectBuffer ( buffer ) ; } static long directBufferAddress ( ByteBuffer buffer ) { return getLong ( buffer , ADDRESS_FIELD_OFFSET ) ; } static long byteArrayBaseOffset ( ) { return BYTE_ARRAY_BASE_OFFSET ; } static Object getObject ( Object object , long fieldOffset ) { return UNSAFE . getObject ( object , fieldOffset ) ; } static Object getObjectVolatile ( Object object , long fieldOffset ) { return UNSAFE . getObjectVolatile ( object , fieldOffset ) ; } static int getInt ( Object object , long fieldOffset ) { return UNSAFE . getInt ( object , fieldOffset ) ; } private static long getLong ( Object object , long fieldOffset ) { return UNSAFE . getLong ( object , fieldOffset ) ; } static long objectFieldOffset ( Field field ) { return UNSAFE . objectFieldOffset ( field ) ; } static byte getByte ( long address ) { return UNSAFE . getByte ( address ) ; } static short getShort ( long address ) { return UNSAFE . getShort ( address ) ; } static int getInt ( long address ) { return UNSAFE . getInt ( address ) ; } static long getLong ( long address ) { return UNSAFE . getLong ( address ) ; } static byte getByte ( byte [ ] data , int index ) { return UNSAFE . getByte ( data , BYTE_ARRAY_BASE_OFFSET + index ) ; } static short getShort ( byte [ ] data , int index ) { return UNSAFE . getShort ( data , BYTE_ARRAY_BASE_OFFSET + index ) ; } static int getInt ( byte [ ] data , int index ) { return UNSAFE . getInt ( data , BYTE_ARRAY_BASE_OFFSET + index ) ; } static long getLong ( byte [ ] data , int index ) { return UNSAFE . getLong ( data , BYTE_ARRAY_BASE_OFFSET + index ) ; } static void putOrderedObject ( Object object , long address , Object value ) { UNSAFE . putOrderedObject ( object , address , value ) ; } static void putByte ( long address , byte value ) { UNSAFE . putByte ( address , value ) ; } static void putShort ( long address , short value ) { UNSAFE . putShort ( address , value ) ; } static void putInt ( long address , int value ) { UNSAFE . putInt ( address , value ) ; } static void putLong ( long address , long value ) { UNSAFE . putLong ( address , value ) ; } static void putByte ( byte [ ] data , int index , byte value ) { UNSAFE . putByte ( data , BYTE_ARRAY_BASE_OFFSET + index , value ) ; } static void putShort ( byte [ ] data , int index , short value ) { UNSAFE . putShort ( data , BYTE_ARRAY_BASE_OFFSET + index , value ) ; } static void putInt ( byte [ ] data , int index , int value ) { UNSAFE . putInt ( data , BYTE_ARRAY_BASE_OFFSET + index , value ) ; } static void putLong ( byte [ ] data , int index , long value ) { UNSAFE . putLong ( data , BYTE_ARRAY_BASE_OFFSET + index , value ) ; } static void copyMemory ( long srcAddr , long dstAddr , long length ) { while ( length > <int> ) { long size = Math . min ( length , UNSAFE_COPY_THRESHOLD ) ; UNSAFE . copyMemory ( srcAddr , dstAddr , size ) ; length - = size ; srcAddr + = size ; dstAddr + = size ; } } static void copyMemory ( Object src , long srcOffset , Object dst , long dstOffset , long length ) { while ( length > <int> ) { long size = Math . min ( length , UNSAFE_COPY_THRESHOLD ) ; UNSAFE . copyMemory ( src , srcOffset , dst , dstOffset , size ) ; length - = size ; srcOffset + = size ; dstOffset + = size ; } } static boolean equals ( byte [ ] bytes1 , int startPos1 , byte [ ] bytes2 , int startPos2 , int length ) { if ( length = = <int> ) { return true ; } final long baseOffset1 = BYTE_ARRAY_BASE_OFFSET + startPos1 ; final long baseOffset2 = BYTE_ARRAY_BASE_OFFSET + startPos2 ; final int remainingBytes = length & <int> ; final long end = baseOffset1 + remainingBytes ; for ( long i = baseOffset1 - <int> + length , j = baseOffset2 - <int> + length ; i > = end ; i - = <int> , j - = <int> ) { if ( UNSAFE . getLong ( bytes1 , i ) ! = UNSAFE . getLong ( bytes2 , j ) ) { return false ; } } switch ( remainingBytes ) { case <int> : return UNSAFE . getInt ( bytes1 , baseOffset1 + <int> ) = = UNSAFE . getInt ( bytes2 , baseOffset2 + <int> ) & & UNSAFE . getChar ( bytes1 , baseOffset1 + <int> ) = = UNSAFE . getChar ( bytes2 , baseOffset2 + <int> ) & & UNSAFE . getByte ( bytes1 , baseOffset1 ) = = UNSAFE . getByte ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getInt ( bytes1 , baseOffset1 + <int> ) = = UNSAFE . getInt ( bytes2 , baseOffset2 + <int> ) & & UNSAFE . getChar ( bytes1 , baseOffset1 ) = = UNSAFE . getChar ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getInt ( bytes1 , baseOffset1 + <int> ) = = UNSAFE . getInt ( bytes2 , baseOffset2 + <int> ) & & UNSAFE . getByte ( bytes1 , baseOffset1 ) = = UNSAFE . getByte ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getInt ( bytes1 , baseOffset1 ) = = UNSAFE . getInt ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getChar ( bytes1 , baseOffset1 + <int> ) = = UNSAFE . getChar ( bytes2 , baseOffset2 + <int> ) & & UNSAFE . getByte ( bytes1 , baseOffset1 ) = = UNSAFE . getByte ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getChar ( bytes1 , baseOffset1 ) = = UNSAFE . getChar ( bytes2 , baseOffset2 ) ; case <int> : return UNSAFE . getByte ( bytes1 , baseOffset1 ) = = UNSAFE . getByte ( bytes2 , baseOffset2 ) ; default : return true ; } } static int hashCodeAscii ( byte [ ] bytes , int startPos , int length ) { int hash = HASH_CODE_ASCII_SEED ; final long baseOffset = BYTE_ARRAY_BASE_OFFSET + startPos ; final int remainingBytes = length & <int> ; if ( length > <int> ) { final long end = baseOffset + remainingBytes ; for ( long i = baseOffset - <int> + length ; i > = end ; i - = <int> ) { hash = hashCodeAsciiCompute ( UNSAFE . getLong ( bytes , i ) , hash ) ; } } switch ( remainingBytes ) { case <int> : return ( ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( UNSAFE . getInt ( bytes , baseOffset + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( UNSAFE . getShort ( bytes , baseOffset + <int> ) ) ) * <int> + hashCodeAsciiSanitize ( UNSAFE . getByte ( bytes , baseOffset ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( UNSAFE . getInt ( bytes , baseOffset + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( UNSAFE . getShort ( bytes , baseOffset ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitize ( UNSAFE . getInt ( bytes , baseOffset + <int> ) ) , <int> ) ) * <int> + hashCodeAsciiSanitize ( UNSAFE . getByte ( bytes , baseOffset ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( UNSAFE . getInt ( bytes , baseOffset ) ) ; case <int> : return ( hash * <int> + hashCodeAsciiSanitize ( UNSAFE . getShort ( bytes , baseOffset + <int> ) ) ) * <int> + hashCodeAsciiSanitize ( UNSAFE . getByte ( bytes , baseOffset ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( UNSAFE . getShort ( bytes , baseOffset ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitize ( UNSAFE . getByte ( bytes , baseOffset ) ) ; default : return hash ; } } static int hashCodeAscii ( char [ ] bytes ) { int hash = HASH_CODE_ASCII_SEED ; final int remainingBytes = bytes . length & <int> ; for ( int i = bytes . length - <int> ; i > = remainingBytes ; i - = <int> ) { hash = hashCodeAsciiComputeFromChar ( UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET + i * CHAR_ARRAY_INDEX_SCALE ) , UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET + ( i + <int> ) * CHAR_ARRAY_INDEX_SCALE ) , hash ) ; } switch ( remainingBytes ) { case <int> : return ( ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitizeFromChar ( UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET + <int> * CHAR_ARRAY_INDEX_SCALE ) ) , <int> ) ) * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getInt ( bytes , CHAR_ARRAY_BASE_OFFSET + CHAR_ARRAY_INDEX_SCALE ) ) ) * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getShort ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitizeFromChar ( UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET + <int> * CHAR_ARRAY_INDEX_SCALE ) ) , <int> ) ) * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getInt ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return ( hash * <int> + Integer . rotateLeft ( hashCodeAsciiSanitizeFromChar ( UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET + CHAR_ARRAY_INDEX_SCALE ) ) , <int> ) ) * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getShort ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getLong ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return ( hash * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getInt ( bytes , CHAR_ARRAY_BASE_OFFSET + CHAR_ARRAY_INDEX_SCALE ) ) ) * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getShort ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getInt ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; case <int> : return hash * <int> + hashCodeAsciiSanitizeFromChar ( UNSAFE . getShort ( bytes , CHAR_ARRAY_BASE_OFFSET ) ) ; default : return hash ; } } static char [ ] array ( CharSequence data ) { return ( STRING_VALUE_FIELD_OFFSET ! = - <int> & & data . getClass ( ) = = String . class ) ? ( char [ ] ) UNSAFE . getObject ( data , STRING_VALUE_FIELD_OFFSET ) : null ; } static int hashCodeAsciiCompute ( long value , int hash ) { return ( hash * <int> + ( int ) ( ( value & <hex> ) > > > <int> ) ) * <int> + hashCodeAsciiSanitize ( ( int ) value ) ; } static int hashCodeAsciiComputeFromChar ( long high , long low , int hash ) { return ( hash * <int> + hashCodeAsciiSanitizeFromChar ( low ) ) * <int> + hashCodeAsciiSanitizeFromChar ( high ) ; } static int hashCodeAsciiSanitize ( int value ) { return value & <hex> ; } private static int hashCodeAsciiSanitizeFromChar ( long value ) { return ( int ) ( ( ( value & <hex> ) > > > <int> ) | ( ( value & <hex> ) > > > <int> ) | ( ( value & <hex> ) > > > <int> ) | ( value & <hex> ) ) ; } static int hashCodeAsciiSanitize ( short value ) { return value & <hex> ; } private static int hashCodeAsciiSanitizeFromChar ( int value ) { return ( ( value & <hex> ) > > > <int> ) | ( value & <hex> ) ; } static int hashCodeAsciiSanitizeAsByte ( char value ) { return value & <hex> ; } static int hashCodeAsciiSanitize ( byte value ) { return value & <hex> ; } private static int hashCodeAsciiSanitizeFromChar ( short value ) { return value & <hex> ; } static < U , W > AtomicReferenceFieldUpdater < U , W > newAtomicReferenceFieldUpdater ( Class < U > tclass , String fieldName ) throws Exception { return new UnsafeAtomicReferenceFieldUpdater < U , W > ( UNSAFE , tclass , fieldName ) ; } static < T > AtomicIntegerFieldUpdater < T > newAtomicIntegerFieldUpdater ( Class < ? > tclass , String fieldName ) throws Exception { return new UnsafeAtomicIntegerFieldUpdater < T > ( UNSAFE , tclass , fieldName ) ; } static < T > AtomicLongFieldUpdater < T > newAtomicLongFieldUpdater ( Class < ? > tclass , String fieldName ) throws Exception { return new UnsafeAtomicLongFieldUpdater < T > ( UNSAFE , tclass , fieldName ) ; } static ClassLoader getClassLoader ( final Class < ? > clazz ) { if ( System . getSecurityManager ( ) = = null ) { return clazz . getClassLoader ( ) ; } else { return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { @Override public ClassLoader run ( ) { return clazz . getClassLoader ( ) ; } } ) ; } } static ClassLoader getContextClassLoader ( ) { if ( System . getSecurityManager ( ) = = null ) { return Thread . currentThread ( ) . getContextClassLoader ( ) ; } else { return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { @Override public ClassLoader run ( ) { return Thread . currentThread ( ) . getContextClassLoader ( ) ; } } ) ; } } static ClassLoader getSystemClassLoader ( ) { if ( System . getSecurityManager ( ) = = null ) { return ClassLoader . getSystemClassLoader ( ) ; } else { return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { @Override public ClassLoader run ( ) { return ClassLoader . getSystemClassLoader ( ) ; } } ) ; } } static int addressSize ( ) { return UNSAFE . addressSize ( ) ; } static long allocateMemory ( long size ) { return UNSAFE . allocateMemory ( size ) ; } static void freeMemory ( long address ) { UNSAFE . freeMemory ( address ) ; } private PlatformDependent0 ( ) { } } 
