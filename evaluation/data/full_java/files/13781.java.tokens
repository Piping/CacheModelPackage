package org . gradle . launcher . daemon . client ; import com . google . common . collect . Lists ; import org . gradle . api . BuildCancelledException ; import org . gradle . api . internal . specs . ExplainingSpec ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . initialization . BuildEventConsumer ; import org . gradle . initialization . BuildRequestContext ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . id . IdGenerator ; import org . gradle . internal . invocation . BuildAction ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . launcher . daemon . diagnostics . DaemonDiagnostics ; import org . gradle . launcher . daemon . protocol . * ; import org . gradle . launcher . daemon . server . api . DaemonStoppedException ; import org . gradle . launcher . exec . BuildActionExecuter ; import org . gradle . launcher . exec . BuildActionParameters ; import org . gradle . logging . internal . OutputEventListener ; import org . gradle . messaging . remote . internal . Connection ; import java . io . InputStream ; import java . util . List ; public class DaemonClient implements BuildActionExecuter < BuildActionParameters > { private static final Logger LOGGER = Logging . getLogger ( DaemonClient . class ) ; private final DaemonConnector connector ; private final OutputEventListener outputEventListener ; private final ExplainingSpec < DaemonContext > compatibilitySpec ; private final InputStream buildStandardInput ; private final ExecutorFactory executorFactory ; private final IdGenerator < ? > idGenerator ; public DaemonClient ( DaemonConnector connector , OutputEventListener outputEventListener , ExplainingSpec < DaemonContext > compatibilitySpec , InputStream buildStandardInput , ExecutorFactory executorFactory , IdGenerator < ? > idGenerator ) { this . connector = connector ; this . outputEventListener = outputEventListener ; this . compatibilitySpec = compatibilitySpec ; this . buildStandardInput = buildStandardInput ; this . executorFactory = executorFactory ; this . idGenerator = idGenerator ; } protected IdGenerator < ? > getIdGenerator ( ) { return idGenerator ; } protected DaemonConnector getConnector ( ) { return connector ; } public Object execute ( BuildAction action , BuildRequestContext requestContext , BuildActionParameters parameters , ServiceRegistry contextServices ) { Object buildId = idGenerator . generateId ( ) ; Build build = new Build ( buildId , action , requestContext . getClient ( ) , requestContext . getBuildTimeClock ( ) . getStartTime ( ) , parameters ) ; List < DaemonInitialConnectException > accumulatedExceptions = Lists . newArrayList ( ) ; int saneNumberOfAttempts = <int> ; for ( int i = <int> ; i < saneNumberOfAttempts ; i + + ) { final DaemonClientConnection connection = connector . connect ( compatibilitySpec ) ; try { return executeBuild ( build , connection , requestContext . getCancellationToken ( ) , requestContext . getEventConsumer ( ) ) ; } catch ( DaemonInitialConnectException e ) { LOGGER . debug ( <str> , e . getMessage ( ) ) ; accumulatedExceptions . add ( e ) ; } finally { connection . stop ( ) ; } } throw new NoUsableDaemonFoundException ( <str> + saneNumberOfAttempts + <str> + build + <str> + parameters + <str> , accumulatedExceptions ) ; } protected Object executeBuild ( Build build , DaemonClientConnection connection , BuildCancellationToken cancellationToken , BuildEventConsumer buildEventConsumer ) throws DaemonInitialConnectException { Object result ; try { LOGGER . info ( <str> , connection . getDaemon ( ) , build ) ; connection . dispatch ( build ) ; result = connection . receive ( ) ; } catch ( StaleDaemonAddressException e ) { LOGGER . debug ( <str> , e ) ; throw new DaemonInitialConnectException ( <str> , e ) ; } if ( result = = null ) { throw new DaemonInitialConnectException ( <str> ) ; } LOGGER . info ( <str> , result , connection . getDaemon ( ) ) ; DaemonDiagnostics diagnostics = null ; if ( result instanceof BuildStarted ) { diagnostics = ( ( BuildStarted ) result ) . getDiagnostics ( ) ; result = monitorBuild ( build , diagnostics , connection , cancellationToken , buildEventConsumer ) ; } LOGGER . info ( <str> , result , connection . getDaemon ( ) ) ; connection . dispatch ( new Finished ( ) ) ; if ( result instanceof Failure ) { Throwable failure = ( ( Failure ) result ) . getValue ( ) ; if ( failure instanceof DaemonStoppedException & & cancellationToken . isCancellationRequested ( ) ) { LOGGER . error ( <str> ) ; throw new BuildCancelledException ( ) ; } throw UncheckedException . throwAsUncheckedException ( failure ) ; } else if ( result instanceof DaemonUnavailable ) { throw new DaemonInitialConnectException ( <str> + ( ( DaemonUnavailable ) result ) . getReason ( ) ) ; } else if ( result instanceof Result ) { return ( ( Result ) result ) . getValue ( ) ; } else { throw invalidResponse ( result , build , diagnostics ) ; } } private Object monitorBuild ( Build build , DaemonDiagnostics diagnostics , Connection < Message > connection , BuildCancellationToken cancellationToken , BuildEventConsumer buildEventConsumer ) { DaemonClientInputForwarder inputForwarder = new DaemonClientInputForwarder ( buildStandardInput , connection , executorFactory ) ; DaemonCancelForwarder cancelForwarder = new DaemonCancelForwarder ( connection , cancellationToken , idGenerator ) ; try { cancelForwarder . start ( ) ; inputForwarder . start ( ) ; int objectsReceived = <int> ; while ( true ) { Message object = connection . receive ( ) ; LOGGER . trace ( <str> , objectsReceived + + , object = = null ? null : object . getClass ( ) . getName ( ) ) ; if ( object = = null ) { return handleDaemonDisappearance ( build , diagnostics ) ; } else if ( object instanceof OutputMessage ) { outputEventListener . onOutput ( ( ( OutputMessage ) object ) . getEvent ( ) ) ; } else if ( object instanceof BuildEvent ) { buildEventConsumer . dispatch ( ( ( BuildEvent ) object ) . getPayload ( ) ) ; } else { return object ; } } } finally { CompositeStoppable . stoppable ( cancelForwarder , inputForwarder ) . stop ( ) ; } } private Result handleDaemonDisappearance ( Build build , DaemonDiagnostics diagnostics ) { LOGGER . error ( <str> + <str> + <str> , build ) ; LOGGER . error ( diagnostics . describe ( ) ) ; throw new DaemonDisappearedException ( ) ; } private IllegalStateException invalidResponse ( Object response , Build command , DaemonDiagnostics diagnostics ) { String diagnosticsMessage = diagnostics = = null ? <str> : diagnostics . describe ( ) ; return new IllegalStateException ( String . format ( <str> + <str> , response , command , diagnosticsMessage ) ) ; } } 
