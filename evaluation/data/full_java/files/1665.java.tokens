package org . apache . cassandra . utils ; import java . io . ByteArrayInputStream ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . TreeSet ; import java . util . concurrent . ThreadLocalRandom ; import org . junit . Test ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . DataOutputPlus ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class OverlapIteratorTest { private static List < Interval < Integer , Integer > > randomIntervals ( int range , int increment , int count ) { List < Integer > a = random ( range , increment , count ) ; List < Integer > b = random ( range , increment , count ) ; List < Interval < Integer , Integer > > r = new ArrayList < > ( ) ; for ( int i = <int> ; i < count ; i + + ) { r . add ( a . get ( i ) < b . get ( i ) ? Interval . create ( a . get ( i ) , b . get ( i ) , i ) : Interval . create ( b . get ( i ) , a . get ( i ) , i ) ) ; } return r ; } private static List < Integer > random ( int range , int increment , int count ) { List < Integer > random = new ArrayList < > ( ) ; for ( int i = <int> ; i < count ; i + + ) { int base = i * increment ; random . add ( ThreadLocalRandom . current ( ) . nextInt ( base , base + range ) ) ; } return random ; } @Test public void test ( ) { for ( int i = <int> ; i < <int> ; i + + ) { test ( <int> , <int> , <int> ) ; test ( <int> , <int> , <int> ) ; test ( <int> , <int> , <int> ) ; } } private void test ( int range , int increment , int count ) { compare ( randomIntervals ( range , increment , count ) , random ( range , increment , count ) , <int> ) ; compare ( randomIntervals ( range , increment , count ) , random ( range , increment , count ) , <int> ) ; compare ( randomIntervals ( range , increment , count ) , random ( range , increment , count ) , <int> ) ; } private < I extends Comparable < I > , V > void compare ( List < Interval < I , V > > intervals , List < I > points , int initCount ) { Collections . sort ( points ) ; IntervalTree < I , V , Interval < I , V > > tree = IntervalTree . build ( intervals ) ; OverlapIterator < I , V > iter = new OverlapIterator < > ( intervals ) ; int initPoint = points . size ( ) / initCount ; int i = <int> ; for ( I point : points ) { if ( i + + = = initPoint ) iter = new OverlapIterator < > ( intervals ) ; iter . update ( point ) ; TreeSet < V > act = new TreeSet < > ( iter . overlaps ) ; TreeSet < V > exp = new TreeSet < > ( tree . search ( point ) ) ; TreeSet < V > extra = new TreeSet < > ( act ) ; extra . removeAll ( exp ) ; TreeSet < V > missing = new TreeSet < > ( exp ) ; missing . removeAll ( act ) ; assertTrue ( extra . isEmpty ( ) ) ; assertTrue ( missing . isEmpty ( ) ) ; } } } 
