package org . eclipse . debug . internal . ui . views . memory ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Hashtable ; import java . util . Set ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockRetrieval ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . views . memory . renderings . CreateRendering ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . memory . IMemoryRendering ; import org . eclipse . debug . ui . memory . IMemoryRenderingContainer ; import org . eclipse . debug . ui . memory . IMemoryRenderingSite ; import org . eclipse . debug . ui . memory . IMemoryRenderingSynchronizationService ; import org . eclipse . debug . ui . memory . IResettableMemoryRendering ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . resource . ColorRegistry ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . SWTException ; import org . eclipse . swt . custom . CTabFolder ; import org . eclipse . swt . custom . CTabFolder2Adapter ; import org . eclipse . swt . custom . CTabFolderEvent ; import org . eclipse . swt . custom . CTabItem ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPreferenceConstants ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . progress . UIJob ; public class RenderingViewPane extends AbstractMemoryViewPane implements IMemoryRenderingContainer { public static final String RENDERING_VIEW_PANE_ID = DebugUIPlugin . getUniqueIdentifier ( ) + <str> ; private Hashtable < IMemoryBlock , CTabFolder > fTabFolderForMemoryBlock = new Hashtable < IMemoryBlock , CTabFolder > ( ) ; private Hashtable < CTabFolder , IMemoryBlock > fMemoryBlockFromTabFolder = new Hashtable < CTabFolder , IMemoryBlock > ( ) ; private ViewPaneRenderingMgr fRenderingMgr ; private IMemoryRenderingSite fRenderingSite ; private Set < IMemoryRendering > fAddedRenderings = new HashSet < IMemoryRendering > ( ) ; private Set < IMemoryBlock > fAddedMemoryBlocks = new HashSet < IMemoryBlock > ( ) ; private boolean fCanAddRendering = true ; private boolean fCanRemoveRendering = true ; public RenderingViewPane ( IViewPart parent ) { super ( parent ) ; if ( parent instanceof IMemoryRenderingSite ) { fRenderingSite = ( IMemoryRenderingSite ) parent ; } else { DebugUIPlugin . logErrorMessage ( <str> ) ; } } @Override public void memoryBlocksAdded ( final IMemoryBlock [ ] memoryBlocks ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } if ( memoryBlocks = = null | | memoryBlocks . length < = <int> ) { return ; } for ( int i = <int> ; i < memoryBlocks . length ; i + + ) { IMemoryBlock memory = memoryBlocks [ i ] ; if ( ! fTabFolderForMemoryBlock . containsKey ( memory ) ) { createFolderForMemoryBlock ( memory ) ; } fAddedMemoryBlocks . add ( memory ) ; updateToolBarActionsEnablement ( ) ; } } } ) ; } @Override public void memoryBlocksRemoved ( final IMemoryBlock [ ] memoryBlocks ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { for ( int j = <int> ; j < memoryBlocks . length ; j + + ) { IMemoryBlock mbRemoved = memoryBlocks [ j ] ; if ( fTabFolderForMemoryBlock = = null ) { return ; } IMemoryRendering [ ] renderings = fRenderingMgr . getRenderingsFromMemoryBlock ( mbRemoved ) ; for ( int k = <int> ; k < renderings . length ; k + + ) { removeMemoryRendering ( renderings [ k ] ) ; } CTabFolder tabFolder = fTabFolderForMemoryBlock . get ( mbRemoved ) ; if ( tabFolder = = null ) { continue ; } fTabFolderForMemoryBlock . remove ( mbRemoved ) ; fMemoryBlockFromTabFolder . remove ( tabFolder ) ; IMemoryBlockRetrieval retrieve = MemoryViewUtil . getMemoryBlockRetrieval ( mbRemoved ) ; if ( retrieve ! = null ) { if ( fTabFolderForDebugView . contains ( tabFolder ) ) { fTabFolderForDebugView . remove ( MemoryViewUtil . getHashCode ( retrieve ) ) ; } } if ( ! tabFolder . isDisposed ( ) ) { CTabItem [ ] items = tabFolder . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { disposeTab ( items [ i ] ) ; } tabFolder . dispose ( ) ; if ( tabFolder = = fStackLayout . topControl ) { ISelection selection = DebugUIPlugin . getActiveWorkbenchWindow ( ) . getSelectionService ( ) . getSelection ( IDebugUIConstants . ID_MEMORY_VIEW ) ; IMemoryBlock mbToSelect = getMemoryBlock ( selection ) ; if ( mbToSelect ! = null ) { if ( mbToSelect ! = mbRemoved ) { handleMemoryBlockSelection ( null , mbToSelect ) ; } else if ( ( MemoryViewUtil . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieve ) . length > <int> ) ) { mbToSelect = MemoryViewUtil . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieve ) [ <int> ] ; handleMemoryBlockSelection ( null , mbToSelect ) ; } else { emptyFolder ( ) ; } } else if ( MemoryViewUtil . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieve ) . length > <int> ) { mbToSelect = MemoryViewUtil . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieve ) [ <int> ] ; handleMemoryBlockSelection ( null , mbToSelect ) ; } else { emptyFolder ( ) ; } } } fAddedMemoryBlocks . remove ( mbRemoved ) ; updateToolBarActionsEnablement ( ) ; } } } ) ; } @Override public void selectionChanged ( final IWorkbenchPart part , final ISelection selection ) { if ( isDisposed ( ) ) { return ; } if ( part = = RenderingViewPane . this ) { return ; } if ( ! ( selection instanceof IStructuredSelection ) ) { return ; } if ( selection = = AbstractMemoryViewPane . EMPTY ) { return ; } UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { try { if ( isDisposed ( ) ) { return Status . OK_STATUS ; } if ( selection . isEmpty ( ) ) { if ( part . getSite ( ) . getId ( ) . equals ( IDebugUIConstants . ID_MEMORY_VIEW ) ) { if ( part = = getMemoryRenderingSite ( ) . getSite ( ) . getPart ( ) ) { IMemoryViewTab lastViewTab = getTopMemoryTab ( ) ; if ( lastViewTab ! = null ) { lastViewTab . setEnabled ( false ) ; } emptyFolder ( ) ; } } return Status . OK_STATUS ; } IMemoryViewTab lastViewTab = getTopMemoryTab ( ) ; if ( ! ( selection instanceof IStructuredSelection ) ) { return Status . OK_STATUS ; } Object elem = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; if ( elem instanceof IMemoryBlock ) { if ( part = = getMemoryRenderingSite ( ) ) { IMemoryBlock memBlock = ( IMemoryBlock ) elem ; if ( fTabFolderForMemoryBlock = = null ) { if ( lastViewTab ! = null ) { lastViewTab . setEnabled ( false ) ; } emptyFolder ( ) ; return Status . OK_STATUS ; } handleMemoryBlockSelection ( lastViewTab , memBlock ) ; } } } catch ( SWTException se ) { DebugUIPlugin . log ( se ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } public void handleMemoryBlockSelection ( final IMemoryViewTab lastViewTab , final IMemoryBlock memBlock ) { CTabFolder currentFolder = ( CTabFolder ) fStackLayout . topControl ; if ( currentFolder ! = null & & ! currentFolder . isDisposed ( ) ) { IMemoryBlock currentBlk = fMemoryBlockFromTabFolder . get ( currentFolder ) ; if ( currentBlk ! = null ) { if ( currentBlk = = memBlock ) { return ; } } } if ( getTopMemoryTab ( ) ! = null ) { if ( getTopMemoryTab ( ) . getRendering ( ) . getMemoryBlock ( ) = = memBlock ) { return ; } } if ( fTabFolderForMemoryBlock . containsKey ( memBlock ) ) { if ( fStackLayout . topControl ! = fTabFolderForMemoryBlock . get ( memBlock ) ) { setTabFolder ( fTabFolderForMemoryBlock . get ( memBlock ) ) ; fViewPaneCanvas . layout ( ) ; } } else { CTabFolder folder = createTabFolder ( fViewPaneCanvas ) ; fTabFolderForMemoryBlock . put ( memBlock , folder ) ; fMemoryBlockFromTabFolder . put ( folder , memBlock ) ; setTabFolder ( fTabFolderForMemoryBlock . get ( memBlock ) ) ; fViewPaneCanvas . layout ( ) ; fAddedMemoryBlocks . add ( memBlock ) ; newCreateRenderingForFolder ( memBlock , folder ) ; } IMemoryRendering [ ] renderings = fRenderingMgr . getRenderingsFromMemoryBlock ( memBlock ) ; CTabFolder toDisplay = ( CTabFolder ) fStackLayout . topControl ; if ( isRestoreViewTabs ( toDisplay ) ) { restoreViewTabs ( renderings ) ; } IMemoryViewTab newViewTab = getTopMemoryTab ( ) ; if ( lastViewTab ! = null & & lastViewTab ! = newViewTab ) { lastViewTab . setEnabled ( false ) ; } if ( newViewTab ! = null ) { if ( ! newViewTab . isEnabled ( ) ) { if ( fVisible ) { newViewTab . setEnabled ( fVisible ) ; } } } IMemoryViewTab viewTab = getTopMemoryTab ( ) ; if ( viewTab ! = null ) { setRenderingSelection ( viewTab . getRendering ( ) ) ; } updateToolBarActionsEnablement ( ) ; } private boolean isRestoreViewTabs ( CTabFolder folder ) { if ( canAddRendering ( ) ) { return ( folder . getItemCount ( ) = = <int> & & getTopMemoryTab ( ) . getRendering ( ) instanceof CreateRendering ) ; } else { return ( folder . getItemCount ( ) = = <int> ) ; } } private int getIndexOfCreateRenderingTab ( CTabFolder folder ) { for ( int i = <int> ; i < folder . getItemCount ( ) ; i + + ) { if ( folder . getItem ( i ) . getData ( ) instanceof MemoryViewTab & & ( ( MemoryViewTab ) folder . getItem ( i ) . getData ( ) ) . getRendering ( ) instanceof CreateRendering ) { return i ; } } return - <int> ; } public void memoryBlockRenderingAdded ( final IMemoryRendering rendering ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } if ( fAddedRenderings . contains ( rendering ) ) { return ; } IMemoryBlock memoryblk = rendering . getMemoryBlock ( ) ; CTabFolder tabFolder = fTabFolderForMemoryBlock . get ( memoryblk ) ; if ( tabFolder = = null ) { tabFolder = createFolderForMemoryBlock ( memoryblk ) ; } if ( tabFolder = = fStackLayout . topControl ) { if ( getTopMemoryTab ( ) ! = null ) { deactivateRendering ( getTopMemoryTab ( ) ) ; getTopMemoryTab ( ) . setEnabled ( false ) ; } } fAddedRenderings . add ( rendering ) ; int index = getIndexOfCreateRenderingTab ( tabFolder ) ; if ( index < <int> ) { index = <int> ; } CTabItem tab = createTab ( tabFolder , index ) ; MemoryViewTab viewTab = new MemoryViewTab ( tab , rendering , getInstance ( ) ) ; tabFolder . setSelection ( tabFolder . indexOf ( tab ) ) ; if ( tabFolder = = fStackLayout . topControl ) { setRenderingSelection ( viewTab . getRendering ( ) ) ; IMemoryViewTab top = getTopMemoryTab ( ) ; if ( top ! = null ) { top . setEnabled ( fVisible ) ; } } else { deactivateRendering ( viewTab ) ; viewTab . setEnabled ( false ) ; } updateToolBarActionsEnablement ( ) ; } } ) ; } public void memoryBlockRenderingRemoved ( final IMemoryRendering rendering ) { final IMemoryBlock memory = rendering . getMemoryBlock ( ) ; Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! fAddedRenderings . contains ( rendering ) ) { return ; } fAddedRenderings . remove ( rendering ) ; CTabFolder tabFolder = ( CTabFolder ) fStackLayout . topControl ; if ( tabFolder . isDisposed ( ) ) { return ; } CTabItem [ ] tabs = tabFolder . getItems ( ) ; boolean foundTab = false ; for ( int i = <int> ; i < tabs . length ; i + + ) { IMemoryViewTab viewTab = ( IMemoryViewTab ) tabs [ i ] . getData ( ) ; if ( tabs [ i ] . isDisposed ( ) ) { continue ; } if ( viewTab . getRendering ( ) . getMemoryBlock ( ) = = memory ) { if ( viewTab . getRendering ( ) = = rendering ) { foundTab = true ; disposeTab ( tabs [ i ] ) ; break ; } } } if ( ! foundTab ) { Enumeration < CTabFolder > enumeration = fTabFolderForMemoryBlock . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { CTabFolder otherTabFolder = enumeration . nextElement ( ) ; tabs = otherTabFolder . getItems ( ) ; IMemoryViewTab viewTab = null ; for ( int i = <int> ; i < tabs . length ; i + + ) { viewTab = ( IMemoryViewTab ) tabs [ i ] . getData ( ) ; if ( viewTab . getRendering ( ) . getMemoryBlock ( ) = = memory ) { if ( viewTab . getRendering ( ) = = rendering ) { foundTab = true ; disposeTab ( tabs [ i ] ) ; break ; } } } } } IMemoryViewTab top = getTopMemoryTab ( ) ; if ( top ! = null ) { setRenderingSelection ( top . getRendering ( ) ) ; } updateToolBarActionsEnablement ( ) ; } } ) ; } protected void setRenderingSelection ( IMemoryRendering rendering ) { if ( rendering ! = null ) { fSelectionProvider . setSelection ( new StructuredSelection ( rendering ) ) ; } } private void restoreViewTabs ( IMemoryRendering [ ] renderings ) { for ( int i = <int> ; i < renderings . length ; i + + ) { memoryBlockRenderingAdded ( renderings [ i ] ) ; } } private void handleDebugElementSelection ( final IMemoryViewTab lastViewTab , final IAdaptable element ) { IMemoryBlockRetrieval currentRetrieve = null ; CTabFolder tabFolder = ( CTabFolder ) fStackLayout . topControl ; IMemoryBlock currentBlock = fMemoryBlockFromTabFolder . get ( tabFolder ) ; if ( currentBlock ! = null ) { currentRetrieve = MemoryViewUtil . getMemoryBlockRetrieval ( currentBlock ) ; if ( currentRetrieve ! = null & & tabFolder ! = null ) { fTabFolderForDebugView . put ( MemoryViewUtil . getHashCode ( currentRetrieve ) , tabFolder ) ; } } IMemoryBlockRetrieval retrieve = MemoryViewUtil . getMemoryBlockRetrieval ( element ) ; if ( retrieve ! = null & & retrieve ! = currentRetrieve ) { Integer key = MemoryViewUtil . getHashCode ( retrieve ) ; CTabFolder folder = fTabFolderForDebugView . get ( key ) ; if ( folder ! = null ) { setTabFolder ( folder ) ; fTabFolderForDebugView . put ( key , folder ) ; fViewPaneCanvas . layout ( ) ; } else { IMemoryBlock blocks [ ] = MemoryViewUtil . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieve ) ; if ( blocks . length > <int> ) { handleMemoryBlockSelection ( null , blocks [ <int> ] ) ; } else { emptyFolder ( ) ; fTabFolderForDebugView . put ( key , fEmptyTabFolder ) ; fViewPaneCanvas . layout ( ) ; } } } IMemoryViewTab newViewTab = getTopMemoryTab ( ) ; if ( lastViewTab ! = null & & lastViewTab ! = newViewTab ) { lastViewTab . setEnabled ( false ) ; } if ( newViewTab ! = null ) { if ( ! newViewTab . isEnabled ( ) ) { if ( fVisible ) { newViewTab . setEnabled ( fVisible ) ; } } if ( lastViewTab ! = newViewTab ) { setRenderingSelection ( newViewTab . getRendering ( ) ) ; } } updateToolBarActionsEnablement ( ) ; } @Override protected void addListeners ( ) { super . addListeners ( ) ; fParent . getSite ( ) . getSelectionProvider ( ) . addSelectionChangedListener ( this ) ; } @Override protected void removeListeners ( ) { super . removeListeners ( ) ; fParent . getSite ( ) . getSelectionProvider ( ) . removeSelectionChangedListener ( this ) ; } @Override public void widgetSelected ( SelectionEvent e ) { if ( getTopMemoryTab ( ) = = null ) { return ; } IMemoryRendering rendering = getTopMemoryTab ( ) . getRendering ( ) ; if ( rendering ! = null ) { fSelectionProvider . setSelection ( new StructuredSelection ( rendering ) ) ; } } @Override public void widgetDefaultSelected ( SelectionEvent e ) { } @Override public Object getCurrentSelection ( ) { if ( getTopMemoryTab ( ) ! = null ) { if ( getTopMemoryTab ( ) . getRendering ( ) ! = null ) { return getTopMemoryTab ( ) . getRendering ( ) ; } } return null ; } @Override public IMemoryViewTab [ ] getAllViewTabs ( ) { CTabFolder folder = ( CTabFolder ) fStackLayout . topControl ; CTabItem [ ] items = folder . getItems ( ) ; IMemoryViewTab [ ] viewTabs = new IMemoryViewTab [ folder . getItemCount ( ) ] ; for ( int i = <int> ; i < items . length ; i + + ) { viewTabs [ i ] = ( IMemoryViewTab ) items [ i ] . getData ( ) ; } return viewTabs ; } @Override public void moveToTop ( IMemoryViewTab viewTab ) { IMemoryViewTab lastViewTab = getTopMemoryTab ( ) ; if ( viewTab = = lastViewTab ) { return ; } CTabFolder folder = ( CTabFolder ) fStackLayout . topControl ; CTabItem [ ] items = folder . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { IMemoryViewTab tab = ( IMemoryViewTab ) items [ i ] . getData ( ) ; if ( viewTab = = tab ) { boolean isEnabled = lastViewTab . isEnabled ( ) ; lastViewTab . setEnabled ( false ) ; folder . setSelection ( i ) ; setRenderingSelection ( tab . getRendering ( ) ) ; getTopMemoryTab ( ) . setEnabled ( isEnabled & & fVisible ) ; break ; } } } private CTabFolder createTabFolder ( Composite parent ) { CTabFolder folder = new CTabFolder ( parent , SWT . NO_REDRAW_RESIZE | SWT . NO_TRIM | SWT . FLAT ) ; ColorRegistry reg = JFaceResources . getColorRegistry ( ) ; Color c1 = reg . get ( <str> ) , c2 = reg . get ( <str> ) ; folder . setSelectionBackground ( new Color [ ] { c1 , c2 } , new int [ ] { <int> } , true ) ; folder . setSelectionForeground ( reg . get ( <str> ) ) ; folder . setSimple ( PlatformUI . getPreferenceStore ( ) . getBoolean ( IWorkbenchPreferenceConstants . SHOW_TRADITIONAL_STYLE_TABS ) ) ; folder . setBorderVisible ( true ) ; folder . setFont ( fViewPaneCanvas . getFont ( ) ) ; folder . addCTabFolder2Listener ( new CTabFolder2Adapter ( ) { @Override public void close ( CTabFolderEvent event ) { if ( event . item . getData ( ) instanceof MemoryViewTab ) { RenderingViewPane . this . removeMemoryRendering ( ( ( MemoryViewTab ) event . item . getData ( ) ) . getRendering ( ) ) ; } event . doit = false ; } } ) ; return folder ; } @Override public void restoreViewPane ( ) { ISelection selection = null ; if ( fParent . getSite ( ) . getSelectionProvider ( ) ! = null ) { selection = fParent . getSite ( ) . getSelectionProvider ( ) . getSelection ( ) ; } IMemoryBlock memoryBlock = null ; if ( selection ! = null ) { memoryBlock = getMemoryBlock ( selection ) ; } if ( memoryBlock = = null ) { selection = fSelectionProvider . getSelection ( ) ; if ( MemoryViewUtil . isValidSelection ( selection ) ) { Object elem = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; if ( ! ( elem instanceof IMemoryBlock ) ) { return ; } memoryBlock = ( IMemoryBlock ) elem ; } } if ( memoryBlock = = null ) { IAdaptable context = DebugUITools . getPartDebugContext ( fParent . getSite ( ) ) ; if ( context ! = null ) { IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( context ) ; if ( retrieval ! = null ) { IMemoryBlock [ ] blocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieval ) ; if ( blocks . length > <int> ) { memoryBlock = blocks [ <int> ] ; } } } } if ( memoryBlock ! = null ) { if ( ! fTabFolderForMemoryBlock . containsKey ( memoryBlock ) ) { CTabFolder folder = createTabFolder ( fViewPaneCanvas ) ; fTabFolderForMemoryBlock . put ( memoryBlock , folder ) ; fMemoryBlockFromTabFolder . put ( folder , memoryBlock ) ; setTabFolder ( fTabFolderForMemoryBlock . get ( memoryBlock ) ) ; IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( memoryBlock ) ; if ( retrieval ! = null ) { fTabFolderForDebugView . put ( MemoryViewUtil . getHashCode ( retrieval ) , fTabFolderForMemoryBlock . get ( memoryBlock ) ) ; } else { DebugUIPlugin . logErrorMessage ( <str> ) ; } fViewPaneCanvas . layout ( ) ; fAddedMemoryBlocks . add ( memoryBlock ) ; newCreateRenderingForFolder ( memoryBlock , folder ) ; } if ( fTabFolderForMemoryBlock . containsKey ( memoryBlock ) ) { CTabFolder toDisplay = fTabFolderForMemoryBlock . get ( memoryBlock ) ; if ( toDisplay ! = null ) { setTabFolder ( toDisplay ) ; IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( memoryBlock ) ; if ( retrieval ! = null ) { fTabFolderForDebugView . put ( MemoryViewUtil . getHashCode ( retrieval ) , toDisplay ) ; } else { DebugUIPlugin . logErrorMessage ( <str> ) ; } fViewPaneCanvas . layout ( ) ; IMemoryRendering [ ] renderings = fRenderingMgr . getRenderingsFromMemoryBlock ( memoryBlock ) ; if ( isRestoreViewTabs ( toDisplay ) ) { restoreViewTabs ( renderings ) ; } } } IMemoryViewTab top = getTopMemoryTab ( ) ; if ( top ! = null ) { top . setEnabled ( fVisible ) ; } } } @Override public void dispose ( ) { super . dispose ( ) ; fTabFolderForMemoryBlock . clear ( ) ; fTabFolderForMemoryBlock = null ; fMemoryBlockFromTabFolder . clear ( ) ; fMemoryBlockFromTabFolder = null ; fRenderingMgr . dispose ( ) ; fRenderingMgr = null ; fAddedMemoryBlocks . clear ( ) ; fAddedRenderings . clear ( ) ; } public Control createViewPane ( Composite parent , String paneId , String label , boolean canAddRendering , boolean canRemoveRendering ) { return doCreateViewPane ( parent , paneId , label , canAddRendering , canRemoveRendering ) ; } @Override public Control createViewPane ( Composite parent , String paneId , String label ) { return doCreateViewPane ( parent , paneId , label , true , true ) ; } private Control doCreateViewPane ( Composite parent , String paneId , String label , boolean canAddRendering , boolean canRemoveRendering ) { Control control = super . createViewPane ( parent , paneId , label ) ; fCanAddRendering = canAddRendering ; fCanRemoveRendering = canRemoveRendering ; fRenderingMgr = new ViewPaneRenderingMgr ( this ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( parent , IDebugUIConstants . PLUGIN_ID + <str> ) ; return control ; } @Override public IAction [ ] getActions ( ) { return new IAction [ <int> ] ; } protected void updateToolBarActionsEnablement ( ) { } @Override protected void emptyFolder ( ) { super . emptyFolder ( ) ; updateToolBarActionsEnablement ( ) ; fSelectionProvider . setSelection ( AbstractMemoryViewPane . EMPTY ) ; } @Override public void addMemoryRendering ( IMemoryRendering rendering ) { if ( rendering = = null ) { return ; } memoryBlockRenderingAdded ( rendering ) ; fRenderingMgr . addMemoryBlockRendering ( rendering ) ; } @Override public void removeMemoryRendering ( IMemoryRendering rendering ) { if ( rendering = = null ) { return ; } memoryBlockRenderingRemoved ( rendering ) ; if ( fRenderingMgr ! = null ) { fRenderingMgr . removeMemoryBlockRendering ( rendering ) ; } } private RenderingViewPane getInstance ( ) { return this ; } private IMemoryBlock getMemoryBlock ( ISelection selection ) { if ( ! ( selection instanceof IStructuredSelection ) ) { return null ; } if ( selection . isEmpty ( ) | | ( ( IStructuredSelection ) selection ) . size ( ) > <int> ) { return null ; } Object elem = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; if ( elem instanceof IMemoryBlock ) { return ( IMemoryBlock ) elem ; } else if ( elem instanceof IMemoryRendering ) { return ( ( IMemoryRendering ) elem ) . getMemoryBlock ( ) ; } else { return null ; } } private void deactivateRendering ( IMemoryViewTab viewTab ) { if ( viewTab = = null ) { return ; } if ( ! viewTab . isDisposed ( ) ) { viewTab . getRendering ( ) . deactivated ( ) ; } } @Override public IMemoryRenderingSite getMemoryRenderingSite ( ) { return fRenderingSite ; } @Override public String getId ( ) { return getPaneId ( ) ; } @Override public IMemoryRendering [ ] getRenderings ( ) { return fRenderingMgr . getRenderings ( ) ; } @Override public IMemoryRendering getActiveRendering ( ) { if ( getTopMemoryTab ( ) = = null ) { return null ; } return getTopMemoryTab ( ) . getRendering ( ) ; } public void resetRenderings ( IMemoryBlock memoryBlock , boolean resetVisible ) { if ( resetVisible & & ! isVisible ( ) ) { return ; } if ( resetVisible ) { IMemoryRendering rendering = getActiveRendering ( ) ; if ( rendering ! = null ) { if ( rendering . getMemoryBlock ( ) = = memoryBlock ) { if ( rendering instanceof IResettableMemoryRendering ) { IResettableMemoryRendering resettableRendering = ( IResettableMemoryRendering ) rendering ; try { resettableRendering . resetRendering ( ) ; } catch ( DebugException e ) { } } } } } else { IMemoryRendering [ ] renderings = fRenderingMgr . getRenderingsFromMemoryBlock ( memoryBlock ) ; IMemoryRendering originalProvider = null ; IMemoryRenderingSynchronizationService service = getMemoryRenderingSite ( ) . getSynchronizationService ( ) ; if ( service ! = null ) { originalProvider = service . getSynchronizationProvider ( ) ; } for ( int i = <int> ; i < renderings . length ; i + + ) { if ( renderings [ i ] instanceof IResettableMemoryRendering ) { try { if ( service ! = null ) { service . setSynchronizationProvider ( renderings [ i ] ) ; } ( ( IResettableMemoryRendering ) renderings [ i ] ) . resetRendering ( ) ; } catch ( DebugException e ) { } } } if ( service ! = null ) { service . setSynchronizationProvider ( originalProvider ) ; } } } public void showCreateRenderingTab ( ) { IMemoryRendering activeRendering = RenderingViewPane . this . getActiveRendering ( ) ; if ( activeRendering = = null ) { return ; } IMemoryBlock memoryblk = activeRendering . getMemoryBlock ( ) ; final CTabFolder tabFolder = fTabFolderForMemoryBlock . get ( memoryblk ) ; if ( tabFolder ! = null ) { Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { int index = getIndexOfCreateRenderingTab ( tabFolder ) ; if ( index > = <int> ) { tabFolder . setSelection ( index ) ; } } } ) ; } } public void contextActivated ( final ISelection selection ) { UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( isDisposed ( ) ) { return Status . OK_STATUS ; } IMemoryViewTab lastViewTab = getTopMemoryTab ( ) ; if ( MemoryViewUtil . isValidSelection ( selection ) ) { if ( ! ( selection instanceof IStructuredSelection ) ) { return Status . OK_STATUS ; } Object elem = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; if ( elem instanceof IAdaptable ) { handleDebugElementSelection ( lastViewTab , ( IAdaptable ) elem ) ; } } else { if ( lastViewTab ! = null ) { lastViewTab . setEnabled ( false ) ; } if ( fStackLayout . topControl ! = fEmptyTabFolder ) { emptyFolder ( ) ; } } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } private CTabFolder createFolderForMemoryBlock ( IMemoryBlock memory ) { CTabFolder folder = createTabFolder ( fViewPaneCanvas ) ; fTabFolderForMemoryBlock . put ( memory , folder ) ; fMemoryBlockFromTabFolder . put ( folder , memory ) ; IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( memory ) ; if ( retrieval ! = null ) { fTabFolderForDebugView . put ( MemoryViewUtil . getHashCode ( retrieval ) , folder ) ; } else { DebugUIPlugin . logErrorMessage ( <str> ) ; } newCreateRenderingForFolder ( memory , folder ) ; return folder ; } private void newCreateRenderingForFolder ( IMemoryBlock memory , CTabFolder folder ) { if ( ! canAddRendering ( ) ) { return ; } CTabItem newItem = new CTabItem ( folder , SWT . NONE ) ; CreateRendering rendering = new CreateRendering ( getInstance ( ) ) ; rendering . init ( getInstance ( ) , memory ) ; new MemoryViewTab ( newItem , rendering , getInstance ( ) ) ; folder . setSelection ( <int> ) ; } @Override public void debugContextChanged ( DebugContextEvent event ) { if ( ( event . getFlags ( ) & DebugContextEvent . ACTIVATED ) > <int> ) { contextActivated ( event . getContext ( ) ) ; } } public boolean canAddRendering ( ) { return fCanAddRendering ; } public boolean canRemoveRendering ( ) { return fCanRemoveRendering ; } private CTabItem createTab ( CTabFolder tabFolder , int index ) { int swtStyle = SWT . CLOSE ; if ( ! canRemoveRendering ( ) ) { swtStyle = SWT . NONE ; } CTabItem tab = new CTabItem ( tabFolder , swtStyle , index ) ; return tab ; } } 
