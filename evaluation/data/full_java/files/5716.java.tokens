package org . elasticsearch . common . compress ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentType ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; import java . util . zip . CRC32 ; import java . util . zip . CheckedOutputStream ; public final class CompressedXContent { private static int crc32 ( BytesReference data ) { OutputStream dummy = new OutputStream ( ) { @Override public void write ( int b ) throws IOException { } @Override public void write ( byte [ ] b , int off , int len ) throws IOException { } } ; CRC32 crc32 = new CRC32 ( ) ; try { data . writeTo ( new CheckedOutputStream ( dummy , crc32 ) ) ; } catch ( IOException bogus ) { throw new Error ( bogus ) ; } return ( int ) crc32 . getValue ( ) ; } private final byte [ ] bytes ; private final int crc32 ; private CompressedXContent ( byte [ ] compressed , int crc32 ) { this . bytes = compressed ; this . crc32 = crc32 ; assertConsistent ( ) ; } public CompressedXContent ( ToXContent xcontent , XContentType type , ToXContent . Params params ) throws IOException { BytesStreamOutput bStream = new BytesStreamOutput ( ) ; OutputStream compressedStream = CompressorFactory . defaultCompressor ( ) . streamOutput ( bStream ) ; CRC32 crc32 = new CRC32 ( ) ; OutputStream checkedStream = new CheckedOutputStream ( compressedStream , crc32 ) ; try ( XContentBuilder builder = XContentFactory . contentBuilder ( type , checkedStream ) ) { builder . startObject ( ) ; xcontent . toXContent ( builder , params ) ; builder . endObject ( ) ; } this . bytes = bStream . bytes ( ) . toBytes ( ) ; this . crc32 = ( int ) crc32 . getValue ( ) ; assertConsistent ( ) ; } public CompressedXContent ( BytesReference data ) throws IOException { Compressor compressor = CompressorFactory . compressor ( data ) ; if ( compressor ! = null ) { this . bytes = data . toBytes ( ) ; this . crc32 = crc32 ( new BytesArray ( uncompressed ( ) ) ) ; } else { BytesStreamOutput out = new BytesStreamOutput ( ) ; try ( OutputStream compressedOutput = CompressorFactory . defaultCompressor ( ) . streamOutput ( out ) ) { data . writeTo ( compressedOutput ) ; } this . bytes = out . bytes ( ) . toBytes ( ) ; this . crc32 = crc32 ( data ) ; } assertConsistent ( ) ; } private void assertConsistent ( ) { assert CompressorFactory . compressor ( new BytesArray ( bytes ) ) ! = null ; assert this . crc32 = = crc32 ( new BytesArray ( uncompressed ( ) ) ) ; } public CompressedXContent ( byte [ ] data ) throws IOException { this ( new BytesArray ( data ) ) ; } public CompressedXContent ( String str ) throws IOException { this ( new BytesArray ( new BytesRef ( str ) ) ) ; } public byte [ ] compressed ( ) { return this . bytes ; } public BytesReference compressedReference ( ) { return new BytesArray ( bytes ) ; } public byte [ ] uncompressed ( ) { try { return CompressorFactory . uncompress ( new BytesArray ( bytes ) ) . toBytes ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } public String string ( ) throws IOException { return new BytesRef ( uncompressed ( ) ) . utf8ToString ( ) ; } public static CompressedXContent readCompressedString ( StreamInput in ) throws IOException { int crc32 = in . readInt ( ) ; byte [ ] compressed = new byte [ in . readVInt ( ) ] ; in . readBytes ( compressed , <int> , compressed . length ) ; return new CompressedXContent ( compressed , crc32 ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeInt ( crc32 ) ; out . writeVInt ( bytes . length ) ; out . writeBytes ( bytes ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; CompressedXContent that = ( CompressedXContent ) o ; if ( Arrays . equals ( compressed ( ) , that . compressed ( ) ) ) { return true ; } if ( crc32 ! = that . crc32 ) { return false ; } return Arrays . equals ( uncompressed ( ) , that . uncompressed ( ) ) ; } @Override public int hashCode ( ) { return crc32 ; } @Override public String toString ( ) { try { return string ( ) ; } catch ( IOException e ) { return <str> ; } } } 
