package jcuda . utils ; import static jcuda . driver . JCudaDriver . cuDeviceGetCount ; import static jcuda . driver . JCudaDriver . cuLaunchKernel ; import static jcuda . driver . JCudaDriver . cuModuleGetFunction ; import static jcuda . driver . JCudaDriver . cuModuleLoadDataEx ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import jcuda . CudaException ; import jcuda . Pointer ; import jcuda . driver . CUcontext ; import jcuda . driver . CUfunction ; import jcuda . driver . CUmodule ; import jcuda . driver . CUresult ; import jcuda . driver . CUstream ; import jcuda . driver . JCudaDriver ; import jcuda . runtime . JCuda ; import jcuda . runtime . dim3 ; import org . nd4j . linalg . jcublas . SimpleJCublas ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class KernelLauncher { private static final Logger logger = LoggerFactory . getLogger ( KernelLauncher . class . getName ( ) ) ; private static String compilerPath = <str> ; private int deviceNumber = <int> ; public static void setCompilerPath ( String path ) { if ( path = = null ) { compilerPath = <str> ; } compilerPath = path ; if ( ! compilerPath . endsWith ( File . separator ) ) { compilerPath + = File . separator ; } } public void setDeviceNumber ( int number ) { int count [ ] = new int [ <int> ] ; cuDeviceGetCount ( count ) ; if ( number < <int> ) { throw new CudaException ( <str> + number + <str> + <str> + count [ <int> ] + <str> ) ; } deviceNumber = number ; } public static KernelLauncher compile ( String sourceCode , String functionName , String . . . nvccArguments ) { File cuFile = null ; try { cuFile = File . createTempFile ( <str> , <str> ) ; } catch ( IOException e ) { throw new CudaException ( <str> , e ) ; } String cuFileName = cuFile . getPath ( ) ; FileOutputStream fos = null ; try { fos = new FileOutputStream ( cuFile ) ; fos . write ( sourceCode . getBytes ( ) ) ; } catch ( IOException e ) { throw new CudaException ( <str> , e ) ; } finally { if ( fos ! = null ) { try { fos . close ( ) ; } catch ( IOException e ) { throw new CudaException ( <str> , e ) ; } } } return create ( cuFileName , functionName , nvccArguments ) ; } public static KernelLauncher create ( String cuFileName , String functionName , String . . . nvccArguments ) { return create ( cuFileName , functionName , false , nvccArguments ) ; } public static KernelLauncher create ( String cuFileName , String functionName , boolean forceRebuild , String . . . nvccArguments ) { String ptxFileName = null ; try { ptxFileName = preparePtxFile ( cuFileName , forceRebuild , nvccArguments ) ; } catch ( IOException e ) { throw new CudaException ( <str> + cuFileName + <str> , e ) ; } KernelLauncher kernelLauncher = new KernelLauncher ( ) ; byte ptxData [ ] = loadData ( ptxFileName ) ; kernelLauncher . initModule ( ptxData ) ; kernelLauncher . initFunction ( functionName ) ; return kernelLauncher ; } public static KernelLauncher load ( String moduleFileName , String functionName ) { KernelLauncher kernelLauncher = new KernelLauncher ( ) ; byte moduleData [ ] = loadData ( moduleFileName ) ; kernelLauncher . initModule ( moduleData ) ; kernelLauncher . initFunction ( functionName ) ; return kernelLauncher ; } public static KernelLauncher load ( InputStream moduleInputStream , String functionName ) { KernelLauncher kernelLauncher = new KernelLauncher ( ) ; byte moduleData [ ] = loadData ( moduleInputStream ) ; kernelLauncher . initModule ( moduleData ) ; kernelLauncher . initFunction ( functionName ) ; return kernelLauncher ; } private static byte [ ] loadData ( String fileName ) { InputStream inputStream = null ; try { inputStream = new FileInputStream ( new File ( fileName ) ) ; return loadData ( inputStream ) ; } catch ( FileNotFoundException e ) { throw new CudaException ( <str> + fileName + <str> , e ) ; } finally { if ( inputStream ! = null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { throw new CudaException ( <str> + fileName + <str> , e ) ; } } } } private static byte [ ] loadData ( InputStream inputStream ) { ByteArrayOutputStream baos = null ; try { baos = new ByteArrayOutputStream ( ) ; byte buffer [ ] = new byte [ <int> ] ; while ( true ) { int read = inputStream . read ( buffer ) ; if ( read = = - <int> ) { break ; } baos . write ( buffer , <int> , read ) ; } baos . write ( <str> ) ; baos . flush ( ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { throw new CudaException ( <str> , e ) ; } finally { if ( baos ! = null ) { try { baos . close ( ) ; } catch ( IOException e ) { throw new CudaException ( <str> , e ) ; } } } } private CUcontext context ; private CUmodule module ; private CUfunction function ; private dim3 blockSize = new dim3 ( <int> , <int> , <int> ) ; private dim3 gridSize = new dim3 ( <int> , <int> , <int> ) ; private int sharedMemSize = <int> ; private CUstream stream ; private KernelLauncher ( ) { initialize ( ) ; } private void initialize ( ) { context = ContextHolder . getInstance ( ) . getContext ( deviceNumber ) ; } public static void setContext ( ) { JCudaDriver . cuCtxSetCurrent ( ContextHolder . getInstance ( ) . getContext ( ) ) ; JCuda . cudaSetDevice ( ContextHolder . getInstance ( ) . getDeviceForThread ( ) ) ; JCudaDriver . cuCtxSynchronize ( ) ; JCuda . cudaDeviceSynchronize ( ) ; } public KernelLauncher forFunction ( String functionName ) { KernelLauncher kernelLauncher = new KernelLauncher ( ) ; kernelLauncher . module = this . module ; kernelLauncher . initFunction ( functionName ) ; return kernelLauncher ; } private void initModule ( byte moduleData [ ] ) { module = new CUmodule ( ) ; cuModuleLoadDataEx ( module , Pointer . to ( moduleData ) , <int> , new int [ <int> ] , Pointer . to ( new int [ <int> ] ) ) ; } private void initFunction ( String functionName ) { function = new CUfunction ( ) ; String functionErrorString = <str> + functionName + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; try { int result = cuModuleGetFunction ( function , module , functionName ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( functionErrorString ) ; } } catch ( CudaException e ) { throw new CudaException ( functionErrorString , e ) ; } } public CUmodule getModule ( ) { return module ; } public KernelLauncher setGridSize ( int x , int y ) { gridSize . x = x ; gridSize . y = y ; return this ; } public KernelLauncher setGridSize ( int x , int y , int z ) { gridSize . x = x ; gridSize . y = y ; gridSize . z = z ; return this ; } public KernelLauncher setBlockSize ( int x , int y , int z ) { blockSize . x = x ; blockSize . y = y ; blockSize . z = z ; return this ; } public KernelLauncher setSharedMemSize ( int sharedMemSize ) { this . sharedMemSize = sharedMemSize ; return this ; } public KernelLauncher setStream ( CUstream stream ) { this . stream = stream ; return this ; } public KernelLauncher setup ( dim3 gridSize , dim3 blockSize ) { return setup ( gridSize , blockSize , sharedMemSize , stream ) ; } public KernelLauncher setup ( dim3 gridSize , dim3 blockSize , int sharedMemSize ) { return setup ( gridSize , blockSize , sharedMemSize , stream ) ; } public CUcontext context ( ) { return context ; } public KernelLauncher setup ( dim3 gridSize , dim3 blockSize , int sharedMemSize , CUstream stream ) { setGridSize ( gridSize . x , gridSize . y ) ; setBlockSize ( blockSize . x , blockSize . y , blockSize . z ) ; setSharedMemSize ( sharedMemSize ) ; setStream ( stream ) ; return this ; } public void call ( Object . . . args ) { Pointer kernelParameters [ ] = new Pointer [ args . length ] ; for ( int i = <int> ; i < args . length ; i + + ) { Object arg = args [ i ] ; if ( arg instanceof Pointer ) { Pointer argPointer = ( Pointer ) arg ; Pointer pointer = Pointer . to ( argPointer ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Byte ) { Byte value = ( Byte ) arg ; Pointer pointer = Pointer . to ( new byte [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Short ) { Short value = ( Short ) arg ; Pointer pointer = Pointer . to ( new short [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Integer ) { Integer value = ( Integer ) arg ; Pointer pointer = Pointer . to ( new int [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Long ) { Long value = ( Long ) arg ; Pointer pointer = Pointer . to ( new long [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Float ) { Float value = ( Float ) arg ; Pointer pointer = Pointer . to ( new float [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof Double ) { Double value = ( Double ) arg ; Pointer pointer = Pointer . to ( new double [ ] { value } ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof double [ ] ) { double [ ] value = ( double [ ] ) arg ; Pointer pointer = Pointer . to ( value ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof float [ ] ) { float [ ] value = ( float [ ] ) arg ; Pointer pointer = Pointer . to ( value ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof int [ ] ) { int [ ] value = ( int [ ] ) arg ; Pointer pointer = Pointer . to ( value ) ; kernelParameters [ i ] = pointer ; } else if ( arg instanceof jcuda . jcurand . curandGenerator ) { jcuda . jcurand . curandGenerator rng = ( jcuda . jcurand . curandGenerator ) arg ; kernelParameters [ i ] = Pointer . to ( rng ) ; } else { throw new CudaException ( <str> + arg . getClass ( ) + <str> ) ; } } cuLaunchKernel ( function , gridSize . x , gridSize . y , gridSize . z , blockSize . x , blockSize . y , blockSize . z , sharedMemSize , stream , Pointer . to ( kernelParameters ) , null ) ; ContextHolder . syncStream ( ) ; try { } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } private static String preparePtxFile ( String cuFileName , boolean forceRebuild , String . . . nvccArguments ) throws IOException { logger . info ( <str> + cuFileName ) ; File cuFile = new File ( cuFileName ) ; if ( ! cuFile . exists ( ) ) throw new CudaException ( <str> + cuFileName ) ; String ptxFileName = null ; int lastIndex = cuFileName . lastIndexOf ( <str> ) ; if ( lastIndex = = - <int> ) ptxFileName = cuFileName + <str> ; else ptxFileName = cuFileName . substring ( <int> , lastIndex ) + <str> ; File ptxFile = new File ( ptxFileName ) ; if ( ptxFile . exists ( ) & & ! forceRebuild ) { long cuLastModified = cuFile . lastModified ( ) ; long ptxLastModified = ptxFile . lastModified ( ) ; if ( cuLastModified < ptxLastModified ) return ptxFileName ; } String modelString = <str> + System . getProperty ( <str> ) ; String defaultArguments = <str> ; String optionalArguments = createArgumentsString ( nvccArguments ) ; String command = compilerPath + <str> + modelString + <str> + defaultArguments + <str> + optionalArguments + <str> + cuFile . getPath ( ) + <str> + ptxFileName ; logger . info ( <str> + command ) ; Process process = Runtime . getRuntime ( ) . exec ( command ) ; String errorMessage = new String ( toByteArray ( process . getErrorStream ( ) ) ) ; String outputMessage = new String ( toByteArray ( process . getInputStream ( ) ) ) ; int exitValue = <int> ; try { exitValue = process . waitFor ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new CudaException ( <str> , e ) ; } logger . info ( <str> + exitValue ) ; if ( exitValue ! = <int> ) { logger . error ( <str> + errorMessage ) ; logger . error ( <str> + outputMessage ) ; throw new CudaException ( <str> + errorMessage ) ; } return ptxFileName ; } private static String createArgumentsString ( String . . . nvccArguments ) { if ( nvccArguments = = null | | nvccArguments . length = = <int> ) { return <str> ; } StringBuilder sb = new StringBuilder ( ) ; for ( String s : nvccArguments ) { sb . append ( s ) ; sb . append ( <str> ) ; } return sb . toString ( ) ; } private static byte [ ] toByteArray ( InputStream inputStream ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte buffer [ ] = new byte [ <int> ] ; while ( true ) { int read = inputStream . read ( buffer ) ; if ( read = = - <int> ) { break ; } baos . write ( buffer , <int> , read ) ; } return baos . toByteArray ( ) ; } @Override public String toString ( ) { return <str> + <str> + deviceNumber + <str> + context + <str> + module + <str> + function + <str> + blockSize + <str> + gridSize + <str> + sharedMemSize + <str> + stream + <str> ; } } 
