package org . gradle . api . internal ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . internal . reflect . ObjectInstantiationException ; import org . gradle . internal . service . ServiceRegistry ; import javax . inject . Inject ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . List ; public class DependencyInjectingInstantiator implements Instantiator { private final ServiceRegistry services ; public DependencyInjectingInstantiator ( ServiceRegistry services ) { this . services = services ; } public < T > T newInstance ( Class < ? extends T > type , Object . . . parameters ) { try { validateType ( type ) ; Constructor < ? > constructor = selectConstructor ( type ) ; constructor . setAccessible ( true ) ; Object [ ] resolvedParameters = convertParameters ( type , constructor , parameters ) ; try { return type . cast ( constructor . newInstance ( resolvedParameters ) ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } } catch ( Throwable e ) { throw new ObjectInstantiationException ( type , e ) ; } } private < T > Object [ ] convertParameters ( Class < T > type , Constructor < ? > match , Object [ ] parameters ) { Class < ? > [ ] parameterTypes = match . getParameterTypes ( ) ; if ( parameterTypes . length < parameters . length ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) , parameterTypes . length , parameters . length ) ) ; } Object [ ] resolvedParameters = new Object [ parameterTypes . length ] ; int pos = <int> ; for ( int i = <int> ; i < resolvedParameters . length ; i + + ) { Class < ? > targetType = parameterTypes [ i ] ; if ( targetType . isPrimitive ( ) ) { targetType = JavaReflectionUtil . getWrapperTypeForPrimitiveType ( targetType ) ; } if ( pos < parameters . length & & targetType . isInstance ( parameters [ pos ] ) ) { resolvedParameters [ i ] = parameters [ pos ] ; pos + + ; } else { resolvedParameters [ i ] = services . get ( match . getGenericParameterTypes ( ) [ i ] ) ; } } if ( pos ! = parameters . length ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } return resolvedParameters ; } private < T > Constructor < ? > selectConstructor ( Class < T > type ) { Constructor < ? > [ ] constructors = type . getDeclaredConstructors ( ) ; if ( constructors . length = = <int> ) { Constructor < ? > constructor = constructors [ <int> ] ; if ( constructor . getParameterTypes ( ) . length = = <int> & & isPublicOrPackageScoped ( type , constructor ) ) { return constructor ; } } List < Constructor < ? > > injectConstructors = new ArrayList < Constructor < ? > > ( ) ; for ( Constructor < ? > constructor : constructors ) { if ( constructor . getAnnotation ( Inject . class ) ! = null ) { injectConstructors . add ( constructor ) ; } } if ( injectConstructors . isEmpty ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } if ( injectConstructors . size ( ) > <int> ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } return injectConstructors . get ( <int> ) ; } private static boolean isPublicOrPackageScoped ( Class < ? > type , Constructor < ? > constructor ) { if ( isPackagePrivate ( type . getModifiers ( ) ) ) { return ! Modifier . isPrivate ( constructor . getModifiers ( ) ) & & ! Modifier . isProtected ( constructor . getModifiers ( ) ) ; } else { return Modifier . isPublic ( constructor . getModifiers ( ) ) ; } } private static boolean isPackagePrivate ( int modifiers ) { return ! Modifier . isPrivate ( modifiers ) & & ! Modifier . isProtected ( modifiers ) & & ! Modifier . isPublic ( modifiers ) ; } private < T > void validateType ( Class < T > type ) { if ( type . isInterface ( ) | | type . isAnnotation ( ) | | type . isEnum ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } if ( type . getEnclosingClass ( ) ! = null & & ! Modifier . isStatic ( type . getModifiers ( ) ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } if ( Modifier . isAbstract ( type . getModifiers ( ) ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } } } 
