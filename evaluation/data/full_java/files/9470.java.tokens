package com . google . common . net ; import com . google . common . annotations . Beta ; import com . google . common . base . MoreObjects ; import com . google . common . base . Preconditions ; import com . google . common . base . Splitter ; import com . google . common . hash . Hashing ; import com . google . common . io . ByteStreams ; import com . google . common . primitives . Ints ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Locale ; import javax . annotation . Nullable ; @Beta public final class InetAddresses { private static final int IPV4_PART_COUNT = <int> ; private static final int IPV6_PART_COUNT = <int> ; private static final Splitter IPV4_SPLITTER = Splitter . on ( <str> ) . limit ( IPV4_PART_COUNT ) ; private static final Inet4Address LOOPBACK4 = ( Inet4Address ) forString ( <str> ) ; private static final Inet4Address ANY4 = ( Inet4Address ) forString ( <str> ) ; private InetAddresses ( ) { } private static Inet4Address getInet4Address ( byte [ ] bytes ) { Preconditions . checkArgument ( bytes . length = = <int> , <str> , bytes . length ) ; return ( Inet4Address ) bytesToInetAddress ( bytes ) ; } public static InetAddress forString ( String ipString ) { byte [ ] addr = ipStringToBytes ( ipString ) ; if ( addr = = null ) { throw formatIllegalArgumentException ( <str> , ipString ) ; } return bytesToInetAddress ( addr ) ; } public static boolean isInetAddress ( String ipString ) { return ipStringToBytes ( ipString ) ! = null ; } private static byte [ ] ipStringToBytes ( String ipString ) { boolean hasColon = false ; boolean hasDot = false ; for ( int i = <int> ; i < ipString . length ( ) ; i + + ) { char c = ipString . charAt ( i ) ; if ( c = = <str> ) { hasDot = true ; } else if ( c = = <str> ) { if ( hasDot ) { return null ; } hasColon = true ; } else if ( Character . digit ( c , <int> ) = = - <int> ) { return null ; } } if ( hasColon ) { if ( hasDot ) { ipString = convertDottedQuadToHex ( ipString ) ; if ( ipString = = null ) { return null ; } } return textToNumericFormatV6 ( ipString ) ; } else if ( hasDot ) { return textToNumericFormatV4 ( ipString ) ; } return null ; } private static byte [ ] textToNumericFormatV4 ( String ipString ) { byte [ ] bytes = new byte [ IPV4_PART_COUNT ] ; int i = <int> ; try { for ( String octet : IPV4_SPLITTER . split ( ipString ) ) { bytes [ i + + ] = parseOctet ( octet ) ; } } catch ( NumberFormatException ex ) { return null ; } return i = = IPV4_PART_COUNT ? bytes : null ; } private static byte [ ] textToNumericFormatV6 ( String ipString ) { String [ ] parts = ipString . split ( <str> , IPV6_PART_COUNT + <int> ) ; if ( parts . length < <int> | | parts . length > IPV6_PART_COUNT + <int> ) { return null ; } int skipIndex = - <int> ; for ( int i = <int> ; i < parts . length - <int> ; i + + ) { if ( parts [ i ] . length ( ) = = <int> ) { if ( skipIndex > = <int> ) { return null ; } skipIndex = i ; } } int partsHi ; int partsLo ; if ( skipIndex > = <int> ) { partsHi = skipIndex ; partsLo = parts . length - skipIndex - <int> ; if ( parts [ <int> ] . length ( ) = = <int> & & - - partsHi ! = <int> ) { return null ; } if ( parts [ parts . length - <int> ] . length ( ) = = <int> & & - - partsLo ! = <int> ) { return null ; } } else { partsHi = parts . length ; partsLo = <int> ; } int partsSkipped = IPV6_PART_COUNT - ( partsHi + partsLo ) ; if ( ! ( skipIndex > = <int> ? partsSkipped > = <int> : partsSkipped = = <int> ) ) { return null ; } ByteBuffer rawBytes = ByteBuffer . allocate ( <int> * IPV6_PART_COUNT ) ; try { for ( int i = <int> ; i < partsHi ; i + + ) { rawBytes . putShort ( parseHextet ( parts [ i ] ) ) ; } for ( int i = <int> ; i < partsSkipped ; i + + ) { rawBytes . putShort ( ( short ) <int> ) ; } for ( int i = partsLo ; i > <int> ; i - - ) { rawBytes . putShort ( parseHextet ( parts [ parts . length - i ] ) ) ; } } catch ( NumberFormatException ex ) { return null ; } return rawBytes . array ( ) ; } private static String convertDottedQuadToHex ( String ipString ) { int lastColon = ipString . lastIndexOf ( <str> ) ; String initialPart = ipString . substring ( <int> , lastColon + <int> ) ; String dottedQuad = ipString . substring ( lastColon + <int> ) ; byte [ ] quad = textToNumericFormatV4 ( dottedQuad ) ; if ( quad = = null ) { return null ; } String penultimate = Integer . toHexString ( ( ( quad [ <int> ] & <hex> ) < < <int> ) | ( quad [ <int> ] & <hex> ) ) ; String ultimate = Integer . toHexString ( ( ( quad [ <int> ] & <hex> ) < < <int> ) | ( quad [ <int> ] & <hex> ) ) ; return initialPart + penultimate + <str> + ultimate ; } private static byte parseOctet ( String ipPart ) { int octet = Integer . parseInt ( ipPart ) ; if ( octet > <int> | | ( ipPart . startsWith ( <str> ) & & ipPart . length ( ) > <int> ) ) { throw new NumberFormatException ( ) ; } return ( byte ) octet ; } private static short parseHextet ( String ipPart ) { int hextet = Integer . parseInt ( ipPart , <int> ) ; if ( hextet > <hex> ) { throw new NumberFormatException ( ) ; } return ( short ) hextet ; } private static InetAddress bytesToInetAddress ( byte [ ] addr ) { try { return InetAddress . getByAddress ( addr ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } public static String toAddrString ( InetAddress ip ) { Preconditions . checkNotNull ( ip ) ; if ( ip instanceof Inet4Address ) { return ip . getHostAddress ( ) ; } Preconditions . checkArgument ( ip instanceof Inet6Address ) ; byte [ ] bytes = ip . getAddress ( ) ; int [ ] hextets = new int [ IPV6_PART_COUNT ] ; for ( int i = <int> ; i < hextets . length ; i + + ) { hextets [ i ] = Ints . fromBytes ( ( byte ) <int> , ( byte ) <int> , bytes [ <int> * i ] , bytes [ <int> * i + <int> ] ) ; } compressLongestRunOfZeroes ( hextets ) ; return hextetsToIPv6String ( hextets ) ; } private static void compressLongestRunOfZeroes ( int [ ] hextets ) { int bestRunStart = - <int> ; int bestRunLength = - <int> ; int runStart = - <int> ; for ( int i = <int> ; i < hextets . length + <int> ; i + + ) { if ( i < hextets . length & & hextets [ i ] = = <int> ) { if ( runStart < <int> ) { runStart = i ; } } else if ( runStart > = <int> ) { int runLength = i - runStart ; if ( runLength > bestRunLength ) { bestRunStart = runStart ; bestRunLength = runLength ; } runStart = - <int> ; } } if ( bestRunLength > = <int> ) { Arrays . fill ( hextets , bestRunStart , bestRunStart + bestRunLength , - <int> ) ; } } private static String hextetsToIPv6String ( int [ ] hextets ) { StringBuilder buf = new StringBuilder ( <int> ) ; boolean lastWasNumber = false ; for ( int i = <int> ; i < hextets . length ; i + + ) { boolean thisIsNumber = hextets [ i ] > = <int> ; if ( thisIsNumber ) { if ( lastWasNumber ) { buf . append ( <str> ) ; } buf . append ( Integer . toHexString ( hextets [ i ] ) ) ; } else { if ( i = = <int> | | lastWasNumber ) { buf . append ( <str> ) ; } } lastWasNumber = thisIsNumber ; } return buf . toString ( ) ; } public static String toUriString ( InetAddress ip ) { if ( ip instanceof Inet6Address ) { return <str> + toAddrString ( ip ) + <str> ; } return toAddrString ( ip ) ; } public static InetAddress forUriString ( String hostAddr ) { Preconditions . checkNotNull ( hostAddr ) ; String ipString ; int expectBytes ; if ( hostAddr . startsWith ( <str> ) & & hostAddr . endsWith ( <str> ) ) { ipString = hostAddr . substring ( <int> , hostAddr . length ( ) - <int> ) ; expectBytes = <int> ; } else { ipString = hostAddr ; expectBytes = <int> ; } byte [ ] addr = ipStringToBytes ( ipString ) ; if ( addr = = null | | addr . length ! = expectBytes ) { throw formatIllegalArgumentException ( <str> , hostAddr ) ; } return bytesToInetAddress ( addr ) ; } public static boolean isUriInetAddress ( String ipString ) { try { forUriString ( ipString ) ; return true ; } catch ( IllegalArgumentException e ) { return false ; } } public static boolean isCompatIPv4Address ( Inet6Address ip ) { if ( ! ip . isIPv4CompatibleAddress ( ) ) { return false ; } byte [ ] bytes = ip . getAddress ( ) ; if ( ( bytes [ <int> ] = = <int> ) & & ( bytes [ <int> ] = = <int> ) & & ( bytes [ <int> ] = = <int> ) & & ( ( bytes [ <int> ] = = <int> ) | | ( bytes [ <int> ] = = <int> ) ) ) { return false ; } return true ; } public static Inet4Address getCompatIPv4Address ( Inet6Address ip ) { Preconditions . checkArgument ( isCompatIPv4Address ( ip ) , <str> , toAddrString ( ip ) ) ; return getInet4Address ( Arrays . copyOfRange ( ip . getAddress ( ) , <int> , <int> ) ) ; } public static boolean is6to4Address ( Inet6Address ip ) { byte [ ] bytes = ip . getAddress ( ) ; return ( bytes [ <int> ] = = ( byte ) <hex> ) & & ( bytes [ <int> ] = = ( byte ) <hex> ) ; } public static Inet4Address get6to4IPv4Address ( Inet6Address ip ) { Preconditions . checkArgument ( is6to4Address ( ip ) , <str> , toAddrString ( ip ) ) ; return getInet4Address ( Arrays . copyOfRange ( ip . getAddress ( ) , <int> , <int> ) ) ; } @Beta public static final class TeredoInfo { private final Inet4Address server ; private final Inet4Address client ; private final int port ; private final int flags ; public TeredoInfo ( @Nullable Inet4Address server , @Nullable Inet4Address client , int port , int flags ) { Preconditions . checkArgument ( ( port > = <int> ) & & ( port < = <hex> ) , <str> , port ) ; Preconditions . checkArgument ( ( flags > = <int> ) & & ( flags < = <hex> ) , <str> , flags ) ; this . server = MoreObjects . firstNonNull ( server , ANY4 ) ; this . client = MoreObjects . firstNonNull ( client , ANY4 ) ; this . port = port ; this . flags = flags ; } public Inet4Address getServer ( ) { return server ; } public Inet4Address getClient ( ) { return client ; } public int getPort ( ) { return port ; } public int getFlags ( ) { return flags ; } } public static boolean isTeredoAddress ( Inet6Address ip ) { byte [ ] bytes = ip . getAddress ( ) ; return ( bytes [ <int> ] = = ( byte ) <hex> ) & & ( bytes [ <int> ] = = ( byte ) <hex> ) & & ( bytes [ <int> ] = = <int> ) & & ( bytes [ <int> ] = = <int> ) ; } public static TeredoInfo getTeredoInfo ( Inet6Address ip ) { Preconditions . checkArgument ( isTeredoAddress ( ip ) , <str> , toAddrString ( ip ) ) ; byte [ ] bytes = ip . getAddress ( ) ; Inet4Address server = getInet4Address ( Arrays . copyOfRange ( bytes , <int> , <int> ) ) ; int flags = ByteStreams . newDataInput ( bytes , <int> ) . readShort ( ) & <hex> ; int port = ~ ByteStreams . newDataInput ( bytes , <int> ) . readShort ( ) & <hex> ; byte [ ] clientBytes = Arrays . copyOfRange ( bytes , <int> , <int> ) ; for ( int i = <int> ; i < clientBytes . length ; i + + ) { clientBytes [ i ] = ( byte ) ~ clientBytes [ i ] ; } Inet4Address client = getInet4Address ( clientBytes ) ; return new TeredoInfo ( server , client , port , flags ) ; } public static boolean isIsatapAddress ( Inet6Address ip ) { if ( isTeredoAddress ( ip ) ) { return false ; } byte [ ] bytes = ip . getAddress ( ) ; if ( ( bytes [ <int> ] | ( byte ) <hex> ) ! = ( byte ) <hex> ) { return false ; } return ( bytes [ <int> ] = = ( byte ) <hex> ) & & ( bytes [ <int> ] = = ( byte ) <hex> ) & & ( bytes [ <int> ] = = ( byte ) <hex> ) ; } public static Inet4Address getIsatapIPv4Address ( Inet6Address ip ) { Preconditions . checkArgument ( isIsatapAddress ( ip ) , <str> , toAddrString ( ip ) ) ; return getInet4Address ( Arrays . copyOfRange ( ip . getAddress ( ) , <int> , <int> ) ) ; } public static boolean hasEmbeddedIPv4ClientAddress ( Inet6Address ip ) { return isCompatIPv4Address ( ip ) | | is6to4Address ( ip ) | | isTeredoAddress ( ip ) ; } public static Inet4Address getEmbeddedIPv4ClientAddress ( Inet6Address ip ) { if ( isCompatIPv4Address ( ip ) ) { return getCompatIPv4Address ( ip ) ; } if ( is6to4Address ( ip ) ) { return get6to4IPv4Address ( ip ) ; } if ( isTeredoAddress ( ip ) ) { return getTeredoInfo ( ip ) . getClient ( ) ; } throw formatIllegalArgumentException ( <str> , toAddrString ( ip ) ) ; } public static boolean isMappedIPv4Address ( String ipString ) { byte [ ] bytes = ipStringToBytes ( ipString ) ; if ( bytes ! = null & & bytes . length = = <int> ) { for ( int i = <int> ; i < <int> ; i + + ) { if ( bytes [ i ] ! = <int> ) { return false ; } } for ( int i = <int> ; i < <int> ; i + + ) { if ( bytes [ i ] ! = ( byte ) <hex> ) { return false ; } } return true ; } return false ; } public static Inet4Address getCoercedIPv4Address ( InetAddress ip ) { if ( ip instanceof Inet4Address ) { return ( Inet4Address ) ip ; } byte [ ] bytes = ip . getAddress ( ) ; boolean leadingBytesOfZero = true ; for ( int i = <int> ; i < <int> ; + + i ) { if ( bytes [ i ] ! = <int> ) { leadingBytesOfZero = false ; break ; } } if ( leadingBytesOfZero & & ( bytes [ <int> ] = = <int> ) ) { return LOOPBACK4 ; } else if ( leadingBytesOfZero & & ( bytes [ <int> ] = = <int> ) ) { return ANY4 ; } Inet6Address ip6 = ( Inet6Address ) ip ; long addressAsLong = <int> ; if ( hasEmbeddedIPv4ClientAddress ( ip6 ) ) { addressAsLong = getEmbeddedIPv4ClientAddress ( ip6 ) . hashCode ( ) ; } else { addressAsLong = ByteBuffer . wrap ( ip6 . getAddress ( ) , <int> , <int> ) . getLong ( ) ; } int coercedHash = Hashing . murmur3_32 ( ) . hashLong ( addressAsLong ) . asInt ( ) ; coercedHash | = <hex> ; if ( coercedHash = = <hex> ) { coercedHash = <hex> ; } return getInet4Address ( Ints . toByteArray ( coercedHash ) ) ; } public static int coerceToInteger ( InetAddress ip ) { return ByteStreams . newDataInput ( getCoercedIPv4Address ( ip ) . getAddress ( ) ) . readInt ( ) ; } public static Inet4Address fromInteger ( int address ) { return getInet4Address ( Ints . toByteArray ( address ) ) ; } public static InetAddress fromLittleEndianByteArray ( byte [ ] addr ) throws UnknownHostException { byte [ ] reversed = new byte [ addr . length ] ; for ( int i = <int> ; i < addr . length ; i + + ) { reversed [ i ] = addr [ addr . length - i - <int> ] ; } return InetAddress . getByAddress ( reversed ) ; } public static InetAddress decrement ( InetAddress address ) { byte [ ] addr = address . getAddress ( ) ; int i = addr . length - <int> ; while ( i > = <int> & & addr [ i ] = = ( byte ) <hex> ) { addr [ i ] = ( byte ) <hex> ; i - - ; } Preconditions . checkArgument ( i > = <int> , <str> , address ) ; addr [ i ] - - ; return bytesToInetAddress ( addr ) ; } public static InetAddress increment ( InetAddress address ) { byte [ ] addr = address . getAddress ( ) ; int i = addr . length - <int> ; while ( i > = <int> & & addr [ i ] = = ( byte ) <hex> ) { addr [ i ] = <int> ; i - - ; } Preconditions . checkArgument ( i > = <int> , <str> , address ) ; addr [ i ] + + ; return bytesToInetAddress ( addr ) ; } public static boolean isMaximum ( InetAddress address ) { byte [ ] addr = address . getAddress ( ) ; for ( int i = <int> ; i < addr . length ; i + + ) { if ( addr [ i ] ! = ( byte ) <hex> ) { return false ; } } return true ; } private static IllegalArgumentException formatIllegalArgumentException ( String format , Object . . . args ) { return new IllegalArgumentException ( String . format ( Locale . ROOT , format , args ) ) ; } } 
