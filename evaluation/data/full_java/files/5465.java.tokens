package org . elasticsearch . action . termvectors . dfs ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . index . query . BoolQueryBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import java . io . IOException ; import java . util . Arrays ; import java . util . Set ; import static org . elasticsearch . index . query . QueryBuilders . boolQuery ; public class DfsOnlyRequest extends BroadcastRequest < DfsOnlyRequest > { private SearchRequest searchRequest = new SearchRequest ( ) ; long nowInMillis ; public DfsOnlyRequest ( ) { } public DfsOnlyRequest ( Fields termVectorsFields , String [ ] indices , String [ ] types , Set < String > selectedFields ) throws IOException { super ( indices ) ; final BoolQueryBuilder boolBuilder = boolQuery ( ) ; for ( String fieldName : termVectorsFields ) { if ( ( selectedFields ! = null ) & & ( ! selectedFields . contains ( fieldName ) ) ) { continue ; } Terms terms = termVectorsFields . terms ( fieldName ) ; TermsEnum iterator = terms . iterator ( ) ; while ( iterator . next ( ) ! = null ) { String text = iterator . term ( ) . utf8ToString ( ) ; boolBuilder . should ( QueryBuilders . termQuery ( fieldName , text ) ) ; } } this . searchRequest = new SearchRequest ( indices ) . types ( types ) . source ( new SearchSourceBuilder ( ) . query ( boolBuilder ) ) ; } public SearchRequest getSearchRequest ( ) { return searchRequest ; } @Override public ActionRequestValidationException validate ( ) { return searchRequest . validate ( ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; this . searchRequest . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; this . searchRequest . writeTo ( out ) ; } public String [ ] types ( ) { return this . searchRequest . types ( ) ; } public String routing ( ) { return this . searchRequest . routing ( ) ; } public String preference ( ) { return this . searchRequest . preference ( ) ; } @Override public String toString ( ) { String sSource = <str> ; if ( searchRequest . source ( ) ! = null ) { sSource = searchRequest . source ( ) . toString ( ) ; } return <str> + Arrays . toString ( indices ) + <str> + Arrays . toString ( types ( ) ) + <str> + sSource + <str> ; } } 
