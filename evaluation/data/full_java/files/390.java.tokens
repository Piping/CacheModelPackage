package org . apache . cassandra . db . compaction ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Joiner ; import com . google . common . collect . * ; import com . google . common . primitives . Doubles ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . FBUtilities ; public class LeveledCompactionStrategy extends AbstractCompactionStrategy { private static final Logger logger = LoggerFactory . getLogger ( LeveledCompactionStrategy . class ) ; private static final String SSTABLE_SIZE_OPTION = <str> ; @VisibleForTesting final LeveledManifest manifest ; private final int maxSSTableSizeInMB ; public LeveledCompactionStrategy ( ColumnFamilyStore cfs , Map < String , String > options ) { super ( cfs , options ) ; int configuredMaxSSTableSize = <int> ; SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions ( options ) ; if ( options ! = null ) { if ( options . containsKey ( SSTABLE_SIZE_OPTION ) ) { configuredMaxSSTableSize = Integer . parseInt ( options . get ( SSTABLE_SIZE_OPTION ) ) ; if ( ! Boolean . getBoolean ( <str> ) ) { if ( configuredMaxSSTableSize > = <int> ) logger . warn ( <str> , configuredMaxSSTableSize , cfs . name , cfs . getColumnFamilyName ( ) ) ; if ( configuredMaxSSTableSize < <int> ) logger . warn ( <str> , configuredMaxSSTableSize , cfs . name , cfs . getColumnFamilyName ( ) ) ; } } } maxSSTableSizeInMB = configuredMaxSSTableSize ; manifest = new LeveledManifest ( cfs , this . maxSSTableSizeInMB , localOptions ) ; logger . trace ( <str> , manifest ) ; } public int getLevelSize ( int i ) { return manifest . getLevelSize ( i ) ; } public int [ ] getAllLevelSize ( ) { return manifest . getAllLevelSize ( ) ; } @SuppressWarnings ( <str> ) public synchronized AbstractCompactionTask getNextBackgroundTask ( int gcBefore ) { while ( true ) { OperationType op ; LeveledManifest . CompactionCandidate candidate = manifest . getCompactionCandidates ( ) ; if ( candidate = = null ) { SSTableReader sstable = findDroppableSSTable ( gcBefore ) ; if ( sstable = = null ) { logger . trace ( <str> , this ) ; return null ; } candidate = new LeveledManifest . CompactionCandidate ( Collections . singleton ( sstable ) , sstable . getSSTableLevel ( ) , getMaxSSTableBytes ( ) ) ; op = OperationType . TOMBSTONE_COMPACTION ; } else { op = OperationType . COMPACTION ; } LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( candidate . sstables , OperationType . COMPACTION ) ; if ( txn ! = null ) { LeveledCompactionTask newTask = new LeveledCompactionTask ( cfs , txn , candidate . level , gcBefore , candidate . maxSSTableBytes , false ) ; newTask . setCompactionType ( op ) ; return newTask ; } } } @SuppressWarnings ( <str> ) public synchronized Collection < AbstractCompactionTask > getMaximalTask ( int gcBefore , boolean splitOutput ) { Iterable < SSTableReader > sstables = manifest . getAllSSTables ( ) ; Iterable < SSTableReader > filteredSSTables = filterSuspectSSTables ( sstables ) ; if ( Iterables . isEmpty ( sstables ) ) return null ; LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( filteredSSTables , OperationType . COMPACTION ) ; if ( txn = = null ) return null ; return Arrays . < AbstractCompactionTask > asList ( new LeveledCompactionTask ( cfs , txn , <int> , gcBefore , getMaxSSTableBytes ( ) , true ) ) ; } @Override public AbstractCompactionTask getUserDefinedTask ( Collection < SSTableReader > sstables , int gcBefore ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public AbstractCompactionTask getCompactionTask ( LifecycleTransaction txn , int gcBefore , long maxSSTableBytes ) { assert txn . originals ( ) . size ( ) > <int> ; int level = - <int> ; for ( SSTableReader sstable : txn . originals ( ) ) { if ( level = = - <int> ) level = sstable . getSSTableLevel ( ) ; if ( level ! = sstable . getSSTableLevel ( ) ) level = <int> ; } return new LeveledCompactionTask ( cfs , txn , level , gcBefore , maxSSTableBytes , false ) ; } @Override public Collection < Collection < SSTableReader > > groupSSTablesForAntiCompaction ( Collection < SSTableReader > ssTablesToGroup ) { int groupSize = <int> ; Map < Integer , Collection < SSTableReader > > sstablesByLevel = new HashMap < > ( ) ; for ( SSTableReader sstable : ssTablesToGroup ) { Integer level = sstable . getSSTableLevel ( ) ; if ( ! sstablesByLevel . containsKey ( level ) ) { sstablesByLevel . put ( level , new ArrayList < SSTableReader > ( ) ) ; } sstablesByLevel . get ( level ) . add ( sstable ) ; } Collection < Collection < SSTableReader > > groupedSSTables = new ArrayList < > ( ) ; for ( Collection < SSTableReader > levelOfSSTables : sstablesByLevel . values ( ) ) { Collection < SSTableReader > currGroup = new ArrayList < > ( ) ; for ( SSTableReader sstable : levelOfSSTables ) { currGroup . add ( sstable ) ; if ( currGroup . size ( ) = = groupSize ) { groupedSSTables . add ( currGroup ) ; currGroup = new ArrayList < > ( ) ; } } if ( currGroup . size ( ) ! = <int> ) groupedSSTables . add ( currGroup ) ; } return groupedSSTables ; } public int getEstimatedRemainingTasks ( ) { return manifest . getEstimatedTasks ( ) ; } public long getMaxSSTableBytes ( ) { return maxSSTableSizeInMB * <int> * <int> ; } public ScannerList getScanners ( Collection < SSTableReader > sstables , Range < Token > range ) { Multimap < Integer , SSTableReader > byLevel = ArrayListMultimap . create ( ) ; for ( SSTableReader sstable : sstables ) { byLevel . get ( sstable . getSSTableLevel ( ) ) . add ( sstable ) ; } List < ISSTableScanner > scanners = new ArrayList < ISSTableScanner > ( sstables . size ( ) ) ; try { for ( Integer level : byLevel . keySet ( ) ) { if ( level < = <int> ) { for ( SSTableReader sstable : byLevel . get ( level ) ) scanners . add ( sstable . getScanner ( range , CompactionManager . instance . getRateLimiter ( ) ) ) ; } else { List < SSTableReader > intersecting = LeveledScanner . intersecting ( byLevel . get ( level ) , range ) ; if ( ! intersecting . isEmpty ( ) ) { @SuppressWarnings ( <str> ) ISSTableScanner scanner = new LeveledScanner ( intersecting , range ) ; scanners . add ( scanner ) ; } } } } catch ( Throwable t ) { try { new ScannerList ( scanners ) . close ( ) ; } catch ( Throwable t2 ) { t . addSuppressed ( t2 ) ; } throw t ; } return new ScannerList ( scanners ) ; } @Override public void replaceSSTables ( Collection < SSTableReader > removed , Collection < SSTableReader > added ) { manifest . replace ( removed , added ) ; } @Override public void addSSTable ( SSTableReader added ) { manifest . add ( added ) ; } @Override public void removeSSTable ( SSTableReader sstable ) { manifest . remove ( sstable ) ; } private static class LeveledScanner extends AbstractIterator < UnfilteredRowIterator > implements ISSTableScanner { private final Range < Token > range ; private final List < SSTableReader > sstables ; private final Iterator < SSTableReader > sstableIterator ; private final long totalLength ; private ISSTableScanner currentScanner ; private long positionOffset ; public LeveledScanner ( Collection < SSTableReader > sstables , Range < Token > range ) { this . range = range ; this . sstables = new ArrayList < > ( sstables . size ( ) ) ; long length = <int> ; for ( SSTableReader sstable : sstables ) { this . sstables . add ( sstable ) ; long estimatedKeys = sstable . estimatedKeys ( ) ; double estKeysInRangeRatio = <float> ; if ( estimatedKeys > <int> & & range ! = null ) estKeysInRangeRatio = ( ( double ) sstable . estimatedKeysForRanges ( Collections . singleton ( range ) ) ) / estimatedKeys ; length + = sstable . uncompressedLength ( ) * estKeysInRangeRatio ; } totalLength = length ; Collections . sort ( this . sstables , SSTableReader . sstableComparator ) ; sstableIterator = this . sstables . iterator ( ) ; assert sstableIterator . hasNext ( ) ; currentScanner = sstableIterator . next ( ) . getScanner ( range , CompactionManager . instance . getRateLimiter ( ) ) ; } public static List < SSTableReader > intersecting ( Collection < SSTableReader > sstables , Range < Token > range ) { ArrayList < SSTableReader > filtered = new ArrayList < > ( ) ; for ( SSTableReader sstable : sstables ) { Range < Token > sstableRange = new Range < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ; if ( range = = null | | sstableRange . intersects ( range ) ) filtered . add ( sstable ) ; } return filtered ; } public boolean isForThrift ( ) { return false ; } public CFMetaData metadata ( ) { return sstables . get ( <int> ) . metadata ; } protected UnfilteredRowIterator computeNext ( ) { if ( currentScanner = = null ) return endOfData ( ) ; while ( true ) { if ( currentScanner . hasNext ( ) ) return currentScanner . next ( ) ; positionOffset + = currentScanner . getLengthInBytes ( ) ; currentScanner . close ( ) ; if ( ! sstableIterator . hasNext ( ) ) { currentScanner = null ; return endOfData ( ) ; } currentScanner = sstableIterator . next ( ) . getScanner ( range , CompactionManager . instance . getRateLimiter ( ) ) ; } } public void close ( ) { if ( currentScanner ! = null ) currentScanner . close ( ) ; } public long getLengthInBytes ( ) { return totalLength ; } public long getCurrentPosition ( ) { return positionOffset + ( currentScanner = = null ? <int> L : currentScanner . getCurrentPosition ( ) ) ; } public String getBackingFiles ( ) { return Joiner . on ( <str> ) . join ( sstables ) ; } } @Override public String toString ( ) { return String . format ( <str> , hashCode ( ) , cfs . name ) ; } private SSTableReader findDroppableSSTable ( final int gcBefore ) { level : for ( int i = manifest . getLevelCount ( ) ; i > = <int> ; i - - ) { SortedSet < SSTableReader > sstables = manifest . getLevelSorted ( i , new Comparator < SSTableReader > ( ) { public int compare ( SSTableReader o1 , SSTableReader o2 ) { double r1 = o1 . getEstimatedDroppableTombstoneRatio ( gcBefore ) ; double r2 = o2 . getEstimatedDroppableTombstoneRatio ( gcBefore ) ; return - <int> * Doubles . compare ( r1 , r2 ) ; } } ) ; if ( sstables . isEmpty ( ) ) continue ; Set < SSTableReader > compacting = cfs . getTracker ( ) . getCompacting ( ) ; for ( SSTableReader sstable : sstables ) { if ( sstable . getEstimatedDroppableTombstoneRatio ( gcBefore ) < = tombstoneThreshold ) continue level ; else if ( ! compacting . contains ( sstable ) & & ! sstable . isMarkedSuspect ( ) & & worthDroppingTombstones ( sstable , gcBefore ) ) return sstable ; } } return null ; } public static Map < String , String > validateOptions ( Map < String , String > options ) throws ConfigurationException { Map < String , String > uncheckedOptions = AbstractCompactionStrategy . validateOptions ( options ) ; String size = options . containsKey ( SSTABLE_SIZE_OPTION ) ? options . get ( SSTABLE_SIZE_OPTION ) : <str> ; try { int ssSize = Integer . parseInt ( size ) ; if ( ssSize < <int> ) { throw new ConfigurationException ( String . format ( <str> , SSTABLE_SIZE_OPTION , ssSize ) ) ; } } catch ( NumberFormatException ex ) { throw new ConfigurationException ( String . format ( <str> , size , SSTABLE_SIZE_OPTION ) , ex ) ; } uncheckedOptions . remove ( SSTABLE_SIZE_OPTION ) ; uncheckedOptions = SizeTieredCompactionStrategyOptions . validateOptions ( options , uncheckedOptions ) ; return uncheckedOptions ; } } 
