package com . badlogic . gdx . graphics . g3d . utils ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . model . Node ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . Pool ; public class AnimationController extends BaseAnimationController { public interface AnimationListener { void onEnd ( final AnimationDesc animation ) ; void onLoop ( final AnimationDesc animation ) ; } public static class AnimationDesc { public AnimationListener listener ; public Animation animation ; public float speed ; public float time ; public float offset ; public float duration ; public int loopCount ; protected AnimationDesc ( ) { } protected float update ( float delta ) { if ( loopCount ! = <int> & & animation ! = null ) { int loops ; final float diff = speed * delta ; if ( ! MathUtils . isZero ( duration ) ) { time + = diff ; loops = ( int ) Math . abs ( time / duration ) ; if ( time < <float> ) { loops + + ; while ( time < <float> ) time + = duration ; } time = Math . abs ( time % duration ) ; } else loops = <int> ; for ( int i = <int> ; i < loops ; i + + ) { if ( loopCount > <int> ) loopCount - - ; if ( loopCount ! = <int> & & listener ! = null ) listener . onLoop ( this ) ; if ( loopCount = = <int> ) { final float result = ( ( loops - <int> ) - i ) * duration + ( diff < <float> ? duration - time : time ) ; time = ( diff < <float> ) ? <float> : duration ; if ( listener ! = null ) listener . onEnd ( this ) ; return result ; } } return <float> ; } else return delta ; } } protected final Pool < AnimationDesc > animationPool = new Pool < AnimationDesc > ( ) { @Override protected AnimationDesc newObject ( ) { return new AnimationDesc ( ) ; } } ; public AnimationDesc current ; public AnimationDesc queued ; public float queuedTransitionTime ; public AnimationDesc previous ; public float transitionCurrentTime ; public float transitionTargetTime ; public boolean inAction ; public boolean paused ; public boolean allowSameAnimation ; private boolean justChangedAnimation = false ; public AnimationController ( final ModelInstance target ) { super ( target ) ; } private AnimationDesc obtain ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationListener listener ) { if ( anim = = null ) return null ; final AnimationDesc result = animationPool . obtain ( ) ; result . animation = anim ; result . listener = listener ; result . loopCount = loopCount ; result . speed = speed ; result . offset = offset ; result . duration = duration < <int> ? ( anim . duration - offset ) : duration ; result . time = speed < <int> ? result . duration : <float> ; return result ; } private AnimationDesc obtain ( final String id , float offset , float duration , int loopCount , float speed , final AnimationListener listener ) { if ( id = = null ) return null ; final Animation anim = target . getAnimation ( id ) ; if ( anim = = null ) throw new GdxRuntimeException ( <str> + id ) ; return obtain ( anim , offset , duration , loopCount , speed , listener ) ; } private AnimationDesc obtain ( final AnimationDesc anim ) { return obtain ( anim . animation , anim . offset , anim . duration , anim . loopCount , anim . speed , anim . listener ) ; } public void update ( float delta ) { if ( paused ) return ; if ( previous ! = null & & ( ( transitionCurrentTime + = delta ) > = transitionTargetTime ) ) { removeAnimation ( previous . animation ) ; justChangedAnimation = true ; animationPool . free ( previous ) ; previous = null ; } if ( justChangedAnimation ) { target . calculateTransforms ( ) ; justChangedAnimation = false ; } if ( current = = null | | current . loopCount = = <int> | | current . animation = = null ) return ; final float remain = current . update ( delta ) ; if ( remain ! = <float> & & queued ! = null ) { inAction = false ; animate ( queued , queuedTransitionTime ) ; queued = null ; update ( remain ) ; return ; } if ( previous ! = null ) applyAnimations ( previous . animation , previous . offset + previous . time , current . animation , current . offset + current . time , transitionCurrentTime / transitionTargetTime ) ; else applyAnimation ( current . animation , current . offset + current . time ) ; } public AnimationDesc setAnimation ( final String id ) { return setAnimation ( id , <int> , <float> , null ) ; } public AnimationDesc setAnimation ( final String id , int loopCount ) { return setAnimation ( id , loopCount , <float> , null ) ; } public AnimationDesc setAnimation ( final String id , final AnimationListener listener ) { return setAnimation ( id , <int> , <float> , listener ) ; } public AnimationDesc setAnimation ( final String id , int loopCount , final AnimationListener listener ) { return setAnimation ( id , loopCount , <float> , listener ) ; } public AnimationDesc setAnimation ( final String id , int loopCount , float speed , final AnimationListener listener ) { return setAnimation ( id , <float> , - <float> , loopCount , speed , listener ) ; } public AnimationDesc setAnimation ( final String id , float offset , float duration , int loopCount , float speed , final AnimationListener listener ) { return setAnimation ( obtain ( id , offset , duration , loopCount , speed , listener ) ) ; } protected AnimationDesc setAnimation ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationListener listener ) { return setAnimation ( obtain ( anim , offset , duration , loopCount , speed , listener ) ) ; } protected AnimationDesc setAnimation ( final AnimationDesc anim ) { if ( current = = null ) current = anim ; else { if ( ! allowSameAnimation & & anim ! = null & & current . animation = = anim . animation ) anim . time = current . time ; else removeAnimation ( current . animation ) ; animationPool . free ( current ) ; current = anim ; } justChangedAnimation = true ; return anim ; } public AnimationDesc animate ( final String id , float transitionTime ) { return animate ( id , <int> , <float> , null , transitionTime ) ; } public AnimationDesc animate ( final String id , final AnimationListener listener , float transitionTime ) { return animate ( id , <int> , <float> , listener , transitionTime ) ; } public AnimationDesc animate ( final String id , int loopCount , final AnimationListener listener , float transitionTime ) { return animate ( id , loopCount , <float> , listener , transitionTime ) ; } public AnimationDesc animate ( final String id , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return animate ( id , <float> , - <float> , loopCount , speed , listener , transitionTime ) ; } public AnimationDesc animate ( final String id , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return animate ( obtain ( id , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc animate ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return animate ( obtain ( anim , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc animate ( final AnimationDesc anim , float transitionTime ) { if ( current = = null ) current = anim ; else if ( inAction ) queue ( anim , transitionTime ) ; else if ( ! allowSameAnimation & & anim ! = null & & current . animation = = anim . animation ) { anim . time = current . time ; animationPool . free ( current ) ; current = anim ; } else { if ( previous ! = null ) { removeAnimation ( previous . animation ) ; animationPool . free ( previous ) ; } previous = current ; current = anim ; transitionCurrentTime = <float> ; transitionTargetTime = transitionTime ; } return anim ; } public AnimationDesc queue ( final String id , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return queue ( id , <float> , - <float> , loopCount , speed , listener , transitionTime ) ; } public AnimationDesc queue ( final String id , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return queue ( obtain ( id , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc queue ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return queue ( obtain ( anim , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc queue ( final AnimationDesc anim , float transitionTime ) { if ( current = = null | | current . loopCount = = <int> ) animate ( anim , transitionTime ) ; else { if ( queued ! = null ) animationPool . free ( queued ) ; queued = anim ; queuedTransitionTime = transitionTime ; if ( current . loopCount < <int> ) current . loopCount = <int> ; } return anim ; } public AnimationDesc action ( final String id , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return action ( id , <int> , - <float> , loopCount , speed , listener , transitionTime ) ; } public AnimationDesc action ( final String id , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return action ( obtain ( id , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc action ( final Animation anim , float offset , float duration , int loopCount , float speed , final AnimationListener listener , float transitionTime ) { return action ( obtain ( anim , offset , duration , loopCount , speed , listener ) , transitionTime ) ; } protected AnimationDesc action ( final AnimationDesc anim , float transitionTime ) { if ( anim . loopCount < <int> ) throw new GdxRuntimeException ( <str> ) ; if ( current = = null | | current . loopCount = = <int> ) animate ( anim , transitionTime ) ; else { AnimationDesc toQueue = inAction ? null : obtain ( current ) ; inAction = false ; animate ( anim , transitionTime ) ; inAction = true ; if ( toQueue ! = null ) queue ( toQueue , transitionTime ) ; } return anim ; } } 
