package io . netty . example . sctp . multihoming ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . sctp . SctpChannel ; import io . netty . channel . sctp . SctpChannelOption ; import io . netty . channel . sctp . nio . NioSctpChannel ; import io . netty . example . sctp . SctpEchoClientHandler ; import java . net . InetAddress ; import java . net . InetSocketAddress ; public final class SctpMultiHomingEchoClient { private static final String CLIENT_PRIMARY_HOST = System . getProperty ( <str> , <str> ) ; private static final String CLIENT_SECONDARY_HOST = System . getProperty ( <str> , <str> ) ; private static final int CLIENT_PORT = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; private static final String SERVER_REMOTE_HOST = System . getProperty ( <str> , <str> ) ; private static final int SERVER_REMOTE_PORT = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; public static void main ( String [ ] args ) throws Exception { EventLoopGroup group = new NioEventLoopGroup ( ) ; try { Bootstrap b = new Bootstrap ( ) ; b . group ( group ) . channel ( NioSctpChannel . class ) . option ( SctpChannelOption . SCTP_NODELAY , true ) . handler ( new ChannelInitializer < SctpChannel > ( ) { @Override public void initChannel ( SctpChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new SctpEchoClientHandler ( ) ) ; } } ) ; InetSocketAddress localAddress = new InetSocketAddress ( CLIENT_PRIMARY_HOST , CLIENT_PORT ) ; InetAddress localSecondaryAddress = InetAddress . getByName ( CLIENT_SECONDARY_HOST ) ; InetSocketAddress remoteAddress = new InetSocketAddress ( SERVER_REMOTE_HOST , SERVER_REMOTE_PORT ) ; ChannelFuture bindFuture = b . bind ( localAddress ) . sync ( ) ; SctpChannel channel = ( SctpChannel ) bindFuture . channel ( ) ; channel . bindAddress ( localSecondaryAddress ) . sync ( ) ; ChannelFuture connectFuture = channel . connect ( remoteAddress ) . sync ( ) ; connectFuture . channel ( ) . closeFuture ( ) . sync ( ) ; } finally { group . shutdownGracefully ( ) ; } } } 
