package org . gradle . performance . results ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import org . gradle . performance . fixture . BuildDisplayInfo ; import org . gradle . performance . fixture . CrossBuildPerformanceResults ; import org . gradle . performance . fixture . DataReporter ; import org . gradle . performance . fixture . MeasuredOperationList ; import org . gradle . performance . measure . DataAmount ; import org . gradle . performance . measure . Duration ; import org . gradle . performance . measure . MeasuredOperation ; import java . io . Closeable ; import java . io . File ; import java . sql . * ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; public class CrossBuildResultsStore implements ResultsStore , DataReporter < CrossBuildPerformanceResults > , Closeable { private final File dbFile ; private final H2FileDb db ; public CrossBuildResultsStore ( ) { this ( new File ( System . getProperty ( <str> ) , <str> ) ) ; } public CrossBuildResultsStore ( File dbFile ) { this . dbFile = dbFile ; this . db = new H2FileDb ( dbFile , new CrossBuildResultsSchemaInitializer ( ) ) ; } public void report ( final CrossBuildPerformanceResults results ) { try { db . withConnection ( new ConnectionAction < Void > ( ) { public Void execute ( Connection connection ) throws Exception { long executionId ; PreparedStatement statement = connection . prepareStatement ( <str> ) ; try { statement . setString ( <int> , results . getTestId ( ) ) ; statement . setTimestamp ( <int> , new Timestamp ( results . getTestTime ( ) ) ) ; statement . setString ( <int> , results . getVersionUnderTest ( ) ) ; statement . setString ( <int> , results . getOperatingSystem ( ) ) ; statement . setString ( <int> , results . getJvm ( ) ) ; statement . setString ( <int> , results . getVcsBranch ( ) ) ; statement . setString ( <int> , results . getVcsCommit ( ) ) ; statement . setString ( <int> , results . getTestGroup ( ) ) ; statement . execute ( ) ; ResultSet keys = statement . getGeneratedKeys ( ) ; keys . next ( ) ; executionId = keys . getLong ( <int> ) ; } finally { statement . close ( ) ; } statement = connection . prepareStatement ( <str> ) ; try { for ( BuildDisplayInfo displayInfo : results . getBuilds ( ) ) { addOperations ( statement , executionId , displayInfo , results . buildResult ( displayInfo ) ) ; } } finally { statement . close ( ) ; } return null ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } private void addOperations ( PreparedStatement statement , long executionId , BuildDisplayInfo displayInfo , MeasuredOperationList operations ) throws SQLException { for ( MeasuredOperation operation : operations ) { statement . setLong ( <int> , executionId ) ; statement . setString ( <int> , displayInfo . getProjectName ( ) ) ; statement . setString ( <int> , displayInfo . getDisplayName ( ) ) ; statement . setObject ( <int> , toArray ( displayInfo . getTasksToRun ( ) ) ) ; statement . setObject ( <int> , toArray ( displayInfo . getArgs ( ) ) ) ; statement . setBigDecimal ( <int> , operation . getTotalTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getConfigurationTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getExecutionTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getTotalMemoryUsed ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getTotalHeapUsage ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxHeapUsage ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxUncollectedHeap ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxCommittedHeap ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . execute ( ) ; } } private String [ ] toArray ( List < String > list ) { return list . toArray ( new String [ list . size ( ) ] ) ; } public void close ( ) { db . close ( ) ; } public List < String > getTestNames ( ) { try { return db . withConnection ( new ConnectionAction < List < String > > ( ) { public List < String > execute ( Connection connection ) throws Exception { List < String > testNames = new ArrayList < String > ( ) ; ResultSet testGroups = connection . createStatement ( ) . executeQuery ( <str> ) ; PreparedStatement testIdsStatement = connection . prepareStatement ( <str> ) ; while ( testGroups . next ( ) ) { testIdsStatement . setString ( <int> , testGroups . getString ( <int> ) ) ; ResultSet testExecutions = testIdsStatement . executeQuery ( ) ; while ( testExecutions . next ( ) ) { testNames . add ( testExecutions . getString ( <int> ) ) ; } testExecutions . close ( ) ; } testIdsStatement . close ( ) ; testGroups . close ( ) ; return testNames ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } @Override public CrossBuildTestExecutionHistory getTestResults ( String testName ) { return getTestResults ( testName , Integer . MAX_VALUE ) ; } public CrossBuildTestExecutionHistory getTestResults ( final String testName , final int mostRecentN ) { try { return db . withConnection ( new ConnectionAction < CrossBuildTestExecutionHistory > ( ) { public CrossBuildTestExecutionHistory execute ( Connection connection ) throws Exception { List < CrossBuildPerformanceResults > results = Lists . newArrayList ( ) ; Set < BuildDisplayInfo > builds = Sets . newTreeSet ( new Comparator < BuildDisplayInfo > ( ) { @Override public int compare ( BuildDisplayInfo o1 , BuildDisplayInfo o2 ) { return o1 . getDisplayName ( ) . compareTo ( o2 . getDisplayName ( ) ) ; } } ) ; PreparedStatement executionsForName = connection . prepareStatement ( <str> ) ; PreparedStatement operationsForExecution = connection . prepareStatement ( <str> ) ; executionsForName . setInt ( <int> , mostRecentN ) ; executionsForName . setString ( <int> , testName ) ; ResultSet testExecutions = executionsForName . executeQuery ( ) ; while ( testExecutions . next ( ) ) { long id = testExecutions . getLong ( <int> ) ; CrossBuildPerformanceResults performanceResults = new CrossBuildPerformanceResults ( ) ; performanceResults . setTestId ( testName ) ; performanceResults . setTestTime ( testExecutions . getTimestamp ( <int> ) . getTime ( ) ) ; performanceResults . setVersionUnderTest ( testExecutions . getString ( <int> ) ) ; performanceResults . setOperatingSystem ( testExecutions . getString ( <int> ) ) ; performanceResults . setJvm ( testExecutions . getString ( <int> ) ) ; performanceResults . setVcsBranch ( testExecutions . getString ( <int> ) . trim ( ) ) ; performanceResults . setVcsCommit ( testExecutions . getString ( <int> ) ) ; performanceResults . setTestGroup ( testExecutions . getString ( <int> ) ) ; if ( ignore ( performanceResults ) ) { continue ; } results . add ( performanceResults ) ; operationsForExecution . setLong ( <int> , id ) ; ResultSet resultSet = operationsForExecution . executeQuery ( ) ; while ( resultSet . next ( ) ) { BuildDisplayInfo displayInfo = new BuildDisplayInfo ( resultSet . getString ( <int> ) , resultSet . getString ( <int> ) , toList ( resultSet . getObject ( <int> ) ) , toList ( resultSet . getObject ( <int> ) ) ) ; MeasuredOperation operation = new MeasuredOperation ( ) ; operation . setTotalTime ( Duration . millis ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setConfigurationTime ( Duration . millis ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setExecutionTime ( Duration . millis ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setTotalMemoryUsed ( DataAmount . bytes ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setTotalHeapUsage ( DataAmount . bytes ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setMaxHeapUsage ( DataAmount . bytes ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setMaxUncollectedHeap ( DataAmount . bytes ( resultSet . getBigDecimal ( <int> ) ) ) ; operation . setMaxCommittedHeap ( DataAmount . bytes ( resultSet . getBigDecimal ( <int> ) ) ) ; performanceResults . buildResult ( displayInfo ) . add ( operation ) ; builds . add ( displayInfo ) ; } resultSet . close ( ) ; } testExecutions . close ( ) ; operationsForExecution . close ( ) ; executionsForName . close ( ) ; return new CrossBuildTestExecutionHistory ( testName , ImmutableList . copyOf ( builds ) , results ) ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } private boolean ignore ( CrossBuildPerformanceResults performanceResults ) { return performanceResults . getVcsCommit ( ) . equals ( <str> ) | | performanceResults . getVcsCommit ( ) . equals ( <str> ) | | performanceResults . getVcsCommit ( ) . equals ( <str> ) ; } private List < String > toList ( Object object ) { Object [ ] value = ( Object [ ] ) object ; List < String > list = Lists . newLinkedList ( ) ; for ( Object aValue : value ) { list . add ( aValue . toString ( ) ) ; } return list ; } private class CrossBuildResultsSchemaInitializer implements ConnectionAction < Void > { @Override public Void execute ( Connection connection ) throws Exception { Statement statement = connection . createStatement ( ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; if ( columnExists ( connection , <str> , <str> ) ) { statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; } statement . close ( ) ; return null ; } private boolean columnExists ( Connection connection , String table , String column ) throws SQLException { ResultSet columns = connection . getMetaData ( ) . getColumns ( null , null , table , column ) ; boolean exists = columns . next ( ) ; columns . close ( ) ; return exists ; } } } 
