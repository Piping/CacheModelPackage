package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import com . google . common . collect . Lists ; import junit . framework . TestCase ; import java . util . List ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class AbstractIdleServiceTest extends TestCase { public static class FunctionalTest extends TestCase { private static class DefaultService extends AbstractIdleService { @Override protected void startUp ( ) throws Exception { } @Override protected void shutDown ( ) throws Exception { } } public void testServiceStartStop ( ) throws Exception { AbstractIdleService service = new DefaultService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( Service . State . RUNNING , service . state ( ) ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( Service . State . TERMINATED , service . state ( ) ) ; } public void testStart_failed ( ) throws Exception { final Exception exception = new Exception ( <str> ) ; AbstractIdleService service = new DefaultService ( ) { @Override protected void startUp ( ) throws Exception { throw exception ; } } ; try { service . startAsync ( ) . awaitRunning ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertSame ( exception , e . getCause ( ) ) ; } assertEquals ( Service . State . FAILED , service . state ( ) ) ; } public void testStop_failed ( ) throws Exception { final Exception exception = new Exception ( <str> ) ; AbstractIdleService service = new DefaultService ( ) { @Override protected void shutDown ( ) throws Exception { throw exception ; } } ; service . startAsync ( ) . awaitRunning ( ) ; try { service . stopAsync ( ) . awaitTerminated ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertSame ( exception , e . getCause ( ) ) ; } assertEquals ( Service . State . FAILED , service . state ( ) ) ; } } public void testStart ( ) { TestService service = new TestService ( ) ; assertEquals ( <int> , service . startUpCalled ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( Service . State . RUNNING , service . state ( ) ) ; assertThat ( service . transitionStates ) . containsExactly ( Service . State . STARTING ) ; } public void testStart_failed ( ) { final Exception exception = new Exception ( <str> ) ; TestService service = new TestService ( ) { @Override protected void startUp ( ) throws Exception { super . startUp ( ) ; throw exception ; } } ; assertEquals ( <int> , service . startUpCalled ) ; try { service . startAsync ( ) . awaitRunning ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertSame ( exception , e . getCause ( ) ) ; } assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( Service . State . FAILED , service . state ( ) ) ; assertThat ( service . transitionStates ) . containsExactly ( Service . State . STARTING ) ; } public void testStop_withoutStart ( ) { TestService service = new TestService ( ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( <int> , service . shutDownCalled ) ; assertEquals ( Service . State . TERMINATED , service . state ( ) ) ; assertThat ( service . transitionStates ) . isEmpty ( ) ; } public void testStop_afterStart ( ) { TestService service = new TestService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( <int> , service . shutDownCalled ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( <int> , service . shutDownCalled ) ; assertEquals ( Service . State . TERMINATED , service . state ( ) ) ; assertThat ( service . transitionStates ) . containsExactly ( Service . State . STARTING , Service . State . STOPPING ) . inOrder ( ) ; } public void testStop_failed ( ) { final Exception exception = new Exception ( <str> ) ; TestService service = new TestService ( ) { @Override protected void shutDown ( ) throws Exception { super . shutDown ( ) ; throw exception ; } } ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( <int> , service . shutDownCalled ) ; try { service . stopAsync ( ) . awaitTerminated ( ) ; fail ( ) ; } catch ( RuntimeException e ) { assertSame ( exception , e . getCause ( ) ) ; } assertEquals ( <int> , service . startUpCalled ) ; assertEquals ( <int> , service . shutDownCalled ) ; assertEquals ( Service . State . FAILED , service . state ( ) ) ; assertThat ( service . transitionStates ) . containsExactly ( Service . State . STARTING , Service . State . STOPPING ) . inOrder ( ) ; } public void testServiceToString ( ) { AbstractIdleService service = new TestService ( ) ; assertEquals ( <str> , service . toString ( ) ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <str> , service . toString ( ) ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( <str> , service . toString ( ) ) ; } public void testTimeout ( ) throws Exception { Service service = new TestService ( ) { @Override protected Executor executor ( ) { return new Executor ( ) { @Override public void execute ( Runnable command ) { } } ; } @Override protected String serviceName ( ) { return <str> ; } } ; try { service . startAsync ( ) . awaitRunning ( <int> , TimeUnit . MILLISECONDS ) ; fail ( <str> ) ; } catch ( TimeoutException e ) { assertThat ( e ) . hasMessage ( <str> ) ; } } private static class TestService extends AbstractIdleService { int startUpCalled = <int> ; int shutDownCalled = <int> ; final List < State > transitionStates = Lists . newArrayList ( ) ; @Override protected void startUp ( ) throws Exception { assertEquals ( <int> , startUpCalled ) ; assertEquals ( <int> , shutDownCalled ) ; startUpCalled + + ; assertEquals ( State . STARTING , state ( ) ) ; } @Override protected void shutDown ( ) throws Exception { assertEquals ( <int> , startUpCalled ) ; assertEquals ( <int> , shutDownCalled ) ; shutDownCalled + + ; assertEquals ( State . STOPPING , state ( ) ) ; } @Override protected Executor executor ( ) { transitionStates . add ( state ( ) ) ; return directExecutor ( ) ; } } } 
