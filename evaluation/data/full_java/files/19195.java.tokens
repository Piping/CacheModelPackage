package io . netty . handler . codec . http . websocketx ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; public class WebSocketServerHandshakerFactory { private final String webSocketURL ; private final String subprotocols ; private final boolean allowExtensions ; private final int maxFramePayloadLength ; private final boolean allowMaskMismatch ; public WebSocketServerHandshakerFactory ( String webSocketURL , String subprotocols , boolean allowExtensions ) { this ( webSocketURL , subprotocols , allowExtensions , <int> ) ; } public WebSocketServerHandshakerFactory ( String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength ) { this ( webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength , false ) ; } public WebSocketServerHandshakerFactory ( String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength , boolean allowMaskMismatch ) { this . webSocketURL = webSocketURL ; this . subprotocols = subprotocols ; this . allowExtensions = allowExtensions ; this . maxFramePayloadLength = maxFramePayloadLength ; this . allowMaskMismatch = allowMaskMismatch ; } public WebSocketServerHandshaker newHandshaker ( HttpRequest req ) { CharSequence version = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_VERSION ) ; if ( version ! = null ) { if ( version . equals ( WebSocketVersion . V13 . toHttpHeaderValue ( ) ) ) { return new WebSocketServerHandshaker13 ( webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength , allowMaskMismatch ) ; } else if ( version . equals ( WebSocketVersion . V08 . toHttpHeaderValue ( ) ) ) { return new WebSocketServerHandshaker08 ( webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength , allowMaskMismatch ) ; } else if ( version . equals ( WebSocketVersion . V07 . toHttpHeaderValue ( ) ) ) { return new WebSocketServerHandshaker07 ( webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength , allowMaskMismatch ) ; } else { return null ; } } else { return new WebSocketServerHandshaker00 ( webSocketURL , subprotocols , maxFramePayloadLength ) ; } } @Deprecated public static void sendUnsupportedWebSocketVersionResponse ( Channel channel ) { sendUnsupportedVersionResponse ( channel ) ; } public static ChannelFuture sendUnsupportedVersionResponse ( Channel channel ) { return sendUnsupportedVersionResponse ( channel , channel . newPromise ( ) ) ; } public static ChannelFuture sendUnsupportedVersionResponse ( Channel channel , ChannelPromise promise ) { HttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . UPGRADE_REQUIRED ) ; res . headers ( ) . set ( HttpHeaderNames . SEC_WEBSOCKET_VERSION , WebSocketVersion . V13 . toHttpHeaderValue ( ) ) ; HttpUtil . setContentLength ( res , <int> ) ; return channel . writeAndFlush ( res , promise ) ; } } 
