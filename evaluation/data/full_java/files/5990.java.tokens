package org . elasticsearch . common . lucene . search ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import java . util . List ; import java . util . regex . Pattern ; public class Queries { public static Query newMatchAllQuery ( ) { return new MatchAllDocsQuery ( ) ; } public static Query newMatchNoDocsQuery ( ) { return new BooleanQuery . Builder ( ) . build ( ) ; } public static Query newNestedFilter ( ) { return new PrefixQuery ( new Term ( TypeFieldMapper . NAME , new BytesRef ( <str> ) ) ) ; } public static Query newNonNestedFilter ( ) { return not ( newNestedFilter ( ) ) ; } public static BooleanQuery filtered ( @Nullable Query query , @Nullable Query filter ) { BooleanQuery . Builder builder = new BooleanQuery . Builder ( ) ; if ( query ! = null ) { builder . add ( new BooleanClause ( query , Occur . MUST ) ) ; } if ( filter ! = null ) { builder . add ( new BooleanClause ( filter , Occur . FILTER ) ) ; } return builder . build ( ) ; } public static Query not ( Query q ) { return new BooleanQuery . Builder ( ) . add ( new MatchAllDocsQuery ( ) , Occur . MUST ) . add ( q , Occur . MUST_NOT ) . build ( ) ; } private static boolean isNegativeQuery ( Query q ) { if ( ! ( q instanceof BooleanQuery ) ) { return false ; } List < BooleanClause > clauses = ( ( BooleanQuery ) q ) . clauses ( ) ; if ( clauses . isEmpty ( ) ) { return false ; } for ( BooleanClause clause : clauses ) { if ( ! clause . isProhibited ( ) ) return false ; } return true ; } public static Query fixNegativeQueryIfNeeded ( Query q ) { if ( isNegativeQuery ( q ) ) { BooleanQuery bq = ( BooleanQuery ) q ; BooleanQuery . Builder builder = new BooleanQuery . Builder ( ) ; builder . setDisableCoord ( bq . isCoordDisabled ( ) ) ; for ( BooleanClause clause : bq ) { builder . add ( clause ) ; } builder . add ( newMatchAllQuery ( ) , BooleanClause . Occur . MUST ) ; return builder . build ( ) ; } return q ; } public static boolean isConstantMatchAllQuery ( Query query ) { if ( query instanceof ConstantScoreQuery ) { return isConstantMatchAllQuery ( ( ( ConstantScoreQuery ) query ) . getQuery ( ) ) ; } else if ( query instanceof MatchAllDocsQuery ) { return true ; } return false ; } public static Query applyMinimumShouldMatch ( BooleanQuery query , @Nullable String minimumShouldMatch ) { if ( minimumShouldMatch = = null ) { return query ; } int optionalClauses = <int> ; for ( BooleanClause c : query . clauses ( ) ) { if ( c . getOccur ( ) = = BooleanClause . Occur . SHOULD ) { optionalClauses + + ; } } int msm = calculateMinShouldMatch ( optionalClauses , minimumShouldMatch ) ; if ( <int> < msm ) { BooleanQuery . Builder builder = new BooleanQuery . Builder ( ) ; builder . setDisableCoord ( query . isCoordDisabled ( ) ) ; for ( BooleanClause clause : query ) { builder . add ( clause ) ; } builder . setMinimumNumberShouldMatch ( msm ) ; BooleanQuery bq = builder . build ( ) ; if ( query . getBoost ( ) ! = <float> ) { return new BoostQuery ( bq , query . getBoost ( ) ) ; } return bq ; } else { return query ; } } private static Pattern spaceAroundLessThanPattern = Pattern . compile ( <str> ) ; private static Pattern spacePattern = Pattern . compile ( <str> ) ; private static Pattern lessThanPattern = Pattern . compile ( <str> ) ; public static int calculateMinShouldMatch ( int optionalClauseCount , String spec ) { int result = optionalClauseCount ; spec = spec . trim ( ) ; if ( - <int> < spec . indexOf ( <str> ) ) { spec = spaceAroundLessThanPattern . matcher ( spec ) . replaceAll ( <str> ) ; for ( String s : spacePattern . split ( spec ) ) { String [ ] parts = lessThanPattern . split ( s , <int> ) ; int upperBound = Integer . parseInt ( parts [ <int> ] ) ; if ( optionalClauseCount < = upperBound ) { return result ; } else { result = calculateMinShouldMatch ( optionalClauseCount , parts [ <int> ] ) ; } } return result ; } if ( - <int> < spec . indexOf ( <str> ) ) { spec = spec . substring ( <int> , spec . length ( ) - <int> ) ; int percent = Integer . parseInt ( spec ) ; float calc = ( result * percent ) * ( <int> / <int> f ) ; result = calc < <int> ? result + ( int ) calc : ( int ) calc ; } else { int calc = Integer . parseInt ( spec ) ; result = calc < <int> ? result + calc : calc ; } return ( optionalClauseCount < result ? optionalClauseCount : ( result < <int> ? <int> : result ) ) ; } } 
