package org . junit . tests . running . classes ; import static org . junit . Assert . fail ; import java . util . List ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . ClassRule ; import org . junit . Ignore ; import org . junit . Test ; import org . junit . experimental . categories . Categories . CategoryFilter ; import org . junit . experimental . categories . Category ; import org . junit . rules . TestRule ; import org . junit . runner . Description ; import org . junit . runner . JUnitCore ; import org . junit . runner . Request ; import org . junit . runner . Result ; import org . junit . runner . notification . Failure ; import org . junit . runners . model . Statement ; public class ClassLevelMethodsWithIgnoredTestsTest { private static final String FAILURE_MESSAGE = <str> ; public static class BeforeClassWithIgnoredTest { @BeforeClass public static void beforeClass ( ) { fail ( FAILURE_MESSAGE ) ; } @Ignore @Test public void test ( ) throws Exception { fail ( <str> ) ; } } @Test public void beforeClassShouldNotRunWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredTest . class , <str> ) ; } @Ignore public static class BeforeClassWithIgnoredClass { @BeforeClass public static void beforeClass ( ) { fail ( FAILURE_MESSAGE ) ; } @Test public void test ( ) throws Exception { fail ( <str> ) ; } } @Test public void beforeClassShouldNotRunWhenWholeClassIsIgnored ( ) { runClassAndVerifyNoFailures ( BeforeClassWithIgnoredClass . class , <str> ) ; } public static class AfterClassWithIgnoredTest { @Ignore @Test public void test ( ) throws Exception { fail ( <str> ) ; } @AfterClass public static void afterClass ( ) { fail ( FAILURE_MESSAGE ) ; } } @Test public void afterClassShouldNotRunWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( AfterClassWithIgnoredTest . class , <str> ) ; } public interface FilteredTests { } public static class BeforeClassWithFilteredTest { @BeforeClass public static void setUpClass ( ) { fail ( FAILURE_MESSAGE ) ; } @Category ( FilteredTests . class ) @Test public void test ( ) throws Exception { fail ( <str> ) ; } } public static class HasUnfilteredTest { @Test public void unfilteredTest ( ) { } } @Test public void beforeClassShouldNotRunWhenAllTestsAreFiltered ( ) { Result result = new JUnitCore ( ) . run ( Request . classes ( BeforeClassWithFilteredTest . class , HasUnfilteredTest . class ) . filterWith ( CategoryFilter . exclude ( FilteredTests . class ) ) ) ; analyseResult ( result , <str> ) ; } public static class BrokenRule implements TestRule { public Statement apply ( Statement base , Description description ) { throw new RuntimeException ( <str> ) ; } } public static class ClassRuleWithIgnoredTest { @ClassRule public static BrokenRule brokenRule = new BrokenRule ( ) ; @Ignore @Test public void test ( ) throws Exception { fail ( <str> ) ; } } @Test public void classRuleShouldNotBeAppliedWhenAllTestsAreIgnored ( ) { runClassAndVerifyNoFailures ( ClassRuleWithIgnoredTest . class , <str> ) ; } private void runClassAndVerifyNoFailures ( Class < ? > klass , String testFailureDescription ) { Result result = JUnitCore . runClasses ( klass ) ; analyseResult ( result , testFailureDescription ) ; } private void analyseResult ( Result result , String testFailureDescription ) { List < Failure > failures = result . getFailures ( ) ; if ( failures . isEmpty ( ) = = false ) { analyzeFailure ( failures . get ( <int> ) , testFailureDescription ) ; } } private void analyzeFailure ( Failure failure , String testFailureDescription ) { String actualFailureMsg = failure . getMessage ( ) ; if ( FAILURE_MESSAGE . equals ( actualFailureMsg ) ) { fail ( testFailureDescription ) ; } fail ( <str> + actualFailureMsg ) ; } } 
