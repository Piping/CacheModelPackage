package org . elasticsearch . http . netty ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . netty . NettyUtils ; import org . elasticsearch . common . netty . OpenChannelsHandler ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . * ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . http . * ; import org . elasticsearch . http . netty . pipelining . HttpPipeliningHandler ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . transport . BindTransportException ; import org . jboss . netty . bootstrap . ServerBootstrap ; import org . jboss . netty . channel . * ; import org . jboss . netty . channel . socket . nio . NioServerSocketChannelFactory ; import org . jboss . netty . channel . socket . oio . OioServerSocketChannelFactory ; import org . jboss . netty . handler . codec . http . HttpChunkAggregator ; import org . jboss . netty . handler . codec . http . HttpContentCompressor ; import org . jboss . netty . handler . codec . http . HttpRequestDecoder ; import org . jboss . netty . handler . timeout . ReadTimeoutException ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . network . NetworkService . TcpSettings . * ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; public class NettyHttpServerTransport extends AbstractLifecycleComponent < HttpServerTransport > implements HttpServerTransport { static { NettyUtils . setup ( ) ; } public static final String SETTING_CORS_ENABLED = <str> ; public static final String SETTING_CORS_ALLOW_ORIGIN = <str> ; public static final String SETTING_CORS_MAX_AGE = <str> ; public static final String SETTING_CORS_ALLOW_METHODS = <str> ; public static final String SETTING_CORS_ALLOW_HEADERS = <str> ; public static final String SETTING_CORS_ALLOW_CREDENTIALS = <str> ; public static final String SETTING_PIPELINING = <str> ; public static final String SETTING_PIPELINING_MAX_EVENTS = <str> ; public static final String SETTING_HTTP_COMPRESSION = <str> ; public static final String SETTING_HTTP_COMPRESSION_LEVEL = <str> ; public static final String SETTING_HTTP_DETAILED_ERRORS_ENABLED = <str> ; public static final boolean DEFAULT_SETTING_PIPELINING = true ; public static final int DEFAULT_SETTING_PIPELINING_MAX_EVENTS = <int> ; public static final String DEFAULT_PORT_RANGE = <str> ; protected final NetworkService networkService ; protected final BigArrays bigArrays ; protected final ByteSizeValue maxContentLength ; protected final ByteSizeValue maxInitialLineLength ; protected final ByteSizeValue maxHeaderSize ; protected final ByteSizeValue maxChunkSize ; protected final int workerCount ; protected final boolean blockingServer ; protected final boolean pipelining ; protected final int pipeliningMaxEvents ; protected final boolean compression ; protected final int compressionLevel ; protected final boolean resetCookies ; protected final String port ; protected final String bindHosts [ ] ; protected final String publishHosts [ ] ; protected final boolean detailedErrorsEnabled ; protected int publishPort ; protected final String tcpNoDelay ; protected final String tcpKeepAlive ; protected final boolean reuseAddress ; protected final ByteSizeValue tcpSendBufferSize ; protected final ByteSizeValue tcpReceiveBufferSize ; protected final ReceiveBufferSizePredictorFactory receiveBufferSizePredictorFactory ; protected final ByteSizeValue maxCumulationBufferCapacity ; protected final int maxCompositeBufferComponents ; protected volatile ServerBootstrap serverBootstrap ; protected volatile BoundTransportAddress boundAddress ; protected volatile List < Channel > serverChannels = new ArrayList < > ( ) ; OpenChannelsHandler serverOpenChannels ; protected volatile HttpServerAdapter httpServerAdapter ; @Inject @SuppressForbidden ( reason = <str> ) public NettyHttpServerTransport ( Settings settings , NetworkService networkService , BigArrays bigArrays ) { super ( settings ) ; this . networkService = networkService ; this . bigArrays = bigArrays ; if ( settings . getAsBoolean ( <str> , false ) ) { System . setProperty ( <str> , <str> ) ; } ByteSizeValue maxContentLength = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ) ; this . maxChunkSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; this . maxHeaderSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; this . maxInitialLineLength = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ) ; this . resetCookies = settings . getAsBoolean ( <str> , settings . getAsBoolean ( <str> , false ) ) ; this . maxCumulationBufferCapacity = settings . getAsBytesSize ( <str> , null ) ; this . maxCompositeBufferComponents = settings . getAsInt ( <str> , - <int> ) ; this . workerCount = settings . getAsInt ( <str> , EsExecutors . boundedNumberOfProcessors ( settings ) * <int> ) ; this . blockingServer = settings . getAsBoolean ( <str> , settings . getAsBoolean ( TCP_BLOCKING_SERVER , settings . getAsBoolean ( TCP_BLOCKING , false ) ) ) ; this . port = settings . get ( <str> , settings . get ( <str> , DEFAULT_PORT_RANGE ) ) ; this . bindHosts = settings . getAsArray ( <str> , settings . getAsArray ( <str> , settings . getAsArray ( <str> , null ) ) ) ; this . publishHosts = settings . getAsArray ( <str> , settings . getAsArray ( <str> , settings . getAsArray ( <str> , null ) ) ) ; this . publishPort = settings . getAsInt ( <str> , settings . getAsInt ( <str> , <int> ) ) ; this . tcpNoDelay = settings . get ( <str> , settings . get ( TCP_NO_DELAY , <str> ) ) ; this . tcpKeepAlive = settings . get ( <str> , settings . get ( TCP_KEEP_ALIVE , <str> ) ) ; this . reuseAddress = settings . getAsBoolean ( <str> , settings . getAsBoolean ( TCP_REUSE_ADDRESS , NetworkUtils . defaultReuseAddress ( ) ) ) ; this . tcpSendBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_SEND_BUFFER_SIZE , TCP_DEFAULT_SEND_BUFFER_SIZE ) ) ; this . tcpReceiveBufferSize = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( TCP_RECEIVE_BUFFER_SIZE , TCP_DEFAULT_RECEIVE_BUFFER_SIZE ) ) ; this . detailedErrorsEnabled = settings . getAsBoolean ( SETTING_HTTP_DETAILED_ERRORS_ENABLED , true ) ; long defaultReceiverPredictor = <int> * <int> ; if ( JvmInfo . jvmInfo ( ) . getMem ( ) . getDirectMemoryMax ( ) . bytes ( ) > <int> ) { long l = ( long ) ( ( <float> * JvmInfo . jvmInfo ( ) . getMem ( ) . getDirectMemoryMax ( ) . bytes ( ) ) / workerCount ) ; defaultReceiverPredictor = Math . min ( defaultReceiverPredictor , Math . max ( l , <int> * <int> ) ) ; } ByteSizeValue receivePredictorMin = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( defaultReceiverPredictor ) ) ) ; ByteSizeValue receivePredictorMax = settings . getAsBytesSize ( <str> , settings . getAsBytesSize ( <str> , new ByteSizeValue ( defaultReceiverPredictor ) ) ) ; if ( receivePredictorMax . bytes ( ) = = receivePredictorMin . bytes ( ) ) { receiveBufferSizePredictorFactory = new FixedReceiveBufferSizePredictorFactory ( ( int ) receivePredictorMax . bytes ( ) ) ; } else { receiveBufferSizePredictorFactory = new AdaptiveReceiveBufferSizePredictorFactory ( ( int ) receivePredictorMin . bytes ( ) , ( int ) receivePredictorMin . bytes ( ) , ( int ) receivePredictorMax . bytes ( ) ) ; } this . compression = settings . getAsBoolean ( SETTING_HTTP_COMPRESSION , false ) ; this . compressionLevel = settings . getAsInt ( SETTING_HTTP_COMPRESSION_LEVEL , <int> ) ; this . pipelining = settings . getAsBoolean ( SETTING_PIPELINING , DEFAULT_SETTING_PIPELINING ) ; this . pipeliningMaxEvents = settings . getAsInt ( SETTING_PIPELINING_MAX_EVENTS , DEFAULT_SETTING_PIPELINING_MAX_EVENTS ) ; if ( maxContentLength . bytes ( ) > Integer . MAX_VALUE ) { logger . warn ( <str> + maxContentLength + <str> ) ; maxContentLength = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ; } this . maxContentLength = maxContentLength ; logger . debug ( <str> , maxChunkSize , maxHeaderSize , maxInitialLineLength , this . maxContentLength , receivePredictorMin , receivePredictorMax , pipelining , pipeliningMaxEvents ) ; } public Settings settings ( ) { return this . settings ; } @Override public void httpServerAdapter ( HttpServerAdapter httpServerAdapter ) { this . httpServerAdapter = httpServerAdapter ; } @Override protected void doStart ( ) { this . serverOpenChannels = new OpenChannelsHandler ( logger ) ; if ( blockingServer ) { serverBootstrap = new ServerBootstrap ( new OioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , <str> ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , <str> ) ) ) ) ; } else { serverBootstrap = new ServerBootstrap ( new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( daemonThreadFactory ( settings , <str> ) ) , Executors . newCachedThreadPool ( daemonThreadFactory ( settings , <str> ) ) , workerCount ) ) ; } serverBootstrap . setPipelineFactory ( configureServerChannelPipelineFactory ( ) ) ; if ( ! <str> . equals ( tcpNoDelay ) ) { serverBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpNoDelay , null ) ) ; } if ( ! <str> . equals ( tcpKeepAlive ) ) { serverBootstrap . setOption ( <str> , Booleans . parseBoolean ( tcpKeepAlive , null ) ) ; } if ( tcpSendBufferSize ! = null & & tcpSendBufferSize . bytes ( ) > <int> ) { serverBootstrap . setOption ( <str> , tcpSendBufferSize . bytes ( ) ) ; } if ( tcpReceiveBufferSize ! = null & & tcpReceiveBufferSize . bytes ( ) > <int> ) { serverBootstrap . setOption ( <str> , tcpReceiveBufferSize . bytes ( ) ) ; } serverBootstrap . setOption ( <str> , receiveBufferSizePredictorFactory ) ; serverBootstrap . setOption ( <str> , receiveBufferSizePredictorFactory ) ; serverBootstrap . setOption ( <str> , reuseAddress ) ; serverBootstrap . setOption ( <str> , reuseAddress ) ; InetAddress hostAddresses [ ] ; try { hostAddresses = networkService . resolveBindHostAddresses ( bindHosts ) ; } catch ( IOException e ) { throw new BindHttpException ( <str> + Arrays . toString ( bindHosts ) + <str> , e ) ; } List < InetSocketTransportAddress > boundAddresses = new ArrayList < > ( hostAddresses . length ) ; for ( InetAddress address : hostAddresses ) { boundAddresses . add ( bindAddress ( address ) ) ; } final InetAddress publishInetAddress ; try { publishInetAddress = networkService . resolvePublishHostAddresses ( publishHosts ) ; } catch ( Exception e ) { throw new BindTransportException ( <str> , e ) ; } if ( <int> = = publishPort ) { for ( InetSocketTransportAddress boundAddress : boundAddresses ) { InetAddress boundInetAddress = boundAddress . address ( ) . getAddress ( ) ; if ( boundInetAddress . isAnyLocalAddress ( ) | | boundInetAddress . equals ( publishInetAddress ) ) { publishPort = boundAddress . getPort ( ) ; break ; } } } if ( <int> = = publishPort ) { throw new BindHttpException ( <str> + publishInetAddress + <str> + boundAddresses + <str> ) ; } final InetSocketAddress publishAddress = new InetSocketAddress ( publishInetAddress , publishPort ) ; ; this . boundAddress = new BoundTransportAddress ( boundAddresses . toArray ( new TransportAddress [ boundAddresses . size ( ) ] ) , new InetSocketTransportAddress ( publishAddress ) ) ; } private InetSocketTransportAddress bindAddress ( final InetAddress hostAddress ) { PortsRange portsRange = new PortsRange ( port ) ; final AtomicReference < Exception > lastException = new AtomicReference < > ( ) ; final AtomicReference < InetSocketAddress > boundSocket = new AtomicReference < > ( ) ; boolean success = portsRange . iterate ( new PortsRange . PortCallback ( ) { @Override public boolean onPortNumber ( int portNumber ) { try { synchronized ( serverChannels ) { Channel channel = serverBootstrap . bind ( new InetSocketAddress ( hostAddress , portNumber ) ) ; serverChannels . add ( channel ) ; boundSocket . set ( ( InetSocketAddress ) channel . getLocalAddress ( ) ) ; } } catch ( Exception e ) { lastException . set ( e ) ; return false ; } return true ; } } ) ; if ( ! success ) { throw new BindHttpException ( <str> + port + <str> , lastException . get ( ) ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , NetworkAddress . format ( boundSocket . get ( ) ) ) ; } return new InetSocketTransportAddress ( boundSocket . get ( ) ) ; } @Override protected void doStop ( ) { synchronized ( serverChannels ) { if ( serverChannels ! = null ) { for ( Channel channel : serverChannels ) { channel . close ( ) . awaitUninterruptibly ( ) ; } serverChannels = null ; } } if ( serverOpenChannels ! = null ) { serverOpenChannels . close ( ) ; serverOpenChannels = null ; } if ( serverBootstrap ! = null ) { serverBootstrap . releaseExternalResources ( ) ; serverBootstrap = null ; } } @Override protected void doClose ( ) { } @Override public BoundTransportAddress boundAddress ( ) { return this . boundAddress ; } @Override public HttpInfo info ( ) { BoundTransportAddress boundTransportAddress = boundAddress ( ) ; if ( boundTransportAddress = = null ) { return null ; } return new HttpInfo ( boundTransportAddress , maxContentLength . bytes ( ) ) ; } @Override public HttpStats stats ( ) { OpenChannelsHandler channels = serverOpenChannels ; return new HttpStats ( channels = = null ? <int> : channels . numberOfOpenChannels ( ) , channels = = null ? <int> : channels . totalChannels ( ) ) ; } protected void dispatchRequest ( HttpRequest request , HttpChannel channel ) { httpServerAdapter . dispatchRequest ( request , channel ) ; } protected void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { if ( e . getCause ( ) instanceof ReadTimeoutException ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , ctx . getChannel ( ) . getRemoteAddress ( ) ) ; } ctx . getChannel ( ) . close ( ) ; } else { if ( ! lifecycle . started ( ) ) { return ; } if ( ! NetworkExceptionHelper . isCloseConnectionException ( e . getCause ( ) ) ) { logger . warn ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; } else { logger . debug ( <str> , e . getCause ( ) , ctx . getChannel ( ) ) ; ctx . getChannel ( ) . close ( ) ; } } } public ChannelPipelineFactory configureServerChannelPipelineFactory ( ) { return new HttpChannelPipelineFactory ( this , detailedErrorsEnabled ) ; } protected static class HttpChannelPipelineFactory implements ChannelPipelineFactory { protected final NettyHttpServerTransport transport ; protected final HttpRequestHandler requestHandler ; public HttpChannelPipelineFactory ( NettyHttpServerTransport transport , boolean detailedErrorsEnabled ) { this . transport = transport ; this . requestHandler = new HttpRequestHandler ( transport , detailedErrorsEnabled ) ; } @Override public ChannelPipeline getPipeline ( ) throws Exception { ChannelPipeline pipeline = Channels . pipeline ( ) ; pipeline . addLast ( <str> , transport . serverOpenChannels ) ; HttpRequestDecoder requestDecoder = new HttpRequestDecoder ( ( int ) transport . maxInitialLineLength . bytes ( ) , ( int ) transport . maxHeaderSize . bytes ( ) , ( int ) transport . maxChunkSize . bytes ( ) ) ; if ( transport . maxCumulationBufferCapacity ! = null ) { if ( transport . maxCumulationBufferCapacity . bytes ( ) > Integer . MAX_VALUE ) { requestDecoder . setMaxCumulationBufferCapacity ( Integer . MAX_VALUE ) ; } else { requestDecoder . setMaxCumulationBufferCapacity ( ( int ) transport . maxCumulationBufferCapacity . bytes ( ) ) ; } } if ( transport . maxCompositeBufferComponents ! = - <int> ) { requestDecoder . setMaxCumulationBufferComponents ( transport . maxCompositeBufferComponents ) ; } pipeline . addLast ( <str> , requestDecoder ) ; pipeline . addLast ( <str> , new ESHttpContentDecompressor ( transport . compression ) ) ; HttpChunkAggregator httpChunkAggregator = new HttpChunkAggregator ( ( int ) transport . maxContentLength . bytes ( ) ) ; if ( transport . maxCompositeBufferComponents ! = - <int> ) { httpChunkAggregator . setMaxCumulationBufferComponents ( transport . maxCompositeBufferComponents ) ; } pipeline . addLast ( <str> , httpChunkAggregator ) ; pipeline . addLast ( <str> , new ESHttpResponseEncoder ( ) ) ; if ( transport . compression ) { pipeline . addLast ( <str> , new HttpContentCompressor ( transport . compressionLevel ) ) ; } if ( transport . pipelining ) { pipeline . addLast ( <str> , new HttpPipeliningHandler ( transport . pipeliningMaxEvents ) ) ; } pipeline . addLast ( <str> , requestHandler ) ; return pipeline ; } } } 
