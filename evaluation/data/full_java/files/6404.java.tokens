package org . elasticsearch . index . engine ; import org . apache . lucene . index . SegmentInfos ; import org . elasticsearch . common . Base64 ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import java . io . IOException ; import java . util . Map ; public final class CommitStats implements Streamable , ToXContent { private Map < String , String > userData ; private long generation ; private String id ; private int numDocs ; public CommitStats ( SegmentInfos segmentInfos ) { userData = MapBuilder . < String , String > newMapBuilder ( ) . putAll ( segmentInfos . getUserData ( ) ) . immutableMap ( ) ; generation = segmentInfos . getLastGeneration ( ) ; if ( segmentInfos . getId ( ) ! = null ) { id = Base64 . encodeBytes ( segmentInfos . getId ( ) ) ; } numDocs = Lucene . getNumDocs ( segmentInfos ) ; } private CommitStats ( ) { } public static CommitStats readCommitStatsFrom ( StreamInput in ) throws IOException { CommitStats commitStats = new CommitStats ( ) ; commitStats . readFrom ( in ) ; return commitStats ; } public static CommitStats readOptionalCommitStatsFrom ( StreamInput in ) throws IOException { return in . readOptionalStreamable ( CommitStats : : new ) ; } public Map < String , String > getUserData ( ) { return userData ; } public long getGeneration ( ) { return generation ; } public String getId ( ) { return id ; } public int getNumDocs ( ) { return numDocs ; } @Override public void readFrom ( StreamInput in ) throws IOException { MapBuilder < String , String > builder = MapBuilder . newMapBuilder ( ) ; for ( int i = in . readVInt ( ) ; i > <int> ; i - - ) { builder . put ( in . readString ( ) , in . readString ( ) ) ; } userData = builder . immutableMap ( ) ; generation = in . readLong ( ) ; id = in . readOptionalString ( ) ; numDocs = in . readInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( userData . size ( ) ) ; for ( Map . Entry < String , String > entry : userData . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeString ( entry . getValue ( ) ) ; } out . writeLong ( generation ) ; out . writeOptionalString ( id ) ; out . writeInt ( numDocs ) ; } static final class Fields { static final XContentBuilderString GENERATION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString USER_DATA = new XContentBuilderString ( <str> ) ; static final XContentBuilderString ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString COMMIT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NUM_DOCS = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . COMMIT ) ; builder . field ( Fields . ID , id ) ; builder . field ( Fields . GENERATION , generation ) ; builder . field ( Fields . USER_DATA , userData ) ; builder . field ( Fields . NUM_DOCS , numDocs ) ; builder . endObject ( ) ; return builder ; } } 
