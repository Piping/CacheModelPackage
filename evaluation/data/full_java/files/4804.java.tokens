package org . eclipse . ui . console ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; import org . eclipse . swt . SWT ; import org . eclipse . swt . custom . LineBackgroundEvent ; import org . eclipse . swt . custom . LineBackgroundListener ; import org . eclipse . swt . custom . LineStyleEvent ; import org . eclipse . swt . custom . LineStyleListener ; import org . eclipse . swt . custom . StyleRange ; import org . eclipse . swt . custom . StyledText ; import org . eclipse . swt . events . KeyAdapter ; import org . eclipse . swt . events . KeyEvent ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseListener ; import org . eclipse . swt . events . MouseMoveListener ; import org . eclipse . swt . events . MouseTrackListener ; import org . eclipse . swt . events . MouseWheelListener ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . VerifyEvent ; import org . eclipse . swt . events . VerifyListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Cursor ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . jface . preference . JFacePreferences ; import org . eclipse . jface . resource . ColorRegistry ; import org . eclipse . jface . resource . JFaceColors ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . text . BadPositionCategoryException ; import org . eclipse . jface . text . DocumentEvent ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentAdapter ; import org . eclipse . jface . text . IDocumentListener ; import org . eclipse . jface . text . IPositionUpdater ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . JFaceTextUtil ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . source . SourceViewer ; import org . eclipse . ui . internal . console . ConsoleDocumentAdapter ; import org . eclipse . ui . internal . console . ConsoleHyperlinkPosition ; import org . eclipse . ui . progress . WorkbenchJob ; public class TextConsoleViewer extends SourceViewer implements LineStyleListener , LineBackgroundListener , MouseTrackListener , MouseMoveListener , MouseListener { private ConsoleDocumentAdapter documentAdapter ; private IHyperlink hyperlink ; private Cursor handCursor ; private Cursor textCursor ; private int consoleWidth = - <int> ; private TextConsole console ; private IPropertyChangeListener propertyChangeListener ; private IScrollLockStateProvider scrollLockStateProvider ; private IDocumentListener documentListener = new IDocumentListener ( ) { @Override public void documentAboutToBeChanged ( DocumentEvent event ) { } @Override public void documentChanged ( DocumentEvent event ) { updateLinks ( event . fOffset ) ; } } ; private Listener mouseUpListener = new Listener ( ) { @Override public void handleEvent ( Event event ) { if ( hyperlink ! = null ) { String selection = getTextWidget ( ) . getSelectionText ( ) ; if ( selection . length ( ) < = <int> ) { if ( event . button = = <int> ) { if ( hyperlink instanceof IHyperlink2 ) { ( ( IHyperlink2 ) hyperlink ) . linkActivated ( event ) ; } else { hyperlink . linkActivated ( ) ; } } } } } } ; private AtomicBoolean userHoldsScrollLock = new AtomicBoolean ( false ) ; WorkbenchJob revealJob = new WorkbenchJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { scrollToEndOfDocument ( ) ; return Status . OK_STATUS ; } } ; private void scrollToEndOfDocument ( ) { StyledText textWidget = getTextWidget ( ) ; if ( textWidget ! = null & & ! textWidget . isDisposed ( ) ) { int lineCount = textWidget . getLineCount ( ) ; textWidget . setTopIndex ( lineCount > <int> ? lineCount - <int> : <int> ) ; } } private void setScrollLock ( boolean lock ) { userHoldsScrollLock . set ( lock ) ; if ( scrollLockStateProvider ! = null & & scrollLockStateProvider . getAutoScrollLock ( ) ! = lock ) { scrollLockStateProvider . setAutoScrollLock ( lock ) ; } } private boolean checkEndOfDocument ( ) { StyledText textWidget = getTextWidget ( ) ; if ( textWidget ! = null & & ! textWidget . isDisposed ( ) ) { int partialIndex = JFaceTextUtil . getPartialBottomIndex ( textWidget ) ; int bottomLine = JFaceTextUtil . getLineIndex ( textWidget , partialIndex ) ; int lineCount = textWidget . getLineCount ( ) ; int delta = textWidget . getVerticalBar ( ) . getIncrement ( ) * <int> ; return lineCount - bottomLine < delta ; } return false ; } private IPositionUpdater positionUpdater = new IPositionUpdater ( ) { @Override public void update ( DocumentEvent event ) { try { IDocument document = getDocument ( ) ; if ( document ! = null ) { Position [ ] positions = document . getPositions ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; for ( int i = <int> ; i < positions . length ; i + + ) { Position position = positions [ i ] ; if ( position . offset = = event . fOffset & & position . length < = event . fLength ) { position . delete ( ) ; } if ( position . isDeleted ) { document . removePosition ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY , position ) ; } } } } catch ( BadPositionCategoryException e ) { } } } ; public TextConsoleViewer ( Composite parent , TextConsole console , IScrollLockStateProvider scrollLockStateProvider ) { this ( parent , console ) ; this . scrollLockStateProvider = scrollLockStateProvider ; } public TextConsoleViewer ( Composite parent , TextConsole console ) { super ( parent , null , SWT . V_SCROLL | SWT . H_SCROLL ) ; this . console = console ; IDocument document = console . getDocument ( ) ; setDocument ( document ) ; StyledText styledText = getTextWidget ( ) ; styledText . setDoubleClickEnabled ( true ) ; styledText . addLineStyleListener ( this ) ; styledText . addLineBackgroundListener ( this ) ; styledText . setEditable ( true ) ; styledText . setBackground ( console . getBackground ( ) ) ; setFont ( console . getFont ( ) ) ; styledText . addMouseTrackListener ( this ) ; styledText . addListener ( SWT . MouseUp , mouseUpListener ) ; styledText . getVerticalBar ( ) . addSelectionListener ( new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { if ( e . detail = = SWT . TOP | | e . detail = = SWT . HOME ) { setScrollLock ( true ) ; } else if ( e . detail = = SWT . ARROW_UP | | e . detail = = SWT . PAGE_UP ) { if ( checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } else { setScrollLock ( true ) ; } } else if ( e . detail = = SWT . END | | e . detail = = SWT . BOTTOM ) { setScrollLock ( false ) ; } else if ( e . detail = = SWT . DRAG ) { if ( checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } else { setScrollLock ( true ) ; } } else if ( ( e . detail = = SWT . PAGE_DOWN | | e . detail = = SWT . ARROW_DOWN ) & & checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } } } ) ; styledText . addKeyListener ( new KeyAdapter ( ) { @Override public void keyPressed ( KeyEvent e ) { if ( e . keyCode = = SWT . HOME | | e . keyCode = = SWT . TOP ) { setScrollLock ( true ) ; } else if ( e . keyCode = = SWT . PAGE_UP | | e . keyCode = = SWT . ARROW_UP ) { if ( checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } else { setScrollLock ( true ) ; } } else if ( e . keyCode = = SWT . END | | e . keyCode = = SWT . BOTTOM ) { setScrollLock ( false ) ; } else if ( ( e . keyCode = = SWT . PAGE_DOWN | | e . keyCode = = SWT . ARROW_DOWN ) & & checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } } } ) ; styledText . addMouseWheelListener ( new MouseWheelListener ( ) { @Override public void mouseScrolled ( MouseEvent e ) { if ( e . count < <int> ) { if ( checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } } else if ( ! userHoldsScrollLock . get ( ) ) { if ( checkEndOfDocument ( ) ) { setScrollLock ( false ) ; } else { setScrollLock ( true ) ; } } } } ) ; styledText . addVerifyListener ( new VerifyListener ( ) { @Override public void verifyText ( VerifyEvent e ) { if ( scrollLockStateProvider ! = null & & ! scrollLockStateProvider . getScrollLock ( ) ) { setScrollLock ( false ) ; } } } ) ; ColorRegistry colorRegistry = JFaceResources . getColorRegistry ( ) ; propertyChangeListener = new HyperlinkColorChangeListener ( ) ; colorRegistry . addListener ( propertyChangeListener ) ; revealJob . setSystem ( true ) ; document . addDocumentListener ( documentListener ) ; document . addPositionUpdater ( positionUpdater ) ; } public void setTabWidth ( int tabWidth ) { StyledText styledText = getTextWidget ( ) ; int oldWidth = styledText . getTabs ( ) ; if ( tabWidth ! = oldWidth ) { styledText . setTabs ( tabWidth ) ; } } public void setFont ( Font font ) { StyledText styledText = getTextWidget ( ) ; Font oldFont = styledText . getFont ( ) ; if ( oldFont = = font ) { return ; } if ( font = = null | | ! ( font . equals ( oldFont ) ) ) { styledText . setFont ( font ) ; } } protected void revealEndOfDocument ( ) { revealJob . schedule ( <int> ) ; } @Override public void lineGetStyle ( LineStyleEvent event ) { IDocument document = getDocument ( ) ; if ( document ! = null & & document . getLength ( ) > <int> ) { ArrayList < StyleRange > ranges = new ArrayList < StyleRange > ( ) ; int offset = event . lineOffset ; int length = event . lineText . length ( ) ; StyleRange [ ] partitionerStyles = ( ( IConsoleDocumentPartitioner ) document . getDocumentPartitioner ( ) ) . getStyleRanges ( event . lineOffset , event . lineText . length ( ) ) ; if ( partitionerStyles ! = null ) { for ( int i = <int> ; i < partitionerStyles . length ; i + + ) { ranges . add ( partitionerStyles [ i ] ) ; } } else { ranges . add ( new StyleRange ( offset , length , null , null ) ) ; } try { Position [ ] positions = getDocument ( ) . getPositions ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; Position [ ] overlap = findPosition ( offset , length , positions ) ; Color color = JFaceColors . getHyperlinkText ( Display . getCurrent ( ) ) ; if ( overlap ! = null ) { for ( int i = <int> ; i < overlap . length ; i + + ) { Position position = overlap [ i ] ; StyleRange linkRange = new StyleRange ( position . offset , position . length , color , null ) ; linkRange . underline = true ; override ( ranges , linkRange ) ; } } } catch ( BadPositionCategoryException e ) { } if ( ranges . size ( ) > <int> ) { event . styles = ranges . toArray ( new StyleRange [ ranges . size ( ) ] ) ; } } } private void override ( List < StyleRange > ranges , StyleRange newRange ) { if ( ranges . isEmpty ( ) ) { ranges . add ( newRange ) ; return ; } int start = newRange . start ; int end = start + newRange . length ; for ( int i = <int> ; i < ranges . size ( ) ; i + + ) { StyleRange existingRange = ranges . get ( i ) ; int rEnd = existingRange . start + existingRange . length ; if ( end < = existingRange . start | | start > = rEnd ) { continue ; } if ( start < existingRange . start & & end > existingRange . start ) { start = existingRange . start ; } if ( start > = existingRange . start & & end < = rEnd ) { existingRange . length = start - existingRange . start ; ranges . add ( + + i , newRange ) ; if ( end ! = rEnd ) { ranges . add ( + + i , new StyleRange ( end , rEnd - end - <int> , existingRange . foreground , existingRange . background ) ) ; } return ; } else if ( start > = existingRange . start & & start < rEnd ) { existingRange . length = start - existingRange . start ; ranges . add ( + + i , newRange ) ; } else if ( end > = rEnd ) { ranges . remove ( i ) ; } else { ranges . add ( + + i , new StyleRange ( end + <int> , rEnd - end + <int> , existingRange . foreground , existingRange . background ) ) ; } } } private Position [ ] findPosition ( int offset , int length , Position [ ] positions ) { if ( positions . length = = <int> ) { return null ; } int rangeEnd = offset + length ; int left = <int> ; int right = positions . length - <int> ; int mid = <int> ; Position position = null ; while ( left < right ) { mid = ( left + right ) / <int> ; position = positions [ mid ] ; if ( rangeEnd < position . getOffset ( ) ) { if ( left = = mid ) { right = left ; } else { right = mid - <int> ; } } else if ( offset > ( position . getOffset ( ) + position . getLength ( ) - <int> ) ) { if ( right = = mid ) { left = right ; } else { left = mid + <int> ; } } else { left = right = mid ; } } List < Position > list = new ArrayList < Position > ( ) ; int index = left - <int> ; if ( index > = <int> ) { position = positions [ index ] ; while ( index > = <int> & & ( position . getOffset ( ) + position . getLength ( ) ) > offset ) { index - - ; if ( index > <int> ) { position = positions [ index ] ; } } } index + + ; position = positions [ index ] ; while ( index < positions . length & & ( position . getOffset ( ) < rangeEnd ) ) { list . add ( position ) ; index + + ; if ( index < positions . length ) { position = positions [ index ] ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Position [ list . size ( ) ] ) ; } @Override public void lineGetBackground ( LineBackgroundEvent event ) { event . lineBackground = null ; } protected Cursor getHandCursor ( ) { if ( handCursor = = null ) { handCursor = new Cursor ( ConsolePlugin . getStandardDisplay ( ) , SWT . CURSOR_HAND ) ; } return handCursor ; } protected Cursor getTextCursor ( ) { if ( textCursor = = null ) { textCursor = new Cursor ( ConsolePlugin . getStandardDisplay ( ) , SWT . CURSOR_IBEAM ) ; } return textCursor ; } protected void linkEntered ( IHyperlink link ) { Control control = getTextWidget ( ) ; if ( hyperlink ! = null ) { linkExited ( hyperlink ) ; } hyperlink = link ; hyperlink . linkEntered ( ) ; control . setCursor ( getHandCursor ( ) ) ; control . redraw ( ) ; control . addMouseListener ( this ) ; } protected void linkExited ( IHyperlink link ) { link . linkExited ( ) ; hyperlink = null ; Control control = getTextWidget ( ) ; control . setCursor ( getTextCursor ( ) ) ; control . redraw ( ) ; control . removeMouseListener ( this ) ; } @Override public void mouseEnter ( MouseEvent e ) { getTextWidget ( ) . addMouseMoveListener ( this ) ; } @Override public void mouseExit ( MouseEvent e ) { getTextWidget ( ) . removeMouseMoveListener ( this ) ; if ( hyperlink ! = null ) { linkExited ( hyperlink ) ; } } @Override public void mouseHover ( MouseEvent e ) { } @Override public void mouseMove ( MouseEvent e ) { int offset = - <int> ; try { Point p = new Point ( e . x , e . y ) ; offset = getTextWidget ( ) . getOffsetAtLocation ( p ) ; } catch ( IllegalArgumentException ex ) { } updateLinks ( offset ) ; } protected void updateLinks ( int offset ) { if ( offset > = <int> ) { IHyperlink link = getHyperlink ( offset ) ; if ( link ! = null ) { if ( link . equals ( hyperlink ) ) { return ; } linkEntered ( link ) ; return ; } } if ( hyperlink ! = null ) { linkExited ( hyperlink ) ; } } public IHyperlink getHyperlink ( ) { return hyperlink ; } public IHyperlink getHyperlink ( int offset ) { if ( offset > = <int> & & console ! = null ) { return console . getHyperlink ( offset ) ; } return null ; } @Override public void mouseDoubleClick ( MouseEvent e ) { } @Override public void mouseDown ( MouseEvent e ) { } @Override public void mouseUp ( MouseEvent e ) { } @Override protected IDocumentAdapter createDocumentAdapter ( ) { if ( documentAdapter = = null ) { documentAdapter = new ConsoleDocumentAdapter ( consoleWidth = - <int> ) ; } return documentAdapter ; } public void setConsoleWidth ( int width ) { if ( consoleWidth ! = width ) { consoleWidth = width ; ConsolePlugin . getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( documentAdapter ! = null ) { documentAdapter . setWidth ( consoleWidth ) ; } } } ) ; } } @Override protected void handleDispose ( ) { IDocument document = getDocument ( ) ; if ( document ! = null ) { document . removeDocumentListener ( documentListener ) ; document . removePositionUpdater ( positionUpdater ) ; } StyledText styledText = getTextWidget ( ) ; styledText . removeLineStyleListener ( this ) ; styledText . removeLineBackgroundListener ( this ) ; styledText . removeMouseTrackListener ( this ) ; if ( handCursor ! = null ) { handCursor . dispose ( ) ; } handCursor = null ; if ( textCursor ! = null ) { textCursor . dispose ( ) ; } textCursor = null ; hyperlink = null ; console = null ; ColorRegistry colorRegistry = JFaceResources . getColorRegistry ( ) ; colorRegistry . removeListener ( propertyChangeListener ) ; super . handleDispose ( ) ; } class HyperlinkColorChangeListener implements IPropertyChangeListener { @Override public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( JFacePreferences . ACTIVE_HYPERLINK_COLOR ) | | event . getProperty ( ) . equals ( JFacePreferences . HYPERLINK_COLOR ) ) { getTextWidget ( ) . redraw ( ) ; } } } @Override protected void updateTextListeners ( WidgetCommand cmd ) { super . updateTextListeners ( cmd ) ; cmd . preservedText = null ; cmd . event = null ; cmd . text = null ; } @Override protected void internalRevealRange ( int start , int end ) { StyledText textWidget = getTextWidget ( ) ; int startLine = documentAdapter . getLineAtOffset ( start ) ; int endLine = documentAdapter . getLineAtOffset ( end ) ; int top = textWidget . getTopIndex ( ) ; if ( top > - <int> ) { @SuppressWarnings ( <str> ) int lines = getVisibleLinesInViewport ( ) ; int bottom = top + lines ; int bufferZone = <int> ; if ( startLine > = top + bufferZone & & startLine < = bottom - bufferZone & & endLine > = top + bufferZone & & endLine < = bottom - bufferZone ) { } else { int delta = Math . max ( <int> , lines - ( endLine - startLine ) ) ; textWidget . setTopIndex ( startLine - delta / <int> ) ; updateViewportListeners ( INTERNAL ) ; } if ( endLine < startLine ) { endLine + = startLine ; startLine = endLine - startLine ; endLine - = startLine ; } int startPixel = - <int> ; int endPixel = - <int> ; if ( endLine > startLine ) { IRegion extent = getExtent ( start , start ) ; startPixel = extent . getOffset ( ) + textWidget . getHorizontalPixel ( ) ; endPixel = startPixel ; } else { IRegion extent = getExtent ( start , end ) ; startPixel = extent . getOffset ( ) + textWidget . getHorizontalPixel ( ) ; endPixel = startPixel + extent . getLength ( ) ; } int visibleStart = textWidget . getHorizontalPixel ( ) ; int visibleEnd = visibleStart + textWidget . getClientArea ( ) . width ; if ( startPixel < visibleStart | | visibleEnd < endPixel ) { bufferZone = <int> ; int newOffset = visibleStart ; int visibleWidth = visibleEnd - visibleStart ; int selectionPixelWidth = endPixel - startPixel ; if ( startPixel < visibleStart ) { newOffset = startPixel ; } else if ( selectionPixelWidth + bufferZone < visibleWidth ) { newOffset = endPixel + bufferZone - visibleWidth ; } else { newOffset = startPixel ; } float index = ( ( float ) newOffset ) / ( ( float ) getAverageCharWidth ( ) ) ; textWidget . setHorizontalIndex ( Math . round ( index ) ) ; } } } } 
