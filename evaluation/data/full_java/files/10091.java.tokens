package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import static com . google . common . collect . testing . features . MapFeature . ALLOWS_NULL_KEYS ; import static com . google . common . collect . testing . features . MapFeature . ALLOWS_NULL_VALUES ; import static com . google . common . collect . testing . features . MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION ; import static com . google . common . collect . testing . features . MapFeature . SUPPORTS_PUT ; import static java . util . Collections . singletonList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . AbstractMapTester ; import com . google . common . collect . testing . Helpers ; import com . google . common . collect . testing . MinimalCollection ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @SuppressWarnings ( <str> ) @GwtCompatible ( emulated = true ) public class MapPutAllTester < K , V > extends AbstractMapTester < K , V > { private List < Entry < K , V > > containsNullKey ; private List < Entry < K , V > > containsNullValue ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; containsNullKey = singletonList ( entry ( null , v3 ( ) ) ) ; containsNullValue = singletonList ( entry ( k3 ( ) , null ) ) ; } @MapFeature.Require ( SUPPORTS_PUT ) public void testPutAll_supportedNothing ( ) { getMap ( ) . putAll ( emptyMap ( ) ) ; expectUnchanged ( ) ; } @MapFeature.Require ( absent = SUPPORTS_PUT ) public void testPutAll_unsupportedNothing ( ) { try { getMap ( ) . putAll ( emptyMap ( ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @MapFeature.Require ( SUPPORTS_PUT ) public void testPutAll_supportedNonePresent ( ) { putAll ( createDisjointCollection ( ) ) ; expectAdded ( e3 ( ) , e4 ( ) ) ; } @MapFeature.Require ( absent = SUPPORTS_PUT ) public void testPutAll_unsupportedNonePresent ( ) { try { putAll ( createDisjointCollection ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; expectMissing ( e3 ( ) , e4 ( ) ) ; } @MapFeature.Require ( SUPPORTS_PUT ) @CollectionSize.Require ( absent = ZERO ) public void testPutAll_supportedSomePresent ( ) { putAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ; expectAdded ( e3 ( ) ) ; } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_PUT } ) @CollectionSize.Require ( absent = ZERO ) public void testPutAllSomePresentConcurrentWithEntrySetIteration ( ) { try { Iterator < Entry < K , V > > iterator = getMap ( ) . entrySet ( ) . iterator ( ) ; putAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( absent = SUPPORTS_PUT ) @CollectionSize.Require ( absent = ZERO ) public void testPutAll_unsupportedSomePresent ( ) { try { putAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; } @MapFeature.Require ( absent = SUPPORTS_PUT ) @CollectionSize.Require ( absent = ZERO ) public void testPutAll_unsupportedAllPresent ( ) { try { putAll ( MinimalCollection . of ( e0 ( ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_KEYS } ) public void testPutAll_nullKeySupported ( ) { putAll ( containsNullKey ) ; expectAdded ( containsNullKey . get ( <int> ) ) ; } @MapFeature.Require ( value = SUPPORTS_PUT , absent = ALLOWS_NULL_KEYS ) public void testPutAll_nullKeyUnsupported ( ) { try { putAll ( containsNullKey ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullKeyMissingWhenNullKeysUnsupported ( <str> + <str> ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_VALUES } ) public void testPutAll_nullValueSupported ( ) { putAll ( containsNullValue ) ; expectAdded ( containsNullValue . get ( <int> ) ) ; } @MapFeature.Require ( value = SUPPORTS_PUT , absent = ALLOWS_NULL_VALUES ) public void testPutAll_nullValueUnsupported ( ) { try { putAll ( containsNullValue ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullValueMissingWhenNullValuesUnsupported ( <str> + <str> ) ; } @MapFeature.Require ( SUPPORTS_PUT ) public void testPutAll_nullCollectionReference ( ) { try { getMap ( ) . putAll ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } private Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } private void putAll ( Iterable < Entry < K , V > > entries ) { Map < K , V > map = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entries ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } getMap ( ) . putAll ( map ) ; } @GwtIncompatible ( <str> ) public static Method getPutAllNullKeyUnsupportedMethod ( ) { return Helpers . getMethod ( MapPutAllTester . class , <str> ) ; } } 
