package org . elasticsearch . search . suggest . completion ; import org . apache . lucene . search . suggest . Lookup ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . suggest . Suggest ; import java . io . IOException ; import java . util . * ; public final class CompletionSuggestion extends Suggest . Suggestion < CompletionSuggestion . Entry > { public static final int TYPE = <int> ; public CompletionSuggestion ( ) { } public CompletionSuggestion ( String name , int size ) { super ( name , size ) ; } private static final class OptionPriorityQueue extends org . apache . lucene . util . PriorityQueue < Entry . Option > { private final Comparator < Suggest . Suggestion . Entry . Option > comparator ; OptionPriorityQueue ( int maxSize , Comparator < Suggest . Suggestion . Entry . Option > comparator ) { super ( maxSize ) ; this . comparator = comparator ; } @Override protected boolean lessThan ( Entry . Option a , Entry . Option b ) { int cmp = comparator . compare ( a , b ) ; if ( cmp ! = <int> ) { return cmp > <int> ; } return Lookup . CHARSEQUENCE_COMPARATOR . compare ( a . getText ( ) . string ( ) , b . getText ( ) . string ( ) ) > <int> ; } Entry . Option [ ] get ( ) { int size = size ( ) ; Entry . Option [ ] results = new Entry . Option [ size ] ; for ( int i = size - <int> ; i > = <int> ; i - - ) { results [ i ] = pop ( ) ; } return results ; } } @Override public Suggest . Suggestion < Entry > reduce ( List < Suggest . Suggestion < Entry > > toReduce ) { if ( toReduce . size ( ) = = <int> ) { return toReduce . get ( <int> ) ; } else { Comparator < Suggest . Suggestion . Entry . Option > optionComparator = sortComparator ( ) ; OptionPriorityQueue priorityQueue = new OptionPriorityQueue ( size , sortComparator ( ) ) ; for ( Suggest . Suggestion < Entry > entries : toReduce ) { assert entries . getEntries ( ) . size ( ) = = <int> : <str> ; for ( Entry . Option option : entries . getEntries ( ) . get ( <int> ) ) { if ( option = = priorityQueue . insertWithOverflow ( option ) ) { break ; } } } Entry options = this . entries . get ( <int> ) ; options . getOptions ( ) . clear ( ) ; Collections . addAll ( options . getOptions ( ) , priorityQueue . get ( ) ) ; return this ; } } @Override public int getType ( ) { return TYPE ; } @Override protected Entry newEntry ( ) { return new Entry ( ) ; } public final static class Entry extends Suggest . Suggestion . Entry < CompletionSuggestion . Entry . Option > { public Entry ( Text text , int offset , int length ) { super ( text , offset , length ) ; } protected Entry ( ) { super ( ) ; } @Override protected Option newOption ( ) { return new Option ( ) ; } public static class Option extends Suggest . Suggestion . Entry . Option { private Map < String , Set < CharSequence > > contexts ; private Map < String , List < Object > > payload ; public Option ( Text text , float score , Map < String , Set < CharSequence > > contexts , Map < String , List < Object > > payload ) { super ( text , score ) ; this . payload = payload ; this . contexts = contexts ; } protected Option ( ) { super ( ) ; } @Override protected void mergeInto ( Suggest . Suggestion . Entry . Option otherOption ) { throw new UnsupportedOperationException ( ) ; } public Map < String , List < Object > > getPayload ( ) { return payload ; } public Map < String , Set < CharSequence > > getContexts ( ) { return contexts ; } @Override public void setScore ( float score ) { super . setScore ( score ) ; } @Override protected XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { super . innerToXContent ( builder , params ) ; if ( payload . size ( ) > <int> ) { builder . startObject ( <str> ) ; for ( Map . Entry < String , List < Object > > entry : payload . entrySet ( ) ) { builder . startArray ( entry . getKey ( ) ) ; for ( Object payload : entry . getValue ( ) ) { builder . value ( payload ) ; } builder . endArray ( ) ; } builder . endObject ( ) ; } if ( contexts . size ( ) > <int> ) { builder . startObject ( <str> ) ; for ( Map . Entry < String , Set < CharSequence > > entry : contexts . entrySet ( ) ) { builder . startArray ( entry . getKey ( ) ) ; for ( CharSequence context : entry . getValue ( ) ) { builder . value ( context . toString ( ) ) ; } builder . endArray ( ) ; } builder . endObject ( ) ; } return builder ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int payloadSize = in . readInt ( ) ; this . payload = new LinkedHashMap < > ( payloadSize ) ; for ( int i = <int> ; i < payloadSize ; i + + ) { String payloadName = in . readString ( ) ; int nValues = in . readVInt ( ) ; List < Object > values = new ArrayList < > ( nValues ) ; for ( int j = <int> ; j < nValues ; j + + ) { values . add ( in . readGenericValue ( ) ) ; } this . payload . put ( payloadName , values ) ; } int contextSize = in . readInt ( ) ; this . contexts = new LinkedHashMap < > ( contextSize ) ; for ( int i = <int> ; i < contextSize ; i + + ) { String contextName = in . readString ( ) ; int nContexts = in . readVInt ( ) ; Set < CharSequence > contexts = new HashSet < > ( nContexts ) ; for ( int j = <int> ; j < nContexts ; j + + ) { contexts . add ( in . readString ( ) ) ; } this . contexts . put ( contextName , contexts ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( payload . size ( ) ) ; for ( Map . Entry < String , List < Object > > entry : payload . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; List < Object > values = entry . getValue ( ) ; out . writeVInt ( values . size ( ) ) ; for ( Object value : values ) { out . writeGenericValue ( value ) ; } } out . writeInt ( contexts . size ( ) ) ; for ( Map . Entry < String , Set < CharSequence > > entry : contexts . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeVInt ( entry . getValue ( ) . size ( ) ) ; for ( CharSequence ctx : entry . getValue ( ) ) { out . writeString ( ctx . toString ( ) ) ; } } } @Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( getText ( ) ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( getScore ( ) ) ; stringBuilder . append ( <str> ) ; for ( Map . Entry < String , List < Object > > entry : payload . entrySet ( ) ) { stringBuilder . append ( <str> ) ; stringBuilder . append ( entry . getKey ( ) ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( entry . getValue ( ) ) ; } stringBuilder . append ( <str> ) ; stringBuilder . append ( <str> ) ; for ( Map . Entry < String , Set < CharSequence > > entry : contexts . entrySet ( ) ) { stringBuilder . append ( <str> ) ; stringBuilder . append ( entry . getKey ( ) ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( entry . getValue ( ) ) ; } stringBuilder . append ( <str> ) ; return stringBuilder . toString ( ) ; } } } } 
