package org . elasticsearch . search . aggregations . bucket . sampler ; import org . apache . lucene . index . LeafReaderContext ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . search . aggregations . * ; import org . elasticsearch . search . aggregations . bucket . BestDocsDeferringCollector ; import org . elasticsearch . search . aggregations . bucket . DeferringBucketCollector ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSource . Numeric ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class SamplerAggregator extends SingleBucketAggregator { public enum ExecutionMode { MAP ( new ParseField ( <str> ) ) { @Override Aggregator create ( String name , AggregatorFactories factories , int shardSize , int maxDocsPerValue , ValuesSource valuesSource , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new DiversifiedMapSamplerAggregator ( name , shardSize , factories , context , parent , pipelineAggregators , metaData , valuesSource , maxDocsPerValue ) ; } @Override boolean needsGlobalOrdinals ( ) { return false ; } } , BYTES_HASH ( new ParseField ( <str> ) ) { @Override Aggregator create ( String name , AggregatorFactories factories , int shardSize , int maxDocsPerValue , ValuesSource valuesSource , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new DiversifiedBytesHashSamplerAggregator ( name , shardSize , factories , context , parent , pipelineAggregators , metaData , valuesSource , maxDocsPerValue ) ; } @Override boolean needsGlobalOrdinals ( ) { return false ; } } , GLOBAL_ORDINALS ( new ParseField ( <str> ) ) { @Override Aggregator create ( String name , AggregatorFactories factories , int shardSize , int maxDocsPerValue , ValuesSource valuesSource , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new DiversifiedOrdinalsSamplerAggregator ( name , shardSize , factories , context , parent , pipelineAggregators , metaData , ( ValuesSource . Bytes . WithOrdinals . FieldData ) valuesSource , maxDocsPerValue ) ; } @Override boolean needsGlobalOrdinals ( ) { return true ; } } ; public static ExecutionMode fromString ( String value , ParseFieldMatcher parseFieldMatcher ) { for ( ExecutionMode mode : values ( ) ) { if ( parseFieldMatcher . match ( value , mode . parseField ) ) { return mode ; } } throw new IllegalArgumentException ( <str> + value + <str> + values ( ) ) ; } private final ParseField parseField ; ExecutionMode ( ParseField parseField ) { this . parseField = parseField ; } abstract Aggregator create ( String name , AggregatorFactories factories , int shardSize , int maxDocsPerValue , ValuesSource valuesSource , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException ; abstract boolean needsGlobalOrdinals ( ) ; @Override public String toString ( ) { return parseField . getPreferredName ( ) ; } } protected final int shardSize ; protected BestDocsDeferringCollector bdd ; public SamplerAggregator ( String name , int shardSize , AggregatorFactories factories , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . shardSize = shardSize ; } @Override public boolean needsScores ( ) { return true ; } @Override public DeferringBucketCollector getDeferringCollector ( ) { bdd = new BestDocsDeferringCollector ( shardSize , context . bigArrays ( ) ) ; return bdd ; } @Override protected boolean shouldDefer ( Aggregator aggregator ) { return true ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { runDeferredCollections ( owningBucketOrdinal ) ; return new InternalSampler ( name , bdd = = null ? <int> : bdd . getDocCount ( owningBucketOrdinal ) , bucketAggregations ( owningBucketOrdinal ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalSampler ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } public static class Factory extends AggregatorFactory { private int shardSize ; public Factory ( String name , int shardSize ) { super ( name , InternalSampler . TYPE . name ( ) ) ; this . shardSize = shardSize ; } @Override public Aggregator createInternal ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new SamplerAggregator ( name , shardSize , factories , context , parent , pipelineAggregators , metaData ) ; } } public static class DiversifiedFactory extends ValuesSourceAggregatorFactory < ValuesSource > { private int shardSize ; private int maxDocsPerValue ; private String executionHint ; public DiversifiedFactory ( String name , int shardSize , String executionHint , ValuesSourceConfig vsConfig , int maxDocsPerValue ) { super ( name , InternalSampler . TYPE . name ( ) , vsConfig ) ; this . shardSize = shardSize ; this . maxDocsPerValue = maxDocsPerValue ; this . executionHint = executionHint ; } @Override protected Aggregator doCreateInternal ( ValuesSource valuesSource , AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { if ( valuesSource instanceof ValuesSource . Numeric ) { return new DiversifiedNumericSamplerAggregator ( name , shardSize , factories , context , parent , pipelineAggregators , metaData , ( Numeric ) valuesSource , maxDocsPerValue ) ; } if ( valuesSource instanceof ValuesSource . Bytes ) { ExecutionMode execution = null ; if ( executionHint ! = null ) { execution = ExecutionMode . fromString ( executionHint , context . searchContext ( ) . parseFieldMatcher ( ) ) ; } if ( execution = = null ) { execution = ExecutionMode . GLOBAL_ORDINALS ; } if ( ( execution . needsGlobalOrdinals ( ) ) & & ( ! ( valuesSource instanceof ValuesSource . Bytes . WithOrdinals ) ) ) { execution = ExecutionMode . MAP ; } return execution . create ( name , factories , shardSize , maxDocsPerValue , valuesSource , context , parent , pipelineAggregators , metaData ) ; } throw new AggregationExecutionException ( <str> + config . fieldContext ( ) . field ( ) + <str> ) ; } @Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { final UnmappedSampler aggregation = new UnmappedSampler ( name , pipelineAggregators , metaData ) ; return new NonCollectingAggregator ( name , aggregationContext , parent , factories , pipelineAggregators , metaData ) { @Override public InternalAggregation buildEmptyAggregation ( ) { return aggregation ; } } ; } } @Override protected LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , LeafBucketCollector sub ) throws IOException { if ( bdd = = null ) { throw new AggregationExecutionException ( <str> ) ; } return bdd . getLeafCollector ( ctx ) ; } @Override protected void doClose ( ) { Releasables . close ( bdd ) ; super . doClose ( ) ; } } 
