package org . apache . cassandra . utils ; import java . io . * ; import java . lang . reflect . Field ; import java . math . BigInteger ; import java . net . * ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . * ; import java . util . concurrent . * ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; import javax . annotation . Nonnull ; import javax . annotation . Nullable ; import com . google . common . base . Joiner ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . auth . IAuthenticator ; import org . apache . cassandra . auth . IAuthorizer ; import org . apache . cassandra . auth . IRoleManager ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . DataOutputBufferFixed ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . net . AsyncOneResponse ; import org . codehaus . jackson . JsonFactory ; import org . codehaus . jackson . map . ObjectMapper ; public class FBUtilities { private static final Logger logger = LoggerFactory . getLogger ( FBUtilities . class ) ; private static final ObjectMapper jsonMapper = new ObjectMapper ( new JsonFactory ( ) ) ; public static final BigInteger TWO = new BigInteger ( <str> ) ; private static final String DEFAULT_TRIGGER_DIR = <str> ; private static final String OPERATING_SYSTEM = System . getProperty ( <str> ) . toLowerCase ( ) ; private static final boolean IS_WINDOWS = OPERATING_SYSTEM . contains ( <str> ) ; private static final boolean HAS_PROCFS = ! IS_WINDOWS & & ( new File ( File . separator + <str> ) ) . exists ( ) ; private static volatile InetAddress localInetAddress ; private static volatile InetAddress broadcastInetAddress ; public static int getAvailableProcessors ( ) { if ( System . getProperty ( <str> ) ! = null ) return Integer . parseInt ( System . getProperty ( <str> ) ) ; else return Runtime . getRuntime ( ) . availableProcessors ( ) ; } private static final ThreadLocal < MessageDigest > localMD5Digest = new ThreadLocal < MessageDigest > ( ) { @Override protected MessageDigest initialValue ( ) { return newMessageDigest ( <str> ) ; } @Override public MessageDigest get ( ) { MessageDigest digest = super . get ( ) ; digest . reset ( ) ; return digest ; } } ; public static final int MAX_UNSIGNED_SHORT = <hex> ; public static MessageDigest threadLocalMD5Digest ( ) { return localMD5Digest . get ( ) ; } public static MessageDigest newMessageDigest ( String algorithm ) { try { return MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( <str> + algorithm + <str> , nsae ) ; } } public static InetAddress getLocalAddress ( ) { if ( localInetAddress = = null ) try { localInetAddress = DatabaseDescriptor . getListenAddress ( ) = = null ? InetAddress . getLocalHost ( ) : DatabaseDescriptor . getListenAddress ( ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } return localInetAddress ; } public static InetAddress getBroadcastAddress ( ) { if ( broadcastInetAddress = = null ) broadcastInetAddress = DatabaseDescriptor . getBroadcastAddress ( ) = = null ? getLocalAddress ( ) : DatabaseDescriptor . getBroadcastAddress ( ) ; return broadcastInetAddress ; } public static Collection < InetAddress > getAllLocalAddresses ( ) { Set < InetAddress > localAddresses = new HashSet < InetAddress > ( ) ; try { Enumeration < NetworkInterface > nets = NetworkInterface . getNetworkInterfaces ( ) ; if ( nets ! = null ) { while ( nets . hasMoreElements ( ) ) localAddresses . addAll ( Collections . list ( nets . nextElement ( ) . getInetAddresses ( ) ) ) ; } } catch ( SocketException e ) { throw new AssertionError ( e ) ; } return localAddresses ; } public static String getNetworkInterface ( InetAddress localAddress ) { try { for ( NetworkInterface ifc : Collections . list ( NetworkInterface . getNetworkInterfaces ( ) ) ) { if ( ifc . isUp ( ) ) { for ( InetAddress addr : Collections . list ( ifc . getInetAddresses ( ) ) ) { if ( addr . equals ( localAddress ) ) return ifc . getDisplayName ( ) ; } } } } catch ( SocketException e ) { } return null ; } public static Pair < BigInteger , Boolean > midpoint ( BigInteger left , BigInteger right , int sigbits ) { BigInteger midpoint ; boolean remainder ; if ( left . compareTo ( right ) < <int> ) { BigInteger sum = left . add ( right ) ; remainder = sum . testBit ( <int> ) ; midpoint = sum . shiftRight ( <int> ) ; } else { BigInteger max = TWO . pow ( sigbits ) ; BigInteger distance = max . add ( right ) . subtract ( left ) ; remainder = distance . testBit ( <int> ) ; midpoint = distance . shiftRight ( <int> ) . add ( left ) . mod ( max ) ; } return Pair . create ( midpoint , remainder ) ; } public static int compareUnsigned ( byte [ ] bytes1 , byte [ ] bytes2 , int offset1 , int offset2 , int len1 , int len2 ) { return FastByteOperations . compareUnsigned ( bytes1 , offset1 , len1 , bytes2 , offset2 , len2 ) ; } public static int compareUnsigned ( byte [ ] bytes1 , byte [ ] bytes2 ) { return compareUnsigned ( bytes1 , bytes2 , <int> , <int> , bytes1 . length , bytes2 . length ) ; } public static byte [ ] xor ( byte [ ] left , byte [ ] right ) { if ( left = = null | | right = = null ) return null ; if ( left . length > right . length ) { byte [ ] swap = left ; left = right ; right = swap ; } byte [ ] out = Arrays . copyOf ( right , right . length ) ; for ( int i = <int> ; i < left . length ; i + + ) { out [ i ] = ( byte ) ( ( left [ i ] & <hex> ) ^ ( right [ i ] & <hex> ) ) ; } return out ; } public static byte [ ] hash ( ByteBuffer . . . data ) { MessageDigest messageDigest = localMD5Digest . get ( ) ; for ( ByteBuffer block : data ) { if ( block . hasArray ( ) ) messageDigest . update ( block . array ( ) , block . arrayOffset ( ) + block . position ( ) , block . remaining ( ) ) ; else messageDigest . update ( block . duplicate ( ) ) ; } return messageDigest . digest ( ) ; } public static BigInteger hashToBigInteger ( ByteBuffer data ) { return new BigInteger ( hash ( data ) ) . abs ( ) ; } public static void sortSampledKeys ( List < DecoratedKey > keys , Range < Token > range ) { if ( range . left . compareTo ( range . right ) > = <int> ) { final Token right = range . right ; Comparator < DecoratedKey > comparator = new Comparator < DecoratedKey > ( ) { public int compare ( DecoratedKey o1 , DecoratedKey o2 ) { if ( ( right . compareTo ( o1 . getToken ( ) ) < <int> & & right . compareTo ( o2 . getToken ( ) ) < <int> ) | | ( right . compareTo ( o1 . getToken ( ) ) > <int> & & right . compareTo ( o2 . getToken ( ) ) > <int> ) ) { return o1 . compareTo ( o2 ) ; } return o2 . compareTo ( o1 ) ; } } ; Collections . sort ( keys , comparator ) ; } else { Collections . sort ( keys ) ; } } public static String resourceToFile ( String filename ) throws ConfigurationException { ClassLoader loader = FBUtilities . class . getClassLoader ( ) ; URL scpurl = loader . getResource ( filename ) ; if ( scpurl = = null ) throw new ConfigurationException ( <str> + filename ) ; return new File ( scpurl . getFile ( ) ) . getAbsolutePath ( ) ; } public static File cassandraTriggerDir ( ) { File triggerDir = null ; if ( System . getProperty ( <str> ) ! = null ) { triggerDir = new File ( System . getProperty ( <str> ) ) ; } else { URL confDir = FBUtilities . class . getClassLoader ( ) . getResource ( DEFAULT_TRIGGER_DIR ) ; if ( confDir ! = null ) triggerDir = new File ( confDir . getFile ( ) ) ; } if ( triggerDir = = null | | ! triggerDir . exists ( ) ) { logger . warn ( <str> ) ; return null ; } return triggerDir ; } public static String getReleaseVersionString ( ) { try ( InputStream in = FBUtilities . class . getClassLoader ( ) . getResourceAsStream ( <str> ) ) { if ( in = = null ) { return System . getProperty ( <str> , <str> ) ; } Properties props = new Properties ( ) ; props . load ( in ) ; return props . getProperty ( <str> ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; logger . warn ( <str> , e ) ; return <str> ; } } public static long timestampMicros ( ) { return System . currentTimeMillis ( ) * <int> ; } public static int nowInSeconds ( ) { return ( int ) ( System . currentTimeMillis ( ) / <int> ) ; } public static < T > List < T > waitOnFutures ( Iterable < ? extends Future < ? extends T > > futures ) { List < T > results = new ArrayList < > ( ) ; Throwable fail = null ; for ( Future < ? extends T > f : futures ) { try { results . add ( f . get ( ) ) ; } catch ( Throwable t ) { fail = Throwables . merge ( fail , t ) ; } } Throwables . maybeFail ( fail ) ; return results ; } public static < T > T waitOnFuture ( Future < T > future ) { try { return future . get ( ) ; } catch ( ExecutionException ee ) { throw new RuntimeException ( ee ) ; } catch ( InterruptedException ie ) { throw new AssertionError ( ie ) ; } } public static void waitOnFutures ( List < AsyncOneResponse > results , long ms ) throws TimeoutException { for ( AsyncOneResponse result : results ) result . get ( ms , TimeUnit . MILLISECONDS ) ; } public static IPartitioner newPartitioner ( String partitionerClassName ) throws ConfigurationException { if ( ! partitionerClassName . contains ( <str> ) ) partitionerClassName = <str> + partitionerClassName ; return FBUtilities . instanceOrConstruct ( partitionerClassName , <str> ) ; } public static IAuthorizer newAuthorizer ( String className ) throws ConfigurationException { if ( ! className . contains ( <str> ) ) className = <str> + className ; return FBUtilities . construct ( className , <str> ) ; } public static IAuthenticator newAuthenticator ( String className ) throws ConfigurationException { if ( ! className . contains ( <str> ) ) className = <str> + className ; return FBUtilities . construct ( className , <str> ) ; } public static IRoleManager newRoleManager ( String className ) throws ConfigurationException { if ( ! className . contains ( <str> ) ) className = <str> + className ; return FBUtilities . construct ( className , <str> ) ; } public static < T > Class < T > classForName ( String classname , String readable ) throws ConfigurationException { try { return ( Class < T > ) Class . forName ( classname ) ; } catch ( ClassNotFoundException | NoClassDefFoundError e ) { throw new ConfigurationException ( String . format ( <str> , readable , classname ) , e ) ; } } public static < T > T instanceOrConstruct ( String classname , String readable ) throws ConfigurationException { Class < T > cls = FBUtilities . classForName ( classname , readable ) ; try { Field instance = cls . getField ( <str> ) ; return cls . cast ( instance . get ( null ) ) ; } catch ( NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e ) { return construct ( cls , classname , readable ) ; } } public static < T > T construct ( String classname , String readable ) throws ConfigurationException { Class < T > cls = FBUtilities . classForName ( classname , readable ) ; return construct ( cls , classname , readable ) ; } private static < T > T construct ( Class < T > cls , String classname , String readable ) throws ConfigurationException { try { return cls . newInstance ( ) ; } catch ( IllegalAccessException e ) { throw new ConfigurationException ( String . format ( <str> , readable , classname ) ) ; } catch ( InstantiationException e ) { throw new ConfigurationException ( String . format ( <str> , classname , readable ) ) ; } catch ( Exception e ) { if ( e . getCause ( ) instanceof ConfigurationException ) throw ( ConfigurationException ) e . getCause ( ) ; throw new ConfigurationException ( String . format ( <str> , readable , classname ) , e ) ; } } public static < T > NavigableSet < T > singleton ( T column , Comparator < ? super T > comparator ) { NavigableSet < T > s = new TreeSet < T > ( comparator ) ; s . add ( column ) ; return s ; } public static < T > NavigableSet < T > emptySortedSet ( Comparator < ? super T > comparator ) { return new TreeSet < T > ( comparator ) ; } @Nonnull public static String toString ( @Nullable Map < ? , ? > map ) { if ( map = = null ) return <str> ; Joiner . MapJoiner joiner = Joiner . on ( <str> ) . withKeyValueSeparator ( <str> ) ; return joiner . join ( map ) ; } public static Field getProtectedField ( Class klass , String fieldName ) { try { Field field = klass . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; return field ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } public static < T > CloseableIterator < T > closeableIterator ( Iterator < T > iterator ) { return new WrappedCloseableIterator < T > ( iterator ) ; } public static Map < String , String > fromJsonMap ( String json ) { try { return jsonMapper . readValue ( json , Map . class ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static List < String > fromJsonList ( String json ) { try { return jsonMapper . readValue ( json , List . class ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static String json ( Object object ) { try { return jsonMapper . writeValueAsString ( object ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static String prettyPrintMemory ( long size ) { if ( size > = <int> < < <int> ) return String . format ( <str> , size / ( double ) ( <int> < < <int> ) ) ; if ( size > = <int> < < <int> ) return String . format ( <str> , size / ( double ) ( <int> < < <int> ) ) ; return String . format ( <str> , size / ( double ) ( <int> < < <int> ) ) ; } public static void exec ( ProcessBuilder pb ) throws IOException { Process p = pb . start ( ) ; try { int errCode = p . waitFor ( ) ; if ( errCode ! = <int> ) { try ( BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; BufferedReader err = new BufferedReader ( new InputStreamReader ( p . getErrorStream ( ) ) ) ) { String lineSep = System . getProperty ( <str> ) ; StringBuilder sb = new StringBuilder ( ) ; String str ; while ( ( str = in . readLine ( ) ) ! = null ) sb . append ( str ) . append ( lineSep ) ; while ( ( str = err . readLine ( ) ) ! = null ) sb . append ( str ) . append ( lineSep ) ; throw new IOException ( <str> + StringUtils . join ( pb . command ( ) , <str> ) + <str> + errCode + <str> + sb . toString ( ) ) ; } } } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } } public static void updateChecksumInt ( Checksum checksum , int v ) { checksum . update ( ( v > > > <int> ) & <hex> ) ; checksum . update ( ( v > > > <int> ) & <hex> ) ; checksum . update ( ( v > > > <int> ) & <hex> ) ; checksum . update ( ( v > > > <int> ) & <hex> ) ; } public static void updateChecksum ( CRC32 checksum , ByteBuffer buffer , int offset , int length ) { int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; buffer . position ( offset ) . limit ( offset + length ) ; checksum . update ( buffer ) ; buffer . position ( position ) . limit ( limit ) ; } public static void updateChecksum ( CRC32 checksum , ByteBuffer buffer ) { int position = buffer . position ( ) ; checksum . update ( buffer ) ; buffer . position ( position ) ; } private static final ThreadLocal < byte [ ] > threadLocalScratchBuffer = new ThreadLocal < byte [ ] > ( ) { @Override protected byte [ ] initialValue ( ) { return new byte [ CompressionParams . DEFAULT_CHUNK_LENGTH ] ; } } ; public static byte [ ] getThreadLocalScratchBuffer ( ) { return threadLocalScratchBuffer . get ( ) ; } public static long abs ( long index ) { long negbit = index > > <int> ; return ( index ^ negbit ) - negbit ; } private static final class WrappedCloseableIterator < T > extends AbstractIterator < T > implements CloseableIterator < T > { private final Iterator < T > source ; public WrappedCloseableIterator ( Iterator < T > source ) { this . source = source ; } protected T computeNext ( ) { if ( ! source . hasNext ( ) ) return endOfData ( ) ; return source . next ( ) ; } public void close ( ) { } } public static < T > byte [ ] serialize ( T object , IVersionedSerializer < T > serializer , int version ) { int size = ( int ) serializer . serializedSize ( object , version ) ; try ( DataOutputBuffer buffer = new DataOutputBufferFixed ( size ) ) { serializer . serialize ( object , buffer , version ) ; assert buffer . getLength ( ) = = size & & buffer . getData ( ) . length = = size : String . format ( <str> , buffer . getData ( ) . length , buffer . getLength ( ) , size , object ) ; return buffer . getData ( ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } } public static long copy ( InputStream from , OutputStream to , long limit ) throws IOException { byte [ ] buffer = new byte [ <int> ] ; long copied = <int> ; int toCopy = buffer . length ; while ( true ) { if ( limit < buffer . length + copied ) toCopy = ( int ) ( limit - copied ) ; int sofar = from . read ( buffer , <int> , toCopy ) ; if ( sofar = = - <int> ) break ; to . write ( buffer , <int> , sofar ) ; copied + = sofar ; if ( limit = = copied ) break ; } return copied ; } public static File getToolsOutputDirectory ( ) { File historyDir = new File ( System . getProperty ( <str> ) , <str> ) ; FileUtils . createDirectory ( historyDir ) ; return historyDir ; } public static boolean isWindows ( ) { return IS_WINDOWS ; } public static boolean hasProcFS ( ) { return HAS_PROCFS ; } public static void updateWithShort ( MessageDigest digest , int val ) { digest . update ( ( byte ) ( ( val > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( val & <hex> ) ) ; } public static void updateWithByte ( MessageDigest digest , int val ) { digest . update ( ( byte ) ( val & <hex> ) ) ; } public static void updateWithInt ( MessageDigest digest , int val ) { digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; } public static void updateWithLong ( MessageDigest digest , long val ) { digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; digest . update ( ( byte ) ( ( val > > > <int> ) & <hex> ) ) ; } public static void updateWithBoolean ( MessageDigest digest , boolean val ) { updateWithByte ( digest , val ? <int> : <int> ) ; } public static void closeAll ( List < ? extends AutoCloseable > l ) throws Exception { Exception toThrow = null ; for ( AutoCloseable c : l ) { try { c . close ( ) ; } catch ( Exception e ) { if ( toThrow = = null ) toThrow = e ; else toThrow . addSuppressed ( e ) ; } } if ( toThrow ! = null ) throw toThrow ; } public static byte [ ] toWriteUTFBytes ( String s ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( baos ) ; dos . writeUTF ( s ) ; dos . flush ( ) ; return baos . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static void sleepQuietly ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } 
