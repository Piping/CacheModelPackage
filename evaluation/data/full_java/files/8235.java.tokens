package org . elasticsearch . index . query ; import com . spatial4j . core . io . GeohashUtils ; import com . spatial4j . core . shape . Rectangle ; import org . apache . lucene . search . * ; import org . elasticsearch . Version ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . index . search . geo . InMemoryGeoBoundingBoxQuery ; import org . elasticsearch . test . geo . RandomShapeGenerator ; import java . io . IOException ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class GeoBoundingBoxQueryBuilderTests extends AbstractQueryTestCase < GeoBoundingBoxQueryBuilder > { private static Double [ ] brokenDoubles = { Double . NaN , Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY } ; @Override protected GeoBoundingBoxQueryBuilder doCreateTestQueryBuilder ( ) { GeoBoundingBoxQueryBuilder builder = new GeoBoundingBoxQueryBuilder ( GEO_POINT_FIELD_NAME ) ; Rectangle box = RandomShapeGenerator . xRandomRectangle ( getRandom ( ) , RandomShapeGenerator . xRandomPoint ( getRandom ( ) ) ) ; if ( randomBoolean ( ) ) { int path = randomIntBetween ( <int> , <int> ) ; switch ( path ) { case <int> : builder . setCorners ( new GeoPoint ( box . getMaxY ( ) , box . getMinX ( ) ) , new GeoPoint ( box . getMinY ( ) , box . getMaxX ( ) ) ) ; break ; case <int> : builder . setCorners ( GeohashUtils . encodeLatLon ( box . getMaxY ( ) , box . getMinX ( ) ) , GeohashUtils . encodeLatLon ( box . getMinY ( ) , box . getMaxX ( ) ) ) ; break ; default : builder . setCorners ( box . getMaxY ( ) , box . getMinX ( ) , box . getMinY ( ) , box . getMaxX ( ) ) ; } } else { if ( randomBoolean ( ) ) { builder . setCornersOGC ( new GeoPoint ( box . getMinY ( ) , box . getMinX ( ) ) , new GeoPoint ( box . getMaxY ( ) , box . getMaxX ( ) ) ) ; } else { builder . setCornersOGC ( GeohashUtils . encodeLatLon ( box . getMinY ( ) , box . getMinX ( ) ) , GeohashUtils . encodeLatLon ( box . getMaxY ( ) , box . getMaxX ( ) ) ) ; } } if ( randomBoolean ( ) ) { builder . setValidationMethod ( randomFrom ( GeoValidationMethod . values ( ) ) ) ; } builder . type ( randomFrom ( GeoExecType . values ( ) ) ) ; return builder ; } public void testValidationNullFieldname ( ) { try { new GeoBoundingBoxQueryBuilder ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testValidationNullType ( ) { GeoBoundingBoxQueryBuilder qb = new GeoBoundingBoxQueryBuilder ( <str> ) ; try { qb . type ( ( GeoExecType ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testValidationNullTypeString ( ) { GeoBoundingBoxQueryBuilder qb = new GeoBoundingBoxQueryBuilder ( <str> ) ; try { qb . type ( ( String ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } @Override public void testToQuery ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; super . testToQuery ( ) ; } public void testExceptionOnMissingTypes ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length = = <int> ) ; try { super . testToQuery ( ) ; fail ( <str> ) ; } catch ( QueryShardException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testBrokenCoordinateCannotBeSet ( ) { PointTester [ ] testers = { new TopTester ( ) , new LeftTester ( ) , new BottomTester ( ) , new RightTester ( ) } ; GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; builder . setValidationMethod ( GeoValidationMethod . STRICT ) ; for ( PointTester tester : testers ) { try { tester . invalidateCoordinate ( builder , true ) ; fail ( <str> + tester . getClass ( ) . getName ( ) + <str> ) ; } catch ( IllegalArgumentException e ) { } } } public void testBrokenCoordinateCanBeSetWithIgnoreMalformed ( ) { PointTester [ ] testers = { new TopTester ( ) , new LeftTester ( ) , new BottomTester ( ) , new RightTester ( ) } ; GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; builder . setValidationMethod ( GeoValidationMethod . IGNORE_MALFORMED ) ; for ( PointTester tester : testers ) { tester . invalidateCoordinate ( builder , true ) ; } } public void testValidation ( ) { PointTester [ ] testers = { new TopTester ( ) , new LeftTester ( ) , new BottomTester ( ) , new RightTester ( ) } ; for ( PointTester tester : testers ) { QueryValidationException except = null ; GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; tester . invalidateCoordinate ( builder . setValidationMethod ( GeoValidationMethod . COERCE ) , false ) ; except = builder . checkLatLon ( true ) ; assertNull ( <str> + tester . getClass ( ) . getName ( ) + <str> + tester . invalidCoordinate + <str> , except ) ; tester . invalidateCoordinate ( builder . setValidationMethod ( GeoValidationMethod . COERCE ) , false ) ; except = builder . checkLatLon ( false ) ; assertNull ( <str> + tester . getClass ( ) . getName ( ) + <str> + tester . invalidCoordinate + <str> , except ) ; tester . invalidateCoordinate ( builder . setValidationMethod ( GeoValidationMethod . STRICT ) , false ) ; except = builder . checkLatLon ( true ) ; assertNull ( <str> + tester . getClass ( ) . getName ( ) + <str> + tester . invalidCoordinate , except ) ; tester . invalidateCoordinate ( builder . setValidationMethod ( GeoValidationMethod . STRICT ) , false ) ; except = builder . checkLatLon ( false ) ; assertNotNull ( <str> + tester . getClass ( ) . getName ( ) + <str> + tester . invalidCoordinate , except ) ; } } public void testTopBottomCannotBeFlipped ( ) { GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; double top = builder . topLeft ( ) . getLat ( ) ; double left = builder . topLeft ( ) . getLon ( ) ; double bottom = builder . bottomRight ( ) . getLat ( ) ; double right = builder . bottomRight ( ) . getLon ( ) ; assumeTrue ( <str> , top ! = bottom ) ; logger . info ( <str> , top , bottom ) ; try { builder . setValidationMethod ( GeoValidationMethod . STRICT ) . setCorners ( bottom , left , top , right ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testTopBottomCanBeFlippedOnIgnoreMalformed ( ) { GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; double top = builder . topLeft ( ) . getLat ( ) ; double left = builder . topLeft ( ) . getLon ( ) ; double bottom = builder . bottomRight ( ) . getLat ( ) ; double right = builder . bottomRight ( ) . getLon ( ) ; assumeTrue ( <str> , top ! = bottom ) ; builder . setValidationMethod ( GeoValidationMethod . IGNORE_MALFORMED ) . setCorners ( bottom , left , top , right ) ; } public void testLeftRightCanBeFlipped ( ) { GeoBoundingBoxQueryBuilder builder = createTestQueryBuilder ( ) ; double top = builder . topLeft ( ) . getLat ( ) ; double left = builder . topLeft ( ) . getLon ( ) ; double bottom = builder . bottomRight ( ) . getLat ( ) ; double right = builder . bottomRight ( ) . getLon ( ) ; builder . setValidationMethod ( GeoValidationMethod . IGNORE_MALFORMED ) . setCorners ( top , right , bottom , left ) ; builder . setValidationMethod ( GeoValidationMethod . STRICT ) . setCorners ( top , right , bottom , left ) ; } public void testNormalization ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; GeoBoundingBoxQueryBuilder qb = createTestQueryBuilder ( ) ; if ( getCurrentTypes ( ) . length ! = <int> & & <str> . equals ( qb . fieldName ( ) ) ) { qb . setCorners ( <int> , <int> , qb . bottomRight ( ) . getLat ( ) , qb . bottomRight ( ) . getLon ( ) ) ; qb . setValidationMethod ( GeoValidationMethod . COERCE ) ; Query query = qb . toQuery ( createShardContext ( ) ) ; if ( query instanceof ConstantScoreQuery ) { ConstantScoreQuery result = ( ConstantScoreQuery ) query ; BooleanQuery bboxFilter = ( BooleanQuery ) result . getQuery ( ) ; for ( BooleanClause clause : bboxFilter . clauses ( ) ) { NumericRangeQuery boundary = ( NumericRangeQuery ) clause . getQuery ( ) ; if ( boundary . getMax ( ) ! = null ) { assertTrue ( <str> , boundary . getMax ( ) . intValue ( ) < = <int> ) ; } } } else { assertTrue ( <str> , query instanceof InMemoryGeoBoundingBoxQuery ) ; } } } public void testStrictnessDefault ( ) { assertFalse ( <str> , GeoValidationMethod . DEFAULT_LENIENT_PARSING ) ; } @Override protected void doAssertLuceneQuery ( GeoBoundingBoxQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( context . indexVersionCreated ( ) . before ( Version . V_2_2_0 ) ) { if ( queryBuilder . type ( ) = = GeoExecType . INDEXED ) { assertTrue ( <str> , query instanceof ConstantScoreQuery ) ; } else { assertTrue ( <str> , query instanceof InMemoryGeoBoundingBoxQuery ) ; } } else { assertTrue ( <str> , query instanceof GeoPointInBBoxQuery ) ; } } public abstract class PointTester { private double brokenCoordinate = randomFrom ( brokenDoubles ) ; private double invalidCoordinate ; public PointTester ( double invalidCoodinate ) { this . invalidCoordinate = invalidCoodinate ; } public void invalidateCoordinate ( GeoBoundingBoxQueryBuilder qb , boolean useBrokenDouble ) { if ( useBrokenDouble ) { fillIn ( brokenCoordinate , qb ) ; } else { fillIn ( invalidCoordinate , qb ) ; } } protected abstract void fillIn ( double fillIn , GeoBoundingBoxQueryBuilder qb ) ; } public class TopTester extends PointTester { public TopTester ( ) { super ( randomDoubleBetween ( GeoUtils . MAX_LAT , Double . MAX_VALUE , false ) ) ; } @Override public void fillIn ( double coordinate , GeoBoundingBoxQueryBuilder qb ) { qb . setCorners ( coordinate , qb . topLeft ( ) . getLon ( ) , qb . bottomRight ( ) . getLat ( ) , qb . bottomRight ( ) . getLon ( ) ) ; } } public class LeftTester extends PointTester { public LeftTester ( ) { super ( randomDoubleBetween ( - Double . MAX_VALUE , GeoUtils . MIN_LON , true ) ) ; } @Override public void fillIn ( double coordinate , GeoBoundingBoxQueryBuilder qb ) { qb . setCorners ( qb . topLeft ( ) . getLat ( ) , coordinate , qb . bottomRight ( ) . getLat ( ) , qb . bottomRight ( ) . getLon ( ) ) ; } } public class BottomTester extends PointTester { public BottomTester ( ) { super ( randomDoubleBetween ( - Double . MAX_VALUE , GeoUtils . MIN_LAT , false ) ) ; } @Override public void fillIn ( double coordinate , GeoBoundingBoxQueryBuilder qb ) { qb . setCorners ( qb . topLeft ( ) . getLat ( ) , qb . topLeft ( ) . getLon ( ) , coordinate , qb . bottomRight ( ) . getLon ( ) ) ; } } public class RightTester extends PointTester { public RightTester ( ) { super ( randomDoubleBetween ( GeoUtils . MAX_LON , Double . MAX_VALUE , true ) ) ; } @Override public void fillIn ( double coordinate , GeoBoundingBoxQueryBuilder qb ) { qb . setCorners ( qb . topLeft ( ) . getLat ( ) , qb . topLeft ( ) . getLon ( ) , qb . topLeft ( ) . getLat ( ) , coordinate ) ; } } public void testParsingAndToQuery1 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } public void testParsingAndToQuery2 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } public void testParsingAndToQuery3 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } public void testParsingAndToQuery4 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } public void testParsingAndToQuery5 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } public void testParsingAndToQuery6 ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + GEO_POINT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; assertGeoBoundingBoxQuery ( query ) ; } private void assertGeoBoundingBoxQuery ( String query ) throws IOException { Query parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) ; if ( queryShardContext ( ) . indexVersionCreated ( ) . before ( Version . V_2_2_0 ) ) { InMemoryGeoBoundingBoxQuery filter = ( InMemoryGeoBoundingBoxQuery ) parsedQuery ; assertThat ( filter . fieldName ( ) , equalTo ( GEO_POINT_FIELD_NAME ) ) ; assertThat ( filter . topLeft ( ) . lat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( filter . topLeft ( ) . lon ( ) , closeTo ( - <int> , <float> ) ) ; assertThat ( filter . bottomRight ( ) . lat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( filter . bottomRight ( ) . lon ( ) , closeTo ( - <int> , <float> ) ) ; } else { GeoPointInBBoxQuery q = ( GeoPointInBBoxQuery ) parsedQuery ; assertThat ( q . getField ( ) , equalTo ( GEO_POINT_FIELD_NAME ) ) ; assertThat ( q . getMaxLat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( q . getMinLon ( ) , closeTo ( - <int> , <float> ) ) ; assertThat ( q . getMinLat ( ) , closeTo ( <int> , <float> ) ) ; assertThat ( q . getMaxLon ( ) , closeTo ( - <int> , <float> ) ) ; } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; GeoBoundingBoxQueryBuilder parsed = ( GeoBoundingBoxQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . fieldName ( ) ) ; assertEquals ( json , - <float> , parsed . topLeft ( ) . getLon ( ) , <float> ) ; assertEquals ( json , <float> , parsed . topLeft ( ) . getLat ( ) , <float> ) ; assertEquals ( json , - <float> , parsed . bottomRight ( ) . getLon ( ) , <float> ) ; assertEquals ( json , <float> , parsed . bottomRight ( ) . getLat ( ) , <float> ) ; assertEquals ( json , <float> , parsed . boost ( ) , <float> ) ; assertEquals ( json , GeoExecType . MEMORY , parsed . type ( ) ) ; } } 
