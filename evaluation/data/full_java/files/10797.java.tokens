package org . gradle . internal ; import org . gradle . api . Action ; import org . gradle . api . Transformer ; import org . gradle . api . specs . Spec ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; public abstract class Actions { public static < T > Action < T > doNothing ( ) { return new NullAction < T > ( ) ; } private static class NullAction < T > implements Action < T > , Serializable { public void execute ( T t ) { } } public static < T > Action < T > composite ( Iterable < ? extends Action < ? super T > > actions ) { return new CompositeAction < T > ( actions ) ; } public static < T > Action < T > composite ( Action < ? super T > . . . actions ) { return composite ( Arrays . asList ( actions ) ) ; } private static class CompositeAction < T > implements Action < T > { private final Iterable < ? extends Action < ? super T > > actions ; private CompositeAction ( Iterable < ? extends Action < ? super T > > actions ) { this . actions = actions ; } public void execute ( T item ) { for ( Action < ? super T > action : actions ) { action . execute ( item ) ; } } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } CompositeAction that = ( CompositeAction ) o ; if ( ! actions . equals ( that . actions ) ) { return false ; } return true ; } @Override public int hashCode ( ) { return actions . hashCode ( ) ; } } public static < T , I > Action < I > transformBefore ( final Action < ? super T > action , final Transformer < ? extends T , ? super I > transformer ) { return new TransformingActionAdapter < T , I > ( transformer , action ) ; } private static class TransformingActionAdapter < T , I > implements Action < I > { private final Transformer < ? extends T , ? super I > transformer ; private final Action < ? super T > action ; private TransformingActionAdapter ( Transformer < ? extends T , ? super I > transformer , Action < ? super T > action ) { this . transformer = transformer ; this . action = action ; } public void execute ( I thing ) { T transformed = transformer . transform ( thing ) ; action . execute ( transformed ) ; } } public static < T , I > Action < I > castBefore ( final Class < T > actionType , final Action < ? super T > action ) { return transformBefore ( action , Transformers . cast ( actionType ) ) ; } public static < T > Action < T > toAction ( Runnable runnable ) { if ( runnable = = null ) { return Actions . doNothing ( ) ; } else { return new RunnableActionAdapter < T > ( runnable ) ; } } private static class RunnableActionAdapter < T > implements Action < T > { private final Runnable runnable ; private RunnableActionAdapter ( Runnable runnable ) { this . runnable = runnable ; } public void execute ( T t ) { runnable . run ( ) ; } @Override public String toString ( ) { return String . format ( <str> , runnable ) ; } } public static < T > Action < T > filter ( Action < ? super T > action , Spec < ? super T > filter ) { return new FilteredAction < T > ( action , filter ) ; } private static class FilteredAction < T > implements Action < T > { private final Spec < ? super T > filter ; private final Action < ? super T > action ; public FilteredAction ( Action < ? super T > action , Spec < ? super T > filter ) { this . filter = filter ; this . action = action ; } public void execute ( T t ) { if ( filter . isSatisfiedBy ( t ) ) { action . execute ( t ) ; } } } public static < T > T with ( T instance , Action < ? super T > action ) { action . execute ( instance ) ; return instance ; } public static < T > Action < T > add ( final Collection < ? super T > collection ) { return new Action < T > ( ) { @Override public void execute ( T t ) { collection . add ( t ) ; } } ; } } 
