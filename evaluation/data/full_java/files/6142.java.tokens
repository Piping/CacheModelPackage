package org . elasticsearch . common . xcontent ; import com . fasterxml . jackson . dataformat . cbor . CBORConstants ; import com . fasterxml . jackson . dataformat . smile . SmileConstants ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . xcontent . cbor . CborXContent ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . common . xcontent . smile . SmileXContent ; import org . elasticsearch . common . xcontent . yaml . YamlXContent ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class XContentFactory { private static int GUESS_HEADER_LENGTH = <int> ; public static XContentBuilder jsonBuilder ( ) throws IOException { return contentBuilder ( XContentType . JSON ) ; } public static XContentBuilder jsonBuilder ( OutputStream os ) throws IOException { return new XContentBuilder ( JsonXContent . jsonXContent , os ) ; } public static XContentBuilder smileBuilder ( ) throws IOException { return contentBuilder ( XContentType . SMILE ) ; } public static XContentBuilder smileBuilder ( OutputStream os ) throws IOException { return new XContentBuilder ( SmileXContent . smileXContent , os ) ; } public static XContentBuilder yamlBuilder ( ) throws IOException { return contentBuilder ( XContentType . YAML ) ; } public static XContentBuilder yamlBuilder ( OutputStream os ) throws IOException { return new XContentBuilder ( YamlXContent . yamlXContent , os ) ; } public static XContentBuilder cborBuilder ( ) throws IOException { return contentBuilder ( XContentType . CBOR ) ; } public static XContentBuilder cborBuilder ( OutputStream os ) throws IOException { return new XContentBuilder ( CborXContent . cborXContent , os ) ; } public static XContentBuilder contentBuilder ( XContentType type , OutputStream outputStream ) throws IOException { if ( type = = XContentType . JSON ) { return jsonBuilder ( outputStream ) ; } else if ( type = = XContentType . SMILE ) { return smileBuilder ( outputStream ) ; } else if ( type = = XContentType . YAML ) { return yamlBuilder ( outputStream ) ; } else if ( type = = XContentType . CBOR ) { return cborBuilder ( outputStream ) ; } throw new IllegalArgumentException ( <str> + type ) ; } public static XContentBuilder contentBuilder ( XContentType type ) throws IOException { if ( type = = XContentType . JSON ) { return JsonXContent . contentBuilder ( ) ; } else if ( type = = XContentType . SMILE ) { return SmileXContent . contentBuilder ( ) ; } else if ( type = = XContentType . YAML ) { return YamlXContent . contentBuilder ( ) ; } else if ( type = = XContentType . CBOR ) { return CborXContent . contentBuilder ( ) ; } throw new IllegalArgumentException ( <str> + type ) ; } public static XContent xContent ( XContentType type ) { return type . xContent ( ) ; } public static XContentType xContentType ( CharSequence content ) { int length = content . length ( ) < GUESS_HEADER_LENGTH ? content . length ( ) : GUESS_HEADER_LENGTH ; if ( length = = <int> ) { return null ; } char first = content . charAt ( <int> ) ; if ( first = = <str> ) { return XContentType . JSON ; } if ( length > <int> & & first = = SmileConstants . HEADER_BYTE_1 & & content . charAt ( <int> ) = = SmileConstants . HEADER_BYTE_2 & & content . charAt ( <int> ) = = SmileConstants . HEADER_BYTE_3 ) { return XContentType . SMILE ; } if ( length > <int> & & first = = <str> & & content . charAt ( <int> ) = = <str> & & content . charAt ( <int> ) = = <str> ) { return XContentType . YAML ; } for ( int i = <int> ; i < length ; i + + ) { char c = content . charAt ( i ) ; if ( c = = <str> ) { return XContentType . JSON ; } if ( Character . isWhitespace ( c ) = = false ) { break ; } } return null ; } public static XContent xContent ( CharSequence content ) { XContentType type = xContentType ( content ) ; if ( type = = null ) { throw new ElasticsearchParseException ( <str> ) ; } return xContent ( type ) ; } public static XContent xContent ( byte [ ] data ) { return xContent ( data , <int> , data . length ) ; } public static XContent xContent ( byte [ ] data , int offset , int length ) { XContentType type = xContentType ( data , offset , length ) ; if ( type = = null ) { throw new ElasticsearchParseException ( <str> ) ; } return xContent ( type ) ; } public static XContentType xContentType ( byte [ ] data ) { return xContentType ( data , <int> , data . length ) ; } public static XContentType xContentType ( InputStream si ) throws IOException { if ( si . markSupported ( ) = = false ) { throw new IllegalArgumentException ( <str> + si . getClass ( ) ) ; } si . mark ( GUESS_HEADER_LENGTH ) ; try { final byte [ ] firstBytes = new byte [ GUESS_HEADER_LENGTH ] ; final int read = Streams . readFully ( si , firstBytes ) ; return xContentType ( new BytesArray ( firstBytes , <int> , read ) ) ; } finally { si . reset ( ) ; } } public static XContentType xContentType ( byte [ ] data , int offset , int length ) { return xContentType ( new BytesArray ( data , offset , length ) ) ; } public static XContent xContent ( BytesReference bytes ) { XContentType type = xContentType ( bytes ) ; if ( type = = null ) { throw new ElasticsearchParseException ( <str> ) ; } return xContent ( type ) ; } public static XContentType xContentType ( BytesReference bytes ) { int length = bytes . length ( ) ; if ( length = = <int> ) { return null ; } byte first = bytes . get ( <int> ) ; if ( first = = <str> ) { return XContentType . JSON ; } if ( length > <int> & & first = = SmileConstants . HEADER_BYTE_1 & & bytes . get ( <int> ) = = SmileConstants . HEADER_BYTE_2 & & bytes . get ( <int> ) = = SmileConstants . HEADER_BYTE_3 ) { return XContentType . SMILE ; } if ( length > <int> & & first = = <str> & & bytes . get ( <int> ) = = <str> & & bytes . get ( <int> ) = = <str> ) { return XContentType . YAML ; } if ( first = = CBORConstants . BYTE_OBJECT_INDEFINITE & & length > <int> ) { return XContentType . CBOR ; } if ( CBORConstants . hasMajorType ( CBORConstants . MAJOR_TYPE_TAG , first ) & & length > <int> ) { if ( first = = ( byte ) <hex> & & bytes . get ( <int> ) = = ( byte ) <hex> & & bytes . get ( <int> ) = = ( byte ) <hex> ) { return XContentType . CBOR ; } } if ( CBORConstants . hasMajorType ( CBORConstants . MAJOR_TYPE_OBJECT , first ) ) { return XContentType . CBOR ; } int jsonStart = <int> ; if ( length > <int> & & first = = ( byte ) <hex> & & bytes . get ( <int> ) = = ( byte ) <hex> & & bytes . get ( <int> ) = = ( byte ) <hex> ) { jsonStart = <int> ; } for ( int i = jsonStart ; i < length ; i + + ) { byte b = bytes . get ( i ) ; if ( b = = <str> ) { return XContentType . JSON ; } if ( Character . isWhitespace ( b ) = = false ) { break ; } } return null ; } } 
