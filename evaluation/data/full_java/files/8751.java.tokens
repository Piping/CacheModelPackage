package org . elasticsearch . discovery . gce ; import com . google . api . services . compute . model . AccessConfig ; import com . google . api . services . compute . model . Instance ; import com . google . api . services . compute . model . NetworkInterface ; import org . elasticsearch . Version ; import org . elasticsearch . cloud . gce . GceComputeService ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . zen . ping . unicast . UnicastHostsProvider ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import static org . elasticsearch . cloud . gce . GceComputeService . Fields ; public class GceUnicastHostsProvider extends AbstractComponent implements UnicastHostsProvider { static final class Status { private static final String TERMINATED = <str> ; } private final GceComputeService gceComputeService ; private TransportService transportService ; private NetworkService networkService ; private final Version version ; private final String project ; private final String [ ] zones ; private final String [ ] tags ; private final TimeValue refreshInterval ; private long lastRefresh ; private List < DiscoveryNode > cachedDiscoNodes ; @Inject public GceUnicastHostsProvider ( Settings settings , GceComputeService gceComputeService , TransportService transportService , NetworkService networkService , Version version ) { super ( settings ) ; this . gceComputeService = gceComputeService ; this . transportService = transportService ; this . networkService = networkService ; this . version = version ; this . refreshInterval = settings . getAsTime ( Fields . REFRESH , TimeValue . timeValueSeconds ( <int> ) ) ; this . project = settings . get ( Fields . PROJECT ) ; this . zones = settings . getAsArray ( Fields . ZONE ) ; this . tags = settings . getAsArray ( Fields . TAGS ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , Arrays . asList ( this . tags ) ) ; } } @Override public List < DiscoveryNode > buildDynamicNodes ( ) { if ( refreshInterval . millis ( ) ! = <int> ) { if ( cachedDiscoNodes ! = null & & ( refreshInterval . millis ( ) < <int> | | ( System . currentTimeMillis ( ) - lastRefresh ) < refreshInterval . millis ( ) ) ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> ) ; return cachedDiscoNodes ; } lastRefresh = System . currentTimeMillis ( ) ; } logger . debug ( <str> ) ; cachedDiscoNodes = new ArrayList < > ( ) ; String ipAddress = null ; try { InetAddress inetAddress = networkService . resolvePublishHostAddresses ( null ) ; if ( inetAddress ! = null ) { ipAddress = NetworkAddress . formatAddress ( inetAddress ) ; } } catch ( IOException e ) { } try { Collection < Instance > instances = gceComputeService . instances ( ) ; if ( instances = = null ) { logger . trace ( <str> , this . project , this . zones ) ; return cachedDiscoNodes ; } for ( Instance instance : instances ) { String name = instance . getName ( ) ; String type = instance . getMachineType ( ) ; String status = instance . getStatus ( ) ; logger . trace ( <str> , name , status ) ; if ( Status . TERMINATED . equals ( status ) ) { logger . debug ( <str> , name ) ; continue ; } boolean filterByTag = false ; if ( tags . length > <int> ) { logger . trace ( <str> , name , tags ) ; if ( instance . getTags ( ) = = null | | instance . getTags ( ) . isEmpty ( ) | | instance . getTags ( ) . getItems ( ) = = null | | instance . getTags ( ) . getItems ( ) . isEmpty ( ) ) { logger . trace ( <str> , name ) ; filterByTag = true ; } else { logger . trace ( <str> , instance . getTags ( ) . getItems ( ) , tags ) ; for ( String tag : tags ) { boolean found = false ; for ( String instancetag : instance . getTags ( ) . getItems ( ) ) { if ( instancetag . equals ( tag ) ) { found = true ; break ; } } if ( ! found ) { filterByTag = true ; break ; } } } } if ( filterByTag ) { logger . trace ( <str> , name , tags , instance . getTags ( ) = = null | | instance . getTags ( ) . getItems ( ) = = null ? <str> : instance . getTags ( ) ) ; continue ; } else { logger . trace ( <str> , name , tags ) ; } String ip_public = null ; String ip_private = null ; List < NetworkInterface > interfaces = instance . getNetworkInterfaces ( ) ; for ( NetworkInterface networkInterface : interfaces ) { if ( ip_public = = null ) { if ( networkInterface . getAccessConfigs ( ) ! = null ) { for ( AccessConfig accessConfig : networkInterface . getAccessConfigs ( ) ) { if ( Strings . hasText ( accessConfig . getNatIP ( ) ) ) { ip_public = accessConfig . getNatIP ( ) ; break ; } } } } if ( ip_private = = null ) { ip_private = networkInterface . getNetworkIP ( ) ; } if ( ip_private ! = null & & ip_public ! = null ) break ; } try { if ( ip_private . equals ( ipAddress ) ) { logger . trace ( <str> , name , ip_private ) ; } else { String address = ip_private ; if ( instance . getMetadata ( ) ! = null & & instance . getMetadata ( ) . containsKey ( <str> ) ) { Object es_port = instance . getMetadata ( ) . get ( <str> ) ; logger . trace ( <str> , es_port ) ; if ( es_port instanceof String ) { address = address . concat ( <str> ) . concat ( ( String ) es_port ) ; } else { logger . trace ( <str> , es_port . getClass ( ) . getName ( ) ) ; } } TransportAddress [ ] addresses = transportService . addressesFromString ( address , <int> ) ; for ( TransportAddress transportAddress : addresses ) { logger . trace ( <str> , name , type , ip_private , transportAddress , status ) ; cachedDiscoNodes . add ( new DiscoveryNode ( <str> + name + <str> + <int> , transportAddress , version . minimumCompatibilityVersion ( ) ) ) ; } } } catch ( Exception e ) { logger . warn ( <str> , e , name , ip_private ) ; } } } catch ( Throwable e ) { logger . warn ( <str> , e , e . getMessage ( ) ) ; } logger . debug ( <str> , cachedDiscoNodes . size ( ) ) ; logger . debug ( <str> , cachedDiscoNodes ) ; return cachedDiscoNodes ; } } 
