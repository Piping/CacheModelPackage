package org . apache . cassandra . locator ; import java . io . IOException ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import java . util . stream . Collectors ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Multimap ; import org . junit . Assert ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . dht . OrderPreservingPartitioner . StringToken ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . locator . TokenMetadata . Topology ; import org . apache . cassandra . service . StorageService ; public class NetworkTopologyStrategyTest { private String keyspaceName = <str> ; private static final Logger logger = LoggerFactory . getLogger ( NetworkTopologyStrategyTest . class ) ; @Test public void testProperties ( ) throws IOException , ConfigurationException { IEndpointSnitch snitch = new PropertyFileSnitch ( ) ; DatabaseDescriptor . setEndpointSnitch ( snitch ) ; TokenMetadata metadata = new TokenMetadata ( ) ; createDummyTokens ( metadata , true ) ; Map < String , String > configOptions = new HashMap < String , String > ( ) ; configOptions . put ( <str> , <str> ) ; configOptions . put ( <str> , <str> ) ; configOptions . put ( <str> , <str> ) ; NetworkTopologyStrategy strategy = new NetworkTopologyStrategy ( keyspaceName , metadata , snitch , configOptions ) ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; ArrayList < InetAddress > endpoints = strategy . getNaturalEndpoints ( new StringToken ( <str> ) ) ; assert <int> = = endpoints . size ( ) ; assert <int> = = new HashSet < InetAddress > ( endpoints ) . size ( ) ; } @Test public void testPropertiesWithEmptyDC ( ) throws IOException , ConfigurationException { IEndpointSnitch snitch = new PropertyFileSnitch ( ) ; DatabaseDescriptor . setEndpointSnitch ( snitch ) ; TokenMetadata metadata = new TokenMetadata ( ) ; createDummyTokens ( metadata , false ) ; Map < String , String > configOptions = new HashMap < String , String > ( ) ; configOptions . put ( <str> , <str> ) ; configOptions . put ( <str> , <str> ) ; configOptions . put ( <str> , <str> ) ; NetworkTopologyStrategy strategy = new NetworkTopologyStrategy ( keyspaceName , metadata , snitch , configOptions ) ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; assert strategy . getReplicationFactor ( <str> ) = = <int> ; ArrayList < InetAddress > endpoints = strategy . getNaturalEndpoints ( new StringToken ( <str> ) ) ; assert <int> = = endpoints . size ( ) ; assert <int> = = new HashSet < InetAddress > ( endpoints ) . size ( ) ; } @Test public void testLargeCluster ( ) throws UnknownHostException , ConfigurationException { int [ ] dcRacks = new int [ ] { <int> , <int> , <int> } ; int [ ] dcEndpoints = new int [ ] { <int> , <int> , <int> } ; int [ ] dcReplication = new int [ ] { <int> , <int> , <int> } ; IEndpointSnitch snitch = new RackInferringSnitch ( ) ; DatabaseDescriptor . setEndpointSnitch ( snitch ) ; TokenMetadata metadata = new TokenMetadata ( ) ; Map < String , String > configOptions = new HashMap < String , String > ( ) ; Multimap < InetAddress , Token > tokens = HashMultimap . create ( ) ; int totalRF = <int> ; for ( int dc = <int> ; dc < dcRacks . length ; + + dc ) { totalRF + = dcReplication [ dc ] ; configOptions . put ( Integer . toString ( dc ) , Integer . toString ( dcReplication [ dc ] ) ) ; for ( int rack = <int> ; rack < dcRacks [ dc ] ; + + rack ) { for ( int ep = <int> ; ep < = dcEndpoints [ dc ] / dcRacks [ dc ] ; + + ep ) { byte [ ] ipBytes = new byte [ ] { <int> , ( byte ) dc , ( byte ) rack , ( byte ) ep } ; InetAddress address = InetAddress . getByAddress ( ipBytes ) ; StringToken token = new StringToken ( String . format ( <str> , ep , rack , dc ) ) ; logger . debug ( <str> , address , token ) ; tokens . put ( address , token ) ; } } } metadata . updateNormalTokens ( tokens ) ; NetworkTopologyStrategy strategy = new NetworkTopologyStrategy ( keyspaceName , metadata , snitch , configOptions ) ; for ( String testToken : new String [ ] { <str> , <str> , <str> , <str> , <str> } ) { List < InetAddress > endpoints = strategy . calculateNaturalEndpoints ( new StringToken ( testToken ) , metadata ) ; Set < InetAddress > epSet = new HashSet < InetAddress > ( endpoints ) ; Assert . assertEquals ( totalRF , endpoints . size ( ) ) ; Assert . assertEquals ( totalRF , epSet . size ( ) ) ; logger . debug ( <str> , testToken , endpoints ) ; } } public void createDummyTokens ( TokenMetadata metadata , boolean populateDC3 ) throws UnknownHostException { tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; if ( populateDC3 ) { tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; } tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; if ( populateDC3 ) tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; tokenFactory ( metadata , <str> , new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void tokenFactory ( TokenMetadata metadata , String token , byte [ ] bytes ) throws UnknownHostException { Token token1 = new StringToken ( token ) ; InetAddress add1 = InetAddress . getByAddress ( bytes ) ; metadata . updateNormalToken ( token1 , add1 ) ; } @Test public void testCalculateEndpoints ( ) throws UnknownHostException { final int NODES = <int> ; final int VNODES = <int> ; final int RUNS = <int> ; StorageService . instance . setPartitionerUnsafe ( Murmur3Partitioner . instance ) ; Map < String , Integer > datacenters = ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; List < InetAddress > nodes = new ArrayList < > ( NODES ) ; for ( byte i = <int> ; i < NODES ; + + i ) nodes . add ( InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , i } ) ) ; for ( int run = <int> ; run < RUNS ; + + run ) { Random rand = new Random ( ) ; IEndpointSnitch snitch = generateSnitch ( datacenters , nodes , rand ) ; DatabaseDescriptor . setEndpointSnitch ( snitch ) ; TokenMetadata meta = new TokenMetadata ( ) ; for ( int i = <int> ; i < NODES ; + + i ) for ( int j = <int> ; j < VNODES ; + + j ) meta . updateNormalToken ( Murmur3Partitioner . instance . getRandomToken ( rand ) , nodes . get ( i ) ) ; testEquivalence ( meta , snitch , datacenters , rand ) ; } } void testEquivalence ( TokenMetadata tokenMetadata , IEndpointSnitch snitch , Map < String , Integer > datacenters , Random rand ) { NetworkTopologyStrategy nts = new NetworkTopologyStrategy ( <str> , tokenMetadata , snitch , datacenters . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( x - > x . getKey ( ) , x - > Integer . toString ( x . getValue ( ) ) ) ) ) ; for ( int i = <int> ; i < <int> ; + + i ) { Token token = Murmur3Partitioner . instance . getRandomToken ( rand ) ; List < InetAddress > expected = calculateNaturalEndpoints ( token , tokenMetadata , datacenters , snitch ) ; List < InetAddress > actual = nts . calculateNaturalEndpoints ( token , tokenMetadata ) ; if ( endpointsDiffer ( expected , actual ) ) { System . err . println ( <str> + token ) ; System . err . println ( <str> + expected ) ; System . err . println ( <str> + actual ) ; Assert . assertEquals ( <str> + token + <str> , expected , actual ) ; } } } private boolean endpointsDiffer ( List < InetAddress > ep1 , List < InetAddress > ep2 ) { if ( ep1 . equals ( ep2 ) ) return false ; if ( ! ep1 . get ( <int> ) . equals ( ep2 . get ( <int> ) ) ) return true ; Set < InetAddress > s1 = new HashSet < > ( ep1 ) ; Set < InetAddress > s2 = new HashSet < > ( ep2 ) ; return ! s1 . equals ( s2 ) ; } IEndpointSnitch generateSnitch ( Map < String , Integer > datacenters , Collection < InetAddress > nodes , Random rand ) { final Map < InetAddress , String > nodeToRack = new HashMap < > ( ) ; final Map < InetAddress , String > nodeToDC = new HashMap < > ( ) ; Map < String , List < String > > racksPerDC = new HashMap < > ( ) ; datacenters . forEach ( ( dc , rf ) - > racksPerDC . put ( dc , randomRacks ( rf , rand ) ) ) ; int rf = datacenters . values ( ) . stream ( ) . mapToInt ( x - > x ) . sum ( ) ; String [ ] dcs = new String [ rf ] ; int pos = <int> ; for ( Map . Entry < String , Integer > dce : datacenters . entrySet ( ) ) { for ( int i = <int> ; i < dce . getValue ( ) ; + + i ) dcs [ pos + + ] = dce . getKey ( ) ; } for ( InetAddress node : nodes ) { String dc = dcs [ rand . nextInt ( rf ) ] ; List < String > racks = racksPerDC . get ( dc ) ; String rack = racks . get ( rand . nextInt ( racks . size ( ) ) ) ; nodeToRack . put ( node , rack ) ; nodeToDC . put ( node , dc ) ; } return new AbstractNetworkTopologySnitch ( ) { public String getRack ( InetAddress endpoint ) { return nodeToRack . get ( endpoint ) ; } public String getDatacenter ( InetAddress endpoint ) { return nodeToDC . get ( endpoint ) ; } } ; } private List < String > randomRacks ( int rf , Random rand ) { int rc = rand . nextInt ( rf * <int> - <int> ) + <int> ; List < String > racks = new ArrayList < > ( rc ) ; for ( int i = <int> ; i < rc ; + + i ) racks . add ( Integer . toString ( i ) ) ; return racks ; } public static List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata , Map < String , Integer > datacenters , IEndpointSnitch snitch ) { Set < InetAddress > replicas = new LinkedHashSet < > ( ) ; Map < String , Set < InetAddress > > dcReplicas = new HashMap < > ( datacenters . size ( ) ) ; for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) dcReplicas . put ( dc . getKey ( ) , new HashSet < InetAddress > ( dc . getValue ( ) ) ) ; Topology topology = tokenMetadata . getTopology ( ) ; Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; assert ! allEndpoints . isEmpty ( ) & & ! racks . isEmpty ( ) : <str> ; Map < String , Set < String > > seenRacks = new HashMap < > ( datacenters . size ( ) ) ; for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) seenRacks . put ( dc . getKey ( ) , new HashSet < String > ( ) ) ; Map < String , Set < InetAddress > > skippedDcEndpoints = new HashMap < > ( datacenters . size ( ) ) ; for ( Map . Entry < String , Integer > dc : datacenters . entrySet ( ) ) skippedDcEndpoints . put ( dc . getKey ( ) , new LinkedHashSet < InetAddress > ( ) ) ; Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken , false ) ; while ( tokenIter . hasNext ( ) & & ! hasSufficientReplicas ( dcReplicas , allEndpoints , datacenters ) ) { Token next = tokenIter . next ( ) ; InetAddress ep = tokenMetadata . getEndpoint ( next ) ; String dc = snitch . getDatacenter ( ep ) ; if ( ! datacenters . containsKey ( dc ) | | hasSufficientReplicas ( dc , dcReplicas , allEndpoints , datacenters ) ) continue ; if ( seenRacks . get ( dc ) . size ( ) = = racks . get ( dc ) . keySet ( ) . size ( ) ) { dcReplicas . get ( dc ) . add ( ep ) ; replicas . add ( ep ) ; } else { String rack = snitch . getRack ( ep ) ; if ( seenRacks . get ( dc ) . contains ( rack ) ) { skippedDcEndpoints . get ( dc ) . add ( ep ) ; } else { dcReplicas . get ( dc ) . add ( ep ) ; replicas . add ( ep ) ; seenRacks . get ( dc ) . add ( rack ) ; if ( seenRacks . get ( dc ) . size ( ) = = racks . get ( dc ) . keySet ( ) . size ( ) ) { Iterator < InetAddress > skippedIt = skippedDcEndpoints . get ( dc ) . iterator ( ) ; while ( skippedIt . hasNext ( ) & & ! hasSufficientReplicas ( dc , dcReplicas , allEndpoints , datacenters ) ) { InetAddress nextSkipped = skippedIt . next ( ) ; dcReplicas . get ( dc ) . add ( nextSkipped ) ; replicas . add ( nextSkipped ) ; } } } } } return new ArrayList < InetAddress > ( replicas ) ; } private static boolean hasSufficientReplicas ( String dc , Map < String , Set < InetAddress > > dcReplicas , Multimap < String , InetAddress > allEndpoints , Map < String , Integer > datacenters ) { return dcReplicas . get ( dc ) . size ( ) > = Math . min ( allEndpoints . get ( dc ) . size ( ) , getReplicationFactor ( dc , datacenters ) ) ; } private static boolean hasSufficientReplicas ( Map < String , Set < InetAddress > > dcReplicas , Multimap < String , InetAddress > allEndpoints , Map < String , Integer > datacenters ) { for ( String dc : datacenters . keySet ( ) ) if ( ! hasSufficientReplicas ( dc , dcReplicas , allEndpoints , datacenters ) ) return false ; return true ; } public static int getReplicationFactor ( String dc , Map < String , Integer > datacenters ) { Integer replicas = datacenters . get ( dc ) ; return replicas = = null ? <int> : replicas ; } } 
