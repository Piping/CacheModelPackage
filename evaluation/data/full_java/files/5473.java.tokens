package org . elasticsearch . action . update ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . DocumentMissingException ; import org . elasticsearch . index . engine . DocumentSourceMissingException ; import org . elasticsearch . index . get . GetField ; import org . elasticsearch . index . get . GetResult ; import org . elasticsearch . index . mapper . internal . ParentFieldMapper ; import org . elasticsearch . index . mapper . internal . RoutingFieldMapper ; import org . elasticsearch . index . mapper . internal . TTLFieldMapper ; import org . elasticsearch . index . mapper . internal . TimestampFieldMapper ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptContext ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import org . elasticsearch . search . lookup . SourceLookup ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Map ; public class UpdateHelper extends AbstractComponent { private final ScriptService scriptService ; @Inject public UpdateHelper ( Settings settings , ScriptService scriptService ) { super ( settings ) ; this . scriptService = scriptService ; } @SuppressWarnings ( <str> ) public Result prepare ( UpdateRequest request , IndexShard indexShard ) { final GetResult getResult = indexShard . getService ( ) . get ( request . type ( ) , request . id ( ) , new String [ ] { RoutingFieldMapper . NAME , ParentFieldMapper . NAME , TTLFieldMapper . NAME , TimestampFieldMapper . NAME } , true , request . version ( ) , request . versionType ( ) , FetchSourceContext . FETCH_SOURCE , false ) ; return prepare ( request , getResult ) ; } @SuppressWarnings ( <str> ) protected Result prepare ( UpdateRequest request , final GetResult getResult ) { long getDateNS = System . nanoTime ( ) ; final ShardId shardId = new ShardId ( getResult . getIndex ( ) , request . shardId ( ) ) ; if ( ! getResult . isExists ( ) ) { if ( request . upsertRequest ( ) = = null & & ! request . docAsUpsert ( ) ) { throw new DocumentMissingException ( shardId , request . type ( ) , request . id ( ) ) ; } IndexRequest indexRequest = request . docAsUpsert ( ) ? request . doc ( ) : request . upsertRequest ( ) ; TimeValue ttl = indexRequest . ttl ( ) ; if ( request . scriptedUpsert ( ) & & request . script ( ) ! = null ) { IndexRequest upsert = request . upsertRequest ( ) ; Map < String , Object > upsertDoc = upsert . sourceAsMap ( ) ; Map < String , Object > ctx = new HashMap < > ( <int> ) ; ctx . put ( <str> , <str> ) ; ctx . put ( <str> , upsertDoc ) ; ctx = executeScript ( request , ctx ) ; if ( ttl = = null ) { ttl = getTTLFromScriptContext ( ctx ) ; } String scriptOpChoice = ( String ) ctx . get ( <str> ) ; if ( ! <str> . equals ( scriptOpChoice ) ) { if ( ! <str> . equals ( scriptOpChoice ) ) { logger . warn ( <str> , scriptOpChoice , request . script . getScript ( ) ) ; } UpdateResponse update = new UpdateResponse ( shardId , getResult . getType ( ) , getResult . getId ( ) , getResult . getVersion ( ) , false ) ; update . setGetResult ( getResult ) ; return new Result ( update , Operation . NONE , upsertDoc , XContentType . JSON ) ; } indexRequest . source ( ( Map ) ctx . get ( <str> ) ) ; } indexRequest . index ( request . index ( ) ) . type ( request . type ( ) ) . id ( request . id ( ) ) . create ( true ) . ttl ( ttl ) . refresh ( request . refresh ( ) ) . routing ( request . routing ( ) ) . parent ( request . parent ( ) ) . consistencyLevel ( request . consistencyLevel ( ) ) ; if ( request . versionType ( ) ! = VersionType . INTERNAL ) { indexRequest . version ( request . version ( ) ) . versionType ( request . versionType ( ) ) ; } return new Result ( indexRequest , Operation . UPSERT , null , null ) ; } long updateVersion = getResult . getVersion ( ) ; if ( request . versionType ( ) ! = VersionType . INTERNAL ) { assert request . versionType ( ) = = VersionType . FORCE ; updateVersion = request . version ( ) ; } if ( getResult . internalSourceRef ( ) = = null ) { throw new DocumentSourceMissingException ( shardId , request . type ( ) , request . id ( ) ) ; } Tuple < XContentType , Map < String , Object > > sourceAndContent = XContentHelper . convertToMap ( getResult . internalSourceRef ( ) , true ) ; String operation = null ; String timestamp = null ; TimeValue ttl = null ; final Map < String , Object > updatedSourceAsMap ; final XContentType updateSourceContentType = sourceAndContent . v1 ( ) ; String routing = getResult . getFields ( ) . containsKey ( RoutingFieldMapper . NAME ) ? getResult . field ( RoutingFieldMapper . NAME ) . getValue ( ) . toString ( ) : null ; String parent = getResult . getFields ( ) . containsKey ( ParentFieldMapper . NAME ) ? getResult . field ( ParentFieldMapper . NAME ) . getValue ( ) . toString ( ) : null ; if ( request . script ( ) = = null & & request . doc ( ) ! = null ) { IndexRequest indexRequest = request . doc ( ) ; updatedSourceAsMap = sourceAndContent . v2 ( ) ; if ( indexRequest . ttl ( ) ! = null ) { ttl = indexRequest . ttl ( ) ; } timestamp = indexRequest . timestamp ( ) ; if ( indexRequest . routing ( ) ! = null ) { routing = indexRequest . routing ( ) ; } if ( indexRequest . parent ( ) ! = null ) { parent = indexRequest . parent ( ) ; } boolean noop = ! XContentHelper . update ( updatedSourceAsMap , indexRequest . sourceAsMap ( ) , request . detectNoop ( ) ) ; if ( request . detectNoop ( ) & & noop ) { operation = <str> ; } } else { Map < String , Object > ctx = new HashMap < > ( <int> ) ; Long originalTtl = getResult . getFields ( ) . containsKey ( TTLFieldMapper . NAME ) ? ( Long ) getResult . field ( TTLFieldMapper . NAME ) . getValue ( ) : null ; Long originalTimestamp = getResult . getFields ( ) . containsKey ( TimestampFieldMapper . NAME ) ? ( Long ) getResult . field ( TimestampFieldMapper . NAME ) . getValue ( ) : null ; ctx . put ( <str> , getResult . getIndex ( ) ) ; ctx . put ( <str> , getResult . getType ( ) ) ; ctx . put ( <str> , getResult . getId ( ) ) ; ctx . put ( <str> , getResult . getVersion ( ) ) ; ctx . put ( <str> , routing ) ; ctx . put ( <str> , parent ) ; ctx . put ( <str> , originalTimestamp ) ; ctx . put ( <str> , originalTtl ) ; ctx . put ( <str> , sourceAndContent . v2 ( ) ) ; ctx = executeScript ( request , ctx ) ; operation = ( String ) ctx . get ( <str> ) ; Object fetchedTimestamp = ctx . get ( <str> ) ; if ( fetchedTimestamp ! = null ) { timestamp = fetchedTimestamp . toString ( ) ; } else if ( originalTimestamp ! = null ) { timestamp = originalTimestamp . toString ( ) ; } ttl = getTTLFromScriptContext ( ctx ) ; updatedSourceAsMap = ( Map < String , Object > ) ctx . get ( <str> ) ; } if ( ttl = = null ) { Long ttlAsLong = getResult . getFields ( ) . containsKey ( TTLFieldMapper . NAME ) ? ( Long ) getResult . field ( TTLFieldMapper . NAME ) . getValue ( ) : null ; if ( ttlAsLong ! = null ) { ttl = new TimeValue ( ttlAsLong - TimeValue . nsecToMSec ( System . nanoTime ( ) - getDateNS ) ) ; } } if ( operation = = null | | <str> . equals ( operation ) ) { final IndexRequest indexRequest = Requests . indexRequest ( request . index ( ) ) . type ( request . type ( ) ) . id ( request . id ( ) ) . routing ( routing ) . parent ( parent ) . source ( updatedSourceAsMap , updateSourceContentType ) . version ( updateVersion ) . versionType ( request . versionType ( ) ) . consistencyLevel ( request . consistencyLevel ( ) ) . timestamp ( timestamp ) . ttl ( ttl ) . refresh ( request . refresh ( ) ) ; return new Result ( indexRequest , Operation . INDEX , updatedSourceAsMap , updateSourceContentType ) ; } else if ( <str> . equals ( operation ) ) { DeleteRequest deleteRequest = Requests . deleteRequest ( request . index ( ) ) . type ( request . type ( ) ) . id ( request . id ( ) ) . routing ( routing ) . parent ( parent ) . version ( updateVersion ) . versionType ( request . versionType ( ) ) . consistencyLevel ( request . consistencyLevel ( ) ) ; return new Result ( deleteRequest , Operation . DELETE , updatedSourceAsMap , updateSourceContentType ) ; } else if ( <str> . equals ( operation ) ) { UpdateResponse update = new UpdateResponse ( shardId , getResult . getType ( ) , getResult . getId ( ) , getResult . getVersion ( ) , false ) ; update . setGetResult ( extractGetResult ( request , request . index ( ) , getResult . getVersion ( ) , updatedSourceAsMap , updateSourceContentType , getResult . internalSourceRef ( ) ) ) ; return new Result ( update , Operation . NONE , updatedSourceAsMap , updateSourceContentType ) ; } else { logger . warn ( <str> , operation , request . script . getScript ( ) ) ; UpdateResponse update = new UpdateResponse ( shardId , getResult . getType ( ) , getResult . getId ( ) , getResult . getVersion ( ) , false ) ; return new Result ( update , Operation . NONE , updatedSourceAsMap , updateSourceContentType ) ; } } private Map < String , Object > executeScript ( UpdateRequest request , Map < String , Object > ctx ) { try { if ( scriptService ! = null ) { ExecutableScript script = scriptService . executable ( request . script , ScriptContext . Standard . UPDATE , request ) ; script . setNextVar ( <str> , ctx ) ; script . run ( ) ; ctx = ( Map < String , Object > ) script . unwrap ( ctx ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( <str> , e ) ; } return ctx ; } private TimeValue getTTLFromScriptContext ( Map < String , Object > ctx ) { Object fetchedTTL = ctx . get ( <str> ) ; if ( fetchedTTL ! = null ) { if ( fetchedTTL instanceof Number ) { return new TimeValue ( ( ( Number ) fetchedTTL ) . longValue ( ) ) ; } return TimeValue . parseTimeValue ( ( String ) fetchedTTL , null , <str> ) ; } return null ; } public GetResult extractGetResult ( final UpdateRequest request , String concreteIndex , long version , final Map < String , Object > source , XContentType sourceContentType , @Nullable final BytesReference sourceAsBytes ) { if ( request . fields ( ) = = null | | request . fields ( ) . length = = <int> ) { return null ; } boolean sourceRequested = false ; Map < String , GetField > fields = null ; if ( request . fields ( ) ! = null & & request . fields ( ) . length > <int> ) { SourceLookup sourceLookup = new SourceLookup ( ) ; sourceLookup . setSource ( source ) ; for ( String field : request . fields ( ) ) { if ( field . equals ( <str> ) ) { sourceRequested = true ; continue ; } Object value = sourceLookup . extractValue ( field ) ; if ( value ! = null ) { if ( fields = = null ) { fields = new HashMap < > ( <int> ) ; } GetField getField = fields . get ( field ) ; if ( getField = = null ) { getField = new GetField ( field , new ArrayList < > ( <int> ) ) ; fields . put ( field , getField ) ; } getField . getValues ( ) . add ( value ) ; } } } return new GetResult ( concreteIndex , request . type ( ) , request . id ( ) , version , true , sourceRequested ? sourceAsBytes : null , fields ) ; } public static class Result { private final Streamable action ; private final Operation operation ; private final Map < String , Object > updatedSourceAsMap ; private final XContentType updateSourceContentType ; public Result ( Streamable action , Operation operation , Map < String , Object > updatedSourceAsMap , XContentType updateSourceContentType ) { this . action = action ; this . operation = operation ; this . updatedSourceAsMap = updatedSourceAsMap ; this . updateSourceContentType = updateSourceContentType ; } @SuppressWarnings ( <str> ) public < T extends Streamable > T action ( ) { return ( T ) action ; } public Operation operation ( ) { return operation ; } public Map < String , Object > updatedSourceAsMap ( ) { return updatedSourceAsMap ; } public XContentType updateSourceContentType ( ) { return updateSourceContentType ; } } public enum Operation { UPSERT , INDEX , DELETE , NONE } } 
