package org . eclipse . debug . ui ; import java . util . Set ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . operations . IOperationHistory ; import org . eclipse . core . commands . operations . IUndoContext ; import org . eclipse . core . commands . operations . IUndoableOperation ; import org . eclipse . core . commands . operations . ObjectUndoContext ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchDelegate ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . ISourceLocator ; import org . eclipse . debug . internal . core . IConfigurationElementConstants ; import org . eclipse . debug . internal . ui . DebugPluginImages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . DefaultLabelProvider ; import org . eclipse . debug . internal . ui . DelegatingModelPresentation ; import org . eclipse . debug . internal . ui . LazyModelPresentation ; import org . eclipse . debug . internal . ui . actions . ActionMessages ; import org . eclipse . debug . internal . ui . actions . ToggleBreakpointsTargetManager ; import org . eclipse . debug . internal . ui . contexts . DebugContextManager ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationManager ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationPropertiesDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationsDialog ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchGroupExtension ; import org . eclipse . debug . internal . ui . memory . MemoryRenderingManager ; import org . eclipse . debug . internal . ui . sourcelookup . SourceLookupFacility ; import org . eclipse . debug . internal . ui . sourcelookup . SourceLookupUIUtils ; import org . eclipse . debug . internal . ui . stringsubstitution . SelectedResourceManager ; import org . eclipse . debug . ui . actions . IToggleBreakpointsTargetManager ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . debug . ui . contexts . IDebugContextManager ; import org . eclipse . debug . ui . contexts . IDebugContextService ; import org . eclipse . debug . ui . memory . IMemoryRenderingManager ; import org . eclipse . debug . ui . sourcelookup . ISourceContainerBrowser ; import org . eclipse . debug . ui . sourcelookup . ISourceLookupResult ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . window . Window ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IViewSite ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartSite ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . console . IConsole ; import org . eclipse . ui . handlers . HandlerUtil ; import org . eclipse . ui . ide . undo . DeleteMarkersOperation ; import org . eclipse . ui . ide . undo . WorkspaceUndoUtil ; public class DebugUITools { private static ObjectUndoContext fgBreakpointsUndoContext ; public static Image getImage ( String key ) { return DebugPluginImages . getImage ( key ) ; } public static ImageDescriptor getImageDescriptor ( String key ) { return DebugPluginImages . getImageDescriptor ( key ) ; } public static ImageDescriptor getDefaultImageDescriptor ( Object element ) { String imageKey = getDefaultImageKey ( element ) ; if ( imageKey = = null ) { return null ; } return DebugPluginImages . getImageDescriptor ( imageKey ) ; } private static String getDefaultImageKey ( Object element ) { return ( ( DefaultLabelProvider ) DebugUIPlugin . getDefaultLabelProvider ( ) ) . getImageKey ( element ) ; } public static IPreferenceStore getPreferenceStore ( ) { return DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) ; } public static IDebugModelPresentation newDebugModelPresentation ( ) { return new DelegatingModelPresentation ( ) ; } public static IDebugModelPresentation newDebugModelPresentation ( String identifier ) { IExtensionPoint point = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugUIPlugin . getUniqueIdentifier ( ) , IDebugUIConstants . ID_DEBUG_MODEL_PRESENTATION ) ; if ( point ! = null ) { IExtension [ ] extensions = point . getExtensions ( ) ; for ( int i = <int> ; i < extensions . length ; i + + ) { IExtension extension = extensions [ i ] ; IConfigurationElement [ ] configElements = extension . getConfigurationElements ( ) ; for ( int j = <int> ; j < configElements . length ; j + + ) { IConfigurationElement elt = configElements [ j ] ; String id = elt . getAttribute ( <str> ) ; if ( id ! = null & & id . equals ( identifier ) ) { return new LazyModelPresentation ( elt ) ; } } } } return null ; } public static IAdaptable getDebugContext ( ) { IWorkbenchWindow activeWindow = SelectedResourceManager . getDefault ( ) . getActiveWindow ( ) ; if ( activeWindow ! = null ) { ISelection activeContext = DebugUITools . getDebugContextManager ( ) . getContextService ( activeWindow ) . getActiveContext ( ) ; return getDebugContextElementForSelection ( activeContext ) ; } return null ; } public static ISelection getDebugContextForPart ( IWorkbenchPart part ) { IWorkbenchPartSite site = part . getSite ( ) ; IWorkbenchWindow partWindow = site . getWorkbenchWindow ( ) ; if ( partWindow ! = null ) { IDebugContextService contextService = DebugUITools . getDebugContextManager ( ) . getContextService ( partWindow ) ; if ( site instanceof IViewSite ) { return contextService . getActiveContext ( site . getId ( ) , ( ( IViewSite ) site ) . getSecondaryId ( ) ) ; } else { return contextService . getActiveContext ( site . getId ( ) ) ; } } return null ; } public static synchronized IUndoContext getBreakpointsUndoContext ( ) { if ( fgBreakpointsUndoContext = = null ) { fgBreakpointsUndoContext = new ObjectUndoContext ( new Object ( ) , <str> ) ; fgBreakpointsUndoContext . addMatch ( WorkspaceUndoUtil . getWorkspaceUndoContext ( ) ) ; } return fgBreakpointsUndoContext ; } public static void deleteBreakpoints ( IBreakpoint [ ] breakpoints , final Shell shell , IProgressMonitor progressMonitor ) throws CoreException { IMarker [ ] markers = new IMarker [ breakpoints . length ] ; int markerCount ; for ( markerCount = <int> ; markerCount < breakpoints . length ; markerCount + + ) { if ( ! breakpoints [ markerCount ] . isRegistered ( ) ) { break ; } markers [ markerCount ] = breakpoints [ markerCount ] . getMarker ( ) ; if ( markers [ markerCount ] = = null ) { break ; } } boolean allowUndo = markerCount = = breakpoints . length ; DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . removeBreakpoints ( breakpoints , ! allowUndo ) ; if ( allowUndo ) { for ( int i = <int> ; i < markers . length ; i + + ) { markers [ i ] . setAttribute ( DebugPlugin . ATTR_BREAKPOINT_IS_DELETED , true ) ; } IAdaptable context = null ; if ( shell ! = null ) { context = new IAdaptable ( ) { @SuppressWarnings ( <str> ) @Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter = = Shell . class ) { return ( T ) shell ; } return null ; } } ; } String operationName = markers . length = = <int> ? ActionMessages . DeleteBreakpointOperationName : ActionMessages . DeleteBreakpointsOperationName ; IUndoableOperation deleteMarkerOperation = new DeleteMarkersOperation ( markers , operationName ) ; deleteMarkerOperation . removeContext ( WorkspaceUndoUtil . getWorkspaceUndoContext ( ) ) ; deleteMarkerOperation . addContext ( DebugUITools . getBreakpointsUndoContext ( ) ) ; IOperationHistory operationHistory = PlatformUI . getWorkbench ( ) . getOperationSupport ( ) . getOperationHistory ( ) ; try { operationHistory . execute ( deleteMarkerOperation , progressMonitor , context ) ; } catch ( ExecutionException e ) { throw new CoreException ( DebugUIPlugin . newErrorStatus ( <str> , e ) ) ; } } } public static IAdaptable getPartDebugContext ( IWorkbenchPartSite site ) { IDebugContextService service = DebugUITools . getDebugContextManager ( ) . getContextService ( site . getWorkbenchWindow ( ) ) ; String id = null ; String secondaryId = null ; id = site . getId ( ) ; if ( site instanceof IViewSite ) { secondaryId = ( ( IViewSite ) site ) . getSecondaryId ( ) ; } ISelection activeContext = service . getActiveContext ( id , secondaryId ) ; return getDebugContextElementForSelection ( activeContext ) ; } public static void addPartDebugContextListener ( IWorkbenchPartSite site , IDebugContextListener listener ) { IDebugContextService service = DebugUITools . getDebugContextManager ( ) . getContextService ( site . getWorkbenchWindow ( ) ) ; String id = site . getId ( ) ; String secondaryId = null ; if ( site instanceof IViewSite ) { secondaryId = ( ( IViewSite ) site ) . getSecondaryId ( ) ; } service . addDebugContextListener ( listener , id , secondaryId ) ; } public static void removePartDebugContextListener ( IWorkbenchPartSite site , IDebugContextListener listener ) { IDebugContextService service = DebugUITools . getDebugContextManager ( ) . getContextService ( site . getWorkbenchWindow ( ) ) ; String id = site . getId ( ) ; String secondaryId = null ; if ( site instanceof IViewSite ) { secondaryId = ( ( IViewSite ) site ) . getSecondaryId ( ) ; } service . removeDebugContextListener ( listener , id , secondaryId ) ; } private static IAdaptable getDebugContextElementForSelection ( ISelection activeContext ) { if ( activeContext instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) activeContext ; if ( ! selection . isEmpty ( ) ) { Object firstElement = selection . getFirstElement ( ) ; if ( firstElement instanceof IAdaptable ) { return ( IAdaptable ) firstElement ; } } } return null ; } public static IResource getSelectedResource ( ) { return SelectedResourceManager . getDefault ( ) . getSelectedResource ( ) ; } public static IProcess getCurrentProcess ( ) { IAdaptable context = getDebugContext ( ) ; if ( context = = null ) { ILaunch [ ] launches = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunches ( ) ; if ( launches . length > <int> ) { context = launches [ launches . length - <int> ] ; } } if ( context instanceof IDebugElement ) { return ( ( IDebugElement ) context ) . getDebugTarget ( ) . getProcess ( ) ; } if ( context instanceof IProcess ) { return ( IProcess ) context ; } if ( context instanceof ILaunch ) { ILaunch launch = ( ILaunch ) context ; IDebugTarget target = launch . getDebugTarget ( ) ; if ( target ! = null ) { IProcess process = target . getProcess ( ) ; if ( process ! = null ) { return process ; } } IProcess [ ] ps = launch . getProcesses ( ) ; if ( ps . length > <int> ) { return ps [ ps . length - <int> ] ; } } if ( context ! = null ) { return context . getAdapter ( IProcess . class ) ; } return null ; } @Deprecated public static int openLaunchConfigurationDialog ( Shell shell , IStructuredSelection selection , String mode ) { ILaunchGroup [ ] groups = getLaunchGroups ( ) ; for ( int i = <int> ; i < groups . length ; i + + ) { ILaunchGroup group = groups [ i ] ; if ( group . getMode ( ) . equals ( mode ) & & group . getCategory ( ) = = null ) { return openLaunchConfigurationDialogOnGroup ( shell , selection , group . getIdentifier ( ) ) ; } } return Window . CANCEL ; } public static int openLaunchConfigurationDialogOnGroup ( Shell shell , IStructuredSelection selection , String groupIdentifier ) { return openLaunchConfigurationDialogOnGroup ( shell , selection , groupIdentifier , null ) ; } public static int openLaunchConfigurationDialogOnGroup ( final Shell shell , final IStructuredSelection selection , final String groupIdentifier , final IStatus status ) { final int [ ] result = new int [ <int> ] ; Runnable r = new Runnable ( ) { @Override public void run ( ) { LaunchConfigurationsDialog dialog = ( LaunchConfigurationsDialog ) LaunchConfigurationsDialog . getCurrentlyVisibleLaunchConfigurationDialog ( ) ; if ( dialog ! = null ) { dialog . setInitialSelection ( selection ) ; dialog . doInitialTreeSelection ( ) ; if ( status ! = null ) { dialog . handleStatus ( status ) ; } result [ <int> ] = Window . OK ; } else { LaunchGroupExtension ext = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( ext ! = null ) { dialog = new LaunchConfigurationsDialog ( shell , ext ) ; dialog . setOpenMode ( LaunchConfigurationsDialog . LAUNCH_CONFIGURATION_DIALOG_OPEN_ON_SELECTION ) ; dialog . setInitialSelection ( selection ) ; dialog . setInitialStatus ( status ) ; result [ <int> ] = dialog . open ( ) ; } else { result [ <int> ] = Window . CANCEL ; } } } } ; BusyIndicator . showWhile ( DebugUIPlugin . getStandardDisplay ( ) , r ) ; return result [ <int> ] ; } public static int openLaunchConfigurationPropertiesDialog ( Shell shell , ILaunchConfiguration configuration , String groupIdentifier ) { return openLaunchConfigurationPropertiesDialog ( shell , configuration , groupIdentifier , null ) ; } public static int openLaunchConfigurationPropertiesDialog ( Shell shell , ILaunchConfiguration configuration , String groupIdentifier , IStatus status ) { LaunchGroupExtension group = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( group ! = null ) { LaunchConfigurationPropertiesDialog dialog = new LaunchConfigurationPropertiesDialog ( shell , configuration , group ) ; dialog . setInitialStatus ( status ) ; return dialog . open ( ) ; } return Window . CANCEL ; } public static int openLaunchConfigurationDialog ( Shell shell , ILaunchConfiguration configuration , String groupIdentifier , IStatus status ) { LaunchGroupExtension group = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( groupIdentifier ) ; if ( group ! = null ) { LaunchConfigurationDialog dialog = new LaunchConfigurationDialog ( shell , configuration , group ) ; dialog . setInitialStatus ( status ) ; return dialog . open ( ) ; } return Window . CANCEL ; } @Deprecated public static boolean saveAndBuildBeforeLaunch ( ) { return DebugUIPlugin . saveAndBuild ( ) ; } @Deprecated public static boolean saveBeforeLaunch ( ) { return DebugUIPlugin . preLaunchSave ( ) ; } public static void launch ( final ILaunchConfiguration configuration , final String mode ) { boolean launchInBackground = true ; try { launchInBackground = configuration . getAttribute ( IDebugUIConstants . ATTR_LAUNCH_IN_BACKGROUND , true ) ; } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } if ( launchInBackground ) { DebugUIPlugin . launchInBackground ( configuration , mode ) ; } else { DebugUIPlugin . launchInForeground ( configuration , mode ) ; } } public static ILaunch buildAndLaunch ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { return DebugUIPlugin . buildAndLaunch ( configuration , mode , monitor ) ; } public static String getLaunchPerspective ( ILaunchConfigurationType type , String mode ) { return DebugUIPlugin . getDefault ( ) . getPerspectiveManager ( ) . getLaunchPerspective ( type , mode ) ; } public static String getLaunchPerspective ( ILaunchConfigurationType type , ILaunchDelegate delegate , Set < String > modes ) { return DebugUIPlugin . getDefault ( ) . getPerspectiveManager ( ) . getLaunchPerspective ( type , modes , delegate ) ; } public static void setLaunchPerspective ( ILaunchConfigurationType type , String mode , String perspective ) { DebugUIPlugin . getDefault ( ) . getPerspectiveManager ( ) . setLaunchPerspective ( type , mode , perspective ) ; } public static void setLaunchPerspective ( ILaunchConfigurationType type , ILaunchDelegate delegate , Set < String > modes , String perspectiveid ) { DebugUIPlugin . getDefault ( ) . getPerspectiveManager ( ) . setLaunchPerspective ( type , modes , delegate , perspectiveid ) ; } public static boolean isPrivate ( ILaunchConfiguration configuration ) { return ! LaunchConfigurationManager . isVisible ( configuration ) ; } public static void setUseStepFilters ( boolean useStepFilters ) { DebugPlugin . setUseStepFilters ( useStepFilters ) ; } public static boolean isUseStepFilters ( ) { return DebugPlugin . isUseStepFilters ( ) ; } public static IConsole getConsole ( IProcess process ) { return DebugUIPlugin . getDefault ( ) . getProcessConsoleManager ( ) . getConsole ( process ) ; } public static IConsole getConsole ( IDebugElement element ) { IProcess process = element . getDebugTarget ( ) . getProcess ( ) ; if ( process ! = null ) { return getConsole ( process ) ; } return null ; } public static ILaunchGroup [ ] getLaunchGroups ( ) { return DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroups ( ) ; } public static ILaunchConfiguration getLastLaunch ( String groupId ) { return DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLastLaunch ( groupId ) ; } public static ILaunchGroup getLaunchGroup ( ILaunchConfiguration configuration , String mode ) { try { return DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchGroup ( configuration . getType ( ) , mode ) ; } catch ( CoreException ce ) { return null ; } } public static ISourceLookupResult lookupSource ( Object artifact , ISourceLocator locator ) { return SourceLookupFacility . getDefault ( ) . lookup ( artifact , locator , false ) ; } public static void displaySource ( ISourceLookupResult result , IWorkbenchPage page ) { SourceLookupFacility . getDefault ( ) . display ( result , page ) ; } public static IMemoryRenderingManager getMemoryRenderingManager ( ) { return MemoryRenderingManager . getDefault ( ) ; } public static Image getSourceContainerImage ( String id ) { return SourceLookupUIUtils . getSourceContainerImage ( id ) ; } public static ISourceContainerBrowser getSourceContainerBrowser ( String id ) { return SourceLookupUIUtils . getSourceContainerBrowser ( id ) ; } public static Color getPreferenceColor ( String id ) { return DebugUIPlugin . getPreferenceColor ( id ) ; } public static IDebugContextManager getDebugContextManager ( ) { return DebugContextManager . getDefault ( ) ; } public static ISelection getDebugContextForEvent ( ExecutionEvent event ) { Object o = HandlerUtil . getVariable ( event , IConfigurationElementConstants . DEBUG_CONTEXT ) ; if ( o instanceof ISelection ) { return ( ISelection ) o ; } return null ; } public static ISelection getDebugContextForEventChecked ( ExecutionEvent event ) throws ExecutionException { Object o = HandlerUtil . getVariableChecked ( event , IConfigurationElementConstants . DEBUG_CONTEXT ) ; if ( ! ( o instanceof ISelection ) ) { throw new ExecutionException ( <str> + IConfigurationElementConstants . DEBUG_CONTEXT + <str> + event . getCommand ( ) . getId ( ) + <str> + ISelection . class . getName ( ) + <str> + o . getClass ( ) . getName ( ) ) ; } return ( ISelection ) o ; } public static IToggleBreakpointsTargetManager getToggleBreakpointsTargetManager ( ) { return ToggleBreakpointsTargetManager . getDefault ( ) ; } } 
