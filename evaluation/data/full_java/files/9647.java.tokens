package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . base . Optional ; import java . util . LinkedList ; import java . util . Iterator ; public abstract class BinaryTreeTraverser < T > extends TreeTraverser < T > { public abstract Optional < T > leftChild ( T root ) ; public abstract Optional < T > rightChild ( T root ) ; @Override public final Iterable < T > children ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return new AbstractIterator < T > ( ) { boolean doneLeft ; boolean doneRight ; @Override protected T computeNext ( ) { if ( ! doneLeft ) { doneLeft = true ; Optional < T > left = leftChild ( root ) ; if ( left . isPresent ( ) ) { return left . get ( ) ; } } if ( ! doneRight ) { doneRight = true ; Optional < T > right = rightChild ( root ) ; if ( right . isPresent ( ) ) { return right . get ( ) ; } } return endOfData ( ) ; } } ; } } ; } public final FluentIterable < T > inOrderTraversal ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public UnmodifiableIterator < T > iterator ( ) { return new InOrderIterator ( root ) ; } } ; } private static final class InOrderNode < T > { final T node ; boolean hasExpandedLeft ; InOrderNode ( T node ) { this . node = checkNotNull ( node ) ; this . hasExpandedLeft = false ; } } private final class InOrderIterator extends AbstractIterator < T > { private final LinkedList < InOrderNode < T > > stack ; InOrderIterator ( T root ) { this . stack = Lists . newLinkedList ( ) ; stack . addLast ( new InOrderNode < T > ( root ) ) ; } @Override protected T computeNext ( ) { while ( ! stack . isEmpty ( ) ) { InOrderNode < T > inOrderNode = stack . getLast ( ) ; if ( inOrderNode . hasExpandedLeft ) { stack . removeLast ( ) ; pushIfPresent ( rightChild ( inOrderNode . node ) ) ; return inOrderNode . node ; } else { inOrderNode . hasExpandedLeft = true ; pushIfPresent ( leftChild ( inOrderNode . node ) ) ; } } return endOfData ( ) ; } private void pushIfPresent ( Optional < T > node ) { if ( node . isPresent ( ) ) { stack . addLast ( new InOrderNode < T > ( node . get ( ) ) ) ; } } } } 
