package org . elasticsearch . cluster . routing ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . collect . Iterators ; import java . util . * ; public class RoutingNode implements Iterable < ShardRouting > { private final String nodeId ; private final DiscoveryNode node ; private final List < ShardRouting > shards ; public RoutingNode ( String nodeId , DiscoveryNode node ) { this ( nodeId , node , new ArrayList < ShardRouting > ( ) ) ; } public RoutingNode ( String nodeId , DiscoveryNode node , List < ShardRouting > shards ) { this . nodeId = nodeId ; this . node = node ; this . shards = shards ; } @Override public Iterator < ShardRouting > iterator ( ) { return Collections . unmodifiableCollection ( shards ) . iterator ( ) ; } Iterator < ShardRouting > mutableIterator ( ) { return shards . iterator ( ) ; } public DiscoveryNode node ( ) { return this . node ; } public String nodeId ( ) { return this . nodeId ; } public int size ( ) { return shards . size ( ) ; } void add ( ShardRouting shard ) { for ( ShardRouting shardRouting : shards ) { if ( shardRouting . isSameShard ( shard ) ) { throw new IllegalStateException ( <str> + shard . shardId ( ) . index ( ) . name ( ) + <str> + shard . shardId ( ) . id ( ) + <str> + nodeId + <str> ) ; } } shards . add ( shard ) ; } public int numberOfShardsWithState ( ShardRoutingState . . . states ) { int count = <int> ; for ( ShardRouting shardEntry : this ) { for ( ShardRoutingState state : states ) { if ( shardEntry . state ( ) = = state ) { count + + ; } } } return count ; } public List < ShardRouting > shardsWithState ( ShardRoutingState . . . states ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( ShardRouting shardEntry : this ) { for ( ShardRoutingState state : states ) { if ( shardEntry . state ( ) = = state ) { shards . add ( shardEntry ) ; } } } return shards ; } public List < ShardRouting > shardsWithState ( String index , ShardRoutingState . . . states ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( ShardRouting shardEntry : this ) { if ( ! shardEntry . index ( ) . equals ( index ) ) { continue ; } for ( ShardRoutingState state : states ) { if ( shardEntry . state ( ) = = state ) { shards . add ( shardEntry ) ; } } } return shards ; } public int numberOfOwningShards ( ) { int count = <int> ; for ( ShardRouting shardEntry : this ) { if ( shardEntry . state ( ) ! = ShardRoutingState . RELOCATING ) { count + + ; } } return count ; } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( nodeId ) . append ( <str> + ( node = = null ? <str> : <str> ) + <str> ) ; for ( ShardRouting entry : shards ) { sb . append ( <str> ) . append ( entry . shortSummary ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; sb . append ( node . getName ( ) ) ; sb . append ( <str> ) ; sb . append ( node . getId ( ) ) ; sb . append ( <str> ) ; sb . append ( node . getHostName ( ) ) ; sb . append ( <str> ) ; sb . append ( node . getHostAddress ( ) ) ; sb . append ( <str> ) ; sb . append ( shards . size ( ) ) ; sb . append ( <str> ) ; return sb . toString ( ) ; } public ShardRouting get ( int i ) { return shards . get ( i ) ; } public Collection < ShardRouting > copyShards ( ) { return new ArrayList < > ( shards ) ; } public boolean isEmpty ( ) { return shards . isEmpty ( ) ; } } 
