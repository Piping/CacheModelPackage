package org . elasticsearch . bwcompat ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . get . GetIndexResponse ; import org . elasticsearch . action . admin . indices . segments . IndexSegments ; import org . elasticsearch . action . admin . indices . segments . IndexShardSegments ; import org . elasticsearch . action . admin . indices . segments . IndicesSegmentResponse ; import org . elasticsearch . action . admin . indices . segments . ShardSegments ; import org . elasticsearch . action . admin . indices . upgrade . UpgradeIT ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . MultiDataPathUpgrader ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . index . engine . EngineConfig ; import org . elasticsearch . index . engine . Segment ; import org . elasticsearch . index . mapper . string . StringFieldMapperPositionIncrementGapTests ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . shard . MergePolicyConfig ; import org . elasticsearch . indices . recovery . RecoverySettings ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . VersionUtils ; import org . elasticsearch . test . hamcrest . ElasticsearchAssertions ; import org . hamcrest . Matchers ; import org . junit . AfterClass ; import org . junit . Before ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . * ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) @LuceneTestCase.SuppressFileSystems ( <str> ) public class OldIndexBackwardsCompatibilityIT extends ESIntegTestCase { List < String > indexes ; List < String > unsupportedIndexes ; static Path singleDataPath ; static Path [ ] multiDataPath ; @Before public void initIndexesList ( ) throws Exception { indexes = loadIndexesList ( <str> ) ; unsupportedIndexes = loadIndexesList ( <str> ) ; } private List < String > loadIndexesList ( String prefix ) throws IOException { List < String > indexes = new ArrayList < > ( ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( getBwcIndicesPath ( ) , prefix + <str> ) ) { for ( Path path : stream ) { indexes . add ( path . getFileName ( ) . toString ( ) ) ; } } Collections . sort ( indexes ) ; return indexes ; } @AfterClass public static void tearDownStatics ( ) { singleDataPath = null ; multiDataPath = null ; } @Override public Settings nodeSettings ( int ord ) { return Settings . builder ( ) . put ( MergePolicyConfig . INDEX_MERGE_ENABLED , false ) . put ( RecoverySettings . INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS , <int> ) . build ( ) ; } void setupCluster ( ) throws Exception { InternalTestCluster . Async < List < String > > replicas = internalCluster ( ) . startNodesAsync ( <int> ) ; Path baseTempDir = createTempDir ( ) ; Settings . Builder nodeSettings = Settings . builder ( ) . put ( <str> , baseTempDir . resolve ( <str> ) . toAbsolutePath ( ) ) . put ( <str> , false ) ; InternalTestCluster . Async < String > singleDataPathNode = internalCluster ( ) . startNodeAsync ( nodeSettings . build ( ) ) ; nodeSettings = Settings . builder ( ) . put ( <str> , baseTempDir . resolve ( <str> ) . toAbsolutePath ( ) + <str> + baseTempDir . resolve ( <str> ) . toAbsolutePath ( ) ) . put ( <str> , false ) ; InternalTestCluster . Async < String > multiDataPathNode = internalCluster ( ) . startNodeAsync ( nodeSettings . build ( ) ) ; Path [ ] nodePaths = internalCluster ( ) . getInstance ( NodeEnvironment . class , singleDataPathNode . get ( ) ) . nodeDataPaths ( ) ; assertEquals ( <int> , nodePaths . length ) ; singleDataPath = nodePaths [ <int> ] . resolve ( NodeEnvironment . INDICES_FOLDER ) ; assertFalse ( Files . exists ( singleDataPath ) ) ; Files . createDirectories ( singleDataPath ) ; logger . info ( <str> + singleDataPath . toString ( ) ) ; nodePaths = internalCluster ( ) . getInstance ( NodeEnvironment . class , multiDataPathNode . get ( ) ) . nodeDataPaths ( ) ; assertEquals ( <int> , nodePaths . length ) ; multiDataPath = new Path [ ] { nodePaths [ <int> ] . resolve ( NodeEnvironment . INDICES_FOLDER ) , nodePaths [ <int> ] . resolve ( NodeEnvironment . INDICES_FOLDER ) } ; assertFalse ( Files . exists ( multiDataPath [ <int> ] ) ) ; assertFalse ( Files . exists ( multiDataPath [ <int> ] ) ) ; Files . createDirectories ( multiDataPath [ <int> ] ) ; Files . createDirectories ( multiDataPath [ <int> ] ) ; logger . info ( <str> + multiDataPath [ <int> ] . toString ( ) + <str> + multiDataPath [ <int> ] . toString ( ) ) ; replicas . get ( ) ; } String loadIndex ( String indexFile ) throws Exception { Path unzipDir = createTempDir ( ) ; Path unzipDataDir = unzipDir . resolve ( <str> ) ; String indexName = indexFile . replace ( <str> , <str> ) . toLowerCase ( Locale . ROOT ) . replace ( <str> , <str> ) ; Path backwardsIndex = getBwcIndicesPath ( ) . resolve ( indexFile ) ; try ( InputStream stream = Files . newInputStream ( backwardsIndex ) ) { TestUtil . unzip ( stream , unzipDir ) ; } assertTrue ( Files . exists ( unzipDataDir ) ) ; Path [ ] list = FileSystemUtils . files ( unzipDataDir ) ; if ( list . length ! = <int> ) { throw new IllegalStateException ( <str> ) ; } Path src = list [ <int> ] . resolve ( <str> + indexName ) ; assertTrue ( <str> + indexFile + <str> + src . toString ( ) , Files . exists ( src ) ) ; if ( randomBoolean ( ) ) { logger . info ( <str> , indexName ) ; copyIndex ( logger , src , indexName , singleDataPath ) ; } else { logger . info ( <str> , indexName ) ; copyIndex ( logger , src , indexName , multiDataPath ) ; } return indexName ; } void importIndex ( String indexName ) throws IOException { final Iterable < NodeEnvironment > instances = internalCluster ( ) . getInstances ( NodeEnvironment . class ) ; for ( NodeEnvironment nodeEnv : instances ) { MultiDataPathUpgrader . upgradeMultiDataPath ( nodeEnv , logger ) ; } client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) ; ensureGreen ( indexName ) ; } public static void copyIndex ( final ESLogger logger , final Path src , final String indexName , final Path . . . dests ) throws IOException { for ( Path dest : dests ) { Path indexDir = dest . resolve ( indexName ) ; assertFalse ( Files . exists ( indexDir ) ) ; Files . createDirectories ( indexDir ) ; } Files . walkFileTree ( src , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { Path relativeDir = src . relativize ( dir ) ; for ( Path dest : dests ) { Path destDir = dest . resolve ( indexName ) . resolve ( relativeDir ) ; Files . createDirectories ( destDir ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . equals ( IndexWriter . WRITE_LOCK_NAME ) ) { logger . trace ( <str> + file . toString ( ) ) ; return FileVisitResult . CONTINUE ; } Path relativeFile = src . relativize ( file ) ; Path destFile = dests [ randomInt ( dests . length - <int> ) ] . resolve ( indexName ) . resolve ( relativeFile ) ; logger . trace ( <str> + relativeFile . toString ( ) + <str> + destFile . toString ( ) ) ; Files . move ( file , destFile ) ; assertFalse ( Files . exists ( file ) ) ; assertTrue ( Files . exists ( destFile ) ) ; return FileVisitResult . CONTINUE ; } } ) ; } void unloadIndex ( String indexName ) throws Exception { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( indexName ) . get ( ) ) ; } public void testAllVersionsTested ( ) throws Exception { SortedSet < String > expectedVersions = new TreeSet < > ( ) ; for ( Version v : VersionUtils . allVersions ( ) ) { if ( v . snapshot ( ) ) continue ; if ( v . onOrBefore ( Version . V_2_0_0_beta1 ) ) continue ; if ( v . equals ( Version . CURRENT ) ) continue ; expectedVersions . add ( <str> + v . toString ( ) + <str> ) ; } for ( String index : indexes ) { if ( expectedVersions . remove ( index ) = = false ) { logger . warn ( <str> + index ) ; } } if ( expectedVersions . isEmpty ( ) = = false ) { StringBuilder msg = new StringBuilder ( <str> ) ; for ( String expected : expectedVersions ) { msg . append ( <str> + expected ) ; } fail ( msg . toString ( ) ) ; } } public void testOldIndexes ( ) throws Exception { setupCluster ( ) ; Collections . shuffle ( indexes , random ( ) ) ; for ( String index : indexes ) { long startTime = System . currentTimeMillis ( ) ; logger . info ( <str> + index ) ; assertOldIndexWorks ( index ) ; logger . info ( <str> + index + <str> + ( ( System . currentTimeMillis ( ) - startTime ) / <float> ) + <str> ) ; } } void assertOldIndexWorks ( String index ) throws Exception { Version version = extractVersion ( index ) ; String indexName = loadIndex ( index ) ; importIndex ( indexName ) ; assertIndexSanity ( indexName , version ) ; assertBasicSearchWorks ( indexName ) ; assertBasicAggregationWorks ( indexName ) ; assertRealtimeGetWorks ( indexName ) ; assertNewReplicasWork ( indexName ) ; assertUpgradeWorks ( indexName , isLatestLuceneVersion ( version ) ) ; assertDeleteByQueryWorked ( indexName , version ) ; assertPositionIncrementGapDefaults ( indexName , version ) ; unloadIndex ( indexName ) ; } Version extractVersion ( String index ) { return Version . fromString ( index . substring ( index . indexOf ( <str> ) + <int> , index . lastIndexOf ( <str> ) ) ) ; } boolean isLatestLuceneVersion ( Version version ) { return version . luceneVersion . major = = Version . CURRENT . luceneVersion . major & & version . luceneVersion . minor = = Version . CURRENT . luceneVersion . minor ; } void assertIndexSanity ( String indexName , Version indexCreated ) { GetIndexResponse getIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareGetIndex ( ) . addIndices ( indexName ) . get ( ) ; assertEquals ( <int> , getIndexResponse . indices ( ) . length ) ; assertEquals ( indexName , getIndexResponse . indices ( ) [ <int> ] ) ; Version actualVersionCreated = Version . indexCreated ( getIndexResponse . getSettings ( ) . get ( indexName ) ) ; assertEquals ( indexCreated , actualVersionCreated ) ; ensureYellow ( indexName ) ; IndicesSegmentResponse segmentsResponse = client ( ) . admin ( ) . indices ( ) . prepareSegments ( indexName ) . get ( ) ; IndexSegments segments = segmentsResponse . getIndices ( ) . get ( indexName ) ; for ( IndexShardSegments indexShardSegments : segments ) { for ( ShardSegments shardSegments : indexShardSegments ) { for ( Segment segment : shardSegments ) { assertEquals ( indexCreated . luceneVersion , segment . version ) ; } } } SearchResponse test = client ( ) . prepareSearch ( indexName ) . get ( ) ; assertThat ( test . getHits ( ) . getTotalHits ( ) , greaterThanOrEqualTo ( <int> ) ) ; } void assertBasicSearchWorks ( String indexName ) { logger . info ( <str> ) ; SearchRequestBuilder searchReq = client ( ) . prepareSearch ( indexName ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; SearchResponse searchRsp = searchReq . get ( ) ; ElasticsearchAssertions . assertNoFailures ( searchRsp ) ; long numDocs = searchRsp . getHits ( ) . getTotalHits ( ) ; logger . info ( <str> + numDocs + <str> ) ; logger . info ( <str> ) ; searchReq . addSort ( <str> , SortOrder . ASC ) ; ElasticsearchAssertions . assertNoFailures ( searchReq . get ( ) ) ; logger . info ( <str> ) ; searchReq = client ( ) . prepareSearch ( indexName ) . setQuery ( QueryBuilders . existsQuery ( <str> ) ) ; searchRsp = searchReq . get ( ) ; ElasticsearchAssertions . assertNoFailures ( searchRsp ) ; assertEquals ( numDocs , searchRsp . getHits ( ) . getTotalHits ( ) ) ; } void assertBasicAggregationWorks ( String indexName ) { SearchResponse searchRsp = client ( ) . prepareSearch ( indexName ) . addAggregation ( AggregationBuilders . histogram ( <str> ) . field ( <str> ) . interval ( <int> ) ) . get ( ) ; ElasticsearchAssertions . assertSearchResponse ( searchRsp ) ; Histogram histo = searchRsp . getAggregations ( ) . get ( <str> ) ; assertNotNull ( histo ) ; long totalCount = <int> ; for ( Histogram . Bucket bucket : histo . getBuckets ( ) ) { totalCount + = bucket . getDocCount ( ) ; } assertEquals ( totalCount , searchRsp . getHits ( ) . getTotalHits ( ) ) ; searchRsp = client ( ) . prepareSearch ( indexName ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) ) . get ( ) ; Terms terms = searchRsp . getAggregations ( ) . get ( <str> ) ; totalCount = <int> ; for ( Terms . Bucket bucket : terms . getBuckets ( ) ) { totalCount + = bucket . getDocCount ( ) ; } assertEquals ( totalCount , searchRsp . getHits ( ) . getTotalHits ( ) ) ; } void assertRealtimeGetWorks ( String indexName ) { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( indexName ) . setSettings ( Settings . builder ( ) . put ( <str> , - <int> ) . build ( ) ) ) ; SearchRequestBuilder searchReq = client ( ) . prepareSearch ( indexName ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; SearchHit hit = searchReq . get ( ) . getHits ( ) . getAt ( <int> ) ; String docId = hit . getId ( ) ; client ( ) . prepareUpdate ( indexName , <str> , docId ) . setDoc ( <str> , <str> ) . get ( ) ; GetResponse getRsp = client ( ) . prepareGet ( indexName , <str> , docId ) . get ( ) ; Map < String , Object > source = getRsp . getSourceAsMap ( ) ; assertThat ( source , Matchers . hasKey ( <str> ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( indexName ) . setSettings ( Settings . builder ( ) . put ( <str> , EngineConfig . DEFAULT_REFRESH_INTERVAL ) . build ( ) ) ) ; } void assertNewReplicasWork ( String indexName ) throws Exception { final int numReplicas = <int> ; final long startTime = System . currentTimeMillis ( ) ; logger . debug ( <str> , numReplicas , indexName ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( indexName ) . setSettings ( Settings . builder ( ) . put ( <str> , numReplicas ) ) . execute ( ) . actionGet ( ) ) ; ensureGreen ( TimeValue . timeValueMinutes ( <int> ) , indexName ) ; logger . debug ( <str> , indexName , TimeValue . timeValueMillis ( System . currentTimeMillis ( ) - startTime ) ) ; logger . debug ( <str> , XContentHelper . toString ( client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( indexName ) . get ( ) ) ) ; } void assertDeleteByQueryWorked ( String indexName , Version version ) throws Exception { if ( version . onOrBefore ( Version . V_1_0_0_Beta2 ) | | version . onOrAfter ( Version . V_2_0_0_beta1 ) ) { return ; } SearchRequestBuilder searchReq = client ( ) . prepareSearch ( indexName ) . setQuery ( QueryBuilders . queryStringQuery ( <str> ) ) ; assertEquals ( <int> , searchReq . get ( ) . getHits ( ) . getTotalHits ( ) ) ; } void assertPositionIncrementGapDefaults ( String indexName , Version version ) throws Exception { if ( version . before ( Version . V_2_0_0_beta1 ) ) { StringFieldMapperPositionIncrementGapTests . assertGapIsZero ( client ( ) , indexName , <str> ) ; } else { StringFieldMapperPositionIncrementGapTests . assertGapIsOneHundred ( client ( ) , indexName , <str> ) ; } } void assertUpgradeWorks ( String indexName , boolean alreadyLatest ) throws Exception { if ( alreadyLatest = = false ) { UpgradeIT . assertNotUpgraded ( client ( ) , indexName ) ; } assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareUpgrade ( indexName ) . get ( ) ) ; UpgradeIT . assertUpgraded ( client ( ) , indexName ) ; } } 
