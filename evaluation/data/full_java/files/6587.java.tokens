package org . elasticsearch . index . percolator ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . metrics . MeanMetric ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . indexing . IndexingOperationListener ; import org . elasticsearch . index . indexing . ShardIndexingService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentTypeListener ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . shard . AbstractIndexShardComponent ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . percolator . PercolatorService ; import java . io . Closeable ; import java . io . IOException ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public final class PercolatorQueriesRegistry extends AbstractIndexShardComponent implements Closeable { public final String MAP_UNMAPPED_FIELDS_AS_STRING = <str> ; private final MapperService mapperService ; private final IndexFieldDataService indexFieldDataService ; private final ShardIndexingService indexingService ; private final ConcurrentMap < BytesRef , Query > percolateQueries = ConcurrentCollections . newConcurrentMapWithAggressiveConcurrency ( ) ; private final RealTimePercolatorOperationListener realTimePercolatorOperationListener = new RealTimePercolatorOperationListener ( ) ; private final PercolateTypeListener percolateTypeListener = new PercolateTypeListener ( ) ; private final AtomicBoolean realTimePercolatorEnabled = new AtomicBoolean ( false ) ; private final QueryShardContext queryShardContext ; private boolean mapUnmappedFieldsAsString ; private final MeanMetric percolateMetric = new MeanMetric ( ) ; private final CounterMetric currentMetric = new CounterMetric ( ) ; private final CounterMetric numberOfQueries = new CounterMetric ( ) ; public PercolatorQueriesRegistry ( ShardId shardId , IndexSettings indexSettings , ShardIndexingService indexingService , MapperService mapperService , QueryShardContext queryShardContext , IndexFieldDataService indexFieldDataService ) { super ( shardId , indexSettings ) ; this . mapperService = mapperService ; this . indexingService = indexingService ; this . queryShardContext = queryShardContext ; this . indexFieldDataService = indexFieldDataService ; this . mapUnmappedFieldsAsString = this . indexSettings . getSettings ( ) . getAsBoolean ( MAP_UNMAPPED_FIELDS_AS_STRING , false ) ; mapperService . addTypeListener ( percolateTypeListener ) ; } public ConcurrentMap < BytesRef , Query > percolateQueries ( ) { return percolateQueries ; } @Override public void close ( ) { mapperService . removeTypeListener ( percolateTypeListener ) ; indexingService . removeListener ( realTimePercolatorOperationListener ) ; clear ( ) ; } public void clear ( ) { percolateQueries . clear ( ) ; } public void enableRealTimePercolator ( ) { if ( realTimePercolatorEnabled . compareAndSet ( false , true ) ) { indexingService . addListener ( realTimePercolatorOperationListener ) ; } } public void addPercolateQuery ( String idAsString , BytesReference source ) { Query newquery = parsePercolatorDocument ( idAsString , source ) ; BytesRef id = new BytesRef ( idAsString ) ; percolateQueries . put ( id , newquery ) ; numberOfQueries . inc ( ) ; } public void removePercolateQuery ( String idAsString ) { BytesRef id = new BytesRef ( idAsString ) ; Query query = percolateQueries . remove ( id ) ; if ( query ! = null ) { numberOfQueries . dec ( ) ; } } Query parsePercolatorDocument ( String id , BytesReference source ) { String type = null ; BytesReference querySource = null ; try ( XContentParser sourceParser = XContentHelper . createParser ( source ) ) { String currentFieldName = null ; XContentParser . Token token = sourceParser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchException ( <str> + id + <str> ) ; } while ( ( token = sourceParser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = sourceParser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { if ( type ! = null ) { return parseQuery ( type , sourceParser ) ; } else { XContentBuilder builder = XContentFactory . contentBuilder ( sourceParser . contentType ( ) ) ; builder . copyCurrentStructure ( sourceParser ) ; querySource = builder . bytes ( ) ; builder . close ( ) ; } } else { sourceParser . skipChildren ( ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { sourceParser . skipChildren ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { type = sourceParser . text ( ) ; } } } try ( XContentParser queryParser = XContentHelper . createParser ( querySource ) ) { return parseQuery ( type , queryParser ) ; } } catch ( Exception e ) { throw new PercolatorException ( shardId ( ) . index ( ) , <str> + id + <str> , e ) ; } } private Query parseQuery ( String type , XContentParser parser ) { String [ ] previousTypes = null ; if ( type ! = null ) { previousTypes = QueryShardContext . setTypesWithPrevious ( type ) ; } QueryShardContext context = new QueryShardContext ( queryShardContext ) ; try { context . reset ( parser ) ; context . setAllowUnmappedFields ( false ) ; context . setMapUnmappedFieldAsString ( mapUnmappedFieldsAsString ) ; return context . parseInnerQuery ( ) ; } catch ( IOException e ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> , e ) ; } finally { if ( type ! = null ) { QueryShardContext . setTypes ( previousTypes ) ; } context . reset ( null ) ; } } private class PercolateTypeListener implements DocumentTypeListener { @Override public void beforeCreate ( DocumentMapper mapper ) { if ( PercolatorService . TYPE_NAME . equals ( mapper . type ( ) ) ) { enableRealTimePercolator ( ) ; } } } public void loadQueries ( IndexReader reader ) { logger . trace ( <str> ) ; final int loadedQueries ; try { Query query = new TermQuery ( new Term ( TypeFieldMapper . NAME , PercolatorService . TYPE_NAME ) ) ; QueriesLoaderCollector queryCollector = new QueriesLoaderCollector ( PercolatorQueriesRegistry . this , logger , mapperService , indexFieldDataService ) ; IndexSearcher indexSearcher = new IndexSearcher ( reader ) ; indexSearcher . setQueryCache ( null ) ; indexSearcher . search ( query , queryCollector ) ; Map < BytesRef , Query > queries = queryCollector . queries ( ) ; for ( Map . Entry < BytesRef , Query > entry : queries . entrySet ( ) ) { percolateQueries . put ( entry . getKey ( ) , entry . getValue ( ) ) ; numberOfQueries . inc ( ) ; } loadedQueries = queries . size ( ) ; } catch ( Exception e ) { throw new PercolatorException ( shardId . index ( ) , <str> , e ) ; } logger . debug ( <str> , loadedQueries ) ; } private class RealTimePercolatorOperationListener extends IndexingOperationListener { @Override public Engine . Index preIndex ( Engine . Index operation ) { if ( PercolatorService . TYPE_NAME . equals ( operation . type ( ) ) ) { parsePercolatorDocument ( operation . id ( ) , operation . source ( ) ) ; } return operation ; } @Override public void postIndexUnderLock ( Engine . Index index ) { if ( PercolatorService . TYPE_NAME . equals ( index . type ( ) ) ) { addPercolateQuery ( index . id ( ) , index . source ( ) ) ; } } @Override public void postDeleteUnderLock ( Engine . Delete delete ) { if ( PercolatorService . TYPE_NAME . equals ( delete . type ( ) ) ) { removePercolateQuery ( delete . id ( ) ) ; } } } public void prePercolate ( ) { currentMetric . inc ( ) ; } public void postPercolate ( long tookInNanos ) { currentMetric . dec ( ) ; percolateMetric . inc ( tookInNanos ) ; } public PercolateStats stats ( ) { return new PercolateStats ( percolateMetric . count ( ) , TimeUnit . NANOSECONDS . toMillis ( percolateMetric . sum ( ) ) , currentMetric . count ( ) , - <int> , numberOfQueries . count ( ) ) ; } } 
