package com . badlogic . gdx . graphics . g3d . attributes ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . g3d . Attribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . NumberUtils ; public class DepthTestAttribute extends Attribute { public final static String Alias = <str> ; public final static long Type = register ( Alias ) ; protected static long Mask = Type ; public final static boolean is ( final long mask ) { return ( mask & Mask ) ! = <int> ; } public int depthFunc ; public float depthRangeNear ; public float depthRangeFar ; public boolean depthMask ; public DepthTestAttribute ( ) { this ( GL20 . GL_LEQUAL ) ; } public DepthTestAttribute ( boolean depthMask ) { this ( GL20 . GL_LEQUAL , depthMask ) ; } public DepthTestAttribute ( final int depthFunc ) { this ( depthFunc , true ) ; } public DepthTestAttribute ( int depthFunc , boolean depthMask ) { this ( depthFunc , <int> , <int> , depthMask ) ; } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar ) { this ( depthFunc , depthRangeNear , depthRangeFar , true ) ; } public DepthTestAttribute ( int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { this ( Type , depthFunc , depthRangeNear , depthRangeFar , depthMask ) ; } public DepthTestAttribute ( final long type , int depthFunc , float depthRangeNear , float depthRangeFar , boolean depthMask ) { super ( type ) ; if ( ! is ( type ) ) throw new GdxRuntimeException ( <str> ) ; this . depthFunc = depthFunc ; this . depthRangeNear = depthRangeNear ; this . depthRangeFar = depthRangeFar ; this . depthMask = depthMask ; } public DepthTestAttribute ( final DepthTestAttribute rhs ) { this ( rhs . type , rhs . depthFunc , rhs . depthRangeNear , rhs . depthRangeFar , rhs . depthMask ) ; } @Override public Attribute copy ( ) { return new DepthTestAttribute ( this ) ; } @Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = <int> * result + depthFunc ; result = <int> * result + NumberUtils . floatToRawIntBits ( depthRangeNear ) ; result = <int> * result + NumberUtils . floatToRawIntBits ( depthRangeFar ) ; result = <int> * result + ( depthMask ? <int> : <int> ) ; return result ; } @Override public int compareTo ( Attribute o ) { if ( type ! = o . type ) return ( int ) ( type - o . type ) ; DepthTestAttribute other = ( DepthTestAttribute ) o ; if ( depthFunc ! = other . depthFunc ) return depthFunc - other . depthFunc ; if ( depthMask ! = other . depthMask ) return depthMask ? - <int> : <int> ; if ( ! MathUtils . isEqual ( depthRangeNear , other . depthRangeNear ) ) return depthRangeNear < other . depthRangeNear ? - <int> : <int> ; if ( ! MathUtils . isEqual ( depthRangeFar , other . depthRangeFar ) ) return depthRangeFar < other . depthRangeFar ? - <int> : <int> ; return <int> ; } } 
