package io . netty . util ; import org . junit . Test ; import java . util . Random ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class RecyclerTest { @Test ( expected = IllegalStateException . class ) public void testMultipleRecycle ( ) { RecyclableObject object = RecyclableObject . newInstance ( ) ; object . recycle ( ) ; object . recycle ( ) ; } @Test public void testRecycle ( ) { RecyclableObject object = RecyclableObject . newInstance ( ) ; object . recycle ( ) ; RecyclableObject object2 = RecyclableObject . newInstance ( ) ; assertSame ( object , object2 ) ; object2 . recycle ( ) ; } @Test public void testRecycleDisable ( ) { DisabledRecyclableObject object = DisabledRecyclableObject . newInstance ( ) ; object . recycle ( ) ; DisabledRecyclableObject object2 = DisabledRecyclableObject . newInstance ( ) ; assertNotSame ( object , object2 ) ; object2 . recycle ( ) ; } static final class RecyclableObject { private static final Recycler < RecyclableObject > RECYCLER = new Recycler < RecyclableObject > ( ) { @Override protected RecyclableObject newObject ( Handle < RecyclableObject > handle ) { return new RecyclableObject ( handle ) ; } } ; private final Recycler . Handle < RecyclableObject > handle ; private RecyclableObject ( Recycler . Handle < RecyclableObject > handle ) { this . handle = handle ; } public static RecyclableObject newInstance ( ) { return RECYCLER . get ( ) ; } public void recycle ( ) { RECYCLER . recycle ( this , handle ) ; } } static final class DisabledRecyclableObject { private static final Recycler < DisabledRecyclableObject > RECYCLER = new Recycler < DisabledRecyclableObject > ( - <int> ) { @Override protected DisabledRecyclableObject newObject ( Handle handle ) { return new DisabledRecyclableObject ( handle ) ; } } ; private final Recycler . Handle handle ; private DisabledRecyclableObject ( Recycler . Handle handle ) { this . handle = handle ; } public static DisabledRecyclableObject newInstance ( ) { return RECYCLER . get ( ) ; } public void recycle ( ) { RECYCLER . recycle ( this , handle ) ; } } @Test public void testMaxCapacity ( ) { testMaxCapacity ( <int> ) ; Random rand = new Random ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { testMaxCapacity ( rand . nextInt ( <int> ) + <int> ) ; } } void testMaxCapacity ( int maxCapacity ) { Recycler < HandledObject > recycler = new Recycler < HandledObject > ( maxCapacity ) { @Override protected HandledObject newObject ( Recycler . Handle < HandledObject > handle ) { return new HandledObject ( handle ) ; } } ; HandledObject [ ] objects = new HandledObject [ maxCapacity * <int> ] ; for ( int i = <int> ; i < objects . length ; i + + ) { objects [ i ] = recycler . get ( ) ; } for ( int i = <int> ; i < objects . length ; i + + ) { recycler . recycle ( objects [ i ] , objects [ i ] . handle ) ; objects [ i ] = null ; } assertEquals ( maxCapacity , recycler . threadLocalCapacity ( ) ) ; } @Test public void testRecycleAtDifferentThread ( ) throws Exception { final Recycler < HandledObject > recycler = new Recycler < HandledObject > ( <int> ) { @Override protected HandledObject newObject ( Recycler . Handle handle ) { return new HandledObject ( handle ) ; } } ; final HandledObject o = recycler . get ( ) ; final Thread thread = new Thread ( ) { @Override public void run ( ) { recycler . recycle ( o , o . handle ) ; } } ; thread . start ( ) ; thread . join ( ) ; assertThat ( recycler . get ( ) , is ( sameInstance ( o ) ) ) ; } @Test public void testMaxCapacityWithRecycleAtDifferentThread ( ) throws Exception { final int maxCapacity = <int> ; final Recycler < HandledObject > recycler = new Recycler < HandledObject > ( maxCapacity ) { @Override protected HandledObject newObject ( Recycler . Handle handle ) { return new HandledObject ( handle ) ; } } ; final HandledObject [ ] array = new HandledObject [ maxCapacity * <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { array [ i ] = recycler . get ( ) ; } for ( int i = <int> ; i < maxCapacity ; i + + ) { recycler . recycle ( array [ i ] , array [ i ] . handle ) ; } final Thread thread = new Thread ( ) { @Override public void run ( ) { for ( int i = maxCapacity ; i < array . length ; i + + ) { recycler . recycle ( array [ i ] , array [ i ] . handle ) ; } } } ; thread . start ( ) ; thread . join ( ) ; assertThat ( recycler . threadLocalCapacity ( ) , is ( maxCapacity ) ) ; assertThat ( recycler . threadLocalSize ( ) , is ( maxCapacity ) ) ; for ( int i = <int> ; i < array . length ; i + + ) { recycler . get ( ) ; } assertThat ( recycler . threadLocalCapacity ( ) , is ( maxCapacity ) ) ; assertThat ( recycler . threadLocalSize ( ) , is ( <int> ) ) ; } static final class HandledObject { Recycler . Handle < HandledObject > handle ; HandledObject ( Recycler . Handle < HandledObject > handle ) { this . handle = handle ; } } } 
