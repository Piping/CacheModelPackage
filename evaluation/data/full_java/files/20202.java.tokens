package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . buffer . Unpooled ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . util . Recycler ; import io . netty . util . Recycler . Handle ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . FastThreadLocal ; import io . netty . util . internal . InternalThreadLocalMap ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteBuffer ; import java . nio . channels . ClosedChannelException ; import java . util . Arrays ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; public final class ChannelOutboundBuffer { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ChannelOutboundBuffer . class ) ; private static final FastThreadLocal < ByteBuffer [ ] > NIO_BUFFERS = new FastThreadLocal < ByteBuffer [ ] > ( ) { @Override protected ByteBuffer [ ] initialValue ( ) throws Exception { return new ByteBuffer [ <int> ] ; } } ; private final Channel channel ; private Entry flushedEntry ; private Entry unflushedEntry ; private Entry tailEntry ; private int flushed ; private int nioBufferCount ; private long nioBufferSize ; private boolean inFail ; private static final AtomicLongFieldUpdater < ChannelOutboundBuffer > TOTAL_PENDING_SIZE_UPDATER ; @SuppressWarnings ( <str> ) private volatile long totalPendingSize ; private static final AtomicIntegerFieldUpdater < ChannelOutboundBuffer > UNWRITABLE_UPDATER ; @SuppressWarnings ( <str> ) private volatile int unwritable ; private volatile Runnable fireChannelWritabilityChangedTask ; static { AtomicIntegerFieldUpdater < ChannelOutboundBuffer > unwritableUpdater = PlatformDependent . newAtomicIntegerFieldUpdater ( ChannelOutboundBuffer . class , <str> ) ; if ( unwritableUpdater = = null ) { unwritableUpdater = AtomicIntegerFieldUpdater . newUpdater ( ChannelOutboundBuffer . class , <str> ) ; } UNWRITABLE_UPDATER = unwritableUpdater ; AtomicLongFieldUpdater < ChannelOutboundBuffer > pendingSizeUpdater = PlatformDependent . newAtomicLongFieldUpdater ( ChannelOutboundBuffer . class , <str> ) ; if ( pendingSizeUpdater = = null ) { pendingSizeUpdater = AtomicLongFieldUpdater . newUpdater ( ChannelOutboundBuffer . class , <str> ) ; } TOTAL_PENDING_SIZE_UPDATER = pendingSizeUpdater ; } ChannelOutboundBuffer ( AbstractChannel channel ) { this . channel = channel ; } public void addMessage ( Object msg , int size , ChannelPromise promise ) { Entry entry = Entry . newInstance ( msg , size , total ( msg ) , promise ) ; if ( tailEntry = = null ) { flushedEntry = null ; tailEntry = entry ; } else { Entry tail = tailEntry ; tail . next = entry ; tailEntry = entry ; } if ( unflushedEntry = = null ) { unflushedEntry = entry ; } incrementPendingOutboundBytes ( size , false ) ; } public void addFlush ( ) { Entry entry = unflushedEntry ; if ( entry ! = null ) { if ( flushedEntry = = null ) { flushedEntry = entry ; } do { flushed + + ; if ( ! entry . promise . setUncancellable ( ) ) { int pending = entry . cancel ( ) ; decrementPendingOutboundBytes ( pending , false , true ) ; } entry = entry . next ; } while ( entry ! = null ) ; unflushedEntry = null ; } } void incrementPendingOutboundBytes ( long size ) { incrementPendingOutboundBytes ( size , true ) ; } private void incrementPendingOutboundBytes ( long size , boolean invokeLater ) { if ( size = = <int> ) { return ; } long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER . addAndGet ( this , size ) ; if ( newWriteBufferSize > = channel . config ( ) . getWriteBufferHighWaterMark ( ) ) { setUnwritable ( invokeLater ) ; } } void decrementPendingOutboundBytes ( long size ) { decrementPendingOutboundBytes ( size , true , true ) ; } private void decrementPendingOutboundBytes ( long size , boolean invokeLater , boolean notifyWritability ) { if ( size = = <int> ) { return ; } long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER . addAndGet ( this , - size ) ; if ( notifyWritability & & ( newWriteBufferSize = = <int> | | newWriteBufferSize < = channel . config ( ) . getWriteBufferLowWaterMark ( ) ) ) { setWritable ( invokeLater ) ; } } private static long total ( Object msg ) { if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . readableBytes ( ) ; } if ( msg instanceof FileRegion ) { return ( ( FileRegion ) msg ) . count ( ) ; } if ( msg instanceof ByteBufHolder ) { return ( ( ByteBufHolder ) msg ) . content ( ) . readableBytes ( ) ; } return - <int> ; } public Object current ( ) { Entry entry = flushedEntry ; if ( entry = = null ) { return null ; } return entry . msg ; } public void progress ( long amount ) { Entry e = flushedEntry ; assert e ! = null ; ChannelPromise p = e . promise ; if ( p instanceof ChannelProgressivePromise ) { long progress = e . progress + amount ; e . progress = progress ; ( ( ChannelProgressivePromise ) p ) . tryProgress ( progress , e . total ) ; } } public boolean remove ( ) { Entry e = flushedEntry ; if ( e = = null ) { clearNioBuffers ( ) ; return false ; } Object msg = e . msg ; ChannelPromise promise = e . promise ; int size = e . pendingSize ; removeEntry ( e ) ; if ( ! e . cancelled ) { ReferenceCountUtil . safeRelease ( msg ) ; safeSuccess ( promise ) ; decrementPendingOutboundBytes ( size , false , true ) ; } e . recycle ( ) ; return true ; } public boolean remove ( Throwable cause ) { return remove0 ( cause , true ) ; } private boolean remove0 ( Throwable cause , boolean notifyWritability ) { Entry e = flushedEntry ; if ( e = = null ) { clearNioBuffers ( ) ; return false ; } Object msg = e . msg ; ChannelPromise promise = e . promise ; int size = e . pendingSize ; removeEntry ( e ) ; if ( ! e . cancelled ) { ReferenceCountUtil . safeRelease ( msg ) ; safeFail ( promise , cause ) ; decrementPendingOutboundBytes ( size , false , notifyWritability ) ; } e . recycle ( ) ; return true ; } private void removeEntry ( Entry e ) { if ( - - flushed = = <int> ) { flushedEntry = null ; if ( e = = tailEntry ) { tailEntry = null ; unflushedEntry = null ; } } else { flushedEntry = e . next ; } } public void removeBytes ( long writtenBytes ) { for ( ; ; ) { Object msg = current ( ) ; if ( ! ( msg instanceof ByteBuf ) ) { assert writtenBytes = = <int> ; break ; } final ByteBuf buf = ( ByteBuf ) msg ; final int readerIndex = buf . readerIndex ( ) ; final int readableBytes = buf . writerIndex ( ) - readerIndex ; if ( readableBytes < = writtenBytes ) { if ( writtenBytes ! = <int> ) { progress ( readableBytes ) ; writtenBytes - = readableBytes ; } remove ( ) ; } else { if ( writtenBytes ! = <int> ) { buf . readerIndex ( readerIndex + ( int ) writtenBytes ) ; progress ( writtenBytes ) ; } break ; } } clearNioBuffers ( ) ; } private void clearNioBuffers ( ) { int count = nioBufferCount ; if ( count > <int> ) { nioBufferCount = <int> ; Arrays . fill ( NIO_BUFFERS . get ( ) , <int> , count , null ) ; } } public ByteBuffer [ ] nioBuffers ( ) { long nioBufferSize = <int> ; int nioBufferCount = <int> ; final InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap . get ( ) ; ByteBuffer [ ] nioBuffers = NIO_BUFFERS . get ( threadLocalMap ) ; Entry entry = flushedEntry ; while ( isFlushedEntry ( entry ) & & entry . msg instanceof ByteBuf ) { if ( ! entry . cancelled ) { ByteBuf buf = ( ByteBuf ) entry . msg ; final int readerIndex = buf . readerIndex ( ) ; final int readableBytes = buf . writerIndex ( ) - readerIndex ; if ( readableBytes > <int> ) { if ( Integer . MAX_VALUE - readableBytes < nioBufferSize ) { break ; } nioBufferSize + = readableBytes ; int count = entry . count ; if ( count = = - <int> ) { entry . count = count = buf . nioBufferCount ( ) ; } int neededSpace = nioBufferCount + count ; if ( neededSpace > nioBuffers . length ) { nioBuffers = expandNioBufferArray ( nioBuffers , neededSpace , nioBufferCount ) ; NIO_BUFFERS . set ( threadLocalMap , nioBuffers ) ; } if ( count = = <int> ) { ByteBuffer nioBuf = entry . buf ; if ( nioBuf = = null ) { entry . buf = nioBuf = buf . internalNioBuffer ( readerIndex , readableBytes ) ; } nioBuffers [ nioBufferCount + + ] = nioBuf ; } else { ByteBuffer [ ] nioBufs = entry . bufs ; if ( nioBufs = = null ) { entry . bufs = nioBufs = buf . nioBuffers ( ) ; } nioBufferCount = fillBufferArray ( nioBufs , nioBuffers , nioBufferCount ) ; } } } entry = entry . next ; } this . nioBufferCount = nioBufferCount ; this . nioBufferSize = nioBufferSize ; return nioBuffers ; } private static int fillBufferArray ( ByteBuffer [ ] nioBufs , ByteBuffer [ ] nioBuffers , int nioBufferCount ) { for ( ByteBuffer nioBuf : nioBufs ) { if ( nioBuf = = null ) { break ; } nioBuffers [ nioBufferCount + + ] = nioBuf ; } return nioBufferCount ; } private static ByteBuffer [ ] expandNioBufferArray ( ByteBuffer [ ] array , int neededSpace , int size ) { int newCapacity = array . length ; do { newCapacity < < = <int> ; if ( newCapacity < <int> ) { throw new IllegalStateException ( ) ; } } while ( neededSpace > newCapacity ) ; ByteBuffer [ ] newArray = new ByteBuffer [ newCapacity ] ; System . arraycopy ( array , <int> , newArray , <int> , size ) ; return newArray ; } public int nioBufferCount ( ) { return nioBufferCount ; } public long nioBufferSize ( ) { return nioBufferSize ; } public boolean isWritable ( ) { return unwritable = = <int> ; } public boolean getUserDefinedWritability ( int index ) { return ( unwritable & writabilityMask ( index ) ) = = <int> ; } public void setUserDefinedWritability ( int index , boolean writable ) { if ( writable ) { setUserDefinedWritability ( index ) ; } else { clearUserDefinedWritability ( index ) ; } } private void setUserDefinedWritability ( int index ) { final int mask = ~ writabilityMask ( index ) ; for ( ; ; ) { final int oldValue = unwritable ; final int newValue = oldValue & mask ; if ( UNWRITABLE_UPDATER . compareAndSet ( this , oldValue , newValue ) ) { if ( oldValue ! = <int> & & newValue = = <int> ) { fireChannelWritabilityChanged ( true ) ; } break ; } } } private void clearUserDefinedWritability ( int index ) { final int mask = writabilityMask ( index ) ; for ( ; ; ) { final int oldValue = unwritable ; final int newValue = oldValue | mask ; if ( UNWRITABLE_UPDATER . compareAndSet ( this , oldValue , newValue ) ) { if ( oldValue = = <int> & & newValue ! = <int> ) { fireChannelWritabilityChanged ( true ) ; } break ; } } } private static int writabilityMask ( int index ) { if ( index < <int> | | index > <int> ) { throw new IllegalArgumentException ( <str> + index + <str> ) ; } return <int> < < index ; } private void setWritable ( boolean invokeLater ) { for ( ; ; ) { final int oldValue = unwritable ; final int newValue = oldValue & ~ <int> ; if ( UNWRITABLE_UPDATER . compareAndSet ( this , oldValue , newValue ) ) { if ( oldValue ! = <int> & & newValue = = <int> ) { fireChannelWritabilityChanged ( invokeLater ) ; } break ; } } } private void setUnwritable ( boolean invokeLater ) { for ( ; ; ) { final int oldValue = unwritable ; final int newValue = oldValue | <int> ; if ( UNWRITABLE_UPDATER . compareAndSet ( this , oldValue , newValue ) ) { if ( oldValue = = <int> & & newValue ! = <int> ) { fireChannelWritabilityChanged ( invokeLater ) ; } break ; } } } private void fireChannelWritabilityChanged ( boolean invokeLater ) { final ChannelPipeline pipeline = channel . pipeline ( ) ; if ( invokeLater ) { Runnable task = fireChannelWritabilityChangedTask ; if ( task = = null ) { fireChannelWritabilityChangedTask = task = new Runnable ( ) { @Override public void run ( ) { pipeline . fireChannelWritabilityChanged ( ) ; } } ; } channel . eventLoop ( ) . execute ( task ) ; } else { pipeline . fireChannelWritabilityChanged ( ) ; } } public int size ( ) { return flushed ; } public boolean isEmpty ( ) { return flushed = = <int> ; } void failFlushed ( Throwable cause , boolean notify ) { if ( inFail ) { return ; } try { inFail = true ; for ( ; ; ) { if ( ! remove0 ( cause , notify ) ) { break ; } } } finally { inFail = false ; } } void close ( final ClosedChannelException cause ) { if ( inFail ) { channel . eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { close ( cause ) ; } } ) ; return ; } inFail = true ; if ( channel . isOpen ( ) ) { throw new IllegalStateException ( <str> ) ; } if ( ! isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } try { Entry e = unflushedEntry ; while ( e ! = null ) { int size = e . pendingSize ; TOTAL_PENDING_SIZE_UPDATER . addAndGet ( this , - size ) ; if ( ! e . cancelled ) { ReferenceCountUtil . safeRelease ( e . msg ) ; safeFail ( e . promise , cause ) ; } e = e . recycleAndGetNext ( ) ; } } finally { inFail = false ; } clearNioBuffers ( ) ; } private static void safeSuccess ( ChannelPromise promise ) { if ( ! ( promise instanceof VoidChannelPromise ) & & ! promise . trySuccess ( ) ) { logger . warn ( <str> , promise ) ; } } private static void safeFail ( ChannelPromise promise , Throwable cause ) { if ( ! ( promise instanceof VoidChannelPromise ) & & ! promise . tryFailure ( cause ) ) { logger . warn ( <str> , promise , cause ) ; } } @Deprecated public void recycle ( ) { } public long totalPendingWriteBytes ( ) { return totalPendingSize ; } public long bytesBeforeUnwritable ( ) { long bytes = channel . config ( ) . getWriteBufferHighWaterMark ( ) - totalPendingSize ; if ( bytes > <int> ) { return isWritable ( ) ? bytes : <int> ; } return <int> ; } public long bytesBeforeWritable ( ) { long bytes = totalPendingSize - channel . config ( ) . getWriteBufferLowWaterMark ( ) ; if ( bytes > <int> ) { return isWritable ( ) ? <int> : bytes ; } return <int> ; } public void forEachFlushedMessage ( MessageProcessor processor ) throws Exception { if ( processor = = null ) { throw new NullPointerException ( <str> ) ; } Entry entry = flushedEntry ; if ( entry = = null ) { return ; } do { if ( ! entry . cancelled ) { if ( ! processor . processMessage ( entry . msg ) ) { return ; } } entry = entry . next ; } while ( isFlushedEntry ( entry ) ) ; } private boolean isFlushedEntry ( Entry e ) { return e ! = null & & e ! = unflushedEntry ; } public interface MessageProcessor { boolean processMessage ( Object msg ) throws Exception ; } static final class Entry { private static final Recycler < Entry > RECYCLER = new Recycler < Entry > ( ) { @Override protected Entry newObject ( Handle handle ) { return new Entry ( handle ) ; } } ; private final Handle handle ; Entry next ; Object msg ; ByteBuffer [ ] bufs ; ByteBuffer buf ; ChannelPromise promise ; long progress ; long total ; int pendingSize ; int count = - <int> ; boolean cancelled ; private Entry ( Handle handle ) { this . handle = handle ; } static Entry newInstance ( Object msg , int size , long total , ChannelPromise promise ) { Entry entry = RECYCLER . get ( ) ; entry . msg = msg ; entry . pendingSize = size ; entry . total = total ; entry . promise = promise ; return entry ; } int cancel ( ) { if ( ! cancelled ) { cancelled = true ; int pSize = pendingSize ; ReferenceCountUtil . safeRelease ( msg ) ; msg = Unpooled . EMPTY_BUFFER ; pendingSize = <int> ; total = <int> ; progress = <int> ; bufs = null ; buf = null ; return pSize ; } return <int> ; } void recycle ( ) { next = null ; bufs = null ; buf = null ; msg = null ; promise = null ; progress = <int> ; total = <int> ; pendingSize = <int> ; count = - <int> ; cancelled = false ; RECYCLER . recycle ( this , handle ) ; } Entry recycleAndGetNext ( ) { Entry next = this . next ; recycle ( ) ; return next ; } } } 
