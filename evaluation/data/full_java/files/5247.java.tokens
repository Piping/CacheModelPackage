package org . elasticsearch . action . admin . indices . validate . query ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . ValidateActions ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . index . query . MatchAllQueryBuilder ; import org . elasticsearch . index . query . QueryBuilder ; import java . io . IOException ; import java . util . Arrays ; public class ValidateQueryRequest extends BroadcastRequest < ValidateQueryRequest > { private QueryBuilder < ? > query = new MatchAllQueryBuilder ( ) ; private boolean explain ; private boolean rewrite ; private String [ ] types = Strings . EMPTY_ARRAY ; long nowInMillis ; public ValidateQueryRequest ( ) { this ( Strings . EMPTY_ARRAY ) ; } public ValidateQueryRequest ( String . . . indices ) { super ( indices ) ; indicesOptions ( IndicesOptions . fromOptions ( false , false , true , false ) ) ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = super . validate ( ) ; if ( query = = null ) { validationException = ValidateActions . addValidationError ( <str> , validationException ) ; } return validationException ; } public QueryBuilder < ? > query ( ) { return query ; } public ValidateQueryRequest query ( QueryBuilder < ? > query ) { this . query = query ; return this ; } public String [ ] types ( ) { return this . types ; } public ValidateQueryRequest types ( String . . . types ) { this . types = types ; return this ; } public void explain ( boolean explain ) { this . explain = explain ; } public boolean explain ( ) { return explain ; } public void rewrite ( boolean rewrite ) { this . rewrite = rewrite ; } public boolean rewrite ( ) { return rewrite ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; query = in . readQuery ( ) ; int typesSize = in . readVInt ( ) ; if ( typesSize > <int> ) { types = new String [ typesSize ] ; for ( int i = <int> ; i < typesSize ; i + + ) { types [ i ] = in . readString ( ) ; } } explain = in . readBoolean ( ) ; rewrite = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeQuery ( query ) ; out . writeVInt ( types . length ) ; for ( String type : types ) { out . writeString ( type ) ; } out . writeBoolean ( explain ) ; out . writeBoolean ( rewrite ) ; } @Override public String toString ( ) { return <str> + Arrays . toString ( indices ) + <str> + Arrays . toString ( types ) + <str> + query + <str> + explain + <str> + rewrite ; } } 
