package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class CompactTables { public static final ByteBuffer SUPER_COLUMN_MAP_COLUMN = ByteBufferUtil . EMPTY_BYTE_BUFFER ; public static final String SUPER_COLUMN_MAP_COLUMN_STR = UTF8Type . instance . compose ( SUPER_COLUMN_MAP_COLUMN ) ; private CompactTables ( ) { } public static ColumnDefinition getCompactValueColumn ( PartitionColumns columns , boolean isSuper ) { if ( isSuper ) { for ( ColumnDefinition column : columns . regulars ) if ( column . name . bytes . equals ( SUPER_COLUMN_MAP_COLUMN ) ) return column ; throw new AssertionError ( <str> ) ; } assert columns . regulars . simpleColumnCount ( ) = = <int> & & columns . regulars . complexColumnCount ( ) = = <int> ; return columns . regulars . getSimple ( <int> ) ; } public static AbstractType < ? > columnDefinitionComparator ( ColumnDefinition . Kind kind , boolean isSuper , AbstractType < ? > rawComparator , AbstractType < ? > rawSubComparator ) { if ( isSuper ) return kind = = ColumnDefinition . Kind . REGULAR ? rawSubComparator : UTF8Type . instance ; else return kind = = ColumnDefinition . Kind . STATIC ? rawComparator : UTF8Type . instance ; } public static boolean hasEmptyCompactValue ( CFMetaData metadata ) { return metadata . compactValueColumn ( ) . type instanceof EmptyType ; } public static boolean isSuperColumnMapColumn ( ColumnDefinition column ) { return column . kind = = ColumnDefinition . Kind . REGULAR & & column . name . bytes . equals ( SUPER_COLUMN_MAP_COLUMN ) ; } public static DefaultNames defaultNameGenerator ( Set < String > usedNames ) { return new DefaultNames ( new HashSet < String > ( usedNames ) ) ; } public static DefaultNames defaultNameGenerator ( Iterable < ColumnDefinition > defs ) { Set < String > usedNames = new HashSet < > ( ) ; for ( ColumnDefinition def : defs ) usedNames . add ( def . name . toString ( ) ) ; return new DefaultNames ( usedNames ) ; } public static class DefaultNames { private static final String DEFAULT_PARTITION_KEY_NAME = <str> ; private static final String DEFAULT_CLUSTERING_NAME = <str> ; private static final String DEFAULT_COMPACT_VALUE_NAME = <str> ; private final Set < String > usedNames ; private int partitionIndex = <int> ; private int clusteringIndex = <int> ; private int compactIndex = <int> ; private DefaultNames ( Set < String > usedNames ) { this . usedNames = usedNames ; } public String defaultPartitionKeyName ( ) { while ( true ) { String candidate = partitionIndex = = <int> ? DEFAULT_PARTITION_KEY_NAME : DEFAULT_PARTITION_KEY_NAME + ( partitionIndex + <int> ) ; + + partitionIndex ; if ( usedNames . add ( candidate ) ) return candidate ; } } public String defaultClusteringName ( ) { while ( true ) { String candidate = DEFAULT_CLUSTERING_NAME + clusteringIndex ; + + clusteringIndex ; if ( usedNames . add ( candidate ) ) return candidate ; } } public String defaultCompactValueName ( ) { while ( true ) { String candidate = compactIndex = = <int> ? DEFAULT_COMPACT_VALUE_NAME : DEFAULT_COMPACT_VALUE_NAME + compactIndex ; + + compactIndex ; if ( usedNames . add ( candidate ) ) return candidate ; } } } } 
