package clojure . asm . commons ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import clojure . asm . ClassVisitor ; import clojure . asm . Handle ; import clojure . asm . Label ; import clojure . asm . MethodVisitor ; import clojure . asm . Opcodes ; import clojure . asm . Type ; public class GeneratorAdapter extends LocalVariablesSorter { private static final String CLDESC = <str> ; private static final Type BYTE_TYPE = Type . getObjectType ( <str> ) ; private static final Type BOOLEAN_TYPE = Type . getObjectType ( <str> ) ; private static final Type SHORT_TYPE = Type . getObjectType ( <str> ) ; private static final Type CHARACTER_TYPE = Type . getObjectType ( <str> ) ; private static final Type INTEGER_TYPE = Type . getObjectType ( <str> ) ; private static final Type FLOAT_TYPE = Type . getObjectType ( <str> ) ; private static final Type LONG_TYPE = Type . getObjectType ( <str> ) ; private static final Type DOUBLE_TYPE = Type . getObjectType ( <str> ) ; private static final Type NUMBER_TYPE = Type . getObjectType ( <str> ) ; private static final Type OBJECT_TYPE = Type . getObjectType ( <str> ) ; private static final Method BOOLEAN_VALUE = Method . getMethod ( <str> ) ; private static final Method CHAR_VALUE = Method . getMethod ( <str> ) ; private static final Method INT_VALUE = Method . getMethod ( <str> ) ; private static final Method FLOAT_VALUE = Method . getMethod ( <str> ) ; private static final Method LONG_VALUE = Method . getMethod ( <str> ) ; private static final Method DOUBLE_VALUE = Method . getMethod ( <str> ) ; public static final int ADD = Opcodes . IADD ; public static final int SUB = Opcodes . ISUB ; public static final int MUL = Opcodes . IMUL ; public static final int DIV = Opcodes . IDIV ; public static final int REM = Opcodes . IREM ; public static final int NEG = Opcodes . INEG ; public static final int SHL = Opcodes . ISHL ; public static final int SHR = Opcodes . ISHR ; public static final int USHR = Opcodes . IUSHR ; public static final int AND = Opcodes . IAND ; public static final int OR = Opcodes . IOR ; public static final int XOR = Opcodes . IXOR ; public static final int EQ = Opcodes . IFEQ ; public static final int NE = Opcodes . IFNE ; public static final int LT = Opcodes . IFLT ; public static final int GE = Opcodes . IFGE ; public static final int GT = Opcodes . IFGT ; public static final int LE = Opcodes . IFLE ; private final int access ; private final Type returnType ; private final Type [ ] argumentTypes ; private final List < Type > localTypes = new ArrayList < Type > ( ) ; public GeneratorAdapter ( final MethodVisitor mv , final int access , final String name , final String desc ) { this ( Opcodes . ASM4 , mv , access , name , desc ) ; } protected GeneratorAdapter ( final int api , final MethodVisitor mv , final int access , final String name , final String desc ) { super ( api , access , desc , mv ) ; this . access = access ; this . returnType = Type . getReturnType ( desc ) ; this . argumentTypes = Type . getArgumentTypes ( desc ) ; } public GeneratorAdapter ( final int access , final Method method , final MethodVisitor mv ) { this ( mv , access , null , method . getDescriptor ( ) ) ; } public GeneratorAdapter ( final int access , final Method method , final String signature , final Type [ ] exceptions , final ClassVisitor cv ) { this ( access , method , cv . visitMethod ( access , method . getName ( ) , method . getDescriptor ( ) , signature , getInternalNames ( exceptions ) ) ) ; } private static String [ ] getInternalNames ( final Type [ ] types ) { if ( types = = null ) { return null ; } String [ ] names = new String [ types . length ] ; for ( int i = <int> ; i < names . length ; + + i ) { names [ i ] = types [ i ] . getInternalName ( ) ; } return names ; } public void push ( final boolean value ) { push ( value ? <int> : <int> ) ; } public void push ( final int value ) { if ( value > = - <int> & & value < = <int> ) { mv . visitInsn ( Opcodes . ICONST_0 + value ) ; } else if ( value > = Byte . MIN_VALUE & & value < = Byte . MAX_VALUE ) { mv . visitIntInsn ( Opcodes . BIPUSH , value ) ; } else if ( value > = Short . MIN_VALUE & & value < = Short . MAX_VALUE ) { mv . visitIntInsn ( Opcodes . SIPUSH , value ) ; } else { mv . visitLdcInsn ( new Integer ( value ) ) ; } } public void push ( final long value ) { if ( value = = <int> L | | value = = <int> ) { mv . visitInsn ( Opcodes . LCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Long ( value ) ) ; } } public void push ( final float value ) { int bits = Float . floatToIntBits ( value ) ; if ( bits = = <int> L | | bits = = <hex> | | bits = = <hex> ) { mv . visitInsn ( Opcodes . FCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Float ( value ) ) ; } } public void push ( final double value ) { long bits = Double . doubleToLongBits ( value ) ; if ( bits = = <int> L | | bits = = <hex> ) { mv . visitInsn ( Opcodes . DCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Double ( value ) ) ; } } public void push ( final String value ) { if ( value = = null ) { mv . visitInsn ( Opcodes . ACONST_NULL ) ; } else { mv . visitLdcInsn ( value ) ; } } public void push ( final Type value ) { if ( value = = null ) { mv . visitInsn ( Opcodes . ACONST_NULL ) ; } else { switch ( value . getSort ( ) ) { case Type . BOOLEAN : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . CHAR : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . BYTE : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . SHORT : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . INT : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . FLOAT : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . LONG : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; case Type . DOUBLE : mv . visitFieldInsn ( Opcodes . GETSTATIC , <str> , <str> , CLDESC ) ; break ; default : mv . visitLdcInsn ( value ) ; } } } public void push ( final Handle handle ) { mv . visitLdcInsn ( handle ) ; } private int getArgIndex ( final int arg ) { int index = ( access & Opcodes . ACC_STATIC ) = = <int> ? <int> : <int> ; for ( int i = <int> ; i < arg ; i + + ) { index + = argumentTypes [ i ] . getSize ( ) ; } return index ; } private void loadInsn ( final Type type , final int index ) { mv . visitVarInsn ( type . getOpcode ( Opcodes . ILOAD ) , index ) ; } private void storeInsn ( final Type type , final int index ) { mv . visitVarInsn ( type . getOpcode ( Opcodes . ISTORE ) , index ) ; } public void loadThis ( ) { if ( ( access & Opcodes . ACC_STATIC ) ! = <int> ) { throw new IllegalStateException ( <str> ) ; } mv . visitVarInsn ( Opcodes . ALOAD , <int> ) ; } public void loadArg ( final int arg ) { loadInsn ( argumentTypes [ arg ] , getArgIndex ( arg ) ) ; } public void loadArgs ( final int arg , final int count ) { int index = getArgIndex ( arg ) ; for ( int i = <int> ; i < count ; + + i ) { Type t = argumentTypes [ arg + i ] ; loadInsn ( t , index ) ; index + = t . getSize ( ) ; } } public void loadArgs ( ) { loadArgs ( <int> , argumentTypes . length ) ; } public void loadArgArray ( ) { push ( argumentTypes . length ) ; newArray ( OBJECT_TYPE ) ; for ( int i = <int> ; i < argumentTypes . length ; i + + ) { dup ( ) ; push ( i ) ; loadArg ( i ) ; box ( argumentTypes [ i ] ) ; arrayStore ( OBJECT_TYPE ) ; } } public void storeArg ( final int arg ) { storeInsn ( argumentTypes [ arg ] , getArgIndex ( arg ) ) ; } public Type getLocalType ( final int local ) { return localTypes . get ( local - firstLocal ) ; } @Override protected void setLocalType ( final int local , final Type type ) { int index = local - firstLocal ; while ( localTypes . size ( ) < index + <int> ) { localTypes . add ( null ) ; } localTypes . set ( index , type ) ; } public void loadLocal ( final int local ) { loadInsn ( getLocalType ( local ) , local ) ; } public void loadLocal ( final int local , final Type type ) { setLocalType ( local , type ) ; loadInsn ( type , local ) ; } public void storeLocal ( final int local ) { storeInsn ( getLocalType ( local ) , local ) ; } public void storeLocal ( final int local , final Type type ) { setLocalType ( local , type ) ; storeInsn ( type , local ) ; } public void arrayLoad ( final Type type ) { mv . visitInsn ( type . getOpcode ( Opcodes . IALOAD ) ) ; } public void arrayStore ( final Type type ) { mv . visitInsn ( type . getOpcode ( Opcodes . IASTORE ) ) ; } public void pop ( ) { mv . visitInsn ( Opcodes . POP ) ; } public void pop2 ( ) { mv . visitInsn ( Opcodes . POP2 ) ; } public void dup ( ) { mv . visitInsn ( Opcodes . DUP ) ; } public void dup2 ( ) { mv . visitInsn ( Opcodes . DUP2 ) ; } public void dupX1 ( ) { mv . visitInsn ( Opcodes . DUP_X1 ) ; } public void dupX2 ( ) { mv . visitInsn ( Opcodes . DUP_X2 ) ; } public void dup2X1 ( ) { mv . visitInsn ( Opcodes . DUP2_X1 ) ; } public void dup2X2 ( ) { mv . visitInsn ( Opcodes . DUP2_X2 ) ; } public void swap ( ) { mv . visitInsn ( Opcodes . SWAP ) ; } public void swap ( final Type prev , final Type type ) { if ( type . getSize ( ) = = <int> ) { if ( prev . getSize ( ) = = <int> ) { swap ( ) ; } else { dupX2 ( ) ; pop ( ) ; } } else { if ( prev . getSize ( ) = = <int> ) { dup2X1 ( ) ; pop2 ( ) ; } else { dup2X2 ( ) ; pop2 ( ) ; } } } public void math ( final int op , final Type type ) { mv . visitInsn ( type . getOpcode ( op ) ) ; } public void not ( ) { mv . visitInsn ( Opcodes . ICONST_1 ) ; mv . visitInsn ( Opcodes . IXOR ) ; } public void iinc ( final int local , final int amount ) { mv . visitIincInsn ( local , amount ) ; } public void cast ( final Type from , final Type to ) { if ( from ! = to ) { if ( from = = Type . DOUBLE_TYPE ) { if ( to = = Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . D2F ) ; } else if ( to = = Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . D2L ) ; } else { mv . visitInsn ( Opcodes . D2I ) ; cast ( Type . INT_TYPE , to ) ; } } else if ( from = = Type . FLOAT_TYPE ) { if ( to = = Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . F2D ) ; } else if ( to = = Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . F2L ) ; } else { mv . visitInsn ( Opcodes . F2I ) ; cast ( Type . INT_TYPE , to ) ; } } else if ( from = = Type . LONG_TYPE ) { if ( to = = Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . L2D ) ; } else if ( to = = Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . L2F ) ; } else { mv . visitInsn ( Opcodes . L2I ) ; cast ( Type . INT_TYPE , to ) ; } } else { if ( to = = Type . BYTE_TYPE ) { mv . visitInsn ( Opcodes . I2B ) ; } else if ( to = = Type . CHAR_TYPE ) { mv . visitInsn ( Opcodes . I2C ) ; } else if ( to = = Type . DOUBLE_TYPE ) { mv . visitInsn ( Opcodes . I2D ) ; } else if ( to = = Type . FLOAT_TYPE ) { mv . visitInsn ( Opcodes . I2F ) ; } else if ( to = = Type . LONG_TYPE ) { mv . visitInsn ( Opcodes . I2L ) ; } else if ( to = = Type . SHORT_TYPE ) { mv . visitInsn ( Opcodes . I2S ) ; } } } } private static Type getBoxedType ( final Type type ) { switch ( type . getSort ( ) ) { case Type . BYTE : return BYTE_TYPE ; case Type . BOOLEAN : return BOOLEAN_TYPE ; case Type . SHORT : return SHORT_TYPE ; case Type . CHAR : return CHARACTER_TYPE ; case Type . INT : return INTEGER_TYPE ; case Type . FLOAT : return FLOAT_TYPE ; case Type . LONG : return LONG_TYPE ; case Type . DOUBLE : return DOUBLE_TYPE ; } return type ; } public void box ( final Type type ) { if ( type . getSort ( ) = = Type . OBJECT | | type . getSort ( ) = = Type . ARRAY ) { return ; } if ( type = = Type . VOID_TYPE ) { push ( ( String ) null ) ; } else { Type boxed = getBoxedType ( type ) ; newInstance ( boxed ) ; if ( type . getSize ( ) = = <int> ) { dupX2 ( ) ; dupX2 ( ) ; pop ( ) ; } else { dupX1 ( ) ; swap ( ) ; } invokeConstructor ( boxed , new Method ( <str> , Type . VOID_TYPE , new Type [ ] { type } ) ) ; } } public void valueOf ( final Type type ) { if ( type . getSort ( ) = = Type . OBJECT | | type . getSort ( ) = = Type . ARRAY ) { return ; } if ( type = = Type . VOID_TYPE ) { push ( ( String ) null ) ; } else { Type boxed = getBoxedType ( type ) ; invokeStatic ( boxed , new Method ( <str> , boxed , new Type [ ] { type } ) ) ; } } public void unbox ( final Type type ) { Type t = NUMBER_TYPE ; Method sig = null ; switch ( type . getSort ( ) ) { case Type . VOID : return ; case Type . CHAR : t = CHARACTER_TYPE ; sig = CHAR_VALUE ; break ; case Type . BOOLEAN : t = BOOLEAN_TYPE ; sig = BOOLEAN_VALUE ; break ; case Type . DOUBLE : sig = DOUBLE_VALUE ; break ; case Type . FLOAT : sig = FLOAT_VALUE ; break ; case Type . LONG : sig = LONG_VALUE ; break ; case Type . INT : case Type . SHORT : case Type . BYTE : sig = INT_VALUE ; } if ( sig = = null ) { checkCast ( type ) ; } else { checkCast ( t ) ; invokeVirtual ( t , sig ) ; } } public Label newLabel ( ) { return new Label ( ) ; } public void mark ( final Label label ) { mv . visitLabel ( label ) ; } public Label mark ( ) { Label label = new Label ( ) ; mv . visitLabel ( label ) ; return label ; } public void ifCmp ( final Type type , final int mode , final Label label ) { switch ( type . getSort ( ) ) { case Type . LONG : mv . visitInsn ( Opcodes . LCMP ) ; break ; case Type . DOUBLE : mv . visitInsn ( mode = = GE | | mode = = GT ? Opcodes . DCMPL : Opcodes . DCMPG ) ; break ; case Type . FLOAT : mv . visitInsn ( mode = = GE | | mode = = GT ? Opcodes . FCMPL : Opcodes . FCMPG ) ; break ; case Type . ARRAY : case Type . OBJECT : switch ( mode ) { case EQ : mv . visitJumpInsn ( Opcodes . IF_ACMPEQ , label ) ; return ; case NE : mv . visitJumpInsn ( Opcodes . IF_ACMPNE , label ) ; return ; } throw new IllegalArgumentException ( <str> + type ) ; default : int intOp = - <int> ; switch ( mode ) { case EQ : intOp = Opcodes . IF_ICMPEQ ; break ; case NE : intOp = Opcodes . IF_ICMPNE ; break ; case GE : intOp = Opcodes . IF_ICMPGE ; break ; case LT : intOp = Opcodes . IF_ICMPLT ; break ; case LE : intOp = Opcodes . IF_ICMPLE ; break ; case GT : intOp = Opcodes . IF_ICMPGT ; break ; } mv . visitJumpInsn ( intOp , label ) ; return ; } mv . visitJumpInsn ( mode , label ) ; } public void ifICmp ( final int mode , final Label label ) { ifCmp ( Type . INT_TYPE , mode , label ) ; } public void ifZCmp ( final int mode , final Label label ) { mv . visitJumpInsn ( mode , label ) ; } public void ifNull ( final Label label ) { mv . visitJumpInsn ( Opcodes . IFNULL , label ) ; } public void ifNonNull ( final Label label ) { mv . visitJumpInsn ( Opcodes . IFNONNULL , label ) ; } public void goTo ( final Label label ) { mv . visitJumpInsn ( Opcodes . GOTO , label ) ; } public void ret ( final int local ) { mv . visitVarInsn ( Opcodes . RET , local ) ; } public void tableSwitch ( final int [ ] keys , final TableSwitchGenerator generator ) { float density ; if ( keys . length = = <int> ) { density = <int> ; } else { density = ( float ) keys . length / ( keys [ keys . length - <int> ] - keys [ <int> ] + <int> ) ; } tableSwitch ( keys , generator , density > = <float> ) ; } public void tableSwitch ( final int [ ] keys , final TableSwitchGenerator generator , final boolean useTable ) { for ( int i = <int> ; i < keys . length ; + + i ) { if ( keys [ i ] < keys [ i - <int> ] ) { throw new IllegalArgumentException ( <str> ) ; } } Label def = newLabel ( ) ; Label end = newLabel ( ) ; if ( keys . length > <int> ) { int len = keys . length ; int min = keys [ <int> ] ; int max = keys [ len - <int> ] ; int range = max - min + <int> ; if ( useTable ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = <int> ; i < len ; + + i ) { labels [ keys [ i ] - min ] = newLabel ( ) ; } mv . visitTableSwitchInsn ( min , max , def , labels ) ; for ( int i = <int> ; i < range ; + + i ) { Label label = labels [ i ] ; if ( label ! = def ) { mark ( label ) ; generator . generateCase ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = <int> ; i < len ; + + i ) { labels [ i ] = newLabel ( ) ; } mv . visitLookupSwitchInsn ( def , keys , labels ) ; for ( int i = <int> ; i < len ; + + i ) { mark ( labels [ i ] ) ; generator . generateCase ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generateDefault ( ) ; mark ( end ) ; } public void returnValue ( ) { mv . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; } private void fieldInsn ( final int opcode , final Type ownerType , final String name , final Type fieldType ) { mv . visitFieldInsn ( opcode , ownerType . getInternalName ( ) , name , fieldType . getDescriptor ( ) ) ; } public void getStatic ( final Type owner , final String name , final Type type ) { fieldInsn ( Opcodes . GETSTATIC , owner , name , type ) ; } public void putStatic ( final Type owner , final String name , final Type type ) { fieldInsn ( Opcodes . PUTSTATIC , owner , name , type ) ; } public void getField ( final Type owner , final String name , final Type type ) { fieldInsn ( Opcodes . GETFIELD , owner , name , type ) ; } public void putField ( final Type owner , final String name , final Type type ) { fieldInsn ( Opcodes . PUTFIELD , owner , name , type ) ; } private void invokeInsn ( final int opcode , final Type type , final Method method ) { String owner = type . getSort ( ) = = Type . ARRAY ? type . getDescriptor ( ) : type . getInternalName ( ) ; mv . visitMethodInsn ( opcode , owner , method . getName ( ) , method . getDescriptor ( ) ) ; } public void invokeVirtual ( final Type owner , final Method method ) { invokeInsn ( Opcodes . INVOKEVIRTUAL , owner , method ) ; } public void invokeConstructor ( final Type type , final Method method ) { invokeInsn ( Opcodes . INVOKESPECIAL , type , method ) ; } public void invokeStatic ( final Type owner , final Method method ) { invokeInsn ( Opcodes . INVOKESTATIC , owner , method ) ; } public void invokeInterface ( final Type owner , final Method method ) { invokeInsn ( Opcodes . INVOKEINTERFACE , owner , method ) ; } public void invokeDynamic ( String name , String desc , Handle bsm , Object . . . bsmArgs ) { mv . visitInvokeDynamicInsn ( name , desc , bsm , bsmArgs ) ; } private void typeInsn ( final int opcode , final Type type ) { mv . visitTypeInsn ( opcode , type . getInternalName ( ) ) ; } public void newInstance ( final Type type ) { typeInsn ( Opcodes . NEW , type ) ; } public void newArray ( final Type type ) { int typ ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : typ = Opcodes . T_BOOLEAN ; break ; case Type . CHAR : typ = Opcodes . T_CHAR ; break ; case Type . BYTE : typ = Opcodes . T_BYTE ; break ; case Type . SHORT : typ = Opcodes . T_SHORT ; break ; case Type . INT : typ = Opcodes . T_INT ; break ; case Type . FLOAT : typ = Opcodes . T_FLOAT ; break ; case Type . LONG : typ = Opcodes . T_LONG ; break ; case Type . DOUBLE : typ = Opcodes . T_DOUBLE ; break ; default : typeInsn ( Opcodes . ANEWARRAY , type ) ; return ; } mv . visitIntInsn ( Opcodes . NEWARRAY , typ ) ; } public void arrayLength ( ) { mv . visitInsn ( Opcodes . ARRAYLENGTH ) ; } public void throwException ( ) { mv . visitInsn ( Opcodes . ATHROW ) ; } public void throwException ( final Type type , final String msg ) { newInstance ( type ) ; dup ( ) ; push ( msg ) ; invokeConstructor ( type , Method . getMethod ( <str> ) ) ; throwException ( ) ; } public void checkCast ( final Type type ) { if ( ! type . equals ( OBJECT_TYPE ) ) { typeInsn ( Opcodes . CHECKCAST , type ) ; } } public void instanceOf ( final Type type ) { typeInsn ( Opcodes . INSTANCEOF , type ) ; } public void monitorEnter ( ) { mv . visitInsn ( Opcodes . MONITORENTER ) ; } public void monitorExit ( ) { mv . visitInsn ( Opcodes . MONITOREXIT ) ; } public void endMethod ( ) { if ( ( access & Opcodes . ACC_ABSTRACT ) = = <int> ) { mv . visitMaxs ( <int> , <int> ) ; } mv . visitEnd ( ) ; } public void catchException ( final Label start , final Label end , final Type exception ) { if ( exception = = null ) { mv . visitTryCatchBlock ( start , end , mark ( ) , null ) ; } else { mv . visitTryCatchBlock ( start , end , mark ( ) , exception . getInternalName ( ) ) ; } } } 
