package org . elasticsearch . search . aggregations . pipeline . movavg ; import org . elasticsearch . common . collect . EvictingQueue ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModel ; public class SimulatedAnealingMinimizer { public static MovAvgModel minimize ( MovAvgModel model , EvictingQueue < Double > train , double [ ] test ) { double temp = <int> ; double minTemp = <float> ; int iterations = <int> ; double alpha = <float> ; MovAvgModel bestModel = model ; MovAvgModel oldModel = model ; double oldCost = cost ( model , train , test ) ; double bestCost = oldCost ; while ( temp > minTemp ) { for ( int i = <int> ; i < iterations ; i + + ) { MovAvgModel newModel = oldModel . neighboringModel ( ) ; double newCost = cost ( newModel , train , test ) ; double ap = acceptanceProbability ( oldCost , newCost , temp ) ; if ( ap > Math . random ( ) ) { oldModel = newModel ; oldCost = newCost ; if ( newCost < bestCost ) { bestCost = newCost ; bestModel = newModel ; } } } temp * = alpha ; } return bestModel ; } private static double acceptanceProbability ( double oldCost , double newCost , double temp ) { return newCost < oldCost ? <float> : Math . exp ( - ( newCost - oldCost ) / temp ) ; } private static double cost ( MovAvgModel model , EvictingQueue < Double > train , double [ ] test ) { double error = <int> ; double [ ] predictions = model . predict ( train , test . length ) ; assert ( predictions . length = = test . length ) ; for ( int i = <int> ; i < predictions . length ; i + + ) { error + = Math . abs ( test [ i ] - predictions [ i ] ) ; } return error ; } } 
