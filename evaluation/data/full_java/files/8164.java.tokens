package org . elasticsearch . index . mapper . core ; import com . carrotsearch . randomizedtesting . annotations . Name ; import com . carrotsearch . randomizedtesting . annotations . ParametersFactory ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . Matchers . containsInAnyOrder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . nullValue ; public class TokenCountFieldMapperIntegrationIT extends ESIntegTestCase { @ParametersFactory public static Iterable < Object [ ] > buildParameters ( ) { List < Object [ ] > parameters = new ArrayList < > ( ) ; for ( boolean storeCountedFields : new boolean [ ] { true , false } ) { for ( boolean loadCountedFields : new boolean [ ] { true , false } ) { parameters . add ( new Object [ ] { storeCountedFields , loadCountedFields } ) ; } } return parameters ; } private final boolean storeCountedFields ; private final boolean loadCountedFields ; public TokenCountFieldMapperIntegrationIT ( @Name ( <str> ) boolean storeCountedFields , @Name ( <str> ) boolean loadCountedFields ) { this . storeCountedFields = storeCountedFields ; this . loadCountedFields = loadCountedFields ; } public void testSearchReturnsTokenCount ( ) throws IOException { init ( ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; assertSearchReturns ( searchById ( <str> ) , <str> ) ; } public void testSearchByTokenCount ( ) throws IOException { init ( ) ; assertSearchReturns ( searchByNumericRange ( <int> , <int> ) . get ( ) , <str> ) ; assertSearchReturns ( searchByNumericRange ( <int> , <int> ) . get ( ) , <str> ) ; assertSearchReturns ( searchByNumericRange ( <int> , <int> ) . get ( ) , <str> , <str> , <str> ) ; assertSearchReturns ( searchByNumericRange ( <int> , <int> ) . get ( ) , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertSearchReturns ( searchByNumericRange ( <int> , <int> ) . get ( ) ) ; } public void testFacetByTokenCount ( ) throws IOException { init ( ) ; String facetField = randomFrom ( Arrays . asList ( <str> , <str> , <str> ) ) ; SearchResponse result = searchByNumericRange ( <int> , <int> ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( facetField ) ) . get ( ) ; assertSearchReturns ( result , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( result . getAggregations ( ) . asList ( ) . size ( ) , equalTo ( <int> ) ) ; Terms terms = ( Terms ) result . getAggregations ( ) . asList ( ) . get ( <int> ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } private void init ( ) throws IOException { prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , storeCountedFields ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; ensureGreen ( ) ; assertTrue ( prepareIndex ( <str> , <str> ) . get ( ) . isCreated ( ) ) ; BulkResponse bulk = client ( ) . prepareBulk ( ) . add ( prepareIndex ( <str> , <str> ) ) . add ( prepareIndex ( <str> , <str> ) ) . get ( ) ; assertFalse ( bulk . buildFailureMessage ( ) , bulk . hasFailures ( ) ) ; assertTrue ( prepareIndex ( <str> , <str> , <str> ) . get ( ) . isCreated ( ) ) ; bulk = client ( ) . prepareBulk ( ) . add ( prepareIndex ( <str> , <str> , <str> ) ) . add ( prepareIndex ( <str> , <str> , <str> ) ) . get ( ) ; assertFalse ( bulk . buildFailureMessage ( ) , bulk . hasFailures ( ) ) ; assertThat ( refresh ( ) . getFailedShards ( ) , equalTo ( <int> ) ) ; } private IndexRequestBuilder prepareIndex ( String id , String . . . texts ) throws IOException { return client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , texts ) ; } private SearchResponse searchById ( String id ) { return prepareSearch ( ) . setQuery ( QueryBuilders . termQuery ( <str> , id ) ) . get ( ) ; } private SearchRequestBuilder searchByNumericRange ( int low , int high ) { return prepareSearch ( ) . setQuery ( QueryBuilders . rangeQuery ( randomFrom ( Arrays . asList ( <str> , <str> , <str> ) ) ) . gte ( low ) . lte ( high ) ) ; } private SearchRequestBuilder prepareSearch ( ) { SearchRequestBuilder request = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) ; request . addField ( <str> ) ; if ( loadCountedFields ) { request . addField ( <str> ) ; } return request ; } private void assertSearchReturns ( SearchResponse result , String . . . ids ) { assertThat ( result . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) ids . length ) ) ; assertThat ( result . getHits ( ) . hits ( ) . length , equalTo ( ids . length ) ) ; List < String > foundIds = new ArrayList < > ( ) ; for ( SearchHit hit : result . getHits ( ) ) { foundIds . add ( hit . id ( ) ) ; } assertThat ( foundIds , containsInAnyOrder ( ids ) ) ; for ( SearchHit hit : result . getHits ( ) ) { String id = hit . id ( ) ; if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> ) ; } else if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> ) ; } else if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> ) ; } else if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> , <int> ) ; } else if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> , <int> ) ; } else if ( id . equals ( <str> ) ) { assertSearchHit ( hit , <int> , <int> ) ; } else { throw new ElasticsearchException ( <str> ) ; } } } private void assertSearchHit ( SearchHit hit , int . . . termCounts ) { assertThat ( hit . field ( <str> ) , not ( nullValue ( ) ) ) ; assertThat ( hit . field ( <str> ) . values ( ) . size ( ) , equalTo ( termCounts . length ) ) ; for ( int i = <int> ; i < termCounts . length ; i + + ) { assertThat ( ( Integer ) hit . field ( <str> ) . values ( ) . get ( i ) , equalTo ( termCounts [ i ] ) ) ; } if ( loadCountedFields & & storeCountedFields ) { assertThat ( hit . field ( <str> ) . values ( ) . size ( ) , equalTo ( termCounts . length ) ) ; } } } 
