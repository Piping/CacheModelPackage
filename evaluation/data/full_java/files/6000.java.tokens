package org . elasticsearch . common . lucene . search . function ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . Scorer ; import org . elasticsearch . script . ExplainableSearchScript ; import org . elasticsearch . script . LeafSearchScript ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptException ; import org . elasticsearch . script . SearchScript ; import java . io . IOException ; import java . util . Objects ; public class ScriptScoreFunction extends ScoreFunction { static final class CannedScorer extends Scorer { protected int docid ; protected float score ; public CannedScorer ( ) { super ( null ) ; } @Override public int docID ( ) { return docid ; } @Override public float score ( ) throws IOException { return score ; } @Override public int freq ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public int nextDoc ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public int advance ( int target ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public long cost ( ) { return <int> ; } } private final Script sScript ; private final SearchScript script ; public ScriptScoreFunction ( Script sScript , SearchScript script ) { super ( CombineFunction . REPLACE ) ; this . sScript = sScript ; this . script = script ; } @Override public LeafScoreFunction getLeafScoreFunction ( LeafReaderContext ctx ) throws IOException { final LeafSearchScript leafScript = script . getLeafSearchScript ( ctx ) ; final CannedScorer scorer = new CannedScorer ( ) ; leafScript . setScorer ( scorer ) ; return new LeafScoreFunction ( ) { @Override public double score ( int docId , float subQueryScore ) { leafScript . setDocument ( docId ) ; scorer . docid = docId ; scorer . score = subQueryScore ; double result = leafScript . runAsDouble ( ) ; if ( Double . isNaN ( result ) ) { throw new ScriptException ( <str> ) ; } return result ; } @Override public Explanation explainScore ( int docId , Explanation subQueryScore ) throws IOException { Explanation exp ; if ( leafScript instanceof ExplainableSearchScript ) { leafScript . setDocument ( docId ) ; scorer . docid = docId ; scorer . score = subQueryScore . getValue ( ) ; exp = ( ( ExplainableSearchScript ) leafScript ) . explain ( subQueryScore ) ; } else { double score = score ( docId , subQueryScore . getValue ( ) ) ; String explanation = <str> + sScript + <str> ; if ( sScript . getParams ( ) ! = null ) { explanation + = <str> + sScript . getParams ( ) . toString ( ) ; } Explanation scoreExp = Explanation . match ( subQueryScore . getValue ( ) , <str> , subQueryScore ) ; return Explanation . match ( CombineFunction . toFloat ( score ) , explanation , scoreExp ) ; } return exp ; } } ; } @Override public boolean needsScores ( ) { return script . needsScores ( ) ; } @Override public String toString ( ) { return <str> + sScript . toString ( ) ; } @Override protected boolean doEquals ( ScoreFunction other ) { ScriptScoreFunction scriptScoreFunction = ( ScriptScoreFunction ) other ; return Objects . equals ( this . sScript , scriptScoreFunction . sScript ) ; } } 
