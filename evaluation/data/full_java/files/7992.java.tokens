package org . elasticsearch . common . util . concurrent ; import org . apache . lucene . store . AlreadyClosedException ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class RefCountedTests extends ESTestCase { public void testRefCount ( ) throws IOException { MyRefCounted counted = new MyRefCounted ( ) ; int incs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < incs ; i + + ) { if ( randomBoolean ( ) ) { counted . incRef ( ) ; } else { assertTrue ( counted . tryIncRef ( ) ) ; } counted . ensureOpen ( ) ; } for ( int i = <int> ; i < incs ; i + + ) { counted . decRef ( ) ; counted . ensureOpen ( ) ; } counted . incRef ( ) ; counted . decRef ( ) ; for ( int i = <int> ; i < incs ; i + + ) { if ( randomBoolean ( ) ) { counted . incRef ( ) ; } else { assertTrue ( counted . tryIncRef ( ) ) ; } counted . ensureOpen ( ) ; } for ( int i = <int> ; i < incs ; i + + ) { counted . decRef ( ) ; counted . ensureOpen ( ) ; } counted . decRef ( ) ; assertFalse ( counted . tryIncRef ( ) ) ; try { counted . incRef ( ) ; fail ( <str> ) ; } catch ( AlreadyClosedException ex ) { assertThat ( ex . getMessage ( ) , equalTo ( <str> ) ) ; } try { counted . ensureOpen ( ) ; fail ( <str> ) ; } catch ( AlreadyClosedException ex ) { assertThat ( ex . getMessage ( ) , equalTo ( <str> ) ) ; } } public void testMultiThreaded ( ) throws InterruptedException { final MyRefCounted counted = new MyRefCounted ( ) ; Thread [ ] threads = new Thread [ randomIntBetween ( <int> , <int> ) ] ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CopyOnWriteArrayList < Throwable > exceptions = new CopyOnWriteArrayList < > ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( ) { @Override public void run ( ) { try { latch . await ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { counted . incRef ( ) ; try { counted . ensureOpen ( ) ; } finally { counted . decRef ( ) ; } } } catch ( Throwable e ) { exceptions . add ( e ) ; } } } ; threads [ i ] . start ( ) ; } latch . countDown ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] . join ( ) ; } counted . decRef ( ) ; try { counted . ensureOpen ( ) ; fail ( <str> ) ; } catch ( AlreadyClosedException ex ) { assertThat ( ex . getMessage ( ) , equalTo ( <str> ) ) ; } assertThat ( counted . refCount ( ) , is ( <int> ) ) ; assertThat ( exceptions , Matchers . emptyIterable ( ) ) ; } private final class MyRefCounted extends AbstractRefCounted { private final AtomicBoolean closed = new AtomicBoolean ( false ) ; public MyRefCounted ( ) { super ( <str> ) ; } @Override protected void closeInternal ( ) { this . closed . set ( true ) ; } public void ensureOpen ( ) { if ( closed . get ( ) ) { assert this . refCount ( ) = = <int> ; throw new AlreadyClosedException ( <str> ) ; } } } } 
