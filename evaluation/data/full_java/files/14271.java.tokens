package org . gradle . model . internal . core ; import com . google . common . collect . ImmutableSortedSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import org . gradle . api . Nullable ; import org . gradle . internal . Cast ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . manage . schema . extract . * ; import org . gradle . model . internal . type . ModelType ; import java . util . List ; public class DefaultNodeInitializerRegistry implements NodeInitializerRegistry { public static final ModelReference < NodeInitializerRegistry > DEFAULT_REFERENCE = ModelReference . of ( <str> , NodeInitializerRegistry . class ) ; private final List < NodeInitializerExtractionStrategy > allStrategies ; private final List < NodeInitializerExtractionStrategy > additionalStrategies ; private final ModelSchemaStore schemaStore ; public DefaultNodeInitializerRegistry ( ModelSchemaStore schemaStore ) { this . schemaStore = schemaStore ; this . allStrategies = Lists . newArrayList ( new ModelSetNodeInitializerExtractionStrategy ( ) , new ManagedSetNodeInitializerExtractionStrategy ( ) , new SpecializedMapNodeInitializerExtractionStrategy ( ) , new ModelMapNodeInitializerExtractionStrategy ( ) , new ScalarCollectionNodeInitializerExtractionStrategy ( ) , new ManagedImplStructNodeInitializerExtractionStrategy ( ) ) ; additionalStrategies = Lists . newArrayList ( ) ; } private ModelTypeInitializationException canNotConstructTypeException ( NodeInitializerContext < ? > context ) { Iterable < ModelType < ? > > scalars = Iterables . concat ( ScalarTypes . TYPES , ScalarTypes . NON_FINAL_TYPES ) ; ImmutableSortedSet . Builder < ModelType < Object > > constructibleTypes = ImmutableSortedSet . orderedBy ( ModelType . displayOrder ( ) ) ; for ( NodeInitializerExtractionStrategy extractor : additionalStrategies ) { for ( ModelType < ? > constructibleType : extractor . supportedTypes ( ) ) { if ( context . getBaseType ( ) . isAssignableFrom ( constructibleType ) ) { constructibleTypes . add ( Cast . < ModelType < Object > > uncheckedCast ( constructibleType ) ) ; } } } return new ModelTypeInitializationException ( context , schemaStore , scalars , constructibleTypes . build ( ) ) ; } @Override public NodeInitializer getNodeInitializer ( NodeInitializerContext < ? > nodeInitializerContext ) { NodeInitializer nodeInitializer = findNodeInitializer ( nodeInitializerContext . getModelType ( ) ) ; if ( nodeInitializer ! = null ) { return nodeInitializer ; } throw canNotConstructTypeException ( nodeInitializerContext ) ; } @Nullable private NodeInitializer findNodeInitializer ( ModelType < ? > type ) { ModelSchema < ? > schema = schemaStore . getSchema ( type ) ; for ( NodeInitializerExtractionStrategy extractor : allStrategies ) { NodeInitializer nodeInitializer = extractor . extractNodeInitializer ( schema ) ; if ( nodeInitializer ! = null ) { return nodeInitializer ; } } return null ; } @Override public void ensureHasInitializer ( NodeInitializerContext < ? > nodeInitializer ) { getNodeInitializer ( nodeInitializer ) ; } @Override public void registerStrategy ( NodeInitializerExtractionStrategy strategy ) { allStrategies . add ( <int> , strategy ) ; additionalStrategies . add ( <int> , strategy ) ; } } 
