package org . elasticsearch . search . aggregations . bucket . sampler ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class UnmappedSampler extends InternalSampler { public static final Type TYPE = new Type ( <str> , <str> ) ; public static final AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public UnmappedSampler readResult ( StreamInput in ) throws IOException { UnmappedSampler sampler = new UnmappedSampler ( ) ; sampler . readFrom ( in ) ; return sampler ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } UnmappedSampler ( ) { } public UnmappedSampler ( String name , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , <int> , InternalAggregations . EMPTY , pipelineAggregators , metaData ) ; } @Override public Type type ( ) { return TYPE ; } @Override public InternalAggregation doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { for ( InternalAggregation agg : aggregations ) { if ( ! ( agg instanceof UnmappedSampler ) ) { return agg . reduce ( aggregations , reduceContext ) ; } } return this ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( InternalAggregation . CommonFields . DOC_COUNT , <int> ) ; return builder ; } } 
