package org . elasticsearch . plugin . discovery . multicast ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . discovery . zen . ping . PingContextProvider ; import org . elasticsearch . discovery . zen . ping . ZenPing ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import org . elasticsearch . transport . local . LocalTransport ; import org . hamcrest . Matchers ; import org . junit . Assert ; import java . net . DatagramPacket ; import java . net . InetAddress ; import java . net . MulticastSocket ; public class MulticastZenPingTests extends ESTestCase { private Settings buildRandomMulticast ( Settings settings ) { Settings . Builder builder = Settings . builder ( ) . put ( settings ) ; builder . put ( <str> , <str> + randomIntBetween ( <int> , <int> ) ) ; builder . put ( <str> , randomIntBetween ( <int> , <int> ) ) ; builder . put ( <str> , true ) ; if ( randomBoolean ( ) ) { builder . put ( <str> , randomBoolean ( ) ) ; } return builder . build ( ) ; } public void testSimplePings ( ) throws InterruptedException { Settings settings = Settings . EMPTY ; settings = buildRandomMulticast ( settings ) ; Thread . sleep ( <int> ) ; ThreadPool threadPool = new ThreadPool ( <str> ) ; final ClusterName clusterName = new ClusterName ( <str> ) ; final TransportService transportServiceA = new TransportService ( new LocalTransport ( settings , threadPool , Version . CURRENT , new NamedWriteableRegistry ( ) ) , threadPool ) . start ( ) ; final DiscoveryNode nodeA = new DiscoveryNode ( <str> , transportServiceA . boundAddress ( ) . publishAddress ( ) , Version . CURRENT ) ; final TransportService transportServiceB = new TransportService ( new LocalTransport ( settings , threadPool , Version . CURRENT , new NamedWriteableRegistry ( ) ) , threadPool ) . start ( ) ; final DiscoveryNode nodeB = new DiscoveryNode ( <str> , transportServiceB . boundAddress ( ) . publishAddress ( ) , Version . CURRENT ) ; MulticastZenPing zenPingA = new MulticastZenPing ( threadPool , transportServiceA , clusterName , Version . CURRENT ) ; zenPingA . setPingContextProvider ( new PingContextProvider ( ) { @Override public DiscoveryNodes nodes ( ) { return DiscoveryNodes . builder ( ) . put ( nodeA ) . localNodeId ( <str> ) . build ( ) ; } @Override public NodeService nodeService ( ) { return null ; } @Override public boolean nodeHasJoinedClusterOnce ( ) { return false ; } } ) ; zenPingA . start ( ) ; MulticastZenPing zenPingB = new MulticastZenPing ( threadPool , transportServiceB , clusterName , Version . CURRENT ) ; zenPingB . setPingContextProvider ( new PingContextProvider ( ) { @Override public DiscoveryNodes nodes ( ) { return DiscoveryNodes . builder ( ) . put ( nodeB ) . localNodeId ( <str> ) . build ( ) ; } @Override public NodeService nodeService ( ) { return null ; } @Override public boolean nodeHasJoinedClusterOnce ( ) { return true ; } } ) ; zenPingB . start ( ) ; try { logger . info ( <str> ) ; ZenPing . PingResponse [ ] pingResponses = zenPingA . pingAndWait ( TimeValue . timeValueSeconds ( <int> ) ) ; Assert . assertThat ( pingResponses . length , Matchers . equalTo ( <int> ) ) ; Assert . assertThat ( pingResponses [ <int> ] . node ( ) . id ( ) , Matchers . equalTo ( <str> ) ) ; Assert . assertTrue ( pingResponses [ <int> ] . hasJoinedOnce ( ) ) ; logger . info ( <str> ) ; pingResponses = zenPingB . pingAndWait ( TimeValue . timeValueSeconds ( <int> ) ) ; Assert . assertThat ( pingResponses . length , Matchers . equalTo ( <int> ) ) ; Assert . assertThat ( pingResponses [ <int> ] . node ( ) . id ( ) , Matchers . equalTo ( <str> ) ) ; Assert . assertFalse ( pingResponses [ <int> ] . hasJoinedOnce ( ) ) ; } finally { zenPingA . close ( ) ; zenPingB . close ( ) ; transportServiceA . close ( ) ; transportServiceB . close ( ) ; terminate ( threadPool ) ; } } @SuppressForbidden ( reason = <str> ) public void testExternalPing ( ) throws Exception { Settings settings = Settings . EMPTY ; settings = buildRandomMulticast ( settings ) ; final ThreadPool threadPool = new ThreadPool ( <str> ) ; final ClusterName clusterName = new ClusterName ( <str> ) ; final TransportService transportServiceA = new TransportService ( new LocalTransport ( settings , threadPool , Version . CURRENT , new NamedWriteableRegistry ( ) ) , threadPool ) . start ( ) ; final DiscoveryNode nodeA = new DiscoveryNode ( <str> , transportServiceA . boundAddress ( ) . publishAddress ( ) , Version . CURRENT ) ; MulticastZenPing zenPingA = new MulticastZenPing ( threadPool , transportServiceA , clusterName , Version . CURRENT ) ; zenPingA . setPingContextProvider ( new PingContextProvider ( ) { @Override public DiscoveryNodes nodes ( ) { return DiscoveryNodes . builder ( ) . put ( nodeA ) . localNodeId ( <str> ) . build ( ) ; } @Override public NodeService nodeService ( ) { return null ; } @Override public boolean nodeHasJoinedClusterOnce ( ) { return false ; } } ) ; zenPingA . start ( ) ; MulticastSocket multicastSocket = null ; try { Loggers . getLogger ( MulticastZenPing . class ) . setLevel ( <str> ) ; multicastSocket = new MulticastSocket ( ) ; multicastSocket . setReceiveBufferSize ( <int> ) ; multicastSocket . setSendBufferSize ( <int> ) ; multicastSocket . setSoTimeout ( <int> ) ; DatagramPacket datagramPacket = new DatagramPacket ( new byte [ <int> ] , <int> , InetAddress . getByName ( <str> ) , <int> ) ; XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; datagramPacket . setData ( builder . bytes ( ) . toBytes ( ) ) ; multicastSocket . send ( datagramPacket ) ; Thread . sleep ( <int> ) ; } finally { Loggers . getLogger ( MulticastZenPing . class ) . setLevel ( <str> ) ; if ( multicastSocket ! = null ) multicastSocket . close ( ) ; zenPingA . close ( ) ; terminate ( threadPool ) ; } } } 
