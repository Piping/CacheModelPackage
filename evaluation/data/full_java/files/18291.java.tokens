package com . badlogic . gdx . scenes . scene2d . ui ; import static com . badlogic . gdx . math . Interpolation . * ; import static com . badlogic . gdx . scenes . scene2d . actions . Actions . * ; import com . badlogic . gdx . Files ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . math . Interpolation ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Timer ; import com . badlogic . gdx . utils . Timer . Task ; public class TooltipManager { static private TooltipManager instance ; static private Files files ; public float initialTime = <int> ; public float subsequentTime = <int> ; public float resetTime = <float> ; public boolean enabled = true ; public boolean animations = true ; public float maxWidth = Integer . MAX_VALUE ; public float offsetX = <int> , offsetY = <int> ; public float edgeDistance = <int> ; final Array < Tooltip > shown = new Array ( ) ; float time = initialTime ; final Task resetTask = new Task ( ) { public void run ( ) { time = initialTime ; } } ; Tooltip showTooltip ; final Task showTask = new Task ( ) { public void run ( ) { if ( showTooltip = = null ) return ; Stage stage = showTooltip . targetActor . getStage ( ) ; if ( stage = = null ) return ; stage . addActor ( showTooltip . container ) ; showTooltip . container . toFront ( ) ; shown . add ( showTooltip ) ; showTooltip . container . clearActions ( ) ; showAction ( showTooltip ) ; if ( ! showTooltip . instant ) { time = subsequentTime ; resetTask . cancel ( ) ; } } } ; public void touchDown ( Tooltip tooltip ) { showTask . cancel ( ) ; if ( tooltip . container . remove ( ) ) resetTask . cancel ( ) ; resetTask . run ( ) ; if ( enabled | | tooltip . always ) { showTooltip = tooltip ; Timer . schedule ( showTask , time ) ; } } public void enter ( Tooltip tooltip ) { showTooltip = tooltip ; showTask . cancel ( ) ; if ( enabled | | tooltip . always ) { if ( time = = <int> | | tooltip . instant ) showTask . run ( ) ; else Timer . schedule ( showTask , time ) ; } } public void hide ( Tooltip tooltip ) { showTooltip = null ; showTask . cancel ( ) ; if ( tooltip . container . hasParent ( ) ) { shown . removeValue ( tooltip , true ) ; hideAction ( tooltip ) ; resetTask . cancel ( ) ; Timer . schedule ( resetTask , resetTime ) ; } } protected void showAction ( Tooltip tooltip ) { float actionTime = animations ? ( time > <int> ? <float> : <float> ) : <float> ; tooltip . container . setTransform ( true ) ; tooltip . container . getColor ( ) . a = <float> ; tooltip . container . setScale ( <float> ) ; tooltip . container . addAction ( parallel ( fadeIn ( actionTime , fade ) , scaleTo ( <int> , <int> , actionTime , Interpolation . fade ) ) ) ; } protected void hideAction ( Tooltip tooltip ) { tooltip . container . addAction ( sequence ( parallel ( alpha ( <float> , <float> , fade ) , scaleTo ( <float> , <float> , <float> , Interpolation . fade ) ) , removeActor ( ) ) ) ; } public void hideAll ( ) { resetTask . cancel ( ) ; showTask . cancel ( ) ; time = initialTime ; showTooltip = null ; for ( Tooltip tooltip : shown ) tooltip . hide ( ) ; shown . clear ( ) ; } public void instant ( ) { time = <int> ; showTask . run ( ) ; showTask . cancel ( ) ; } static public TooltipManager getInstance ( ) { if ( files = = null | | files ! = Gdx . files ) { files = Gdx . files ; instance = new TooltipManager ( ) ; } return instance ; } } 
