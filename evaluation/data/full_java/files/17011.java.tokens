package com . badlogic . gwtref . gen ; import java . io . PrintWriter ; import java . lang . annotation . Annotation ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . google . gwt . core . ext . BadPropertyValueException ; import com . google . gwt . core . ext . ConfigurationProperty ; import com . google . gwt . core . ext . GeneratorContext ; import com . google . gwt . core . ext . TreeLogger ; import com . google . gwt . core . ext . TreeLogger . Type ; import com . google . gwt . core . ext . typeinfo . * ; import com . google . gwt . user . rebind . ClassSourceFileComposerFactory ; import com . google . gwt . user . rebind . SourceWriter ; public class ReflectionCacheSourceCreator { private static final List < String > PRIMITIVE_TYPES = Collections . unmodifiableList ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; final TreeLogger logger ; final GeneratorContext context ; final JClassType type ; final String simpleName ; final String packageName ; SourceWriter sw ; final StringBuffer source = new StringBuffer ( ) ; final List < JType > types = new ArrayList < JType > ( ) ; final List < SetterGetterStub > setterGetterStubs = new ArrayList < SetterGetterStub > ( ) ; final List < MethodStub > methodStubs = new ArrayList < MethodStub > ( ) ; final Map < String , String > parameterName2ParameterInstantiation = new HashMap < String , String > ( ) ; final Map < String , Integer > typeNames2typeIds = new HashMap < String , Integer > ( ) ; int nextTypeId ; int nextSetterGetterId ; int nextInvokableId ; class SetterGetterStub { int getter ; int setter ; String name ; String enclosingType ; String type ; boolean isStatic ; boolean isFinal ; boolean unused ; } class MethodStub { String enclosingType ; String returnType ; List < String > parameterTypes = new ArrayList < String > ( ) ; String jnsi ; int methodId ; boolean isStatic ; boolean isAbstract ; boolean isFinal ; boolean isNative ; boolean isConstructor ; boolean isMethod ; boolean isPublic ; String name ; boolean unused ; } public ReflectionCacheSourceCreator ( TreeLogger logger , GeneratorContext context , JClassType type ) { this . logger = logger ; this . context = context ; this . type = type ; this . packageName = type . getPackage ( ) . getName ( ) ; this . simpleName = type . getSimpleSourceName ( ) + <str> ; logger . log ( Type . INFO , type . getQualifiedSourceName ( ) ) ; } public String create ( ) { ClassSourceFileComposerFactory composer = new ClassSourceFileComposerFactory ( packageName , simpleName ) ; composer . addImplementedInterface ( <str> ) ; imports ( composer ) ; PrintWriter printWriter = context . tryCreate ( logger , packageName , simpleName ) ; if ( printWriter = = null ) { return packageName + <str> + simpleName ; } sw = composer . createSourceWriter ( context , printWriter ) ; generateLookups ( ) ; forNameC ( ) ; newArrayC ( ) ; getArrayLengthT ( ) ; getArrayElementT ( ) ; setArrayElementT ( ) ; getF ( ) ; setF ( ) ; invokeM ( ) ; sw . commit ( logger ) ; createProxy ( type ) ; return packageName + <str> + simpleName ; } private void createProxy ( JClassType type ) { ClassSourceFileComposerFactory composer = new ClassSourceFileComposerFactory ( type . getPackage ( ) . getName ( ) , type . getSimpleSourceName ( ) + <str> ) ; PrintWriter printWriter = context . tryCreate ( logger , packageName , simpleName ) ; if ( printWriter = = null ) { return ; } SourceWriter writer = composer . createSourceWriter ( context , printWriter ) ; writer . commit ( logger ) ; } private void generateLookups ( ) { TypeOracle typeOracle = context . getTypeOracle ( ) ; JPackage [ ] packages = typeOracle . getPackages ( ) ; for ( JPackage p : packages ) { for ( JClassType t : p . getTypes ( ) ) { gatherTypes ( t . getErasedType ( ) , types ) ; } } try { ConfigurationProperty prop = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; for ( String s : prop . getValues ( ) ) { JClassType type = typeOracle . findType ( s ) ; if ( type ! = null ) gatherTypes ( type . getErasedType ( ) , types ) ; } } catch ( BadPropertyValueException e ) { } gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; gatherTypes ( typeOracle . findType ( <str> ) . getErasedType ( ) , types ) ; Collections . sort ( types , new Comparator < JType > ( ) { public int compare ( JType o1 , JType o2 ) { return o1 . getQualifiedSourceName ( ) . compareTo ( o2 . getQualifiedSourceName ( ) ) ; } } ) ; for ( JType t : types ) { p ( createTypeGenerator ( t ) ) ; } parameterInitialization ( ) ; Collections . sort ( setterGetterStubs , new Comparator < SetterGetterStub > ( ) { @Override public int compare ( SetterGetterStub o1 , SetterGetterStub o2 ) { return new Integer ( o1 . setter ) . compareTo ( o2 . setter ) ; } } ) ; for ( SetterGetterStub stub : setterGetterStubs ) { String stubSource = generateSetterGetterStub ( stub ) ; if ( stubSource . equals ( <str> ) ) stub . unused = true ; p ( stubSource ) ; } Collections . sort ( methodStubs , new Comparator < MethodStub > ( ) { @Override public int compare ( MethodStub o1 , MethodStub o2 ) { return new Integer ( o1 . methodId ) . compareTo ( o2 . methodId ) ; } } ) ; for ( MethodStub stub : methodStubs ) { String stubSource = generateMethodStub ( stub ) ; if ( stubSource . equals ( <str> ) ) stub . unused = true ; p ( stubSource ) ; } logger . log ( Type . INFO , types . size ( ) + <str> ) ; } private void out ( String message , int nesting ) { for ( int i = <int> ; i < nesting ; i + + ) System . out . print ( <str> ) ; System . out . println ( message ) ; } int nesting = <int> ; private void gatherTypes ( JType type , List < JType > types ) { nesting + + ; if ( type = = null ) { nesting - - ; return ; } if ( type . getQualifiedSourceName ( ) . contains ( <str> ) ) { nesting - - ; return ; } if ( ! isVisible ( type ) ) { nesting - - ; return ; } boolean keep = false ; String name = type . getQualifiedSourceName ( ) ; try { ConfigurationProperty prop ; keep | = ! name . contains ( <str> ) ; prop = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; for ( String s : prop . getValues ( ) ) keep | = name . contains ( s ) ; prop = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; for ( String s : prop . getValues ( ) ) keep & = ! name . equals ( s ) ; } catch ( BadPropertyValueException e ) { e . printStackTrace ( ) ; } if ( ! keep ) { nesting - - ; return ; } if ( types . contains ( type . getErasedType ( ) ) ) { nesting - - ; return ; } types . add ( type . getErasedType ( ) ) ; out ( type . getErasedType ( ) . getQualifiedSourceName ( ) , nesting ) ; if ( type instanceof JPrimitiveType ) { nesting - - ; return ; } else { JClassType c = ( JClassType ) type ; JField [ ] fields = c . getFields ( ) ; if ( fields ! = null ) { for ( JField field : fields ) { gatherTypes ( field . getType ( ) . getErasedType ( ) , types ) ; } } gatherTypes ( c . getSuperclass ( ) , types ) ; JClassType [ ] interfaces = c . getImplementedInterfaces ( ) ; if ( interfaces ! = null ) { for ( JClassType i : interfaces ) { gatherTypes ( i . getErasedType ( ) , types ) ; } } JMethod [ ] methods = c . getMethods ( ) ; if ( methods ! = null ) { for ( JMethod m : methods ) { gatherTypes ( m . getReturnType ( ) . getErasedType ( ) , types ) ; if ( m . getParameterTypes ( ) ! = null ) { for ( JType p : m . getParameterTypes ( ) ) { gatherTypes ( p . getErasedType ( ) , types ) ; } } } } JClassType [ ] inner = c . getNestedTypes ( ) ; if ( inner ! = null ) { for ( JClassType i : inner ) { gatherTypes ( i . getErasedType ( ) , types ) ; } } } nesting - - ; } private String generateMethodStub ( MethodStub stub ) { buffer . setLength ( <int> ) ; if ( stub . enclosingType = = null ) { logger . log ( Type . INFO , <str> + stub . name + <str> ) ; return <str> ; } if ( ( stub . enclosingType . startsWith ( <str> ) & & ! stub . enclosingType . startsWith ( <str> ) ) | | stub . enclosingType . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } if ( stub . enclosingType . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } for ( int i = <int> ; i < stub . parameterTypes . size ( ) ; i + + ) { String paramType = stub . parameterTypes . get ( i ) ; if ( paramType = = null ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } else if ( paramType . startsWith ( <str> ) | | paramType . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } else { stub . parameterTypes . set ( i , paramType . replace ( <str> , <str> ) ) ; } } if ( stub . returnType = = null ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } if ( stub . returnType . startsWith ( <str> ) | | stub . returnType . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } stub . enclosingType = stub . enclosingType . replace ( <str> , <str> ) ; stub . returnType = stub . returnType . replace ( <str> , <str> ) ; if ( stub . isMethod ) { boolean isVoid = stub . returnType . equals ( <str> ) ; pbn ( <str> + ( isVoid ? <str> : stub . returnType ) + <str> + stub . methodId + <str> ) ; if ( ! stub . isStatic ) pbn ( stub . enclosingType + <str> + ( stub . parameterTypes . size ( ) > <int> ? <str> : <str> ) ) ; int i = <int> ; for ( String paramType : stub . parameterTypes ) { pbn ( paramType + <str> + i + ( i < stub . parameterTypes . size ( ) - <int> ? <str> : <str> ) ) ; i + + ; } pbn ( <str> ) ; if ( ! isVoid ) pbn ( <str> ) ; if ( stub . isStatic ) pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> + stub . jnsi + <str> ) ; else pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> + stub . jnsi + <str> ) ; for ( i = <int> ; i < stub . parameterTypes . size ( ) ; i + + ) { pbn ( <str> + i + ( i < stub . parameterTypes . size ( ) - <int> ? <str> : <str> ) ) ; } pbn ( <str> ) ; if ( isVoid ) pbn ( <str> ) ; pbn ( <str> ) ; } else { pbn ( <str> + stub . returnType + <str> + stub . methodId + <str> ) ; int i = <int> ; for ( String paramType : stub . parameterTypes ) { pbn ( paramType + <str> + i + ( i < stub . parameterTypes . size ( ) - <int> ? <str> : <str> ) ) ; i + + ; } pbn ( <str> ) ; pbn ( <str> + stub . returnType + <str> ) ; for ( i = <int> ; i < stub . parameterTypes . size ( ) ; i + + ) { pbn ( <str> + i + ( i < stub . parameterTypes . size ( ) - <int> ? <str> : <str> ) ) ; } pbn ( <str> ) ; if ( ! stub . isPublic ) { pbn ( <str> ) ; } pbn ( <str> ) ; pbn ( <str> ) ; } return buffer . toString ( ) ; } private String generateSetterGetterStub ( SetterGetterStub stub ) { buffer . setLength ( <int> ) ; if ( stub . enclosingType = = null | | stub . type = = null ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> + stub . type + <str> ) ; return <str> ; } if ( stub . enclosingType . startsWith ( <str> ) | | stub . enclosingType . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } if ( stub . type . startsWith ( <str> ) | | stub . type . contains ( <str> ) ) { logger . log ( Type . INFO , <str> + stub . name + <str> + stub . enclosingType + <str> ) ; return <str> ; } stub . enclosingType = stub . enclosingType . replace ( <str> , <str> ) ; stub . type = stub . type . replace ( <str> , <str> ) ; pbn ( <str> + stub . type + <str> + stub . getter + <str> + stub . enclosingType + <str> ) ; if ( stub . isStatic ) pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> ) ; else pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> ) ; pb ( <str> ) ; if ( ! stub . isFinal ) { pbn ( <str> + stub . setter + <str> + stub . enclosingType + <str> + stub . type + <str> ) ; if ( stub . isStatic ) pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> ) ; else pbn ( <str> + stub . enclosingType + <str> + stub . name + <str> ) ; pb ( <str> ) ; } return buffer . toString ( ) ; } private boolean isVisible ( JType type ) { if ( type = = null ) return false ; if ( type instanceof JClassType ) { if ( type instanceof JArrayType ) { JType componentType = ( ( JArrayType ) type ) . getComponentType ( ) ; while ( componentType instanceof JArrayType ) { componentType = ( ( JArrayType ) componentType ) . getComponentType ( ) ; } if ( componentType instanceof JClassType ) { return ( ( JClassType ) componentType ) . isPublic ( ) ; } } else { return ( ( JClassType ) type ) . isPublic ( ) ; } } return true ; } private String createTypeGenerator ( JType t ) { buffer . setLength ( <int> ) ; int id = nextTypeId + + ; typeNames2typeIds . put ( t . getErasedType ( ) . getQualifiedSourceName ( ) , id ) ; JClassType c = t . isClass ( ) ; String name = t . getErasedType ( ) . getQualifiedSourceName ( ) ; String superClass = null ; if ( c ! = null & & ( isVisible ( c . getSuperclass ( ) ) ) ) superClass = c . getSuperclass ( ) . getErasedType ( ) . getQualifiedSourceName ( ) + <str> ; String assignables = null ; String interfaces = null ; if ( c ! = null & & c . getFlattenedSupertypeHierarchy ( ) ! = null ) { assignables = <str> ; boolean used = false ; for ( JType i : c . getFlattenedSupertypeHierarchy ( ) ) { if ( ! isVisible ( i ) | | i . equals ( t ) | | <str> . equals ( i . getErasedType ( ) . getQualifiedSourceName ( ) ) ) continue ; if ( used ) assignables + = <str> ; assignables + = i . getErasedType ( ) . getQualifiedSourceName ( ) + <str> ; used = true ; } if ( used ) assignables + = <str> ; else assignables = null ; } if ( c = = null ) { c = t . isInterface ( ) ; } if ( c ! = null & & c . getImplementedInterfaces ( ) ! = null ) { interfaces = <str> ; boolean used = false ; for ( JType i : c . getImplementedInterfaces ( ) ) { if ( ! isVisible ( i ) | | i . equals ( t ) ) continue ; if ( used ) interfaces + = <str> ; interfaces + = i . getErasedType ( ) . getQualifiedSourceName ( ) + <str> ; used = true ; } if ( used ) interfaces + = <str> ; else interfaces = null ; } String varName = <str> + id ; pb ( <str> + varName + <str> ) ; pb ( <str> + varName + <str> ) ; pb ( <str> + varName + <str> + varName + <str> ) ; pb ( varName + <str> + name + <str> + id + <str> + name + <str> + superClass + <str> + assignables + <str> + interfaces + <str> ) ; if ( c ! = null ) { if ( c . isEnum ( ) ! = null ) pb ( varName + <str> ) ; if ( c . isArray ( ) ! = null ) pb ( varName + <str> ) ; if ( c . isMemberType ( ) ) pb ( varName + <str> ) ; if ( c . isInterface ( ) ! = null ) { pb ( varName + <str> ) ; } else { pb ( varName + <str> + c . isStatic ( ) + <str> ) ; pb ( varName + <str> + c . isAbstract ( ) + <str> ) ; } if ( c . getFields ( ) ! = null & & c . getFields ( ) . length > <int> ) { pb ( varName + <str> ) ; for ( JField f : c . getFields ( ) ) { String enclosingType = getType ( c ) ; String fieldType = getType ( f . getType ( ) ) ; int setterGetter = nextSetterGetterId + + ; String elementType = getElementTypes ( f ) ; String annotations = getAnnotations ( f . getDeclaredAnnotations ( ) ) ; pb ( <str> + f . getName ( ) + <str> + enclosingType + <str> + fieldType + <str> + f . isFinal ( ) + <str> + f . isDefaultAccess ( ) + <str> + f . isPrivate ( ) + <str> + f . isProtected ( ) + <str> + f . isPublic ( ) + <str> + f . isStatic ( ) + <str> + f . isTransient ( ) + <str> + f . isVolatile ( ) + <str> + setterGetter + <str> + setterGetter + <str> + elementType + <str> + annotations + <str> ) ; SetterGetterStub stub = new SetterGetterStub ( ) ; stub . name = f . getName ( ) ; stub . enclosingType = enclosingType ; stub . type = fieldType ; stub . isStatic = f . isStatic ( ) ; stub . isFinal = f . isFinal ( ) ; if ( enclosingType ! = null & & fieldType ! = null ) { stub . getter = setterGetter ; stub . setter = setterGetter ; } setterGetterStubs . add ( stub ) ; } pb ( <str> ) ; } createTypeInvokables ( c , varName , <str> , c . getMethods ( ) ) ; if ( c . isPublic ( ) & & ! c . isAbstract ( ) & & ( c . getEnclosingType ( ) = = null | | c . isStatic ( ) ) ) { createTypeInvokables ( c , varName , <str> , c . getConstructors ( ) ) ; } else { logger . log ( Type . INFO , c . getName ( ) + <str> ) ; } if ( c . isArray ( ) ! = null ) { pb ( varName + <str> + getType ( c . isArray ( ) . getComponentType ( ) ) + <str> ) ; } if ( c . isEnum ( ) ! = null ) { JEnumConstant [ ] enumConstants = c . isEnum ( ) . getEnumConstants ( ) ; if ( enumConstants ! = null ) { pb ( varName + <str> + enumConstants . length + <str> ) ; for ( int i = <int> ; i < enumConstants . length ; i + + ) { pb ( varName + <str> + i + <str> + c . getErasedType ( ) . getQualifiedSourceName ( ) + <str> + enumConstants [ i ] . getName ( ) + <str> ) ; } } } Annotation [ ] annotations = c . getDeclaredAnnotations ( ) ; if ( annotations ! = null & & annotations . length > <int> ) { pb ( varName + <str> + getAnnotations ( annotations ) + <str> ) ; } } else if ( t . isAnnotation ( ) ! = null ) { pb ( varName + <str> ) ; } else { pb ( varName + <str> ) ; } pb ( <str> + varName + <str> ) ; pb ( <str> ) ; return buffer . toString ( ) ; } private void parameterInitialization ( ) { p ( <str> ) ; for ( Map . Entry < String , String > e : parameterName2ParameterInstantiation . entrySet ( ) ) { p ( <str> + e . getKey ( ) + <str> ) ; p ( <str> + e . getKey ( ) + <str> ) ; p ( <str> + e . getKey ( ) + <str> + e . getKey ( ) + <str> ) ; p ( <str> + e . getKey ( ) + <str> + e . getValue ( ) + <str> ) ; p ( <str> ) ; } } private void createTypeInvokables ( JClassType c , String varName , String methodType , JAbstractMethod [ ] methodTypes ) { if ( methodTypes ! = null & & methodTypes . length > <int> ) { pb ( varName + <str> + methodType . toLowerCase ( ) + <str> + methodType + <str> ) ; for ( JAbstractMethod m : methodTypes ) { MethodStub stub = new MethodStub ( ) ; stub . isPublic = m . isPublic ( ) ; stub . enclosingType = getType ( c ) ; if ( m . isMethod ( ) ! = null ) { stub . isMethod = true ; stub . returnType = getType ( m . isMethod ( ) . getReturnType ( ) ) ; stub . isStatic = m . isMethod ( ) . isStatic ( ) ; stub . isAbstract = m . isMethod ( ) . isAbstract ( ) ; stub . isNative = m . isMethod ( ) . isAbstract ( ) ; stub . isFinal = m . isMethod ( ) . isFinal ( ) ; } else { if ( m . isPrivate ( ) | | m . isDefaultAccess ( ) ) { logger . log ( Type . INFO , <str> + c . getName ( ) ) ; continue ; } if ( m . getEnclosingType ( ) . isFinal ( ) & & ! m . isPublic ( ) ) { logger . log ( Type . INFO , <str> + c . getName ( ) ) ; continue ; } stub . isConstructor = true ; stub . returnType = stub . enclosingType ; } stub . jnsi = <str> ; stub . methodId = nextInvokableId + + ; stub . name = m . getName ( ) ; methodStubs . add ( stub ) ; pbn ( <str> + methodType + <str> + m . getName ( ) + <str> ) ; pbn ( stub . enclosingType + <str> ) ; pbn ( stub . returnType + <str> ) ; if ( m . getParameters ( ) ! = null & & m . getParameters ( ) . length > <int> ) { pbn ( <str> ) ; for ( JParameter p : m . getParameters ( ) ) { stub . parameterTypes . add ( getType ( p . getType ( ) ) ) ; stub . jnsi + = p . getType ( ) . getErasedType ( ) . getJNISignature ( ) ; String paramName = ( p . getName ( ) + <str> + p . getType ( ) . getErasedType ( ) . getJNISignature ( ) ) . replaceAll ( <str> , <str> ) ; String paramInstantiation = <str> + p . getName ( ) + <str> + getType ( p . getType ( ) ) + <str> + p . getType ( ) . getJNISignature ( ) + <str> ; parameterName2ParameterInstantiation . put ( paramName , paramInstantiation ) ; pbn ( paramName + <str> ) ; } pbn ( <str> ) ; } else { pbn ( <str> ) ; } pb ( stub . isAbstract + <str> + stub . isFinal + <str> + stub . isStatic + <str> + m . isDefaultAccess ( ) + <str> + m . isPrivate ( ) + <str> + m . isProtected ( ) + <str> + m . isPublic ( ) + <str> + stub . isNative + <str> + m . isVarArgs ( ) + <str> + stub . isMethod + <str> + stub . isConstructor + <str> + stub . methodId + <str> + getAnnotations ( m . getDeclaredAnnotations ( ) ) + <str> ) ; } pb ( <str> ) ; } } private String getElementTypes ( JField f ) { StringBuilder b = new StringBuilder ( ) ; JParameterizedType params = f . getType ( ) . isParameterized ( ) ; if ( params ! = null ) { JClassType [ ] typeArgs = params . getTypeArgs ( ) ; b . append ( <str> ) ; for ( JClassType typeArg : typeArgs ) { if ( typeArg . isWildcard ( ) ! = null ) b . append ( <str> ) ; else if ( ! isVisible ( typeArg ) ) b . append ( <str> ) ; else if ( typeArg . isClassOrInterface ( ) ! = null ) b . append ( typeArg . isClassOrInterface ( ) . getQualifiedSourceName ( ) ) . append ( <str> ) ; else if ( typeArg . isParameterized ( ) ! = null ) b . append ( typeArg . isParameterized ( ) . getQualifiedBinaryName ( ) ) . append ( <str> ) ; else b . append ( <str> ) ; b . append ( <str> ) ; } b . append ( <str> ) ; return b . toString ( ) ; } return <str> ; } private String getAnnotations ( Annotation [ ] annotations ) { if ( annotations ! = null & & annotations . length > <int> ) { int numValidAnnotations = <int> ; final Class < ? > [ ] ignoredAnnotations = { Deprecated . class , Retention . class } ; StringBuilder b = new StringBuilder ( ) ; b . append ( <str> ) ; for ( Annotation annotation : annotations ) { Class < ? > type = annotation . annotationType ( ) ; boolean ignoredType = false ; for ( int i = <int> ; ! ignoredType & & i < ignoredAnnotations . length ; i + + ) { ignoredType = ignoredAnnotations [ i ] . equals ( type ) ; } if ( ignoredType ) { continue ; } Retention retention = type . getAnnotation ( Retention . class ) ; if ( retention = = null | | retention . value ( ) ! = RetentionPolicy . RUNTIME ) { continue ; } numValidAnnotations + + ; b . append ( <str> ) . append ( type . getCanonicalName ( ) ) . append ( <str> ) ; Method [ ] methods = type . getDeclaredMethods ( ) ; for ( Method method : methods ) { Class < ? > returnType = method . getReturnType ( ) ; b . append ( <str> ) ; b . append ( <str> ) . append ( returnType . getCanonicalName ( ) ) ; b . append ( <str> ) . append ( method . getName ( ) ) . append ( <str> ) ; if ( returnType . isArray ( ) ) { b . append ( <str> ) . append ( returnType . getCanonicalName ( ) ) . append ( <str> ) ; } Object invokeResult = null ; try { invokeResult = method . invoke ( annotation ) ; } catch ( IllegalAccessException e ) { logger . log ( Type . ERROR , <str> ) ; } catch ( InvocationTargetException e ) { logger . log ( Type . ERROR , <str> ) ; } if ( invokeResult ! = null ) { if ( returnType . equals ( String [ ] . class ) ) { for ( String s : ( String [ ] ) invokeResult ) { b . append ( <str> ) . append ( s ) . append ( <str> ) ; } } else if ( returnType . equals ( String . class ) ) { b . append ( <str> ) . append ( ( String ) invokeResult ) . append ( <str> ) ; } else if ( returnType . equals ( Class [ ] . class ) ) { for ( Class c : ( Class [ ] ) invokeResult ) { b . append ( <str> ) . append ( c . getCanonicalName ( ) ) . append ( <str> ) ; } } else if ( returnType . equals ( Class . class ) ) { b . append ( <str> ) . append ( ( ( Class ) invokeResult ) . getCanonicalName ( ) ) . append ( <str> ) ; } else if ( returnType . isArray ( ) & & returnType . getComponentType ( ) . isEnum ( ) ) { String enumTypeName = returnType . getComponentType ( ) . getCanonicalName ( ) ; int length = Array . getLength ( invokeResult ) ; for ( int i = <int> ; i < length ; i + + ) { Object e = Array . get ( invokeResult , i ) ; b . append ( <str> ) . append ( enumTypeName ) . append ( <str> ) . append ( e . toString ( ) ) . append ( <str> ) ; } } else if ( returnType . isEnum ( ) ) { b . append ( <str> ) . append ( returnType . getCanonicalName ( ) ) . append ( <str> ) . append ( invokeResult . toString ( ) ) ; } else if ( returnType . isArray ( ) & & returnType . getComponentType ( ) . isPrimitive ( ) ) { Class < ? > primitiveType = returnType . getComponentType ( ) ; int length = Array . getLength ( invokeResult ) ; for ( int i = <int> ; i < length ; i + + ) { Object n = Array . get ( invokeResult , i ) ; b . append ( <str> ) . append ( n . toString ( ) ) ; if ( primitiveType . equals ( float . class ) ) { b . append ( <str> ) ; } b . append ( <str> ) ; } } else if ( returnType . isPrimitive ( ) ) { b . append ( <str> ) . append ( invokeResult . toString ( ) ) ; if ( returnType . equals ( float . class ) ) { b . append ( <str> ) ; } } else { logger . log ( Type . ERROR , <str> ) ; } } if ( returnType . isArray ( ) ) { b . append ( <str> ) ; } b . append ( <str> ) ; b . append ( <str> ) ; } b . append ( <str> ) ; b . append ( type . getCanonicalName ( ) ) ; b . append ( <str> ) ; b . append ( <str> ) ; } b . append ( <str> ) ; return ( numValidAnnotations > <int> ) ? b . toString ( ) : <str> ; } return <str> ; } private String getType ( JType type ) { if ( ! isVisible ( type ) ) return null ; return type . getErasedType ( ) . getQualifiedSourceName ( ) + <str> ; } private void imports ( ClassSourceFileComposerFactory composer ) { composer . addImport ( <str> ) ; composer . addImport ( <str> ) ; composer . addImport ( <str> ) ; } private void invokeM ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; int subN = <int> ; int nDispatch = <int> ; for ( MethodStub stub : methodStubs ) { if ( stub . enclosingType = = null ) continue ; if ( stub . enclosingType . contains ( <str> ) ) continue ; if ( stub . returnType = = null ) continue ; if ( stub . unused ) continue ; boolean paramsOk = true ; for ( String paramType : stub . parameterTypes ) { if ( paramType = = null ) { paramsOk = false ; break ; } } if ( ! paramsOk ) continue ; buffer . setLength ( <int> ) ; pbn ( <str> + stub . methodId + <str> ) ; addParameters ( stub ) ; pbn ( <str> ) ; pc . add ( stub . methodId , buffer . toString ( ) ) ; nDispatch + + ; if ( nDispatch > <int> ) { pc . print ( ) ; pc = new SwitchedCodeBlock ( <str> ) ; subN + + ; p ( <str> + subN + <str> ) ; p ( <str> ) ; p ( <str> + subN + <str> ) ; nDispatch = <int> ; } } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private void addParameters ( MethodStub stub ) { if ( ! stub . isStatic & & ! stub . isConstructor ) pbn ( <str> + stub . enclosingType + <str> + ( stub . parameterTypes . size ( ) > <int> ? <str> : <str> ) ) ; for ( int i = <int> ; i < stub . parameterTypes . size ( ) ; i + + ) { pbn ( cast ( stub . parameterTypes . get ( i ) , <str> + i + <str> ) + ( i < stub . parameterTypes . size ( ) - <int> ? <str> : <str> ) ) ; } } private String cast ( String paramType , String arg ) { if ( paramType . equals ( <str> ) | | paramType . equals ( <str> ) | | paramType . equals ( <str> ) | | paramType . equals ( <str> ) | | paramType . equals ( <str> ) | | paramType . equals ( <str> ) ) { return <str> + arg + <str> + paramType + <str> ; } else if ( paramType . equals ( <str> ) ) { return <str> + arg + <str> + paramType + <str> ; } else if ( paramType . equals ( <str> ) ) { return <str> + arg + <str> + paramType + <str> ; } else { return <str> + paramType + <str> + arg + <str> ; } } private void setF ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( SetterGetterStub stub : setterGetterStubs ) { if ( stub . enclosingType = = null | | stub . type = = null | | stub . isFinal | | stub . unused ) continue ; pc . add ( stub . setter , <str> + stub . setter + <str> + cast ( stub . enclosingType , <str> ) + <str> + cast ( stub . type , <str> ) + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private void getF ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( SetterGetterStub stub : setterGetterStubs ) { if ( stub . enclosingType = = null | | stub . type = = null | | stub . unused ) continue ; pc . add ( stub . getter , <str> + stub . getter + <str> + cast ( stub . enclosingType , <str> ) + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private static boolean isInstantiableWithNewOperator ( JClassType t ) { if ( ! t . isDefaultInstantiable ( ) | | t instanceof JArrayType | | t instanceof JEnumType ) return false ; try { JConstructor constructor = t . getConstructor ( new JType [ <int> ] ) ; return constructor ! = null & & constructor . isPublic ( ) ; } catch ( NotFoundException e ) { return false ; } } private void setArrayElementT ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( String s : PRIMITIVE_TYPES ) { if ( ! typeNames2typeIds . containsKey ( s + <str> ) ) continue ; pc . add ( typeNames2typeIds . get ( s + <str> ) , <str> + s + <str> + cast ( s , <str> ) + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private void getArrayElementT ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( String s : PRIMITIVE_TYPES ) { if ( ! typeNames2typeIds . containsKey ( s + <str> ) ) continue ; pc . add ( typeNames2typeIds . get ( s + <str> ) , <str> + s + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private void getArrayLengthT ( ) { p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( String s : PRIMITIVE_TYPES ) { if ( ! typeNames2typeIds . containsKey ( s + <str> ) ) continue ; pc . add ( typeNames2typeIds . get ( s + <str> ) , <str> + s + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; } private void newArrayC ( ) { p ( <str> ) ; p ( <str> ) ; SwitchedCodeBlock pc = new SwitchedCodeBlock ( <str> ) ; for ( JType type : types ) { if ( type . getQualifiedSourceName ( ) . equals ( <str> ) ) continue ; if ( type . getQualifiedSourceName ( ) . endsWith ( <str> ) ) continue ; String arrayType = type . getErasedType ( ) . getQualifiedSourceName ( ) + <str> ; if ( arrayType . contains ( <str> ) ) { arrayType = type . getErasedType ( ) . getQualifiedSourceName ( ) ; arrayType = arrayType . replaceFirst ( <str> , <str> ) + <str> ; } pc . add ( typeNames2typeIds . get ( type . getQualifiedSourceName ( ) ) , <str> + arrayType + <str> ) ; } pc . print ( ) ; p ( <str> ) ; p ( <str> ) ; p ( <str> ) ; } private void forNameC ( ) { p ( <str> ) ; p ( <str> ) ; int i = <int> ; SwitchedCodeBlockByString cb = new SwitchedCodeBlockByString ( <str> , <str> ) ; for ( String typeName : typeNames2typeIds . keySet ( ) ) { cb . add ( typeName , <str> + typeNames2typeIds . get ( typeName ) + <str> ) ; i + + ; if ( i % <int> = = <int> ) { cb . print ( ) ; cb = new SwitchedCodeBlockByString ( <str> , <str> ) ; p ( <str> + i + <str> ) ; p ( <str> ) ; p ( <str> + i + ( <str> ) ) ; } } cb . print ( ) ; p ( <str> ) ; p ( <str> ) ; } void p ( String line ) { sw . println ( line ) ; source . append ( line ) ; source . append ( <str> ) ; } void pn ( String line ) { sw . print ( line ) ; source . append ( line ) ; } StringBuffer buffer = new StringBuffer ( ) ; void pb ( String line ) { buffer . append ( line ) ; buffer . append ( <str> ) ; } private void pbn ( String line ) { buffer . append ( line ) ; } class SwitchedCodeBlock { private List < KeyedCodeBlock > blocks = new ArrayList < KeyedCodeBlock > ( ) ; private final String switchStatement ; SwitchedCodeBlock ( String switchStatement ) { this . switchStatement = switchStatement ; } void add ( int key , String codeBlock ) { KeyedCodeBlock b = new KeyedCodeBlock ( ) ; b . key = key ; b . codeBlock = codeBlock ; blocks . add ( b ) ; } void print ( ) { if ( blocks . isEmpty ( ) ) return ; p ( <str> + switchStatement + <str> ) ; for ( KeyedCodeBlock b : blocks ) { p ( <str> + b . key + <str> + b . codeBlock ) ; } p ( <str> ) ; } class KeyedCodeBlock { int key ; String codeBlock ; } } class SwitchedCodeBlockByString { private Map < String , List < KeyedCodeBlock > > blocks = new HashMap < String , List < KeyedCodeBlock > > ( ) ; private final String switchStatement ; private final String expectedValue ; SwitchedCodeBlockByString ( String switchStatement , String expectedValue ) { this . switchStatement = switchStatement ; this . expectedValue = expectedValue ; } void add ( String key , String codeBlock ) { KeyedCodeBlock b = new KeyedCodeBlock ( ) ; b . key = key ; b . codeBlock = codeBlock ; List < KeyedCodeBlock > blockList = blocks . get ( key ) ; if ( blockList = = null ) { blockList = new ArrayList < KeyedCodeBlock > ( ) ; blocks . put ( key , blockList ) ; } blockList . add ( b ) ; } void print ( ) { if ( blocks . isEmpty ( ) ) return ; p ( <str> + switchStatement + <str> ) ; for ( String key : blocks . keySet ( ) ) { p ( <str> + key . hashCode ( ) + <str> ) ; for ( KeyedCodeBlock block : blocks . get ( key ) ) { p ( <str> + expectedValue + <str> + block . key + <str> + block . codeBlock ) ; p ( <str> ) ; } } p ( <str> ) ; } class KeyedCodeBlock { String key ; String codeBlock ; } } } 
