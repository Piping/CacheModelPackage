package org . apache . cassandra . utils ; import java . math . BigInteger ; import java . util . * ; import com . google . common . collect . AbstractIterator ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . MerkleTree . Hashable ; import org . apache . cassandra . utils . MerkleTree . RowHash ; import org . apache . cassandra . utils . MerkleTree . TreeRange ; import org . apache . cassandra . utils . MerkleTrees . TreeRangeIterator ; import static org . junit . Assert . * ; public class MerkleTreesTest { public static byte [ ] DUMMY = <str> . getBytes ( ) ; public static BigInteger TOKEN_SCALE = new BigInteger ( <str> ) ; protected static final IPartitioner partitioner = RandomPartitioner . instance ; protected MerkleTrees mts ; private Range < Token > fullRange ( ) { return new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getMinimumToken ( ) ) ; } @BeforeClass public static void setUp ( ) { StorageService . instance . setPartitionerUnsafe ( partitioner ) ; } @Before public void clear ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTree ( Integer . MAX_VALUE , fullRange ( ) ) ; } public static void assertHashEquals ( final byte [ ] left , final byte [ ] right ) { assertHashEquals ( <str> , left , right ) ; } public static void assertHashEquals ( String message , final byte [ ] left , final byte [ ] right ) { String lstring = left = = null ? <str> : Hex . bytesToHex ( left ) ; String rstring = right = = null ? <str> : Hex . bytesToHex ( right ) ; assertEquals ( message , lstring , rstring ) ; } public static Token tok ( int i ) { if ( i = = - <int> ) return new BigIntegerToken ( new BigInteger ( <str> ) ) ; BigInteger bint = RandomPartitioner . MAXIMUM . divide ( TOKEN_SCALE ) . multiply ( new BigInteger ( <str> + i ) ) ; return new BigIntegerToken ( bint ) ; } @Test public void testIntersectingRanges ( ) { mts = new MerkleTrees ( partitioner ) ; boolean failure = true ; mts . addMerkleTree ( <int> , new Range < > ( tok ( <int> ) , tok ( <int> ) ) ) ; try { mts . addMerkleTree ( <int> , new Range < > ( tok ( <int> ) , tok ( <int> ) ) ) ; } catch ( AssertionError e ) { failure = false ; } assertFalse ( failure ) ; } @Test public void testSplit ( ) { mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; assertEquals ( <int> , mts . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mts . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; assertEquals ( ( byte ) <int> , mts . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mts . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mts . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mts . get ( tok ( - <int> ) ) . depth ) ; try { mts . split ( tok ( - <int> ) ) ; fail ( <str> ) ; } catch ( AssertionError e ) { } } @Test public void testSplitLimitDepth ( ) { mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTree ( Integer . MAX_VALUE , ( byte ) <int> , fullRange ( ) ) ; assertTrue ( mts . split ( tok ( <int> ) ) ) ; assertTrue ( mts . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mts . size ( ) ) ; assertFalse ( mts . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mts . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mts . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; } @Test public void testSplitLimitSize ( ) { mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTree ( <int> , fullRange ( ) ) ; assertTrue ( mts . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mts . size ( ) ) ; assertFalse ( mts . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mts . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mts . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mts . get ( tok ( <int> ) ) ) ; } @Test public void testInvalids ( ) { Iterator < TreeRange > ranges ; ranges = mts . invalids ( ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertFalse ( ranges . hasNext ( ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; ranges = mts . invalids ( ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertFalse ( ranges . hasNext ( ) ) ; } @Test public void testHashFull ( ) { byte [ ] val = DUMMY ; Range < Token > range = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; assertNull ( mts . hash ( range ) ) ; mts . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( val , mts . hash ( range ) ) ; } @Test public void testHashPartial ( ) { byte [ ] val = DUMMY ; byte [ ] leftval = hashed ( val , <int> , <int> ) ; byte [ ] partialval = hashed ( val , <int> ) ; Range < Token > left = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > partial = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; Range < Token > right = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; Range < Token > linvalid = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; Range < Token > rinvalid = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; assertNull ( mts . hash ( left ) ) ; assertNull ( mts . hash ( partial ) ) ; assertNull ( mts . hash ( right ) ) ; assertNull ( mts . hash ( linvalid ) ) ; assertNull ( mts . hash ( rinvalid ) ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( leftval , mts . hash ( left ) ) ; assertHashEquals ( partialval , mts . hash ( partial ) ) ; assertHashEquals ( val , mts . hash ( right ) ) ; assertNull ( mts . hash ( linvalid ) ) ; assertNull ( mts . hash ( rinvalid ) ) ; } @Test public void testHashInner ( ) { byte [ ] val = DUMMY ; byte [ ] lchildval = hashed ( val , <int> , <int> , <int> ) ; byte [ ] rchildval = hashed ( val , <int> , <int> ) ; byte [ ] fullval = hashed ( val , <int> , <int> , <int> , <int> , <int> ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Range < Token > lchild = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > rchild = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; Range < Token > invalid = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; assertNull ( mts . hash ( full ) ) ; assertNull ( mts . hash ( lchild ) ) ; assertNull ( mts . hash ( rchild ) ) ; assertNull ( mts . hash ( invalid ) ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( fullval , mts . hash ( full ) ) ; assertHashEquals ( lchildval , mts . hash ( lchild ) ) ; assertHashEquals ( rchildval , mts . hash ( rchild ) ) ; assertNull ( mts . hash ( invalid ) ) ; } @Test public void testHashDegenerate ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; byte [ ] val = DUMMY ; byte [ ] childfullval = hashed ( val , <int> , <int> , <int> ) ; byte [ ] fullval = hashed ( val , <int> , <int> , <int> , <int> , <int> , <int> ) ; Range < Token > childfull = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Range < Token > invalid = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; assertNull ( mts . hash ( full ) ) ; assertNull ( mts . hash ( childfull ) ) ; assertNull ( mts . hash ( invalid ) ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( <int> ) ) . hash ( val ) ; mts . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( fullval , mts . hash ( full ) ) ; assertHashEquals ( childfullval , mts . hash ( childfull ) ) ; assertNull ( mts . hash ( invalid ) ) ; } @Test public void testHashRandom ( ) { int max = <int> ; TOKEN_SCALE = new BigInteger ( <str> + max ) ; mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTree ( <int> , fullRange ( ) ) ; Random random = new Random ( ) ; while ( true ) { if ( ! mts . split ( tok ( random . nextInt ( max ) ) ) ) break ; } TreeRangeIterator ranges = mts . invalids ( ) ; for ( TreeRange range : ranges ) range . addHash ( new RowHash ( range . right , new byte [ <int> ] , <int> ) ) ; assert mts . hash ( new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ) ! = null : <str> + mts ; } @Test public void testValidateTree ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Iterator < TreeRange > ranges ; MerkleTrees mts2 = new MerkleTrees ( partitioner ) ; mts2 . addMerkleTree ( Integer . MAX_VALUE , fullRange ( ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; mts . split ( tok ( <int> ) ) ; ranges = mts . invalids ( ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , - <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; mts2 . split ( tok ( <int> ) ) ; ranges = mts2 . invalids ( ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , - <int> ) ) ; byte [ ] mthash = mts . hash ( full ) ; byte [ ] mt2hash = mts2 . hash ( full ) ; assertHashEquals ( <str> + mts + <str> + mts2 , mthash , mt2hash ) ; } @Test public void testSerialization ( ) throws Exception { Range < Token > first = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; Collection < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( first ) ; ranges . add ( new Range < Token > ( tok ( <int> ) , tok ( <int> ) ) ) ; mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTrees ( <int> , ranges ) ; mts . init ( ) ; for ( TreeRange range : mts . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; byte [ ] initialhash = mts . hash ( first ) ; long serializedSize = MerkleTrees . serializer . serializedSize ( mts , MessagingService . current_version ) ; DataOutputBuffer out = new DataOutputBuffer ( ) ; MerkleTrees . serializer . serialize ( mts , out , MessagingService . current_version ) ; byte [ ] serialized = out . toByteArray ( ) ; assertEquals ( serializedSize , serialized . length ) ; DataInputBuffer in = new DataInputBuffer ( serialized ) ; MerkleTrees restored = MerkleTrees . serializer . deserialize ( in , MessagingService . current_version ) ; assertHashEquals ( initialhash , restored . hash ( first ) ) ; } @Test public void testDifference ( ) { int maxsize = <int> ; mts = new MerkleTrees ( partitioner ) ; mts . addMerkleTree ( <int> , fullRange ( ) ) ; MerkleTrees mts2 = new MerkleTrees ( partitioner ) ; mts2 . addMerkleTree ( <int> , fullRange ( ) ) ; mts . init ( ) ; mts2 . init ( ) ; for ( TreeRange range : mts . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; for ( TreeRange range : mts2 . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; TreeRange leftmost = null ; TreeRange middle = null ; mts . maxsize ( fullRange ( ) , maxsize + <int> ) ; Iterator < TreeRange > ranges = mts . invalids ( ) ; leftmost = ranges . next ( ) ; mts . split ( leftmost . right ) ; middle = mts . get ( leftmost . right ) ; middle . hash ( <str> . getBytes ( ) ) ; mts . get ( partitioner . midpoint ( leftmost . left , leftmost . right ) ) . hash ( <str> . getBytes ( ) ) ; List < Range < Token > > diffs = MerkleTrees . difference ( mts , mts2 ) ; assertEquals ( diffs + <str> , <int> , diffs . size ( ) ) ; assertTrue ( diffs . contains ( new Range < > ( leftmost . left , middle . right ) ) ) ; } byte [ ] hashed ( byte [ ] val , Integer . . . depths ) { ArrayDeque < Integer > dstack = new ArrayDeque < Integer > ( ) ; ArrayDeque < byte [ ] > hstack = new ArrayDeque < byte [ ] > ( ) ; Iterator < Integer > depthiter = Arrays . asList ( depths ) . iterator ( ) ; if ( depthiter . hasNext ( ) ) { dstack . push ( depthiter . next ( ) ) ; hstack . push ( val ) ; } while ( depthiter . hasNext ( ) ) { Integer depth = depthiter . next ( ) ; byte [ ] hash = val ; while ( depth . equals ( dstack . peek ( ) ) ) { hash = Hashable . binaryHash ( hstack . pop ( ) , hash ) ; depth = dstack . pop ( ) - <int> ; } dstack . push ( depth ) ; hstack . push ( hash ) ; } assert hstack . size ( ) = = <int> ; return hstack . pop ( ) ; } static class HIterator extends AbstractIterator < RowHash > { private Iterator < Token > tokens ; public HIterator ( int . . . tokens ) { List < Token > tlist = new LinkedList < Token > ( ) ; for ( int token : tokens ) tlist . add ( tok ( token ) ) ; this . tokens = tlist . iterator ( ) ; } public HIterator ( Token . . . tokens ) { this . tokens = Arrays . asList ( tokens ) . iterator ( ) ; } public RowHash computeNext ( ) { if ( tokens . hasNext ( ) ) return new RowHash ( tokens . next ( ) , DUMMY , DUMMY . length ) ; return endOfData ( ) ; } } } 
