package org . elasticsearch . repositories . blobstore ; import org . apache . lucene . store . RateLimiter ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . blobstore . BlobContainer ; import org . elasticsearch . common . blobstore . BlobMetaData ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . BlobStore ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . compress . NotXContentException ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . OutputStreamStreamOutput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . snapshots . blobstore . BlobStoreIndexShardRepository ; import org . elasticsearch . index . snapshots . blobstore . BlobStoreIndexShardRepository . RateLimiterListener ; import org . elasticsearch . repositories . Repository ; import org . elasticsearch . repositories . RepositoryException ; import org . elasticsearch . repositories . RepositorySettings ; import org . elasticsearch . repositories . RepositoryVerificationException ; import org . elasticsearch . snapshots . InvalidSnapshotNameException ; import org . elasticsearch . snapshots . Snapshot ; import org . elasticsearch . snapshots . SnapshotCreationException ; import org . elasticsearch . snapshots . SnapshotException ; import org . elasticsearch . snapshots . SnapshotMissingException ; import org . elasticsearch . snapshots . SnapshotShardFailure ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public abstract class BlobStoreRepository extends AbstractLifecycleComponent < Repository > implements Repository , RateLimiterListener { private BlobContainer snapshotsBlobContainer ; protected final String repositoryName ; private static final String LEGACY_SNAPSHOT_PREFIX = <str> ; private static final String SNAPSHOT_PREFIX = <str> ; private static final String SNAPSHOT_SUFFIX = <str> ; private static final String COMMON_SNAPSHOT_PREFIX = <str> ; private static final String SNAPSHOT_CODEC = <str> ; private static final String SNAPSHOTS_FILE = <str> ; private static final String TESTS_FILE = <str> ; private static final String METADATA_NAME_FORMAT = <str> ; private static final String LEGACY_METADATA_NAME_FORMAT = <str> ; private static final String METADATA_CODEC = <str> ; private static final String INDEX_METADATA_CODEC = <str> ; private static final String SNAPSHOT_NAME_FORMAT = SNAPSHOT_PREFIX + <str> + SNAPSHOT_SUFFIX ; private static final String LEGACY_SNAPSHOT_NAME_FORMAT = LEGACY_SNAPSHOT_PREFIX + <str> ; private final BlobStoreIndexShardRepository indexShardRepository ; private final RateLimiter snapshotRateLimiter ; private final RateLimiter restoreRateLimiter ; private final CounterMetric snapshotRateLimitingTimeInNanos = new CounterMetric ( ) ; private final CounterMetric restoreRateLimitingTimeInNanos = new CounterMetric ( ) ; private ChecksumBlobStoreFormat < MetaData > globalMetaDataFormat ; private LegacyBlobStoreFormat < MetaData > globalMetaDataLegacyFormat ; private ChecksumBlobStoreFormat < IndexMetaData > indexMetaDataFormat ; private LegacyBlobStoreFormat < IndexMetaData > indexMetaDataLegacyFormat ; private ChecksumBlobStoreFormat < Snapshot > snapshotFormat ; private LegacyBlobStoreFormat < Snapshot > snapshotLegacyFormat ; private final boolean readOnly ; protected BlobStoreRepository ( String repositoryName , RepositorySettings repositorySettings , IndexShardRepository indexShardRepository ) { super ( repositorySettings . globalSettings ( ) ) ; this . repositoryName = repositoryName ; this . indexShardRepository = ( BlobStoreIndexShardRepository ) indexShardRepository ; snapshotRateLimiter = getRateLimiter ( repositorySettings , <str> , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; restoreRateLimiter = getRateLimiter ( repositorySettings , <str> , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; readOnly = repositorySettings . settings ( ) . getAsBoolean ( <str> , false ) ; } @Override protected void doStart ( ) { this . snapshotsBlobContainer = blobStore ( ) . blobContainer ( basePath ( ) ) ; indexShardRepository . initialize ( blobStore ( ) , basePath ( ) , chunkSize ( ) , snapshotRateLimiter , restoreRateLimiter , this , isCompress ( ) ) ; ParseFieldMatcher parseFieldMatcher = new ParseFieldMatcher ( settings ) ; globalMetaDataFormat = new ChecksumBlobStoreFormat < > ( METADATA_CODEC , METADATA_NAME_FORMAT , MetaData . PROTO , parseFieldMatcher , isCompress ( ) ) ; globalMetaDataLegacyFormat = new LegacyBlobStoreFormat < > ( LEGACY_METADATA_NAME_FORMAT , MetaData . PROTO , parseFieldMatcher ) ; indexMetaDataFormat = new ChecksumBlobStoreFormat < > ( INDEX_METADATA_CODEC , METADATA_NAME_FORMAT , IndexMetaData . PROTO , parseFieldMatcher , isCompress ( ) ) ; indexMetaDataLegacyFormat = new LegacyBlobStoreFormat < > ( LEGACY_SNAPSHOT_NAME_FORMAT , IndexMetaData . PROTO , parseFieldMatcher ) ; snapshotFormat = new ChecksumBlobStoreFormat < > ( SNAPSHOT_CODEC , SNAPSHOT_NAME_FORMAT , Snapshot . PROTO , parseFieldMatcher , isCompress ( ) ) ; snapshotLegacyFormat = new LegacyBlobStoreFormat < > ( LEGACY_SNAPSHOT_NAME_FORMAT , Snapshot . PROTO , parseFieldMatcher ) ; } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { try { blobStore ( ) . close ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } abstract protected BlobStore blobStore ( ) ; abstract protected BlobPath basePath ( ) ; protected boolean isCompress ( ) { return false ; } protected ByteSizeValue chunkSize ( ) { return null ; } @Override public void initializeSnapshot ( SnapshotId snapshotId , List < String > indices , MetaData metaData ) { if ( readOnly ( ) ) { throw new RepositoryException ( this . repositoryName , <str> ) ; } try { if ( snapshotFormat . exists ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) | | snapshotLegacyFormat . exists ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } globalMetaDataFormat . write ( metaData , snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; for ( String index : indices ) { final IndexMetaData indexMetaData = metaData . index ( index ) ; final BlobPath indexPath = basePath ( ) . add ( <str> ) . add ( index ) ; final BlobContainer indexMetaDataBlobContainer = blobStore ( ) . blobContainer ( indexPath ) ; indexMetaDataFormat . write ( indexMetaData , indexMetaDataBlobContainer , snapshotId . getSnapshot ( ) ) ; } } catch ( IOException ex ) { throw new SnapshotCreationException ( snapshotId , ex ) ; } } @Override public void deleteSnapshot ( SnapshotId snapshotId ) { if ( readOnly ( ) ) { throw new RepositoryException ( this . repositoryName , <str> ) ; } List < String > indices = Collections . emptyList ( ) ; Snapshot snapshot = null ; try { snapshot = readSnapshot ( snapshotId ) ; indices = snapshot . indices ( ) ; } catch ( SnapshotMissingException ex ) { throw ex ; } catch ( IllegalStateException | SnapshotException | ElasticsearchParseException ex ) { logger . warn ( <str> , ex , snapshotId ) ; } MetaData metaData = null ; try { if ( snapshot ! = null ) { metaData = readSnapshotMetaData ( snapshotId , snapshot . version ( ) , indices , true ) ; } else { metaData = readSnapshotMetaData ( snapshotId , null , indices , true ) ; } } catch ( IOException | SnapshotException ex ) { logger . warn ( <str> , ex , snapshotId ) ; } try { if ( snapshot ! = null ) { snapshotFormat ( snapshot . version ( ) ) . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; globalMetaDataFormat ( snapshot . version ( ) ) . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; } else { snapshotFormat . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; snapshotLegacyFormat . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; globalMetaDataLegacyFormat . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; globalMetaDataFormat . delete ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; } List < SnapshotId > snapshotIds = snapshots ( ) ; if ( snapshotIds . contains ( snapshotId ) ) { List < SnapshotId > builder = new ArrayList < > ( ) ; for ( SnapshotId id : snapshotIds ) { if ( ! snapshotId . equals ( id ) ) { builder . add ( id ) ; } } snapshotIds = Collections . unmodifiableList ( builder ) ; } writeSnapshotList ( snapshotIds ) ; for ( String index : indices ) { BlobPath indexPath = basePath ( ) . add ( <str> ) . add ( index ) ; BlobContainer indexMetaDataBlobContainer = blobStore ( ) . blobContainer ( indexPath ) ; try { indexMetaDataFormat ( snapshot . version ( ) ) . delete ( indexMetaDataBlobContainer , snapshotId . getSnapshot ( ) ) ; } catch ( IOException ex ) { logger . warn ( <str> , ex , snapshotId , index ) ; } if ( metaData ! = null ) { IndexMetaData indexMetaData = metaData . index ( index ) ; if ( indexMetaData ! = null ) { for ( int i = <int> ; i < indexMetaData . getNumberOfShards ( ) ; i + + ) { ShardId shardId = new ShardId ( index , i ) ; try { indexShardRepository . delete ( snapshotId , snapshot . version ( ) , shardId ) ; } catch ( SnapshotException ex ) { logger . warn ( <str> , ex , snapshotId , shardId ) ; } } } } } } catch ( IOException ex ) { throw new RepositoryException ( this . repositoryName , <str> , ex ) ; } } @Override public Snapshot finalizeSnapshot ( SnapshotId snapshotId , List < String > indices , long startTime , String failure , int totalShards , List < SnapshotShardFailure > shardFailures ) { try { Snapshot blobStoreSnapshot = new Snapshot ( snapshotId . getSnapshot ( ) , indices , startTime , failure , System . currentTimeMillis ( ) , totalShards , shardFailures ) ; snapshotFormat . write ( blobStoreSnapshot , snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; List < SnapshotId > snapshotIds = snapshots ( ) ; if ( ! snapshotIds . contains ( snapshotId ) ) { snapshotIds = new ArrayList < > ( snapshotIds ) ; snapshotIds . add ( snapshotId ) ; snapshotIds = Collections . unmodifiableList ( snapshotIds ) ; } writeSnapshotList ( snapshotIds ) ; return blobStoreSnapshot ; } catch ( IOException ex ) { throw new RepositoryException ( this . repositoryName , <str> , ex ) ; } } @Override public List < SnapshotId > snapshots ( ) { try { List < SnapshotId > snapshots = new ArrayList < > ( ) ; Map < String , BlobMetaData > blobs ; try { blobs = snapshotsBlobContainer . listBlobsByPrefix ( COMMON_SNAPSHOT_PREFIX ) ; } catch ( UnsupportedOperationException ex ) { return readSnapshotList ( ) ; } int prefixLength = SNAPSHOT_PREFIX . length ( ) ; int suffixLength = SNAPSHOT_SUFFIX . length ( ) ; int legacyPrefixLength = LEGACY_SNAPSHOT_PREFIX . length ( ) ; for ( BlobMetaData md : blobs . values ( ) ) { String blobName = md . name ( ) ; final String name ; if ( blobName . startsWith ( SNAPSHOT_PREFIX ) & & blobName . length ( ) > legacyPrefixLength ) { name = blobName . substring ( prefixLength , blobName . length ( ) - suffixLength ) ; } else if ( blobName . startsWith ( LEGACY_SNAPSHOT_PREFIX ) & & blobName . length ( ) > suffixLength + prefixLength ) { name = blobName . substring ( legacyPrefixLength ) ; } else { continue ; } snapshots . add ( new SnapshotId ( repositoryName , name ) ) ; } return Collections . unmodifiableList ( snapshots ) ; } catch ( IOException ex ) { throw new RepositoryException ( repositoryName , <str> , ex ) ; } } @Override public MetaData readSnapshotMetaData ( SnapshotId snapshotId , Snapshot snapshot , List < String > indices ) throws IOException { return readSnapshotMetaData ( snapshotId , snapshot . version ( ) , indices , false ) ; } @Override public Snapshot readSnapshot ( SnapshotId snapshotId ) { try { return snapshotFormat . read ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; } catch ( FileNotFoundException | NoSuchFileException ex ) { try { return snapshotLegacyFormat . read ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; } catch ( FileNotFoundException | NoSuchFileException ex1 ) { throw new SnapshotMissingException ( snapshotId , ex ) ; } catch ( IOException | NotXContentException ex1 ) { throw new SnapshotException ( snapshotId , <str> , ex1 ) ; } } catch ( IOException | NotXContentException ex ) { throw new SnapshotException ( snapshotId , <str> , ex ) ; } } private MetaData readSnapshotMetaData ( SnapshotId snapshotId , Version snapshotVersion , List < String > indices , boolean ignoreIndexErrors ) throws IOException { MetaData metaData ; if ( snapshotVersion = = null ) { assert ignoreIndexErrors ; if ( globalMetaDataFormat . exists ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ) { snapshotVersion = Version . CURRENT ; } else if ( globalMetaDataLegacyFormat . exists ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ) { snapshotVersion = Version . V_1_0_0 ; } else { throw new SnapshotMissingException ( snapshotId ) ; } } try { metaData = globalMetaDataFormat ( snapshotVersion ) . read ( snapshotsBlobContainer , snapshotId . getSnapshot ( ) ) ; } catch ( FileNotFoundException | NoSuchFileException ex ) { throw new SnapshotMissingException ( snapshotId , ex ) ; } catch ( IOException ex ) { throw new SnapshotException ( snapshotId , <str> , ex ) ; } MetaData . Builder metaDataBuilder = MetaData . builder ( metaData ) ; for ( String index : indices ) { BlobPath indexPath = basePath ( ) . add ( <str> ) . add ( index ) ; BlobContainer indexMetaDataBlobContainer = blobStore ( ) . blobContainer ( indexPath ) ; try { metaDataBuilder . put ( indexMetaDataFormat ( snapshotVersion ) . read ( indexMetaDataBlobContainer , snapshotId . getSnapshot ( ) ) , false ) ; } catch ( ElasticsearchParseException | IOException ex ) { if ( ignoreIndexErrors ) { logger . warn ( <str> , snapshotId , index , ex ) ; } else { throw ex ; } } } return metaDataBuilder . build ( ) ; } private RateLimiter getRateLimiter ( RepositorySettings repositorySettings , String setting , ByteSizeValue defaultRate ) { ByteSizeValue maxSnapshotBytesPerSec = repositorySettings . settings ( ) . getAsBytesSize ( setting , settings . getAsBytesSize ( setting , defaultRate ) ) ; if ( maxSnapshotBytesPerSec . bytes ( ) < = <int> ) { return null ; } else { return new RateLimiter . SimpleRateLimiter ( maxSnapshotBytesPerSec . mbFrac ( ) ) ; } } private BlobStoreFormat < MetaData > globalMetaDataFormat ( Version version ) { if ( legacyMetaData ( version ) ) { return globalMetaDataLegacyFormat ; } else { return globalMetaDataFormat ; } } private BlobStoreFormat < Snapshot > snapshotFormat ( Version version ) { if ( legacyMetaData ( version ) ) { return snapshotLegacyFormat ; } else { return snapshotFormat ; } } public static boolean legacyMetaData ( Version version ) { return version . before ( Version . V_2_0_0_beta1 ) ; } private BlobStoreFormat < IndexMetaData > indexMetaDataFormat ( Version version ) { if ( legacyMetaData ( version ) ) { return indexMetaDataLegacyFormat ; } else { return indexMetaDataFormat ; } } protected void writeSnapshotList ( List < SnapshotId > snapshots ) throws IOException { final BytesReference bRef ; try ( BytesStreamOutput bStream = new BytesStreamOutput ( ) ) { try ( StreamOutput stream = new OutputStreamStreamOutput ( bStream ) ) { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON , stream ) ; builder . startObject ( ) ; builder . startArray ( <str> ) ; for ( SnapshotId snapshot : snapshots ) { builder . value ( snapshot . getSnapshot ( ) ) ; } builder . endArray ( ) ; builder . endObject ( ) ; builder . close ( ) ; } bRef = bStream . bytes ( ) ; } if ( snapshotsBlobContainer . blobExists ( SNAPSHOTS_FILE ) ) { snapshotsBlobContainer . deleteBlob ( SNAPSHOTS_FILE ) ; } snapshotsBlobContainer . writeBlob ( SNAPSHOTS_FILE , bRef ) ; } protected List < SnapshotId > readSnapshotList ( ) throws IOException { try ( InputStream blob = snapshotsBlobContainer . readBlob ( SNAPSHOTS_FILE ) ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; Streams . copy ( blob , out ) ; ArrayList < SnapshotId > snapshots = new ArrayList < > ( ) ; try ( XContentParser parser = XContentHelper . createParser ( out . bytes ( ) ) ) { if ( parser . nextToken ( ) = = XContentParser . Token . START_OBJECT ) { if ( parser . nextToken ( ) = = XContentParser . Token . FIELD_NAME ) { String currentFieldName = parser . currentName ( ) ; if ( <str> . equals ( currentFieldName ) ) { if ( parser . nextToken ( ) = = XContentParser . Token . START_ARRAY ) { while ( parser . nextToken ( ) ! = XContentParser . Token . END_ARRAY ) { snapshots . add ( new SnapshotId ( repositoryName , parser . text ( ) ) ) ; } } } } } } return Collections . unmodifiableList ( snapshots ) ; } } @Override public void onRestorePause ( long nanos ) { restoreRateLimitingTimeInNanos . inc ( nanos ) ; } @Override public void onSnapshotPause ( long nanos ) { snapshotRateLimitingTimeInNanos . inc ( nanos ) ; } @Override public long snapshotThrottleTimeInNanos ( ) { return snapshotRateLimitingTimeInNanos . count ( ) ; } @Override public long restoreThrottleTimeInNanos ( ) { return restoreRateLimitingTimeInNanos . count ( ) ; } @Override public String startVerification ( ) { try { if ( readOnly ( ) ) { return null ; } else { String seed = Strings . randomBase64UUID ( ) ; byte [ ] testBytes = Strings . toUTF8Bytes ( seed ) ; BlobContainer testContainer = blobStore ( ) . blobContainer ( basePath ( ) . add ( testBlobPrefix ( seed ) ) ) ; String blobName = <str> ; testContainer . writeBlob ( blobName + <str> , new BytesArray ( testBytes ) ) ; testContainer . move ( blobName + <str> , blobName ) ; return seed ; } } catch ( IOException exp ) { throw new RepositoryVerificationException ( repositoryName , <str> + basePath ( ) + <str> , exp ) ; } } @Override public void endVerification ( String seed ) { if ( readOnly ( ) ) { throw new UnsupportedOperationException ( <str> ) ; } try { blobStore ( ) . delete ( basePath ( ) . add ( testBlobPrefix ( seed ) ) ) ; } catch ( IOException exp ) { throw new RepositoryVerificationException ( repositoryName , <str> + basePath ( ) , exp ) ; } } public static String testBlobPrefix ( String seed ) { return TESTS_FILE + seed ; } @Override public boolean readOnly ( ) { return readOnly ; } } 
