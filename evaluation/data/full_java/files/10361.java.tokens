package com . google . common . collect ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . TestMapGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class ImmutableClassToInstanceMapTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableClassToInstanceMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestClassToInstanceMapGenerator ( ) { @Override @SuppressWarnings ( <str> ) public Map < Class , Number > create ( Object . . . elements ) { ImmutableClassToInstanceMap . Builder < Number > builder = ImmutableClassToInstanceMap . builder ( ) ; for ( Object object : elements ) { Entry < Class , Number > entry = ( Entry < Class , Number > ) object ; builder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ( Map ) builder . build ( ) ; } } ) . named ( <str> ) . withFeatures ( MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . RESTRICTS_KEYS , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY , MapFeature . ALLOWS_ANY_NULL_QUERIES , CollectionFeature . SERIALIZABLE ) . createTestSuite ( ) ) ; return suite ; } public void testSerialization_empty ( ) { assertSame ( ImmutableClassToInstanceMap . of ( ) , SerializableTester . reserialize ( ImmutableClassToInstanceMap . of ( ) ) ) ; } public void testCopyOf_map_empty ( ) { Map < Class < ? > , Object > in = Collections . emptyMap ( ) ; ClassToInstanceMap < Object > map = ImmutableClassToInstanceMap . copyOf ( in ) ; assertTrue ( map . isEmpty ( ) ) ; assertSame ( map , ImmutableClassToInstanceMap . of ( ) ) ; assertSame ( map , ImmutableClassToInstanceMap . copyOf ( map ) ) ; } public void testOf_zero ( ) { assertTrue ( ImmutableClassToInstanceMap . of ( ) . isEmpty ( ) ) ; } public void testOf_one ( ) { ImmutableClassToInstanceMap < Number > map = ImmutableClassToInstanceMap . of ( int . class , <int> ) ; assertEquals ( <int> , map . size ( ) ) ; } public void testCopyOf_map_valid ( ) { Map < Class < ? extends Number > , Number > in = Maps . newHashMap ( ) ; in . put ( Number . class , <int> ) ; in . put ( Double . class , Math . PI ) ; ClassToInstanceMap < Number > map = ImmutableClassToInstanceMap . copyOf ( in ) ; assertEquals ( <int> , map . size ( ) ) ; Number zero = map . getInstance ( Number . class ) ; assertEquals ( <int> , zero ) ; Double pi = map . getInstance ( Double . class ) ; assertEquals ( Math . PI , pi , <float> ) ; assertSame ( map , ImmutableClassToInstanceMap . copyOf ( map ) ) ; } public void testCopyOf_map_nulls ( ) { Map < Class < ? extends Number > , Number > nullKey = Collections . singletonMap ( null , ( Number ) <float> ) ; try { ImmutableClassToInstanceMap . copyOf ( nullKey ) ; fail ( ) ; } catch ( NullPointerException expected ) { } Map < ? extends Class < ? extends Number > , Number > nullValue = Collections . singletonMap ( Number . class , null ) ; try { ImmutableClassToInstanceMap . copyOf ( nullValue ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCopyOf_imap_empty ( ) { Map < Class < ? > , Object > in = Collections . emptyMap ( ) ; ClassToInstanceMap < Object > map = ImmutableClassToInstanceMap . copyOf ( in ) ; assertTrue ( map . isEmpty ( ) ) ; } public void testCopyOf_imap_valid ( ) { ImmutableMap < Class < ? extends Number > , ? extends Number > in = ImmutableMap . of ( Number . class , <int> , Double . class , Math . PI ) ; ClassToInstanceMap < Number > map = ImmutableClassToInstanceMap . copyOf ( in ) ; assertEquals ( <int> , map . size ( ) ) ; Number zero = map . getInstance ( Number . class ) ; assertEquals ( <int> , zero ) ; Double pi = map . getInstance ( Double . class ) ; assertEquals ( Math . PI , pi , <float> ) ; } public void testPrimitiveAndWrapper ( ) { ImmutableClassToInstanceMap < Number > ictim = new ImmutableClassToInstanceMap . Builder < Number > ( ) . put ( Integer . class , <int> ) . put ( int . class , <int> ) . build ( ) ; assertEquals ( <int> , ictim . size ( ) ) ; assertEquals ( <int> , ( int ) ictim . getInstance ( Integer . class ) ) ; assertEquals ( <int> , ( int ) ictim . getInstance ( int . class ) ) ; } abstract static class TestClassToInstanceMapGenerator implements TestMapGenerator < Class , Number > { @Override public Class [ ] createKeyArray ( int length ) { return new Class [ length ] ; } @Override public Number [ ] createValueArray ( int length ) { return new Number [ length ] ; } @Override public SampleElements < Entry < Class , Number > > samples ( ) { Entry < Class , Number > entry1 = Maps . immutableEntry ( ( Class ) Integer . class , ( Number ) <int> ) ; Entry < Class , Number > entry2 = Maps . immutableEntry ( ( Class ) Number . class , ( Number ) <int> ) ; Entry < Class , Number > entry3 = Maps . immutableEntry ( ( Class ) Double . class , ( Number ) <float> ) ; Entry < Class , Number > entry4 = Maps . immutableEntry ( ( Class ) Byte . class , ( Number ) ( byte ) <hex> ) ; Entry < Class , Number > entry5 = Maps . immutableEntry ( ( Class ) Long . class , ( Number ) <hex> ) ; return new SampleElements < Entry < Class , Number > > ( entry1 , entry2 , entry3 , entry4 , entry5 ) ; } @Override @SuppressWarnings ( <str> ) public Entry < Class , Number > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < Class , Number > > order ( List < Entry < Class , Number > > insertionOrder ) { return insertionOrder ; } } } 
