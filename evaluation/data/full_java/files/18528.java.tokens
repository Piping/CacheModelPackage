package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . PolygonRegion ; import com . badlogic . gdx . graphics . g2d . PolygonRegionLoader ; import com . badlogic . gdx . graphics . g2d . PolygonSprite ; import com . badlogic . gdx . graphics . g2d . PolygonSpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; public class PolygonSpriteTest extends GdxTest { PolygonSpriteBatch batch ; ShapeRenderer renderer ; Texture texture ; OrthographicCamera camera ; PolygonRegion region ; Rectangle bounds ; Array < PolygonSprite > sprites = new Array < PolygonSprite > ( ) ; @Override public void create ( ) { texture = new Texture ( Gdx . files . internal ( <str> ) ) ; PolygonRegionLoader loader = new PolygonRegionLoader ( ) ; region = loader . load ( new TextureRegion ( texture ) , Gdx . files . internal ( <str> ) ) ; renderer = new ShapeRenderer ( ) ; camera = new OrthographicCamera ( <int> , <int> ) ; camera . position . x = <int> ; camera . position . y = <int> ; camera . update ( ) ; batch = new PolygonSpriteBatch ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { PolygonSprite sprite = new PolygonSprite ( region ) ; sprite . setPosition ( MathUtils . random ( - <int> , <int> ) , MathUtils . random ( - <int> , <int> ) ) ; sprite . setColor ( MathUtils . random ( ) , MathUtils . random ( ) , MathUtils . random ( ) , <float> ) ; sprite . setScale ( MathUtils . random ( <float> , <float> ) , MathUtils . random ( <float> , <float> ) ) ; sprites . add ( sprite ) ; } } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; Gdx . gl . glClearColor ( <float> , <float> , <float> , <float> ) ; camera . update ( ) ; batch . setProjectionMatrix ( camera . combined ) ; batch . begin ( ) ; for ( int i = <int> ; i < sprites . size ; i + + ) { PolygonSprite sprite = sprites . get ( i ) ; sprite . rotate ( <int> * Gdx . graphics . getDeltaTime ( ) ) ; sprite . translateX ( <int> * Gdx . graphics . getDeltaTime ( ) ) ; if ( sprite . getX ( ) > <int> ) sprite . setX ( - <int> ) ; sprite . draw ( batch ) ; } batch . end ( ) ; renderer . setProjectionMatrix ( camera . combined ) ; renderer . setColor ( Color . GREEN ) ; renderer . begin ( ShapeType . Line ) ; PolygonSprite sprite = sprites . get ( <int> ) ; bounds = sprite . getBoundingRectangle ( ) ; renderer . rect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; renderer . end ( ) ; renderer . begin ( ShapeType . Filled ) ; renderer . circle ( sprite . getX ( ) + sprite . getOriginX ( ) , sprite . getY ( ) + sprite . getOriginY ( ) , <int> ) ; renderer . end ( ) ; } @Override public void dispose ( ) { texture . dispose ( ) ; batch . dispose ( ) ; } } 
