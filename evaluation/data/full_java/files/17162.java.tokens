package org . jbox2d . collision . shapes ; import org . jbox2d . collision . AABB ; import org . jbox2d . collision . RayCastInput ; import org . jbox2d . collision . RayCastOutput ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . pooling . arrays . IntArray ; import org . jbox2d . pooling . arrays . Vec2Array ; public class PolygonShape extends Shape { private final static boolean m_debug = false ; public final Vec2 m_centroid = new Vec2 ( ) ; public final Vec2 m_vertices [ ] ; public final Vec2 m_normals [ ] ; public int m_count ; private final Vec2 pool1 = new Vec2 ( ) ; private final Vec2 pool2 = new Vec2 ( ) ; private final Vec2 pool3 = new Vec2 ( ) ; private final Vec2 pool4 = new Vec2 ( ) ; private Transform poolt1 = new Transform ( ) ; public PolygonShape ( ) { super ( ShapeType . POLYGON ) ; m_count = <int> ; m_vertices = new Vec2 [ Settings . maxPolygonVertices ] ; for ( int i = <int> ; i < m_vertices . length ; i + + ) { m_vertices [ i ] = new Vec2 ( ) ; } m_normals = new Vec2 [ Settings . maxPolygonVertices ] ; for ( int i = <int> ; i < m_normals . length ; i + + ) { m_normals [ i ] = new Vec2 ( ) ; } setRadius ( Settings . polygonRadius ) ; m_centroid . setZero ( ) ; } public final Shape clone ( ) { PolygonShape shape = new PolygonShape ( ) ; shape . m_centroid . set ( this . m_centroid ) ; for ( int i = <int> ; i < shape . m_normals . length ; i + + ) { shape . m_normals [ i ] . set ( m_normals [ i ] ) ; shape . m_vertices [ i ] . set ( m_vertices [ i ] ) ; } shape . setRadius ( this . getRadius ( ) ) ; shape . m_count = this . m_count ; return shape ; } public final void set ( final Vec2 [ ] vertices , final int count ) { set ( vertices , count , null , null ) ; } public final void set ( final Vec2 [ ] verts , final int num , final Vec2Array vecPool , final IntArray intPool ) { assert ( <int> < = num & & num < = Settings . maxPolygonVertices ) ; if ( num < <int> ) { setAsBox ( <float> , <float> ) ; return ; } int n = MathUtils . min ( num , Settings . maxPolygonVertices ) ; Vec2 [ ] ps = ( vecPool ! = null ) ? vecPool . get ( Settings . maxPolygonVertices ) : new Vec2 [ Settings . maxPolygonVertices ] ; int tempCount = <int> ; for ( int i = <int> ; i < n ; + + i ) { Vec2 v = verts [ i ] ; boolean unique = true ; for ( int j = <int> ; j < tempCount ; + + j ) { if ( MathUtils . distanceSquared ( v , ps [ j ] ) < <float> * Settings . linearSlop ) { unique = false ; break ; } } if ( unique ) { ps [ tempCount + + ] = v ; } } n = tempCount ; if ( n < <int> ) { assert ( false ) ; setAsBox ( <float> , <float> ) ; return ; } int i0 = <int> ; float x0 = ps [ <int> ] . x ; for ( int i = <int> ; i < n ; + + i ) { float x = ps [ i ] . x ; if ( x > x0 | | ( x = = x0 & & ps [ i ] . y < ps [ i0 ] . y ) ) { i0 = i ; x0 = x ; } } int [ ] hull = ( intPool ! = null ) ? intPool . get ( Settings . maxPolygonVertices ) : new int [ Settings . maxPolygonVertices ] ; int m = <int> ; int ih = i0 ; while ( true ) { hull [ m ] = ih ; int ie = <int> ; for ( int j = <int> ; j < n ; + + j ) { if ( ie = = ih ) { ie = j ; continue ; } Vec2 r = pool1 . set ( ps [ ie ] ) . subLocal ( ps [ hull [ m ] ] ) ; Vec2 v = pool2 . set ( ps [ j ] ) . subLocal ( ps [ hull [ m ] ] ) ; float c = Vec2 . cross ( r , v ) ; if ( c < <float> ) { ie = j ; } if ( c = = <float> & & v . lengthSquared ( ) > r . lengthSquared ( ) ) { ie = j ; } } + + m ; ih = ie ; if ( ie = = i0 ) { break ; } } this . m_count = m ; for ( int i = <int> ; i < m_count ; + + i ) { if ( m_vertices [ i ] = = null ) { m_vertices [ i ] = new Vec2 ( ) ; } m_vertices [ i ] . set ( ps [ hull [ i ] ] ) ; } final Vec2 edge = pool1 ; for ( int i = <int> ; i < m_count ; + + i ) { final int i1 = i ; final int i2 = i + <int> < m_count ? i + <int> : <int> ; edge . set ( m_vertices [ i2 ] ) . subLocal ( m_vertices [ i1 ] ) ; assert ( edge . lengthSquared ( ) > Settings . EPSILON * Settings . EPSILON ) ; Vec2 . crossToOutUnsafe ( edge , <float> , m_normals [ i ] ) ; m_normals [ i ] . normalize ( ) ; } computeCentroidToOut ( m_vertices , m_count , m_centroid ) ; } public final void setAsBox ( final float hx , final float hy ) { m_count = <int> ; m_vertices [ <int> ] . set ( - hx , - hy ) ; m_vertices [ <int> ] . set ( hx , - hy ) ; m_vertices [ <int> ] . set ( hx , hy ) ; m_vertices [ <int> ] . set ( - hx , hy ) ; m_normals [ <int> ] . set ( <float> , - <float> ) ; m_normals [ <int> ] . set ( <float> , <float> ) ; m_normals [ <int> ] . set ( <float> , <float> ) ; m_normals [ <int> ] . set ( - <float> , <float> ) ; m_centroid . setZero ( ) ; } public final void setAsBox ( final float hx , final float hy , final Vec2 center , final float angle ) { m_count = <int> ; m_vertices [ <int> ] . set ( - hx , - hy ) ; m_vertices [ <int> ] . set ( hx , - hy ) ; m_vertices [ <int> ] . set ( hx , hy ) ; m_vertices [ <int> ] . set ( - hx , hy ) ; m_normals [ <int> ] . set ( <float> , - <float> ) ; m_normals [ <int> ] . set ( <float> , <float> ) ; m_normals [ <int> ] . set ( <float> , <float> ) ; m_normals [ <int> ] . set ( - <float> , <float> ) ; m_centroid . set ( center ) ; final Transform xf = poolt1 ; xf . p . set ( center ) ; xf . q . set ( angle ) ; for ( int i = <int> ; i < m_count ; + + i ) { Transform . mulToOut ( xf , m_vertices [ i ] , m_vertices [ i ] ) ; Rot . mulToOut ( xf . q , m_normals [ i ] , m_normals [ i ] ) ; } } public int getChildCount ( ) { return <int> ; } @Override public final boolean testPoint ( final Transform xf , final Vec2 p ) { float tempx , tempy ; final Rot xfq = xf . q ; tempx = p . x - xf . p . x ; tempy = p . y - xf . p . y ; final float pLocalx = xfq . c * tempx + xfq . s * tempy ; final float pLocaly = - xfq . s * tempx + xfq . c * tempy ; if ( m_debug ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; for ( int i = <int> ; i < m_count ; + + i ) { System . out . println ( m_vertices [ i ] ) ; } System . out . println ( <str> + pLocalx + <str> + pLocaly ) ; } for ( int i = <int> ; i < m_count ; + + i ) { Vec2 vertex = m_vertices [ i ] ; Vec2 normal = m_normals [ i ] ; tempx = pLocalx - vertex . x ; tempy = pLocaly - vertex . y ; final float dot = normal . x * tempx + normal . y * tempy ; if ( dot > <float> ) { return false ; } } return true ; } @Override public final void computeAABB ( final AABB aabb , final Transform xf , int childIndex ) { final Vec2 lower = aabb . lowerBound ; final Vec2 upper = aabb . upperBound ; final Vec2 v1 = m_vertices [ <int> ] ; final float xfqc = xf . q . c ; final float xfqs = xf . q . s ; final float xfpx = xf . p . x ; final float xfpy = xf . p . y ; lower . x = ( xfqc * v1 . x - xfqs * v1 . y ) + xfpx ; lower . y = ( xfqs * v1 . x + xfqc * v1 . y ) + xfpy ; upper . x = lower . x ; upper . y = lower . y ; for ( int i = <int> ; i < m_count ; + + i ) { Vec2 v2 = m_vertices [ i ] ; float vx = ( xfqc * v2 . x - xfqs * v2 . y ) + xfpx ; float vy = ( xfqs * v2 . x + xfqc * v2 . y ) + xfpy ; lower . x = lower . x < vx ? lower . x : vx ; lower . y = lower . y < vy ? lower . y : vy ; upper . x = upper . x > vx ? upper . x : vx ; upper . y = upper . y > vy ? upper . y : vy ; } lower . x - = m_radius ; lower . y - = m_radius ; upper . x + = m_radius ; upper . y + = m_radius ; } public final int getVertexCount ( ) { return m_count ; } public final Vec2 getVertex ( final int index ) { assert ( <int> < = index & & index < m_count ) ; return m_vertices [ index ] ; } @Override public float computeDistanceToOut ( Transform xf , Vec2 p , int childIndex , Vec2 normalOut ) { float xfqc = xf . q . c ; float xfqs = xf . q . s ; float tx = p . x - xf . p . x ; float ty = p . y - xf . p . y ; float pLocalx = xfqc * tx + xfqs * ty ; float pLocaly = - xfqs * tx + xfqc * ty ; float maxDistance = - Float . MAX_VALUE ; float normalForMaxDistanceX = pLocalx ; float normalForMaxDistanceY = pLocaly ; for ( int i = <int> ; i < m_count ; + + i ) { Vec2 vertex = m_vertices [ i ] ; Vec2 normal = m_normals [ i ] ; tx = pLocalx - vertex . x ; ty = pLocaly - vertex . y ; float dot = normal . x * tx + normal . y * ty ; if ( dot > maxDistance ) { maxDistance = dot ; normalForMaxDistanceX = normal . x ; normalForMaxDistanceY = normal . y ; } } float distance ; if ( maxDistance > <int> ) { float minDistanceX = normalForMaxDistanceX ; float minDistanceY = normalForMaxDistanceY ; float minDistance2 = maxDistance * maxDistance ; for ( int i = <int> ; i < m_count ; + + i ) { Vec2 vertex = m_vertices [ i ] ; float distanceVecX = pLocalx - vertex . x ; float distanceVecY = pLocaly - vertex . y ; float distance2 = ( distanceVecX * distanceVecX + distanceVecY * distanceVecY ) ; if ( minDistance2 > distance2 ) { minDistanceX = distanceVecX ; minDistanceY = distanceVecY ; minDistance2 = distance2 ; } } distance = MathUtils . sqrt ( minDistance2 ) ; normalOut . x = xfqc * minDistanceX - xfqs * minDistanceY ; normalOut . y = xfqs * minDistanceX + xfqc * minDistanceY ; normalOut . normalize ( ) ; } else { distance = maxDistance ; normalOut . x = xfqc * normalForMaxDistanceX - xfqs * normalForMaxDistanceY ; normalOut . y = xfqs * normalForMaxDistanceX + xfqc * normalForMaxDistanceY ; } return distance ; } @Override public final boolean raycast ( RayCastOutput output , RayCastInput input , Transform xf , int childIndex ) { final float xfqc = xf . q . c ; final float xfqs = xf . q . s ; final Vec2 xfp = xf . p ; float tempx , tempy ; tempx = input . p1 . x - xfp . x ; tempy = input . p1 . y - xfp . y ; final float p1x = xfqc * tempx + xfqs * tempy ; final float p1y = - xfqs * tempx + xfqc * tempy ; tempx = input . p2 . x - xfp . x ; tempy = input . p2 . y - xfp . y ; final float p2x = xfqc * tempx + xfqs * tempy ; final float p2y = - xfqs * tempx + xfqc * tempy ; final float dx = p2x - p1x ; final float dy = p2y - p1y ; float lower = <int> , upper = input . maxFraction ; int index = - <int> ; for ( int i = <int> ; i < m_count ; + + i ) { Vec2 normal = m_normals [ i ] ; Vec2 vertex = m_vertices [ i ] ; float tempxn = vertex . x - p1x ; float tempyn = vertex . y - p1y ; final float numerator = normal . x * tempxn + normal . y * tempyn ; final float denominator = normal . x * dx + normal . y * dy ; if ( denominator = = <float> ) { if ( numerator < <float> ) { return false ; } } else { if ( denominator < <float> & & numerator < lower * denominator ) { lower = numerator / denominator ; index = i ; } else if ( denominator > <float> & & numerator < upper * denominator ) { upper = numerator / denominator ; } } if ( upper < lower ) { return false ; } } assert ( <float> < = lower & & lower < = input . maxFraction ) ; if ( index > = <int> ) { output . fraction = lower ; Vec2 normal = m_normals [ index ] ; Vec2 out = output . normal ; out . x = xfqc * normal . x - xfqs * normal . y ; out . y = xfqs * normal . x + xfqc * normal . y ; return true ; } return false ; } public final void computeCentroidToOut ( final Vec2 [ ] vs , final int count , final Vec2 out ) { assert ( count > = <int> ) ; out . set ( <float> , <float> ) ; float area = <float> ; final Vec2 pRef = pool1 ; pRef . setZero ( ) ; final Vec2 e1 = pool2 ; final Vec2 e2 = pool3 ; final float inv3 = <float> / <float> ; for ( int i = <int> ; i < count ; + + i ) { final Vec2 p1 = pRef ; final Vec2 p2 = vs [ i ] ; final Vec2 p3 = i + <int> < count ? vs [ i + <int> ] : vs [ <int> ] ; e1 . set ( p2 ) . subLocal ( p1 ) ; e2 . set ( p3 ) . subLocal ( p1 ) ; final float D = Vec2 . cross ( e1 , e2 ) ; final float triangleArea = <float> * D ; area + = triangleArea ; e1 . set ( p1 ) . addLocal ( p2 ) . addLocal ( p3 ) . mulLocal ( triangleArea * inv3 ) ; out . addLocal ( e1 ) ; } assert ( area > Settings . EPSILON ) ; out . mulLocal ( <float> / area ) ; } public void computeMass ( final MassData massData , float density ) { assert ( m_count > = <int> ) ; final Vec2 center = pool1 ; center . setZero ( ) ; float area = <float> ; float I = <float> ; final Vec2 s = pool2 ; s . setZero ( ) ; for ( int i = <int> ; i < m_count ; + + i ) { s . addLocal ( m_vertices [ i ] ) ; } s . mulLocal ( <float> / m_count ) ; final float k_inv3 = <float> / <float> ; final Vec2 e1 = pool3 ; final Vec2 e2 = pool4 ; for ( int i = <int> ; i < m_count ; + + i ) { e1 . set ( m_vertices [ i ] ) . subLocal ( s ) ; e2 . set ( s ) . negateLocal ( ) . addLocal ( i + <int> < m_count ? m_vertices [ i + <int> ] : m_vertices [ <int> ] ) ; final float D = Vec2 . cross ( e1 , e2 ) ; final float triangleArea = <float> * D ; area + = triangleArea ; center . x + = triangleArea * k_inv3 * ( e1 . x + e2 . x ) ; center . y + = triangleArea * k_inv3 * ( e1 . y + e2 . y ) ; final float ex1 = e1 . x , ey1 = e1 . y ; final float ex2 = e2 . x , ey2 = e2 . y ; float intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2 ; float inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2 ; I + = ( <float> * k_inv3 * D ) * ( intx2 + inty2 ) ; } massData . mass = density * area ; assert ( area > Settings . EPSILON ) ; center . mulLocal ( <float> / area ) ; massData . center . set ( center ) . addLocal ( s ) ; massData . I = I * density ; massData . I + = massData . mass * ( Vec2 . dot ( massData . center , massData . center ) ) ; } public boolean validate ( ) { for ( int i = <int> ; i < m_count ; + + i ) { int i1 = i ; int i2 = i < m_count - <int> ? i1 + <int> : <int> ; Vec2 p = m_vertices [ i1 ] ; Vec2 e = pool1 . set ( m_vertices [ i2 ] ) . subLocal ( p ) ; for ( int j = <int> ; j < m_count ; + + j ) { if ( j = = i1 | | j = = i2 ) { continue ; } Vec2 v = pool2 . set ( m_vertices [ j ] ) . subLocal ( p ) ; float c = Vec2 . cross ( e , v ) ; if ( c < <float> ) { return false ; } } } return true ; } public Vec2 [ ] getVertices ( ) { return m_vertices ; } public Vec2 [ ] getNormals ( ) { return m_normals ; } public Vec2 centroid ( final Transform xf ) { return Transform . mul ( xf , m_centroid ) ; } public Vec2 centroidToOut ( final Transform xf , final Vec2 out ) { Transform . mulToOutUnsafe ( xf , m_centroid , out ) ; return out ; } } 
