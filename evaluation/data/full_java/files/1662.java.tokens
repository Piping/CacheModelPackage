package org . apache . cassandra . utils ; import java . math . BigInteger ; import java . util . * ; import org . apache . cassandra . utils . AbstractIterator ; import org . junit . Before ; import org . junit . Test ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . MerkleTree . Hashable ; import org . apache . cassandra . utils . MerkleTree . RowHash ; import org . apache . cassandra . utils . MerkleTree . TreeRange ; import org . apache . cassandra . utils . MerkleTree . TreeRangeIterator ; import static org . apache . cassandra . utils . MerkleTree . RECOMMENDED_DEPTH ; import static org . junit . Assert . * ; public class MerkleTreeTest { public static byte [ ] DUMMY = <str> . getBytes ( ) ; public static BigInteger TOKEN_SCALE = new BigInteger ( <str> ) ; protected IPartitioner partitioner ; protected MerkleTree mt ; private Range < Token > fullRange ( ) { return new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getMinimumToken ( ) ) ; } @Before public void clear ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; partitioner = RandomPartitioner . instance ; DatabaseDescriptor . setPartitionerUnsafe ( partitioner ) ; mt = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , Integer . MAX_VALUE ) ; } public static void assertHashEquals ( final byte [ ] left , final byte [ ] right ) { assertHashEquals ( <str> , left , right ) ; } public static void assertHashEquals ( String message , final byte [ ] left , final byte [ ] right ) { String lstring = left = = null ? <str> : Hex . bytesToHex ( left ) ; String rstring = right = = null ? <str> : Hex . bytesToHex ( right ) ; assertEquals ( message , lstring , rstring ) ; } public static Token tok ( int i ) { if ( i = = - <int> ) return new BigIntegerToken ( new BigInteger ( <str> ) ) ; BigInteger bint = RandomPartitioner . MAXIMUM . divide ( TOKEN_SCALE ) . multiply ( new BigInteger ( <str> + i ) ) ; return new BigIntegerToken ( bint ) ; } @Test public void testSplit ( ) { mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; assertEquals ( <int> , mt . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mt . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; assertEquals ( ( byte ) <int> , mt . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mt . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mt . get ( tok ( <int> ) ) . depth ) ; assertEquals ( ( byte ) <int> , mt . get ( tok ( - <int> ) ) . depth ) ; try { mt . split ( tok ( - <int> ) ) ; fail ( <str> ) ; } catch ( AssertionError e ) { } } @Test public void testSplitLimitDepth ( ) { mt = new MerkleTree ( partitioner , fullRange ( ) , ( byte ) <int> , Integer . MAX_VALUE ) ; assertTrue ( mt . split ( tok ( <int> ) ) ) ; assertTrue ( mt . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mt . size ( ) ) ; assertFalse ( mt . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mt . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mt . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; } @Test public void testSplitLimitSize ( ) { mt = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , <int> ) ; assertTrue ( mt . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mt . size ( ) ) ; assertFalse ( mt . split ( tok ( <int> ) ) ) ; assertEquals ( <int> , mt . size ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , mt . get ( tok ( - <int> ) ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , mt . get ( tok ( <int> ) ) ) ; } @Test public void testInvalids ( ) { Iterator < TreeRange > ranges ; ranges = mt . invalids ( ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertFalse ( ranges . hasNext ( ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; ranges = mt . invalids ( ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( - <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( <int> ) ) , ranges . next ( ) ) ; assertEquals ( new Range < > ( tok ( <int> ) , tok ( - <int> ) ) , ranges . next ( ) ) ; assertFalse ( ranges . hasNext ( ) ) ; } @Test public void testHashFull ( ) { byte [ ] val = DUMMY ; Range < Token > range = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; assertNull ( mt . hash ( range ) ) ; mt . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( val , mt . hash ( range ) ) ; } @Test public void testHashPartial ( ) { byte [ ] val = DUMMY ; byte [ ] leftval = hashed ( val , <int> , <int> ) ; byte [ ] partialval = hashed ( val , <int> ) ; Range < Token > left = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > partial = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; Range < Token > right = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; Range < Token > linvalid = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; Range < Token > rinvalid = new Range < > ( tok ( <int> ) , tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; assertNull ( mt . hash ( left ) ) ; assertNull ( mt . hash ( partial ) ) ; assertNull ( mt . hash ( right ) ) ; assertNull ( mt . hash ( linvalid ) ) ; assertNull ( mt . hash ( rinvalid ) ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( leftval , mt . hash ( left ) ) ; assertHashEquals ( partialval , mt . hash ( partial ) ) ; assertHashEquals ( val , mt . hash ( right ) ) ; assertNull ( mt . hash ( linvalid ) ) ; assertNull ( mt . hash ( rinvalid ) ) ; } @Test public void testHashInner ( ) { byte [ ] val = DUMMY ; byte [ ] lchildval = hashed ( val , <int> , <int> , <int> ) ; byte [ ] rchildval = hashed ( val , <int> , <int> ) ; byte [ ] fullval = hashed ( val , <int> , <int> , <int> , <int> , <int> ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Range < Token > lchild = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > rchild = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; Range < Token > invalid = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; assertNull ( mt . hash ( full ) ) ; assertNull ( mt . hash ( lchild ) ) ; assertNull ( mt . hash ( rchild ) ) ; assertNull ( mt . hash ( invalid ) ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( fullval , mt . hash ( full ) ) ; assertHashEquals ( lchildval , mt . hash ( lchild ) ) ; assertHashEquals ( rchildval , mt . hash ( rchild ) ) ; assertNull ( mt . hash ( invalid ) ) ; } @Test public void testHashDegenerate ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; byte [ ] val = DUMMY ; byte [ ] childfullval = hashed ( val , <int> , <int> , <int> ) ; byte [ ] fullval = hashed ( val , <int> , <int> , <int> , <int> , <int> , <int> ) ; Range < Token > childfull = new Range < > ( tok ( - <int> ) , tok ( <int> ) ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Range < Token > invalid = new Range < > ( tok ( <int> ) , tok ( - <int> ) ) ; mt = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , Integer . MAX_VALUE ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; assertNull ( mt . hash ( full ) ) ; assertNull ( mt . hash ( childfull ) ) ; assertNull ( mt . hash ( invalid ) ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( <int> ) ) . hash ( val ) ; mt . get ( tok ( - <int> ) ) . hash ( val ) ; assertHashEquals ( fullval , mt . hash ( full ) ) ; assertHashEquals ( childfullval , mt . hash ( childfull ) ) ; assertNull ( mt . hash ( invalid ) ) ; } @Test public void testHashRandom ( ) { int max = <int> ; TOKEN_SCALE = new BigInteger ( <str> + max ) ; mt = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , <int> ) ; Random random = new Random ( ) ; while ( true ) { if ( ! mt . split ( tok ( random . nextInt ( max ) ) ) ) break ; } TreeRangeIterator ranges = mt . invalids ( ) ; for ( TreeRange range : ranges ) range . addHash ( new RowHash ( range . right , new byte [ <int> ] , <int> ) ) ; assert mt . hash ( new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ) ! = null : <str> + mt ; } @Test public void testValidateTree ( ) { TOKEN_SCALE = new BigInteger ( <str> ) ; Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; Iterator < TreeRange > ranges ; MerkleTree mt2 = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , Integer . MAX_VALUE ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; mt . split ( tok ( <int> ) ) ; ranges = mt . invalids ( ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , - <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; mt2 . split ( tok ( <int> ) ) ; ranges = mt2 . invalids ( ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( new int [ <int> ] ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> ) ) ; ranges . next ( ) . addAll ( new HIterator ( <int> , - <int> ) ) ; byte [ ] mthash = mt . hash ( full ) ; byte [ ] mt2hash = mt2 . hash ( full ) ; assertHashEquals ( <str> + mt + <str> + mt2 , mthash , mt2hash ) ; } @Test public void testSerialization ( ) throws Exception { Range < Token > full = new Range < > ( tok ( - <int> ) , tok ( - <int> ) ) ; mt . maxsize ( <int> ) ; mt . init ( ) ; for ( TreeRange range : mt . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; byte [ ] initialhash = mt . hash ( full ) ; DataOutputBuffer out = new DataOutputBuffer ( ) ; MerkleTree . serializer . serialize ( mt , out , MessagingService . current_version ) ; byte [ ] serialized = out . toByteArray ( ) ; DataInputPlus in = new DataInputBuffer ( serialized ) ; MerkleTree restored = MerkleTree . serializer . deserialize ( in , MessagingService . current_version ) ; assertHashEquals ( initialhash , restored . hash ( full ) ) ; } @Test public void testDifference ( ) { int maxsize = <int> ; mt . maxsize ( maxsize ) ; MerkleTree mt2 = new MerkleTree ( partitioner , fullRange ( ) , RECOMMENDED_DEPTH , maxsize ) ; mt . init ( ) ; mt2 . init ( ) ; for ( TreeRange range : mt . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; for ( TreeRange range : mt2 . invalids ( ) ) range . addAll ( new HIterator ( range . right ) ) ; TreeRange leftmost = null ; TreeRange middle = null ; mt . maxsize ( maxsize + <int> ) ; Iterator < TreeRange > ranges = mt . invalids ( ) ; leftmost = ranges . next ( ) ; mt . split ( leftmost . right ) ; middle = mt . get ( leftmost . right ) ; middle . hash ( <str> . getBytes ( ) ) ; mt . get ( partitioner . midpoint ( leftmost . left , leftmost . right ) ) . hash ( <str> . getBytes ( ) ) ; List < TreeRange > diffs = MerkleTree . difference ( mt , mt2 ) ; assertEquals ( diffs + <str> , <int> , diffs . size ( ) ) ; assertTrue ( diffs . contains ( new Range < > ( leftmost . left , middle . right ) ) ) ; } byte [ ] hashed ( byte [ ] val , Integer . . . depths ) { ArrayDeque < Integer > dstack = new ArrayDeque < Integer > ( ) ; ArrayDeque < byte [ ] > hstack = new ArrayDeque < byte [ ] > ( ) ; Iterator < Integer > depthiter = Arrays . asList ( depths ) . iterator ( ) ; if ( depthiter . hasNext ( ) ) { dstack . push ( depthiter . next ( ) ) ; hstack . push ( val ) ; } while ( depthiter . hasNext ( ) ) { Integer depth = depthiter . next ( ) ; byte [ ] hash = val ; while ( depth . equals ( dstack . peek ( ) ) ) { hash = Hashable . binaryHash ( hstack . pop ( ) , hash ) ; depth = dstack . pop ( ) - <int> ; } dstack . push ( depth ) ; hstack . push ( hash ) ; } assert hstack . size ( ) = = <int> ; return hstack . pop ( ) ; } static class HIterator extends AbstractIterator < RowHash > { private Iterator < Token > tokens ; public HIterator ( int . . . tokens ) { List < Token > tlist = new LinkedList < Token > ( ) ; for ( int token : tokens ) tlist . add ( tok ( token ) ) ; this . tokens = tlist . iterator ( ) ; } public HIterator ( Token . . . tokens ) { this . tokens = Arrays . asList ( tokens ) . iterator ( ) ; } public RowHash computeNext ( ) { if ( tokens . hasNext ( ) ) return new RowHash ( tokens . next ( ) , DUMMY , DUMMY . length ) ; return endOfData ( ) ; } } } 
