package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . base . Joiner ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . Clustering ; import org . apache . cassandra . db . MultiCBuilder ; import org . apache . cassandra . db . Slice ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . index . SecondaryIndexManager ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; public abstract class TokenRestriction extends AbstractPrimaryKeyRestrictions { protected final List < ColumnDefinition > columnDefs ; final CFMetaData metadata ; public TokenRestriction ( CFMetaData metadata , List < ColumnDefinition > columnDefs ) { super ( metadata . getKeyValidatorAsClusteringComparator ( ) ) ; this . columnDefs = columnDefs ; this . metadata = metadata ; } @Override public boolean isOnToken ( ) { return true ; } @Override public Collection < ColumnDefinition > getColumnDefs ( ) { return columnDefs ; } @Override public ColumnDefinition getFirstColumn ( ) { return columnDefs . get ( <int> ) ; } @Override public ColumnDefinition getLastColumn ( ) { return columnDefs . get ( columnDefs . size ( ) - <int> ) ; } @Override public boolean hasSupportingIndex ( SecondaryIndexManager secondaryIndexManager ) { return false ; } @Override public void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexManager , QueryOptions options ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { throw new UnsupportedOperationException ( ) ; } @Override public NavigableSet < Clustering > valuesAsClustering ( QueryOptions options ) throws InvalidRequestException { throw new UnsupportedOperationException ( ) ; } @Override public NavigableSet < Slice . Bound > boundsAsClustering ( Bound bound , QueryOptions options ) throws InvalidRequestException { throw new UnsupportedOperationException ( ) ; } protected final String getColumnNamesAsString ( ) { return Joiner . on ( <str> ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ; } @Override public final PrimaryKeyRestrictions mergeWith ( Restriction otherRestriction ) throws InvalidRequestException { if ( ! otherRestriction . isOnToken ( ) ) return new TokenFilter ( toPrimaryKeyRestriction ( otherRestriction ) , this ) ; return doMergeWith ( ( TokenRestriction ) otherRestriction ) ; } protected abstract PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException ; private PrimaryKeyRestrictions toPrimaryKeyRestriction ( Restriction restriction ) throws InvalidRequestException { if ( restriction instanceof PrimaryKeyRestrictions ) return ( PrimaryKeyRestrictions ) restriction ; return new PrimaryKeyRestrictionSet ( comparator , true ) . mergeWith ( restriction ) ; } public static final class EQRestriction extends TokenRestriction { private final Term value ; public EQRestriction ( CFMetaData cfm , List < ColumnDefinition > columnDefs , Term value ) { super ( cfm , columnDefs ) ; this . value = value ; } @Override public boolean isEQ ( ) { return true ; } @Override public Iterable < Function > getFunctions ( ) { return value . getFunctions ( ) ; } @Override protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException { throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( ColumnDefinition . toIdentifiers ( columnDefs ) ) ) ; } @Override public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException { return Collections . singletonList ( value . bindAndGet ( options ) ) ; } } public static class SliceRestriction extends TokenRestriction { private final TermSlice slice ; public SliceRestriction ( CFMetaData cfm , List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) { super ( cfm , columnDefs ) ; slice = TermSlice . newInstance ( bound , inclusive , term ) ; } @Override public boolean isSlice ( ) { return true ; } @Override public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException { throw new UnsupportedOperationException ( ) ; } @Override public boolean hasBound ( Bound b ) { return slice . hasBound ( b ) ; } @Override public List < ByteBuffer > bounds ( Bound b , QueryOptions options ) throws InvalidRequestException { return Collections . singletonList ( slice . bound ( b ) . bindAndGet ( options ) ) ; } @Override public Iterable < Function > getFunctions ( ) { return slice . getFunctions ( ) ; } @Override public boolean isInclusive ( Bound b ) { return slice . isInclusive ( b ) ; } @Override protected PrimaryKeyRestrictions doMergeWith ( TokenRestriction otherRestriction ) throws InvalidRequestException { if ( ! otherRestriction . isSlice ( ) ) throw invalidRequest ( <str> , getColumnNamesAsString ( ) ) ; TokenRestriction . SliceRestriction otherSlice = ( TokenRestriction . SliceRestriction ) otherRestriction ; if ( hasBound ( Bound . START ) & & otherSlice . hasBound ( Bound . START ) ) throw invalidRequest ( <str> , getColumnNamesAsString ( ) ) ; if ( hasBound ( Bound . END ) & & otherSlice . hasBound ( Bound . END ) ) throw invalidRequest ( <str> , getColumnNamesAsString ( ) ) ; return new SliceRestriction ( metadata , columnDefs , slice . merge ( otherSlice . slice ) ) ; } @Override public String toString ( ) { return String . format ( <str> , slice ) ; } private SliceRestriction ( CFMetaData cfm , List < ColumnDefinition > columnDefs , TermSlice slice ) { super ( cfm , columnDefs ) ; this . slice = slice ; } } } 
