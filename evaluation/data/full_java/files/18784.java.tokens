package io . netty . buffer ; import io . netty . util . internal . PlatformDependent ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . CharBuffer ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . List ; public final class Unpooled { private static final ByteBufAllocator ALLOC = UnpooledByteBufAllocator . DEFAULT ; public static final ByteOrder BIG_ENDIAN = ByteOrder . BIG_ENDIAN ; public static final ByteOrder LITTLE_ENDIAN = ByteOrder . LITTLE_ENDIAN ; public static final ByteBuf EMPTY_BUFFER = ALLOC . buffer ( <int> , <int> ) ; static { assert EMPTY_BUFFER instanceof EmptyByteBuf : <str> ; } public static ByteBuf buffer ( ) { return ALLOC . heapBuffer ( ) ; } public static ByteBuf directBuffer ( ) { return ALLOC . directBuffer ( ) ; } public static ByteBuf buffer ( int initialCapacity ) { return ALLOC . heapBuffer ( initialCapacity ) ; } public static ByteBuf directBuffer ( int initialCapacity ) { return ALLOC . directBuffer ( initialCapacity ) ; } public static ByteBuf buffer ( int initialCapacity , int maxCapacity ) { return ALLOC . heapBuffer ( initialCapacity , maxCapacity ) ; } public static ByteBuf directBuffer ( int initialCapacity , int maxCapacity ) { return ALLOC . directBuffer ( initialCapacity , maxCapacity ) ; } public static ByteBuf wrappedBuffer ( byte [ ] array ) { if ( array . length = = <int> ) { return EMPTY_BUFFER ; } return new UnpooledHeapByteBuf ( ALLOC , array , array . length ) ; } public static ByteBuf wrappedBuffer ( byte [ ] array , int offset , int length ) { if ( length = = <int> ) { return EMPTY_BUFFER ; } if ( offset = = <int> & & length = = array . length ) { return wrappedBuffer ( array ) ; } return wrappedBuffer ( array ) . slice ( offset , length ) ; } public static ByteBuf wrappedBuffer ( ByteBuffer buffer ) { if ( ! buffer . hasRemaining ( ) ) { return EMPTY_BUFFER ; } if ( buffer . hasArray ( ) ) { return wrappedBuffer ( buffer . array ( ) , buffer . arrayOffset ( ) + buffer . position ( ) , buffer . remaining ( ) ) . order ( buffer . order ( ) ) ; } else if ( PlatformDependent . hasUnsafe ( ) ) { if ( buffer . isReadOnly ( ) ) { if ( buffer . isDirect ( ) ) { return new ReadOnlyUnsafeDirectByteBuf ( ALLOC , buffer ) ; } else { return new ReadOnlyByteBufferBuf ( ALLOC , buffer ) ; } } else { return new UnpooledUnsafeDirectByteBuf ( ALLOC , buffer , buffer . remaining ( ) ) ; } } else { if ( buffer . isReadOnly ( ) ) { return new ReadOnlyByteBufferBuf ( ALLOC , buffer ) ; } else { return new UnpooledDirectByteBuf ( ALLOC , buffer , buffer . remaining ( ) ) ; } } } public static ByteBuf wrappedBuffer ( ByteBuf buffer ) { if ( buffer . isReadable ( ) ) { return buffer . slice ( ) ; } else { return EMPTY_BUFFER ; } } public static ByteBuf wrappedBuffer ( byte [ ] . . . arrays ) { return wrappedBuffer ( <int> , arrays ) ; } public static ByteBuf wrappedBuffer ( ByteBuf . . . buffers ) { return wrappedBuffer ( <int> , buffers ) ; } public static ByteBuf wrappedBuffer ( ByteBuffer . . . buffers ) { return wrappedBuffer ( <int> , buffers ) ; } public static ByteBuf wrappedBuffer ( int maxNumComponents , byte [ ] . . . arrays ) { switch ( arrays . length ) { case <int> : break ; case <int> : if ( arrays [ <int> ] . length ! = <int> ) { return wrappedBuffer ( arrays [ <int> ] ) ; } break ; default : final List < ByteBuf > components = new ArrayList < ByteBuf > ( arrays . length ) ; for ( byte [ ] a : arrays ) { if ( a = = null ) { break ; } if ( a . length > <int> ) { components . add ( wrappedBuffer ( a ) ) ; } } if ( ! components . isEmpty ( ) ) { return new CompositeByteBuf ( ALLOC , false , maxNumComponents , components ) ; } } return EMPTY_BUFFER ; } public static ByteBuf wrappedBuffer ( int maxNumComponents , ByteBuf . . . buffers ) { switch ( buffers . length ) { case <int> : break ; case <int> : if ( buffers [ <int> ] . isReadable ( ) ) { return wrappedBuffer ( buffers [ <int> ] . order ( BIG_ENDIAN ) ) ; } break ; default : for ( ByteBuf b : buffers ) { if ( b . isReadable ( ) ) { return new CompositeByteBuf ( ALLOC , false , maxNumComponents , buffers ) ; } } } return EMPTY_BUFFER ; } public static ByteBuf wrappedBuffer ( int maxNumComponents , ByteBuffer . . . buffers ) { switch ( buffers . length ) { case <int> : break ; case <int> : if ( buffers [ <int> ] . hasRemaining ( ) ) { return wrappedBuffer ( buffers [ <int> ] . order ( BIG_ENDIAN ) ) ; } break ; default : final List < ByteBuf > components = new ArrayList < ByteBuf > ( buffers . length ) ; for ( ByteBuffer b : buffers ) { if ( b = = null ) { break ; } if ( b . remaining ( ) > <int> ) { components . add ( wrappedBuffer ( b . order ( BIG_ENDIAN ) ) ) ; } } if ( ! components . isEmpty ( ) ) { return new CompositeByteBuf ( ALLOC , false , maxNumComponents , components ) ; } } return EMPTY_BUFFER ; } public static CompositeByteBuf compositeBuffer ( ) { return compositeBuffer ( <int> ) ; } public static CompositeByteBuf compositeBuffer ( int maxNumComponents ) { return new CompositeByteBuf ( ALLOC , false , maxNumComponents ) ; } public static ByteBuf copiedBuffer ( byte [ ] array ) { if ( array . length = = <int> ) { return EMPTY_BUFFER ; } return wrappedBuffer ( array . clone ( ) ) ; } public static ByteBuf copiedBuffer ( byte [ ] array , int offset , int length ) { if ( length = = <int> ) { return EMPTY_BUFFER ; } byte [ ] copy = new byte [ length ] ; System . arraycopy ( array , offset , copy , <int> , length ) ; return wrappedBuffer ( copy ) ; } public static ByteBuf copiedBuffer ( ByteBuffer buffer ) { int length = buffer . remaining ( ) ; if ( length = = <int> ) { return EMPTY_BUFFER ; } byte [ ] copy = new byte [ length ] ; ByteBuffer duplicate = buffer . duplicate ( ) ; duplicate . get ( copy ) ; return wrappedBuffer ( copy ) . order ( duplicate . order ( ) ) ; } public static ByteBuf copiedBuffer ( ByteBuf buffer ) { int readable = buffer . readableBytes ( ) ; if ( readable > <int> ) { ByteBuf copy = buffer ( readable ) ; copy . writeBytes ( buffer , buffer . readerIndex ( ) , readable ) ; return copy ; } else { return EMPTY_BUFFER ; } } public static ByteBuf copiedBuffer ( byte [ ] . . . arrays ) { switch ( arrays . length ) { case <int> : return EMPTY_BUFFER ; case <int> : if ( arrays [ <int> ] . length = = <int> ) { return EMPTY_BUFFER ; } else { return copiedBuffer ( arrays [ <int> ] ) ; } } int length = <int> ; for ( byte [ ] a : arrays ) { if ( Integer . MAX_VALUE - length < a . length ) { throw new IllegalArgumentException ( <str> ) ; } length + = a . length ; } if ( length = = <int> ) { return EMPTY_BUFFER ; } byte [ ] mergedArray = new byte [ length ] ; for ( int i = <int> , j = <int> ; i < arrays . length ; i + + ) { byte [ ] a = arrays [ i ] ; System . arraycopy ( a , <int> , mergedArray , j , a . length ) ; j + = a . length ; } return wrappedBuffer ( mergedArray ) ; } public static ByteBuf copiedBuffer ( ByteBuf . . . buffers ) { switch ( buffers . length ) { case <int> : return EMPTY_BUFFER ; case <int> : return copiedBuffer ( buffers [ <int> ] ) ; } ByteOrder order = null ; int length = <int> ; for ( ByteBuf b : buffers ) { int bLen = b . readableBytes ( ) ; if ( bLen < = <int> ) { continue ; } if ( Integer . MAX_VALUE - length < bLen ) { throw new IllegalArgumentException ( <str> ) ; } length + = bLen ; if ( order ! = null ) { if ( ! order . equals ( b . order ( ) ) ) { throw new IllegalArgumentException ( <str> ) ; } } else { order = b . order ( ) ; } } if ( length = = <int> ) { return EMPTY_BUFFER ; } byte [ ] mergedArray = new byte [ length ] ; for ( int i = <int> , j = <int> ; i < buffers . length ; i + + ) { ByteBuf b = buffers [ i ] ; int bLen = b . readableBytes ( ) ; b . getBytes ( b . readerIndex ( ) , mergedArray , j , bLen ) ; j + = bLen ; } return wrappedBuffer ( mergedArray ) . order ( order ) ; } public static ByteBuf copiedBuffer ( ByteBuffer . . . buffers ) { switch ( buffers . length ) { case <int> : return EMPTY_BUFFER ; case <int> : return copiedBuffer ( buffers [ <int> ] ) ; } ByteOrder order = null ; int length = <int> ; for ( ByteBuffer b : buffers ) { int bLen = b . remaining ( ) ; if ( bLen < = <int> ) { continue ; } if ( Integer . MAX_VALUE - length < bLen ) { throw new IllegalArgumentException ( <str> ) ; } length + = bLen ; if ( order ! = null ) { if ( ! order . equals ( b . order ( ) ) ) { throw new IllegalArgumentException ( <str> ) ; } } else { order = b . order ( ) ; } } if ( length = = <int> ) { return EMPTY_BUFFER ; } byte [ ] mergedArray = new byte [ length ] ; for ( int i = <int> , j = <int> ; i < buffers . length ; i + + ) { ByteBuffer b = buffers [ i ] . duplicate ( ) ; int bLen = b . remaining ( ) ; b . get ( mergedArray , j , bLen ) ; j + = bLen ; } return wrappedBuffer ( mergedArray ) . order ( order ) ; } public static ByteBuf copiedBuffer ( CharSequence string , Charset charset ) { if ( string = = null ) { throw new NullPointerException ( <str> ) ; } if ( string instanceof CharBuffer ) { return copiedBuffer ( ( CharBuffer ) string , charset ) ; } return copiedBuffer ( CharBuffer . wrap ( string ) , charset ) ; } public static ByteBuf copiedBuffer ( CharSequence string , int offset , int length , Charset charset ) { if ( string = = null ) { throw new NullPointerException ( <str> ) ; } if ( length = = <int> ) { return EMPTY_BUFFER ; } if ( string instanceof CharBuffer ) { CharBuffer buf = ( CharBuffer ) string ; if ( buf . hasArray ( ) ) { return copiedBuffer ( buf . array ( ) , buf . arrayOffset ( ) + buf . position ( ) + offset , length , charset ) ; } buf = buf . slice ( ) ; buf . limit ( length ) ; buf . position ( offset ) ; return copiedBuffer ( buf , charset ) ; } return copiedBuffer ( CharBuffer . wrap ( string , offset , offset + length ) , charset ) ; } public static ByteBuf copiedBuffer ( char [ ] array , Charset charset ) { if ( array = = null ) { throw new NullPointerException ( <str> ) ; } return copiedBuffer ( array , <int> , array . length , charset ) ; } public static ByteBuf copiedBuffer ( char [ ] array , int offset , int length , Charset charset ) { if ( array = = null ) { throw new NullPointerException ( <str> ) ; } if ( length = = <int> ) { return EMPTY_BUFFER ; } return copiedBuffer ( CharBuffer . wrap ( array , offset , length ) , charset ) ; } private static ByteBuf copiedBuffer ( CharBuffer buffer , Charset charset ) { return ByteBufUtil . encodeString0 ( ALLOC , true , buffer , charset ) ; } public static ByteBuf unmodifiableBuffer ( ByteBuf buffer ) { ByteOrder endianness = buffer . order ( ) ; if ( endianness = = BIG_ENDIAN ) { return new ReadOnlyByteBuf ( buffer ) ; } return new ReadOnlyByteBuf ( buffer . order ( BIG_ENDIAN ) ) . order ( LITTLE_ENDIAN ) ; } public static ByteBuf copyInt ( int value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeInt ( value ) ; return buf ; } public static ByteBuf copyInt ( int . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( int v : values ) { buffer . writeInt ( v ) ; } return buffer ; } public static ByteBuf copyShort ( int value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeShort ( value ) ; return buf ; } public static ByteBuf copyShort ( short . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( int v : values ) { buffer . writeShort ( v ) ; } return buffer ; } public static ByteBuf copyShort ( int . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( int v : values ) { buffer . writeShort ( v ) ; } return buffer ; } public static ByteBuf copyMedium ( int value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeMedium ( value ) ; return buf ; } public static ByteBuf copyMedium ( int . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( int v : values ) { buffer . writeMedium ( v ) ; } return buffer ; } public static ByteBuf copyLong ( long value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeLong ( value ) ; return buf ; } public static ByteBuf copyLong ( long . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( long v : values ) { buffer . writeLong ( v ) ; } return buffer ; } public static ByteBuf copyBoolean ( boolean value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeBoolean ( value ) ; return buf ; } public static ByteBuf copyBoolean ( boolean . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length ) ; for ( boolean v : values ) { buffer . writeBoolean ( v ) ; } return buffer ; } public static ByteBuf copyFloat ( float value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeFloat ( value ) ; return buf ; } public static ByteBuf copyFloat ( float . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( float v : values ) { buffer . writeFloat ( v ) ; } return buffer ; } public static ByteBuf copyDouble ( double value ) { ByteBuf buf = buffer ( <int> ) ; buf . writeDouble ( value ) ; return buf ; } public static ByteBuf copyDouble ( double . . . values ) { if ( values = = null | | values . length = = <int> ) { return EMPTY_BUFFER ; } ByteBuf buffer = buffer ( values . length * <int> ) ; for ( double v : values ) { buffer . writeDouble ( v ) ; } return buffer ; } public static ByteBuf unreleasableBuffer ( ByteBuf buf ) { return new UnreleasableByteBuf ( buf ) ; } public static ByteBuf unmodifiableBuffer ( ByteBuf . . . buffers ) { return new FixedCompositeByteBuf ( ALLOC , buffers ) ; } private Unpooled ( ) { } } 
