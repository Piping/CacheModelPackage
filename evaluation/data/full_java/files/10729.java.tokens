package org . gradle . build . docs . dsl . source ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . Action ; import org . gradle . build . docs . dsl . source . model . ClassMetaData ; import org . gradle . build . docs . dsl . source . model . TypeMetaData ; import org . gradle . build . docs . model . ClassMetaDataRepository ; import org . gradle . internal . UncheckedException ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public class TypeNameResolver { private final Set < String > primitiveTypes = new HashSet < String > ( ) ; private final List < String > groovyImplicitImportPackages = new ArrayList < String > ( ) ; private final List < String > groovyImplicitTypes = new ArrayList < String > ( ) ; private final ClassMetaDataRepository < ClassMetaData > metaDataRepository ; public TypeNameResolver ( ClassMetaDataRepository < ClassMetaData > metaDataRepository ) { this . metaDataRepository = metaDataRepository ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; primitiveTypes . add ( <str> ) ; groovyImplicitImportPackages . add ( <str> ) ; groovyImplicitImportPackages . add ( <str> ) ; groovyImplicitImportPackages . add ( <str> ) ; groovyImplicitImportPackages . add ( <str> ) ; groovyImplicitImportPackages . add ( <str> ) ; groovyImplicitTypes . add ( <str> ) ; groovyImplicitTypes . add ( <str> ) ; try { getClass ( ) . getClassLoader ( ) . loadClass ( <str> ) ; } catch ( ClassNotFoundException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public void resolve ( final TypeMetaData type , final ClassMetaData classMetaData ) { type . visitTypes ( new Action < TypeMetaData > ( ) { public void execute ( TypeMetaData t ) { t . setName ( resolve ( t . getName ( ) , classMetaData ) ) ; } } ) ; } public String resolve ( String name , ClassMetaData classMetaData ) { if ( primitiveTypes . contains ( name ) ) { return name ; } String candidateClassName ; String [ ] innerNames = name . split ( <str> ) ; ClassMetaData pos = classMetaData ; for ( int i = <int> ; i < innerNames . length ; i + + ) { String innerName = innerNames [ i ] ; candidateClassName = pos . getClassName ( ) + <str> + innerName ; if ( ! pos . getInnerClassNames ( ) . contains ( candidateClassName ) ) { break ; } if ( i = = innerNames . length - <int> ) { return candidateClassName ; } pos = metaDataRepository . get ( candidateClassName ) ; } String outerClassName = classMetaData . getOuterClassName ( ) ; while ( outerClassName ! = null ) { if ( name . equals ( StringUtils . substringAfterLast ( outerClassName , <str> ) ) ) { return outerClassName ; } ClassMetaData outerClass = metaDataRepository . get ( outerClassName ) ; candidateClassName = outerClassName + <str> + name ; if ( outerClass . getInnerClassNames ( ) . contains ( candidateClassName ) ) { return candidateClassName ; } outerClassName = outerClass . getOuterClassName ( ) ; } if ( name . contains ( <str> ) ) { return name ; } for ( String importedClass : classMetaData . getImports ( ) ) { String baseName = StringUtils . substringAfterLast ( importedClass , <str> ) ; if ( baseName . equals ( <str> ) ) { candidateClassName = StringUtils . substringBeforeLast ( importedClass , <str> ) + <str> + name ; if ( metaDataRepository . find ( candidateClassName ) ! = null ) { return candidateClassName ; } if ( importedClass . startsWith ( <str> ) & & isVisibleClass ( candidateClassName ) ) { return candidateClassName ; } } else if ( name . equals ( baseName ) ) { return importedClass ; } } candidateClassName = classMetaData . getPackageName ( ) + <str> + name ; if ( metaDataRepository . find ( candidateClassName ) ! = null ) { return candidateClassName ; } candidateClassName = <str> + name ; if ( isVisibleClass ( candidateClassName ) ) { return candidateClassName ; } if ( classMetaData . isGroovy ( ) ) { candidateClassName = <str> + name ; if ( groovyImplicitTypes . contains ( candidateClassName ) ) { return candidateClassName ; } for ( String prefix : groovyImplicitImportPackages ) { candidateClassName = prefix + name ; if ( isVisibleClass ( candidateClassName ) ) { return candidateClassName ; } } } return name ; } private boolean isVisibleClass ( String candidateClassName ) { try { getClass ( ) . getClassLoader ( ) . loadClass ( candidateClassName ) ; return true ; } catch ( ClassNotFoundException e ) { } return false ; } } 
