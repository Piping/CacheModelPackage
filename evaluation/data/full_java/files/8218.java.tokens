package org . elasticsearch . index . mapper . ttl ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsResponse ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . SourceToParse ; import org . elasticsearch . index . mapper . internal . TTLFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; public class TTLMappingTests extends ESSingleNodeTestCase { public void testSimpleDisabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; BytesReference source = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ; ParsedDocument doc = docMapper . parse ( SourceToParse . source ( source ) . type ( <str> ) . id ( <str> ) . ttl ( Long . MAX_VALUE ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , equalTo ( null ) ) ; } public void testEnabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; BytesReference source = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ; ParsedDocument doc = docMapper . parse ( SourceToParse . source ( source ) . type ( <str> ) . id ( <str> ) . ttl ( Long . MAX_VALUE ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . stored ( ) , equalTo ( true ) ) ; assertNotSame ( IndexOptions . NONE , doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . indexOptions ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , notNullValue ( ) ) ; } public void testDefaultValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; assertThat ( docMapper . TTLFieldMapper ( ) . enabled ( ) , equalTo ( TTLFieldMapper . Defaults . ENABLED_STATE . enabled ) ) ; assertThat ( docMapper . TTLFieldMapper ( ) . fieldType ( ) . stored ( ) , equalTo ( TTLFieldMapper . Defaults . TTL_FIELD_TYPE . stored ( ) ) ) ; assertThat ( docMapper . TTLFieldMapper ( ) . fieldType ( ) . indexOptions ( ) , equalTo ( TTLFieldMapper . Defaults . TTL_FIELD_TYPE . indexOptions ( ) ) ) ; } public void testSetValuesBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; assertThat ( docMapper . TTLFieldMapper ( ) . enabled ( ) , equalTo ( true ) ) ; assertThat ( docMapper . TTLFieldMapper ( ) . fieldType ( ) . stored ( ) , equalTo ( true ) ) ; } public void testThatEnablingTTLFieldOnMergeWorks ( ) throws Exception { String mappingWithoutTtl = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String mappingWithTtl = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper mapperWithoutTtl = parser . parse ( mappingWithoutTtl ) ; DocumentMapper mapperWithTtl = parser . parse ( mappingWithTtl ) ; MergeResult mergeResult = mapperWithoutTtl . merge ( mapperWithTtl . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( mapperWithoutTtl . TTLFieldMapper ( ) . enabled ( ) , equalTo ( true ) ) ; } public void testThatChangingTTLKeepsMapperEnabled ( ) throws Exception { String mappingWithTtl = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String updatedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper initialMapper = parser . parse ( mappingWithTtl ) ; DocumentMapper updatedMapper = parser . parse ( updatedMapping ) ; MergeResult mergeResult = initialMapper . merge ( updatedMapper . mapping ( ) , true , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( initialMapper . TTLFieldMapper ( ) . enabled ( ) , equalTo ( true ) ) ; } public void testThatDisablingTTLReportsConflict ( ) throws Exception { String mappingWithTtl = getMappingWithTtlEnabled ( ) . string ( ) ; String mappingWithTtlDisabled = getMappingWithTtlDisabled ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper initialMapper = parser . parse ( mappingWithTtl ) ; DocumentMapper updatedMapper = parser . parse ( mappingWithTtlDisabled ) ; MergeResult mergeResult = initialMapper . merge ( updatedMapper . mapping ( ) , true , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( true ) ) ; assertThat ( initialMapper . TTLFieldMapper ( ) . enabled ( ) , equalTo ( true ) ) ; } public void testThatDisablingTTLReportsConflictOnCluster ( ) throws Exception { String mappingWithTtl = getMappingWithTtlEnabled ( ) . string ( ) ; String mappingWithTtlDisabled = getMappingWithTtlDisabled ( ) . string ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , mappingWithTtl ) ) ; GetMappingsResponse mappingsBeforeUpdateResponse = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . addTypes ( <str> ) . get ( ) ; try { client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setSource ( mappingWithTtlDisabled ) . setType ( <str> ) . get ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } GetMappingsResponse mappingsAfterUpdateResponse = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . addTypes ( <str> ) . get ( ) ; assertThat ( mappingsBeforeUpdateResponse . getMappings ( ) . get ( <str> ) . get ( <str> ) . source ( ) , equalTo ( mappingsAfterUpdateResponse . getMappings ( ) . get ( <str> ) . get ( <str> ) . source ( ) ) ) ; } public void testThatEnablingTTLAfterFirstDisablingWorks ( ) throws Exception { String mappingWithTtl = getMappingWithTtlEnabled ( ) . string ( ) ; String withTtlDisabled = getMappingWithTtlDisabled ( ) . string ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , withTtlDisabled ) ) ; GetMappingsResponse mappingsAfterUpdateResponse = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . addTypes ( <str> ) . get ( ) ; assertThat ( mappingsAfterUpdateResponse . getMappings ( ) . get ( <str> ) . get ( <str> ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setSource ( mappingWithTtl ) . setType ( <str> ) . get ( ) ; mappingsAfterUpdateResponse = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . addTypes ( <str> ) . get ( ) ; assertThat ( mappingsAfterUpdateResponse . getMappings ( ) . get ( <str> ) . get ( <str> ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testNoConflictIfNothingSetAndDisabledLater ( ) throws Exception { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> ) ; XContentBuilder mappingWithTtlDisabled = getMappingWithTtlDisabled ( <str> ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlDisabled . string ( ) ) , true ) . mapping ( ) , randomBoolean ( ) , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; } public void testNoConflictIfNothingSetAndEnabledLater ( ) throws Exception { IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> ) ; XContentBuilder mappingWithTtlEnabled = getMappingWithTtlEnabled ( <str> ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlEnabled . string ( ) ) , true ) . mapping ( ) , randomBoolean ( ) , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; } public void testMergeWithOnlyDefaultSet ( ) throws Exception { XContentBuilder mappingWithTtlEnabled = getMappingWithTtlEnabled ( <str> ) ; IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithTtlEnabled ) ; XContentBuilder mappingWithOnlyDefaultSet = getMappingWithOnlyTtlDefaultSet ( <str> ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithOnlyDefaultSet . string ( ) ) , true ) . mapping ( ) , false , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; CompressedXContent mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( new CompressedXContent ( <str> ) ) ) ; } public void testMergeWithOnlyDefaultSetTtlDisabled ( ) throws Exception { XContentBuilder mappingWithTtlEnabled = getMappingWithTtlDisabled ( <str> ) ; IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithTtlEnabled ) ; CompressedXContent mappingAfterCreation = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterCreation , equalTo ( new CompressedXContent ( <str> ) ) ) ; XContentBuilder mappingWithOnlyDefaultSet = getMappingWithOnlyTtlDefaultSet ( <str> ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithOnlyDefaultSet . string ( ) ) , true ) . mapping ( ) , false , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; CompressedXContent mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( new CompressedXContent ( <str> ) ) ) ; } public void testThatSimulatedMergingLeavesStateUntouched ( ) throws Exception { XContentBuilder mappingWithTtl = getMappingWithTtlEnabled ( <str> ) ; IndexService indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithTtl ) ; CompressedXContent mappingBeforeMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; XContentBuilder mappingWithTtlDifferentDefault = getMappingWithTtlEnabled ( <str> ) ; MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlDifferentDefault . string ( ) ) , true ) . mapping ( ) , true , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; CompressedXContent mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( mappingBeforeMerge ) ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; XContentBuilder mappingWithoutTtl = getMappingWithTtlDisabled ( ) ; indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithoutTtl ) ; mappingBeforeMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; XContentBuilder mappingWithTtlEnabled = getMappingWithTtlEnabled ( ) ; mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlEnabled . string ( ) ) , true ) . mapping ( ) , true , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( mappingBeforeMerge ) ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; mappingWithoutTtl = getMappingWithTtlDisabled ( <str> ) ; indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithoutTtl ) ; mappingBeforeMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; mappingWithTtlEnabled = getMappingWithTtlEnabled ( <str> ) ; mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlEnabled . string ( ) ) , true ) . mapping ( ) , true , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( mappingBeforeMerge ) ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; mappingWithoutTtl = getMappingWithTtlDisabled ( <str> ) ; indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> , mappingWithoutTtl ) ; mappingWithTtlEnabled = getMappingWithTtlEnabled ( <str> ) ; mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlEnabled . string ( ) ) , true ) . mapping ( ) , false , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( new CompressedXContent ( <str> ) ) ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; indexService = createIndex ( <str> , Settings . settingsBuilder ( ) . build ( ) , <str> ) ; mappingWithTtlEnabled = getMappingWithTtlEnabled ( <str> ) ; mergeResult = indexService . mapperService ( ) . documentMapper ( <str> ) . merge ( indexService . mapperService ( ) . parse ( <str> , new CompressedXContent ( mappingWithTtlEnabled . string ( ) ) , true ) . mapping ( ) , false , false ) ; assertFalse ( mergeResult . hasConflicts ( ) ) ; mappingAfterMerge = indexService . mapperService ( ) . documentMapper ( <str> ) . mappingSource ( ) ; assertThat ( mappingAfterMerge , equalTo ( new CompressedXContent ( <str> ) ) ) ; } public void testIncludeInObjectBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( MetaData . builder ( ) . build ( ) , mappingMetaData , true , <str> ) ; assertNull ( request . ttl ( ) ) ; assertNull ( docMapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) . rootDoc ( ) . get ( <str> ) ) ; } public void testIncludeInObjectNotAllowed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; try { docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } private org . elasticsearch . common . xcontent . XContentBuilder getMappingWithTtlEnabled ( ) throws IOException { return getMappingWithTtlEnabled ( null ) ; } private org . elasticsearch . common . xcontent . XContentBuilder getMappingWithTtlDisabled ( ) throws IOException { return getMappingWithTtlDisabled ( null ) ; } private org . elasticsearch . common . xcontent . XContentBuilder getMappingWithTtlEnabled ( String defaultValue ) throws IOException { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) ; if ( defaultValue ! = null ) { mapping . field ( <str> , defaultValue ) ; } return mapping . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; } private org . elasticsearch . common . xcontent . XContentBuilder getMappingWithTtlDisabled ( String defaultValue ) throws IOException { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) ; if ( defaultValue ! = null ) { mapping . field ( <str> , defaultValue ) ; } return mapping . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; } private org . elasticsearch . common . xcontent . XContentBuilder getMappingWithOnlyTtlDefaultSet ( String defaultValue ) throws IOException { return XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , defaultValue ) . endObject ( ) . startObject ( <str> ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; } } 
