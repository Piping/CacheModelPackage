package io . netty . util . internal ; import java . util . AbstractQueue ; import java . util . Iterator ; abstract class ConcurrentCircularArrayQueue < E > extends ConcurrentCircularArrayQueueL0Pad < E > { protected static final int REF_BUFFER_PAD ; private static final long REF_ARRAY_BASE ; private static final int REF_ELEMENT_SHIFT ; static { final int scale = PlatformDependent0 . UNSAFE . arrayIndexScale ( Object [ ] . class ) ; if ( <int> = = scale ) { REF_ELEMENT_SHIFT = <int> ; } else if ( <int> = = scale ) { REF_ELEMENT_SHIFT = <int> ; } else { throw new IllegalStateException ( <str> ) ; } REF_BUFFER_PAD = ( <int> * <int> ) / scale ; REF_ARRAY_BASE = PlatformDependent0 . UNSAFE . arrayBaseOffset ( Object [ ] . class ) + ( REF_BUFFER_PAD * scale ) ; } protected final long mask ; protected final E [ ] buffer ; @SuppressWarnings ( <str> ) public ConcurrentCircularArrayQueue ( int capacity ) { int actualCapacity = roundToPowerOfTwo ( capacity ) ; mask = actualCapacity - <int> ; buffer = ( E [ ] ) new Object [ actualCapacity + REF_BUFFER_PAD * <int> ] ; } private static int roundToPowerOfTwo ( final int value ) { return <int> < < ( <int> - Integer . numberOfLeadingZeros ( value - <int> ) ) ; } protected final long calcElementOffset ( long index ) { return calcElementOffset ( index , mask ) ; } protected static final long calcElementOffset ( long index , long mask ) { return REF_ARRAY_BASE + ( ( index & mask ) < < REF_ELEMENT_SHIFT ) ; } protected final void spElement ( long offset , E e ) { spElement ( buffer , offset , e ) ; } protected static final < E > void spElement ( E [ ] buffer , long offset , E e ) { PlatformDependent0 . UNSAFE . putObject ( buffer , offset , e ) ; } protected final void soElement ( long offset , E e ) { soElement ( buffer , offset , e ) ; } protected static final < E > void soElement ( E [ ] buffer , long offset , E e ) { PlatformDependent0 . UNSAFE . putOrderedObject ( buffer , offset , e ) ; } protected final E lpElement ( long offset ) { return lpElement ( buffer , offset ) ; } @SuppressWarnings ( <str> ) protected static final < E > E lpElement ( E [ ] buffer , long offset ) { return ( E ) PlatformDependent0 . UNSAFE . getObject ( buffer , offset ) ; } protected final E lvElement ( long offset ) { return lvElement ( buffer , offset ) ; } @SuppressWarnings ( <str> ) protected static final < E > E lvElement ( E [ ] buffer , long offset ) { return ( E ) PlatformDependent0 . UNSAFE . getObjectVolatile ( buffer , offset ) ; } @Override public Iterator < E > iterator ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { while ( poll ( ) ! = null | | ! isEmpty ( ) ) { } } public int capacity ( ) { return ( int ) ( mask + <int> ) ; } } abstract class ConcurrentCircularArrayQueueL0Pad < E > extends AbstractQueue < E > { long p00 , p01 , p02 , p03 , p04 , p05 , p06 , p07 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; } 
