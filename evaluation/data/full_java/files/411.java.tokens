package org . apache . cassandra . db . filter ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Comparator ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class ColumnSubselection implements Comparable < ColumnSubselection > { public static final Serializer serializer = new Serializer ( ) ; private enum Kind { SLICE , ELEMENT } protected final ColumnDefinition column ; protected ColumnSubselection ( ColumnDefinition column ) { this . column = column ; } public static ColumnSubselection slice ( ColumnDefinition column , CellPath from , CellPath to ) { assert column . isComplex ( ) & & column . type instanceof CollectionType ; assert from . size ( ) < = <int> & & to . size ( ) < = <int> ; return new Slice ( column , from , to ) ; } public static ColumnSubselection element ( ColumnDefinition column , CellPath elt ) { assert column . isComplex ( ) & & column . type instanceof CollectionType ; assert elt . size ( ) = = <int> ; return new Element ( column , elt ) ; } public ColumnDefinition column ( ) { return column ; } protected abstract Kind kind ( ) ; protected abstract CellPath comparisonPath ( ) ; public int compareTo ( ColumnSubselection other ) { assert other . column ( ) . name . equals ( column ( ) . name ) ; return column ( ) . cellPathComparator ( ) . compare ( comparisonPath ( ) , other . comparisonPath ( ) ) ; } public abstract int compareInclusionOf ( CellPath path ) ; private static class Slice extends ColumnSubselection { private final CellPath from ; private final CellPath to ; private Slice ( ColumnDefinition column , CellPath from , CellPath to ) { super ( column ) ; this . from = from ; this . to = to ; } protected Kind kind ( ) { return Kind . SLICE ; } public CellPath comparisonPath ( ) { return from ; } public int compareInclusionOf ( CellPath path ) { Comparator < CellPath > cmp = column . cellPathComparator ( ) ; if ( cmp . compare ( path , from ) < <int> ) return - <int> ; else if ( cmp . compare ( to , path ) < <int> ) return <int> ; else return <int> ; } @Override public String toString ( ) { AbstractType < ? > type = ( ( CollectionType < ? > ) column ( ) . type ) . nameComparator ( ) ; return String . format ( <str> , from = = CellPath . BOTTOM ? <str> : type . getString ( from . get ( <int> ) ) , to = = CellPath . TOP ? <str> : type . getString ( to . get ( <int> ) ) ) ; } } private static class Element extends ColumnSubselection { private final CellPath element ; private Element ( ColumnDefinition column , CellPath elt ) { super ( column ) ; this . element = elt ; } protected Kind kind ( ) { return Kind . ELEMENT ; } public CellPath comparisonPath ( ) { return element ; } public int compareInclusionOf ( CellPath path ) { return column . cellPathComparator ( ) . compare ( path , element ) ; } @Override public String toString ( ) { AbstractType < ? > type = ( ( CollectionType < ? > ) column ( ) . type ) . nameComparator ( ) ; return String . format ( <str> , type . getString ( element . get ( <int> ) ) ) ; } } public static class Serializer { public void serialize ( ColumnSubselection subSel , DataOutputPlus out , int version ) throws IOException { ColumnDefinition column = subSel . column ( ) ; ByteBufferUtil . writeWithShortLength ( column . name . bytes , out ) ; out . writeByte ( subSel . kind ( ) . ordinal ( ) ) ; switch ( subSel . kind ( ) ) { case SLICE : Slice slice = ( Slice ) subSel ; column . cellPathSerializer ( ) . serialize ( slice . from , out ) ; column . cellPathSerializer ( ) . serialize ( slice . to , out ) ; break ; case ELEMENT : Element eltSelection = ( Element ) subSel ; column . cellPathSerializer ( ) . serialize ( eltSelection . element , out ) ; break ; default : throw new AssertionError ( ) ; } } public ColumnSubselection deserialize ( DataInputPlus in , int version , CFMetaData metadata ) throws IOException { ByteBuffer name = ByteBufferUtil . readWithShortLength ( in ) ; ColumnDefinition column = metadata . getColumnDefinition ( name ) ; if ( column = = null ) { column = metadata . getDroppedColumnDefinition ( name ) ; if ( column = = null ) throw new RuntimeException ( <str> + UTF8Type . instance . getString ( name ) + <str> ) ; } Kind kind = Kind . values ( ) [ in . readUnsignedByte ( ) ] ; switch ( kind ) { case SLICE : CellPath from = column . cellPathSerializer ( ) . deserialize ( in ) ; CellPath to = column . cellPathSerializer ( ) . deserialize ( in ) ; return new Slice ( column , from , to ) ; case ELEMENT : CellPath elt = column . cellPathSerializer ( ) . deserialize ( in ) ; return new Element ( column , elt ) ; } throw new AssertionError ( ) ; } public long serializedSize ( ColumnSubselection subSel , int version ) { long size = <int> ; ColumnDefinition column = subSel . column ( ) ; size + = TypeSizes . sizeofWithShortLength ( column . name . bytes ) ; size + = <int> ; switch ( subSel . kind ( ) ) { case SLICE : Slice slice = ( Slice ) subSel ; size + = column . cellPathSerializer ( ) . serializedSize ( slice . from ) ; size + = column . cellPathSerializer ( ) . serializedSize ( slice . to ) ; break ; case ELEMENT : Element element = ( Element ) subSel ; size + = column . cellPathSerializer ( ) . serializedSize ( element . element ) ; break ; } return size ; } } } 
