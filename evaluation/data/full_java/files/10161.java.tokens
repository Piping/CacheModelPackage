package com . google . common . testing ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Preconditions ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Sets ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . util . Set ; @GwtCompatible public class EqualsTesterTest extends TestCase { private ValidTestObject reference ; private EqualsTester equalsTester ; private ValidTestObject equalObject1 ; private ValidTestObject equalObject2 ; private ValidTestObject notEqualObject1 ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; reference = new ValidTestObject ( <int> , <int> ) ; equalsTester = new EqualsTester ( ) ; equalObject1 = new ValidTestObject ( <int> , <int> ) ; equalObject2 = new ValidTestObject ( <int> , <int> ) ; notEqualObject1 = new ValidTestObject ( <int> , <int> ) ; } public void testAddNullReference ( ) { try { equalsTester . addEqualityGroup ( ( Object ) null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } } public void testAddTwoEqualObjectsAtOnceWithNull ( ) { try { equalsTester . addEqualityGroup ( reference , equalObject1 , null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } } public void testAddNullEqualObject ( ) { try { equalsTester . addEqualityGroup ( reference , ( Object [ ] ) null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } } public void testAddEqualObjectWithOArgConstructor ( ) { equalsTester . addEqualityGroup ( equalObject1 , notEqualObject1 ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , equalObject1 + <str> + notEqualObject1 + <str> ) ; return ; } fail ( <str> ) ; } public void testTestEqualsEmptyLists ( ) { equalsTester . addEqualityGroup ( reference ) ; equalsTester . testEquals ( ) ; } public void testTestEqualsEqualsObjects ( ) { equalsTester . addEqualityGroup ( reference , equalObject1 , equalObject2 ) ; equalsTester . testEquals ( ) ; } public void testNonreflexiveEquals ( ) { Object obj = new NonReflexiveObject ( ) ; equalsTester . addEqualityGroup ( obj ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , obj + <str> ) ; return ; } fail ( <str> ) ; } public void testInvalidEqualsNull ( ) { Object obj = new InvalidEqualsNullObject ( ) ; equalsTester . addEqualityGroup ( obj ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , obj + <str> ) ; return ; } fail ( <str> ) ; } public void testInvalidEqualsIncompatibleClass ( ) { Object obj = new InvalidEqualsIncompatibleClassObject ( ) ; equalsTester . addEqualityGroup ( obj ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , obj + <str> ) ; return ; } fail ( <str> ) ; } public void testInvalidNotEqualsEqualObject ( ) { equalsTester . addEqualityGroup ( reference , notEqualObject1 ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , reference + <str> ) ; assertErrorMessage ( e , notEqualObject1 + <str> ) ; return ; } fail ( <str> ) ; } public void testInvalidHashCode ( ) { Object a = new InvalidHashCodeObject ( <int> , <int> ) ; Object b = new InvalidHashCodeObject ( <int> , <int> ) ; equalsTester . addEqualityGroup ( a , b ) ; try { equalsTester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , <str> + a . hashCode ( ) + <str> + a + <str> + b . hashCode ( ) + <str> + b ) ; return ; } fail ( <str> ) ; } public void testNullEqualityGroup ( ) { EqualsTester tester = new EqualsTester ( ) ; try { tester . addEqualityGroup ( ( Object [ ] ) null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } public void testNullObjectInEqualityGroup ( ) { EqualsTester tester = new EqualsTester ( ) ; try { tester . addEqualityGroup ( <int> , null , <int> ) ; fail ( ) ; } catch ( NullPointerException e ) { assertErrorMessage ( e , <str> ) ; } } public void testSymmetryBroken ( ) { EqualsTester tester = new EqualsTester ( ) . addEqualityGroup ( named ( <str> ) . addPeers ( <str> ) , named ( <str> ) ) ; try { tester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , <str> ) ; return ; } fail ( <str> ) ; } public void testTransitivityBrokenInEqualityGroup ( ) { EqualsTester tester = new EqualsTester ( ) . addEqualityGroup ( named ( <str> ) . addPeers ( <str> , <str> ) , named ( <str> ) . addPeers ( <str> ) , named ( <str> ) . addPeers ( <str> ) ) ; try { tester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , <str> ) ; return ; } fail ( <str> ) ; } public void testUnequalObjectsInEqualityGroup ( ) { EqualsTester tester = new EqualsTester ( ) . addEqualityGroup ( named ( <str> ) , named ( <str> ) ) ; try { tester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , <str> ) ; return ; } fail ( <str> ) ; } public void testTransitivityBrokenAcrossEqualityGroups ( ) { EqualsTester tester = new EqualsTester ( ) . addEqualityGroup ( named ( <str> ) . addPeers ( <str> ) , named ( <str> ) . addPeers ( <str> , <str> ) ) . addEqualityGroup ( named ( <str> ) . addPeers ( <str> ) , named ( <str> ) . addPeers ( <str> , <str> ) ) ; try { tester . testEquals ( ) ; } catch ( AssertionFailedError e ) { assertErrorMessage ( e , <str> ) ; return ; } fail ( <str> ) ; } public void testEqualityGroups ( ) { new EqualsTester ( ) . addEqualityGroup ( named ( <str> ) . addPeers ( <str> ) , named ( <str> ) . addPeers ( <str> ) ) . addEqualityGroup ( named ( <str> ) , named ( <str> ) ) . testEquals ( ) ; } private static void assertErrorMessage ( Throwable e , String message ) { if ( ! e . getMessage ( ) . contains ( message ) ) { fail ( <str> + e . getMessage ( ) + <str> + message + <str> ) ; } } private static class ValidTestObject { private int aspect1 ; private int aspect2 ; ValidTestObject ( int aspect1 , int aspect2 ) { this . aspect1 = aspect1 ; this . aspect2 = aspect2 ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof ValidTestObject ) ) { return false ; } ValidTestObject other = ( ValidTestObject ) o ; if ( aspect1 ! = other . aspect1 ) { return false ; } if ( aspect2 ! = other . aspect2 ) { return false ; } return true ; } @Override public int hashCode ( ) { int result = <int> ; result = <int> * result + aspect1 ; result = <int> * result + aspect2 ; return result ; } } private static class InvalidHashCodeObject { private int aspect1 ; private int aspect2 ; InvalidHashCodeObject ( int aspect1 , int aspect2 ) { this . aspect1 = aspect1 ; this . aspect2 = aspect2 ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof InvalidHashCodeObject ) ) { return false ; } InvalidHashCodeObject other = ( InvalidHashCodeObject ) o ; if ( aspect1 ! = other . aspect1 ) { return false ; } if ( aspect2 ! = other . aspect2 ) { return false ; } return true ; } } private static class NonReflexiveObject { @Override public boolean equals ( Object o ) { return false ; } @Override public int hashCode ( ) { return super . hashCode ( ) ; } } private static class InvalidEqualsNullObject { @Override public boolean equals ( Object o ) { return o = = this | | o = = null ; } @Override public int hashCode ( ) { return <int> ; } } private static class InvalidEqualsIncompatibleClassObject { @Override public boolean equals ( Object o ) { return o ! = null ; } @Override public int hashCode ( ) { return <int> ; } } private static NamedObject named ( String name ) { return new NamedObject ( name ) ; } private static class NamedObject { private final Set < String > peerNames = Sets . newHashSet ( ) ; private final String name ; NamedObject ( String name ) { this . name = Preconditions . checkNotNull ( name ) ; } NamedObject addPeers ( String . . . names ) { peerNames . addAll ( ImmutableList . copyOf ( names ) ) ; return this ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof NamedObject ) { NamedObject that = ( NamedObject ) obj ; return name . equals ( that . name ) | | peerNames . contains ( that . name ) ; } return false ; } @Override public int hashCode ( ) { return <int> ; } @Override public String toString ( ) { return name ; } } } 
