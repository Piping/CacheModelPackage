package io . netty . handler . stream ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . io . InputStream ; import java . io . PushbackInputStream ; public class ChunkedStream implements ChunkedInput < ByteBuf > { static final int DEFAULT_CHUNK_SIZE = <int> ; private final PushbackInputStream in ; private final int chunkSize ; private long offset ; private boolean closed ; public ChunkedStream ( InputStream in ) { this ( in , DEFAULT_CHUNK_SIZE ) ; } public ChunkedStream ( InputStream in , int chunkSize ) { if ( in = = null ) { throw new NullPointerException ( <str> ) ; } if ( chunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + chunkSize + <str> ) ; } if ( in instanceof PushbackInputStream ) { this . in = ( PushbackInputStream ) in ; } else { this . in = new PushbackInputStream ( in ) ; } this . chunkSize = chunkSize ; } public long transferredBytes ( ) { return offset ; } @Override public boolean isEndOfInput ( ) throws Exception { if ( closed ) { return true ; } int b = in . read ( ) ; if ( b < <int> ) { return true ; } else { in . unread ( b ) ; return false ; } } @Override public void close ( ) throws Exception { closed = true ; in . close ( ) ; } @Override public ByteBuf readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( isEndOfInput ( ) ) { return null ; } final int availableBytes = in . available ( ) ; final int chunkSize ; if ( availableBytes < = <int> ) { chunkSize = this . chunkSize ; } else { chunkSize = Math . min ( this . chunkSize , in . available ( ) ) ; } boolean release = true ; ByteBuf buffer = ctx . alloc ( ) . buffer ( chunkSize ) ; try { offset + = buffer . writeBytes ( in , chunkSize ) ; release = false ; return buffer ; } finally { if ( release ) { buffer . release ( ) ; } } } @Override public long length ( ) { return - <int> ; } @Override public long progress ( ) { return offset ; } } 
