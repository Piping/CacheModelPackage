package com . badlogic . gdx . graphics . g3d . particles . values ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; public final class UnweightedMeshSpawnShapeValue extends MeshSpawnShapeValue { private float [ ] vertices ; private short [ ] indices ; private int positionOffset , vertexSize , vertexCount , triangleCount ; public UnweightedMeshSpawnShapeValue ( UnweightedMeshSpawnShapeValue value ) { super ( value ) ; load ( value ) ; } public UnweightedMeshSpawnShapeValue ( ) { } @Override public void setMesh ( Mesh mesh , Model model ) { super . setMesh ( mesh , model ) ; vertexSize = mesh . getVertexSize ( ) / <int> ; positionOffset = mesh . getVertexAttribute ( Usage . Position ) . offset / <int> ; int indicesCount = mesh . getNumIndices ( ) ; if ( indicesCount > <int> ) { indices = new short [ indicesCount ] ; mesh . getIndices ( indices ) ; triangleCount = indices . length / <int> ; } else indices = null ; vertexCount = mesh . getNumVertices ( ) ; vertices = new float [ vertexCount * vertexSize ] ; mesh . getVertices ( vertices ) ; } @Override public void spawnAux ( Vector3 vector , float percent ) { if ( indices = = null ) { int triangleIndex = MathUtils . random ( vertexCount - <int> ) * vertexSize ; int p1Offset = triangleIndex + positionOffset , p2Offset = p1Offset + vertexSize , p3Offset = p2Offset + vertexSize ; float x1 = vertices [ p1Offset ] , y1 = vertices [ p1Offset + <int> ] , z1 = vertices [ p1Offset + <int> ] , x2 = vertices [ p2Offset ] , y2 = vertices [ p2Offset + <int> ] , z2 = vertices [ p2Offset + <int> ] , x3 = vertices [ p3Offset ] , y3 = vertices [ p3Offset + <int> ] , z3 = vertices [ p3Offset + <int> ] ; Triangle . pick ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , vector ) ; } else { int triangleIndex = MathUtils . random ( triangleCount - <int> ) * <int> ; int p1Offset = indices [ triangleIndex ] * vertexSize + positionOffset , p2Offset = indices [ triangleIndex + <int> ] * vertexSize + positionOffset , p3Offset = indices [ triangleIndex + <int> ] * vertexSize + positionOffset ; float x1 = vertices [ p1Offset ] , y1 = vertices [ p1Offset + <int> ] , z1 = vertices [ p1Offset + <int> ] , x2 = vertices [ p2Offset ] , y2 = vertices [ p2Offset + <int> ] , z2 = vertices [ p2Offset + <int> ] , x3 = vertices [ p3Offset ] , y3 = vertices [ p3Offset + <int> ] , z3 = vertices [ p3Offset + <int> ] ; Triangle . pick ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , vector ) ; } } @Override public SpawnShapeValue copy ( ) { return new UnweightedMeshSpawnShapeValue ( this ) ; } } 
