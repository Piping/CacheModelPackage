package org . gradle . api . internal . file . collections ; import org . gradle . api . file . * ; import org . gradle . api . internal . file . DefaultFileVisitDetails ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . util . PatternFilterable ; import org . gradle . api . tasks . util . PatternSet ; import org . gradle . internal . Factory ; import org . gradle . internal . nativeintegration . filesystem . FileSystem ; import org . gradle . internal . nativeintegration . services . FileSystems ; import org . gradle . util . GFileUtils ; import org . gradle . util . GUtil ; import java . io . File ; import java . util . Collection ; import java . util . Collections ; import java . util . concurrent . atomic . AtomicBoolean ; public class DirectoryFileTree implements MinimalFileTree , PatternFilterableFileTree , RandomAccessFileCollection , LocalFileTree , DirectoryTree { private static final Logger LOGGER = Logging . getLogger ( DirectoryFileTree . class ) ; private final File dir ; private PatternSet patternSet ; private boolean postfix ; private final FileSystem fileSystem = FileSystems . getDefault ( ) ; private static final Factory < DirectoryWalker > DEFAULT_DIRECTORY_WALKER_FACTORY = new DefaultDirectoryWalkerFactory ( ) ; private final Factory < DirectoryWalker > directoryWalkerFactory ; public DirectoryFileTree ( File dir ) { this ( dir , new PatternSet ( ) ) ; } public DirectoryFileTree ( File dir , PatternSet patternSet ) { this ( dir , patternSet , DEFAULT_DIRECTORY_WALKER_FACTORY ) ; } DirectoryFileTree ( File dir , PatternSet patternSet , Factory < DirectoryWalker > directoryWalkerFactory ) { this . patternSet = patternSet ; this . dir = GFileUtils . canonicalise ( dir ) ; this . directoryWalkerFactory = directoryWalkerFactory ; } public String getDisplayName ( ) { String includes = patternSet . getIncludes ( ) . isEmpty ( ) ? <str> : String . format ( <str> , GUtil . toString ( patternSet . getIncludes ( ) ) ) ; String excludes = patternSet . getExcludes ( ) . isEmpty ( ) ? <str> : String . format ( <str> , GUtil . toString ( patternSet . getExcludes ( ) ) ) ; return String . format ( <str> , dir , includes , excludes ) ; } @Override public String toString ( ) { return getDisplayName ( ) ; } public PatternSet getPatterns ( ) { return patternSet ; } public File getDir ( ) { return dir ; } public Collection < DirectoryFileTree > getLocalContents ( ) { return Collections . singletonList ( this ) ; } public DirectoryFileTree filter ( PatternFilterable patterns ) { PatternSet patternSet = this . patternSet . intersect ( ) ; patternSet . copyFrom ( patterns ) ; return new DirectoryFileTree ( dir , patternSet , directoryWalkerFactory ) ; } public boolean contains ( File file ) { return DirectoryTrees . contains ( fileSystem , this , file ) & & file . isFile ( ) ; } @Override public void registerWatchPoints ( FileSystemSubset . Builder builder ) { builder . add ( this ) ; } @Override public void visitTreeOrBackingFile ( FileVisitor visitor ) { visit ( visitor ) ; } public void visit ( FileVisitor visitor ) { visitFrom ( visitor , dir , new RelativePath ( false ) ) ; } public void visitFrom ( FileVisitor visitor , File dir , RelativePath path ) { AtomicBoolean stopFlag = new AtomicBoolean ( ) ; Spec < FileTreeElement > spec = patternSet . getAsSpec ( ) ; if ( dir . exists ( ) ) { if ( dir . isFile ( ) ) { processSingleFile ( dir , visitor , spec , stopFlag ) ; } else { walkDir ( dir , path , visitor , spec , stopFlag ) ; } } else { LOGGER . info ( <str> , dir ) ; } } private void processSingleFile ( File file , FileVisitor visitor , Spec < FileTreeElement > spec , AtomicBoolean stopFlag ) { RelativePath path = new RelativePath ( true , file . getName ( ) ) ; FileVisitDetails details = new DefaultFileVisitDetails ( file , path , stopFlag , fileSystem , fileSystem , false ) ; if ( isAllowed ( details , spec ) ) { visitor . visitFile ( details ) ; } } private void walkDir ( File file , RelativePath path , FileVisitor visitor , Spec < FileTreeElement > spec , AtomicBoolean stopFlag ) { directoryWalkerFactory . create ( ) . walkDir ( file , path , visitor , spec , stopFlag , fileSystem , postfix ) ; } static boolean isAllowed ( FileTreeElement element , Spec < FileTreeElement > spec ) { return spec . isSatisfiedBy ( element ) ; } public DirectoryFileTree postfix ( ) { postfix = true ; return this ; } public PatternSet getPatternSet ( ) { return patternSet ; } } 
