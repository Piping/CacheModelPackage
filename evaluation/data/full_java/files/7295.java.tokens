package org . elasticsearch . search . aggregations . metrics . cardinality ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . metrics . InternalNumericMetricsAggregation ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . aggregations . support . format . ValueFormatterStreams ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public final class InternalCardinality extends InternalNumericMetricsAggregation . SingleValue implements Cardinality { public final static Type TYPE = new Type ( <str> ) ; public final static AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public InternalCardinality readResult ( StreamInput in ) throws IOException { InternalCardinality result = new InternalCardinality ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } private HyperLogLogPlusPlus counts ; InternalCardinality ( String name , HyperLogLogPlusPlus counts , ValueFormatter formatter , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; this . counts = counts ; this . valueFormatter = formatter ; } private InternalCardinality ( ) { } @Override public double value ( ) { return getValue ( ) ; } @Override public long getValue ( ) { return counts = = null ? <int> : counts . cardinality ( <int> ) ; } @Override public Type type ( ) { return TYPE ; } @Override protected void doReadFrom ( StreamInput in ) throws IOException { valueFormatter = ValueFormatterStreams . readOptional ( in ) ; if ( in . readBoolean ( ) ) { counts = HyperLogLogPlusPlus . readFrom ( in , BigArrays . NON_RECYCLING_INSTANCE ) ; } else { counts = null ; } } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { ValueFormatterStreams . writeOptional ( valueFormatter , out ) ; if ( counts ! = null ) { out . writeBoolean ( true ) ; counts . writeTo ( <int> , out ) ; } else { out . writeBoolean ( false ) ; } } @Override public InternalAggregation doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { InternalCardinality reduced = null ; for ( InternalAggregation aggregation : aggregations ) { final InternalCardinality cardinality = ( InternalCardinality ) aggregation ; if ( cardinality . counts ! = null ) { if ( reduced = = null ) { reduced = new InternalCardinality ( name , new HyperLogLogPlusPlus ( cardinality . counts . precision ( ) , BigArrays . NON_RECYCLING_INSTANCE , <int> ) , this . valueFormatter , pipelineAggregators ( ) , getMetaData ( ) ) ; } reduced . merge ( cardinality ) ; } } if ( reduced = = null ) { return aggregations . get ( <int> ) ; } else { return reduced ; } } public void merge ( InternalCardinality other ) { assert counts ! = null & & other ! = null ; counts . merge ( <int> , other . counts , <int> ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { final long cardinality = getValue ( ) ; builder . field ( CommonFields . VALUE , cardinality ) ; if ( ! ( valueFormatter instanceof ValueFormatter . Raw ) ) { builder . field ( CommonFields . VALUE_AS_STRING , valueFormatter . format ( cardinality ) ) ; } return builder ; } } 
