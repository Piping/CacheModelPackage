package org . elasticsearch . common . util ; import org . apache . lucene . store . ByteArrayDataInput ; import org . apache . lucene . store . ByteArrayDataOutput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; public class ByteUtilsTests extends ESTestCase { public void testZigZag ( long l ) { assertEquals ( l , ByteUtils . zigZagDecode ( ByteUtils . zigZagEncode ( l ) ) ) ; } public void testZigZag ( ) { testZigZag ( <int> ) ; testZigZag ( <int> ) ; testZigZag ( - <int> ) ; testZigZag ( Long . MAX_VALUE ) ; testZigZag ( Long . MIN_VALUE ) ; for ( int i = <int> ; i < <int> ; + + i ) { testZigZag ( randomLong ( ) ) ; assertTrue ( ByteUtils . zigZagEncode ( randomInt ( <int> ) ) > = <int> ) ; assertTrue ( ByteUtils . zigZagEncode ( - randomInt ( <int> ) ) > = <int> ) ; } } public void testFloat ( ) throws IOException { final float [ ] data = new float [ scaledRandomIntBetween ( <int> , <int> ) ] ; final byte [ ] encoded = new byte [ data . length * <int> ] ; for ( int i = <int> ; i < data . length ; + + i ) { data [ i ] = randomFloat ( ) ; ByteUtils . writeFloatLE ( data [ i ] , encoded , i * <int> ) ; } for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( data [ i ] , ByteUtils . readFloatLE ( encoded , i * <int> ) , Float . MIN_VALUE ) ; } } public void testDouble ( ) throws IOException { final double [ ] data = new double [ scaledRandomIntBetween ( <int> , <int> ) ] ; final byte [ ] encoded = new byte [ data . length * <int> ] ; for ( int i = <int> ; i < data . length ; + + i ) { data [ i ] = randomDouble ( ) ; ByteUtils . writeDoubleLE ( data [ i ] , encoded , i * <int> ) ; } for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( data [ i ] , ByteUtils . readDoubleLE ( encoded , i * <int> ) , Double . MIN_VALUE ) ; } } public void testVLong ( ) throws IOException { final long [ ] data = new long [ scaledRandomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < data . length ; + + i ) { switch ( randomInt ( <int> ) ) { case <int> : data [ i ] = <int> ; break ; case <int> : data [ i ] = Long . MAX_VALUE ; break ; case <int> : data [ i ] = Long . MIN_VALUE ; break ; case <int> : data [ i ] = randomInt ( <int> < < randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : data [ i ] = randomLong ( ) ; break ; default : throw new AssertionError ( ) ; } } final byte [ ] encoded = new byte [ ByteUtils . MAX_BYTES_VLONG * data . length ] ; ByteArrayDataOutput out = new ByteArrayDataOutput ( encoded ) ; for ( int i = <int> ; i < data . length ; + + i ) { final int pos = out . getPosition ( ) ; ByteUtils . writeVLong ( out , data [ i ] ) ; if ( data [ i ] < <int> ) { assertEquals ( ByteUtils . MAX_BYTES_VLONG , out . getPosition ( ) - pos ) ; } } final ByteArrayDataInput in = new ByteArrayDataInput ( encoded ) ; for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( data [ i ] , ByteUtils . readVLong ( in ) ) ; } } } 
