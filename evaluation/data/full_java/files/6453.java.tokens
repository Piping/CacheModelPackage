package org . elasticsearch . index . fielddata ; import org . apache . lucene . index . FilteredTermsEnum ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . index . fielddata . plain . AbstractIndexFieldData ; import org . elasticsearch . common . breaker . CircuitBreaker ; import java . io . IOException ; public final class RamAccountingTermsEnum extends FilteredTermsEnum { private static final long FLUSH_BUFFER_SIZE = <int> * <int> * <int> ; private final CircuitBreaker breaker ; private final TermsEnum termsEnum ; private final AbstractIndexFieldData . PerValueEstimator estimator ; private final String fieldName ; private long totalBytes ; private long flushBuffer ; public RamAccountingTermsEnum ( TermsEnum termsEnum , CircuitBreaker breaker , AbstractIndexFieldData . PerValueEstimator estimator , String fieldName ) { super ( termsEnum ) ; this . breaker = breaker ; this . termsEnum = termsEnum ; this . estimator = estimator ; this . fieldName = fieldName ; this . totalBytes = <int> ; this . flushBuffer = <int> ; } @Override protected AcceptStatus accept ( BytesRef term ) throws IOException { return AcceptStatus . YES ; } public void flush ( ) { breaker . addEstimateBytesAndMaybeBreak ( this . flushBuffer , this . fieldName ) ; this . totalBytes + = this . flushBuffer ; this . flushBuffer = <int> ; } @Override public BytesRef next ( ) throws IOException { BytesRef term = termsEnum . next ( ) ; if ( term = = null & & this . flushBuffer ! = <int> ) { flush ( ) ; } else { this . flushBuffer + = estimator . bytesPerValue ( term ) ; if ( this . flushBuffer > = FLUSH_BUFFER_SIZE ) { flush ( ) ; } } return term ; } public long getTotalBytes ( ) { return this . totalBytes ; } } 
