package org . elasticsearch . cluster . routing ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . atomic . AtomicBoolean ; public class RoutingService extends AbstractLifecycleComponent < RoutingService > implements ClusterStateListener { private static final String CLUSTER_UPDATE_TASK_SOURCE = <str> ; final ThreadPool threadPool ; private final ClusterService clusterService ; private final AllocationService allocationService ; private AtomicBoolean rerouting = new AtomicBoolean ( ) ; private volatile long minDelaySettingAtLastSchedulingNanos = Long . MAX_VALUE ; private volatile ScheduledFuture registeredNextDelayFuture ; @Inject public RoutingService ( Settings settings , ThreadPool threadPool , ClusterService clusterService , AllocationService allocationService ) { super ( settings ) ; this . threadPool = threadPool ; this . clusterService = clusterService ; this . allocationService = allocationService ; if ( clusterService ! = null ) { clusterService . addFirst ( this ) ; } } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { FutureUtils . cancel ( registeredNextDelayFuture ) ; clusterService . remove ( this ) ; } public AllocationService getAllocationService ( ) { return this . allocationService ; } public final void reroute ( String reason ) { performReroute ( reason ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . state ( ) . nodes ( ) . localNodeMaster ( ) ) { long minDelaySetting = UnassignedInfo . findSmallestDelayedAllocationSettingNanos ( settings , event . state ( ) ) ; if ( minDelaySetting < = <int> ) { logger . trace ( <str> , minDelaySetting , minDelaySettingAtLastSchedulingNanos ) ; minDelaySettingAtLastSchedulingNanos = Long . MAX_VALUE ; FutureUtils . cancel ( registeredNextDelayFuture ) ; } else if ( minDelaySetting < minDelaySettingAtLastSchedulingNanos ) { FutureUtils . cancel ( registeredNextDelayFuture ) ; minDelaySettingAtLastSchedulingNanos = minDelaySetting ; TimeValue nextDelay = TimeValue . timeValueNanos ( UnassignedInfo . findNextDelayedAllocationIn ( event . state ( ) ) ) ; assert nextDelay . nanos ( ) > <int> : <str> + minDelaySetting + <str> ; logger . info ( <str> , UnassignedInfo . getNumberOfDelayedUnassigned ( event . state ( ) ) , nextDelay ) ; registeredNextDelayFuture = threadPool . schedule ( nextDelay , ThreadPool . Names . SAME , new AbstractRunnable ( ) { @Override protected void doRun ( ) throws Exception { minDelaySettingAtLastSchedulingNanos = Long . MAX_VALUE ; reroute ( <str> ) ; } @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , t ) ; minDelaySettingAtLastSchedulingNanos = Long . MAX_VALUE ; } } ) ; } else { logger . trace ( <str> , minDelaySetting , minDelaySettingAtLastSchedulingNanos ) ; } } } long getMinDelaySettingAtLastSchedulingNanos ( ) { return this . minDelaySettingAtLastSchedulingNanos ; } protected void performReroute ( String reason ) { try { if ( lifecycle . stopped ( ) ) { return ; } if ( rerouting . compareAndSet ( false , true ) = = false ) { logger . trace ( <str> , reason ) ; return ; } logger . trace ( <str> , reason ) ; clusterService . submitStateUpdateTask ( CLUSTER_UPDATE_TASK_SOURCE + <str> + reason + <str> , new ClusterStateUpdateTask ( Priority . HIGH ) { @Override public ClusterState execute ( ClusterState currentState ) { rerouting . set ( false ) ; RoutingAllocation . Result routingResult = allocationService . reroute ( currentState , reason ) ; if ( ! routingResult . changed ( ) ) { return currentState ; } return ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; } @Override public void onNoLongerMaster ( String source ) { rerouting . set ( false ) ; } @Override public void onFailure ( String source , Throwable t ) { rerouting . set ( false ) ; ClusterState state = clusterService . state ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . error ( <str> , t , source , state . prettyPrint ( ) ) ; } else { logger . error ( <str> , t , source , state . version ( ) ) ; } } } ) ; } catch ( Throwable e ) { rerouting . set ( false ) ; ClusterState state = clusterService . state ( ) ; logger . warn ( <str> , e , state . prettyPrint ( ) ) ; } } } 
