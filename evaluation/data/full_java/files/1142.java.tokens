package org . apache . cassandra . tools . nodetool ; import static com . google . common . base . Preconditions . checkArgument ; import static java . lang . String . format ; import io . airlift . command . Arguments ; import io . airlift . command . Command ; import java . util . ArrayList ; import java . util . List ; import org . apache . cassandra . metrics . CassandraMetricsRegistry ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; import org . apache . cassandra . utils . EstimatedHistogram ; import org . apache . commons . lang3 . ArrayUtils ; @Command ( name = <str> , description = <str> ) public class TableHistograms extends NodeToolCmd { @Arguments ( usage = <str> , description = <str> ) private List < String > args = new ArrayList < > ( ) ; @Override public void execute ( NodeProbe probe ) { checkArgument ( args . size ( ) = = <int> , <str> ) ; String keyspace = args . get ( <int> ) ; String table = args . get ( <int> ) ; long [ ] estimatedPartitionSize = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , <str> ) ; long [ ] estimatedColumnCount = ( long [ ] ) probe . getColumnFamilyMetric ( keyspace , table , <str> ) ; double [ ] estimatedRowSizePercentiles = new double [ <int> ] ; double [ ] estimatedColumnCountPercentiles = new double [ <int> ] ; double [ ] offsetPercentiles = new double [ ] { <float> , <float> , <float> , <float> , <float> } ; if ( ArrayUtils . isEmpty ( estimatedPartitionSize ) | | ArrayUtils . isEmpty ( estimatedColumnCount ) ) { System . err . println ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { estimatedRowSizePercentiles [ i ] = Double . NaN ; estimatedColumnCountPercentiles [ i ] = Double . NaN ; } } else { long [ ] partitionSizeBucketOffsets = new EstimatedHistogram ( estimatedPartitionSize . length ) . getBucketOffsets ( ) ; long [ ] columnCountBucketOffsets = new EstimatedHistogram ( estimatedColumnCount . length ) . getBucketOffsets ( ) ; EstimatedHistogram partitionSizeHist = new EstimatedHistogram ( partitionSizeBucketOffsets , estimatedPartitionSize ) ; EstimatedHistogram columnCountHist = new EstimatedHistogram ( columnCountBucketOffsets , estimatedColumnCount ) ; if ( partitionSizeHist . isOverflowed ( ) ) { System . err . println ( String . format ( <str> , partitionSizeBucketOffsets [ partitionSizeBucketOffsets . length - <int> ] ) ) ; for ( int i = <int> ; i < offsetPercentiles . length ; i + + ) estimatedRowSizePercentiles [ i ] = Double . NaN ; } else { for ( int i = <int> ; i < offsetPercentiles . length ; i + + ) estimatedRowSizePercentiles [ i ] = partitionSizeHist . percentile ( offsetPercentiles [ i ] ) ; } if ( columnCountHist . isOverflowed ( ) ) { System . err . println ( String . format ( <str> , columnCountBucketOffsets [ columnCountBucketOffsets . length - <int> ] ) ) ; for ( int i = <int> ; i < estimatedColumnCountPercentiles . length ; i + + ) estimatedColumnCountPercentiles [ i ] = Double . NaN ; } else { for ( int i = <int> ; i < offsetPercentiles . length ; i + + ) estimatedColumnCountPercentiles [ i ] = columnCountHist . percentile ( offsetPercentiles [ i ] ) ; } estimatedRowSizePercentiles [ <int> ] = partitionSizeHist . min ( ) ; estimatedColumnCountPercentiles [ <int> ] = columnCountHist . min ( ) ; estimatedRowSizePercentiles [ <int> ] = partitionSizeHist . max ( ) ; estimatedColumnCountPercentiles [ <int> ] = columnCountHist . max ( ) ; } String [ ] percentiles = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; double [ ] readLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , <str> ) ) ; double [ ] writeLatency = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspace , table , <str> ) ) ; double [ ] sstablesPerRead = probe . metricPercentilesAsArray ( ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspace , table , <str> ) ) ; System . out . println ( format ( <str> , keyspace , table ) ) ; System . out . println ( format ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; System . out . println ( format ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; for ( int i = <int> ; i < percentiles . length ; i + + ) { System . out . println ( format ( <str> , percentiles [ i ] , sstablesPerRead [ i ] , writeLatency [ i ] , readLatency [ i ] , estimatedRowSizePercentiles [ i ] , estimatedColumnCountPercentiles [ i ] ) ) ; } System . out . println ( ) ; } } 
