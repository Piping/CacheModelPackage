package org . elasticsearch . search . aggregations . pipeline . movavg ; import org . elasticsearch . common . collect . EvictingQueue ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . ReduceContext ; import org . elasticsearch . search . aggregations . InternalAggregation . Type ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . bucket . histogram . HistogramAggregator ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . InternalSimpleValue ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorStreams ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModelStreams ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . aggregations . support . format . ValueFormatterStreams ; import org . joda . time . DateTime ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . stream . Collectors ; import java . util . stream . StreamSupport ; import static org . elasticsearch . search . aggregations . pipeline . BucketHelpers . resolveBucketValue ; public class MovAvgPipelineAggregator extends PipelineAggregator { public final static Type TYPE = new Type ( <str> ) ; public final static PipelineAggregatorStreams . Stream STREAM = new PipelineAggregatorStreams . Stream ( ) { @Override public MovAvgPipelineAggregator readResult ( StreamInput in ) throws IOException { MovAvgPipelineAggregator result = new MovAvgPipelineAggregator ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { PipelineAggregatorStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } private ValueFormatter formatter ; private GapPolicy gapPolicy ; private int window ; private MovAvgModel model ; private int predict ; private boolean minimize ; public MovAvgPipelineAggregator ( ) { } public MovAvgPipelineAggregator ( String name , String [ ] bucketsPaths , ValueFormatter formatter , GapPolicy gapPolicy , int window , int predict , MovAvgModel model , boolean minimize , Map < String , Object > metadata ) { super ( name , bucketsPaths , metadata ) ; this . formatter = formatter ; this . gapPolicy = gapPolicy ; this . window = window ; this . model = model ; this . predict = predict ; this . minimize = minimize ; } @Override public Type type ( ) { return TYPE ; } @Override public InternalAggregation reduce ( InternalAggregation aggregation , ReduceContext reduceContext ) { InternalHistogram histo = ( InternalHistogram ) aggregation ; List < ? extends InternalHistogram . Bucket > buckets = histo . getBuckets ( ) ; InternalHistogram . Factory < ? extends InternalHistogram . Bucket > factory = histo . getFactory ( ) ; List newBuckets = new ArrayList < > ( ) ; EvictingQueue < Double > values = new EvictingQueue < > ( this . window ) ; long lastValidKey = <int> ; int lastValidPosition = <int> ; int counter = <int> ; if ( minimize ) { assert ( model . canBeMinimized ( ) ) ; model = minimize ( buckets , histo , model ) ; } for ( InternalHistogram . Bucket bucket : buckets ) { Double thisBucketValue = resolveBucketValue ( histo , bucket , bucketsPaths ( ) [ <int> ] , gapPolicy ) ; InternalHistogram . Bucket newBucket = bucket ; if ( ! ( thisBucketValue = = null | | thisBucketValue . equals ( Double . NaN ) ) ) { if ( model . hasValue ( values . size ( ) ) ) { double movavg = model . next ( values ) ; List < InternalAggregation > aggs = StreamSupport . stream ( bucket . getAggregations ( ) . spliterator ( ) , false ) . map ( ( p ) - > { return ( InternalAggregation ) p ; } ) . collect ( Collectors . toList ( ) ) ; aggs . add ( new InternalSimpleValue ( name ( ) , movavg , formatter , new ArrayList < PipelineAggregator > ( ) , metaData ( ) ) ) ; newBucket = factory . createBucket ( bucket . getKey ( ) , bucket . getDocCount ( ) , new InternalAggregations ( aggs ) , bucket . getKeyed ( ) , bucket . getFormatter ( ) ) ; } if ( predict > <int> ) { if ( bucket . getKey ( ) instanceof Number ) { lastValidKey = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; } else if ( bucket . getKey ( ) instanceof DateTime ) { lastValidKey = ( ( DateTime ) bucket . getKey ( ) ) . getMillis ( ) ; } else { throw new AggregationExecutionException ( <str> + lastValidKey + <str> ) ; } lastValidPosition = counter ; } values . offer ( thisBucketValue ) ; } counter + = <int> ; newBuckets . add ( newBucket ) ; } if ( buckets . size ( ) > <int> & & predict > <int> ) { boolean keyed ; ValueFormatter formatter ; keyed = buckets . get ( <int> ) . getKeyed ( ) ; formatter = buckets . get ( <int> ) . getFormatter ( ) ; double [ ] predictions = model . predict ( values , predict ) ; for ( int i = <int> ; i < predictions . length ; i + + ) { List < InternalAggregation > aggs ; long newKey = histo . getRounding ( ) . nextRoundingValue ( lastValidKey ) ; if ( lastValidPosition + i + <int> < newBuckets . size ( ) ) { InternalHistogram . Bucket bucket = ( InternalHistogram . Bucket ) newBuckets . get ( lastValidPosition + i + <int> ) ; aggs = StreamSupport . stream ( bucket . getAggregations ( ) . spliterator ( ) , false ) . map ( ( p ) - > { return ( InternalAggregation ) p ; } ) . collect ( Collectors . toList ( ) ) ; aggs . add ( new InternalSimpleValue ( name ( ) , predictions [ i ] , formatter , new ArrayList < PipelineAggregator > ( ) , metaData ( ) ) ) ; InternalHistogram . Bucket newBucket = factory . createBucket ( newKey , <int> , new InternalAggregations ( aggs ) , keyed , formatter ) ; newBuckets . set ( lastValidPosition + i + <int> , newBucket ) ; } else { aggs = new ArrayList < > ( ) ; aggs . add ( new InternalSimpleValue ( name ( ) , predictions [ i ] , formatter , new ArrayList < PipelineAggregator > ( ) , metaData ( ) ) ) ; InternalHistogram . Bucket newBucket = factory . createBucket ( newKey , <int> , new InternalAggregations ( aggs ) , keyed , formatter ) ; newBuckets . add ( newBucket ) ; } lastValidKey = newKey ; } } return factory . create ( newBuckets , histo ) ; } private MovAvgModel minimize ( List < ? extends InternalHistogram . Bucket > buckets , InternalHistogram histo , MovAvgModel model ) { int counter = <int> ; EvictingQueue < Double > values = new EvictingQueue < > ( this . window ) ; double [ ] test = new double [ window ] ; ListIterator < ? extends InternalHistogram . Bucket > iter = buckets . listIterator ( buckets . size ( ) ) ; while ( iter . hasPrevious ( ) & & counter < window ) { Double thisBucketValue = resolveBucketValue ( histo , iter . previous ( ) , bucketsPaths ( ) [ <int> ] , gapPolicy ) ; if ( ! ( thisBucketValue = = null | | thisBucketValue . equals ( Double . NaN ) ) ) { test [ window - counter - <int> ] = thisBucketValue ; counter + = <int> ; } } if ( counter < window ) { return model ; } counter = <int> ; double [ ] train = new double [ window ] ; while ( iter . hasPrevious ( ) & & counter < window ) { Double thisBucketValue = resolveBucketValue ( histo , iter . previous ( ) , bucketsPaths ( ) [ <int> ] , gapPolicy ) ; if ( ! ( thisBucketValue = = null | | thisBucketValue . equals ( Double . NaN ) ) ) { train [ window - counter - <int> ] = thisBucketValue ; counter + = <int> ; } } if ( counter < window ) { return model ; } for ( double v : train ) { values . add ( v ) ; } return SimulatedAnealingMinimizer . minimize ( model , values , test ) ; } @Override public void doReadFrom ( StreamInput in ) throws IOException { formatter = ValueFormatterStreams . readOptional ( in ) ; gapPolicy = GapPolicy . readFrom ( in ) ; window = in . readVInt ( ) ; predict = in . readVInt ( ) ; model = MovAvgModelStreams . read ( in ) ; minimize = in . readBoolean ( ) ; } @Override public void doWriteTo ( StreamOutput out ) throws IOException { ValueFormatterStreams . writeOptional ( formatter , out ) ; gapPolicy . writeTo ( out ) ; out . writeVInt ( window ) ; out . writeVInt ( predict ) ; model . writeTo ( out ) ; out . writeBoolean ( minimize ) ; } public static class Factory extends PipelineAggregatorFactory { private final ValueFormatter formatter ; private GapPolicy gapPolicy ; private int window ; private MovAvgModel model ; private int predict ; private boolean minimize ; public Factory ( String name , String [ ] bucketsPaths , ValueFormatter formatter , GapPolicy gapPolicy , int window , int predict , MovAvgModel model , boolean minimize ) { super ( name , TYPE . name ( ) , bucketsPaths ) ; this . formatter = formatter ; this . gapPolicy = gapPolicy ; this . window = window ; this . model = model ; this . predict = predict ; this . minimize = minimize ; } @Override protected PipelineAggregator createInternal ( Map < String , Object > metaData ) throws IOException { return new MovAvgPipelineAggregator ( name , bucketsPaths , formatter , gapPolicy , window , predict , model , minimize , metaData ) ; } @Override public void doValidate ( AggregatorFactory parent , AggregatorFactory [ ] aggFactories , List < PipelineAggregatorFactory > pipelineAggregatoractories ) { if ( bucketsPaths . length ! = <int> ) { throw new IllegalStateException ( PipelineAggregator . Parser . BUCKETS_PATH . getPreferredName ( ) + <str> + name + <str> ) ; } if ( ! ( parent instanceof HistogramAggregator . Factory ) ) { throw new IllegalStateException ( <str> + name + <str> ) ; } else { HistogramAggregator . Factory histoParent = ( HistogramAggregator . Factory ) parent ; if ( histoParent . minDocCount ( ) ! = <int> ) { throw new IllegalStateException ( <str> + name + <str> ) ; } } } } } 
