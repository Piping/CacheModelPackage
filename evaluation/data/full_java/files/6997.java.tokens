package org . elasticsearch . rest . action . admin . indices . mapping . get ; import org . elasticsearch . action . admin . indices . mapping . get . GetFieldMappingsRequest ; import org . elasticsearch . action . admin . indices . mapping . get . GetFieldMappingsResponse ; import org . elasticsearch . action . admin . indices . mapping . get . GetFieldMappingsResponse . FieldMappingMetaData ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . rest . BaseRestHandler ; import org . elasticsearch . rest . BytesRestResponse ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import java . io . IOException ; import java . util . Map ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestStatus . NOT_FOUND ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestGetFieldMappingAction extends BaseRestHandler { @Inject public RestGetFieldMappingAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; final String [ ] types = request . paramAsStringArrayOrEmptyIfAll ( <str> ) ; final String [ ] fields = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; GetFieldMappingsRequest getMappingsRequest = new GetFieldMappingsRequest ( ) ; getMappingsRequest . indices ( indices ) . types ( types ) . fields ( fields ) . includeDefaults ( request . paramAsBoolean ( <str> , false ) ) ; getMappingsRequest . indicesOptions ( IndicesOptions . fromRequest ( request , getMappingsRequest . indicesOptions ( ) ) ) ; getMappingsRequest . local ( request . paramAsBoolean ( <str> , getMappingsRequest . local ( ) ) ) ; client . admin ( ) . indices ( ) . getFieldMappings ( getMappingsRequest , new RestBuilderListener < GetFieldMappingsResponse > ( channel ) { @Override public RestResponse buildResponse ( GetFieldMappingsResponse response , XContentBuilder builder ) throws Exception { Map < String , Map < String , Map < String , FieldMappingMetaData > > > mappingsByIndex = response . mappings ( ) ; boolean isPossibleSingleFieldRequest = indices . length = = <int> & & types . length = = <int> & & fields . length = = <int> ; if ( isPossibleSingleFieldRequest & & isFieldMappingMissingField ( mappingsByIndex ) ) { return new BytesRestResponse ( OK , builder . startObject ( ) . endObject ( ) ) ; } RestStatus status = OK ; if ( mappingsByIndex . isEmpty ( ) & & fields . length > <int> ) { status = NOT_FOUND ; } builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; return new BytesRestResponse ( status , builder ) ; } } ) ; } private boolean isFieldMappingMissingField ( Map < String , Map < String , Map < String , FieldMappingMetaData > > > mappingsByIndex ) throws IOException { if ( mappingsByIndex . size ( ) ! = <int> ) { return false ; } for ( Map < String , Map < String , FieldMappingMetaData > > value : mappingsByIndex . values ( ) ) { for ( Map < String , FieldMappingMetaData > fieldValue : value . values ( ) ) { for ( Map . Entry < String , FieldMappingMetaData > fieldMappingMetaDataEntry : fieldValue . entrySet ( ) ) { if ( fieldMappingMetaDataEntry . getValue ( ) . isNull ( ) ) { return true ; } } } } return false ; } } 
