package org . apache . cassandra . db ; import java . io . * ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . filter . ClusteringIndexFilter ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public abstract class ReadResponse { public static final IVersionedSerializer < ReadResponse > serializer = new Serializer ( ) ; public static final IVersionedSerializer < ReadResponse > rangeSliceSerializer = new RangeSliceSerializer ( ) ; public static final IVersionedSerializer < ReadResponse > legacyRangeSliceReplySerializer = new LegacyRangeSliceReplySerializer ( ) ; private final CFMetaData metadata ; protected ReadResponse ( CFMetaData metadata ) { this . metadata = metadata ; } public static ReadResponse createDataResponse ( UnfilteredPartitionIterator data , ColumnFilter selection ) { return new LocalDataResponse ( data , selection ) ; } @VisibleForTesting public static ReadResponse createRemoteDataResponse ( UnfilteredPartitionIterator data , ColumnFilter selection ) { return new RemoteDataResponse ( LocalDataResponse . build ( data , selection ) ) ; } public static ReadResponse createDigestResponse ( UnfilteredPartitionIterator data , int version ) { return new DigestResponse ( makeDigest ( data , version ) ) ; } public abstract UnfilteredPartitionIterator makeIterator ( CFMetaData metadata , ReadCommand command ) ; public abstract ByteBuffer digest ( CFMetaData metadata , ReadCommand command ) ; public abstract boolean isDigestResponse ( ) ; protected static ByteBuffer makeDigest ( UnfilteredPartitionIterator iterator , int version ) { MessageDigest digest = FBUtilities . threadLocalMD5Digest ( ) ; UnfilteredPartitionIterators . digest ( iterator , digest , version ) ; return ByteBuffer . wrap ( digest . digest ( ) ) ; } private static class DigestResponse extends ReadResponse { private final ByteBuffer digest ; private DigestResponse ( ByteBuffer digest ) { super ( null ) ; assert digest . hasRemaining ( ) ; this . digest = digest ; } public UnfilteredPartitionIterator makeIterator ( CFMetaData metadata , ReadCommand command ) { throw new UnsupportedOperationException ( ) ; } public ByteBuffer digest ( CFMetaData metadata , ReadCommand command ) { return digest ; } public boolean isDigestResponse ( ) { return true ; } } private static class LocalDataResponse extends DataResponse { private final ColumnFilter received ; private LocalDataResponse ( UnfilteredPartitionIterator iter , ColumnFilter received ) { super ( iter . metadata ( ) , build ( iter , received ) , SerializationHelper . Flag . LOCAL ) ; this . received = received ; } private static ByteBuffer build ( UnfilteredPartitionIterator iter , ColumnFilter selection ) { try ( DataOutputBuffer buffer = new DataOutputBuffer ( ) ) { UnfilteredPartitionIterators . serializerForIntraNode ( ) . serialize ( iter , selection , buffer , MessagingService . current_version ) ; return buffer . buffer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } protected ColumnFilter selection ( ReadCommand sent ) { assert sent = = null | | sent . columnFilter ( ) = = received ; return received ; } } private static class RemoteDataResponse extends DataResponse { protected RemoteDataResponse ( ByteBuffer data ) { super ( null , data , SerializationHelper . Flag . FROM_REMOTE ) ; } protected ColumnFilter selection ( ReadCommand sent ) { assert sent ! = null ; return sent . columnFilter ( ) ; } } static abstract class DataResponse extends ReadResponse { private final ByteBuffer data ; private final SerializationHelper . Flag flag ; protected DataResponse ( CFMetaData metadata , ByteBuffer data , SerializationHelper . Flag flag ) { super ( metadata ) ; this . data = data ; this . flag = flag ; } protected abstract ColumnFilter selection ( ReadCommand command ) ; public UnfilteredPartitionIterator makeIterator ( CFMetaData metadata , ReadCommand command ) { try ( DataInputBuffer in = new DataInputBuffer ( data , true ) ) { return UnfilteredPartitionIterators . serializerForIntraNode ( ) . deserialize ( in , MessagingService . current_version , metadata , selection ( command ) , flag ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public ByteBuffer digest ( CFMetaData metadata , ReadCommand command ) { try ( UnfilteredPartitionIterator iterator = makeIterator ( metadata , command ) ) { return makeDigest ( iterator , command . digestVersion ( ) ) ; } } public boolean isDigestResponse ( ) { return false ; } } @VisibleForTesting static class LegacyRemoteDataResponse extends ReadResponse { private final List < ImmutableBTreePartition > partitions ; @VisibleForTesting LegacyRemoteDataResponse ( List < ImmutableBTreePartition > partitions ) { super ( null ) ; this . partitions = partitions ; } public UnfilteredPartitionIterator makeIterator ( CFMetaData metadata , final ReadCommand command ) { boolean skipFirst = false ; boolean skipLast = false ; if ( ! partitions . isEmpty ( ) & & command instanceof PartitionRangeReadCommand ) { AbstractBounds < PartitionPosition > keyRange = ( ( PartitionRangeReadCommand ) command ) . dataRange ( ) . keyRange ( ) ; boolean isExcludingBounds = keyRange instanceof ExcludingBounds ; skipFirst = isExcludingBounds & & ! keyRange . contains ( partitions . get ( <int> ) . partitionKey ( ) ) ; skipLast = ( isExcludingBounds | | keyRange instanceof IncludingExcludingBounds ) & & ! keyRange . contains ( partitions . get ( partitions . size ( ) - <int> ) . partitionKey ( ) ) ; } final List < ImmutableBTreePartition > toReturn ; if ( skipFirst | | skipLast ) { toReturn = partitions . size ( ) = = <int> ? Collections . emptyList ( ) : partitions . subList ( skipFirst ? <int> : <int> , skipLast ? partitions . size ( ) - <int> : partitions . size ( ) ) ; } else { toReturn = partitions ; } return new AbstractUnfilteredPartitionIterator ( ) { private int idx ; public boolean isForThrift ( ) { return true ; } public CFMetaData metadata ( ) { return metadata ; } public boolean hasNext ( ) { return idx < toReturn . size ( ) ; } public UnfilteredRowIterator next ( ) { ImmutableBTreePartition partition = toReturn . get ( idx + + ) ; ClusteringIndexFilter filter = command . clusteringIndexFilter ( partition . partitionKey ( ) ) ; if ( ! command . metadata ( ) . isCompound ( ) ) return filter . filter ( partition . sliceableUnfilteredIterator ( command . columnFilter ( ) , filter . isReversed ( ) ) ) ; return partition . unfilteredIterator ( command . columnFilter ( ) , Slices . ALL , filter . isReversed ( ) ) ; } } ; } public ByteBuffer digest ( CFMetaData metadata , ReadCommand command ) { try ( UnfilteredPartitionIterator iterator = makeIterator ( metadata , command ) ) { return makeDigest ( iterator , command . digestVersion ( ) ) ; } } public boolean isDigestResponse ( ) { return false ; } } private static class Serializer implements IVersionedSerializer < ReadResponse > { public void serialize ( ReadResponse response , DataOutputPlus out , int version ) throws IOException { boolean isDigest = response instanceof DigestResponse ; ByteBuffer digest = isDigest ? ( ( DigestResponse ) response ) . digest : ByteBufferUtil . EMPTY_BYTE_BUFFER ; if ( version < MessagingService . VERSION_30 ) { out . writeInt ( digest . remaining ( ) ) ; out . write ( digest ) ; out . writeBoolean ( isDigest ) ; if ( ! isDigest ) { assert ! ( response instanceof LegacyRemoteDataResponse ) ; try ( UnfilteredPartitionIterator iter = response . makeIterator ( response . metadata , null ) ) { assert iter . hasNext ( ) ; try ( UnfilteredRowIterator partition = iter . next ( ) ) { ByteBufferUtil . writeWithShortLength ( partition . partitionKey ( ) . getKey ( ) , out ) ; LegacyLayout . serializeAsLegacyPartition ( partition , out , version ) ; } assert ! iter . hasNext ( ) ; } } return ; } ByteBufferUtil . writeWithVIntLength ( digest , out ) ; if ( ! isDigest ) { ByteBuffer data = ( ( DataResponse ) response ) . data ; ByteBufferUtil . writeWithVIntLength ( data , out ) ; } } public ReadResponse deserialize ( DataInputPlus in , int version ) throws IOException { if ( version < MessagingService . VERSION_30 ) { byte [ ] digest = null ; int digestSize = in . readInt ( ) ; if ( digestSize > <int> ) { digest = new byte [ digestSize ] ; in . readFully ( digest , <int> , digestSize ) ; } boolean isDigest = in . readBoolean ( ) ; assert isDigest = = digestSize > <int> ; if ( isDigest ) { assert digest ! = null ; return new DigestResponse ( ByteBuffer . wrap ( digest ) ) ; } ByteBuffer key = ByteBufferUtil . readWithShortLength ( in ) ; try ( UnfilteredRowIterator rowIterator = LegacyLayout . deserializeLegacyPartition ( in , version , SerializationHelper . Flag . FROM_REMOTE , key ) ) { if ( rowIterator = = null ) return new LegacyRemoteDataResponse ( Collections . emptyList ( ) ) ; return new LegacyRemoteDataResponse ( Collections . singletonList ( ImmutableBTreePartition . create ( rowIterator ) ) ) ; } } ByteBuffer digest = ByteBufferUtil . readWithVIntLength ( in ) ; if ( digest . hasRemaining ( ) ) return new DigestResponse ( digest ) ; assert version = = MessagingService . VERSION_30 ; ByteBuffer data = ByteBufferUtil . readWithVIntLength ( in ) ; return new RemoteDataResponse ( data ) ; } public long serializedSize ( ReadResponse response , int version ) { boolean isDigest = response instanceof DigestResponse ; ByteBuffer digest = isDigest ? ( ( DigestResponse ) response ) . digest : ByteBufferUtil . EMPTY_BYTE_BUFFER ; if ( version < MessagingService . VERSION_30 ) { long size = TypeSizes . sizeof ( digest . remaining ( ) ) + digest . remaining ( ) + TypeSizes . sizeof ( isDigest ) ; if ( ! isDigest ) { assert ! ( response instanceof LegacyRemoteDataResponse ) ; try ( UnfilteredPartitionIterator iter = response . makeIterator ( response . metadata , null ) ) { assert iter . hasNext ( ) ; try ( UnfilteredRowIterator partition = iter . next ( ) ) { size + = ByteBufferUtil . serializedSizeWithShortLength ( partition . partitionKey ( ) . getKey ( ) ) ; size + = LegacyLayout . serializedSizeAsLegacyPartition ( partition , version ) ; } assert ! iter . hasNext ( ) ; } } return size ; } long size = ByteBufferUtil . serializedSizeWithVIntLength ( digest ) ; if ( ! isDigest ) { assert version = = MessagingService . VERSION_30 ; ByteBuffer data = ( ( DataResponse ) response ) . data ; size + = ByteBufferUtil . serializedSizeWithVIntLength ( data ) ; } return size ; } } private static class RangeSliceSerializer implements IVersionedSerializer < ReadResponse > { public void serialize ( ReadResponse response , DataOutputPlus out , int version ) throws IOException { if ( version < MessagingService . VERSION_30 ) legacyRangeSliceReplySerializer . serialize ( response , out , version ) ; else serializer . serialize ( response , out , version ) ; } public ReadResponse deserialize ( DataInputPlus in , int version ) throws IOException { return version < MessagingService . VERSION_30 ? legacyRangeSliceReplySerializer . deserialize ( in , version ) : serializer . deserialize ( in , version ) ; } public long serializedSize ( ReadResponse response , int version ) { return version < MessagingService . VERSION_30 ? legacyRangeSliceReplySerializer . serializedSize ( response , version ) : serializer . serializedSize ( response , version ) ; } } private static class LegacyRangeSliceReplySerializer implements IVersionedSerializer < ReadResponse > { public void serialize ( ReadResponse response , DataOutputPlus out , int version ) throws IOException { assert version < MessagingService . VERSION_30 ; int numPartitions = <int> ; assert ! ( response instanceof LegacyRemoteDataResponse ) ; try ( UnfilteredPartitionIterator iterator = response . makeIterator ( response . metadata , null ) ) { while ( iterator . hasNext ( ) ) { try ( UnfilteredRowIterator atomIterator = iterator . next ( ) ) { numPartitions + + ; while ( atomIterator . hasNext ( ) ) atomIterator . next ( ) ; } } } out . writeInt ( numPartitions ) ; try ( UnfilteredPartitionIterator iterator = response . makeIterator ( response . metadata , null ) ) { while ( iterator . hasNext ( ) ) { try ( UnfilteredRowIterator partition = iterator . next ( ) ) { ByteBufferUtil . writeWithShortLength ( partition . partitionKey ( ) . getKey ( ) , out ) ; LegacyLayout . serializeAsLegacyPartition ( partition , out , version ) ; } } } } public ReadResponse deserialize ( DataInputPlus in , int version ) throws IOException { int partitionCount = in . readInt ( ) ; ArrayList < ImmutableBTreePartition > partitions = new ArrayList < > ( partitionCount ) ; for ( int i = <int> ; i < partitionCount ; i + + ) { ByteBuffer key = ByteBufferUtil . readWithShortLength ( in ) ; try ( UnfilteredRowIterator partition = LegacyLayout . deserializeLegacyPartition ( in , version , SerializationHelper . Flag . FROM_REMOTE , key ) ) { partitions . add ( ImmutableBTreePartition . create ( partition ) ) ; } } return new LegacyRemoteDataResponse ( partitions ) ; } public long serializedSize ( ReadResponse response , int version ) { assert version < MessagingService . VERSION_30 ; long size = TypeSizes . sizeof ( <int> ) ; assert ! ( response instanceof LegacyRemoteDataResponse ) ; try ( UnfilteredPartitionIterator iterator = response . makeIterator ( response . metadata , null ) ) { while ( iterator . hasNext ( ) ) { try ( UnfilteredRowIterator partition = iterator . next ( ) ) { size + = ByteBufferUtil . serializedSizeWithShortLength ( partition . partitionKey ( ) . getKey ( ) ) ; size + = LegacyLayout . serializedSizeAsLegacyPartition ( partition , version ) ; } } } return size ; } } } 
