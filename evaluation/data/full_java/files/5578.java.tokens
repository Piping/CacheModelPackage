package org . elasticsearch . cluster . node ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . Version ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . transport . TransportAddressSerializers ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . transport . TransportAddressSerializers . addressToStream ; public class DiscoveryNode implements Streamable , ToXContent { public static final Version MINIMUM_DISCOVERY_NODE_VERSION = Version . CURRENT . minimumCompatibilityVersion ( ) ; public static boolean localNode ( Settings settings ) { if ( settings . get ( <str> ) ! = null ) { return settings . getAsBoolean ( <str> , false ) ; } if ( settings . get ( <str> ) ! = null ) { String nodeMode = settings . get ( <str> ) ; if ( <str> . equals ( nodeMode ) ) { return true ; } else if ( <str> . equals ( nodeMode ) ) { return false ; } else { throw new IllegalArgumentException ( <str> + nodeMode + <str> ) ; } } return false ; } public static boolean nodeRequiresLocalStorage ( Settings settings ) { return ! ( settings . getAsBoolean ( <str> , false ) | | ( ! settings . getAsBoolean ( <str> , true ) & & ! settings . getAsBoolean ( <str> , true ) ) ) ; } public static boolean clientNode ( Settings settings ) { String client = settings . get ( <str> ) ; return Booleans . isExplicitTrue ( client ) ; } public static boolean masterNode ( Settings settings ) { String master = settings . get ( <str> ) ; if ( master = = null ) { return ! clientNode ( settings ) ; } return Booleans . isExplicitTrue ( master ) ; } public static boolean dataNode ( Settings settings ) { String data = settings . get ( <str> ) ; if ( data = = null ) { return ! clientNode ( settings ) ; } return Booleans . isExplicitTrue ( data ) ; } public static final List < DiscoveryNode > EMPTY_LIST = Collections . emptyList ( ) ; private String nodeName = <str> ; private String nodeId ; private String hostName ; private String hostAddress ; private TransportAddress address ; private ImmutableOpenMap < String , String > attributes ; private Version version = Version . CURRENT ; DiscoveryNode ( ) { } public DiscoveryNode ( String nodeId , TransportAddress address , Version version ) { this ( <str> , nodeId , address , Collections . emptyMap ( ) , version ) ; } public DiscoveryNode ( String nodeName , String nodeId , TransportAddress address , Map < String , String > attributes , Version version ) { this ( nodeName , nodeId , address . getHost ( ) , address . getAddress ( ) , address , attributes , version ) ; } public DiscoveryNode ( String nodeName , String nodeId , String hostName , String hostAddress , TransportAddress address , Map < String , String > attributes , Version version ) { if ( nodeName ! = null ) { this . nodeName = nodeName . intern ( ) ; } ImmutableOpenMap . Builder < String , String > builder = ImmutableOpenMap . builder ( ) ; for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { builder . put ( entry . getKey ( ) . intern ( ) , entry . getValue ( ) . intern ( ) ) ; } this . attributes = builder . build ( ) ; this . nodeId = nodeId . intern ( ) ; this . hostName = hostName . intern ( ) ; this . hostAddress = hostAddress . intern ( ) ; this . address = address ; this . version = version ; } public DiscoveryNode ( String nodeName , String nodeId , String hostName , String hostAddress , TransportAddress address , ImmutableOpenMap < String , String > attributes , Version version ) { if ( nodeName ! = null ) { this . nodeName = nodeName . intern ( ) ; } ImmutableOpenMap . Builder < String , String > builder = ImmutableOpenMap . builder ( ) ; for ( ObjectObjectCursor < String , String > entry : attributes ) { builder . put ( entry . key . intern ( ) , entry . value . intern ( ) ) ; } this . attributes = builder . build ( ) ; this . nodeId = nodeId . intern ( ) ; this . hostName = hostName . intern ( ) ; this . hostAddress = hostAddress . intern ( ) ; this . address = address ; this . version = version ; } public boolean shouldConnectTo ( DiscoveryNode otherNode ) { if ( clientNode ( ) & & otherNode . clientNode ( ) ) { return false ; } return true ; } public TransportAddress address ( ) { return address ; } public TransportAddress getAddress ( ) { return address ( ) ; } public String id ( ) { return nodeId ; } public String getId ( ) { return id ( ) ; } public String name ( ) { return this . nodeName ; } public String getName ( ) { return name ( ) ; } public ImmutableOpenMap < String , String > attributes ( ) { return this . attributes ; } public ImmutableOpenMap < String , String > getAttributes ( ) { return attributes ( ) ; } public boolean dataNode ( ) { String data = attributes . get ( <str> ) ; if ( data = = null ) { return ! clientNode ( ) ; } return Booleans . parseBooleanExact ( data ) ; } public boolean isDataNode ( ) { return dataNode ( ) ; } public boolean clientNode ( ) { String client = attributes . get ( <str> ) ; return client ! = null & & Booleans . parseBooleanExact ( client ) ; } public boolean isClientNode ( ) { return clientNode ( ) ; } public boolean masterNode ( ) { String master = attributes . get ( <str> ) ; if ( master = = null ) { return ! clientNode ( ) ; } return Booleans . parseBooleanExact ( master ) ; } public boolean isMasterNode ( ) { return masterNode ( ) ; } public Version version ( ) { return this . version ; } public String getHostName ( ) { return this . hostName ; } public String getHostAddress ( ) { return this . hostAddress ; } public Version getVersion ( ) { return this . version ; } public static DiscoveryNode readNode ( StreamInput in ) throws IOException { DiscoveryNode node = new DiscoveryNode ( ) ; node . readFrom ( in ) ; return node ; } @Override public void readFrom ( StreamInput in ) throws IOException { nodeName = in . readString ( ) . intern ( ) ; nodeId = in . readString ( ) . intern ( ) ; hostName = in . readString ( ) . intern ( ) ; hostAddress = in . readString ( ) . intern ( ) ; address = TransportAddressSerializers . addressFromStream ( in ) ; int size = in . readVInt ( ) ; ImmutableOpenMap . Builder < String , String > attributes = ImmutableOpenMap . builder ( size ) ; for ( int i = <int> ; i < size ; i + + ) { attributes . put ( in . readString ( ) . intern ( ) , in . readString ( ) . intern ( ) ) ; } this . attributes = attributes . build ( ) ; version = Version . readVersion ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( nodeName ) ; out . writeString ( nodeId ) ; out . writeString ( hostName ) ; out . writeString ( hostAddress ) ; addressToStream ( out , address ) ; out . writeVInt ( attributes . size ( ) ) ; for ( ObjectObjectCursor < String , String > entry : attributes ) { out . writeString ( entry . key ) ; out . writeString ( entry . value ) ; } Version . writeVersion ( version , out ) ; } @Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof DiscoveryNode ) ) { return false ; } DiscoveryNode other = ( DiscoveryNode ) obj ; return this . nodeId . equals ( other . nodeId ) ; } @Override public int hashCode ( ) { return nodeId . hashCode ( ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( nodeName . length ( ) > <int> ) { sb . append ( <str> ) . append ( nodeName ) . append ( <str> ) ; } if ( nodeId ! = null ) { sb . append ( <str> ) . append ( nodeId ) . append ( <str> ) ; } if ( Strings . hasLength ( hostName ) ) { sb . append ( <str> ) . append ( hostName ) . append ( <str> ) ; } if ( address ! = null ) { sb . append ( <str> ) . append ( address ) . append ( <str> ) ; } if ( ! attributes . isEmpty ( ) ) { sb . append ( attributes ) ; } return sb . toString ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( id ( ) , XContentBuilder . FieldCaseConversion . NONE ) ; builder . field ( <str> , name ( ) ) ; builder . field ( <str> , address ( ) . toString ( ) ) ; builder . startObject ( <str> ) ; for ( ObjectObjectCursor < String , String > attr : attributes ) { builder . field ( attr . key , attr . value ) ; } builder . endObject ( ) ; builder . endObject ( ) ; return builder ; } } 
