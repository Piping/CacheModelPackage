package com . badlogic . gdx . graphics . g3d . particles . values ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; public final class CylinderSpawnShapeValue extends PrimitiveSpawnShapeValue { public CylinderSpawnShapeValue ( CylinderSpawnShapeValue cylinderSpawnShapeValue ) { super ( cylinderSpawnShapeValue ) ; load ( cylinderSpawnShapeValue ) ; } public CylinderSpawnShapeValue ( ) { } @Override public void spawnAux ( Vector3 vector , float percent ) { float width = spawnWidth + ( spawnWidthDiff * spawnWidthValue . getScale ( percent ) ) ; float height = spawnHeight + ( spawnHeightDiff * spawnHeightValue . getScale ( percent ) ) ; float depth = spawnDepth + ( spawnDepthDiff * spawnDepthValue . getScale ( percent ) ) ; float radiusX , radiusZ ; float hf = height / <int> ; float ty = MathUtils . random ( height ) - hf ; if ( edges ) { radiusX = width / <int> ; radiusZ = depth / <int> ; } else { radiusX = MathUtils . random ( width ) / <int> ; radiusZ = MathUtils . random ( depth ) / <int> ; } float spawnTheta = <int> ; boolean isRadiusXZero = radiusX = = <int> , isRadiusZZero = radiusZ = = <int> ; if ( ! isRadiusXZero & & ! isRadiusZZero ) spawnTheta = MathUtils . random ( <int> f ) ; else { if ( isRadiusXZero ) spawnTheta = MathUtils . random ( <int> ) = = <int> ? - <int> : <int> ; else if ( isRadiusZZero ) spawnTheta = MathUtils . random ( <int> ) = = <int> ? <int> : <int> ; } vector . set ( radiusX * MathUtils . cosDeg ( spawnTheta ) , ty , radiusZ * MathUtils . sinDeg ( spawnTheta ) ) ; } @Override public SpawnShapeValue copy ( ) { return new CylinderSpawnShapeValue ( this ) ; } } 
