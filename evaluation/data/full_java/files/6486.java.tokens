package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . * ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . * ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . fielddata . fieldcomparator . BytesRefFieldComparatorSource ; import org . elasticsearch . index . fielddata . ordinals . GlobalOrdinalsBuilder ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . search . MultiValueMode ; import java . io . IOException ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public abstract class AbstractIndexOrdinalsFieldData extends AbstractIndexFieldData < AtomicOrdinalsFieldData > implements IndexOrdinalsFieldData { protected Settings frequency ; protected Settings regex ; protected final CircuitBreakerService breakerService ; protected AbstractIndexOrdinalsFieldData ( IndexSettings indexSettings , Names fieldNames , FieldDataType fieldDataType , IndexFieldDataCache cache , CircuitBreakerService breakerService ) { super ( indexSettings , fieldNames , fieldDataType , cache ) ; final Map < String , Settings > groups = fieldDataType . getSettings ( ) . getGroups ( <str> ) ; frequency = groups . get ( <str> ) ; regex = groups . get ( <str> ) ; this . breakerService = breakerService ; } @Override public XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , Nested nested ) { return new BytesRefFieldComparatorSource ( this , missingValue , sortMode , nested ) ; } @Override public IndexOrdinalsFieldData loadGlobal ( DirectoryReader indexReader ) { if ( indexReader . leaves ( ) . size ( ) < = <int> ) { return this ; } boolean fieldFound = false ; for ( LeafReaderContext context : indexReader . leaves ( ) ) { if ( context . reader ( ) . getFieldInfos ( ) . fieldInfo ( getFieldNames ( ) . indexName ( ) ) ! = null ) { fieldFound = true ; break ; } } if ( fieldFound = = false ) { try { return GlobalOrdinalsBuilder . buildEmpty ( indexSettings , indexReader , this ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } try { return cache . load ( indexReader , this ) ; } catch ( Throwable e ) { if ( e instanceof ElasticsearchException ) { throw ( ElasticsearchException ) e ; } else { throw new ElasticsearchException ( e ) ; } } } @Override public IndexOrdinalsFieldData localGlobalDirect ( DirectoryReader indexReader ) throws Exception { return GlobalOrdinalsBuilder . build ( indexReader , this , indexSettings , breakerService , logger ) ; } @Override protected AtomicOrdinalsFieldData empty ( int maxDoc ) { return AbstractAtomicOrdinalsFieldData . empty ( ) ; } protected TermsEnum filter ( Terms terms , LeafReader reader ) throws IOException { TermsEnum iterator = terms . iterator ( ) ; if ( iterator = = null ) { return null ; } if ( iterator ! = null & & frequency ! = null ) { iterator = FrequencyFilter . filter ( iterator , terms , reader , frequency ) ; } if ( iterator ! = null & & regex ! = null ) { iterator = RegexFilter . filter ( iterator , terms , reader , regex ) ; } return iterator ; } private static final class FrequencyFilter extends FilteredTermsEnum { private int minFreq ; private int maxFreq ; public FrequencyFilter ( TermsEnum delegate , int minFreq , int maxFreq ) { super ( delegate , false ) ; this . minFreq = minFreq ; this . maxFreq = maxFreq ; } public static TermsEnum filter ( TermsEnum toFilter , Terms terms , LeafReader reader , Settings settings ) throws IOException { int docCount = terms . getDocCount ( ) ; if ( docCount = = - <int> ) { docCount = reader . maxDoc ( ) ; } final double minFrequency = settings . getAsDouble ( <str> , <float> ) ; final double maxFrequency = settings . getAsDouble ( <str> , docCount + <float> ) ; final double minSegmentSize = settings . getAsInt ( <str> , <int> ) ; if ( minSegmentSize < docCount ) { final int minFreq = minFrequency > <float> ? ( int ) minFrequency : ( int ) ( docCount * minFrequency ) ; final int maxFreq = maxFrequency > <float> ? ( int ) maxFrequency : ( int ) ( docCount * maxFrequency ) ; assert minFreq < maxFreq ; return new FrequencyFilter ( toFilter , minFreq , maxFreq ) ; } return toFilter ; } @Override protected AcceptStatus accept ( BytesRef arg0 ) throws IOException { int docFreq = docFreq ( ) ; if ( docFreq > = minFreq & & docFreq < = maxFreq ) { return AcceptStatus . YES ; } return AcceptStatus . NO ; } } private static final class RegexFilter extends FilteredTermsEnum { private final Matcher matcher ; private final CharsRefBuilder spare = new CharsRefBuilder ( ) ; public RegexFilter ( TermsEnum delegate , Matcher matcher ) { super ( delegate , false ) ; this . matcher = matcher ; } public static TermsEnum filter ( TermsEnum iterator , Terms terms , LeafReader reader , Settings regex ) { String pattern = regex . get ( <str> ) ; if ( pattern = = null ) { return iterator ; } Pattern p = Pattern . compile ( pattern ) ; return new RegexFilter ( iterator , p . matcher ( <str> ) ) ; } @Override protected AcceptStatus accept ( BytesRef arg0 ) throws IOException { spare . copyUTF8Bytes ( arg0 ) ; matcher . reset ( spare . get ( ) ) ; if ( matcher . matches ( ) ) { return AcceptStatus . YES ; } return AcceptStatus . NO ; } } } 
