package org . apache . cassandra . db . marshal ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; public class TypeParser { private final String str ; private int idx ; private static final Map < String , AbstractType < ? > > cache = new HashMap < > ( ) ; public static final TypeParser EMPTY_PARSER = new TypeParser ( <str> , <int> ) ; private TypeParser ( String str , int idx ) { this . str = str ; this . idx = idx ; } public TypeParser ( String str ) { this ( str , <int> ) ; } public static AbstractType < ? > parse ( String str ) throws SyntaxException , ConfigurationException { if ( str = = null ) return BytesType . instance ; AbstractType < ? > type = cache . get ( str ) ; if ( type ! = null ) return type ; int i = <int> ; i = skipBlank ( str , i ) ; int j = i ; while ( ! isEOS ( str , i ) & & isIdentifierChar ( str . charAt ( i ) ) ) + + i ; if ( i = = j ) return BytesType . instance ; String name = str . substring ( j , i ) ; i = skipBlank ( str , i ) ; if ( ! isEOS ( str , i ) & & str . charAt ( i ) = = <str> ) type = getAbstractType ( name , new TypeParser ( str , i ) ) ; else type = getAbstractType ( name ) ; cache . put ( str , type ) ; return type ; } public static AbstractType < ? > parse ( CharSequence compareWith ) throws SyntaxException , ConfigurationException { return parse ( compareWith = = null ? null : compareWith . toString ( ) ) ; } public AbstractType < ? > parse ( ) throws SyntaxException , ConfigurationException { skipBlank ( ) ; String name = readNextIdentifier ( ) ; skipBlank ( ) ; if ( ! isEOS ( ) & & str . charAt ( idx ) = = <str> ) return getAbstractType ( name , this ) ; else return getAbstractType ( name ) ; } public Map < String , String > getKeyValueParameters ( ) throws SyntaxException { if ( isEOS ( ) ) return Collections . emptyMap ( ) ; if ( str . charAt ( idx ) ! = <str> ) throw new IllegalStateException ( ) ; Map < String , String > map = new HashMap < > ( ) ; + + idx ; while ( skipBlankAndComma ( ) ) { if ( str . charAt ( idx ) = = <str> ) { + + idx ; return map ; } String k = readNextIdentifier ( ) ; String v = <str> ; skipBlank ( ) ; if ( str . charAt ( idx ) = = <str> ) { + + idx ; skipBlank ( ) ; v = readNextIdentifier ( ) ; } else if ( str . charAt ( idx ) ! = <str> & & str . charAt ( idx ) ! = <str> ) { throwSyntaxError ( <str> + str . charAt ( idx ) + <str> ) ; } map . put ( k , v ) ; } throw new SyntaxException ( String . format ( <str> , str , idx ) ) ; } public List < AbstractType < ? > > getTypeParameters ( ) throws SyntaxException , ConfigurationException { List < AbstractType < ? > > list = new ArrayList < > ( ) ; if ( isEOS ( ) ) return list ; if ( str . charAt ( idx ) ! = <str> ) throw new IllegalStateException ( ) ; + + idx ; while ( skipBlankAndComma ( ) ) { if ( str . charAt ( idx ) = = <str> ) { + + idx ; return list ; } try { list . add ( parse ( ) ) ; } catch ( SyntaxException e ) { SyntaxException ex = new SyntaxException ( String . format ( <str> , str , idx ) ) ; ex . initCause ( e ) ; throw ex ; } } throw new SyntaxException ( String . format ( <str> , str , idx ) ) ; } public Map < Byte , AbstractType < ? > > getAliasParameters ( ) throws SyntaxException , ConfigurationException { Map < Byte , AbstractType < ? > > map = new HashMap < > ( ) ; if ( isEOS ( ) ) return map ; if ( str . charAt ( idx ) ! = <str> ) throw new IllegalStateException ( ) ; + + idx ; while ( skipBlankAndComma ( ) ) { if ( str . charAt ( idx ) = = <str> ) { + + idx ; return map ; } String alias = readNextIdentifier ( ) ; if ( alias . length ( ) ! = <int> ) throwSyntaxError ( <str> ) ; char aliasChar = alias . charAt ( <int> ) ; if ( aliasChar < <int> | | aliasChar > <int> ) throwSyntaxError ( <str> ) ; skipBlank ( ) ; if ( ! ( str . charAt ( idx ) = = <str> & & str . charAt ( idx + <int> ) = = <str> ) ) throwSyntaxError ( <str> ) ; idx + = <int> ; skipBlank ( ) ; try { map . put ( ( byte ) aliasChar , parse ( ) ) ; } catch ( SyntaxException e ) { SyntaxException ex = new SyntaxException ( String . format ( <str> , str , idx ) ) ; ex . initCause ( e ) ; throw ex ; } } throw new SyntaxException ( String . format ( <str> , str , idx ) ) ; } public Map < ByteBuffer , CollectionType > getCollectionsParameters ( ) throws SyntaxException , ConfigurationException { Map < ByteBuffer , CollectionType > map = new HashMap < > ( ) ; if ( isEOS ( ) ) return map ; if ( str . charAt ( idx ) ! = <str> ) throw new IllegalStateException ( ) ; + + idx ; while ( skipBlankAndComma ( ) ) { if ( str . charAt ( idx ) = = <str> ) { + + idx ; return map ; } ByteBuffer bb = fromHex ( readNextIdentifier ( ) ) ; skipBlank ( ) ; if ( str . charAt ( idx ) ! = <str> ) throwSyntaxError ( <str> ) ; + + idx ; skipBlank ( ) ; try { AbstractType < ? > type = parse ( ) ; if ( ! ( type instanceof CollectionType ) ) throw new SyntaxException ( type + <str> ) ; map . put ( bb , ( CollectionType ) type ) ; } catch ( SyntaxException e ) { SyntaxException ex = new SyntaxException ( String . format ( <str> , str , idx ) ) ; ex . initCause ( e ) ; throw ex ; } } throw new SyntaxException ( String . format ( <str> , str , idx ) ) ; } private ByteBuffer fromHex ( String hex ) throws SyntaxException { try { return ByteBufferUtil . hexToBytes ( hex ) ; } catch ( NumberFormatException e ) { throwSyntaxError ( e . getMessage ( ) ) ; return null ; } } public Pair < Pair < String , ByteBuffer > , List < Pair < ByteBuffer , AbstractType > > > getUserTypeParameters ( ) throws SyntaxException , ConfigurationException { if ( isEOS ( ) | | str . charAt ( idx ) ! = <str> ) throw new IllegalStateException ( ) ; + + idx ; skipBlankAndComma ( ) ; String keyspace = readNextIdentifier ( ) ; skipBlankAndComma ( ) ; ByteBuffer typeName = fromHex ( readNextIdentifier ( ) ) ; List < Pair < ByteBuffer , AbstractType > > defs = new ArrayList < > ( ) ; while ( skipBlankAndComma ( ) ) { if ( str . charAt ( idx ) = = <str> ) { + + idx ; return Pair . create ( Pair . create ( keyspace , typeName ) , defs ) ; } ByteBuffer name = fromHex ( readNextIdentifier ( ) ) ; skipBlank ( ) ; if ( str . charAt ( idx ) ! = <str> ) throwSyntaxError ( <str> ) ; + + idx ; skipBlank ( ) ; try { AbstractType type = parse ( ) ; defs . add ( Pair . create ( name , type ) ) ; } catch ( SyntaxException e ) { SyntaxException ex = new SyntaxException ( String . format ( <str> , str , idx ) ) ; ex . initCause ( e ) ; throw ex ; } } throw new SyntaxException ( String . format ( <str> , str , idx ) ) ; } private static AbstractType < ? > getAbstractType ( String compareWith ) throws ConfigurationException { String className = compareWith . contains ( <str> ) ? compareWith : <str> + compareWith ; Class < ? extends AbstractType < ? > > typeClass = FBUtilities . < AbstractType < ? > > classForName ( className , <str> ) ; try { Field field = typeClass . getDeclaredField ( <str> ) ; return ( AbstractType < ? > ) field . get ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException e ) { return getRawAbstractType ( typeClass , EMPTY_PARSER ) ; } } private static AbstractType < ? > getAbstractType ( String compareWith , TypeParser parser ) throws SyntaxException , ConfigurationException { String className = compareWith . contains ( <str> ) ? compareWith : <str> + compareWith ; Class < ? extends AbstractType < ? > > typeClass = FBUtilities . < AbstractType < ? > > classForName ( className , <str> ) ; try { Method method = typeClass . getDeclaredMethod ( <str> , TypeParser . class ) ; return ( AbstractType < ? > ) method . invoke ( null , parser ) ; } catch ( NoSuchMethodException | IllegalAccessException e ) { AbstractType < ? > type = getRawAbstractType ( typeClass ) ; return AbstractType . parseDefaultParameters ( type , parser ) ; } catch ( InvocationTargetException e ) { ConfigurationException ex = new ConfigurationException ( <str> + typeClass . getName ( ) + <str> ) ; ex . initCause ( e . getTargetException ( ) ) ; throw ex ; } } private static AbstractType < ? > getRawAbstractType ( Class < ? extends AbstractType < ? > > typeClass ) throws ConfigurationException { try { Field field = typeClass . getDeclaredField ( <str> ) ; return ( AbstractType < ? > ) field . get ( null ) ; } catch ( NoSuchFieldException | IllegalAccessException e ) { throw new ConfigurationException ( <str> + typeClass . getName ( ) + <str> ) ; } } private static AbstractType < ? > getRawAbstractType ( Class < ? extends AbstractType < ? > > typeClass , TypeParser parser ) throws ConfigurationException { try { Method method = typeClass . getDeclaredMethod ( <str> , TypeParser . class ) ; return ( AbstractType < ? > ) method . invoke ( null , parser ) ; } catch ( NoSuchMethodException | IllegalAccessException e ) { throw new ConfigurationException ( <str> + typeClass . getName ( ) + <str> ) ; } catch ( InvocationTargetException e ) { ConfigurationException ex = new ConfigurationException ( <str> + typeClass . getName ( ) + <str> ) ; ex . initCause ( e . getTargetException ( ) ) ; throw ex ; } } private void throwSyntaxError ( String msg ) throws SyntaxException { throw new SyntaxException ( String . format ( <str> , str , idx , msg ) ) ; } private boolean isEOS ( ) { return isEOS ( str , idx ) ; } private static boolean isEOS ( String str , int i ) { return i > = str . length ( ) ; } private static boolean isBlank ( int c ) { return c = = <str> | | c = = <str> | | c = = <str> ; } private void skipBlank ( ) { idx = skipBlank ( str , idx ) ; } private static int skipBlank ( String str , int i ) { while ( ! isEOS ( str , i ) & & isBlank ( str . charAt ( i ) ) ) + + i ; return i ; } private boolean skipBlankAndComma ( ) { boolean commaFound = false ; while ( ! isEOS ( ) ) { int c = str . charAt ( idx ) ; if ( c = = <str> ) { if ( commaFound ) return true ; else commaFound = true ; } else if ( ! isBlank ( c ) ) { return true ; } + + idx ; } return false ; } private static boolean isIdentifierChar ( int c ) { return ( c > = <str> & & c < = <str> ) | | ( c > = <str> & & c < = <str> ) | | ( c > = <str> & & c < = <str> ) | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> ; } public String readNextIdentifier ( ) { int i = idx ; while ( ! isEOS ( ) & & isIdentifierChar ( str . charAt ( idx ) ) ) + + idx ; return str . substring ( i , idx ) ; } public static String stringifyAliasesParameters ( Map < Byte , AbstractType < ? > > aliases ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; Iterator < Map . Entry < Byte , AbstractType < ? > > > iter = aliases . entrySet ( ) . iterator ( ) ; if ( iter . hasNext ( ) ) { Map . Entry < Byte , AbstractType < ? > > entry = iter . next ( ) ; sb . append ( ( char ) ( byte ) entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) ; } while ( iter . hasNext ( ) ) { Map . Entry < Byte , AbstractType < ? > > entry = iter . next ( ) ; sb . append ( <str> ) . append ( ( char ) ( byte ) entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public static String stringifyTypeParameters ( List < AbstractType < ? > > types ) { return stringifyTypeParameters ( types , false ) ; } public static String stringifyTypeParameters ( List < AbstractType < ? > > types , boolean ignoreFreezing ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < types . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( types . get ( i ) . toString ( ignoreFreezing ) ) ; } return sb . append ( <str> ) . toString ( ) ; } public static String stringifyCollectionsParameters ( Map < ByteBuffer , ? extends CollectionType > collections ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; boolean first = true ; for ( Map . Entry < ByteBuffer , ? extends CollectionType > entry : collections . entrySet ( ) ) { if ( ! first ) sb . append ( <str> ) ; first = false ; sb . append ( ByteBufferUtil . bytesToHex ( entry . getKey ( ) ) ) . append ( <str> ) ; sb . append ( entry . getValue ( ) ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public static String stringifyUserTypeParameters ( String keysace , ByteBuffer typeName , List < ByteBuffer > columnNames , List < AbstractType < ? > > columnTypes ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( keysace ) . append ( <str> ) . append ( ByteBufferUtil . bytesToHex ( typeName ) ) ; for ( int i = <int> ; i < columnNames . size ( ) ; i + + ) { sb . append ( <str> ) ; sb . append ( ByteBufferUtil . bytesToHex ( columnNames . get ( i ) ) ) . append ( <str> ) ; sb . append ( columnTypes . get ( i ) . toString ( true ) ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } } 
