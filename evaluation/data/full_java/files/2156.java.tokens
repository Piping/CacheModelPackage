package org . nd4j . linalg . api . rng . distribution . impl ; import java . util . Iterator ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . exception . NumberIsTooLargeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . util . LocalizedFormats ; import org . apache . commons . math3 . special . Erf ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . rng . Random ; import org . nd4j . linalg . api . rng . distribution . BaseDistribution ; import org . nd4j . linalg . factory . Nd4j ; public class NormalDistribution extends BaseDistribution { public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = <float> ; private static final long serialVersionUID = <int> ; private static final double SQRT2PI = FastMath . sqrt ( <int> * FastMath . PI ) ; private static final double SQRT2 = FastMath . sqrt ( <float> ) ; private final double standardDeviation ; private double mean ; private INDArray means ; private double solverAbsoluteAccuracy ; public NormalDistribution ( Random rng , double standardDeviation , INDArray means ) { super ( rng ) ; this . standardDeviation = standardDeviation ; this . means = means ; } public NormalDistribution ( double standardDeviation , INDArray means ) { this . standardDeviation = standardDeviation ; this . means = means ; } public NormalDistribution ( ) { this ( <int> , <int> ) ; } public NormalDistribution ( double mean , double sd ) throws NotStrictlyPositiveException { this ( mean , sd , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; } public NormalDistribution ( double mean , double sd , double inverseCumAccuracy ) throws NotStrictlyPositiveException { this ( Nd4j . getRandom ( ) , mean , sd , inverseCumAccuracy ) ; } public NormalDistribution ( Random rng , double mean , double sd , double inverseCumAccuracy ) throws NotStrictlyPositiveException { super ( rng ) ; if ( sd < = <int> ) { throw new NotStrictlyPositiveException ( LocalizedFormats . STANDARD_DEVIATION , sd ) ; } this . mean = mean ; standardDeviation = sd ; solverAbsoluteAccuracy = inverseCumAccuracy ; } public NormalDistribution ( INDArray mean , double std ) { this . means = mean ; this . standardDeviation = std ; this . random = Nd4j . getRandom ( ) ; } public double getMean ( ) { return mean ; } public double getStandardDeviation ( ) { return standardDeviation ; } public double density ( double x ) { if ( means ! = null ) throw new IllegalStateException ( <str> ) ; final double x0 = x - mean ; final double x1 = x0 / standardDeviation ; return FastMath . exp ( - <float> * x1 * x1 ) / ( standardDeviation * SQRT2PI ) ; } public double cumulativeProbability ( double x ) { if ( means ! = null ) throw new IllegalStateException ( <str> ) ; final double dev = x - mean ; if ( FastMath . abs ( dev ) > <int> * standardDeviation ) { return dev < <int> ? <float> : <float> ; } return <float> * ( <int> + Erf . erf ( dev / ( standardDeviation * SQRT2 ) ) ) ; } @Override public double inverseCumulativeProbability ( final double p ) throws OutOfRangeException { if ( p < <float> | | p > <float> ) { throw new OutOfRangeException ( p , <int> , <int> ) ; } if ( means ! = null ) throw new IllegalStateException ( <str> ) ; return mean + standardDeviation * SQRT2 * Erf . erfInv ( <int> * p - <int> ) ; } @Override @Deprecated public double cumulativeProbability ( double x0 , double x1 ) throws NumberIsTooLargeException { return probability ( x0 , x1 ) ; } @Override public double probability ( double x0 , double x1 ) throws NumberIsTooLargeException { if ( x0 > x1 ) { throw new NumberIsTooLargeException ( LocalizedFormats . LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; } final double denom = standardDeviation * SQRT2 ; final double v0 = ( x0 - mean ) / denom ; final double v1 = ( x1 - mean ) / denom ; return <float> * Erf . erf ( v0 , v1 ) ; } @Override protected double getSolverAbsoluteAccuracy ( ) { return solverAbsoluteAccuracy ; } public double getNumericalMean ( ) { return getMean ( ) ; } public double getNumericalVariance ( ) { final double s = getStandardDeviation ( ) ; return s * s ; } public double getSupportLowerBound ( ) { return Double . NEGATIVE_INFINITY ; } public double getSupportUpperBound ( ) { return Double . POSITIVE_INFINITY ; } public boolean isSupportLowerBoundInclusive ( ) { return false ; } public boolean isSupportUpperBoundInclusive ( ) { return false ; } public boolean isSupportConnected ( ) { return true ; } @Override public double sample ( ) { if ( means ! = null ) throw new IllegalStateException ( <str> ) ; return standardDeviation * random . nextGaussian ( ) + mean ; } @Override public INDArray sample ( int [ ] shape ) { INDArray ret = Nd4j . create ( shape ) ; Iterator < int [ ] > idxIter = new NdIndexIterator ( shape ) ; int len = ret . length ( ) ; if ( means ! = null ) { for ( int i = <int> ; i < len ; i + + ) { int [ ] idx = idxIter . next ( ) ; ret . putScalar ( idx , standardDeviation * random . nextGaussian ( ) + means . getDouble ( idx ) ) ; } } else { for ( int i = <int> ; i < len ; i + + ) { ret . putScalar ( idxIter . next ( ) , standardDeviation * random . nextGaussian ( ) + mean ) ; } } return ret ; } } 
