package org . elasticsearch . transport . netty ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . rest . RestStatus ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelHandlerContext ; import org . jboss . netty . handler . codec . frame . FrameDecoder ; import org . jboss . netty . handler . codec . frame . TooLongFrameException ; import java . io . IOException ; import java . io . StreamCorruptedException ; public class SizeHeaderFrameDecoder extends FrameDecoder { private static final long NINETY_PER_HEAP_SIZE = ( long ) ( JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapMax ( ) . bytes ( ) * <float> ) ; @Override protected Object decode ( ChannelHandlerContext ctx , Channel channel , ChannelBuffer buffer ) throws Exception { if ( buffer . readableBytes ( ) < <int> ) { return null ; } int readerIndex = buffer . readerIndex ( ) ; if ( buffer . getByte ( readerIndex ) ! = <str> | | buffer . getByte ( readerIndex + <int> ) ! = <str> ) { if ( bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) | | bufferStartsWith ( buffer , readerIndex , <str> ) ) { throw new HttpOnTransportException ( <str> ) ; } throw new StreamCorruptedException ( <str> + Integer . toHexString ( buffer . getByte ( readerIndex ) & <hex> ) + <str> + Integer . toHexString ( buffer . getByte ( readerIndex + <int> ) & <hex> ) + <str> + Integer . toHexString ( buffer . getByte ( readerIndex + <int> ) & <hex> ) + <str> + Integer . toHexString ( buffer . getByte ( readerIndex + <int> ) & <hex> ) + <str> ) ; } int dataLen = buffer . getInt ( buffer . readerIndex ( ) + <int> ) ; if ( dataLen = = NettyHeader . PING_DATA_SIZE ) { buffer . skipBytes ( <int> ) ; return null ; } if ( dataLen < = <int> ) { throw new StreamCorruptedException ( <str> + dataLen ) ; } if ( dataLen > NINETY_PER_HEAP_SIZE ) { throw new TooLongFrameException ( <str> + new ByteSizeValue ( dataLen ) + <str> + new ByteSizeValue ( NINETY_PER_HEAP_SIZE ) + <str> ) ; } if ( buffer . readableBytes ( ) < dataLen + <int> ) { return null ; } buffer . skipBytes ( <int> ) ; return buffer ; } private boolean bufferStartsWith ( ChannelBuffer buffer , int readerIndex , String method ) { char [ ] chars = method . toCharArray ( ) ; for ( int i = <int> ; i < chars . length ; i + + ) { if ( buffer . getByte ( readerIndex + i ) ! = chars [ i ] ) { return false ; } } return true ; } public static class HttpOnTransportException extends ElasticsearchException { public HttpOnTransportException ( String msg ) { super ( msg ) ; } @Override public RestStatus status ( ) { return RestStatus . BAD_REQUEST ; } public HttpOnTransportException ( StreamInput in ) throws IOException { super ( in ) ; } } } 
