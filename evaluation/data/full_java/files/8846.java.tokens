package org . elasticsearch . index . mapper . murmur3 ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . Version ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . hash . MurmurHash3 ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . analysis . NumericLongAnalyzer ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseNumberField ; public class Murmur3FieldMapper extends LongFieldMapper { public static final String CONTENT_TYPE = <str> ; public static class Defaults extends LongFieldMapper . Defaults { public static final MappedFieldType FIELD_TYPE = new Murmur3FieldType ( ) ; static { FIELD_TYPE . freeze ( ) ; } } public static class Builder extends NumberFieldMapper . Builder < Builder , Murmur3FieldMapper > { public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE , Integer . MAX_VALUE ) ; builder = this ; builder . precisionStep ( Integer . MAX_VALUE ) ; } @Override public Murmur3FieldMapper build ( BuilderContext context ) { setupFieldType ( context ) ; Murmur3FieldMapper fieldMapper = new Murmur3FieldMapper ( name , fieldType , defaultFieldType , ignoreMalformed ( context ) , coerce ( context ) , context . indexSettings ( ) , multiFieldsBuilder . build ( this , context ) , copyTo ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } @Override protected void setupFieldType ( BuilderContext context ) { super . setupFieldType ( context ) ; if ( context . indexCreatedVersion ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { fieldType . setIndexOptions ( IndexOptions . NONE ) ; defaultFieldType . setIndexOptions ( IndexOptions . NONE ) ; fieldType . setHasDocValues ( true ) ; defaultFieldType . setHasDocValues ( true ) ; } } @Override protected NamedAnalyzer makeNumberAnalyzer ( int precisionStep ) { return NumericLongAnalyzer . buildNamedAnalyzer ( precisionStep ) ; } @Override protected int maxPrecisionStep ( ) { return <int> ; } } public static class TypeParser implements Mapper . TypeParser { @Override @SuppressWarnings ( <str> ) public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { Builder builder = new Builder ( name ) ; if ( parserContext . indexVersionCreated ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { if ( node . get ( <str> ) ! = null ) { throw new MapperParsingException ( <str> + name + <str> ) ; } if ( node . get ( <str> ) ! = null ) { throw new MapperParsingException ( <str> + name + <str> ) ; } } if ( parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { builder . indexOptions ( IndexOptions . DOCS ) ; } parseNumberField ( builder , name , node , parserContext ) ; return builder ; } } public static class Murmur3FieldType extends LongFieldMapper . LongFieldType { public Murmur3FieldType ( ) { } protected Murmur3FieldType ( Murmur3FieldType ref ) { super ( ref ) ; } @Override public Murmur3FieldType clone ( ) { return new Murmur3FieldType ( this ) ; } } protected Murmur3FieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Explicit < Boolean > ignoreMalformed , Explicit < Boolean > coerce , Settings indexSettings , MultiFields multiFields , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , ignoreMalformed , coerce , indexSettings , multiFields , copyTo ) ; } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override protected void innerParseCreateField ( ParseContext context , List < Field > fields ) throws IOException { final Object value ; if ( context . externalValueSet ( ) ) { value = context . externalValue ( ) ; } else { value = context . parser ( ) . textOrNull ( ) ; } if ( value ! = null ) { final BytesRef bytes = new BytesRef ( value . toString ( ) ) ; final long hash = MurmurHash3 . hash128 ( bytes . bytes , bytes . offset , bytes . length , <int> , new MurmurHash3 . Hash128 ( ) ) . h1 ; super . innerParseCreateField ( context . createExternalValueContext ( hash ) , fields ) ; } } @Override public boolean isGenerated ( ) { return true ; } } 
