package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Iterator ; import javax . annotation . Nullable ; import com . google . common . primitives . Ints ; import com . google . common . util . concurrent . RateLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . UnknownColumnFamilyException ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . AbstractIterator ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . CLibrary ; final class HintsReader implements AutoCloseable , Iterable < HintsReader . Page > { private static final Logger logger = LoggerFactory . getLogger ( HintsReader . class ) ; private static final int PAGE_SIZE = <int> < < <int> ; private final HintsDescriptor descriptor ; private final File file ; private final ChecksummedDataInput input ; @Nullable private final RateLimiter rateLimiter ; private HintsReader ( HintsDescriptor descriptor , File file , ChecksummedDataInput reader , RateLimiter rateLimiter ) { this . descriptor = descriptor ; this . file = file ; this . input = reader ; this . rateLimiter = rateLimiter ; } @SuppressWarnings ( <str> ) static HintsReader open ( File file , RateLimiter rateLimiter ) { ChecksummedDataInput reader = ChecksummedDataInput . open ( file ) ; try { HintsDescriptor descriptor = HintsDescriptor . deserialize ( reader ) ; return new HintsReader ( descriptor , file , reader , rateLimiter ) ; } catch ( IOException e ) { reader . close ( ) ; throw new FSReadError ( e , file ) ; } } static HintsReader open ( File file ) { return open ( file , null ) ; } public void close ( ) { input . close ( ) ; } public HintsDescriptor descriptor ( ) { return descriptor ; } void seek ( long newPosition ) { input . seek ( newPosition ) ; } public Iterator < Page > iterator ( ) { return new PagesIterator ( ) ; } final class Page { public final long offset ; private Page ( long offset ) { this . offset = offset ; } Iterator < Hint > hintsIterator ( ) { return new HintsIterator ( offset ) ; } Iterator < ByteBuffer > buffersIterator ( ) { return new BuffersIterator ( offset ) ; } } final class PagesIterator extends AbstractIterator < Page > { @SuppressWarnings ( <str> ) protected Page computeNext ( ) { CLibrary . trySkipCache ( input . getChannel ( ) . getFileDescriptor ( ) , <int> , input . getFilePointer ( ) , input . getPath ( ) ) ; if ( input . length ( ) = = input . getFilePointer ( ) ) return endOfData ( ) ; return new Page ( input . getFilePointer ( ) ) ; } } final class HintsIterator extends AbstractIterator < Hint > { private final long offset ; HintsIterator ( long offset ) { super ( ) ; this . offset = offset ; } protected Hint computeNext ( ) { Hint hint ; do { long position = input . getFilePointer ( ) ; if ( input . length ( ) = = position ) return endOfData ( ) ; if ( position - offset > = PAGE_SIZE ) return endOfData ( ) ; try { hint = computeNextInternal ( ) ; } catch ( IOException e ) { throw new FSReadError ( e , file ) ; } } while ( hint = = null ) ; return hint ; } private Hint computeNextInternal ( ) throws IOException { input . resetCrc ( ) ; input . resetLimit ( ) ; int size = input . readInt ( ) ; if ( ! input . checkCrc ( ) ) throw new IOException ( <str> ) ; return readHint ( size ) ; } private Hint readHint ( int size ) throws IOException { if ( rateLimiter ! = null ) rateLimiter . acquire ( size ) ; input . limit ( size ) ; Hint hint ; try { hint = Hint . serializer . deserialize ( input , descriptor . messagingVersion ( ) ) ; input . checkLimit ( <int> ) ; } catch ( UnknownColumnFamilyException e ) { logger . warn ( <str> , descriptor . hostId , e . cfId , descriptor . fileName ( ) ) ; input . skipBytes ( Ints . checkedCast ( size - input . bytesPastLimit ( ) ) ) ; return null ; } if ( input . checkCrc ( ) ) return hint ; logger . warn ( <str> , descriptor . hostId , input . getPosition ( ) - size - <int> , descriptor . fileName ( ) ) ; return null ; } } final class BuffersIterator extends AbstractIterator < ByteBuffer > { private final long offset ; BuffersIterator ( long offset ) { super ( ) ; this . offset = offset ; } protected ByteBuffer computeNext ( ) { ByteBuffer buffer ; do { long position = input . getFilePointer ( ) ; if ( input . length ( ) = = position ) return endOfData ( ) ; if ( position - offset > = PAGE_SIZE ) return endOfData ( ) ; try { buffer = computeNextInternal ( ) ; } catch ( IOException e ) { throw new FSReadError ( e , file ) ; } } while ( buffer = = null ) ; return buffer ; } private ByteBuffer computeNextInternal ( ) throws IOException { input . resetCrc ( ) ; input . resetLimit ( ) ; int size = input . readInt ( ) ; if ( ! input . checkCrc ( ) ) throw new IOException ( <str> ) ; return readBuffer ( size ) ; } private ByteBuffer readBuffer ( int size ) throws IOException { if ( rateLimiter ! = null ) rateLimiter . acquire ( size ) ; input . limit ( size ) ; ByteBuffer buffer = ByteBufferUtil . read ( input , size ) ; if ( input . checkCrc ( ) ) return buffer ; logger . warn ( <str> , descriptor . hostId , input . getPosition ( ) - size - <int> , descriptor . fileName ( ) ) ; return null ; } } } 
