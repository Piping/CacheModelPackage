package org . elasticsearch . cluster ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamableReader ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; public abstract class AbstractDiffable < T extends Diffable < T > > implements Diffable < T > { @Override public Diff < T > diff ( T previousState ) { if ( this . get ( ) . equals ( previousState ) ) { return new CompleteDiff < > ( ) ; } else { return new CompleteDiff < > ( get ( ) ) ; } } @Override public Diff < T > readDiffFrom ( StreamInput in ) throws IOException { return new CompleteDiff < > ( this , in ) ; } public static < T extends Diffable < T > > Diff < T > readDiffFrom ( StreamableReader < T > reader , StreamInput in ) throws IOException { return new CompleteDiff < T > ( reader , in ) ; } private static class CompleteDiff < T extends Diffable < T > > implements Diff < T > { @Nullable private final T part ; public CompleteDiff ( T part ) { this . part = part ; } public CompleteDiff ( ) { this . part = null ; } public CompleteDiff ( StreamableReader < T > reader , StreamInput in ) throws IOException { if ( in . readBoolean ( ) ) { this . part = reader . readFrom ( in ) ; } else { this . part = null ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { if ( part ! = null ) { out . writeBoolean ( true ) ; part . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; } } @Override public T apply ( T part ) { if ( this . part ! = null ) { return this . part ; } else { return part ; } } } @SuppressWarnings ( <str> ) public T get ( ) { return ( T ) this ; } } 
