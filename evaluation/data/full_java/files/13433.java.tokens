package org . gradle . api . tasks . compile ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . internal . tasks . compile . * ; import org . gradle . api . internal . tasks . compile . daemon . CompilerDaemonManager ; import org . gradle . api . internal . tasks . compile . daemon . InProcessCompilerDaemonFactory ; import org . gradle . api . tasks . InputFiles ; import org . gradle . api . tasks . Nested ; import org . gradle . api . tasks . TaskAction ; import org . gradle . api . tasks . WorkResult ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . GFileUtils ; import java . io . File ; public class GroovyCompile extends AbstractCompile { private Compiler < GroovyJavaJointCompileSpec > compiler ; private FileCollection groovyClasspath ; private final CompileOptions compileOptions = new CompileOptions ( ) ; private final GroovyCompileOptions groovyCompileOptions = new GroovyCompileOptions ( ) ; @TaskAction protected void compile ( ) { checkGroovyClasspathIsNonEmpty ( ) ; DefaultGroovyJavaJointCompileSpec spec = createSpec ( ) ; WorkResult result = getCompiler ( spec ) . execute ( spec ) ; setDidWork ( result . getDidWork ( ) ) ; } private Compiler < GroovyJavaJointCompileSpec > getCompiler ( GroovyJavaJointCompileSpec spec ) { if ( compiler = = null ) { ProjectInternal projectInternal = ( ProjectInternal ) getProject ( ) ; CompilerDaemonManager compilerDaemonManager = getServices ( ) . get ( CompilerDaemonManager . class ) ; InProcessCompilerDaemonFactory inProcessCompilerDaemonFactory = getServices ( ) . get ( InProcessCompilerDaemonFactory . class ) ; JavaCompilerFactory javaCompilerFactory = getServices ( ) . get ( JavaCompilerFactory . class ) ; GroovyCompilerFactory groovyCompilerFactory = new GroovyCompilerFactory ( projectInternal , javaCompilerFactory , compilerDaemonManager , inProcessCompilerDaemonFactory ) ; Compiler < GroovyJavaJointCompileSpec > delegatingCompiler = groovyCompilerFactory . newCompiler ( spec ) ; compiler = new CleaningGroovyCompiler ( delegatingCompiler , getOutputs ( ) ) ; } return compiler ; } private DefaultGroovyJavaJointCompileSpec createSpec ( ) { DefaultGroovyJavaJointCompileSpec spec = new DefaultGroovyJavaJointCompileSpecFactory ( compileOptions ) . create ( ) ; spec . setSource ( getSource ( ) ) ; spec . setDestinationDir ( getDestinationDir ( ) ) ; spec . setWorkingDir ( getProject ( ) . getProjectDir ( ) ) ; spec . setTempDir ( getTemporaryDir ( ) ) ; spec . setClasspath ( getClasspath ( ) ) ; spec . setSourceCompatibility ( getSourceCompatibility ( ) ) ; spec . setTargetCompatibility ( getTargetCompatibility ( ) ) ; spec . setGroovyClasspath ( getGroovyClasspath ( ) ) ; spec . setCompileOptions ( compileOptions ) ; spec . setGroovyCompileOptions ( groovyCompileOptions ) ; if ( spec . getGroovyCompileOptions ( ) . getStubDir ( ) = = null ) { File dir = new File ( getTemporaryDir ( ) , <str> ) ; GFileUtils . mkdirs ( dir ) ; spec . getGroovyCompileOptions ( ) . setStubDir ( dir ) ; } return spec ; } private void checkGroovyClasspathIsNonEmpty ( ) { if ( getGroovyClasspath ( ) . isEmpty ( ) ) { throw new InvalidUserDataException ( <str> + getName ( ) + <str> + <str> ) ; } } @Nested public GroovyCompileOptions getGroovyOptions ( ) { return groovyCompileOptions ; } @Nested public CompileOptions getOptions ( ) { return compileOptions ; } @InputFiles public FileCollection getGroovyClasspath ( ) { return groovyClasspath ; } public void setGroovyClasspath ( FileCollection groovyClasspath ) { this . groovyClasspath = groovyClasspath ; } public Compiler < GroovyJavaJointCompileSpec > getCompiler ( ) { return getCompiler ( createSpec ( ) ) ; } public void setCompiler ( Compiler < GroovyJavaJointCompileSpec > compiler ) { this . compiler = compiler ; } } 
