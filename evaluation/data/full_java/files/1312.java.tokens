package org . apache . cassandra . dht . tokenallocator ; import java . util . * ; import junit . framework . Assert ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import org . apache . commons . math3 . stat . descriptive . SummaryStatistics ; import org . junit . Test ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . dht . Token ; public class ReplicationAwareTokenAllocatorTest { private static final int MAX_VNODE_COUNT = <int> ; private static final int TARGET_CLUSTER_SIZE = <int> ; interface TestReplicationStrategy extends ReplicationStrategy < Unit > { void addUnit ( Unit n ) ; void removeUnit ( Unit n ) ; List < Unit > getReplicas ( Token token , NavigableMap < Token , Unit > sortedTokens ) ; Token replicationStart ( Token token , Unit unit , NavigableMap < Token , Unit > sortedTokens ) ; public double spreadExpectation ( ) ; } static class NoReplicationStrategy implements TestReplicationStrategy { public List < Unit > getReplicas ( Token token , NavigableMap < Token , Unit > sortedTokens ) { return Collections . singletonList ( sortedTokens . ceilingEntry ( token ) . getValue ( ) ) ; } public Token replicationStart ( Token token , Unit unit , NavigableMap < Token , Unit > sortedTokens ) { return sortedTokens . lowerKey ( token ) ; } public String toString ( ) { return <str> ; } public void addUnit ( Unit n ) { } public void removeUnit ( Unit n ) { } public int replicas ( ) { return <int> ; } public boolean sameGroup ( Unit n1 , Unit n2 ) { return false ; } public Object getGroup ( Unit unit ) { return unit ; } public double spreadExpectation ( ) { return <int> ; } } static class SimpleReplicationStrategy implements TestReplicationStrategy { int replicas ; public SimpleReplicationStrategy ( int replicas ) { super ( ) ; this . replicas = replicas ; } public List < Unit > getReplicas ( Token token , NavigableMap < Token , Unit > sortedTokens ) { List < Unit > endpoints = new ArrayList < Unit > ( replicas ) ; token = sortedTokens . ceilingKey ( token ) ; if ( token = = null ) token = sortedTokens . firstKey ( ) ; Iterator < Unit > iter = Iterables . concat ( sortedTokens . tailMap ( token , true ) . values ( ) , sortedTokens . values ( ) ) . iterator ( ) ; while ( endpoints . size ( ) < replicas ) { if ( ! iter . hasNext ( ) ) return endpoints ; Unit ep = iter . next ( ) ; if ( ! endpoints . contains ( ep ) ) endpoints . add ( ep ) ; } return endpoints ; } public Token replicationStart ( Token token , Unit unit , NavigableMap < Token , Unit > sortedTokens ) { Set < Unit > seenUnits = Sets . newHashSet ( ) ; int unitsFound = <int> ; for ( Map . Entry < Token , Unit > en : Iterables . concat ( sortedTokens . headMap ( token , false ) . descendingMap ( ) . entrySet ( ) , sortedTokens . descendingMap ( ) . entrySet ( ) ) ) { Unit n = en . getValue ( ) ; if ( n = = unit ) break ; if ( seenUnits . add ( n ) ) { if ( + + unitsFound = = replicas ) break ; } token = en . getKey ( ) ; } return token ; } public void addUnit ( Unit n ) { } public void removeUnit ( Unit n ) { } public String toString ( ) { return String . format ( <str> , replicas ) ; } public int replicas ( ) { return replicas ; } public boolean sameGroup ( Unit n1 , Unit n2 ) { return false ; } public Unit getGroup ( Unit unit ) { return unit ; } public double spreadExpectation ( ) { return <int> ; } } static abstract class GroupReplicationStrategy implements TestReplicationStrategy { final int replicas ; final Map < Unit , Integer > groupMap ; public GroupReplicationStrategy ( int replicas ) { this . replicas = replicas ; this . groupMap = Maps . newHashMap ( ) ; } public List < Unit > getReplicas ( Token token , NavigableMap < Token , Unit > sortedTokens ) { List < Unit > endpoints = new ArrayList < Unit > ( replicas ) ; BitSet usedGroups = new BitSet ( ) ; if ( sortedTokens . isEmpty ( ) ) return endpoints ; token = sortedTokens . ceilingKey ( token ) ; if ( token = = null ) token = sortedTokens . firstKey ( ) ; Iterator < Unit > iter = Iterables . concat ( sortedTokens . tailMap ( token , true ) . values ( ) , sortedTokens . values ( ) ) . iterator ( ) ; while ( endpoints . size ( ) < replicas ) { Unit ep = iter . next ( ) ; int group = groupMap . get ( ep ) ; if ( ! usedGroups . get ( group ) ) { endpoints . add ( ep ) ; usedGroups . set ( group ) ; } } return endpoints ; } public Token lastReplicaToken ( Token token , NavigableMap < Token , Unit > sortedTokens ) { BitSet usedGroups = new BitSet ( ) ; int groupsFound = <int> ; token = sortedTokens . ceilingKey ( token ) ; if ( token = = null ) token = sortedTokens . firstKey ( ) ; for ( Map . Entry < Token , Unit > en : Iterables . concat ( sortedTokens . tailMap ( token , true ) . entrySet ( ) , sortedTokens . entrySet ( ) ) ) { Unit ep = en . getValue ( ) ; int group = groupMap . get ( ep ) ; if ( ! usedGroups . get ( group ) ) { usedGroups . set ( group ) ; if ( + + groupsFound > = replicas ) return en . getKey ( ) ; } } return token ; } public Token replicationStart ( Token token , Unit unit , NavigableMap < Token , Unit > sortedTokens ) { int unitGroup = groupMap . get ( unit ) ; BitSet seenGroups = new BitSet ( ) ; int groupsFound = <int> ; for ( Map . Entry < Token , Unit > en : Iterables . concat ( sortedTokens . headMap ( token , false ) . descendingMap ( ) . entrySet ( ) , sortedTokens . descendingMap ( ) . entrySet ( ) ) ) { Unit n = en . getValue ( ) ; int ngroup = groupMap . get ( n ) ; if ( ngroup = = unitGroup ) break ; if ( ! seenGroups . get ( ngroup ) ) { if ( + + groupsFound = = replicas ) break ; seenGroups . set ( ngroup ) ; } token = en . getKey ( ) ; } return token ; } public String toString ( ) { Map < Integer , Integer > idToSize = instanceToCount ( groupMap ) ; Map < Integer , Integer > sizeToCount = Maps . newTreeMap ( ) ; sizeToCount . putAll ( instanceToCount ( idToSize ) ) ; return String . format ( <str> , getClass ( ) . getSimpleName ( ) , replicas , sizeToCount ) ; } @Override public int replicas ( ) { return replicas ; } public boolean sameGroup ( Unit n1 , Unit n2 ) { return groupMap . get ( n1 ) . equals ( groupMap . get ( n2 ) ) ; } public void removeUnit ( Unit n ) { groupMap . remove ( n ) ; } public Integer getGroup ( Unit unit ) { return groupMap . get ( unit ) ; } public double spreadExpectation ( ) { return <float> ; } } private static < T > Map < T , Integer > instanceToCount ( Map < ? , T > map ) { Map < T , Integer > idToCount = Maps . newHashMap ( ) ; for ( Map . Entry < ? , T > en : map . entrySet ( ) ) { Integer old = idToCount . get ( en . getValue ( ) ) ; idToCount . put ( en . getValue ( ) , old ! = null ? old + <int> : <int> ) ; } return idToCount ; } static class FixedGroupCountReplicationStrategy extends GroupReplicationStrategy { int groupId ; int groupCount ; public FixedGroupCountReplicationStrategy ( int replicas , int groupCount ) { super ( replicas ) ; assert groupCount > = replicas ; groupId = <int> ; this . groupCount = groupCount ; } public void addUnit ( Unit n ) { groupMap . put ( n , groupId + + % groupCount ) ; } } static class BalancedGroupReplicationStrategy extends GroupReplicationStrategy { int groupId ; int groupSize ; public BalancedGroupReplicationStrategy ( int replicas , int groupSize ) { super ( replicas ) ; groupId = <int> ; this . groupSize = groupSize ; } public void addUnit ( Unit n ) { groupMap . put ( n , groupId + + / groupSize ) ; } } static class UnbalancedGroupReplicationStrategy extends GroupReplicationStrategy { int groupId ; int nextSize ; int num ; int minGroupSize ; int maxGroupSize ; Random rand ; public UnbalancedGroupReplicationStrategy ( int replicas , int minGroupSize , int maxGroupSize , Random rand ) { super ( replicas ) ; groupId = - <int> ; nextSize = <int> ; num = <int> ; this . maxGroupSize = maxGroupSize ; this . minGroupSize = minGroupSize ; this . rand = rand ; } public void addUnit ( Unit n ) { if ( + + num > nextSize ) { nextSize = minGroupSize + rand . nextInt ( maxGroupSize - minGroupSize + <int> ) ; + + groupId ; num = <int> ; } groupMap . put ( n , groupId ) ; } public double spreadExpectation ( ) { return <int> ; } } static Map < Unit , Double > evaluateReplicatedOwnership ( ReplicationAwareTokenAllocator < Unit > t ) { Map < Unit , Double > ownership = Maps . newHashMap ( ) ; Iterator < Token > it = t . sortedTokens . keySet ( ) . iterator ( ) ; if ( ! it . hasNext ( ) ) return ownership ; Token current = it . next ( ) ; while ( it . hasNext ( ) ) { Token next = it . next ( ) ; addOwnership ( t , current , next , ownership ) ; current = next ; } addOwnership ( t , current , t . sortedTokens . firstKey ( ) , ownership ) ; return ownership ; } private static void addOwnership ( ReplicationAwareTokenAllocator < Unit > t , Token current , Token next , Map < Unit , Double > ownership ) { TestReplicationStrategy ts = ( TestReplicationStrategy ) t . strategy ; double size = current . size ( next ) ; Token representative = t . partitioner . midpoint ( current , next ) ; for ( Unit n : ts . getReplicas ( representative , t . sortedTokens ) ) { Double v = ownership . get ( n ) ; ownership . put ( n , v ! = null ? v + size : size ) ; } } private static double replicatedTokenOwnership ( Token token , NavigableMap < Token , Unit > sortedTokens , ReplicationStrategy < Unit > strategy ) { TestReplicationStrategy ts = ( TestReplicationStrategy ) strategy ; Token next = sortedTokens . higherKey ( token ) ; if ( next = = null ) next = sortedTokens . firstKey ( ) ; return ts . replicationStart ( token , sortedTokens . get ( token ) , sortedTokens ) . size ( next ) ; } static interface TokenCount { int tokenCount ( int perUnitCount , Random rand ) ; double spreadExpectation ( ) ; } static TokenCount fixedTokenCount = new TokenCount ( ) { public int tokenCount ( int perUnitCount , Random rand ) { return perUnitCount ; } public double spreadExpectation ( ) { return <int> ; } } ; static TokenCount varyingTokenCount = new TokenCount ( ) { public int tokenCount ( int perUnitCount , Random rand ) { if ( perUnitCount = = <int> ) return <int> ; return rand . nextInt ( perUnitCount * <int> / <int> ) + ( perUnitCount + <int> ) / <int> ; } public double spreadExpectation ( ) { return <int> ; } } ; Murmur3Partitioner partitioner = new Murmur3Partitioner ( ) ; Random seededRand = new Random ( <int> ) ; private void random ( Map < Token , Unit > map , TestReplicationStrategy rs , int unitCount , TokenCount tc , int perUnitCount ) { System . out . format ( <str> , unitCount , perUnitCount ) ; Random rand = seededRand ; for ( int i = <int> ; i < unitCount ; i + + ) { Unit unit = new Unit ( ) ; rs . addUnit ( unit ) ; int tokens = tc . tokenCount ( perUnitCount , rand ) ; for ( int j = <int> ; j < tokens ; j + + ) { map . put ( partitioner . getRandomToken ( rand ) , unit ) ; } } } @Test public void testExistingCluster ( ) { for ( int rf = <int> ; rf < = <int> ; + + rf ) { for ( int perUnitCount = <int> ; perUnitCount < = MAX_VNODE_COUNT ; perUnitCount * = <int> ) { testExistingCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; testExistingCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; if ( rf = = <int> ) continue ; for ( int groupSize = <int> ; groupSize < = <int> & & groupSize * rf * <int> < TARGET_CLUSTER_SIZE ; groupSize * = <int> ) { testExistingCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; testExistingCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / <int> , groupSize * <int> , seededRand ) ) ; } testExistingCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * <int> ) ) ; } } } public void testExistingCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) { System . out . println ( <str> + perUnitCount + <str> + rs ) ; final int targetClusterSize = TARGET_CLUSTER_SIZE ; NavigableMap < Token , Unit > tokenMap = Maps . newTreeMap ( ) ; random ( tokenMap , rs , targetClusterSize / <int> , tc , perUnitCount ) ; ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; grow ( t , targetClusterSize * <int> / <int> , tc , perUnitCount , false ) ; grow ( t , targetClusterSize , tc , perUnitCount , true ) ; loseAndReplace ( t , targetClusterSize / <int> , tc , perUnitCount ) ; System . out . println ( ) ; } @Test public void testNewCluster ( ) { for ( int rf = <int> ; rf < = <int> ; + + rf ) { for ( int perUnitCount = <int> ; perUnitCount < = MAX_VNODE_COUNT ; perUnitCount * = <int> ) { testNewCluster ( perUnitCount , fixedTokenCount , new SimpleReplicationStrategy ( rf ) ) ; testNewCluster ( perUnitCount , varyingTokenCount , new SimpleReplicationStrategy ( rf ) ) ; if ( rf = = <int> ) continue ; for ( int groupSize = <int> ; groupSize < = <int> & & groupSize * rf * <int> < TARGET_CLUSTER_SIZE ; groupSize * = <int> ) { testNewCluster ( perUnitCount , fixedTokenCount , new BalancedGroupReplicationStrategy ( rf , groupSize ) ) ; testNewCluster ( perUnitCount , varyingTokenCount , new UnbalancedGroupReplicationStrategy ( rf , groupSize / <int> , groupSize * <int> , seededRand ) ) ; } testNewCluster ( perUnitCount , fixedTokenCount , new FixedGroupCountReplicationStrategy ( rf , rf * <int> ) ) ; } } } public void testNewCluster ( int perUnitCount , TokenCount tc , TestReplicationStrategy rs ) { System . out . println ( <str> + perUnitCount + <str> + rs ) ; final int targetClusterSize = TARGET_CLUSTER_SIZE ; NavigableMap < Token , Unit > tokenMap = Maps . newTreeMap ( ) ; ReplicationAwareTokenAllocator < Unit > t = new ReplicationAwareTokenAllocator < > ( tokenMap , rs , partitioner ) ; grow ( t , targetClusterSize * <int> / <int> , tc , perUnitCount , false ) ; grow ( t , targetClusterSize , tc , perUnitCount , true ) ; loseAndReplace ( t , targetClusterSize / <int> , tc , perUnitCount ) ; System . out . println ( ) ; } private void loseAndReplace ( ReplicationAwareTokenAllocator < Unit > t , int howMany , TokenCount tc , int perUnitCount ) { int fullCount = t . unitCount ( ) ; System . out . format ( <str> , howMany ) ; for ( int i = <int> ; i < howMany ; + + i ) { Unit u = t . unitFor ( partitioner . getRandomToken ( seededRand ) ) ; t . removeUnit ( u ) ; ( ( TestReplicationStrategy ) t . strategy ) . removeUnit ( u ) ; } grow ( t , ( t . unitCount ( ) + fullCount * <int> ) / <int> , tc , perUnitCount , false ) ; grow ( t , fullCount , tc , perUnitCount , true ) ; } static class Summary { double min = <int> ; double max = <int> ; double stddev = <int> ; void update ( SummaryStatistics stat ) { min = Math . min ( min , stat . getMin ( ) ) ; max = Math . max ( max , stat . getMax ( ) ) ; stddev = Math . max ( stddev , stat . getStandardDeviation ( ) ) ; } public String toString ( ) { return String . format ( <str> , max , min , stddev ) ; } } public void grow ( ReplicationAwareTokenAllocator < Unit > t , int targetClusterSize , TokenCount tc , int perUnitCount , boolean verifyMetrics ) { int size = t . unitCount ( ) ; Summary su = new Summary ( ) ; Summary st = new Summary ( ) ; Random rand = new Random ( targetClusterSize + perUnitCount ) ; TestReplicationStrategy strategy = ( TestReplicationStrategy ) t . strategy ; if ( size < targetClusterSize ) { System . out . format ( <str> , targetClusterSize - size , t . toString ( ) ) ; long time = System . currentTimeMillis ( ) ; while ( size < targetClusterSize ) { int tokens = tc . tokenCount ( perUnitCount , rand ) ; Unit unit = new Unit ( ) ; strategy . addUnit ( unit ) ; t . addUnit ( unit , tokens ) ; + + size ; if ( verifyMetrics ) updateSummary ( t , su , st , false ) ; } System . out . format ( <str> , ( System . currentTimeMillis ( ) - time ) / <float> ) ; if ( verifyMetrics ) { updateSummary ( t , su , st , true ) ; double maxExpected = <float> + tc . spreadExpectation ( ) * strategy . spreadExpectation ( ) / ( perUnitCount * t . replicas ) ; if ( su . max > maxExpected ) { Assert . fail ( String . format ( <str> , maxExpected , su . max ) ) ; } } } } private void updateSummary ( ReplicationAwareTokenAllocator < Unit > t , Summary su , Summary st , boolean print ) { int size = t . sortedTokens . size ( ) ; double inverseAverage = <float> * size / t . strategy . replicas ( ) ; Map < Unit , Double > ownership = evaluateReplicatedOwnership ( t ) ; SummaryStatistics unitStat = new SummaryStatistics ( ) ; for ( Map . Entry < Unit , Double > en : ownership . entrySet ( ) ) unitStat . addValue ( en . getValue ( ) * inverseAverage / t . unitToTokens . get ( en . getKey ( ) ) . size ( ) ) ; su . update ( unitStat ) ; SummaryStatistics tokenStat = new SummaryStatistics ( ) ; for ( Token tok : t . sortedTokens . keySet ( ) ) tokenStat . addValue ( replicatedTokenOwnership ( tok , t . sortedTokens , t . strategy ) * inverseAverage ) ; st . update ( tokenStat ) ; if ( print ) { System . out . format ( <str> , t . unitCount ( ) , size , mms ( unitStat ) , mms ( tokenStat ) , t . strategy ) ; System . out . format ( <str> , su , st ) ; } } private static String mms ( SummaryStatistics s ) { return String . format ( <str> , s . getMax ( ) , s . getMin ( ) , s . getStandardDeviation ( ) ) ; } int nextUnitId = <int> ; final class Unit implements Comparable < Unit > { int unitId = nextUnitId + + ; public String toString ( ) { return Integer . toString ( unitId ) ; } @Override public int compareTo ( Unit o ) { return Integer . compare ( unitId , o . unitId ) ; } } } 
