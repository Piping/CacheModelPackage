package org . apache . cassandra . db ; import java . io . IOException ; import java . util . Date ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicReference ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . junit . Assert ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . assertEquals ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . db . commitlog . CommitLogArchiver ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . db . commitlog . CommitLogReplayer ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class RecoveryManagerTest { private static Logger logger = LoggerFactory . getLogger ( RecoveryManagerTest . class ) ; static final Semaphore blocker = new Semaphore ( <int> ) ; static final Semaphore blocked = new Semaphore ( <int> ) ; static CommitLogReplayer . MutationInitiator originalInitiator = null ; static final CommitLogReplayer . MutationInitiator mockInitiator = new CommitLogReplayer . MutationInitiator ( ) { @Override protected Future < Integer > initiateMutation ( final Mutation mutation , final long segmentId , final int serializedSize , final long entryLocation , final CommitLogReplayer clr ) { final Future < Integer > toWrap = super . initiateMutation ( mutation , segmentId , serializedSize , entryLocation , clr ) ; return new Future < Integer > ( ) { @Override public boolean cancel ( boolean mayInterruptIfRunning ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean isCancelled ( ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean isDone ( ) { return blocker . availablePermits ( ) > <int> & & toWrap . isDone ( ) ; } @Override public Integer get ( ) throws InterruptedException , ExecutionException { System . out . println ( <str> ) ; blocked . release ( ) ; blocker . acquire ( ) ; return toWrap . get ( ) ; } @Override public Integer get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { blocked . release ( ) ; blocker . tryAcquire ( <int> , timeout , unit ) ; return toWrap . get ( timeout , unit ) ; } } ; } } ; private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private static final String CF_COUNTER1 = <str> ; private static final String KEYSPACE2 = <str> ; private static final String CF_STANDARD3 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . counterCFMD ( KEYSPACE1 , CF_COUNTER1 ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE2 , CF_STANDARD3 ) ) ; } @Before public void clearData ( ) { Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_COUNTER1 ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE2 ) . getColumnFamilyStore ( CF_STANDARD3 ) . truncateBlocking ( ) ; } @Test public void testNothingToRecover ( ) throws IOException { CommitLog . instance . resetUnsafe ( true ) ; } @Test public void testRecoverBlocksOnBytesOutstanding ( ) throws Exception { long originalMaxOutstanding = CommitLogReplayer . MAX_OUTSTANDING_REPLAY_BYTES ; CommitLogReplayer . MAX_OUTSTANDING_REPLAY_BYTES = <int> ; CommitLogReplayer . MutationInitiator originalInitiator = CommitLogReplayer . mutationInitiator ; CommitLogReplayer . mutationInitiator = mockInitiator ; try { CommitLog . instance . resetUnsafe ( true ) ; Keyspace keyspace1 = Keyspace . open ( KEYSPACE1 ) ; Keyspace keyspace2 = Keyspace . open ( KEYSPACE2 ) ; UnfilteredRowIterator upd1 = Util . apply ( new RowUpdateBuilder ( keyspace1 . getColumnFamilyStore ( CF_STANDARD1 ) . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ) ; UnfilteredRowIterator upd2 = Util . apply ( new RowUpdateBuilder ( keyspace2 . getColumnFamilyStore ( CF_STANDARD3 ) . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ) ; keyspace1 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; keyspace2 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; DecoratedKey dk = Util . dk ( <str> ) ; Assert . assertTrue ( Util . getAllUnfiltered ( Util . cmd ( keyspace1 . getColumnFamilyStore ( CF_STANDARD1 ) , dk ) . build ( ) ) . isEmpty ( ) ) ; Assert . assertTrue ( Util . getAllUnfiltered ( Util . cmd ( keyspace2 . getColumnFamilyStore ( CF_STANDARD3 ) , dk ) . build ( ) ) . isEmpty ( ) ) ; final AtomicReference < Throwable > err = new AtomicReference < Throwable > ( ) ; Thread t = new Thread ( ) { @Override public void run ( ) { try { CommitLog . instance . resetUnsafe ( false ) ; } catch ( Throwable t ) { err . set ( t ) ; } } } ; t . start ( ) ; Assert . assertTrue ( blocked . tryAcquire ( <int> , <int> , TimeUnit . SECONDS ) ) ; Thread . sleep ( <int> ) ; Assert . assertTrue ( t . isAlive ( ) ) ; blocker . release ( Integer . MAX_VALUE ) ; t . join ( <int> * <int> ) ; if ( err . get ( ) ! = null ) throw new RuntimeException ( err . get ( ) ) ; if ( t . isAlive ( ) ) { Throwable toPrint = new Throwable ( ) ; toPrint . setStackTrace ( Thread . getAllStackTraces ( ) . get ( t ) ) ; toPrint . printStackTrace ( System . out ) ; } Assert . assertFalse ( t . isAlive ( ) ) ; Assert . assertTrue ( Util . equal ( upd1 , Util . getOnlyPartitionUnfiltered ( Util . cmd ( keyspace1 . getColumnFamilyStore ( CF_STANDARD1 ) , dk ) . build ( ) ) . unfilteredIterator ( ) ) ) ; Assert . assertTrue ( Util . equal ( upd2 , Util . getOnlyPartitionUnfiltered ( Util . cmd ( keyspace2 . getColumnFamilyStore ( CF_STANDARD3 ) , dk ) . build ( ) ) . unfilteredIterator ( ) ) ) ; } finally { CommitLogReplayer . mutationInitiator = originalInitiator ; CommitLogReplayer . MAX_OUTSTANDING_REPLAY_BYTES = originalMaxOutstanding ; } } @Test public void testOne ( ) throws IOException { CommitLog . instance . resetUnsafe ( true ) ; Keyspace keyspace1 = Keyspace . open ( KEYSPACE1 ) ; Keyspace keyspace2 = Keyspace . open ( KEYSPACE2 ) ; UnfilteredRowIterator upd1 = Util . apply ( new RowUpdateBuilder ( keyspace1 . getColumnFamilyStore ( CF_STANDARD1 ) . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ) ; UnfilteredRowIterator upd2 = Util . apply ( new RowUpdateBuilder ( keyspace2 . getColumnFamilyStore ( CF_STANDARD3 ) . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ) ; keyspace1 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; keyspace2 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; CommitLog . instance . resetUnsafe ( false ) ; DecoratedKey dk = Util . dk ( <str> ) ; Assert . assertTrue ( Util . equal ( upd1 , Util . getOnlyPartitionUnfiltered ( Util . cmd ( keyspace1 . getColumnFamilyStore ( CF_STANDARD1 ) , dk ) . build ( ) ) . unfilteredIterator ( ) ) ) ; Assert . assertTrue ( Util . equal ( upd2 , Util . getOnlyPartitionUnfiltered ( Util . cmd ( keyspace2 . getColumnFamilyStore ( CF_STANDARD3 ) , dk ) . build ( ) ) . unfilteredIterator ( ) ) ) ; } @Test public void testRecoverCounter ( ) throws IOException { CommitLog . instance . resetUnsafe ( true ) ; Keyspace keyspace1 = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace1 . getColumnFamilyStore ( CF_COUNTER1 ) ; for ( int i = <int> ; i < <int> ; + + i ) { new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , CounterContext . instance ( ) . createLocal ( <int> ) ) . build ( ) , ConsistencyLevel . ALL ) . apply ( ) ; } keyspace1 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; int replayed = CommitLog . instance . resetUnsafe ( false ) ; ColumnDefinition counterCol = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; Row row = Util . getOnlyRow ( Util . cmd ( cfs ) . includeRow ( <str> ) . columns ( <str> ) . build ( ) ) ; assertEquals ( <int> , CounterContext . instance ( ) . total ( row . getCell ( counterCol ) . value ( ) ) ) ; } @Test public void testRecoverPIT ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; CommitLog . instance . resetUnsafe ( true ) ; Date date = CommitLogArchiver . format . parse ( <str> ) ; long timeMS = date . getTime ( ) - <int> ; Keyspace keyspace1 = Keyspace . open ( KEYSPACE1 ) ; for ( int i = <int> ; i < <int> ; + + i ) { long ts = TimeUnit . MILLISECONDS . toMicros ( timeMS + ( i * <int> ) ) ; new RowUpdateBuilder ( cfs . metadata , ts , <str> + i ) . clustering ( <str> ) . add ( <str> , Integer . toString ( i ) ) . build ( ) . apply ( ) ; } assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; keyspace1 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; CommitLog . instance . resetUnsafe ( false ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; } @Test public void testRecoverPITUnordered ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; CommitLog . instance . resetUnsafe ( true ) ; Date date = CommitLogArchiver . format . parse ( <str> ) ; long timeMS = date . getTime ( ) ; Keyspace keyspace1 = Keyspace . open ( KEYSPACE1 ) ; for ( int i = <int> ; i < <int> ; + + i ) { long ts ; if ( i = = <int> ) ts = TimeUnit . MILLISECONDS . toMicros ( timeMS - <int> ) ; else ts = TimeUnit . MILLISECONDS . toMicros ( timeMS + ( i * <int> ) ) ; new RowUpdateBuilder ( cfs . metadata , ts , <str> + i ) . clustering ( <str> ) . add ( <str> , Integer . toString ( i ) ) . build ( ) . apply ( ) ; } assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; keyspace1 . getColumnFamilyStore ( <str> ) . clearUnsafe ( ) ; CommitLog . instance . resetUnsafe ( false ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; } } 
