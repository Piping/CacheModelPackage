package com . badlogic . gdx . scenes . scene2d ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . math . Affine2 ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . utils . Cullable ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . SnapshotArray ; public class Group extends Actor implements Cullable { static private final Vector2 tmp = new Vector2 ( ) ; final SnapshotArray < Actor > children = new SnapshotArray ( true , <int> , Actor . class ) ; private final Affine2 worldTransform = new Affine2 ( ) ; private final Matrix4 computedTransform = new Matrix4 ( ) ; private final Matrix4 oldTransform = new Matrix4 ( ) ; boolean transform = true ; private Rectangle cullingArea ; public void act ( float delta ) { super . act ( delta ) ; Actor [ ] actors = children . begin ( ) ; for ( int i = <int> , n = children . size ; i < n ; i + + ) actors [ i ] . act ( delta ) ; children . end ( ) ; } public void draw ( Batch batch , float parentAlpha ) { if ( transform ) applyTransform ( batch , computeTransform ( ) ) ; drawChildren ( batch , parentAlpha ) ; if ( transform ) resetTransform ( batch ) ; } protected void drawChildren ( Batch batch , float parentAlpha ) { parentAlpha * = this . color . a ; SnapshotArray < Actor > children = this . children ; Actor [ ] actors = children . begin ( ) ; Rectangle cullingArea = this . cullingArea ; if ( cullingArea ! = null ) { float cullLeft = cullingArea . x ; float cullRight = cullLeft + cullingArea . width ; float cullBottom = cullingArea . y ; float cullTop = cullBottom + cullingArea . height ; if ( transform ) { for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; float cx = child . x , cy = child . y ; if ( cx < = cullRight & & cy < = cullTop & & cx + child . width > = cullLeft & & cy + child . height > = cullBottom ) child . draw ( batch , parentAlpha ) ; } } else { float offsetX = x , offsetY = y ; x = <int> ; y = <int> ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; float cx = child . x , cy = child . y ; if ( cx < = cullRight & & cy < = cullTop & & cx + child . width > = cullLeft & & cy + child . height > = cullBottom ) { child . x = cx + offsetX ; child . y = cy + offsetY ; child . draw ( batch , parentAlpha ) ; child . x = cx ; child . y = cy ; } } x = offsetX ; y = offsetY ; } } else { if ( transform ) { for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; child . draw ( batch , parentAlpha ) ; } } else { float offsetX = x , offsetY = y ; x = <int> ; y = <int> ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; float cx = child . x , cy = child . y ; child . x = cx + offsetX ; child . y = cy + offsetY ; child . draw ( batch , parentAlpha ) ; child . x = cx ; child . y = cy ; } x = offsetX ; y = offsetY ; } } children . end ( ) ; } public void drawDebug ( ShapeRenderer shapes ) { drawDebugBounds ( shapes ) ; if ( transform ) applyTransform ( shapes , computeTransform ( ) ) ; drawDebugChildren ( shapes ) ; if ( transform ) resetTransform ( shapes ) ; } protected void drawDebugChildren ( ShapeRenderer shapes ) { SnapshotArray < Actor > children = this . children ; Actor [ ] actors = children . begin ( ) ; if ( transform ) { for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; if ( ! child . getDebug ( ) & & ! ( child instanceof Group ) ) continue ; child . drawDebug ( shapes ) ; } shapes . flush ( ) ; } else { float offsetX = x , offsetY = y ; x = <int> ; y = <int> ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; if ( ! child . isVisible ( ) ) continue ; if ( ! child . getDebug ( ) & & ! ( child instanceof Group ) ) continue ; float cx = child . x , cy = child . y ; child . x = cx + offsetX ; child . y = cy + offsetY ; child . drawDebug ( shapes ) ; child . x = cx ; child . y = cy ; } x = offsetX ; y = offsetY ; } children . end ( ) ; } protected Matrix4 computeTransform ( ) { Affine2 worldTransform = this . worldTransform ; float originX = this . originX ; float originY = this . originY ; float rotation = this . rotation ; float scaleX = this . scaleX ; float scaleY = this . scaleY ; worldTransform . setToTrnRotScl ( x + originX , y + originY , rotation , scaleX , scaleY ) ; if ( originX ! = <int> | | originY ! = <int> ) worldTransform . translate ( - originX , - originY ) ; Group parentGroup = parent ; while ( parentGroup ! = null ) { if ( parentGroup . transform ) break ; parentGroup = parentGroup . parent ; } if ( parentGroup ! = null ) worldTransform . preMul ( parentGroup . worldTransform ) ; computedTransform . set ( worldTransform ) ; return computedTransform ; } protected void applyTransform ( Batch batch , Matrix4 transform ) { oldTransform . set ( batch . getTransformMatrix ( ) ) ; batch . setTransformMatrix ( transform ) ; } protected void resetTransform ( Batch batch ) { batch . setTransformMatrix ( oldTransform ) ; } protected void applyTransform ( ShapeRenderer shapes , Matrix4 transform ) { oldTransform . set ( shapes . getTransformMatrix ( ) ) ; shapes . setTransformMatrix ( transform ) ; } protected void resetTransform ( ShapeRenderer shapes ) { shapes . setTransformMatrix ( oldTransform ) ; } public void setCullingArea ( Rectangle cullingArea ) { this . cullingArea = cullingArea ; } public Rectangle getCullingArea ( ) { return cullingArea ; } public Actor hit ( float x , float y , boolean touchable ) { if ( touchable & & getTouchable ( ) = = Touchable . disabled ) return null ; Vector2 point = tmp ; Actor [ ] childrenArray = children . items ; for ( int i = children . size - <int> ; i > = <int> ; i - - ) { Actor child = childrenArray [ i ] ; if ( ! child . isVisible ( ) ) continue ; child . parentToLocalCoordinates ( point . set ( x , y ) ) ; Actor hit = child . hit ( point . x , point . y , touchable ) ; if ( hit ! = null ) return hit ; } return super . hit ( x , y , touchable ) ; } protected void childrenChanged ( ) { } public void addActor ( Actor actor ) { if ( actor . parent ! = null ) actor . parent . removeActor ( actor , false ) ; children . add ( actor ) ; actor . setParent ( this ) ; actor . setStage ( getStage ( ) ) ; childrenChanged ( ) ; } public void addActorAt ( int index , Actor actor ) { if ( actor . parent ! = null ) actor . parent . removeActor ( actor , false ) ; if ( index > = children . size ) children . add ( actor ) ; else children . insert ( index , actor ) ; actor . setParent ( this ) ; actor . setStage ( getStage ( ) ) ; childrenChanged ( ) ; } public void addActorBefore ( Actor actorBefore , Actor actor ) { if ( actor . parent ! = null ) actor . parent . removeActor ( actor , false ) ; int index = children . indexOf ( actorBefore , true ) ; children . insert ( index , actor ) ; actor . setParent ( this ) ; actor . setStage ( getStage ( ) ) ; childrenChanged ( ) ; } public void addActorAfter ( Actor actorAfter , Actor actor ) { if ( actor . parent ! = null ) actor . parent . removeActor ( actor , false ) ; int index = children . indexOf ( actorAfter , true ) ; if ( index = = children . size ) children . add ( actor ) ; else children . insert ( index + <int> , actor ) ; actor . setParent ( this ) ; actor . setStage ( getStage ( ) ) ; childrenChanged ( ) ; } public boolean removeActor ( Actor actor ) { return removeActor ( actor , true ) ; } public boolean removeActor ( Actor actor , boolean unfocus ) { if ( ! children . removeValue ( actor , true ) ) return false ; if ( unfocus ) { Stage stage = getStage ( ) ; if ( stage ! = null ) stage . unfocus ( actor ) ; } actor . setParent ( null ) ; actor . setStage ( null ) ; childrenChanged ( ) ; return true ; } public void clearChildren ( ) { Actor [ ] actors = children . begin ( ) ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = actors [ i ] ; child . setStage ( null ) ; child . setParent ( null ) ; } children . end ( ) ; children . clear ( ) ; childrenChanged ( ) ; } public void clear ( ) { super . clear ( ) ; clearChildren ( ) ; } public < T extends Actor > T findActor ( String name ) { Array < Actor > children = this . children ; for ( int i = <int> , n = children . size ; i < n ; i + + ) if ( name . equals ( children . get ( i ) . getName ( ) ) ) return ( T ) children . get ( i ) ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = children . get ( i ) ; if ( child instanceof Group ) { Actor actor = ( ( Group ) child ) . findActor ( name ) ; if ( actor ! = null ) return ( T ) actor ; } } return null ; } protected void setStage ( Stage stage ) { super . setStage ( stage ) ; Actor [ ] childrenArray = children . items ; for ( int i = <int> , n = children . size ; i < n ; i + + ) childrenArray [ i ] . setStage ( stage ) ; } public boolean swapActor ( int first , int second ) { int maxIndex = children . size ; if ( first < <int> | | first > = maxIndex ) return false ; if ( second < <int> | | second > = maxIndex ) return false ; children . swap ( first , second ) ; return true ; } public boolean swapActor ( Actor first , Actor second ) { int firstIndex = children . indexOf ( first , true ) ; int secondIndex = children . indexOf ( second , true ) ; if ( firstIndex = = - <int> | | secondIndex = = - <int> ) return false ; children . swap ( firstIndex , secondIndex ) ; return true ; } public SnapshotArray < Actor > getChildren ( ) { return children ; } public boolean hasChildren ( ) { return children . size > <int> ; } public void setTransform ( boolean transform ) { this . transform = transform ; } public boolean isTransform ( ) { return transform ; } public Vector2 localToDescendantCoordinates ( Actor descendant , Vector2 localCoords ) { Group parent = descendant . parent ; if ( parent = = null ) throw new IllegalArgumentException ( <str> + descendant ) ; if ( parent ! = this ) localToDescendantCoordinates ( parent , localCoords ) ; descendant . parentToLocalCoordinates ( localCoords ) ; return localCoords ; } public void setDebug ( boolean enabled , boolean recursively ) { setDebug ( enabled ) ; if ( recursively ) { for ( Actor child : children ) { if ( child instanceof Group ) { ( ( Group ) child ) . setDebug ( enabled , recursively ) ; } else { child . setDebug ( enabled ) ; } } } } public Group debugAll ( ) { setDebug ( true , true ) ; return this ; } public String toString ( ) { StringBuilder buffer = new StringBuilder ( <int> ) ; toString ( buffer , <int> ) ; buffer . setLength ( buffer . length ( ) - <int> ) ; return buffer . toString ( ) ; } void toString ( StringBuilder buffer , int indent ) { buffer . append ( super . toString ( ) ) ; buffer . append ( <str> ) ; Actor [ ] actors = children . begin ( ) ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { for ( int ii = <int> ; ii < indent ; ii + + ) buffer . append ( <str> ) ; Actor actor = actors [ i ] ; if ( actor instanceof Group ) ( ( Group ) actor ) . toString ( buffer , indent + <int> ) ; else { buffer . append ( actor ) ; buffer . append ( <str> ) ; } } children . end ( ) ; } } 
