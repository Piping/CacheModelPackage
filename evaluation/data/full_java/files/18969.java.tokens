package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Before ; import org . junit . Rule ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . FromDataPoints ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . rules . ExpectedException ; import org . junit . runner . RunWith ; import static org . junit . Assert . * ; @RunWith ( Theories . class ) public abstract class AbstractDecoderTest extends AbstractCompressionTest { protected static final ByteBuf WRAPPED_BYTES_SMALL ; protected static final ByteBuf WRAPPED_BYTES_LARGE ; static { WRAPPED_BYTES_SMALL = Unpooled . wrappedBuffer ( BYTES_SMALL ) ; WRAPPED_BYTES_LARGE = Unpooled . wrappedBuffer ( BYTES_LARGE ) ; } @Rule public final ExpectedException expected = ExpectedException . none ( ) ; protected EmbeddedChannel channel ; protected static byte [ ] compressedBytesSmall ; protected static byte [ ] compressedBytesLarge ; protected AbstractDecoderTest ( ) throws Exception { compressedBytesSmall = compress ( BYTES_SMALL ) ; compressedBytesLarge = compress ( BYTES_LARGE ) ; } protected abstract byte [ ] compress ( byte [ ] data ) throws Exception ; @Before public abstract void initChannel ( ) ; @DataPoints ( <str> ) public static ByteBuf [ ] smallData ( ) { ByteBuf heap = Unpooled . wrappedBuffer ( compressedBytesSmall ) ; ByteBuf direct = Unpooled . directBuffer ( compressedBytesSmall . length ) ; direct . writeBytes ( compressedBytesSmall ) ; return new ByteBuf [ ] { heap , direct } ; } @DataPoints ( <str> ) public static ByteBuf [ ] largeData ( ) { ByteBuf heap = Unpooled . wrappedBuffer ( compressedBytesLarge ) ; ByteBuf direct = Unpooled . directBuffer ( compressedBytesLarge . length ) ; direct . writeBytes ( compressedBytesLarge ) ; return new ByteBuf [ ] { heap , direct } ; } @Theory public void testDecompressionOfSmallChunkOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testDecompression ( WRAPPED_BYTES_SMALL , data ) ; } @Theory public void testDecompressionOfLargeChunkOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testDecompression ( WRAPPED_BYTES_LARGE , data ) ; } @Theory public void testDecompressionOfBatchedFlowOfData ( @FromDataPoints ( <str> ) ByteBuf data ) throws Exception { testDecompressionOfBatchedFlow ( WRAPPED_BYTES_LARGE , data ) ; } protected void testDecompression ( final ByteBuf expected , final ByteBuf data ) throws Exception { assertTrue ( channel . writeInbound ( data ) ) ; ByteBuf decompressed = readDecompressed ( channel ) ; assertEquals ( expected , decompressed ) ; decompressed . release ( ) ; } protected void testDecompressionOfBatchedFlow ( final ByteBuf expected , final ByteBuf data ) throws Exception { final int compressedLength = data . readableBytes ( ) ; int written = <int> , length = rand . nextInt ( <int> ) ; while ( written + length < compressedLength ) { ByteBuf compressedBuf = data . slice ( written , length ) ; channel . writeInbound ( compressedBuf . retain ( ) ) ; written + = length ; length = rand . nextInt ( <int> ) ; } ByteBuf compressedBuf = data . slice ( written , compressedLength - written ) ; assertTrue ( channel . writeInbound ( compressedBuf . retain ( ) ) ) ; ByteBuf decompressedBuf = readDecompressed ( channel ) ; assertEquals ( expected , decompressedBuf ) ; decompressedBuf . release ( ) ; data . release ( ) ; } protected static ByteBuf readDecompressed ( final EmbeddedChannel channel ) { CompositeByteBuf decompressed = Unpooled . compositeBuffer ( ) ; ByteBuf msg ; while ( ( msg = channel . readInbound ( ) ) ! = null ) { decompressed . addComponent ( msg ) ; decompressed . writerIndex ( decompressed . writerIndex ( ) + msg . readableBytes ( ) ) ; } return decompressed ; } protected static void tryDecodeAndCatchBufLeaks ( final EmbeddedChannel channel , final ByteBuf data ) { try { channel . writeInbound ( data ) ; } finally { for ( ; ; ) { ByteBuf inflated = channel . readInbound ( ) ; if ( inflated = = null ) { break ; } inflated . release ( ) ; } channel . finish ( ) ; } } } 
