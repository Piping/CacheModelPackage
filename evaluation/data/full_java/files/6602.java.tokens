package org . elasticsearch . index . query ; import org . apache . lucene . search . * ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . internal . FieldNamesFieldMapper ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import java . io . IOException ; import java . util . Collection ; import java . util . Objects ; public class ExistsQueryBuilder extends AbstractQueryBuilder < ExistsQueryBuilder > { public static final String NAME = <str> ; private final String fieldName ; static final ExistsQueryBuilder PROTOTYPE = new ExistsQueryBuilder ( <str> ) ; public ExistsQueryBuilder ( String fieldName ) { if ( Strings . isEmpty ( fieldName ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldName = fieldName ; } public String fieldName ( ) { return this . fieldName ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( ExistsQueryParser . FIELD_FIELD . getPreferredName ( ) , fieldName ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { return newFilter ( context , fieldName ) ; } public static Query newFilter ( QueryShardContext context , String fieldPattern ) { final FieldNamesFieldMapper . FieldNamesFieldType fieldNamesFieldType = ( FieldNamesFieldMapper . FieldNamesFieldType ) context . getMapperService ( ) . fullName ( FieldNamesFieldMapper . NAME ) ; if ( fieldNamesFieldType = = null ) { return Queries . newMatchNoDocsQuery ( ) ; } ObjectMapper objectMapper = context . getObjectMapper ( fieldPattern ) ; if ( objectMapper ! = null ) { fieldPattern = fieldPattern + <str> ; } Collection < String > fields = context . simpleMatchToIndexNames ( fieldPattern ) ; if ( fields . isEmpty ( ) ) { return Queries . newMatchNoDocsQuery ( ) ; } BooleanQuery . Builder boolFilterBuilder = new BooleanQuery . Builder ( ) ; for ( String field : fields ) { MappedFieldType fieldType = context . fieldMapper ( field ) ; Query filter = null ; if ( fieldNamesFieldType . isEnabled ( ) ) { final String f ; if ( fieldType ! = null ) { f = fieldType . names ( ) . indexName ( ) ; } else { f = field ; } filter = fieldNamesFieldType . termQuery ( f , context ) ; } if ( filter = = null & & fieldType ! = null ) { filter = fieldType . rangeQuery ( null , null , true , true ) ; } if ( filter = = null ) { filter = new TermRangeQuery ( field , null , null , true , true ) ; } boolFilterBuilder . add ( filter , BooleanClause . Occur . SHOULD ) ; } return new ConstantScoreQuery ( boolFilterBuilder . build ( ) ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( fieldName ) ; } @Override protected boolean doEquals ( ExistsQueryBuilder other ) { return Objects . equals ( fieldName , other . fieldName ) ; } @Override protected ExistsQueryBuilder doReadFrom ( StreamInput in ) throws IOException { return new ExistsQueryBuilder ( in . readString ( ) ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
