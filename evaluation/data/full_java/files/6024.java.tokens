package org . elasticsearch . common . network ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import java . io . IOException ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . TimeUnit ; public class NetworkService extends AbstractComponent { public static final String DEFAULT_NETWORK_HOST = <str> ; private static final String GLOBAL_NETWORK_HOST_SETTING = <str> ; private static final String GLOBAL_NETWORK_BINDHOST_SETTING = <str> ; private static final String GLOBAL_NETWORK_PUBLISHHOST_SETTING = <str> ; public static final class TcpSettings { public static final String TCP_NO_DELAY = <str> ; public static final String TCP_KEEP_ALIVE = <str> ; public static final String TCP_REUSE_ADDRESS = <str> ; public static final String TCP_SEND_BUFFER_SIZE = <str> ; public static final String TCP_RECEIVE_BUFFER_SIZE = <str> ; public static final String TCP_BLOCKING = <str> ; public static final String TCP_BLOCKING_SERVER = <str> ; public static final String TCP_BLOCKING_CLIENT = <str> ; public static final String TCP_CONNECT_TIMEOUT = <str> ; public static final ByteSizeValue TCP_DEFAULT_SEND_BUFFER_SIZE = null ; public static final ByteSizeValue TCP_DEFAULT_RECEIVE_BUFFER_SIZE = null ; public static final TimeValue TCP_DEFAULT_CONNECT_TIMEOUT = new TimeValue ( <int> , TimeUnit . SECONDS ) ; } public static interface CustomNameResolver { InetAddress [ ] resolveDefault ( ) ; InetAddress [ ] resolveIfPossible ( String value ) throws IOException ; } private final List < CustomNameResolver > customNameResolvers = new CopyOnWriteArrayList < > ( ) ; public NetworkService ( Settings settings ) { super ( settings ) ; IfConfig . logIfNecessary ( ) ; } public void addCustomNameResolver ( CustomNameResolver customNameResolver ) { customNameResolvers . add ( customNameResolver ) ; } public InetAddress [ ] resolveBindHostAddresses ( String bindHosts [ ] ) throws IOException { if ( bindHosts = = null ) { bindHosts = settings . getAsArray ( GLOBAL_NETWORK_BINDHOST_SETTING , settings . getAsArray ( GLOBAL_NETWORK_HOST_SETTING , null ) ) ; } if ( bindHosts = = null ) { for ( CustomNameResolver customNameResolver : customNameResolvers ) { InetAddress addresses [ ] = customNameResolver . resolveDefault ( ) ; if ( addresses ! = null ) { return addresses ; } } } if ( bindHosts = = null ) { bindHosts = new String [ ] { DEFAULT_NETWORK_HOST } ; } InetAddress addresses [ ] = resolveInetAddresses ( bindHosts ) ; for ( InetAddress address : addresses ) { if ( address . isMulticastAddress ( ) ) { throw new IllegalArgumentException ( <str> + NetworkAddress . format ( address ) + <str> ) ; } if ( address . isAnyLocalAddress ( ) & & addresses . length > <int> ) { throw new IllegalArgumentException ( <str> + NetworkAddress . format ( address ) + <str> ) ; } } return addresses ; } public InetAddress resolvePublishHostAddresses ( String publishHosts [ ] ) throws IOException { if ( publishHosts = = null ) { publishHosts = settings . getAsArray ( GLOBAL_NETWORK_PUBLISHHOST_SETTING , settings . getAsArray ( GLOBAL_NETWORK_HOST_SETTING , null ) ) ; } if ( publishHosts = = null ) { for ( CustomNameResolver customNameResolver : customNameResolvers ) { InetAddress addresses [ ] = customNameResolver . resolveDefault ( ) ; if ( addresses ! = null ) { return addresses [ <int> ] ; } } } if ( publishHosts = = null ) { publishHosts = new String [ ] { DEFAULT_NETWORK_HOST } ; } InetAddress addresses [ ] = resolveInetAddresses ( publishHosts ) ; if ( addresses . length = = <int> & & addresses [ <int> ] . isAnyLocalAddress ( ) ) { HashSet < InetAddress > all = new HashSet < > ( Arrays . asList ( NetworkUtils . getAllAddresses ( ) ) ) ; addresses = all . toArray ( new InetAddress [ all . size ( ) ] ) ; } for ( InetAddress address : addresses ) { if ( address . isMulticastAddress ( ) ) { throw new IllegalArgumentException ( <str> + NetworkAddress . format ( address ) + <str> ) ; } if ( address . isAnyLocalAddress ( ) ) { throw new IllegalArgumentException ( <str> + NetworkAddress . format ( address ) + <str> ) ; } } if ( addresses . length > <int> ) { List < InetAddress > sorted = new ArrayList < > ( Arrays . asList ( addresses ) ) ; NetworkUtils . sortAddresses ( sorted ) ; addresses = new InetAddress [ ] { sorted . get ( <int> ) } ; } return addresses [ <int> ] ; } private InetAddress [ ] resolveInetAddresses ( String hosts [ ] ) throws IOException { if ( hosts . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } HashSet < InetAddress > set = new HashSet < > ( ) ; for ( String host : hosts ) { set . addAll ( Arrays . asList ( resolveInternal ( host ) ) ) ; } return set . toArray ( new InetAddress [ set . size ( ) ] ) ; } private InetAddress [ ] resolveInternal ( String host ) throws IOException { if ( ( host . startsWith ( <str> ) & & host . endsWith ( <str> ) ) | | ( host . startsWith ( <str> ) & & host . endsWith ( <str> ) ) ) { host = host . substring ( <int> , host . length ( ) - <int> ) ; for ( CustomNameResolver customNameResolver : customNameResolvers ) { InetAddress addresses [ ] = customNameResolver . resolveIfPossible ( host ) ; if ( addresses ! = null ) { return addresses ; } } switch ( host ) { case <str> : return NetworkUtils . getLoopbackAddresses ( ) ; case <str> : return NetworkUtils . filterIPV4 ( NetworkUtils . getLoopbackAddresses ( ) ) ; case <str> : return NetworkUtils . filterIPV6 ( NetworkUtils . getLoopbackAddresses ( ) ) ; case <str> : return NetworkUtils . getSiteLocalAddresses ( ) ; case <str> : return NetworkUtils . filterIPV4 ( NetworkUtils . getSiteLocalAddresses ( ) ) ; case <str> : return NetworkUtils . filterIPV6 ( NetworkUtils . getSiteLocalAddresses ( ) ) ; case <str> : return NetworkUtils . getGlobalAddresses ( ) ; case <str> : return NetworkUtils . filterIPV4 ( NetworkUtils . getGlobalAddresses ( ) ) ; case <str> : return NetworkUtils . filterIPV6 ( NetworkUtils . getGlobalAddresses ( ) ) ; default : if ( host . endsWith ( <str> ) ) { host = host . substring ( <int> , host . length ( ) - <int> ) ; return NetworkUtils . filterIPV4 ( NetworkUtils . getAddressesForInterface ( host ) ) ; } else if ( host . endsWith ( <str> ) ) { host = host . substring ( <int> , host . length ( ) - <int> ) ; return NetworkUtils . filterIPV6 ( NetworkUtils . getAddressesForInterface ( host ) ) ; } else { return NetworkUtils . getAddressesForInterface ( host ) ; } } } return InetAddress . getAllByName ( host ) ; } } 
