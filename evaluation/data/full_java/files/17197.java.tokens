package org . jbox2d . dynamics . contacts ; import org . jbox2d . callbacks . ContactListener ; import org . jbox2d . collision . ContactID ; import org . jbox2d . collision . Manifold ; import org . jbox2d . collision . ManifoldPoint ; import org . jbox2d . collision . WorldManifold ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Transform ; import org . jbox2d . dynamics . Body ; import org . jbox2d . dynamics . Fixture ; import org . jbox2d . pooling . IWorldPool ; public abstract class Contact { public static final int ISLAND_FLAG = <hex> ; public static final int TOUCHING_FLAG = <hex> ; public static final int ENABLED_FLAG = <hex> ; public static final int FILTER_FLAG = <hex> ; public static final int BULLET_HIT_FLAG = <hex> ; public static final int TOI_FLAG = <hex> ; public int m_flags ; public Contact m_prev ; public Contact m_next ; public ContactEdge m_nodeA = null ; public ContactEdge m_nodeB = null ; public Fixture m_fixtureA ; public Fixture m_fixtureB ; public int m_indexA ; public int m_indexB ; public final Manifold m_manifold ; public float m_toiCount ; public float m_toi ; public float m_friction ; public float m_restitution ; public float m_tangentSpeed ; protected final IWorldPool pool ; protected Contact ( IWorldPool argPool ) { m_fixtureA = null ; m_fixtureB = null ; m_nodeA = new ContactEdge ( ) ; m_nodeB = new ContactEdge ( ) ; m_manifold = new Manifold ( ) ; pool = argPool ; } public void init ( Fixture fA , int indexA , Fixture fB , int indexB ) { m_flags = ENABLED_FLAG ; m_fixtureA = fA ; m_fixtureB = fB ; m_indexA = indexA ; m_indexB = indexB ; m_manifold . pointCount = <int> ; m_prev = null ; m_next = null ; m_nodeA . contact = null ; m_nodeA . prev = null ; m_nodeA . next = null ; m_nodeA . other = null ; m_nodeB . contact = null ; m_nodeB . prev = null ; m_nodeB . next = null ; m_nodeB . other = null ; m_toiCount = <int> ; m_friction = Contact . mixFriction ( fA . m_friction , fB . m_friction ) ; m_restitution = Contact . mixRestitution ( fA . m_restitution , fB . m_restitution ) ; m_tangentSpeed = <int> ; } public Manifold getManifold ( ) { return m_manifold ; } public void getWorldManifold ( WorldManifold worldManifold ) { final Body bodyA = m_fixtureA . getBody ( ) ; final Body bodyB = m_fixtureB . getBody ( ) ; final Shape shapeA = m_fixtureA . getShape ( ) ; final Shape shapeB = m_fixtureB . getShape ( ) ; worldManifold . initialize ( m_manifold , bodyA . getTransform ( ) , shapeA . m_radius , bodyB . getTransform ( ) , shapeB . m_radius ) ; } public boolean isTouching ( ) { return ( m_flags & TOUCHING_FLAG ) = = TOUCHING_FLAG ; } public void setEnabled ( boolean flag ) { if ( flag ) { m_flags | = ENABLED_FLAG ; } else { m_flags & = ~ ENABLED_FLAG ; } } public boolean isEnabled ( ) { return ( m_flags & ENABLED_FLAG ) = = ENABLED_FLAG ; } public Contact getNext ( ) { return m_next ; } public Fixture getFixtureA ( ) { return m_fixtureA ; } public int getChildIndexA ( ) { return m_indexA ; } public Fixture getFixtureB ( ) { return m_fixtureB ; } public int getChildIndexB ( ) { return m_indexB ; } public void setFriction ( float friction ) { m_friction = friction ; } public float getFriction ( ) { return m_friction ; } public void resetFriction ( ) { m_friction = Contact . mixFriction ( m_fixtureA . m_friction , m_fixtureB . m_friction ) ; } public void setRestitution ( float restitution ) { m_restitution = restitution ; } public float getRestitution ( ) { return m_restitution ; } public void resetRestitution ( ) { m_restitution = Contact . mixRestitution ( m_fixtureA . m_restitution , m_fixtureB . m_restitution ) ; } public void setTangentSpeed ( float speed ) { m_tangentSpeed = speed ; } public float getTangentSpeed ( ) { return m_tangentSpeed ; } public abstract void evaluate ( Manifold manifold , Transform xfA , Transform xfB ) ; public void flagForFiltering ( ) { m_flags | = FILTER_FLAG ; } private final Manifold oldManifold = new Manifold ( ) ; public void update ( ContactListener listener ) { oldManifold . set ( m_manifold ) ; m_flags | = ENABLED_FLAG ; boolean touching = false ; boolean wasTouching = ( m_flags & TOUCHING_FLAG ) = = TOUCHING_FLAG ; boolean sensorA = m_fixtureA . isSensor ( ) ; boolean sensorB = m_fixtureB . isSensor ( ) ; boolean sensor = sensorA | | sensorB ; Body bodyA = m_fixtureA . getBody ( ) ; Body bodyB = m_fixtureB . getBody ( ) ; Transform xfA = bodyA . getTransform ( ) ; Transform xfB = bodyB . getTransform ( ) ; if ( sensor ) { Shape shapeA = m_fixtureA . getShape ( ) ; Shape shapeB = m_fixtureB . getShape ( ) ; touching = pool . getCollision ( ) . testOverlap ( shapeA , m_indexA , shapeB , m_indexB , xfA , xfB ) ; m_manifold . pointCount = <int> ; } else { evaluate ( m_manifold , xfA , xfB ) ; touching = m_manifold . pointCount > <int> ; for ( int i = <int> ; i < m_manifold . pointCount ; + + i ) { ManifoldPoint mp2 = m_manifold . points [ i ] ; mp2 . normalImpulse = <float> ; mp2 . tangentImpulse = <float> ; ContactID id2 = mp2 . id ; for ( int j = <int> ; j < oldManifold . pointCount ; + + j ) { ManifoldPoint mp1 = oldManifold . points [ j ] ; if ( mp1 . id . isEqual ( id2 ) ) { mp2 . normalImpulse = mp1 . normalImpulse ; mp2 . tangentImpulse = mp1 . tangentImpulse ; break ; } } } if ( touching ! = wasTouching ) { bodyA . setAwake ( true ) ; bodyB . setAwake ( true ) ; } } if ( touching ) { m_flags | = TOUCHING_FLAG ; } else { m_flags & = ~ TOUCHING_FLAG ; } if ( listener = = null ) { return ; } if ( wasTouching = = false & & touching = = true ) { listener . beginContact ( this ) ; } if ( wasTouching = = true & & touching = = false ) { listener . endContact ( this ) ; } if ( sensor = = false & & touching ) { listener . preSolve ( this , oldManifold ) ; } } public static final float mixFriction ( float friction1 , float friction2 ) { return MathUtils . sqrt ( friction1 * friction2 ) ; } public static final float mixRestitution ( float restitution1 , float restitution2 ) { return restitution1 > restitution2 ? restitution1 : restitution2 ; } } 
