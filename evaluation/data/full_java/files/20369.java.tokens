package io . netty . channel . epoll ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . SingleThreadEventLoop ; import io . netty . channel . epoll . AbstractEpollChannel . AbstractEpollUnsafe ; import io . netty . channel . unix . FileDescriptor ; import io . netty . util . collection . IntObjectHashMap ; import io . netty . util . collection . IntObjectMap ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Queue ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; final class EpollEventLoop extends SingleThreadEventLoop { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( EpollEventLoop . class ) ; private static final AtomicIntegerFieldUpdater < EpollEventLoop > WAKEN_UP_UPDATER ; static { AtomicIntegerFieldUpdater < EpollEventLoop > updater = PlatformDependent . newAtomicIntegerFieldUpdater ( EpollEventLoop . class , <str> ) ; if ( updater = = null ) { updater = AtomicIntegerFieldUpdater . newUpdater ( EpollEventLoop . class , <str> ) ; } WAKEN_UP_UPDATER = updater ; } private final FileDescriptor epollFd ; private final FileDescriptor eventFd ; private final IntObjectMap < AbstractEpollChannel > channels = new IntObjectHashMap < AbstractEpollChannel > ( <int> ) ; private final boolean allowGrowing ; private final EpollEventArray events ; private final IovArray iovArray = new IovArray ( ) ; private volatile int wakenUp ; private volatile int ioRatio = <int> ; EpollEventLoop ( EventLoopGroup parent , Executor executor , int maxEvents ) { super ( parent , executor , false ) ; if ( maxEvents = = <int> ) { allowGrowing = true ; events = new EpollEventArray ( <int> ) ; } else { allowGrowing = false ; events = new EpollEventArray ( maxEvents ) ; } boolean success = false ; FileDescriptor epollFd = null ; FileDescriptor eventFd = null ; try { this . epollFd = epollFd = Native . newEpollCreate ( ) ; this . eventFd = eventFd = Native . newEventFd ( ) ; try { Native . epollCtlAdd ( epollFd . intValue ( ) , eventFd . intValue ( ) , Native . EPOLLIN ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } success = true ; } finally { if ( ! success ) { if ( epollFd ! = null ) { try { epollFd . close ( ) ; } catch ( Exception e ) { } } if ( eventFd ! = null ) { try { eventFd . close ( ) ; } catch ( Exception e ) { } } } } } IovArray cleanArray ( ) { iovArray . clear ( ) ; return iovArray ; } @Override protected void wakeup ( boolean inEventLoop ) { if ( ! inEventLoop & & WAKEN_UP_UPDATER . compareAndSet ( this , <int> , <int> ) ) { Native . eventFdWrite ( eventFd . intValue ( ) , <int> ) ; } } void add ( AbstractEpollChannel ch ) throws IOException { assert inEventLoop ( ) ; int fd = ch . fd ( ) . intValue ( ) ; Native . epollCtlAdd ( epollFd . intValue ( ) , fd , ch . flags ) ; channels . put ( fd , ch ) ; } void modify ( AbstractEpollChannel ch ) throws IOException { assert inEventLoop ( ) ; Native . epollCtlMod ( epollFd . intValue ( ) , ch . fd ( ) . intValue ( ) , ch . flags ) ; } void remove ( AbstractEpollChannel ch ) throws IOException { assert inEventLoop ( ) ; if ( ch . isOpen ( ) ) { int fd = ch . fd ( ) . intValue ( ) ; if ( channels . remove ( fd ) ! = null ) { Native . epollCtlDel ( epollFd . intValue ( ) , ch . fd ( ) . intValue ( ) ) ; } } } @Override protected Queue < Runnable > newTaskQueue ( ) { return PlatformDependent . newMpscQueue ( ) ; } public int getIoRatio ( ) { return ioRatio ; } public void setIoRatio ( int ioRatio ) { if ( ioRatio < = <int> | | ioRatio > <int> ) { throw new IllegalArgumentException ( <str> + ioRatio + <str> ) ; } this . ioRatio = ioRatio ; } private int epollWait ( boolean oldWakenUp ) throws IOException { int selectCnt = <int> ; long currentTimeNanos = System . nanoTime ( ) ; long selectDeadLineNanos = currentTimeNanos + delayNanos ( currentTimeNanos ) ; for ( ; ; ) { long timeoutMillis = ( selectDeadLineNanos - currentTimeNanos + <int> ) / <int> ; if ( timeoutMillis < = <int> ) { if ( selectCnt = = <int> ) { int ready = Native . epollWait ( epollFd . intValue ( ) , events , <int> ) ; if ( ready > <int> ) { return ready ; } } break ; } int selectedKeys = Native . epollWait ( epollFd . intValue ( ) , events , ( int ) timeoutMillis ) ; selectCnt + + ; if ( selectedKeys ! = <int> | | oldWakenUp | | wakenUp = = <int> | | hasTasks ( ) | | hasScheduledTasks ( ) ) { return selectedKeys ; } currentTimeNanos = System . nanoTime ( ) ; } return <int> ; } @Override protected void run ( ) { for ( ; ; ) { boolean oldWakenUp = WAKEN_UP_UPDATER . getAndSet ( this , <int> ) = = <int> ; try { int ready ; if ( hasTasks ( ) ) { ready = Native . epollWait ( epollFd . intValue ( ) , events , <int> ) ; } else { ready = epollWait ( oldWakenUp ) ; if ( wakenUp = = <int> ) { Native . eventFdWrite ( eventFd . intValue ( ) , <int> ) ; } } final int ioRatio = this . ioRatio ; if ( ioRatio = = <int> ) { if ( ready > <int> ) { processReady ( events , ready ) ; } runAllTasks ( ) ; } else { final long ioStartTime = System . nanoTime ( ) ; if ( ready > <int> ) { processReady ( events , ready ) ; } final long ioTime = System . nanoTime ( ) - ioStartTime ; runAllTasks ( ioTime * ( <int> - ioRatio ) / ioRatio ) ; } if ( allowGrowing & & ready = = events . length ( ) ) { events . increase ( ) ; } if ( isShuttingDown ( ) ) { closeAll ( ) ; if ( confirmShutdown ( ) ) { break ; } } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } } private void closeAll ( ) { try { Native . epollWait ( epollFd . intValue ( ) , events , <int> ) ; } catch ( IOException ignore ) { } Collection < AbstractEpollChannel > array = new ArrayList < AbstractEpollChannel > ( channels . size ( ) ) ; for ( AbstractEpollChannel channel : channels . values ( ) ) { array . add ( channel ) ; } for ( AbstractEpollChannel ch : array ) { ch . unsafe ( ) . close ( ch . unsafe ( ) . voidPromise ( ) ) ; } } private void processReady ( EpollEventArray events , int ready ) { for ( int i = <int> ; i < ready ; i + + ) { final int fd = events . fd ( i ) ; if ( fd = = eventFd . intValue ( ) ) { Native . eventFdRead ( eventFd . intValue ( ) ) ; } else { final long ev = events . events ( i ) ; AbstractEpollChannel ch = channels . get ( fd ) ; if ( ch ! = null ) { AbstractEpollUnsafe unsafe = ( AbstractEpollUnsafe ) ch . unsafe ( ) ; if ( ( ev & ( Native . EPOLLERR | Native . EPOLLOUT ) ) ! = <int> ) { unsafe . epollOutReady ( ) ; } if ( ( ev & ( Native . EPOLLERR | Native . EPOLLIN ) ) ! = <int> ) { unsafe . epollInReady ( ) ; } if ( ( ev & Native . EPOLLRDHUP ) ! = <int> ) { unsafe . epollRdHupReady ( ) ; } } else { try { Native . epollCtlDel ( epollFd . intValue ( ) , fd ) ; } catch ( IOException ignore ) { } } } } } @Override protected void cleanup ( ) { try { try { epollFd . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } try { eventFd . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } finally { iovArray . release ( ) ; events . free ( ) ; } } } 
