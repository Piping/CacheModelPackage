package org . apache . cassandra . cql3 ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CyclicBarrier ; import org . junit . After ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import com . datastax . driver . core . Row ; import com . datastax . driver . core . exceptions . NoHostAvailableException ; import com . datastax . driver . core . exceptions . WriteTimeoutException ; import org . apache . cassandra . concurrent . SEPExecutor ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . batchlog . BatchlogManager ; import org . apache . cassandra . utils . WrappedRunnable ; public class ViewLongTest extends CQLTester { int protocolVersion = <int> ; private final List < String > views = new ArrayList < > ( ) ; @BeforeClass public static void startup ( ) { requireNetwork ( ) ; } @Before public void begin ( ) { views . clear ( ) ; } @After public void end ( ) throws Throwable { for ( String viewName : views ) executeNet ( protocolVersion , <str> + viewName ) ; } private void createView ( String name , String query ) throws Throwable { executeNet ( protocolVersion , String . format ( query , name ) ) ; views . add ( name ) ; } @Test public void testConflictResolution ( ) throws Throwable { final int writers = <int> ; final int insertsPerWriter = <int> ; final Map < Integer , Exception > failedWrites = new ConcurrentHashMap < > ( ) ; createTable ( <str> + <str> + <str> + <str> + <str> ) ; executeNet ( protocolVersion , <str> + keyspace ( ) ) ; createView ( <str> , <str> ) ; CyclicBarrier semaphore = new CyclicBarrier ( writers ) ; Thread [ ] threads = new Thread [ writers ] ; for ( int i = <int> ; i < writers ; i + + ) { final int writer = i ; Thread t = new Thread ( new WrappedRunnable ( ) { public void runMayThrow ( ) { try { int writerOffset = writer * insertsPerWriter ; semaphore . await ( ) ; for ( int i = <int> ; i < insertsPerWriter ; i + + ) { try { executeNet ( protocolVersion , <str> , <int> , <int> , i + writerOffset ) ; } catch ( NoHostAvailableException | WriteTimeoutException e ) { failedWrites . put ( i + writerOffset , e ) ; } } } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } } ) ; t . start ( ) ; threads [ i ] = t ; } for ( int i = <int> ; i < writers ; i + + ) threads [ i ] . join ( ) ; for ( int i = <int> ; i < writers * insertsPerWriter ; i + + ) { if ( executeNet ( protocolVersion , <str> ) . one ( ) . getLong ( <int> ) = = <int> ) break ; try { BatchlogManager . instance . startBatchlogReplay ( ) . get ( ) ; } catch ( Throwable ignore ) { } } int value = executeNet ( protocolVersion , <str> ) . one ( ) . getInt ( <str> ) ; List < Row > rows = executeNet ( protocolVersion , <str> + keyspace ( ) + <str> ) . all ( ) ; boolean containsC = false ; StringBuilder others = new StringBuilder ( ) ; StringBuilder overlappingFailedWrites = new StringBuilder ( ) ; for ( Row row : rows ) { int c = row . getInt ( <str> ) ; if ( c = = value ) containsC = true ; else { if ( others . length ( ) ! = <int> ) others . append ( <str> ) ; others . append ( c ) ; if ( failedWrites . containsKey ( c ) ) { if ( overlappingFailedWrites . length ( ) ! = <int> ) overlappingFailedWrites . append ( <str> ) ; overlappingFailedWrites . append ( c ) . append ( <str> ) . append ( failedWrites . get ( c ) . getMessage ( ) ) ; } } } if ( rows . size ( ) > <int> ) { throw new AssertionError ( String . format ( <str> , rows . size ( ) , containsC ? <str> : <str> , value , others , overlappingFailedWrites ) ) ; } else if ( rows . isEmpty ( ) ) { throw new AssertionError ( String . format ( <str> , value ) ) ; } else if ( rows . size ( ) = = <int> & & ! containsC ) { throw new AssertionError ( String . format ( <str> , rows . get ( <int> ) . getInt ( <str> ) , value ) ) ; } } } 
