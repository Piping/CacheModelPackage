package org . elasticsearch . search . fetch . innerhits ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . index . query . ParsedQuery ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . fetch . fielddata . FieldDataFieldsParseElement ; import org . elasticsearch . search . fetch . script . ScriptFieldsParseElement ; import org . elasticsearch . search . fetch . source . FetchSourceParseElement ; import org . elasticsearch . search . highlight . HighlighterParseElement ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . internal . SubSearchContext ; import org . elasticsearch . search . sort . SortParseElement ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . index . query . support . InnerHitsQueryParserHelper . parseCommonInnerHitOptions ; public class InnerHitsParseElement implements SearchParseElement { private final SortParseElement sortParseElement ; private final FetchSourceParseElement sourceParseElement ; private final HighlighterParseElement highlighterParseElement ; private final FieldDataFieldsParseElement fieldDataFieldsParseElement ; private final ScriptFieldsParseElement scriptFieldsParseElement ; public InnerHitsParseElement ( SortParseElement sortParseElement , FetchSourceParseElement sourceParseElement , HighlighterParseElement highlighterParseElement , FieldDataFieldsParseElement fieldDataFieldsParseElement , ScriptFieldsParseElement scriptFieldsParseElement ) { this . sortParseElement = sortParseElement ; this . sourceParseElement = sourceParseElement ; this . highlighterParseElement = highlighterParseElement ; this . fieldDataFieldsParseElement = fieldDataFieldsParseElement ; this . scriptFieldsParseElement = scriptFieldsParseElement ; } @Override public void parse ( XContentParser parser , SearchContext searchContext ) throws Exception { QueryShardContext context = searchContext . indexShard ( ) . getQueryShardContext ( ) ; context . reset ( parser ) ; Map < String , InnerHitsContext . BaseInnerHits > innerHitsMap = parseInnerHits ( parser , context , searchContext ) ; if ( innerHitsMap ! = null ) { searchContext . innerHits ( new InnerHitsContext ( innerHitsMap ) ) ; } } private Map < String , InnerHitsContext . BaseInnerHits > parseInnerHits ( XContentParser parser , QueryShardContext context , SearchContext searchContext ) throws Exception { XContentParser . Token token ; Map < String , InnerHitsContext . BaseInnerHits > innerHitsMap = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new IllegalArgumentException ( <str> + token + <str> ) ; } final String innerHitName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new IllegalArgumentException ( <str> + innerHitName + <str> + token + <str> + XContentParser . Token . START_OBJECT + <str> ) ; } InnerHitsContext . BaseInnerHits innerHits = parseInnerHit ( parser , context , searchContext , innerHitName ) ; if ( innerHitsMap = = null ) { innerHitsMap = new HashMap < > ( ) ; } innerHitsMap . put ( innerHitName , innerHits ) ; } return innerHitsMap ; } private InnerHitsContext . BaseInnerHits parseInnerHit ( XContentParser parser , QueryShardContext context , SearchContext searchContext , String innerHitName ) throws Exception { XContentParser . Token token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new IllegalArgumentException ( <str> + token + <str> ) ; } String fieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new IllegalArgumentException ( <str> + innerHitName + <str> + token + <str> + XContentParser . Token . START_OBJECT + <str> ) ; } String nestedPath = null ; String type = null ; switch ( fieldName ) { case <str> : nestedPath = parser . currentName ( ) ; break ; case <str> : type = parser . currentName ( ) ; break ; default : throw new IllegalArgumentException ( <str> ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new IllegalArgumentException ( <str> + token + <str> ) ; } fieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new IllegalArgumentException ( <str> + innerHitName + <str> + token + <str> + XContentParser . Token . START_OBJECT + <str> ) ; } final InnerHitsContext . BaseInnerHits innerHits ; if ( nestedPath ! = null ) { innerHits = parseNested ( parser , context , searchContext , fieldName ) ; } else if ( type ! = null ) { innerHits = parseParentChild ( parser , context , searchContext , fieldName ) ; } else { throw new IllegalArgumentException ( <str> ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . END_OBJECT ) { throw new IllegalArgumentException ( <str> + XContentParser . Token . END_OBJECT + <str> + token + <str> ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . END_OBJECT ) { throw new IllegalArgumentException ( <str> + XContentParser . Token . END_OBJECT + <str> + token + <str> ) ; } return innerHits ; } private InnerHitsContext . ParentChildInnerHits parseParentChild ( XContentParser parser , QueryShardContext context , SearchContext searchContext , String type ) throws Exception { ParseResult parseResult = parseSubSearchContext ( searchContext , context , parser ) ; DocumentMapper documentMapper = searchContext . mapperService ( ) . documentMapper ( type ) ; if ( documentMapper = = null ) { throw new IllegalArgumentException ( <str> + type + <str> ) ; } return new InnerHitsContext . ParentChildInnerHits ( parseResult . context ( ) , parseResult . query ( ) , parseResult . childInnerHits ( ) , context . getMapperService ( ) , documentMapper ) ; } private InnerHitsContext . NestedInnerHits parseNested ( XContentParser parser , QueryShardContext context , SearchContext searchContext , String nestedPath ) throws Exception { ObjectMapper objectMapper = searchContext . getObjectMapper ( nestedPath ) ; if ( objectMapper = = null ) { throw new IllegalArgumentException ( <str> + nestedPath + <str> ) ; } if ( objectMapper . nested ( ) . isNested ( ) = = false ) { throw new IllegalArgumentException ( <str> + nestedPath + <str> ) ; } ObjectMapper parentObjectMapper = context . nestedScope ( ) . nextLevel ( objectMapper ) ; ParseResult parseResult = parseSubSearchContext ( searchContext , context , parser ) ; context . nestedScope ( ) . previousLevel ( ) ; return new InnerHitsContext . NestedInnerHits ( parseResult . context ( ) , parseResult . query ( ) , parseResult . childInnerHits ( ) , parentObjectMapper , objectMapper ) ; } private ParseResult parseSubSearchContext ( SearchContext searchContext , QueryShardContext context , XContentParser parser ) throws Exception { ParsedQuery query = null ; Map < String , InnerHitsContext . BaseInnerHits > childInnerHits = null ; SubSearchContext subSearchContext = new SubSearchContext ( searchContext ) ; String fieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( fieldName ) ) { Query q = context . parseInnerQuery ( ) ; query = new ParsedQuery ( q , context . copyNamedQueries ( ) ) ; } else if ( <str> . equals ( fieldName ) ) { childInnerHits = parseInnerHits ( parser , context , searchContext ) ; } else { parseCommonInnerHitOptions ( parser , token , fieldName , subSearchContext , sortParseElement , sourceParseElement , highlighterParseElement , scriptFieldsParseElement , fieldDataFieldsParseElement ) ; } } else { parseCommonInnerHitOptions ( parser , token , fieldName , subSearchContext , sortParseElement , sourceParseElement , highlighterParseElement , scriptFieldsParseElement , fieldDataFieldsParseElement ) ; } } if ( query = = null ) { query = ParsedQuery . parsedMatchAllQuery ( ) ; } return new ParseResult ( subSearchContext , query , childInnerHits ) ; } private static final class ParseResult { private final SubSearchContext context ; private final ParsedQuery query ; private final Map < String , InnerHitsContext . BaseInnerHits > childInnerHits ; private ParseResult ( SubSearchContext context , ParsedQuery query , Map < String , InnerHitsContext . BaseInnerHits > childInnerHits ) { this . context = context ; this . query = query ; this . childInnerHits = childInnerHits ; } public SubSearchContext context ( ) { return context ; } public ParsedQuery query ( ) { return query ; } public Map < String , InnerHitsContext . BaseInnerHits > childInnerHits ( ) { return childInnerHits ; } } } 
