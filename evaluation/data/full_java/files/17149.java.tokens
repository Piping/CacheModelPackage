package org . jbox2d . collision ; import org . jbox2d . collision . Distance . DistanceProxy ; import org . jbox2d . collision . Distance . SimplexCache ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Sweep ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . pooling . IWorldPool ; public class TimeOfImpact { public static final int MAX_ITERATIONS = <int> ; public static int toiCalls = <int> ; public static int toiIters = <int> ; public static int toiMaxIters = <int> ; public static int toiRootIters = <int> ; public static int toiMaxRootIters = <int> ; public static class TOIInput { public final DistanceProxy proxyA = new DistanceProxy ( ) ; public final DistanceProxy proxyB = new DistanceProxy ( ) ; public final Sweep sweepA = new Sweep ( ) ; public final Sweep sweepB = new Sweep ( ) ; public float tMax ; } public static enum TOIOutputState { UNKNOWN , FAILED , OVERLAPPED , TOUCHING , SEPARATED } public static class TOIOutput { public TOIOutputState state ; public float t ; } private final SimplexCache cache = new SimplexCache ( ) ; private final DistanceInput distanceInput = new DistanceInput ( ) ; private final Transform xfA = new Transform ( ) ; private final Transform xfB = new Transform ( ) ; private final DistanceOutput distanceOutput = new DistanceOutput ( ) ; private final SeparationFunction fcn = new SeparationFunction ( ) ; private final int [ ] indexes = new int [ <int> ] ; private final Sweep sweepA = new Sweep ( ) ; private final Sweep sweepB = new Sweep ( ) ; private final IWorldPool pool ; public TimeOfImpact ( IWorldPool argPool ) { pool = argPool ; } public final void timeOfImpact ( TOIOutput output , TOIInput input ) { + + toiCalls ; output . state = TOIOutputState . UNKNOWN ; output . t = input . tMax ; final DistanceProxy proxyA = input . proxyA ; final DistanceProxy proxyB = input . proxyB ; sweepA . set ( input . sweepA ) ; sweepB . set ( input . sweepB ) ; sweepA . normalize ( ) ; sweepB . normalize ( ) ; float tMax = input . tMax ; float totalRadius = proxyA . m_radius + proxyB . m_radius ; float target = MathUtils . max ( Settings . linearSlop , totalRadius - <float> * Settings . linearSlop ) ; float tolerance = <float> * Settings . linearSlop ; assert ( target > tolerance ) ; float t1 = <float> ; int iter = <int> ; cache . count = <int> ; distanceInput . proxyA = input . proxyA ; distanceInput . proxyB = input . proxyB ; distanceInput . useRadii = false ; for ( ; ; ) { sweepA . getTransform ( xfA , t1 ) ; sweepB . getTransform ( xfB , t1 ) ; distanceInput . transformA = xfA ; distanceInput . transformB = xfB ; pool . getDistance ( ) . distance ( distanceOutput , cache , distanceInput ) ; if ( distanceOutput . distance < = <float> ) { output . state = TOIOutputState . OVERLAPPED ; output . t = <float> ; break ; } if ( distanceOutput . distance < target + tolerance ) { output . state = TOIOutputState . TOUCHING ; output . t = t1 ; break ; } fcn . initialize ( cache , proxyA , sweepA , proxyB , sweepB , t1 ) ; boolean done = false ; float t2 = tMax ; int pushBackIter = <int> ; for ( ; ; ) { float s2 = fcn . findMinSeparation ( indexes , t2 ) ; if ( s2 > target + tolerance ) { output . state = TOIOutputState . SEPARATED ; output . t = tMax ; done = true ; break ; } if ( s2 > target - tolerance ) { t1 = t2 ; break ; } float s1 = fcn . evaluate ( indexes [ <int> ] , indexes [ <int> ] , t1 ) ; if ( s1 < target - tolerance ) { output . state = TOIOutputState . FAILED ; output . t = t1 ; done = true ; break ; } if ( s1 < = target + tolerance ) { output . state = TOIOutputState . TOUCHING ; output . t = t1 ; done = true ; break ; } int rootIterCount = <int> ; float a1 = t1 , a2 = t2 ; for ( ; ; ) { float t ; if ( ( rootIterCount & <int> ) = = <int> ) { t = a1 + ( target - s1 ) * ( a2 - a1 ) / ( s2 - s1 ) ; } else { t = <float> * ( a1 + a2 ) ; } float s = fcn . evaluate ( indexes [ <int> ] , indexes [ <int> ] , t ) ; if ( MathUtils . abs ( s - target ) < tolerance ) { t2 = t ; break ; } if ( s > target ) { a1 = t ; s1 = s ; } else { a2 = t ; s2 = s ; } + + rootIterCount ; + + toiRootIters ; if ( rootIterCount = = <int> ) { break ; } } toiMaxRootIters = MathUtils . max ( toiMaxRootIters , rootIterCount ) ; + + pushBackIter ; if ( pushBackIter = = Settings . maxPolygonVertices ) { break ; } } + + iter ; + + toiIters ; if ( done ) { break ; } if ( iter = = MAX_ITERATIONS ) { output . state = TOIOutputState . FAILED ; output . t = t1 ; break ; } } toiMaxIters = MathUtils . max ( toiMaxIters , iter ) ; } } enum Type { POINTS , FACE_A , FACE_B ; } class SeparationFunction { public DistanceProxy m_proxyA ; public DistanceProxy m_proxyB ; public Type m_type ; public final Vec2 m_localPoint = new Vec2 ( ) ; public final Vec2 m_axis = new Vec2 ( ) ; public Sweep m_sweepA ; public Sweep m_sweepB ; private final Vec2 localPointA = new Vec2 ( ) ; private final Vec2 localPointB = new Vec2 ( ) ; private final Vec2 pointA = new Vec2 ( ) ; private final Vec2 pointB = new Vec2 ( ) ; private final Vec2 localPointA1 = new Vec2 ( ) ; private final Vec2 localPointA2 = new Vec2 ( ) ; private final Vec2 normal = new Vec2 ( ) ; private final Vec2 localPointB1 = new Vec2 ( ) ; private final Vec2 localPointB2 = new Vec2 ( ) ; private final Vec2 temp = new Vec2 ( ) ; private final Transform xfa = new Transform ( ) ; private final Transform xfb = new Transform ( ) ; public float initialize ( final SimplexCache cache , final DistanceProxy proxyA , final Sweep sweepA , final DistanceProxy proxyB , final Sweep sweepB , float t1 ) { m_proxyA = proxyA ; m_proxyB = proxyB ; int count = cache . count ; assert ( <int> < count & & count < <int> ) ; m_sweepA = sweepA ; m_sweepB = sweepB ; m_sweepA . getTransform ( xfa , t1 ) ; m_sweepB . getTransform ( xfb , t1 ) ; if ( count = = <int> ) { m_type = Type . POINTS ; localPointA . set ( m_proxyA . getVertex ( cache . indexA [ <int> ] ) ) ; localPointB . set ( m_proxyB . getVertex ( cache . indexB [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; m_axis . set ( pointB ) . subLocal ( pointA ) ; float s = m_axis . normalize ( ) ; return s ; } else if ( cache . indexA [ <int> ] = = cache . indexA [ <int> ] ) { m_type = Type . FACE_B ; localPointB1 . set ( m_proxyB . getVertex ( cache . indexB [ <int> ] ) ) ; localPointB2 . set ( m_proxyB . getVertex ( cache . indexB [ <int> ] ) ) ; temp . set ( localPointB2 ) . subLocal ( localPointB1 ) ; Vec2 . crossToOutUnsafe ( temp , <float> , m_axis ) ; m_axis . normalize ( ) ; Rot . mulToOutUnsafe ( xfb . q , m_axis , normal ) ; m_localPoint . set ( localPointB1 ) . addLocal ( localPointB2 ) . mulLocal ( <float> ) ; Transform . mulToOutUnsafe ( xfb , m_localPoint , pointB ) ; localPointA . set ( proxyA . getVertex ( cache . indexA [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; temp . set ( pointA ) . subLocal ( pointB ) ; float s = Vec2 . dot ( temp , normal ) ; if ( s < <float> ) { m_axis . negateLocal ( ) ; s = - s ; } return s ; } else { m_type = Type . FACE_A ; localPointA1 . set ( m_proxyA . getVertex ( cache . indexA [ <int> ] ) ) ; localPointA2 . set ( m_proxyA . getVertex ( cache . indexA [ <int> ] ) ) ; temp . set ( localPointA2 ) . subLocal ( localPointA1 ) ; Vec2 . crossToOutUnsafe ( temp , <float> , m_axis ) ; m_axis . normalize ( ) ; Rot . mulToOutUnsafe ( xfa . q , m_axis , normal ) ; m_localPoint . set ( localPointA1 ) . addLocal ( localPointA2 ) . mulLocal ( <float> ) ; Transform . mulToOutUnsafe ( xfa , m_localPoint , pointA ) ; localPointB . set ( m_proxyB . getVertex ( cache . indexB [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; temp . set ( pointB ) . subLocal ( pointA ) ; float s = Vec2 . dot ( temp , normal ) ; if ( s < <float> ) { m_axis . negateLocal ( ) ; s = - s ; } return s ; } } private final Vec2 axisA = new Vec2 ( ) ; private final Vec2 axisB = new Vec2 ( ) ; public float findMinSeparation ( int [ ] indexes , float t ) { m_sweepA . getTransform ( xfa , t ) ; m_sweepB . getTransform ( xfb , t ) ; switch ( m_type ) { case POINTS : { Rot . mulTransUnsafe ( xfa . q , m_axis , axisA ) ; Rot . mulTransUnsafe ( xfb . q , m_axis . negateLocal ( ) , axisB ) ; m_axis . negateLocal ( ) ; indexes [ <int> ] = m_proxyA . getSupport ( axisA ) ; indexes [ <int> ] = m_proxyB . getSupport ( axisB ) ; localPointA . set ( m_proxyA . getVertex ( indexes [ <int> ] ) ) ; localPointB . set ( m_proxyB . getVertex ( indexes [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; float separation = Vec2 . dot ( pointB . subLocal ( pointA ) , m_axis ) ; return separation ; } case FACE_A : { Rot . mulToOutUnsafe ( xfa . q , m_axis , normal ) ; Transform . mulToOutUnsafe ( xfa , m_localPoint , pointA ) ; Rot . mulTransUnsafe ( xfb . q , normal . negateLocal ( ) , axisB ) ; normal . negateLocal ( ) ; indexes [ <int> ] = - <int> ; indexes [ <int> ] = m_proxyB . getSupport ( axisB ) ; localPointB . set ( m_proxyB . getVertex ( indexes [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; float separation = Vec2 . dot ( pointB . subLocal ( pointA ) , normal ) ; return separation ; } case FACE_B : { Rot . mulToOutUnsafe ( xfb . q , m_axis , normal ) ; Transform . mulToOutUnsafe ( xfb , m_localPoint , pointB ) ; Rot . mulTransUnsafe ( xfa . q , normal . negateLocal ( ) , axisA ) ; normal . negateLocal ( ) ; indexes [ <int> ] = - <int> ; indexes [ <int> ] = m_proxyA . getSupport ( axisA ) ; localPointA . set ( m_proxyA . getVertex ( indexes [ <int> ] ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; float separation = Vec2 . dot ( pointA . subLocal ( pointB ) , normal ) ; return separation ; } default : assert ( false ) ; indexes [ <int> ] = - <int> ; indexes [ <int> ] = - <int> ; return <float> ; } } public float evaluate ( int indexA , int indexB , float t ) { m_sweepA . getTransform ( xfa , t ) ; m_sweepB . getTransform ( xfb , t ) ; switch ( m_type ) { case POINTS : { Rot . mulTransUnsafe ( xfa . q , m_axis , axisA ) ; Rot . mulTransUnsafe ( xfb . q , m_axis . negateLocal ( ) , axisB ) ; m_axis . negateLocal ( ) ; localPointA . set ( m_proxyA . getVertex ( indexA ) ) ; localPointB . set ( m_proxyB . getVertex ( indexB ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; float separation = Vec2 . dot ( pointB . subLocal ( pointA ) , m_axis ) ; return separation ; } case FACE_A : { Rot . mulToOutUnsafe ( xfa . q , m_axis , normal ) ; Transform . mulToOutUnsafe ( xfa , m_localPoint , pointA ) ; Rot . mulTransUnsafe ( xfb . q , normal . negateLocal ( ) , axisB ) ; normal . negateLocal ( ) ; localPointB . set ( m_proxyB . getVertex ( indexB ) ) ; Transform . mulToOutUnsafe ( xfb , localPointB , pointB ) ; float separation = Vec2 . dot ( pointB . subLocal ( pointA ) , normal ) ; return separation ; } case FACE_B : { Rot . mulToOutUnsafe ( xfb . q , m_axis , normal ) ; Transform . mulToOutUnsafe ( xfb , m_localPoint , pointB ) ; Rot . mulTransUnsafe ( xfa . q , normal . negateLocal ( ) , axisA ) ; normal . negateLocal ( ) ; localPointA . set ( m_proxyA . getVertex ( indexA ) ) ; Transform . mulToOutUnsafe ( xfa , localPointA , pointA ) ; float separation = Vec2 . dot ( pointA . subLocal ( pointB ) , normal ) ; return separation ; } default : assert ( false ) ; return <float> ; } } } 
