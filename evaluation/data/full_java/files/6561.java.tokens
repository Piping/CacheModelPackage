package org . elasticsearch . index . mapper . geo ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . Version ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Iterators ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . support . XContentMapValues ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . DoubleFieldMapper ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . object . ArrayValueMapperParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import static org . elasticsearch . index . mapper . MapperBuilders . doubleField ; import static org . elasticsearch . index . mapper . MapperBuilders . stringField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseMultiField ; public abstract class BaseGeoPointFieldMapper extends FieldMapper implements ArrayValueMapperParser { public static final String CONTENT_TYPE = <str> ; public static class Names { public static final String LAT = <str> ; public static final String LAT_SUFFIX = <str> + LAT ; public static final String LON = <str> ; public static final String LON_SUFFIX = <str> + LON ; public static final String GEOHASH = <str> ; public static final String GEOHASH_SUFFIX = <str> + GEOHASH ; public static final String IGNORE_MALFORMED = <str> ; } public static class Defaults { public static final ContentPath . Type PATH_TYPE = ContentPath . Type . FULL ; public static final boolean ENABLE_LATLON = false ; public static final boolean ENABLE_GEOHASH = false ; public static final boolean ENABLE_GEOHASH_PREFIX = false ; public static final int GEO_HASH_PRECISION = GeoHashUtils . PRECISION ; public static final Explicit < Boolean > IGNORE_MALFORMED = new Explicit ( false , false ) ; } public abstract static class Builder < T extends Builder , Y extends BaseGeoPointFieldMapper > extends FieldMapper . Builder < T , Y > { protected ContentPath . Type pathType = Defaults . PATH_TYPE ; protected boolean enableLatLon = Defaults . ENABLE_LATLON ; protected Integer precisionStep ; protected boolean enableGeoHash = Defaults . ENABLE_GEOHASH ; protected boolean enableGeoHashPrefix = Defaults . ENABLE_GEOHASH_PREFIX ; protected int geoHashPrecision = Defaults . GEO_HASH_PRECISION ; protected Boolean ignoreMalformed ; public Builder ( String name , GeoPointFieldType fieldType ) { super ( name , fieldType ) ; } @Override public GeoPointFieldType fieldType ( ) { return ( GeoPointFieldType ) fieldType ; } @Override public T multiFieldPathType ( ContentPath . Type pathType ) { this . pathType = pathType ; return builder ; } @Override public T fieldDataSettings ( Settings settings ) { this . fieldDataSettings = settings ; return builder ; } public T enableLatLon ( boolean enableLatLon ) { this . enableLatLon = enableLatLon ; return builder ; } public T precisionStep ( int precisionStep ) { this . precisionStep = precisionStep ; return builder ; } public T enableGeoHash ( boolean enableGeoHash ) { this . enableGeoHash = enableGeoHash ; return builder ; } public T geoHashPrefix ( boolean enableGeoHashPrefix ) { this . enableGeoHashPrefix = enableGeoHashPrefix ; return builder ; } public T geoHashPrecision ( int precision ) { this . geoHashPrecision = precision ; return builder ; } public T ignoreMalformed ( boolean ignoreMalformed ) { this . ignoreMalformed = ignoreMalformed ; return builder ; } protected Explicit < Boolean > ignoreMalformed ( BuilderContext context ) { if ( ignoreMalformed ! = null ) { return new Explicit < > ( ignoreMalformed , true ) ; } if ( context . indexSettings ( ) ! = null ) { return new Explicit < > ( context . indexSettings ( ) . getAsBoolean ( <str> , Defaults . IGNORE_MALFORMED . value ( ) ) , false ) ; } return Defaults . IGNORE_MALFORMED ; } public abstract Y build ( BuilderContext context , String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , CopyTo copyTo ) ; public Y build ( Mapper . BuilderContext context ) { ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( pathType ) ; GeoPointFieldType geoPointFieldType = ( GeoPointFieldType ) fieldType ; DoubleFieldMapper latMapper = null ; DoubleFieldMapper lonMapper = null ; context . path ( ) . add ( name ) ; if ( enableLatLon ) { NumberFieldMapper . Builder < ? , ? > latMapperBuilder = doubleField ( Names . LAT ) . includeInAll ( false ) ; NumberFieldMapper . Builder < ? , ? > lonMapperBuilder = doubleField ( Names . LON ) . includeInAll ( false ) ; if ( precisionStep ! = null ) { latMapperBuilder . precisionStep ( precisionStep ) ; lonMapperBuilder . precisionStep ( precisionStep ) ; } latMapper = ( DoubleFieldMapper ) latMapperBuilder . includeInAll ( false ) . store ( fieldType . stored ( ) ) . docValues ( false ) . build ( context ) ; lonMapper = ( DoubleFieldMapper ) lonMapperBuilder . includeInAll ( false ) . store ( fieldType . stored ( ) ) . docValues ( false ) . build ( context ) ; geoPointFieldType . setLatLonEnabled ( latMapper . fieldType ( ) , lonMapper . fieldType ( ) ) ; } StringFieldMapper geoHashMapper = null ; if ( enableGeoHash | | enableGeoHashPrefix ) { geoHashMapper = stringField ( Names . GEOHASH ) . index ( true ) . tokenized ( false ) . includeInAll ( false ) . store ( fieldType . stored ( ) ) . omitNorms ( true ) . indexOptions ( IndexOptions . DOCS ) . build ( context ) ; geoPointFieldType . setGeoHashEnabled ( geoHashMapper . fieldType ( ) , geoHashPrecision , enableGeoHashPrefix ) ; } context . path ( ) . remove ( ) ; context . path ( ) . pathType ( origPathType ) ; return build ( context , name , fieldType , defaultFieldType , context . indexSettings ( ) , origPathType , latMapper , lonMapper , geoHashMapper , multiFieldsBuilder . build ( this , context ) , ignoreMalformed ( context ) , copyTo ) ; } } public abstract static class TypeParser implements Mapper . TypeParser { @Override public Mapper . Builder < ? , ? > parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { Builder builder ; if ( parserContext . indexVersionCreated ( ) . before ( Version . V_2_2_0 ) ) { builder = new GeoPointFieldMapperLegacy . Builder ( name ) ; } else { builder = new GeoPointFieldMapper . Builder ( name ) ; } parseField ( builder , name , node , parserContext ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { builder . enableLatLon ( XContentMapValues . nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . precisionStep ( XContentMapValues . nodeIntegerValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . enableGeoHash ( XContentMapValues . nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . geoHashPrefix ( XContentMapValues . nodeBooleanValue ( propNode ) ) ; if ( XContentMapValues . nodeBooleanValue ( propNode ) ) { builder . enableGeoHash ( true ) ; } iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { if ( propNode instanceof Integer ) { builder . geoHashPrecision ( XContentMapValues . nodeIntegerValue ( propNode ) ) ; } else { builder . geoHashPrecision ( GeoUtils . geoHashLevelsForPrecision ( propNode . toString ( ) ) ) ; } iterator . remove ( ) ; } else if ( propName . equals ( Names . IGNORE_MALFORMED ) ) { builder . ignoreMalformed ( XContentMapValues . nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( parseMultiField ( builder , name , parserContext , propName , propNode ) ) { iterator . remove ( ) ; } } if ( builder instanceof GeoPointFieldMapperLegacy . Builder ) { return GeoPointFieldMapperLegacy . parse ( ( GeoPointFieldMapperLegacy . Builder ) builder , node , parserContext ) ; } return ( GeoPointFieldMapper . Builder ) builder ; } } public static class GeoPointFieldType extends MappedFieldType { protected MappedFieldType geoHashFieldType ; protected int geoHashPrecision ; protected boolean geoHashPrefixEnabled ; protected MappedFieldType latFieldType ; protected MappedFieldType lonFieldType ; GeoPointFieldType ( ) { } GeoPointFieldType ( GeoPointFieldType ref ) { super ( ref ) ; this . geoHashFieldType = ref . geoHashFieldType ; this . geoHashPrecision = ref . geoHashPrecision ; this . geoHashPrefixEnabled = ref . geoHashPrefixEnabled ; this . latFieldType = ref . latFieldType ; this . lonFieldType = ref . lonFieldType ; } @Override public MappedFieldType clone ( ) { return new GeoPointFieldType ( this ) ; } @Override public boolean equals ( Object o ) { if ( ! super . equals ( o ) ) return false ; GeoPointFieldType that = ( GeoPointFieldType ) o ; return geoHashPrecision = = that . geoHashPrecision & & geoHashPrefixEnabled = = that . geoHashPrefixEnabled & & java . util . Objects . equals ( geoHashFieldType , that . geoHashFieldType ) & & java . util . Objects . equals ( latFieldType , that . latFieldType ) & & java . util . Objects . equals ( lonFieldType , that . lonFieldType ) ; } @Override public int hashCode ( ) { return java . util . Objects . hash ( super . hashCode ( ) , geoHashFieldType , geoHashPrecision , geoHashPrefixEnabled , latFieldType , lonFieldType ) ; } @Override public String typeName ( ) { return CONTENT_TYPE ; } @Override public void checkCompatibility ( MappedFieldType fieldType , List < String > conflicts , boolean strict ) { super . checkCompatibility ( fieldType , conflicts , strict ) ; GeoPointFieldType other = ( GeoPointFieldType ) fieldType ; if ( isLatLonEnabled ( ) ! = other . isLatLonEnabled ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( isLatLonEnabled ( ) & & other . isLatLonEnabled ( ) & & latFieldType ( ) . numericPrecisionStep ( ) ! = other . latFieldType ( ) . numericPrecisionStep ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( isGeoHashEnabled ( ) ! = other . isGeoHashEnabled ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( geoHashPrecision ( ) ! = other . geoHashPrecision ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( isGeoHashPrefixEnabled ( ) ! = other . isGeoHashPrefixEnabled ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } } public boolean isGeoHashEnabled ( ) { return geoHashFieldType ! = null ; } public MappedFieldType geoHashFieldType ( ) { return geoHashFieldType ; } public int geoHashPrecision ( ) { return geoHashPrecision ; } public boolean isGeoHashPrefixEnabled ( ) { return geoHashPrefixEnabled ; } public void setGeoHashEnabled ( MappedFieldType geoHashFieldType , int geoHashPrecision , boolean geoHashPrefixEnabled ) { checkIfFrozen ( ) ; this . geoHashFieldType = geoHashFieldType ; this . geoHashPrecision = geoHashPrecision ; this . geoHashPrefixEnabled = geoHashPrefixEnabled ; } public boolean isLatLonEnabled ( ) { return latFieldType ! = null ; } public MappedFieldType latFieldType ( ) { return latFieldType ; } public MappedFieldType lonFieldType ( ) { return lonFieldType ; } public void setLatLonEnabled ( MappedFieldType latFieldType , MappedFieldType lonFieldType ) { checkIfFrozen ( ) ; this . latFieldType = latFieldType ; this . lonFieldType = lonFieldType ; } } protected final DoubleFieldMapper latMapper ; protected final DoubleFieldMapper lonMapper ; protected final ContentPath . Type pathType ; protected final StringFieldMapper geoHashMapper ; protected Explicit < Boolean > ignoreMalformed ; protected BaseGeoPointFieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , indexSettings , multiFields , copyTo ) ; this . pathType = pathType ; this . latMapper = latMapper ; this . lonMapper = lonMapper ; this . geoHashMapper = geoHashMapper ; this . ignoreMalformed = ignoreMalformed ; } @Override public GeoPointFieldType fieldType ( ) { return ( GeoPointFieldType ) super . fieldType ( ) ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { super . merge ( mergeWith , mergeResult ) ; if ( ! this . getClass ( ) . equals ( mergeWith . getClass ( ) ) ) { return ; } BaseGeoPointFieldMapper gpfmMergeWith = ( BaseGeoPointFieldMapper ) mergeWith ; if ( mergeResult . simulate ( ) = = false & & mergeResult . hasConflicts ( ) = = false ) { if ( gpfmMergeWith . ignoreMalformed . explicit ( ) ) { this . ignoreMalformed = gpfmMergeWith . ignoreMalformed ; } } } @Override public Iterator < Mapper > iterator ( ) { List < Mapper > extras = new ArrayList < > ( ) ; if ( fieldType ( ) . isGeoHashEnabled ( ) ) { extras . add ( geoHashMapper ) ; } if ( fieldType ( ) . isLatLonEnabled ( ) ) { extras . add ( latMapper ) ; extras . add ( lonMapper ) ; } return Iterators . concat ( super . iterator ( ) , extras . iterator ( ) ) ; } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { throw new UnsupportedOperationException ( <str> ) ; } protected void parse ( ParseContext context , GeoPoint point , String geoHash ) throws IOException { if ( fieldType ( ) . isGeoHashEnabled ( ) ) { if ( geoHash = = null ) { geoHash = GeoHashUtils . stringEncode ( point . lon ( ) , point . lat ( ) ) ; } addGeoHashField ( context , geoHash ) ; } if ( fieldType ( ) . isLatLonEnabled ( ) ) { latMapper . parse ( context . createExternalValueContext ( point . lat ( ) ) ) ; lonMapper . parse ( context . createExternalValueContext ( point . lon ( ) ) ) ; } multiFields . parse ( this , context ) ; } @Override public Mapper parse ( ParseContext context ) throws IOException { ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( pathType ) ; context . path ( ) . add ( simpleName ( ) ) ; GeoPoint sparse = context . parseExternalValue ( GeoPoint . class ) ; if ( sparse ! = null ) { parse ( context , sparse , null ) ; } else { sparse = new GeoPoint ( ) ; XContentParser . Token token = context . parser ( ) . currentToken ( ) ; if ( token = = XContentParser . Token . START_ARRAY ) { token = context . parser ( ) . nextToken ( ) ; if ( token = = XContentParser . Token . START_ARRAY ) { while ( token ! = XContentParser . Token . END_ARRAY ) { parse ( context , GeoUtils . parseGeoPoint ( context . parser ( ) , sparse ) , null ) ; token = context . parser ( ) . nextToken ( ) ; } } else { if ( token = = XContentParser . Token . VALUE_NUMBER ) { double lon = context . parser ( ) . doubleValue ( ) ; token = context . parser ( ) . nextToken ( ) ; double lat = context . parser ( ) . doubleValue ( ) ; while ( ( token = context . parser ( ) . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) ; parse ( context , sparse . reset ( lat , lon ) , null ) ; } else { while ( token ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . VALUE_STRING ) { parsePointFromString ( context , sparse , context . parser ( ) . text ( ) ) ; } else { parse ( context , GeoUtils . parseGeoPoint ( context . parser ( ) , sparse ) , null ) ; } token = context . parser ( ) . nextToken ( ) ; } } } } else if ( token = = XContentParser . Token . VALUE_STRING ) { parsePointFromString ( context , sparse , context . parser ( ) . text ( ) ) ; } else if ( token ! = XContentParser . Token . VALUE_NULL ) { parse ( context , GeoUtils . parseGeoPoint ( context . parser ( ) , sparse ) , null ) ; } } context . path ( ) . remove ( ) ; context . path ( ) . pathType ( origPathType ) ; return null ; } private void addGeoHashField ( ParseContext context , String geoHash ) throws IOException { int len = Math . min ( fieldType ( ) . geoHashPrecision ( ) , geoHash . length ( ) ) ; int min = fieldType ( ) . isGeoHashPrefixEnabled ( ) ? <int> : len ; for ( int i = len ; i > = min ; i - - ) { geoHashMapper . parse ( context . createExternalValueContext ( geoHash . substring ( <int> , i ) ) ) ; } } private void parsePointFromString ( ParseContext context , GeoPoint sparse , String point ) throws IOException { if ( point . indexOf ( <str> ) < <int> ) { parse ( context , sparse . resetFromGeoHash ( point ) , point ) ; } else { parse ( context , sparse . resetFromString ( point ) , null ) ; } } @Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { super . doXContentBody ( builder , includeDefaults , params ) ; if ( includeDefaults | | pathType ! = Defaults . PATH_TYPE ) { builder . field ( <str> , pathType . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( includeDefaults | | fieldType ( ) . isLatLonEnabled ( ) ! = GeoPointFieldMapper . Defaults . ENABLE_LATLON ) { builder . field ( <str> , fieldType ( ) . isLatLonEnabled ( ) ) ; } if ( fieldType ( ) . isLatLonEnabled ( ) & & ( includeDefaults | | fieldType ( ) . latFieldType ( ) . numericPrecisionStep ( ) ! = NumericUtils . PRECISION_STEP_DEFAULT ) ) { builder . field ( <str> , fieldType ( ) . latFieldType ( ) . numericPrecisionStep ( ) ) ; } if ( includeDefaults | | fieldType ( ) . isGeoHashEnabled ( ) ! = Defaults . ENABLE_GEOHASH ) { builder . field ( <str> , fieldType ( ) . isGeoHashEnabled ( ) ) ; } if ( includeDefaults | | fieldType ( ) . isGeoHashPrefixEnabled ( ) ! = Defaults . ENABLE_GEOHASH_PREFIX ) { builder . field ( <str> , fieldType ( ) . isGeoHashPrefixEnabled ( ) ) ; } if ( fieldType ( ) . isGeoHashEnabled ( ) & & ( includeDefaults | | fieldType ( ) . geoHashPrecision ( ) ! = Defaults . GEO_HASH_PRECISION ) ) { builder . field ( <str> , fieldType ( ) . geoHashPrecision ( ) ) ; } if ( includeDefaults | | ignoreMalformed . explicit ( ) ) { builder . field ( Names . IGNORE_MALFORMED , ignoreMalformed . value ( ) ) ; } } } 
