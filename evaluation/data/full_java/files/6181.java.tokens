package org . elasticsearch . discovery . zen . fd ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import static org . elasticsearch . common . util . concurrent . ConcurrentCollections . newConcurrentMap ; public class NodesFaultDetection extends FaultDetection { public static final String PING_ACTION_NAME = <str> ; public abstract static class Listener { public void onNodeFailure ( DiscoveryNode node , String reason ) { } public void onPingReceived ( PingRequest pingRequest ) { } } private final CopyOnWriteArrayList < Listener > listeners = new CopyOnWriteArrayList < > ( ) ; private final ConcurrentMap < DiscoveryNode , NodeFD > nodesFD = newConcurrentMap ( ) ; private volatile long clusterStateVersion = ClusterState . UNKNOWN_VERSION ; private volatile DiscoveryNode localNode ; public NodesFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterName clusterName ) { super ( settings , threadPool , transportService , clusterName ) ; logger . debug ( <str> , pingInterval , pingRetryTimeout , pingRetryCount ) ; transportService . registerRequestHandler ( PING_ACTION_NAME , PingRequest : : new , ThreadPool . Names . SAME , new PingRequestHandler ( ) ) ; } public void setLocalNode ( DiscoveryNode localNode ) { this . localNode = localNode ; } public void addListener ( Listener listener ) { listeners . add ( listener ) ; } public void removeListener ( Listener listener ) { listeners . remove ( listener ) ; } public void updateNodesAndPing ( ClusterState clusterState ) { for ( DiscoveryNode monitoredNode : nodesFD . keySet ( ) ) { if ( ! clusterState . nodes ( ) . nodeExists ( monitoredNode . id ( ) ) ) { nodesFD . remove ( monitoredNode ) ; } } for ( DiscoveryNode node : clusterState . nodes ( ) ) { if ( node . equals ( localNode ) ) { continue ; } if ( ! nodesFD . containsKey ( node ) ) { NodeFD fd = new NodeFD ( node ) ; nodesFD . put ( node , fd ) ; threadPool . schedule ( TimeValue . timeValueMillis ( <int> ) , ThreadPool . Names . SAME , fd ) ; } } } public NodesFaultDetection stop ( ) { nodesFD . clear ( ) ; return this ; } @Override public void close ( ) { super . close ( ) ; stop ( ) ; transportService . removeHandler ( PING_ACTION_NAME ) ; } @Override protected void handleTransportDisconnect ( DiscoveryNode node ) { NodeFD nodeFD = nodesFD . remove ( node ) ; if ( nodeFD = = null ) { return ; } if ( connectOnNetworkDisconnect ) { NodeFD fd = new NodeFD ( node ) ; try { transportService . connectToNode ( node ) ; nodesFD . put ( node , fd ) ; threadPool . schedule ( TimeValue . timeValueMillis ( <int> ) , ThreadPool . Names . SAME , fd ) ; } catch ( Exception e ) { logger . trace ( <str> , node ) ; nodesFD . remove ( node , fd ) ; notifyNodeFailure ( node , <str> ) ; } } else { logger . trace ( <str> , node ) ; notifyNodeFailure ( node , <str> ) ; } } private void notifyNodeFailure ( final DiscoveryNode node , final String reason ) { try { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { for ( Listener listener : listeners ) { listener . onNodeFailure ( node , reason ) ; } } } ) ; } catch ( EsRejectedExecutionException ex ) { logger . trace ( <str> , ex , node , reason ) ; } } private void notifyPingReceived ( final PingRequest pingRequest ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { for ( Listener listener : listeners ) { listener . onPingReceived ( pingRequest ) ; } } } ) ; } private class NodeFD implements Runnable { volatile int retryCount ; private final DiscoveryNode node ; private NodeFD ( DiscoveryNode node ) { this . node = node ; } private boolean running ( ) { return NodeFD . this . equals ( nodesFD . get ( node ) ) ; } @Override public void run ( ) { if ( ! running ( ) ) { return ; } final PingRequest pingRequest = new PingRequest ( node . id ( ) , clusterName , localNode , clusterStateVersion ) ; final TransportRequestOptions options = TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . PING ) . withTimeout ( pingRetryTimeout ) . build ( ) ; transportService . sendRequest ( node , PING_ACTION_NAME , pingRequest , options , new BaseTransportResponseHandler < PingResponse > ( ) { @Override public PingResponse newInstance ( ) { return new PingResponse ( ) ; } @Override public void handleResponse ( PingResponse response ) { if ( ! running ( ) ) { return ; } retryCount = <int> ; threadPool . schedule ( pingInterval , ThreadPool . Names . SAME , NodeFD . this ) ; } @Override public void handleException ( TransportException exp ) { if ( ! running ( ) ) { return ; } if ( exp instanceof ConnectTransportException | | exp . getCause ( ) instanceof ConnectTransportException ) { handleTransportDisconnect ( node ) ; return ; } retryCount + + ; logger . trace ( <str> , exp , node , retryCount , pingRetryCount ) ; if ( retryCount > = pingRetryCount ) { logger . debug ( <str> , node , pingRetryCount , pingRetryTimeout ) ; if ( nodesFD . remove ( node , NodeFD . this ) ) { notifyNodeFailure ( node , <str> + pingRetryCount + <str> + pingRetryTimeout + <str> ) ; } } else { transportService . sendRequest ( node , PING_ACTION_NAME , pingRequest , options , this ) ; } } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } } class PingRequestHandler implements TransportRequestHandler < PingRequest > { @Override public void messageReceived ( PingRequest request , TransportChannel channel ) throws Exception { if ( ! localNode . id ( ) . equals ( request . nodeId ) ) { throw new IllegalStateException ( <str> + request . nodeId + <str> + localNode . id ( ) + <str> ) ; } if ( request . clusterName ! = null & & ! request . clusterName . equals ( clusterName ) ) { throw new IllegalStateException ( <str> + request . clusterName + <str> + clusterName + <str> ) ; } notifyPingReceived ( request ) ; channel . sendResponse ( new PingResponse ( ) ) ; } } public static class PingRequest extends TransportRequest { private String nodeId ; private ClusterName clusterName ; private DiscoveryNode masterNode ; private long clusterStateVersion = ClusterState . UNKNOWN_VERSION ; public PingRequest ( ) { } PingRequest ( String nodeId , ClusterName clusterName , DiscoveryNode masterNode , long clusterStateVersion ) { this . nodeId = nodeId ; this . clusterName = clusterName ; this . masterNode = masterNode ; this . clusterStateVersion = clusterStateVersion ; } public String nodeId ( ) { return nodeId ; } public ClusterName clusterName ( ) { return clusterName ; } public DiscoveryNode masterNode ( ) { return masterNode ; } public long clusterStateVersion ( ) { return clusterStateVersion ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; nodeId = in . readString ( ) ; clusterName = ClusterName . readClusterName ( in ) ; masterNode = DiscoveryNode . readNode ( in ) ; clusterStateVersion = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( nodeId ) ; clusterName . writeTo ( out ) ; masterNode . writeTo ( out ) ; out . writeLong ( clusterStateVersion ) ; } } private static class PingResponse extends TransportResponse { private PingResponse ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; } } } 
