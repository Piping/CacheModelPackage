package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . MockInternalClusterInfoService . DevNullClusterInfo ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import static org . hamcrest . CoreMatchers . equalTo ; public class DiskThresholdDeciderUnitTests extends ESTestCase { public void testDynamicSettings ( ) { NodeSettingsService nss = new NodeSettingsService ( Settings . EMPTY ) ; ClusterInfoService cis = EmptyClusterInfoService . INSTANCE ; DiskThresholdDecider decider = new DiskThresholdDecider ( Settings . EMPTY , nss , cis , null ) ; assertThat ( decider . getFreeBytesThresholdHigh ( ) , equalTo ( ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ) ) ; assertThat ( decider . getFreeDiskThresholdHigh ( ) , equalTo ( <float> ) ) ; assertThat ( decider . getFreeBytesThresholdLow ( ) , equalTo ( ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ) ) ; assertThat ( decider . getFreeDiskThresholdLow ( ) , equalTo ( <float> ) ) ; assertThat ( decider . getUsedDiskThresholdLow ( ) , equalTo ( <float> ) ) ; assertThat ( decider . getRerouteInterval ( ) . seconds ( ) , equalTo ( <int> ) ) ; assertTrue ( decider . isEnabled ( ) ) ; assertTrue ( decider . isIncludeRelocations ( ) ) ; DiskThresholdDecider . ApplySettings applySettings = decider . newApplySettings ( ) ; Settings newSettings = Settings . builder ( ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , false ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , false ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) . put ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL , <str> ) . build ( ) ; applySettings . onRefreshSettings ( newSettings ) ; assertThat ( <str> , decider . getFreeBytesThresholdHigh ( ) , equalTo ( ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ) ) ; assertThat ( <str> , decider . getFreeDiskThresholdHigh ( ) , equalTo ( <float> ) ) ; assertThat ( <str> , decider . getFreeBytesThresholdLow ( ) , equalTo ( ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ) ) ; assertThat ( <str> , decider . getFreeDiskThresholdLow ( ) , equalTo ( <float> ) ) ; assertThat ( <str> , decider . getRerouteInterval ( ) . seconds ( ) , equalTo ( <int> ) ) ; assertFalse ( <str> , decider . isEnabled ( ) ) ; assertFalse ( <str> , decider . isIncludeRelocations ( ) ) ; } public void testCanAllocateUsesMaxAvailableSpace ( ) { NodeSettingsService nss = new NodeSettingsService ( Settings . EMPTY ) ; ClusterInfoService cis = EmptyClusterInfoService . INSTANCE ; DiskThresholdDecider decider = new DiskThresholdDecider ( Settings . EMPTY , nss , cis , null ) ; ShardRouting test_0 = ShardRouting . newUnassigned ( <str> , <int> , null , true , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; DiscoveryNode node_0 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; DiscoveryNode node_1 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( node_0 ) . put ( node_1 ) ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > leastAvailableUsages = ImmutableOpenMap . builder ( ) ; leastAvailableUsages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; leastAvailableUsages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap . Builder < String , DiskUsage > mostAvailableUsage = ImmutableOpenMap . builder ( ) ; mostAvailableUsage . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , randomIntBetween ( <int> , <int> ) ) ) ; mostAvailableUsage . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , randomIntBetween ( <int> , <int> ) ) ) ; ImmutableOpenMap . Builder < String , Long > shardSizes = ImmutableOpenMap . builder ( ) ; shardSizes . put ( <str> , <int> ) ; final ClusterInfo clusterInfo = new ClusterInfo ( leastAvailableUsages . build ( ) , mostAvailableUsage . build ( ) , shardSizes . build ( ) , ImmutableOpenMap . of ( ) ) ; RoutingAllocation allocation = new RoutingAllocation ( new AllocationDeciders ( Settings . EMPTY , new AllocationDecider [ ] { decider } ) , clusterState . getRoutingNodes ( ) , clusterState . nodes ( ) , clusterInfo , System . nanoTime ( ) ) ; assertEquals ( mostAvailableUsage . toString ( ) , Decision . YES , decider . canAllocate ( test_0 , new RoutingNode ( <str> , node_0 ) , allocation ) ) ; assertEquals ( mostAvailableUsage . toString ( ) , Decision . NO , decider . canAllocate ( test_0 , new RoutingNode ( <str> , node_1 ) , allocation ) ) ; } public void testCanRemainUsesLeastAvailableSpace ( ) { NodeSettingsService nss = new NodeSettingsService ( Settings . EMPTY ) ; ClusterInfoService cis = EmptyClusterInfoService . INSTANCE ; DiskThresholdDecider decider = new DiskThresholdDecider ( Settings . EMPTY , nss , cis , null ) ; ImmutableOpenMap . Builder < ShardRouting , String > shardRoutingMap = ImmutableOpenMap . builder ( ) ; DiscoveryNode node_0 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; DiscoveryNode node_1 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; ShardRouting test_0 = ShardRouting . newUnassigned ( <str> , <int> , null , true , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_0 , node_0 . getId ( ) ) ; ShardRoutingHelper . moveToStarted ( test_0 ) ; shardRoutingMap . put ( test_0 , <str> ) ; ShardRouting test_1 = ShardRouting . newUnassigned ( <str> , <int> , null , true , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_1 , node_1 . getId ( ) ) ; ShardRoutingHelper . moveToStarted ( test_1 ) ; shardRoutingMap . put ( test_1 , <str> ) ; ShardRouting test_2 = ShardRouting . newUnassigned ( <str> , <int> , null , true , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_2 , node_1 . getId ( ) ) ; ShardRoutingHelper . moveToStarted ( test_2 ) ; shardRoutingMap . put ( test_2 , <str> ) ; ShardRouting test_3 = ShardRouting . newUnassigned ( <str> , <int> , null , true , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_3 , node_1 . getId ( ) ) ; ShardRoutingHelper . moveToStarted ( test_3 ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( node_0 ) . put ( node_1 ) ) . build ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > leastAvailableUsages = ImmutableOpenMap . builder ( ) ; leastAvailableUsages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; leastAvailableUsages . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap . Builder < String , DiskUsage > mostAvailableUsage = ImmutableOpenMap . builder ( ) ; mostAvailableUsage . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; mostAvailableUsage . put ( <str> , new DiskUsage ( <str> , <str> , <str> , <int> , <int> ) ) ; ImmutableOpenMap . Builder < String , Long > shardSizes = ImmutableOpenMap . builder ( ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; final ClusterInfo clusterInfo = new ClusterInfo ( leastAvailableUsages . build ( ) , mostAvailableUsage . build ( ) , shardSizes . build ( ) , shardRoutingMap . build ( ) ) ; RoutingAllocation allocation = new RoutingAllocation ( new AllocationDeciders ( Settings . EMPTY , new AllocationDecider [ ] { decider } ) , clusterState . getRoutingNodes ( ) , clusterState . nodes ( ) , clusterInfo , System . nanoTime ( ) ) ; assertEquals ( Decision . YES , decider . canRemain ( test_0 , new RoutingNode ( <str> , node_0 ) , allocation ) ) ; assertEquals ( Decision . NO , decider . canRemain ( test_1 , new RoutingNode ( <str> , node_1 ) , allocation ) ) ; try { decider . canRemain ( test_0 , new RoutingNode ( <str> , node_1 ) , allocation ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { decider . canRemain ( test_1 , new RoutingNode ( <str> , node_0 ) , allocation ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } assertEquals ( <str> , Decision . YES , decider . canRemain ( test_2 , new RoutingNode ( <str> , node_1 ) , allocation ) ) ; assertEquals ( <str> , Decision . YES , decider . canRemain ( test_2 , new RoutingNode ( <str> , node_1 ) , allocation ) ) ; } public void testShardSizeAndRelocatingSize ( ) { ImmutableOpenMap . Builder < String , Long > shardSizes = ImmutableOpenMap . builder ( ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; shardSizes . put ( <str> , <int> ) ; ClusterInfo info = new DevNullClusterInfo ( ImmutableOpenMap . of ( ) , ImmutableOpenMap . of ( ) , shardSizes . build ( ) ) ; ShardRouting test_0 = ShardRouting . newUnassigned ( <str> , <int> , null , false , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_0 , <str> ) ; ShardRoutingHelper . moveToStarted ( test_0 ) ; ShardRoutingHelper . relocate ( test_0 , <str> ) ; ShardRouting test_1 = ShardRouting . newUnassigned ( <str> , <int> , null , false , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_1 , <str> ) ; ShardRoutingHelper . moveToStarted ( test_1 ) ; ShardRoutingHelper . relocate ( test_1 , <str> ) ; ShardRouting test_2 = ShardRouting . newUnassigned ( <str> , <int> , null , false , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_2 , <str> ) ; ShardRoutingHelper . moveToStarted ( test_2 ) ; assertEquals ( <int> , DiskThresholdDecider . getShardSize ( test_2 , info ) ) ; assertEquals ( <int> , DiskThresholdDecider . getShardSize ( test_1 , info ) ) ; assertEquals ( <int> , DiskThresholdDecider . getShardSize ( test_0 , info ) ) ; RoutingNode node = new RoutingNode ( <str> , new DiscoveryNode ( <str> , LocalTransportAddress . PROTO , Version . CURRENT ) , Arrays . asList ( test_0 , test_1 . buildTargetRelocatingShard ( ) , test_2 ) ) ; assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , false , <str> ) ) ; assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , true , <str> ) ) ; assertEquals ( <int> l , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , true , <str> ) ) ; assertEquals ( <int> l , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , true , <str> ) ) ; ShardRouting test_3 = ShardRouting . newUnassigned ( <str> , <int> , null , false , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( test_3 , <str> ) ; ShardRoutingHelper . moveToStarted ( test_3 ) ; assertEquals ( <int> l , DiskThresholdDecider . getShardSize ( test_3 , info ) ) ; ShardRouting other_0 = ShardRouting . newUnassigned ( <str> , <int> , null , randomBoolean ( ) , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( other_0 , <str> ) ; ShardRoutingHelper . moveToStarted ( other_0 ) ; ShardRoutingHelper . relocate ( other_0 , <str> ) ; node = new RoutingNode ( <str> , new DiscoveryNode ( <str> , LocalTransportAddress . PROTO , Version . CURRENT ) , Arrays . asList ( test_0 , test_1 . buildTargetRelocatingShard ( ) , test_2 , other_0 . buildTargetRelocatingShard ( ) ) ) ; if ( other_0 . primary ( ) ) { assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , false , <str> ) ) ; assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , true , <str> ) ) ; } else { assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , false , <str> ) ) ; assertEquals ( <int> , DiskThresholdDecider . sizeOfRelocatingShards ( node , info , true , <str> ) ) ; } } } 
