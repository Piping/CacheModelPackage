package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import org . junit . Test ; import java . io . IOException ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class SocketCancelWriteTest extends AbstractSocketTest { @Test ( timeout = <int> ) public void testCancelWrite ( ) throws Throwable { run ( ) ; } public void testCancelWrite ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { final TestHandler sh = new TestHandler ( ) ; final TestHandler ch = new TestHandler ( ) ; final ByteBuf a = Unpooled . buffer ( ) . writeByte ( <str> ) ; final ByteBuf b = Unpooled . buffer ( ) . writeByte ( <str> ) ; final ByteBuf c = Unpooled . buffer ( ) . writeByte ( <str> ) ; final ByteBuf d = Unpooled . buffer ( ) . writeByte ( <str> ) ; final ByteBuf e = Unpooled . buffer ( ) . writeByte ( <str> ) ; cb . handler ( ch ) ; sb . childHandler ( sh ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; ChannelFuture f = cc . write ( a ) ; assertTrue ( f . cancel ( false ) ) ; cc . writeAndFlush ( b ) ; cc . write ( c ) ; ChannelFuture f2 = cc . write ( d ) ; assertTrue ( f2 . cancel ( false ) ) ; cc . writeAndFlush ( e ) ; while ( sh . counter < <int> ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignore ) { } } sh . channel . close ( ) . sync ( ) ; ch . channel . close ( ) . sync ( ) ; sc . close ( ) . sync ( ) ; if ( sh . exception . get ( ) ! = null & & ! ( sh . exception . get ( ) instanceof IOException ) ) { throw sh . exception . get ( ) ; } if ( sh . exception . get ( ) ! = null ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null & & ! ( ch . exception . get ( ) instanceof IOException ) ) { throw ch . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null ) { throw ch . exception . get ( ) ; } assertEquals ( <int> , ch . counter ) ; assertEquals ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) , sh . received ) ; } private static class TestHandler extends SimpleChannelInboundHandler < ByteBuf > { volatile Channel channel ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; volatile int counter ; final ByteBuf received = Unpooled . buffer ( ) ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { channel = ctx . channel ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { counter + = in . readableBytes ( ) ; received . writeBytes ( in ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { ctx . close ( ) ; } } } } 
