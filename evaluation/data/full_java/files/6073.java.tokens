package org . elasticsearch . common . unit ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import java . io . IOException ; public class SizeValue implements Streamable { private long size ; private SizeUnit sizeUnit ; private SizeValue ( ) { } public SizeValue ( long singles ) { this ( singles , SizeUnit . SINGLE ) ; } public SizeValue ( long size , SizeUnit sizeUnit ) { if ( size < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . size = size ; this . sizeUnit = sizeUnit ; } public long singles ( ) { return sizeUnit . toSingles ( size ) ; } public long getSingles ( ) { return singles ( ) ; } public long kilo ( ) { return sizeUnit . toKilo ( size ) ; } public long getKilo ( ) { return kilo ( ) ; } public long mega ( ) { return sizeUnit . toMega ( size ) ; } public long getMega ( ) { return mega ( ) ; } public long giga ( ) { return sizeUnit . toGiga ( size ) ; } public long getGiga ( ) { return giga ( ) ; } public long tera ( ) { return sizeUnit . toTera ( size ) ; } public long getTera ( ) { return tera ( ) ; } public long peta ( ) { return sizeUnit . toPeta ( size ) ; } public long getPeta ( ) { return peta ( ) ; } public double kiloFrac ( ) { return ( ( double ) singles ( ) ) / SizeUnit . C1 ; } public double getKiloFrac ( ) { return kiloFrac ( ) ; } public double megaFrac ( ) { return ( ( double ) singles ( ) ) / SizeUnit . C2 ; } public double getMegaFrac ( ) { return megaFrac ( ) ; } public double gigaFrac ( ) { return ( ( double ) singles ( ) ) / SizeUnit . C3 ; } public double getGigaFrac ( ) { return gigaFrac ( ) ; } public double teraFrac ( ) { return ( ( double ) singles ( ) ) / SizeUnit . C4 ; } public double getTeraFrac ( ) { return teraFrac ( ) ; } public double petaFrac ( ) { return ( ( double ) singles ( ) ) / SizeUnit . C5 ; } public double getPetaFrac ( ) { return petaFrac ( ) ; } @Override public String toString ( ) { long singles = singles ( ) ; double value = singles ; String suffix = <str> ; if ( singles > = SizeUnit . C5 ) { value = petaFrac ( ) ; suffix = <str> ; } else if ( singles > = SizeUnit . C4 ) { value = teraFrac ( ) ; suffix = <str> ; } else if ( singles > = SizeUnit . C3 ) { value = gigaFrac ( ) ; suffix = <str> ; } else if ( singles > = SizeUnit . C2 ) { value = megaFrac ( ) ; suffix = <str> ; } else if ( singles > = SizeUnit . C1 ) { value = kiloFrac ( ) ; suffix = <str> ; } return Strings . format1Decimals ( value , suffix ) ; } public static SizeValue parseSizeValue ( String sValue ) throws ElasticsearchParseException { return parseSizeValue ( sValue , null ) ; } public static SizeValue parseSizeValue ( String sValue , SizeValue defaultValue ) throws ElasticsearchParseException { if ( sValue = = null ) { return defaultValue ; } long singles ; try { if ( sValue . endsWith ( <str> ) ) { singles = Long . parseLong ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) ; } else if ( sValue . endsWith ( <str> ) | | sValue . endsWith ( <str> ) ) { singles = ( long ) ( Double . parseDouble ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) * SizeUnit . C1 ) ; } else if ( sValue . endsWith ( <str> ) | | sValue . endsWith ( <str> ) ) { singles = ( long ) ( Double . parseDouble ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) * SizeUnit . C2 ) ; } else if ( sValue . endsWith ( <str> ) | | sValue . endsWith ( <str> ) ) { singles = ( long ) ( Double . parseDouble ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) * SizeUnit . C3 ) ; } else if ( sValue . endsWith ( <str> ) | | sValue . endsWith ( <str> ) ) { singles = ( long ) ( Double . parseDouble ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) * SizeUnit . C4 ) ; } else if ( sValue . endsWith ( <str> ) | | sValue . endsWith ( <str> ) ) { singles = ( long ) ( Double . parseDouble ( sValue . substring ( <int> , sValue . length ( ) - <int> ) ) * SizeUnit . C5 ) ; } else { singles = Long . parseLong ( sValue ) ; } } catch ( NumberFormatException e ) { throw new ElasticsearchParseException ( <str> , e , sValue ) ; } return new SizeValue ( singles , SizeUnit . SINGLE ) ; } public static SizeValue readSizeValue ( StreamInput in ) throws IOException { SizeValue sizeValue = new SizeValue ( ) ; sizeValue . readFrom ( in ) ; return sizeValue ; } @Override public void readFrom ( StreamInput in ) throws IOException { size = in . readVLong ( ) ; sizeUnit = SizeUnit . SINGLE ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( singles ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; SizeValue sizeValue = ( SizeValue ) o ; if ( size ! = sizeValue . size ) return false ; if ( sizeUnit ! = sizeValue . sizeUnit ) return false ; return true ; } @Override public int hashCode ( ) { int result = Long . hashCode ( size ) ; result = <int> * result + ( sizeUnit ! = null ? sizeUnit . hashCode ( ) : <int> ) ; return result ; } } 
