package org . elasticsearch . cluster ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . unit . TimeValue ; import java . util . concurrent . atomic . AtomicReference ; public class ClusterStateObserver { protected final ESLogger logger ; public final ChangePredicate MATCH_ALL_CHANGES_PREDICATE = new EventPredicate ( ) { @Override public boolean apply ( ClusterChangedEvent changedEvent ) { return changedEvent . previousState ( ) . version ( ) ! = changedEvent . state ( ) . version ( ) ; } } ; private final ClusterService clusterService ; volatile TimeValue timeOutValue ; final AtomicReference < ObservedState > lastObservedState ; final TimeoutClusterStateListener clusterStateListener = new ObserverClusterStateListener ( ) ; final AtomicReference < ObservingContext > observingContext = new AtomicReference < ObservingContext > ( null ) ; volatile Long startTimeNS ; volatile boolean timedOut ; public ClusterStateObserver ( ClusterService clusterService , ESLogger logger ) { this ( clusterService , new TimeValue ( <int> ) , logger ) ; } public ClusterStateObserver ( ClusterService clusterService , @Nullable TimeValue timeout , ESLogger logger ) { this . clusterService = clusterService ; this . lastObservedState = new AtomicReference < > ( new ObservedState ( clusterService . state ( ) ) ) ; this . timeOutValue = timeout ; if ( timeOutValue ! = null ) { this . startTimeNS = System . nanoTime ( ) ; } this . logger = logger ; } public ClusterState observedState ( ) { ObservedState state = lastObservedState . get ( ) ; assert state ! = null ; return state . clusterState ; } public boolean isTimedOut ( ) { return timedOut ; } public void waitForNextChange ( Listener listener ) { waitForNextChange ( listener , MATCH_ALL_CHANGES_PREDICATE ) ; } public void waitForNextChange ( Listener listener , @Nullable TimeValue timeOutValue ) { waitForNextChange ( listener , MATCH_ALL_CHANGES_PREDICATE , timeOutValue ) ; } public void waitForNextChange ( Listener listener , ChangePredicate changePredicate ) { waitForNextChange ( listener , changePredicate , null ) ; } public void waitForNextChange ( Listener listener , ChangePredicate changePredicate , @Nullable TimeValue timeOutValue ) { if ( observingContext . get ( ) ! = null ) { throw new ElasticsearchException ( <str> ) ; } Long timeoutTimeLeftMS ; if ( timeOutValue = = null ) { timeOutValue = this . timeOutValue ; if ( timeOutValue ! = null ) { long timeSinceStartMS = TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ; timeoutTimeLeftMS = timeOutValue . millis ( ) - timeSinceStartMS ; if ( timeoutTimeLeftMS < = <int> l ) { logger . trace ( <str> , timeOutValue , new TimeValue ( timeSinceStartMS ) ) ; timedOut = true ; lastObservedState . set ( new ObservedState ( clusterService . state ( ) ) ) ; listener . onTimeout ( timeOutValue ) ; return ; } } else { timeoutTimeLeftMS = null ; } } else { this . startTimeNS = System . nanoTime ( ) ; this . timeOutValue = timeOutValue ; timeoutTimeLeftMS = timeOutValue . millis ( ) ; timedOut = false ; } ObservedState newState = new ObservedState ( clusterService . state ( ) ) ; ObservedState lastState = lastObservedState . get ( ) ; if ( changePredicate . apply ( lastState . clusterState , lastState . status , newState . clusterState , newState . status ) ) { logger . trace ( <str> , newState ) ; lastObservedState . set ( newState ) ; listener . onNewClusterState ( newState . clusterState ) ; } else { logger . trace ( <str> , newState ) ; ObservingContext context = new ObservingContext ( listener , changePredicate ) ; if ( ! observingContext . compareAndSet ( null , context ) ) { throw new ElasticsearchException ( <str> ) ; } clusterService . add ( timeoutTimeLeftMS = = null ? null : new TimeValue ( timeoutTimeLeftMS ) , clusterStateListener ) ; } } public void reset ( ClusterState toState ) { if ( observingContext . getAndSet ( null ) ! = null ) { clusterService . remove ( clusterStateListener ) ; } lastObservedState . set ( new ObservedState ( toState ) ) ; } class ObserverClusterStateListener implements TimeoutClusterStateListener { @Override public void clusterChanged ( ClusterChangedEvent event ) { ObservingContext context = observingContext . get ( ) ; if ( context = = null ) { return ; } if ( context . changePredicate . apply ( event ) ) { if ( observingContext . compareAndSet ( context , null ) ) { clusterService . remove ( this ) ; ObservedState state = new ObservedState ( event . state ( ) ) ; logger . trace ( <str> , state ) ; lastObservedState . set ( state ) ; context . listener . onNewClusterState ( state . clusterState ) ; } else { logger . trace ( <str> , event . state ( ) . version ( ) ) ; } } else { logger . trace ( <str> , event . state ( ) . version ( ) ) ; } } @Override public void postAdded ( ) { ObservingContext context = observingContext . get ( ) ; if ( context = = null ) { return ; } ObservedState newState = new ObservedState ( clusterService . state ( ) ) ; ObservedState lastState = lastObservedState . get ( ) ; if ( context . changePredicate . apply ( lastState . clusterState , lastState . status , newState . clusterState , newState . status ) ) { if ( observingContext . compareAndSet ( context , null ) ) { logger . trace ( <str> , newState ) ; clusterService . remove ( this ) ; lastObservedState . set ( newState ) ; context . listener . onNewClusterState ( newState . clusterState ) ; } else { logger . trace ( <str> , newState ) ; } } else { logger . trace ( <str> , newState ) ; } } @Override public void onClose ( ) { ObservingContext context = observingContext . getAndSet ( null ) ; if ( context ! = null ) { logger . trace ( <str> ) ; clusterService . remove ( this ) ; context . listener . onClusterServiceClose ( ) ; } } @Override public void onTimeout ( TimeValue timeout ) { ObservingContext context = observingContext . getAndSet ( null ) ; if ( context ! = null ) { clusterService . remove ( this ) ; long timeSinceStartMS = TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ; logger . trace ( <str> , timeOutValue , new TimeValue ( timeSinceStartMS ) ) ; lastObservedState . set ( new ObservedState ( clusterService . state ( ) ) ) ; timedOut = true ; context . listener . onTimeout ( timeOutValue ) ; } } } public static interface Listener { void onNewClusterState ( ClusterState state ) ; void onClusterServiceClose ( ) ; void onTimeout ( TimeValue timeout ) ; } public interface ChangePredicate { public boolean apply ( ClusterState previousState , ClusterState . ClusterStateStatus previousStatus , ClusterState newState , ClusterState . ClusterStateStatus newStatus ) ; public boolean apply ( ClusterChangedEvent changedEvent ) ; } public static abstract class ValidationPredicate implements ChangePredicate { @Override public boolean apply ( ClusterState previousState , ClusterState . ClusterStateStatus previousStatus , ClusterState newState , ClusterState . ClusterStateStatus newStatus ) { if ( previousState ! = newState | | previousStatus ! = newStatus ) { return validate ( newState ) ; } return false ; } protected abstract boolean validate ( ClusterState newState ) ; @Override public boolean apply ( ClusterChangedEvent changedEvent ) { if ( changedEvent . previousState ( ) . version ( ) ! = changedEvent . state ( ) . version ( ) ) { return validate ( changedEvent . state ( ) ) ; } return false ; } } public static abstract class EventPredicate implements ChangePredicate { @Override public boolean apply ( ClusterState previousState , ClusterState . ClusterStateStatus previousStatus , ClusterState newState , ClusterState . ClusterStateStatus newStatus ) { return previousState ! = newState | | previousStatus ! = newStatus ; } } static class ObservingContext { final public Listener listener ; final public ChangePredicate changePredicate ; public ObservingContext ( Listener listener , ChangePredicate changePredicate ) { this . listener = listener ; this . changePredicate = changePredicate ; } } static class ObservedState { final public ClusterState clusterState ; final public ClusterState . ClusterStateStatus status ; public ObservedState ( ClusterState clusterState ) { this . clusterState = clusterState ; this . status = clusterState . status ( ) ; } @Override public String toString ( ) { return <str> + clusterState . version ( ) + <str> + status + <str> ; } } } 
