package com . google . common . util . concurrent ; import static com . google . common . collect . Sets . newConcurrentHashSet ; import static java . util . concurrent . atomic . AtomicIntegerFieldUpdater . newUpdater ; import static java . util . concurrent . atomic . AtomicReferenceFieldUpdater . newUpdater ; import com . google . common . annotations . GwtCompatible ; import java . util . Set ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; @GwtCompatible ( emulated = true ) abstract class AggregateFutureState { @SuppressWarnings ( { <str> , <str> } ) private static final AtomicReferenceFieldUpdater < AggregateFutureState , Set < Throwable > > SEEN_EXCEPTIONS_UDPATER = newUpdater ( AggregateFutureState . class , ( Class ) Set . class , <str> ) ; private static final AtomicIntegerFieldUpdater < AggregateFutureState > REMAINING_COUNT_UPDATER = newUpdater ( AggregateFutureState . class , <str> ) ; private volatile Set < Throwable > seenExceptions = null ; @SuppressWarnings ( <str> ) private volatile int remaining ; AggregateFutureState ( int remainingFutures ) { this . remaining = remainingFutures ; } final Set < Throwable > getOrInitSeenExceptions ( ) { Set < Throwable > seenExceptionsLocal = seenExceptions ; if ( seenExceptionsLocal = = null ) { seenExceptionsLocal = newConcurrentHashSet ( ) ; addInitialException ( seenExceptionsLocal ) ; SEEN_EXCEPTIONS_UDPATER . compareAndSet ( this , null , seenExceptionsLocal ) ; seenExceptionsLocal = seenExceptions ; } return seenExceptionsLocal ; } abstract void addInitialException ( Set < Throwable > seen ) ; final int decrementRemainingAndGet ( ) { return REMAINING_COUNT_UPDATER . decrementAndGet ( this ) ; } } 
