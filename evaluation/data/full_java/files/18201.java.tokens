package com . badlogic . gdx . math ; import java . util . Random ; public class RandomXS128 extends Random { private static final double NORM_DOUBLE = <float> / ( <int> < < <int> ) ; private static final double NORM_FLOAT = <float> / ( <int> < < <int> ) ; private long seed0 ; private long seed1 ; public RandomXS128 ( ) { setSeed ( new Random ( ) . nextLong ( ) ) ; } public RandomXS128 ( long seed ) { setSeed ( seed ) ; } public RandomXS128 ( long seed0 , long seed1 ) { setState ( seed0 , seed1 ) ; } @Override public long nextLong ( ) { long s1 = this . seed0 ; final long s0 = this . seed1 ; this . seed0 = s0 ; s1 ^ = s1 < < <int> ; return ( this . seed1 = ( s1 ^ s0 ^ ( s1 > > > <int> ) ^ ( s0 > > > <int> ) ) ) + s0 ; } @Override protected final int next ( int bits ) { return ( int ) ( nextLong ( ) & ( ( <int> < < bits ) - <int> ) ) ; } @Override public int nextInt ( ) { return ( int ) nextLong ( ) ; } @Override public int nextInt ( final int n ) { return ( int ) nextLong ( n ) ; } public long nextLong ( final long n ) { if ( n < = <int> ) throw new IllegalArgumentException ( <str> ) ; for ( ; ; ) { final long bits = nextLong ( ) > > > <int> ; final long value = bits % n ; if ( bits - value + ( n - <int> ) > = <int> ) return value ; } } @Override public double nextDouble ( ) { return ( nextLong ( ) > > > <int> ) * NORM_DOUBLE ; } @Override public float nextFloat ( ) { return ( float ) ( ( nextLong ( ) > > > <int> ) * NORM_FLOAT ) ; } @Override public boolean nextBoolean ( ) { return ( nextLong ( ) & <int> ) ! = <int> ; } @Override public void nextBytes ( final byte [ ] bytes ) { int n = <int> ; int i = bytes . length ; while ( i ! = <int> ) { n = i < <int> ? i : <int> ; for ( long bits = nextLong ( ) ; n - - ! = <int> ; bits > > = <int> ) bytes [ - - i ] = ( byte ) bits ; } } @Override public void setSeed ( final long seed ) { long seed0 = murmurHash3 ( seed = = <int> ? Long . MIN_VALUE : seed ) ; setState ( seed0 , murmurHash3 ( seed0 ) ) ; } public void setState ( final long seed0 , final long seed1 ) { this . seed0 = seed0 ; this . seed1 = seed1 ; } public long getState ( int seed ) { return seed = = <int> ? seed0 : seed1 ; } private final static long murmurHash3 ( long x ) { x ^ = x > > > <int> ; x * = <hex> ; x ^ = x > > > <int> ; x * = <hex> ; x ^ = x > > > <int> ; return x ; } } 
