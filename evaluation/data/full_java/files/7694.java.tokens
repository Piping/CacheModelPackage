package org . elasticsearch . watcher ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . Arrays ; public class FileWatcher extends AbstractResourceWatcher < FileChangesListener > { private FileObserver rootFileObserver ; private Path file ; private static final ESLogger logger = Loggers . getLogger ( FileWatcher . class ) ; public FileWatcher ( Path file ) { this . file = file ; rootFileObserver = new FileObserver ( file ) ; } public void clearState ( ) { rootFileObserver = new FileObserver ( file ) ; try { rootFileObserver . init ( false ) ; } catch ( IOException e ) { } } @Override protected void doInit ( ) throws IOException { rootFileObserver . init ( true ) ; } @Override protected void doCheckAndNotify ( ) throws IOException { rootFileObserver . checkAndNotify ( ) ; } private static FileObserver [ ] EMPTY_DIRECTORY = new FileObserver [ <int> ] ; private class FileObserver { private Path file ; private boolean exists ; private long length ; private long lastModified ; private boolean isDirectory ; private FileObserver [ ] children ; public FileObserver ( Path file ) { this . file = file ; } public void checkAndNotify ( ) throws IOException { boolean prevExists = exists ; boolean prevIsDirectory = isDirectory ; long prevLength = length ; long prevLastModified = lastModified ; exists = Files . exists ( file ) ; if ( exists ) { BasicFileAttributes attributes = Files . readAttributes ( file , BasicFileAttributes . class ) ; isDirectory = attributes . isDirectory ( ) ; if ( isDirectory ) { length = <int> ; lastModified = <int> ; } else { length = attributes . size ( ) ; lastModified = attributes . lastModifiedTime ( ) . toMillis ( ) ; } } else { isDirectory = false ; length = <int> ; lastModified = <int> ; } if ( prevExists ) { if ( exists ) { if ( isDirectory ) { if ( prevIsDirectory ) { updateChildren ( ) ; } else { onFileDeleted ( ) ; onDirectoryCreated ( false ) ; } } else { if ( prevIsDirectory ) { onDirectoryDeleted ( ) ; onFileCreated ( false ) ; } else { if ( prevLastModified ! = lastModified | | prevLength ! = length ) { onFileChanged ( ) ; } } } } else { if ( prevIsDirectory ) { onDirectoryDeleted ( ) ; } else { onFileDeleted ( ) ; } } } else { if ( exists ) { if ( isDirectory ) { onDirectoryCreated ( false ) ; } else { onFileCreated ( false ) ; } } } } private void init ( boolean initial ) throws IOException { exists = Files . exists ( file ) ; if ( exists ) { BasicFileAttributes attributes = Files . readAttributes ( file , BasicFileAttributes . class ) ; isDirectory = attributes . isDirectory ( ) ; if ( isDirectory ) { onDirectoryCreated ( initial ) ; } else { length = attributes . size ( ) ; lastModified = attributes . lastModifiedTime ( ) . toMillis ( ) ; onFileCreated ( initial ) ; } } } private FileObserver createChild ( Path file , boolean initial ) throws IOException { FileObserver child = new FileObserver ( file ) ; child . init ( initial ) ; return child ; } private Path [ ] listFiles ( ) throws IOException { final Path [ ] files = FileSystemUtils . files ( file ) ; Arrays . sort ( files ) ; return files ; } private FileObserver [ ] listChildren ( boolean initial ) throws IOException { Path [ ] files = listFiles ( ) ; if ( files ! = null & & files . length > <int> ) { FileObserver [ ] children = new FileObserver [ files . length ] ; for ( int i = <int> ; i < files . length ; i + + ) { children [ i ] = createChild ( files [ i ] , initial ) ; } return children ; } else { return EMPTY_DIRECTORY ; } } private void updateChildren ( ) throws IOException { Path [ ] files = listFiles ( ) ; if ( files ! = null & & files . length > <int> ) { FileObserver [ ] newChildren = new FileObserver [ files . length ] ; int child = <int> ; int file = <int> ; while ( file < files . length | | child < children . length ) { int compare ; if ( file > = files . length ) { compare = - <int> ; } else if ( child > = children . length ) { compare = <int> ; } else { compare = children [ child ] . file . compareTo ( files [ file ] ) ; } if ( compare = = <int> ) { children [ child ] . checkAndNotify ( ) ; newChildren [ file ] = children [ child ] ; file + + ; child + + ; } else { if ( compare > <int> ) { newChildren [ file ] = createChild ( files [ file ] , false ) ; file + + ; } else { deleteChild ( child ) ; child + + ; } } } children = newChildren ; } else { for ( int child = <int> ; child < children . length ; child + + ) { deleteChild ( child ) ; } children = EMPTY_DIRECTORY ; } } private void deleteChild ( int child ) { if ( children [ child ] . exists ) { if ( children [ child ] . isDirectory ) { children [ child ] . onDirectoryDeleted ( ) ; } else { children [ child ] . onFileDeleted ( ) ; } } } private void onFileCreated ( boolean initial ) { for ( FileChangesListener listener : listeners ( ) ) { try { if ( initial ) { listener . onFileInit ( file ) ; } else { listener . onFileCreated ( file ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } private void onFileDeleted ( ) { for ( FileChangesListener listener : listeners ( ) ) { try { listener . onFileDeleted ( file ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } private void onFileChanged ( ) { for ( FileChangesListener listener : listeners ( ) ) { try { listener . onFileChanged ( file ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } private void onDirectoryCreated ( boolean initial ) throws IOException { for ( FileChangesListener listener : listeners ( ) ) { try { if ( initial ) { listener . onDirectoryInit ( file ) ; } else { listener . onDirectoryCreated ( file ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } children = listChildren ( initial ) ; } private void onDirectoryDeleted ( ) { for ( int child = <int> ; child < children . length ; child + + ) { deleteChild ( child ) ; } for ( FileChangesListener listener : listeners ( ) ) { try { listener . onDirectoryDeleted ( file ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } } } 
