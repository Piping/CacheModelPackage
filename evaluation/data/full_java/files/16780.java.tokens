package com . badlogic . gdx . backends . lwjgl ; import java . nio . ByteOrder ; import java . nio . IntBuffer ; import org . lwjgl . LWJGLException ; import org . lwjgl . input . Mouse ; import com . badlogic . gdx . graphics . Cursor ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class LwjglCursor implements Cursor { public static void resetCursor ( ) { try { Mouse . setNativeCursor ( null ) ; } catch ( LWJGLException e ) { throw new GdxRuntimeException ( <str> , e ) ; } } private org . lwjgl . input . Cursor lwjglCursor = null ; public LwjglCursor ( Pixmap pixmap , int xHotspot , int yHotspot ) { try { if ( pixmap = = null ) { lwjglCursor = null ; return ; } if ( pixmap . getFormat ( ) ! = Pixmap . Format . RGBA8888 ) { throw new GdxRuntimeException ( <str> ) ; } if ( ( pixmap . getWidth ( ) & ( pixmap . getWidth ( ) - <int> ) ) ! = <int> ) { throw new GdxRuntimeException ( <str> + pixmap . getWidth ( ) + <str> ) ; } if ( ( pixmap . getHeight ( ) & ( pixmap . getHeight ( ) - <int> ) ) ! = <int> ) { throw new GdxRuntimeException ( <str> + pixmap . getHeight ( ) + <str> ) ; } if ( xHotspot < <int> | | xHotspot > = pixmap . getWidth ( ) ) { throw new GdxRuntimeException ( <str> + xHotspot + <str> + pixmap . getWidth ( ) + <str> ) ; } if ( yHotspot < <int> | | yHotspot > = pixmap . getHeight ( ) ) { throw new GdxRuntimeException ( <str> + yHotspot + <str> + pixmap . getHeight ( ) + <str> ) ; } IntBuffer pixelBuffer = pixmap . getPixels ( ) . asIntBuffer ( ) ; int [ ] pixelsRGBA = new int [ pixelBuffer . capacity ( ) ] ; pixelBuffer . get ( pixelsRGBA ) ; int [ ] pixelsARGBflipped = new int [ pixelBuffer . capacity ( ) ] ; int pixel ; if ( pixelBuffer . order ( ) = = ByteOrder . BIG_ENDIAN ) { for ( int y = <int> ; y < pixmap . getHeight ( ) ; + + y ) { for ( int x = <int> ; x < pixmap . getWidth ( ) ; + + x ) { pixel = pixelsRGBA [ x + ( y * pixmap . getWidth ( ) ) ] ; pixelsARGBflipped [ x + ( ( pixmap . getHeight ( ) - <int> - y ) * pixmap . getWidth ( ) ) ] = ( ( pixel > > <int> ) & <hex> ) | ( ( pixel < < <int> ) & <hex> ) ; } } } else { for ( int y = <int> ; y < pixmap . getHeight ( ) ; + + y ) { for ( int x = <int> ; x < pixmap . getWidth ( ) ; + + x ) { pixel = pixelsRGBA [ x + ( y * pixmap . getWidth ( ) ) ] ; pixelsARGBflipped [ x + ( ( pixmap . getHeight ( ) - <int> - y ) * pixmap . getWidth ( ) ) ] = ( ( pixel & <hex> ) < < <int> ) | ( ( pixel & <hex> ) > > <int> ) | ( pixel & <hex> ) ; } } } lwjglCursor = new org . lwjgl . input . Cursor ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , xHotspot , pixmap . getHeight ( ) - yHotspot - <int> , <int> , IntBuffer . wrap ( pixelsARGBflipped ) , null ) ; } catch ( LWJGLException e ) { throw new GdxRuntimeException ( <str> , e ) ; } } @Override public void setSystemCursor ( ) { try { Mouse . setNativeCursor ( lwjglCursor ) ; } catch ( LWJGLException e ) { throw new GdxRuntimeException ( <str> , e ) ; } } } 
