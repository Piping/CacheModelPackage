package org . nd4j . linalg . dataset ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . ndarray . BaseNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . rng . DefaultRandom ; import org . nd4j . linalg . dataset . api . iterator . DataSetIterator ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . util . FeatureUtil ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Random ; import static org . junit . Assert . * ; public class DataSetTest extends BaseNd4jTest { public DataSetTest ( ) { } public DataSetTest ( String name ) { super ( name ) ; } public DataSetTest ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public DataSetTest ( Nd4jBackend backend ) { super ( backend ) ; } @Test public void testViewIterator ( ) { DataSetIterator iter = new ViewIterator ( new IrisDataSetIterator ( <int> , <int> ) . next ( ) , <int> ) ; assertTrue ( iter . hasNext ( ) ) ; int count = <int> ; while ( iter . hasNext ( ) ) { DataSet next = iter . next ( ) ; count + + ; assertArrayEquals ( new int [ ] { <int> , <int> } , next . getFeatureMatrix ( ) . shape ( ) ) ; } assertFalse ( iter . hasNext ( ) ) ; assertEquals ( <int> , count ) ; iter . reset ( ) ; assertTrue ( iter . hasNext ( ) ) ; } @Test public void testPersist ( ) { DataSet iris = new IrisDataSetIterator ( <int> , <int> ) . next ( ) ; iris . save ( new File ( <str> ) ) ; DataSet load = new DataSet ( ) ; load . load ( new File ( <str> ) ) ; new File ( <str> ) . deleteOnExit ( ) ; assertEquals ( iris , load ) ; } @Test public void testSplitTestAndTrain ( ) throws Exception { INDArray labels = FeatureUtil . toOutcomeMatrix ( new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> ) ; DataSet data = new DataSet ( Nd4j . rand ( <int> , <int> ) , labels ) ; SplitTestAndTrain train = data . splitTestAndTrain ( <int> , new Random ( <int> ) ) ; assertEquals ( train . getTrain ( ) . getLabels ( ) . length ( ) , <int> ) ; SplitTestAndTrain train2 = data . splitTestAndTrain ( <int> , new Random ( <int> ) ) ; assertEquals ( getFailureMessage ( ) , train . getTrain ( ) . getFeatureMatrix ( ) , train2 . getTrain ( ) . getFeatureMatrix ( ) ) ; DataSet x0 = new IrisDataSetIterator ( <int> , <int> ) . next ( ) ; SplitTestAndTrain testAndTrain = x0 . splitTestAndTrain ( <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , testAndTrain . getTrain ( ) . getFeatureMatrix ( ) . shape ( ) ) ; assertEquals ( x0 . getFeatureMatrix ( ) . getRows ( ArrayUtil . range ( <int> , <int> ) ) , testAndTrain . getTrain ( ) . getFeatureMatrix ( ) ) ; assertEquals ( x0 . getLabels ( ) . getRows ( ArrayUtil . range ( <int> , <int> ) ) , testAndTrain . getTrain ( ) . getLabels ( ) ) ; } @Test public void testLabelCounts ( ) { DataSet x0 = new IrisDataSetIterator ( <int> , <int> ) . next ( ) ; assertEquals ( getFailureMessage ( ) , <int> , x0 . get ( <int> ) . outcome ( ) ) ; assertEquals ( getFailureMessage ( ) , <int> , x0 . get ( <int> ) . outcome ( ) ) ; assertEquals ( getFailureMessage ( ) , <int> , x0 . get ( <int> ) . outcome ( ) ) ; Map < Integer , Double > counts = x0 . labelCounts ( ) ; assertEquals ( getFailureMessage ( ) , <int> , counts . get ( <int> ) , <float> ) ; assertEquals ( getFailureMessage ( ) , <int> , counts . get ( <int> ) , <float> ) ; assertEquals ( getFailureMessage ( ) , <int> , counts . get ( <int> ) , <float> ) ; } @Test public void testTimeSeriesMerge ( ) { int numExamples = <int> ; int inSize = <int> ; int labelSize = <int> ; int tsLength = <int> ; Nd4j . getRandom ( ) . setSeed ( <int> ) ; List < DataSet > list = new ArrayList < > ( numExamples ) ; for ( int i = <int> ; i < numExamples ; i + + ) { INDArray in = Nd4j . rand ( new int [ ] { <int> , inSize , tsLength } ) ; INDArray out = Nd4j . rand ( new int [ ] { <int> , labelSize , tsLength } ) ; list . add ( new DataSet ( in , out ) ) ; } DataSet merged = DataSet . merge ( list ) ; assertEquals ( numExamples , merged . numExamples ( ) ) ; INDArray f = merged . getFeatures ( ) ; INDArray l = merged . getLabels ( ) ; assertArrayEquals ( new int [ ] { numExamples , inSize , tsLength } , f . shape ( ) ) ; assertArrayEquals ( new int [ ] { numExamples , labelSize , tsLength } , l . shape ( ) ) ; for ( int i = <int> ; i < numExamples ; i + + ) { DataSet exp = list . get ( i ) ; INDArray expIn = exp . getFeatureMatrix ( ) ; INDArray expL = exp . getLabels ( ) ; INDArray fSubset = f . get ( NDArrayIndex . interval ( i , i + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; INDArray lSubset = l . get ( NDArrayIndex . interval ( i , i + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; assertEquals ( expIn , fSubset ) ; assertEquals ( expL , lSubset ) ; } } @Override public char ordering ( ) { return <str> ; } } 
