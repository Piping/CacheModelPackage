package com . google . common . graph ; import static com . google . common . graph . Graphs . MULTIGRAPH ; import static com . google . common . truth . Truth . assertThat ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . junit . runners . Parameterized ; import org . junit . runners . Parameterized . Parameters ; import java . util . Arrays ; import java . util . Collection ; @RunWith ( Parameterized . class ) public final class GraphEqualsTest { private static final Integer N1 = <int> ; private static final Integer N2 = <int> ; private static final Integer N3 = <int> ; private static final String E12 = <str> ; private static final String E12_A = <str> ; private static final String E13 = <str> ; enum GraphType { UNDIRECTED , DIRECTED , HYPER } private final GraphType graphType ; private final Graph < Integer , String > graph ; @Parameters public static Collection < Object [ ] > parameters ( ) { return Arrays . asList ( new Object [ ] [ ] { { GraphType . UNDIRECTED } , { GraphType . DIRECTED } } ) ; } public GraphEqualsTest ( GraphType graphType ) { this . graphType = graphType ; this . graph = createGraph ( ) ; } private Graph < Integer , String > createGraph ( ) { return createGraph ( Graphs . config ( ) ) ; } private Graph < Integer , String > createGraph ( GraphConfig config ) { switch ( graphType ) { case UNDIRECTED : return Graphs . createUndirected ( config ) ; case DIRECTED : return Graphs . createDirected ( config ) ; default : throw new IllegalStateException ( <str> + graphType ) ; } } @Test public void equals_nodeSetsDiffer ( ) { graph . addNode ( N1 ) ; Graph < Integer , String > g2 = createGraph ( ) ; g2 . addNode ( N2 ) ; assertThat ( graph . equals ( g2 ) ) . isFalse ( ) ; } @Test public void equals_edgeSetsDiffer ( ) { graph . addEdge ( E12 , N1 , N2 ) ; Graph < Integer , String > g2 = createGraph ( ) ; g2 . addEdge ( E13 , N1 , N2 ) ; assertThat ( graph . equals ( g2 ) ) . isFalse ( ) ; } @Test public void equals_typesDiffer ( ) { graph . addEdge ( E12 , N1 , N2 ) ; Graph < Integer , String > g2 ; switch ( graphType ) { case UNDIRECTED : g2 = Graphs . createDirected ( ) ; break ; case DIRECTED : g2 = Graphs . createUndirected ( ) ; break ; default : throw new IllegalStateException ( <str> + graphType ) ; } g2 . addEdge ( E12 , N1 , N2 ) ; assertThat ( graph . equals ( g2 ) ) . isFalse ( ) ; } @Test public void equals_connectionsDiffer ( ) { graph . addEdge ( E12 , N1 , N2 ) ; graph . addEdge ( E13 , N1 , N3 ) ; Graph < Integer , String > g2 = createGraph ( ) ; g2 . addEdge ( E13 , N1 , N2 ) ; g2 . addEdge ( E12 , N1 , N3 ) ; assertThat ( graph . equals ( g2 ) ) . isFalse ( ) ; } @Test public void equals_configsDiffer ( ) { graph . addEdge ( E12 , N1 , N2 ) ; Graph < Integer , String > g2 = createGraph ( MULTIGRAPH . noSelfLoops ( ) ) ; g2 . addEdge ( E12 , N1 , N2 ) ; assertThat ( graph . equals ( g2 ) ) . isTrue ( ) ; } @Test public void equals_edgeAddOrdersDiffer ( ) { Graph < Integer , String > g1 = createGraph ( MULTIGRAPH ) ; Graph < Integer , String > g2 = createGraph ( MULTIGRAPH ) ; g1 . addEdge ( E12 , N1 , N2 ) ; g1 . addEdge ( E12_A , N1 , N2 ) ; g2 . addEdge ( E12_A , N1 , N2 ) ; g2 . addEdge ( E12 , N1 , N2 ) ; assertThat ( g1 . equals ( g2 ) ) . isTrue ( ) ; } } 
