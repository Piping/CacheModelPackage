package org . elasticsearch . index . query ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . util . CollectionUtils ; import java . io . IOException ; public enum GeoValidationMethod implements Writeable < GeoValidationMethod > { COERCE , IGNORE_MALFORMED , STRICT ; public static final GeoValidationMethod DEFAULT = STRICT ; public static final boolean DEFAULT_LENIENT_PARSING = ( DEFAULT ! = STRICT ) ; private static final GeoValidationMethod PROTOTYPE = DEFAULT ; @Override public GeoValidationMethod readFrom ( StreamInput in ) throws IOException { return GeoValidationMethod . values ( ) [ in . readVInt ( ) ] ; } public static GeoValidationMethod readGeoValidationMethodFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } public static GeoValidationMethod fromString ( String op ) { for ( GeoValidationMethod method : GeoValidationMethod . values ( ) ) { if ( method . name ( ) . equalsIgnoreCase ( op ) ) { return method ; } } throw new IllegalArgumentException ( <str> + CollectionUtils . arrayAsArrayList ( GeoValidationMethod . values ( ) ) + <str> + op + <str> ) ; } public static boolean isIgnoreMalformed ( GeoValidationMethod method ) { return ( method = = GeoValidationMethod . IGNORE_MALFORMED | | method = = GeoValidationMethod . COERCE ) ; } public static boolean isCoerce ( GeoValidationMethod method ) { return method = = GeoValidationMethod . COERCE ; } public static GeoValidationMethod infer ( boolean coerce , boolean ignoreMalformed ) { if ( coerce ) { return GeoValidationMethod . COERCE ; } else if ( ignoreMalformed ) { return GeoValidationMethod . IGNORE_MALFORMED ; } else { return GeoValidationMethod . STRICT ; } } } 
