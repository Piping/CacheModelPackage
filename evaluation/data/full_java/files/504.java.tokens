package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public interface RangeTombstoneMarker extends Unfiltered { @Override public RangeTombstone . Bound clustering ( ) ; public boolean isBoundary ( ) ; public boolean isOpen ( boolean reversed ) ; public boolean isClose ( boolean reversed ) ; public DeletionTime openDeletionTime ( boolean reversed ) ; public DeletionTime closeDeletionTime ( boolean reversed ) ; public boolean openIsInclusive ( boolean reversed ) ; public boolean closeIsInclusive ( boolean reversed ) ; public RangeTombstone . Bound openBound ( boolean reversed ) ; public RangeTombstone . Bound closeBound ( boolean reversed ) ; public RangeTombstoneMarker copy ( AbstractAllocator allocator ) ; public static class Merger { private final DeletionTime partitionDeletion ; private final boolean reversed ; private RangeTombstone . Bound bound ; private final RangeTombstoneMarker [ ] markers ; private final DeletionTime [ ] openMarkers ; private int biggestOpenMarker = - <int> ; public Merger ( int size , DeletionTime partitionDeletion , boolean reversed ) { this . partitionDeletion = partitionDeletion ; this . reversed = reversed ; this . markers = new RangeTombstoneMarker [ size ] ; this . openMarkers = new DeletionTime [ size ] ; } public void clear ( ) { Arrays . fill ( markers , null ) ; } public void add ( int i , RangeTombstoneMarker marker ) { bound = marker . clustering ( ) ; markers [ i ] = marker ; } public RangeTombstoneMarker merge ( ) { DeletionTime previousDeletionTimeInMerged = currentOpenDeletionTimeInMerged ( ) ; updateOpenMarkers ( ) ; DeletionTime newDeletionTimeInMerged = currentOpenDeletionTimeInMerged ( ) ; if ( previousDeletionTimeInMerged . equals ( newDeletionTimeInMerged ) ) return null ; boolean isBeforeClustering = bound . kind ( ) . comparedToClustering < <int> ; if ( reversed ) isBeforeClustering = ! isBeforeClustering ; ByteBuffer [ ] values = bound . getRawValues ( ) ; RangeTombstoneMarker merged ; if ( previousDeletionTimeInMerged . isLive ( ) ) { merged = isBeforeClustering ? RangeTombstoneBoundMarker . inclusiveOpen ( reversed , values , newDeletionTimeInMerged ) : RangeTombstoneBoundMarker . exclusiveOpen ( reversed , values , newDeletionTimeInMerged ) ; } else if ( newDeletionTimeInMerged . isLive ( ) ) { merged = isBeforeClustering ? RangeTombstoneBoundMarker . exclusiveClose ( reversed , values , previousDeletionTimeInMerged ) : RangeTombstoneBoundMarker . inclusiveClose ( reversed , values , previousDeletionTimeInMerged ) ; } else { merged = isBeforeClustering ? RangeTombstoneBoundaryMarker . exclusiveCloseInclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) : RangeTombstoneBoundaryMarker . inclusiveCloseExclusiveOpen ( reversed , values , previousDeletionTimeInMerged , newDeletionTimeInMerged ) ; } return merged ; } public RangeTombstoneMarker [ ] mergedMarkers ( ) { return markers ; } private DeletionTime currentOpenDeletionTimeInMerged ( ) { if ( biggestOpenMarker < <int> ) return DeletionTime . LIVE ; DeletionTime biggestDeletionTime = openMarkers [ biggestOpenMarker ] ; return partitionDeletion . supersedes ( biggestDeletionTime ) ? DeletionTime . LIVE : biggestDeletionTime ; } private void updateOpenMarkers ( ) { for ( int i = <int> ; i < markers . length ; i + + ) { RangeTombstoneMarker marker = markers [ i ] ; if ( marker = = null ) continue ; if ( marker . isOpen ( reversed ) ) openMarkers [ i ] = marker . openDeletionTime ( reversed ) ; else openMarkers [ i ] = null ; } biggestOpenMarker = - <int> ; for ( int i = <int> ; i < openMarkers . length ; i + + ) { if ( openMarkers [ i ] ! = null & & ( biggestOpenMarker < <int> | | openMarkers [ i ] . supersedes ( openMarkers [ biggestOpenMarker ] ) ) ) biggestOpenMarker = i ; } } public DeletionTime activeDeletion ( ) { DeletionTime openMarker = currentOpenDeletionTimeInMerged ( ) ; return openMarker . isLive ( ) ? partitionDeletion : openMarker ; } } } 
