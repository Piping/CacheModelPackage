package io . netty . handler . codec . http . websocketx ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelPipeline ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . ssl . SslHandler ; import static io . netty . handler . codec . http . HttpUtil . * ; import static io . netty . handler . codec . http . HttpMethod . * ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . * ; class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter { private final String websocketPath ; private final String subprotocols ; private final boolean allowExtensions ; private final int maxFramePayloadSize ; private final boolean allowMaskMismatch ; WebSocketServerProtocolHandshakeHandler ( String websocketPath , String subprotocols , boolean allowExtensions , int maxFrameSize , boolean allowMaskMismatch ) { this . websocketPath = websocketPath ; this . subprotocols = subprotocols ; this . allowExtensions = allowExtensions ; maxFramePayloadSize = maxFrameSize ; this . allowMaskMismatch = allowMaskMismatch ; } @Override public void channelRead ( final ChannelHandlerContext ctx , Object msg ) throws Exception { FullHttpRequest req = ( FullHttpRequest ) msg ; try { if ( req . method ( ) ! = GET ) { sendHttpResponse ( ctx , req , new DefaultFullHttpResponse ( HTTP_1_1 , FORBIDDEN ) ) ; return ; } final WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( getWebSocketLocation ( ctx . pipeline ( ) , req , websocketPath ) , subprotocols , allowExtensions , maxFramePayloadSize , allowMaskMismatch ) ; final WebSocketServerHandshaker handshaker = wsFactory . newHandshaker ( req ) ; if ( handshaker = = null ) { WebSocketServerHandshakerFactory . sendUnsupportedVersionResponse ( ctx . channel ( ) ) ; } else { final ChannelFuture handshakeFuture = handshaker . handshake ( ctx . channel ( ) , req ) ; handshakeFuture . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { ctx . fireExceptionCaught ( future . cause ( ) ) ; } else { ctx . fireUserEventTriggered ( WebSocketServerProtocolHandler . ServerHandshakeStateEvent . HANDSHAKE_COMPLETE ) ; } } } ) ; WebSocketServerProtocolHandler . setHandshaker ( ctx . channel ( ) , handshaker ) ; ctx . pipeline ( ) . replace ( this , <str> , WebSocketServerProtocolHandler . forbiddenHttpRequestResponder ( ) ) ; } } finally { req . release ( ) ; } } private static void sendHttpResponse ( ChannelHandlerContext ctx , HttpRequest req , HttpResponse res ) { ChannelFuture f = ctx . channel ( ) . writeAndFlush ( res ) ; if ( ! isKeepAlive ( req ) | | res . status ( ) . code ( ) ! = <int> ) { f . addListener ( ChannelFutureListener . CLOSE ) ; } } private static String getWebSocketLocation ( ChannelPipeline cp , HttpRequest req , String path ) { String protocol = <str> ; if ( cp . get ( SslHandler . class ) ! = null ) { protocol = <str> ; } return protocol + <str> + req . headers ( ) . get ( HttpHeaderNames . HOST ) + path ; } } 
