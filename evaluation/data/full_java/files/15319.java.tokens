package org . gradle . api . tasks . compile ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . ConventionTask ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . api . internal . tasks . compile . GroovyJavaJointCompileSpec ; import org . gradle . api . tasks . WorkResult ; import org . gradle . util . GFileUtils ; import org . gradle . util . JUnit4GroovyMockery ; import org . hamcrest . core . IsNull ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . File ; import static org . hamcrest . CoreMatchers . containsString ; import static org . junit . Assert . * ; @RunWith ( org . jmock . integration . junit4 . JMock . class ) public class GroovyCompileTest extends AbstractCompileTest { private GroovyCompile testObj ; Compiler < GroovyJavaJointCompileSpec > groovyCompilerMock ; JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; public AbstractCompile getCompile ( ) { return testObj ; } @Before public void setUp ( ) { testObj = createTask ( GroovyCompile . class ) ; groovyCompilerMock = context . mock ( Compiler . class ) ; testObj . setCompiler ( groovyCompilerMock ) ; GFileUtils . touch ( new File ( srcDir , <str> ) ) ; } public ConventionTask getTask ( ) { return testObj ; } public void testExecute ( final int numFilesCompiled ) { setUpMocksAndAttributes ( testObj , false ) ; context . checking ( new Expectations ( ) { { WorkResult result = context . mock ( WorkResult . class ) ; one ( groovyCompilerMock ) . execute ( ( GroovyJavaJointCompileSpec ) with ( IsNull . notNullValue ( ) ) ) ; will ( returnValue ( result ) ) ; allowing ( result ) . getDidWork ( ) ; will ( returnValue ( numFilesCompiled > <int> ) ) ; } } ) ; testObj . compile ( ) ; } @Test public void testExecuteDoingWork ( ) { testExecute ( <int> ) ; assertTrue ( testObj . getDidWork ( ) ) ; } @Test public void testExecuteNotDoingWork ( ) { testExecute ( <int> ) ; assertFalse ( testObj . getDidWork ( ) ) ; } @Test public void testMoansIfGroovyClasspathIsEmpty ( ) { setUpMocksAndAttributes ( testObj , true ) ; try { testObj . compile ( ) ; fail ( ) ; } catch ( InvalidUserDataException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } void setUpMocksAndAttributes ( GroovyCompile compile , final boolean groovyClasspathEmpty ) { super . setUpMocksAndAttributes ( compile ) ; final FileCollection groovyClasspathCollection = context . mock ( FileCollection . class ) ; context . checking ( new Expectations ( ) { { allowing ( groovyClasspathCollection ) . isEmpty ( ) ; will ( returnValue ( groovyClasspathEmpty ) ) ; } } ) ; compile . setGroovyClasspath ( groovyClasspathCollection ) ; compile . source ( srcDir ) ; } } 
