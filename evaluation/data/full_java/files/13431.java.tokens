package org . gradle . api . internal . tasks . compile ; import com . google . common . base . Joiner ; import com . google . common . collect . Lists ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . file . collections . SimpleFileCollection ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . WorkResult ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; public class NormalizingGroovyCompiler implements Compiler < GroovyJavaJointCompileSpec > { private static final Logger LOGGER = Logging . getLogger ( NormalizingGroovyCompiler . class ) ; private final Compiler < GroovyJavaJointCompileSpec > delegate ; public NormalizingGroovyCompiler ( Compiler < GroovyJavaJointCompileSpec > delegate ) { this . delegate = delegate ; } public WorkResult execute ( GroovyJavaJointCompileSpec spec ) { resolveAndFilterSourceFiles ( spec ) ; resolveClasspath ( spec ) ; resolveNonStringsInCompilerArgs ( spec ) ; logSourceFiles ( spec ) ; logCompilerArguments ( spec ) ; return delegateAndHandleErrors ( spec ) ; } private void resolveAndFilterSourceFiles ( final GroovyJavaJointCompileSpec spec ) { FileCollection filtered = spec . getSource ( ) . filter ( new Spec < File > ( ) { public boolean isSatisfiedBy ( File element ) { for ( String fileExtension : spec . getGroovyCompileOptions ( ) . getFileExtensions ( ) ) { if ( element . getName ( ) . endsWith ( <str> + fileExtension ) ) { return true ; } } return false ; } } ) ; spec . setSource ( new SimpleFileCollection ( filtered . getFiles ( ) ) ) ; } private void resolveClasspath ( GroovyJavaJointCompileSpec spec ) { ArrayList < File > classPath = Lists . newArrayList ( spec . getClasspath ( ) ) ; classPath . add ( spec . getDestinationDir ( ) ) ; spec . setClasspath ( classPath ) ; spec . setGroovyClasspath ( Lists . newArrayList ( spec . getGroovyClasspath ( ) ) ) ; } private void resolveNonStringsInCompilerArgs ( GroovyJavaJointCompileSpec spec ) { spec . getCompileOptions ( ) . setCompilerArgs ( CollectionUtils . toStringList ( spec . getCompileOptions ( ) . getCompilerArgs ( ) ) ) ; } private void logSourceFiles ( GroovyJavaJointCompileSpec spec ) { if ( ! spec . getGroovyCompileOptions ( ) . isListFiles ( ) ) { return ; } StringBuilder builder = new StringBuilder ( ) ; builder . append ( <str> ) ; for ( File file : spec . getSource ( ) ) { builder . append ( <str> ) ; builder . append ( file ) ; } LOGGER . quiet ( builder . toString ( ) ) ; } private void logCompilerArguments ( GroovyJavaJointCompileSpec spec ) { if ( ! LOGGER . isDebugEnabled ( ) ) { return ; } List < String > compilerArgs = new JavaCompilerArgumentsBuilder ( spec ) . includeLauncherOptions ( true ) . includeSourceFiles ( true ) . build ( ) ; String joinedArgs = Joiner . on ( <str> ) . join ( compilerArgs ) ; LOGGER . debug ( <str> , joinedArgs ) ; } private WorkResult delegateAndHandleErrors ( GroovyJavaJointCompileSpec spec ) { try { return delegate . execute ( spec ) ; } catch ( CompilationFailedException e ) { if ( spec . getCompileOptions ( ) . isFailOnError ( ) ) { throw e ; } LOGGER . debug ( <str> ) ; return new SimpleWorkResult ( false ) ; } } } 
