package org . apache . cassandra . db . monitoring ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . UUID ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class MonitoringTaskTest { private static final long timeout = <int> ; private static final long MAX_SPIN_TIME_NANOS = TimeUnit . SECONDS . toNanos ( <int> ) ; public static final int REPORT_INTERVAL_MS = <int> ; public static final int MAX_TIMEDOUT_OPERATIONS = - <int> ; @BeforeClass public static void setup ( ) { MonitoringTask . instance = MonitoringTask . make ( REPORT_INTERVAL_MS , MAX_TIMEDOUT_OPERATIONS ) ; } private static final class TestMonitor extends MonitorableImpl { private final String name ; TestMonitor ( String name , ConstructionTime constructionTime , long timeout ) { this . name = name ; setMonitoringTime ( constructionTime , timeout ) ; } public String name ( ) { return name ; } @Override public String toString ( ) { return name ( ) ; } } private static void waitForOperationsToComplete ( Monitorable . . . operations ) throws InterruptedException { waitForOperationsToComplete ( Arrays . asList ( operations ) ) ; } private static void waitForOperationsToComplete ( List < Monitorable > operations ) throws InterruptedException { long timeout = operations . stream ( ) . map ( Monitorable : : timeout ) . reduce ( <int> L , Long : : max ) ; Thread . sleep ( timeout * <int> + ApproximateTime . precision ( ) ) ; long start = System . nanoTime ( ) ; while ( System . nanoTime ( ) - start < = MAX_SPIN_TIME_NANOS ) { long numInProgress = operations . stream ( ) . filter ( Monitorable : : isInProgress ) . count ( ) ; if ( numInProgress = = <int> ) return ; Thread . yield ( ) ; } } @Test public void testAbort ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . isAborted ( ) ) ; assertFalse ( operation . isCompleted ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testAbortIdemPotent ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . abort ( ) ) ; assertTrue ( operation . isAborted ( ) ) ; assertFalse ( operation . isCompleted ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testAbortCrossNode ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) , true ) , timeout ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . isAborted ( ) ) ; assertFalse ( operation . isCompleted ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testComplete ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; operation . complete ( ) ; waitForOperationsToComplete ( operation ) ; assertFalse ( operation . isAborted ( ) ) ; assertTrue ( operation . isCompleted ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testCompleteIdemPotent ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; operation . complete ( ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . complete ( ) ) ; assertFalse ( operation . isAborted ( ) ) ; assertTrue ( operation . isCompleted ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testReport ( ) throws InterruptedException { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . isAborted ( ) ) ; assertFalse ( operation . isCompleted ( ) ) ; MonitoringTask . instance . logFailedOperations ( ApproximateTime . currentTimeMillis ( ) ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testRealScheduling ( ) throws InterruptedException { MonitoringTask . instance = MonitoringTask . make ( <int> , - <int> ) ; try { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; waitForOperationsToComplete ( operation ) ; assertTrue ( operation . isAborted ( ) ) ; assertFalse ( operation . isCompleted ( ) ) ; Thread . sleep ( ApproximateTime . precision ( ) + <int> ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } finally { MonitoringTask . instance = MonitoringTask . make ( REPORT_INTERVAL_MS , MAX_TIMEDOUT_OPERATIONS ) ; } } @Test public void testMultipleThreads ( ) throws InterruptedException { final int opCount = <int> ; final ExecutorService executorService = Executors . newFixedThreadPool ( <int> ) ; final List < Monitorable > operations = Collections . synchronizedList ( new ArrayList < > ( opCount ) ) ; for ( int i = <int> ; i < opCount ; i + + ) { executorService . submit ( ( ) - > operations . add ( new TestMonitor ( UUID . randomUUID ( ) . toString ( ) , new ConstructionTime ( ) , timeout ) ) ) ; } executorService . shutdown ( ) ; assertTrue ( executorService . awaitTermination ( <int> , TimeUnit . SECONDS ) ) ; assertEquals ( opCount , operations . size ( ) ) ; waitForOperationsToComplete ( operations ) ; assertEquals ( opCount , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testZeroMaxTimedoutOperations ( ) throws InterruptedException { doTestMaxTimedoutOperations ( <int> , <int> , <int> ) ; } @Test public void testMaxTimedoutOperationsExceeded ( ) throws InterruptedException { doTestMaxTimedoutOperations ( <int> , <int> , <int> ) ; } private static void doTestMaxTimedoutOperations ( int maxTimedoutOperations , int numThreads , int numExpectedOperations ) throws InterruptedException { MonitoringTask . instance = MonitoringTask . make ( REPORT_INTERVAL_MS , maxTimedoutOperations ) ; try { final int threadCount = numThreads ; ExecutorService executorService = Executors . newFixedThreadPool ( threadCount ) ; final CountDownLatch finished = new CountDownLatch ( threadCount ) ; for ( int i = <int> ; i < threadCount ; i + + ) { final String operationName = <str> + Integer . toString ( i + <int> ) ; final int numTimes = i + <int> ; executorService . submit ( ( ) - > { try { for ( int j = <int> ; j < numTimes ; j + + ) { Monitorable operation = new TestMonitor ( operationName , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; waitForOperationsToComplete ( operation ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; fail ( <str> ) ; } finally { finished . countDown ( ) ; } } ) ; } finished . await ( ) ; assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; List < String > failedOperations = MonitoringTask . instance . getFailedOperations ( ) ; assertEquals ( numExpectedOperations , failedOperations . size ( ) ) ; if ( numExpectedOperations > <int> ) assertTrue ( failedOperations . get ( numExpectedOperations - <int> ) . startsWith ( <str> ) ) ; } finally { MonitoringTask . instance = MonitoringTask . make ( REPORT_INTERVAL_MS , MAX_TIMEDOUT_OPERATIONS ) ; } } @Test public void testMultipleThreadsSameName ( ) throws InterruptedException { final int threadCount = <int> ; final List < Monitorable > operations = new ArrayList < > ( threadCount ) ; ExecutorService executorService = Executors . newFixedThreadPool ( threadCount ) ; final CountDownLatch finished = new CountDownLatch ( threadCount ) ; for ( int i = <int> ; i < threadCount ; i + + ) { executorService . submit ( ( ) - > { try { Monitorable operation = new TestMonitor ( <str> , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; operations . add ( operation ) ; } finally { finished . countDown ( ) ; } } ) ; } finished . await ( ) ; assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; waitForOperationsToComplete ( operations ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } @Test public void testMultipleThreadsNoFailedOps ( ) throws InterruptedException { final int threadCount = <int> ; final List < Monitorable > operations = new ArrayList < > ( threadCount ) ; ExecutorService executorService = Executors . newFixedThreadPool ( threadCount ) ; final CountDownLatch finished = new CountDownLatch ( threadCount ) ; for ( int i = <int> ; i < threadCount ; i + + ) { executorService . submit ( ( ) - > { try { Monitorable operation = new TestMonitor ( <str> + Thread . currentThread ( ) . getName ( ) , new ConstructionTime ( System . currentTimeMillis ( ) ) , timeout ) ; operations . add ( operation ) ; operation . complete ( ) ; } finally { finished . countDown ( ) ; } } ) ; } finished . await ( ) ; assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; waitForOperationsToComplete ( operations ) ; assertEquals ( <int> , MonitoringTask . instance . getFailedOperations ( ) . size ( ) ) ; } } 
