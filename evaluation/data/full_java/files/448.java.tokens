package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . cql3 . Json ; import org . apache . cassandra . cql3 . Lists ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . serializers . CollectionSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . serializers . ListSerializer ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ListType < T > extends CollectionType < List < T > > { private static final Logger logger = LoggerFactory . getLogger ( ListType . class ) ; private static final Map < AbstractType < ? > , ListType > instances = new HashMap < > ( ) ; private static final Map < AbstractType < ? > , ListType > frozenInstances = new HashMap < > ( ) ; private final AbstractType < T > elements ; public final ListSerializer < T > serializer ; private final boolean isMultiCell ; public static ListType < ? > getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException { List < AbstractType < ? > > l = parser . getTypeParameters ( ) ; if ( l . size ( ) ! = <int> ) throw new ConfigurationException ( <str> ) ; return getInstance ( l . get ( <int> ) , true ) ; } public static synchronized < T > ListType < T > getInstance ( AbstractType < T > elements , boolean isMultiCell ) { Map < AbstractType < ? > , ListType > internMap = isMultiCell ? instances : frozenInstances ; ListType < T > t = internMap . get ( elements ) ; if ( t = = null ) { t = new ListType < T > ( elements , isMultiCell ) ; internMap . put ( elements , t ) ; } return t ; } private ListType ( AbstractType < T > elements , boolean isMultiCell ) { super ( ComparisonType . CUSTOM , Kind . LIST ) ; this . elements = elements ; this . serializer = ListSerializer . getInstance ( elements . getSerializer ( ) ) ; this . isMultiCell = isMultiCell ; } @Override public boolean references ( AbstractType < ? > check ) { return super . references ( check ) | | elements . references ( check ) ; } public AbstractType < T > getElementsType ( ) { return elements ; } public AbstractType < UUID > nameComparator ( ) { return TimeUUIDType . instance ; } public AbstractType < T > valueComparator ( ) { return elements ; } public ListSerializer < T > getSerializer ( ) { return serializer ; } @Override public AbstractType < ? > freeze ( ) { if ( isMultiCell ) return getInstance ( this . elements , false ) ; else return this ; } @Override public boolean isMultiCell ( ) { return isMultiCell ; } @Override public boolean isCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isCompatibleWith ( ( ( ListType ) previous ) . elements ) ; } @Override public boolean isValueCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isValueCompatibleWithInternal ( ( ( ListType ) previous ) . elements ) ; } @Override public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { return compareListOrSet ( elements , o1 , o2 ) ; } static int compareListOrSet ( AbstractType < ? > elementsComparator , ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? <int> : o2 . hasRemaining ( ) ? - <int> : <int> ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; int size1 = CollectionSerializer . readCollectionSize ( bb1 , <int> ) ; int size2 = CollectionSerializer . readCollectionSize ( bb2 , <int> ) ; for ( int i = <int> ; i < Math . min ( size1 , size2 ) ; i + + ) { ByteBuffer v1 = CollectionSerializer . readValue ( bb1 , <int> ) ; ByteBuffer v2 = CollectionSerializer . readValue ( bb2 , <int> ) ; int cmp = elementsComparator . compare ( v1 , v2 ) ; if ( cmp ! = <int> ) return cmp ; } return size1 = = size2 ? <int> : ( size1 < size2 ? - <int> : <int> ) ; } @Override public String toString ( boolean ignoreFreezing ) { boolean includeFrozenType = ! ignoreFreezing & & ! isMultiCell ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( includeFrozenType ) sb . append ( FrozenType . class . getName ( ) ) . append ( <str> ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( TypeParser . stringifyTypeParameters ( Collections . < AbstractType < ? > > singletonList ( elements ) , ignoreFreezing | | ! isMultiCell ) ) ; if ( includeFrozenType ) sb . append ( <str> ) ; return sb . toString ( ) ; } public List < ByteBuffer > serializedValues ( Iterator < Cell > cells ) { assert isMultiCell ; List < ByteBuffer > bbs = new ArrayList < ByteBuffer > ( ) ; while ( cells . hasNext ( ) ) bbs . add ( cells . next ( ) . value ( ) ) ; return bbs ; } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof List ) ) throw new MarshalException ( String . format ( <str> , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; List list = ( List ) parsed ; List < Term > terms = new ArrayList < > ( list . size ( ) ) ; for ( Object element : list ) { if ( element = = null ) throw new MarshalException ( <str> ) ; terms . add ( elements . fromJSONObject ( element ) ) ; } return new Lists . DelayedValue ( terms ) ; } public static String setOrListToJsonString ( ByteBuffer buffer , AbstractType elementsType , int protocolVersion ) { StringBuilder sb = new StringBuilder ( <str> ) ; int size = CollectionSerializer . readCollectionSize ( buffer , protocolVersion ) ; for ( int i = <int> ; i < size ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; sb . append ( elementsType . toJSONString ( CollectionSerializer . readValue ( buffer , protocolVersion ) , protocolVersion ) ) ; } return sb . append ( <str> ) . toString ( ) ; } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return setOrListToJsonString ( buffer , elements , protocolVersion ) ; } } 
