package org . elasticsearch . common . io . stream ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . util . BitUtil ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . index . query . functionscore . ScoreFunctionBuilder ; import org . joda . time . ReadableInstant ; import java . io . EOFException ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . file . NoSuchFileException ; import java . util . Date ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; public abstract class StreamOutput extends OutputStream { private Version version = Version . CURRENT ; public Version getVersion ( ) { return this . version ; } public StreamOutput setVersion ( Version version ) { this . version = version ; return this ; } public long position ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public void seek ( long position ) throws IOException { throw new UnsupportedOperationException ( ) ; } public abstract void writeByte ( byte b ) throws IOException ; public void writeBytes ( byte [ ] b ) throws IOException { writeBytes ( b , <int> , b . length ) ; } public void writeBytes ( byte [ ] b , int length ) throws IOException { writeBytes ( b , <int> , length ) ; } public abstract void writeBytes ( byte [ ] b , int offset , int length ) throws IOException ; public void writeByteArray ( byte [ ] b ) throws IOException { writeVInt ( b . length ) ; writeBytes ( b , <int> , b . length ) ; } public void writeBytesReference ( @Nullable BytesReference bytes ) throws IOException { if ( bytes = = null ) { writeVInt ( <int> ) ; return ; } writeVInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; } public void writeBytesRef ( BytesRef bytes ) throws IOException { if ( bytes = = null ) { writeVInt ( <int> ) ; return ; } writeVInt ( bytes . length ) ; write ( bytes . bytes , bytes . offset , bytes . length ) ; } public final void writeShort ( short v ) throws IOException { writeByte ( ( byte ) ( v > > <int> ) ) ; writeByte ( ( byte ) v ) ; } public void writeInt ( int i ) throws IOException { writeByte ( ( byte ) ( i > > <int> ) ) ; writeByte ( ( byte ) ( i > > <int> ) ) ; writeByte ( ( byte ) ( i > > <int> ) ) ; writeByte ( ( byte ) i ) ; } public void writeVInt ( int i ) throws IOException { while ( ( i & ~ <hex> ) ! = <int> ) { writeByte ( ( byte ) ( ( i & <hex> ) | <hex> ) ) ; i > > > = <int> ; } writeByte ( ( byte ) i ) ; } public void writeLong ( long i ) throws IOException { writeInt ( ( int ) ( i > > <int> ) ) ; writeInt ( ( int ) i ) ; } public void writeVLong ( long i ) throws IOException { assert i > = <int> ; while ( ( i & ~ <hex> ) ! = <int> ) { writeByte ( ( byte ) ( ( i & <hex> ) | <hex> ) ) ; i > > > = <int> ; } writeByte ( ( byte ) i ) ; } public void writeZLong ( long i ) throws IOException { long value = BitUtil . zigZagEncode ( i ) ; while ( ( value & <hex> ) ! = <int> L ) { writeByte ( ( byte ) ( ( value & <hex> ) | <hex> ) ) ; value > > > = <int> ; } writeByte ( ( byte ) ( value & <hex> ) ) ; } public void writeOptionalString ( @Nullable String str ) throws IOException { if ( str = = null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeString ( str ) ; } } public void writeOptionalVInt ( @Nullable Integer integer ) throws IOException { if ( integer = = null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeVInt ( integer ) ; } } public void writeOptionalText ( @Nullable Text text ) throws IOException { if ( text = = null ) { writeInt ( - <int> ) ; } else { writeText ( text ) ; } } private final BytesRefBuilder spare = new BytesRefBuilder ( ) ; public void writeText ( Text text ) throws IOException { if ( ! text . hasBytes ( ) ) { final String string = text . string ( ) ; spare . copyChars ( string ) ; writeInt ( spare . length ( ) ) ; write ( spare . bytes ( ) , <int> , spare . length ( ) ) ; } else { BytesReference bytes = text . bytes ( ) ; writeInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; } } public void writeString ( String str ) throws IOException { int charCount = str . length ( ) ; writeVInt ( charCount ) ; int c ; for ( int i = <int> ; i < charCount ; i + + ) { c = str . charAt ( i ) ; if ( c < = <hex> ) { writeByte ( ( byte ) c ) ; } else if ( c > <hex> ) { writeByte ( ( byte ) ( <hex> | c > > <int> & <hex> ) ) ; writeByte ( ( byte ) ( <hex> | c > > <int> & <hex> ) ) ; writeByte ( ( byte ) ( <hex> | c > > <int> & <hex> ) ) ; } else { writeByte ( ( byte ) ( <hex> | c > > <int> & <hex> ) ) ; writeByte ( ( byte ) ( <hex> | c > > <int> & <hex> ) ) ; } } } public void writeFloat ( float v ) throws IOException { writeInt ( Float . floatToIntBits ( v ) ) ; } public void writeDouble ( double v ) throws IOException { writeLong ( Double . doubleToLongBits ( v ) ) ; } private static byte ZERO = <int> ; private static byte ONE = <int> ; private static byte TWO = <int> ; public void writeBoolean ( boolean b ) throws IOException { writeByte ( b ? ONE : ZERO ) ; } public void writeOptionalBoolean ( @Nullable Boolean b ) throws IOException { if ( b = = null ) { writeByte ( TWO ) ; } else { writeByte ( b ? ONE : ZERO ) ; } } @Override public abstract void flush ( ) throws IOException ; @Override public abstract void close ( ) throws IOException ; public abstract void reset ( ) throws IOException ; @Override public void write ( int b ) throws IOException { writeByte ( ( byte ) b ) ; } @Override public void write ( byte [ ] b , int off , int len ) throws IOException { writeBytes ( b , off , len ) ; } public void writeStringArray ( String [ ] array ) throws IOException { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } } public void writeStringArrayNullable ( @Nullable String [ ] array ) throws IOException { if ( array = = null ) { writeVInt ( <int> ) ; } else { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } } } public void writeOptionalStringArray ( @Nullable String [ ] array ) throws IOException { if ( array = = null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeStringArray ( array ) ; } } public void writeMap ( @Nullable Map < String , Object > map ) throws IOException { writeGenericValue ( map ) ; } public void writeGenericValue ( @Nullable Object value ) throws IOException { if ( value = = null ) { writeByte ( ( byte ) - <int> ) ; return ; } Class type = value . getClass ( ) ; if ( type = = String . class ) { writeByte ( ( byte ) <int> ) ; writeString ( ( String ) value ) ; } else if ( type = = Integer . class ) { writeByte ( ( byte ) <int> ) ; writeInt ( ( Integer ) value ) ; } else if ( type = = Long . class ) { writeByte ( ( byte ) <int> ) ; writeLong ( ( Long ) value ) ; } else if ( type = = Float . class ) { writeByte ( ( byte ) <int> ) ; writeFloat ( ( Float ) value ) ; } else if ( type = = Double . class ) { writeByte ( ( byte ) <int> ) ; writeDouble ( ( Double ) value ) ; } else if ( type = = Boolean . class ) { writeByte ( ( byte ) <int> ) ; writeBoolean ( ( Boolean ) value ) ; } else if ( type = = byte [ ] . class ) { writeByte ( ( byte ) <int> ) ; writeVInt ( ( ( byte [ ] ) value ) . length ) ; writeBytes ( ( ( byte [ ] ) value ) ) ; } else if ( value instanceof List ) { writeByte ( ( byte ) <int> ) ; List list = ( List ) value ; writeVInt ( list . size ( ) ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Object [ ] ) { writeByte ( ( byte ) <int> ) ; Object [ ] list = ( Object [ ] ) value ; writeVInt ( list . length ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Map ) { if ( value instanceof LinkedHashMap ) { writeByte ( ( byte ) <int> ) ; } else { writeByte ( ( byte ) <int> ) ; } @SuppressWarnings ( <str> ) Map < String , Object > map = ( Map < String , Object > ) value ; writeVInt ( map . size ( ) ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { writeString ( entry . getKey ( ) ) ; writeGenericValue ( entry . getValue ( ) ) ; } } else if ( type = = Byte . class ) { writeByte ( ( byte ) <int> ) ; writeByte ( ( Byte ) value ) ; } else if ( type = = Date . class ) { writeByte ( ( byte ) <int> ) ; writeLong ( ( ( Date ) value ) . getTime ( ) ) ; } else if ( value instanceof ReadableInstant ) { writeByte ( ( byte ) <int> ) ; writeString ( ( ( ReadableInstant ) value ) . getZone ( ) . getID ( ) ) ; writeLong ( ( ( ReadableInstant ) value ) . getMillis ( ) ) ; } else if ( value instanceof BytesReference ) { writeByte ( ( byte ) <int> ) ; writeBytesReference ( ( BytesReference ) value ) ; } else if ( value instanceof Text ) { writeByte ( ( byte ) <int> ) ; writeText ( ( Text ) value ) ; } else if ( type = = Short . class ) { writeByte ( ( byte ) <int> ) ; writeShort ( ( Short ) value ) ; } else if ( type = = int [ ] . class ) { writeByte ( ( byte ) <int> ) ; writeIntArray ( ( int [ ] ) value ) ; } else if ( type = = long [ ] . class ) { writeByte ( ( byte ) <int> ) ; writeLongArray ( ( long [ ] ) value ) ; } else if ( type = = float [ ] . class ) { writeByte ( ( byte ) <int> ) ; writeFloatArray ( ( float [ ] ) value ) ; } else if ( type = = double [ ] . class ) { writeByte ( ( byte ) <int> ) ; writeDoubleArray ( ( double [ ] ) value ) ; } else if ( value instanceof BytesRef ) { writeByte ( ( byte ) <int> ) ; writeBytesRef ( ( BytesRef ) value ) ; } else if ( type = = GeoPoint . class ) { writeByte ( ( byte ) <int> ) ; writeGeoPoint ( ( GeoPoint ) value ) ; } else { throw new IOException ( <str> + type + <str> ) ; } } public void writeIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeInt ( value ) ; } } public void writeVIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeVInt ( value ) ; } } public void writeLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeLong ( value ) ; } } public void writeVLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeVLong ( value ) ; } } public void writeFloatArray ( float [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( float value : values ) { writeFloat ( value ) ; } } public void writeDoubleArray ( double [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( double value : values ) { writeDouble ( value ) ; } } public void writeOptionalStreamable ( @Nullable Streamable streamable ) throws IOException { if ( streamable ! = null ) { writeBoolean ( true ) ; streamable . writeTo ( this ) ; } else { writeBoolean ( false ) ; } } public void writeThrowable ( Throwable throwable ) throws IOException { if ( throwable = = null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; boolean writeCause = true ; boolean writeMessage = true ; if ( throwable instanceof CorruptIndexException ) { writeVInt ( <int> ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getOriginalMessage ( ) ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getResourceDescription ( ) ) ; writeMessage = false ; } else if ( throwable instanceof IndexFormatTooNewException ) { writeVInt ( <int> ) ; writeOptionalString ( ( ( IndexFormatTooNewException ) throwable ) . getResourceDescription ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMinVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMaxVersion ( ) ) ; writeMessage = false ; writeCause = false ; } else if ( throwable instanceof IndexFormatTooOldException ) { writeVInt ( <int> ) ; IndexFormatTooOldException t = ( IndexFormatTooOldException ) throwable ; writeOptionalString ( t . getResourceDescription ( ) ) ; if ( t . getVersion ( ) = = null ) { writeBoolean ( false ) ; writeOptionalString ( t . getReason ( ) ) ; } else { writeBoolean ( true ) ; writeInt ( t . getVersion ( ) ) ; writeInt ( t . getMinVersion ( ) ) ; writeInt ( t . getMaxVersion ( ) ) ; } writeMessage = false ; writeCause = false ; } else if ( throwable instanceof NullPointerException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof NumberFormatException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof IllegalArgumentException ) { writeVInt ( <int> ) ; } else if ( throwable instanceof AlreadyClosedException ) { writeVInt ( <int> ) ; } else if ( throwable instanceof EOFException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof SecurityException ) { writeVInt ( <int> ) ; } else if ( throwable instanceof StringIndexOutOfBoundsException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof ArrayIndexOutOfBoundsException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof AssertionError ) { writeVInt ( <int> ) ; } else if ( throwable instanceof FileNotFoundException ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof NoSuchFileException ) { writeVInt ( <int> ) ; writeOptionalString ( ( ( NoSuchFileException ) throwable ) . getFile ( ) ) ; writeOptionalString ( ( ( NoSuchFileException ) throwable ) . getOtherFile ( ) ) ; writeOptionalString ( ( ( NoSuchFileException ) throwable ) . getReason ( ) ) ; writeCause = false ; } else if ( throwable instanceof OutOfMemoryError ) { writeVInt ( <int> ) ; writeCause = false ; } else if ( throwable instanceof IllegalStateException ) { writeVInt ( <int> ) ; } else if ( throwable instanceof LockObtainFailedException ) { writeVInt ( <int> ) ; } else if ( throwable instanceof InterruptedException ) { writeVInt ( <int> ) ; writeCause = false ; } else { ElasticsearchException ex ; if ( throwable instanceof ElasticsearchException & & ElasticsearchException . isRegistered ( throwable . getClass ( ) ) ) { ex = ( ElasticsearchException ) throwable ; } else { ex = new NotSerializableExceptionWrapper ( throwable ) ; } writeVInt ( <int> ) ; writeVInt ( ElasticsearchException . getId ( ex . getClass ( ) ) ) ; ex . writeTo ( this ) ; return ; } if ( writeMessage ) { writeOptionalString ( throwable . getMessage ( ) ) ; } if ( writeCause ) { writeThrowable ( throwable . getCause ( ) ) ; } ElasticsearchException . writeStackTraces ( throwable , this ) ; } } void writeNamedWriteable ( NamedWriteable namedWriteable ) throws IOException { writeString ( namedWriteable . getWriteableName ( ) ) ; namedWriteable . writeTo ( this ) ; } public void writeQuery ( QueryBuilder queryBuilder ) throws IOException { writeNamedWriteable ( queryBuilder ) ; } public void writeScoreFunction ( ScoreFunctionBuilder < ? > scoreFunctionBuilder ) throws IOException { writeNamedWriteable ( scoreFunctionBuilder ) ; } public void writeGeoPoint ( GeoPoint geoPoint ) throws IOException { writeDouble ( geoPoint . lat ( ) ) ; writeDouble ( geoPoint . lon ( ) ) ; } } 
