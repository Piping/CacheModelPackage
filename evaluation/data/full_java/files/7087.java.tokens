package org . elasticsearch . script ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . logging . support . LoggerMessageFormat ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . script . ScriptService . ScriptType ; import java . io . IOException ; import java . util . Map ; public class Script implements ToXContent , Streamable { public static final ScriptType DEFAULT_TYPE = ScriptType . INLINE ; private static final ScriptParser PARSER = new ScriptParser ( ) ; private String script ; private @Nullable ScriptType type ; private @Nullable String lang ; private @Nullable Map < String , Object > params ; Script ( ) { } public Script ( String script ) { this ( script , null ) ; } protected Script ( String script , String lang ) { this ( script , ScriptType . INLINE , lang , null ) ; } public Script ( String script , ScriptType type , @Nullable String lang , @Nullable Map < String , ? extends Object > params ) { if ( script = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( type = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . script = script ; this . type = type ; this . lang = lang ; this . params = ( Map < String , Object > ) params ; } public String getScript ( ) { return script ; } public ScriptType getType ( ) { return type = = null ? DEFAULT_TYPE : type ; } public String getLang ( ) { return lang ; } public Map < String , Object > getParams ( ) { return params ; } @Override public final void readFrom ( StreamInput in ) throws IOException { script = in . readString ( ) ; if ( in . readBoolean ( ) ) { type = ScriptType . readFrom ( in ) ; } lang = in . readOptionalString ( ) ; if ( in . readBoolean ( ) ) { params = in . readMap ( ) ; } doReadFrom ( in ) ; } protected void doReadFrom ( StreamInput in ) throws IOException { } @Override public final void writeTo ( StreamOutput out ) throws IOException { out . writeString ( script ) ; boolean hasType = type ! = null ; out . writeBoolean ( hasType ) ; if ( hasType ) { ScriptType . writeTo ( type , out ) ; } out . writeOptionalString ( lang ) ; boolean hasParams = params ! = null ; out . writeBoolean ( hasParams ) ; if ( hasParams ) { out . writeMap ( params ) ; } doWriteTo ( out ) ; } protected void doWriteTo ( StreamOutput out ) throws IOException { } @Override public final XContentBuilder toXContent ( XContentBuilder builder , Params builderParams ) throws IOException { if ( type = = null ) { return builder . value ( script ) ; } builder . startObject ( ) ; scriptFieldToXContent ( script , type , builder , builderParams ) ; if ( lang ! = null ) { builder . field ( ScriptField . LANG . getPreferredName ( ) , lang ) ; } if ( params ! = null ) { builder . field ( ScriptField . PARAMS . getPreferredName ( ) , params ) ; } builder . endObject ( ) ; return builder ; } protected XContentBuilder scriptFieldToXContent ( String script , ScriptType type , XContentBuilder builder , Params builderParams ) throws IOException { builder . field ( type . getParseField ( ) . getPreferredName ( ) , script ) ; return builder ; } public static Script readScript ( StreamInput in ) throws IOException { Script script = new Script ( ) ; script . readFrom ( in ) ; return script ; } public static Script parse ( Map < String , Object > config , boolean removeMatchedEntries , ParseFieldMatcher parseFieldMatcher ) { return PARSER . parse ( config , removeMatchedEntries , parseFieldMatcher ) ; } public static Script parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher ) throws IOException { return PARSER . parse ( parser , parseFieldMatcher ) ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + ( ( lang = = null ) ? <int> : lang . hashCode ( ) ) ; result = prime * result + ( ( params = = null ) ? <int> : params . hashCode ( ) ) ; result = prime * result + ( ( script = = null ) ? <int> : script . hashCode ( ) ) ; result = prime * result + ( ( type = = null ) ? <int> : type . hashCode ( ) ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Script other = ( Script ) obj ; if ( lang = = null ) { if ( other . lang ! = null ) return false ; } else if ( ! lang . equals ( other . lang ) ) return false ; if ( params = = null ) { if ( other . params ! = null ) return false ; } else if ( ! params . equals ( other . params ) ) return false ; if ( script = = null ) { if ( other . script ! = null ) return false ; } else if ( ! script . equals ( other . script ) ) return false ; if ( type ! = other . type ) return false ; return true ; } @Override public String toString ( ) { return <str> + script + <str> + type . getParseField ( ) . getPreferredName ( ) + <str> + lang + <str> + params + <str> ; } private static class ScriptParser extends AbstractScriptParser < Script > { @Override protected Script createSimpleScript ( XContentParser parser ) throws IOException { if ( parser . currentToken ( ) = = XContentParser . Token . VALUE_STRING ) { return new Script ( parser . text ( ) ) ; } else { throw new ScriptParseException ( <str> , parser . currentName ( ) , parser . currentToken ( ) ) ; } } @Override protected Script createScript ( String script , ScriptType type , String lang , Map < String , Object > params ) { return new Script ( script , type , lang , params ) ; } @Override protected String parseInlineScript ( XContentParser parser ) throws IOException { return parser . text ( ) ; } } public interface ScriptField { ParseField SCRIPT = new ParseField ( <str> ) ; ParseField LANG = new ParseField ( <str> ) ; ParseField PARAMS = new ParseField ( <str> ) ; } public static class ScriptParseException extends ElasticsearchException { public ScriptParseException ( String msg , Object . . . args ) { super ( LoggerMessageFormat . format ( msg , args ) ) ; } public ScriptParseException ( StreamInput in ) throws IOException { super ( in ) ; } } } 
