package com . badlogic . gdx . graphics . g3d . particles . batches ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . Shader ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . DepthTestAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . FloatChannel ; import com . badlogic . gdx . graphics . g3d . particles . ParticleChannels ; import com . badlogic . gdx . graphics . g3d . particles . ParticleShader ; import com . badlogic . gdx . graphics . g3d . particles . ParticleShader . AlignMode ; import com . badlogic . gdx . graphics . g3d . particles . ResourceData ; import com . badlogic . gdx . graphics . g3d . particles . ResourceData . SaveData ; import com . badlogic . gdx . graphics . g3d . particles . renderers . BillboardControllerRenderData ; import com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; public class BillboardParticleBatch extends BufferedParticleBatch < BillboardControllerRenderData > { protected static final Vector3 TMP_V1 = new Vector3 ( ) , TMP_V2 = new Vector3 ( ) , TMP_V3 = new Vector3 ( ) , TMP_V4 = new Vector3 ( ) , TMP_V5 = new Vector3 ( ) , TMP_V6 = new Vector3 ( ) ; protected static final Matrix3 TMP_M3 = new Matrix3 ( ) ; protected static final int sizeAndRotationUsage = <int> < < <int> , directionUsage = <int> < < <int> ; private static final VertexAttributes GPU_ATTRIBUTES = new VertexAttributes ( new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) , new VertexAttribute ( Usage . ColorUnpacked , <int> , ShaderProgram . COLOR_ATTRIBUTE ) , new VertexAttribute ( sizeAndRotationUsage , <int> , <str> ) ) , CPU_ATTRIBUTES = new VertexAttributes ( new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) , new VertexAttribute ( Usage . ColorUnpacked , <int> , ShaderProgram . COLOR_ATTRIBUTE ) ) ; private static final int GPU_POSITION_OFFSET = ( short ) ( GPU_ATTRIBUTES . findByUsage ( Usage . Position ) . offset / <int> ) , GPU_UV_OFFSET = ( short ) ( GPU_ATTRIBUTES . findByUsage ( Usage . TextureCoordinates ) . offset / <int> ) , GPU_SIZE_ROTATION_OFFSET = ( short ) ( GPU_ATTRIBUTES . findByUsage ( sizeAndRotationUsage ) . offset / <int> ) , GPU_COLOR_OFFSET = ( short ) ( GPU_ATTRIBUTES . findByUsage ( Usage . ColorUnpacked ) . offset / <int> ) , GPU_VERTEX_SIZE = GPU_ATTRIBUTES . vertexSize / <int> , CPU_POSITION_OFFSET = ( short ) ( CPU_ATTRIBUTES . findByUsage ( Usage . Position ) . offset / <int> ) , CPU_UV_OFFSET = ( short ) ( CPU_ATTRIBUTES . findByUsage ( Usage . TextureCoordinates ) . offset / <int> ) , CPU_COLOR_OFFSET = ( short ) ( CPU_ATTRIBUTES . findByUsage ( Usage . ColorUnpacked ) . offset / <int> ) , CPU_VERTEX_SIZE = CPU_ATTRIBUTES . vertexSize / <int> ; private final static int MAX_PARTICLES_PER_MESH = Short . MAX_VALUE / <int> , MAX_VERTICES_PER_MESH = MAX_PARTICLES_PER_MESH * <int> ; private class RenderablePool extends Pool < Renderable > { public RenderablePool ( ) { } @Override public Renderable newObject ( ) { return allocRenderable ( ) ; } } public static class Config { public Config ( ) { } public Config ( boolean useGPU , AlignMode mode ) { this . useGPU = useGPU ; this . mode = mode ; } boolean useGPU ; AlignMode mode ; } private RenderablePool renderablePool ; private Array < Renderable > renderables ; private float [ ] vertices ; private short [ ] indices ; private int currentVertexSize = <int> ; private VertexAttributes currentAttributes ; protected boolean useGPU = false ; protected AlignMode mode = AlignMode . Screen ; protected Texture texture ; protected BlendingAttribute blendingAttribute ; protected DepthTestAttribute depthTestAttribute ; Shader shader ; public BillboardParticleBatch ( AlignMode mode , boolean useGPU , int capacity , BlendingAttribute blendingAttribute , DepthTestAttribute depthTestAttribute ) { super ( BillboardControllerRenderData . class ) ; renderables = new Array < Renderable > ( ) ; renderablePool = new RenderablePool ( ) ; this . blendingAttribute = blendingAttribute ; this . depthTestAttribute = depthTestAttribute ; if ( this . blendingAttribute = = null ) this . blendingAttribute = new BlendingAttribute ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA , <float> ) ; if ( this . depthTestAttribute = = null ) this . depthTestAttribute = new DepthTestAttribute ( GL20 . GL_LEQUAL , false ) ; allocIndices ( ) ; initRenderData ( ) ; ensureCapacity ( capacity ) ; setUseGpu ( useGPU ) ; setAlignMode ( mode ) ; } public BillboardParticleBatch ( AlignMode mode , boolean useGPU , int capacity ) { this ( mode , useGPU , capacity , null , null ) ; } public BillboardParticleBatch ( ) { this ( AlignMode . Screen , false , <int> ) ; } public BillboardParticleBatch ( int capacity ) { this ( AlignMode . Screen , false , capacity ) ; } @Override public void allocParticlesData ( int capacity ) { vertices = new float [ currentVertexSize * <int> * capacity ] ; allocRenderables ( capacity ) ; } protected Renderable allocRenderable ( ) { Renderable renderable = new Renderable ( ) ; renderable . meshPart . primitiveType = GL20 . GL_TRIANGLES ; renderable . meshPart . offset = <int> ; renderable . material = new Material ( this . blendingAttribute , this . depthTestAttribute , TextureAttribute . createDiffuse ( texture ) ) ; renderable . meshPart . mesh = new Mesh ( false , MAX_VERTICES_PER_MESH , MAX_PARTICLES_PER_MESH * <int> , currentAttributes ) ; renderable . meshPart . mesh . setIndices ( indices ) ; renderable . shader = shader ; return renderable ; } private void allocIndices ( ) { int indicesCount = MAX_PARTICLES_PER_MESH * <int> ; indices = new short [ indicesCount ] ; for ( int i = <int> , vertex = <int> ; i < indicesCount ; i + = <int> , vertex + = <int> ) { indices [ i ] = ( short ) vertex ; indices [ i + <int> ] = ( short ) ( vertex + <int> ) ; indices [ i + <int> ] = ( short ) ( vertex + <int> ) ; indices [ i + <int> ] = ( short ) ( vertex + <int> ) ; indices [ i + <int> ] = ( short ) ( vertex + <int> ) ; indices [ i + <int> ] = ( short ) vertex ; } } private void allocRenderables ( int capacity ) { int meshCount = MathUtils . ceil ( capacity / MAX_PARTICLES_PER_MESH ) , free = renderablePool . getFree ( ) ; if ( free < meshCount ) { for ( int i = <int> , left = meshCount - free ; i < left ; + + i ) renderablePool . free ( renderablePool . newObject ( ) ) ; } } private Shader getShader ( Renderable renderable ) { Shader shader = useGPU ? new ParticleShader ( renderable , new ParticleShader . Config ( mode ) ) : new DefaultShader ( renderable ) ; shader . init ( ) ; return shader ; } private void allocShader ( ) { Renderable newRenderable = allocRenderable ( ) ; shader = newRenderable . shader = getShader ( newRenderable ) ; renderablePool . free ( newRenderable ) ; } private void clearRenderablesPool ( ) { renderablePool . freeAll ( renderables ) ; for ( int i = <int> , free = renderablePool . getFree ( ) ; i < free ; + + i ) { Renderable renderable = renderablePool . obtain ( ) ; renderable . meshPart . mesh . dispose ( ) ; } renderables . clear ( ) ; } public void setVertexData ( ) { if ( useGPU ) { currentAttributes = GPU_ATTRIBUTES ; currentVertexSize = GPU_VERTEX_SIZE ; } else { currentAttributes = CPU_ATTRIBUTES ; currentVertexSize = CPU_VERTEX_SIZE ; } } private void initRenderData ( ) { setVertexData ( ) ; clearRenderablesPool ( ) ; allocShader ( ) ; resetCapacity ( ) ; } public void setAlignMode ( AlignMode mode ) { if ( mode ! = this . mode ) { this . mode = mode ; if ( useGPU ) { initRenderData ( ) ; allocRenderables ( bufferedParticlesCount ) ; } } } public AlignMode getAlignMode ( ) { return mode ; } public void setUseGpu ( boolean useGPU ) { if ( this . useGPU ! = useGPU ) { this . useGPU = useGPU ; initRenderData ( ) ; allocRenderables ( bufferedParticlesCount ) ; } } public boolean isUseGPU ( ) { return useGPU ; } public void setTexture ( Texture texture ) { renderablePool . freeAll ( renderables ) ; renderables . clear ( ) ; for ( int i = <int> , free = renderablePool . getFree ( ) ; i < free ; + + i ) { Renderable renderable = renderablePool . obtain ( ) ; TextureAttribute attribute = ( TextureAttribute ) renderable . material . get ( TextureAttribute . Diffuse ) ; attribute . textureDescription . texture = texture ; } this . texture = texture ; } public Texture getTexture ( ) { return texture ; } @Override public void begin ( ) { super . begin ( ) ; renderablePool . freeAll ( renderables ) ; renderables . clear ( ) ; } private static void putVertex ( float [ ] vertices , int offset , float x , float y , float z , float u , float v , float scaleX , float scaleY , float cosRotation , float sinRotation , float r , float g , float b , float a ) { vertices [ offset + GPU_POSITION_OFFSET ] = x ; vertices [ offset + GPU_POSITION_OFFSET + <int> ] = y ; vertices [ offset + GPU_POSITION_OFFSET + <int> ] = z ; vertices [ offset + GPU_UV_OFFSET ] = u ; vertices [ offset + GPU_UV_OFFSET + <int> ] = v ; vertices [ offset + GPU_SIZE_ROTATION_OFFSET ] = scaleX ; vertices [ offset + GPU_SIZE_ROTATION_OFFSET + <int> ] = scaleY ; vertices [ offset + GPU_SIZE_ROTATION_OFFSET + <int> ] = cosRotation ; vertices [ offset + GPU_SIZE_ROTATION_OFFSET + <int> ] = sinRotation ; vertices [ offset + GPU_COLOR_OFFSET ] = r ; vertices [ offset + GPU_COLOR_OFFSET + <int> ] = g ; vertices [ offset + GPU_COLOR_OFFSET + <int> ] = b ; vertices [ offset + GPU_COLOR_OFFSET + <int> ] = a ; } private static void putVertex ( float [ ] vertices , int offset , Vector3 p , float u , float v , float r , float g , float b , float a ) { vertices [ offset + CPU_POSITION_OFFSET ] = p . x ; vertices [ offset + CPU_POSITION_OFFSET + <int> ] = p . y ; vertices [ offset + CPU_POSITION_OFFSET + <int> ] = p . z ; vertices [ offset + CPU_UV_OFFSET ] = u ; vertices [ offset + CPU_UV_OFFSET + <int> ] = v ; vertices [ offset + CPU_COLOR_OFFSET ] = r ; vertices [ offset + CPU_COLOR_OFFSET + <int> ] = g ; vertices [ offset + CPU_COLOR_OFFSET + <int> ] = b ; vertices [ offset + CPU_COLOR_OFFSET + <int> ] = a ; } private void fillVerticesGPU ( int [ ] particlesOffset ) { int tp = <int> ; for ( BillboardControllerRenderData data : renderData ) { FloatChannel scaleChannel = data . scaleChannel ; FloatChannel regionChannel = data . regionChannel ; FloatChannel positionChannel = data . positionChannel ; FloatChannel colorChannel = data . colorChannel ; FloatChannel rotationChannel = data . rotationChannel ; for ( int p = <int> , c = data . controller . particles . size ; p < c ; + + p , + + tp ) { int baseOffset = particlesOffset [ tp ] * currentVertexSize * <int> ; float scale = scaleChannel . data [ p * scaleChannel . strideSize ] ; int regionOffset = p * regionChannel . strideSize ; int positionOffset = p * positionChannel . strideSize ; int colorOffset = p * colorChannel . strideSize ; int rotationOffset = p * rotationChannel . strideSize ; float px = positionChannel . data [ positionOffset + ParticleChannels . XOffset ] , py = positionChannel . data [ positionOffset + ParticleChannels . YOffset ] , pz = positionChannel . data [ positionOffset + ParticleChannels . ZOffset ] ; float u = regionChannel . data [ regionOffset + ParticleChannels . UOffset ] ; float v = regionChannel . data [ regionOffset + ParticleChannels . VOffset ] ; float u2 = regionChannel . data [ regionOffset + ParticleChannels . U2Offset ] ; float v2 = regionChannel . data [ regionOffset + ParticleChannels . V2Offset ] ; float sx = regionChannel . data [ regionOffset + ParticleChannels . HalfWidthOffset ] * scale , sy = regionChannel . data [ regionOffset + ParticleChannels . HalfHeightOffset ] * scale ; float r = colorChannel . data [ colorOffset + ParticleChannels . RedOffset ] ; float g = colorChannel . data [ colorOffset + ParticleChannels . GreenOffset ] ; float b = colorChannel . data [ colorOffset + ParticleChannels . BlueOffset ] ; float a = colorChannel . data [ colorOffset + ParticleChannels . AlphaOffset ] ; float cosRotation = rotationChannel . data [ rotationOffset + ParticleChannels . CosineOffset ] ; float sinRotation = rotationChannel . data [ rotationOffset + ParticleChannels . SineOffset ] ; putVertex ( vertices , baseOffset , px , py , pz , u , v2 , - sx , - sy , cosRotation , sinRotation , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , px , py , pz , u2 , v2 , sx , - sy , cosRotation , sinRotation , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , px , py , pz , u2 , v , sx , sy , cosRotation , sinRotation , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , px , py , pz , u , v , - sx , sy , cosRotation , sinRotation , r , g , b , a ) ; baseOffset + = currentVertexSize ; } } } private void fillVerticesToViewPointCPU ( int [ ] particlesOffset ) { int tp = <int> ; for ( BillboardControllerRenderData data : renderData ) { FloatChannel scaleChannel = data . scaleChannel ; FloatChannel regionChannel = data . regionChannel ; FloatChannel positionChannel = data . positionChannel ; FloatChannel colorChannel = data . colorChannel ; FloatChannel rotationChannel = data . rotationChannel ; for ( int p = <int> , c = data . controller . particles . size ; p < c ; + + p , + + tp ) { int baseOffset = particlesOffset [ tp ] * currentVertexSize * <int> ; float scale = scaleChannel . data [ p * scaleChannel . strideSize ] ; int regionOffset = p * regionChannel . strideSize ; int positionOffset = p * positionChannel . strideSize ; int colorOffset = p * colorChannel . strideSize ; int rotationOffset = p * rotationChannel . strideSize ; float px = positionChannel . data [ positionOffset + ParticleChannels . XOffset ] , py = positionChannel . data [ positionOffset + ParticleChannels . YOffset ] , pz = positionChannel . data [ positionOffset + ParticleChannels . ZOffset ] ; float u = regionChannel . data [ regionOffset + ParticleChannels . UOffset ] ; float v = regionChannel . data [ regionOffset + ParticleChannels . VOffset ] ; float u2 = regionChannel . data [ regionOffset + ParticleChannels . U2Offset ] ; float v2 = regionChannel . data [ regionOffset + ParticleChannels . V2Offset ] ; float sx = regionChannel . data [ regionOffset + ParticleChannels . HalfWidthOffset ] * scale , sy = regionChannel . data [ regionOffset + ParticleChannels . HalfHeightOffset ] * scale ; float r = colorChannel . data [ colorOffset + ParticleChannels . RedOffset ] ; float g = colorChannel . data [ colorOffset + ParticleChannels . GreenOffset ] ; float b = colorChannel . data [ colorOffset + ParticleChannels . BlueOffset ] ; float a = colorChannel . data [ colorOffset + ParticleChannels . AlphaOffset ] ; float cosRotation = rotationChannel . data [ rotationOffset + ParticleChannels . CosineOffset ] ; float sinRotation = rotationChannel . data [ rotationOffset + ParticleChannels . SineOffset ] ; Vector3 look = TMP_V3 . set ( camera . position ) . sub ( px , py , pz ) . nor ( ) , right = TMP_V1 . set ( camera . up ) . crs ( look ) . nor ( ) , up = TMP_V2 . set ( look ) . crs ( right ) ; right . scl ( sx ) ; up . scl ( sy ) ; if ( cosRotation ! = <int> ) { TMP_M3 . setToRotation ( look , cosRotation , sinRotation ) ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x - TMP_V2 . x , - TMP_V1 . y - TMP_V2 . y , - TMP_V1 . z - TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x - TMP_V2 . x , TMP_V1 . y - TMP_V2 . y , TMP_V1 . z - TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u2 , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x + TMP_V2 . x , TMP_V1 . y + TMP_V2 . y , TMP_V1 . z + TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u2 , v , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x + TMP_V2 . x , - TMP_V1 . y + TMP_V2 . y , - TMP_V1 . z + TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u , v , r , g , b , a ) ; } else { putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x - TMP_V2 . x + px , - TMP_V1 . y - TMP_V2 . y + py , - TMP_V1 . z - TMP_V2 . z + pz ) , u , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x - TMP_V2 . x + px , TMP_V1 . y - TMP_V2 . y + py , TMP_V1 . z - TMP_V2 . z + pz ) , u2 , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x + TMP_V2 . x + px , TMP_V1 . y + TMP_V2 . y + py , TMP_V1 . z + TMP_V2 . z + pz ) , u2 , v , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x + TMP_V2 . x + px , - TMP_V1 . y + TMP_V2 . y + py , - TMP_V1 . z + TMP_V2 . z + pz ) , u , v , r , g , b , a ) ; } } } } private void fillVerticesToScreenCPU ( int [ ] particlesOffset ) { Vector3 look = TMP_V3 . set ( camera . direction ) . scl ( - <int> ) , right = TMP_V4 . set ( camera . up ) . crs ( look ) . nor ( ) , up = camera . up ; int tp = <int> ; for ( BillboardControllerRenderData data : renderData ) { FloatChannel scaleChannel = data . scaleChannel ; FloatChannel regionChannel = data . regionChannel ; FloatChannel positionChannel = data . positionChannel ; FloatChannel colorChannel = data . colorChannel ; FloatChannel rotationChannel = data . rotationChannel ; for ( int p = <int> , c = data . controller . particles . size ; p < c ; + + p , + + tp ) { int baseOffset = particlesOffset [ tp ] * currentVertexSize * <int> ; float scale = scaleChannel . data [ p * scaleChannel . strideSize ] ; int regionOffset = p * regionChannel . strideSize ; int positionOffset = p * positionChannel . strideSize ; int colorOffset = p * colorChannel . strideSize ; int rotationOffset = p * rotationChannel . strideSize ; float px = positionChannel . data [ positionOffset + ParticleChannels . XOffset ] , py = positionChannel . data [ positionOffset + ParticleChannels . YOffset ] , pz = positionChannel . data [ positionOffset + ParticleChannels . ZOffset ] ; float u = regionChannel . data [ regionOffset + ParticleChannels . UOffset ] ; float v = regionChannel . data [ regionOffset + ParticleChannels . VOffset ] ; float u2 = regionChannel . data [ regionOffset + ParticleChannels . U2Offset ] ; float v2 = regionChannel . data [ regionOffset + ParticleChannels . V2Offset ] ; float sx = regionChannel . data [ regionOffset + ParticleChannels . HalfWidthOffset ] * scale , sy = regionChannel . data [ regionOffset + ParticleChannels . HalfHeightOffset ] * scale ; float r = colorChannel . data [ colorOffset + ParticleChannels . RedOffset ] ; float g = colorChannel . data [ colorOffset + ParticleChannels . GreenOffset ] ; float b = colorChannel . data [ colorOffset + ParticleChannels . BlueOffset ] ; float a = colorChannel . data [ colorOffset + ParticleChannels . AlphaOffset ] ; float cosRotation = rotationChannel . data [ rotationOffset + ParticleChannels . CosineOffset ] ; float sinRotation = rotationChannel . data [ rotationOffset + ParticleChannels . SineOffset ] ; TMP_V1 . set ( right ) . scl ( sx ) ; TMP_V2 . set ( up ) . scl ( sy ) ; if ( cosRotation ! = <int> ) { TMP_M3 . setToRotation ( look , cosRotation , sinRotation ) ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x - TMP_V2 . x , - TMP_V1 . y - TMP_V2 . y , - TMP_V1 . z - TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x - TMP_V2 . x , TMP_V1 . y - TMP_V2 . y , TMP_V1 . z - TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u2 , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x + TMP_V2 . x , TMP_V1 . y + TMP_V2 . y , TMP_V1 . z + TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u2 , v , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x + TMP_V2 . x , - TMP_V1 . y + TMP_V2 . y , - TMP_V1 . z + TMP_V2 . z ) . mul ( TMP_M3 ) . add ( px , py , pz ) , u , v , r , g , b , a ) ; } else { putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x - TMP_V2 . x + px , - TMP_V1 . y - TMP_V2 . y + py , - TMP_V1 . z - TMP_V2 . z + pz ) , u , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x - TMP_V2 . x + px , TMP_V1 . y - TMP_V2 . y + py , TMP_V1 . z - TMP_V2 . z + pz ) , u2 , v2 , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( TMP_V1 . x + TMP_V2 . x + px , TMP_V1 . y + TMP_V2 . y + py , TMP_V1 . z + TMP_V2 . z + pz ) , u2 , v , r , g , b , a ) ; baseOffset + = currentVertexSize ; putVertex ( vertices , baseOffset , TMP_V6 . set ( - TMP_V1 . x + TMP_V2 . x + px , - TMP_V1 . y + TMP_V2 . y + py , - TMP_V1 . z + TMP_V2 . z + pz ) , u , v , r , g , b , a ) ; } } } } @Override protected void flush ( int [ ] offsets ) { if ( useGPU ) { fillVerticesGPU ( offsets ) ; } else { if ( mode = = AlignMode . Screen ) fillVerticesToScreenCPU ( offsets ) ; else if ( mode = = AlignMode . ViewPoint ) fillVerticesToViewPointCPU ( offsets ) ; } int addedVertexCount = <int> ; int vCount = bufferedParticlesCount * <int> ; for ( int v = <int> ; v < vCount ; v + = addedVertexCount ) { addedVertexCount = Math . min ( vCount - v , MAX_VERTICES_PER_MESH ) ; Renderable renderable = renderablePool . obtain ( ) ; renderable . meshPart . size = ( addedVertexCount / <int> ) * <int> ; renderable . meshPart . mesh . setVertices ( vertices , currentVertexSize * v , currentVertexSize * addedVertexCount ) ; renderable . meshPart . update ( ) ; renderables . add ( renderable ) ; } } @Override public void getRenderables ( Array < Renderable > renderables , Pool < Renderable > pool ) { for ( Renderable renderable : this . renderables ) renderables . add ( pool . obtain ( ) . set ( renderable ) ) ; } @Override public void save ( AssetManager manager , ResourceData resources ) { SaveData data = resources . createSaveData ( <str> ) ; data . save ( <str> , new Config ( useGPU , mode ) ) ; data . saveAsset ( manager . getAssetFileName ( texture ) , Texture . class ) ; } @Override public void load ( AssetManager manager , ResourceData resources ) { SaveData data = resources . getSaveData ( <str> ) ; if ( data ! = null ) { setTexture ( ( Texture ) manager . get ( data . loadAsset ( ) ) ) ; Config cfg = ( Config ) data . load ( <str> ) ; setUseGpu ( cfg . useGPU ) ; setAlignMode ( cfg . mode ) ; } } } 
