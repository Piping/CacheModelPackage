package org . elasticsearch . index . translog ; import org . elasticsearch . common . io . Channels ; import java . io . EOFException ; import java . io . IOException ; import java . nio . ByteBuffer ; public class ImmutableTranslogReader extends TranslogReader { private final int totalOperations ; protected final long length ; public ImmutableTranslogReader ( long generation , ChannelReference channelReference , long firstOperationOffset , long length , int totalOperations ) { super ( generation , channelReference , firstOperationOffset ) ; this . length = length ; this . totalOperations = totalOperations ; } @Override public final TranslogReader clone ( ) { if ( channelReference . tryIncRef ( ) ) { try { ImmutableTranslogReader reader = newReader ( generation , channelReference , firstOperationOffset , length , totalOperations ) ; channelReference . incRef ( ) ; return reader ; } finally { channelReference . decRef ( ) ; } } else { throw new IllegalStateException ( <str> + generation + <str> ) ; } } protected ImmutableTranslogReader newReader ( long generation , ChannelReference channelReference , long offset , long length , int totalOperations ) { return new ImmutableTranslogReader ( generation , channelReference , offset , length , totalOperations ) ; } public long sizeInBytes ( ) { return length ; } public int totalOperations ( ) { return totalOperations ; } protected void readBytes ( ByteBuffer buffer , long position ) throws IOException { if ( position > = length ) { throw new EOFException ( <str> + position + <str> + length + <str> ) ; } if ( position < firstOperationOffset ) { throw new IOException ( <str> + position + <str> + firstOperationOffset + <str> ) ; } Channels . readFromFileChannelWithEofException ( channel , position , buffer ) ; } public Checkpoint getInfo ( ) { return new Checkpoint ( length , totalOperations , getGeneration ( ) ) ; } } 
