package org . elasticsearch . index . mapper ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . util . CloseableThreadLocal ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . mapper . core . DateFieldMapper . DateFieldType ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper . StringFieldType ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . mapper . object . ArrayValueMapperParser ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . index . mapper . object . RootObjectMapper ; import java . io . Closeable ; import java . io . IOException ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; class DocumentParser implements Closeable { private CloseableThreadLocal < ParseContext . InternalParseContext > cache = new CloseableThreadLocal < ParseContext . InternalParseContext > ( ) { @Override protected ParseContext . InternalParseContext initialValue ( ) { return new ParseContext . InternalParseContext ( indexSettings , docMapperParser , docMapper , new ContentPath ( <int> ) ) ; } } ; private final Settings indexSettings ; private final DocumentMapperParser docMapperParser ; private final DocumentMapper docMapper ; private final ReleasableLock parseLock ; public DocumentParser ( Settings indexSettings , DocumentMapperParser docMapperParser , DocumentMapper docMapper , ReleasableLock parseLock ) { this . indexSettings = indexSettings ; this . docMapperParser = docMapperParser ; this . docMapper = docMapper ; this . parseLock = parseLock ; } public ParsedDocument parseDocument ( SourceToParse source ) throws MapperParsingException { try ( ReleasableLock lock = parseLock . acquire ( ) ) { return innerParseDocument ( source ) ; } } private ParsedDocument innerParseDocument ( SourceToParse source ) throws MapperParsingException { if ( docMapper . type ( ) . equals ( MapperService . DEFAULT_MAPPING ) ) { throw new IllegalArgumentException ( <str> + MapperService . DEFAULT_MAPPING + <str> ) ; } ParseContext . InternalParseContext context = cache . get ( ) ; final Mapping mapping = docMapper . mapping ( ) ; if ( source . type ( ) ! = null & & ! source . type ( ) . equals ( docMapper . type ( ) ) ) { throw new MapperParsingException ( <str> + source . type ( ) + <str> + docMapper . type ( ) + <str> ) ; } source . type ( docMapper . type ( ) ) ; XContentParser parser = source . parser ( ) ; try { if ( parser = = null ) { parser = XContentHelper . createParser ( source . source ( ) ) ; } context . reset ( parser , new ParseContext . Document ( ) , source ) ; XContentParser . Token token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new MapperParsingException ( <str> ) ; } boolean emptyDoc = false ; if ( mapping . root . isEnabled ( ) ) { token = parser . nextToken ( ) ; if ( token = = XContentParser . Token . END_OBJECT ) { emptyDoc = true ; } else if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new MapperParsingException ( <str> ) ; } } for ( MetadataFieldMapper metadataMapper : mapping . metadataMappers ) { metadataMapper . preParse ( context ) ; } if ( mapping . root . isEnabled ( ) = = false ) { parser . skipChildren ( ) ; } else if ( emptyDoc = = false ) { Mapper update = parseObject ( context , mapping . root , true ) ; if ( update ! = null ) { context . addDynamicMappingsUpdate ( update ) ; } } for ( MetadataFieldMapper metadataMapper : mapping . metadataMappers ) { metadataMapper . postParse ( context ) ; } if ( Version . indexCreated ( indexSettings ) . onOrAfter ( Version . V_2_0_0_beta1 ) & & source . parser ( ) = = null & & parser ! = null ) { token = parser . nextToken ( ) ; if ( token ! = null ) { throw new IllegalArgumentException ( <str> + token ) ; } } } catch ( Throwable e ) { if ( e instanceof MapperParsingException ) { throw ( MapperParsingException ) e ; } if ( source . source ( ) ! = null & & source . source ( ) . length ( ) = = <int> ) { throw new MapperParsingException ( <str> ) ; } throw new MapperParsingException ( <str> , e ) ; } finally { if ( source . parser ( ) = = null & & parser ! = null ) { parser . close ( ) ; } } if ( context . docs ( ) . size ( ) > <int> ) { Collections . reverse ( context . docs ( ) ) ; } if ( context . docBoost ( ) ! = <float> ) { Set < String > encounteredFields = new HashSet < > ( ) ; for ( ParseContext . Document doc : context . docs ( ) ) { encounteredFields . clear ( ) ; for ( IndexableField field : doc ) { if ( field . fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE & & ! field . fieldType ( ) . omitNorms ( ) ) { if ( ! encounteredFields . contains ( field . name ( ) ) ) { ( ( Field ) field ) . setBoost ( context . docBoost ( ) * field . boost ( ) ) ; encounteredFields . add ( field . name ( ) ) ; } } } } } Mapper rootDynamicUpdate = context . dynamicMappingsUpdate ( ) ; Mapping update = null ; if ( rootDynamicUpdate ! = null ) { update = mapping . mappingUpdate ( rootDynamicUpdate ) ; } ParsedDocument doc = new ParsedDocument ( context . uid ( ) , context . version ( ) , context . id ( ) , context . type ( ) , source . routing ( ) , source . timestamp ( ) , source . ttl ( ) , context . docs ( ) , context . source ( ) , update ) . parent ( source . parent ( ) ) ; context . reset ( null , null , null ) ; return doc ; } static ObjectMapper parseObject ( ParseContext context , ObjectMapper mapper , boolean atRoot ) throws IOException { if ( mapper . isEnabled ( ) = = false ) { context . parser ( ) . skipChildren ( ) ; return null ; } XContentParser parser = context . parser ( ) ; String currentFieldName = parser . currentName ( ) ; if ( atRoot & & MapperService . isMetadataField ( currentFieldName ) & & Version . indexCreated ( context . indexSettings ( ) ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { throw new MapperParsingException ( <str> + currentFieldName + <str> ) ; } XContentParser . Token token = parser . currentToken ( ) ; if ( token = = XContentParser . Token . VALUE_NULL ) { return null ; } if ( token . isValue ( ) ) { throw new MapperParsingException ( <str> + mapper . name ( ) + <str> + currentFieldName + <str> ) ; } ObjectMapper . Nested nested = mapper . nested ( ) ; if ( nested . isNested ( ) ) { context = context . createNestedContext ( mapper . fullPath ( ) ) ; ParseContext . Document nestedDoc = context . doc ( ) ; ParseContext . Document parentDoc = nestedDoc . getParent ( ) ; IndexableField uidField = parentDoc . getField ( UidFieldMapper . NAME ) ; if ( uidField ! = null ) { nestedDoc . add ( new Field ( UidFieldMapper . NAME , uidField . stringValue ( ) , UidFieldMapper . Defaults . NESTED_FIELD_TYPE ) ) ; } nestedDoc . add ( new Field ( TypeFieldMapper . NAME , mapper . nestedTypePathAsString ( ) , TypeFieldMapper . Defaults . FIELD_TYPE ) ) ; } ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( mapper . pathType ( ) ) ; if ( token = = XContentParser . Token . END_OBJECT ) { token = parser . nextToken ( ) ; } if ( token = = XContentParser . Token . START_OBJECT ) { token = parser . nextToken ( ) ; } ObjectMapper update = null ; while ( token ! = XContentParser . Token . END_OBJECT ) { ObjectMapper newUpdate = null ; if ( token = = XContentParser . Token . START_OBJECT ) { newUpdate = parseObject ( context , mapper , currentFieldName ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { newUpdate = parseArray ( context , mapper , currentFieldName ) ; } else if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NULL ) { parseNullValue ( context , mapper , currentFieldName ) ; } else if ( token = = null ) { throw new MapperParsingException ( <str> + mapper . name ( ) + <str> + currentFieldName + <str> ) ; } else if ( token . isValue ( ) ) { newUpdate = parseValue ( context , mapper , currentFieldName , token ) ; } token = parser . nextToken ( ) ; if ( newUpdate ! = null ) { if ( update = = null ) { update = newUpdate ; } else { MapperUtils . merge ( update , newUpdate ) ; } } } context . path ( ) . pathType ( origPathType ) ; if ( nested . isNested ( ) ) { ParseContext . Document nestedDoc = context . doc ( ) ; ParseContext . Document parentDoc = nestedDoc . getParent ( ) ; if ( nested . isIncludeInParent ( ) ) { for ( IndexableField field : nestedDoc . getFields ( ) ) { if ( field . name ( ) . equals ( UidFieldMapper . NAME ) | | field . name ( ) . equals ( TypeFieldMapper . NAME ) ) { continue ; } else { parentDoc . add ( field ) ; } } } if ( nested . isIncludeInRoot ( ) ) { ParseContext . Document rootDoc = context . rootDoc ( ) ; if ( ! nested . isIncludeInParent ( ) | | parentDoc ! = rootDoc ) { for ( IndexableField field : nestedDoc . getFields ( ) ) { if ( field . name ( ) . equals ( UidFieldMapper . NAME ) | | field . name ( ) . equals ( TypeFieldMapper . NAME ) ) { continue ; } else { rootDoc . add ( field ) ; } } } } } return update ; } private static Mapper parseObjectOrField ( ParseContext context , Mapper mapper ) throws IOException { if ( mapper instanceof ObjectMapper ) { return parseObject ( context , ( ObjectMapper ) mapper , false ) ; } else { FieldMapper fieldMapper = ( FieldMapper ) mapper ; Mapper update = fieldMapper . parse ( context ) ; if ( fieldMapper . copyTo ( ) ! = null ) { parseCopyFields ( context , fieldMapper , fieldMapper . copyTo ( ) . copyToFields ( ) ) ; } return update ; } } private static ObjectMapper parseObject ( final ParseContext context , ObjectMapper mapper , String currentFieldName ) throws IOException { if ( currentFieldName = = null ) { throw new MapperParsingException ( <str> + mapper . name ( ) + <str> + context . parser ( ) . textOrNull ( ) + <str> ) ; } context . path ( ) . add ( currentFieldName ) ; ObjectMapper update = null ; Mapper objectMapper = mapper . getMapper ( currentFieldName ) ; if ( objectMapper ! = null ) { final Mapper subUpdate = parseObjectOrField ( context , objectMapper ) ; if ( subUpdate ! = null ) { update = mapper . mappingUpdate ( subUpdate ) ; } } else { ObjectMapper . Dynamic dynamic = mapper . dynamic ( ) ; if ( dynamic = = null ) { dynamic = dynamicOrDefault ( context . root ( ) . dynamic ( ) ) ; } if ( dynamic = = ObjectMapper . Dynamic . STRICT ) { throw new StrictDynamicMappingException ( mapper . fullPath ( ) , currentFieldName ) ; } else if ( dynamic = = ObjectMapper . Dynamic . TRUE ) { context . path ( ) . remove ( ) ; Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . object ( currentFieldName ) . enabled ( true ) . pathType ( mapper . pathType ( ) ) ; if ( ! ( mapper instanceof RootObjectMapper ) & & mapper . dynamic ( ) ! = ObjectMapper . Defaults . DYNAMIC ) { ( ( ObjectMapper . Builder ) builder ) . dynamic ( mapper . dynamic ( ) ) ; } } Mapper . BuilderContext builderContext = new Mapper . BuilderContext ( context . indexSettings ( ) , context . path ( ) ) ; objectMapper = builder . build ( builderContext ) ; context . path ( ) . add ( currentFieldName ) ; update = mapper . mappingUpdate ( parseAndMergeUpdate ( objectMapper , context ) ) ; } else { context . parser ( ) . skipChildren ( ) ; } } context . path ( ) . remove ( ) ; return update ; } private static ObjectMapper parseArray ( ParseContext context , ObjectMapper parentMapper , String lastFieldName ) throws IOException { String arrayFieldName = lastFieldName ; Mapper mapper = parentMapper . getMapper ( lastFieldName ) ; if ( mapper ! = null ) { if ( mapper instanceof ArrayValueMapperParser ) { final Mapper subUpdate = parseObjectOrField ( context , mapper ) ; if ( subUpdate ! = null ) { return parentMapper . mappingUpdate ( subUpdate ) ; } else { return null ; } } else { return parseNonDynamicArray ( context , parentMapper , lastFieldName , arrayFieldName ) ; } } else { ObjectMapper . Dynamic dynamic = parentMapper . dynamic ( ) ; if ( dynamic = = null ) { dynamic = dynamicOrDefault ( context . root ( ) . dynamic ( ) ) ; } if ( dynamic = = ObjectMapper . Dynamic . STRICT ) { throw new StrictDynamicMappingException ( parentMapper . fullPath ( ) , arrayFieldName ) ; } else if ( dynamic = = ObjectMapper . Dynamic . TRUE ) { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , arrayFieldName , <str> ) ; if ( builder = = null ) { return parseNonDynamicArray ( context , parentMapper , lastFieldName , arrayFieldName ) ; } Mapper . BuilderContext builderContext = new Mapper . BuilderContext ( context . indexSettings ( ) , context . path ( ) ) ; mapper = builder . build ( builderContext ) ; if ( mapper ! = null & & mapper instanceof ArrayValueMapperParser ) { context . path ( ) . add ( arrayFieldName ) ; mapper = parseAndMergeUpdate ( mapper , context ) ; return parentMapper . mappingUpdate ( mapper ) ; } else { return parseNonDynamicArray ( context , parentMapper , lastFieldName , arrayFieldName ) ; } } else { return parseNonDynamicArray ( context , parentMapper , lastFieldName , arrayFieldName ) ; } } } private static ObjectMapper parseNonDynamicArray ( ParseContext context , ObjectMapper mapper , String lastFieldName , String arrayFieldName ) throws IOException { XContentParser parser = context . parser ( ) ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . START_OBJECT ) { return parseObject ( context , mapper , lastFieldName ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { return parseArray ( context , mapper , lastFieldName ) ; } else if ( token = = XContentParser . Token . FIELD_NAME ) { lastFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NULL ) { parseNullValue ( context , mapper , lastFieldName ) ; } else if ( token = = null ) { throw new MapperParsingException ( <str> + mapper . name ( ) + <str> + arrayFieldName + <str> ) ; } else { return parseValue ( context , mapper , lastFieldName , token ) ; } } return null ; } private static ObjectMapper parseValue ( final ParseContext context , ObjectMapper parentMapper , String currentFieldName , XContentParser . Token token ) throws IOException { if ( currentFieldName = = null ) { throw new MapperParsingException ( <str> + parentMapper . name ( ) + <str> + context . parser ( ) . textOrNull ( ) + <str> ) ; } Mapper mapper = parentMapper . getMapper ( currentFieldName ) ; if ( mapper ! = null ) { Mapper subUpdate = parseObjectOrField ( context , mapper ) ; if ( subUpdate = = null ) { return null ; } return parentMapper . mappingUpdate ( subUpdate ) ; } else { return parseDynamicValue ( context , parentMapper , currentFieldName , token ) ; } } private static void parseNullValue ( ParseContext context , ObjectMapper parentMapper , String lastFieldName ) throws IOException { Mapper mapper = parentMapper . getMapper ( lastFieldName ) ; if ( mapper ! = null ) { parseObjectOrField ( context , mapper ) ; } else if ( parentMapper . dynamic ( ) = = ObjectMapper . Dynamic . STRICT ) { throw new StrictDynamicMappingException ( parentMapper . fullPath ( ) , lastFieldName ) ; } } private static Mapper . Builder < ? , ? > createBuilderFromFieldType ( final ParseContext context , MappedFieldType fieldType , String currentFieldName ) { Mapper . Builder builder = null ; if ( fieldType instanceof StringFieldType ) { builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . stringField ( currentFieldName ) ; } } else if ( fieldType instanceof DateFieldType ) { builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . dateField ( currentFieldName ) ; } } else if ( fieldType . numericType ( ) ! = null ) { switch ( fieldType . numericType ( ) ) { case LONG : builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . longField ( currentFieldName ) ; } break ; case DOUBLE : builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . doubleField ( currentFieldName ) ; } break ; case INT : builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . integerField ( currentFieldName ) ; } break ; case FLOAT : builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . floatField ( currentFieldName ) ; } break ; default : throw new AssertionError ( <str> + fieldType . numericType ( ) ) ; } } return builder ; } private static Mapper . Builder < ? , ? > createBuilderFromDynamicValue ( final ParseContext context , XContentParser . Token token , String currentFieldName ) throws IOException { if ( token = = XContentParser . Token . VALUE_STRING ) { { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> , null ) ; if ( builder ! = null ) { return builder ; } } if ( context . root ( ) . dateDetection ( ) ) { String text = context . parser ( ) . text ( ) ; if ( Strings . countOccurrencesOf ( text , <str> ) > <int> | | Strings . countOccurrencesOf ( text , <str> ) > <int> | | Strings . countOccurrencesOf ( text , <str> ) > <int> ) { for ( FormatDateTimeFormatter dateTimeFormatter : context . root ( ) . dynamicDateTimeFormatters ( ) ) { try { dateTimeFormatter . parser ( ) . parseMillis ( text ) ; Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . dateField ( currentFieldName ) . dateTimeFormatter ( dateTimeFormatter ) ; } return builder ; } catch ( Exception e ) { } } } } if ( context . root ( ) . numericDetection ( ) ) { String text = context . parser ( ) . text ( ) ; try { Long . parseLong ( text ) ; Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . longField ( currentFieldName ) ; } return builder ; } catch ( NumberFormatException e ) { } try { Double . parseDouble ( text ) ; Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . doubleField ( currentFieldName ) ; } return builder ; } catch ( NumberFormatException e ) { } } Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . stringField ( currentFieldName ) ; } return builder ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { XContentParser . NumberType numberType = context . parser ( ) . numberType ( ) ; if ( numberType = = XContentParser . NumberType . INT | | numberType = = XContentParser . NumberType . LONG ) { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . longField ( currentFieldName ) ; } return builder ; } else if ( numberType = = XContentParser . NumberType . FLOAT | | numberType = = XContentParser . NumberType . DOUBLE ) { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . floatField ( currentFieldName ) ; } return builder ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . booleanField ( currentFieldName ) ; } return builder ; } else if ( token = = XContentParser . Token . VALUE_EMBEDDED_OBJECT ) { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , <str> ) ; if ( builder = = null ) { builder = MapperBuilders . binaryField ( currentFieldName ) ; } return builder ; } else { Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , currentFieldName , null ) ; if ( builder ! = null ) { return builder ; } } throw new IllegalStateException ( <str> + token + <str> + currentFieldName + <str> ) ; } private static ObjectMapper parseDynamicValue ( final ParseContext context , ObjectMapper parentMapper , String currentFieldName , XContentParser . Token token ) throws IOException { ObjectMapper . Dynamic dynamic = parentMapper . dynamic ( ) ; if ( dynamic = = null ) { dynamic = dynamicOrDefault ( context . root ( ) . dynamic ( ) ) ; } if ( dynamic = = ObjectMapper . Dynamic . STRICT ) { throw new StrictDynamicMappingException ( parentMapper . fullPath ( ) , currentFieldName ) ; } if ( dynamic = = ObjectMapper . Dynamic . FALSE ) { return null ; } final Mapper . BuilderContext builderContext = new Mapper . BuilderContext ( context . indexSettings ( ) , context . path ( ) ) ; final MappedFieldType existingFieldType = context . mapperService ( ) . fullName ( context . path ( ) . fullPathAsText ( currentFieldName ) ) ; Mapper . Builder builder = null ; if ( existingFieldType ! = null ) { builder = createBuilderFromFieldType ( context , existingFieldType , currentFieldName ) ; if ( builder ! = null ) { if ( builder instanceof StringFieldMapper . Builder ) { StringFieldMapper . Builder stringBuilder = ( StringFieldMapper . Builder ) builder ; stringBuilder . fieldDataSettings ( existingFieldType . fieldDataType ( ) . getSettings ( ) ) ; stringBuilder . store ( existingFieldType . stored ( ) ) ; stringBuilder . indexOptions ( existingFieldType . indexOptions ( ) ) ; stringBuilder . tokenized ( existingFieldType . tokenized ( ) ) ; stringBuilder . omitNorms ( existingFieldType . omitNorms ( ) ) ; stringBuilder . docValues ( existingFieldType . hasDocValues ( ) ) ; stringBuilder . indexAnalyzer ( existingFieldType . indexAnalyzer ( ) ) ; stringBuilder . searchAnalyzer ( existingFieldType . searchAnalyzer ( ) ) ; } else if ( builder instanceof NumberFieldMapper . Builder ) { NumberFieldMapper . Builder < ? , ? > numberBuilder = ( NumberFieldMapper . Builder < ? , ? > ) builder ; numberBuilder . fieldDataSettings ( existingFieldType . fieldDataType ( ) . getSettings ( ) ) ; numberBuilder . store ( existingFieldType . stored ( ) ) ; numberBuilder . indexOptions ( existingFieldType . indexOptions ( ) ) ; numberBuilder . tokenized ( existingFieldType . tokenized ( ) ) ; numberBuilder . omitNorms ( existingFieldType . omitNorms ( ) ) ; numberBuilder . docValues ( existingFieldType . hasDocValues ( ) ) ; numberBuilder . precisionStep ( existingFieldType . numericPrecisionStep ( ) ) ; } } } if ( builder = = null ) { builder = createBuilderFromDynamicValue ( context , token , currentFieldName ) ; } Mapper mapper = builder . build ( builderContext ) ; mapper = parseAndMergeUpdate ( mapper , context ) ; ObjectMapper update = null ; if ( mapper ! = null ) { update = parentMapper . mappingUpdate ( mapper ) ; } return update ; } private static void parseCopyFields ( ParseContext context , FieldMapper fieldMapper , List < String > copyToFields ) throws IOException { if ( ! context . isWithinCopyTo ( ) & & copyToFields . isEmpty ( ) = = false ) { context = context . createCopyToContext ( ) ; for ( String field : copyToFields ) { ParseContext . Document targetDoc = null ; for ( ParseContext . Document doc = context . doc ( ) ; doc ! = null ; doc = doc . getParent ( ) ) { if ( field . startsWith ( doc . getPrefix ( ) ) ) { targetDoc = doc ; break ; } } assert targetDoc ! = null ; final ParseContext copyToContext ; if ( targetDoc = = context . doc ( ) ) { copyToContext = context ; } else { copyToContext = context . switchDoc ( targetDoc ) ; } parseCopy ( field , copyToContext ) ; } } } private static void parseCopy ( String field , ParseContext context ) throws IOException { FieldMapper fieldMapper = context . docMapper ( ) . mappers ( ) . getMapper ( field ) ; if ( fieldMapper ! = null ) { fieldMapper . parse ( context ) ; } else { context = context . overridePath ( new ContentPath ( <int> ) ) ; String [ ] paths = Strings . splitStringToArray ( field , <str> ) ; String fieldName = paths [ paths . length - <int> ] ; ObjectMapper mapper = context . root ( ) ; ObjectMapper [ ] mappers = new ObjectMapper [ paths . length - <int> ] ; if ( paths . length > <int> ) { ObjectMapper parent = context . root ( ) ; for ( int i = <int> ; i < paths . length - <int> ; i + + ) { mapper = context . docMapper ( ) . objectMappers ( ) . get ( context . path ( ) . fullPathAsText ( paths [ i ] ) ) ; if ( mapper = = null ) { ObjectMapper . Dynamic dynamic = parent . dynamic ( ) ; if ( dynamic = = null ) { dynamic = dynamicOrDefault ( context . root ( ) . dynamic ( ) ) ; } switch ( dynamic ) { case STRICT : throw new StrictDynamicMappingException ( parent . fullPath ( ) , paths [ i ] ) ; case TRUE : Mapper . Builder builder = context . root ( ) . findTemplateBuilder ( context , paths [ i ] , <str> ) ; if ( builder = = null ) { if ( ! ( parent instanceof RootObjectMapper ) & & parent . dynamic ( ) ! = ObjectMapper . Defaults . DYNAMIC ) { ( ( ObjectMapper . Builder ) builder ) . dynamic ( parent . dynamic ( ) ) ; } builder = MapperBuilders . object ( paths [ i ] ) . enabled ( true ) . pathType ( parent . pathType ( ) ) ; } Mapper . BuilderContext builderContext = new Mapper . BuilderContext ( context . indexSettings ( ) , context . path ( ) ) ; mapper = ( ObjectMapper ) builder . build ( builderContext ) ; if ( mapper . nested ( ) ! = ObjectMapper . Nested . NO ) { throw new MapperParsingException ( <str> + context . path ( ) . fullPathAsText ( paths [ i ] ) + <str> ) ; } break ; case FALSE : break ; default : throw new AssertionError ( <str> + dynamic ) ; } } context . path ( ) . add ( paths [ i ] ) ; mappers [ i ] = mapper ; parent = mapper ; } } ObjectMapper update = parseDynamicValue ( context , mapper , fieldName , context . parser ( ) . currentToken ( ) ) ; assert update ! = null ; if ( paths . length > <int> ) { for ( int i = paths . length - <int> ; i > = <int> ; i - - ) { ObjectMapper parent = context . root ( ) ; if ( i > <int> ) { parent = mappers [ i - <int> ] ; } assert parent ! = null ; update = parent . mappingUpdate ( update ) ; } } context . addDynamicMappingsUpdate ( update ) ; } } private static < M extends Mapper > M parseAndMergeUpdate ( M mapper , ParseContext context ) throws IOException { final Mapper update = parseObjectOrField ( context , mapper ) ; if ( update ! = null ) { MapperUtils . merge ( mapper , update ) ; } return mapper ; } private static ObjectMapper . Dynamic dynamicOrDefault ( ObjectMapper . Dynamic dynamic ) { return dynamic = = null ? ObjectMapper . Dynamic . TRUE : dynamic ; } @Override public void close ( ) { cache . close ( ) ; } } 
