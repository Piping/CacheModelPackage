package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import static io . netty . handler . codec . compression . Snappy . * ; public class SnappyFrameEncoder extends MessageToByteEncoder < ByteBuf > { private static final int MIN_COMPRESSIBLE_LENGTH = <int> ; private static final byte [ ] STREAM_START = { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; private final Snappy snappy = new Snappy ( ) ; private boolean started ; @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { if ( ! in . isReadable ( ) ) { return ; } if ( ! started ) { started = true ; out . writeBytes ( STREAM_START ) ; } int dataLength = in . readableBytes ( ) ; if ( dataLength > MIN_COMPRESSIBLE_LENGTH ) { for ( ; ; ) { final int lengthIdx = out . writerIndex ( ) + <int> ; if ( dataLength < MIN_COMPRESSIBLE_LENGTH ) { ByteBuf slice = in . readSlice ( dataLength ) ; writeUnencodedChunk ( slice , out , dataLength ) ; break ; } out . writeInt ( <int> ) ; if ( dataLength > Short . MAX_VALUE ) { ByteBuf slice = in . readSlice ( Short . MAX_VALUE ) ; calculateAndWriteChecksum ( slice , out ) ; snappy . encode ( slice , out , Short . MAX_VALUE ) ; setChunkLength ( out , lengthIdx ) ; dataLength - = Short . MAX_VALUE ; } else { ByteBuf slice = in . readSlice ( dataLength ) ; calculateAndWriteChecksum ( slice , out ) ; snappy . encode ( slice , out , dataLength ) ; setChunkLength ( out , lengthIdx ) ; break ; } } } else { writeUnencodedChunk ( in , out , dataLength ) ; } } private static void writeUnencodedChunk ( ByteBuf in , ByteBuf out , int dataLength ) { out . writeByte ( <int> ) ; writeChunkLength ( out , dataLength + <int> ) ; calculateAndWriteChecksum ( in , out ) ; out . writeBytes ( in , dataLength ) ; } private static void setChunkLength ( ByteBuf out , int lengthIdx ) { int chunkLength = out . writerIndex ( ) - lengthIdx - <int> ; if ( chunkLength > > > <int> ! = <int> ) { throw new CompressionException ( <str> + chunkLength ) ; } out . setMediumLE ( lengthIdx , chunkLength ) ; } private static void writeChunkLength ( ByteBuf out , int chunkLength ) { out . writeMediumLE ( chunkLength ) ; } private static void calculateAndWriteChecksum ( ByteBuf slice , ByteBuf out ) { out . writeIntLE ( calculateChecksum ( slice ) ) ; } } 
