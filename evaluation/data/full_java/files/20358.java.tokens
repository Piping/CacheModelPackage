package io . netty . channel . epoll ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . Unpooled ; import io . netty . channel . AbstractChannel ; import io . netty . channel . Channel ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOption ; import io . netty . channel . EventLoop ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . socket . ChannelInputShutdownEvent ; import io . netty . channel . unix . Socket ; import io . netty . channel . unix . UnixChannel ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . OneTimeTask ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . UnresolvedAddressException ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; abstract class AbstractEpollChannel extends AbstractChannel implements UnixChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( false ) ; private final int readFlag ; private final Socket fileDescriptor ; protected int flags = Native . EPOLLET ; protected volatile boolean active ; AbstractEpollChannel ( Socket fd , int flag ) { this ( null , fd , flag , false ) ; } AbstractEpollChannel ( Channel parent , Socket fd , int flag , boolean active ) { super ( parent ) ; fileDescriptor = checkNotNull ( fd , <str> ) ; readFlag = flag ; flags | = flag ; this . active = active ; } void setFlag ( int flag ) throws IOException { if ( ! isFlagSet ( flag ) ) { flags | = flag ; modifyEvents ( ) ; } } void clearFlag ( int flag ) throws IOException { if ( isFlagSet ( flag ) ) { flags & = ~ flag ; modifyEvents ( ) ; } } boolean isFlagSet ( int flag ) { return ( flags & flag ) ! = <int> ; } @Override public final Socket fd ( ) { return fileDescriptor ; } @Override public abstract EpollChannelConfig config ( ) ; @Override public boolean isActive ( ) { return active ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override protected void doClose ( ) throws Exception { this . active = false ; Socket fd = fileDescriptor ; try { doDeregister ( ) ; if ( ! fd . isShutdown ( ) ) { try { fd ( ) . shutdown ( ) ; } catch ( IOException ignored ) { } } } finally { fd . close ( ) ; } } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof EpollEventLoop ; } @Override public boolean isOpen ( ) { return fileDescriptor . isOpen ( ) ; } @Override protected void doDeregister ( ) throws Exception { ( ( EpollEventLoop ) eventLoop ( ) ) . remove ( this ) ; } @Override protected void doBeginRead ( ) throws Exception { ( ( AbstractEpollUnsafe ) unsafe ( ) ) . readPending = true ; setFlag ( readFlag ) ; } final void clearEpollIn ( ) { if ( isRegistered ( ) ) { final EventLoop loop = eventLoop ( ) ; final AbstractEpollUnsafe unsafe = ( AbstractEpollUnsafe ) unsafe ( ) ; if ( loop . inEventLoop ( ) ) { unsafe . clearEpollIn0 ( ) ; } else { loop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { if ( ! config ( ) . isAutoRead ( ) & & ! unsafe . readPending ) { unsafe . clearEpollIn0 ( ) ; } } } ) ; } } else { flags & = ~ readFlag ; } } private void modifyEvents ( ) throws IOException { if ( isOpen ( ) & & isRegistered ( ) ) { ( ( EpollEventLoop ) eventLoop ( ) ) . modify ( this ) ; } } @Override protected void doRegister ( ) throws Exception { EpollEventLoop loop = ( EpollEventLoop ) eventLoop ( ) ; loop . add ( this ) ; } @Override protected abstract AbstractEpollUnsafe newUnsafe ( ) ; protected final ByteBuf newDirectBuffer ( ByteBuf buf ) { return newDirectBuffer ( buf , buf ) ; } protected final ByteBuf newDirectBuffer ( Object holder , ByteBuf buf ) { final int readableBytes = buf . readableBytes ( ) ; if ( readableBytes = = <int> ) { ReferenceCountUtil . safeRelease ( holder ) ; return Unpooled . EMPTY_BUFFER ; } final ByteBufAllocator alloc = alloc ( ) ; if ( alloc . isDirectBufferPooled ( ) ) { return newDirectBuffer0 ( holder , buf , alloc , readableBytes ) ; } final ByteBuf directBuf = ByteBufUtil . threadLocalDirectBuffer ( ) ; if ( directBuf = = null ) { return newDirectBuffer0 ( holder , buf , alloc , readableBytes ) ; } directBuf . writeBytes ( buf , buf . readerIndex ( ) , readableBytes ) ; ReferenceCountUtil . safeRelease ( holder ) ; return directBuf ; } private static ByteBuf newDirectBuffer0 ( Object holder , ByteBuf buf , ByteBufAllocator alloc , int capacity ) { final ByteBuf directBuf = alloc . directBuffer ( capacity ) ; directBuf . writeBytes ( buf , buf . readerIndex ( ) , capacity ) ; ReferenceCountUtil . safeRelease ( holder ) ; return directBuf ; } protected static void checkResolvable ( InetSocketAddress addr ) { if ( addr . isUnresolved ( ) ) { throw new UnresolvedAddressException ( ) ; } } protected final int doReadBytes ( ByteBuf byteBuf ) throws Exception { int writerIndex = byteBuf . writerIndex ( ) ; int localReadAmount ; unsafe ( ) . recvBufAllocHandle ( ) . attemptedBytesRead ( byteBuf . writableBytes ( ) ) ; if ( byteBuf . hasMemoryAddress ( ) ) { localReadAmount = fileDescriptor . readAddress ( byteBuf . memoryAddress ( ) , writerIndex , byteBuf . capacity ( ) ) ; } else { ByteBuffer buf = byteBuf . internalNioBuffer ( writerIndex , byteBuf . writableBytes ( ) ) ; localReadAmount = fileDescriptor . read ( buf , buf . position ( ) , buf . limit ( ) ) ; } if ( localReadAmount > <int> ) { byteBuf . writerIndex ( writerIndex + localReadAmount ) ; } return localReadAmount ; } protected final int doWriteBytes ( ByteBuf buf , int writeSpinCount ) throws Exception { int readableBytes = buf . readableBytes ( ) ; int writtenBytes = <int> ; if ( buf . hasMemoryAddress ( ) ) { long memoryAddress = buf . memoryAddress ( ) ; int readerIndex = buf . readerIndex ( ) ; int writerIndex = buf . writerIndex ( ) ; for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { int localFlushedAmount = fileDescriptor . writeAddress ( memoryAddress , readerIndex , writerIndex ) ; if ( localFlushedAmount > <int> ) { writtenBytes + = localFlushedAmount ; if ( writtenBytes = = readableBytes ) { return writtenBytes ; } readerIndex + = localFlushedAmount ; } else { break ; } } } else { ByteBuffer nioBuf ; if ( buf . nioBufferCount ( ) = = <int> ) { nioBuf = buf . internalNioBuffer ( buf . readerIndex ( ) , buf . readableBytes ( ) ) ; } else { nioBuf = buf . nioBuffer ( ) ; } for ( int i = writeSpinCount - <int> ; i > = <int> ; i - - ) { int pos = nioBuf . position ( ) ; int limit = nioBuf . limit ( ) ; int localFlushedAmount = fileDescriptor . write ( nioBuf , pos , limit ) ; if ( localFlushedAmount > <int> ) { nioBuf . position ( pos + localFlushedAmount ) ; writtenBytes + = localFlushedAmount ; if ( writtenBytes = = readableBytes ) { return writtenBytes ; } } else { break ; } } } if ( writtenBytes < readableBytes ) { setFlag ( Native . EPOLLOUT ) ; } return writtenBytes ; } protected abstract class AbstractEpollUnsafe extends AbstractUnsafe { protected boolean readPending ; private EpollRecvByteAllocatorHandle allocHandle ; abstract void epollInReady ( ) ; final void checkResetEpollIn ( boolean edgeTriggered ) { if ( edgeTriggered & & ! fd ( ) . isInputShutdown ( ) ) { eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { epollInReady ( ) ; } } ) ; } } final void epollRdHupReady ( ) { recvBufAllocHandle ( ) . receivedRdHup ( ) ; if ( isActive ( ) ) { epollInReady ( ) ; clearEpollRdHup ( ) ; } shutdownInput ( ) ; } private void clearEpollRdHup ( ) { try { clearFlag ( Native . EPOLLRDHUP ) ; } catch ( IOException e ) { pipeline ( ) . fireExceptionCaught ( e ) ; close ( voidPromise ( ) ) ; } } void shutdownInput ( ) { if ( ! fd ( ) . isInputShutdown ( ) ) { if ( Boolean . TRUE . equals ( config ( ) . getOption ( ChannelOption . ALLOW_HALF_CLOSURE ) ) ) { try { fd ( ) . shutdown ( true , false ) ; clearEpollIn0 ( ) ; pipeline ( ) . fireUserEventTriggered ( ChannelInputShutdownEvent . INSTANCE ) ; } catch ( IOException ignored ) { pipeline ( ) . fireUserEventTriggered ( ChannelInputShutdownEvent . INSTANCE ) ; close ( voidPromise ( ) ) ; } } else { close ( voidPromise ( ) ) ; } } } @Override public EpollRecvByteAllocatorHandle recvBufAllocHandle ( ) { if ( allocHandle = = null ) { allocHandle = newEpollHandle ( super . recvBufAllocHandle ( ) ) ; } return allocHandle ; } protected abstract EpollRecvByteAllocatorHandle newEpollHandle ( RecvByteBufAllocator . Handle handle ) ; @Override protected void flush0 ( ) { if ( isFlagSet ( Native . EPOLLOUT ) ) { return ; } super . flush0 ( ) ; } void epollOutReady ( ) { if ( fd ( ) . isOutputShutdown ( ) ) { return ; } super . flush0 ( ) ; } protected final void clearEpollIn0 ( ) { assert eventLoop ( ) . inEventLoop ( ) ; try { clearFlag ( readFlag ) ; } catch ( IOException e ) { pipeline ( ) . fireExceptionCaught ( e ) ; unsafe ( ) . close ( unsafe ( ) . voidPromise ( ) ) ; } } } } 
