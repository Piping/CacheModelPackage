package org . elasticsearch . cluster ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionModule ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsAction ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsAction ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . Collection ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicBoolean ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) public class ClusterInfoServiceIT extends ESIntegTestCase { public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( ActionModule module ) { module . registerFilter ( BlockingActionFilter . class ) ; } } public static class BlockingActionFilter extends org . elasticsearch . action . support . ActionFilter . Simple { private Set < String > blockedActions = emptySet ( ) ; @Inject public BlockingActionFilter ( Settings settings ) { super ( settings ) ; } @Override protected boolean apply ( String action , ActionRequest request , ActionListener listener ) { if ( blockedActions . contains ( action ) ) { throw new ElasticsearchException ( <str> + action + <str> ) ; } return true ; } @Override protected boolean apply ( String action , ActionResponse response , ActionListener listener ) { return true ; } @Override public int order ( ) { return <int> ; } public void blockActions ( String . . . actions ) { blockedActions = unmodifiableSet ( newHashSet ( actions ) ) ; } } @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( InternalClusterInfoService . INTERNAL_CLUSTER_INFO_TIMEOUT , <str> ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( TestPlugin . class , MockTransportService . TestPlugin . class ) ; } public void testClusterInfoServiceCollectsInformation ( ) throws Exception { internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( InternalClusterInfoService . INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , <str> ) . build ( ) ) . get ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( Store . INDEX_STORE_STATS_REFRESH_INTERVAL , <int> ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) . build ( ) ) ) ; ensureGreen ( <str> ) ; InternalTestCluster internalTestCluster = internalCluster ( ) ; final InternalClusterInfoService infoService = ( InternalClusterInfoService ) internalTestCluster . getInstance ( ClusterInfoService . class , internalTestCluster . getMasterName ( ) ) ; ClusterInfo info = infoService . refresh ( ) ; assertNotNull ( <str> , info ) ; ImmutableOpenMap < String , DiskUsage > leastUsages = info . getNodeLeastAvailableDiskUsages ( ) ; ImmutableOpenMap < String , DiskUsage > mostUsages = info . getNodeMostAvailableDiskUsages ( ) ; ImmutableOpenMap < String , Long > shardSizes = info . shardSizes ; assertNotNull ( leastUsages ) ; assertNotNull ( shardSizes ) ; assertThat ( <str> , leastUsages . values ( ) . size ( ) , Matchers . equalTo ( <int> ) ) ; assertThat ( <str> , shardSizes . values ( ) . size ( ) , greaterThan ( <int> ) ) ; for ( ObjectCursor < DiskUsage > usage : leastUsages . values ( ) ) { logger . info ( <str> , usage . value ) ; assertThat ( <str> , usage . value . getFreeBytes ( ) , greaterThan ( <int> L ) ) ; } for ( ObjectCursor < DiskUsage > usage : mostUsages . values ( ) ) { logger . info ( <str> , usage . value ) ; assertThat ( <str> , usage . value . getFreeBytes ( ) , greaterThan ( <int> L ) ) ; } for ( ObjectCursor < Long > size : shardSizes . values ( ) ) { logger . info ( <str> , size . value ) ; assertThat ( <str> , size . value , greaterThanOrEqualTo ( <int> L ) ) ; } ClusterService clusterService = internalTestCluster . getInstance ( ClusterService . class , internalTestCluster . getMasterName ( ) ) ; ClusterState state = clusterService . state ( ) ; RoutingNodes routingNodes = state . getRoutingNodes ( ) ; for ( ShardRouting shard : routingNodes . getRoutingTable ( ) . allShards ( ) ) { String dataPath = info . getDataPath ( shard ) ; assertNotNull ( dataPath ) ; String nodeId = shard . currentNodeId ( ) ; DiscoveryNode discoveryNode = state . getNodes ( ) . get ( nodeId ) ; IndicesService indicesService = internalTestCluster . getInstance ( IndicesService . class , discoveryNode . getName ( ) ) ; IndexService indexService = indicesService . indexService ( shard . index ( ) ) ; IndexShard indexShard = indexService . getShardOrNull ( shard . id ( ) ) ; assertEquals ( indexShard . shardPath ( ) . getRootDataPath ( ) . toString ( ) , dataPath ) ; } } public void testClusterInfoServiceInformationClearOnError ( ) throws InterruptedException , ExecutionException { internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( InternalClusterInfoService . INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , <str> ) . build ( ) ) . get ( ) ; prepareCreate ( <str> ) . setSettings ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . get ( ) ; ensureGreen ( <str> ) ; InternalTestCluster internalTestCluster = internalCluster ( ) ; InternalClusterInfoService infoService = ( InternalClusterInfoService ) internalTestCluster . getInstance ( ClusterInfoService . class , internalTestCluster . getMasterName ( ) ) ; ClusterInfo info = infoService . refresh ( ) ; assertNotNull ( <str> , info ) ; assertThat ( <str> , info . getNodeLeastAvailableDiskUsages ( ) . size ( ) , Matchers . equalTo ( <int> ) ) ; assertThat ( <str> , info . shardSizes . size ( ) , greaterThan ( <int> ) ) ; MockTransportService mockTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , internalTestCluster . getMasterName ( ) ) ; final AtomicBoolean timeout = new AtomicBoolean ( false ) ; final Set < String > blockedActions = newHashSet ( NodesStatsAction . NAME , NodesStatsAction . NAME + <str> , IndicesStatsAction . NAME , IndicesStatsAction . NAME + <str> ) ; for ( DiscoveryNode node : internalTestCluster . clusterService ( ) . state ( ) . getNodes ( ) ) { mockTransportService . addDelegate ( internalTestCluster . getInstance ( TransportService . class , node . getName ( ) ) , new MockTransportService . DelegateTransport ( mockTransportService . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( blockedActions . contains ( action ) ) { if ( timeout . get ( ) ) { logger . info ( <str> , action , node ) ; return ; } } super . sendRequest ( node , requestId , action , request , options ) ; } } ) ; } timeout . set ( true ) ; info = infoService . refresh ( ) ; assertNotNull ( <str> , info ) ; assertThat ( info . getNodeLeastAvailableDiskUsages ( ) . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( info . getNodeMostAvailableDiskUsages ( ) . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( info . shardSizes . size ( ) , greaterThan ( <int> ) ) ; timeout . set ( false ) ; ActionFilters actionFilters = internalTestCluster . getInstance ( ActionFilters . class , internalTestCluster . getMasterName ( ) ) ; BlockingActionFilter blockingActionFilter = null ; for ( ActionFilter filter : actionFilters . filters ( ) ) { if ( filter instanceof BlockingActionFilter ) { blockingActionFilter = ( BlockingActionFilter ) filter ; break ; } } assertNotNull ( <str> , blockingActionFilter ) ; blockingActionFilter . blockActions ( blockedActions . toArray ( Strings . EMPTY_ARRAY ) ) ; info = infoService . refresh ( ) ; assertNotNull ( <str> , info ) ; assertThat ( info . getNodeLeastAvailableDiskUsages ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( info . getNodeMostAvailableDiskUsages ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( info . shardSizes . size ( ) , equalTo ( <int> ) ) ; blockingActionFilter . blockActions ( ) ; info = infoService . refresh ( ) ; assertNotNull ( <str> , info ) ; assertThat ( info . getNodeLeastAvailableDiskUsages ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( info . getNodeMostAvailableDiskUsages ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( info . shardSizes . size ( ) , greaterThan ( <int> ) ) ; } } 
