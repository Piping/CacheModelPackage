package io . netty . testsuite . transport . udt ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . group . ChannelGroup ; import io . netty . channel . group . DefaultChannelGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . udt . UdtChannel ; import io . netty . channel . udt . nio . NioUdtProvider ; import io . netty . handler . codec . DelimiterBasedFrameDecoder ; import io . netty . handler . codec . Delimiters ; import io . netty . handler . codec . string . StringDecoder ; import io . netty . handler . codec . string . StringEncoder ; import io . netty . util . CharsetUtil ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . concurrent . GlobalEventExecutor ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ThreadFactory ; import static org . junit . Assert . * ; public class UDTClientServerConnectionTest { static class Client implements Runnable { static final Logger log = LoggerFactory . getLogger ( Client . class ) ; final String host ; final int port ; volatile Channel channel ; volatile boolean isRunning ; volatile boolean isShutdown ; Client ( final String host , final int port ) { this . host = host ; this . port = port ; } @Override public void run ( ) { final Bootstrap boot = new Bootstrap ( ) ; final ThreadFactory clientFactory = new DefaultThreadFactory ( <str> ) ; final NioEventLoopGroup connectGroup = new NioEventLoopGroup ( <int> , clientFactory , NioUdtProvider . BYTE_PROVIDER ) ; try { boot . group ( connectGroup ) . channelFactory ( NioUdtProvider . BYTE_CONNECTOR ) . handler ( new ChannelInitializer < UdtChannel > ( ) { @Override protected void initChannel ( final UdtChannel ch ) throws Exception { final ChannelPipeline pipeline = ch . pipeline ( ) ; pipeline . addLast ( <str> , new DelimiterBasedFrameDecoder ( <int> , Delimiters . lineDelimiter ( ) ) ) ; pipeline . addLast ( <str> , new StringDecoder ( CharsetUtil . UTF_8 ) ) ; pipeline . addLast ( <str> , new StringEncoder ( CharsetUtil . UTF_8 ) ) ; pipeline . addLast ( <str> , new ClientHandler ( ) ) ; } } ) ; channel = boot . connect ( host , port ) . sync ( ) . channel ( ) ; isRunning = true ; log . info ( <str> ) ; waitForRunning ( false ) ; log . info ( <str> ) ; channel . close ( ) . sync ( ) ; isShutdown = true ; log . info ( <str> ) ; } catch ( final Throwable e ) { log . error ( <str> , e ) ; } finally { connectGroup . shutdownGracefully ( ) . syncUninterruptibly ( ) ; } } void shutdown ( ) { isRunning = false ; } void waitForActive ( final boolean isActive ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { Thread . sleep ( WAIT_SLEEP ) ; final ClientHandler handler = channel . pipeline ( ) . get ( ClientHandler . class ) ; if ( handler ! = null & & isActive = = handler . isActive ) { return ; } } } void waitForRunning ( final boolean isRunning ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { if ( isRunning = = this . isRunning ) { return ; } Thread . sleep ( WAIT_SLEEP ) ; } } private void waitForShutdown ( ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { if ( isShutdown ) { return ; } Thread . sleep ( WAIT_SLEEP ) ; } } } static class ClientHandler extends SimpleChannelInboundHandler < Object > { static final Logger log = LoggerFactory . getLogger ( ClientHandler . class ) ; volatile boolean isActive ; @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { isActive = true ; log . info ( <str> , ctx . channel ( ) ) ; super . channelActive ( ctx ) ; } @Override public void channelInactive ( final ChannelHandlerContext ctx ) throws Exception { isActive = false ; log . info ( <str> , ctx . channel ( ) ) ; super . channelInactive ( ctx ) ; } @Override public void exceptionCaught ( final ChannelHandlerContext ctx , final Throwable cause ) throws Exception { log . warn ( <str> , cause ) ; ctx . close ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { log . info ( <str> + msg ) ; } } static class Server implements Runnable { static final Logger log = LoggerFactory . getLogger ( Server . class ) ; final ChannelGroup group = new DefaultChannelGroup ( <str> , GlobalEventExecutor . INSTANCE ) ; final String host ; final int port ; volatile Channel channel ; volatile boolean isRunning ; volatile boolean isShutdown ; Server ( final String host , final int port ) { this . host = host ; this . port = port ; } @Override public void run ( ) { final ServerBootstrap boot = new ServerBootstrap ( ) ; final ThreadFactory acceptFactory = new DefaultThreadFactory ( <str> ) ; final ThreadFactory serverFactory = new DefaultThreadFactory ( <str> ) ; final NioEventLoopGroup acceptGroup = new NioEventLoopGroup ( <int> , acceptFactory , NioUdtProvider . BYTE_PROVIDER ) ; final NioEventLoopGroup connectGroup = new NioEventLoopGroup ( <int> , serverFactory , NioUdtProvider . BYTE_PROVIDER ) ; try { boot . group ( acceptGroup , connectGroup ) . channelFactory ( NioUdtProvider . BYTE_ACCEPTOR ) . childHandler ( new ChannelInitializer < UdtChannel > ( ) { @Override protected void initChannel ( final UdtChannel ch ) throws Exception { final ChannelPipeline pipeline = ch . pipeline ( ) ; pipeline . addLast ( <str> , new DelimiterBasedFrameDecoder ( <int> , Delimiters . lineDelimiter ( ) ) ) ; pipeline . addLast ( <str> , new StringDecoder ( CharsetUtil . UTF_8 ) ) ; pipeline . addLast ( <str> , new StringEncoder ( CharsetUtil . UTF_8 ) ) ; pipeline . addLast ( <str> , new ServerHandler ( group ) ) ; } } ) ; channel = boot . bind ( port ) . sync ( ) . channel ( ) ; isRunning = true ; log . info ( <str> ) ; waitForRunning ( false ) ; log . info ( <str> ) ; channel . close ( ) . sync ( ) ; log . info ( <str> ) ; group . close ( ) . sync ( ) ; isShutdown = true ; log . info ( <str> ) ; } catch ( final Throwable e ) { log . error ( <str> , e ) ; } finally { acceptGroup . shutdownGracefully ( ) ; connectGroup . shutdownGracefully ( ) ; acceptGroup . terminationFuture ( ) . syncUninterruptibly ( ) ; connectGroup . terminationFuture ( ) . syncUninterruptibly ( ) ; } } void shutdown ( ) { isRunning = false ; } void waitForActive ( final boolean isActive ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { Thread . sleep ( WAIT_SLEEP ) ; if ( isActive ) { for ( final Channel channel : group ) { final ServerHandler handler = channel . pipeline ( ) . get ( ServerHandler . class ) ; if ( handler ! = null & & handler . isActive ) { return ; } } } else { if ( group . isEmpty ( ) ) { return ; } } } } void waitForRunning ( final boolean isRunning ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { if ( isRunning = = this . isRunning ) { return ; } Thread . sleep ( WAIT_SLEEP ) ; } } void waitForShutdown ( ) throws Exception { for ( int k = <int> ; k < WAIT_COUNT ; k + + ) { if ( isShutdown ) { return ; } Thread . sleep ( WAIT_SLEEP ) ; } } } static class ServerHandler extends SimpleChannelInboundHandler < Object > { static final Logger log = LoggerFactory . getLogger ( ServerHandler . class ) ; final ChannelGroup group ; volatile boolean isActive ; ServerHandler ( final ChannelGroup group ) { this . group = group ; } @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { group . add ( ctx . channel ( ) ) ; isActive = true ; log . info ( <str> , ctx . channel ( ) ) ; super . channelActive ( ctx ) ; } @Override public void channelInactive ( final ChannelHandlerContext ctx ) throws Exception { group . remove ( ctx . channel ( ) ) ; isActive = false ; log . info ( <str> , ctx . channel ( ) ) ; super . channelInactive ( ctx ) ; } @Override public void exceptionCaught ( final ChannelHandlerContext ctx , final Throwable cause ) { log . warn ( <str> , cause ) ; ctx . close ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { log . info ( <str> + msg ) ; } } static final Logger log = LoggerFactory . getLogger ( UDTClientServerConnectionTest . class ) ; static final int WAIT_COUNT = <int> ; static final int WAIT_SLEEP = <int> ; @Test public void connection ( ) throws Exception { final String host = <str> ; final int port = <int> ; log . info ( <str> ) ; final Server server = new Server ( host , port ) ; final Thread serverTread = new Thread ( server , <str> ) ; serverTread . start ( ) ; server . waitForRunning ( true ) ; assertTrue ( server . isRunning ) ; log . info ( <str> ) ; final Client client = new Client ( host , port ) ; final Thread clientThread = new Thread ( client , <str> ) ; clientThread . start ( ) ; client . waitForRunning ( true ) ; assertTrue ( client . isRunning ) ; log . info ( <str> ) ; client . waitForActive ( true ) ; server . waitForActive ( true ) ; log . info ( <str> ) ; assertEquals ( <str> , <int> , server . group . size ( ) ) ; log . info ( <str> ) ; client . shutdown ( ) ; client . waitForShutdown ( ) ; assertTrue ( client . isShutdown ) ; log . info ( <str> ) ; client . waitForActive ( false ) ; server . waitForActive ( false ) ; log . info ( <str> ) ; assertEquals ( <str> , <int> , server . group . size ( ) ) ; log . info ( <str> ) ; server . shutdown ( ) ; server . waitForShutdown ( ) ; assertTrue ( server . isShutdown ) ; log . info ( <str> ) ; } } 
