package org . gradle . api . internal . file . collections . jdk7 ; import org . gradle . api . GradleException ; import org . gradle . api . file . FileTreeElement ; import org . gradle . api . file . FileVisitDetails ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . file . RelativePath ; import org . gradle . api . internal . file . DefaultFileVisitDetails ; import org . gradle . api . internal . file . collections . DirectoryWalker ; import org . gradle . api . specs . Spec ; import org . gradle . internal . nativeintegration . filesystem . FileSystem ; import java . io . File ; import java . io . IOException ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . Deque ; import java . util . EnumSet ; import java . util . LinkedList ; import java . util . concurrent . atomic . AtomicBoolean ; public class Jdk7DirectoryWalker implements DirectoryWalker { static boolean isAllowed ( FileTreeElement element , Spec < FileTreeElement > spec ) { return spec . isSatisfiedBy ( element ) ; } @Override public void walkDir ( final File rootDir , final RelativePath rootPath , final FileVisitor visitor , final Spec < FileTreeElement > spec , final AtomicBoolean stopFlag , final FileSystem fileSystem , final boolean postfix ) { final Deque < FileVisitDetails > directoryDetailsHolder = new LinkedList < FileVisitDetails > ( ) ; try { Files . walkFileTree ( rootDir . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new java . nio . file . FileVisitor < Path > ( ) { @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { FileVisitDetails details = getFileVisitDetails ( dir , attrs , true ) ; if ( directoryDetailsHolder . size ( ) = = <int> | | isAllowed ( details , spec ) ) { directoryDetailsHolder . push ( details ) ; if ( directoryDetailsHolder . size ( ) > <int> & & ! postfix ) { visitor . visitDir ( details ) ; } return checkStopFlag ( ) ; } else { return FileVisitResult . SKIP_SUBTREE ; } } private FileVisitResult checkStopFlag ( ) { return stopFlag . get ( ) ? FileVisitResult . TERMINATE : FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( attrs . isSymbolicLink ( ) ) { throw new GradleException ( String . format ( <str> , file ) ) ; } FileVisitDetails details = getFileVisitDetails ( file , attrs , false ) ; if ( isAllowed ( details , spec ) ) { visitor . visitFile ( details ) ; } return checkStopFlag ( ) ; } private FileVisitDetails getFileVisitDetails ( Path file , BasicFileAttributes attrs , boolean isDirectory ) { File child = file . toFile ( ) ; FileVisitDetails dirDetails = directoryDetailsHolder . peek ( ) ; RelativePath childPath = dirDetails ! = null ? dirDetails . getRelativePath ( ) . append ( ! isDirectory , child . getName ( ) ) : rootPath ; return new DefaultFileVisitDetails ( child , childPath , stopFlag , fileSystem , fileSystem , isDirectory , attrs . lastModifiedTime ( ) . toMillis ( ) , attrs . size ( ) ) ; } @Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) throws IOException { if ( exc ! = null & & ! ( exc instanceof FileSystemLoopException ) ) { throw new GradleException ( String . format ( <str> , file ) , exc ) ; } return checkStopFlag ( ) ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { if ( exc ! = null ) { if ( ! ( exc instanceof FileSystemLoopException ) ) { throw new GradleException ( String . format ( <str> , dir ) , exc ) ; } } else { if ( postfix ) { FileVisitDetails details = directoryDetailsHolder . peek ( ) ; if ( directoryDetailsHolder . size ( ) > <int> & & details ! = null ) { visitor . visitDir ( details ) ; } } } directoryDetailsHolder . pop ( ) ; return checkStopFlag ( ) ; } } ) ; } catch ( IOException e ) { throw new GradleException ( String . format ( <str> , rootDir ) , e ) ; } } } 
