package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . ObjectUtil ; import java . util . ArrayDeque ; public final class CoalescingBufferQueue { private final Channel channel ; private final ArrayDeque < Object > bufAndListenerPairs = new ArrayDeque < Object > ( ) ; private int readableBytes ; public CoalescingBufferQueue ( Channel channel ) { this . channel = ObjectUtil . checkNotNull ( channel , <str> ) ; } public void add ( ByteBuf buf ) { add ( buf , ( ChannelFutureListener ) null ) ; } public void add ( ByteBuf buf , ChannelPromise promise ) { ObjectUtil . checkNotNull ( promise , <str> ) ; add ( buf , promise . isVoid ( ) ? null : new ChannelPromiseNotifier ( promise ) ) ; } public void add ( ByteBuf buf , ChannelFutureListener listener ) { ObjectUtil . checkNotNull ( buf , <str> ) ; if ( readableBytes > Integer . MAX_VALUE - buf . readableBytes ( ) ) { throw new IllegalStateException ( <str> + readableBytes + <str> + buf . readableBytes ( ) ) ; } bufAndListenerPairs . add ( buf ) ; if ( listener ! = null ) { bufAndListenerPairs . add ( listener ) ; } readableBytes + = buf . readableBytes ( ) ; } public ByteBuf remove ( int bytes , ChannelPromise aggregatePromise ) { if ( bytes < <int> ) { throw new IllegalArgumentException ( <str> + bytes ) ; } ObjectUtil . checkNotNull ( aggregatePromise , <str> ) ; if ( bufAndListenerPairs . isEmpty ( ) ) { return Unpooled . EMPTY_BUFFER ; } bytes = Math . min ( bytes , readableBytes ) ; ByteBuf toReturn = null ; int originalBytes = bytes ; for ( ; ; ) { Object entry = bufAndListenerPairs . poll ( ) ; if ( entry = = null ) { break ; } if ( entry instanceof ChannelFutureListener ) { aggregatePromise . addListener ( ( ChannelFutureListener ) entry ) ; continue ; } ByteBuf entryBuffer = ( ByteBuf ) entry ; if ( entryBuffer . readableBytes ( ) > bytes ) { bufAndListenerPairs . addFirst ( entryBuffer ) ; if ( bytes > <int> ) { toReturn = compose ( toReturn , entryBuffer . readSlice ( bytes ) . retain ( ) ) ; bytes = <int> ; } break ; } else { toReturn = compose ( toReturn , entryBuffer ) ; bytes - = entryBuffer . readableBytes ( ) ; } } readableBytes - = originalBytes - bytes ; assert readableBytes > = <int> ; return toReturn ; } private ByteBuf compose ( ByteBuf current , ByteBuf next ) { if ( current = = null ) { return next ; } if ( current instanceof CompositeByteBuf ) { CompositeByteBuf composite = ( CompositeByteBuf ) current ; composite . addComponent ( next ) ; composite . writerIndex ( composite . writerIndex ( ) + next . readableBytes ( ) ) ; return composite ; } CompositeByteBuf composite = channel . alloc ( ) . compositeBuffer ( bufAndListenerPairs . size ( ) + <int> ) ; composite . addComponent ( current ) ; composite . addComponent ( next ) ; return composite . writerIndex ( current . readableBytes ( ) + next . readableBytes ( ) ) ; } public int readableBytes ( ) { return readableBytes ; } public boolean isEmpty ( ) { return bufAndListenerPairs . isEmpty ( ) ; } public void releaseAndFailAll ( Throwable cause ) { releaseAndCompleteAll ( channel . newFailedFuture ( cause ) ) ; } private void releaseAndCompleteAll ( ChannelFuture future ) { readableBytes = <int> ; Throwable pending = null ; for ( ; ; ) { Object entry = bufAndListenerPairs . poll ( ) ; if ( entry = = null ) { break ; } try { if ( entry instanceof ByteBuf ) { ReferenceCountUtil . safeRelease ( entry ) ; } else { ( ( ChannelFutureListener ) entry ) . operationComplete ( future ) ; } } catch ( Throwable t ) { pending = t ; } } if ( pending ! = null ) { throw new IllegalStateException ( pending ) ; } } public void copyTo ( CoalescingBufferQueue dest ) { dest . bufAndListenerPairs . addAll ( bufAndListenerPairs ) ; dest . readableBytes + = readableBytes ; } } 
