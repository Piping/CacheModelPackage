package org . gradle . model . internal . manage . schema . extract ; import org . gradle . api . Action ; import org . gradle . model . internal . manage . schema . CollectionSchema ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . ModelSetSchema ; import org . gradle . model . internal . type . ModelType ; public abstract class SetStrategy extends CollectionStrategy { private final ModelType < ? > modelType ; public SetStrategy ( ModelType < ? > modelType ) { this . modelType = modelType ; } public < T > void extract ( ModelSchemaExtractionContext < T > extractionContext ) { ModelType < T > type = extractionContext . getType ( ) ; if ( modelType . isAssignableFrom ( type ) ) { validateType ( modelType , extractionContext , type ) ; ModelType < ? > elementType = type . getTypeVariables ( ) . get ( <int> ) ; extractionContext . found ( getModelSchema ( modelType , extractionContext , elementType ) ) ; } } protected < T , E > ModelSchema < T > getModelSchema ( ModelType < ? > modelType , final ModelSchemaExtractionContext < T > extractionContext , final ModelType < E > elementType ) { if ( modelType . isAssignableFrom ( elementType ) ) { throw new InvalidManagedModelElementTypeException ( extractionContext , String . format ( <str> , modelType . getConcreteClass ( ) . getName ( ) ) ) ; } final CollectionSchema < T , E > schema = new ModelSetSchema < T , E > ( extractionContext . getType ( ) , elementType ) ; extractionContext . child ( elementType , <str> , new Action < ModelSchema < E > > ( ) { @Override public void execute ( ModelSchema < E > elementTypeSchema ) { schema . setElementTypeSchema ( elementTypeSchema ) ; } } ) ; return schema ; } } 
