package io . netty . channel . socket . oio ; import io . netty . buffer . ByteBuf ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPromise ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . oio . AbstractOioMessageChannel ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . DatagramChannelConfig ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . socket . DefaultDatagramChannelConfig ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . MulticastSocket ; import java . net . NetworkInterface ; import java . net . SocketAddress ; import java . net . SocketException ; import java . net . SocketTimeoutException ; import java . util . List ; import java . util . Locale ; public class OioDatagramChannel extends AbstractOioMessageChannel implements DatagramChannel { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OioDatagramChannel . class ) ; private static final ChannelMetadata METADATA = new ChannelMetadata ( true ) ; private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( DatagramPacket . class ) + <str> + StringUtil . simpleClassName ( AddressedEnvelope . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( SocketAddress . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> ; private final MulticastSocket socket ; private final DatagramChannelConfig config ; private final java . net . DatagramPacket tmpPacket = new java . net . DatagramPacket ( EmptyArrays . EMPTY_BYTES , <int> ) ; private static MulticastSocket newSocket ( ) { try { return new MulticastSocket ( null ) ; } catch ( Exception e ) { throw new ChannelException ( <str> , e ) ; } } public OioDatagramChannel ( ) { this ( newSocket ( ) ) ; } public OioDatagramChannel ( MulticastSocket socket ) { super ( null ) ; boolean success = false ; try { socket . setSoTimeout ( SO_TIMEOUT ) ; socket . setBroadcast ( false ) ; success = true ; } catch ( SocketException e ) { throw new ChannelException ( <str> , e ) ; } finally { if ( ! success ) { socket . close ( ) ; } } this . socket = socket ; config = new DefaultDatagramChannelConfig ( this , socket ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public DatagramChannelConfig config ( ) { return config ; } @Override public boolean isOpen ( ) { return ! socket . isClosed ( ) ; } @Override @SuppressWarnings ( <str> ) public boolean isActive ( ) { return isOpen ( ) & & ( config . getOption ( ChannelOption . DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION ) & & isRegistered ( ) | | socket . isBound ( ) ) ; } @Override public boolean isConnected ( ) { return socket . isConnected ( ) ; } @Override protected SocketAddress localAddress0 ( ) { return socket . getLocalSocketAddress ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { return socket . getRemoteSocketAddress ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { socket . bind ( localAddress ) ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } @Override protected void doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( localAddress ! = null ) { socket . bind ( localAddress ) ; } boolean success = false ; try { socket . connect ( remoteAddress ) ; success = true ; } finally { if ( ! success ) { try { socket . close ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } } @Override protected void doDisconnect ( ) throws Exception { socket . disconnect ( ) ; } @Override protected void doClose ( ) throws Exception { socket . close ( ) ; } @Override protected int doReadMessages ( List < Object > buf ) throws Exception { DatagramChannelConfig config = config ( ) ; final RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; ByteBuf data = config . getAllocator ( ) . heapBuffer ( allocHandle . guess ( ) ) ; boolean free = true ; try { tmpPacket . setData ( data . array ( ) , data . arrayOffset ( ) , data . capacity ( ) ) ; socket . receive ( tmpPacket ) ; InetSocketAddress remoteAddr = ( InetSocketAddress ) tmpPacket . getSocketAddress ( ) ; allocHandle . lastBytesRead ( tmpPacket . getLength ( ) ) ; buf . add ( new DatagramPacket ( data . writerIndex ( allocHandle . lastBytesRead ( ) ) , localAddress ( ) , remoteAddr ) ) ; free = false ; return <int> ; } catch ( SocketTimeoutException e ) { return <int> ; } catch ( SocketException e ) { if ( ! e . getMessage ( ) . toLowerCase ( Locale . US ) . contains ( <str> ) ) { throw e ; } return - <int> ; } catch ( Throwable cause ) { PlatformDependent . throwException ( cause ) ; return - <int> ; } finally { if ( free ) { data . release ( ) ; } } } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { for ( ; ; ) { final Object o = in . current ( ) ; if ( o = = null ) { break ; } final ByteBuf data ; final SocketAddress remoteAddress ; if ( o instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < ByteBuf , SocketAddress > envelope = ( AddressedEnvelope < ByteBuf , SocketAddress > ) o ; remoteAddress = envelope . recipient ( ) ; data = envelope . content ( ) ; } else { data = ( ByteBuf ) o ; remoteAddress = null ; } final int length = data . readableBytes ( ) ; if ( remoteAddress ! = null ) { tmpPacket . setSocketAddress ( remoteAddress ) ; } if ( data . hasArray ( ) ) { tmpPacket . setData ( data . array ( ) , data . arrayOffset ( ) + data . readerIndex ( ) , length ) ; } else { byte [ ] tmp = new byte [ length ] ; data . getBytes ( data . readerIndex ( ) , tmp ) ; tmpPacket . setData ( tmp ) ; } try { socket . send ( tmpPacket ) ; in . remove ( ) ; } catch ( IOException e ) { in . remove ( e ) ; } } } @Override protected Object filterOutboundMessage ( Object msg ) { if ( msg instanceof DatagramPacket | | msg instanceof ByteBuf ) { return msg ; } if ( msg instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < Object , SocketAddress > e = ( AddressedEnvelope < Object , SocketAddress > ) msg ; if ( e . content ( ) instanceof ByteBuf ) { return msg ; } } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress ) { return joinGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelPromise promise ) { ensureBound ( ) ; try { socket . joinGroup ( multicastAddress ) ; promise . setSuccess ( ) ; } catch ( IOException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return joinGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { ensureBound ( ) ; try { socket . joinGroup ( multicastAddress , networkInterface ) ; promise . setSuccess ( ) ; } catch ( IOException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return newFailedFuture ( new UnsupportedOperationException ( ) ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , ChannelPromise promise ) { promise . setFailure ( new UnsupportedOperationException ( ) ) ; return promise ; } private void ensureBound ( ) { if ( ! isActive ( ) ) { throw new IllegalStateException ( DatagramChannel . class . getName ( ) + <str> ) ; } } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress ) { return leaveGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelPromise promise ) { try { socket . leaveGroup ( multicastAddress ) ; promise . setSuccess ( ) ; } catch ( IOException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return leaveGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { try { socket . leaveGroup ( multicastAddress , networkInterface ) ; promise . setSuccess ( ) ; } catch ( IOException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return newFailedFuture ( new UnsupportedOperationException ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , ChannelPromise promise ) { promise . setFailure ( new UnsupportedOperationException ( ) ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress sourceToBlock ) { return newFailedFuture ( new UnsupportedOperationException ( ) ) ; } @Override public ChannelFuture block ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress sourceToBlock , ChannelPromise promise ) { promise . setFailure ( new UnsupportedOperationException ( ) ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock ) { return newFailedFuture ( new UnsupportedOperationException ( ) ) ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock , ChannelPromise promise ) { promise . setFailure ( new UnsupportedOperationException ( ) ) ; return promise ; } } 
