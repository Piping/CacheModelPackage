package org . elasticsearch . index . get ; import org . apache . lucene . index . Term ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . metrics . MeanMetric ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . common . xcontent . support . XContentMapValues ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . fieldvisitor . CustomFieldsVisitor ; import org . elasticsearch . index . fieldvisitor . FieldsVisitor ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . ParentFieldMapper ; import org . elasticsearch . index . mapper . internal . RoutingFieldMapper ; import org . elasticsearch . index . mapper . internal . SourceFieldMapper ; import org . elasticsearch . index . mapper . internal . TTLFieldMapper ; import org . elasticsearch . index . mapper . internal . TimestampFieldMapper ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . shard . AbstractIndexShardComponent ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import org . elasticsearch . search . lookup . LeafSearchLookup ; import org . elasticsearch . search . lookup . SearchLookup ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . TimeUnit ; public final class ShardGetService extends AbstractIndexShardComponent { private final MapperService mapperService ; private final MeanMetric existsMetric = new MeanMetric ( ) ; private final MeanMetric missingMetric = new MeanMetric ( ) ; private final CounterMetric currentMetric = new CounterMetric ( ) ; private final IndexShard indexShard ; public ShardGetService ( IndexSettings indexSettings , IndexShard indexShard , MapperService mapperService ) { super ( indexShard . shardId ( ) , indexSettings ) ; this . mapperService = mapperService ; this . indexShard = indexShard ; } public GetStats stats ( ) { return new GetStats ( existsMetric . count ( ) , TimeUnit . NANOSECONDS . toMillis ( existsMetric . sum ( ) ) , missingMetric . count ( ) , TimeUnit . NANOSECONDS . toMillis ( missingMetric . sum ( ) ) , currentMetric . count ( ) ) ; } public GetResult get ( String type , String id , String [ ] gFields , boolean realtime , long version , VersionType versionType , FetchSourceContext fetchSourceContext , boolean ignoreErrorsOnGeneratedFields ) { currentMetric . inc ( ) ; try { long now = System . nanoTime ( ) ; GetResult getResult = innerGet ( type , id , gFields , realtime , version , versionType , fetchSourceContext , ignoreErrorsOnGeneratedFields ) ; if ( getResult . isExists ( ) ) { existsMetric . inc ( System . nanoTime ( ) - now ) ; } else { missingMetric . inc ( System . nanoTime ( ) - now ) ; } return getResult ; } finally { currentMetric . dec ( ) ; } } public GetResult get ( Engine . GetResult engineGetResult , String id , String type , String [ ] fields , FetchSourceContext fetchSourceContext , boolean ignoreErrorsOnGeneratedFields ) { if ( ! engineGetResult . exists ( ) ) { return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } currentMetric . inc ( ) ; try { long now = System . nanoTime ( ) ; DocumentMapper docMapper = mapperService . documentMapper ( type ) ; if ( docMapper = = null ) { missingMetric . inc ( System . nanoTime ( ) - now ) ; return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } fetchSourceContext = normalizeFetchSourceContent ( fetchSourceContext , fields ) ; GetResult getResult = innerGetLoadFromStoredFields ( type , id , fields , fetchSourceContext , engineGetResult , docMapper , ignoreErrorsOnGeneratedFields ) ; if ( getResult . isExists ( ) ) { existsMetric . inc ( System . nanoTime ( ) - now ) ; } else { missingMetric . inc ( System . nanoTime ( ) - now ) ; } return getResult ; } finally { currentMetric . dec ( ) ; } } private FetchSourceContext normalizeFetchSourceContent ( @Nullable FetchSourceContext context , @Nullable String [ ] gFields ) { if ( context ! = null ) { return context ; } if ( gFields = = null ) { return FetchSourceContext . FETCH_SOURCE ; } for ( String field : gFields ) { if ( SourceFieldMapper . NAME . equals ( field ) ) { return FetchSourceContext . FETCH_SOURCE ; } } return FetchSourceContext . DO_NOT_FETCH_SOURCE ; } private GetResult innerGet ( String type , String id , String [ ] gFields , boolean realtime , long version , VersionType versionType , FetchSourceContext fetchSourceContext , boolean ignoreErrorsOnGeneratedFields ) { fetchSourceContext = normalizeFetchSourceContent ( fetchSourceContext , gFields ) ; Engine . GetResult get = null ; if ( type = = null | | type . equals ( <str> ) ) { for ( String typeX : mapperService . types ( ) ) { get = indexShard . get ( new Engine . Get ( realtime , new Term ( UidFieldMapper . NAME , Uid . createUidAsBytes ( typeX , id ) ) ) . version ( version ) . versionType ( versionType ) ) ; if ( get . exists ( ) ) { type = typeX ; break ; } else { get . release ( ) ; } } if ( get = = null ) { return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } if ( ! get . exists ( ) ) { return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } } else { get = indexShard . get ( new Engine . Get ( realtime , new Term ( UidFieldMapper . NAME , Uid . createUidAsBytes ( type , id ) ) ) . version ( version ) . versionType ( versionType ) ) ; if ( ! get . exists ( ) ) { get . release ( ) ; return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } } DocumentMapper docMapper = mapperService . documentMapper ( type ) ; if ( docMapper = = null ) { get . release ( ) ; return new GetResult ( shardId . index ( ) . name ( ) , type , id , - <int> , false , null , null ) ; } try { if ( get . docIdAndVersion ( ) ! = null ) { return innerGetLoadFromStoredFields ( type , id , gFields , fetchSourceContext , get , docMapper , ignoreErrorsOnGeneratedFields ) ; } else { Translog . Source source = get . source ( ) ; Map < String , GetField > fields = null ; SearchLookup searchLookup = null ; Set < String > neededFields = new HashSet < > ( ) ; neededFields . add ( RoutingFieldMapper . NAME ) ; if ( docMapper . parentFieldMapper ( ) . active ( ) ) { neededFields . add ( ParentFieldMapper . NAME ) ; } if ( docMapper . timestampFieldMapper ( ) . enabled ( ) ) { neededFields . add ( TimestampFieldMapper . NAME ) ; } if ( docMapper . TTLFieldMapper ( ) . enabled ( ) ) { neededFields . add ( TTLFieldMapper . NAME ) ; } if ( gFields ! = null ) { neededFields . addAll ( Arrays . asList ( gFields ) ) ; } for ( String field : neededFields ) { if ( SourceFieldMapper . NAME . equals ( field ) ) { continue ; } Object value = null ; if ( field . equals ( RoutingFieldMapper . NAME ) ) { value = source . routing ; } else if ( field . equals ( ParentFieldMapper . NAME ) & & docMapper . parentFieldMapper ( ) . active ( ) ) { value = source . parent ; } else if ( field . equals ( TimestampFieldMapper . NAME ) & & docMapper . timestampFieldMapper ( ) . enabled ( ) ) { value = source . timestamp ; } else if ( field . equals ( TTLFieldMapper . NAME ) & & docMapper . TTLFieldMapper ( ) . enabled ( ) ) { if ( source . ttl > <int> ) { value = docMapper . TTLFieldMapper ( ) . valueForSearch ( source . timestamp + source . ttl ) ; } } else { if ( searchLookup = = null ) { searchLookup = new SearchLookup ( mapperService , null , new String [ ] { type } ) ; searchLookup . source ( ) . setSource ( source . source ) ; } FieldMapper fieldMapper = docMapper . mappers ( ) . smartNameFieldMapper ( field ) ; if ( fieldMapper = = null ) { if ( docMapper . objectMappers ( ) . get ( field ) ! = null ) { throw new IllegalArgumentException ( <str> + field + <str> ) ; } } else if ( shouldGetFromSource ( ignoreErrorsOnGeneratedFields , docMapper , fieldMapper ) ) { List < Object > values = searchLookup . source ( ) . extractRawValues ( field ) ; if ( ! values . isEmpty ( ) ) { for ( int i = <int> ; i < values . size ( ) ; i + + ) { values . set ( i , fieldMapper . fieldType ( ) . valueForSearch ( values . get ( i ) ) ) ; } value = values ; } } } if ( value ! = null ) { if ( fields = = null ) { fields = new HashMap < > ( <int> ) ; } if ( value instanceof List ) { fields . put ( field , new GetField ( field , ( List ) value ) ) ; } else { fields . put ( field , new GetField ( field , Collections . singletonList ( value ) ) ) ; } } } BytesReference sourceToBeReturned = null ; SourceFieldMapper sourceFieldMapper = docMapper . sourceMapper ( ) ; if ( fetchSourceContext . fetchSource ( ) & & sourceFieldMapper . enabled ( ) ) { sourceToBeReturned = source . source ; boolean sourceFieldFiltering = sourceFieldMapper . includes ( ) . length > <int> | | sourceFieldMapper . excludes ( ) . length > <int> ; boolean sourceFetchFiltering = fetchSourceContext . includes ( ) . length > <int> | | fetchSourceContext . excludes ( ) . length > <int> ; if ( sourceFieldFiltering | | sourceFetchFiltering ) { Tuple < XContentType , Map < String , Object > > typeMapTuple = XContentHelper . convertToMap ( source . source , true ) ; XContentType sourceContentType = typeMapTuple . v1 ( ) ; Map < String , Object > sourceAsMap = typeMapTuple . v2 ( ) ; if ( sourceFieldFiltering ) { sourceAsMap = XContentMapValues . filter ( sourceAsMap , sourceFieldMapper . includes ( ) , sourceFieldMapper . excludes ( ) ) ; } if ( sourceFetchFiltering ) { sourceAsMap = XContentMapValues . filter ( sourceAsMap , fetchSourceContext . includes ( ) , fetchSourceContext . excludes ( ) ) ; } try { sourceToBeReturned = XContentFactory . contentBuilder ( sourceContentType ) . map ( sourceAsMap ) . bytes ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> + type + <str> + id + <str> , e ) ; } } } return new GetResult ( shardId . index ( ) . name ( ) , type , id , get . version ( ) , get . exists ( ) , sourceToBeReturned , fields ) ; } } finally { get . release ( ) ; } } protected boolean shouldGetFromSource ( boolean ignoreErrorsOnGeneratedFields , DocumentMapper docMapper , FieldMapper fieldMapper ) { if ( ! fieldMapper . isGenerated ( ) ) { return docMapper . sourceMapper ( ) . enabled ( ) | | fieldMapper . fieldType ( ) . stored ( ) ; } else { if ( ! fieldMapper . fieldType ( ) . stored ( ) ) { return false ; } else { if ( ignoreErrorsOnGeneratedFields ) { return false ; } else { throw new ElasticsearchException ( <str> + fieldMapper . name ( ) + <str> ) ; } } } } private GetResult innerGetLoadFromStoredFields ( String type , String id , String [ ] gFields , FetchSourceContext fetchSourceContext , Engine . GetResult get , DocumentMapper docMapper , boolean ignoreErrorsOnGeneratedFields ) { Map < String , GetField > fields = null ; BytesReference source = null ; Versions . DocIdAndVersion docIdAndVersion = get . docIdAndVersion ( ) ; FieldsVisitor fieldVisitor = buildFieldsVisitors ( gFields , fetchSourceContext ) ; if ( fieldVisitor ! = null ) { try { docIdAndVersion . context . reader ( ) . document ( docIdAndVersion . docId , fieldVisitor ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> + type + <str> + id + <str> , e ) ; } source = fieldVisitor . source ( ) ; if ( ! fieldVisitor . fields ( ) . isEmpty ( ) ) { fieldVisitor . postProcess ( docMapper ) ; fields = new HashMap < > ( fieldVisitor . fields ( ) . size ( ) ) ; for ( Map . Entry < String , List < Object > > entry : fieldVisitor . fields ( ) . entrySet ( ) ) { fields . put ( entry . getKey ( ) , new GetField ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } } } if ( gFields ! = null & & gFields . length > <int> ) { SearchLookup searchLookup = null ; for ( String field : gFields ) { Object value = null ; FieldMapper fieldMapper = docMapper . mappers ( ) . smartNameFieldMapper ( field ) ; if ( fieldMapper = = null ) { if ( docMapper . objectMappers ( ) . get ( field ) ! = null ) { throw new IllegalArgumentException ( <str> + field + <str> ) ; } } else if ( ! fieldMapper . fieldType ( ) . stored ( ) & & ! fieldMapper . isGenerated ( ) ) { if ( searchLookup = = null ) { searchLookup = new SearchLookup ( mapperService , null , new String [ ] { type } ) ; LeafSearchLookup leafSearchLookup = searchLookup . getLeafSearchLookup ( docIdAndVersion . context ) ; searchLookup . source ( ) . setSource ( source ) ; leafSearchLookup . setDocument ( docIdAndVersion . docId ) ; } List < Object > values = searchLookup . source ( ) . extractRawValues ( field ) ; if ( ! values . isEmpty ( ) ) { for ( int i = <int> ; i < values . size ( ) ; i + + ) { values . set ( i , fieldMapper . fieldType ( ) . valueForSearch ( values . get ( i ) ) ) ; } value = values ; } } if ( value ! = null ) { if ( fields = = null ) { fields = new HashMap < > ( <int> ) ; } if ( value instanceof List ) { fields . put ( field , new GetField ( field , ( List ) value ) ) ; } else { fields . put ( field , new GetField ( field , Collections . singletonList ( value ) ) ) ; } } } } if ( ! fetchSourceContext . fetchSource ( ) ) { source = null ; } else if ( fetchSourceContext . includes ( ) . length > <int> | | fetchSourceContext . excludes ( ) . length > <int> ) { Map < String , Object > sourceAsMap ; XContentType sourceContentType = null ; Tuple < XContentType , Map < String , Object > > typeMapTuple = XContentHelper . convertToMap ( source , true ) ; sourceContentType = typeMapTuple . v1 ( ) ; sourceAsMap = typeMapTuple . v2 ( ) ; sourceAsMap = XContentMapValues . filter ( sourceAsMap , fetchSourceContext . includes ( ) , fetchSourceContext . excludes ( ) ) ; try { source = XContentFactory . contentBuilder ( sourceContentType ) . map ( sourceAsMap ) . bytes ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> + type + <str> + id + <str> , e ) ; } } return new GetResult ( shardId . index ( ) . name ( ) , type , id , get . version ( ) , get . exists ( ) , source , fields ) ; } private static FieldsVisitor buildFieldsVisitors ( String [ ] fields , FetchSourceContext fetchSourceContext ) { if ( fields = = null | | fields . length = = <int> ) { return fetchSourceContext . fetchSource ( ) ? new FieldsVisitor ( true ) : null ; } return new CustomFieldsVisitor ( Sets . newHashSet ( fields ) , fetchSourceContext . fetchSource ( ) ) ; } } 
