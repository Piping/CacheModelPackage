package org . elasticsearch . client . transport ; import org . elasticsearch . Version ; import org . elasticsearch . action . GenericAction ; import org . elasticsearch . action . admin . cluster . node . liveness . LivenessResponse ; import org . elasticsearch . action . admin . cluster . node . liveness . TransportLivenessAction ; import org . elasticsearch . action . admin . cluster . state . ClusterStateAction ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . client . AbstractClientHeadersTestCase ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . Transport ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportModule ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportResponseHandler ; import org . elasticsearch . transport . TransportService ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class TransportClientHeadersTests extends AbstractClientHeadersTestCase { private static final LocalTransportAddress address = new LocalTransportAddress ( <str> ) ; @Override protected Client buildClient ( Settings headersSettings , GenericAction [ ] testedActions ) { TransportClient client = TransportClient . builder ( ) . settings ( Settings . builder ( ) . put ( <str> , false ) . put ( <str> , <str> + this . getTestName ( ) ) . put ( headersSettings ) . build ( ) ) . addPlugin ( InternalTransportService . TestPlugin . class ) . build ( ) ; client . addTransportAddress ( address ) ; return client ; } public void testWithSniffing ( ) throws Exception { TransportClient client = TransportClient . builder ( ) . settings ( Settings . builder ( ) . put ( <str> , true ) . put ( <str> , <str> ) . put ( <str> , <str> + this . getTestName ( ) + <str> ) . put ( <str> , <str> ) . put ( HEADER_SETTINGS ) . put ( <str> , createTempDir ( ) . toString ( ) ) . build ( ) ) . addPlugin ( InternalTransportService . TestPlugin . class ) . build ( ) ; try { client . addTransportAddress ( address ) ; InternalTransportService service = ( InternalTransportService ) client . injector . getInstance ( TransportService . class ) ; if ( ! service . clusterStateLatch . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } assertThat ( client . connectedNodes ( ) . size ( ) , is ( <int> ) ) ; assertThat ( client . connectedNodes ( ) . get ( <int> ) . getAddress ( ) , is ( ( TransportAddress ) address ) ) ; } finally { client . close ( ) ; } } public static class InternalTransportService extends TransportService { public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( TransportModule transportModule ) { transportModule . addTransportService ( <str> , InternalTransportService . class ) ; } @Override public Settings additionalSettings ( ) { return Settings . builder ( ) . put ( TransportModule . TRANSPORT_SERVICE_TYPE_KEY , <str> ) . build ( ) ; } } CountDownLatch clusterStateLatch = new CountDownLatch ( <int> ) ; @Inject public InternalTransportService ( Settings settings , Transport transport , ThreadPool threadPool ) { super ( settings , transport , threadPool ) ; } @Override @SuppressWarnings ( <str> ) public < T extends TransportResponse > void sendRequest ( DiscoveryNode node , String action , TransportRequest request , TransportRequestOptions options , TransportResponseHandler < T > handler ) { if ( TransportLivenessAction . NAME . equals ( action ) ) { assertHeaders ( request ) ; ( ( TransportResponseHandler < LivenessResponse > ) handler ) . handleResponse ( new LivenessResponse ( ClusterName . DEFAULT , node ) ) ; return ; } if ( ClusterStateAction . NAME . equals ( action ) ) { assertHeaders ( request ) ; ClusterName cluster1 = new ClusterName ( <str> ) ; ( ( TransportResponseHandler < ClusterStateResponse > ) handler ) . handleResponse ( new ClusterStateResponse ( cluster1 , state ( cluster1 ) ) ) ; clusterStateLatch . countDown ( ) ; return ; } handler . handleException ( new TransportException ( <str> , new InternalException ( action , request ) ) ) ; } @Override public boolean nodeConnected ( DiscoveryNode node ) { assertThat ( ( LocalTransportAddress ) node . getAddress ( ) , equalTo ( address ) ) ; return true ; } @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { assertThat ( ( LocalTransportAddress ) node . getAddress ( ) , equalTo ( address ) ) ; } } private static ClusterState state ( ClusterName clusterName ) { ClusterState . Builder builder = ClusterState . builder ( clusterName ) ; builder . nodes ( DiscoveryNodes . builder ( ) . put ( new DiscoveryNode ( <str> , address , Version . CURRENT ) ) ) ; return builder . build ( ) ; } } 
