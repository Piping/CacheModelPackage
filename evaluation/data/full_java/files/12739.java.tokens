package org . gradle . api . internal . artifacts . repositories ; import org . gradle . api . Action ; import org . gradle . api . artifacts . repositories . AuthenticationContainer ; import org . gradle . api . artifacts . repositories . PasswordCredentials ; import org . gradle . authentication . Authentication ; import org . gradle . api . credentials . AwsCredentials ; import org . gradle . api . credentials . Credentials ; import org . gradle . internal . authentication . AllSchemesAuthentication ; import org . gradle . internal . authentication . AuthenticationInternal ; import org . gradle . internal . Cast ; import org . gradle . internal . artifacts . repositories . AuthenticationSupportedInternal ; import org . gradle . internal . credentials . DefaultAwsCredentials ; import org . gradle . internal . reflect . Instantiator ; import java . util . Collection ; import java . util . Collections ; public abstract class AbstractAuthenticationSupportedRepository extends AbstractArtifactRepository implements AuthenticationSupportedInternal { private Credentials credentials ; private final Instantiator instantiator ; private AuthenticationContainer authenticationContainer ; AbstractAuthenticationSupportedRepository ( Instantiator instantiator , AuthenticationContainer authenticationContainer ) { this . instantiator = instantiator ; this . authenticationContainer = authenticationContainer ; } @Override public PasswordCredentials getCredentials ( ) { if ( credentials = = null ) { return setCredentials ( PasswordCredentials . class ) ; } else if ( credentials instanceof PasswordCredentials ) { return Cast . uncheckedCast ( credentials ) ; } else { throw new IllegalStateException ( <str> ) ; } } @Override public < T extends Credentials > T getCredentials ( Class < T > credentialsType ) { if ( credentials = = null ) { return setCredentials ( credentialsType ) ; } else if ( credentialsType . isInstance ( credentials ) ) { return Cast . uncheckedCast ( credentials ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , credentialsType . getName ( ) , getCredentialsPublicType ( credentials . getClass ( ) ) . getName ( ) ) ) ; } } public void credentials ( Action < ? super PasswordCredentials > action ) { if ( credentials ! = null & & ! ( credentials instanceof PasswordCredentials ) ) { throw new IllegalStateException ( <str> ) ; } credentials ( PasswordCredentials . class , action ) ; } public < T extends Credentials > void credentials ( Class < T > credentialsType , Action < ? super T > action ) throws IllegalStateException { action . execute ( getCredentials ( credentialsType ) ) ; } private < T extends Credentials > T setCredentials ( Class < T > clazz ) { T t = newCredentials ( clazz ) ; credentials = t ; return t ; } private < T extends Credentials > T newCredentials ( Class < T > clazz ) { return instantiator . newInstance ( getCredentialsImplType ( clazz ) ) ; } public Credentials getConfiguredCredentials ( ) { return credentials ; } @Override public void authentication ( Action < ? super AuthenticationContainer > action ) { action . execute ( getAuthentication ( ) ) ; } @Override public AuthenticationContainer getAuthentication ( ) { return authenticationContainer ; } @Override public Collection < Authentication > getConfiguredAuthentication ( ) { populateAuthenticationCredentials ( ) ; if ( getConfiguredCredentials ( ) ! = null & authenticationContainer . size ( ) = = <int> ) { return Collections . < Authentication > singleton ( new AllSchemesAuthentication ( getConfiguredCredentials ( ) ) ) ; } else { return getAuthentication ( ) ; } } private void populateAuthenticationCredentials ( ) { for ( Authentication authentication : authenticationContainer ) { ( ( AuthenticationInternal ) authentication ) . setCredentials ( getConfiguredCredentials ( ) ) ; } } private static < T extends Credentials > Class < ? extends T > getCredentialsImplType ( Class < T > publicType ) { if ( publicType = = PasswordCredentials . class ) { return Cast . uncheckedCast ( DefaultPasswordCredentials . class ) ; } else if ( publicType = = AwsCredentials . class ) { return Cast . uncheckedCast ( DefaultAwsCredentials . class ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , publicType . getName ( ) , PasswordCredentials . class . getName ( ) , AwsCredentials . class . getName ( ) ) ) ; } } private static < T extends Credentials > Class < ? super T > getCredentialsPublicType ( Class < T > implType ) { if ( PasswordCredentials . class . isAssignableFrom ( implType ) ) { return Cast . uncheckedCast ( PasswordCredentials . class ) ; } else if ( AwsCredentials . class . isAssignableFrom ( implType ) ) { return Cast . uncheckedCast ( AwsCredentials . class ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , implType . getName ( ) , DefaultPasswordCredentials . class . getName ( ) , DefaultAwsCredentials . class . getName ( ) ) ) ; } } } 
