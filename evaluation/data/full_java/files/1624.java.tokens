package org . apache . cassandra . service ; import java . io . File ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; import org . junit . * ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . * ; import org . apache . cassandra . exceptions . StartupException ; import org . apache . cassandra . io . util . FileUtils ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class StartupChecksTest { public static final String INVALID_LEGACY_SSTABLE_ROOT_PROP = <str> ; StartupChecks startupChecks ; Path sstableDir ; @BeforeClass public static void setupServer ( ) { SchemaLoader . prepareServer ( ) ; } @Before public void setup ( ) throws IOException { for ( ColumnFamilyStore cfs : Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStores ( ) ) cfs . clearUnsafe ( ) ; for ( File dataDir : Directories . getKSChildDirectories ( SystemKeyspace . NAME ) ) FileUtils . deleteRecursive ( dataDir ) ; File dataDir = new File ( DatabaseDescriptor . getAllDataFileLocations ( ) [ <int> ] ) ; sstableDir = Paths . get ( dataDir . getAbsolutePath ( ) , <str> , <str> ) ; Files . createDirectories ( sstableDir ) ; startupChecks = new StartupChecks ( ) ; } @After public void tearDown ( ) throws IOException { FileUtils . deleteRecursive ( sstableDir . toFile ( ) ) ; } @Test public void failStartupIfInvalidSSTablesFound ( ) throws Exception { startupChecks = startupChecks . withTest ( StartupChecks . checkSSTablesFormat ) ; copyInvalidLegacySSTables ( sstableDir ) ; verifyFailure ( startupChecks , <str> ) ; FileUtils . deleteRecursive ( sstableDir . toFile ( ) ) ; Path snapshotDir = sstableDir . resolve ( <str> ) ; Files . createDirectories ( snapshotDir ) ; copyInvalidLegacySSTables ( snapshotDir ) ; startupChecks . verify ( ) ; FileUtils . deleteRecursive ( sstableDir . toFile ( ) ) ; Path backupDir = sstableDir . resolve ( <str> ) ; Files . createDirectories ( backupDir ) ; copyInvalidLegacySSTables ( backupDir ) ; startupChecks . verify ( ) ; } @Test public void compatibilityCheckIgnoresNonDbFiles ( ) throws Exception { startupChecks = startupChecks . withTest ( StartupChecks . checkSSTablesFormat ) ; copyLegacyNonSSTableFiles ( sstableDir ) ; assertFalse ( sstableDir . toFile ( ) . listFiles ( ) . length = = <int> ) ; startupChecks . verify ( ) ; } private void copyLegacyNonSSTableFiles ( Path targetDir ) throws IOException { Path legacySSTableRoot = Paths . get ( System . getProperty ( INVALID_LEGACY_SSTABLE_ROOT_PROP ) , <str> , <str> ) ; for ( String filename : new String [ ] { <str> , <str> , <str> } ) Files . copy ( Paths . get ( legacySSTableRoot . toString ( ) , filename ) , targetDir . resolve ( filename ) ) ; } private void copyInvalidLegacySSTables ( Path targetDir ) throws IOException { File legacySSTableRoot = Paths . get ( System . getProperty ( INVALID_LEGACY_SSTABLE_ROOT_PROP ) , <str> , <str> ) . toFile ( ) ; for ( File f : legacySSTableRoot . listFiles ( ) ) Files . copy ( f . toPath ( ) , targetDir . resolve ( f . getName ( ) ) ) ; } private void verifyFailure ( StartupChecks tests , String message ) { try { tests . verify ( ) ; fail ( <str> ) ; } catch ( StartupException e ) { assertTrue ( e . getMessage ( ) . contains ( message ) ) ; } } } 
