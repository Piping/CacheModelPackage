package com . badlogic . gdx . tests . box2d ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . Body ; import com . badlogic . gdx . physics . box2d . BodyDef ; import com . badlogic . gdx . physics . box2d . BodyDef . BodyType ; import com . badlogic . gdx . physics . box2d . CircleShape ; import com . badlogic . gdx . physics . box2d . ContactFilter ; import com . badlogic . gdx . physics . box2d . EdgeShape ; import com . badlogic . gdx . physics . box2d . Fixture ; import com . badlogic . gdx . physics . box2d . PolygonShape ; import com . badlogic . gdx . physics . box2d . World ; public class OneSidedPlatform extends Box2DTest { enum State { Unknown , Above , Below } Fixture m_platform ; Fixture m_character ; float m_bottom ; float m_top ; float m_radius ; State m_state ; @Override protected void createWorld ( World world ) { { BodyDef bd = new BodyDef ( ) ; Body ground = world . createBody ( bd ) ; EdgeShape shape = new EdgeShape ( ) ; shape . set ( new Vector2 ( - <float> , <int> ) , new Vector2 ( <float> , <float> ) ) ; ground . createFixture ( shape , <int> ) ; shape . dispose ( ) ; } { BodyDef bd = new BodyDef ( ) ; bd . position . set ( <int> , <int> ) ; Body body = world . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( <int> , <float> ) ; m_platform = body . createFixture ( shape , <int> ) ; m_bottom = <float> - <float> ; m_top = <float> + <float> ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . position . set ( <int> , <int> ) ; Body body = world . createBody ( bd ) ; m_radius = <float> ; CircleShape shape = new CircleShape ( ) ; shape . setRadius ( m_radius ) ; m_character = body . createFixture ( shape , <float> ) ; shape . dispose ( ) ; m_state = State . Unknown ; } world . setContactFilter ( new ContactFilter ( ) { @Override public boolean shouldCollide ( Fixture fixtureA , Fixture fixtureB ) { if ( ( fixtureA = = m_platform & & fixtureB = = m_character ) | | ( fixtureA = = m_platform & & fixtureB = = m_character ) ) { Vector2 position = m_character . getBody ( ) . getPosition ( ) ; if ( position . y < m_top + m_radius - <float> * <float> ) return false ; else return true ; } else return true ; } } ) ; } } 
