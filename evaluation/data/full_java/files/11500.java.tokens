package org . gradle . api . internal . file . archive ; import org . apache . tools . tar . TarEntry ; import org . apache . tools . tar . TarInputStream ; import org . gradle . api . GradleException ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . Nullable ; import org . gradle . api . file . FileVisitDetails ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . file . RelativePath ; import org . gradle . api . internal . file . AbstractFileTreeElement ; import org . gradle . api . internal . file . DefaultFileVisitDetails ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . api . internal . file . collections . DirectoryFileTree ; import org . gradle . api . internal . file . collections . FileSystemMirroringFileTree ; import org . gradle . api . internal . file . collections . MinimalFileTree ; import org . gradle . api . internal . file . collections . SingletonFileTree ; import org . gradle . api . resources . ResourceException ; import org . gradle . api . resources . internal . ReadableResourceInternal ; import org . gradle . internal . hash . HashUtil ; import org . gradle . internal . nativeintegration . filesystem . Chmod ; import org . gradle . util . GFileUtils ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . util . concurrent . atomic . AtomicBoolean ; public class TarFileTree implements MinimalFileTree , FileSystemMirroringFileTree { private final File tarFile ; private final ReadableResourceInternal resource ; private final Chmod chmod ; private final File tmpDir ; public TarFileTree ( @Nullable File tarFile , ReadableResourceInternal resource , File tmpDir , Chmod chmod ) { this . tarFile = tarFile ; this . resource = resource ; this . chmod = chmod ; String expandDirName = String . format ( <str> , resource . getBaseName ( ) , HashUtil . createCompactMD5 ( resource . getURI ( ) . toString ( ) ) ) ; this . tmpDir = new File ( tmpDir , expandDirName ) ; } public String getDisplayName ( ) { return String . format ( <str> , resource . getDisplayName ( ) ) ; } public DirectoryFileTree getMirror ( ) { return new DirectoryFileTree ( tmpDir ) ; } public void visit ( FileVisitor visitor ) { InputStream inputStream ; try { inputStream = resource . read ( ) ; } catch ( ResourceException e ) { throw new InvalidUserDataException ( String . format ( <str> , getDisplayName ( ) ) , e ) ; } try { try { visitImpl ( visitor , inputStream ) ; } finally { inputStream . close ( ) ; } } catch ( Exception e ) { String message = <str> + getDisplayName ( ) + <str> + <str> + <str> + <str> ; throw new GradleException ( message , e ) ; } } private void visitImpl ( FileVisitor visitor , InputStream inputStream ) throws IOException { AtomicBoolean stopFlag = new AtomicBoolean ( ) ; NoCloseTarInputStream tar = new NoCloseTarInputStream ( inputStream ) ; TarEntry entry ; while ( ! stopFlag . get ( ) & & ( entry = tar . getNextEntry ( ) ) ! = null ) { if ( entry . isDirectory ( ) ) { visitor . visitDir ( new DetailsImpl ( entry , tar , stopFlag , chmod ) ) ; } else { visitor . visitFile ( new DetailsImpl ( entry , tar , stopFlag , chmod ) ) ; } } } private File getBackingFile ( ) { if ( tarFile ! = null ) { return tarFile ; } if ( resource ! = null ) { return resource . getBackingFile ( ) ; } return null ; } private class DetailsImpl extends AbstractFileTreeElement implements FileVisitDetails { private final TarEntry entry ; private final NoCloseTarInputStream tar ; private final AtomicBoolean stopFlag ; private File file ; private boolean read ; public DetailsImpl ( TarEntry entry , NoCloseTarInputStream tar , AtomicBoolean stopFlag , Chmod chmod ) { super ( chmod ) ; this . entry = entry ; this . tar = tar ; this . stopFlag = stopFlag ; } public String getDisplayName ( ) { return String . format ( <str> , resource . getDisplayName ( ) , entry . getName ( ) ) ; } public void stopVisiting ( ) { stopFlag . set ( true ) ; } public File getFile ( ) { if ( file = = null ) { file = new File ( tmpDir , entry . getName ( ) ) ; copyTo ( file ) ; } return file ; } public long getLastModified ( ) { return entry . getModTime ( ) . getTime ( ) ; } public boolean isDirectory ( ) { return entry . isDirectory ( ) ; } public long getSize ( ) { return entry . getSize ( ) ; } public InputStream open ( ) { if ( read & & file ! = null ) { return GFileUtils . openInputStream ( file ) ; } if ( read | | tar . getCurrent ( ) ! = entry ) { throw new UnsupportedOperationException ( String . format ( <str> , this ) ) ; } read = true ; return tar ; } public RelativePath getRelativePath ( ) { return new RelativePath ( ! entry . isDirectory ( ) , entry . getName ( ) . split ( <str> ) ) ; } public int getMode ( ) { return entry . getMode ( ) & <oct> ; } } private static class NoCloseTarInputStream extends TarInputStream { public NoCloseTarInputStream ( InputStream is ) { super ( is ) ; } @Override public void close ( ) throws IOException { } public TarEntry getCurrent ( ) { return currEntry ; } } @Override public void registerWatchPoints ( FileSystemSubset . Builder builder ) { if ( tarFile ! = null ) { builder . add ( tarFile ) ; } } @Override public void visitTreeOrBackingFile ( final FileVisitor visitor ) { File backingFile = getBackingFile ( ) ; if ( backingFile ! = null ) { new SingletonFileTree ( backingFile ) . visit ( visitor ) ; } else { visit ( new FileVisitor ( ) { @Override public void visitDir ( FileVisitDetails dirDetails ) { visitor . visitDir ( new DefaultFileVisitDetails ( dirDetails . getFile ( ) ) ) ; } @Override public void visitFile ( FileVisitDetails fileDetails ) { visitor . visitFile ( new DefaultFileVisitDetails ( fileDetails . getFile ( ) ) ) ; } } ) ; } } } 
