package org . elasticsearch . common . transport ; import org . elasticsearch . common . io . stream . ByteBufferStreamInput ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . test . ESTestCase ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . List ; import static org . hamcrest . Matchers . * ; public class BoundTransportAddressTests extends ESTestCase { public void testSerialization ( ) throws Exception { InetAddress [ ] inetAddresses = InetAddress . getAllByName ( <str> ) ; List < InetSocketTransportAddress > transportAddressList = new ArrayList < > ( ) ; for ( InetAddress address : inetAddresses ) { transportAddressList . add ( new InetSocketTransportAddress ( address , randomIntBetween ( <int> , <int> ) ) ) ; } final BoundTransportAddress transportAddress = new BoundTransportAddress ( transportAddressList . toArray ( new InetSocketTransportAddress [ <int> ] ) , transportAddressList . get ( <int> ) ) ; assertThat ( transportAddress . boundAddresses ( ) . length , equalTo ( transportAddressList . size ( ) ) ) ; BytesStreamOutput streamOutput = new BytesStreamOutput ( ) ; transportAddress . writeTo ( streamOutput ) ; StreamInput in = ByteBufferStreamInput . wrap ( streamOutput . bytes ( ) ) ; BoundTransportAddress serializedAddress ; if ( randomBoolean ( ) ) { serializedAddress = BoundTransportAddress . readBoundTransportAddress ( in ) ; } else { serializedAddress = new BoundTransportAddress ( ) ; serializedAddress . readFrom ( in ) ; } assertThat ( serializedAddress , not ( sameInstance ( transportAddress ) ) ) ; assertThat ( serializedAddress . boundAddresses ( ) . length , equalTo ( transportAddress . boundAddresses ( ) . length ) ) ; assertThat ( serializedAddress . publishAddress ( ) , equalTo ( transportAddress . publishAddress ( ) ) ) ; TransportAddress [ ] serializedBoundAddresses = serializedAddress . boundAddresses ( ) ; TransportAddress [ ] boundAddresses = transportAddress . boundAddresses ( ) ; for ( int i = <int> ; i < serializedBoundAddresses . length ; i + + ) { assertThat ( serializedBoundAddresses [ i ] , equalTo ( boundAddresses [ i ] ) ) ; } } public void testBadBoundAddressArray ( ) { try { TransportAddress [ ] badArray = randomBoolean ( ) ? null : new TransportAddress [ <int> ] ; new BoundTransportAddress ( badArray , new InetSocketTransportAddress ( InetAddress . getLoopbackAddress ( ) , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } } 
