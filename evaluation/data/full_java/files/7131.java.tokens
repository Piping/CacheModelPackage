package org . elasticsearch . search . aggregations ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Scorer ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . ObjectArray ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . internal . SearchContext . Lifetime ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public abstract class AggregatorFactory { protected String name ; protected String type ; protected AggregatorFactory parent ; protected AggregatorFactories factories = AggregatorFactories . EMPTY ; protected Map < String , Object > metaData ; public AggregatorFactory ( String name , String type ) { this . name = name ; this . type = type ; } public AggregatorFactory subFactories ( AggregatorFactories subFactories ) { this . factories = subFactories ; this . factories . setParent ( this ) ; return this ; } public String name ( ) { return name ; } public final void validate ( ) { doValidate ( ) ; factories . validate ( ) ; } public AggregatorFactory parent ( ) { return parent ; } protected abstract Aggregator createInternal ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException ; public final Aggregator create ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket ) throws IOException { return createInternal ( context , parent , collectsFromSingleBucket , this . factories . createPipelineAggregators ( ) , this . metaData ) ; } public void doValidate ( ) { } public void setMetaData ( Map < String , Object > metaData ) { this . metaData = metaData ; } protected static Aggregator asMultiBucketAggregator ( final AggregatorFactory factory , final AggregationContext context , final Aggregator parent ) throws IOException { final Aggregator first = factory . create ( context , parent , true ) ; final BigArrays bigArrays = context . bigArrays ( ) ; return new Aggregator ( ) { ObjectArray < Aggregator > aggregators ; ObjectArray < LeafBucketCollector > collectors ; { context . searchContext ( ) . addReleasable ( this , Lifetime . PHASE ) ; aggregators = bigArrays . newObjectArray ( <int> ) ; aggregators . set ( <int> , first ) ; collectors = bigArrays . newObjectArray ( <int> ) ; } @Override public String name ( ) { return first . name ( ) ; } @Override public AggregationContext context ( ) { return first . context ( ) ; } @Override public Aggregator parent ( ) { return first . parent ( ) ; } @Override public boolean needsScores ( ) { return first . needsScores ( ) ; } @Override public Aggregator subAggregator ( String name ) { throw new UnsupportedOperationException ( ) ; } @Override public void preCollection ( ) throws IOException { for ( long i = <int> ; i < aggregators . size ( ) ; + + i ) { final Aggregator aggregator = aggregators . get ( i ) ; if ( aggregator ! = null ) { aggregator . preCollection ( ) ; } } } @Override public void postCollection ( ) throws IOException { for ( long i = <int> ; i < aggregators . size ( ) ; + + i ) { final Aggregator aggregator = aggregators . get ( i ) ; if ( aggregator ! = null ) { aggregator . postCollection ( ) ; } } } @Override public LeafBucketCollector getLeafCollector ( final LeafReaderContext ctx ) { for ( long i = <int> ; i < collectors . size ( ) ; + + i ) { collectors . set ( i , null ) ; } return new LeafBucketCollector ( ) { Scorer scorer ; @Override public void setScorer ( Scorer scorer ) throws IOException { this . scorer = scorer ; } @Override public void collect ( int doc , long bucket ) throws IOException { aggregators = bigArrays . grow ( aggregators , bucket + <int> ) ; collectors = bigArrays . grow ( collectors , bucket + <int> ) ; LeafBucketCollector collector = collectors . get ( bucket ) ; if ( collector = = null ) { Aggregator aggregator = aggregators . get ( bucket ) ; if ( aggregator = = null ) { aggregator = factory . create ( context , parent , true ) ; aggregator . preCollection ( ) ; aggregators . set ( bucket , aggregator ) ; } collector = aggregator . getLeafCollector ( ctx ) ; collector . setScorer ( scorer ) ; collectors . set ( bucket , collector ) ; } collector . collect ( doc , <int> ) ; } } ; } @Override public InternalAggregation buildAggregation ( long bucket ) throws IOException { if ( bucket < aggregators . size ( ) ) { Aggregator aggregator = aggregators . get ( bucket ) ; if ( aggregator ! = null ) { return aggregator . buildAggregation ( <int> ) ; } } return buildEmptyAggregation ( ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return first . buildEmptyAggregation ( ) ; } @Override public void close ( ) { Releasables . close ( aggregators , collectors ) ; } } ; } } 
