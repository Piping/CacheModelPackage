package org . nd4j . linalg . jcublas . kernel ; import jcuda . utils . KernelLauncher ; import org . apache . commons . io . IOUtils ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . nd4j . linalg . io . ClassPathResource ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; public class KernelFunctionLoader { public final static String NAME_SPACE = <str> ; public final static String DOUBLE = NAME_SPACE + <str> ; public final static String FLOAT = NAME_SPACE + <str> ; public final static String IMPORTS_FLOAT = NAME_SPACE + <str> ; public final static String IMPORTS_DOUBLE = NAME_SPACE + <str> ; public final static String CACHE_COMPILED = NAME_SPACE + <str> ; private Map < String , String > paths = new HashMap < > ( ) ; private static Logger log = LoggerFactory . getLogger ( KernelFunctionLoader . class ) ; private static KernelFunctionLoader INSTANCE ; private static Map < String , KernelLauncher > launchers = new HashMap < > ( ) ; private boolean init = false ; private KernelFunctionLoader ( ) { } public static synchronized KernelFunctionLoader getInstance ( ) { if ( INSTANCE = = null ) { INSTANCE = new KernelFunctionLoader ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { @Override public void run ( ) { INSTANCE . unload ( ) ; } } ) ) ; try { INSTANCE . load ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return INSTANCE ; } private static String dataFolder ( DataBuffer . Type type ) { return <str> + ( type = = DataBuffer . Type . FLOAT ? <str> : <str> ) ; } public static KernelLauncher launcher ( String functionName , String dataType ) { return KernelFunctionLoader . getInstance ( ) . get ( functionName , dataType ) ; } public boolean exists ( String functionName ) { return get ( functionName , <str> ) ! = null | | get ( functionName , <str> ) ! = null ; } public KernelLauncher get ( String functionName , String dataType ) { String name = functionName + <str> + dataType ; KernelLauncher launcher = launchers . get ( name ) ; if ( launcher = = null ) { name = functionName + <str> + <str> + dataType ; launcher = launchers . get ( name ) ; if ( launcher = = null ) return null ; } return launcher ; } public void unload ( ) { init = false ; } public void load ( ) throws Exception { if ( init ) return ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; ClassPathResource res = new ClassPathResource ( <str> , KernelFunctionLoader . class . getClassLoader ( ) ) ; if ( ! res . exists ( ) ) throw new IllegalStateException ( <str> ) ; Properties props = new Properties ( ) ; props . load ( res . getInputStream ( ) ) ; log . info ( <str> ) ; ensureImports ( props , <str> ) ; ensureImports ( props , <str> ) ; compileAndLoad ( props , FLOAT , <str> ) ; compileAndLoad ( props , DOUBLE , <str> ) ; init = true ; } private void compileAndLoad ( Properties props , String key , String dataType ) throws IOException { compileAndLoad ( props , key , dataType , <int> ) ; } private void compileAndLoad ( Properties props , String key , String dataType , int compiledAttempts ) throws IOException { String f = props . getProperty ( key ) ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; sb . append ( <str> ) ; String tmpDir = System . getProperty ( <str> ) ; StringBuffer dir = new StringBuffer ( ) ; boolean cache = Boolean . parseBoolean ( props . getProperty ( CACHE_COMPILED , String . valueOf ( <str> ) ) ) ; sb . append ( tmpDir ) . append ( File . separator ) . append ( <str> ) . append ( File . separator ) . append ( dataType ) . append ( File . separator ) . toString ( ) ; String kernelPath = dir . append ( tmpDir ) . append ( File . separator ) . append ( <str> ) . append ( File . separator ) . append ( dataType ) . append ( File . separator ) . toString ( ) ; boolean shouldCompile = cache ; if ( cache ) { File tmpDir2 = new File ( tmpDir + File . separator + <str> ) ; if ( tmpDir2 . exists ( ) ) { shouldCompile = cache & & ! tmpDir2 . exists ( ) | | compiledAttempts > <int> ; } } String [ ] split = f . split ( <str> ) ; if ( shouldCompile ) { sb . append ( <str> ) . append ( <str> ) ; log . info ( <str> + dataType + <str> ) ; if ( f ! = null ) { for ( String s : split ) { String loaded = extract ( <str> + dataType + <str> + s + <str> , dataType . equals ( <str> ) ? DataBuffer . Type . FLOAT : DataBuffer . Type . DOUBLE ) ; sb . append ( <str> + loaded ) ; } sb . append ( <str> + kernelPath ) ; Process process = Runtime . getRuntime ( ) . exec ( sb . toString ( ) ) ; String errorMessage = new String ( IOUtils . toByteArray ( process . getErrorStream ( ) ) ) ; String outputMessage = new String ( IOUtils . toByteArray ( process . getInputStream ( ) ) ) ; int exitValue = <int> ; try { exitValue = process . waitFor ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IOException ( <str> , e ) ; } if ( exitValue ! = <int> ) { log . info ( <str> + exitValue ) ; log . info ( <str> + errorMessage ) ; log . info ( <str> + outputMessage ) ; throw new IOException ( <str> + errorMessage ) ; } } } else { log . info ( <str> ) ; for ( String module : split ) { log . info ( <str> + module ) ; String path = kernelPath + module + <str> ; String name = module + <str> + dataType ; paths . put ( name , path ) ; } } try { for ( String module : split ) { log . info ( <str> + module ) ; String path = kernelPath + module + <str> ; String name = module + <str> + dataType ; paths . put ( name , path ) ; KernelLauncher launch = KernelLauncher . load ( path , name ) ; launchers . put ( name , launch ) ; } } catch ( Exception e ) { if ( ! shouldCompile & & compiledAttempts < <int> ) { log . warn ( <str> ) ; props . setProperty ( CACHE_COMPILED , String . valueOf ( true ) ) ; compileAndLoad ( props , key , dataType , compiledAttempts + <int> ) ; } else throw new RuntimeException ( e ) ; } } public String extract ( String file , DataBuffer . Type dataType ) throws IOException { String path = dataFolder ( dataType ) ; String tmpDir = System . getProperty ( <str> ) ; File dataDir = new File ( tmpDir , path ) ; if ( ! dataDir . exists ( ) ) dataDir . mkdirs ( ) ; return loadFile ( file ) ; } private void ensureImports ( Properties props , String dataType ) throws IOException { if ( dataType . equals ( <str> ) ) { String [ ] imports = props . getProperty ( IMPORTS_FLOAT ) . split ( <str> ) ; for ( String import1 : imports ) { loadFile ( <str> + dataType + <str> + import1 ) ; } } else { String [ ] imports = props . getProperty ( IMPORTS_DOUBLE ) . split ( <str> ) ; for ( String import1 : imports ) { loadFile ( <str> + dataType + <str> + import1 ) ; } } } private String loadFile ( String file ) throws IOException { ClassPathResource resource = new ClassPathResource ( file , KernelFunctionLoader . class . getClassLoader ( ) ) ; String tmpDir = System . getProperty ( <str> ) ; if ( ! resource . exists ( ) ) throw new IllegalStateException ( <str> + resource ) ; File out = new File ( tmpDir , file ) ; if ( ! out . getParentFile ( ) . exists ( ) ) out . getParentFile ( ) . mkdirs ( ) ; if ( out . exists ( ) ) out . delete ( ) ; out . createNewFile ( ) ; BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; IOUtils . copy ( resource . getInputStream ( ) , bos ) ; bos . flush ( ) ; bos . close ( ) ; out . deleteOnExit ( ) ; return out . getAbsolutePath ( ) ; } } 
