package org . elasticsearch . common . inject . matcher ; import java . io . Serializable ; import java . lang . annotation . Annotation ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Objects ; public class Matchers { private Matchers ( ) { } public static Matcher < Object > any ( ) { return ANY ; } private static final Matcher < Object > ANY = new Any ( ) ; private static class Any extends AbstractMatcher < Object > implements Serializable { @Override public boolean matches ( Object o ) { return true ; } @Override public String toString ( ) { return <str> ; } public Object readResolve ( ) { return any ( ) ; } private static final long serialVersionUID = <int> ; } public static < T > Matcher < T > not ( final Matcher < ? super T > p ) { return new Not < > ( p ) ; } private static class Not < T > extends AbstractMatcher < T > implements Serializable { final Matcher < ? super T > delegate ; private Not ( Matcher < ? super T > delegate ) { this . delegate = Objects . requireNonNull ( delegate , <str> ) ; } @Override public boolean matches ( T t ) { return ! delegate . matches ( t ) ; } @Override public boolean equals ( Object other ) { return other instanceof Not & & ( ( Not ) other ) . delegate . equals ( delegate ) ; } @Override public int hashCode ( ) { return - delegate . hashCode ( ) ; } @Override public String toString ( ) { return <str> + delegate + <str> ; } private static final long serialVersionUID = <int> ; } private static void checkForRuntimeRetention ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; if ( retention = = null | | retention . value ( ) ! = RetentionPolicy . RUNTIME ) { throw new IllegalArgumentException ( <str> + annotationType . getSimpleName ( ) + <str> ) ; } } public static Matcher < AnnotatedElement > annotatedWith ( final Class < ? extends Annotation > annotationType ) { return new AnnotatedWithType ( annotationType ) ; } private static class AnnotatedWithType extends AbstractMatcher < AnnotatedElement > implements Serializable { private final Class < ? extends Annotation > annotationType ; public AnnotatedWithType ( Class < ? extends Annotation > annotationType ) { this . annotationType = Objects . requireNonNull ( annotationType , <str> ) ; checkForRuntimeRetention ( annotationType ) ; } @Override public boolean matches ( AnnotatedElement element ) { return element . getAnnotation ( annotationType ) ! = null ; } @Override public boolean equals ( Object other ) { return other instanceof AnnotatedWithType & & ( ( AnnotatedWithType ) other ) . annotationType . equals ( annotationType ) ; } @Override public int hashCode ( ) { return <int> * annotationType . hashCode ( ) ; } @Override public String toString ( ) { return <str> + annotationType . getSimpleName ( ) + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < AnnotatedElement > annotatedWith ( final Annotation annotation ) { return new AnnotatedWith ( annotation ) ; } private static class AnnotatedWith extends AbstractMatcher < AnnotatedElement > implements Serializable { private final Annotation annotation ; public AnnotatedWith ( Annotation annotation ) { this . annotation = Objects . requireNonNull ( annotation , <str> ) ; checkForRuntimeRetention ( annotation . annotationType ( ) ) ; } @Override public boolean matches ( AnnotatedElement element ) { Annotation fromElement = element . getAnnotation ( annotation . annotationType ( ) ) ; return fromElement ! = null & & annotation . equals ( fromElement ) ; } @Override public boolean equals ( Object other ) { return other instanceof AnnotatedWith & & ( ( AnnotatedWith ) other ) . annotation . equals ( annotation ) ; } @Override public int hashCode ( ) { return <int> * annotation . hashCode ( ) ; } @Override public String toString ( ) { return <str> + annotation + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < Class > subclassesOf ( final Class < ? > superclass ) { return new SubclassesOf ( superclass ) ; } private static class SubclassesOf extends AbstractMatcher < Class > implements Serializable { private final Class < ? > superclass ; public SubclassesOf ( Class < ? > superclass ) { this . superclass = Objects . requireNonNull ( superclass , <str> ) ; } @Override public boolean matches ( Class subclass ) { return superclass . isAssignableFrom ( subclass ) ; } @Override public boolean equals ( Object other ) { return other instanceof SubclassesOf & & ( ( SubclassesOf ) other ) . superclass . equals ( superclass ) ; } @Override public int hashCode ( ) { return <int> * superclass . hashCode ( ) ; } @Override public String toString ( ) { return <str> + superclass . getSimpleName ( ) + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < Object > only ( Object value ) { return new Only ( value ) ; } private static class Only extends AbstractMatcher < Object > implements Serializable { private final Object value ; public Only ( Object value ) { this . value = Objects . requireNonNull ( value , <str> ) ; } @Override public boolean matches ( Object other ) { return value . equals ( other ) ; } @Override public boolean equals ( Object other ) { return other instanceof Only & & ( ( Only ) other ) . value . equals ( value ) ; } @Override public int hashCode ( ) { return <int> * value . hashCode ( ) ; } @Override public String toString ( ) { return <str> + value + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < Object > identicalTo ( final Object value ) { return new IdenticalTo ( value ) ; } private static class IdenticalTo extends AbstractMatcher < Object > implements Serializable { private final Object value ; public IdenticalTo ( Object value ) { this . value = Objects . requireNonNull ( value , <str> ) ; } @Override public boolean matches ( Object other ) { return value = = other ; } @Override public boolean equals ( Object other ) { return other instanceof IdenticalTo & & ( ( IdenticalTo ) other ) . value = = value ; } @Override public int hashCode ( ) { return <int> * System . identityHashCode ( value ) ; } @Override public String toString ( ) { return <str> + value + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < Class > inPackage ( final Package targetPackage ) { return new InPackage ( targetPackage ) ; } private static class InPackage extends AbstractMatcher < Class > implements Serializable { private final transient Package targetPackage ; private final String packageName ; public InPackage ( Package targetPackage ) { this . targetPackage = Objects . requireNonNull ( targetPackage , <str> ) ; this . packageName = targetPackage . getName ( ) ; } @Override public boolean matches ( Class c ) { return c . getPackage ( ) . equals ( targetPackage ) ; } @Override public boolean equals ( Object other ) { return other instanceof InPackage & & ( ( InPackage ) other ) . targetPackage . equals ( targetPackage ) ; } @Override public int hashCode ( ) { return <int> * targetPackage . hashCode ( ) ; } @Override public String toString ( ) { return <str> + targetPackage . getName ( ) + <str> ; } public Object readResolve ( ) { return inPackage ( Package . getPackage ( packageName ) ) ; } private static final long serialVersionUID = <int> ; } public static Matcher < Class > inSubpackage ( final String targetPackageName ) { return new InSubpackage ( targetPackageName ) ; } private static class InSubpackage extends AbstractMatcher < Class > implements Serializable { private final String targetPackageName ; public InSubpackage ( String targetPackageName ) { this . targetPackageName = targetPackageName ; } @Override public boolean matches ( Class c ) { String classPackageName = c . getPackage ( ) . getName ( ) ; return classPackageName . equals ( targetPackageName ) | | classPackageName . startsWith ( targetPackageName + <str> ) ; } @Override public boolean equals ( Object other ) { return other instanceof InSubpackage & & ( ( InSubpackage ) other ) . targetPackageName . equals ( targetPackageName ) ; } @Override public int hashCode ( ) { return <int> * targetPackageName . hashCode ( ) ; } @Override public String toString ( ) { return <str> + targetPackageName + <str> ; } private static final long serialVersionUID = <int> ; } public static Matcher < Method > returns ( final Matcher < ? super Class < ? > > returnType ) { return new Returns ( returnType ) ; } private static class Returns extends AbstractMatcher < Method > implements Serializable { private final Matcher < ? super Class < ? > > returnType ; public Returns ( Matcher < ? super Class < ? > > returnType ) { this . returnType = Objects . requireNonNull ( returnType , <str> ) ; } @Override public boolean matches ( Method m ) { return returnType . matches ( m . getReturnType ( ) ) ; } @Override public boolean equals ( Object other ) { return other instanceof Returns & & ( ( Returns ) other ) . returnType . equals ( returnType ) ; } @Override public int hashCode ( ) { return <int> * returnType . hashCode ( ) ; } @Override public String toString ( ) { return <str> + returnType + <str> ; } private static final long serialVersionUID = <int> ; } } 
