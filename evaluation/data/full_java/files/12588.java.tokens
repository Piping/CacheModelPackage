package org . gradle . api . internal . artifacts . ivyservice . ivyresolve . parser ; import org . apache . ivy . Ivy ; import org . apache . ivy . core . module . descriptor . * ; import org . apache . ivy . core . module . descriptor . Configuration . Visibility ; import org . apache . ivy . core . module . id . ArtifactId ; import org . apache . ivy . core . module . id . ModuleId ; import org . apache . ivy . core . module . id . ModuleRevisionId ; import org . apache . ivy . plugins . matcher . ExactPatternMatcher ; import org . apache . ivy . plugins . matcher . PatternMatcher ; import org . apache . ivy . plugins . parser . xml . XmlModuleDescriptorParser ; import org . gradle . api . internal . artifacts . ivyservice . IvyUtil ; import org . gradle . api . internal . artifacts . ivyservice . ivyresolve . parser . PomReader . PomDependencyData ; import org . gradle . api . internal . artifacts . ivyservice . ivyresolve . parser . data . PomDependencyMgt ; import org . gradle . api . internal . artifacts . ivyservice . ivyresolve . strategy . VersionSelector ; import org . gradle . api . internal . artifacts . ivyservice . ivyresolve . strategy . VersionSelectorScheme ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class GradlePomModuleDescriptorBuilder { public static final Configuration [ ] MAVEN2_CONFIGURATIONS = new Configuration [ ] { new Configuration ( <str> , Visibility . PUBLIC , <str> , new String [ ] { <str> , <str> } , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> + <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> + <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> + <str> + <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> + <str> + <str> , new String [ ] { <str> } , true , null ) , new Configuration ( <str> , Visibility . PRIVATE , <str> + <str> + <str> , new String [ ] { <str> } , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> + <str> + <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> , new String [ <int> ] , true , null ) , new Configuration ( <str> , Visibility . PUBLIC , <str> , new String [ <int> ] , true , null ) } ; static final Map < String , ConfMapper > MAVEN2_CONF_MAPPING = new HashMap < String , ConfMapper > ( ) ; private static final Pattern TIMESTAMP_PATTERN = Pattern . compile ( <str> ) ; private static final String EXTRA_ATTRIBUTE_CLASSIFIER = <str> ; static interface ConfMapper { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) ; } static { MAVEN2_CONF_MAPPING . put ( <str> , new ConfMapper ( ) { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) { if ( isOptional ) { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } else { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } } } ) ; MAVEN2_CONF_MAPPING . put ( <str> , new ConfMapper ( ) { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) { if ( isOptional ) { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } else { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } } } ) ; MAVEN2_CONF_MAPPING . put ( <str> , new ConfMapper ( ) { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) { if ( isOptional ) { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } else { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } } } ) ; MAVEN2_CONF_MAPPING . put ( <str> , new ConfMapper ( ) { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) { dd . addDependencyConfiguration ( <str> , <str> ) ; dd . addDependencyConfiguration ( <str> , <str> ) ; } } ) ; MAVEN2_CONF_MAPPING . put ( <str> , new ConfMapper ( ) { public void addMappingConfs ( DefaultDependencyDescriptor dd , boolean isOptional ) { dd . addDependencyConfiguration ( <str> , <str> ) ; } } ) ; } private final VersionSelectorScheme defaultVersionSelectorScheme ; private final VersionSelectorScheme mavenVersionSelectorScheme ; private final DefaultModuleDescriptor ivyModuleDescriptor ; private ModuleRevisionId mrid ; private final PomReader pomReader ; public GradlePomModuleDescriptorBuilder ( PomReader pomReader , VersionSelectorScheme gradleVersionSelectorScheme , VersionSelectorScheme mavenVersionSelectorScheme ) { this . defaultVersionSelectorScheme = gradleVersionSelectorScheme ; this . mavenVersionSelectorScheme = mavenVersionSelectorScheme ; ivyModuleDescriptor = new DefaultModuleDescriptor ( XmlModuleDescriptorParser . getInstance ( ) , null ) ; ivyModuleDescriptor . setResolvedPublicationDate ( new Date ( ) ) ; for ( Configuration maven2Configuration : MAVEN2_CONFIGURATIONS ) { ivyModuleDescriptor . addConfiguration ( maven2Configuration ) ; } ivyModuleDescriptor . setMappingOverride ( true ) ; ivyModuleDescriptor . addExtraAttributeNamespace ( <str> , Ivy . getIvyHomeURL ( ) + <str> ) ; this . pomReader = pomReader ; } public DefaultModuleDescriptor getModuleDescriptor ( ) { return ivyModuleDescriptor ; } public void setModuleRevId ( String group , String module , String version ) { String effectiveVersion = version ; if ( version ! = null ) { Matcher matcher = TIMESTAMP_PATTERN . matcher ( version ) ; if ( matcher . matches ( ) ) { effectiveVersion = matcher . group ( <int> ) + <str> ; } } this . mrid = IvyUtil . createModuleRevisionId ( group , module , effectiveVersion ) ; ivyModuleDescriptor . setModuleRevisionId ( mrid ) ; if ( effectiveVersion ! = null & & effectiveVersion . endsWith ( <str> ) ) { ivyModuleDescriptor . setStatus ( <str> ) ; } else { ivyModuleDescriptor . setStatus ( <str> ) ; } } public void setHomePage ( String homePage ) { ivyModuleDescriptor . setHomePage ( homePage ) ; } public void setDescription ( String description ) { ivyModuleDescriptor . setDescription ( description ) ; } public void setLicenses ( Iterable < License > licenses ) { for ( License license : licenses ) { ivyModuleDescriptor . addLicense ( license ) ; } } public void addDependency ( PomDependencyData dep ) { String scope = dep . getScope ( ) ; if ( ( scope ! = null ) & & ( scope . length ( ) > <int> ) & & ! MAVEN2_CONF_MAPPING . containsKey ( scope ) ) { scope = <str> ; } String version = determineVersion ( dep ) ; String mappedVersion = convertVersionFromMavenSyntax ( version ) ; ModuleRevisionId moduleRevId = IvyUtil . createModuleRevisionId ( dep . getGroupId ( ) , dep . getArtifactId ( ) , mappedVersion ) ; ModuleRevisionId mRevId = ivyModuleDescriptor . getModuleRevisionId ( ) ; if ( ( mRevId ! = null ) & & mRevId . getModuleId ( ) . equals ( moduleRevId . getModuleId ( ) ) ) { return ; } DefaultDependencyDescriptor dd = new DefaultDependencyDescriptor ( ivyModuleDescriptor , moduleRevId , true , false , true ) ; scope = ( scope = = null | | scope . length ( ) = = <int> ) ? getDefaultScope ( dep ) : scope ; ConfMapper mapping = MAVEN2_CONF_MAPPING . get ( scope ) ; mapping . addMappingConfs ( dd , dep . isOptional ( ) ) ; Map < String , String > extraAtt = new HashMap < String , String > ( ) ; boolean hasClassifier = dep . getClassifier ( ) ! = null & & dep . getClassifier ( ) . length ( ) > <int> ; boolean hasNonJarType = dep . getType ( ) ! = null & & ! <str> . equals ( dep . getType ( ) ) ; if ( hasClassifier | | hasNonJarType ) { String type = <str> ; if ( dep . getType ( ) ! = null ) { type = dep . getType ( ) ; } String ext = determineExtension ( type ) ; handleSpecialTypes ( type , extraAtt ) ; if ( dep . getClassifier ( ) ! = null ) { extraAtt . put ( EXTRA_ATTRIBUTE_CLASSIFIER , dep . getClassifier ( ) ) ; } DefaultDependencyArtifactDescriptor depArtifact = new DefaultDependencyArtifactDescriptor ( dd , dd . getDependencyId ( ) . getName ( ) , type , ext , null , extraAtt ) ; String optionalizedScope = dep . isOptional ( ) ? <str> : scope ; dd . addDependencyArtifact ( optionalizedScope , depArtifact ) ; } List < ModuleId > excluded = dep . getExcludedModules ( ) ; if ( excluded . isEmpty ( ) ) { excluded = getDependencyMgtExclusions ( dep ) ; } for ( Object anExcluded : excluded ) { ModuleId excludedModule = ( ModuleId ) anExcluded ; String [ ] confs = dd . getModuleConfigurations ( ) ; for ( String conf : confs ) { dd . addExcludeRule ( conf , new DefaultExcludeRule ( new ArtifactId ( excludedModule , PatternMatcher . ANY_EXPRESSION , PatternMatcher . ANY_EXPRESSION , PatternMatcher . ANY_EXPRESSION ) , ExactPatternMatcher . INSTANCE , null ) ) ; } } ivyModuleDescriptor . addDependency ( dd ) ; } private String convertVersionFromMavenSyntax ( String version ) { VersionSelector versionSelector = mavenVersionSelectorScheme . parseSelector ( version ) ; return defaultVersionSelectorScheme . renderSelector ( versionSelector ) ; } private String determineExtension ( String type ) { return JarDependencyType . isJarExtension ( type ) ? <str> : type ; } private void handleSpecialTypes ( String type , Map < String , String > extraAttributes ) { if ( JarDependencyType . TEST_JAR . getName ( ) . equals ( type ) ) { extraAttributes . put ( EXTRA_ATTRIBUTE_CLASSIFIER , <str> ) ; } else if ( JarDependencyType . EJB_CLIENT . getName ( ) . equals ( type ) ) { extraAttributes . put ( EXTRA_ATTRIBUTE_CLASSIFIER , <str> ) ; } } private enum JarDependencyType { TEST_JAR ( <str> ) , EJB_CLIENT ( <str> ) , EJB ( <str> ) , BUNDLE ( <str> ) , MAVEN_PLUGIN ( <str> ) , ECLIPSE_PLUGIN ( <str> ) ; private static final Map < String , JarDependencyType > TYPES ; static { TYPES = new HashMap < String , JarDependencyType > ( ) ; for ( JarDependencyType type : values ( ) ) { TYPES . put ( type . name , type ) ; } } private final String name ; private JarDependencyType ( String name ) { this . name = name ; } public String getName ( ) { return name ; } public static boolean isJarExtension ( String type ) { return TYPES . containsKey ( type ) ; } } private String determineVersion ( PomDependencyData dependency ) { String version = dependency . getVersion ( ) ; version = ( version = = null | | version . length ( ) = = <int> ) ? getDefaultVersion ( dependency ) : version ; if ( version = = null ) { throw new UnresolvedDependencyVersionException ( dependency . getId ( ) ) ; } return version ; } public void addDependency ( DependencyDescriptor descriptor ) { ModuleId dependencyId = descriptor . getDependencyId ( ) ; ModuleRevisionId mRevId = ivyModuleDescriptor . getModuleRevisionId ( ) ; if ( ( mRevId ! = null ) & & mRevId . getModuleId ( ) . equals ( dependencyId ) ) { return ; } ivyModuleDescriptor . addDependency ( descriptor ) ; } private String getDefaultVersion ( PomDependencyData dep ) { PomDependencyMgt pomDependencyMgt = findDependencyDefault ( dep ) ; if ( pomDependencyMgt ! = null ) { return pomDependencyMgt . getVersion ( ) ; } return null ; } private String getDefaultScope ( PomDependencyData dep ) { PomDependencyMgt pomDependencyMgt = findDependencyDefault ( dep ) ; String result = null ; if ( pomDependencyMgt ! = null ) { result = pomDependencyMgt . getScope ( ) ; } if ( ( result = = null ) | | ! MAVEN2_CONF_MAPPING . containsKey ( result ) ) { result = <str> ; } return result ; } private List < ModuleId > getDependencyMgtExclusions ( PomDependencyData dep ) { PomDependencyMgt pomDependencyMgt = findDependencyDefault ( dep ) ; if ( pomDependencyMgt ! = null ) { return pomDependencyMgt . getExcludedModules ( ) ; } return Collections . emptyList ( ) ; } private PomDependencyMgt findDependencyDefault ( PomDependencyData dependency ) { return pomReader . findDependencyDefaults ( dependency . getId ( ) ) ; } } 
