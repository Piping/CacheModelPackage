package org . apache . cassandra . index . internal . composites ; import java . nio . ByteBuffer ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . db . marshal . SetType ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . IndexEntry ; import org . apache . cassandra . schema . IndexMetadata ; public class CollectionValueIndex extends CassandraIndex { public CollectionValueIndex ( ColumnFamilyStore baseCfs , IndexMetadata indexDef ) { super ( baseCfs , indexDef ) ; } public ByteBuffer getIndexedValue ( ByteBuffer partitionKey , Clustering clustering , CellPath path , ByteBuffer cellValue ) { return cellValue ; } public CBuilder buildIndexClusteringPrefix ( ByteBuffer partitionKey , ClusteringPrefix prefix , CellPath path ) { CBuilder builder = CBuilder . create ( getIndexComparator ( ) ) ; builder . add ( partitionKey ) ; for ( int i = <int> ; i < prefix . size ( ) ; i + + ) builder . add ( prefix . get ( i ) ) ; if ( prefix . size ( ) = = baseCfs . metadata . clusteringColumns ( ) . size ( ) & & path ! = null ) builder . add ( path . get ( <int> ) ) ; return builder ; } public IndexEntry decodeEntry ( DecoratedKey indexedValue , Row indexEntry ) { Clustering clustering = indexEntry . clustering ( ) ; CBuilder builder = CBuilder . create ( baseCfs . getComparator ( ) ) ; for ( int i = <int> ; i < baseCfs . getComparator ( ) . size ( ) ; i + + ) builder . add ( clustering . get ( i + <int> ) ) ; return new IndexEntry ( indexedValue , clustering , indexEntry . primaryKeyLivenessInfo ( ) . timestamp ( ) , clustering . get ( <int> ) , builder . build ( ) ) ; } public boolean supportsOperator ( ColumnDefinition indexedColumn , Operator operator ) { return operator = = Operator . CONTAINS & & ! ( indexedColumn . type instanceof SetType ) ; } public boolean isStale ( Row data , ByteBuffer indexValue , int nowInSec ) { ColumnDefinition columnDef = indexedColumn ; ComplexColumnData complexData = data . getComplexColumnData ( columnDef ) ; if ( complexData = = null ) return true ; for ( Cell cell : complexData ) { if ( cell . isLive ( nowInSec ) & & ( ( CollectionType ) columnDef . type ) . valueComparator ( ) . compare ( indexValue , cell . value ( ) ) = = <int> ) return false ; } return true ; } } 
