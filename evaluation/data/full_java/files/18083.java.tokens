package com . badlogic . gdx . graphics . g3d . particles . values ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonValue ; public class ScaledNumericValue extends RangedNumericValue { private float [ ] scaling = { <int> } ; public float [ ] timeline = { <int> } ; private float highMin , highMax ; private boolean relative = false ; public float newHighValue ( ) { return highMin + ( highMax - highMin ) * MathUtils . random ( ) ; } public void setHigh ( float value ) { highMin = value ; highMax = value ; } public void setHigh ( float min , float max ) { highMin = min ; highMax = max ; } public float getHighMin ( ) { return highMin ; } public void setHighMin ( float highMin ) { this . highMin = highMin ; } public float getHighMax ( ) { return highMax ; } public void setHighMax ( float highMax ) { this . highMax = highMax ; } public float [ ] getScaling ( ) { return scaling ; } public void setScaling ( float [ ] values ) { this . scaling = values ; } public float [ ] getTimeline ( ) { return timeline ; } public void setTimeline ( float [ ] timeline ) { this . timeline = timeline ; } public boolean isRelative ( ) { return relative ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public float getScale ( float percent ) { int endIndex = - <int> ; int n = timeline . length ; for ( int i = <int> ; i < n ; i + + ) { float t = timeline [ i ] ; if ( t > percent ) { endIndex = i ; break ; } } if ( endIndex = = - <int> ) return scaling [ n - <int> ] ; int startIndex = endIndex - <int> ; float startValue = scaling [ startIndex ] ; float startTime = timeline [ startIndex ] ; return startValue + ( scaling [ endIndex ] - startValue ) * ( ( percent - startTime ) / ( timeline [ endIndex ] - startTime ) ) ; } public void load ( ScaledNumericValue value ) { super . load ( value ) ; highMax = value . highMax ; highMin = value . highMin ; scaling = new float [ value . scaling . length ] ; System . arraycopy ( value . scaling , <int> , scaling , <int> , scaling . length ) ; timeline = new float [ value . timeline . length ] ; System . arraycopy ( value . timeline , <int> , timeline , <int> , timeline . length ) ; relative = value . relative ; } @Override public void write ( Json json ) { super . write ( json ) ; json . writeValue ( <str> , highMin ) ; json . writeValue ( <str> , highMax ) ; json . writeValue ( <str> , relative ) ; json . writeValue ( <str> , scaling ) ; json . writeValue ( <str> , timeline ) ; } @Override public void read ( Json json , JsonValue jsonData ) { super . read ( json , jsonData ) ; highMin = json . readValue ( <str> , float . class , jsonData ) ; highMax = json . readValue ( <str> , float . class , jsonData ) ; relative = json . readValue ( <str> , boolean . class , jsonData ) ; scaling = json . readValue ( <str> , float [ ] . class , jsonData ) ; timeline = json . readValue ( <str> , float [ ] . class , jsonData ) ; } } 
