package org . nd4j . linalg . api . ops . impl . transforms ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseTransformOp ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; public class LeakyReLUDerivative extends BaseTransformOp { private double alpha = <float> ; public LeakyReLUDerivative ( ) { } public LeakyReLUDerivative ( INDArray x , INDArray z ) { super ( x , z ) ; } public LeakyReLUDerivative ( INDArray x , INDArray z , int n ) { super ( x , z , n ) ; } public LeakyReLUDerivative ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; } public LeakyReLUDerivative ( INDArray x ) { super ( x ) ; } public LeakyReLUDerivative ( INDArray x , INDArray z , double alpha ) { super ( x , z ) ; this . alpha = alpha ; } public LeakyReLUDerivative ( INDArray x , INDArray z , int n , double alpha ) { super ( x , z , n ) ; this . alpha = alpha ; } public LeakyReLUDerivative ( INDArray x , INDArray y , INDArray z , int n , double alpha ) { super ( x , y , z , n ) ; this . alpha = alpha ; } public LeakyReLUDerivative ( INDArray x , double alpha ) { super ( x ) ; this . alpha = alpha ; } @Override public String name ( ) { return <str> ; } @Override public IComplexNumber op ( IComplexNumber origin , double other ) { return ( origin . realComponent ( ) . doubleValue ( ) > = <float> ? Nd4j . createDouble ( <int> , <int> ) : Nd4j . createDouble ( alpha , <int> ) ) ; } @Override public IComplexNumber op ( IComplexNumber origin , float other ) { return ( origin . realComponent ( ) . doubleValue ( ) > = <float> ? Nd4j . createDouble ( <int> , <int> ) : Nd4j . createDouble ( alpha , <int> ) ) ; } @Override public IComplexNumber op ( IComplexNumber origin , IComplexNumber other ) { return ( origin . realComponent ( ) . doubleValue ( ) > = <float> ? Nd4j . createDouble ( <int> , <int> ) : Nd4j . createDouble ( alpha , <int> ) ) ; } @Override public float op ( float origin , float other ) { return ( origin > = <float> ? <float> : ( float ) alpha ) ; } @Override public double op ( double origin , double other ) { return ( origin > = <int> ? <float> : alpha ) ; } @Override public double op ( double origin ) { return ( origin > = <int> ? <float> : alpha ) ; } @Override public float op ( float origin ) { return ( origin > = <float> ? <float> : ( float ) alpha ) ; } @Override public IComplexNumber op ( IComplexNumber origin ) { return ( origin . realComponent ( ) . doubleValue ( ) > = <int> ? Nd4j . createDouble ( <int> , <int> ) : Nd4j . createDouble ( alpha , <int> ) ) ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new LeakyReLUDerivative ( x . vectorAlongDimension ( index , dimension ) , y . vectorAlongDimension ( index , dimension ) , z . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) , alpha ) ; else return new LeakyReLUDerivative ( x . vectorAlongDimension ( index , dimension ) , z . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) , alpha ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new LeakyReLUDerivative ( x . tensorAlongDimension ( index , dimension ) , y . tensorAlongDimension ( index , dimension ) , z . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) , alpha ) ; else return new LeakyReLUDerivative ( x . tensorAlongDimension ( index , dimension ) , z . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) , alpha ) ; } } 
