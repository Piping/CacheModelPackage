package org . elasticsearch . script . expression ; import org . apache . lucene . expressions . Expression ; import org . apache . lucene . expressions . SimpleBindings ; import org . apache . lucene . expressions . js . JavascriptCompiler ; import org . apache . lucene . expressions . js . VariableContext ; import org . apache . lucene . queries . function . ValueSource ; import org . apache . lucene . queries . function . valuesource . DoubleConstValueSource ; import org . apache . lucene . search . SortField ; import org . elasticsearch . SpecialPermission ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import org . elasticsearch . script . ClassPermission ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptEngineService ; import org . elasticsearch . script . ScriptException ; import org . elasticsearch . script . SearchScript ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . search . lookup . SearchLookup ; import java . security . AccessControlContext ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . text . ParseException ; import java . util . Calendar ; import java . util . Map ; public class ExpressionScriptEngineService extends AbstractComponent implements ScriptEngineService { public static final String NAME = <str> ; protected static final String GET_YEAR_METHOD = <str> ; protected static final String GET_MONTH_METHOD = <str> ; protected static final String GET_DAY_OF_MONTH_METHOD = <str> ; protected static final String GET_HOUR_OF_DAY_METHOD = <str> ; protected static final String GET_MINUTES_METHOD = <str> ; protected static final String GET_SECONDS_METHOD = <str> ; protected static final String MINIMUM_METHOD = <str> ; protected static final String MAXIMUM_METHOD = <str> ; protected static final String AVERAGE_METHOD = <str> ; protected static final String MEDIAN_METHOD = <str> ; protected static final String SUM_METHOD = <str> ; protected static final String COUNT_METHOD = <str> ; @Inject public ExpressionScriptEngineService ( Settings settings ) { super ( settings ) ; } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return new String [ ] { NAME } ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { final SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new SpecialPermission ( ) ) ; } return AccessController . doPrivileged ( new PrivilegedAction < Expression > ( ) { @Override public Expression run ( ) { try { AccessControlContext engineContext = AccessController . getContext ( ) ; ClassLoader loader = getClass ( ) . getClassLoader ( ) ; if ( sm ! = null ) { loader = new ClassLoader ( loader ) { @Override protected Class < ? > loadClass ( String name , boolean resolve ) throws ClassNotFoundException { try { engineContext . checkPermission ( new ClassPermission ( name ) ) ; } catch ( SecurityException e ) { throw new ClassNotFoundException ( name , e ) ; } return super . loadClass ( name , resolve ) ; } } ; } return JavascriptCompiler . compile ( script , JavascriptCompiler . DEFAULT_FUNCTIONS , loader ) ; } catch ( ParseException e ) { throw new ScriptException ( <str> + script , e ) ; } } } ) ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , @Nullable Map < String , Object > vars ) { try { Expression expr = ( Expression ) compiledScript . compiled ( ) ; MapperService mapper = lookup . doc ( ) . mapperService ( ) ; SimpleBindings bindings = new SimpleBindings ( ) ; ReplaceableConstValueSource specialValue = null ; for ( String variable : expr . variables ) { if ( variable . equals ( <str> ) ) { bindings . add ( new SortField ( <str> , SortField . Type . SCORE ) ) ; } else if ( variable . equals ( <str> ) ) { specialValue = new ReplaceableConstValueSource ( ) ; bindings . add ( <str> , specialValue ) ; } else if ( vars ! = null & & vars . containsKey ( variable ) ) { Object value = vars . get ( variable ) ; if ( value instanceof Number ) { bindings . add ( variable , new DoubleConstValueSource ( ( ( Number ) value ) . doubleValue ( ) ) ) ; } else { throw new ScriptException ( <str> + variable + <str> ) ; } } else { String fieldname = null ; String methodname = null ; VariableContext [ ] parts = VariableContext . parse ( variable ) ; if ( parts [ <int> ] . text . equals ( <str> ) = = false ) { throw new ScriptException ( <str> + parts [ <int> ] . text + <str> ) ; } if ( parts . length < <int> | | parts [ <int> ] . type ! = VariableContext . Type . STR_INDEX ) { throw new ScriptException ( <str> ) ; } else { fieldname = parts [ <int> ] . text ; } if ( parts . length = = <int> ) { if ( parts [ <int> ] . type = = VariableContext . Type . METHOD ) { methodname = parts [ <int> ] . text ; } else if ( parts [ <int> ] . type ! = VariableContext . Type . MEMBER | | ! <str> . equals ( parts [ <int> ] . text ) ) { throw new ScriptException ( <str> ) ; } } if ( parts . length > <int> ) { throw new ScriptException ( <str> + variable + <str> ) ; } MappedFieldType fieldType = mapper . smartNameFieldType ( fieldname ) ; if ( fieldType = = null ) { throw new ScriptException ( <str> + fieldname + <str> ) ; } if ( fieldType . isNumeric ( ) = = false ) { throw new ScriptException ( <str> + fieldname + <str> ) ; } IndexFieldData < ? > fieldData = lookup . doc ( ) . fieldDataService ( ) . getForField ( ( NumberFieldMapper . NumberFieldType ) fieldType ) ; if ( methodname = = null ) { bindings . add ( variable , new FieldDataValueSource ( fieldData , MultiValueMode . MIN ) ) ; } else { bindings . add ( variable , getMethodValueSource ( fieldType , fieldData , fieldname , methodname ) ) ; } } } final boolean needsScores = expr . getSortField ( bindings , false ) . needsScores ( ) ; return new ExpressionSearchScript ( compiledScript , bindings , specialValue , needsScores ) ; } catch ( Exception exception ) { throw new ScriptException ( <str> + compiledScript , exception ) ; } } protected ValueSource getMethodValueSource ( MappedFieldType fieldType , IndexFieldData < ? > fieldData , String fieldName , String methodName ) { switch ( methodName ) { case GET_YEAR_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . YEAR ) ; case GET_MONTH_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . MONTH ) ; case GET_DAY_OF_MONTH_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . DAY_OF_MONTH ) ; case GET_HOUR_OF_DAY_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . HOUR_OF_DAY ) ; case GET_MINUTES_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . MINUTE ) ; case GET_SECONDS_METHOD : return getDateMethodValueSource ( fieldType , fieldData , fieldName , methodName , Calendar . SECOND ) ; case MINIMUM_METHOD : return new FieldDataValueSource ( fieldData , MultiValueMode . MIN ) ; case MAXIMUM_METHOD : return new FieldDataValueSource ( fieldData , MultiValueMode . MAX ) ; case AVERAGE_METHOD : return new FieldDataValueSource ( fieldData , MultiValueMode . AVG ) ; case MEDIAN_METHOD : return new FieldDataValueSource ( fieldData , MultiValueMode . MEDIAN ) ; case SUM_METHOD : return new FieldDataValueSource ( fieldData , MultiValueMode . SUM ) ; case COUNT_METHOD : return new CountMethodValueSource ( fieldData ) ; default : throw new IllegalArgumentException ( <str> + methodName + <str> ) ; } } protected ValueSource getDateMethodValueSource ( MappedFieldType fieldType , IndexFieldData < ? > fieldData , String fieldName , String methodName , int calendarType ) { if ( ! ( fieldType instanceof DateFieldMapper . DateFieldType ) ) { throw new IllegalArgumentException ( <str> + methodName + <str> + fieldName + <str> ) ; } return new DateMethodValueSource ( fieldData , MultiValueMode . MIN , methodName , calendarType ) ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > vars ) { return new ExpressionExecutableScript ( compiledScript , vars ) ; } @Override public void close ( ) { } @Override public void scriptRemoved ( CompiledScript script ) { } } 
