package org . apache . cassandra . db ; import java . io . IOException ; import java . util . Collections ; import com . google . common . collect . Iterables ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . rows . AbstractRow ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class RepairedDataTombstonesTest extends CQLTester { @Test public void compactionTest ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; SSTableReader repairedSSTable = getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; repair ( getCurrentColumnFamilyStore ( ) , repairedSSTable ) ; Thread . sleep ( <int> ) ; execute ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; getCurrentColumnFamilyStore ( ) . forceMajorCompaction ( ) ; verify ( ) ; verify2 ( <int> ) ; assertEquals ( <int> , Iterables . size ( getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) ) ) ; } @Test public void compactionDropExpiredSSTableTest ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; SSTableReader repairedSSTable = getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; repair ( getCurrentColumnFamilyStore ( ) , repairedSSTable ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; getCurrentColumnFamilyStore ( ) . forceMajorCompaction ( ) ; verify ( ) ; verify2 ( <int> ) ; assertEquals ( <int> , Iterables . size ( getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) ) ) ; assertFalse ( getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) . isRepaired ( ) ) ; } @Test public void readTest ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; SSTableReader repairedSSTable = getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; repair ( getCurrentColumnFamilyStore ( ) , repairedSSTable ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; verify ( ) ; verify2 ( <int> ) ; } @Test public void readOnlyUnrepairedTest ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; verify ( ) ; verify2 ( <int> ) ; } @Test public void readTestRowTombstones ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; SSTableReader repairedSSTable = getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; repair ( getCurrentColumnFamilyStore ( ) , repairedSSTable ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , <int> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; verify ( ) ; verify2 ( <int> ) ; } @Test public void readTestPartitionTombstones ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , i ) ; } flush ( ) ; SSTableReader repairedSSTable = getCurrentColumnFamilyStore ( ) . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; repair ( getCurrentColumnFamilyStore ( ) , repairedSSTable ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; ReadCommand cmd = Util . cmd ( getCurrentColumnFamilyStore ( ) ) . build ( ) ; int partitionsFound = <int> ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator iterator = cmd . executeLocally ( executionController ) ) { while ( iterator . hasNext ( ) ) { partitionsFound + + ; UnfilteredRowIterator rowIter = iterator . next ( ) ; int val = ByteBufferUtil . toInt ( rowIter . partitionKey ( ) . getKey ( ) ) ; assertTrue ( <str> + val , val > = <int> & & val < <int> ) ; } } assertEquals ( <int> , partitionsFound ) ; } @Test public void readTestOldUnrepaired ( ) throws Throwable { createTable ( <str> ) ; getCurrentColumnFamilyStore ( ) . disableAutoCompaction ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , i ) ; } flush ( ) ; SSTableReader oldSSTable = getCurrentColumnFamilyStore ( ) . getLiveSSTables ( ) . iterator ( ) . next ( ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , i ) ; } flush ( ) ; for ( SSTableReader sstable : getCurrentColumnFamilyStore ( ) . getLiveSSTables ( ) ) if ( sstable ! = oldSSTable ) repair ( getCurrentColumnFamilyStore ( ) , sstable ) ; Thread . sleep ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { execute ( <str> , i ) ; } flush ( ) ; Thread . sleep ( <int> ) ; verify ( <int> , <int> , <int> ) ; verify2 ( <int> , <int> , <int> , <int> ) ; } private void verify ( ) { verify ( <int> , <int> , <int> ) ; } private void verify ( int expectedRows , int minVal , int maxVal ) { ReadCommand cmd = Util . cmd ( getCurrentColumnFamilyStore ( ) ) . build ( ) ; int foundRows = <int> ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator iterator = cmd . executeLocally ( executionController ) ) { while ( iterator . hasNext ( ) ) { UnfilteredRowIterator rowIter = iterator . next ( ) ; if ( ! rowIter . partitionKey ( ) . equals ( Util . dk ( ByteBufferUtil . bytes ( <int> ) ) ) ) { while ( rowIter . hasNext ( ) ) { AbstractRow row = ( AbstractRow ) rowIter . next ( ) ; for ( int i = <int> ; i < row . clustering ( ) . size ( ) ; i + + ) { foundRows + + ; int val = ByteBufferUtil . toInt ( row . clustering ( ) . get ( i ) ) ; assertTrue ( <str> + val , val > = minVal & & val < maxVal ) ; } } } } } assertEquals ( expectedRows , foundRows ) ; } private void verify2 ( int key ) { verify2 ( key , <int> , <int> , <int> ) ; } private void verify2 ( int key , int expectedRows , int minVal , int maxVal ) { ReadCommand cmd = Util . cmd ( getCurrentColumnFamilyStore ( ) , Util . dk ( ByteBufferUtil . bytes ( key ) ) ) . build ( ) ; int foundRows = <int> ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator iterator = cmd . executeLocally ( executionController ) ) { while ( iterator . hasNext ( ) ) { UnfilteredRowIterator rowIter = iterator . next ( ) ; while ( rowIter . hasNext ( ) ) { AbstractRow row = ( AbstractRow ) rowIter . next ( ) ; for ( int i = <int> ; i < row . clustering ( ) . size ( ) ; i + + ) { foundRows + + ; int val = ByteBufferUtil . toInt ( row . clustering ( ) . get ( i ) ) ; assertTrue ( <str> + val , val > = minVal & & val < maxVal ) ; } } } } assertEquals ( expectedRows , foundRows ) ; } public static void repair ( ColumnFamilyStore cfs , SSTableReader sstable ) throws IOException { sstable . descriptor . getMetadataSerializer ( ) . mutateRepairedAt ( sstable . descriptor , <int> ) ; sstable . reloadSSTableMetadata ( ) ; cfs . getTracker ( ) . notifySSTableRepairedStatusChanged ( Collections . singleton ( sstable ) ) ; } } 
