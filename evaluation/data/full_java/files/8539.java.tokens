package org . elasticsearch . search . suggest . completion ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . common . inject . matcher . Matchers ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . search . suggest . completion . context . * ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . * ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . suggest . completion . CategoryContextMappingTests . assertContextSuggestFields ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . isIn ; public class GeoContextMappingTests extends ESSingleNodeTestCase { public void testIndexingWithNoContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . array ( <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . array ( <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithSimpleContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , - <float> ) . endObject ( ) . endObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithContextList ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> , <str> , <str> ) . startObject ( <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , - <float> ) . endObject ( ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , - <float> ) . endObject ( ) . endArray ( ) . endObject ( ) . field ( <str> , <int> ) . endObject ( ) . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testIndexingWithMultipleContexts ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . getMapper ( <str> ) ; MappedFieldType completionFieldType = fieldMapper . fieldType ( ) ; XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . startObject ( <str> ) . array ( <str> , <str> ) . array ( <str> , <str> ) . endObject ( ) . endObject ( ) . endArray ( ) . endObject ( ) ; ParsedDocument parsedDocument = defaultMapper . parse ( <str> , <str> , <str> , builder . bytes ( ) ) ; IndexableField [ ] fields = parsedDocument . rootDoc ( ) . getFields ( completionFieldType . names ( ) . indexName ( ) ) ; assertContextSuggestFields ( fields , <int> ) ; } public void testParsingQueryContextBasic ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . value ( <str> ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; GeoContextMapping mapping = ContextBuilder . geo ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> + <int> ) ) ; Collection < String > locations = new ArrayList < > ( ) ; locations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , GeoContextMapping . DEFAULT_PRECISION , locations ) ; for ( ContextMapping . QueryContext queryContext : queryContexts ) { assertThat ( queryContext . context , isIn ( locations ) ) ; assertThat ( queryContext . boost , equalTo ( <int> ) ) ; assertThat ( queryContext . isPrefix , equalTo ( false ) ) ; } } public void testParsingQueryContextGeoPoint ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; GeoContextMapping mapping = ContextBuilder . geo ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> + <int> ) ) ; Collection < String > locations = new ArrayList < > ( ) ; locations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , GeoContextMapping . DEFAULT_PRECISION , locations ) ; for ( ContextMapping . QueryContext queryContext : queryContexts ) { assertThat ( queryContext . context , isIn ( locations ) ) ; assertThat ( queryContext . boost , equalTo ( <int> ) ) ; assertThat ( queryContext . isPrefix , equalTo ( false ) ) ; } } public void testParsingQueryContextObject ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . field ( <str> , <int> ) . array ( <str> , <int> , <int> , <int> ) . endObject ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; GeoContextMapping mapping = ContextBuilder . geo ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> + <int> + <int> + <int> + <int> + <int> + <int> ) ) ; Collection < String > locations = new ArrayList < > ( ) ; locations . add ( <str> ) ; locations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , locations ) ; locations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , locations ) ; locations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , locations ) ; for ( ContextMapping . QueryContext queryContext : queryContexts ) { assertThat ( queryContext . context , isIn ( locations ) ) ; assertThat ( queryContext . boost , equalTo ( <int> ) ) ; assertThat ( queryContext . isPrefix , equalTo ( queryContext . context . length ( ) < GeoContextMapping . DEFAULT_PRECISION ) ) ; } } public void testParsingQueryContextObjectArray ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startArray ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . field ( <str> , <int> ) . array ( <str> , <int> , <int> , <int> ) . endObject ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . field ( <str> , <int> ) . array ( <str> , <int> ) . endObject ( ) . endArray ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; GeoContextMapping mapping = ContextBuilder . geo ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> + <int> + <int> + <int> + <int> + <int> + <int> + <int> + <int> + <int> ) ) ; Collection < String > firstLocations = new ArrayList < > ( ) ; firstLocations . add ( <str> ) ; firstLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , firstLocations ) ; firstLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , firstLocations ) ; firstLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , firstLocations ) ; Collection < String > secondLocations = new ArrayList < > ( ) ; secondLocations . add ( <str> ) ; secondLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , secondLocations ) ; for ( ContextMapping . QueryContext queryContext : queryContexts ) { if ( firstLocations . contains ( queryContext . context ) ) { assertThat ( queryContext . boost , equalTo ( <int> ) ) ; } else if ( secondLocations . contains ( queryContext . context ) ) { assertThat ( queryContext . boost , equalTo ( <int> ) ) ; } else { fail ( queryContext . context + <str> ) ; } assertThat ( queryContext . isPrefix , equalTo ( queryContext . context . length ( ) < GeoContextMapping . DEFAULT_PRECISION ) ) ; } } public void testParsingQueryContextMixed ( ) throws Exception { XContentBuilder builder = jsonBuilder ( ) . startArray ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . field ( <str> , <int> ) . array ( <str> , <int> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endArray ( ) ; XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( builder . bytes ( ) ) ; GeoContextMapping mapping = ContextBuilder . geo ( <str> ) . build ( ) ; List < ContextMapping . QueryContext > queryContexts = mapping . parseQueryContext ( parser ) ; assertThat ( queryContexts . size ( ) , equalTo ( <int> + <int> + <int> + <int> + <int> + <int> + <int> ) ) ; Collection < String > firstLocations = new ArrayList < > ( ) ; firstLocations . add ( <str> ) ; firstLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , firstLocations ) ; firstLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , firstLocations ) ; Collection < String > secondLocations = new ArrayList < > ( ) ; secondLocations . add ( <str> ) ; GeoHashUtils . addNeighbors ( <str> , <int> , secondLocations ) ; for ( ContextMapping . QueryContext queryContext : queryContexts ) { if ( firstLocations . contains ( queryContext . context ) ) { assertThat ( queryContext . boost , equalTo ( <int> ) ) ; } else if ( secondLocations . contains ( queryContext . context ) ) { assertThat ( queryContext . boost , equalTo ( <int> ) ) ; } else { fail ( queryContext . context + <str> ) ; } assertThat ( queryContext . isPrefix , equalTo ( queryContext . context . length ( ) < GeoContextMapping . DEFAULT_PRECISION ) ) ; } } } 
