package org . elasticsearch . action ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . action . search . ShardSearchFailure ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import java . util . Locale ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = ESIntegTestCase . Scope . SUITE , numDataNodes = <int> ) public class RejectionActionIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; } public void testSimulatedSearchRejectionLoad ( ) throws Throwable { for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> ) . get ( ) ; } int numberOfAsyncOps = randomIntBetween ( <int> , <int> ) ; final CountDownLatch latch = new CountDownLatch ( numberOfAsyncOps ) ; final CopyOnWriteArrayList < Object > responses = new CopyOnWriteArrayList < > ( ) ; for ( int i = <int> ; i < numberOfAsyncOps ; i + + ) { client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_THEN_FETCH ) . setQuery ( QueryBuilders . matchQuery ( <str> , <str> ) ) . execute ( new ActionListener < SearchResponse > ( ) { @Override public void onResponse ( SearchResponse searchResponse ) { responses . add ( searchResponse ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable e ) { responses . add ( e ) ; latch . countDown ( ) ; } } ) ; } latch . await ( ) ; assertThat ( responses . size ( ) , equalTo ( numberOfAsyncOps ) ) ; for ( Object response : responses ) { if ( response instanceof SearchResponse ) { SearchResponse searchResponse = ( SearchResponse ) response ; for ( ShardSearchFailure failure : searchResponse . getShardFailures ( ) ) { assertTrue ( <str> + failure . reason ( ) , failure . reason ( ) . toLowerCase ( Locale . ENGLISH ) . contains ( <str> ) ) ; } } else { Throwable t = ( Throwable ) response ; Throwable unwrap = ExceptionsHelper . unwrapCause ( t ) ; if ( unwrap instanceof SearchPhaseExecutionException ) { SearchPhaseExecutionException e = ( SearchPhaseExecutionException ) unwrap ; for ( ShardSearchFailure failure : e . shardFailures ( ) ) { assertTrue ( <str> + failure . reason ( ) , failure . reason ( ) . toLowerCase ( Locale . ENGLISH ) . contains ( <str> ) ) ; } } else if ( ( unwrap instanceof EsRejectedExecutionException ) = = false ) { throw new AssertionError ( <str> , ( Throwable ) response ) ; } } } } } 
