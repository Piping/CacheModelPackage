package org . gradle . api . internal . tasks . compile ; import com . google . common . collect . Iterables ; import groovy . lang . Binding ; import groovy . lang . GroovyClassLoader ; import groovy . lang . GroovyShell ; import groovy . lang . GroovySystem ; import org . codehaus . groovy . control . CompilationUnit ; import org . codehaus . groovy . control . CompilerConfiguration ; import org . codehaus . groovy . control . customizers . ImportCustomizer ; import org . codehaus . groovy . control . messages . SimpleMessage ; import org . codehaus . groovy . tools . javac . JavaAwareCompilationUnit ; import org . codehaus . groovy . tools . javac . JavaCompiler ; import org . codehaus . groovy . tools . javac . JavaCompilerFactory ; import org . gradle . api . GradleException ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . classloading . GroovySystemLoader ; import org . gradle . api . internal . classloading . GroovySystemLoaderFactory ; import org . gradle . api . internal . file . collections . SimpleFileCollection ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . WorkResult ; import org . gradle . internal . classloader . DefaultClassLoaderFactory ; import org . gradle . internal . classloader . FilteringClassLoader ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . VersionNumber ; import java . io . File ; import java . io . IOException ; import java . io . Serializable ; import java . lang . reflect . Method ; import java . net . URL ; import java . util . * ; public class ApiGroovyCompiler implements org . gradle . language . base . internal . compile . Compiler < GroovyJavaJointCompileSpec > , Serializable { private final Compiler < JavaCompileSpec > javaCompiler ; public ApiGroovyCompiler ( Compiler < JavaCompileSpec > javaCompiler ) { this . javaCompiler = javaCompiler ; } public WorkResult execute ( final GroovyJavaJointCompileSpec spec ) { GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory ( ) ; ClassLoader compilerClassLoader = this . getClass ( ) . getClassLoader ( ) ; GroovySystemLoader compilerGroovyLoader = groovySystemLoaderFactory . forClassLoader ( compilerClassLoader ) ; CompilerConfiguration configuration = new CompilerConfiguration ( ) ; configuration . setVerbose ( spec . getGroovyCompileOptions ( ) . isVerbose ( ) ) ; configuration . setSourceEncoding ( spec . getGroovyCompileOptions ( ) . getEncoding ( ) ) ; configuration . setTargetBytecode ( spec . getTargetCompatibility ( ) ) ; configuration . setTargetDirectory ( spec . getDestinationDir ( ) ) ; canonicalizeValues ( spec . getGroovyCompileOptions ( ) . getOptimizationOptions ( ) ) ; if ( spec . getGroovyCompileOptions ( ) . getConfigurationScript ( ) ! = null ) { applyConfigurationScript ( spec . getGroovyCompileOptions ( ) . getConfigurationScript ( ) , configuration ) ; } try { configuration . setOptimizationOptions ( spec . getGroovyCompileOptions ( ) . getOptimizationOptions ( ) ) ; } catch ( NoSuchMethodError ignored ) { } Map < String , Object > jointCompilationOptions = new HashMap < String , Object > ( ) ; final File stubDir = spec . getGroovyCompileOptions ( ) . getStubDir ( ) ; stubDir . mkdirs ( ) ; jointCompilationOptions . put ( <str> , stubDir ) ; jointCompilationOptions . put ( <str> , spec . getGroovyCompileOptions ( ) . isKeepStubs ( ) ) ; configuration . setJointCompilationOptions ( jointCompilationOptions ) ; ClassLoader classPathLoader ; VersionNumber version = parseGroovyVersion ( ) ; if ( version . compareTo ( VersionNumber . parse ( <str> ) ) < <int> ) { classPathLoader = new GroovyCompileTransformingClassLoader ( getExtClassLoader ( ) , new DefaultClassPath ( spec . getClasspath ( ) ) ) ; } else { classPathLoader = new DefaultClassLoaderFactory ( ) . createIsolatedClassLoader ( new DefaultClassPath ( spec . getClasspath ( ) ) ) ; } GroovyClassLoader compileClasspathClassLoader = new GroovyClassLoader ( classPathLoader , null ) ; GroovySystemLoader compileClasspathLoader = groovySystemLoaderFactory . forClassLoader ( classPathLoader ) ; FilteringClassLoader groovyCompilerClassLoader = new FilteringClassLoader ( GroovyClassLoader . class . getClassLoader ( ) ) ; groovyCompilerClassLoader . allowPackage ( <str> ) ; groovyCompilerClassLoader . allowPackage ( <str> ) ; groovyCompilerClassLoader . disallowClass ( <str> ) ; groovyCompilerClassLoader . disallowPackage ( <str> ) ; final GroovyClassLoader astTransformClassLoader = new GroovyClassLoader ( groovyCompilerClassLoader , null ) ; for ( File file : spec . getClasspath ( ) ) { astTransformClassLoader . addClasspath ( file . getPath ( ) ) ; } JavaAwareCompilationUnit unit = new JavaAwareCompilationUnit ( configuration , compileClasspathClassLoader ) { @Override public GroovyClassLoader getTransformLoader ( ) { return astTransformClassLoader ; } } ; final boolean shouldProcessAnnotations = shouldProcessAnnotations ( astTransformClassLoader , spec ) ; if ( shouldProcessAnnotations ) { unit . addSources ( new File [ ] { new File ( <str> ) } ) ; } unit . addSources ( Iterables . toArray ( spec . getSource ( ) , File . class ) ) ; unit . setCompilerFactory ( new JavaCompilerFactory ( ) { public JavaCompiler createCompiler ( final CompilerConfiguration config ) { return new JavaCompiler ( ) { public void compile ( List < String > files , CompilationUnit cu ) { if ( shouldProcessAnnotations ) { spec . setSource ( spec . getSource ( ) . plus ( new SimpleFileCollection ( stubDir ) . getAsFileTree ( ) ) ) ; } else { FileCollection sourcepath = new SimpleFileCollection ( stubDir ) ; if ( spec . getCompileOptions ( ) . getSourcepath ( ) ! = null ) { sourcepath = spec . getCompileOptions ( ) . getSourcepath ( ) . plus ( sourcepath ) ; } spec . getCompileOptions ( ) . setSourcepath ( sourcepath ) ; } spec . setSource ( spec . getSource ( ) . filter ( new Spec < File > ( ) { public boolean isSatisfiedBy ( File file ) { return file . getName ( ) . endsWith ( <str> ) ; } } ) ) ; try { javaCompiler . execute ( spec ) ; } catch ( CompilationFailedException e ) { cu . getErrorCollector ( ) . addFatalError ( new SimpleMessage ( e . getMessage ( ) , cu ) ) ; } } } ; } } ) ; try { unit . compile ( ) ; } catch ( org . codehaus . groovy . control . CompilationFailedException e ) { System . err . println ( e . getMessage ( ) ) ; throw new CompilationFailedException ( ) ; } finally { compilerGroovyLoader . discardTypesFrom ( classPathLoader ) ; compilerGroovyLoader . discardTypesFrom ( astTransformClassLoader ) ; compileClasspathLoader . shutdown ( ) ; } return new SimpleWorkResult ( true ) ; } private boolean shouldProcessAnnotations ( ClassLoader classLoader , GroovyJavaJointCompileSpec spec ) { return ! isAnnotationProcessingDisabled ( spec ) & & ( isAnnotationProcessorOnClasspath ( classLoader ) | | isDefaultAnnotationProcessorDiscoveryOverridden ( spec ) ) ; } private boolean isAnnotationProcessingDisabled ( GroovyJavaJointCompileSpec spec ) { List < String > compilerArgs = spec . getCompileOptions ( ) . getCompilerArgs ( ) ; return ! spec . getGroovyCompileOptions ( ) . isJavaAnnotationProcessing ( ) | | compilerArgs . contains ( <str> ) ; } private boolean isAnnotationProcessorOnClasspath ( ClassLoader classLoader ) { try { Enumeration < URL > processorEntries = classLoader . getResources ( <str> ) ; return processorEntries . hasMoreElements ( ) ; } catch ( IOException e ) { throw new GradleException ( <str> , e ) ; } } private boolean isDefaultAnnotationProcessorDiscoveryOverridden ( GroovyJavaJointCompileSpec spec ) { List < String > compilerArgs = spec . getCompileOptions ( ) . getCompilerArgs ( ) ; return ! Collections . disjoint ( compilerArgs , Arrays . asList ( <str> , <str> ) ) ; } private void applyConfigurationScript ( File configScript , CompilerConfiguration configuration ) { VersionNumber version = parseGroovyVersion ( ) ; if ( version . compareTo ( VersionNumber . parse ( <str> ) ) < <int> ) { throw new GradleException ( <str> + version + <str> ) ; } Binding binding = new Binding ( ) ; binding . setVariable ( <str> , configuration ) ; CompilerConfiguration configuratorConfig = new CompilerConfiguration ( ) ; ImportCustomizer customizer = new ImportCustomizer ( ) ; customizer . addStaticStars ( <str> ) ; configuratorConfig . addCompilationCustomizers ( customizer ) ; GroovyShell shell = new GroovyShell ( binding , configuratorConfig ) ; try { shell . evaluate ( configScript ) ; } catch ( Exception e ) { throw new GradleException ( <str> + configScript . getAbsolutePath ( ) , e ) ; } } private VersionNumber parseGroovyVersion ( ) { String version ; try { version = GroovySystem . getVersion ( ) ; } catch ( NoSuchMethodError e ) { try { Class < ? > ih = Class . forName ( <str> ) ; Method getVersion = ih . getDeclaredMethod ( <str> ) ; version = ( String ) getVersion . invoke ( ih ) ; } catch ( Exception e1 ) { throw new GradleException ( <str> , e1 ) ; } } return VersionNumber . parse ( version ) ; } private void canonicalizeValues ( Map < String , Boolean > options ) { for ( String key : options . keySet ( ) ) { boolean value = options . get ( key ) ; options . put ( key , value ) ; } } private ClassLoader getExtClassLoader ( ) { return new DefaultClassLoaderFactory ( ) . getIsolatedSystemClassLoader ( ) ; } } 
