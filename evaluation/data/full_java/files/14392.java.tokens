package org . gradle . model . internal . manage . schema . extract ; import com . google . common . base . Equivalence ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . base . Predicate ; import com . google . common . collect . * ; import org . gradle . api . Action ; import org . gradle . api . Named ; import org . gradle . internal . reflect . MethodDescription ; import org . gradle . model . Managed ; import org . gradle . model . Unmanaged ; import org . gradle . model . internal . manage . schema . * ; import org . gradle . model . internal . type . ModelType ; import java . lang . reflect . * ; import java . util . * ; import static org . gradle . model . internal . manage . schema . extract . ModelSchemaUtils . * ; import static org . gradle . model . internal . manage . schema . extract . MethodType . * ; public class ManagedImplStructStrategy extends StructSchemaExtractionStrategySupport { protected ManagedImplStructStrategy ( ModelSchemaAspectExtractor aspectExtractor ) { super ( aspectExtractor ) ; } protected boolean isTarget ( ModelType < ? > type ) { return type . isAnnotationPresent ( Managed . class ) ; } @Override protected < R > void validateTypeHierarchy ( final ModelSchemaExtractionContext < R > extractionContext , ModelType < R > type ) { walkTypeHierarchy ( type . getConcreteClass ( ) , new ModelSchemaUtils . TypeVisitor < R > ( ) { @Override public void visitType ( Class < ? super R > type ) { if ( type . isAnnotationPresent ( Managed . class ) ) { validateManagedType ( extractionContext , type ) ; } } } ) ; } private void validateManagedType ( ModelSchemaExtractionContext < ? > extractionContext , Class < ? > typeClass ) { if ( ! typeClass . isInterface ( ) & & ! Modifier . isAbstract ( typeClass . getModifiers ( ) ) ) { throw new InvalidManagedModelElementTypeException ( extractionContext , <str> ) ; } if ( typeClass . getTypeParameters ( ) . length > <int> ) { throw new InvalidManagedModelElementTypeException ( extractionContext , <str> ) ; } Constructor < ? > customConstructor = findCustomConstructor ( typeClass ) ; if ( customConstructor ! = null ) { throw invalidMethod ( extractionContext , <str> , customConstructor ) ; } ensureNoInstanceScopedFields ( extractionContext , typeClass ) ; ensureNoProtectedOrPrivateMethods ( extractionContext , typeClass ) ; } private Constructor < ? > findCustomConstructor ( Class < ? > typeClass ) { Class < ? > superClass = typeClass . getSuperclass ( ) ; if ( superClass ! = null & & ! superClass . equals ( Object . class ) ) { Constructor < ? > customSuperConstructor = findCustomConstructor ( typeClass . getSuperclass ( ) ) ; if ( customSuperConstructor ! = null ) { return customSuperConstructor ; } } Constructor < ? > [ ] constructors = typeClass . getConstructors ( ) ; if ( constructors . length = = <int> | | ( constructors . length = = <int> & & constructors [ <int> ] . getParameterTypes ( ) . length = = <int> ) ) { return null ; } else { for ( Constructor < ? > constructor : constructors ) { if ( constructor . getParameterTypes ( ) . length > <int> ) { return constructor ; } } throw new RuntimeException ( String . format ( <str> , typeClass . getName ( ) ) ) ; } } private void ensureNoInstanceScopedFields ( ModelSchemaExtractionContext < ? > extractionContext , Class < ? > typeClass ) { Class < ? > superClass = typeClass . getSuperclass ( ) ; if ( superClass ! = null & & ! superClass . equals ( Object . class ) ) { ensureNoInstanceScopedFields ( extractionContext , superClass ) ; } List < Field > declaredFields = Arrays . asList ( typeClass . getDeclaredFields ( ) ) ; Iterable < Field > instanceScopedFields = Iterables . filter ( declaredFields , new Predicate < Field > ( ) { public boolean apply ( Field field ) { return ! Modifier . isStatic ( field . getModifiers ( ) ) & & ! field . getName ( ) . equals ( <str> ) ; } } ) ; ImmutableSortedSet < String > sortedDescriptions = ImmutableSortedSet . copyOf ( Iterables . transform ( instanceScopedFields , new Function < Field , String > ( ) { public String apply ( Field field ) { return field . toString ( ) ; } } ) ) ; if ( ! sortedDescriptions . isEmpty ( ) ) { throw new InvalidManagedModelElementTypeException ( extractionContext , <str> + Joiner . on ( <str> ) . join ( sortedDescriptions ) + <str> ) ; } } private void ensureNoProtectedOrPrivateMethods ( ModelSchemaExtractionContext < ? > extractionContext , Class < ? > typeClass ) { Class < ? > superClass = typeClass . getSuperclass ( ) ; if ( superClass ! = null & & ! superClass . equals ( Object . class ) ) { ensureNoProtectedOrPrivateMethods ( extractionContext , superClass ) ; } Iterable < Method > protectedAndPrivateMethods = Iterables . filter ( Arrays . asList ( typeClass . getDeclaredMethods ( ) ) , new Predicate < Method > ( ) { @Override public boolean apply ( Method method ) { int modifiers = method . getModifiers ( ) ; return ! method . isSynthetic ( ) & & ( Modifier . isProtected ( modifiers ) | | Modifier . isPrivate ( modifiers ) ) ; } } ) ; if ( ! Iterables . isEmpty ( protectedAndPrivateMethods ) ) { throw invalidMethods ( extractionContext , <str> , protectedAndPrivateMethods ) ; } } @Override protected void validateMethodDeclarationHierarchy ( ModelSchemaExtractionContext < ? > context , CandidateMethods candidateMethods ) { for ( String methodName : candidateMethods . methodNames ( ) ) { Collection < Equivalence . Wrapper < Method > > handledOverridden = Lists . newArrayList ( ) ; if ( ! MethodType . isPropertyMethodName ( methodName ) ) { Map < Equivalence . Wrapper < Method > , Collection < Method > > overridden = candidateMethods . overriddenMethodsNamed ( methodName ) ; if ( ! overridden . isEmpty ( ) ) { handleOverriddenMethods ( context , overridden . values ( ) ) ; handledOverridden . addAll ( overridden . keySet ( ) ) ; } } Map < Equivalence . Wrapper < Method > , Collection < Method > > overloaded = candidateMethods . overloadedMethodsNamed ( methodName , handledOverridden ) ; if ( ! overloaded . isEmpty ( ) ) { handleOverloadedMethods ( context , Iterables . concat ( overloaded . values ( ) ) ) ; } } } private void handleOverriddenMethods ( ModelSchemaExtractionContext < ? > extractionContext , Iterable < Collection < Method > > overriddenMethods ) { ImmutableSet . Builder < Method > rejectedBuilder = ImmutableSet . builder ( ) ; for ( Collection < Method > methods : overriddenMethods ) { if ( methods . size ( ) < = <int> | | isMethodDeclaredInManagedType ( Iterables . getLast ( methods ) ) ) { rejectedBuilder . addAll ( methods ) ; } } ImmutableSet < Method > rejectedOverrides = rejectedBuilder . build ( ) ; if ( ! rejectedOverrides . isEmpty ( ) & & isMethodDeclaredInManagedType ( rejectedOverrides ) ) { throw invalidMethods ( extractionContext , <str> , rejectedOverrides ) ; } } private void handleOverloadedMethods ( ModelSchemaExtractionContext < ? > extractionContext , Iterable < Method > overloadedMethods ) { if ( isMethodDeclaredInManagedType ( overloadedMethods ) ) { throw invalidMethods ( extractionContext , <str> , overloadedMethods ) ; } } @Override protected void handleNonPropertyMethod ( ModelSchemaExtractionContext < ? > context , Collection < Method > nonPropertyMethodsWithEqualSignature ) { Method mostSpecificMethod = findMostSpecificMethod ( nonPropertyMethodsWithEqualSignature ) ; if ( isMethodDeclaredInManagedType ( mostSpecificMethod ) ) { String methodName = mostSpecificMethod . getName ( ) ; if ( isGetterName ( methodName ) ) { if ( ! takesNoParameter ( mostSpecificMethod ) ) { throw invalidMethods ( context , <str> , nonPropertyMethodsWithEqualSignature ) ; } } if ( isSetterName ( methodName ) ) { if ( ! hasVoidReturnType ( mostSpecificMethod ) ) { throw invalidMethods ( context , <str> , nonPropertyMethodsWithEqualSignature ) ; } if ( ! takesSingleParameter ( mostSpecificMethod ) ) { throw invalidMethods ( context , <str> , nonPropertyMethodsWithEqualSignature ) ; } } if ( nonPropertyMethodsWithEqualSignature . size ( ) > <int> & & ! isMethodDeclaredInManagedType ( Iterables . getLast ( nonPropertyMethodsWithEqualSignature ) ) ) { return ; } throw invalidMethods ( context , <str> , nonPropertyMethodsWithEqualSignature ) ; } } @Override protected boolean selectProperty ( ModelSchemaExtractionContext < ? > context , ModelPropertyExtractionContext property ) { return true ; } @Override protected void handleInvalidGetter ( ModelSchemaExtractionContext < ? > extractionContext , Method getter , String message ) { if ( ModelSchemaUtils . isMethodDeclaredInManagedType ( getter ) ) { throw invalidMethod ( extractionContext , message , getter ) ; } } @Override protected void validateProperty ( ModelSchemaExtractionContext < ? > context , ModelPropertyExtractionContext property ) { PropertyAccessorExtractionContext mergedGetter = property . mergeGetters ( ) ; PropertyAccessorExtractionContext setter = property . getSetter ( ) ; if ( setter ! = null ) { Method mostSpecificSetter = setter . getMostSpecificDeclaration ( ) ; if ( mergedGetter = = null ) { throw invalidMethods ( context , <str> , setter . getDeclaringMethods ( ) ) ; } if ( setter . isDeclaredAsAbstract ( ) ) { if ( ! mergedGetter . isDeclaredAsAbstract ( ) ) { throw invalidMethod ( context , <str> , mostSpecificSetter ) ; } } if ( mostSpecificSetter . getName ( ) . equals ( <str> ) & & Named . class . isAssignableFrom ( context . getType ( ) . getRawClass ( ) ) ) { throw new InvalidManagedModelElementTypeException ( context , String . format ( <str> , Named . class . getName ( ) ) ) ; } if ( mergedGetter . isDeclaredInManagedType ( ) & & ! setter . isDeclaredInManagedType ( ) ) { throw invalidMethods ( context , <str> , mergedGetter . getDeclaringMethods ( ) ) ; } if ( ! mergedGetter . isDeclaredInManagedType ( ) & & setter . isDeclaredInManagedType ( ) ) { throw invalidMethods ( context , <str> , mergedGetter . getDeclaringMethods ( ) ) ; } if ( ! setter . isDeclaredInManagedType ( ) ) { return ; } if ( ! Modifier . isAbstract ( mostSpecificSetter . getModifiers ( ) ) ) { throw invalidMethod ( context , <str> , mostSpecificSetter ) ; } ModelType < ? > propertyType = ModelType . returnType ( mergedGetter . getMostSpecificDeclaration ( ) ) ; ModelType < ? > setterType = ModelType . paramType ( mostSpecificSetter , <int> ) ; if ( ! propertyType . equals ( setterType ) ) { String message = <str> + propertyType + <str> + setterType + <str> ; throw invalidMethod ( context , message , mostSpecificSetter ) ; } } } @Override protected ModelProperty . StateManagementType determineStateManagementType ( ModelSchemaExtractionContext < ? > extractionContext , PropertyAccessorExtractionContext getterContext ) { if ( getterContext . getMostSpecificDeclaration ( ) . getName ( ) . equals ( <str> ) & & Named . class . isAssignableFrom ( extractionContext . getType ( ) . getRawClass ( ) ) ) { return ModelProperty . StateManagementType . MANAGED ; } if ( getterContext . isDeclaredInManagedType ( ) ) { if ( getterContext . isDeclaredAsAbstract ( ) ) { return ModelProperty . StateManagementType . MANAGED ; } else { return ModelProperty . StateManagementType . UNMANAGED ; } } else { return ModelProperty . StateManagementType . UNMANAGED ; } } @Override protected < P > Action < ModelSchema < P > > createPropertyValidator ( final ModelSchemaExtractionContext < ? > parentContext , final ModelPropertyExtractionResult < P > propertyResult ) { return new Action < ModelSchema < P > > ( ) { @Override public void execute ( ModelSchema < P > propertySchema ) { ModelProperty < P > property = propertyResult . getProperty ( ) ; if ( ! property . getStateManagementType ( ) . equals ( ModelProperty . StateManagementType . MANAGED ) ) { return ; } if ( property . getName ( ) . equals ( <str> ) & & Named . class . isAssignableFrom ( parentContext . getType ( ) . getRawClass ( ) ) ) { return ; } boolean isAllowedPropertyTypeOfManagedType = propertySchema instanceof ManagedImplSchema | | propertySchema instanceof ScalarValueSchema ; boolean isDeclaredAsHavingUnmanagedType = propertyResult . getGetter ( ) . isAnnotationPresent ( Unmanaged . class ) ; if ( isAllowedPropertyTypeOfManagedType & & isDeclaredAsHavingUnmanagedType ) { throw new InvalidManagedModelElementTypeException ( parentContext , String . format ( <str> , property . getName ( ) , property . getType ( ) ) ) ; } if ( ! property . isWritable ( ) ) { if ( isDeclaredAsHavingUnmanagedType ) { throw new InvalidManagedModelElementTypeException ( parentContext , String . format ( <str> , property . getName ( ) ) ) ; } } if ( propertySchema instanceof CollectionSchema ) { if ( ! ( propertySchema instanceof ScalarCollectionSchema ) & & property . isWritable ( ) ) { throw new InvalidManagedModelElementTypeException ( parentContext , String . format ( <str> , property . getName ( ) , property . getType ( ) . toString ( ) ) ) ; } } } } ; } @Override protected < R > ManagedImplStructSchema < R > createSchema ( ModelSchemaExtractionContext < R > extractionContext , Iterable < ModelPropertyExtractionResult < ? > > propertyResults , Iterable < ModelSchemaAspect > aspects ) { ModelType < R > type = extractionContext . getType ( ) ; Iterable < ModelProperty < ? > > properties = Iterables . transform ( propertyResults , new Function < ModelPropertyExtractionResult < ? > , ModelProperty < ? > > ( ) { @Override public ModelProperty < ? > apply ( ModelPropertyExtractionResult < ? > propertyResult ) { return propertyResult . getProperty ( ) ; } } ) ; return new ManagedImplStructSchema < R > ( type , properties , aspects ) ; } private InvalidManagedModelElementTypeException invalidMethod ( ModelSchemaExtractionContext < ? > extractionContext , String message , Method method ) { return invalidMethod ( extractionContext , message , MethodDescription . of ( method ) ) ; } private InvalidManagedModelElementTypeException invalidMethod ( ModelSchemaExtractionContext < ? > extractionContext , String message , Constructor < ? > constructor ) { return invalidMethod ( extractionContext , message , MethodDescription . of ( constructor ) ) ; } private InvalidManagedModelElementTypeException invalidMethod ( ModelSchemaExtractionContext < ? > extractionContext , String message , MethodDescription methodDescription ) { return new InvalidManagedModelElementTypeException ( extractionContext , message + <str> + methodDescription . toString ( ) + <str> ) ; } private InvalidManagedModelElementTypeException invalidMethods ( ModelSchemaExtractionContext < ? > extractionContext , String message , Iterable < Method > methods ) { final ImmutableSortedSet < String > descriptions = ImmutableSortedSet . copyOf ( Iterables . transform ( methods , new Function < Method , String > ( ) { public String apply ( Method method ) { return MethodDescription . of ( method ) . toString ( ) ; } } ) ) ; return new InvalidManagedModelElementTypeException ( extractionContext , message + <str> + Joiner . on ( <str> ) . join ( descriptions ) + <str> ) ; } } 
