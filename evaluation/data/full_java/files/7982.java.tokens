package org . elasticsearch . common . util ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefArray ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . Counter ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; import static org . elasticsearch . common . util . CollectionUtils . eagerPartition ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class CollectionUtilsTests extends ESTestCase { public void testRotateEmpty ( ) { assertTrue ( CollectionUtils . rotate ( Collections . emptyList ( ) , randomInt ( ) ) . isEmpty ( ) ) ; } public void testRotate ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int k = <int> ; k < iters ; + + k ) { final int size = randomIntBetween ( <int> , <int> ) ; final int distance = randomInt ( ) ; List < Object > list = new ArrayList < > ( ) ; for ( int i = <int> ; i < size ; + + i ) { list . add ( new Object ( ) ) ; } final List < Object > rotated = CollectionUtils . rotate ( list , distance ) ; assertEquals ( rotated . size ( ) , list . size ( ) ) ; assertEquals ( rotated . size ( ) , list . size ( ) ) ; assertEquals ( new HashSet < > ( rotated ) , new HashSet < > ( list ) ) ; for ( int j = randomInt ( <int> ) ; j > = <int> ; - - j ) { assertEquals ( rotated , CollectionUtils . rotate ( list , distance ) ) ; } if ( distance ! = Integer . MIN_VALUE ) { assertEquals ( list , CollectionUtils . rotate ( CollectionUtils . rotate ( list , distance ) , - distance ) ) ; } } } public void testSortAndDedupByteRefArray ( ) { SortedSet < BytesRef > set = new TreeSet < > ( ) ; final int numValues = scaledRandomIntBetween ( <int> , <int> ) ; List < BytesRef > tmpList = new ArrayList < > ( ) ; BytesRefArray array = new BytesRefArray ( Counter . newCounter ( ) ) ; for ( int i = <int> ; i < numValues ; i + + ) { String s = randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) ; set . add ( new BytesRef ( s ) ) ; tmpList . add ( new BytesRef ( s ) ) ; array . append ( new BytesRef ( s ) ) ; } if ( randomBoolean ( ) ) { Collections . shuffle ( tmpList , random ( ) ) ; for ( BytesRef ref : tmpList ) { array . append ( ref ) ; } } int [ ] indices = new int [ array . size ( ) ] ; for ( int i = <int> ; i < indices . length ; i + + ) { indices [ i ] = i ; } int numUnique = CollectionUtils . sortAndDedup ( array , indices ) ; assertThat ( numUnique , equalTo ( set . size ( ) ) ) ; Iterator < BytesRef > iterator = set . iterator ( ) ; BytesRefBuilder spare = new BytesRefBuilder ( ) ; for ( int i = <int> ; i < numUnique ; i + + ) { assertThat ( iterator . hasNext ( ) , is ( true ) ) ; assertThat ( array . get ( spare , indices [ i ] ) , equalTo ( iterator . next ( ) ) ) ; } } public void testSortByteRefArray ( ) { List < BytesRef > values = new ArrayList < > ( ) ; final int numValues = scaledRandomIntBetween ( <int> , <int> ) ; BytesRefArray array = new BytesRefArray ( Counter . newCounter ( ) ) ; for ( int i = <int> ; i < numValues ; i + + ) { String s = randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) ; values . add ( new BytesRef ( s ) ) ; array . append ( new BytesRef ( s ) ) ; } if ( randomBoolean ( ) ) { Collections . shuffle ( values , random ( ) ) ; } int [ ] indices = new int [ array . size ( ) ] ; for ( int i = <int> ; i < indices . length ; i + + ) { indices [ i ] = i ; } CollectionUtils . sort ( array , indices ) ; Collections . sort ( values ) ; Iterator < BytesRef > iterator = values . iterator ( ) ; BytesRefBuilder spare = new BytesRefBuilder ( ) ; for ( int i = <int> ; i < values . size ( ) ; i + + ) { assertThat ( iterator . hasNext ( ) , is ( true ) ) ; assertThat ( array . get ( spare , indices [ i ] ) , equalTo ( iterator . next ( ) ) ) ; } } public void testEmptyPartition ( ) { assertEquals ( Collections . emptyList ( ) , eagerPartition ( Collections . emptyList ( ) , <int> ) ) ; } public void testSimplePartition ( ) { assertEquals ( Arrays . asList ( Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> , <int> ) , Arrays . asList ( <int> ) ) , eagerPartition ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , <int> ) ) ; } public void testSingletonPartition ( ) { assertEquals ( Arrays . asList ( Arrays . asList ( <int> ) , Arrays . asList ( <int> ) , Arrays . asList ( <int> ) , Arrays . asList ( <int> ) , Arrays . asList ( <int> ) ) , eagerPartition ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , <int> ) ) ; } public void testOversizedPartition ( ) { assertEquals ( Arrays . asList ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ) , eagerPartition ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , <int> ) ) ; } public void testPerfectPartition ( ) { assertEquals ( Arrays . asList ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> ) , Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ) , eagerPartition ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , <int> ) ) ; } } 
