package org . gradle . api . reporting . plugins ; import org . gradle . api . * ; import org . gradle . api . internal . ConventionMapping ; import org . gradle . api . internal . plugins . DslObject ; import org . gradle . api . plugins . ReportingBasePlugin ; import org . gradle . api . reporting . DirectoryReport ; import org . gradle . api . reporting . GenerateBuildDashboard ; import org . gradle . api . reporting . Reporting ; import org . gradle . api . reporting . ReportingExtension ; import java . util . concurrent . Callable ; @Incubating public class BuildDashboardPlugin implements Plugin < Project > { public static final String BUILD_DASHBOARD_TASK_NAME = <str> ; public void apply ( final Project project ) { project . getPluginManager ( ) . apply ( ReportingBasePlugin . class ) ; final GenerateBuildDashboard buildDashboardTask = project . getTasks ( ) . create ( BUILD_DASHBOARD_TASK_NAME , GenerateBuildDashboard . class ) ; buildDashboardTask . setDescription ( <str> ) ; buildDashboardTask . setGroup ( <str> ) ; DirectoryReport htmlReport = buildDashboardTask . getReports ( ) . getHtml ( ) ; ConventionMapping htmlReportConventionMapping = new DslObject ( htmlReport ) . getConventionMapping ( ) ; htmlReportConventionMapping . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return project . getExtensions ( ) . getByType ( ReportingExtension . class ) . file ( <str> ) ; } } ) ; Action < Task > captureReportingTasks = new Action < Task > ( ) { public void execute ( Task task ) { if ( ! ( task instanceof Reporting ) ) { return ; } Reporting reporting = ( Reporting ) task ; buildDashboardTask . aggregate ( reporting ) ; if ( ! task . equals ( buildDashboardTask ) ) { task . finalizedBy ( buildDashboardTask ) ; } } } ; for ( Project aProject : project . getAllprojects ( ) ) { aProject . getTasks ( ) . all ( captureReportingTasks ) ; } } } 
