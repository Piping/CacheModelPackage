package org . eclipse . debug . tests . viewer . model ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class LazyTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; IInternalTreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public LazyTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , true , true ) ; fShell . open ( ) ; } abstract protected IInternalTreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } private TestModel largeSubtreeModel ( int size ) { TestModel model = new TestModel ( ) ; TestElement [ ] children = new TestElement [ size ] ; for ( int i = <int> ; i < size ; i + + ) { children [ i ] = new TestElement ( model , <str> + i , new TestElement [ <int> ] ) ; } TestElement element = new TestElement ( model , <str> , children ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { element } ) ) ; return model ; } public void testExpandLargeSubTree ( ) throws InterruptedException { TestModel model = largeSubtreeModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , true ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestElement rootElement = model . getRootElement ( ) ; ModelDelta rootDelta = new ModelDelta ( rootElement , IModelDelta . NO_CHANGE ) ; ModelDelta expandDelta = model . getBaseDelta ( rootDelta ) ; TestElement expandElement = rootElement . getChildren ( ) [ <int> ] ; expandDelta . addNode ( expandElement , <int> , IModelDelta . EXPAND , expandElement . getChildren ( ) . length ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( true ) ; TreePath expandElementPath = model . findElement ( <str> ) ; fListener . addChildreCountUpdate ( expandElementPath ) ; fListener . addLabelUpdate ( expandElementPath ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . addChildreUpdate ( expandElementPath , i ) ; TreePath childPath = expandElementPath . createChildPath ( expandElement . getChildren ( ) [ i ] ) ; fListener . addLabelUpdate ( childPath ) ; fListener . addHasChildrenUpdate ( childPath ) ; } model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | MODEL_CHANGED_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testReplaceAndSelectInSubTreeTree ( ) throws InterruptedException { TestModel model = largeSubtreeModel ( <int> ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( ) ; fListener . setFailOnMultipleModelUpdateSequences ( true ) ; fListener . setFailOnRedundantUpdates ( false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; fListener . addLabelUpdate ( model . findElement ( <str> ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | LABEL_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fViewer . setSelection ( new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) } ) ) ; TestElement rootElement = model . getRootElement ( ) ; ModelDelta rootDelta = new ModelDelta ( rootElement , IModelDelta . NO_CHANGE ) ; ModelDelta baseDelta = model . getBaseDelta ( rootDelta ) ; TestElement _1Element = rootElement . getChildren ( ) [ <int> ] ; ModelDelta _1Delta = baseDelta . addNode ( _1Element , <int> , IModelDelta . NO_CHANGE , _1Element . getChildren ( ) . length ) ; TestElement _1_0_newElement = new TestElement ( model , <str> , new TestElement [ <int> ] ) ; TreePath _1ElementPath = model . findElement ( <str> ) ; model . replaceElementChild ( _1ElementPath , <int> , _1_0_newElement ) ; _1Delta . addNode ( _1_0_newElement , <int> , IModelDelta . SELECT ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( true ) ; TreePath _1_0_newElementPath = model . findElement ( <str> ) ; fListener . addLabelUpdate ( _1_0_newElementPath ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | LABEL_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertEquals ( ( ( IStructuredSelection ) fViewer . getSelection ( ) ) . getFirstElement ( ) , _1_0_newElement ) ; } public void testContentRefresh ( ) throws InterruptedException { TestModel model = largeSubtreeModel ( <int> ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , true ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; fViewer . reveal ( model . findElement ( <str> ) , <int> ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestElement rootElement = model . getRootElement ( ) ; ModelDelta rootDelta = new ModelDelta ( rootElement , IModelDelta . NO_CHANGE ) ; ModelDelta expandDelta = model . getBaseDelta ( rootDelta ) ; TestElement expandElement = rootElement . getChildren ( ) [ <int> ] ; expandDelta . addNode ( expandElement , <int> , IModelDelta . CONTENT , expandElement . getChildren ( ) . length ) ; for ( int repeatCount = <int> ; repeatCount < <int> ; repeatCount + + ) { fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( true ) ; TreePath refreshElementPath = model . findElement ( <str> ) ; fListener . addRedundantExceptionChildCount ( refreshElementPath ) ; fListener . addRedundantExceptionLabel ( refreshElementPath ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fListener . addHasChildrenUpdate ( refreshElementPath ) ; fListener . addChildreCountUpdate ( refreshElementPath ) ; fListener . addLabelUpdate ( refreshElementPath ) ; for ( int i = <int> ; i < <int> ; i + + ) { fListener . addChildreUpdate ( refreshElementPath , i ) ; TreePath childPath = refreshElementPath . createChildPath ( expandElement . getChildren ( ) [ i ] ) ; fListener . addLabelUpdate ( childPath ) ; fListener . addHasChildrenUpdate ( childPath ) ; } model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } } } 
