package io . netty . handler . codec . haproxy ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . LineBasedFrameDecoder ; import io . netty . handler . codec . ProtocolDetectionResult ; import io . netty . util . CharsetUtil ; import java . util . List ; public class HAProxyMessageDecoder extends ByteToMessageDecoder { private static final int V1_MAX_LENGTH = <int> ; private static final int V2_MAX_LENGTH = <int> + <int> ; private static final int V2_MIN_LENGTH = <int> + <int> ; private static final int V2_MAX_TLV = <int> - <int> ; private static final int DELIMITER_LENGTH = <int> ; private static final byte [ ] BINARY_PREFIX = { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; private static final byte [ ] TEXT_PREFIX = { ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , } ; private static final int BINARY_PREFIX_LENGTH = BINARY_PREFIX . length ; private static final ProtocolDetectionResult < HAProxyProtocolVersion > DETECTION_RESULT_V1 = ProtocolDetectionResult . detected ( HAProxyProtocolVersion . V1 ) ; private static final ProtocolDetectionResult < HAProxyProtocolVersion > DETECTION_RESULT_V2 = ProtocolDetectionResult . detected ( HAProxyProtocolVersion . V2 ) ; private boolean discarding ; private int discardedBytes ; private boolean finished ; private int version = - <int> ; private final int v2MaxHeaderSize ; public HAProxyMessageDecoder ( ) { v2MaxHeaderSize = V2_MAX_LENGTH ; } public HAProxyMessageDecoder ( int maxTlvSize ) { if ( maxTlvSize < <int> ) { v2MaxHeaderSize = V2_MIN_LENGTH ; } else if ( maxTlvSize > V2_MAX_TLV ) { v2MaxHeaderSize = V2_MAX_LENGTH ; } else { int calcMax = maxTlvSize + V2_MIN_LENGTH ; if ( calcMax > V2_MAX_LENGTH ) { v2MaxHeaderSize = V2_MAX_LENGTH ; } else { v2MaxHeaderSize = calcMax ; } } } private static int findVersion ( final ByteBuf buffer ) { final int n = buffer . readableBytes ( ) ; if ( n < <int> ) { return - <int> ; } int idx = buffer . readerIndex ( ) ; return match ( BINARY_PREFIX , buffer , idx ) ? buffer . getByte ( idx + BINARY_PREFIX_LENGTH ) : <int> ; } private static int findEndOfHeader ( final ByteBuf buffer ) { final int n = buffer . readableBytes ( ) ; if ( n < <int> ) { return - <int> ; } int offset = buffer . readerIndex ( ) + <int> ; int totalHeaderBytes = <int> + buffer . getUnsignedShort ( offset ) ; if ( n > = totalHeaderBytes ) { return totalHeaderBytes ; } else { return - <int> ; } } private static int findEndOfLine ( final ByteBuf buffer ) { final int n = buffer . writerIndex ( ) ; for ( int i = buffer . readerIndex ( ) ; i < n ; i + + ) { final byte b = buffer . getByte ( i ) ; if ( b = = <str> & & i < n - <int> & & buffer . getByte ( i + <int> ) = = <str> ) { return i ; } } return - <int> ; } @Override public boolean isSingleDecode ( ) { return true ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { super . channelRead ( ctx , msg ) ; if ( finished ) { ctx . pipeline ( ) . remove ( this ) ; } } @Override protected final void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( version = = - <int> ) { if ( ( version = findVersion ( in ) ) = = - <int> ) { return ; } } ByteBuf decoded ; if ( version = = <int> ) { decoded = decodeLine ( ctx , in ) ; } else { decoded = decodeStruct ( ctx , in ) ; } if ( decoded ! = null ) { finished = true ; try { if ( version = = <int> ) { out . add ( HAProxyMessage . decodeHeader ( decoded . toString ( CharsetUtil . US_ASCII ) ) ) ; } else { out . add ( HAProxyMessage . decodeHeader ( decoded ) ) ; } } catch ( HAProxyProtocolException e ) { fail ( ctx , null , e ) ; } } } private ByteBuf decodeStruct ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { final int eoh = findEndOfHeader ( buffer ) ; if ( ! discarding ) { if ( eoh > = <int> ) { final int length = eoh - buffer . readerIndex ( ) ; if ( length > v2MaxHeaderSize ) { buffer . readerIndex ( eoh ) ; failOverLimit ( ctx , length ) ; return null ; } return buffer . readSlice ( length ) ; } else { final int length = buffer . readableBytes ( ) ; if ( length > v2MaxHeaderSize ) { discardedBytes = length ; buffer . skipBytes ( length ) ; discarding = true ; failOverLimit ( ctx , <str> + discardedBytes ) ; } return null ; } } else { if ( eoh > = <int> ) { buffer . readerIndex ( eoh ) ; discardedBytes = <int> ; discarding = false ; } else { discardedBytes = buffer . readableBytes ( ) ; buffer . skipBytes ( discardedBytes ) ; } return null ; } } private ByteBuf decodeLine ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { final int eol = findEndOfLine ( buffer ) ; if ( ! discarding ) { if ( eol > = <int> ) { final int length = eol - buffer . readerIndex ( ) ; if ( length > V1_MAX_LENGTH ) { buffer . readerIndex ( eol + DELIMITER_LENGTH ) ; failOverLimit ( ctx , length ) ; return null ; } ByteBuf frame = buffer . readSlice ( length ) ; buffer . skipBytes ( DELIMITER_LENGTH ) ; return frame ; } else { final int length = buffer . readableBytes ( ) ; if ( length > V1_MAX_LENGTH ) { discardedBytes = length ; buffer . skipBytes ( length ) ; discarding = true ; failOverLimit ( ctx , <str> + discardedBytes ) ; } return null ; } } else { if ( eol > = <int> ) { final int delimLength = buffer . getByte ( eol ) = = <str> ? <int> : <int> ; buffer . readerIndex ( eol + delimLength ) ; discardedBytes = <int> ; discarding = false ; } else { discardedBytes = buffer . readableBytes ( ) ; buffer . skipBytes ( discardedBytes ) ; } return null ; } } private void failOverLimit ( final ChannelHandlerContext ctx , int length ) { failOverLimit ( ctx , String . valueOf ( length ) ) ; } private void failOverLimit ( final ChannelHandlerContext ctx , String length ) { int maxLength = version = = <int> ? V1_MAX_LENGTH : v2MaxHeaderSize ; fail ( ctx , <str> + length + <str> + maxLength + <str> , null ) ; } private void fail ( final ChannelHandlerContext ctx , String errMsg , Throwable t ) { finished = true ; ctx . close ( ) ; HAProxyProtocolException ppex ; if ( errMsg ! = null & & t ! = null ) { ppex = new HAProxyProtocolException ( errMsg , t ) ; } else if ( errMsg ! = null ) { ppex = new HAProxyProtocolException ( errMsg ) ; } else if ( t ! = null ) { ppex = new HAProxyProtocolException ( t ) ; } else { ppex = new HAProxyProtocolException ( ) ; } throw ppex ; } public static ProtocolDetectionResult < HAProxyProtocolVersion > detectProtocol ( ByteBuf buffer ) { if ( buffer . readableBytes ( ) < <int> ) { return ProtocolDetectionResult . needsMoreData ( ) ; } int idx = buffer . readerIndex ( ) ; if ( match ( BINARY_PREFIX , buffer , idx ) ) { return DETECTION_RESULT_V2 ; } if ( match ( TEXT_PREFIX , buffer , idx ) ) { return DETECTION_RESULT_V1 ; } return ProtocolDetectionResult . invalid ( ) ; } private static boolean match ( byte [ ] prefix , ByteBuf buffer , int idx ) { for ( int i = <int> ; i < prefix . length ; i + + ) { final byte b = buffer . getByte ( idx + i ) ; if ( b ! = prefix [ i ] ) { return false ; } } return true ; } } 
