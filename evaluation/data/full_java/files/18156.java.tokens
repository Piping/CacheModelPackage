package com . badlogic . gdx . maps . tiled ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . StringTokenizer ; import java . util . zip . GZIPInputStream ; import java . util . zip . InflaterInputStream ; import com . badlogic . gdx . assets . AssetLoaderParameters ; import com . badlogic . gdx . assets . loaders . AsynchronousAssetLoader ; import com . badlogic . gdx . assets . loaders . FileHandleResolver ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . maps . ImageResolver ; import com . badlogic . gdx . maps . MapLayer ; import com . badlogic . gdx . maps . MapObject ; import com . badlogic . gdx . maps . MapProperties ; import com . badlogic . gdx . maps . objects . EllipseMapObject ; import com . badlogic . gdx . maps . objects . PolygonMapObject ; import com . badlogic . gdx . maps . objects . PolylineMapObject ; import com . badlogic . gdx . maps . objects . RectangleMapObject ; import com . badlogic . gdx . maps . tiled . TiledMapTileLayer . Cell ; import com . badlogic . gdx . maps . tiled . objects . TiledMapTileMapObject ; import com . badlogic . gdx . math . Polygon ; import com . badlogic . gdx . math . Polyline ; import com . badlogic . gdx . utils . Base64Coder ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; import com . badlogic . gdx . utils . XmlReader ; import com . badlogic . gdx . utils . XmlReader . Element ; public abstract class BaseTmxMapLoader < P extends AssetLoaderParameters < TiledMap > > extends AsynchronousAssetLoader < TiledMap , P > { public static class Parameters extends AssetLoaderParameters < TiledMap > { public boolean generateMipMaps = false ; public TextureFilter textureMinFilter = TextureFilter . Nearest ; public TextureFilter textureMagFilter = TextureFilter . Nearest ; public boolean convertObjectToTileSpace = false ; public boolean flipY = true ; } protected static final int FLAG_FLIP_HORIZONTALLY = <hex> ; protected static final int FLAG_FLIP_VERTICALLY = <hex> ; protected static final int FLAG_FLIP_DIAGONALLY = <hex> ; protected static final int MASK_CLEAR = <hex> ; protected XmlReader xml = new XmlReader ( ) ; protected Element root ; protected boolean convertObjectToTileSpace ; protected boolean flipY = true ; protected int mapTileWidth ; protected int mapTileHeight ; protected int mapWidthInPixels ; protected int mapHeightInPixels ; protected TiledMap map ; public BaseTmxMapLoader ( FileHandleResolver resolver ) { super ( resolver ) ; } protected void loadTileLayer ( TiledMap map , Element element ) { if ( element . getName ( ) . equals ( <str> ) ) { int width = element . getIntAttribute ( <str> , <int> ) ; int height = element . getIntAttribute ( <str> , <int> ) ; int tileWidth = element . getParent ( ) . getIntAttribute ( <str> , <int> ) ; int tileHeight = element . getParent ( ) . getIntAttribute ( <str> , <int> ) ; TiledMapTileLayer layer = new TiledMapTileLayer ( width , height , tileWidth , tileHeight ) ; loadBasicLayerInfo ( layer , element ) ; int [ ] ids = getTileIds ( element , width , height ) ; TiledMapTileSets tilesets = map . getTileSets ( ) ; for ( int y = <int> ; y < height ; y + + ) { for ( int x = <int> ; x < width ; x + + ) { int id = ids [ y * width + x ] ; boolean flipHorizontally = ( ( id & FLAG_FLIP_HORIZONTALLY ) ! = <int> ) ; boolean flipVertically = ( ( id & FLAG_FLIP_VERTICALLY ) ! = <int> ) ; boolean flipDiagonally = ( ( id & FLAG_FLIP_DIAGONALLY ) ! = <int> ) ; TiledMapTile tile = tilesets . getTile ( id & ~ MASK_CLEAR ) ; if ( tile ! = null ) { Cell cell = createTileLayerCell ( flipHorizontally , flipVertically , flipDiagonally ) ; cell . setTile ( tile ) ; layer . setCell ( x , flipY ? height - <int> - y : y , cell ) ; } } } Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( layer . getProperties ( ) , properties ) ; } map . getLayers ( ) . add ( layer ) ; } } protected void loadObjectGroup ( TiledMap map , Element element ) { if ( element . getName ( ) . equals ( <str> ) ) { String name = element . getAttribute ( <str> , null ) ; MapLayer layer = new MapLayer ( ) ; layer . setName ( name ) ; Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( layer . getProperties ( ) , properties ) ; } for ( Element objectElement : element . getChildrenByName ( <str> ) ) { loadObject ( map , layer , objectElement ) ; } map . getLayers ( ) . add ( layer ) ; } } protected void loadImageLayer ( TiledMap map , Element element , FileHandle tmxFile , ImageResolver imageResolver ) { if ( element . getName ( ) . equals ( <str> ) ) { int x = Integer . parseInt ( element . getAttribute ( <str> , <str> ) ) ; int y = Integer . parseInt ( element . getAttribute ( <str> , <str> ) ) ; if ( flipY ) y = mapHeightInPixels - y ; TextureRegion texture = null ; Element image = element . getChildByName ( <str> ) ; if ( image ! = null ) { String source = image . getAttribute ( <str> ) ; FileHandle handle = getRelativeFileHandle ( tmxFile , source ) ; texture = imageResolver . getImage ( handle . path ( ) ) ; y - = texture . getRegionHeight ( ) ; } TiledMapImageLayer layer = new TiledMapImageLayer ( texture , x , y ) ; loadBasicLayerInfo ( layer , element ) ; Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( layer . getProperties ( ) , properties ) ; } map . getLayers ( ) . add ( layer ) ; } } protected void loadBasicLayerInfo ( MapLayer layer , Element element ) { String name = element . getAttribute ( <str> , null ) ; float opacity = Float . parseFloat ( element . getAttribute ( <str> , <str> ) ) ; boolean visible = element . getIntAttribute ( <str> , <int> ) = = <int> ; layer . setName ( name ) ; layer . setOpacity ( opacity ) ; layer . setVisible ( visible ) ; } protected void loadObject ( TiledMap map , MapLayer layer , Element element ) { if ( element . getName ( ) . equals ( <str> ) ) { MapObject object = null ; float scaleX = convertObjectToTileSpace ? <float> / mapTileWidth : <float> ; float scaleY = convertObjectToTileSpace ? <float> / mapTileHeight : <float> ; float x = element . getFloatAttribute ( <str> , <int> ) * scaleX ; float y = ( flipY ? ( mapHeightInPixels - element . getFloatAttribute ( <str> , <int> ) ) : element . getFloatAttribute ( <str> , <int> ) ) * scaleY ; float width = element . getFloatAttribute ( <str> , <int> ) * scaleX ; float height = element . getFloatAttribute ( <str> , <int> ) * scaleY ; if ( element . getChildCount ( ) > <int> ) { Element child = null ; if ( ( child = element . getChildByName ( <str> ) ) ! = null ) { String [ ] points = child . getAttribute ( <str> ) . split ( <str> ) ; float [ ] vertices = new float [ points . length * <int> ] ; for ( int i = <int> ; i < points . length ; i + + ) { String [ ] point = points [ i ] . split ( <str> ) ; vertices [ i * <int> ] = Float . parseFloat ( point [ <int> ] ) * scaleX ; vertices [ i * <int> + <int> ] = Float . parseFloat ( point [ <int> ] ) * scaleY * ( flipY ? - <int> : <int> ) ; } Polygon polygon = new Polygon ( vertices ) ; polygon . setPosition ( x , y ) ; object = new PolygonMapObject ( polygon ) ; } else if ( ( child = element . getChildByName ( <str> ) ) ! = null ) { String [ ] points = child . getAttribute ( <str> ) . split ( <str> ) ; float [ ] vertices = new float [ points . length * <int> ] ; for ( int i = <int> ; i < points . length ; i + + ) { String [ ] point = points [ i ] . split ( <str> ) ; vertices [ i * <int> ] = Float . parseFloat ( point [ <int> ] ) * scaleX ; vertices [ i * <int> + <int> ] = Float . parseFloat ( point [ <int> ] ) * scaleY * ( flipY ? - <int> : <int> ) ; } Polyline polyline = new Polyline ( vertices ) ; polyline . setPosition ( x , y ) ; object = new PolylineMapObject ( polyline ) ; } else if ( ( child = element . getChildByName ( <str> ) ) ! = null ) { object = new EllipseMapObject ( x , flipY ? y - height : y , width , height ) ; } } if ( object = = null ) { String gid = null ; if ( ( gid = element . getAttribute ( <str> , null ) ) ! = null ) { int id = ( int ) Long . parseLong ( gid ) ; boolean flipHorizontally = ( ( id & FLAG_FLIP_HORIZONTALLY ) ! = <int> ) ; boolean flipVertically = ( ( id & FLAG_FLIP_VERTICALLY ) ! = <int> ) ; TiledMapTile tile = map . getTileSets ( ) . getTile ( id & ~ MASK_CLEAR ) ; TiledMapTileMapObject tiledMapTileMapObject = new TiledMapTileMapObject ( tile , flipHorizontally , flipVertically ) ; TextureRegion textureRegion = tiledMapTileMapObject . getTextureRegion ( ) ; tiledMapTileMapObject . getProperties ( ) . put ( <str> , id ) ; tiledMapTileMapObject . setX ( x ) ; tiledMapTileMapObject . setY ( flipY ? y : y - height ) ; float objectWidth = element . getFloatAttribute ( <str> , textureRegion . getRegionWidth ( ) ) ; float objectHeight = element . getFloatAttribute ( <str> , textureRegion . getRegionHeight ( ) ) ; tiledMapTileMapObject . setScaleX ( scaleX * ( objectWidth / textureRegion . getRegionWidth ( ) ) ) ; tiledMapTileMapObject . setScaleY ( scaleY * ( objectHeight / textureRegion . getRegionHeight ( ) ) ) ; tiledMapTileMapObject . setRotation ( element . getFloatAttribute ( <str> , <int> ) ) ; object = tiledMapTileMapObject ; } else { object = new RectangleMapObject ( x , flipY ? y - height : y , width , height ) ; } } object . setName ( element . getAttribute ( <str> , null ) ) ; String rotation = element . getAttribute ( <str> , null ) ; if ( rotation ! = null ) { object . getProperties ( ) . put ( <str> , Float . parseFloat ( rotation ) ) ; } String type = element . getAttribute ( <str> , null ) ; if ( type ! = null ) { object . getProperties ( ) . put ( <str> , type ) ; } int id = element . getIntAttribute ( <str> , <int> ) ; if ( id ! = <int> ) { object . getProperties ( ) . put ( <str> , id ) ; } object . getProperties ( ) . put ( <str> , x * scaleX ) ; object . getProperties ( ) . put ( <str> , ( flipY ? y - height : y ) * scaleY ) ; object . getProperties ( ) . put ( <str> , width ) ; object . getProperties ( ) . put ( <str> , height ) ; object . setVisible ( element . getIntAttribute ( <str> , <int> ) = = <int> ) ; Element properties = element . getChildByName ( <str> ) ; if ( properties ! = null ) { loadProperties ( object . getProperties ( ) , properties ) ; } layer . getObjects ( ) . add ( object ) ; } } protected void loadProperties ( MapProperties properties , Element element ) { if ( element = = null ) return ; if ( element . getName ( ) . equals ( <str> ) ) { for ( Element property : element . getChildrenByName ( <str> ) ) { String name = property . getAttribute ( <str> , null ) ; String value = property . getAttribute ( <str> , null ) ; if ( value = = null ) { value = property . getText ( ) ; } properties . put ( name , value ) ; } } } protected Cell createTileLayerCell ( boolean flipHorizontally , boolean flipVertically , boolean flipDiagonally ) { Cell cell = new Cell ( ) ; if ( flipDiagonally ) { if ( flipHorizontally & & flipVertically ) { cell . setFlipHorizontally ( true ) ; cell . setRotation ( Cell . ROTATE_270 ) ; } else if ( flipHorizontally ) { cell . setRotation ( Cell . ROTATE_270 ) ; } else if ( flipVertically ) { cell . setRotation ( Cell . ROTATE_90 ) ; } else { cell . setFlipVertically ( true ) ; cell . setRotation ( Cell . ROTATE_270 ) ; } } else { cell . setFlipHorizontally ( flipHorizontally ) ; cell . setFlipVertically ( flipVertically ) ; } return cell ; } static public int [ ] getTileIds ( Element element , int width , int height ) { Element data = element . getChildByName ( <str> ) ; String encoding = data . getAttribute ( <str> , null ) ; if ( encoding = = null ) { throw new GdxRuntimeException ( <str> ) ; } int [ ] ids = new int [ width * height ] ; if ( encoding . equals ( <str> ) ) { String [ ] array = data . getText ( ) . split ( <str> ) ; for ( int i = <int> ; i < array . length ; i + + ) ids [ i ] = ( int ) Long . parseLong ( array [ i ] . trim ( ) ) ; } else { if ( true ) if ( encoding . equals ( <str> ) ) { InputStream is = null ; try { String compression = data . getAttribute ( <str> , null ) ; byte [ ] bytes = Base64Coder . decode ( data . getText ( ) ) ; if ( compression = = null ) is = new ByteArrayInputStream ( bytes ) ; else if ( compression . equals ( <str> ) ) is = new BufferedInputStream ( new GZIPInputStream ( new ByteArrayInputStream ( bytes ) , bytes . length ) ) ; else if ( compression . equals ( <str> ) ) is = new BufferedInputStream ( new InflaterInputStream ( new ByteArrayInputStream ( bytes ) ) ) ; else throw new GdxRuntimeException ( <str> + compression + <str> ) ; byte [ ] temp = new byte [ <int> ] ; for ( int y = <int> ; y < height ; y + + ) { for ( int x = <int> ; x < width ; x + + ) { int read = is . read ( temp ) ; while ( read < temp . length ) { int curr = is . read ( temp , read , temp . length - read ) ; if ( curr = = - <int> ) break ; read + = curr ; } if ( read ! = temp . length ) throw new GdxRuntimeException ( <str> ) ; ids [ y * width + x ] = unsignedByteToInt ( temp [ <int> ] ) | unsignedByteToInt ( temp [ <int> ] ) < < <int> | unsignedByteToInt ( temp [ <int> ] ) < < <int> | unsignedByteToInt ( temp [ <int> ] ) < < <int> ; } } } catch ( IOException e ) { throw new GdxRuntimeException ( <str> + e . getMessage ( ) ) ; } finally { StreamUtils . closeQuietly ( is ) ; } } else { throw new GdxRuntimeException ( <str> + encoding + <str> ) ; } } return ids ; } protected static int unsignedByteToInt ( byte b ) { return b & <hex> ; } protected static FileHandle getRelativeFileHandle ( FileHandle file , String path ) { StringTokenizer tokenizer = new StringTokenizer ( path , <str> ) ; FileHandle result = file . parent ( ) ; while ( tokenizer . hasMoreElements ( ) ) { String token = tokenizer . nextToken ( ) ; if ( token . equals ( <str> ) ) result = result . parent ( ) ; else { result = result . child ( token ) ; } } return result ; } } 
