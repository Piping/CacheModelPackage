package com . badlogic . gdx . input ; import java . io . DataInputStream ; import java . io . IOException ; import java . net . InetAddress ; import java . net . ServerSocket ; import java . net . Socket ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . Input . TextInputListener ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntSet ; public class RemoteInput implements Runnable , Input { public interface RemoteInputListener { void onConnected ( ) ; void onDisconnected ( ) ; } class KeyEvent { static final int KEY_DOWN = <int> ; static final int KEY_UP = <int> ; static final int KEY_TYPED = <int> ; long timeStamp ; int type ; int keyCode ; char keyChar ; } class TouchEvent { static final int TOUCH_DOWN = <int> ; static final int TOUCH_UP = <int> ; static final int TOUCH_DRAGGED = <int> ; long timeStamp ; int type ; int x ; int y ; int pointer ; } class EventTrigger implements Runnable { TouchEvent touchEvent ; KeyEvent keyEvent ; public EventTrigger ( TouchEvent touchEvent , KeyEvent keyEvent ) { this . touchEvent = touchEvent ; this . keyEvent = keyEvent ; } @Override public void run ( ) { justTouched = false ; if ( keyJustPressed ) { keyJustPressed = false ; for ( int i = <int> ; i < justPressedKeys . length ; i + + ) { justPressedKeys [ i ] = false ; } } if ( processor ! = null ) { if ( touchEvent ! = null ) { touchX [ touchEvent . pointer ] = touchEvent . x ; touchY [ touchEvent . pointer ] = touchEvent . y ; switch ( touchEvent . type ) { case TouchEvent . TOUCH_DOWN : processor . touchDown ( touchEvent . x , touchEvent . y , touchEvent . pointer , Input . Buttons . LEFT ) ; isTouched [ touchEvent . pointer ] = true ; justTouched = true ; break ; case TouchEvent . TOUCH_UP : processor . touchUp ( touchEvent . x , touchEvent . y , touchEvent . pointer , Input . Buttons . LEFT ) ; isTouched [ touchEvent . pointer ] = false ; break ; case TouchEvent . TOUCH_DRAGGED : processor . touchDragged ( touchEvent . x , touchEvent . y , touchEvent . pointer ) ; break ; } } if ( keyEvent ! = null ) { switch ( keyEvent . type ) { case KeyEvent . KEY_DOWN : processor . keyDown ( keyEvent . keyCode ) ; if ( ! keys [ keyEvent . keyCode ] ) { keyCount + + ; keys [ keyEvent . keyCode ] = true ; } keyJustPressed = true ; justPressedKeys [ keyEvent . keyCode ] = true ; break ; case KeyEvent . KEY_UP : processor . keyUp ( keyEvent . keyCode ) ; if ( keys [ keyEvent . keyCode ] ) { keyCount - - ; keys [ keyEvent . keyCode ] = false ; } break ; case KeyEvent . KEY_TYPED : processor . keyTyped ( keyEvent . keyChar ) ; break ; } } } else { if ( touchEvent ! = null ) { touchX [ touchEvent . pointer ] = touchEvent . x ; touchY [ touchEvent . pointer ] = touchEvent . y ; if ( touchEvent . type = = TouchEvent . TOUCH_DOWN ) { isTouched [ touchEvent . pointer ] = true ; justTouched = true ; } if ( touchEvent . type = = TouchEvent . TOUCH_UP ) { isTouched [ touchEvent . pointer ] = false ; } } if ( keyEvent ! = null ) { if ( keyEvent . type = = KeyEvent . KEY_DOWN ) { if ( ! keys [ keyEvent . keyCode ] ) { keyCount + + ; keys [ keyEvent . keyCode ] = true ; } keyJustPressed = true ; justPressedKeys [ keyEvent . keyCode ] = true ; } if ( keyEvent . type = = KeyEvent . KEY_UP ) { if ( keys [ keyEvent . keyCode ] ) { keyCount - - ; keys [ keyEvent . keyCode ] = false ; } } } } } } public static int DEFAULT_PORT = <int> ; private ServerSocket serverSocket ; private float [ ] accel = new float [ <int> ] ; private float [ ] compass = new float [ <int> ] ; private boolean multiTouch = false ; private float remoteWidth = <int> ; private float remoteHeight = <int> ; private boolean connected = false ; private RemoteInputListener listener ; int keyCount = <int> ; boolean [ ] keys = new boolean [ <int> ] ; boolean keyJustPressed = false ; boolean [ ] justPressedKeys = new boolean [ <int> ] ; int [ ] touchX = new int [ <int> ] ; int [ ] touchY = new int [ <int> ] ; boolean isTouched [ ] = new boolean [ <int> ] ; boolean justTouched = false ; InputProcessor processor = null ; private final int port ; public final String [ ] ips ; public RemoteInput ( ) { this ( DEFAULT_PORT ) ; } public RemoteInput ( RemoteInputListener listener ) { this ( DEFAULT_PORT , listener ) ; } public RemoteInput ( int port ) { this ( port , null ) ; } public RemoteInput ( int port , RemoteInputListener listener ) { this . listener = listener ; try { this . port = port ; serverSocket = new ServerSocket ( port ) ; Thread thread = new Thread ( this ) ; thread . setDaemon ( true ) ; thread . start ( ) ; InetAddress [ ] allByName = InetAddress . getAllByName ( InetAddress . getLocalHost ( ) . getHostName ( ) ) ; ips = new String [ allByName . length ] ; for ( int i = <int> ; i < allByName . length ; i + + ) { ips [ i ] = allByName [ i ] . getHostAddress ( ) ; } } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + port + <str> , e ) ; } } @Override public void run ( ) { while ( true ) { try { connected = false ; if ( listener ! = null ) listener . onDisconnected ( ) ; System . out . println ( <str> + port ) ; Socket socket = null ; socket = serverSocket . accept ( ) ; socket . setTcpNoDelay ( true ) ; socket . setSoTimeout ( <int> ) ; connected = true ; if ( listener ! = null ) listener . onConnected ( ) ; DataInputStream in = new DataInputStream ( socket . getInputStream ( ) ) ; multiTouch = in . readBoolean ( ) ; while ( true ) { int event = in . readInt ( ) ; KeyEvent keyEvent = null ; TouchEvent touchEvent = null ; switch ( event ) { case RemoteSender . ACCEL : accel [ <int> ] = in . readFloat ( ) ; accel [ <int> ] = in . readFloat ( ) ; accel [ <int> ] = in . readFloat ( ) ; break ; case RemoteSender . COMPASS : compass [ <int> ] = in . readFloat ( ) ; compass [ <int> ] = in . readFloat ( ) ; compass [ <int> ] = in . readFloat ( ) ; break ; case RemoteSender . SIZE : remoteWidth = in . readFloat ( ) ; remoteHeight = in . readFloat ( ) ; break ; case RemoteSender . KEY_DOWN : keyEvent = new KeyEvent ( ) ; keyEvent . keyCode = in . readInt ( ) ; keyEvent . type = KeyEvent . KEY_DOWN ; break ; case RemoteSender . KEY_UP : keyEvent = new KeyEvent ( ) ; keyEvent . keyCode = in . readInt ( ) ; keyEvent . type = KeyEvent . KEY_UP ; break ; case RemoteSender . KEY_TYPED : keyEvent = new KeyEvent ( ) ; keyEvent . keyChar = in . readChar ( ) ; keyEvent . type = KeyEvent . KEY_TYPED ; break ; case RemoteSender . TOUCH_DOWN : touchEvent = new TouchEvent ( ) ; touchEvent . x = ( int ) ( ( in . readInt ( ) / remoteWidth ) * Gdx . graphics . getWidth ( ) ) ; touchEvent . y = ( int ) ( ( in . readInt ( ) / remoteHeight ) * Gdx . graphics . getHeight ( ) ) ; touchEvent . pointer = in . readInt ( ) ; touchEvent . type = TouchEvent . TOUCH_DOWN ; break ; case RemoteSender . TOUCH_UP : touchEvent = new TouchEvent ( ) ; touchEvent . x = ( int ) ( ( in . readInt ( ) / remoteWidth ) * Gdx . graphics . getWidth ( ) ) ; touchEvent . y = ( int ) ( ( in . readInt ( ) / remoteHeight ) * Gdx . graphics . getHeight ( ) ) ; touchEvent . pointer = in . readInt ( ) ; touchEvent . type = TouchEvent . TOUCH_UP ; break ; case RemoteSender . TOUCH_DRAGGED : touchEvent = new TouchEvent ( ) ; touchEvent . x = ( int ) ( ( in . readInt ( ) / remoteWidth ) * Gdx . graphics . getWidth ( ) ) ; touchEvent . y = ( int ) ( ( in . readInt ( ) / remoteHeight ) * Gdx . graphics . getHeight ( ) ) ; touchEvent . pointer = in . readInt ( ) ; touchEvent . type = TouchEvent . TOUCH_DRAGGED ; break ; } Gdx . app . postRunnable ( new EventTrigger ( touchEvent , keyEvent ) ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } public boolean isConnected ( ) { return connected ; } @Override public float getAccelerometerX ( ) { return accel [ <int> ] ; } @Override public float getAccelerometerY ( ) { return accel [ <int> ] ; } @Override public float getAccelerometerZ ( ) { return accel [ <int> ] ; } @Override public int getX ( ) { return touchX [ <int> ] ; } @Override public int getX ( int pointer ) { return touchX [ pointer ] ; } @Override public int getY ( ) { return touchY [ <int> ] ; } @Override public int getY ( int pointer ) { return touchY [ pointer ] ; } @Override public boolean isTouched ( ) { return isTouched [ <int> ] ; } @Override public boolean justTouched ( ) { return justTouched ; } @Override public boolean isTouched ( int pointer ) { return isTouched [ pointer ] ; } @Override public boolean isButtonPressed ( int button ) { if ( button ! = Buttons . LEFT ) return false ; for ( int i = <int> ; i < isTouched . length ; i + + ) if ( isTouched [ i ] ) return true ; return false ; } @Override public boolean isKeyPressed ( int key ) { if ( key = = Input . Keys . ANY_KEY ) { return keyCount > <int> ; } if ( key < <int> | | key > <int> ) { return false ; } return keys [ key ] ; } @Override public boolean isKeyJustPressed ( int key ) { if ( key = = Input . Keys . ANY_KEY ) { return keyJustPressed ; } if ( key < <int> | | key > <int> ) { return false ; } return justPressedKeys [ key ] ; } @Override public void getTextInput ( TextInputListener listener , String title , String text , String hint ) { Gdx . app . getInput ( ) . getTextInput ( listener , title , text , hint ) ; } @Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @Override public void vibrate ( int milliseconds ) { } @Override public void vibrate ( long [ ] pattern , int repeat ) { } @Override public void cancelVibrate ( ) { } @Override public float getAzimuth ( ) { return compass [ <int> ] ; } @Override public float getPitch ( ) { return compass [ <int> ] ; } @Override public float getRoll ( ) { return compass [ <int> ] ; } @Override public void setCatchBackKey ( boolean catchBack ) { } @Override public boolean isCatchBackKey ( ) { return false ; } @Override public void setCatchMenuKey ( boolean catchMenu ) { } @Override public boolean isCatchMenuKey ( ) { return false ; } @Override public void setInputProcessor ( InputProcessor processor ) { this . processor = processor ; } @Override public InputProcessor getInputProcessor ( ) { return this . processor ; } public String [ ] getIPs ( ) { return ips ; } @Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { if ( peripheral = = Peripheral . Accelerometer ) return true ; if ( peripheral = = Peripheral . Compass ) return true ; if ( peripheral = = Peripheral . MultitouchScreen ) return multiTouch ; return false ; } @Override public int getRotation ( ) { return <int> ; } @Override public Orientation getNativeOrientation ( ) { return Orientation . Landscape ; } @Override public void setCursorCatched ( boolean catched ) { } @Override public boolean isCursorCatched ( ) { return false ; } @Override public int getDeltaX ( ) { return <int> ; } @Override public int getDeltaX ( int pointer ) { return <int> ; } @Override public int getDeltaY ( ) { return <int> ; } @Override public int getDeltaY ( int pointer ) { return <int> ; } @Override public void setCursorPosition ( int x , int y ) { } @Override public long getCurrentEventTime ( ) { return <int> ; } @Override public void getRotationMatrix ( float [ ] matrix ) { } } 
