package org . elasticsearch . snapshots ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . cluster . tasks . PendingClusterTasksResponse ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . cluster . service . PendingClusterTask ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . repositories . RepositoriesService ; import org . elasticsearch . snapshots . mockstore . MockRepository ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . nio . file . FileVisitResult ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . SimpleFileVisitor ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . Predicate ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; public abstract class AbstractSnapshotIntegTestCase extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockRepository . Plugin . class ) ; } public static long getFailureCount ( String repository ) { long failureCount = <int> ; for ( RepositoriesService repositoriesService : internalCluster ( ) . getDataNodeInstances ( RepositoriesService . class ) ) { MockRepository mockRepository = ( MockRepository ) repositoriesService . repository ( repository ) ; failureCount + = mockRepository . getFailureCount ( ) ; } return failureCount ; } public static int numberOfFiles ( Path dir ) throws IOException { final AtomicInteger count = new AtomicInteger ( ) ; Files . walkFileTree ( dir , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { count . incrementAndGet ( ) ; return FileVisitResult . CONTINUE ; } } ) ; return count . get ( ) ; } public static void stopNode ( final String node ) throws IOException { internalCluster ( ) . stopRandomNode ( settings - > settings . get ( <str> ) . equals ( node ) ) ; } public void waitForBlock ( String node , String repository , TimeValue timeout ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; RepositoriesService repositoriesService = internalCluster ( ) . getInstance ( RepositoriesService . class , node ) ; MockRepository mockRepository = ( MockRepository ) repositoriesService . repository ( repository ) ; while ( System . currentTimeMillis ( ) - start < timeout . millis ( ) ) { if ( mockRepository . blocked ( ) ) { return ; } Thread . sleep ( <int> ) ; } fail ( <str> ) ; } public SnapshotInfo waitForCompletion ( String repository , String snapshot , TimeValue timeout ) throws InterruptedException { long start = System . currentTimeMillis ( ) ; SnapshotId snapshotId = new SnapshotId ( repository , snapshot ) ; while ( System . currentTimeMillis ( ) - start < timeout . millis ( ) ) { List < SnapshotInfo > snapshotInfos = client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( repository ) . setSnapshots ( snapshot ) . get ( ) . getSnapshots ( ) ; assertThat ( snapshotInfos . size ( ) , equalTo ( <int> ) ) ; if ( snapshotInfos . get ( <int> ) . state ( ) . completed ( ) ) { ClusterStateResponse stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; SnapshotsInProgress snapshotsInProgress = stateResponse . getState ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshotsInProgress = = null | | snapshotsInProgress . snapshot ( snapshotId ) = = null ) { return snapshotInfos . get ( <int> ) ; } } Thread . sleep ( <int> ) ; } fail ( <str> ) ; return null ; } public static String blockNodeWithIndex ( String index ) { for ( String node : internalCluster ( ) . nodesInclude ( <str> ) ) { ( ( MockRepository ) internalCluster ( ) . getInstance ( RepositoriesService . class , node ) . repository ( <str> ) ) . blockOnDataFiles ( true ) ; return node ; } fail ( <str> + index + <str> ) ; return null ; } public static void unblockNode ( String node ) { ( ( MockRepository ) internalCluster ( ) . getInstance ( RepositoriesService . class , node ) . repository ( <str> ) ) . unblock ( ) ; } protected void assertBusyPendingTasks ( final String taskPrefix , final int expectedCount ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { PendingClusterTasksResponse tasks = client ( ) . admin ( ) . cluster ( ) . preparePendingClusterTasks ( ) . get ( ) ; int count = <int> ; for ( PendingClusterTask task : tasks ) { if ( task . getSource ( ) . toString ( ) . startsWith ( taskPrefix ) ) { count + + ; } } assertThat ( count , greaterThanOrEqualTo ( expectedCount ) ) ; } } , <int> , TimeUnit . MINUTES ) ; } protected class BlockingClusterStateListener implements ClusterStateListener { private final Predicate < ClusterChangedEvent > blockOn ; private final Predicate < ClusterChangedEvent > countOn ; private final ClusterService clusterService ; private final CountDownLatch latch ; private final Priority passThroughPriority ; private int count ; private boolean timedOut ; private final TimeValue timeout ; private long stopWaitingAt = - <int> ; public BlockingClusterStateListener ( ClusterService clusterService , String blockOn , String countOn , Priority passThroughPriority ) { this ( clusterService , blockOn , countOn , passThroughPriority , TimeValue . timeValueMinutes ( <int> ) ) ; } public BlockingClusterStateListener ( ClusterService clusterService , final String blockOn , final String countOn , Priority passThroughPriority , TimeValue timeout ) { this . clusterService = clusterService ; this . blockOn = clusterChangedEvent - > clusterChangedEvent . source ( ) . startsWith ( blockOn ) ; this . countOn = clusterChangedEvent - > clusterChangedEvent . source ( ) . startsWith ( countOn ) ; this . latch = new CountDownLatch ( <int> ) ; this . passThroughPriority = passThroughPriority ; this . timeout = timeout ; } public void unblock ( ) { latch . countDown ( ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( blockOn . test ( event ) ) { logger . info ( <str> , event . source ( ) ) ; assert stopWaitingAt < <int> ; stopWaitingAt = System . currentTimeMillis ( ) + timeout . getMillis ( ) ; addBlock ( ) ; } if ( countOn . test ( event ) ) { count + + ; } } private void addBlock ( ) { clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( passThroughPriority ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { while ( System . currentTimeMillis ( ) < stopWaitingAt ) { for ( PendingClusterTask task : clusterService . pendingTasks ( ) ) { if ( task . getSource ( ) . string ( ) . equals ( <str> ) = = false & & passThroughPriority . sameOrAfter ( task . getPriority ( ) ) ) { logger . info ( <str> , task . getSource ( ) ) ; addBlock ( ) ; return currentState ; } } try { logger . info ( <str> ) ; if ( latch . await ( Math . min ( <int> , timeout . millis ( ) ) , TimeUnit . MILLISECONDS ) ) { logger . info ( <str> ) ; return currentState ; } logger . info ( <str> ) ; } catch ( InterruptedException ex ) { logger . info ( <str> ) ; Thread . currentThread ( ) . interrupt ( ) ; return currentState ; } } timedOut = true ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , source ) ; } } ) ; } public int count ( ) { return count ; } public boolean timedOut ( ) { return timedOut ; } } } 
