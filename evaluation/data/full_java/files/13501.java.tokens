package org . gradle . api . internal . tasks . compile . incremental . jar ; import org . gradle . api . internal . tasks . compile . incremental . deps . AffectedClasses ; import org . gradle . api . internal . tasks . compile . incremental . deps . DefaultDependentsSet ; import org . gradle . api . internal . tasks . compile . incremental . deps . DependencyToAll ; import org . gradle . api . internal . tasks . compile . incremental . deps . DependentsSet ; import org . gradle . api . tasks . incremental . InputFileDetails ; public class JarChangeDependentsFinder { private final JarClasspathSnapshot jarClasspathSnapshot ; private final PreviousCompilation previousCompilation ; public JarChangeDependentsFinder ( JarClasspathSnapshot jarClasspathSnapshot , PreviousCompilation previousCompilation ) { this . jarClasspathSnapshot = jarClasspathSnapshot ; this . previousCompilation = previousCompilation ; } public DependentsSet getActualDependents ( InputFileDetails jarChangeDetails , JarArchive jarArchive ) { if ( jarChangeDetails . isAdded ( ) ) { if ( jarClasspathSnapshot . isAnyClassDuplicated ( jarArchive ) ) { return new DependencyToAll ( <str> + jarArchive . file . getName ( ) + <str> ) ; } else { return new DefaultDependentsSet ( ) ; } } JarSnapshot previous = previousCompilation . getJarSnapshot ( jarChangeDetails . getFile ( ) ) ; if ( previous = = null ) { return new DependencyToAll ( <str> + jarArchive . file . getName ( ) + <str> ) ; } if ( jarChangeDetails . isRemoved ( ) ) { DependentsSet allClasses = previous . getAllClasses ( ) ; if ( allClasses . isDependencyToAll ( ) ) { return new DependencyToAll ( <str> + jarArchive . file . getName ( ) + <str> ) ; } return previousCompilation . getDependents ( allClasses . getDependentClasses ( ) ) ; } if ( jarChangeDetails . isModified ( ) ) { JarSnapshot currentSnapshot = jarClasspathSnapshot . getSnapshot ( jarArchive ) ; AffectedClasses affected = currentSnapshot . getAffectedClassesSince ( previous ) ; if ( affected . getAltered ( ) . isDependencyToAll ( ) ) { return affected . getAltered ( ) ; } if ( jarClasspathSnapshot . isAnyClassDuplicated ( affected . getAdded ( ) ) ) { return new DependencyToAll ( <str> + jarArchive . file . getName ( ) + <str> ) ; } return previousCompilation . getDependents ( affected . getAltered ( ) . getDependentClasses ( ) ) ; } throw new IllegalArgumentException ( <str> + jarChangeDetails ) ; } } 
