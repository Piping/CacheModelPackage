package org . apache . cassandra . db . commitlog ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . MappedByteBuffer ; import java . nio . channels . FileChannel ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . CLibrary ; import org . apache . cassandra . utils . SyncUtil ; public class MemoryMappedSegment extends CommitLogSegment { MemoryMappedSegment ( CommitLog commitLog ) { super ( commitLog ) ; int firstSync = buffer . position ( ) ; buffer . putInt ( firstSync + <int> , <int> ) ; buffer . putInt ( firstSync + <int> , <int> ) ; } ByteBuffer createBuffer ( CommitLog commitLog ) { try { try ( RandomAccessFile raf = new RandomAccessFile ( logFile , <str> ) ) { raf . setLength ( DatabaseDescriptor . getCommitLogSegmentSize ( ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , logFile ) ; } commitLog . allocator . addSize ( DatabaseDescriptor . getCommitLogSegmentSize ( ) ) ; return channel . map ( FileChannel . MapMode . READ_WRITE , <int> , DatabaseDescriptor . getCommitLogSegmentSize ( ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , logFile ) ; } } @Override void write ( int startMarker , int nextMarker ) { if ( nextMarker < = buffer . capacity ( ) - SYNC_MARKER_SIZE ) { buffer . putInt ( nextMarker , <int> ) ; buffer . putInt ( nextMarker + <int> , <int> ) ; } writeSyncMarker ( buffer , startMarker , startMarker , nextMarker ) ; try { SyncUtil . force ( ( MappedByteBuffer ) buffer ) ; } catch ( Exception e ) { throw new FSWriteError ( e , getPath ( ) ) ; } CLibrary . trySkipCache ( fd , startMarker , nextMarker , logFile . getAbsolutePath ( ) ) ; } @Override public long onDiskSize ( ) { return DatabaseDescriptor . getCommitLogSegmentSize ( ) ; } @Override protected void internalClose ( ) { if ( FileUtils . isCleanerAvailable ( ) ) FileUtils . clean ( buffer ) ; super . internalClose ( ) ; } } 
