package org . gradle . process . internal . streams ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . util . DisconnectableInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public class StreamsForwarder implements StreamsHandler { private final OutputStream standardOutput ; private final OutputStream errorOutput ; private final InputStream input ; private final boolean readErrorStream ; private StoppableExecutor executor ; private ExecOutputHandleRunner standardOutputRunner ; private ExecOutputHandleRunner errorOutputRunner ; private ExecOutputHandleRunner standardInputRunner ; public StreamsForwarder ( OutputStream standardOutput , OutputStream errorOutput , InputStream input , boolean readErrorStream ) { this . standardOutput = standardOutput ; this . errorOutput = errorOutput ; this . input = input ; this . readErrorStream = readErrorStream ; } public void connectStreams ( Process process , String processName , ExecutorFactory executorFactory ) { InputStream instr = new DisconnectableInputStream ( input ) ; standardOutputRunner = new ExecOutputHandleRunner ( <str> + processName , process . getInputStream ( ) , standardOutput ) ; errorOutputRunner = new ExecOutputHandleRunner ( <str> + processName , process . getErrorStream ( ) , errorOutput ) ; standardInputRunner = new ExecOutputHandleRunner ( <str> + processName , instr , process . getOutputStream ( ) ) ; this . executor = executorFactory . create ( String . format ( <str> , processName ) ) ; } public void start ( ) { executor . execute ( standardInputRunner ) ; if ( readErrorStream ) { executor . execute ( errorOutputRunner ) ; } executor . execute ( standardOutputRunner ) ; } public void stop ( ) { try { standardInputRunner . closeInput ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } executor . stop ( ) ; } } 
