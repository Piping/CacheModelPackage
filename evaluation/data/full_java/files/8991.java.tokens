package org . elasticsearch . test . disruption ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . InternalTestCluster ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; public class SlowClusterStateProcessing extends SingleNodeDisruption { volatile boolean disrupting ; volatile Thread worker ; final long intervalBetweenDelaysMin ; final long intervalBetweenDelaysMax ; final long delayDurationMin ; final long delayDurationMax ; public SlowClusterStateProcessing ( Random random ) { this ( null , random ) ; } public SlowClusterStateProcessing ( String disruptedNode , Random random ) { this ( disruptedNode , random , <int> , <int> , <int> , <int> ) ; } public SlowClusterStateProcessing ( String disruptedNode , Random random , long intervalBetweenDelaysMin , long intervalBetweenDelaysMax , long delayDurationMin , long delayDurationMax ) { this ( random , intervalBetweenDelaysMin , intervalBetweenDelaysMax , delayDurationMin , delayDurationMax ) ; this . disruptedNode = disruptedNode ; } public SlowClusterStateProcessing ( Random random , long intervalBetweenDelaysMin , long intervalBetweenDelaysMax , long delayDurationMin , long delayDurationMax ) { super ( random ) ; this . intervalBetweenDelaysMin = intervalBetweenDelaysMin ; this . intervalBetweenDelaysMax = intervalBetweenDelaysMax ; this . delayDurationMin = delayDurationMin ; this . delayDurationMax = delayDurationMax ; } @Override public void startDisrupting ( ) { disrupting = true ; worker = new Thread ( new BackgroundWorker ( ) ) ; worker . setDaemon ( true ) ; worker . start ( ) ; } @Override public void stopDisrupting ( ) { if ( worker = = null ) { return ; } logger . info ( <str> , disruptedNode ) ; disrupting = false ; worker . interrupt ( ) ; try { worker . join ( <int> * ( intervalBetweenDelaysMax + delayDurationMax ) ) ; } catch ( InterruptedException e ) { logger . info ( <str> ) ; } worker = null ; } private boolean interruptClusterStateProcessing ( final TimeValue duration ) throws InterruptedException { final String disruptionNodeCopy = disruptedNode ; if ( disruptionNodeCopy = = null ) { return false ; } logger . info ( <str> , disruptionNodeCopy , duration ) ; final CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; ClusterService clusterService = cluster . getInstance ( ClusterService . class , disruptionNodeCopy ) ; if ( clusterService = = null ) { return false ; } final AtomicBoolean stopped = new AtomicBoolean ( false ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { long count = duration . millis ( ) / <int> ; for ( ; count > <int> & & ! stopped . get ( ) ; count - - ) { Thread . sleep ( <int> ) ; } if ( ! stopped . get ( ) ) { Thread . sleep ( duration . millis ( ) % <int> ) ; } countDownLatch . countDown ( ) ; return currentState ; } @Override public void onFailure ( String source , Throwable t ) { countDownLatch . countDown ( ) ; } } ) ; try { countDownLatch . await ( ) ; } catch ( InterruptedException e ) { stopped . set ( true ) ; countDownLatch . await ( ) ; } return true ; } @Override public void removeAndEnsureHealthy ( InternalTestCluster cluster ) { removeFromCluster ( cluster ) ; ensureNodeCount ( cluster ) ; } @Override public TimeValue expectedTimeToHeal ( ) { return TimeValue . timeValueMillis ( <int> ) ; } class BackgroundWorker implements Runnable { @Override public void run ( ) { while ( disrupting & & disruptedNode ! = null ) { try { TimeValue duration = new TimeValue ( delayDurationMin + random . nextInt ( ( int ) ( delayDurationMax - delayDurationMin ) ) ) ; if ( ! interruptClusterStateProcessing ( duration ) ) { continue ; } if ( intervalBetweenDelaysMax > <int> ) { duration = new TimeValue ( intervalBetweenDelaysMin + random . nextInt ( ( int ) ( intervalBetweenDelaysMax - intervalBetweenDelaysMin ) ) ) ; if ( disrupting & & disruptedNode ! = null ) { Thread . sleep ( duration . millis ( ) ) ; } } } catch ( InterruptedException e ) { } catch ( Exception e ) { logger . error ( <str> , e ) ; } } } } } 
