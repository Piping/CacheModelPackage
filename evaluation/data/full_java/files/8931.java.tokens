package org . elasticsearch . smoketest ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . SuppressForbidden ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . transport . TransportClient ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . URL ; import java . net . UnknownHostException ; import java . nio . file . Path ; import java . util . Locale ; import java . util . concurrent . atomic . AtomicInteger ; import static com . carrotsearch . randomizedtesting . RandomizedTest . randomAsciiOfLength ; import static org . hamcrest . Matchers . notNullValue ; @LuceneTestCase.SuppressSysoutChecks ( bugUrl = <str> ) public abstract class ESSmokeClientTestCase extends LuceneTestCase { public static final String TESTS_CLUSTER = <str> ; public static final String TESTS_CLUSTER_DEFAULT = <str> ; protected static final ESLogger logger = ESLoggerFactory . getLogger ( ESSmokeClientTestCase . class . getName ( ) ) ; private static final AtomicInteger counter = new AtomicInteger ( ) ; private static Client client ; private static String clusterAddresses ; protected String index ; private static Client startClient ( Path tempDir , TransportAddress . . . transportAddresses ) { Settings clientSettings = Settings . settingsBuilder ( ) . put ( <str> , <str> + counter . getAndIncrement ( ) ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . put ( <str> , true ) . put ( <str> , tempDir ) . put ( <str> , <str> ) . build ( ) ; TransportClient . Builder transportClientBuilder = TransportClient . builder ( ) . settings ( clientSettings ) ; TransportClient client = transportClientBuilder . build ( ) . addTransportAddresses ( transportAddresses ) ; logger . info ( <str> ) ; Exception clientException = null ; try { ClusterHealthResponse health = client . admin ( ) . cluster ( ) . prepareHealth ( ) . get ( ) ; logger . info ( <str> , health . getClusterName ( ) , health . getNumberOfNodes ( ) ) ; } catch ( Exception e ) { clientException = e ; } assumeNoException ( <str> + clusterAddresses , clientException ) ; return client ; } private static Client startClient ( ) throws IOException { String [ ] stringAddresses = clusterAddresses . split ( <str> ) ; TransportAddress [ ] transportAddresses = new TransportAddress [ stringAddresses . length ] ; int i = <int> ; for ( String stringAddress : stringAddresses ) { URL url = new URL ( <str> + stringAddress ) ; InetAddress inetAddress = InetAddress . getByName ( url . getHost ( ) ) ; transportAddresses [ i + + ] = new InetSocketTransportAddress ( new InetSocketAddress ( inetAddress , url . getPort ( ) ) ) ; } return startClient ( createTempDir ( ) , transportAddresses ) ; } public static Client getClient ( ) { if ( client = = null ) { try { client = startClient ( ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; } assertThat ( client , notNullValue ( ) ) ; } return client ; } @BeforeClass public static void initializeSettings ( ) throws UnknownHostException { clusterAddresses = System . getProperty ( TESTS_CLUSTER ) ; if ( clusterAddresses = = null | | clusterAddresses . isEmpty ( ) ) { clusterAddresses = TESTS_CLUSTER_DEFAULT ; logger . info ( <str> , TESTS_CLUSTER , TESTS_CLUSTER_DEFAULT ) ; } } @AfterClass public static void stopTransportClient ( ) { if ( client ! = null ) { client . close ( ) ; client = null ; } } @Before public void defineIndexName ( ) { doClean ( ) ; index = <str> + randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . getDefault ( ) ) ; } @After public void cleanIndex ( ) { doClean ( ) ; } private void doClean ( ) { if ( client ! = null ) { try { client . admin ( ) . indices ( ) . prepareDelete ( index ) . get ( ) ; } catch ( Exception e ) { } } } } 
