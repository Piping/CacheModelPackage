package org . elasticsearch . http . netty ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . http . HttpServerTransport ; import org . elasticsearch . node . Node ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . jboss . netty . handler . codec . http . HttpResponse ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Locale ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . http . netty . NettyHttpClient . returnOpaqueIds ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class NettyPipeliningEnabledIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( Node . HTTP_ENABLED , true ) . put ( <str> , true ) . build ( ) ; } public void testThatNettyHttpServerSupportsPipelining ( ) throws Exception { List < String > requests = Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ; HttpServerTransport httpServerTransport = internalCluster ( ) . getInstance ( HttpServerTransport . class ) ; InetSocketTransportAddress inetSocketTransportAddress = ( InetSocketTransportAddress ) randomFrom ( httpServerTransport . boundAddress ( ) . boundAddresses ( ) ) ; try ( NettyHttpClient nettyHttpClient = new NettyHttpClient ( ) ) { Collection < HttpResponse > responses = nettyHttpClient . sendRequests ( inetSocketTransportAddress . address ( ) , requests . toArray ( new String [ ] { } ) ) ; assertThat ( responses , hasSize ( <int> ) ) ; Collection < String > opaqueIds = returnOpaqueIds ( responses ) ; assertOpaqueIdsInOrder ( opaqueIds ) ; } } private void assertOpaqueIdsInOrder ( Collection < String > opaqueIds ) { int i = <int> ; String msg = String . format ( Locale . ROOT , <str> + opaqueIds + <str> ) ; for ( String opaqueId : opaqueIds ) { assertThat ( msg , opaqueId , is ( String . valueOf ( i + + ) ) ) ; } } } 
