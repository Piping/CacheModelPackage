package io . netty . handler . codec . http ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . SocketChannel ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . codec . CodecException ; import io . netty . handler . codec . PrematureChannelClosureException ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . util . concurrent . CountDownLatch ; import static io . netty . util . ReferenceCountUtil . release ; import static io . netty . util . ReferenceCountUtil . releaseLater ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class HttpClientCodecTest { private static final String RESPONSE = <str> + <str> + <str> + <str> + <str> + <str> ; private static final String INCOMPLETE_CHUNKED_RESPONSE = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; private static final String CHUNKED_RESPONSE = INCOMPLETE_CHUNKED_RESPONSE + <str> ; @Test public void testFailsNotOnRequestResponse ( ) { HttpClientCodec codec = new HttpClientCodec ( <int> , <int> , <int> , true ) ; EmbeddedChannel ch = new EmbeddedChannel ( codec ) ; ch . writeOutbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( RESPONSE , CharsetUtil . ISO_8859_1 ) ) ; ch . finish ( ) ; for ( ; ; ) { Object msg = ch . readOutbound ( ) ; if ( msg = = null ) { break ; } release ( msg ) ; } for ( ; ; ) { Object msg = ch . readInbound ( ) ; if ( msg = = null ) { break ; } release ( msg ) ; } } @Test public void testFailsNotOnRequestResponseChunked ( ) { HttpClientCodec codec = new HttpClientCodec ( <int> , <int> , <int> , true ) ; EmbeddedChannel ch = new EmbeddedChannel ( codec ) ; ch . writeOutbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( CHUNKED_RESPONSE , CharsetUtil . ISO_8859_1 ) ) ; ch . finish ( ) ; for ( ; ; ) { Object msg = ch . readOutbound ( ) ; if ( msg = = null ) { break ; } release ( msg ) ; } for ( ; ; ) { Object msg = ch . readInbound ( ) ; if ( msg = = null ) { break ; } release ( msg ) ; } } @Test public void testFailsOnMissingResponse ( ) { HttpClientCodec codec = new HttpClientCodec ( <int> , <int> , <int> , true ) ; EmbeddedChannel ch = new EmbeddedChannel ( codec ) ; assertTrue ( ch . writeOutbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ) ; assertNotNull ( releaseLater ( ch . readOutbound ( ) ) ) ; try { ch . finish ( ) ; fail ( ) ; } catch ( CodecException e ) { assertTrue ( e instanceof PrematureChannelClosureException ) ; } } @Test public void testFailsOnIncompleteChunkedResponse ( ) { HttpClientCodec codec = new HttpClientCodec ( <int> , <int> , <int> , true ) ; EmbeddedChannel ch = new EmbeddedChannel ( codec ) ; ch . writeOutbound ( releaseLater ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ) ; assertNotNull ( releaseLater ( ch . readOutbound ( ) ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( releaseLater ( Unpooled . copiedBuffer ( INCOMPLETE_CHUNKED_RESPONSE , CharsetUtil . ISO_8859_1 ) ) ) ; assertThat ( releaseLater ( ch . readInbound ( ) ) , instanceOf ( HttpResponse . class ) ) ; assertThat ( releaseLater ( ch . readInbound ( ) ) , instanceOf ( HttpContent . class ) ) ; assertThat ( releaseLater ( ch . readInbound ( ) ) , instanceOf ( HttpContent . class ) ) ; assertNull ( ch . readInbound ( ) ) ; try { ch . finish ( ) ; fail ( ) ; } catch ( CodecException e ) { assertTrue ( e instanceof PrematureChannelClosureException ) ; } } @Test public void testServerCloseSocketInputProvidesData ( ) throws InterruptedException { ServerBootstrap sb = new ServerBootstrap ( ) ; Bootstrap cb = new Bootstrap ( ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; final CountDownLatch responseRecievedLatch = new CountDownLatch ( <int> ) ; try { sb . group ( new NioEventLoopGroup ( <int> ) ) ; sb . channel ( NioServerSocketChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ch . pipeline ( ) . addLast ( new HttpRequestDecoder ( <int> , <int> , <int> , true ) ) ; ch . pipeline ( ) . addLast ( new HttpObjectAggregator ( <int> ) ) ; ch . pipeline ( ) . addLast ( new SimpleChannelInboundHandler < FullHttpRequest > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , FullHttpRequest msg ) { assertTrue ( ctx . channel ( ) instanceof SocketChannel ) ; final SocketChannel sChannel = ( SocketChannel ) ctx . channel ( ) ; sChannel . writeAndFlush ( Unpooled . wrappedBuffer ( ( <str> + <str> + <str> ) . getBytes ( CharsetUtil . ISO_8859_1 ) ) ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { assertTrue ( future . isSuccess ( ) ) ; sChannel . writeAndFlush ( Unpooled . wrappedBuffer ( <str> . getBytes ( CharsetUtil . ISO_8859_1 ) ) ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { assertTrue ( future . isSuccess ( ) ) ; sChannel . shutdownOutput ( ) ; } } ) ; } } ) ; } } ) ; serverChannelLatch . countDown ( ) ; } } ) ; cb . group ( new NioEventLoopGroup ( <int> ) ) ; cb . channel ( NioSocketChannel . class ) ; cb . option ( ChannelOption . ALLOW_HALF_CLOSURE , true ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ch . pipeline ( ) . addLast ( new HttpClientCodec ( <int> , <int> , <int> , true , true ) ) ; ch . pipeline ( ) . addLast ( new HttpObjectAggregator ( <int> ) ) ; ch . pipeline ( ) . addLast ( new SimpleChannelInboundHandler < FullHttpResponse > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , FullHttpResponse msg ) { responseRecievedLatch . countDown ( ) ; } } ) ; } } ) ; Channel serverChannel = sb . bind ( new InetSocketAddress ( <int> ) ) . sync ( ) . channel ( ) ; int port = ( ( InetSocketAddress ) serverChannel . localAddress ( ) ) . getPort ( ) ; ChannelFuture ccf = cb . connect ( new InetSocketAddress ( NetUtil . LOCALHOST , port ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; Channel clientChannel = ccf . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; clientChannel . writeAndFlush ( new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; assertTrue ( responseRecievedLatch . await ( <int> , SECONDS ) ) ; } finally { sb . group ( ) . shutdownGracefully ( ) ; sb . childGroup ( ) . shutdownGracefully ( ) ; cb . group ( ) . shutdownGracefully ( ) ; } } } 
