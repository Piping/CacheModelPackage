package com . badlogic . gdx . backends . android . surfaceview ; import java . io . Writer ; import java . lang . ref . WeakReference ; import java . util . ArrayList ; import javax . microedition . khronos . egl . EGL10 ; import javax . microedition . khronos . egl . EGL11 ; import javax . microedition . khronos . egl . EGLConfig ; import javax . microedition . khronos . egl . EGLContext ; import javax . microedition . khronos . egl . EGLDisplay ; import javax . microedition . khronos . egl . EGLSurface ; import javax . microedition . khronos . opengles . GL ; import javax . microedition . khronos . opengles . GL10 ; import android . content . Context ; import android . graphics . PixelFormat ; import android . opengl . GLDebugHelper ; import android . opengl . GLSurfaceView . EGLConfigChooser ; import android . opengl . GLSurfaceView . Renderer ; import android . util . AttributeSet ; import android . util . Log ; import android . view . SurfaceHolder ; import android . view . SurfaceView ; @SuppressWarnings ( <str> ) public class GLSurfaceViewAPI18 extends SurfaceView implements SurfaceHolder . Callback { private final static String TAG = <str> ; private final static boolean LOG_ATTACH_DETACH = false ; private final static boolean LOG_THREADS = false ; private final static boolean LOG_PAUSE_RESUME = false ; private final static boolean LOG_SURFACE = false ; private final static boolean LOG_RENDERER = false ; private final static boolean LOG_RENDERER_DRAW_FRAME = false ; private final static boolean LOG_EGL = false ; public final static int RENDERMODE_WHEN_DIRTY = <int> ; public final static int RENDERMODE_CONTINUOUSLY = <int> ; public final static int DEBUG_CHECK_GL_ERROR = <int> ; public final static int DEBUG_LOG_GL_CALLS = <int> ; public GLSurfaceViewAPI18 ( Context context ) { super ( context ) ; init ( ) ; } public GLSurfaceViewAPI18 ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; init ( ) ; } @Override protected void finalize ( ) throws Throwable { try { if ( mGLThread ! = null ) { mGLThread . requestExitAndWait ( ) ; } } finally { super . finalize ( ) ; } } private void init ( ) { SurfaceHolder holder = getHolder ( ) ; holder . addCallback ( this ) ; int sdkVersion = android . os . Build . VERSION . SDK_INT ; if ( sdkVersion < = <int> ) { holder . setFormat ( PixelFormat . RGB_565 ) ; } } public void setGLWrapper ( GLWrapper glWrapper ) { mGLWrapper = glWrapper ; } public void setDebugFlags ( int debugFlags ) { mDebugFlags = debugFlags ; } public int getDebugFlags ( ) { return mDebugFlags ; } public void setPreserveEGLContextOnPause ( boolean preserveOnPause ) { mPreserveEGLContextOnPause = preserveOnPause ; } public boolean getPreserveEGLContextOnPause ( ) { return mPreserveEGLContextOnPause ; } public void setRenderer ( Renderer renderer ) { checkRenderThreadState ( ) ; if ( mEGLConfigChooser = = null ) { mEGLConfigChooser = new SimpleEGLConfigChooser ( true ) ; } if ( mEGLContextFactory = = null ) { mEGLContextFactory = new DefaultContextFactory ( ) ; } if ( mEGLWindowSurfaceFactory = = null ) { mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory ( ) ; } mRenderer = renderer ; mGLThread = new GLThread ( mThisWeakRef ) ; mGLThread . start ( ) ; } public void setEGLContextFactory ( EGLContextFactory factory ) { checkRenderThreadState ( ) ; mEGLContextFactory = factory ; } public void setEGLWindowSurfaceFactory ( EGLWindowSurfaceFactory factory ) { checkRenderThreadState ( ) ; mEGLWindowSurfaceFactory = factory ; } public void setEGLConfigChooser ( EGLConfigChooser configChooser ) { checkRenderThreadState ( ) ; mEGLConfigChooser = configChooser ; } public void setEGLConfigChooser ( boolean needDepth ) { setEGLConfigChooser ( new SimpleEGLConfigChooser ( needDepth ) ) ; } public void setEGLConfigChooser ( int redSize , int greenSize , int blueSize , int alphaSize , int depthSize , int stencilSize ) { setEGLConfigChooser ( new ComponentSizeChooser ( redSize , greenSize , blueSize , alphaSize , depthSize , stencilSize ) ) ; } public void setEGLContextClientVersion ( int version ) { checkRenderThreadState ( ) ; mEGLContextClientVersion = version ; } public void setRenderMode ( int renderMode ) { mGLThread . setRenderMode ( renderMode ) ; } public int getRenderMode ( ) { return mGLThread . getRenderMode ( ) ; } public void requestRender ( ) { mGLThread . requestRender ( ) ; } public void surfaceCreated ( SurfaceHolder holder ) { mGLThread . surfaceCreated ( ) ; } public void surfaceDestroyed ( SurfaceHolder holder ) { mGLThread . surfaceDestroyed ( ) ; } public void surfaceChanged ( SurfaceHolder holder , int format , int w , int h ) { mGLThread . onWindowResize ( w , h ) ; } public void onPause ( ) { mGLThread . onPause ( ) ; } public void onResume ( ) { mGLThread . onResume ( ) ; } public void queueEvent ( Runnable r ) { mGLThread . queueEvent ( r ) ; } @Override protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; if ( LOG_ATTACH_DETACH ) { Log . d ( TAG , <str> + mDetached ) ; } if ( mDetached & & ( mRenderer ! = null ) ) { int renderMode = RENDERMODE_CONTINUOUSLY ; if ( mGLThread ! = null ) { renderMode = mGLThread . getRenderMode ( ) ; } mGLThread = new GLThread ( mThisWeakRef ) ; if ( renderMode ! = RENDERMODE_CONTINUOUSLY ) { mGLThread . setRenderMode ( renderMode ) ; } mGLThread . start ( ) ; } mDetached = false ; } @Override protected void onDetachedFromWindow ( ) { if ( LOG_ATTACH_DETACH ) { Log . d ( TAG , <str> ) ; } if ( mGLThread ! = null ) { mGLThread . requestExitAndWait ( ) ; } mDetached = true ; super . onDetachedFromWindow ( ) ; } public interface GLWrapper { GL wrap ( GL gl ) ; } public interface EGLContextFactory { EGLContext createContext ( EGL10 egl , EGLDisplay display , EGLConfig eglConfig ) ; void destroyContext ( EGL10 egl , EGLDisplay display , EGLContext context ) ; } private class DefaultContextFactory implements EGLContextFactory { private int EGL_CONTEXT_CLIENT_VERSION = <hex> ; public EGLContext createContext ( EGL10 egl , EGLDisplay display , EGLConfig config ) { int [ ] attrib_list = { EGL_CONTEXT_CLIENT_VERSION , mEGLContextClientVersion , EGL10 . EGL_NONE } ; return egl . eglCreateContext ( display , config , EGL10 . EGL_NO_CONTEXT , mEGLContextClientVersion ! = <int> ? attrib_list : null ) ; } public void destroyContext ( EGL10 egl , EGLDisplay display , EGLContext context ) { if ( ! egl . eglDestroyContext ( display , context ) ) { Log . e ( <str> , <str> + display + <str> + context ) ; if ( LOG_THREADS ) { Log . i ( <str> , <str> + Thread . currentThread ( ) . getId ( ) ) ; } EglHelper . throwEglException ( <str> , egl . eglGetError ( ) ) ; } } } public interface EGLWindowSurfaceFactory { EGLSurface createWindowSurface ( EGL10 egl , EGLDisplay display , EGLConfig config , Object nativeWindow ) ; void destroySurface ( EGL10 egl , EGLDisplay display , EGLSurface surface ) ; } private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory { public EGLSurface createWindowSurface ( EGL10 egl , EGLDisplay display , EGLConfig config , Object nativeWindow ) { EGLSurface result = null ; try { result = egl . eglCreateWindowSurface ( display , config , nativeWindow , null ) ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , <str> , e ) ; } return result ; } public void destroySurface ( EGL10 egl , EGLDisplay display , EGLSurface surface ) { egl . eglDestroySurface ( display , surface ) ; } } private abstract class BaseConfigChooser implements EGLConfigChooser { public BaseConfigChooser ( int [ ] configSpec ) { mConfigSpec = filterConfigSpec ( configSpec ) ; } public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display ) { int [ ] num_config = new int [ <int> ] ; if ( ! egl . eglChooseConfig ( display , mConfigSpec , null , <int> , num_config ) ) { throw new IllegalArgumentException ( <str> ) ; } int numConfigs = num_config [ <int> ] ; if ( numConfigs < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } EGLConfig [ ] configs = new EGLConfig [ numConfigs ] ; if ( ! egl . eglChooseConfig ( display , mConfigSpec , configs , numConfigs , num_config ) ) { throw new IllegalArgumentException ( <str> ) ; } EGLConfig config = chooseConfig ( egl , display , configs ) ; if ( config = = null ) { throw new IllegalArgumentException ( <str> ) ; } return config ; } abstract EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) ; protected int [ ] mConfigSpec ; private int [ ] filterConfigSpec ( int [ ] configSpec ) { if ( mEGLContextClientVersion ! = <int> ) { return configSpec ; } int len = configSpec . length ; int [ ] newConfigSpec = new int [ len + <int> ] ; System . arraycopy ( configSpec , <int> , newConfigSpec , <int> , len - <int> ) ; newConfigSpec [ len - <int> ] = EGL10 . EGL_RENDERABLE_TYPE ; newConfigSpec [ len ] = <int> ; newConfigSpec [ len + <int> ] = EGL10 . EGL_NONE ; return newConfigSpec ; } } private class ComponentSizeChooser extends BaseConfigChooser { public ComponentSizeChooser ( int redSize , int greenSize , int blueSize , int alphaSize , int depthSize , int stencilSize ) { super ( new int [ ] { EGL10 . EGL_RED_SIZE , redSize , EGL10 . EGL_GREEN_SIZE , greenSize , EGL10 . EGL_BLUE_SIZE , blueSize , EGL10 . EGL_ALPHA_SIZE , alphaSize , EGL10 . EGL_DEPTH_SIZE , depthSize , EGL10 . EGL_STENCIL_SIZE , stencilSize , EGL10 . EGL_NONE } ) ; mValue = new int [ <int> ] ; mRedSize = redSize ; mGreenSize = greenSize ; mBlueSize = blueSize ; mAlphaSize = alphaSize ; mDepthSize = depthSize ; mStencilSize = stencilSize ; } @Override public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) { for ( EGLConfig config : configs ) { int d = findConfigAttrib ( egl , display , config , EGL10 . EGL_DEPTH_SIZE , <int> ) ; int s = findConfigAttrib ( egl , display , config , EGL10 . EGL_STENCIL_SIZE , <int> ) ; if ( ( d > = mDepthSize ) & & ( s > = mStencilSize ) ) { int r = findConfigAttrib ( egl , display , config , EGL10 . EGL_RED_SIZE , <int> ) ; int g = findConfigAttrib ( egl , display , config , EGL10 . EGL_GREEN_SIZE , <int> ) ; int b = findConfigAttrib ( egl , display , config , EGL10 . EGL_BLUE_SIZE , <int> ) ; int a = findConfigAttrib ( egl , display , config , EGL10 . EGL_ALPHA_SIZE , <int> ) ; if ( ( r = = mRedSize ) & & ( g = = mGreenSize ) & & ( b = = mBlueSize ) & & ( a = = mAlphaSize ) ) { return config ; } } } return null ; } private int findConfigAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attribute , int defaultValue ) { if ( egl . eglGetConfigAttrib ( display , config , attribute , mValue ) ) { return mValue [ <int> ] ; } return defaultValue ; } private int [ ] mValue ; protected int mRedSize ; protected int mGreenSize ; protected int mBlueSize ; protected int mAlphaSize ; protected int mDepthSize ; protected int mStencilSize ; } private class SimpleEGLConfigChooser extends ComponentSizeChooser { public SimpleEGLConfigChooser ( boolean withDepthBuffer ) { super ( <int> , <int> , <int> , <int> , withDepthBuffer ? <int> : <int> , <int> ) ; } } private static class EglHelper { public EglHelper ( WeakReference < GLSurfaceViewAPI18 > glSurfaceViewWeakRef ) { mGLSurfaceViewWeakRef = glSurfaceViewWeakRef ; } public void start ( ) { if ( LOG_EGL ) { Log . w ( <str> , <str> + Thread . currentThread ( ) . getId ( ) ) ; } mEgl = ( EGL10 ) EGLContext . getEGL ( ) ; mEglDisplay = mEgl . eglGetDisplay ( EGL10 . EGL_DEFAULT_DISPLAY ) ; if ( mEglDisplay = = EGL10 . EGL_NO_DISPLAY ) { throw new RuntimeException ( <str> ) ; } int [ ] version = new int [ <int> ] ; if ( ! mEgl . eglInitialize ( mEglDisplay , version ) ) { throw new RuntimeException ( <str> ) ; } GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view = = null ) { mEglConfig = null ; mEglContext = null ; } else { mEglConfig = view . mEGLConfigChooser . chooseConfig ( mEgl , mEglDisplay ) ; mEglContext = view . mEGLContextFactory . createContext ( mEgl , mEglDisplay , mEglConfig ) ; } if ( mEglContext = = null | | mEglContext = = EGL10 . EGL_NO_CONTEXT ) { mEglContext = null ; throwEglException ( <str> ) ; } if ( LOG_EGL ) { Log . w ( <str> , <str> + mEglContext + <str> + Thread . currentThread ( ) . getId ( ) ) ; } mEglSurface = null ; } public boolean createSurface ( ) { if ( LOG_EGL ) { Log . w ( <str> , <str> + Thread . currentThread ( ) . getId ( ) ) ; } if ( mEgl = = null ) { throw new RuntimeException ( <str> ) ; } if ( mEglDisplay = = null ) { throw new RuntimeException ( <str> ) ; } if ( mEglConfig = = null ) { throw new RuntimeException ( <str> ) ; } destroySurfaceImp ( ) ; GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { mEglSurface = view . mEGLWindowSurfaceFactory . createWindowSurface ( mEgl , mEglDisplay , mEglConfig , view . getHolder ( ) ) ; } else { mEglSurface = null ; } if ( mEglSurface = = null | | mEglSurface = = EGL10 . EGL_NO_SURFACE ) { int error = mEgl . eglGetError ( ) ; if ( error = = EGL10 . EGL_BAD_NATIVE_WINDOW ) { Log . e ( <str> , <str> ) ; } return false ; } if ( ! mEgl . eglMakeCurrent ( mEglDisplay , mEglSurface , mEglSurface , mEglContext ) ) { logEglErrorAsWarning ( <str> , <str> , mEgl . eglGetError ( ) ) ; return false ; } return true ; } GL createGL ( ) { GL gl = mEglContext . getGL ( ) ; GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { if ( view . mGLWrapper ! = null ) { gl = view . mGLWrapper . wrap ( gl ) ; } if ( ( view . mDebugFlags & ( DEBUG_CHECK_GL_ERROR | DEBUG_LOG_GL_CALLS ) ) ! = <int> ) { int configFlags = <int> ; Writer log = null ; if ( ( view . mDebugFlags & DEBUG_CHECK_GL_ERROR ) ! = <int> ) { configFlags | = GLDebugHelper . CONFIG_CHECK_GL_ERROR ; } if ( ( view . mDebugFlags & DEBUG_LOG_GL_CALLS ) ! = <int> ) { log = new LogWriter ( ) ; } gl = GLDebugHelper . wrap ( gl , configFlags , log ) ; } } return gl ; } public int swap ( ) { if ( ! mEgl . eglSwapBuffers ( mEglDisplay , mEglSurface ) ) { return mEgl . eglGetError ( ) ; } return EGL10 . EGL_SUCCESS ; } public void destroySurface ( ) { if ( LOG_EGL ) { Log . w ( <str> , <str> + Thread . currentThread ( ) . getId ( ) ) ; } destroySurfaceImp ( ) ; } private void destroySurfaceImp ( ) { if ( mEglSurface ! = null & & mEglSurface ! = EGL10 . EGL_NO_SURFACE ) { mEgl . eglMakeCurrent ( mEglDisplay , EGL10 . EGL_NO_SURFACE , EGL10 . EGL_NO_SURFACE , EGL10 . EGL_NO_CONTEXT ) ; GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { view . mEGLWindowSurfaceFactory . destroySurface ( mEgl , mEglDisplay , mEglSurface ) ; } mEglSurface = null ; } } public void finish ( ) { if ( LOG_EGL ) { Log . w ( <str> , <str> + Thread . currentThread ( ) . getId ( ) ) ; } if ( mEglContext ! = null ) { GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { view . mEGLContextFactory . destroyContext ( mEgl , mEglDisplay , mEglContext ) ; } mEglContext = null ; } if ( mEglDisplay ! = null ) { mEgl . eglTerminate ( mEglDisplay ) ; mEglDisplay = null ; } } private void throwEglException ( String function ) { throwEglException ( function , mEgl . eglGetError ( ) ) ; } public static void throwEglException ( String function , int error ) { String message = formatEglError ( function , error ) ; if ( LOG_THREADS ) { Log . e ( <str> , <str> + Thread . currentThread ( ) . getId ( ) + <str> + message ) ; } throw new RuntimeException ( message ) ; } public static void logEglErrorAsWarning ( String tag , String function , int error ) { Log . w ( tag , formatEglError ( function , error ) ) ; } private static String getErrorString ( int error ) { switch ( error ) { case EGL10 . EGL_SUCCESS : return <str> ; case EGL10 . EGL_NOT_INITIALIZED : return <str> ; case EGL10 . EGL_BAD_ACCESS : return <str> ; case EGL10 . EGL_BAD_ALLOC : return <str> ; case EGL10 . EGL_BAD_ATTRIBUTE : return <str> ; case EGL10 . EGL_BAD_CONFIG : return <str> ; case EGL10 . EGL_BAD_CONTEXT : return <str> ; case EGL10 . EGL_BAD_CURRENT_SURFACE : return <str> ; case EGL10 . EGL_BAD_DISPLAY : return <str> ; case EGL10 . EGL_BAD_MATCH : return <str> ; case EGL10 . EGL_BAD_NATIVE_PIXMAP : return <str> ; case EGL10 . EGL_BAD_NATIVE_WINDOW : return <str> ; case EGL10 . EGL_BAD_PARAMETER : return <str> ; case EGL10 . EGL_BAD_SURFACE : return <str> ; case EGL11 . EGL_CONTEXT_LOST : return <str> ; default : return <str> + Integer . toHexString ( error ) ; } } public static String formatEglError ( String function , int error ) { return function + <str> + getErrorString ( error ) ; } private WeakReference < GLSurfaceViewAPI18 > mGLSurfaceViewWeakRef ; EGL10 mEgl ; EGLDisplay mEglDisplay ; EGLSurface mEglSurface ; EGLConfig mEglConfig ; EGLContext mEglContext ; } static class GLThread extends Thread { GLThread ( WeakReference < GLSurfaceViewAPI18 > glSurfaceViewWeakRef ) { super ( ) ; mWidth = <int> ; mHeight = <int> ; mRequestRender = true ; mRenderMode = RENDERMODE_CONTINUOUSLY ; mGLSurfaceViewWeakRef = glSurfaceViewWeakRef ; } @Override public void run ( ) { setName ( <str> + getId ( ) ) ; if ( LOG_THREADS ) { Log . i ( <str> , <str> + getId ( ) ) ; } try { guardedRun ( ) ; } catch ( InterruptedException e ) { } finally { sGLThreadManager . threadExiting ( this ) ; } } private void stopEglSurfaceLocked ( ) { if ( mHaveEglSurface ) { mHaveEglSurface = false ; mEglHelper . destroySurface ( ) ; } } private void stopEglContextLocked ( ) { if ( mHaveEglContext ) { mEglHelper . finish ( ) ; mHaveEglContext = false ; sGLThreadManager . releaseEglContextLocked ( this ) ; } } private void guardedRun ( ) throws InterruptedException { mEglHelper = new EglHelper ( mGLSurfaceViewWeakRef ) ; mHaveEglContext = false ; mHaveEglSurface = false ; try { GL10 gl = null ; boolean createEglContext = false ; boolean createEglSurface = false ; boolean createGlInterface = false ; boolean lostEglContext = false ; boolean sizeChanged = false ; boolean wantRenderNotification = false ; boolean doRenderNotification = false ; boolean askedToReleaseEglContext = false ; int w = <int> ; int h = <int> ; Runnable event = null ; while ( true ) { synchronized ( sGLThreadManager ) { while ( true ) { if ( mShouldExit ) { return ; } if ( ! mEventQueue . isEmpty ( ) ) { event = mEventQueue . remove ( <int> ) ; break ; } boolean pausing = false ; if ( mPaused ! = mRequestPaused ) { pausing = mRequestPaused ; mPaused = mRequestPaused ; sGLThreadManager . notifyAll ( ) ; if ( LOG_PAUSE_RESUME ) { Log . i ( <str> , <str> + mPaused + <str> + getId ( ) ) ; } } if ( mShouldReleaseEglContext ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } stopEglSurfaceLocked ( ) ; stopEglContextLocked ( ) ; mShouldReleaseEglContext = false ; askedToReleaseEglContext = true ; } if ( lostEglContext ) { stopEglSurfaceLocked ( ) ; stopEglContextLocked ( ) ; lostEglContext = false ; } if ( pausing & & mHaveEglSurface ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } stopEglSurfaceLocked ( ) ; } if ( pausing & & mHaveEglContext ) { GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; boolean preserveEglContextOnPause = view = = null ? false : view . mPreserveEGLContextOnPause ; if ( ! preserveEglContextOnPause | | sGLThreadManager . shouldReleaseEGLContextWhenPausing ( ) ) { stopEglContextLocked ( ) ; if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } } } if ( pausing ) { if ( sGLThreadManager . shouldTerminateEGLWhenPausing ( ) ) { mEglHelper . finish ( ) ; if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } } } if ( ( ! mHasSurface ) & & ( ! mWaitingForSurface ) ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } if ( mHaveEglSurface ) { stopEglSurfaceLocked ( ) ; } mWaitingForSurface = true ; mSurfaceIsBad = false ; sGLThreadManager . notifyAll ( ) ; } if ( mHasSurface & & mWaitingForSurface ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } mWaitingForSurface = false ; sGLThreadManager . notifyAll ( ) ; } if ( doRenderNotification ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } wantRenderNotification = false ; doRenderNotification = false ; mRenderComplete = true ; sGLThreadManager . notifyAll ( ) ; } if ( readyToDraw ( ) ) { if ( ! mHaveEglContext ) { if ( askedToReleaseEglContext ) { askedToReleaseEglContext = false ; } else if ( sGLThreadManager . tryAcquireEglContextLocked ( this ) ) { try { mEglHelper . start ( ) ; } catch ( RuntimeException t ) { sGLThreadManager . releaseEglContextLocked ( this ) ; throw t ; } mHaveEglContext = true ; createEglContext = true ; sGLThreadManager . notifyAll ( ) ; } } if ( mHaveEglContext & & ! mHaveEglSurface ) { mHaveEglSurface = true ; createEglSurface = true ; createGlInterface = true ; sizeChanged = true ; } if ( mHaveEglSurface ) { if ( mSizeChanged ) { sizeChanged = true ; w = mWidth ; h = mHeight ; wantRenderNotification = true ; if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } createEglSurface = true ; mSizeChanged = false ; } mRequestRender = false ; sGLThreadManager . notifyAll ( ) ; break ; } } if ( LOG_THREADS ) { Log . i ( <str> , <str> + getId ( ) + <str> + mHaveEglContext + <str> + mHaveEglSurface + <str> + mFinishedCreatingEglSurface + <str> + mPaused + <str> + mHasSurface + <str> + mSurfaceIsBad + <str> + mWaitingForSurface + <str> + mWidth + <str> + mHeight + <str> + mRequestRender + <str> + mRenderMode ) ; } sGLThreadManager . wait ( ) ; } } if ( event ! = null ) { event . run ( ) ; event = null ; continue ; } if ( createEglSurface ) { if ( LOG_SURFACE ) { Log . w ( <str> , <str> ) ; } if ( mEglHelper . createSurface ( ) ) { synchronized ( sGLThreadManager ) { mFinishedCreatingEglSurface = true ; sGLThreadManager . notifyAll ( ) ; } } else { synchronized ( sGLThreadManager ) { mFinishedCreatingEglSurface = true ; mSurfaceIsBad = true ; sGLThreadManager . notifyAll ( ) ; } continue ; } createEglSurface = false ; } if ( createGlInterface ) { gl = ( GL10 ) mEglHelper . createGL ( ) ; sGLThreadManager . checkGLDriver ( gl ) ; createGlInterface = false ; } if ( createEglContext ) { if ( LOG_RENDERER ) { Log . w ( <str> , <str> ) ; } GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { view . mRenderer . onSurfaceCreated ( gl , mEglHelper . mEglConfig ) ; } createEglContext = false ; } if ( sizeChanged ) { if ( LOG_RENDERER ) { Log . w ( <str> , <str> + w + <str> + h + <str> ) ; } GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { view . mRenderer . onSurfaceChanged ( gl , w , h ) ; } sizeChanged = false ; } if ( LOG_RENDERER_DRAW_FRAME ) { Log . w ( <str> , <str> + getId ( ) ) ; } { GLSurfaceViewAPI18 view = mGLSurfaceViewWeakRef . get ( ) ; if ( view ! = null ) { view . mRenderer . onDrawFrame ( gl ) ; } } int swapError = mEglHelper . swap ( ) ; switch ( swapError ) { case EGL10 . EGL_SUCCESS : break ; case EGL11 . EGL_CONTEXT_LOST : if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } lostEglContext = true ; break ; default : EglHelper . logEglErrorAsWarning ( <str> , <str> , swapError ) ; synchronized ( sGLThreadManager ) { mSurfaceIsBad = true ; sGLThreadManager . notifyAll ( ) ; } break ; } if ( wantRenderNotification ) { doRenderNotification = true ; } } } finally { synchronized ( sGLThreadManager ) { stopEglSurfaceLocked ( ) ; stopEglContextLocked ( ) ; } } } public boolean ableToDraw ( ) { return mHaveEglContext & & mHaveEglSurface & & readyToDraw ( ) ; } private boolean readyToDraw ( ) { return ( ! mPaused ) & & mHasSurface & & ( ! mSurfaceIsBad ) & & ( mWidth > <int> ) & & ( mHeight > <int> ) & & ( mRequestRender | | ( mRenderMode = = RENDERMODE_CONTINUOUSLY ) ) ; } public void setRenderMode ( int renderMode ) { if ( ! ( ( RENDERMODE_WHEN_DIRTY < = renderMode ) & & ( renderMode < = RENDERMODE_CONTINUOUSLY ) ) ) { throw new IllegalArgumentException ( <str> ) ; } synchronized ( sGLThreadManager ) { mRenderMode = renderMode ; sGLThreadManager . notifyAll ( ) ; } } public int getRenderMode ( ) { synchronized ( sGLThreadManager ) { return mRenderMode ; } } public void requestRender ( ) { synchronized ( sGLThreadManager ) { mRequestRender = true ; sGLThreadManager . notifyAll ( ) ; } } public void surfaceCreated ( ) { synchronized ( sGLThreadManager ) { if ( LOG_THREADS ) { Log . i ( <str> , <str> + getId ( ) ) ; } mHasSurface = true ; mFinishedCreatingEglSurface = false ; sGLThreadManager . notifyAll ( ) ; while ( mWaitingForSurface & & ! mFinishedCreatingEglSurface & & ! mExited ) { try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void surfaceDestroyed ( ) { synchronized ( sGLThreadManager ) { if ( LOG_THREADS ) { Log . i ( <str> , <str> + getId ( ) ) ; } mHasSurface = false ; sGLThreadManager . notifyAll ( ) ; while ( ( ! mWaitingForSurface ) & & ( ! mExited ) ) { try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void onPause ( ) { synchronized ( sGLThreadManager ) { if ( LOG_PAUSE_RESUME ) { Log . i ( <str> , <str> + getId ( ) ) ; } mRequestPaused = true ; sGLThreadManager . notifyAll ( ) ; while ( ( ! mExited ) & & ( ! mPaused ) ) { if ( LOG_PAUSE_RESUME ) { Log . i ( <str> , <str> ) ; } try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void onResume ( ) { synchronized ( sGLThreadManager ) { if ( LOG_PAUSE_RESUME ) { Log . i ( <str> , <str> + getId ( ) ) ; } mRequestPaused = false ; mRequestRender = true ; mRenderComplete = false ; sGLThreadManager . notifyAll ( ) ; while ( ( ! mExited ) & & mPaused & & ( ! mRenderComplete ) ) { if ( LOG_PAUSE_RESUME ) { Log . i ( <str> , <str> ) ; } try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void onWindowResize ( int w , int h ) { synchronized ( sGLThreadManager ) { mWidth = w ; mHeight = h ; mSizeChanged = true ; mRequestRender = true ; mRenderComplete = false ; sGLThreadManager . notifyAll ( ) ; while ( ! mExited & & ! mPaused & & ! mRenderComplete & & ableToDraw ( ) ) { if ( LOG_SURFACE ) { Log . i ( <str> , <str> + getId ( ) ) ; } try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void requestExitAndWait ( ) { synchronized ( sGLThreadManager ) { mShouldExit = true ; sGLThreadManager . notifyAll ( ) ; while ( ! mExited ) { try { sGLThreadManager . wait ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } public void requestReleaseEglContextLocked ( ) { mShouldReleaseEglContext = true ; sGLThreadManager . notifyAll ( ) ; } public void queueEvent ( Runnable r ) { if ( r = = null ) { throw new IllegalArgumentException ( <str> ) ; } synchronized ( sGLThreadManager ) { mEventQueue . add ( r ) ; sGLThreadManager . notifyAll ( ) ; } } private boolean mShouldExit ; private boolean mExited ; private boolean mRequestPaused ; private boolean mPaused ; private boolean mHasSurface ; private boolean mSurfaceIsBad ; private boolean mWaitingForSurface ; private boolean mHaveEglContext ; private boolean mHaveEglSurface ; private boolean mFinishedCreatingEglSurface ; private boolean mShouldReleaseEglContext ; private int mWidth ; private int mHeight ; private int mRenderMode ; private boolean mRequestRender ; private boolean mRenderComplete ; private ArrayList < Runnable > mEventQueue = new ArrayList < Runnable > ( ) ; private boolean mSizeChanged = true ; private EglHelper mEglHelper ; private WeakReference < GLSurfaceViewAPI18 > mGLSurfaceViewWeakRef ; } static class LogWriter extends Writer { @Override public void close ( ) { flushBuilder ( ) ; } @Override public void flush ( ) { flushBuilder ( ) ; } @Override public void write ( char [ ] buf , int offset , int count ) { for ( int i = <int> ; i < count ; i + + ) { char c = buf [ offset + i ] ; if ( c = = <str> ) { flushBuilder ( ) ; } else { mBuilder . append ( c ) ; } } } private void flushBuilder ( ) { if ( mBuilder . length ( ) > <int> ) { Log . v ( <str> , mBuilder . toString ( ) ) ; mBuilder . delete ( <int> , mBuilder . length ( ) ) ; } } private StringBuilder mBuilder = new StringBuilder ( ) ; } private void checkRenderThreadState ( ) { if ( mGLThread ! = null ) { throw new IllegalStateException ( <str> ) ; } } private static class GLThreadManager { private static String TAG = <str> ; public synchronized void threadExiting ( GLThread thread ) { if ( LOG_THREADS ) { Log . i ( <str> , <str> + thread . getId ( ) ) ; } thread . mExited = true ; if ( mEglOwner = = thread ) { mEglOwner = null ; } notifyAll ( ) ; } public boolean tryAcquireEglContextLocked ( GLThread thread ) { if ( mEglOwner = = thread | | mEglOwner = = null ) { mEglOwner = thread ; notifyAll ( ) ; return true ; } checkGLESVersion ( ) ; if ( mMultipleGLESContextsAllowed ) { return true ; } if ( mEglOwner ! = null ) { mEglOwner . requestReleaseEglContextLocked ( ) ; } return false ; } public void releaseEglContextLocked ( GLThread thread ) { if ( mEglOwner = = thread ) { mEglOwner = null ; } notifyAll ( ) ; } public synchronized boolean shouldReleaseEGLContextWhenPausing ( ) { return mLimitedGLESContexts ; } public synchronized boolean shouldTerminateEGLWhenPausing ( ) { checkGLESVersion ( ) ; return ! mMultipleGLESContextsAllowed ; } public synchronized void checkGLDriver ( GL10 gl ) { if ( ! mGLESDriverCheckComplete ) { checkGLESVersion ( ) ; String renderer = gl . glGetString ( GL10 . GL_RENDERER ) ; if ( mGLESVersion < kGLES_20 ) { mMultipleGLESContextsAllowed = ! renderer . startsWith ( kMSM7K_RENDERER_PREFIX ) ; notifyAll ( ) ; } mLimitedGLESContexts = ! mMultipleGLESContextsAllowed ; if ( LOG_SURFACE ) { Log . w ( TAG , <str> + renderer + <str> + mMultipleGLESContextsAllowed + <str> + mLimitedGLESContexts ) ; } mGLESDriverCheckComplete = true ; } } private void checkGLESVersion ( ) { if ( ! mGLESVersionCheckComplete ) { mGLESVersion = kGLES_20 ; if ( mGLESVersion > = kGLES_20 ) { mMultipleGLESContextsAllowed = true ; } if ( LOG_SURFACE ) { Log . w ( TAG , <str> + <str> + mGLESVersion + <str> + mMultipleGLESContextsAllowed ) ; } mGLESVersionCheckComplete = true ; } } private boolean mGLESVersionCheckComplete ; private int mGLESVersion ; private boolean mGLESDriverCheckComplete ; private boolean mMultipleGLESContextsAllowed ; private boolean mLimitedGLESContexts ; private static final int kGLES_20 = <hex> ; private static final String kMSM7K_RENDERER_PREFIX = <str> ; private GLThread mEglOwner ; } private static final GLThreadManager sGLThreadManager = new GLThreadManager ( ) ; private final WeakReference < GLSurfaceViewAPI18 > mThisWeakRef = new WeakReference < GLSurfaceViewAPI18 > ( this ) ; private GLThread mGLThread ; private Renderer mRenderer ; private boolean mDetached ; private EGLConfigChooser mEGLConfigChooser ; private EGLContextFactory mEGLContextFactory ; private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory ; private GLWrapper mGLWrapper ; private int mDebugFlags ; private int mEGLContextClientVersion ; private boolean mPreserveEGLContextOnPause ; } 
