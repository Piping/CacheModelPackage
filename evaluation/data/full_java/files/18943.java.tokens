package io . netty . handler . codec . serialization ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufOutputStream ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . Attribute ; import io . netty . util . AttributeKey ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . OutputStream ; import java . io . Serializable ; public class CompatibleObjectEncoder extends MessageToByteEncoder < Serializable > { private static final AttributeKey < ObjectOutputStream > OOS = AttributeKey . valueOf ( CompatibleObjectEncoder . class , <str> ) ; private final int resetInterval ; private int writtenObjects ; public CompatibleObjectEncoder ( ) { this ( <int> ) ; } public CompatibleObjectEncoder ( int resetInterval ) { if ( resetInterval < <int> ) { throw new IllegalArgumentException ( <str> + resetInterval ) ; } this . resetInterval = resetInterval ; } protected ObjectOutputStream newObjectOutputStream ( OutputStream out ) throws Exception { return new ObjectOutputStream ( out ) ; } @Override protected void encode ( ChannelHandlerContext ctx , Serializable msg , ByteBuf out ) throws Exception { Attribute < ObjectOutputStream > oosAttr = ctx . attr ( OOS ) ; ObjectOutputStream oos = oosAttr . get ( ) ; if ( oos = = null ) { oos = newObjectOutputStream ( new ByteBufOutputStream ( out ) ) ; ObjectOutputStream newOos = oosAttr . setIfAbsent ( oos ) ; if ( newOos ! = null ) { oos = newOos ; } } synchronized ( oos ) { if ( resetInterval ! = <int> ) { writtenObjects + + ; if ( writtenObjects % resetInterval = = <int> ) { oos . reset ( ) ; } } oos . writeObject ( msg ) ; oos . flush ( ) ; } } } 
