package org . elasticsearch . index . query ; import org . apache . lucene . search . NumericRangeQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermRangeQuery ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . lucene . BytesRefs ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . index . query . QueryBuilders . rangeQuery ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class RangeQueryBuilderTests extends AbstractQueryTestCase < RangeQueryBuilder > { @Override protected RangeQueryBuilder doCreateTestQueryBuilder ( ) { RangeQueryBuilder query ; switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : query = new RangeQueryBuilder ( INT_FIELD_NAME ) ; query . from ( randomIntBetween ( <int> , <int> ) ) ; query . to ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : query = new RangeQueryBuilder ( DATE_FIELD_NAME ) ; query . from ( new DateTime ( System . currentTimeMillis ( ) - randomIntBetween ( <int> , <int> ) , DateTimeZone . UTC ) . toString ( ) ) ; query . to ( new DateTime ( System . currentTimeMillis ( ) + randomIntBetween ( <int> , <int> ) , DateTimeZone . UTC ) . toString ( ) ) ; if ( createShardContext ( ) . getMapperService ( ) . smartNameFieldType ( DATE_FIELD_NAME ) ! = null ) { if ( randomBoolean ( ) ) { query . timeZone ( randomTimeZone ( ) ) ; } if ( randomBoolean ( ) ) { query . format ( <str> ) ; } } break ; case <int> : default : query = new RangeQueryBuilder ( STRING_FIELD_NAME ) ; query . from ( <str> + randomAsciiOfLengthBetween ( <int> , <int> ) ) ; query . to ( <str> + randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; } query . includeLower ( randomBoolean ( ) ) . includeUpper ( randomBoolean ( ) ) ; if ( randomBoolean ( ) ) { query . from ( null ) ; } if ( randomBoolean ( ) ) { query . to ( null ) ; } return query ; } @Override protected Map < String , RangeQueryBuilder > getAlternateVersions ( ) { Map < String , RangeQueryBuilder > alternateVersions = new HashMap < > ( ) ; RangeQueryBuilder rangeQueryBuilder = new RangeQueryBuilder ( INT_FIELD_NAME ) ; rangeQueryBuilder . from ( randomIntBetween ( <int> , <int> ) ) . to ( randomIntBetween ( <int> , <int> ) ) ; rangeQueryBuilder . includeLower ( randomBoolean ( ) ) ; rangeQueryBuilder . includeUpper ( randomBoolean ( ) ) ; String query = <str> + <str> + <str> + INT_FIELD_NAME + <str> + <str> + ( rangeQueryBuilder . includeLower ( ) ? <str> : <str> ) + <str> + rangeQueryBuilder . from ( ) + <str> + <str> + ( rangeQueryBuilder . includeUpper ( ) ? <str> : <str> ) + <str> + rangeQueryBuilder . to ( ) + <str> + <str> + <str> + <str> ; alternateVersions . put ( query , rangeQueryBuilder ) ; return alternateVersions ; } @Override protected void doAssertLuceneQuery ( RangeQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( getCurrentTypes ( ) . length = = <int> | | ( queryBuilder . fieldName ( ) . equals ( DATE_FIELD_NAME ) = = false & & queryBuilder . fieldName ( ) . equals ( INT_FIELD_NAME ) = = false ) ) { assertThat ( query , instanceOf ( TermRangeQuery . class ) ) ; TermRangeQuery termRangeQuery = ( TermRangeQuery ) query ; assertThat ( termRangeQuery . getField ( ) , equalTo ( queryBuilder . fieldName ( ) ) ) ; assertThat ( termRangeQuery . getLowerTerm ( ) , equalTo ( BytesRefs . toBytesRef ( queryBuilder . from ( ) ) ) ) ; assertThat ( termRangeQuery . getUpperTerm ( ) , equalTo ( BytesRefs . toBytesRef ( queryBuilder . to ( ) ) ) ) ; assertThat ( termRangeQuery . includesLower ( ) , equalTo ( queryBuilder . includeLower ( ) ) ) ; assertThat ( termRangeQuery . includesUpper ( ) , equalTo ( queryBuilder . includeUpper ( ) ) ) ; } else if ( queryBuilder . fieldName ( ) . equals ( DATE_FIELD_NAME ) ) { } else if ( queryBuilder . fieldName ( ) . equals ( INT_FIELD_NAME ) ) { assertThat ( query , instanceOf ( NumericRangeQuery . class ) ) ; NumericRangeQuery numericRangeQuery = ( NumericRangeQuery ) query ; assertThat ( numericRangeQuery . getField ( ) , equalTo ( queryBuilder . fieldName ( ) ) ) ; assertThat ( numericRangeQuery . getMin ( ) , equalTo ( queryBuilder . from ( ) ) ) ; assertThat ( numericRangeQuery . getMax ( ) , equalTo ( queryBuilder . to ( ) ) ) ; assertThat ( numericRangeQuery . includesMin ( ) , equalTo ( queryBuilder . includeLower ( ) ) ) ; assertThat ( numericRangeQuery . includesMax ( ) , equalTo ( queryBuilder . includeUpper ( ) ) ) ; } else { throw new UnsupportedOperationException ( ) ; } } public void testIllegalArguments ( ) { try { if ( randomBoolean ( ) ) { new RangeQueryBuilder ( null ) ; } else { new RangeQueryBuilder ( <str> ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } RangeQueryBuilder rangeQueryBuilder = new RangeQueryBuilder ( <str> ) ; try { if ( randomBoolean ( ) ) { rangeQueryBuilder . timeZone ( null ) ; } else { rangeQueryBuilder . timeZone ( <str> ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { if ( randomBoolean ( ) ) { rangeQueryBuilder . format ( null ) ; } else { rangeQueryBuilder . format ( <str> ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testToQueryNonDateWithTimezone ( ) throws QueryShardException , IOException { RangeQueryBuilder query = new RangeQueryBuilder ( INT_FIELD_NAME ) ; query . from ( <int> ) . to ( <int> ) . timeZone ( <str> ) ; try { query . toQuery ( createShardContext ( ) ) ; fail ( <str> ) ; } catch ( QueryShardException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testToQueryUnmappedWithTimezone ( ) throws QueryShardException , IOException { RangeQueryBuilder query = new RangeQueryBuilder ( <str> ) ; query . from ( <int> ) . to ( <int> ) . timeZone ( <str> ) ; try { query . toQuery ( createShardContext ( ) ) ; fail ( <str> ) ; } catch ( QueryShardException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testToQueryNumericField ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query parsedQuery = rangeQuery ( INT_FIELD_NAME ) . from ( <int> ) . to ( <int> ) . includeLower ( true ) . includeUpper ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( parsedQuery , instanceOf ( NumericRangeQuery . class ) ) ; NumericRangeQuery rangeQuery = ( NumericRangeQuery ) parsedQuery ; assertThat ( rangeQuery . getField ( ) , equalTo ( INT_FIELD_NAME ) ) ; assertThat ( rangeQuery . getMin ( ) . intValue ( ) , equalTo ( <int> ) ) ; assertThat ( rangeQuery . getMax ( ) . intValue ( ) , equalTo ( <int> ) ) ; assertThat ( rangeQuery . includesMin ( ) , equalTo ( true ) ) ; assertThat ( rangeQuery . includesMax ( ) , equalTo ( false ) ) ; } public void testDateRangeQueryFormat ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; Query parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) . rewrite ( null ) ; assertThat ( parsedQuery , instanceOf ( NumericRangeQuery . class ) ) ; DateTime min = DateTime . parse ( <str> ) ; assertThat ( ( ( NumericRangeQuery ) parsedQuery ) . getMin ( ) . longValue ( ) , is ( min . getMillis ( ) ) ) ; DateTime max = DateTime . parse ( <str> ) ; assertThat ( ( ( NumericRangeQuery ) parsedQuery ) . getMax ( ) . longValue ( ) , is ( max . getMillis ( ) ) ) ; query = <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; try { parseQuery ( query ) . toQuery ( createShardContext ( ) ) . rewrite ( null ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { } } public void testDateRangeBoundaries ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String query = <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; Query parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) . rewrite ( null ) ; assertThat ( parsedQuery , instanceOf ( NumericRangeQuery . class ) ) ; NumericRangeQuery rangeQuery = ( NumericRangeQuery ) parsedQuery ; DateTime min = DateTime . parse ( <str> ) ; assertThat ( rangeQuery . getMin ( ) . longValue ( ) , is ( min . getMillis ( ) ) ) ; assertTrue ( rangeQuery . includesMin ( ) ) ; DateTime max = DateTime . parse ( <str> ) ; assertThat ( rangeQuery . getMax ( ) . longValue ( ) , is ( max . getMillis ( ) ) ) ; assertTrue ( rangeQuery . includesMax ( ) ) ; query = <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> ; parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) . rewrite ( null ) ; assertThat ( parsedQuery , instanceOf ( NumericRangeQuery . class ) ) ; rangeQuery = ( NumericRangeQuery ) parsedQuery ; min = DateTime . parse ( <str> ) ; assertThat ( rangeQuery . getMin ( ) . longValue ( ) , is ( min . getMillis ( ) ) ) ; assertFalse ( rangeQuery . includesMin ( ) ) ; max = DateTime . parse ( <str> ) ; assertThat ( rangeQuery . getMax ( ) . longValue ( ) , is ( max . getMillis ( ) ) ) ; assertFalse ( rangeQuery . includesMax ( ) ) ; } public void testDateRangeQueryTimezone ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; long startDate = System . currentTimeMillis ( ) ; String query = <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; Query parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) . rewrite ( null ) ; assertThat ( parsedQuery , instanceOf ( NumericRangeQuery . class ) ) ; DateTime min = DateTime . parse ( <str> ) ; DateTime max = new DateTime ( startDate , DateTimeZone . UTC ) ; assertThat ( ( ( NumericRangeQuery ) parsedQuery ) . getMin ( ) . longValue ( ) , is ( min . getMillis ( ) ) ) ; assertThat ( ( ( NumericRangeQuery ) parsedQuery ) . getMax ( ) . longValue ( ) - max . getMillis ( ) , lessThanOrEqualTo ( <int> ) ) ; query = <str> + <str> + <str> + INT_FIELD_NAME + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; try { parseQuery ( query ) . toQuery ( createShardContext ( ) ) ; fail ( <str> ) ; } catch ( QueryShardException e ) { } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; RangeQueryBuilder parsed = ( RangeQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . from ( ) ) ; assertEquals ( json , <str> , parsed . to ( ) ) ; } } 
