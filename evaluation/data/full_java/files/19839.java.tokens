package io . netty . example . http2 . helloworld . server ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . SocketChannel ; import io . netty . handler . codec . http . HttpMessage ; import io . netty . handler . codec . http . HttpObjectAggregator ; import io . netty . handler . codec . http . HttpServerCodec ; import io . netty . handler . codec . http . HttpServerUpgradeHandler ; import io . netty . handler . codec . http . HttpServerUpgradeHandler . UpgradeCodec ; import io . netty . handler . codec . http . HttpServerUpgradeHandler . UpgradeCodecFactory ; import io . netty . handler . codec . http2 . Http2CodecUtil ; import io . netty . handler . codec . http2 . Http2ServerUpgradeCodec ; import io . netty . handler . ssl . SslContext ; import io . netty . util . AsciiString ; public class Http2ServerInitializer extends ChannelInitializer < SocketChannel > { private static final UpgradeCodecFactory upgradeCodecFactory = new UpgradeCodecFactory ( ) { @Override public UpgradeCodec newUpgradeCodec ( CharSequence protocol ) { if ( AsciiString . contentEquals ( Http2CodecUtil . HTTP_UPGRADE_PROTOCOL_NAME , protocol ) ) { return new Http2ServerUpgradeCodec ( new HelloWorldHttp2Handler . Builder ( ) . build ( ) ) ; } else { return null ; } } } ; private final SslContext sslCtx ; private final int maxHttpContentLength ; public Http2ServerInitializer ( SslContext sslCtx ) { this ( sslCtx , <int> * <int> ) ; } public Http2ServerInitializer ( SslContext sslCtx , int maxHttpContentLength ) { if ( maxHttpContentLength < <int> ) { throw new IllegalArgumentException ( <str> + maxHttpContentLength ) ; } this . sslCtx = sslCtx ; this . maxHttpContentLength = maxHttpContentLength ; } @Override public void initChannel ( SocketChannel ch ) { if ( sslCtx ! = null ) { configureSsl ( ch ) ; } else { configureClearText ( ch ) ; } } private void configureSsl ( SocketChannel ch ) { ch . pipeline ( ) . addLast ( sslCtx . newHandler ( ch . alloc ( ) ) , new Http2OrHttpHandler ( ) ) ; } private void configureClearText ( SocketChannel ch ) { final ChannelPipeline p = ch . pipeline ( ) ; final HttpServerCodec sourceCodec = new HttpServerCodec ( ) ; p . addLast ( sourceCodec ) ; p . addLast ( new HttpServerUpgradeHandler ( sourceCodec , upgradeCodecFactory ) ) ; p . addLast ( new SimpleChannelInboundHandler < HttpMessage > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , HttpMessage msg ) throws Exception { System . err . println ( <str> + msg . protocolVersion ( ) + <str> ) ; ChannelPipeline pipeline = ctx . pipeline ( ) ; ChannelHandlerContext thisCtx = pipeline . context ( this ) ; pipeline . addAfter ( thisCtx . name ( ) , null , new HelloWorldHttp1Handler ( <str> ) ) ; pipeline . replace ( this , null , new HttpObjectAggregator ( maxHttpContentLength ) ) ; ctx . fireChannelRead ( msg ) ; } } ) ; p . addLast ( new UserEventLogger ( ) ) ; } private static class UserEventLogger extends ChannelInboundHandlerAdapter { @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) { System . out . println ( <str> + evt ) ; ctx . fireUserEventTriggered ( evt ) ; } } } 
