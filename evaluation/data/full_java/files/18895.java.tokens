package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseNotifier ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . internal . OneTimeTask ; import java . util . concurrent . TimeUnit ; import java . util . zip . CRC32 ; import java . util . zip . Deflater ; public class JdkZlibEncoder extends ZlibEncoder { private final ZlibWrapper wrapper ; private final Deflater deflater ; private volatile boolean finished ; private volatile ChannelHandlerContext ctx ; private final CRC32 crc = new CRC32 ( ) ; private static final byte [ ] gzipHeader = { <hex> , ( byte ) <hex> , Deflater . DEFLATED , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; private boolean writeHeader = true ; public JdkZlibEncoder ( ) { this ( <int> ) ; } public JdkZlibEncoder ( int compressionLevel ) { this ( ZlibWrapper . ZLIB , compressionLevel ) ; } public JdkZlibEncoder ( ZlibWrapper wrapper ) { this ( wrapper , <int> ) ; } public JdkZlibEncoder ( ZlibWrapper wrapper , int compressionLevel ) { if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( wrapper = = null ) { throw new NullPointerException ( <str> ) ; } if ( wrapper = = ZlibWrapper . ZLIB_OR_NONE ) { throw new IllegalArgumentException ( <str> + ZlibWrapper . ZLIB_OR_NONE + <str> + <str> ) ; } this . wrapper = wrapper ; deflater = new Deflater ( compressionLevel , wrapper ! = ZlibWrapper . ZLIB ) ; } public JdkZlibEncoder ( byte [ ] dictionary ) { this ( <int> , dictionary ) ; } public JdkZlibEncoder ( int compressionLevel , byte [ ] dictionary ) { if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( dictionary = = null ) { throw new NullPointerException ( <str> ) ; } wrapper = ZlibWrapper . ZLIB ; deflater = new Deflater ( compressionLevel ) ; deflater . setDictionary ( dictionary ) ; } @Override public ChannelFuture close ( ) { return close ( ctx ( ) . newPromise ( ) ) ; } @Override public ChannelFuture close ( final ChannelPromise promise ) { ChannelHandlerContext ctx = ctx ( ) ; EventExecutor executor = ctx . executor ( ) ; if ( executor . inEventLoop ( ) ) { return finishEncode ( ctx , promise ) ; } else { final ChannelPromise p = ctx . newPromise ( ) ; executor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelFuture f = finishEncode ( ctx ( ) , p ) ; f . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } ) ; return p ; } } private ChannelHandlerContext ctx ( ) { ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( <str> ) ; } return ctx ; } @Override public boolean isClosed ( ) { return finished ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf uncompressed , ByteBuf out ) throws Exception { if ( finished ) { out . writeBytes ( uncompressed ) ; return ; } int len = uncompressed . readableBytes ( ) ; if ( len = = <int> ) { return ; } int offset ; byte [ ] inAry ; if ( uncompressed . hasArray ( ) ) { inAry = uncompressed . array ( ) ; offset = uncompressed . arrayOffset ( ) + uncompressed . readerIndex ( ) ; uncompressed . skipBytes ( len ) ; } else { inAry = new byte [ len ] ; uncompressed . readBytes ( inAry ) ; offset = <int> ; } if ( writeHeader ) { writeHeader = false ; if ( wrapper = = ZlibWrapper . GZIP ) { out . writeBytes ( gzipHeader ) ; } } if ( wrapper = = ZlibWrapper . GZIP ) { crc . update ( inAry , offset , len ) ; } deflater . setInput ( inAry , offset , len ) ; while ( ! deflater . needsInput ( ) ) { deflate ( out ) ; } } @Override protected final ByteBuf allocateBuffer ( ChannelHandlerContext ctx , ByteBuf msg , boolean preferDirect ) throws Exception { int sizeEstimate = ( int ) Math . ceil ( msg . readableBytes ( ) * <float> ) + <int> ; if ( writeHeader ) { switch ( wrapper ) { case GZIP : sizeEstimate + = gzipHeader . length ; break ; case ZLIB : sizeEstimate + = <int> ; break ; } } return ctx . alloc ( ) . heapBuffer ( sizeEstimate ) ; } @Override public void close ( final ChannelHandlerContext ctx , final ChannelPromise promise ) throws Exception { ChannelFuture f = finishEncode ( ctx , ctx . newPromise ( ) ) ; f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture f ) throws Exception { ctx . close ( promise ) ; } } ) ; if ( ! f . isDone ( ) ) { ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { ctx . close ( promise ) ; } } , <int> , TimeUnit . SECONDS ) ; } } private ChannelFuture finishEncode ( final ChannelHandlerContext ctx , ChannelPromise promise ) { if ( finished ) { promise . setSuccess ( ) ; return promise ; } finished = true ; ByteBuf footer = ctx . alloc ( ) . heapBuffer ( ) ; if ( writeHeader & & wrapper = = ZlibWrapper . GZIP ) { writeHeader = false ; footer . writeBytes ( gzipHeader ) ; } deflater . finish ( ) ; while ( ! deflater . finished ( ) ) { deflate ( footer ) ; if ( ! footer . isWritable ( ) ) { ctx . write ( footer ) ; footer = ctx . alloc ( ) . heapBuffer ( ) ; } } if ( wrapper = = ZlibWrapper . GZIP ) { int crcValue = ( int ) crc . getValue ( ) ; int uncBytes = deflater . getTotalIn ( ) ; footer . writeByte ( crcValue ) ; footer . writeByte ( crcValue > > > <int> ) ; footer . writeByte ( crcValue > > > <int> ) ; footer . writeByte ( crcValue > > > <int> ) ; footer . writeByte ( uncBytes ) ; footer . writeByte ( uncBytes > > > <int> ) ; footer . writeByte ( uncBytes > > > <int> ) ; footer . writeByte ( uncBytes > > > <int> ) ; } deflater . end ( ) ; return ctx . writeAndFlush ( footer , promise ) ; } private void deflate ( ByteBuf out ) { int numBytes ; do { int writerIndex = out . writerIndex ( ) ; numBytes = deflater . deflate ( out . array ( ) , out . arrayOffset ( ) + writerIndex , out . writableBytes ( ) , Deflater . SYNC_FLUSH ) ; out . writerIndex ( writerIndex + numBytes ) ; } while ( numBytes > <int> ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; } } 
