package org . apache . cassandra . tools . nodetool ; import static java . lang . String . format ; import io . airlift . command . Arguments ; import io . airlift . command . Command ; import io . airlift . command . Option ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; import com . google . common . collect . LinkedHashMultimap ; @Command ( name = <str> , description = <str> ) public class Ring extends NodeToolCmd { @Arguments ( description = <str> ) private String keyspace = null ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean resolveIp = false ; @Override public void execute ( NodeProbe probe ) { Map < String , String > tokensToEndpoints = probe . getTokenToEndpointMap ( ) ; LinkedHashMultimap < String , String > endpointsToTokens = LinkedHashMultimap . create ( ) ; boolean haveVnodes = false ; for ( Map . Entry < String , String > entry : tokensToEndpoints . entrySet ( ) ) { haveVnodes | = endpointsToTokens . containsKey ( entry . getValue ( ) ) ; endpointsToTokens . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } int maxAddressLength = Collections . max ( endpointsToTokens . keys ( ) , new Comparator < String > ( ) { @Override public int compare ( String first , String second ) { return Integer . compare ( first . length ( ) , second . length ( ) ) ; } } ) . length ( ) ; String formatPlaceholder = <str> ; String format = format ( formatPlaceholder , maxAddressLength ) ; StringBuffer errors = new StringBuffer ( ) ; boolean showEffectiveOwnership = true ; Map < InetAddress , Float > ownerships ; try { ownerships = probe . effectiveOwnership ( keyspace ) ; } catch ( IllegalStateException ex ) { ownerships = probe . getOwnership ( ) ; errors . append ( <str> + ex . getMessage ( ) + <str> ) ; showEffectiveOwnership = false ; } catch ( IllegalArgumentException ex ) { System . out . printf ( <str> + ex . getMessage ( ) + <str> ) ; return ; } System . out . println ( ) ; for ( Entry < String , SetHostStat > entry : NodeTool . getOwnershipByDc ( probe , resolveIp , tokensToEndpoints , ownerships ) . entrySet ( ) ) printDc ( probe , format , entry . getKey ( ) , endpointsToTokens , entry . getValue ( ) , showEffectiveOwnership ) ; if ( haveVnodes ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; } System . out . printf ( <str> + errors . toString ( ) ) ; } private void printDc ( NodeProbe probe , String format , String dc , LinkedHashMultimap < String , String > endpointsToTokens , SetHostStat hoststats , boolean showEffectiveOwnership ) { Collection < String > liveNodes = probe . getLiveNodes ( ) ; Collection < String > deadNodes = probe . getUnreachableNodes ( ) ; Collection < String > joiningNodes = probe . getJoiningNodes ( ) ; Collection < String > leavingNodes = probe . getLeavingNodes ( ) ; Collection < String > movingNodes = probe . getMovingNodes ( ) ; Map < String , String > loadMap = probe . getLoadMap ( ) ; System . out . println ( <str> + dc ) ; System . out . println ( <str> ) ; List < String > tokens = new ArrayList < > ( ) ; String lastToken = <str> ; for ( HostStat stat : hoststats ) { tokens . addAll ( endpointsToTokens . get ( stat . endpoint . getHostAddress ( ) ) ) ; lastToken = tokens . get ( tokens . size ( ) - <int> ) ; } System . out . printf ( format , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; if ( hoststats . size ( ) > <int> ) System . out . printf ( format , <str> , <str> , <str> , <str> , <str> , <str> , lastToken ) ; else System . out . println ( ) ; for ( HostStat stat : hoststats ) { String endpoint = stat . endpoint . getHostAddress ( ) ; String rack ; try { rack = probe . getEndpointSnitchInfoProxy ( ) . getRack ( endpoint ) ; } catch ( UnknownHostException e ) { rack = <str> ; } String status = liveNodes . contains ( endpoint ) ? <str> : deadNodes . contains ( endpoint ) ? <str> : <str> ; String state = <str> ; if ( joiningNodes . contains ( endpoint ) ) state = <str> ; else if ( leavingNodes . contains ( endpoint ) ) state = <str> ; else if ( movingNodes . contains ( endpoint ) ) state = <str> ; String load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : <str> ; String owns = stat . owns ! = null & & showEffectiveOwnership ? new DecimalFormat ( <str> ) . format ( stat . owns ) : <str> ; System . out . printf ( format , stat . ipOrDns ( ) , rack , status , state , load , owns , stat . token ) ; } System . out . println ( ) ; } } 
