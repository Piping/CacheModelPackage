package com . badlogic . gdx . tools . hiero . unicodefont . effects ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Shape ; import java . awt . Stroke ; import java . awt . geom . FlatteningPathIterator ; import java . awt . geom . GeneralPath ; import java . awt . geom . PathIterator ; import java . util . Iterator ; import java . util . List ; public class OutlineWobbleEffect extends OutlineEffect { float detail = <int> ; float amplitude = <int> ; public OutlineWobbleEffect ( ) { setStroke ( new WobbleStroke ( ) ) ; } public OutlineWobbleEffect ( int width , Color color ) { super ( width , color ) ; } public String toString ( ) { return <str> ; } public List getValues ( ) { List values = super . getValues ( ) ; values . remove ( <int> ) ; values . add ( EffectUtil . floatValue ( <str> , detail , <int> , <int> , <str> + <str> ) ) ; values . add ( EffectUtil . floatValue ( <str> , amplitude , <float> , <int> , <str> ) ) ; return values ; } public void setValues ( List values ) { super . setValues ( values ) ; for ( Iterator iter = values . iterator ( ) ; iter . hasNext ( ) ; ) { Value value = ( Value ) iter . next ( ) ; if ( value . getName ( ) . equals ( <str> ) ) { detail = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { amplitude = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } } } class WobbleStroke implements Stroke { private static final float FLATNESS = <int> ; public Shape createStrokedShape ( Shape shape ) { GeneralPath result = new GeneralPath ( ) ; shape = new BasicStroke ( getWidth ( ) , BasicStroke . CAP_SQUARE , getJoin ( ) ) . createStrokedShape ( shape ) ; PathIterator it = new FlatteningPathIterator ( shape . getPathIterator ( null ) , FLATNESS ) ; float points [ ] = new float [ <int> ] ; float moveX = <int> , moveY = <int> ; float lastX = <int> , lastY = <int> ; float thisX = <int> , thisY = <int> ; int type = <int> ; float next = <int> ; while ( ! it . isDone ( ) ) { type = it . currentSegment ( points ) ; switch ( type ) { case PathIterator . SEG_MOVETO : moveX = lastX = randomize ( points [ <int> ] ) ; moveY = lastY = randomize ( points [ <int> ] ) ; result . moveTo ( moveX , moveY ) ; next = <int> ; break ; case PathIterator . SEG_CLOSE : points [ <int> ] = moveX ; points [ <int> ] = moveY ; case PathIterator . SEG_LINETO : thisX = randomize ( points [ <int> ] ) ; thisY = randomize ( points [ <int> ] ) ; float dx = thisX - lastX ; float dy = thisY - lastY ; float distance = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; if ( distance > = next ) { float r = <float> / distance ; while ( distance > = next ) { float x = lastX + next * dx * r ; float y = lastY + next * dy * r ; result . lineTo ( randomize ( x ) , randomize ( y ) ) ; next + = detail ; } } next - = distance ; lastX = thisX ; lastY = thisY ; break ; } it . next ( ) ; } return result ; } private float randomize ( float x ) { return x + ( float ) Math . random ( ) * amplitude * <int> - <int> ; } } } 
