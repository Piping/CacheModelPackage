package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram . Bucket ; import org . elasticsearch . search . aggregations . metrics . stats . Stats ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . derivative . Derivative ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . filters ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . stats ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . derivative ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; @ESIntegTestCase.SuiteScopeTestCase public class DerivativeIT extends ESIntegTestCase { private static final String SINGLE_VALUED_FIELD_NAME = <str> ; private static int interval ; private static int numValueBuckets ; private static int numFirstDerivValueBuckets ; private static int numSecondDerivValueBuckets ; private static long [ ] valueCounts ; private static long [ ] firstDerivValueCounts ; private static long [ ] secondDerivValueCounts ; private static Long [ ] valueCounts_empty ; private static long numDocsEmptyIdx ; private static Double [ ] firstDerivValueCounts_empty ; private static int numBuckets_empty_rnd ; private static Long [ ] valueCounts_empty_rnd ; private static Double [ ] firstDerivValueCounts_empty_rnd ; private static long numDocsEmptyIdx_rnd ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; interval = <int> ; numValueBuckets = randomIntBetween ( <int> , <int> ) ; valueCounts = new long [ numValueBuckets ] ; for ( int i = <int> ; i < numValueBuckets ; i + + ) { valueCounts [ i ] = randomIntBetween ( <int> , <int> ) ; } numFirstDerivValueBuckets = numValueBuckets - <int> ; firstDerivValueCounts = new long [ numFirstDerivValueBuckets ] ; Long lastValueCount = null ; for ( int i = <int> ; i < numValueBuckets ; i + + ) { long thisValue = valueCounts [ i ] ; if ( lastValueCount ! = null ) { long diff = thisValue - lastValueCount ; firstDerivValueCounts [ i - <int> ] = diff ; } lastValueCount = thisValue ; } numSecondDerivValueBuckets = numFirstDerivValueBuckets - <int> ; secondDerivValueCounts = new long [ numSecondDerivValueBuckets ] ; Long lastFirstDerivativeValueCount = null ; for ( int i = <int> ; i < numFirstDerivValueBuckets ; i + + ) { long thisFirstDerivativeValue = firstDerivValueCounts [ i ] ; if ( lastFirstDerivativeValueCount ! = null ) { long diff = thisFirstDerivativeValue - lastFirstDerivativeValueCount ; secondDerivValueCounts [ i - <int> ] = diff ; } lastFirstDerivativeValueCount = thisFirstDerivativeValue ; } List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numValueBuckets ; i + + ) { for ( int docs = <int> ; docs < valueCounts [ i ] ; docs + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( newDocBuilder ( i * interval ) ) ) ; } } valueCounts_empty = new Long [ ] { <int> , <int> , <int> , <int> l , <int> , <int> , <int> l , <int> l , <int> l , <int> , <int> , <int> } ; firstDerivValueCounts_empty = new Double [ ] { null , <float> , <float> , - <float> , <float> , <float> , - <float> , <float> , <float> , <float> , - <float> , - <float> } ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; for ( int i = <int> ; i < valueCounts_empty . length ; i + + ) { for ( int docs = <int> ; docs < valueCounts_empty [ i ] ; docs + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( newDocBuilder ( i ) ) ) ; numDocsEmptyIdx + + ; } } numBuckets_empty_rnd = randomIntBetween ( <int> , <int> ) ; valueCounts_empty_rnd = new Long [ numBuckets_empty_rnd ] ; firstDerivValueCounts_empty_rnd = new Double [ numBuckets_empty_rnd ] ; firstDerivValueCounts_empty_rnd [ <int> ] = null ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; for ( int i = <int> ; i < numBuckets_empty_rnd ; i + + ) { valueCounts_empty_rnd [ i ] = ( long ) randomIntBetween ( <int> , <int> ) ; if ( randomBoolean ( ) ) valueCounts_empty_rnd [ i ] = <int> l ; for ( int docs = <int> ; docs < valueCounts_empty_rnd [ i ] ; docs + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( newDocBuilder ( i ) ) ) ; numDocsEmptyIdx_rnd + + ; } if ( i > <int> ) { firstDerivValueCounts_empty_rnd [ i ] = ( double ) valueCounts_empty_rnd [ i ] - valueCounts_empty_rnd [ i - <int> ] ; } } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } private XContentBuilder newDocBuilder ( int singleValueFieldValue ) throws IOException { return jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , singleValueFieldValue ) . endObject ( ) ; } public void testDocCountDerivative ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i * interval , valueCounts [ i ] ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( ( double ) firstDerivValueCounts [ i - <int> ] ) ) ; } else { assertThat ( docCountDeriv , nullValue ( ) ) ; } SimpleValue docCount2ndDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( docCount2ndDeriv , notNullValue ( ) ) ; assertThat ( docCount2ndDeriv . value ( ) , equalTo ( ( double ) secondDerivValueCounts [ i - <int> ] ) ) ; } else { assertThat ( docCount2ndDeriv , nullValue ( ) ) ; } } } public void testSingleValuedField_normalised ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . unit ( <str> ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . unit ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i * interval , valueCounts [ i ] ) ; Derivative docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , closeTo ( ( firstDerivValueCounts [ i - <int> ] ) , <float> ) ) ; assertThat ( docCountDeriv . normalizedValue ( ) , closeTo ( ( double ) ( firstDerivValueCounts [ i - <int> ] ) / <int> , <float> ) ) ; } else { assertThat ( docCountDeriv , nullValue ( ) ) ; } Derivative docCount2ndDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( docCount2ndDeriv , notNullValue ( ) ) ; assertThat ( docCount2ndDeriv . value ( ) , closeTo ( ( secondDerivValueCounts [ i - <int> ] ) , <float> ) ) ; assertThat ( docCount2ndDeriv . normalizedValue ( ) , closeTo ( ( double ) ( secondDerivValueCounts [ i - <int> ] ) * <int> , <float> ) ) ; } else { assertThat ( docCount2ndDeriv , nullValue ( ) ) ; } } } public void testSingleValueAggDerivative ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) deriv . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) deriv . getProperty ( <str> ) ; Object [ ] propertiesSumCounts = ( Object [ ] ) deriv . getProperty ( <str> ) ; List < Bucket > buckets = new ArrayList < Bucket > ( deriv . getBuckets ( ) ) ; Long expectedSumPreviousBucket = Long . MIN_VALUE ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i * interval , valueCounts [ i ] ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long expectedSum = valueCounts [ i ] * ( i * interval ) ; assertThat ( sum . getValue ( ) , equalTo ( ( double ) expectedSum ) ) ; SimpleValue sumDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( sumDeriv , notNullValue ( ) ) ; long sumDerivValue = expectedSum - expectedSumPreviousBucket ; assertThat ( sumDeriv . value ( ) , equalTo ( ( double ) sumDerivValue ) ) ; assertThat ( ( double ) bucket . getProperty ( <str> , AggregationPath . parse ( <str> ) . getPathElementsAsStringList ( ) ) , equalTo ( ( double ) sumDerivValue ) ) ; } else { assertThat ( sumDeriv , nullValue ( ) ) ; } expectedSumPreviousBucket = expectedSum ; assertThat ( ( long ) propertiesKeys [ i ] , equalTo ( ( long ) i * interval ) ) ; assertThat ( ( long ) propertiesDocCounts [ i ] , equalTo ( valueCounts [ i ] ) ) ; assertThat ( ( double ) propertiesSumCounts [ i ] , equalTo ( ( double ) expectedSum ) ) ; } } public void testMultiValueAggDerivative ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( stats ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) deriv . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) deriv . getProperty ( <str> ) ; Object [ ] propertiesSumCounts = ( Object [ ] ) deriv . getProperty ( <str> ) ; List < Bucket > buckets = new ArrayList < Bucket > ( deriv . getBuckets ( ) ) ; Long expectedSumPreviousBucket = Long . MIN_VALUE ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i * interval , valueCounts [ i ] ) ; Stats stats = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( stats , notNullValue ( ) ) ; long expectedSum = valueCounts [ i ] * ( i * interval ) ; assertThat ( stats . getSum ( ) , equalTo ( ( double ) expectedSum ) ) ; SimpleValue sumDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( sumDeriv , notNullValue ( ) ) ; long sumDerivValue = expectedSum - expectedSumPreviousBucket ; assertThat ( sumDeriv . value ( ) , equalTo ( ( double ) sumDerivValue ) ) ; assertThat ( ( double ) bucket . getProperty ( <str> , AggregationPath . parse ( <str> ) . getPathElementsAsStringList ( ) ) , equalTo ( ( double ) sumDerivValue ) ) ; } else { assertThat ( sumDeriv , nullValue ( ) ) ; } expectedSumPreviousBucket = expectedSum ; assertThat ( ( long ) propertiesKeys [ i ] , equalTo ( ( long ) i * interval ) ) ; assertThat ( ( long ) propertiesDocCounts [ i ] , equalTo ( valueCounts [ i ] ) ) ; assertThat ( ( double ) propertiesSumCounts [ i ] , equalTo ( ( double ) expectedSum ) ) ; } } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testPartiallyUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i * interval , valueCounts [ i ] ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i > <int> ) { assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( ( double ) firstDerivValueCounts [ i - <int> ] ) ) ; } else { assertThat ( docCountDeriv , nullValue ( ) ) ; } } } public void testDocCountDerivativeWithGaps ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( valueCounts_empty . length ) ) ; for ( int i = <int> ; i < valueCounts_empty . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i , valueCounts_empty [ i ] ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( firstDerivValueCounts_empty [ i ] = = null ) { assertThat ( docCountDeriv , nullValue ( ) ) ; } else { assertThat ( docCountDeriv . value ( ) , equalTo ( firstDerivValueCounts_empty [ i ] ) ) ; } } } public void testDocCountDerivativeWithGaps_random ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . extendedBounds ( <int> l , ( long ) numBuckets_empty_rnd - <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( randomFrom ( GapPolicy . values ( ) ) ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx_rnd ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numBuckets_empty_rnd ) ) ; for ( int i = <int> ; i < valueCounts_empty_rnd . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i , valueCounts_empty_rnd [ i ] ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( firstDerivValueCounts_empty_rnd [ i ] = = null ) { assertThat ( docCountDeriv , nullValue ( ) ) ; } else { assertThat ( docCountDeriv . value ( ) , equalTo ( firstDerivValueCounts_empty_rnd [ i ] ) ) ; } } } public void testDocCountDerivativeWithGaps_insertZeros ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( GapPolicy . INSERT_ZEROS ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( valueCounts_empty . length ) ) ; for ( int i = <int> ; i < valueCounts_empty . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i + <str> , bucket , i , valueCounts_empty [ i ] ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( firstDerivValueCounts_empty [ i ] = = null ) { assertThat ( docCountDeriv , nullValue ( ) ) ; } else { assertThat ( docCountDeriv . value ( ) , equalTo ( firstDerivValueCounts_empty [ i ] ) ) ; } } } public void testSingleValueAggDerivativeWithGaps ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( valueCounts_empty . length ) ) ; double lastSumValue = Double . NaN ; for ( int i = <int> ; i < valueCounts_empty . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i , valueCounts_empty [ i ] ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; double thisSumValue = sum . value ( ) ; if ( bucket . getDocCount ( ) = = <int> ) { thisSumValue = Double . NaN ; } SimpleValue sumDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i = = <int> ) { assertThat ( sumDeriv , nullValue ( ) ) ; } else { double expectedDerivative = thisSumValue - lastSumValue ; if ( Double . isNaN ( expectedDerivative ) ) { assertThat ( sumDeriv . value ( ) , equalTo ( expectedDerivative ) ) ; } else { assertThat ( sumDeriv . value ( ) , closeTo ( expectedDerivative , <float> ) ) ; } } lastSumValue = thisSumValue ; } } public void testSingleValueAggDerivativeWithGaps_insertZeros ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( GapPolicy . INSERT_ZEROS ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( valueCounts_empty . length ) ) ; double lastSumValue = Double . NaN ; for ( int i = <int> ; i < valueCounts_empty . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i , valueCounts_empty [ i ] ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; double thisSumValue = sum . value ( ) ; if ( bucket . getDocCount ( ) = = <int> ) { thisSumValue = <int> ; } SimpleValue sumDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i = = <int> ) { assertThat ( sumDeriv , nullValue ( ) ) ; } else { double expectedDerivative = thisSumValue - lastSumValue ; assertThat ( sumDeriv . value ( ) , closeTo ( expectedDerivative , <float> ) ) ; } lastSumValue = thisSumValue ; } } public void testSingleValueAggDerivativeWithGaps_random ( ) throws Exception { GapPolicy gapPolicy = randomFrom ( GapPolicy . values ( ) ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . extendedBounds ( <int> l , ( long ) numBuckets_empty_rnd - <int> ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( gapPolicy ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocsEmptyIdx_rnd ) ) ; InternalHistogram < Bucket > deriv = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , Matchers . notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numBuckets_empty_rnd ) ) ; double lastSumValue = Double . NaN ; for ( int i = <int> ; i < valueCounts_empty_rnd . length ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; checkBucketKeyAndDocCount ( <str> + i , bucket , i , valueCounts_empty_rnd [ i ] ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; double thisSumValue = sum . value ( ) ; if ( bucket . getDocCount ( ) = = <int> ) { thisSumValue = gapPolicy = = GapPolicy . INSERT_ZEROS ? <int> : Double . NaN ; } SimpleValue sumDeriv = bucket . getAggregations ( ) . get ( <str> ) ; if ( i = = <int> ) { assertThat ( sumDeriv , nullValue ( ) ) ; } else { double expectedDerivative = thisSumValue - lastSumValue ; if ( Double . isNaN ( expectedDerivative ) ) { assertThat ( sumDeriv . value ( ) , equalTo ( expectedDerivative ) ) ; } else { assertThat ( sumDeriv . value ( ) , closeTo ( expectedDerivative , <float> ) ) ; } } lastSumValue = thisSumValue ; } } public void testSingleValueAggDerivative_invalidPath ( ) throws Exception { try { client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( filters ( <str> ) . filter ( QueryBuilders . termQuery ( <str> , <str> ) ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { Throwable cause = ExceptionsHelper . unwrapCause ( e ) ; if ( cause = = null ) { throw e ; } else if ( cause instanceof SearchPhaseExecutionException ) { ElasticsearchException [ ] rootCauses = ( ( SearchPhaseExecutionException ) cause ) . guessRootCauses ( ) ; if ( rootCauses . length > <int> ) { throw e ; } ElasticsearchException rootCauseWrapper = rootCauses [ <int> ] ; Throwable rootCause = rootCauseWrapper . getCause ( ) ; if ( rootCause = = null | | ! ( rootCause instanceof IllegalArgumentException ) ) { throw e ; } } else { throw e ; } } } private void checkBucketKeyAndDocCount ( final String msg , final Histogram . Bucket bucket , final long expectedKey , final long expectedDocCount ) { assertThat ( msg , bucket , notNullValue ( ) ) ; assertThat ( msg + <str> , ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( expectedKey ) ) ; assertThat ( msg + <str> , bucket . getDocCount ( ) , equalTo ( expectedDocCount ) ) ; } } 
