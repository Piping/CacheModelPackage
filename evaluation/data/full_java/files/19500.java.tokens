package io . netty . handler . codec . socks ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socks . SocksInitRequestDecoder . State ; import java . util . ArrayList ; import java . util . List ; public class SocksInitRequestDecoder extends ReplayingDecoder < State > { private final List < SocksAuthScheme > authSchemes = new ArrayList < SocksAuthScheme > ( ) ; private SocksProtocolVersion version ; private byte authSchemeNum ; private SocksRequest msg = SocksCommonUtils . UNKNOWN_SOCKS_REQUEST ; public SocksInitRequestDecoder ( ) { super ( State . CHECK_PROTOCOL_VERSION ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf byteBuf , List < Object > out ) throws Exception { switch ( state ( ) ) { case CHECK_PROTOCOL_VERSION : { version = SocksProtocolVersion . valueOf ( byteBuf . readByte ( ) ) ; if ( version ! = SocksProtocolVersion . SOCKS5 ) { break ; } checkpoint ( State . READ_AUTH_SCHEMES ) ; } case READ_AUTH_SCHEMES : { authSchemes . clear ( ) ; authSchemeNum = byteBuf . readByte ( ) ; for ( int i = <int> ; i < authSchemeNum ; i + + ) { authSchemes . add ( SocksAuthScheme . valueOf ( byteBuf . readByte ( ) ) ) ; } msg = new SocksInitRequest ( authSchemes ) ; break ; } } ctx . pipeline ( ) . remove ( this ) ; out . add ( msg ) ; } enum State { CHECK_PROTOCOL_VERSION , READ_AUTH_SCHEMES } } 
