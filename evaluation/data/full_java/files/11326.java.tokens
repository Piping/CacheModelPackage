package org . gradle . api . internal . artifacts ; import org . gradle . api . file . FileCollection ; import org . gradle . internal . graph . CachingDirectedGraphWalker ; import org . gradle . internal . graph . DirectedGraph ; import org . gradle . api . internal . file . UnionFileCollection ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; public class CachingDependencyResolveContext implements DependencyResolveContext { private final List < Object > queue = new ArrayList < Object > ( ) ; private final CachingDirectedGraphWalker < Object , FileCollection > walker = new CachingDirectedGraphWalker < Object , FileCollection > ( new DependencyGraph ( ) ) ; private final boolean transitive ; public CachingDependencyResolveContext ( boolean transitive ) { this . transitive = transitive ; } public boolean isTransitive ( ) { return transitive ; } public FileCollection resolve ( ) { try { walker . add ( queue ) ; return new UnionFileCollection ( walker . findValues ( ) ) ; } finally { queue . clear ( ) ; } } public void add ( Object dependency ) { queue . add ( dependency ) ; } private class DependencyGraph implements DirectedGraph < Object , FileCollection > { public void getNodeValues ( Object node , Collection < ? super FileCollection > values , Collection < ? super Object > connectedNodes ) { if ( node instanceof FileCollection ) { FileCollection fileCollection = ( FileCollection ) node ; values . add ( fileCollection ) ; } else if ( node instanceof ResolvableDependency ) { ResolvableDependency resolvableDependency = ( ResolvableDependency ) node ; queue . clear ( ) ; resolvableDependency . resolve ( CachingDependencyResolveContext . this ) ; connectedNodes . addAll ( queue ) ; queue . clear ( ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , node . getClass ( ) . getSimpleName ( ) ) ) ; } } } } 
