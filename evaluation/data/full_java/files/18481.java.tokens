package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class FilterPerformanceTest extends GdxTest { SpriteBatch batch ; Sprite sprite ; Sprite sprite2 ; TextureAtlas atlas ; Texture texture ; Matrix4 sceneMatrix ; Matrix4 textMatrix ; BitmapFont font ; int mode = <int> ; String modeString = <str> ; int [ ] filters = { GL20 . GL_NEAREST , GL20 . GL_LINEAR , GL20 . GL_NEAREST_MIPMAP_NEAREST , GL20 . GL_LINEAR_MIPMAP_NEAREST , GL20 . GL_LINEAR_MIPMAP_LINEAR } ; String [ ] filterNames = { <str> , <str> , <str> , <str> , <str> } ; void setTextureFilter ( int filter ) { atlas . findRegion ( <str> ) . getTexture ( ) . bind ( ) ; Gdx . gl . glTexParameterf ( GL20 . GL_TEXTURE_2D , GL20 . GL_TEXTURE_MIN_FILTER , filters [ filter ] ) ; texture . bind ( ) ; Gdx . gl . glTexParameterf ( GL20 . GL_TEXTURE_2D , GL20 . GL_TEXTURE_MIN_FILTER , filters [ filter ] ) ; } void setModeString ( ) { modeString = ( mode % <int> = = <int> ? <str> : <str> ) + <str> + filterNames [ mode / <int> ] ; } public void create ( ) { batch = new SpriteBatch ( ) ; sceneMatrix = new Matrix4 ( ) . setToOrtho2D ( <int> , <int> , <int> , <int> ) ; textMatrix = new Matrix4 ( ) . setToOrtho2D ( <int> , <int> , <int> , <int> ) ; atlas = new TextureAtlas ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) ) ; texture = new Texture ( Gdx . files . internal ( <str> ) , true ) ; texture . setFilter ( TextureFilter . MipMap , TextureFilter . Nearest ) ; setTextureFilter ( <int> ) ; setModeString ( ) ; sprite = atlas . createSprite ( <str> ) ; sprite2 = new Sprite ( texture , <int> , <int> , <int> , <int> ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) , false ) ; Gdx . input . setInputProcessor ( new InputAdapter ( ) { public boolean touchDown ( int x , int y , int pointer , int newParam ) { mode + + ; if ( mode = = filters . length * <int> ) mode = <int> ; setTextureFilter ( mode / <int> ) ; setModeString ( ) ; return false ; } } ) ; } @Override public void dispose ( ) { batch . dispose ( ) ; atlas . dispose ( ) ; texture . dispose ( ) ; font . dispose ( ) ; } public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; batch . setProjectionMatrix ( sceneMatrix ) ; batch . begin ( ) ; renderSprite ( ) ; batch . end ( ) ; batch . setProjectionMatrix ( textMatrix ) ; batch . begin ( ) ; font . draw ( batch , modeString + <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; batch . end ( ) ; } public void renderSprite ( ) { batch . disableBlending ( ) ; if ( mode % <int> = = <int> ) sprite2 . draw ( batch ) ; else sprite . draw ( batch ) ; batch . enableBlending ( ) ; } } 
