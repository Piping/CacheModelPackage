package org . elasticsearch . search . aggregations ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static java . util . Collections . unmodifiableMap ; public class AggregatorParsers { public static final Pattern VALID_AGG_NAME = Pattern . compile ( <str> ) ; private final Map < String , Aggregator . Parser > aggParsers ; private final Map < String , PipelineAggregator . Parser > pipelineAggregatorParsers ; @Inject public AggregatorParsers ( Set < Aggregator . Parser > aggParsers , Set < PipelineAggregator . Parser > pipelineAggregatorParsers ) { Map < String , Aggregator . Parser > aggParsersBuilder = new HashMap < > ( aggParsers . size ( ) ) ; for ( Aggregator . Parser parser : aggParsers ) { aggParsersBuilder . put ( parser . type ( ) , parser ) ; } this . aggParsers = unmodifiableMap ( aggParsersBuilder ) ; Map < String , PipelineAggregator . Parser > pipelineAggregatorParsersBuilder = new HashMap < > ( pipelineAggregatorParsers . size ( ) ) ; for ( PipelineAggregator . Parser parser : pipelineAggregatorParsers ) { pipelineAggregatorParsersBuilder . put ( parser . type ( ) , parser ) ; } this . pipelineAggregatorParsers = unmodifiableMap ( pipelineAggregatorParsersBuilder ) ; } public Aggregator . Parser parser ( String type ) { return aggParsers . get ( type ) ; } public PipelineAggregator . Parser pipelineAggregator ( String type ) { return pipelineAggregatorParsers . get ( type ) ; } public AggregatorFactories parseAggregators ( XContentParser parser , SearchContext context ) throws IOException { return parseAggregators ( parser , context , <int> ) ; } private AggregatorFactories parseAggregators ( XContentParser parser , SearchContext context , int level ) throws IOException { Matcher validAggMatcher = VALID_AGG_NAME . matcher ( <str> ) ; AggregatorFactories . Builder factories = new AggregatorFactories . Builder ( ) ; XContentParser . Token token = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new SearchParseException ( context , <str> + token + <str> , parser . getTokenLocation ( ) ) ; } final String aggregationName = parser . currentName ( ) ; if ( ! validAggMatcher . reset ( aggregationName ) . matches ( ) ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new SearchParseException ( context , <str> + aggregationName + <str> + token + <str> + XContentParser . Token . START_OBJECT + <str> , parser . getTokenLocation ( ) ) ; } AggregatorFactory aggFactory = null ; PipelineAggregatorFactory pipelineAggregatorFactory = null ; AggregatorFactories subFactories = null ; Map < String , Object > metaData = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new SearchParseException ( context , <str> + XContentParser . Token . FIELD_NAME + <str> + XContentParser . Token . START_OBJECT + <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } final String fieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( <str> . equals ( fieldName ) ) { if ( subFactories ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } XContentParser binaryParser = null ; if ( token = = XContentParser . Token . VALUE_STRING | | token = = XContentParser . Token . VALUE_EMBEDDED_OBJECT ) { byte [ ] source = parser . binaryValue ( ) ; binaryParser = XContentFactory . xContent ( source ) . createParser ( source ) ; } else { throw new SearchParseException ( context , <str> + XContentParser . Token . VALUE_STRING + <str> + XContentParser . Token . VALUE_EMBEDDED_OBJECT + <str> + fieldName + <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } XContentParser . Token binaryToken = binaryParser . nextToken ( ) ; if ( binaryToken ! = XContentParser . Token . START_OBJECT ) { throw new SearchParseException ( context , <str> + XContentParser . Token . START_OBJECT + <str> + fieldName + <str> + binaryToken + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } subFactories = parseAggregators ( binaryParser , context , level + <int> ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { switch ( fieldName ) { case <str> : metaData = parser . map ( ) ; break ; case <str> : case <str> : if ( subFactories ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } subFactories = parseAggregators ( parser , context , level + <int> ) ; break ; default : if ( aggFactory ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> + aggFactory . type + <str> + fieldName + <str> , parser . getTokenLocation ( ) ) ; } if ( pipelineAggregatorFactory ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> + pipelineAggregatorFactory + <str> + fieldName + <str> , parser . getTokenLocation ( ) ) ; } Aggregator . Parser aggregatorParser = parser ( fieldName ) ; if ( aggregatorParser = = null ) { PipelineAggregator . Parser pipelineAggregatorParser = pipelineAggregator ( fieldName ) ; if ( pipelineAggregatorParser = = null ) { throw new SearchParseException ( context , <str> + fieldName + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } else { pipelineAggregatorFactory = pipelineAggregatorParser . parse ( aggregationName , parser , context ) ; } } else { aggFactory = aggregatorParser . parse ( aggregationName , parser , context ) ; } } } else { throw new SearchParseException ( context , <str> + XContentParser . Token . START_OBJECT + <str> + fieldName + <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( aggFactory = = null & & pipelineAggregatorFactory = = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } else if ( aggFactory ! = null ) { assert pipelineAggregatorFactory = = null ; if ( metaData ! = null ) { aggFactory . setMetaData ( metaData ) ; } if ( subFactories ! = null ) { aggFactory . subFactories ( subFactories ) ; } if ( level = = <int> ) { aggFactory . validate ( ) ; } factories . addAggregator ( aggFactory ) ; } else { assert pipelineAggregatorFactory ! = null ; if ( subFactories ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } if ( level = = <int> ) { pipelineAggregatorFactory . validate ( null , factories . getAggregatorFactories ( ) , factories . getPipelineAggregatorFactories ( ) ) ; } factories . addPipelineAggregator ( pipelineAggregatorFactory ) ; } } return factories . build ( ) ; } } 
