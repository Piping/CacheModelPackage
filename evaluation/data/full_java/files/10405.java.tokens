package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . collect . Lists . newArrayList ; import static com . google . common . testing . SerializableTester . reserialize ; import static com . google . common . testing . SerializableTester . reserializeAndAssert ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . collect . Ordering . ArbitraryOrdering ; import com . google . common . collect . Ordering . IncomparableValueException ; import com . google . common . collect . testing . Helpers ; import com . google . common . primitives . Ints ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Random ; import java . util . RandomAccess ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class OrderingTest extends TestCase { private final Ordering < Number > numberOrdering = new NumberOrdering ( ) ; public void testAllEqual ( ) { Ordering < Object > comparator = Ordering . allEqual ( ) ; assertSame ( comparator , comparator . reverse ( ) ) ; assertEquals ( comparator . compare ( null , null ) , <int> ) ; assertEquals ( comparator . compare ( new Object ( ) , new Object ( ) ) , <int> ) ; assertEquals ( comparator . compare ( <str> , <str> ) , <int> ) ; assertSame ( comparator , reserialize ( comparator ) ) ; assertEquals ( <str> , comparator . toString ( ) ) ; List < String > strings = ImmutableList . of ( <str> , <str> , <str> , <str> ) ; assertEquals ( strings , comparator . sortedCopy ( strings ) ) ; assertEquals ( strings , comparator . immutableSortedCopy ( strings ) ) ; } public void testComplicatedOrderingExample ( ) { Integer nullInt = ( Integer ) null ; Ordering < Iterable < Integer > > example = Ordering . < Integer > natural ( ) . nullsFirst ( ) . reverse ( ) . lexicographical ( ) . reverse ( ) . nullsLast ( ) ; List < Integer > list1 = Lists . newArrayList ( ) ; List < Integer > list2 = Lists . newArrayList ( <int> ) ; List < Integer > list3 = Lists . newArrayList ( <int> , <int> ) ; List < Integer > list4 = Lists . newArrayList ( <int> , <int> ) ; List < Integer > list5 = Lists . newArrayList ( <int> , null , <int> ) ; List < Integer > list6 = Lists . newArrayList ( <int> ) ; List < Integer > list7 = Lists . newArrayList ( nullInt ) ; List < Integer > list8 = Lists . newArrayList ( nullInt , nullInt ) ; List < List < Integer > > list = Lists . newArrayList ( list1 , list2 , list3 , list4 , list5 , list6 , list7 , list8 , null ) ; List < List < Integer > > sorted = example . sortedCopy ( list ) ; assertThat ( sorted ) . containsExactly ( Lists . newArrayList ( nullInt , nullInt ) , Lists . newArrayList ( nullInt ) , Lists . newArrayList ( <int> , null , <int> ) , Lists . newArrayList ( <int> , <int> ) , Lists . newArrayList ( <int> , <int> ) , Lists . newArrayList ( <int> ) , Lists . newArrayList ( <int> ) , Lists . newArrayList ( ) , null ) . inOrder ( ) ; } public void testNatural ( ) { Ordering < Integer > comparator = Ordering . natural ( ) ; Helpers . testComparator ( comparator , Integer . MIN_VALUE , - <int> , <int> , <int> , Integer . MAX_VALUE ) ; try { comparator . compare ( <int> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { comparator . compare ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { comparator . compare ( null , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } assertSame ( comparator , reserialize ( comparator ) ) ; assertEquals ( <str> , comparator . toString ( ) ) ; } public void testFrom ( ) { Ordering < String > caseInsensitiveOrdering = Ordering . from ( String . CASE_INSENSITIVE_ORDER ) ; assertEquals ( <int> , caseInsensitiveOrdering . compare ( <str> , <str> ) ) ; assertTrue ( caseInsensitiveOrdering . compare ( <str> , <str> ) < <int> ) ; assertTrue ( caseInsensitiveOrdering . compare ( <str> , <str> ) > <int> ) ; @SuppressWarnings ( <str> ) Ordering < String > orderingFromOrdering = Ordering . from ( Ordering . < String > natural ( ) ) ; new EqualsTester ( ) . addEqualityGroup ( caseInsensitiveOrdering , Ordering . from ( String . CASE_INSENSITIVE_ORDER ) ) . addEqualityGroup ( orderingFromOrdering , Ordering . natural ( ) ) . testEquals ( ) ; } public void testExplicit_none ( ) { Comparator < Integer > c = Ordering . explicit ( Collections . < Integer > emptyList ( ) ) ; try { c . compare ( <int> , <int> ) ; fail ( ) ; } catch ( IncomparableValueException expected ) { assertEquals ( <int> , expected . value ) ; } reserializeAndAssert ( c ) ; } public void testExplicit_one ( ) { Comparator < Integer > c = Ordering . explicit ( <int> ) ; assertEquals ( <int> , c . compare ( <int> , <int> ) ) ; try { c . compare ( <int> , <int> ) ; fail ( ) ; } catch ( IncomparableValueException expected ) { assertEquals ( <int> , expected . value ) ; } reserializeAndAssert ( c ) ; assertEquals ( <str> , c . toString ( ) ) ; } public void testExplicit_two ( ) { Comparator < Integer > c = Ordering . explicit ( <int> , <int> ) ; assertEquals ( <int> , c . compare ( <int> , <int> ) ) ; assertTrue ( c . compare ( <int> , <int> ) > <int> ) ; assertTrue ( c . compare ( <int> , <int> ) < <int> ) ; try { c . compare ( <int> , <int> ) ; fail ( ) ; } catch ( IncomparableValueException expected ) { assertEquals ( <int> , expected . value ) ; } new EqualsTester ( ) . addEqualityGroup ( c , Ordering . explicit ( <int> , <int> ) ) . addEqualityGroup ( Ordering . explicit ( <int> , <int> ) ) . addEqualityGroup ( Ordering . explicit ( <int> ) ) . testEquals ( ) ; reserializeAndAssert ( c ) ; } public void testExplicit_sortingExample ( ) { Comparator < Integer > c = Ordering . explicit ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; List < Integer > list = Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; Collections . sort ( list , c ) ; assertThat ( list ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; reserializeAndAssert ( c ) ; } public void testExplicit_withDuplicates ( ) { try { Ordering . explicit ( <int> , <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testArbitrary_withoutCollisions ( ) { List < Object > list = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { list . add ( new Object ( ) ) ; } Ordering < Object > arbitrary = Ordering . arbitrary ( ) ; Collections . sort ( list , arbitrary ) ; Helpers . testComparator ( arbitrary , list ) ; assertEquals ( <str> , arbitrary . toString ( ) ) ; } public void testArbitrary_withCollisions ( ) { List < Integer > list = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { list . add ( i ) ; } Ordering < Object > arbitrary = new ArbitraryOrdering ( ) { @Override int identityHashCode ( Object object ) { return ( ( Integer ) object ) % <int> ; } } ; list = shuffledCopy ( list , new Random ( <int> ) ) ; Collections . sort ( list , arbitrary ) ; Helpers . testComparator ( arbitrary , list ) ; } public void testUsingToString ( ) { Ordering < Object > ordering = Ordering . usingToString ( ) ; Helpers . testComparator ( ordering , <int> , <int> , <int> , <int> ) ; assertEquals ( <str> , ordering . toString ( ) ) ; assertSame ( ordering , reserialize ( ordering ) ) ; } private enum CharAtFunction implements Function < String , Character > { AT0 ( <int> ) , AT1 ( <int> ) , AT2 ( <int> ) , AT3 ( <int> ) , AT4 ( <int> ) , AT5 ( <int> ) , ; final int index ; CharAtFunction ( int index ) { this . index = index ; } @Override public Character apply ( String string ) { return string . charAt ( index ) ; } } private static Ordering < String > byCharAt ( int index ) { return Ordering . natural ( ) . onResultOf ( CharAtFunction . values ( ) [ index ] ) ; } public void testCompound_static ( ) { Comparator < String > comparator = Ordering . compound ( ImmutableList . of ( byCharAt ( <int> ) , byCharAt ( <int> ) , byCharAt ( <int> ) , byCharAt ( <int> ) , byCharAt ( <int> ) , byCharAt ( <int> ) ) ) ; Helpers . testComparator ( comparator , ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; reserializeAndAssert ( comparator ) ; } public void testCompound_instance ( ) { Comparator < String > comparator = byCharAt ( <int> ) . compound ( byCharAt ( <int> ) ) ; Helpers . testComparator ( comparator , ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; } public void testCompound_instance_generics ( ) { Ordering < Object > objects = Ordering . explicit ( ( Object ) <int> ) ; Ordering < Number > numbers = Ordering . explicit ( ( Number ) <int> ) ; Ordering < Integer > integers = Ordering . explicit ( <int> ) ; Ordering < Number > a = numbers . compound ( numbers ) ; Ordering < Number > b = numbers . compound ( objects ) ; Ordering < Number > c = objects . compound ( numbers ) ; Ordering < Integer > d = numbers . compound ( integers ) ; Ordering < Integer > e = integers . compound ( numbers ) ; Ordering < Number > f = numbers . compound ( objects ) . compound ( objects ) ; Ordering < Number > g = objects . compound ( numbers ) . compound ( objects ) ; Ordering < Number > h = objects . compound ( objects ) . compound ( numbers ) ; Ordering < Number > i = numbers . compound ( objects . compound ( objects ) ) ; Ordering < Number > j = objects . compound ( numbers . compound ( objects ) ) ; Ordering < Number > k = objects . compound ( objects . compound ( numbers ) ) ; Ordering < Integer > l = objects . compound ( numbers ) ; } public void testReverse ( ) { Ordering < Number > reverseOrder = numberOrdering . reverse ( ) ; Helpers . testComparator ( reverseOrder , Integer . MAX_VALUE , <int> , <int> , - <int> , Integer . MIN_VALUE ) ; new EqualsTester ( ) . addEqualityGroup ( reverseOrder , numberOrdering . reverse ( ) ) . addEqualityGroup ( Ordering . natural ( ) . reverse ( ) ) . addEqualityGroup ( Collections . reverseOrder ( ) ) . testEquals ( ) ; } public void testReverseOfReverseSameAsForward ( ) { assertSame ( numberOrdering , numberOrdering . reverse ( ) . reverse ( ) ) ; } private enum StringLengthFunction implements Function < String , Integer > { StringLength ; @Override public Integer apply ( String string ) { return string . length ( ) ; } } private static final Ordering < Integer > DECREASING_INTEGER = Ordering . natural ( ) . reverse ( ) ; public void testOnResultOf_natural ( ) { Comparator < String > comparator = Ordering . natural ( ) . onResultOf ( StringLengthFunction . StringLength ) ; assertTrue ( comparator . compare ( <str> , <str> ) = = <int> ) ; assertTrue ( comparator . compare ( <str> , <str> ) < <int> ) ; assertTrue ( comparator . compare ( <str> , <str> ) > <int> ) ; new EqualsTester ( ) . addEqualityGroup ( comparator , Ordering . natural ( ) . onResultOf ( StringLengthFunction . StringLength ) ) . addEqualityGroup ( DECREASING_INTEGER ) . testEquals ( ) ; reserializeAndAssert ( comparator ) ; assertEquals ( <str> , comparator . toString ( ) ) ; } public void testOnResultOf_chained ( ) { Comparator < String > comparator = DECREASING_INTEGER . onResultOf ( StringLengthFunction . StringLength ) ; assertTrue ( comparator . compare ( <str> , <str> ) = = <int> ) ; assertTrue ( comparator . compare ( <str> , <str> ) < <int> ) ; assertTrue ( comparator . compare ( <str> , <str> ) > <int> ) ; new EqualsTester ( ) . addEqualityGroup ( comparator , DECREASING_INTEGER . onResultOf ( StringLengthFunction . StringLength ) ) . addEqualityGroup ( DECREASING_INTEGER . onResultOf ( Functions . constant ( <int> ) ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ; reserializeAndAssert ( comparator ) ; assertEquals ( <str> , comparator . toString ( ) ) ; } @SuppressWarnings ( <str> ) public void testLexicographical ( ) { Ordering < String > ordering = Ordering . natural ( ) ; Ordering < Iterable < String > > lexy = ordering . lexicographical ( ) ; ImmutableList < String > empty = ImmutableList . of ( ) ; ImmutableList < String > a = ImmutableList . of ( <str> ) ; ImmutableList < String > aa = ImmutableList . of ( <str> , <str> ) ; ImmutableList < String > ab = ImmutableList . of ( <str> , <str> ) ; ImmutableList < String > b = ImmutableList . of ( <str> ) ; Helpers . testComparator ( lexy , empty , a , aa , ab , b ) ; new EqualsTester ( ) . addEqualityGroup ( lexy , ordering . lexicographical ( ) ) . addEqualityGroup ( numberOrdering . lexicographical ( ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ; } public void testNullsFirst ( ) { Ordering < Integer > ordering = Ordering . natural ( ) . nullsFirst ( ) ; Helpers . testComparator ( ordering , null , Integer . MIN_VALUE , <int> , <int> ) ; new EqualsTester ( ) . addEqualityGroup ( ordering , Ordering . natural ( ) . nullsFirst ( ) ) . addEqualityGroup ( numberOrdering . nullsFirst ( ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ; } public void testNullsLast ( ) { Ordering < Integer > ordering = Ordering . natural ( ) . nullsLast ( ) ; Helpers . testComparator ( ordering , <int> , <int> , Integer . MAX_VALUE , null ) ; new EqualsTester ( ) . addEqualityGroup ( ordering , Ordering . natural ( ) . nullsLast ( ) ) . addEqualityGroup ( numberOrdering . nullsLast ( ) ) . addEqualityGroup ( Ordering . natural ( ) ) . testEquals ( ) ; } public void testBinarySearch ( ) { List < Integer > ints = Lists . newArrayList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , numberOrdering . binarySearch ( ints , <int> ) ) ; } public void testSortedCopy ( ) { List < Integer > unsortedInts = Collections . unmodifiableList ( Arrays . asList ( <int> , <int> , <int> , null , <int> , <int> ) ) ; List < Integer > sortedInts = numberOrdering . nullsLast ( ) . sortedCopy ( unsortedInts ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> , null ) , sortedInts ) ; assertEquals ( Collections . emptyList ( ) , numberOrdering . sortedCopy ( Collections . < Integer > emptyList ( ) ) ) ; } public void testImmutableSortedCopy ( ) { ImmutableList < Integer > unsortedInts = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> ) ; ImmutableList < Integer > sortedInts = numberOrdering . immutableSortedCopy ( unsortedInts ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , sortedInts ) ; assertEquals ( Collections . < Integer > emptyList ( ) , numberOrdering . immutableSortedCopy ( Collections . < Integer > emptyList ( ) ) ) ; List < Integer > listWithNull = Arrays . asList ( <int> , <int> , null , <int> ) ; try { Ordering . natural ( ) . nullsFirst ( ) . immutableSortedCopy ( listWithNull ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testIsOrdered ( ) { assertFalse ( numberOrdering . isOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertFalse ( numberOrdering . isOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isOrdered ( asList ( <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isOrdered ( Collections . singleton ( <int> ) ) ) ; assertTrue ( numberOrdering . isOrdered ( Collections . < Integer > emptyList ( ) ) ) ; } public void testIsStrictlyOrdered ( ) { assertFalse ( numberOrdering . isStrictlyOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertFalse ( numberOrdering . isStrictlyOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isStrictlyOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertFalse ( numberOrdering . isStrictlyOrdered ( asList ( <int> , <int> , <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isStrictlyOrdered ( asList ( <int> , <int> ) ) ) ; assertTrue ( numberOrdering . isStrictlyOrdered ( Collections . singleton ( <int> ) ) ) ; assertTrue ( numberOrdering . isStrictlyOrdered ( Collections . < Integer > emptyList ( ) ) ) ; } public void testLeastOfIterable_empty_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . < Integer > asList ( ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterator_empty_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Iterators . < Integer > emptyIterator ( ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterable_empty_1 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . < Integer > asList ( ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterator_empty_1 ( ) { List < Integer > result = numberOrdering . leastOf ( Iterators . < Integer > emptyIterator ( ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterable_simple_negativeOne ( ) { try { numberOrdering . leastOf ( Arrays . asList ( <int> , <int> , <int> , - <int> ) , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testLeastOfIterator_simple_negativeOne ( ) { try { numberOrdering . leastOf ( Iterators . forArray ( <int> , <int> , <int> , - <int> ) , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testLeastOfIterable_singleton_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . asList ( <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterator_singleton_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Iterators . singletonIterator ( <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterable_simple_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . asList ( <int> , <int> , <int> , - <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterator_simple_0 ( ) { List < Integer > result = numberOrdering . leastOf ( Iterators . forArray ( <int> , <int> , <int> , - <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . < Integer > of ( ) , result ) ; } public void testLeastOfIterable_simple_1 ( ) { List < Integer > result = numberOrdering . leastOf ( Arrays . asList ( <int> , <int> , <int> , - <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> ) , result ) ; } public void testLeastOfIterator_simple_1 ( ) { List < Integer > result = numberOrdering . leastOf ( Iterators . forArray ( <int> , <int> , <int> , - <int> ) , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> ) , result ) ; } public void testLeastOfIterable_simple_nMinusOne_withNullElement ( ) { List < Integer > list = Arrays . asList ( <int> , null , <int> , - <int> ) ; List < Integer > result = Ordering . natural ( ) . nullsLast ( ) . leastOf ( list , list . size ( ) - <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterator_simple_nMinusOne_withNullElement ( ) { Iterator < Integer > itr = Iterators . forArray ( <int> , null , <int> , - <int> ) ; List < Integer > result = Ordering . natural ( ) . nullsLast ( ) . leastOf ( itr , <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterable_simple_nMinusOne ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list , list . size ( ) - <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterator_simple_nMinusOne ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list . iterator ( ) , list . size ( ) - <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterable_simple_n ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list , list . size ( ) ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterator_simple_n ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list . iterator ( ) , list . size ( ) ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterable_simple_n_withNullElement ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , null , - <int> ) ; List < Integer > result = Ordering . natural ( ) . nullsLast ( ) . leastOf ( list , list . size ( ) ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( Arrays . asList ( - <int> , <int> , <int> , <int> , null ) , result ) ; } public void testLeastOfIterator_simple_n_withNullElement ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , null , - <int> ) ; List < Integer > result = Ordering . natural ( ) . nullsLast ( ) . leastOf ( list . iterator ( ) , list . size ( ) ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( Arrays . asList ( - <int> , <int> , <int> , <int> , null ) , result ) ; } public void testLeastOfIterable_simple_nPlusOne ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list , list . size ( ) + <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterator_simple_nPlusOne ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list . iterator ( ) , list . size ( ) + <int> ) ; assertTrue ( result instanceof RandomAccess ) ; assertListImmutable ( result ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , <int> , <int> ) , result ) ; } public void testLeastOfIterable_ties ( ) { Integer foo = new Integer ( Integer . MAX_VALUE - <int> ) ; Integer bar = new Integer ( Integer . MAX_VALUE - <int> ) ; assertNotSame ( foo , bar ) ; assertEquals ( foo , bar ) ; List < Integer > list = Arrays . asList ( <int> , foo , bar , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list , list . size ( ) ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , foo , bar ) , result ) ; } public void testLeastOfIterator_ties ( ) { Integer foo = new Integer ( Integer . MAX_VALUE - <int> ) ; Integer bar = new Integer ( Integer . MAX_VALUE - <int> ) ; assertNotSame ( foo , bar ) ; assertEquals ( foo , bar ) ; List < Integer > list = Arrays . asList ( <int> , foo , bar , - <int> ) ; List < Integer > result = numberOrdering . leastOf ( list . iterator ( ) , list . size ( ) ) ; assertEquals ( ImmutableList . of ( - <int> , <int> , foo , bar ) , result ) ; } @GwtIncompatible ( <str> ) public void testLeastOf_reconcileAgainstSortAndSublist ( ) { runLeastOfComparison ( <int> , <int> , <int> ) ; } public void testLeastOf_reconcileAgainstSortAndSublistSmall ( ) { runLeastOfComparison ( <int> , <int> , <int> ) ; } private static void runLeastOfComparison ( int iterations , int elements , int seeds ) { Random random = new Random ( <int> ) ; Ordering < Integer > ordering = Ordering . natural ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { List < Integer > list = Lists . newArrayList ( ) ; for ( int j = <int> ; j < elements ; j + + ) { list . add ( random . nextInt ( <int> * i + j + <int> ) ) ; } for ( int seed = <int> ; seed < seeds ; seed + + ) { int k = random . nextInt ( <int> * seed ) ; assertEquals ( ordering . sortedCopy ( list ) . subList ( <int> , k ) , ordering . leastOf ( list , k ) ) ; } } } public void testLeastOfIterableLargeK ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , Ordering . natural ( ) . leastOf ( list , Integer . MAX_VALUE ) ) ; } public void testLeastOfIteratorLargeK ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> , <int> ) , Ordering . natural ( ) . leastOf ( list . iterator ( ) , Integer . MAX_VALUE ) ) ; } public void testGreatestOfIterable_simple ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> ) , numberOrdering . greatestOf ( list , <int> ) ) ; } public void testGreatestOfIterator_simple ( ) { List < Integer > list = Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> , <int> ) , numberOrdering . greatestOf ( list . iterator ( ) , <int> ) ) ; } private static void assertListImmutable ( List < Integer > result ) { try { result . set ( <int> , <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testIteratorMinAndMax ( ) { List < Integer > ints = Lists . newArrayList ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( ints . iterator ( ) ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( ints . iterator ( ) ) ) ; Integer a = new Integer ( <int> ) ; Integer b = new Integer ( <int> ) ; ints = Lists . newArrayList ( a , b , b ) ; assertSame ( a , numberOrdering . max ( ints . iterator ( ) ) ) ; assertSame ( a , numberOrdering . min ( ints . iterator ( ) ) ) ; } public void testIteratorMinExhaustsIterator ( ) { List < Integer > ints = Lists . newArrayList ( <int> , <int> , <int> , <int> ) ; Iterator < Integer > iterator = ints . iterator ( ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( iterator ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testIteratorMaxExhaustsIterator ( ) { List < Integer > ints = Lists . newArrayList ( <int> , <int> , <int> , <int> ) ; Iterator < Integer > iterator = ints . iterator ( ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( iterator ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testIterableMinAndMax ( ) { List < Integer > ints = Lists . newArrayList ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( ints ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( ints ) ) ; Integer a = new Integer ( <int> ) ; Integer b = new Integer ( <int> ) ; ints = Lists . newArrayList ( a , b , b ) ; assertSame ( a , numberOrdering . max ( ints ) ) ; assertSame ( a , numberOrdering . min ( ints ) ) ; } public void testVarargsMinAndMax ( ) { assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> , <int> , <int> , <int> ) ) ; Integer a = new Integer ( <int> ) ; Integer b = new Integer ( <int> ) ; assertSame ( a , numberOrdering . max ( a , b , b ) ) ; assertSame ( a , numberOrdering . min ( a , b , b ) ) ; } public void testParameterMinAndMax ( ) { assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . max ( <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> ) ) ; assertEquals ( <int> , ( int ) numberOrdering . min ( <int> , <int> ) ) ; Integer a = new Integer ( <int> ) ; Integer b = new Integer ( <int> ) ; assertSame ( a , numberOrdering . max ( a , b ) ) ; assertSame ( a , numberOrdering . min ( a , b ) ) ; } private static class NumberOrdering extends Ordering < Number > { @Override public int compare ( Number a , Number b ) { return ( ( Double ) a . doubleValue ( ) ) . compareTo ( b . doubleValue ( ) ) ; } @Override public int hashCode ( ) { return NumberOrdering . class . hashCode ( ) ; } @Override public boolean equals ( Object other ) { return other instanceof NumberOrdering ; } private static final long serialVersionUID = <int> ; } private static final int RECURSE_DEPTH = <int> ; public void testCombinationsExhaustively_startingFromNatural ( ) { testExhaustively ( Ordering . < String > natural ( ) , <str> , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testCombinationsExhaustively_startingFromExplicit ( ) { testExhaustively ( Ordering . explicit ( <str> , <str> , <str> , <str> ) , <str> , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testCombinationsExhaustively_startingFromUsingToString ( ) { testExhaustively ( Ordering . usingToString ( ) , <int> , <int> , <int> ) ; } @GwtIncompatible ( <str> ) public void testCombinationsExhaustively_startingFromFromComparator ( ) { testExhaustively ( Ordering . from ( String . CASE_INSENSITIVE_ORDER ) , <str> , <str> , <str> , <str> ) ; } @GwtIncompatible ( <str> ) public void testCombinationsExhaustively_startingFromArbitrary ( ) { Ordering < Object > arbitrary = Ordering . arbitrary ( ) ; Object [ ] array = { <int> , <str> , new Object ( ) } ; Arrays . sort ( array , arbitrary ) ; testExhaustively ( arbitrary , array ) ; } private static < T > void testExhaustively ( Ordering < ? super T > ordering , T . . . strictlyOrderedElements ) { checkArgument ( strictlyOrderedElements . length > = <int> , <str> + <str> ) ; List < T > list = Arrays . asList ( strictlyOrderedElements ) ; T [ ] emptyArray = Platform . newArray ( strictlyOrderedElements , <int> ) ; @SuppressWarnings ( <str> ) Scenario < T > starter = new Scenario < T > ( ( Ordering ) ordering , list , emptyArray ) ; verifyScenario ( starter , <int> ) ; } private static < T > void verifyScenario ( Scenario < T > scenario , int level ) { scenario . testCompareTo ( ) ; scenario . testIsOrdered ( ) ; scenario . testMinAndMax ( ) ; scenario . testBinarySearch ( ) ; scenario . testSortedCopy ( ) ; if ( level < RECURSE_DEPTH ) { for ( OrderingMutation alteration : OrderingMutation . values ( ) ) { verifyScenario ( alteration . mutate ( scenario ) , level + <int> ) ; } } } private static class Scenario < T > { final Ordering < T > ordering ; final List < T > strictlyOrderedList ; final T [ ] emptyArray ; Scenario ( Ordering < T > ordering , List < T > strictlyOrderedList , T [ ] emptyArray ) { this . ordering = ordering ; this . strictlyOrderedList = strictlyOrderedList ; this . emptyArray = emptyArray ; } void testCompareTo ( ) { Helpers . testComparator ( ordering , strictlyOrderedList ) ; } void testIsOrdered ( ) { assertTrue ( ordering . isOrdered ( strictlyOrderedList ) ) ; assertTrue ( ordering . isStrictlyOrdered ( strictlyOrderedList ) ) ; } @SuppressWarnings ( <str> ) void testMinAndMax ( ) { List < T > shuffledList = Lists . newArrayList ( strictlyOrderedList ) ; shuffledList = shuffledCopy ( shuffledList , new Random ( <int> ) ) ; T min = strictlyOrderedList . get ( <int> ) ; T max = strictlyOrderedList . get ( strictlyOrderedList . size ( ) - <int> ) ; T first = shuffledList . get ( <int> ) ; T second = shuffledList . get ( <int> ) ; T third = shuffledList . get ( <int> ) ; T [ ] rest = shuffledList . subList ( <int> , shuffledList . size ( ) ) . toArray ( emptyArray ) ; assertEquals ( min , ordering . min ( shuffledList ) ) ; assertEquals ( min , ordering . min ( shuffledList . iterator ( ) ) ) ; assertEquals ( min , ordering . min ( first , second , third , rest ) ) ; assertEquals ( min , ordering . min ( min , max ) ) ; assertEquals ( min , ordering . min ( max , min ) ) ; assertEquals ( max , ordering . max ( shuffledList ) ) ; assertEquals ( max , ordering . max ( shuffledList . iterator ( ) ) ) ; assertEquals ( max , ordering . max ( first , second , third , rest ) ) ; assertEquals ( max , ordering . max ( min , max ) ) ; assertEquals ( max , ordering . max ( max , min ) ) ; } void testBinarySearch ( ) { for ( int i = <int> ; i < strictlyOrderedList . size ( ) ; i + + ) { assertEquals ( i , ordering . binarySearch ( strictlyOrderedList , strictlyOrderedList . get ( i ) ) ) ; } List < T > newList = Lists . newArrayList ( strictlyOrderedList ) ; T valueNotInList = newList . remove ( <int> ) ; assertEquals ( - <int> , ordering . binarySearch ( newList , valueNotInList ) ) ; } void testSortedCopy ( ) { List < T > shuffledList = Lists . newArrayList ( strictlyOrderedList ) ; shuffledList = shuffledCopy ( shuffledList , new Random ( <int> ) ) ; assertEquals ( strictlyOrderedList , ordering . sortedCopy ( shuffledList ) ) ; if ( ! strictlyOrderedList . contains ( null ) ) { assertEquals ( strictlyOrderedList , ordering . immutableSortedCopy ( shuffledList ) ) ; } } } private enum OrderingMutation { REVERSE { @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { List < T > newList = Lists . newArrayList ( scenario . strictlyOrderedList ) ; Collections . reverse ( newList ) ; return new Scenario < T > ( scenario . ordering . reverse ( ) , newList , scenario . emptyArray ) ; } } , NULLS_FIRST { @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { @SuppressWarnings ( <str> ) List < T > newList = Lists . newArrayList ( ( T ) null ) ; for ( T t : scenario . strictlyOrderedList ) { if ( t ! = null ) { newList . add ( t ) ; } } return new Scenario < T > ( scenario . ordering . nullsFirst ( ) , newList , scenario . emptyArray ) ; } } , NULLS_LAST { @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { List < T > newList = Lists . newArrayList ( ) ; for ( T t : scenario . strictlyOrderedList ) { if ( t ! = null ) { newList . add ( t ) ; } } newList . add ( null ) ; return new Scenario < T > ( scenario . ordering . nullsLast ( ) , newList , scenario . emptyArray ) ; } } , ON_RESULT_OF { @Override < T > Scenario < ? > mutate ( final Scenario < T > scenario ) { Ordering < Integer > ordering = scenario . ordering . onResultOf ( new Function < Integer , T > ( ) { @Override public T apply ( @Nullable Integer from ) { return scenario . strictlyOrderedList . get ( from ) ; } } ) ; List < Integer > list = Lists . newArrayList ( ) ; for ( int i = <int> ; i < scenario . strictlyOrderedList . size ( ) ; i + + ) { list . add ( i ) ; } return new Scenario < Integer > ( ordering , list , new Integer [ <int> ] ) ; } } , COMPOUND_THIS_WITH_NATURAL { @SuppressWarnings ( <str> ) @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { List < Composite < T > > composites = Lists . newArrayList ( ) ; for ( T t : scenario . strictlyOrderedList ) { composites . add ( new Composite < T > ( t , <int> ) ) ; composites . add ( new Composite < T > ( t , <int> ) ) ; } Ordering < Composite < T > > ordering = scenario . ordering . onResultOf ( Composite . < T > getValueFunction ( ) ) . compound ( Ordering . natural ( ) ) ; return new Scenario < Composite < T > > ( ordering , composites , new Composite [ <int> ] ) ; } } , COMPOUND_NATURAL_WITH_THIS { @SuppressWarnings ( <str> ) @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { List < Composite < T > > composites = Lists . newArrayList ( ) ; for ( T t : scenario . strictlyOrderedList ) { composites . add ( new Composite < T > ( t , <int> ) ) ; } for ( T t : scenario . strictlyOrderedList ) { composites . add ( new Composite < T > ( t , <int> ) ) ; } Ordering < Composite < T > > ordering = Ordering . natural ( ) . compound ( scenario . ordering . onResultOf ( Composite . < T > getValueFunction ( ) ) ) ; return new Scenario < Composite < T > > ( ordering , composites , new Composite [ <int> ] ) ; } } , LEXICOGRAPHICAL { @SuppressWarnings ( <str> ) @Override < T > Scenario < ? > mutate ( Scenario < T > scenario ) { List < Iterable < T > > words = Lists . newArrayList ( ) ; words . add ( Collections . < T > emptyList ( ) ) ; for ( T t : scenario . strictlyOrderedList ) { words . add ( Arrays . asList ( t ) ) ; for ( T s : scenario . strictlyOrderedList ) { words . add ( Arrays . asList ( t , s ) ) ; } } return new Scenario < Iterable < T > > ( scenario . ordering . lexicographical ( ) , words , new Iterable [ <int> ] ) ; } } , ; abstract < T > Scenario < ? > mutate ( Scenario < T > scenario ) ; } private static class Composite < T > implements Comparable < Composite < T > > { final T value ; final int rank ; Composite ( T value , int rank ) { this . value = value ; this . rank = rank ; } @Override public int compareTo ( Composite < T > that ) { return Ints . compare ( rank , that . rank ) ; } static < T > Function < Composite < T > , T > getValueFunction ( ) { return new Function < Composite < T > , T > ( ) { @Override public T apply ( Composite < T > from ) { return from . value ; } } ; } } @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( Ordering . class ) ; tester . testAllPublicInstanceMethods ( Ordering . usingToString ( ) . nullsFirst ( ) ) ; } private static < T > List < T > shuffledCopy ( List < T > in , Random random ) { List < T > mutable = newArrayList ( in ) ; List < T > out = newArrayList ( ) ; while ( ! mutable . isEmpty ( ) ) { out . add ( mutable . remove ( random . nextInt ( mutable . size ( ) ) ) ) ; } return out ; } } 
