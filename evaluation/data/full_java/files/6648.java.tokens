package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import java . io . IOException ; public class QueryParseContext { private static final ParseField CACHE = new ParseField ( <str> ) . withAllDeprecated ( <str> ) ; private static final ParseField CACHE_KEY = new ParseField ( <str> ) . withAllDeprecated ( <str> ) ; private XContentParser parser ; private ParseFieldMatcher parseFieldMatcher = ParseFieldMatcher . EMPTY ; private IndicesQueriesRegistry indicesQueriesRegistry ; public QueryParseContext ( IndicesQueriesRegistry registry ) { this . indicesQueriesRegistry = registry ; } public void reset ( XContentParser jp ) { this . parseFieldMatcher = ParseFieldMatcher . EMPTY ; this . parser = jp ; if ( parser ! = null ) { this . parser . setParseFieldMatcher ( parseFieldMatcher ) ; } } public XContentParser parser ( ) { return this . parser ; } public void parseFieldMatcher ( ParseFieldMatcher parseFieldMatcher ) { if ( parseFieldMatcher = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . parseFieldMatcher = parseFieldMatcher ; } public boolean isDeprecatedSetting ( String setting ) { return parseFieldMatcher . match ( setting , CACHE ) | | parseFieldMatcher . match ( setting , CACHE_KEY ) ; } public QueryBuilder < ? > parseTopLevelQueryBuilder ( ) { try { QueryBuilder < ? > queryBuilder = null ; for ( XContentParser . Token token = parser . nextToken ( ) ; token ! = XContentParser . Token . END_OBJECT ; token = parser . nextToken ( ) ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String fieldName = parser . currentName ( ) ; if ( <str> . equals ( fieldName ) ) { queryBuilder = parseInnerQueryBuilder ( ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + parser . currentName ( ) + <str> ) ; } } } if ( queryBuilder = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } return queryBuilder ; } catch ( ParsingException e ) { throw e ; } catch ( Throwable e ) { throw new ParsingException ( parser = = null ? null : parser . getTokenLocation ( ) , <str> , e ) ; } } public QueryBuilder < ? > parseInnerQueryBuilder ( ) throws IOException { XContentParser . Token token ; if ( parser . currentToken ( ) ! = XContentParser . Token . START_OBJECT ) { token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } } token = parser . nextToken ( ) ; if ( token = = XContentParser . Token . END_OBJECT ) { return EmptyQueryBuilder . PROTOTYPE ; } if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } String queryName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT & & token ! = XContentParser . Token . START_ARRAY ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } QueryParser queryParser = queryParser ( queryName ) ; if ( queryParser = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + queryName + <str> ) ; } QueryBuilder result = queryParser . fromXContent ( this ) ; if ( parser . currentToken ( ) = = XContentParser . Token . END_OBJECT | | parser . currentToken ( ) = = XContentParser . Token . END_ARRAY ) { parser . nextToken ( ) ; } return result ; } public ParseFieldMatcher parseFieldMatcher ( ) { return parseFieldMatcher ; } public void parser ( XContentParser innerParser ) { this . parser = innerParser ; } private QueryParser queryParser ( String name ) { return indicesQueriesRegistry . queryParsers ( ) . get ( name ) ; } } 
