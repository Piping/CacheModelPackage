package org . elasticsearch . action . termvectors ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . BoostAttribute ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . termvectors . TermVectorsRequest . Flag ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . dfs . AggregatedDfs ; import java . io . IOException ; import java . util . Collections ; import java . util . EnumSet ; import java . util . Iterator ; import java . util . Set ; public class TermVectorsResponse extends ActionResponse implements ToXContent { private static class FieldStrings { public static final XContentBuilderString TTF = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString DOC_FREQ = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString TERM_FREQ = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString SCORE = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString FIELD_STATISTICS = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString DOC_COUNT = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString SUM_DOC_FREQ = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString SUM_TTF = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString TOKENS = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString POS = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString START_OFFSET = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString END_OFFSET = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString PAYLOAD = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString _INDEX = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString _TYPE = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString _ID = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString _VERSION = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString FOUND = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString TOOK = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString TERMS = new XContentBuilderString ( <str> ) ; public static final XContentBuilderString TERM_VECTORS = new XContentBuilderString ( <str> ) ; } private BytesReference termVectors ; private BytesReference headerRef ; private String index ; private String type ; private String id ; private long docVersion ; private boolean exists = false ; private boolean artificial = false ; private long tookInMillis ; private boolean hasScores = false ; private boolean sourceCopied = false ; int [ ] currentPositions = new int [ <int> ] ; int [ ] currentStartOffset = new int [ <int> ] ; int [ ] currentEndOffset = new int [ <int> ] ; BytesReference [ ] currentPayloads = new BytesReference [ <int> ] ; public TermVectorsResponse ( String index , String type , String id ) { this . index = index ; this . type = type ; this . id = id ; } TermVectorsResponse ( ) { } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( index ) ; out . writeString ( type ) ; out . writeString ( id ) ; out . writeVLong ( docVersion ) ; final boolean docExists = isExists ( ) ; out . writeBoolean ( docExists ) ; out . writeBoolean ( artificial ) ; out . writeVLong ( tookInMillis ) ; out . writeBoolean ( hasTermVectors ( ) ) ; if ( hasTermVectors ( ) ) { out . writeBytesReference ( headerRef ) ; out . writeBytesReference ( termVectors ) ; } } private boolean hasTermVectors ( ) { assert ( headerRef = = null & & termVectors = = null ) | | ( headerRef ! = null & & termVectors ! = null ) ; return headerRef ! = null ; } @Override public void readFrom ( StreamInput in ) throws IOException { index = in . readString ( ) ; type = in . readString ( ) ; id = in . readString ( ) ; docVersion = in . readVLong ( ) ; exists = in . readBoolean ( ) ; artificial = in . readBoolean ( ) ; tookInMillis = in . readVLong ( ) ; if ( in . readBoolean ( ) ) { headerRef = in . readBytesReference ( ) ; termVectors = in . readBytesReference ( ) ; } } public Fields getFields ( ) throws IOException { if ( hasTermVectors ( ) & & isExists ( ) ) { if ( ! sourceCopied ) { headerRef = headerRef . copyBytesArray ( ) ; termVectors = termVectors . copyBytesArray ( ) ; } TermVectorsFields termVectorsFields = new TermVectorsFields ( headerRef , termVectors ) ; hasScores = termVectorsFields . hasScores ; return termVectorsFields ; } else { return new Fields ( ) { @Override public Iterator < String > iterator ( ) { return Collections . emptyIterator ( ) ; } @Override public Terms terms ( String field ) throws IOException { return null ; } @Override public int size ( ) { return <int> ; } } ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { assert index ! = null ; assert type ! = null ; assert id ! = null ; builder . field ( FieldStrings . _INDEX , index ) ; builder . field ( FieldStrings . _TYPE , type ) ; if ( ! isArtificial ( ) ) { builder . field ( FieldStrings . _ID , id ) ; } builder . field ( FieldStrings . _VERSION , docVersion ) ; builder . field ( FieldStrings . FOUND , isExists ( ) ) ; builder . field ( FieldStrings . TOOK , tookInMillis ) ; if ( ! isExists ( ) ) { return builder ; } builder . startObject ( FieldStrings . TERM_VECTORS ) ; final CharsRefBuilder spare = new CharsRefBuilder ( ) ; Fields theFields = getFields ( ) ; Iterator < String > fieldIter = theFields . iterator ( ) ; while ( fieldIter . hasNext ( ) ) { buildField ( builder , spare , theFields , fieldIter ) ; } builder . endObject ( ) ; return builder ; } private void buildField ( XContentBuilder builder , final CharsRefBuilder spare , Fields theFields , Iterator < String > fieldIter ) throws IOException { String fieldName = fieldIter . next ( ) ; builder . startObject ( fieldName ) ; Terms curTerms = theFields . terms ( fieldName ) ; buildFieldStatistics ( builder , curTerms ) ; builder . startObject ( FieldStrings . TERMS ) ; TermsEnum termIter = curTerms . iterator ( ) ; BoostAttribute boostAtt = termIter . attributes ( ) . addAttribute ( BoostAttribute . class ) ; for ( int i = <int> ; i < curTerms . size ( ) ; i + + ) { buildTerm ( builder , spare , curTerms , termIter , boostAtt ) ; } builder . endObject ( ) ; builder . endObject ( ) ; } private void buildTerm ( XContentBuilder builder , final CharsRefBuilder spare , Terms curTerms , TermsEnum termIter , BoostAttribute boostAtt ) throws IOException { BytesRef term = termIter . next ( ) ; spare . copyUTF8Bytes ( term ) ; builder . startObject ( spare . toString ( ) ) ; buildTermStatistics ( builder , termIter ) ; PostingsEnum posEnum = termIter . postings ( null , PostingsEnum . ALL ) ; int termFreq = posEnum . freq ( ) ; builder . field ( FieldStrings . TERM_FREQ , termFreq ) ; initMemory ( curTerms , termFreq ) ; initValues ( curTerms , posEnum , termFreq ) ; buildValues ( builder , curTerms , termFreq ) ; buildScore ( builder , boostAtt ) ; builder . endObject ( ) ; } private void buildTermStatistics ( XContentBuilder builder , TermsEnum termIter ) throws IOException { assert ( ( ( termIter . docFreq ( ) > <int> ) & & ( termIter . totalTermFreq ( ) > <int> ) ) | | ( ( termIter . docFreq ( ) = = - <int> ) & & ( termIter . totalTermFreq ( ) = = - <int> ) ) ) ; int docFreq = termIter . docFreq ( ) ; if ( docFreq > <int> ) { builder . field ( FieldStrings . DOC_FREQ , docFreq ) ; builder . field ( FieldStrings . TTF , termIter . totalTermFreq ( ) ) ; } } private void buildValues ( XContentBuilder builder , Terms curTerms , int termFreq ) throws IOException { if ( ! ( curTerms . hasPayloads ( ) | | curTerms . hasOffsets ( ) | | curTerms . hasPositions ( ) ) ) { return ; } builder . startArray ( FieldStrings . TOKENS ) ; for ( int i = <int> ; i < termFreq ; i + + ) { builder . startObject ( ) ; if ( curTerms . hasPositions ( ) ) { builder . field ( FieldStrings . POS , currentPositions [ i ] ) ; } if ( curTerms . hasOffsets ( ) ) { builder . field ( FieldStrings . START_OFFSET , currentStartOffset [ i ] ) ; builder . field ( FieldStrings . END_OFFSET , currentEndOffset [ i ] ) ; } if ( curTerms . hasPayloads ( ) & & ( currentPayloads [ i ] . length ( ) > <int> ) ) { builder . field ( FieldStrings . PAYLOAD , currentPayloads [ i ] ) ; } builder . endObject ( ) ; } builder . endArray ( ) ; } private void initValues ( Terms curTerms , PostingsEnum posEnum , int termFreq ) throws IOException { for ( int j = <int> ; j < termFreq ; j + + ) { int nextPos = posEnum . nextPosition ( ) ; if ( curTerms . hasPositions ( ) ) { currentPositions [ j ] = nextPos ; } if ( curTerms . hasOffsets ( ) ) { currentStartOffset [ j ] = posEnum . startOffset ( ) ; currentEndOffset [ j ] = posEnum . endOffset ( ) ; } if ( curTerms . hasPayloads ( ) ) { BytesRef curPayload = posEnum . getPayload ( ) ; if ( curPayload ! = null ) { currentPayloads [ j ] = new BytesArray ( curPayload . bytes , <int> , curPayload . length ) ; } else { currentPayloads [ j ] = null ; } } } } private void initMemory ( Terms curTerms , int termFreq ) { if ( curTerms . hasPositions ( ) ) { currentPositions = ArrayUtil . grow ( currentPositions , termFreq ) ; } if ( curTerms . hasOffsets ( ) ) { currentStartOffset = ArrayUtil . grow ( currentStartOffset , termFreq ) ; currentEndOffset = ArrayUtil . grow ( currentEndOffset , termFreq ) ; } if ( curTerms . hasPayloads ( ) ) { currentPayloads = new BytesArray [ termFreq ] ; } } private void buildFieldStatistics ( XContentBuilder builder , Terms curTerms ) throws IOException { long sumDocFreq = curTerms . getSumDocFreq ( ) ; int docCount = curTerms . getDocCount ( ) ; long sumTotalTermFrequencies = curTerms . getSumTotalTermFreq ( ) ; if ( docCount > <int> ) { assert ( ( sumDocFreq > <int> ) ) : <str> ; assert ( ( sumTotalTermFrequencies > <int> ) ) : <str> ; builder . startObject ( FieldStrings . FIELD_STATISTICS ) ; builder . field ( FieldStrings . SUM_DOC_FREQ , sumDocFreq ) ; builder . field ( FieldStrings . DOC_COUNT , docCount ) ; builder . field ( FieldStrings . SUM_TTF , sumTotalTermFrequencies ) ; builder . endObject ( ) ; } else if ( docCount = = - <int> ) { assert ( ( sumDocFreq = = - <int> ) ) : <str> ; assert ( ( sumTotalTermFrequencies = = - <int> ) ) : <str> ; } else { throw new IllegalStateException ( <str> + <str> + FieldStrings . SUM_DOC_FREQ + <str> + sumDocFreq + <str> + FieldStrings . DOC_COUNT + <str> + docCount + <str> + FieldStrings . SUM_TTF + <str> + sumTotalTermFrequencies ) ; } } public void updateTookInMillis ( long startTime ) { this . tookInMillis = Math . max ( <int> , System . currentTimeMillis ( ) - startTime ) ; } public TimeValue getTook ( ) { return new TimeValue ( tookInMillis ) ; } public long getTookInMillis ( ) { return tookInMillis ; } private void buildScore ( XContentBuilder builder , BoostAttribute boostAtt ) throws IOException { if ( hasScores ) { builder . field ( FieldStrings . SCORE , boostAtt . getBoost ( ) ) ; } } public boolean isExists ( ) { return exists ; } public void setExists ( boolean exists ) { this . exists = exists ; } public void setFields ( Fields termVectorsByField , Set < String > selectedFields , EnumSet < Flag > flags , Fields topLevelFields ) throws IOException { setFields ( termVectorsByField , selectedFields , flags , topLevelFields , null , null ) ; } public void setFields ( Fields termVectorsByField , Set < String > selectedFields , EnumSet < Flag > flags , Fields topLevelFields , @Nullable AggregatedDfs dfs , TermVectorsFilter termVectorsFilter ) throws IOException { TermVectorsWriter tvw = new TermVectorsWriter ( this ) ; if ( termVectorsByField ! = null ) { tvw . setFields ( termVectorsByField , selectedFields , flags , topLevelFields , dfs , termVectorsFilter ) ; } } public void setTermVectorsField ( BytesStreamOutput output ) { termVectors = output . bytes ( ) ; } public void setHeader ( BytesReference header ) { headerRef = header ; } public void setDocVersion ( long version ) { this . docVersion = version ; } public Long getVersion ( ) { return docVersion ; } public String getIndex ( ) { return index ; } public String getType ( ) { return type ; } public String getId ( ) { return id ; } public boolean isArtificial ( ) { return artificial ; } public void setArtificial ( boolean artificial ) { this . artificial = artificial ; } } 
