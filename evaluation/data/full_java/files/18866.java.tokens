package io . netty . handler . codec . base64 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; public final class Base64 { private static final int MAX_LINE_LENGTH = <int> ; private static final byte EQUALS_SIGN = ( byte ) <str> ; private static final byte NEW_LINE = ( byte ) <str> ; private static final byte WHITE_SPACE_ENC = - <int> ; private static final byte EQUALS_SIGN_ENC = - <int> ; private static byte [ ] alphabet ( Base64Dialect dialect ) { if ( dialect = = null ) { throw new NullPointerException ( <str> ) ; } return dialect . alphabet ; } private static byte [ ] decodabet ( Base64Dialect dialect ) { if ( dialect = = null ) { throw new NullPointerException ( <str> ) ; } return dialect . decodabet ; } private static boolean breakLines ( Base64Dialect dialect ) { if ( dialect = = null ) { throw new NullPointerException ( <str> ) ; } return dialect . breakLinesByDefault ; } public static ByteBuf encode ( ByteBuf src ) { return encode ( src , Base64Dialect . STANDARD ) ; } public static ByteBuf encode ( ByteBuf src , Base64Dialect dialect ) { return encode ( src , breakLines ( dialect ) , dialect ) ; } public static ByteBuf encode ( ByteBuf src , boolean breakLines ) { return encode ( src , breakLines , Base64Dialect . STANDARD ) ; } public static ByteBuf encode ( ByteBuf src , boolean breakLines , Base64Dialect dialect ) { if ( src = = null ) { throw new NullPointerException ( <str> ) ; } ByteBuf dest = encode ( src , src . readerIndex ( ) , src . readableBytes ( ) , breakLines , dialect ) ; src . readerIndex ( src . writerIndex ( ) ) ; return dest ; } public static ByteBuf encode ( ByteBuf src , int off , int len ) { return encode ( src , off , len , Base64Dialect . STANDARD ) ; } public static ByteBuf encode ( ByteBuf src , int off , int len , Base64Dialect dialect ) { return encode ( src , off , len , breakLines ( dialect ) , dialect ) ; } public static ByteBuf encode ( ByteBuf src , int off , int len , boolean breakLines ) { return encode ( src , off , len , breakLines , Base64Dialect . STANDARD ) ; } public static ByteBuf encode ( ByteBuf src , int off , int len , boolean breakLines , Base64Dialect dialect ) { if ( src = = null ) { throw new NullPointerException ( <str> ) ; } if ( dialect = = null ) { throw new NullPointerException ( <str> ) ; } int len43 = len * <int> / <int> ; ByteBuf dest = Unpooled . buffer ( len43 + ( len % <int> > <int> ? <int> : <int> ) + ( breakLines ? len43 / MAX_LINE_LENGTH : <int> ) ) . order ( src . order ( ) ) ; int d = <int> ; int e = <int> ; int len2 = len - <int> ; int lineLength = <int> ; for ( ; d < len2 ; d + = <int> , e + = <int> ) { encode3to4 ( src , d + off , <int> , dest , e , dialect ) ; lineLength + = <int> ; if ( breakLines & & lineLength = = MAX_LINE_LENGTH ) { dest . setByte ( e + <int> , NEW_LINE ) ; e + + ; lineLength = <int> ; } } if ( d < len ) { encode3to4 ( src , d + off , len - d , dest , e , dialect ) ; e + = <int> ; } return dest . slice ( <int> , e ) ; } private static void encode3to4 ( ByteBuf src , int srcOffset , int numSigBytes , ByteBuf dest , int destOffset , Base64Dialect dialect ) { byte [ ] ALPHABET = alphabet ( dialect ) ; int inBuff = ( numSigBytes > <int> ? src . getByte ( srcOffset ) < < <int> > > > <int> : <int> ) | ( numSigBytes > <int> ? src . getByte ( srcOffset + <int> ) < < <int> > > > <int> : <int> ) | ( numSigBytes > <int> ? src . getByte ( srcOffset + <int> ) < < <int> > > > <int> : <int> ) ; switch ( numSigBytes ) { case <int> : dest . setByte ( destOffset , ALPHABET [ inBuff > > > <int> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff > > > <int> & <hex> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff > > > <int> & <hex> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff & <hex> ] ) ; break ; case <int> : dest . setByte ( destOffset , ALPHABET [ inBuff > > > <int> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff > > > <int> & <hex> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff > > > <int> & <hex> ] ) ; dest . setByte ( destOffset + <int> , EQUALS_SIGN ) ; break ; case <int> : dest . setByte ( destOffset , ALPHABET [ inBuff > > > <int> ] ) ; dest . setByte ( destOffset + <int> , ALPHABET [ inBuff > > > <int> & <hex> ] ) ; dest . setByte ( destOffset + <int> , EQUALS_SIGN ) ; dest . setByte ( destOffset + <int> , EQUALS_SIGN ) ; break ; } } public static ByteBuf decode ( ByteBuf src ) { return decode ( src , Base64Dialect . STANDARD ) ; } public static ByteBuf decode ( ByteBuf src , Base64Dialect dialect ) { if ( src = = null ) { throw new NullPointerException ( <str> ) ; } ByteBuf dest = decode ( src , src . readerIndex ( ) , src . readableBytes ( ) , dialect ) ; src . readerIndex ( src . writerIndex ( ) ) ; return dest ; } public static ByteBuf decode ( ByteBuf src , int off , int len ) { return decode ( src , off , len , Base64Dialect . STANDARD ) ; } public static ByteBuf decode ( ByteBuf src , int off , int len , Base64Dialect dialect ) { if ( src = = null ) { throw new NullPointerException ( <str> ) ; } if ( dialect = = null ) { throw new NullPointerException ( <str> ) ; } byte [ ] DECODABET = decodabet ( dialect ) ; int len34 = len * <int> / <int> ; ByteBuf dest = src . alloc ( ) . buffer ( len34 ) . order ( src . order ( ) ) ; int outBuffPosn = <int> ; byte [ ] b4 = new byte [ <int> ] ; int b4Posn = <int> ; int i ; byte sbiCrop ; byte sbiDecode ; for ( i = off ; i < off + len ; i + + ) { sbiCrop = ( byte ) ( src . getByte ( i ) & <hex> ) ; sbiDecode = DECODABET [ sbiCrop ] ; if ( sbiDecode > = WHITE_SPACE_ENC ) { if ( sbiDecode > = EQUALS_SIGN_ENC ) { b4 [ b4Posn + + ] = sbiCrop ; if ( b4Posn > <int> ) { outBuffPosn + = decode4to3 ( b4 , <int> , dest , outBuffPosn , dialect ) ; b4Posn = <int> ; if ( sbiCrop = = EQUALS_SIGN ) { break ; } } } } else { throw new IllegalArgumentException ( <str> + i + <str> + src . getUnsignedByte ( i ) + <str> ) ; } } return dest . slice ( <int> , outBuffPosn ) ; } private static int decode4to3 ( byte [ ] src , int srcOffset , ByteBuf dest , int destOffset , Base64Dialect dialect ) { byte [ ] DECODABET = decodabet ( dialect ) ; if ( src [ srcOffset + <int> ] = = EQUALS_SIGN ) { int outBuff = ( DECODABET [ src [ srcOffset ] ] & <hex> ) < < <int> | ( DECODABET [ src [ srcOffset + <int> ] ] & <hex> ) < < <int> ; dest . setByte ( destOffset , ( byte ) ( outBuff > > > <int> ) ) ; return <int> ; } else if ( src [ srcOffset + <int> ] = = EQUALS_SIGN ) { int outBuff = ( DECODABET [ src [ srcOffset ] ] & <hex> ) < < <int> | ( DECODABET [ src [ srcOffset + <int> ] ] & <hex> ) < < <int> | ( DECODABET [ src [ srcOffset + <int> ] ] & <hex> ) < < <int> ; dest . setByte ( destOffset , ( byte ) ( outBuff > > > <int> ) ) ; dest . setByte ( destOffset + <int> , ( byte ) ( outBuff > > > <int> ) ) ; return <int> ; } else { int outBuff ; try { outBuff = ( DECODABET [ src [ srcOffset ] ] & <hex> ) < < <int> | ( DECODABET [ src [ srcOffset + <int> ] ] & <hex> ) < < <int> | ( DECODABET [ src [ srcOffset + <int> ] ] & <hex> ) < < <int> | DECODABET [ src [ srcOffset + <int> ] ] & <hex> ; } catch ( IndexOutOfBoundsException ignored ) { throw new IllegalArgumentException ( <str> ) ; } dest . setByte ( destOffset , ( byte ) ( outBuff > > <int> ) ) ; dest . setByte ( destOffset + <int> , ( byte ) ( outBuff > > <int> ) ) ; dest . setByte ( destOffset + <int> , ( byte ) outBuff ) ; return <int> ; } } private Base64 ( ) { } } 
