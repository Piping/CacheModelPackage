package org . gradle . platform . base . internal . registry ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . Nullable ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . internal . core . ExtractedModelRule ; import org . gradle . model . internal . core . ModelReference ; import org . gradle . model . internal . inspect . MethodRuleDefinition ; import org . gradle . model . internal . inspect . ValidationProblemCollector ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . type . ModelType ; import org . gradle . platform . base . InvalidModelException ; import org . gradle . platform . base . internal . builder . TypeBuilderFactory ; import org . gradle . platform . base . internal . builder . TypeBuilderInternal ; import java . lang . annotation . Annotation ; public abstract class TypeModelRuleExtractor < A extends Annotation , T , U extends T > extends AbstractAnnotationDrivenComponentModelRuleExtractor < A > { private final String modelName ; private final ModelType < T > baseInterface ; private final ModelType < U > baseImplementation ; private final ModelType < ? > builderInterface ; private final ModelSchemaStore schemaStore ; private final TypeBuilderFactory < T > typeBuilderFactory ; public TypeModelRuleExtractor ( String modelName , Class < T > baseInterface , Class < U > baseImplementation , Class < ? > builderInterface , ModelSchemaStore schemaStore , TypeBuilderFactory < T > typeBuilderFactory ) { this . modelName = modelName ; this . schemaStore = schemaStore ; this . typeBuilderFactory = typeBuilderFactory ; this . baseInterface = ModelType . of ( baseInterface ) ; this . baseImplementation = ModelType . of ( baseImplementation ) ; this . builderInterface = ModelType . of ( builderInterface ) ; } @Override public < R , S > ExtractedModelRule registration ( MethodRuleDefinition < R , S > ruleDefinition , ValidationProblemCollector problems ) { try { ModelType < ? extends T > type = readType ( ruleDefinition ) ; ModelSchema < ? extends T > schema = schemaStore . getSchema ( type ) ; TypeBuilderInternal < T > builder = typeBuilderFactory . create ( schema ) ; ruleDefinition . getRuleInvoker ( ) . invoke ( builder ) ; ModelType < ? extends U > implModelType = determineImplementationType ( type , builder ) ; return createRegistration ( ruleDefinition , type , implModelType , builder ) ; } catch ( InvalidModelException e ) { throw invalidModelRule ( ruleDefinition , e ) ; } } @Nullable protected abstract < P extends T , I extends U > ExtractedModelRule createRegistration ( MethodRuleDefinition < ? , ? > ruleDefinition , ModelType < P > type , ModelType < I > implModelType , TypeBuilderInternal < T > builder ) ; protected ModelType < ? extends T > readType ( MethodRuleDefinition < ? , ? > ruleDefinition ) { assertIsVoidMethod ( ruleDefinition ) ; if ( ruleDefinition . getReferences ( ) . size ( ) ! = <int> ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , builderInterface . toString ( ) ) ) ; } ModelReference < ? > subjectReference = ruleDefinition . getSubjectReference ( ) ; @SuppressWarnings ( <str> ) ModelType < ? > builder = subjectReference . getType ( ) ; if ( ! builderInterface . isAssignableFrom ( builder ) ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , builderInterface . toString ( ) ) ) ; } if ( builder . getTypeVariables ( ) . size ( ) ! = <int> ) { throw new InvalidModelException ( String . format ( <str> , builderInterface . toString ( ) ) ) ; } ModelType < ? > subType = builder . getTypeVariables ( ) . get ( <int> ) ; if ( subType . isWildcard ( ) ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , subType . toString ( ) ) ) ; } if ( ! baseInterface . isAssignableFrom ( subType ) ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , subType . toString ( ) , baseInterface . toString ( ) ) ) ; } return subType . asSubtype ( baseInterface ) ; } protected InvalidModelRuleDeclarationException invalidModelRule ( MethodRuleDefinition < ? , ? > ruleDefinition , InvalidModelException e ) { StringBuilder sb = new StringBuilder ( ) ; ruleDefinition . getDescriptor ( ) . describeTo ( sb ) ; sb . append ( String . format ( <str> , modelName ) ) ; return new InvalidModelRuleDeclarationException ( sb . toString ( ) , e ) ; } protected ModelType < ? extends U > determineImplementationType ( ModelType < ? extends T > type , TypeBuilderInternal < T > builder ) { for ( Class < ? > internalView : builder . getInternalViews ( ) ) { if ( ! internalView . isInterface ( ) ) { throw new InvalidModelException ( String . format ( <str> , internalView . getName ( ) ) ) ; } } Class < ? extends T > implementation = builder . getDefaultImplementation ( ) ; if ( implementation = = null ) { return null ; } ModelType < ? extends T > implementationType = ModelType . of ( implementation ) ; if ( ! baseImplementation . isAssignableFrom ( implementationType ) ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , implementationType , baseImplementation ) ) ; } ModelType < ? extends U > asSubclass = implementationType . asSubtype ( baseImplementation ) ; if ( ! type . isAssignableFrom ( asSubclass ) ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , asSubclass , type ) ) ; } for ( Class < ? > internalView : builder . getInternalViews ( ) ) { if ( ! internalView . isAssignableFrom ( implementation ) ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , asSubclass , internalView . getName ( ) ) ) ; } } try { asSubclass . getRawClass ( ) . getConstructor ( ) ; } catch ( NoSuchMethodException nsmException ) { throw new InvalidModelException ( String . format ( <str> , StringUtils . capitalize ( modelName ) , asSubclass ) ) ; } return asSubclass ; } } 
