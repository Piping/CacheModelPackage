package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Optional ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . List ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class TreeTraverserTest extends TestCase { private static final class Tree { final char value ; final List < Tree > children ; public Tree ( char value , Tree . . . children ) { this . value = value ; this . children = Arrays . asList ( children ) ; } } private static final class BinaryTree { final char value ; @Nullable final BinaryTree left ; @Nullable final BinaryTree right ; private BinaryTree ( char value , BinaryTree left , BinaryTree right ) { this . value = value ; this . left = left ; this . right = right ; } } private static final TreeTraverser < Tree > ADAPTER = new TreeTraverser < Tree > ( ) { @Override public Iterable < Tree > children ( Tree node ) { return node . children ; } } ; private static final BinaryTreeTraverser < BinaryTree > BIN_ADAPTER = new BinaryTreeTraverser < BinaryTree > ( ) { @Override public Optional < BinaryTree > leftChild ( BinaryTree node ) { return Optional . fromNullable ( node . left ) ; } @Override public Optional < BinaryTree > rightChild ( BinaryTree node ) { return Optional . fromNullable ( node . right ) ; } } ; static final Tree a = new Tree ( <str> ) ; static final Tree b = new Tree ( <str> ) ; static final Tree c = new Tree ( <str> ) ; static final Tree d = new Tree ( <str> , a , b , c ) ; static final Tree e = new Tree ( <str> ) ; static final Tree f = new Tree ( <str> ) ; static final Tree g = new Tree ( <str> , f ) ; static final Tree h = new Tree ( <str> , d , e , g ) ; static final BinaryTree ba = new BinaryTree ( <str> , null , null ) ; static final BinaryTree bc = new BinaryTree ( <str> , null , null ) ; static final BinaryTree bb = new BinaryTree ( <str> , ba , bc ) ; static final BinaryTree bg = new BinaryTree ( <str> , null , null ) ; static final BinaryTree bf = new BinaryTree ( <str> , bg , null ) ; static final BinaryTree be = new BinaryTree ( <str> , null , bf ) ; static final BinaryTree bd = new BinaryTree ( <str> , bb , be ) ; static String iterationOrder ( Iterable < Tree > iterable ) { StringBuilder builder = new StringBuilder ( ) ; for ( Tree t : iterable ) { builder . append ( t . value ) ; } return builder . toString ( ) ; } static String binaryIterationOrder ( Iterable < BinaryTree > iterable ) { StringBuilder builder = new StringBuilder ( ) ; for ( BinaryTree t : iterable ) { builder . append ( t . value ) ; } return builder . toString ( ) ; } public void testPreOrder ( ) { assertThat ( iterationOrder ( ADAPTER . preOrderTraversal ( h ) ) ) . isEqualTo ( <str> ) ; assertThat ( binaryIterationOrder ( BIN_ADAPTER . preOrderTraversal ( bd ) ) ) . isEqualTo ( <str> ) ; } public void testPostOrder ( ) { assertThat ( iterationOrder ( ADAPTER . postOrderTraversal ( h ) ) ) . isEqualTo ( <str> ) ; assertThat ( binaryIterationOrder ( BIN_ADAPTER . postOrderTraversal ( bd ) ) ) . isEqualTo ( <str> ) ; } public void testBreadthOrder ( ) { assertThat ( iterationOrder ( ADAPTER . breadthFirstTraversal ( h ) ) ) . isEqualTo ( <str> ) ; assertThat ( binaryIterationOrder ( BIN_ADAPTER . breadthFirstTraversal ( bd ) ) ) . isEqualTo ( <str> ) ; } public void testInOrder ( ) { assertThat ( binaryIterationOrder ( BIN_ADAPTER . inOrderTraversal ( bd ) ) ) . isEqualTo ( <str> ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( ADAPTER ) ; tester . testAllPublicInstanceMethods ( BIN_ADAPTER ) ; } } 
