package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import java . io . Serializable ; import java . nio . ByteBuffer ; import javax . annotation . Nullable ; final class SipHashFunction extends AbstractStreamingHashFunction implements Serializable { private final int c ; private final int d ; private final long k0 ; private final long k1 ; SipHashFunction ( int c , int d , long k0 , long k1 ) { checkArgument ( c > <int> , <str> , c ) ; checkArgument ( d > <int> , <str> , d ) ; this . c = c ; this . d = d ; this . k0 = k0 ; this . k1 = k1 ; } @Override public int bits ( ) { return <int> ; } @Override public Hasher newHasher ( ) { return new SipHasher ( c , d , k0 , k1 ) ; } @Override public String toString ( ) { return <str> + c + <str> + d + <str> + k0 + <str> + k1 + <str> ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof SipHashFunction ) { SipHashFunction other = ( SipHashFunction ) object ; return ( c = = other . c ) & & ( d = = other . d ) & & ( k0 = = other . k0 ) & & ( k1 = = other . k1 ) ; } return false ; } @Override public int hashCode ( ) { return ( int ) ( getClass ( ) . hashCode ( ) ^ c ^ d ^ k0 ^ k1 ) ; } private static final class SipHasher extends AbstractStreamingHasher { private static final int CHUNK_SIZE = <int> ; private final int c ; private final int d ; private long v0 = <hex> ; private long v1 = <hex> ; private long v2 = <hex> ; private long v3 = <hex> ; private long b = <int> ; private long finalM = <int> ; SipHasher ( int c , int d , long k0 , long k1 ) { super ( CHUNK_SIZE ) ; this . c = c ; this . d = d ; this . v0 ^ = k0 ; this . v1 ^ = k1 ; this . v2 ^ = k0 ; this . v3 ^ = k1 ; } @Override protected void process ( ByteBuffer buffer ) { b + = CHUNK_SIZE ; processM ( buffer . getLong ( ) ) ; } @Override protected void processRemaining ( ByteBuffer buffer ) { b + = buffer . remaining ( ) ; for ( int i = <int> ; buffer . hasRemaining ( ) ; i + = <int> ) { finalM ^ = ( buffer . get ( ) & <hex> ) < < i ; } } @Override public HashCode makeHash ( ) { finalM ^ = b < < <int> ; processM ( finalM ) ; v2 ^ = <hex> ; sipRound ( d ) ; return HashCode . fromLong ( v0 ^ v1 ^ v2 ^ v3 ) ; } private void processM ( long m ) { v3 ^ = m ; sipRound ( c ) ; v0 ^ = m ; } private void sipRound ( int iterations ) { for ( int i = <int> ; i < iterations ; i + + ) { v0 + = v1 ; v2 + = v3 ; v1 = Long . rotateLeft ( v1 , <int> ) ; v3 = Long . rotateLeft ( v3 , <int> ) ; v1 ^ = v0 ; v3 ^ = v2 ; v0 = Long . rotateLeft ( v0 , <int> ) ; v2 + = v1 ; v0 + = v3 ; v1 = Long . rotateLeft ( v1 , <int> ) ; v3 = Long . rotateLeft ( v3 , <int> ) ; v1 ^ = v2 ; v3 ^ = v0 ; v2 = Long . rotateLeft ( v2 , <int> ) ; } } } private static final long serialVersionUID = <int> L ; } 
