package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . atomic . AtomicLong ; import org . apache . commons . lang3 . StringUtils ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . SerializationHelper ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class Mutation implements IMutation { public static final MutationSerializer serializer = new MutationSerializer ( ) ; private static final Logger logger = LoggerFactory . getLogger ( Mutation . class ) ; public static final String FORWARD_TO = <str> ; public static final String FORWARD_FROM = <str> ; private final String keyspaceName ; private final DecoratedKey key ; private final Map < UUID , PartitionUpdate > modifications ; public final long createdAt = System . currentTimeMillis ( ) ; public final AtomicLong viewLockAcquireStart = new AtomicLong ( <int> ) ; public Mutation ( String keyspaceName , DecoratedKey key ) { this ( keyspaceName , key , new HashMap < > ( ) ) ; } public Mutation ( PartitionUpdate update ) { this ( update . metadata ( ) . ksName , update . partitionKey ( ) , Collections . singletonMap ( update . metadata ( ) . cfId , update ) ) ; } protected Mutation ( String keyspaceName , DecoratedKey key , Map < UUID , PartitionUpdate > modifications ) { this . keyspaceName = keyspaceName ; this . key = key ; this . modifications = modifications ; } public Mutation copy ( ) { return new Mutation ( keyspaceName , key , new HashMap < > ( modifications ) ) ; } public Mutation without ( Set < UUID > cfIds ) { if ( cfIds . isEmpty ( ) ) return this ; Mutation copy = copy ( ) ; copy . modifications . keySet ( ) . removeAll ( cfIds ) ; return copy ; } public Mutation without ( UUID cfId ) { return without ( Collections . singleton ( cfId ) ) ; } public String getKeyspaceName ( ) { return keyspaceName ; } public Collection < UUID > getColumnFamilyIds ( ) { return modifications . keySet ( ) ; } public DecoratedKey key ( ) { return key ; } public Collection < PartitionUpdate > getPartitionUpdates ( ) { return modifications . values ( ) ; } public PartitionUpdate getPartitionUpdate ( UUID cfId ) { return modifications . get ( cfId ) ; } public Mutation add ( PartitionUpdate update ) { assert update ! = null ; assert update . partitionKey ( ) . getPartitioner ( ) = = key . getPartitioner ( ) ; PartitionUpdate prev = modifications . put ( update . metadata ( ) . cfId , update ) ; if ( prev ! = null ) throw new IllegalArgumentException ( <str> + update . metadata ( ) . cfName + <str> + prev ) ; return this ; } public PartitionUpdate get ( CFMetaData cfm ) { return modifications . get ( cfm . cfId ) ; } public boolean isEmpty ( ) { return modifications . isEmpty ( ) ; } public static Mutation merge ( List < Mutation > mutations ) { assert ! mutations . isEmpty ( ) ; if ( mutations . size ( ) = = <int> ) return mutations . get ( <int> ) ; Set < UUID > updatedTables = new HashSet < > ( ) ; String ks = null ; DecoratedKey key = null ; for ( Mutation mutation : mutations ) { updatedTables . addAll ( mutation . modifications . keySet ( ) ) ; if ( ks ! = null & & ! ks . equals ( mutation . keyspaceName ) ) throw new IllegalArgumentException ( ) ; if ( key ! = null & & ! key . equals ( mutation . key ) ) throw new IllegalArgumentException ( ) ; ks = mutation . keyspaceName ; key = mutation . key ; } List < PartitionUpdate > updates = new ArrayList < > ( mutations . size ( ) ) ; Map < UUID , PartitionUpdate > modifications = new HashMap < > ( updatedTables . size ( ) ) ; for ( UUID table : updatedTables ) { for ( Mutation mutation : mutations ) { PartitionUpdate upd = mutation . modifications . get ( table ) ; if ( upd ! = null ) updates . add ( upd ) ; } if ( updates . isEmpty ( ) ) continue ; modifications . put ( table , updates . size ( ) = = <int> ? updates . get ( <int> ) : PartitionUpdate . merge ( updates ) ) ; updates . clear ( ) ; } return new Mutation ( ks , key , modifications ) ; } public void apply ( ) { Keyspace ks = Keyspace . open ( keyspaceName ) ; ks . apply ( this , ks . getMetadata ( ) . params . durableWrites ) ; } public void apply ( boolean durableWrites ) { Keyspace . open ( keyspaceName ) . apply ( this , durableWrites ) ; } public void applyUnsafe ( ) { Keyspace . open ( keyspaceName ) . apply ( this , false ) ; } public MessageOut < Mutation > createMessage ( ) { return createMessage ( MessagingService . Verb . MUTATION ) ; } public MessageOut < Mutation > createMessage ( MessagingService . Verb verb ) { return new MessageOut < > ( verb , this , serializer ) ; } public long getTimeout ( ) { return DatabaseDescriptor . getWriteRpcTimeout ( ) ; } public int smallestGCGS ( ) { int gcgs = Integer . MAX_VALUE ; for ( PartitionUpdate update : getPartitionUpdates ( ) ) gcgs = Math . min ( gcgs , update . metadata ( ) . params . gcGraceSeconds ) ; return gcgs ; } public String toString ( ) { return toString ( false ) ; } public String toString ( boolean shallow ) { StringBuilder buff = new StringBuilder ( <str> ) ; buff . append ( <str> ) . append ( keyspaceName ) . append ( <str> ) ; buff . append ( <str> ) . append ( ByteBufferUtil . bytesToHex ( key . getKey ( ) ) ) . append ( <str> ) ; buff . append ( <str> ) ; if ( shallow ) { List < String > cfnames = new ArrayList < String > ( modifications . size ( ) ) ; for ( UUID cfid : modifications . keySet ( ) ) { CFMetaData cfm = Schema . instance . getCFMetaData ( cfid ) ; cfnames . add ( cfm = = null ? <str> : cfm . cfName ) ; } buff . append ( StringUtils . join ( cfnames , <str> ) ) ; } else { buff . append ( <str> ) . append ( StringUtils . join ( modifications . values ( ) , <str> ) ) . append ( <str> ) ; } return buff . append ( <str> ) . toString ( ) ; } public static class MutationSerializer implements IVersionedSerializer < Mutation > { public void serialize ( Mutation mutation , DataOutputPlus out , int version ) throws IOException { if ( version < MessagingService . VERSION_20 ) out . writeUTF ( mutation . getKeyspaceName ( ) ) ; int size = mutation . modifications . size ( ) ; if ( version < MessagingService . VERSION_30 ) { ByteBufferUtil . writeWithShortLength ( mutation . key ( ) . getKey ( ) , out ) ; out . writeInt ( size ) ; } else { out . writeUnsignedVInt ( size ) ; } assert size > <int> ; for ( Map . Entry < UUID , PartitionUpdate > entry : mutation . modifications . entrySet ( ) ) PartitionUpdate . serializer . serialize ( entry . getValue ( ) , out , version ) ; } public Mutation deserialize ( DataInputPlus in , int version , SerializationHelper . Flag flag ) throws IOException { if ( version < MessagingService . VERSION_20 ) in . readUTF ( ) ; ByteBuffer key = null ; int size ; if ( version < MessagingService . VERSION_30 ) { key = ByteBufferUtil . readWithShortLength ( in ) ; size = in . readInt ( ) ; } else { size = ( int ) in . readUnsignedVInt ( ) ; } assert size > <int> ; PartitionUpdate update = PartitionUpdate . serializer . deserialize ( in , version , flag , key ) ; if ( size = = <int> ) return new Mutation ( update ) ; Map < UUID , PartitionUpdate > modifications = new HashMap < > ( size ) ; DecoratedKey dk = update . partitionKey ( ) ; modifications . put ( update . metadata ( ) . cfId , update ) ; for ( int i = <int> ; i < size ; + + i ) { update = PartitionUpdate . serializer . deserialize ( in , version , flag , dk ) ; modifications . put ( update . metadata ( ) . cfId , update ) ; } return new Mutation ( update . metadata ( ) . ksName , dk , modifications ) ; } public Mutation deserialize ( DataInputPlus in , int version ) throws IOException { return deserialize ( in , version , SerializationHelper . Flag . FROM_REMOTE ) ; } public long serializedSize ( Mutation mutation , int version ) { int size = <int> ; if ( version < MessagingService . VERSION_20 ) size + = TypeSizes . sizeof ( mutation . getKeyspaceName ( ) ) ; if ( version < MessagingService . VERSION_30 ) { int keySize = mutation . key ( ) . getKey ( ) . remaining ( ) ; size + = TypeSizes . sizeof ( ( short ) keySize ) + keySize ; size + = TypeSizes . sizeof ( mutation . modifications . size ( ) ) ; } else { size + = TypeSizes . sizeofUnsignedVInt ( mutation . modifications . size ( ) ) ; } for ( Map . Entry < UUID , PartitionUpdate > entry : mutation . modifications . entrySet ( ) ) size + = PartitionUpdate . serializer . serializedSize ( entry . getValue ( ) , version ) ; return size ; } } } 
