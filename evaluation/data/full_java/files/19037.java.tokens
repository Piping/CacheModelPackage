package io . netty . handler . codec . dns ; import io . netty . channel . AddressedEnvelope ; import io . netty . util . internal . StringUtil ; import java . net . SocketAddress ; final class DnsMessageUtil { static StringBuilder appendQuery ( StringBuilder buf , DnsQuery query ) { appendQueryHeader ( buf , query ) ; appendAllRecords ( buf , query ) ; return buf ; } static StringBuilder appendResponse ( StringBuilder buf , DnsResponse response ) { appendResponseHeader ( buf , response ) ; appendAllRecords ( buf , response ) ; return buf ; } static StringBuilder appendRecordClass ( StringBuilder buf , int dnsClass ) { final String name ; switch ( dnsClass & = <hex> ) { case DnsRecord . CLASS_IN : name = <str> ; break ; case DnsRecord . CLASS_CSNET : name = <str> ; break ; case DnsRecord . CLASS_CHAOS : name = <str> ; break ; case DnsRecord . CLASS_HESIOD : name = <str> ; break ; case DnsRecord . CLASS_NONE : name = <str> ; break ; case DnsRecord . CLASS_ANY : name = <str> ; break ; default : name = null ; break ; } if ( name ! = null ) { buf . append ( name ) ; } else { buf . append ( <str> ) . append ( dnsClass ) . append ( <str> ) ; } return buf ; } private static void appendQueryHeader ( StringBuilder buf , DnsQuery msg ) { buf . append ( StringUtil . simpleClassName ( msg ) ) . append ( <str> ) ; appendAddresses ( buf , msg ) . append ( msg . id ( ) ) . append ( <str> ) . append ( msg . opCode ( ) ) ; if ( msg . isRecursionDesired ( ) ) { buf . append ( <str> ) ; } if ( msg . z ( ) ! = <int> ) { buf . append ( <str> ) . append ( msg . z ( ) ) ; } buf . append ( <str> ) ; } private static void appendResponseHeader ( StringBuilder buf , DnsResponse msg ) { buf . append ( StringUtil . simpleClassName ( msg ) ) . append ( <str> ) ; appendAddresses ( buf , msg ) . append ( msg . id ( ) ) . append ( <str> ) . append ( msg . opCode ( ) ) . append ( <str> ) . append ( msg . code ( ) ) . append ( <str> ) ; boolean hasComma = true ; if ( msg . isRecursionDesired ( ) ) { hasComma = false ; buf . append ( <str> ) ; } if ( msg . isAuthoritativeAnswer ( ) ) { hasComma = false ; buf . append ( <str> ) ; } if ( msg . isTruncated ( ) ) { hasComma = false ; buf . append ( <str> ) ; } if ( msg . isRecursionAvailable ( ) ) { hasComma = false ; buf . append ( <str> ) ; } if ( msg . z ( ) ! = <int> ) { if ( ! hasComma ) { buf . append ( <str> ) ; } buf . append ( <str> ) . append ( msg . z ( ) ) ; } if ( hasComma ) { buf . setCharAt ( buf . length ( ) - <int> , <str> ) ; } else { buf . append ( <str> ) ; } } private static StringBuilder appendAddresses ( StringBuilder buf , DnsMessage msg ) { if ( ! ( msg instanceof AddressedEnvelope ) ) { return buf ; } @SuppressWarnings ( <str> ) AddressedEnvelope < ? , SocketAddress > envelope = ( AddressedEnvelope < ? , SocketAddress > ) msg ; SocketAddress addr = envelope . sender ( ) ; if ( addr ! = null ) { buf . append ( <str> ) . append ( addr ) . append ( <str> ) ; } addr = envelope . recipient ( ) ; if ( addr ! = null ) { buf . append ( <str> ) . append ( addr ) . append ( <str> ) ; } return buf ; } private static void appendAllRecords ( StringBuilder buf , DnsMessage msg ) { appendRecords ( buf , msg , DnsSection . QUESTION ) ; appendRecords ( buf , msg , DnsSection . ANSWER ) ; appendRecords ( buf , msg , DnsSection . AUTHORITY ) ; appendRecords ( buf , msg , DnsSection . ADDITIONAL ) ; } private static void appendRecords ( StringBuilder buf , DnsMessage message , DnsSection section ) { final int count = message . count ( section ) ; for ( int i = <int> ; i < count ; i + + ) { buf . append ( StringUtil . NEWLINE ) . append ( StringUtil . TAB ) . append ( message . recordAt ( section , i ) ) ; } } private DnsMessageUtil ( ) { } } 
