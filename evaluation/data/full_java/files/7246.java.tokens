package org . elasticsearch . search . aggregations . bucket . significant . heuristics ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class GND extends NXYSignificanceHeuristic { protected static final ParseField NAMES_FIELD = new ParseField ( <str> ) ; public GND ( boolean backgroundIsSuperset ) { super ( true , backgroundIsSuperset ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof GND ) ) { return false ; } return super . equals ( other ) ; } @Override public int hashCode ( ) { int result = NAMES_FIELD . getPreferredName ( ) . hashCode ( ) ; result = <int> * result + super . hashCode ( ) ; return result ; } public static final SignificanceHeuristicStreams . Stream STREAM = new SignificanceHeuristicStreams . Stream ( ) { @Override public SignificanceHeuristic readResult ( StreamInput in ) throws IOException { return new GND ( in . readBoolean ( ) ) ; } @Override public String getName ( ) { return NAMES_FIELD . getPreferredName ( ) ; } } ; @Override public double getScore ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize ) { Frequencies frequencies = computeNxys ( subsetFreq , subsetSize , supersetFreq , supersetSize , <str> ) ; double fx = frequencies . N1_ ; double fy = frequencies . N_1 ; double fxy = frequencies . N11 ; double N = frequencies . N ; if ( fxy = = <int> ) { return <float> ; } if ( ( fx = = fy ) & & ( fx = = fxy ) ) { return <float> ; } double score = ( Math . max ( Math . log ( fx ) , Math . log ( fy ) ) - Math . log ( fxy ) ) / ( Math . log ( N ) - Math . min ( Math . log ( fx ) , Math . log ( fy ) ) ) ; score = Math . exp ( - <float> * score ) ; return score ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; out . writeBoolean ( backgroundIsSuperset ) ; } public static class GNDParser extends NXYParser { @Override public String [ ] getNames ( ) { return NAMES_FIELD . getAllNamesIncludedDeprecated ( ) ; } @Override protected SignificanceHeuristic newHeuristic ( boolean includeNegatives , boolean backgroundIsSuperset ) { return new GND ( backgroundIsSuperset ) ; } @Override public SignificanceHeuristic parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher , SearchContext context ) throws IOException , QueryShardException { String givenName = parser . currentName ( ) ; boolean backgroundIsSuperset = true ; XContentParser . Token token = parser . nextToken ( ) ; while ( ! token . equals ( XContentParser . Token . END_OBJECT ) ) { if ( parseFieldMatcher . match ( parser . currentName ( ) , BACKGROUND_IS_SUPERSET ) ) { parser . nextToken ( ) ; backgroundIsSuperset = parser . booleanValue ( ) ; } else { throw new ElasticsearchParseException ( <str> , givenName , parser . currentName ( ) ) ; } token = parser . nextToken ( ) ; } return newHeuristic ( true , backgroundIsSuperset ) ; } } public static class GNDBuilder extends NXYBuilder { public GNDBuilder ( boolean backgroundIsSuperset ) { super ( true , backgroundIsSuperset ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( STREAM . getName ( ) ) ; builder . field ( BACKGROUND_IS_SUPERSET . getPreferredName ( ) , backgroundIsSuperset ) ; builder . endObject ( ) ; return builder ; } } } 
