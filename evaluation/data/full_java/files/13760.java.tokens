package org . gradle . launcher . cli ; import groovy . lang . GroovySystem ; import org . apache . tools . ant . Main ; import org . gradle . BuildExceptionReporter ; import org . gradle . api . Action ; import org . gradle . cli . CommandLineArgumentException ; import org . gradle . cli . CommandLineConverter ; import org . gradle . cli . CommandLineParser ; import org . gradle . cli . ParsedCommandLine ; import org . gradle . configuration . GradleLauncherMetaData ; import org . gradle . initialization . BuildLayoutParameters ; import org . gradle . initialization . LayoutCommandLineConverter ; import org . gradle . internal . Actions ; import org . gradle . internal . jvm . Jvm ; import org . gradle . internal . nativeintegration . services . NativeServices ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . launcher . bootstrap . ExecutionListener ; import org . gradle . logging . LoggingConfiguration ; import org . gradle . logging . LoggingManagerInternal ; import org . gradle . logging . LoggingServiceRegistry ; import org . gradle . logging . StyledTextOutputFactory ; import org . gradle . logging . internal . LoggingCommandLineConverter ; import org . gradle . util . GradleVersion ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; public class CommandLineActionFactory { private static final String HELP = <str> ; private static final String VERSION = <str> ; public Action < ExecutionListener > convert ( List < String > args ) { ServiceRegistry loggingServices = createLoggingServices ( ) ; LoggingConfiguration loggingConfiguration = new LoggingConfiguration ( ) ; return new ExceptionReportingAction ( new WithLogging ( loggingServices , args , loggingConfiguration , new JavaRuntimeValidationAction ( new ParseAndBuildAction ( loggingServices , args ) ) ) , new BuildExceptionReporter ( loggingServices . get ( StyledTextOutputFactory . class ) , loggingConfiguration , clientMetaData ( ) ) ) ; } protected void createActionFactories ( ServiceRegistry loggingServices , Collection < CommandLineAction > actions ) { actions . add ( new GuiActionsFactory ( ) ) ; actions . add ( new BuildActionsFactory ( loggingServices , new ParametersConverter ( ) ) ) ; } private static GradleLauncherMetaData clientMetaData ( ) { return new GradleLauncherMetaData ( ) ; } public ServiceRegistry createLoggingServices ( ) { return LoggingServiceRegistry . newCommandLineProcessLogging ( ) ; } private static void showUsage ( PrintStream out , CommandLineParser parser ) { out . println ( ) ; out . print ( <str> ) ; clientMetaData ( ) . describeCommand ( out , <str> , <str> ) ; out . println ( ) ; out . println ( ) ; parser . printUsage ( out ) ; out . println ( ) ; } private static class BuiltInActions implements CommandLineAction { public void configureCommandLineParser ( CommandLineParser parser ) { parser . option ( HELP , <str> , <str> ) . hasDescription ( <str> ) ; parser . option ( VERSION , <str> ) . hasDescription ( <str> ) ; } public Runnable createAction ( CommandLineParser parser , ParsedCommandLine commandLine ) { if ( commandLine . hasOption ( HELP ) ) { return new ShowUsageAction ( parser ) ; } if ( commandLine . hasOption ( VERSION ) ) { return new ShowVersionAction ( ) ; } return null ; } } private static class CommandLineParseFailureAction implements Action < ExecutionListener > { private final Exception e ; private final CommandLineParser parser ; public CommandLineParseFailureAction ( CommandLineParser parser , Exception e ) { this . parser = parser ; this . e = e ; } public void execute ( ExecutionListener executionListener ) { System . err . println ( ) ; System . err . println ( e . getMessage ( ) ) ; showUsage ( System . err , parser ) ; executionListener . onFailure ( e ) ; } } private static class ShowUsageAction implements Runnable { private final CommandLineParser parser ; public ShowUsageAction ( CommandLineParser parser ) { this . parser = parser ; } public void run ( ) { showUsage ( System . out , parser ) ; } } private static class ShowVersionAction implements Runnable { public void run ( ) { GradleVersion currentVersion = GradleVersion . current ( ) ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; sb . append ( currentVersion . getVersion ( ) ) ; sb . append ( <str> ) ; sb . append ( currentVersion . getBuildTime ( ) ) ; sb . append ( <str> ) ; sb . append ( currentVersion . getBuildNumber ( ) ) ; sb . append ( <str> ) ; sb . append ( currentVersion . getRevision ( ) ) ; sb . append ( <str> ) ; sb . append ( GroovySystem . getVersion ( ) ) ; sb . append ( <str> ) ; sb . append ( Main . getAntVersion ( ) ) ; sb . append ( <str> ) ; sb . append ( Jvm . current ( ) ) ; sb . append ( <str> ) ; sb . append ( OperatingSystem . current ( ) ) ; sb . append ( <str> ) ; System . out . println ( sb . toString ( ) ) ; } } private static class WithLogging implements Action < ExecutionListener > { private final ServiceRegistry loggingServices ; private final List < String > args ; private final LoggingConfiguration loggingConfiguration ; private final Action < ExecutionListener > action ; WithLogging ( ServiceRegistry loggingServices , List < String > args , LoggingConfiguration loggingConfiguration , Action < ExecutionListener > action ) { this . loggingServices = loggingServices ; this . args = args ; this . loggingConfiguration = loggingConfiguration ; this . action = action ; } public void execute ( ExecutionListener executionListener ) { CommandLineConverter < LoggingConfiguration > loggingConfigurationConverter = new LoggingCommandLineConverter ( ) ; CommandLineConverter < BuildLayoutParameters > buildLayoutConverter = new LayoutCommandLineConverter ( ) ; BuildLayoutParameters buildLayout = new BuildLayoutParameters ( ) ; CommandLineParser parser = new CommandLineParser ( ) ; loggingConfigurationConverter . configure ( parser ) ; buildLayoutConverter . configure ( parser ) ; parser . allowUnknownOptions ( ) ; parser . allowMixedSubcommandsAndOptions ( ) ; try { ParsedCommandLine parsedCommandLine = parser . parse ( args ) ; loggingConfigurationConverter . convert ( parsedCommandLine , loggingConfiguration ) ; buildLayoutConverter . convert ( parsedCommandLine , buildLayout ) ; } catch ( CommandLineArgumentException e ) { } LoggingManagerInternal loggingManager = loggingServices . getFactory ( LoggingManagerInternal . class ) . create ( ) ; loggingManager . setLevel ( loggingConfiguration . getLogLevel ( ) ) ; loggingManager . start ( ) ; NativeServices . initialize ( buildLayout . getGradleUserHomeDir ( ) ) ; loggingManager . attachProcessConsole ( loggingConfiguration . getConsoleOutput ( ) ) ; action . execute ( executionListener ) ; } } private class ParseAndBuildAction implements Action < ExecutionListener > { private final ServiceRegistry loggingServices ; private final List < String > args ; private ParseAndBuildAction ( ServiceRegistry loggingServices , List < String > args ) { this . loggingServices = loggingServices ; this . args = args ; } public void execute ( ExecutionListener executionListener ) { List < CommandLineAction > actions = new ArrayList < CommandLineAction > ( ) ; actions . add ( new BuiltInActions ( ) ) ; createActionFactories ( loggingServices , actions ) ; CommandLineParser parser = new CommandLineParser ( ) ; for ( CommandLineAction action : actions ) { action . configureCommandLineParser ( parser ) ; } Action < ? super ExecutionListener > action ; try { ParsedCommandLine commandLine = parser . parse ( args ) ; action = createAction ( actions , parser , commandLine ) ; } catch ( CommandLineArgumentException e ) { action = new CommandLineParseFailureAction ( parser , e ) ; } action . execute ( executionListener ) ; } private Action < ? super ExecutionListener > createAction ( Iterable < CommandLineAction > factories , CommandLineParser parser , ParsedCommandLine commandLine ) { for ( CommandLineAction factory : factories ) { Runnable action = factory . createAction ( parser , commandLine ) ; if ( action ! = null ) { return Actions . toAction ( action ) ; } } throw new UnsupportedOperationException ( <str> ) ; } } } 
