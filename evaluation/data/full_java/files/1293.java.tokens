package org . apache . cassandra . utils . obs ; import java . util . Arrays ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . IOException ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . utils . concurrent . Ref ; public class OpenBitSet implements IBitSet { private final long [ ] [ ] bits ; private int wlen ; private final int pageCount ; private static final int PAGE_SIZE = <int> ; public OpenBitSet ( long numBits ) { wlen = ( int ) bits2words ( numBits ) ; int lastPageSize = wlen % PAGE_SIZE ; int fullPageCount = wlen / PAGE_SIZE ; pageCount = fullPageCount + ( lastPageSize = = <int> ? <int> : <int> ) ; bits = new long [ pageCount ] [ ] ; for ( int i = <int> ; i < fullPageCount ; + + i ) bits [ i ] = new long [ PAGE_SIZE ] ; if ( lastPageSize ! = <int> ) bits [ bits . length - <int> ] = new long [ lastPageSize ] ; } public OpenBitSet ( ) { this ( <int> ) ; } public int getPageSize ( ) { return PAGE_SIZE ; } public int getPageCount ( ) { return pageCount ; } public long [ ] getPage ( int pageIdx ) { return bits [ pageIdx ] ; } public long capacity ( ) { return ( ( long ) wlen ) < < <int> ; } @Override public long offHeapSize ( ) { return <int> ; } public void addTo ( Ref . IdentityCollection identities ) { } public long size ( ) { return capacity ( ) ; } public long length ( ) { return capacity ( ) ; } public boolean isEmpty ( ) { return cardinality ( ) = = <int> ; } public int getNumWords ( ) { return wlen ; } public boolean get ( int index ) { int i = index > > <int> ; int bit = index & <hex> ; long bitmask = <int> < < bit ; return ( bits [ i / PAGE_SIZE ] [ i % PAGE_SIZE ] & bitmask ) ! = <int> ; } public boolean get ( long index ) { int i = ( int ) ( index > > <int> ) ; int bit = ( int ) index & <hex> ; long bitmask = <int> < < bit ; return ( bits [ i / PAGE_SIZE ] [ i % PAGE_SIZE ] & bitmask ) ! = <int> ; } public void set ( long index ) { int wordNum = ( int ) ( index > > <int> ) ; int bit = ( int ) index & <hex> ; long bitmask = <int> < < bit ; bits [ wordNum / PAGE_SIZE ] [ wordNum % PAGE_SIZE ] | = bitmask ; } public void set ( int index ) { int wordNum = index > > <int> ; int bit = index & <hex> ; long bitmask = <int> < < bit ; bits [ wordNum / PAGE_SIZE ] [ wordNum % PAGE_SIZE ] | = bitmask ; } public void clear ( int index ) { int wordNum = index > > <int> ; int bit = index & <hex> ; long bitmask = <int> < < bit ; bits [ wordNum / PAGE_SIZE ] [ wordNum % PAGE_SIZE ] & = ~ bitmask ; } public void clear ( long index ) { int wordNum = ( int ) ( index > > <int> ) ; int bit = ( int ) index & <hex> ; long bitmask = <int> < < bit ; bits [ wordNum / PAGE_SIZE ] [ wordNum % PAGE_SIZE ] & = ~ bitmask ; } public void clear ( int startIndex , int endIndex ) { if ( endIndex < = startIndex ) return ; int startWord = ( startIndex > > <int> ) ; if ( startWord > = wlen ) return ; int endWord = ( ( endIndex - <int> ) > > <int> ) ; long startmask = - <int> < < startIndex ; long endmask = - <int> > > > - endIndex ; startmask = ~ startmask ; endmask = ~ endmask ; if ( startWord = = endWord ) { bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] & = ( startmask | endmask ) ; return ; } bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] & = startmask ; int middle = Math . min ( wlen , endWord ) ; if ( startWord / PAGE_SIZE = = middle / PAGE_SIZE ) { Arrays . fill ( bits [ startWord / PAGE_SIZE ] , ( startWord + <int> ) % PAGE_SIZE , middle % PAGE_SIZE , <int> L ) ; } else { while ( + + startWord < middle ) bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] = <int> L ; } if ( endWord < wlen ) { bits [ endWord / PAGE_SIZE ] [ endWord % PAGE_SIZE ] & = endmask ; } } public void clear ( long startIndex , long endIndex ) { if ( endIndex < = startIndex ) return ; int startWord = ( int ) ( startIndex > > <int> ) ; if ( startWord > = wlen ) return ; int endWord = ( int ) ( ( endIndex - <int> ) > > <int> ) ; long startmask = - <int> < < startIndex ; long endmask = - <int> > > > - endIndex ; startmask = ~ startmask ; endmask = ~ endmask ; if ( startWord = = endWord ) { bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] & = ( startmask | endmask ) ; return ; } bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] & = startmask ; int middle = Math . min ( wlen , endWord ) ; if ( startWord / PAGE_SIZE = = middle / PAGE_SIZE ) { Arrays . fill ( bits [ startWord / PAGE_SIZE ] , ( startWord + <int> ) % PAGE_SIZE , middle % PAGE_SIZE , <int> L ) ; } else { while ( + + startWord < middle ) bits [ startWord / PAGE_SIZE ] [ startWord % PAGE_SIZE ] = <int> L ; } if ( endWord < wlen ) { bits [ endWord / PAGE_SIZE ] [ endWord % PAGE_SIZE ] & = endmask ; } } public long cardinality ( ) { long bitCount = <int> L ; for ( int i = getPageCount ( ) ; i - - > <int> ; ) bitCount + = BitUtil . pop_array ( bits [ i ] , <int> , wlen ) ; return bitCount ; } public void intersect ( OpenBitSet other ) { int newLen = Math . min ( this . wlen , other . wlen ) ; long [ ] [ ] thisArr = this . bits ; long [ ] [ ] otherArr = other . bits ; int thisPageSize = PAGE_SIZE ; int otherPageSize = OpenBitSet . PAGE_SIZE ; int pos = newLen ; while ( - - pos > = <int> ) { thisArr [ pos / thisPageSize ] [ pos % thisPageSize ] & = otherArr [ pos / otherPageSize ] [ pos % otherPageSize ] ; } if ( this . wlen > newLen ) { for ( pos = wlen ; pos - - > newLen ; ) thisArr [ pos / thisPageSize ] [ pos % thisPageSize ] = <int> ; } this . wlen = newLen ; } public void and ( OpenBitSet other ) { intersect ( other ) ; } public void trimTrailingZeros ( ) { int idx = wlen - <int> ; while ( idx > = <int> & & bits [ idx / PAGE_SIZE ] [ idx % PAGE_SIZE ] = = <int> ) idx - - ; wlen = idx + <int> ; } public static long bits2words ( long numBits ) { return ( ( ( numBits - <int> ) > > > <int> ) + <int> ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof OpenBitSet ) ) return false ; OpenBitSet a ; OpenBitSet b = ( OpenBitSet ) o ; if ( b . wlen > this . wlen ) { a = b ; b = this ; } else { a = this ; } int aPageSize = OpenBitSet . PAGE_SIZE ; int bPageSize = OpenBitSet . PAGE_SIZE ; for ( int i = a . wlen - <int> ; i > = b . wlen ; i - - ) { if ( a . bits [ i / aPageSize ] [ i % aPageSize ] ! = <int> ) return false ; } for ( int i = b . wlen - <int> ; i > = <int> ; i - - ) { if ( a . bits [ i / aPageSize ] [ i % aPageSize ] ! = b . bits [ i / bPageSize ] [ i % bPageSize ] ) return false ; } return true ; } @Override public int hashCode ( ) { long h = <int> ; for ( int i = wlen ; - - i > = <int> ; ) { h ^ = bits [ i / PAGE_SIZE ] [ i % PAGE_SIZE ] ; h = ( h < < <int> ) | ( h > > > <int> ) ; } return ( int ) ( ( h > > <int> ) ^ h ) + <hex> ; } public void close ( ) { } public void serialize ( DataOutput out ) throws IOException { int bitLength = getNumWords ( ) ; int pageSize = getPageSize ( ) ; int pageCount = getPageCount ( ) ; out . writeInt ( bitLength ) ; for ( int p = <int> ; p < pageCount ; p + + ) { long [ ] bits = getPage ( p ) ; for ( int i = <int> ; i < pageSize & & bitLength - - > <int> ; i + + ) { out . writeLong ( bits [ i ] ) ; } } } public long serializedSize ( ) { int bitLength = getNumWords ( ) ; int pageSize = getPageSize ( ) ; int pageCount = getPageCount ( ) ; long size = TypeSizes . sizeof ( bitLength ) ; for ( int p = <int> ; p < pageCount ; p + + ) { long [ ] bits = getPage ( p ) ; for ( int i = <int> ; i < pageSize & & bitLength - - > <int> ; i + + ) size + = TypeSizes . sizeof ( bits [ i ] ) ; } return size ; } public void clear ( ) { clear ( <int> , capacity ( ) ) ; } public static OpenBitSet deserialize ( DataInput in ) throws IOException { long bitLength = in . readInt ( ) ; OpenBitSet bs = new OpenBitSet ( bitLength < < <int> ) ; int pageSize = bs . getPageSize ( ) ; int pageCount = bs . getPageCount ( ) ; for ( int p = <int> ; p < pageCount ; p + + ) { long [ ] bits = bs . getPage ( p ) ; for ( int i = <int> ; i < pageSize & & bitLength - - > <int> ; i + + ) bits [ i ] = in . readLong ( ) ; } return bs ; } } 
