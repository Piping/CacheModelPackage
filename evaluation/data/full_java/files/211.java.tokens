package org . apache . cassandra . cql3 . restrictions ; import java . util . * ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . restrictions . SingleColumnRestriction . ContainsRestriction ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . index . SecondaryIndexManager ; final class RestrictionSet implements Restrictions , Iterable < Restriction > { private static final Comparator < ColumnDefinition > COLUMN_DEFINITION_COMPARATOR = new Comparator < ColumnDefinition > ( ) { @Override public int compare ( ColumnDefinition column , ColumnDefinition otherColumn ) { int value = Integer . compare ( column . position ( ) , otherColumn . position ( ) ) ; return value ! = <int> ? value : column . name . bytes . compareTo ( otherColumn . name . bytes ) ; } } ; protected final TreeMap < ColumnDefinition , Restriction > restrictions ; public RestrictionSet ( ) { this ( new TreeMap < ColumnDefinition , Restriction > ( COLUMN_DEFINITION_COMPARATOR ) ) ; } private RestrictionSet ( TreeMap < ColumnDefinition , Restriction > restrictions ) { this . restrictions = restrictions ; } @Override public final void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexManager , QueryOptions options ) throws InvalidRequestException { for ( Restriction restriction : restrictions . values ( ) ) restriction . addRowFilterTo ( filter , indexManager , options ) ; } @Override public final Set < ColumnDefinition > getColumnDefs ( ) { return restrictions . keySet ( ) ; } @Override public Iterable < Function > getFunctions ( ) { com . google . common . base . Function < Restriction , Iterable < Function > > transform = new com . google . common . base . Function < Restriction , Iterable < Function > > ( ) { public Iterable < Function > apply ( Restriction restriction ) { return restriction . getFunctions ( ) ; } } ; return Iterables . concat ( Iterables . transform ( restrictions . values ( ) , transform ) ) ; } @Override public final boolean isEmpty ( ) { return restrictions . isEmpty ( ) ; } @Override public final int size ( ) { return restrictions . size ( ) ; } public RestrictionSet addRestriction ( Restriction restriction ) throws InvalidRequestException { TreeMap < ColumnDefinition , Restriction > newRestrictions = new TreeMap < > ( this . restrictions ) ; return new RestrictionSet ( mergeRestrictions ( newRestrictions , restriction ) ) ; } private TreeMap < ColumnDefinition , Restriction > mergeRestrictions ( TreeMap < ColumnDefinition , Restriction > restrictions , Restriction restriction ) throws InvalidRequestException { Collection < ColumnDefinition > columnDefs = restriction . getColumnDefs ( ) ; Set < Restriction > existingRestrictions = getRestrictions ( columnDefs ) ; if ( existingRestrictions . isEmpty ( ) ) { for ( ColumnDefinition columnDef : columnDefs ) restrictions . put ( columnDef , restriction ) ; } else { for ( Restriction existing : existingRestrictions ) { Restriction newRestriction = mergeRestrictions ( existing , restriction ) ; for ( ColumnDefinition columnDef : columnDefs ) restrictions . put ( columnDef , newRestriction ) ; } } return restrictions ; } private Set < Restriction > getRestrictions ( Collection < ColumnDefinition > columnDefs ) { Set < Restriction > set = new HashSet < > ( ) ; for ( ColumnDefinition columnDef : columnDefs ) { Restriction existing = restrictions . get ( columnDef ) ; if ( existing ! = null ) set . add ( existing ) ; } return set ; } @Override public final boolean hasSupportingIndex ( SecondaryIndexManager indexManager ) { for ( Restriction restriction : restrictions . values ( ) ) { if ( restriction . hasSupportingIndex ( indexManager ) ) return true ; } return false ; } ColumnDefinition nextColumn ( ColumnDefinition columnDef ) { return restrictions . tailMap ( columnDef , false ) . firstKey ( ) ; } ColumnDefinition firstColumn ( ) { return isEmpty ( ) ? null : this . restrictions . firstKey ( ) ; } ColumnDefinition lastColumn ( ) { return isEmpty ( ) ? null : this . restrictions . lastKey ( ) ; } Restriction lastRestriction ( ) { return isEmpty ( ) ? null : this . restrictions . lastEntry ( ) . getValue ( ) ; } private static Restriction mergeRestrictions ( Restriction restriction , Restriction otherRestriction ) throws InvalidRequestException { return restriction = = null ? otherRestriction : restriction . mergeWith ( otherRestriction ) ; } public final boolean hasMultipleContains ( ) { int numberOfContains = <int> ; for ( Restriction restriction : restrictions . values ( ) ) { if ( restriction . isContains ( ) ) { ContainsRestriction contains = ( ContainsRestriction ) restriction ; numberOfContains + = ( contains . numberOfValues ( ) + contains . numberOfKeys ( ) + contains . numberOfEntries ( ) ) ; } } return numberOfContains > <int> ; } @Override public Iterator < Restriction > iterator ( ) { return new LinkedHashSet < > ( restrictions . values ( ) ) . iterator ( ) ; } } 
