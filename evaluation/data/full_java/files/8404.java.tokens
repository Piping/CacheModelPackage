package org . elasticsearch . recovery ; import org . apache . lucene . util . English ; import org . apache . lucene . util . LuceneTestCase . SuppressCodecs ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . indices . recovery . IndexRecoveryIT ; import org . elasticsearch . indices . recovery . RecoveryFileChunkRequest ; import org . elasticsearch . indices . recovery . RecoverySettings ; import org . elasticsearch . indices . recovery . RecoveryTarget ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( numDataNodes = <int> , numClientNodes = <int> , scope = ESIntegTestCase . Scope . TEST ) @SuppressCodecs ( <str> ) public class TruncatedRecoveryIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } public void testCancelRecoveryAndResume ( ) throws Exception { for ( RecoverySettings settings : internalCluster ( ) . getInstances ( RecoverySettings . class ) ) { IndexRecoveryIT . setChunkSize ( settings , new ByteSizeValue ( randomIntBetween ( <int> , <int> ) , ByteSizeUnit . BYTES ) ) ; } NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . get ( ) ; List < NodeStats > dataNodeStats = new ArrayList < > ( ) ; for ( NodeStats stat : nodeStats . getNodes ( ) ) { if ( stat . getNode ( ) . isDataNode ( ) ) { dataNodeStats . add ( stat ) ; } } assertThat ( dataNodeStats . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; Collections . shuffle ( dataNodeStats , random ( ) ) ; NodeStats primariesNode = dataNodeStats . get ( <int> ) ; NodeStats unluckyNode = dataNodeStats . get ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) . setSettings ( settingsBuilder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , numberOfShards ( ) ) . put ( <str> , primariesNode . getNode ( ) . name ( ) ) ) ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > builder = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; builder . add ( client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , English . intToEnglish ( i ) , <str> , id ) ) ; } indexRandom ( true , builder ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . termQuery ( <str> , id ) ) . get ( ) , <int> ) ; } ensureGreen ( ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . setForce ( true ) . setWaitIfOngoing ( true ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareForceMerge ( ) . setMaxNumSegments ( <int> ) . setFlush ( true ) . get ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicBoolean truncate = new AtomicBoolean ( true ) ; for ( NodeStats dataNode : dataNodeStats ) { MockTransportService mockTransportService = ( ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , dataNode . getNode ( ) . name ( ) ) ) ; mockTransportService . addDelegate ( internalCluster ( ) . getInstance ( TransportService . class , unluckyNode . getNode ( ) . name ( ) ) , new MockTransportService . DelegateTransport ( mockTransportService . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( action . equals ( RecoveryTarget . Actions . FILE_CHUNK ) ) { RecoveryFileChunkRequest req = ( RecoveryFileChunkRequest ) request ; logger . debug ( <str> + req . toString ( ) + <str> + req . lastChunk ( ) ) ; if ( ( req . name ( ) . endsWith ( <str> ) | | req . name ( ) . endsWith ( <str> ) ) & & req . lastChunk ( ) & & truncate . get ( ) ) { latch . countDown ( ) ; throw new RuntimeException ( <str> ) ; } } super . sendRequest ( node , requestId , action , request , options ) ; } } ) ; } logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( settingsBuilder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( <str> , primariesNode . getNode ( ) . name ( ) + <str> + unluckyNode . getNode ( ) . name ( ) ) ) . get ( ) ; latch . await ( ) ; truncate . compareAndSet ( true , false ) ; ensureGreen ( <str> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String id = Integer . toString ( i ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . termQuery ( <str> , id ) ) . get ( ) , <int> ) ; } } } 
