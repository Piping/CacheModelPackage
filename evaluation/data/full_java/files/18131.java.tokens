package com . badlogic . gdx . graphics . glutils ; import java . nio . ByteBuffer ; import java . nio . FloatBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class VertexBufferObjectSubData implements VertexData { final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; int bufferHandle ; final boolean isDirect ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; public VertexBufferObjectSubData ( boolean isStatic , int numVertices , VertexAttribute . . . attributes ) { this . isStatic = isStatic ; this . attributes = new VertexAttributes ( attributes ) ; byteBuffer = BufferUtils . newByteBuffer ( this . attributes . vertexSize * numVertices ) ; isDirect = true ; usage = isStatic ? GL20 . GL_STATIC_DRAW : GL20 . GL_DYNAMIC_DRAW ; buffer = byteBuffer . asFloatBuffer ( ) ; bufferHandle = createBufferObject ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; } private int createBufferObject ( ) { int result = Gdx . gl20 . glGenBuffer ( ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , result ) ; Gdx . gl20 . glBufferData ( GL20 . GL_ARRAY_BUFFER , byteBuffer . capacity ( ) , null , usage ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , <int> ) ; return result ; } @Override public VertexAttributes getAttributes ( ) { return attributes ; } @Override public int getNumVertices ( ) { return buffer . limit ( ) * <int> / attributes . vertexSize ; } @Override public int getNumMaxVertices ( ) { return byteBuffer . capacity ( ) / attributes . vertexSize ; } @Override public FloatBuffer getBuffer ( ) { isDirty = true ; return buffer ; } private void bufferChanged ( ) { if ( isBound ) { Gdx . gl20 . glBufferSubData ( GL20 . GL_ARRAY_BUFFER , <int> , byteBuffer . limit ( ) , byteBuffer ) ; isDirty = false ; } } @Override public void setVertices ( float [ ] vertices , int offset , int count ) { isDirty = true ; if ( isDirect ) { BufferUtils . copy ( vertices , byteBuffer , count , offset ) ; buffer . position ( <int> ) ; buffer . limit ( count ) ; } else { buffer . clear ( ) ; buffer . put ( vertices , offset , count ) ; buffer . flip ( ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( buffer . limit ( ) < < <int> ) ; } bufferChanged ( ) ; } @Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { isDirty = true ; if ( isDirect ) { final int pos = byteBuffer . position ( ) ; byteBuffer . position ( targetOffset * <int> ) ; BufferUtils . copy ( vertices , sourceOffset , count , byteBuffer ) ; byteBuffer . position ( pos ) ; } else throw new GdxRuntimeException ( <str> ) ; bufferChanged ( ) ; } @Override public void bind ( final ShaderProgram shader ) { bind ( shader , null ) ; } @Override public void bind ( final ShaderProgram shader , final int [ ] locations ) { final GL20 gl = Gdx . gl20 ; gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , bufferHandle ) ; if ( isDirty ) { byteBuffer . limit ( buffer . limit ( ) * <int> ) ; gl . glBufferData ( GL20 . GL_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } final int numAttributes = attributes . size ( ) ; if ( locations = = null ) { for ( int i = <int> ; i < numAttributes ; i + + ) { final VertexAttribute attribute = attributes . get ( i ) ; final int location = shader . getAttributeLocation ( attribute . alias ) ; if ( location < <int> ) continue ; shader . enableVertexAttribute ( location ) ; shader . setVertexAttribute ( location , attribute . numComponents , attribute . type , attribute . normalized , attributes . vertexSize , attribute . offset ) ; } } else { for ( int i = <int> ; i < numAttributes ; i + + ) { final VertexAttribute attribute = attributes . get ( i ) ; final int location = locations [ i ] ; if ( location < <int> ) continue ; shader . enableVertexAttribute ( location ) ; shader . setVertexAttribute ( location , attribute . numComponents , attribute . type , attribute . normalized , attributes . vertexSize , attribute . offset ) ; } } isBound = true ; } @Override public void unbind ( final ShaderProgram shader ) { unbind ( shader , null ) ; } @Override public void unbind ( final ShaderProgram shader , final int [ ] locations ) { final GL20 gl = Gdx . gl20 ; final int numAttributes = attributes . size ( ) ; if ( locations = = null ) { for ( int i = <int> ; i < numAttributes ; i + + ) { shader . disableVertexAttribute ( attributes . get ( i ) . alias ) ; } } else { for ( int i = <int> ; i < numAttributes ; i + + ) { final int location = locations [ i ] ; if ( location > = <int> ) shader . disableVertexAttribute ( location ) ; } } gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , <int> ) ; isBound = false ; } public void invalidate ( ) { bufferHandle = createBufferObject ( ) ; isDirty = true ; } @Override public void dispose ( ) { GL20 gl = Gdx . gl20 ; gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , <int> ) ; gl . glDeleteBuffer ( bufferHandle ) ; bufferHandle = <int> ; } public int getBufferHandle ( ) { return bufferHandle ; } } 
