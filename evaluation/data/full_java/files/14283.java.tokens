package org . gradle . model . internal . core ; import org . gradle . internal . BiAction ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import java . util . Collections ; import java . util . List ; public class InputUsingModelAction < T > extends AbstractModelActionWithView < T > { private final BiAction < ? super T , ? super List < ModelView < ? > > > action ; public InputUsingModelAction ( ModelReference < T > subject , ModelRuleDescriptor descriptor , List < ModelReference < ? > > inputs , BiAction < ? super T , ? super List < ModelView < ? > > > action ) { super ( subject , descriptor , inputs ) ; this . action = action ; } public static < T > InputUsingModelAction < T > of ( ModelReference < T > modelReference , ModelRuleDescriptor descriptor , List < ModelReference < ? > > inputs , BiAction < ? super T , ? super List < ModelView < ? > > > initializer ) { return new InputUsingModelAction < T > ( modelReference , descriptor , inputs , initializer ) ; } public static < T , I > InputUsingModelAction < T > single ( ModelReference < T > modelReference , ModelRuleDescriptor descriptor , final ModelReference < I > input , final BiAction < ? super T , ? super I > initializer ) { return new InputUsingModelAction < T > ( modelReference , descriptor , Collections . < ModelReference < ? > > singletonList ( input ) , new BiAction < T , List < ModelView < ? > > > ( ) { @Override public void execute ( T t , List < ModelView < ? > > modelViews ) { initializer . execute ( t , ModelViews . assertType ( modelViews . get ( <int> ) , input . getType ( ) ) . getInstance ( ) ) ; } } ) ; } @Override protected void execute ( MutableModelNode modelNode , T view , List < ModelView < ? > > inputs ) { action . execute ( view , inputs ) ; } } 
