package org . elasticsearch . common . util ; import com . carrotsearch . hppc . LongLongHashMap ; import com . carrotsearch . hppc . LongLongMap ; import com . carrotsearch . hppc . cursors . LongLongCursor ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; public class LongHashTests extends ESSingleNodeTestCase { LongHash hash ; private void newHash ( ) { if ( hash ! = null ) { hash . close ( ) ; } final float maxLoadFactor = <float> + randomFloat ( ) * <float> ; hash = new LongHash ( randomIntBetween ( <int> , <int> ) , maxLoadFactor , BigArraysTests . randombigArrays ( ) ) ; } @Override public void setUp ( ) throws Exception { super . setUp ( ) ; newHash ( ) ; } public void testDuell ( ) { final Long [ ] values = new Long [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < values . length ; + + i ) { values [ i ] = randomLong ( ) ; } final LongLongMap valueToId = new LongLongHashMap ( ) ; final long [ ] idToValue = new long [ values . length ] ; final int iters = randomInt ( <int> ) ; for ( int i = <int> ; i < iters ; + + i ) { final Long value = randomFrom ( values ) ; if ( valueToId . containsKey ( value ) ) { assertEquals ( - <int> - valueToId . get ( value ) , hash . add ( value ) ) ; } else { assertEquals ( valueToId . size ( ) , hash . add ( value ) ) ; idToValue [ valueToId . size ( ) ] = value ; valueToId . put ( value , valueToId . size ( ) ) ; } } assertEquals ( valueToId . size ( ) , hash . size ( ) ) ; for ( Iterator < LongLongCursor > iterator = valueToId . iterator ( ) ; iterator . hasNext ( ) ; ) { final LongLongCursor next = iterator . next ( ) ; assertEquals ( next . value , hash . find ( next . key ) ) ; } for ( long i = <int> ; i < hash . capacity ( ) ; + + i ) { final long id = hash . id ( i ) ; if ( id > = <int> ) { assertEquals ( idToValue [ ( int ) id ] , hash . get ( id ) ) ; } } for ( long i = <int> ; i < hash . size ( ) ; i + + ) { assertEquals ( idToValue [ ( int ) i ] , hash . get ( i ) ) ; } hash . close ( ) ; } public void testSize ( ) { int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { final int mod = <int> + randomInt ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { long count = hash . size ( ) ; long key = hash . add ( randomLong ( ) ) ; if ( key < <int> ) assertEquals ( hash . size ( ) , count ) ; else assertEquals ( hash . size ( ) , count + <int> ) ; if ( i % mod = = <int> ) { newHash ( ) ; } } } hash . close ( ) ; } public void testKey ( ) { int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Map < Long , Long > longs = new HashMap < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { long ref = randomLong ( ) ; long count = hash . size ( ) ; long key = hash . add ( ref ) ; if ( key > = <int> ) { assertNull ( longs . put ( ref , key ) ) ; assertEquals ( uniqueCount , key ) ; uniqueCount + + ; assertEquals ( hash . size ( ) , count + <int> ) ; } else { assertTrue ( ( - key ) - <int> < count ) ; assertEquals ( hash . size ( ) , count ) ; } } for ( Map . Entry < Long , Long > entry : longs . entrySet ( ) ) { long expected = entry . getKey ( ) ; long keyIdx = entry . getValue ( ) ; assertEquals ( expected , hash . get ( keyIdx ) ) ; } newHash ( ) ; } hash . close ( ) ; } public void testAdd ( ) { int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Set < Long > longs = new HashSet < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { long ref = randomLong ( ) ; long count = hash . size ( ) ; long key = hash . add ( ref ) ; if ( key > = <int> ) { assertTrue ( longs . add ( ref ) ) ; assertEquals ( uniqueCount , key ) ; assertEquals ( hash . size ( ) , count + <int> ) ; uniqueCount + + ; } else { assertFalse ( longs . add ( ref ) ) ; assertTrue ( ( - key ) - <int> < count ) ; assertEquals ( ref , hash . get ( ( - key ) - <int> ) ) ; assertEquals ( count , hash . size ( ) ) ; } } assertAllIn ( longs , hash ) ; newHash ( ) ; } hash . close ( ) ; } public void testFind ( ) throws Exception { int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Set < Long > longs = new HashSet < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { long ref = randomLong ( ) ; long count = hash . size ( ) ; long key = hash . find ( ref ) ; if ( key > = <int> ) { assertFalse ( longs . add ( ref ) ) ; assertTrue ( key < count ) ; assertEquals ( ref , hash . get ( key ) ) ; assertEquals ( count , hash . size ( ) ) ; } else { key = hash . add ( ref ) ; assertTrue ( longs . add ( ref ) ) ; assertEquals ( uniqueCount , key ) ; assertEquals ( hash . size ( ) , count + <int> ) ; uniqueCount + + ; } } assertAllIn ( longs , hash ) ; newHash ( ) ; } hash . close ( ) ; } private static void assertAllIn ( Set < Long > longs , LongHash hash ) { long count = hash . size ( ) ; for ( Long l : longs ) { long key = hash . add ( l ) ; assertEquals ( l . longValue ( ) , hash . get ( ( - key ) - <int> ) ) ; assertEquals ( count , hash . size ( ) ) ; assertTrue ( <str> + key + <str> + count + <str> + l , key < count ) ; } } } 
