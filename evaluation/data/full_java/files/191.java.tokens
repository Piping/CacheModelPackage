package org . apache . cassandra . cql3 . functions ; import java . security . AccessControlException ; import java . security . AllPermission ; import java . security . CodeSource ; import java . security . Permission ; import java . security . PermissionCollection ; import java . security . Permissions ; import java . security . Policy ; import java . security . ProtectionDomain ; import java . util . Collections ; import java . util . Enumeration ; public final class ThreadAwareSecurityManager extends SecurityManager { static final PermissionCollection noPermissions = new PermissionCollection ( ) { public void add ( Permission permission ) { throw new UnsupportedOperationException ( ) ; } public boolean implies ( Permission permission ) { return false ; } public Enumeration < Permission > elements ( ) { return Collections . emptyEnumeration ( ) ; } } ; private static final RuntimePermission CHECK_MEMBER_ACCESS_PERMISSION = new RuntimePermission ( <str> ) ; private static final RuntimePermission MODIFY_THREAD_PERMISSION = new RuntimePermission ( <str> ) ; private static final RuntimePermission MODIFY_THREADGROUP_PERMISSION = new RuntimePermission ( <str> ) ; private static volatile boolean installed ; public static void install ( ) { if ( installed ) return ; System . setSecurityManager ( new ThreadAwareSecurityManager ( ) ) ; installed = true ; } static { Policy . setPolicy ( new Policy ( ) { public PermissionCollection getPermissions ( CodeSource codesource ) { Permissions perms = new Permissions ( ) ; if ( codesource = = null | | codesource . getLocation ( ) = = null ) return perms ; switch ( codesource . getLocation ( ) . getProtocol ( ) ) { case <str> : perms . add ( new AllPermission ( ) ) ; return perms ; } return perms ; } public PermissionCollection getPermissions ( ProtectionDomain domain ) { return getPermissions ( domain . getCodeSource ( ) ) ; } public boolean implies ( ProtectionDomain domain , Permission permission ) { CodeSource codesource = domain . getCodeSource ( ) ; if ( codesource = = null | | codesource . getLocation ( ) = = null ) return false ; switch ( codesource . getLocation ( ) . getProtocol ( ) ) { case <str> : return true ; } return false ; } } ) ; } private static final ThreadLocal < Boolean > initializedThread = new ThreadLocal < > ( ) ; private ThreadAwareSecurityManager ( ) { } private static boolean isSecuredThread ( ) { ThreadGroup tg = Thread . currentThread ( ) . getThreadGroup ( ) ; if ( ! ( tg instanceof SecurityThreadGroup ) ) return false ; Boolean threadInitialized = initializedThread . get ( ) ; if ( threadInitialized = = null ) { initializedThread . set ( false ) ; ( ( SecurityThreadGroup ) tg ) . initializeThread ( ) ; initializedThread . set ( true ) ; threadInitialized = true ; } return threadInitialized ; } public void checkAccess ( Thread t ) { if ( isSecuredThread ( ) ) throw new AccessControlException ( <str> + MODIFY_THREAD_PERMISSION , MODIFY_THREAD_PERMISSION ) ; super . checkAccess ( t ) ; } public void checkAccess ( ThreadGroup g ) { if ( isSecuredThread ( ) ) throw new AccessControlException ( <str> + MODIFY_THREADGROUP_PERMISSION , MODIFY_THREADGROUP_PERMISSION ) ; super . checkAccess ( g ) ; } public void checkPermission ( Permission perm ) { if ( ! isSecuredThread ( ) ) return ; if ( CHECK_MEMBER_ACCESS_PERMISSION . equals ( perm ) ) return ; super . checkPermission ( perm ) ; } public void checkPermission ( Permission perm , Object context ) { if ( isSecuredThread ( ) ) super . checkPermission ( perm , context ) ; } public void checkPackageAccess ( String pkg ) { if ( ! isSecuredThread ( ) ) return ; if ( ! ( ( SecurityThreadGroup ) Thread . currentThread ( ) . getThreadGroup ( ) ) . isPackageAllowed ( pkg ) ) { RuntimePermission perm = new RuntimePermission ( <str> + pkg ) ; throw new AccessControlException ( <str> + perm , perm ) ; } super . checkPackageAccess ( pkg ) ; } } 
