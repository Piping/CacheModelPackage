package org . apache . cassandra . io . util ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . DataOutput ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UTFDataFormatException ; import java . lang . reflect . Field ; import java . nio . BufferOverflowException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . channels . WritableByteChannel ; import java . util . Arrays ; import java . util . Random ; import org . apache . cassandra . utils . vint . VIntCoding ; import org . junit . Test ; import com . google . common . primitives . UnsignedBytes ; import com . google . common . primitives . UnsignedInteger ; import com . google . common . primitives . UnsignedLong ; import static org . junit . Assert . * ; public class BufferedDataOutputStreamTest { @Test ( expected = BufferOverflowException . class ) public void testDataOutputBufferFixedByes ( ) throws Exception { try ( DataOutputBufferFixed dob = new DataOutputBufferFixed ( ) ) { try { for ( int ii = <int> ; ii < <int> ; ii + + ) dob . write ( <int> ) ; } catch ( BufferOverflowException e ) { fail ( <str> ) ; } dob . write ( <int> ) ; } } @Test ( expected = BufferOverflowException . class ) public void testDataOutputBufferFixedByteBuffer ( ) throws Exception { try ( DataOutputBufferFixed dob = new DataOutputBufferFixed ( ) ) { try { dob . write ( ByteBuffer . allocateDirect ( <int> ) ) ; } catch ( BufferOverflowException e ) { fail ( <str> ) ; } dob . write ( ByteBuffer . allocateDirect ( <int> ) ) ; } } WritableByteChannel adapter = new WritableByteChannel ( ) { @Override public boolean isOpen ( ) { return true ; } @Override public void close ( ) throws IOException { } @Override public int write ( ByteBuffer src ) throws IOException { int retval = src . remaining ( ) ; while ( src . hasRemaining ( ) ) generated . write ( src . get ( ) ) ; return retval ; } } ; BufferedDataOutputStreamPlus fakeStream = new BufferedDataOutputStreamPlus ( adapter , <int> ) ; @SuppressWarnings ( <str> ) @Test ( expected = NullPointerException . class ) public void testNullChannel ( ) { new BufferedDataOutputStreamPlus ( ( WritableByteChannel ) null , <int> ) ; } @SuppressWarnings ( <str> ) @Test ( expected = IllegalArgumentException . class ) public void testTooSmallBuffer ( ) { new BufferedDataOutputStreamPlus ( adapter , <int> ) ; } @Test ( expected = NullPointerException . class ) public void testNullBuffer ( ) throws Exception { byte type [ ] = null ; fakeStream . write ( type , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testNegativeOffset ( ) throws Exception { byte type [ ] = new byte [ <int> ] ; fakeStream . write ( type , - <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testNegativeLength ( ) throws Exception { byte type [ ] = new byte [ <int> ] ; fakeStream . write ( type , <int> , - <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testTooBigLength ( ) throws Exception { byte type [ ] = new byte [ <int> ] ; fakeStream . write ( type , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testTooBigLengthWithOffset ( ) throws Exception { byte type [ ] = new byte [ <int> ] ; fakeStream . write ( type , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) public void testTooBigOffset ( ) throws Exception { byte type [ ] = new byte [ <int> ] ; fakeStream . write ( type , <int> , <int> ) ; } static final Random r ; static Field baos_bytes ; static { long seed = System . nanoTime ( ) ; System . out . println ( <str> + seed ) ; r = new Random ( seed ) ; try { baos_bytes = ByteArrayOutputStream . class . getDeclaredField ( <str> ) ; baos_bytes . setAccessible ( true ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } } private ByteArrayOutputStream generated ; private BufferedDataOutputStreamPlus ndosp ; private ByteArrayOutputStream canonical ; private DataOutputStreamPlus dosp ; void setUp ( ) throws Exception { generated = new ByteArrayOutputStream ( ) ; canonical = new ByteArrayOutputStream ( ) ; dosp = new WrappedDataOutputStreamPlus ( canonical ) ; if ( ndosp ! = null ) ndosp . close ( ) ; ndosp = new BufferedDataOutputStreamPlus ( adapter , <int> ) ; } @Test public void testFuzz ( ) throws Exception { for ( int ii = <int> ; ii < <int> ; ii + + ) fuzzOnce ( ) ; } String simple = <str> ; public static final String twoByte = <str> ; public static final String threeByte = <str> ; public static final String fourByte = <str> ; @SuppressWarnings ( <str> ) private void fuzzOnce ( ) throws Exception { setUp ( ) ; int iteration = <int> ; int bytesChecked = <int> ; int action = <int> ; while ( generated . size ( ) < <int> * <int> * <int> ) { action = r . nextInt ( <int> ) ; iteration + + ; switch ( action ) { case <int> : { generated . flush ( ) ; dosp . flush ( ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . write ( val ) ; ndosp . write ( val ) ; break ; } case <int> : { byte randomBytes [ ] = new byte [ r . nextInt ( <int> * <int> + <int> ) ] ; r . nextBytes ( randomBytes ) ; dosp . write ( randomBytes ) ; ndosp . write ( randomBytes ) ; break ; } case <int> : { byte randomBytes [ ] = new byte [ r . nextInt ( <int> * <int> + <int> ) ] ; r . nextBytes ( randomBytes ) ; int offset = randomBytes . length = = <int> ? <int> : r . nextInt ( randomBytes . length ) ; int length = randomBytes . length = = <int> ? <int> : r . nextInt ( randomBytes . length - offset ) ; dosp . write ( randomBytes , offset , length ) ; ndosp . write ( randomBytes , offset , length ) ; break ; } case <int> : { boolean val = r . nextInt ( <int> ) = = <int> ; dosp . writeBoolean ( val ) ; ndosp . writeBoolean ( val ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . writeByte ( val ) ; ndosp . writeByte ( val ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . writeShort ( val ) ; ndosp . writeShort ( val ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . writeChar ( val ) ; ndosp . writeChar ( val ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . writeInt ( val ) ; ndosp . writeInt ( val ) ; break ; } case <int> : { int val = r . nextInt ( ) ; dosp . writeLong ( val ) ; ndosp . writeLong ( val ) ; break ; } case <int> : { float val = r . nextFloat ( ) ; dosp . writeFloat ( val ) ; ndosp . writeFloat ( val ) ; break ; } case <int> : { double val = r . nextDouble ( ) ; dosp . writeDouble ( val ) ; ndosp . writeDouble ( val ) ; break ; } case <int> : { dosp . writeBytes ( simple ) ; ndosp . writeBytes ( simple ) ; break ; } case <int> : { dosp . writeChars ( twoByte ) ; ndosp . writeChars ( twoByte ) ; break ; } case <int> : { StringBuilder sb = new StringBuilder ( ) ; int length = r . nextInt ( <int> ) ; if ( r . nextDouble ( ) > <float> ) length + = <int> ; sb . append ( simple + twoByte + threeByte + fourByte ) ; for ( int ii = <int> ; ii < length ; ii + + ) { sb . append ( ( char ) ( r . nextInt ( ) & <hex> ) ) ; } String str = sb . toString ( ) ; writeUTFLegacy ( str , dosp ) ; ndosp . writeUTF ( str ) ; break ; } case <int> : { StringBuilder sb = new StringBuilder ( ) ; int length = r . nextInt ( <int> ) ; sb . append ( <str> ) ; for ( int ii = <int> ; ii < length ; ii + + ) { sb . append ( <str> ) ; } String str = sb . toString ( ) ; writeUTFLegacy ( str , dosp ) ; ndosp . writeUTF ( str ) ; break ; } case <int> : { ByteBuffer buf = ByteBuffer . allocate ( r . nextInt ( <int> * <int> + <int> ) ) ; r . nextBytes ( buf . array ( ) ) ; buf . position ( buf . capacity ( ) = = <int> ? <int> : r . nextInt ( buf . capacity ( ) ) ) ; buf . limit ( buf . position ( ) + ( buf . capacity ( ) - buf . position ( ) = = <int> ? <int> : r . nextInt ( buf . capacity ( ) - buf . position ( ) ) ) ) ; ByteBuffer dup = buf . duplicate ( ) ; ndosp . write ( buf . duplicate ( ) ) ; assertEquals ( dup . position ( ) , buf . position ( ) ) ; assertEquals ( dup . limit ( ) , buf . limit ( ) ) ; dosp . write ( buf . duplicate ( ) ) ; break ; } case <int> : { ByteBuffer buf = ByteBuffer . allocateDirect ( r . nextInt ( <int> * <int> + <int> ) ) ; while ( buf . hasRemaining ( ) ) buf . put ( ( byte ) r . nextInt ( ) ) ; buf . position ( buf . capacity ( ) = = <int> ? <int> : r . nextInt ( buf . capacity ( ) ) ) ; buf . limit ( buf . position ( ) + ( buf . capacity ( ) - buf . position ( ) = = <int> ? <int> : r . nextInt ( buf . capacity ( ) - buf . position ( ) ) ) ) ; ByteBuffer dup = buf . duplicate ( ) ; ndosp . write ( buf . duplicate ( ) ) ; assertEquals ( dup . position ( ) , buf . position ( ) ) ; assertEquals ( dup . limit ( ) , buf . limit ( ) ) ; dosp . write ( buf . duplicate ( ) ) ; break ; } case <int> : { try ( Memory buf = Memory . allocate ( r . nextInt ( <int> * <int> - <int> ) + <int> ) ; ) { for ( int ii = <int> ; ii < buf . size ( ) ; ii + + ) buf . setByte ( ii , ( byte ) r . nextInt ( ) ) ; long offset = buf . size ( ) = = <int> ? <int> : r . nextInt ( ( int ) buf . size ( ) ) ; long length = ( buf . size ( ) - offset = = <int> ? <int> : r . nextInt ( ( int ) ( buf . size ( ) - offset ) ) ) ; ndosp . write ( buf , offset , length ) ; dosp . write ( buf , offset , length ) ; } break ; } case <int> : { long val = r . nextLong ( ) ; VIntCoding . writeVInt ( val , dosp ) ; ndosp . writeVInt ( val ) ; break ; } case <int> : { long val = r . nextLong ( ) ; VIntCoding . writeUnsignedVInt ( val , dosp ) ; ndosp . writeUnsignedVInt ( val ) ; break ; } default : fail ( <str> ) ; } } assertSameOutput ( <int> , - <int> , iteration ) ; } public static void writeUTFLegacy ( String str , OutputStream out ) throws IOException { int utfCount = <int> , length = str . length ( ) ; for ( int i = <int> ; i < length ; i + + ) { int charValue = str . charAt ( i ) ; if ( charValue > <int> & & charValue < = <int> ) { utfCount + + ; } else if ( charValue < = <int> ) { utfCount + = <int> ; } else { utfCount + = <int> ; } } if ( utfCount > <int> ) { throw new UTFDataFormatException ( ) ; } byte utfBytes [ ] = new byte [ utfCount + <int> ] ; int utfIndex = <int> ; for ( int i = <int> ; i < length ; i + + ) { int charValue = str . charAt ( i ) ; if ( charValue > <int> & & charValue < = <int> ) { utfBytes [ utfIndex + + ] = ( byte ) charValue ; } else if ( charValue < = <int> ) { utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( charValue > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & charValue ) ) ; } else { utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( charValue > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & ( charValue > > <int> ) ) ) ; utfBytes [ utfIndex + + ] = ( byte ) ( <hex> | ( <hex> & charValue ) ) ; } } utfBytes [ <int> ] = ( byte ) ( utfCount > > <int> ) ; utfBytes [ <int> ] = ( byte ) utfCount ; out . write ( utfBytes ) ; } private int assertSameOutput ( int bytesChecked , int lastAction , int iteration ) throws Exception { ndosp . flush ( ) ; dosp . flush ( ) ; byte generatedBytes [ ] = ( byte [ ] ) baos_bytes . get ( generated ) ; byte canonicalBytes [ ] = ( byte [ ] ) baos_bytes . get ( canonical ) ; int count = generated . size ( ) ; if ( count ! = canonical . size ( ) ) System . out . println ( <str> + bytesChecked + <str> + lastAction + <str> + iteration ) ; assertEquals ( count , canonical . size ( ) ) ; for ( ; bytesChecked < count ; bytesChecked + + ) { byte generatedByte = generatedBytes [ bytesChecked ] ; byte canonicalByte = canonicalBytes [ bytesChecked ] ; if ( generatedByte ! = canonicalByte ) System . out . println ( <str> + bytesChecked + <str> + lastAction + <str> + iteration ) ; assertEquals ( generatedByte , canonicalByte ) ; } return count ; } @Test public void testWriteUTF ( ) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutput dataOut = new DataOutputStream ( baos ) ; StringBuilder sb = new StringBuilder ( <int> ) ; for ( int ii = <int> ; ii < <int> < < <int> ; ii + + ) { String s = sb . toString ( ) ; UnbufferedDataOutputStreamPlus . writeUTF ( s , dataOut ) ; DataInput dataIn = new DataInputStream ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; assertEquals ( s , dataIn . readUTF ( ) ) ; baos . reset ( ) ; sb . append ( <str> ) ; } } @Test public void testWriteUTFBigChar ( ) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutput dataOut = new DataOutputStream ( baos ) ; StringBuilder sb = new StringBuilder ( <int> ) ; for ( int ii = <int> ; ii < <int> < < <int> ; ii + + ) { String s = sb . toString ( ) ; UnbufferedDataOutputStreamPlus . writeUTF ( s , dataOut ) ; DataInput dataIn = new DataInputStream ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; assertEquals ( s , dataIn . readUTF ( ) ) ; baos . reset ( ) ; if ( ii = = ( <int> < < <int> ) - <int> ) sb . append ( <str> ) ; else sb . append ( twoByte ) ; } } public static long [ ] enrich ( long vals [ ] ) { long retval [ ] = Arrays . copyOf ( vals , vals . length + <int> ) ; for ( int ii = <int> ; ii < <int> ; ii + + ) retval [ vals . length + ii ] = <int> < < ii ; return retval ; } @Test public void testVInt ( ) throws Exception { setUp ( ) ; long testValues [ ] = new long [ ] { <int> , <int> , - <int> , Long . MIN_VALUE , Long . MIN_VALUE + <int> , Long . MAX_VALUE , Long . MAX_VALUE - <int> , Integer . MIN_VALUE , Integer . MIN_VALUE + <int> , Integer . MAX_VALUE , Integer . MAX_VALUE - <int> , Short . MIN_VALUE , Short . MIN_VALUE + <int> , Short . MAX_VALUE , Short . MAX_VALUE - <int> , Byte . MIN_VALUE , Byte . MIN_VALUE + <int> , Byte . MAX_VALUE , Byte . MAX_VALUE - <int> } ; testValues = enrich ( testValues ) ; int expectedSize = <int> ; for ( long v : testValues ) { expectedSize + = VIntCoding . computeVIntSize ( v ) ; ndosp . writeVInt ( v ) ; } ndosp . flush ( ) ; DataInputBuffer in = new DataInputBuffer ( generated . toByteArray ( ) ) ; assertEquals ( expectedSize , generated . toByteArray ( ) . length ) ; for ( long v : testValues ) { assertEquals ( v , in . readVInt ( ) ) ; } } @Test public void testUnsignedVInt ( ) throws Exception { setUp ( ) ; long testValues [ ] = new long [ ] { <int> , <int> , UnsignedLong . MAX_VALUE . longValue ( ) , UnsignedLong . MAX_VALUE . longValue ( ) - <int> , UnsignedLong . MAX_VALUE . longValue ( ) + <int> , UnsignedInteger . MAX_VALUE . longValue ( ) , UnsignedInteger . MAX_VALUE . longValue ( ) - <int> , UnsignedInteger . MAX_VALUE . longValue ( ) + <int> , UnsignedBytes . MAX_VALUE , UnsignedBytes . MAX_VALUE - <int> , UnsignedBytes . MAX_VALUE + <int> , <int> , <int> - <int> , <int> + <int> } ; testValues = enrich ( testValues ) ; int expectedSize = <int> ; for ( long v : testValues ) { expectedSize + = VIntCoding . computeUnsignedVIntSize ( v ) ; ndosp . writeUnsignedVInt ( v ) ; } ndosp . flush ( ) ; DataInputBuffer in = new DataInputBuffer ( generated . toByteArray ( ) ) ; assertEquals ( expectedSize , generated . toByteArray ( ) . length ) ; for ( long v : testValues ) assertEquals ( v , in . readUnsignedVInt ( ) ) ; } @Test public void testWriteSlowByteOrder ( ) throws Exception { try ( DataOutputBuffer dob = new DataOutputBuffer ( <int> ) ) { dob . order ( ByteOrder . LITTLE_ENDIAN ) ; dob . writeLong ( <int> ) ; assertEquals ( <int> , ByteBuffer . wrap ( dob . toByteArray ( ) ) . order ( ByteOrder . LITTLE_ENDIAN ) . getLong ( ) ) ; } } @Test public void testWriteExcessSlow ( ) throws Exception { try ( DataOutputBuffer dob = new DataOutputBuffer ( <int> ) ) { dob . strictFlushing = true ; ByteBuffer buf = ByteBuffer . allocateDirect ( <int> ) ; buf . putLong ( <int> , <int> ) ; dob . write ( buf ) ; assertEquals ( <int> , ByteBuffer . wrap ( dob . toByteArray ( ) ) . getLong ( ) ) ; } } @Test public void testApplyToChannel ( ) throws Exception { setUp ( ) ; Object obj = new Object ( ) ; Object retval = ndosp . applyToChannel ( channel - > { ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; buf . putLong ( <int> , <int> ) ; try { channel . write ( buf ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return obj ; } ) ; assertEquals ( obj , retval ) ; assertEquals ( <int> , ByteBuffer . wrap ( generated . toByteArray ( ) ) . getLong ( ) ) ; } @Test ( expected = UnsupportedOperationException . class ) public void testApplyToChannelThrowsForMisaligned ( ) throws Exception { setUp ( ) ; ndosp . strictFlushing = true ; ndosp . applyToChannel ( channel - > { return null ; } ) ; } } 
