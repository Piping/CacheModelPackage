package io . netty . handler . codec . http . cookie ; import static io . netty . handler . codec . http . cookie . CookieUtil . add ; import static io . netty . handler . codec . http . cookie . CookieUtil . addQuoted ; import static io . netty . handler . codec . http . cookie . CookieUtil . stringBuilder ; import static io . netty . handler . codec . http . cookie . CookieUtil . stripTrailingSeparator ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import io . netty . handler . codec . http . HttpHeaderDateFormat ; import io . netty . handler . codec . http . HttpRequest ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Date ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public final class ServerCookieEncoder extends CookieEncoder { public static final ServerCookieEncoder STRICT = new ServerCookieEncoder ( true ) ; public static final ServerCookieEncoder LAX = new ServerCookieEncoder ( false ) ; private ServerCookieEncoder ( boolean strict ) { super ( strict ) ; } public String encode ( String name , String value ) { return encode ( new DefaultCookie ( name , value ) ) ; } public String encode ( Cookie cookie ) { final String name = checkNotNull ( cookie , <str> ) . name ( ) ; final String value = cookie . value ( ) ! = null ? cookie . value ( ) : <str> ; validateCookie ( name , value ) ; StringBuilder buf = stringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) ! = Long . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = new Date ( cookie . maxAge ( ) * <int> + System . currentTimeMillis ( ) ) ; add ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; } if ( cookie . path ( ) ! = null ) { add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; } if ( cookie . domain ( ) ! = null ) { add ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; } if ( cookie . isSecure ( ) ) { add ( buf , CookieHeaderNames . SECURE ) ; } if ( cookie . isHttpOnly ( ) ) { add ( buf , CookieHeaderNames . HTTPONLY ) ; } return stripTrailingSeparator ( buf ) ; } private List < String > dedup ( List < String > encoded , Map < String , Integer > nameToLastIndex ) { boolean [ ] isLastInstance = new boolean [ encoded . size ( ) ] ; for ( int idx : nameToLastIndex . values ( ) ) { isLastInstance [ idx ] = true ; } List < String > dedupd = new ArrayList < String > ( nameToLastIndex . size ( ) ) ; for ( int i = <int> , n = encoded . size ( ) ; i < n ; i + + ) { if ( isLastInstance [ i ] ) { dedupd . add ( encoded . get ( i ) ) ; } } return dedupd ; } public List < String > encode ( Cookie . . . cookies ) { if ( checkNotNull ( cookies , <str> ) . length = = <int> ) { return Collections . emptyList ( ) ; } List < String > encoded = new ArrayList < String > ( cookies . length ) ; Map < String , Integer > nameToIndex = strict & & cookies . length > <int> ? new HashMap < String , Integer > ( ) : null ; boolean hasDupdName = false ; for ( int i = <int> ; i < cookies . length ; i + + ) { Cookie c = cookies [ i ] ; encoded . add ( encode ( c ) ) ; if ( nameToIndex ! = null ) { hasDupdName | = nameToIndex . put ( c . name ( ) , i ) ! = null ; } } return hasDupdName ? dedup ( encoded , nameToIndex ) : encoded ; } public List < String > encode ( Collection < ? extends Cookie > cookies ) { if ( checkNotNull ( cookies , <str> ) . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List < String > encoded = new ArrayList < String > ( cookies . size ( ) ) ; Map < String , Integer > nameToIndex = strict & & cookies . size ( ) > <int> ? new HashMap < String , Integer > ( ) : null ; int i = <int> ; boolean hasDupdName = false ; for ( Cookie c : cookies ) { encoded . add ( encode ( c ) ) ; if ( nameToIndex ! = null ) { hasDupdName | = nameToIndex . put ( c . name ( ) , i + + ) ! = null ; } } return hasDupdName ? dedup ( encoded , nameToIndex ) : encoded ; } public List < String > encode ( Iterable < ? extends Cookie > cookies ) { Iterator < ? extends Cookie > cookiesIt = checkNotNull ( cookies , <str> ) . iterator ( ) ; if ( ! cookiesIt . hasNext ( ) ) { return Collections . emptyList ( ) ; } List < String > encoded = new ArrayList < String > ( ) ; Cookie firstCookie = cookiesIt . next ( ) ; Map < String , Integer > nameToIndex = strict & & cookiesIt . hasNext ( ) ? new HashMap < String , Integer > ( ) : null ; int i = <int> ; encoded . add ( encode ( firstCookie ) ) ; boolean hasDupdName = nameToIndex ! = null ? nameToIndex . put ( firstCookie . name ( ) , i + + ) ! = null : false ; while ( cookiesIt . hasNext ( ) ) { Cookie c = cookiesIt . next ( ) ; encoded . add ( encode ( c ) ) ; if ( nameToIndex ! = null ) { hasDupdName | = nameToIndex . put ( c . name ( ) , i + + ) ! = null ; } } return hasDupdName ? dedup ( encoded , nameToIndex ) : encoded ; } } 
