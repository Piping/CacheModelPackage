package org . gradle . messaging . remote . internal . hub ; import org . gradle . api . Action ; import org . gradle . internal . concurrent . AsyncStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . messaging . dispatch . Dispatch ; import org . gradle . messaging . remote . internal . Connection ; import org . gradle . messaging . remote . internal . hub . protocol . * ; import org . gradle . messaging . remote . internal . hub . queue . EndPointQueue ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class MessageHub implements AsyncStoppable { private enum State { Running , Stopping , Stopped } private static final Discard DISCARD = new Discard ( ) ; private final StoppableExecutor workers ; private final String displayName ; private final Action < ? super Throwable > errorHandler ; private final Lock lock = new ReentrantLock ( ) ; private State state = State . Running ; private final IncomingQueue incomingQueue = new IncomingQueue ( lock ) ; private final OutgoingQueue outgoingQueue = new OutgoingQueue ( incomingQueue , lock ) ; private final ConnectionSet connections = new ConnectionSet ( incomingQueue , outgoingQueue ) ; public MessageHub ( String displayName , ExecutorFactory executorFactory , Action < ? super Throwable > errorHandler ) { this . displayName = displayName ; this . errorHandler = errorHandler ; workers = executorFactory . create ( String . format ( <str> , displayName ) ) ; } public < T > Dispatch < T > getOutgoing ( final String channelName , final Class < T > type ) { lock . lock ( ) ; try { assertRunning ( <str> ) ; return new ChannelDispatch < T > ( type , new ChannelIdentifier ( channelName ) ) ; } finally { lock . unlock ( ) ; } } public void addHandler ( String channelName , Object handler ) { lock . lock ( ) ; try { assertRunning ( <str> ) ; RejectedMessageListener rejectedMessageListener ; if ( handler instanceof RejectedMessageListener ) { rejectedMessageListener = ( RejectedMessageListener ) handler ; } else { rejectedMessageListener = DISCARD ; } Dispatch < Object > dispatch ; if ( handler instanceof Dispatch ) { dispatch = ( Dispatch ) handler ; } else { dispatch = DISCARD ; } HubStateListener stateListener ; if ( handler instanceof HubStateListener ) { stateListener = ( HubStateListener ) handler ; } else { stateListener = DISCARD ; } ChannelIdentifier identifier = new ChannelIdentifier ( channelName ) ; EndPointQueue queue = incomingQueue . getChannel ( identifier ) . newEndpoint ( ) ; workers . execute ( new Handler ( queue , dispatch , rejectedMessageListener , stateListener ) ) ; } finally { lock . unlock ( ) ; } } public void addConnection ( Connection < InterHubMessage > connection ) { lock . lock ( ) ; try { assertRunning ( <str> ) ; ConnectionState connectionState = connections . add ( connection ) ; workers . execute ( new ConnectionDispatch ( connectionState ) ) ; workers . execute ( new ConnectionReceive ( connectionState ) ) ; } finally { lock . unlock ( ) ; } } private void assertRunning ( String action ) { if ( state ! = State . Running ) { throw new IllegalStateException ( String . format ( <str> , action , displayName ) ) ; } } public void requestStop ( ) { lock . lock ( ) ; try { if ( state ! = State . Running ) { return ; } try { outgoingQueue . endOutput ( ) ; connections . requestStop ( ) ; } finally { state = State . Stopping ; } } finally { lock . unlock ( ) ; } } public void stop ( ) { try { lock . lock ( ) ; try { requestStop ( ) ; } finally { lock . unlock ( ) ; } workers . stop ( ) ; } finally { lock . lock ( ) ; try { state = State . Stopped ; } finally { lock . unlock ( ) ; } } } private static class Discard implements Dispatch < Object > , RejectedMessageListener , HubStateListener { public void dispatch ( Object message ) { } public void messageDiscarded ( Object message ) { } public void onConnect ( ) { } public void onDisconnect ( ) { } } private class ConnectionReceive implements Runnable { private final Connection < InterHubMessage > connection ; private final ConnectionState connectionState ; public ConnectionReceive ( ConnectionState connectionState ) { this . connection = connectionState . getConnection ( ) ; this . connectionState = connectionState ; } public void run ( ) { try { try { while ( true ) { InterHubMessage message = connection . receive ( ) ; if ( message = = null | | message instanceof EndOfStream ) { return ; } lock . lock ( ) ; try { incomingQueue . queue ( message ) ; } finally { lock . unlock ( ) ; } } } finally { lock . lock ( ) ; try { connectionState . receiveFinished ( ) ; } finally { lock . unlock ( ) ; } } } catch ( Throwable e ) { errorHandler . execute ( e ) ; } } } private class ConnectionDispatch implements Runnable { private final Connection < InterHubMessage > connection ; private final EndPointQueue queue ; private final ConnectionState connectionState ; private ConnectionDispatch ( ConnectionState connectionState ) { this . connection = connectionState . getConnection ( ) ; this . queue = connectionState . getDispatchQueue ( ) ; this . connectionState = connectionState ; } public void run ( ) { try { List < InterHubMessage > messages = new ArrayList < InterHubMessage > ( ) ; try { while ( true ) { lock . lock ( ) ; try { queue . take ( messages ) ; } finally { lock . unlock ( ) ; } for ( Object message : messages ) { InterHubMessage channelMessage = ( InterHubMessage ) message ; connection . dispatch ( channelMessage ) ; if ( message instanceof EndOfStream ) { return ; } } messages . clear ( ) ; } } finally { lock . lock ( ) ; try { connectionState . dispatchFinished ( ) ; } finally { lock . unlock ( ) ; } } } catch ( Throwable t ) { errorHandler . execute ( t ) ; } } } private class ChannelDispatch < T > implements Dispatch < T > { private final Class < T > type ; private final ChannelIdentifier channelIdentifier ; public ChannelDispatch ( Class < T > type , ChannelIdentifier channelIdentifier ) { this . type = type ; this . channelIdentifier = channelIdentifier ; } @Override public String toString ( ) { return String . format ( <str> , type . getSimpleName ( ) , displayName , channelIdentifier ) ; } public void dispatch ( T message ) { lock . lock ( ) ; try { assertRunning ( <str> ) ; outgoingQueue . dispatch ( new ChannelMessage ( channelIdentifier , message ) ) ; } finally { lock . unlock ( ) ; } } } private class Handler implements Runnable { private final EndPointQueue queue ; private final Dispatch < Object > dispatch ; private final RejectedMessageListener listener ; private final HubStateListener stateListener ; public Handler ( EndPointQueue queue , Dispatch < Object > dispatch , RejectedMessageListener listener , HubStateListener stateListener ) { this . queue = queue ; this . dispatch = dispatch ; this . listener = listener ; this . stateListener = stateListener ; } public void run ( ) { try { List < InterHubMessage > messages = new ArrayList < InterHubMessage > ( ) ; try { while ( true ) { lock . lock ( ) ; try { queue . take ( messages ) ; } finally { lock . unlock ( ) ; } for ( InterHubMessage message : messages ) { if ( message instanceof EndOfStream ) { return ; } if ( message instanceof ChannelMessage ) { ChannelMessage channelMessage = ( ChannelMessage ) message ; dispatch . dispatch ( channelMessage . getPayload ( ) ) ; } else if ( message instanceof RejectedMessage ) { RejectedMessage rejectedMessage = ( RejectedMessage ) message ; listener . messageDiscarded ( rejectedMessage . getPayload ( ) ) ; } else if ( message instanceof ConnectionEstablished ) { stateListener . onConnect ( ) ; } else if ( message instanceof ConnectionClosed ) { stateListener . onDisconnect ( ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , message ) ) ; } } messages . clear ( ) ; } } finally { lock . lock ( ) ; try { queue . stop ( ) ; } finally { lock . unlock ( ) ; } } } catch ( Throwable t ) { errorHandler . execute ( t ) ; } } } } 
