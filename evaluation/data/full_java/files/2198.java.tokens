package org . nd4j . linalg . factory ; import java . util . * ; import org . nd4j . linalg . api . blas . Lapack ; import org . nd4j . linalg . api . blas . Level1 ; import org . nd4j . linalg . api . blas . Level2 ; import org . nd4j . linalg . api . blas . Level3 ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . rng . distribution . Distribution ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . util . ArrayUtil ; public abstract class BaseNDArrayFactory implements NDArrayFactory { protected DataBuffer . Type dtype ; protected char order ; protected Level1 level1 ; protected Level2 level2 ; protected Level3 level3 ; protected Lapack lapack ; public BaseNDArrayFactory ( ) { } @Override public Lapack lapack ( ) { if ( lapack = = null ) createLapack ( ) ; return lapack ; } @Override public Level1 level1 ( ) { if ( level1 = = null ) createLevel1 ( ) ; return level1 ; } @Override public Level2 level2 ( ) { if ( level2 = = null ) createLevel2 ( ) ; return level2 ; } @Override public Level3 level3 ( ) { if ( level3 = = null ) createLevel3 ( ) ; return level3 ; } protected BaseNDArrayFactory ( DataBuffer . Type dtype , Character order ) { this . dtype = dtype ; if ( Character . toLowerCase ( order ) ! = <str> & & Character . toLowerCase ( order ) ! = <str> ) throw new IllegalArgumentException ( <str> ) ; this . order = order ; } protected BaseNDArrayFactory ( DataBuffer . Type dtype , char order ) { this . dtype = dtype ; if ( Character . toLowerCase ( order ) ! = <str> & & Character . toLowerCase ( order ) ! = <str> ) throw new IllegalArgumentException ( <str> ) ; this . order = order ; } protected static void validateConcat ( int dimension , INDArray . . . arrs ) { if ( arrs [ <int> ] . isScalar ( ) ) { for ( int i = <int> ; i < arrs . length ; i + + ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( <str> ) ; } else { int dims = arrs [ <int> ] . shape ( ) . length ; int [ ] shape = ArrayUtil . removeIndex ( arrs [ <int> ] . shape ( ) , dimension ) ; for ( int i = <int> ; i < arrs . length ; i + + ) { assert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; assert arrs [ i ] . shape ( ) . length = = dims ; } } } @Override public void setOrder ( char order ) { assert order = = <str> | | order = = <str> : <str> ; this . order = order ; } @Override public INDArray rand ( int [ ] shape , double min , double max , org . nd4j . linalg . api . rng . Random rng ) { Nd4j . getRandom ( ) . setSeed ( rng . getSeed ( ) ) ; return Nd4j . getDistributions ( ) . createUniform ( min , max ) . sample ( shape ) ; } @Override public INDArray rand ( int rows , int columns , double min , double max , org . nd4j . linalg . api . rng . Random rng ) { Nd4j . getRandom ( ) . setSeed ( rng . getSeed ( ) ) ; return rand ( new int [ ] { rows , columns } , min , max , rng ) ; } @Override public void setDType ( DataBuffer . Type dtype ) { assert dtype = = DataBuffer . Type . DOUBLE | | dtype = = DataBuffer . Type . FLOAT | | dtype = = DataBuffer . Type . INT : <str> ; this . dtype = dtype ; } @Override public INDArray create ( int [ ] shape , DataBuffer . Type dataType ) { return create ( shape , Nd4j . createBuffer ( shape , dataType ) ) ; } @Override public char order ( ) { return order ; } @Override public DataBuffer . Type dtype ( ) { return dtype ; } @Override public INDArray linspace ( int lower , int upper , int num ) { double [ ] data = new double [ num ] ; for ( int i = <int> ; i < num ; i + + ) { double t = ( double ) i / ( num - <int> ) ; data [ i ] = lower * ( <int> - t ) + t * upper ; } INDArray ret = Nd4j . create ( data . length ) ; for ( int i = <int> ; i < ret . length ( ) ; i + + ) ret . putScalar ( i , data [ i ] ) ; return ret ; } @Override public IComplexNDArray createComplex ( int [ ] ints , int [ ] ints1 , int [ ] stride , int offset ) { return createComplex ( Nd4j . createBuffer ( ints ) , ints1 , stride , offset ) ; } @Override public INDArray create ( int [ ] ints , int [ ] ints1 , int [ ] stride , int offset ) { return create ( Nd4j . createBuffer ( ints ) , ints1 , stride , offset ) ; } @Override public INDArray create ( int rows , int columns , char ordering ) { return create ( new int [ ] { rows , columns } , ordering ) ; } @Override public INDArray toFlattened ( Collection < INDArray > matrices ) { int length = <int> ; for ( INDArray m : matrices ) length + = m . length ( ) ; INDArray ret = Nd4j . create ( <int> , length ) ; int linearIndex = <int> ; for ( INDArray d : matrices ) { NdIndexIterator iter = new NdIndexIterator ( d . shape ( ) ) ; while ( iter . hasNext ( ) ) { for ( int i = <int> ; i < d . length ( ) ; i + + ) { ret . putScalar ( linearIndex + + , d . getDouble ( iter . next ( ) ) ) ; } } } return ret ; } @Override public INDArray toFlattened ( int length , Iterator < ? extends INDArray > . . . matrices ) { INDArray ret = Nd4j . create ( length ) ; int linearIndex = <int> ; for ( Iterator < ? extends INDArray > iter1 : matrices ) { while ( iter1 . hasNext ( ) ) { INDArray d = iter1 . next ( ) ; NdIndexIterator iter = new NdIndexIterator ( d . shape ( ) ) ; while ( iter . hasNext ( ) ) { for ( int i = <int> ; i < d . length ( ) ; i + + ) { ret . putScalar ( linearIndex + + , d . getDouble ( iter . next ( ) ) ) ; } } } } return ret ; } @Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { assert curr . shape ( ) . length = = <int> ; if ( in . columns ( ) ! = <int> ) { throw new AssertionError ( <str> ) ; } if ( in . rows ( ) ! = curr . size ( curr . shape ( ) . length - <int> ) ) { throw new AssertionError ( <str> ) ; } if ( curr . size ( curr . shape ( ) . length - <int> ) ! = curr . size ( curr . shape ( ) . length - <int> ) ) { throw new AssertionError ( <str> ) ; } INDArray ret = Nd4j . create ( curr . slices ( ) , <int> ) ; INDArray inT = in . transpose ( ) ; for ( int i = <int> ; i < curr . slices ( ) ; i + + ) { INDArray slice = curr . slice ( i ) ; INDArray inTTimesSlice = inT . mmul ( slice ) ; ret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; } return ret ; } @Override public INDArray toFlattened ( INDArray . . . matrices ) { int length = <int> ; for ( INDArray m : matrices ) length + = m . length ( ) ; INDArray ret = Nd4j . create ( <int> , length ) ; int linearIndex = <int> ; for ( INDArray d : matrices ) { if ( ! d . isVector ( ) ) d = Nd4j . create ( d . data ( ) , new int [ ] { <int> , d . length ( ) } , d . offset ( ) ) ; for ( int i = <int> ; i < d . length ( ) ; i + + ) { ret . putScalar ( linearIndex + + , d . getFloat ( i ) ) ; } } return ret ; } @Override public INDArray toFlattened ( char order , Collection < INDArray > matrices ) { int length = <int> ; for ( INDArray m : matrices ) length + = m . length ( ) ; INDArray ret = Nd4j . create ( new int [ ] { <int> , length } , order ) ; int linearIndex = <int> ; for ( INDArray m : matrices ) { if ( m . ordering ( ) = = order & & m . data ( ) . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP & & Shape . strideDescendingCAscendingF ( m ) & & Shape . isContiguousInBuffer ( m ) ) { int retFrom = linearIndex ; int mFrom = m . offset ( ) ; Object arr = m . data ( ) . array ( ) ; if ( arr instanceof float [ ] ) { float [ ] mData = ( float [ ] ) arr ; float [ ] retData = ( float [ ] ) ret . data ( ) . array ( ) ; System . arraycopy ( mData , mFrom , retData , retFrom , m . length ( ) ) ; } else { double [ ] mData = ( double [ ] ) arr ; double [ ] retData = ( double [ ] ) ret . data ( ) . array ( ) ; System . arraycopy ( mData , mFrom , retData , retFrom , m . length ( ) ) ; } linearIndex + = m . length ( ) ; } else { NdIndexIterator iter = new NdIndexIterator ( order , m . shape ( ) ) ; while ( iter . hasNext ( ) ) { ret . putScalar ( linearIndex + + , m . getDouble ( iter . next ( ) ) ) ; } } } return ret ; } @Override public INDArray toFlattened ( char order , INDArray . . . matrices ) { return toFlattened ( order , Arrays . asList ( matrices ) ) ; } @Override public INDArray eye ( int n ) { INDArray ret = Nd4j . create ( n , n ) ; for ( int i = <int> ; i < n ; i + + ) { ret . put ( i , i , <float> ) ; } return ret . reshape ( n , n ) ; } @Override public void rot90 ( INDArray toRotate ) { if ( ! toRotate . isMatrix ( ) ) throw new IllegalArgumentException ( <str> ) ; INDArray start = toRotate . transpose ( ) ; for ( int i = <int> ; i < start . rows ( ) ; i + + ) start . putRow ( i , reverse ( start . getRow ( i ) ) ) ; } @Override public INDArray rot ( INDArray reverse ) { INDArray ret = Nd4j . create ( reverse . shape ( ) ) ; if ( reverse . isVector ( ) ) return reverse ( reverse ) ; else { for ( int i = <int> ; i < reverse . slices ( ) ; i + + ) { ret . putSlice ( i , reverse ( reverse . slice ( i ) ) ) ; } } return ret . reshape ( reverse . shape ( ) ) ; } @Override public INDArray reverse ( INDArray reverse ) { INDArray rev = reverse . linearView ( ) ; INDArray ret = Nd4j . create ( rev . shape ( ) ) ; int count = <int> ; for ( int i = rev . length ( ) - <int> ; i > = <int> ; i - - ) { ret . putScalar ( count + + , rev . getFloat ( i ) ) ; } return ret . reshape ( reverse . shape ( ) ) ; } @Override public INDArray arange ( double begin , double end ) { return Nd4j . create ( ArrayUtil . toDoubles ( ArrayUtil . range ( ( int ) begin , ( int ) end ) ) ) ; } public abstract IComplexFloat createFloat ( float real , float imag ) ; public abstract IComplexDouble createDouble ( double real , double imag ) ; @Override public void copy ( INDArray a , INDArray b ) { b . assign ( a ) ; } @Override public INDArray rand ( int [ ] shape , float min , float max , org . nd4j . linalg . api . rng . Random rng ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return Nd4j . getDistributions ( ) . createUniform ( min , max ) . sample ( shape ) ; } @Override public INDArray rand ( int rows , int columns , float min , float max , org . nd4j . linalg . api . rng . Random rng ) { return rand ( new int [ ] { rows , columns } , min , max , rng ) ; } @Override public INDArray appendBias ( INDArray . . . vectors ) { int size = <int> ; for ( INDArray vector : vectors ) { size + = vector . rows ( ) ; } INDArray result = Nd4j . create ( size + <int> , vectors [ <int> ] . columns ( ) ) ; int index = <int> ; for ( INDArray vector : vectors ) { INDArray put = toFlattened ( vector , Nd4j . ones ( <int> ) ) ; result . put ( new INDArrayIndex [ ] { NDArrayIndex . interval ( index , index + vector . rows ( ) + <int> ) , NDArrayIndex . interval ( <int> , vectors [ <int> ] . columns ( ) ) } , put ) ; index + = vector . rows ( ) ; } return result ; } public abstract IComplexNDArray createComplex ( INDArray arr ) ; public abstract IComplexNDArray createComplex ( IComplexNumber [ ] data , int [ ] shape ) ; public abstract IComplexNDArray createComplex ( List < IComplexNDArray > arrs , int [ ] shape ) ; @Override public INDArray rand ( int rows , int columns , org . nd4j . linalg . api . rng . Random r ) { return rand ( new int [ ] { rows , columns } , r ) ; } @Override public INDArray rand ( int rows , int columns , long seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; return rand ( new int [ ] { rows , columns } , Nd4j . getRandom ( ) ) ; } @Override public INDArray rand ( int rows , int columns ) { return randn ( new int [ ] { rows , columns } , System . currentTimeMillis ( ) ) ; } @Override public INDArray randn ( int rows , int columns , org . nd4j . linalg . api . rng . Random r ) { return randn ( new int [ ] { rows , columns } , r ) ; } @Override public INDArray randn ( int rows , int columns ) { return randn ( new int [ ] { rows , columns } , System . currentTimeMillis ( ) ) ; } @Override public INDArray randn ( int rows , int columns , long seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; return randn ( new int [ ] { rows , columns } , Nd4j . getRandom ( ) ) ; } @Override public INDArray rand ( int [ ] shape , Distribution r ) { INDArray ret = r . sample ( shape ) ; return ret ; } @Override public INDArray rand ( int [ ] shape , org . nd4j . linalg . api . rng . Random r ) { INDArray ret = r . nextDouble ( shape ) ; return ret ; } @Override public INDArray rand ( int [ ] shape , long seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; return rand ( shape , Nd4j . getRandom ( ) ) ; } @Override public INDArray rand ( int [ ] shape ) { return rand ( shape , System . currentTimeMillis ( ) ) ; } @Override public INDArray randn ( int [ ] shape , org . nd4j . linalg . api . rng . Random r ) { return r . nextGaussian ( shape ) ; } @Override public INDArray randn ( int [ ] shape ) { return randn ( shape , System . currentTimeMillis ( ) ) ; } @Override public INDArray randn ( int [ ] shape , long seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; return randn ( shape , Nd4j . getRandom ( ) ) ; } @Override public INDArray create ( double [ ] data ) { return create ( data , new int [ ] { <int> , data . length } ) ; } @Override public INDArray create ( float [ ] data ) { return create ( data , new int [ ] { <int> , data . length } ) ; } @Override public IComplexNDArray createComplex ( double [ ] data ) { assert data . length % <int> = = <int> : <str> ; return createComplex ( data , new int [ ] { <int> , data . length / <int> } ) ; } @Override public INDArray create ( int columns ) { return create ( new int [ ] { <int> , columns } ) ; } @Override public IComplexNDArray createComplex ( int columns ) { return createComplex ( new int [ ] { <int> , columns } ) ; } @Override public INDArray zeros ( int rows , int columns ) { return zeros ( new int [ ] { rows , columns } ) ; } @Override public IComplexNDArray complexZeros ( int rows , int columns ) { return createComplex ( new int [ ] { rows , columns } ) ; } @Override public INDArray zeros ( int columns ) { return zeros ( new int [ ] { <int> , columns } ) ; } @Override public IComplexNDArray complexZeros ( int columns ) { return createComplex ( new int [ ] { <int> , columns } ) ; } @Override public IComplexNDArray complexValueOf ( int [ ] shape , IComplexNumber value ) { IComplexNDArray ones = complexOnes ( shape ) ; ones . assign ( Nd4j . scalar ( value ) ) ; return ones ; } @Override public IComplexNDArray complexValueOf ( int num , double value ) { IComplexNDArray ones = complexOnes ( num ) ; ones . assign ( Nd4j . createDouble ( value , <float> ) ) ; return ones ; } @Override public IComplexNDArray complexValueOf ( int [ ] shape , double value ) { IComplexNDArray ones = complexOnes ( shape ) ; ones . assign ( Nd4j . scalar ( value ) ) ; return ones ; } @Override public IComplexNDArray complexValueOf ( int num , IComplexNumber value ) { IComplexNDArray ones = complexOnes ( num ) ; ones . assign ( Nd4j . scalar ( value ) ) ; return ones ; } @Override public IComplexNDArray createComplex ( int [ ] shape , int [ ] complexStrides , int offset , char ordering ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return createComplex ( Nd4j . createBuffer ( ArrayUtil . prod ( shape ) * <int> ) , shape , complexStrides , offset , ordering ) ; } @Override public INDArray valueArrayOf ( int [ ] shape , double value ) { INDArray create = null ; if ( Nd4j . dataType ( ) = = DataBuffer . Type . DOUBLE ) { double [ ] vals = new double [ ArrayUtil . prod ( shape ) ] ; if ( value ! = <float> ) Arrays . fill ( vals , value ) ; create = Nd4j . create ( vals , shape ) ; } else if ( Nd4j . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] vals = new float [ ArrayUtil . prod ( shape ) ] ; if ( value ! = <float> ) Arrays . fill ( vals , ( float ) value ) ; create = Nd4j . create ( vals , shape ) ; } return create ; } @Override public INDArray create ( int [ ] shape , int [ ] stride , int offset , char ordering ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( Nd4j . createBuffer ( ArrayUtil . prod ( shape ) ) , shape , stride , offset , ordering ) ; } @Override public INDArray valueArrayOf ( int rows , int columns , double value ) { INDArray create = create ( rows , columns ) ; create . assign ( value ) ; return create ; } @Override public INDArray ones ( int rows , int columns ) { return ones ( new int [ ] { rows , columns } ) ; } @Override public IComplexNDArray complexOnes ( int rows , int columns ) { return complexOnes ( new int [ ] { rows , columns } ) ; } @Override public INDArray ones ( int columns ) { return ones ( new int [ ] { <int> , columns } ) ; } @Override public IComplexNDArray complexOnes ( int columns ) { IComplexNDArray base = createComplex ( new int [ ] { <int> , columns } ) ; base . assign ( <int> ) ; return base ; } @Override public INDArray create ( float [ ] data , int [ ] shape , char ordering ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( Nd4j . createBuffer ( data ) , shape , Nd4j . getStrides ( shape , ordering ) , <int> , ordering ) ; } @Override public INDArray concat ( int dimension , INDArray . . . toConcat ) { if ( toConcat . length = = <int> ) return toConcat [ <int> ] ; int sumAlongDim = <int> ; boolean allC = toConcat [ <int> ] . ordering ( ) = = <str> ; for ( int i = <int> ; i < toConcat . length ; i + + ) { sumAlongDim + = toConcat [ i ] . size ( dimension ) ; allC = allC & & toConcat [ i ] . ordering ( ) = = <str> ; } int [ ] outputShape = ArrayUtil . copy ( toConcat [ <int> ] . shape ( ) ) ; outputShape [ dimension ] = sumAlongDim ; int [ ] sortedStrides = Nd4j . getStrides ( outputShape ) ; INDArray ret = Nd4j . create ( outputShape , sortedStrides ) ; if ( ret . isVector ( ) ) { int offset = <int> ; for ( INDArray arr : toConcat ) { for ( int i = <int> ; i < arr . size ( dimension ) ; i + + ) { ret . putScalar ( offset + + , arr . getDouble ( i ) ) ; } } return ret ; } if ( toConcat [ <int> ] . isScalar ( ) ) { INDArray retLinear = ret . linearView ( ) ; for ( int i = <int> ; i < retLinear . length ( ) ; i + + ) retLinear . putScalar ( i , toConcat [ i ] . getDouble ( <int> ) ) ; return ret ; } if ( dimension = = <int> & & allC ) { int currBuffer = <int> ; int currBufferOffset = <int> ; for ( int i = <int> ; i < ret . length ( ) ; i + + ) { ret . data ( ) . put ( i , toConcat [ currBuffer ] . data ( ) . getDouble ( toConcat [ currBuffer ] . offset ( ) + currBufferOffset + + ) ) ; if ( currBufferOffset > = toConcat [ currBuffer ] . length ( ) ) { currBuffer + + ; currBufferOffset = <int> ; } } return ret ; } int arrOffset = <int> ; INDArray [ ] retAlongDimensionArrays = new INDArray [ ret . tensorssAlongDimension ( dimension ) ] ; for ( int i = <int> ; i < retAlongDimensionArrays . length ; i + + ) retAlongDimensionArrays [ i ] = ret . tensorAlongDimension ( i , dimension ) ; for ( INDArray arr : toConcat ) { int arrTensorLength = - <int> ; if ( arr . tensorssAlongDimension ( dimension ) ! = ret . tensorssAlongDimension ( dimension ) ) throw new IllegalStateException ( <str> ) ; for ( int i = <int> ; i < arr . tensorssAlongDimension ( dimension ) ; i + + ) { INDArray retLinear = retAlongDimensionArrays [ i ] ; INDArray arrTensor = arr . tensorAlongDimension ( i , dimension ) ; arrTensorLength = arrTensor . length ( ) ; for ( int j = <int> ; j < arrTensor . length ( ) ; j + + ) { int idx = j + arrOffset ; retLinear . putScalar ( idx , arrTensor . getDouble ( j ) ) ; } } arrOffset + = arrTensorLength ; } return ret ; } @Override public IComplexNDArray concat ( int dimension , IComplexNDArray . . . toConcat ) { if ( toConcat . length = = <int> ) return toConcat [ <int> ] ; validateConcat ( dimension , toConcat ) ; int sumAlongDim = <int> ; for ( int i = <int> ; i < toConcat . length ; i + + ) sumAlongDim + = toConcat [ i ] . shape ( ) [ dimension ] ; int [ ] outputShape = ArrayUtil . copy ( toConcat [ <int> ] . shape ( ) ) ; outputShape [ dimension ] = sumAlongDim ; IComplexNDArray ret = Nd4j . createComplex ( outputShape ) ; IComplexNDArray linear = ret . linearView ( ) ; int count = <int> ; for ( int i = <int> ; i < toConcat . length ; i + + ) { IComplexNDArray flattened = toConcat [ i ] . linearView ( ) ; for ( int j = <int> ; j < flattened . length ( ) ; j + + ) { linear . putScalar ( count + + , flattened . getComplex ( j ) ) ; } } return ret ; } @Override public IComplexNDArray complexFlatten ( IComplexNDArray [ ] flatten ) { int length = <int> ; for ( IComplexNDArray m : flatten ) length + = m . length ( ) ; IComplexNDArray ret = Nd4j . createComplex ( length ) ; int linearIndex = <int> ; for ( IComplexNDArray d : flatten ) { IComplexNDArray flattened = d . linearView ( ) ; for ( int i = <int> ; i < d . length ( ) ; i + + ) { ret . putScalar ( linearIndex + + , flattened . getComplex ( i ) ) ; } } return ret ; } @Override public IComplexNDArray complexFlatten ( List < IComplexNDArray > flatten ) { int length = <int> ; for ( IComplexNDArray m : flatten ) length + = m . length ( ) ; IComplexNDArray ret = Nd4j . createComplex ( length ) ; int linearIndex = <int> ; for ( IComplexNDArray d : flatten ) { IComplexNDArray flattened = d . linearView ( ) ; for ( int i = <int> ; i < d . length ( ) ; i + + ) { ret . putScalar ( linearIndex + + , flattened . getComplex ( i ) ) ; } } return ret ; } public INDArray hstack ( INDArray . . . arrs ) { return Nd4j . concat ( <int> , arrs ) ; } @Override public INDArray vstack ( final INDArray . . . arrs ) { return Nd4j . concat ( <int> , arrs ) ; } @Override public INDArray zeros ( int [ ] shape ) { INDArray ret = create ( shape ) ; return ret ; } @Override public IComplexNDArray complexZeros ( int [ ] shape ) { IComplexNDArray ret = createComplex ( shape ) ; return ret ; } @Override public INDArray ones ( int [ ] shape ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } INDArray ret = create ( shape ) ; ret . assign ( <int> ) ; return ret ; } @Override public IComplexNDArray complexOnes ( int [ ] shape ) { IComplexNDArray ret = createComplex ( shape ) ; ret . assign ( <int> ) ; return ret ; } @Override public IComplexNDArray createComplex ( float [ ] data , int rows , int columns , int [ ] stride , int offset ) { return createComplex ( data , new int [ ] { rows , columns } , stride , offset ) ; } @Override public INDArray create ( float [ ] data , int rows , int columns , int [ ] stride , int offset ) { return create ( data , new int [ ] { rows , columns } , stride , offset ) ; } public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int [ ] stride , int offset ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return createComplex ( Nd4j . createBuffer ( data ) , shape , stride , offset , Nd4j . order ( ) ) ; } public abstract INDArray create ( float [ ] data , int [ ] shape , int [ ] stride , int offset ) ; @Override public INDArray create ( double [ ] data , int [ ] shape ) { return create ( data , shape , Nd4j . getStrides ( shape ) , <int> ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( data , shape , Nd4j . getStrides ( shape ) , <int> ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return createComplex ( data , shape , Nd4j . getComplexStrides ( shape ) , <int> ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return createComplex ( data , shape , Nd4j . getComplexStrides ( shape ) , <int> ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int [ ] stride ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return createComplex ( data , shape , stride , <int> ) ; } @Override public IComplexNDArray createComplex ( float [ ] data , int [ ] shape , int [ ] stride ) { return createComplex ( data , shape , stride , <int> ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int rows , int columns , int [ ] stride , int offset ) { return createComplex ( data , new int [ ] { rows , columns } , stride , offset ) ; } @Override public INDArray create ( double [ ] data , int rows , int columns , int [ ] stride , int offset ) { return create ( data , new int [ ] { rows , columns } , stride , offset ) ; } public abstract IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int [ ] stride , int offset ) ; public abstract INDArray create ( double [ ] data , int [ ] shape , int [ ] stride , int offset ) ; public abstract INDArray create ( List < INDArray > list , int [ ] shape ) ; @Override public IComplexNDArray createComplex ( int rows , int columns , int [ ] stride , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return createComplex ( new double [ rows * columns * <int> ] , new int [ ] { rows , columns } , stride , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return createComplex ( new float [ rows * columns * <int> ] , new int [ ] { rows , columns } , stride , offset ) ; if ( dtype = = DataBuffer . Type . INT ) return createComplex ( new int [ rows * columns * <int> ] , new int [ ] { rows , columns } , stride , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public INDArray create ( int rows , int columns , int [ ] stride , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return create ( new double [ rows * columns ] , new int [ ] { rows , columns } , stride , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return create ( new float [ rows * columns ] , new int [ ] { rows , columns } , stride , offset ) ; if ( dtype = = DataBuffer . Type . INT ) return create ( new int [ rows * columns ] , new int [ ] { rows , columns } , stride , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } public IComplexNDArray createComplex ( int [ ] shape , int [ ] stride , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return createComplex ( new double [ ArrayUtil . prod ( shape ) * <int> ] , shape , stride , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return createComplex ( new float [ ArrayUtil . prod ( shape ) * <int> ] , shape , stride , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public INDArray create ( int [ ] shape , int [ ] stride , int offset ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } DataBuffer buffer = Nd4j . createBuffer ( ArrayUtil . prod ( shape ) ) ; return create ( buffer , shape , stride , offset ) ; } @Override public IComplexNDArray createComplex ( int rows , int columns , int [ ] stride ) { return createComplex ( new int [ ] { rows , columns } , stride ) ; } @Override public INDArray create ( int rows , int columns , int [ ] stride ) { return create ( new int [ ] { rows , columns } , stride ) ; } @Override public IComplexNDArray createComplex ( int [ ] shape , int [ ] stride ) { return createComplex ( shape , stride , <int> ) ; } @Override public INDArray create ( int [ ] shape , int [ ] stride ) { return create ( shape , stride , <int> ) ; } @Override public IComplexNDArray createComplex ( int rows , int columns ) { return createComplex ( new int [ ] { rows , columns } ) ; } @Override public INDArray create ( int rows , int columns ) { return create ( new int [ ] { rows , columns } ) ; } @Override public IComplexNDArray createComplex ( int [ ] shape ) { return createComplex ( shape , Nd4j . getComplexStrides ( shape ) , <int> ) ; } @Override public INDArray create ( int [ ] shape ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( shape , Nd4j . getStrides ( shape ) , <int> ) ; } @Override public INDArray scalar ( Number value , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( value . doubleValue ( ) , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return scalar ( value . floatValue ( ) , offset ) ; if ( dtype = = DataBuffer . Type . INT ) return scalar ( value . intValue ( ) , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public IComplexNDArray complexScalar ( Number value , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( createDouble ( value . doubleValue ( ) , <int> ) , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT | | dtype = = DataBuffer . Type . INT ) return scalar ( createFloat ( value . floatValue ( ) , <int> ) , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public IComplexNDArray complexScalar ( Number value ) { return complexScalar ( value , <int> ) ; } @Override public INDArray scalar ( float value , int offset ) { return create ( new float [ ] { value } , new int [ ] { <int> } , new int [ ] { <int> } , offset ) ; } @Override public INDArray scalar ( double value , int offset ) { return create ( new double [ ] { value } , new int [ ] { <int> } , new int [ ] { <int> } , offset ) ; } @Override public INDArray scalar ( int value , int offset ) { return create ( new int [ ] { value } , new int [ ] { <int> } , new int [ ] { <int> } , offset ) ; } @Override public INDArray scalar ( Number value ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( value . doubleValue ( ) , <int> ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return scalar ( value . floatValue ( ) , <int> ) ; if ( dtype = = DataBuffer . Type . INT ) return scalar ( value . intValue ( ) , <int> ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public INDArray scalar ( float value ) { if ( dtype = = DataBuffer . Type . FLOAT ) return create ( new float [ ] { value } , new int [ ] { <int> } , new int [ ] { <int> } , <int> ) ; else if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( ( double ) value ) ; else return scalar ( ( int ) value ) ; } @Override public INDArray scalar ( double value ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return create ( new double [ ] { value } , new int [ ] { <int> } , new int [ ] { <int> } , <int> ) ; else return scalar ( ( float ) value ) ; } @Override public IComplexNDArray scalar ( IComplexNumber value , int offset ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( value . asDouble ( ) , offset ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return scalar ( value . asFloat ( ) , offset ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public IComplexNDArray scalar ( IComplexFloat value ) { return createComplex ( new float [ ] { value . realComponent ( ) , value . imaginaryComponent ( ) } , new int [ ] { <int> } , new int [ ] { <int> } , <int> ) ; } @Override public IComplexNDArray scalar ( IComplexDouble value ) { return createComplex ( new double [ ] { value . realComponent ( ) , value . imaginaryComponent ( ) } , new int [ ] { <int> } , new int [ ] { <int> } , <int> ) ; } @Override public IComplexNDArray scalar ( IComplexNumber value ) { if ( dtype = = DataBuffer . Type . DOUBLE ) return scalar ( value . asDouble ( ) , <int> ) ; if ( dtype = = DataBuffer . Type . FLOAT ) return scalar ( value . asFloat ( ) , <int> ) ; throw new IllegalStateException ( <str> + dtype ) ; } @Override public IComplexNDArray scalar ( IComplexFloat value , int offset ) { return createComplex ( new float [ ] { value . realComponent ( ) , value . imaginaryComponent ( ) } , new int [ ] { <int> } , new int [ ] { <int> } , offset ) ; } @Override public IComplexNDArray scalar ( IComplexDouble value , int offset ) { return createComplex ( new double [ ] { value . realComponent ( ) , value . imaginaryComponent ( ) } , new int [ ] { <int> } , new int [ ] { <int> } , offset ) ; } @Override public abstract IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int [ ] stride , int offset , char ordering ) ; @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int offset , char ordering ) { return createComplex ( Nd4j . createBuffer ( data ) , shape , offset , ordering ) ; } @Override public IComplexNDArray createComplex ( double [ ] data , int [ ] shape , int offset ) { return createComplex ( Nd4j . createBuffer ( data ) , shape , offset ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int offset ) { return create ( Nd4j . createBuffer ( data ) , shape , offset ) ; } @Override public INDArray create ( float [ ] data , char order ) { int [ ] shape = new int [ ] { <int> , data . length } ; return create ( Nd4j . createBuffer ( data ) , shape , Nd4j . getStrides ( shape , order ) , order , <int> ) ; } @Override public INDArray create ( float [ ] data , int [ ] shape , int [ ] stride , char order , int offset ) { return create ( Nd4j . createBuffer ( data ) , shape , stride , order , offset ) ; } @Override public INDArray create ( double [ ] data , char order ) { return create ( data , new int [ ] { <int> , data . length } , Nd4j . getStrides ( new int [ ] { <int> , data . length } , order ) , order , <int> ) ; } @Override public INDArray create ( double [ ] data , int [ ] shape , int [ ] stride , char order , int offset ) { return create ( Nd4j . createBuffer ( data ) , shape , stride , order , offset ) ; } @Override public INDArray create ( DataBuffer buffer , int [ ] shape , int [ ] stride , char order , int offset ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( buffer , shape , stride , offset , order ) ; } @Override public INDArray create ( int [ ] data , int [ ] shape , int [ ] stride , char order , int offset ) { if ( shape . length = = <int> & & shape [ <int> ] = = <int> ) { shape = new int [ ] { <int> , <int> } ; } return create ( Nd4j . createBuffer ( data ) , shape , stride , order , offset ) ; } } 
