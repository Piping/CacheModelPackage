package org . gradle . internal . jvm ; import org . gradle . api . JavaVersion ; import org . gradle . api . Nullable ; import org . gradle . internal . SystemProperties ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . os . OperatingSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class Jvm implements JavaInfo { private final static Logger LOGGER = LoggerFactory . getLogger ( Jvm . class ) ; private final OperatingSystem os ; private final File javaBase ; private final File javaHome ; private final boolean userSupplied ; private final JavaVersion javaVersion ; private static final AtomicReference < Jvm > CURRENT = new AtomicReference < Jvm > ( ) ; public static Jvm current ( ) { Jvm jvm = CURRENT . get ( ) ; if ( jvm = = null ) { CURRENT . compareAndSet ( null , create ( null ) ) ; jvm = CURRENT . get ( ) ; } return jvm ; } static Jvm create ( File javaBase ) { String vendor = System . getProperty ( <str> ) ; if ( vendor . toLowerCase ( ) . startsWith ( <str> ) ) { return new AppleJvm ( OperatingSystem . current ( ) , javaBase ) ; } if ( vendor . toLowerCase ( ) . startsWith ( <str> ) ) { return new IbmJvm ( OperatingSystem . current ( ) , javaBase ) ; } return new Jvm ( OperatingSystem . current ( ) , javaBase ) ; } Jvm ( OperatingSystem os ) { this ( os , null ) ; } Jvm ( OperatingSystem os , File suppliedJavaBase ) { this . os = os ; if ( suppliedJavaBase = = null ) { try { this . javaBase = new File ( System . getProperty ( <str> ) ) . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new UncheckedException ( e ) ; } this . javaHome = findJavaHome ( javaBase ) ; this . javaVersion = JavaVersion . current ( ) ; this . userSupplied = false ; } else { this . javaBase = suppliedJavaBase ; this . javaHome = suppliedJavaBase ; this . userSupplied = true ; this . javaVersion = null ; } } public static JavaInfo forHome ( File javaHome ) throws JavaHomeException , IllegalArgumentException { if ( javaHome = = null | | ! javaHome . isDirectory ( ) ) { throw new IllegalArgumentException ( <str> + javaHome ) ; } Jvm jvm = create ( javaHome ) ; jvm . getJavaExecutable ( ) ; return jvm ; } @Override public String toString ( ) { if ( userSupplied ) { return <str> + javaBase ; } return String . format ( <str> , SystemProperties . getInstance ( ) . getJavaVersion ( ) , System . getProperty ( <str> ) , System . getProperty ( <str> ) ) ; } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null | | obj . getClass ( ) ! = getClass ( ) ) { return false ; } Jvm other = ( Jvm ) obj ; return other . javaHome . equals ( javaHome ) ; } @Override public int hashCode ( ) { return javaHome . hashCode ( ) ; } private File findExecutable ( String command ) { File exec = new File ( getJavaHome ( ) , <str> + command ) ; File executable = new File ( os . getExecutableName ( exec . getAbsolutePath ( ) ) ) ; if ( executable . isFile ( ) ) { return executable ; } if ( userSupplied ) { throw new JavaHomeException ( String . format ( <str> + <str> , command , executable . getAbsolutePath ( ) ) ) ; } File pathExecutable = os . findInPath ( command ) ; if ( pathExecutable ! = null ) { LOGGER . info ( String . format ( <str> , command , getJavaHome ( ) , pathExecutable ) ) ; return pathExecutable ; } LOGGER . warn ( <str> + <str> , command , getJavaHome ( ) ) ; return new File ( os . getExecutableName ( command ) ) ; } public File getJavaExecutable ( ) throws JavaHomeException { return findExecutable ( <str> ) ; } public File getJavacExecutable ( ) throws JavaHomeException { return findExecutable ( <str> ) ; } public File getJavadocExecutable ( ) throws JavaHomeException { return findExecutable ( <str> ) ; } public File getExecutable ( String name ) throws JavaHomeException { return findExecutable ( name ) ; } public JavaVersion getJavaVersion ( ) { return javaVersion ; } public File getJavaHome ( ) { return javaHome ; } private File findJavaHome ( File javaBase ) { File toolsJar = findToolsJar ( javaBase ) ; if ( toolsJar ! = null ) { return toolsJar . getParentFile ( ) . getParentFile ( ) ; } else if ( javaBase . getName ( ) . equalsIgnoreCase ( <str> ) & & new File ( javaBase . getParentFile ( ) , <str> ) . exists ( ) ) { return javaBase . getParentFile ( ) ; } else { return javaBase ; } } public File getRuntimeJar ( ) { File runtimeJar = new File ( javaBase , <str> ) ; if ( runtimeJar . exists ( ) ) { return runtimeJar ; } runtimeJar = new File ( javaBase , <str> ) ; return runtimeJar . exists ( ) ? runtimeJar : null ; } public File getToolsJar ( ) { return findToolsJar ( javaBase ) ; } @Nullable public Jre getStandaloneJre ( ) { if ( javaVersion . isJava9Compatible ( ) ) { return null ; } if ( os . isWindows ( ) ) { File jreDir ; if ( javaVersion . isJava5 ( ) ) { jreDir = new File ( javaHome . getParentFile ( ) , String . format ( <str> , SystemProperties . getInstance ( ) . getJavaVersion ( ) ) ) ; } else { jreDir = new File ( javaHome . getParentFile ( ) , String . format ( <str> , javaVersion . getMajorVersion ( ) ) ) ; } if ( jreDir . isDirectory ( ) ) { return new DefaultJre ( jreDir ) ; } } if ( ! new File ( javaHome , <str> ) . isDirectory ( ) ) { return new DefaultJre ( javaHome ) ; } return null ; } @Nullable public Jre getJre ( ) { File jreDir = new File ( javaBase , <str> ) ; if ( jreDir . isDirectory ( ) ) { return new DefaultJre ( jreDir ) ; } else if ( JavaVersion . current ( ) . isJava9Compatible ( ) ) { return null ; } return new DefaultJre ( javaBase ) ; } private File findToolsJar ( File javaHome ) { File toolsJar = new File ( javaHome , <str> ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } if ( javaHome . getName ( ) . equalsIgnoreCase ( <str> ) ) { javaHome = javaHome . getParentFile ( ) ; toolsJar = new File ( javaHome , <str> ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } } if ( os . isWindows ( ) ) { String version = SystemProperties . getInstance ( ) . getJavaVersion ( ) ; if ( javaHome . getName ( ) . matches ( <str> ) | | javaHome . getName ( ) . equals ( String . format ( <str> , version ) ) ) { javaHome = new File ( javaHome . getParentFile ( ) , String . format ( <str> , version ) ) ; toolsJar = new File ( javaHome , <str> ) ; if ( toolsJar . exists ( ) ) { return toolsJar ; } } } return null ; } public Map < String , ? > getInheritableEnvironmentVariables ( Map < String , ? > envVars ) { return envVars ; } public boolean isIbmJvm ( ) { return false ; } static class IbmJvm extends Jvm { IbmJvm ( OperatingSystem os , File suppliedJavaBase ) { super ( os , suppliedJavaBase ) ; } @Override public boolean isIbmJvm ( ) { return true ; } } static class AppleJvm extends Jvm { AppleJvm ( OperatingSystem os ) { super ( os ) ; } AppleJvm ( OperatingSystem current , File javaHome ) { super ( current , javaHome ) ; } @Override public File getRuntimeJar ( ) { File javaHome = super . getJavaHome ( ) ; File runtimeJar = new File ( javaHome . getParentFile ( ) , <str> ) ; return runtimeJar . exists ( ) ? runtimeJar : null ; } @Override public File getToolsJar ( ) { return getRuntimeJar ( ) ; } @Override public Map < String , ? > getInheritableEnvironmentVariables ( Map < String , ? > envVars ) { Map < String , Object > vars = new HashMap < String , Object > ( ) ; for ( Map . Entry < String , ? > entry : envVars . entrySet ( ) ) { if ( entry . getKey ( ) . matches ( <str> ) | | entry . getKey ( ) . matches ( <str> ) ) { continue ; } vars . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return vars ; } } private static class DefaultJre extends Jre { private final File jreDir ; public DefaultJre ( File jreDir ) { this . jreDir = jreDir ; } @Override public File getHomeDir ( ) { return jreDir ; } } } 
