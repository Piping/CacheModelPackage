package org . gradle . launcher . exec ; import org . gradle . api . Action ; import org . gradle . api . JavaVersion ; import org . gradle . api . execution . internal . TaskInputsListener ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . file . FileCollectionInternal ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . api . logging . LogLevel ; import org . gradle . execution . CancellableOperationManager ; import org . gradle . execution . DefaultCancellableOperationManager ; import org . gradle . execution . PassThruCancellableOperationManager ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . initialization . BuildRequestContext ; import org . gradle . initialization . ReportedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . event . ListenerManager ; import org . gradle . internal . filewatch . DefaultFileSystemChangeWaiterFactory ; import org . gradle . internal . filewatch . FileSystemChangeWaiter ; import org . gradle . internal . filewatch . FileSystemChangeWaiterFactory ; import org . gradle . internal . filewatch . FileWatcherFactory ; import org . gradle . internal . invocation . BuildAction ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . internal . service . scopes . BuildSessionScopeServices ; import org . gradle . logging . StyledTextOutput ; import org . gradle . logging . StyledTextOutputFactory ; import org . gradle . util . DisconnectableInputStream ; import org . gradle . util . SingleMessageLogger ; public class ContinuousBuildActionExecuter implements BuildExecuter { private final BuildActionExecuter < BuildActionParameters > delegate ; private final ListenerManager listenerManager ; private final OperatingSystem operatingSystem ; private final FileSystemChangeWaiterFactory changeWaiterFactory ; private final ExecutorFactory executorFactory ; private final JavaVersion javaVersion ; private final StyledTextOutput logger ; public ContinuousBuildActionExecuter ( BuildActionExecuter < BuildActionParameters > delegate , FileWatcherFactory fileWatcherFactory , ListenerManager listenerManager , StyledTextOutputFactory styledTextOutputFactory , ExecutorFactory executorFactory ) { this ( delegate , listenerManager , styledTextOutputFactory , JavaVersion . current ( ) , OperatingSystem . current ( ) , executorFactory , new DefaultFileSystemChangeWaiterFactory ( executorFactory , fileWatcherFactory ) ) ; } ContinuousBuildActionExecuter ( BuildActionExecuter < BuildActionParameters > delegate , ListenerManager listenerManager , StyledTextOutputFactory styledTextOutputFactory , JavaVersion javaVersion , OperatingSystem operatingSystem , ExecutorFactory executorFactory , FileSystemChangeWaiterFactory changeWaiterFactory ) { this . delegate = delegate ; this . listenerManager = listenerManager ; this . javaVersion = javaVersion ; this . operatingSystem = operatingSystem ; this . changeWaiterFactory = changeWaiterFactory ; this . executorFactory = executorFactory ; this . logger = styledTextOutputFactory . create ( ContinuousBuildActionExecuter . class , LogLevel . LIFECYCLE ) ; } @Override public Object execute ( BuildAction action , BuildRequestContext requestContext , BuildActionParameters actionParameters , ServiceRegistry contextServices ) { ServiceRegistry buildSessionScopeServices = new BuildSessionScopeServices ( contextServices , action . getStartParameter ( ) , actionParameters . getInjectedPluginClasspath ( ) ) ; try { if ( actionParameters . isContinuous ( ) ) { return executeMultipleBuilds ( action , requestContext , actionParameters , buildSessionScopeServices ) ; } else { return delegate . execute ( action , requestContext , actionParameters , buildSessionScopeServices ) ; } } finally { CompositeStoppable . stoppable ( buildSessionScopeServices ) . stop ( ) ; } } private Object executeMultipleBuilds ( BuildAction action , BuildRequestContext requestContext , final BuildActionParameters actionParameters , ServiceRegistry buildSessionScopeServices ) { if ( ! javaVersion . isJava7Compatible ( ) ) { throw new IllegalStateException ( <str> ) ; } SingleMessageLogger . incubatingFeatureUsed ( <str> ) ; BuildCancellationToken cancellationToken = requestContext . getCancellationToken ( ) ; final CancellableOperationManager cancellableOperationManager ; if ( actionParameters . isInteractive ( ) ) { if ( ! ( System . in instanceof DisconnectableInputStream ) ) { System . setIn ( new DisconnectableInputStream ( System . in ) ) ; } DisconnectableInputStream inputStream = ( DisconnectableInputStream ) System . in ; cancellableOperationManager = new DefaultCancellableOperationManager ( executorFactory . create ( <str> ) , inputStream , cancellationToken ) ; } else { cancellableOperationManager = new PassThruCancellableOperationManager ( cancellationToken ) ; } Object lastResult = null ; int counter = <int> ; while ( ! cancellationToken . isCancellationRequested ( ) ) { if ( + + counter ! = <int> ) { requestContext . getBuildTimeClock ( ) . reset ( ) ; logger . println ( <str> ) . println ( ) ; } FileSystemSubset . Builder fileSystemSubsetBuilder = FileSystemSubset . builder ( ) ; try { lastResult = executeBuildAndAccumulateInputs ( action , requestContext , actionParameters , fileSystemSubsetBuilder , buildSessionScopeServices ) ; } catch ( ReportedException t ) { lastResult = t ; } final FileSystemSubset toWatch = fileSystemSubsetBuilder . build ( ) ; if ( toWatch . isEmpty ( ) ) { logger . println ( ) . withStyle ( StyledTextOutput . Style . Failure ) . println ( <str> ) ; if ( lastResult instanceof ReportedException ) { throw ( ReportedException ) lastResult ; } return lastResult ; } else { cancellableOperationManager . monitorInput ( new Action < BuildCancellationToken > ( ) { @Override public void execute ( BuildCancellationToken cancellationToken ) { FileSystemChangeWaiter waiter = changeWaiterFactory . createChangeWaiter ( cancellationToken ) ; waiter . watch ( toWatch ) ; waiter . wait ( new Runnable ( ) { @Override public void run ( ) { logger . println ( ) . println ( <str> + determineExitHint ( actionParameters ) ) ; } } ) ; } } ) ; } } logger . println ( <str> ) ; if ( lastResult instanceof ReportedException ) { throw ( ReportedException ) lastResult ; } return lastResult ; } public String determineExitHint ( BuildActionParameters actionParameters ) { if ( actionParameters . isInteractive ( ) ) { if ( operatingSystem . isWindows ( ) ) { return <str> ; } else { return <str> ; } } else { return <str> ; } } private Object executeBuildAndAccumulateInputs ( BuildAction action , BuildRequestContext requestContext , BuildActionParameters actionParameters , final FileSystemSubset . Builder fileSystemSubsetBuilder , ServiceRegistry buildSessionScopeServices ) { TaskInputsListener listener = new TaskInputsListener ( ) { @Override public void onExecute ( TaskInternal taskInternal , FileCollectionInternal fileSystemInputs ) { fileSystemInputs . registerWatchPoints ( fileSystemSubsetBuilder ) ; } } ; listenerManager . addListener ( listener ) ; try { return delegate . execute ( action , requestContext , actionParameters , buildSessionScopeServices ) ; } finally { listenerManager . removeListener ( listener ) ; } } } 
