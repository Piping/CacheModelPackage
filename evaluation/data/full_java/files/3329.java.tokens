package org . nd4j . linalg . jcublas . buffer ; import io . netty . buffer . ByteBuf ; import jcuda . Pointer ; import jcuda . Sizeof ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . util . ArrayUtil ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; public class CudaFloatDataBuffer extends BaseCudaDataBuffer { public CudaFloatDataBuffer ( int length ) { super ( length , Sizeof . FLOAT ) ; } public CudaFloatDataBuffer ( float [ ] buffer ) { this ( buffer . length ) ; setData ( buffer ) ; } public CudaFloatDataBuffer ( double [ ] data ) { super ( data ) ; } public CudaFloatDataBuffer ( int [ ] data ) { super ( data ) ; } public CudaFloatDataBuffer ( ByteBuf buf , int length ) { super ( buf , length ) ; } public CudaFloatDataBuffer ( byte [ ] data , int length ) { super ( data , length ) ; } public CudaFloatDataBuffer ( ByteBuffer buffer , int length ) { super ( buffer , length ) ; } @Override public void assign ( int [ ] indices , float [ ] data , boolean contiguous , int inc ) { if ( indices . length ! = data . length ) throw new IllegalArgumentException ( <str> ) ; if ( indices . length > length ( ) ) throw new IllegalArgumentException ( <str> + length ( ) + <str> + data . length ) ; if ( contiguous ) { int offset = indices [ <int> ] ; Pointer p = Pointer . to ( data ) ; set ( offset , data . length , p , inc ) ; } else throw new UnsupportedOperationException ( <str> ) ; } @Override public void assign ( int [ ] indices , double [ ] data , boolean contiguous , int inc ) { if ( indices . length ! = data . length ) throw new IllegalArgumentException ( <str> ) ; if ( indices . length > length ( ) ) throw new IllegalArgumentException ( <str> + length ( ) + <str> + data . length ) ; if ( contiguous ) { int offset = indices [ <int> ] ; Pointer p = Pointer . to ( data ) ; set ( offset , data . length , p , inc ) ; } else throw new UnsupportedOperationException ( <str> ) ; } @Override protected DataBuffer create ( int length ) { return new CudaFloatDataBuffer ( length ) ; } @Override public double [ ] getDoublesAt ( int offset , int inc , int length ) { return ArrayUtil . toDoubles ( getFloatsAt ( offset , inc , length ) ) ; } @Override public void setData ( int [ ] data ) { setData ( ArrayUtil . toFloats ( data ) ) ; } @Override public void setData ( double [ ] data ) { setData ( ArrayUtil . toFloats ( data ) ) ; } @Override public byte [ ] asBytes ( ) { float [ ] data = asFloat ( ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; for ( int i = <int> ; i < data . length ; i + + ) try { dos . writeFloat ( data [ i ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return bos . toByteArray ( ) ; } @Override public DataBuffer . Type dataType ( ) { return DataBuffer . Type . FLOAT ; } @Override public double [ ] asDouble ( ) { return ArrayUtil . toDoubles ( asFloat ( ) ) ; } @Override public int [ ] asInt ( ) { return ArrayUtil . toInts ( asFloat ( ) ) ; } @Override public double getDouble ( int i ) { return getFloat ( i ) ; } @Override public DataBuffer create ( double [ ] data ) { return new CudaFloatDataBuffer ( data ) ; } @Override public DataBuffer create ( float [ ] data ) { return new CudaFloatDataBuffer ( data ) ; } @Override public DataBuffer create ( int [ ] data ) { return new CudaFloatDataBuffer ( data ) ; } @Override public DataBuffer create ( ByteBuf buf , int length ) { return new CudaFloatDataBuffer ( buf , length ) ; } @Override public void flush ( ) { } } 
