package org . elasticsearch . cluster ; import org . elasticsearch . action . admin . indices . create . CreateIndexClusterStateUpdateRequest ; import org . elasticsearch . cluster . metadata . IndexTemplateFilter ; import org . elasticsearch . cluster . metadata . IndexTemplateMetaData ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . FailedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . StartedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . allocator . BalancedShardsAllocator ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocator ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . cluster . settings . ClusterDynamicSettings ; import org . elasticsearch . cluster . settings . DynamicSettings ; import org . elasticsearch . cluster . settings . Validator ; import org . elasticsearch . common . inject . ModuleTestCase ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . settings . IndexDynamicSettings ; public class ClusterModuleTests extends ModuleTestCase { public static class FakeAllocationDecider extends AllocationDecider { protected FakeAllocationDecider ( Settings settings ) { super ( settings ) ; } } static class FakeShardsAllocator implements ShardsAllocator { @Override public void applyStartedShards ( StartedRerouteAllocation allocation ) { } @Override public void applyFailedShards ( FailedRerouteAllocation allocation ) { } @Override public boolean allocateUnassigned ( RoutingAllocation allocation ) { return false ; } @Override public boolean rebalance ( RoutingAllocation allocation ) { return false ; } @Override public boolean move ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return false ; } } static class FakeIndexTemplateFilter implements IndexTemplateFilter { @Override public boolean apply ( CreateIndexClusterStateUpdateRequest request , IndexTemplateMetaData template ) { return false ; } } public void testRegisterClusterDynamicSettingDuplicate ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; try { module . registerClusterDynamicSetting ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , Validator . EMPTY ) ; } catch ( IllegalArgumentException e ) { assertEquals ( e . getMessage ( ) , <str> + EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE + <str> ) ; } } public void testRegisterClusterDynamicSetting ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; module . registerClusterDynamicSetting ( <str> , Validator . EMPTY ) ; assertInstanceBindingWithAnnotation ( module , DynamicSettings . class , dynamicSettings - > dynamicSettings . hasDynamicSetting ( <str> ) , ClusterDynamicSettings . class ) ; } public void testRegisterIndexDynamicSettingDuplicate ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; try { module . registerIndexDynamicSetting ( EnableAllocationDecider . INDEX_ROUTING_ALLOCATION_ENABLE , Validator . EMPTY ) ; } catch ( IllegalArgumentException e ) { assertEquals ( e . getMessage ( ) , <str> + EnableAllocationDecider . INDEX_ROUTING_ALLOCATION_ENABLE + <str> ) ; } } public void testRegisterIndexDynamicSetting ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; module . registerIndexDynamicSetting ( <str> , Validator . EMPTY ) ; assertInstanceBindingWithAnnotation ( module , DynamicSettings . class , dynamicSettings - > dynamicSettings . hasDynamicSetting ( <str> ) , IndexDynamicSettings . class ) ; } public void testRegisterAllocationDeciderDuplicate ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; try { module . registerAllocationDecider ( EnableAllocationDecider . class ) ; } catch ( IllegalArgumentException e ) { assertEquals ( e . getMessage ( ) , <str> + EnableAllocationDecider . class . getName ( ) + <str> ) ; } } public void testRegisterAllocationDecider ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; module . registerAllocationDecider ( FakeAllocationDecider . class ) ; assertSetMultiBinding ( module , AllocationDecider . class , FakeAllocationDecider . class ) ; } public void testRegisterShardsAllocator ( ) { Settings settings = Settings . builder ( ) . put ( ClusterModule . SHARDS_ALLOCATOR_TYPE_KEY , <str> ) . build ( ) ; ClusterModule module = new ClusterModule ( settings ) ; module . registerShardsAllocator ( <str> , FakeShardsAllocator . class ) ; assertBinding ( module , ShardsAllocator . class , FakeShardsAllocator . class ) ; } public void testRegisterShardsAllocatorAlreadyRegistered ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; try { module . registerShardsAllocator ( ClusterModule . BALANCED_ALLOCATOR , FakeShardsAllocator . class ) ; } catch ( IllegalArgumentException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } } public void testUnknownShardsAllocator ( ) { Settings settings = Settings . builder ( ) . put ( ClusterModule . SHARDS_ALLOCATOR_TYPE_KEY , <str> ) . build ( ) ; ClusterModule module = new ClusterModule ( settings ) ; assertBindingFailure ( module , <str> ) ; } public void testEvenShardsAllocatorBackcompat ( ) { Settings settings = Settings . builder ( ) . put ( ClusterModule . SHARDS_ALLOCATOR_TYPE_KEY , ClusterModule . EVEN_SHARD_COUNT_ALLOCATOR ) . build ( ) ; ClusterModule module = new ClusterModule ( settings ) ; assertBinding ( module , ShardsAllocator . class , BalancedShardsAllocator . class ) ; } public void testRegisterIndexTemplateFilterDuplicate ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; try { module . registerIndexTemplateFilter ( FakeIndexTemplateFilter . class ) ; module . registerIndexTemplateFilter ( FakeIndexTemplateFilter . class ) ; } catch ( IllegalArgumentException e ) { assertEquals ( e . getMessage ( ) , <str> + FakeIndexTemplateFilter . class . getName ( ) + <str> ) ; } } public void testRegisterIndexTemplateFilter ( ) { ClusterModule module = new ClusterModule ( Settings . EMPTY ) ; module . registerIndexTemplateFilter ( FakeIndexTemplateFilter . class ) ; assertSetMultiBinding ( module , IndexTemplateFilter . class , FakeIndexTemplateFilter . class ) ; } } 
