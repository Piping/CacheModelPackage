package com . google . common . cache ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static com . google . common . cache . TestingRemovalListeners . countingRemovalListener ; import static com . google . common . cache . TestingWeighers . constantWeigher ; import static com . google . common . cache . TestingWeighers . intKeyWeigher ; import static com . google . common . cache . TestingWeighers . intValueWeigher ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . cache . CacheTesting . Receiver ; import com . google . common . cache . LocalCache . ReferenceEntry ; import com . google . common . cache . TestingCacheLoaders . IdentityLoader ; import com . google . common . cache . TestingRemovalListeners . CountingRemovalListener ; import junit . framework . TestCase ; import java . util . List ; import java . util . Set ; public class CacheEvictionTest extends TestCase { static final int MAX_SIZE = <int> ; public void testEviction_setMaxSegmentSize ( ) { IdentityLoader < Object > loader = identityLoader ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . maximumSize ( i ) . build ( loader ) ; assertEquals ( i , CacheTesting . getTotalSegmentSize ( cache ) ) ; } } public void testEviction_setMaxSegmentWeight ( ) { IdentityLoader < Object > loader = identityLoader ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . maximumWeight ( i ) . weigher ( constantWeigher ( <int> ) ) . build ( loader ) ; assertEquals ( i , CacheTesting . getTotalSegmentSize ( cache ) ) ; } } public void testEviction_maxSizeOneSegment ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( MAX_SIZE ) . build ( loader ) ; for ( int i = <int> ; i < <int> * MAX_SIZE ; i + + ) { cache . getUnchecked ( i ) ; assertEquals ( Math . min ( i + <int> , MAX_SIZE ) , cache . size ( ) ) ; } assertEquals ( MAX_SIZE , cache . size ( ) ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_maxWeightOneSegment ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> * MAX_SIZE ) . weigher ( constantWeigher ( <int> ) ) . build ( loader ) ; for ( int i = <int> ; i < <int> * MAX_SIZE ; i + + ) { cache . getUnchecked ( i ) ; assertEquals ( Math . min ( i + <int> , MAX_SIZE ) , cache . size ( ) ) ; } assertEquals ( MAX_SIZE , cache . size ( ) ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_maxSize ( ) { CountingRemovalListener < Integer , Integer > removalListener = countingRemovalListener ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumSize ( MAX_SIZE ) . removalListener ( removalListener ) . build ( loader ) ; for ( int i = <int> ; i < <int> * MAX_SIZE ; i + + ) { cache . getUnchecked ( i ) ; assertTrue ( cache . size ( ) < = MAX_SIZE ) ; } assertEquals ( MAX_SIZE , CacheTesting . accessQueueSize ( cache ) ) ; assertEquals ( MAX_SIZE , cache . size ( ) ) ; CacheTesting . processPendingNotifications ( cache ) ; assertEquals ( MAX_SIZE , removalListener . getCount ( ) ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_maxWeight ( ) { CountingRemovalListener < Integer , Integer > removalListener = countingRemovalListener ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumWeight ( <int> * MAX_SIZE ) . weigher ( constantWeigher ( <int> ) ) . removalListener ( removalListener ) . build ( loader ) ; for ( int i = <int> ; i < <int> * MAX_SIZE ; i + + ) { cache . getUnchecked ( i ) ; assertTrue ( cache . size ( ) < = MAX_SIZE ) ; } assertEquals ( MAX_SIZE , CacheTesting . accessQueueSize ( cache ) ) ; assertEquals ( MAX_SIZE , cache . size ( ) ) ; CacheTesting . processPendingNotifications ( cache ) ; assertEquals ( MAX_SIZE , removalListener . getCount ( ) ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_maxWeight_zero ( ) { CountingRemovalListener < Integer , Integer > removalListener = countingRemovalListener ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; Weigher < Integer , Integer > evensOnly = new Weigher < Integer , Integer > ( ) { @Override public int weigh ( Integer k , Integer v ) { return k % <int> ; } } ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> ) . weigher ( evensOnly ) . removalListener ( removalListener ) . build ( loader ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . isEmpty ( ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; CacheTesting . checkValidState ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> , <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> , <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_maxWeight_entryTooBig ( ) { CountingRemovalListener < Integer , Integer > removalListener = countingRemovalListener ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> ) . weigher ( intValueWeigher ( ) ) . removalListener ( removalListener ) . build ( loader ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> , <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; assertThat ( cache . getUnchecked ( <int> ) ) . isEqualTo ( <int> ) ; assertThat ( cache . asMap ( ) . keySet ( ) ) . containsExactly ( <int> ) ; CacheTesting . processPendingNotifications ( cache ) ; assertThat ( removalListener . getCount ( ) ) . isEqualTo ( <int> ) ; CacheTesting . checkValidState ( cache ) ; } public void testEviction_overflow ( ) { CountingRemovalListener < Object , Object > removalListener = countingRemovalListener ( ) ; IdentityLoader < Object > loader = identityLoader ( ) ; LoadingCache < Object , Object > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> < < <int> ) . weigher ( constantWeigher ( Integer . MAX_VALUE ) ) . removalListener ( removalListener ) . build ( loader ) ; cache . getUnchecked ( objectWithHash ( <int> ) ) ; cache . getUnchecked ( objectWithHash ( <int> ) ) ; CacheTesting . processPendingNotifications ( cache ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; } public void testUpdateRecency_onGet ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; final LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumSize ( MAX_SIZE ) . build ( loader ) ; CacheTesting . checkRecency ( cache , MAX_SIZE , new Receiver < ReferenceEntry < Integer , Integer > > ( ) { @Override public void accept ( ReferenceEntry < Integer , Integer > entry ) { cache . getUnchecked ( entry . getKey ( ) ) ; } } ) ; } public void testUpdateRecency_onInvalidate ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; final LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumSize ( MAX_SIZE ) . concurrencyLevel ( <int> ) . build ( loader ) ; CacheTesting . checkRecency ( cache , MAX_SIZE , new Receiver < ReferenceEntry < Integer , Integer > > ( ) { @Override public void accept ( ReferenceEntry < Integer , Integer > entry ) { Integer key = entry . getKey ( ) ; cache . invalidate ( key ) ; } } ) ; } public void testEviction_lru ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) . build ( loader ) ; CacheTesting . warmUp ( cache , <int> , <int> ) ; Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testEviction_weightedLru ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> ) . weigher ( intKeyWeigher ( ) ) . build ( loader ) ; CacheTesting . warmUp ( cache , <int> , <int> ) ; Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testEviction_overweight ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumWeight ( <int> ) . weigher ( intKeyWeigher ( ) ) . build ( loader ) ; CacheTesting . warmUp ( cache , <int> , <int> ) ; Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . contains ( <int> ) ; } public void testEviction_invalidateAll ( ) { IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) . build ( loader ) ; Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . isEmpty ( ) ; getAll ( cache , asList ( <int> , <int> , <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) ; cache . invalidateAll ( ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . isEmpty ( ) ; getAll ( cache , asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; } private static void getAll ( LoadingCache < Integer , Integer > cache , List < Integer > keys ) { for ( int i : keys ) { cache . getUnchecked ( i ) ; } } private Object objectWithHash ( final int hash ) { return new Object ( ) { @Override public int hashCode ( ) { return hash ; } } ; } } 
