package io . netty . channel . oio ; import io . netty . channel . AbstractChannel ; import io . netty . channel . Channel ; import io . netty . channel . ChannelPromise ; import io . netty . channel . EventLoop ; import io . netty . channel . ThreadPerChannelEventLoop ; import java . net . SocketAddress ; public abstract class AbstractOioChannel extends AbstractChannel { protected static final int SO_TIMEOUT = <int> ; private volatile boolean readPending ; private final Runnable readTask = new Runnable ( ) { @Override public void run ( ) { doRead ( ) ; } } ; protected AbstractOioChannel ( Channel parent ) { super ( parent ) ; } @Override protected AbstractUnsafe newUnsafe ( ) { return new DefaultOioUnsafe ( ) ; } private final class DefaultOioUnsafe extends AbstractUnsafe { @Override public void connect ( final SocketAddress remoteAddress , final SocketAddress localAddress , final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) | | ! ensureOpen ( promise ) ) { return ; } try { boolean wasActive = isActive ( ) ; doConnect ( remoteAddress , localAddress ) ; safeSetSuccess ( promise ) ; if ( ! wasActive & & isActive ( ) ) { pipeline ( ) . fireChannelActive ( ) ; } } catch ( Throwable t ) { safeSetFailure ( promise , annotateConnectException ( t , remoteAddress ) ) ; closeIfClosed ( ) ; } } } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof ThreadPerChannelEventLoop ; } protected abstract void doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception ; @Override protected void doBeginRead ( ) throws Exception { if ( isReadPending ( ) ) { return ; } setReadPending ( true ) ; eventLoop ( ) . execute ( readTask ) ; } protected abstract void doRead ( ) ; protected boolean isReadPending ( ) { return readPending ; } protected void setReadPending ( boolean readPending ) { this . readPending = readPending ; } } 
