package org . elasticsearch . cluster . block ; import org . elasticsearch . Version ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import java . util . EnumSet ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . CoreMatchers . endsWith ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . not ; public class ClusterBlockTests extends ESTestCase { public void testSerialization ( ) throws Exception { int iterations = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iterations ; i + + ) { Version version = randomVersion ( random ( ) ) ; EnumSet < ClusterBlockLevel > levels = EnumSet . noneOf ( ClusterBlockLevel . class ) ; int nbLevels = randomIntBetween ( <int> , ClusterBlockLevel . values ( ) . length ) ; for ( int j = <int> ; j < nbLevels ; j + + ) { levels . add ( randomFrom ( ClusterBlockLevel . values ( ) ) ) ; } ClusterBlock clusterBlock = new ClusterBlock ( randomInt ( ) , <str> + randomInt ( ) , randomBoolean ( ) , randomBoolean ( ) , randomFrom ( RestStatus . values ( ) ) , levels ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; out . setVersion ( version ) ; clusterBlock . writeTo ( out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; in . setVersion ( version ) ; ClusterBlock result = ClusterBlock . readClusterBlock ( in ) ; assertThat ( result . id ( ) , equalTo ( clusterBlock . id ( ) ) ) ; assertThat ( result . status ( ) , equalTo ( clusterBlock . status ( ) ) ) ; assertThat ( result . description ( ) , equalTo ( clusterBlock . description ( ) ) ) ; assertThat ( result . retryable ( ) , equalTo ( clusterBlock . retryable ( ) ) ) ; assertThat ( result . disableStatePersistence ( ) , equalTo ( clusterBlock . disableStatePersistence ( ) ) ) ; assertArrayEquals ( result . levels ( ) . toArray ( ) , clusterBlock . levels ( ) . toArray ( ) ) ; } } public void testToStringDanglingComma ( ) { EnumSet < ClusterBlockLevel > levels = EnumSet . noneOf ( ClusterBlockLevel . class ) ; int nbLevels = randomIntBetween ( <int> , ClusterBlockLevel . values ( ) . length ) ; for ( int j = <int> ; j < nbLevels ; j + + ) { levels . add ( randomFrom ( ClusterBlockLevel . values ( ) ) ) ; } ClusterBlock clusterBlock = new ClusterBlock ( randomInt ( ) , <str> + randomInt ( ) , randomBoolean ( ) , randomBoolean ( ) , randomFrom ( RestStatus . values ( ) ) , levels ) ; assertThat ( clusterBlock . toString ( ) , not ( endsWith ( <str> ) ) ) ; } } 
