package org . apache . cassandra . db ; import java . util . Objects ; import java . security . MessageDigest ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . FBUtilities ; public class LivenessInfo { public static final long NO_TIMESTAMP = Long . MIN_VALUE ; public static final int NO_TTL = <int> ; public static final int NO_EXPIRATION_TIME = Integer . MAX_VALUE ; public static final LivenessInfo EMPTY = new LivenessInfo ( NO_TIMESTAMP ) ; protected final long timestamp ; protected LivenessInfo ( long timestamp ) { this . timestamp = timestamp ; } public static LivenessInfo create ( CFMetaData metadata , long timestamp , int nowInSec ) { int defaultTTL = metadata . params . defaultTimeToLive ; if ( defaultTTL ! = NO_TTL ) return expiring ( timestamp , defaultTTL , nowInSec ) ; return new LivenessInfo ( timestamp ) ; } public static LivenessInfo expiring ( long timestamp , int ttl , int nowInSec ) { return new ExpiringLivenessInfo ( timestamp , ttl , nowInSec + ttl ) ; } public static LivenessInfo create ( CFMetaData metadata , long timestamp , int ttl , int nowInSec ) { return ttl = = NO_TTL ? create ( metadata , timestamp , nowInSec ) : expiring ( timestamp , ttl , nowInSec ) ; } public static LivenessInfo create ( long timestamp , int ttl , int localExpirationTime ) { return ttl = = NO_TTL ? new LivenessInfo ( timestamp ) : new ExpiringLivenessInfo ( timestamp , ttl , localExpirationTime ) ; } public boolean isEmpty ( ) { return timestamp = = NO_TIMESTAMP ; } public long timestamp ( ) { return timestamp ; } public boolean isExpiring ( ) { return false ; } public int ttl ( ) { return NO_TTL ; } public int localExpirationTime ( ) { return NO_EXPIRATION_TIME ; } public boolean isLive ( int nowInSec ) { return ! isEmpty ( ) ; } public void digest ( MessageDigest digest ) { FBUtilities . updateWithLong ( digest , timestamp ( ) ) ; } public void validate ( ) { } public int dataSize ( ) { return TypeSizes . sizeof ( timestamp ( ) ) ; } public boolean supersedes ( LivenessInfo other ) { return timestamp > other . timestamp ; } public LivenessInfo withUpdatedTimestamp ( long newTimestamp ) { return new LivenessInfo ( newTimestamp ) ; } @Override public String toString ( ) { return String . format ( <str> , timestamp ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof LivenessInfo ) ) return false ; LivenessInfo that = ( LivenessInfo ) other ; return this . timestamp ( ) = = that . timestamp ( ) & & this . ttl ( ) = = that . ttl ( ) & & this . localExpirationTime ( ) = = that . localExpirationTime ( ) ; } @Override public int hashCode ( ) { return Objects . hash ( timestamp ( ) , ttl ( ) , localExpirationTime ( ) ) ; } private static class ExpiringLivenessInfo extends LivenessInfo { private final int ttl ; private final int localExpirationTime ; private ExpiringLivenessInfo ( long timestamp , int ttl , int localExpirationTime ) { super ( timestamp ) ; assert ttl ! = NO_TTL & & localExpirationTime ! = NO_EXPIRATION_TIME ; this . ttl = ttl ; this . localExpirationTime = localExpirationTime ; } @Override public int ttl ( ) { return ttl ; } @Override public int localExpirationTime ( ) { return localExpirationTime ; } @Override public boolean isExpiring ( ) { return true ; } @Override public boolean isLive ( int nowInSec ) { return nowInSec < localExpirationTime ; } @Override public void digest ( MessageDigest digest ) { super . digest ( digest ) ; FBUtilities . updateWithInt ( digest , localExpirationTime ) ; FBUtilities . updateWithInt ( digest , ttl ) ; } @Override public void validate ( ) { if ( ttl < <int> ) throw new MarshalException ( <str> ) ; if ( localExpirationTime < <int> ) throw new MarshalException ( <str> ) ; } @Override public int dataSize ( ) { return super . dataSize ( ) + TypeSizes . sizeof ( ttl ) + TypeSizes . sizeof ( localExpirationTime ) ; } @Override public LivenessInfo withUpdatedTimestamp ( long newTimestamp ) { return new ExpiringLivenessInfo ( newTimestamp , ttl , localExpirationTime ) ; } @Override public String toString ( ) { return String . format ( <str> , timestamp , ttl , localExpirationTime ) ; } } } 
