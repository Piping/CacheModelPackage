package org . elasticsearch . search . aggregations . support . format ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . elasticsearch . index . mapper . ip . IpFieldMapper ; import org . joda . time . DateTimeZone ; import java . io . IOException ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . text . NumberFormat ; import java . util . Locale ; public interface ValueFormatter extends Streamable { public final static ValueFormatter RAW = new Raw ( ) ; public final static ValueFormatter IPv4 = new IPv4Formatter ( ) ; public final static ValueFormatter GEOHASH = new GeoHash ( ) ; public final static ValueFormatter BOOLEAN = new BooleanFormatter ( ) ; byte id ( ) ; String format ( long value ) ; String format ( double value ) ; static class Raw implements ValueFormatter { static final byte ID = <int> ; @Override public String format ( long value ) { return String . valueOf ( value ) ; } @Override public String format ( double value ) { return String . valueOf ( value ) ; } @Override public byte id ( ) { return ID ; } @Override public void readFrom ( StreamInput in ) throws IOException { } @Override public void writeTo ( StreamOutput out ) throws IOException { } } public static class DateTime implements ValueFormatter { public static final ValueFormatter DEFAULT = new ValueFormatter . DateTime ( DateFieldMapper . Defaults . DATE_TIME_FORMATTER ) ; private DateTimeZone timeZone = DateTimeZone . UTC ; public static DateTime mapper ( DateFieldMapper . DateFieldType fieldType , DateTimeZone timezone ) { return new DateTime ( fieldType . dateTimeFormatter ( ) , timezone ) ; } static final byte ID = <int> ; FormatDateTimeFormatter formatter ; DateTime ( ) { } public DateTime ( String format ) { this . formatter = Joda . forPattern ( format ) ; } public DateTime ( FormatDateTimeFormatter formatter ) { this . formatter = formatter ; } public DateTime ( String format , DateTimeZone timezone ) { this . formatter = Joda . forPattern ( format ) ; this . timeZone = timezone ! = null ? timezone : DateTimeZone . UTC ; } public DateTime ( FormatDateTimeFormatter formatter , DateTimeZone timezone ) { this . formatter = formatter ; this . timeZone = timezone ! = null ? timezone : DateTimeZone . UTC ; } @Override public String format ( long time ) { return formatter . printer ( ) . withZone ( timeZone ) . print ( time ) ; } @Override public String format ( double value ) { return format ( ( long ) value ) ; } @Override public byte id ( ) { return ID ; } @Override public void readFrom ( StreamInput in ) throws IOException { formatter = Joda . forPattern ( in . readString ( ) ) ; timeZone = DateTimeZone . forID ( in . readString ( ) ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( formatter . format ( ) ) ; out . writeString ( timeZone . getID ( ) ) ; } } public static abstract class Number implements ValueFormatter { NumberFormat format ; Number ( ) { } Number ( NumberFormat format ) { this . format = format ; } @Override public String format ( long value ) { return format . format ( value ) ; } @Override public String format ( double value ) { return format . format ( value ) ; } public static class Pattern extends Number { private static final DecimalFormatSymbols SYMBOLS = new DecimalFormatSymbols ( Locale . ROOT ) ; static final byte ID = <int> ; String pattern ; Pattern ( ) { } public Pattern ( String pattern ) { super ( new DecimalFormat ( pattern , SYMBOLS ) ) ; this . pattern = pattern ; } @Override public byte id ( ) { return ID ; } @Override public void readFrom ( StreamInput in ) throws IOException { pattern = in . readString ( ) ; format = new DecimalFormat ( pattern , SYMBOLS ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( pattern ) ; } } } static class IPv4Formatter implements ValueFormatter { static final byte ID = <int> ; @Override public byte id ( ) { return ID ; } @Override public String format ( long value ) { return IpFieldMapper . longToIp ( value ) ; } @Override public String format ( double value ) { return format ( ( long ) value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { } @Override public void writeTo ( StreamOutput out ) throws IOException { } } static class GeoHash implements ValueFormatter { static final byte ID = <int> ; @Override public byte id ( ) { return ID ; } @Override public String format ( long value ) { return GeoHashUtils . stringEncode ( value ) ; } @Override public String format ( double value ) { return format ( ( long ) value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { } @Override public void writeTo ( StreamOutput out ) throws IOException { } } static class BooleanFormatter implements ValueFormatter { static final byte ID = <int> ; @Override public byte id ( ) { return ID ; } @Override public String format ( long value ) { return Boolean . valueOf ( value ! = <int> ) . toString ( ) ; } @Override public String format ( double value ) { return Boolean . valueOf ( value ! = <int> ) . toString ( ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { } @Override public void writeTo ( StreamOutput out ) throws IOException { } } } 
