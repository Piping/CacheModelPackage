package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Cubemap ; import com . badlogic . gdx . graphics . Cubemap . CubemapSide ; import com . badlogic . gdx . graphics . g3d . Attributes ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . Shader ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . CubemapAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . shaders . BaseShader ; import com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ; import com . badlogic . gdx . graphics . g3d . utils . AnimationController ; import com . badlogic . gdx . graphics . g3d . utils . DefaultShaderProvider ; import com . badlogic . gdx . graphics . glutils . FacedCubemapData ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . ui . List ; import com . badlogic . gdx . scenes . scene2d . utils . ClickListener ; import com . badlogic . gdx . tests . g3d . shaders . MultiPassShader ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . StringBuilder ; public class ShaderCollectionTest extends BaseG3dHudTest { final static String hotLoadFolder = null ; final static String tempFolder = <str> ; protected String shaders [ ] = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; protected String environments [ ] = new String [ ] { <str> , <str> , <str> , <str> } ; protected String materials [ ] = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public static class TestShaderProvider extends DefaultShaderProvider { public boolean error = false ; public String name = <str> ; public void clear ( ) { for ( final Shader shader : shaders ) shader . dispose ( ) ; shaders . clear ( ) ; } public boolean revert ( ) { if ( config . vertexShader = = null | | config . fragmentShader = = null ) return false ; config . vertexShader = null ; config . fragmentShader = null ; clear ( ) ; return true ; } @Override public Shader getShader ( Renderable renderable ) { try { return super . getShader ( renderable ) ; } catch ( Throwable e ) { if ( tempFolder ! = null & & Gdx . app . getType ( ) = = ApplicationType . Desktop ) Gdx . files . absolute ( tempFolder ) . child ( name + <str> ) . writeString ( e . getMessage ( ) , false ) ; if ( ! revert ( ) ) { Gdx . app . error ( <str> , e . getMessage ( ) ) ; throw new GdxRuntimeException ( <str> , e ) ; } error = true ; Gdx . app . error ( <str> , <str> , e ) ; return super . getShader ( renderable ) ; } } @Override protected Shader createShader ( Renderable renderable ) { if ( config . vertexShader ! = null & & config . fragmentShader ! = null & & tempFolder ! = null & & Gdx . app . getType ( ) = = ApplicationType . Desktop ) { String prefix = DefaultShader . createPrefix ( renderable , config ) ; Gdx . files . absolute ( tempFolder ) . child ( name + <str> ) . writeString ( prefix + config . vertexShader , false ) ; Gdx . files . absolute ( tempFolder ) . child ( name + <str> ) . writeString ( prefix + config . fragmentShader , false ) ; } BaseShader result = new MultiPassShader ( renderable , config ) ; if ( tempFolder ! = null & & Gdx . app . getType ( ) = = ApplicationType . Desktop ) Gdx . files . absolute ( tempFolder ) . child ( name + <str> ) . writeString ( result . program . getLog ( ) , false ) ; return result ; } } protected Environment environment ; protected DirectionalLight dirLight ; protected TestShaderProvider shaderProvider ; protected FileHandle shaderRoot ; protected ModelBatch shaderBatch ; protected CollapsableWindow shadersWindow , materialsWindow , environmentsWindow ; protected ObjectMap < ModelInstance , AnimationController > animationControllers = new ObjectMap < ModelInstance , AnimationController > ( ) ; protected String currentModel = null ; protected String currentMaterial = null ; protected boolean loadingMaterial = false ; Cubemap cubemap ; @Override public void create ( ) { super . create ( ) ; environment = new Environment ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; environment . add ( dirLight = new DirectionalLight ( ) . set ( <float> , <float> , <float> , - <float> , - <float> , - <float> ) ) ; shaderProvider = new TestShaderProvider ( ) ; shaderBatch = new ModelBatch ( shaderProvider ) ; cam . position . set ( <int> , <int> , <int> ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . update ( ) ; showAxes = true ; onModelClicked ( <str> ) ; shaderRoot = ( hotLoadFolder ! = null & & Gdx . app . getType ( ) = = ApplicationType . Desktop ) ? Gdx . files . absolute ( hotLoadFolder ) : Gdx . files . internal ( <str> ) ; } @Override public void dispose ( ) { shaderBatch . dispose ( ) ; shaderBatch = null ; shaderProvider = null ; if ( cubemap ! = null ) cubemap . dispose ( ) ; cubemap = null ; super . dispose ( ) ; } public void setEnvironment ( String name ) { if ( name = = null ) return ; if ( cubemap ! = null ) { cubemap . dispose ( ) ; cubemap = null ; } if ( name . equals ( <str> ) ) { if ( environment . has ( CubemapAttribute . EnvironmentMap ) ) { environment . remove ( CubemapAttribute . EnvironmentMap ) ; shaderProvider . clear ( ) ; } } else { FileHandle root = Gdx . files . internal ( <str> ) ; FacedCubemapData faces = new FacedCubemapData ( root . child ( name + <str> ) , root . child ( name + <str> ) , root . child ( name + <str> ) , root . child ( name + <str> ) , root . child ( name + <str> ) , root . child ( name + <str> ) , false ) ; cubemap = new Cubemap ( faces ) ; faces . load ( CubemapSide . NegativeX , root . child ( name + <str> ) ) ; cubemap . load ( faces ) ; if ( ! environment . has ( CubemapAttribute . EnvironmentMap ) ) shaderProvider . clear ( ) ; environment . set ( new CubemapAttribute ( CubemapAttribute . EnvironmentMap , cubemap ) ) ; } } public void setMaterial ( String name ) { if ( name = = null ) return ; if ( currentlyLoading ! = null ) { Gdx . app . error ( <str> , <str> ) ; return ; } currentlyLoading = <str> + name + <str> ; loadingMaterial = true ; if ( ! name . equals ( currentMaterial ) ) assets . load ( currentlyLoading , Model . class ) ; loading = true ; } public void setShader ( String name ) { shaderProvider . error = false ; if ( name . equals ( <str> ) ) { shaderProvider . config . vertexShader = null ; shaderProvider . config . fragmentShader = null ; shaderProvider . name = <str> ; } else { ShaderLoader loader = new ShaderLoader ( shaderRoot ) ; shaderProvider . config . vertexShader = loader . load ( name + <str> ) ; shaderProvider . config . fragmentShader = loader . load ( name + <str> ) ; shaderProvider . name = name ; } shaderProvider . clear ( ) ; } private final Vector3 tmpV = new Vector3 ( ) ; private final Quaternion tmpQ = new Quaternion ( ) ; private final BoundingBox bounds = new BoundingBox ( ) ; @Override protected void render ( ModelBatch batch , Array < ModelInstance > instances ) { } final Vector3 dirLightRotAxis = new Vector3 ( - <int> , - <int> , - <int> ) . nor ( ) ; @Override public void render ( Array < ModelInstance > instances ) { dirLight . direction . rotate ( dirLightRotAxis , Gdx . graphics . getDeltaTime ( ) * <int> f ) ; super . render ( null ) ; for ( ObjectMap . Entry < ModelInstance , AnimationController > e : animationControllers . entries ( ) ) e . value . update ( Gdx . graphics . getDeltaTime ( ) ) ; shaderBatch . begin ( cam ) ; shaderBatch . render ( instances , environment ) ; shaderBatch . end ( ) ; } @Override protected void getStatus ( StringBuilder stringBuilder ) { super . getStatus ( stringBuilder ) ; if ( shaderProvider . error ) stringBuilder . append ( <str> ) ; else { for ( final ModelInstance instance : instances ) { if ( instance . animations . size > <int> ) { stringBuilder . append ( <str> ) ; break ; } } } } protected String currentlyLoading ; @Override protected void onModelClicked ( final String name ) { if ( name = = null ) return ; if ( currentlyLoading ! = null ) { Gdx . app . error ( <str> , <str> ) ; return ; } currentlyLoading = <str> + name ; loadingMaterial = false ; if ( ! name . equals ( currentModel ) ) assets . load ( currentlyLoading , Model . class ) ; loading = true ; } @Override protected void onLoaded ( ) { if ( currentlyLoading = = null | | currentlyLoading . length ( ) = = <int> ) return ; if ( loadingMaterial ) { loadingMaterial = false ; if ( currentMaterial ! = null & & ! currentMaterial . equals ( currentlyLoading ) ) assets . unload ( currentMaterial ) ; currentMaterial = currentlyLoading ; currentlyLoading = null ; ModelInstance instance = instances . get ( <int> ) ; if ( instance ! = null ) { instance . materials . get ( <int> ) . clear ( ) ; instance . materials . get ( <int> ) . set ( assets . get ( currentMaterial , Model . class ) . materials . get ( <int> ) ) ; } } else { if ( currentModel ! = null & & ! currentModel . equals ( currentlyLoading ) ) assets . unload ( currentModel ) ; currentModel = currentlyLoading ; currentlyLoading = null ; instances . clear ( ) ; animationControllers . clear ( ) ; final ModelInstance instance = new ModelInstance ( assets . get ( currentModel , Model . class ) , transform ) ; instances . add ( instance ) ; if ( instance . animations . size > <int> ) animationControllers . put ( instance , new AnimationController ( instance ) ) ; instance . calculateBoundingBox ( bounds ) ; cam . position . set ( <int> , <int> , <int> ) . nor ( ) . scl ( bounds . getDimensions ( tmpV ) . len ( ) * <float> ) . add ( bounds . getCenter ( tmpV ) ) ; cam . up . set ( <int> , <int> , <int> ) ; cam . lookAt ( inputController . target . set ( bounds . getCenter ( tmpV ) ) ) ; cam . far = Math . max ( <int> f , bounds . getDimensions ( tmpV ) . len ( ) * <float> ) ; cam . update ( ) ; moveRadius = bounds . getDimensions ( tmpV ) . len ( ) * <float> ; } } @Override protected void createHUD ( ) { super . createHUD ( ) ; final List < String > shadersList = new List ( skin ) ; shadersList . setItems ( shaders ) ; shadersList . addListener ( new ClickListener ( ) { @Override public void clicked ( InputEvent event , float x , float y ) { if ( ! shadersWindow . isCollapsed ( ) & & getTapCount ( ) = = <int> ) { setShader ( shadersList . getSelected ( ) ) ; shadersWindow . collapse ( ) ; } } } ) ; shadersWindow = addListWindow ( <str> , shadersList , - <int> , - <int> ) ; final List < String > materialsList = new List ( skin ) ; materialsList . setItems ( materials ) ; materialsList . addListener ( new ClickListener ( ) { @Override public void clicked ( InputEvent event , float x , float y ) { if ( ! materialsWindow . isCollapsed ( ) & & getTapCount ( ) = = <int> ) { setMaterial ( materialsList . getSelected ( ) ) ; materialsWindow . collapse ( ) ; } } } ) ; materialsWindow = addListWindow ( <str> , materialsList , modelsWindow . getWidth ( ) , - <int> ) ; final List < String > environmentsList = new List ( skin ) ; environmentsList . setItems ( environments ) ; environmentsList . addListener ( new ClickListener ( ) { @Override public void clicked ( InputEvent event , float x , float y ) { if ( ! environmentsWindow . isCollapsed ( ) & & getTapCount ( ) = = <int> ) { setEnvironment ( environmentsList . getSelected ( ) ) ; environmentsWindow . collapse ( ) ; } } } ) ; environmentsWindow = addListWindow ( <str> , environmentsList , materialsWindow . getRight ( ) , - <int> ) ; } protected void switchAnimation ( ) { for ( ObjectMap . Entry < ModelInstance , AnimationController > e : animationControllers . entries ( ) ) { int animIndex = <int> ; if ( e . value . current ! = null ) { for ( int i = <int> ; i < e . key . animations . size ; i + + ) { final Animation animation = e . key . animations . get ( i ) ; if ( e . value . current . animation = = animation ) { animIndex = i ; break ; } } } animIndex = ( animIndex + <int> ) % e . key . animations . size ; e . value . animate ( e . key . animations . get ( animIndex ) . id , - <int> , <float> , null , <float> ) ; } } @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . SPACE | | keycode = = Keys . MENU ) switchAnimation ( ) ; return super . keyUp ( keycode ) ; } } 
