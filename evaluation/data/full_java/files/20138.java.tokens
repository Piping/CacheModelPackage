package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelOption ; import org . junit . Ignore ; import org . junit . Test ; import java . net . Socket ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import static org . junit . Assert . * ; public class ServerSocketSuspendTest extends AbstractServerSocketTest { private static final int NUM_CHANNELS = <int> ; private static final long TIMEOUT = <int> ; @Test @Ignore ( <str> ) public void testSuspendAndResumeAccept ( ) throws Throwable { run ( ) ; } public void testSuspendAndResumeAccept ( ServerBootstrap sb ) throws Throwable { AcceptedChannelCounter counter = new AcceptedChannelCounter ( NUM_CHANNELS ) ; sb . option ( ChannelOption . SO_BACKLOG , <int> ) ; sb . option ( ChannelOption . AUTO_READ , false ) ; sb . childHandler ( counter ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; List < Socket > sockets = new ArrayList < Socket > ( ) ; try { long startTime = System . nanoTime ( ) ; for ( int i = <int> ; i < NUM_CHANNELS ; i + + ) { Socket s = new Socket ( ) ; s . connect ( addr , <int> ) ; sockets . add ( s ) ; } sc . config ( ) . setAutoRead ( true ) ; counter . latch . await ( ) ; long endTime = System . nanoTime ( ) ; assertTrue ( endTime - startTime > TIMEOUT ) ; } finally { for ( Socket s : sockets ) { s . close ( ) ; } } Thread . sleep ( TIMEOUT / <int> ) ; try { long startTime = System . nanoTime ( ) ; for ( int i = <int> ; i < NUM_CHANNELS ; i + + ) { Socket s = new Socket ( ) ; s . connect ( addr , <int> ) ; sockets . add ( s ) ; } long endTime = System . nanoTime ( ) ; assertTrue ( endTime - startTime < TIMEOUT ) ; } finally { for ( Socket s : sockets ) { s . close ( ) ; } } } @ChannelHandler.Sharable private static final class AcceptedChannelCounter extends ChannelInboundHandlerAdapter { final CountDownLatch latch ; AcceptedChannelCounter ( int nChannels ) { latch = new CountDownLatch ( nChannels ) ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { latch . countDown ( ) ; } } } 
