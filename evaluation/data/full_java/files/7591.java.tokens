package org . elasticsearch . search . suggest . completion ; import org . apache . lucene . analysis . Analyzer ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . HasContextAndHeaders ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . ObjectParser ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . core . CompletionFieldMapper ; import org . elasticsearch . index . query . RegexpFlag ; import org . elasticsearch . search . suggest . SuggestContextParser ; import org . elasticsearch . search . suggest . SuggestionSearchContext ; import org . elasticsearch . search . suggest . completion . context . ContextMapping ; import org . elasticsearch . search . suggest . completion . context . ContextMappings ; import java . io . IOException ; import java . util . * ; public class CompletionSuggestParser implements SuggestContextParser { private static ObjectParser < CompletionSuggestionContext , ContextAndSuggest > TLP_PARSER = new ObjectParser < > ( <str> , null ) ; private static ObjectParser < CompletionSuggestionBuilder . RegexOptionsBuilder , ContextAndSuggest > REGEXP_PARSER = new ObjectParser < > ( <str> , CompletionSuggestionBuilder . RegexOptionsBuilder : : new ) ; private static ObjectParser < CompletionSuggestionBuilder . FuzzyOptionsBuilder , ContextAndSuggest > FUZZY_PARSER = new ObjectParser < > ( <str> , CompletionSuggestionBuilder . FuzzyOptionsBuilder : : new ) ; static { FUZZY_PARSER . declareInt ( CompletionSuggestionBuilder . FuzzyOptionsBuilder : : setFuzzyMinLength , new ParseField ( <str> ) ) ; FUZZY_PARSER . declareInt ( CompletionSuggestionBuilder . FuzzyOptionsBuilder : : setMaxDeterminizedStates , new ParseField ( <str> ) ) ; FUZZY_PARSER . declareBoolean ( CompletionSuggestionBuilder . FuzzyOptionsBuilder : : setUnicodeAware , new ParseField ( <str> ) ) ; FUZZY_PARSER . declareInt ( CompletionSuggestionBuilder . FuzzyOptionsBuilder : : setFuzzyPrefixLength , new ParseField ( <str> ) ) ; FUZZY_PARSER . declareBoolean ( CompletionSuggestionBuilder . FuzzyOptionsBuilder : : setTranspositions , new ParseField ( <str> ) ) ; FUZZY_PARSER . declareValue ( ( a , b ) - > { try { a . setFuzziness ( Fuzziness . parse ( b ) . asDistance ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchException ( e ) ; } } , new ParseField ( <str> ) ) ; REGEXP_PARSER . declareInt ( CompletionSuggestionBuilder . RegexOptionsBuilder : : setMaxDeterminizedStates , new ParseField ( <str> ) ) ; REGEXP_PARSER . declareStringOrNull ( CompletionSuggestionBuilder . RegexOptionsBuilder : : setFlags , new ParseField ( <str> ) ) ; TLP_PARSER . declareStringArray ( CompletionSuggestionContext : : setPayloadFields , new ParseField ( <str> ) ) ; TLP_PARSER . declareObjectOrDefault ( CompletionSuggestionContext : : setFuzzyOptionsBuilder , FUZZY_PARSER , CompletionSuggestionBuilder . FuzzyOptionsBuilder : : new , new ParseField ( <str> ) ) ; TLP_PARSER . declareObject ( CompletionSuggestionContext : : setRegexOptionsBuilder , REGEXP_PARSER , new ParseField ( <str> ) ) ; TLP_PARSER . declareString ( SuggestionSearchContext . SuggestionContext : : setField , new ParseField ( <str> ) ) ; TLP_PARSER . declareField ( ( p , v , c ) - > { String analyzerName = p . text ( ) ; Analyzer analyzer = c . mapperService . analysisService ( ) . analyzer ( analyzerName ) ; if ( analyzer = = null ) { throw new IllegalArgumentException ( <str> + analyzerName + <str> ) ; } v . setAnalyzer ( analyzer ) ; } , new ParseField ( <str> ) , ObjectParser . ValueType . STRING ) ; TLP_PARSER . declareString ( SuggestionSearchContext . SuggestionContext : : setField , new ParseField ( <str> ) ) ; TLP_PARSER . declareInt ( SuggestionSearchContext . SuggestionContext : : setSize , new ParseField ( <str> ) ) ; TLP_PARSER . declareInt ( SuggestionSearchContext . SuggestionContext : : setShardSize , new ParseField ( <str> ) ) ; TLP_PARSER . declareField ( ( p , v , c ) - > { XContentBuilder builder = XContentFactory . contentBuilder ( p . contentType ( ) ) ; builder . copyCurrentStructure ( p ) ; BytesReference bytes = builder . bytes ( ) ; c . contextParser = XContentFactory . xContent ( bytes ) . createParser ( bytes ) ; p . skipChildren ( ) ; } , new ParseField ( <str> , <str> ) , ObjectParser . ValueType . OBJECT ) ; } private static class ContextAndSuggest { XContentParser contextParser ; final MapperService mapperService ; ContextAndSuggest ( MapperService mapperService ) { this . mapperService = mapperService ; } } private final CompletionSuggester completionSuggester ; public CompletionSuggestParser ( CompletionSuggester completionSuggester ) { this . completionSuggester = completionSuggester ; } @Override public SuggestionSearchContext . SuggestionContext parse ( XContentParser parser , MapperService mapperService , IndexFieldDataService fieldDataService , HasContextAndHeaders headersContext ) throws IOException { final CompletionSuggestionContext suggestion = new CompletionSuggestionContext ( completionSuggester , mapperService , fieldDataService ) ; final ContextAndSuggest contextAndSuggest = new ContextAndSuggest ( mapperService ) ; TLP_PARSER . parse ( parser , suggestion , contextAndSuggest ) ; final XContentParser contextParser = contextAndSuggest . contextParser ; MappedFieldType mappedFieldType = mapperService . smartNameFieldType ( suggestion . getField ( ) ) ; if ( mappedFieldType = = null ) { throw new ElasticsearchException ( <str> + suggestion . getField ( ) + <str> ) ; } else if ( mappedFieldType instanceof CompletionFieldMapper . CompletionFieldType ) { CompletionFieldMapper . CompletionFieldType type = ( CompletionFieldMapper . CompletionFieldType ) mappedFieldType ; if ( type . hasContextMappings ( ) = = false & & contextParser ! = null ) { throw new IllegalArgumentException ( <str> + type . names ( ) . fullName ( ) + <str> ) ; } Map < String , List < ContextMapping . QueryContext > > queryContexts = Collections . emptyMap ( ) ; if ( type . hasContextMappings ( ) & & contextParser ! = null ) { ContextMappings contextMappings = type . getContextMappings ( ) ; contextParser . nextToken ( ) ; queryContexts = new HashMap < > ( contextMappings . size ( ) ) ; assert contextParser . currentToken ( ) = = XContentParser . Token . START_OBJECT ; XContentParser . Token currentToken ; String currentFieldName ; while ( ( currentToken = contextParser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( currentToken = = XContentParser . Token . FIELD_NAME ) { currentFieldName = contextParser . currentName ( ) ; final ContextMapping mapping = contextMappings . get ( currentFieldName ) ; queryContexts . put ( currentFieldName , mapping . parseQueryContext ( contextParser ) ) ; } } contextParser . close ( ) ; } suggestion . setFieldType ( type ) ; suggestion . setQueryContexts ( queryContexts ) ; return suggestion ; } else { throw new IllegalArgumentException ( <str> + suggestion . getField ( ) + <str> ) ; } } } 
