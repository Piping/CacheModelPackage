package org . elasticsearch . search . query ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . MinDocQuery ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Collector ; import org . apache . lucene . search . ConstantScoreQuery ; import org . apache . lucene . search . FieldDoc ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . MultiCollector ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . Sort ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . TimeLimitingCollector ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . search . TopDocsCollector ; import org . apache . lucene . search . TopFieldCollector ; import org . apache . lucene . search . TopScoreDocCollector ; import org . apache . lucene . search . TotalHitCountCollector ; import org . apache . lucene . search . Weight ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . lucene . MinimumScoreCollector ; import org . elasticsearch . common . lucene . search . FilteredCollector ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . SearchPhase ; import org . elasticsearch . search . SearchService ; import org . elasticsearch . search . aggregations . AggregationPhase ; import org . elasticsearch . search . internal . ScrollContext ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . rescore . RescorePhase ; import org . elasticsearch . search . rescore . RescoreSearchContext ; import org . elasticsearch . search . sort . SortParseElement ; import org . elasticsearch . search . sort . TrackScoresParseElement ; import org . elasticsearch . search . suggest . SuggestPhase ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import static java . util . Collections . unmodifiableMap ; public class QueryPhase implements SearchPhase { private final AggregationPhase aggregationPhase ; private final SuggestPhase suggestPhase ; private RescorePhase rescorePhase ; @Inject public QueryPhase ( AggregationPhase aggregationPhase , SuggestPhase suggestPhase , RescorePhase rescorePhase ) { this . aggregationPhase = aggregationPhase ; this . suggestPhase = suggestPhase ; this . rescorePhase = rescorePhase ; } @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { Map < String , SearchParseElement > parseElements = new HashMap < > ( ) ; parseElements . put ( <str> , new FromParseElement ( ) ) ; parseElements . put ( <str> , new SizeParseElement ( ) ) ; parseElements . put ( <str> , new IndicesBoostParseElement ( ) ) ; parseElements . put ( <str> , new IndicesBoostParseElement ( ) ) ; parseElements . put ( <str> , new QueryParseElement ( ) ) ; parseElements . put ( <str> , new PostFilterParseElement ( ) ) ; parseElements . put ( <str> , new PostFilterParseElement ( ) ) ; parseElements . put ( <str> , new SortParseElement ( ) ) ; parseElements . put ( <str> , new TrackScoresParseElement ( ) ) ; parseElements . put ( <str> , new TrackScoresParseElement ( ) ) ; parseElements . put ( <str> , new MinScoreParseElement ( ) ) ; parseElements . put ( <str> , new MinScoreParseElement ( ) ) ; parseElements . put ( <str> , new TimeoutParseElement ( ) ) ; parseElements . put ( <str> , new TerminateAfterParseElement ( ) ) ; parseElements . putAll ( aggregationPhase . parseElements ( ) ) ; parseElements . putAll ( suggestPhase . parseElements ( ) ) ; parseElements . putAll ( rescorePhase . parseElements ( ) ) ; return unmodifiableMap ( parseElements ) ; } @Override public void preProcess ( SearchContext context ) { context . preProcess ( ) ; } @Override public void execute ( SearchContext searchContext ) throws QueryPhaseExecutionException { aggregationPhase . preProcess ( searchContext ) ; boolean rescore = execute ( searchContext , searchContext . searcher ( ) ) ; if ( rescore ) { rescorePhase . execute ( searchContext ) ; } suggestPhase . execute ( searchContext ) ; aggregationPhase . execute ( searchContext ) ; } private static boolean returnsDocsInOrder ( Query query , Sort sort ) { if ( sort = = null | | Sort . RELEVANCE . equals ( sort ) ) { return query . getClass ( ) = = ConstantScoreQuery . class | | query . getClass ( ) = = MatchAllDocsQuery . class ; } else { return Sort . INDEXORDER . equals ( sort ) ; } } static boolean execute ( SearchContext searchContext , final IndexSearcher searcher ) throws QueryPhaseExecutionException { QuerySearchResult queryResult = searchContext . queryResult ( ) ; queryResult . searchTimedOut ( false ) ; final SearchType searchType = searchContext . searchType ( ) ; boolean rescore = false ; try { queryResult . from ( searchContext . from ( ) ) ; queryResult . size ( searchContext . size ( ) ) ; Query query = searchContext . query ( ) ; final int totalNumDocs = searcher . getIndexReader ( ) . numDocs ( ) ; int numDocs = Math . min ( searchContext . from ( ) + searchContext . size ( ) , totalNumDocs ) ; Collector collector ; Callable < TopDocs > topDocsCallable ; assert query = = searcher . rewrite ( query ) ; if ( searchContext . size ( ) = = <int> ) { final TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector ( ) ; collector = totalHitCountCollector ; topDocsCallable = new Callable < TopDocs > ( ) { @Override public TopDocs call ( ) throws Exception { return new TopDocs ( totalHitCountCollector . getTotalHits ( ) , Lucene . EMPTY_SCORE_DOCS , <int> ) ; } } ; } else { final ScrollContext scrollContext = searchContext . scrollContext ( ) ; assert ( scrollContext ! = null ) = = ( searchContext . request ( ) . scroll ( ) ! = null ) ; final TopDocsCollector < ? > topDocsCollector ; ScoreDoc lastEmittedDoc ; if ( searchContext . request ( ) . scroll ( ) ! = null ) { numDocs = Math . min ( searchContext . size ( ) , totalNumDocs ) ; lastEmittedDoc = scrollContext . lastEmittedDoc ; if ( returnsDocsInOrder ( query , searchContext . sort ( ) ) ) { if ( scrollContext . totalHits = = - <int> ) { assert scrollContext . lastEmittedDoc = = null ; } else { if ( scrollContext . lastEmittedDoc ! = null ) { BooleanQuery bq = new BooleanQuery . Builder ( ) . add ( query , BooleanClause . Occur . MUST ) . add ( new MinDocQuery ( lastEmittedDoc . doc + <int> ) , BooleanClause . Occur . FILTER ) . build ( ) ; query = bq ; } searchContext . terminateAfter ( numDocs ) ; } } } else { lastEmittedDoc = null ; } if ( totalNumDocs = = <int> ) { numDocs = <int> ; } assert numDocs > <int> ; if ( searchContext . sort ( ) ! = null ) { topDocsCollector = TopFieldCollector . create ( searchContext . sort ( ) , numDocs , ( FieldDoc ) lastEmittedDoc , true , searchContext . trackScores ( ) , searchContext . trackScores ( ) ) ; } else { rescore = ! searchContext . rescore ( ) . isEmpty ( ) ; for ( RescoreSearchContext rescoreContext : searchContext . rescore ( ) ) { numDocs = Math . max ( rescoreContext . window ( ) , numDocs ) ; } topDocsCollector = TopScoreDocCollector . create ( numDocs , lastEmittedDoc ) ; } collector = topDocsCollector ; topDocsCallable = new Callable < TopDocs > ( ) { @Override public TopDocs call ( ) throws Exception { TopDocs topDocs = topDocsCollector . topDocs ( ) ; if ( scrollContext ! = null ) { if ( scrollContext . totalHits = = - <int> ) { scrollContext . totalHits = topDocs . totalHits ; scrollContext . maxScore = topDocs . getMaxScore ( ) ; } else { topDocs . totalHits = scrollContext . totalHits ; topDocs . setMaxScore ( scrollContext . maxScore ) ; } switch ( searchType ) { case QUERY_AND_FETCH : case DFS_QUERY_AND_FETCH : if ( topDocs . scoreDocs . length > <int> ) { scrollContext . lastEmittedDoc = topDocs . scoreDocs [ topDocs . scoreDocs . length - <int> ] ; } break ; default : break ; } } return topDocs ; } } ; } final boolean terminateAfterSet = searchContext . terminateAfter ( ) ! = SearchContext . DEFAULT_TERMINATE_AFTER ; if ( terminateAfterSet ) { collector = Lucene . wrapCountBasedEarlyTerminatingCollector ( collector , searchContext . terminateAfter ( ) ) ; } if ( searchContext . parsedPostFilter ( ) ! = null ) { final Weight filterWeight = searcher . createNormalizedWeight ( searchContext . parsedPostFilter ( ) . query ( ) , false ) ; collector = new FilteredCollector ( collector , filterWeight ) ; } List < Collector > allCollectors = new ArrayList < > ( ) ; allCollectors . add ( collector ) ; allCollectors . addAll ( searchContext . queryCollectors ( ) . values ( ) ) ; collector = MultiCollector . wrap ( allCollectors ) ; if ( searchContext . minimumScore ( ) ! = null ) { collector = new MinimumScoreCollector ( collector , searchContext . minimumScore ( ) ) ; } if ( collector . getClass ( ) = = TotalHitCountCollector . class ) { while ( true ) { if ( query instanceof ConstantScoreQuery ) { query = ( ( ConstantScoreQuery ) query ) . getQuery ( ) ; } else { break ; } } if ( query . getClass ( ) = = MatchAllDocsQuery . class ) { collector = null ; topDocsCallable = new Callable < TopDocs > ( ) { @Override public TopDocs call ( ) throws Exception { int count = searcher . getIndexReader ( ) . numDocs ( ) ; return new TopDocs ( count , Lucene . EMPTY_SCORE_DOCS , <int> ) ; } } ; } else if ( query . getClass ( ) = = TermQuery . class & & searcher . getIndexReader ( ) . hasDeletions ( ) = = false ) { final Term term = ( ( TermQuery ) query ) . getTerm ( ) ; collector = null ; topDocsCallable = new Callable < TopDocs > ( ) { @Override public TopDocs call ( ) throws Exception { int count = <int> ; for ( LeafReaderContext context : searcher . getIndexReader ( ) . leaves ( ) ) { count + = context . reader ( ) . docFreq ( term ) ; } return new TopDocs ( count , Lucene . EMPTY_SCORE_DOCS , <int> ) ; } } ; } } final boolean timeoutSet = searchContext . timeoutInMillis ( ) ! = SearchService . NO_TIMEOUT . millis ( ) ; if ( timeoutSet & & collector ! = null ) { collector = Lucene . wrapTimeLimitingCollector ( collector , searchContext . timeEstimateCounter ( ) , searchContext . timeoutInMillis ( ) ) ; } try { if ( collector ! = null ) { searcher . search ( query , collector ) ; } } catch ( TimeLimitingCollector . TimeExceededException e ) { assert timeoutSet : <str> ; queryResult . searchTimedOut ( true ) ; } catch ( Lucene . EarlyTerminationException e ) { assert terminateAfterSet : <str> ; queryResult . terminatedEarly ( true ) ; } finally { searchContext . clearReleasables ( SearchContext . Lifetime . COLLECTION ) ; } if ( terminateAfterSet & & queryResult . terminatedEarly ( ) = = null ) { queryResult . terminatedEarly ( false ) ; } queryResult . topDocs ( topDocsCallable . call ( ) ) ; return rescore ; } catch ( Throwable e ) { throw new QueryPhaseExecutionException ( searchContext , <str> , e ) ; } } } 
