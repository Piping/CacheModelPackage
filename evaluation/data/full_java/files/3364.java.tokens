package org . nd4j . linalg . jcublas . util ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . Multimap ; import jcuda . Pointer ; import jcuda . Sizeof ; import jcuda . runtime . JCuda ; import jcuda . runtime . cudaMemcpyKind ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . jcublas . CublasPointer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . jcublas . buffer . allocation . PinnedMemoryStrategy ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . jcublas . context . CudaContext ; import org . nd4j . linalg . jcublas . ops . executioner . JCudaExecutioner ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . ArrayList ; import java . util . List ; public class KernelParamsWrapper implements AutoCloseable { private boolean closeInvoked = false ; private boolean closeContext ; private CudaContext context ; private boolean scalarResult ; final public Object [ ] kernelParameters ; final List < CublasPointer > pointersToFree ; final List < CublasPointer > resultPointers ; private Op resultOp ; public Object [ ] getKernelParameters ( ) { return kernelParameters ; } private Multimap < INDArray , CublasPointer > arrayToPointer ; private int resultLength = <int> ; public KernelParamsWrapper setResultArray ( INDArray array ) { CublasPointer resultPointer = arrayToPointer . get ( array ) . iterator ( ) . next ( ) ; resultPointer . setResultPointer ( true ) ; if ( resultPointer = = null ) { throw new RuntimeException ( <str> ) ; } resultPointers . add ( resultPointer ) ; return this ; } public KernelParamsWrapper setResultOp ( Accumulation op , INDArray result , int . . . dimension ) { resultOp = op ; resultLength = result . length ( ) ; scalarResult = ( dimension = = null | | dimension . length < <int> | | dimension [ <int> ] = = Integer . MAX_VALUE ) ; setResultArray ( result ) ; return this ; } public KernelParamsWrapper ( Op op , Object . . . kernelParams ) { this ( op , false , kernelParams ) ; } public KernelParamsWrapper ( Op op , boolean closeContext , Object . . . kernelParams ) { kernelParameters = new Object [ kernelParams . length ] ; arrayToPointer = ArrayListMultimap . create ( ) ; pointersToFree = new ArrayList < > ( ) ; resultPointers = new ArrayList < > ( ) ; context = new CudaContext ( closeContext ) ; context . initOldStream ( ) ; context . initStream ( ) ; this . closeContext = closeContext ; for ( int i = <int> ; i < kernelParams . length ; i + + ) { Object arg = kernelParams [ i ] ; if ( arg instanceof JCudaBuffer ) { JCudaBuffer buffer = ( JCudaBuffer ) arg ; CublasPointer pointerToFree = new CublasPointer ( buffer , context ) ; kernelParameters [ i ] = pointerToFree . getDevicePointer ( ) ; pointersToFree . add ( pointerToFree ) ; } else if ( arg instanceof INDArray ) { INDArray array = ( INDArray ) arg ; CublasPointer pointerToFree = new CublasPointer ( array , context ) ; kernelParameters [ i ] = pointerToFree . getDevicePointer ( ) ; pointersToFree . add ( pointerToFree ) ; arrayToPointer . put ( array , pointerToFree ) ; } else kernelParameters [ i ] = arg ; } } @Override public void close ( ) throws Exception { if ( closeInvoked ) return ; for ( CublasPointer cublasPointer : pointersToFree ) { if ( resultPointers . contains ( cublasPointer ) ) { if ( closeContext ) { if ( scalarResult & & resultOp instanceof Accumulation ) { setResultForOp ( resultOp , cublasPointer ) ; } else cublasPointer . copyToHost ( ) ; cublasPointer . close ( ) ; } else context . setResultPointer ( cublasPointer ) ; } } if ( closeContext ) context . destroy ( ) ; closeInvoked = true ; } private void setResultForOp ( Op acc , CublasPointer devicePointer ) { if ( devicePointer . getBuffer ( ) . dataType ( ) = = DataBuffer . Type . DOUBLE ) { if ( ContextHolder . getInstance ( ) . getMemoryStrategy ( ) instanceof PinnedMemoryStrategy ) { ByteBuffer buff = devicePointer . getHostPointer ( ) . getByteBuffer ( <int> , acc . x ( ) . data ( ) . getElementSize ( ) * resultLength ) ; buff . order ( ByteOrder . nativeOrder ( ) ) ; buff . rewind ( ) ; INDArray setResult = Nd4j . create ( Nd4j . createBuffer ( buff , DataBuffer . Type . DOUBLE , resultLength ) ) ; acc . setX ( setResult ) ; JCudaExecutioner exec = ( JCudaExecutioner ) Nd4j . getExecutioner ( ) ; exec . calculateBlockResult ( ( Accumulation ) acc , setResult ) ; } else { double [ ] data = new double [ resultLength ] ; Pointer get = Pointer . to ( data ) ; JCuda . cudaMemcpyAsync ( get , devicePointer . getDevicePointer ( ) , resultLength * Sizeof . DOUBLE , cudaMemcpyKind . cudaMemcpyDeviceToHost , context . getOldStream ( ) ) ; context . syncOldStream ( ) ; } } else if ( devicePointer . getBuffer ( ) . dataType ( ) = = DataBuffer . Type . FLOAT ) { if ( ContextHolder . getInstance ( ) . getMemoryStrategy ( ) instanceof PinnedMemoryStrategy ) { ByteBuffer buff = devicePointer . getHostPointer ( ) . getByteBuffer ( <int> , acc . x ( ) . data ( ) . getElementSize ( ) * resultLength ) ; buff . order ( ByteOrder . nativeOrder ( ) ) ; buff . rewind ( ) ; INDArray setResult = Nd4j . create ( Nd4j . createBuffer ( buff , DataBuffer . Type . FLOAT , resultLength ) ) ; JCudaExecutioner exec = ( JCudaExecutioner ) Nd4j . getExecutioner ( ) ; exec . calculateBlockResult ( ( Accumulation ) acc , setResult ) ; } else { float [ ] data = new float [ resultLength ] ; Pointer get = Pointer . to ( data ) ; JCuda . cudaMemcpyAsync ( get , devicePointer . getDevicePointer ( ) , resultLength * Sizeof . FLOAT , cudaMemcpyKind . cudaMemcpyDeviceToHost , context . getOldStream ( ) ) ; context . syncOldStream ( ) ; } } } public CudaContext getContext ( ) { return context ; } public void sync ( ) { context . syncStream ( ) ; } } 
