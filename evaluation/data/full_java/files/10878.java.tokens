package org . gradle . internal . reflect ; import org . gradle . api . Transformer ; import org . gradle . api . specs . Spec ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . util . CollectionUtils ; import java . lang . annotation . Annotation ; import java . lang . annotation . Inherited ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . * ; public class JavaReflectionUtil { public static < T > Map < String , PropertyAccessor > readableProperties ( Class < T > target ) { HashMap < String , PropertyAccessor > properties = new HashMap < String , PropertyAccessor > ( ) ; for ( Method method : target . getMethods ( ) ) { if ( method . getName ( ) . startsWith ( <str> ) & & isGetter ( method ) ) { String propertyName = method . getName ( ) . substring ( <int> ) ; propertyName = Character . toLowerCase ( propertyName . charAt ( <int> ) ) + propertyName . substring ( <int> ) ; properties . put ( propertyName , new GetterMethodBackedPropertyAccessor < T , Object > ( propertyName , Object . class , method ) ) ; } else if ( method . getName ( ) . startsWith ( <str> ) & & isBooleanGetter ( method ) ) { String propertyName = method . getName ( ) . substring ( <int> ) ; propertyName = Character . toLowerCase ( propertyName . charAt ( <int> ) ) + propertyName . substring ( <int> ) ; properties . put ( propertyName , new GetterMethodBackedPropertyAccessor < T , Object > ( propertyName , Object . class , method ) ) ; } } return properties ; } public static < T , F > PropertyAccessor < T , F > readableProperty ( Class < T > target , Class < F > returnType , String property ) throws NoSuchPropertyException { final Method getterMethod = findGetterMethod ( target , property ) ; if ( getterMethod = = null ) { throw new NoSuchPropertyException ( String . format ( <str> , property , target . getSimpleName ( ) ) ) ; } return new GetterMethodBackedPropertyAccessor < T , F > ( property , returnType , getterMethod ) ; } public static < T , F > PropertyAccessor < T , F > readableProperty ( T target , Class < F > returnType , String property ) throws NoSuchPropertyException { @SuppressWarnings ( <str> ) Class < T > targetClass = ( Class < T > ) target . getClass ( ) ; return readableProperty ( targetClass , returnType , property ) ; } public static < T , F > PropertyAccessor < T , F > readableField ( Class < T > target , Class < F > fieldType , String fieldName ) throws NoSuchPropertyException { Field field ; try { field = target . getField ( fieldName ) ; } catch ( java . lang . NoSuchFieldException e ) { throw new NoSuchPropertyException ( String . format ( <str> , fieldName , target . getSimpleName ( ) ) ) ; } return new FieldBackedPropertyAccessor < T , F > ( fieldName , fieldType , field ) ; } public static < T , F > PropertyAccessor < T , F > readableField ( T target , Class < F > fieldType , String fieldName ) throws NoSuchPropertyException { @SuppressWarnings ( <str> ) Class < T > targetClass = ( Class < T > ) target . getClass ( ) ; return readableField ( targetClass , fieldType , fieldName ) ; } private static Method findGetterMethod ( Class < ? > target , String property ) { try { Method getterMethod = target . getMethod ( toMethodName ( <str> , property ) ) ; if ( isGetter ( getterMethod ) ) { return getterMethod ; } } catch ( java . lang . NoSuchMethodException e ) { } try { Method getterMethod = target . getMethod ( toMethodName ( <str> , property ) ) ; if ( isBooleanGetter ( getterMethod ) ) { return getterMethod ; } } catch ( java . lang . NoSuchMethodException e2 ) { } return null ; } private static boolean isGetter ( Method method ) { return method . getParameterTypes ( ) . length = = <int> & & ! Modifier . isStatic ( method . getModifiers ( ) ) & & ! method . getReturnType ( ) . equals ( Void . TYPE ) ; } private static boolean isBooleanGetter ( Method method ) { Class < ? > returnType = method . getReturnType ( ) ; return method . getParameterTypes ( ) . length = = <int> & & ! Modifier . isStatic ( method . getModifiers ( ) ) & & ( returnType . equals ( Boolean . TYPE ) | | returnType . equals ( Boolean . class ) ) ; } public static PropertyMutator writeableProperty ( Class < ? > target , String property ) throws NoSuchPropertyException { String setterName = toMethodName ( <str> , property ) ; for ( final Method method : target . getMethods ( ) ) { if ( ! method . getName ( ) . equals ( setterName ) ) { continue ; } if ( method . getParameterTypes ( ) . length ! = <int> ) { continue ; } if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { continue ; } return new MethodBackedPropertyMutator ( property , method ) ; } throw new NoSuchPropertyException ( String . format ( <str> , property , target . getSimpleName ( ) ) ) ; } public static PropertyMutator writeableField ( Class < ? > target , String fieldName ) throws NoSuchPropertyException { Field field ; try { field = target . getField ( fieldName ) ; return new FieldBackedPropertyMutator ( fieldName , field ) ; } catch ( java . lang . NoSuchFieldException e ) { throw new NoSuchPropertyException ( String . format ( <str> , fieldName , target . getSimpleName ( ) ) ) ; } } private static String toMethodName ( String prefix , String propertyName ) { return prefix + Character . toUpperCase ( propertyName . charAt ( <int> ) ) + propertyName . substring ( <int> ) ; } public static Class < ? > getWrapperTypeForPrimitiveType ( Class < ? > type ) { if ( type = = Character . TYPE ) { return Character . class ; } else if ( type = = Boolean . TYPE ) { return Boolean . class ; } else if ( type = = Long . TYPE ) { return Long . class ; } else if ( type = = Integer . TYPE ) { return Integer . class ; } else if ( type = = Short . TYPE ) { return Short . class ; } else if ( type = = Byte . TYPE ) { return Byte . class ; } else if ( type = = Float . TYPE ) { return Float . class ; } else if ( type = = Double . TYPE ) { return Double . class ; } throw new IllegalArgumentException ( String . format ( <str> , type ) ) ; } public static < T , R > JavaMethod < T , R > method ( Class < T > target , Class < R > returnType , String name , Class < ? > . . . paramTypes ) throws NoSuchMethodException { return new JavaMethod < T , R > ( target , returnType , name , paramTypes ) ; } public static < T , R > JavaMethod < T , R > staticMethod ( Class < T > target , Class < R > returnType , String name , Class < ? > . . . paramTypes ) throws NoSuchMethodException { return new JavaMethod < T , R > ( target , returnType , name , true , paramTypes ) ; } public static < T , R > JavaMethod < T , R > method ( T target , Class < R > returnType , String name , Class < ? > . . . paramTypes ) throws NoSuchMethodException { @SuppressWarnings ( <str> ) Class < T > targetClass = ( Class < T > ) target . getClass ( ) ; return method ( targetClass , returnType , name , paramTypes ) ; } public static < T , R > JavaMethod < T , R > method ( Class < T > target , Class < R > returnType , Method method ) throws NoSuchMethodException { return new JavaMethod < T , R > ( target , returnType , method ) ; } public static < T , R > JavaMethod < T , R > method ( T target , Class < R > returnType , Method method ) throws NoSuchMethodException { @SuppressWarnings ( <str> ) Class < T > targetClass = ( Class < T > ) target . getClass ( ) ; return new JavaMethod < T , R > ( targetClass , returnType , method ) ; } public static void searchMethods ( Class < ? > target , final Transformer < Boolean , Method > stopIndicator ) { Spec < Method > stopIndicatorAsSpec = new Spec < Method > ( ) { public boolean isSatisfiedBy ( Method element ) { return stopIndicator . transform ( element ) ; } } ; findAllMethodsInternal ( target , stopIndicatorAsSpec , new MultiMap < String , Method > ( ) , new ArrayList < Method > ( <int> ) , true ) ; } public static Method findMethod ( Class < ? > target , Spec < Method > predicate ) { List < Method > methods = findAllMethodsInternal ( target , predicate , new MultiMap < String , Method > ( ) , new ArrayList < Method > ( <int> ) , true ) ; return methods . isEmpty ( ) ? null : methods . get ( <int> ) ; } public static List < Method > findAllMethods ( Class < ? > target , Spec < Method > predicate ) { return findAllMethodsInternal ( target , predicate , new MultiMap < String , Method > ( ) , new ArrayList < Method > ( ) , false ) ; } public static boolean propertyExists ( Object target , String propertyName ) { Class < ? > targetType = target . getClass ( ) ; Method getterMethod = findGetterMethod ( target . getClass ( ) , propertyName ) ; if ( getterMethod = = null ) { try { targetType . getField ( propertyName ) ; return true ; } catch ( NoSuchFieldException ignore ) { } } else { return true ; } return false ; } private static class MultiMap < K , V > extends HashMap < K , List < V > > { @Override public List < V > get ( Object key ) { if ( ! containsKey ( key ) ) { @SuppressWarnings ( <str> ) K keyCast = ( K ) key ; put ( keyCast , new LinkedList < V > ( ) ) ; } return super . get ( key ) ; } } private static List < Method > findAllMethodsInternal ( Class < ? > target , Spec < Method > predicate , MultiMap < String , Method > seen , List < Method > collector , boolean stopAtFirst ) { for ( final Method method : target . getDeclaredMethods ( ) ) { List < Method > seenWithName = seen . get ( method . getName ( ) ) ; Method override = CollectionUtils . findFirst ( seenWithName , new Spec < Method > ( ) { public boolean isSatisfiedBy ( Method potentionOverride ) { return potentionOverride . getName ( ) . equals ( method . getName ( ) ) & & Arrays . equals ( potentionOverride . getParameterTypes ( ) , method . getParameterTypes ( ) ) ; } } ) ; if ( override = = null ) { seenWithName . add ( method ) ; if ( predicate . isSatisfiedBy ( method ) ) { collector . add ( method ) ; if ( stopAtFirst ) { return collector ; } } } } Class < ? > parent = target . getSuperclass ( ) ; if ( parent ! = null ) { return findAllMethodsInternal ( parent , predicate , seen , collector , stopAtFirst ) ; } return collector ; } public static < A extends Annotation > A getAnnotation ( Class < ? > type , Class < A > annotationType ) { return getAnnotation ( type , annotationType , true ) ; } private static < A extends Annotation > A getAnnotation ( Class < ? > type , Class < A > annotationType , boolean checkType ) { A annotation ; if ( checkType ) { annotation = type . getAnnotation ( annotationType ) ; if ( annotation ! = null ) { return annotation ; } } if ( annotationType . getAnnotation ( Inherited . class ) ! = null ) { for ( Class < ? > anInterface : type . getInterfaces ( ) ) { annotation = getAnnotation ( anInterface , annotationType , true ) ; if ( annotation ! = null ) { return annotation ; } } } if ( type . isInterface ( ) | | type . equals ( Object . class ) ) { return null ; } else { return getAnnotation ( type . getSuperclass ( ) , annotationType , false ) ; } } public static < T > Factory < T > factory ( final Instantiator instantiator , final Class < ? extends T > type , final Object . . . args ) { return new InstantiatingFactory < T > ( instantiator , type , args ) ; } public static boolean hasDefaultToString ( Object object ) { try { return object . getClass ( ) . getMethod ( <str> ) . getDeclaringClass ( ) = = Object . class ; } catch ( java . lang . NoSuchMethodException e ) { throw new UncheckedException ( e ) ; } } private static class GetterMethodBackedPropertyAccessor < T , F > implements PropertyAccessor < T , F > { private final String property ; private final Method method ; private final Class < F > returnType ; public GetterMethodBackedPropertyAccessor ( String property , Class < F > returnType , Method method ) { this . property = property ; this . method = method ; this . returnType = returnType ; } @Override public String toString ( ) { return String . format ( <str> , method . getDeclaringClass ( ) . getSimpleName ( ) , property ) ; } public String getName ( ) { return property ; } public Class < F > getType ( ) { return returnType ; } public F getValue ( T target ) { try { return returnType . cast ( method . invoke ( target ) ) ; } catch ( InvocationTargetException e ) { throw UncheckedException . unwrapAndRethrow ( e ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } private static class FieldBackedPropertyAccessor < T , F > implements PropertyAccessor < T , F > { private final String property ; private final Field field ; private final Class < F > fieldType ; public FieldBackedPropertyAccessor ( String property , Class < F > fieldType , Field field ) { this . property = property ; this . field = field ; this . fieldType = fieldType ; } @Override public String getName ( ) { return property ; } @Override public Class < F > getType ( ) { return fieldType ; } @Override public F getValue ( T target ) { try { return fieldType . cast ( field . get ( target ) ) ; } catch ( IllegalAccessException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } private static class MethodBackedPropertyMutator implements PropertyMutator { private final String property ; private final Method method ; public MethodBackedPropertyMutator ( String property , Method method ) { this . property = property ; this . method = method ; } @Override public String toString ( ) { return String . format ( <str> , method . getDeclaringClass ( ) . getSimpleName ( ) , property ) ; } public String getName ( ) { return property ; } public Class < ? > getType ( ) { return method . getParameterTypes ( ) [ <int> ] ; } public void setValue ( Object target , Object value ) { try { method . invoke ( target , value ) ; } catch ( InvocationTargetException e ) { throw UncheckedException . unwrapAndRethrow ( e ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } private static class FieldBackedPropertyMutator implements PropertyMutator { private final String name ; private final Field field ; public FieldBackedPropertyMutator ( String name , Field field ) { this . name = name ; this . field = field ; } @Override public String toString ( ) { return String . format ( <str> , field . getDeclaringClass ( ) . getSimpleName ( ) , name ) ; } public String getName ( ) { return name ; } public Class < ? > getType ( ) { return field . getType ( ) ; } public void setValue ( Object target , Object value ) { try { field . set ( target , value ) ; } catch ( IllegalAccessException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } private static class InstantiatingFactory < T > implements Factory < T > { private final Instantiator instantiator ; private final Class < ? extends T > type ; private final Object [ ] args ; public InstantiatingFactory ( Instantiator instantiator , Class < ? extends T > type , Object . . . args ) { this . instantiator = instantiator ; this . type = type ; this . args = args ; } public T create ( ) { return instantiator . newInstance ( type , args ) ; } } } 
