package org . apache . cassandra . cql3 . selection ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . base . Objects ; import com . google . common . base . Predicate ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class Selection { private static final Predicate < ColumnDefinition > STATIC_COLUMN_FILTER = new Predicate < ColumnDefinition > ( ) { public boolean apply ( ColumnDefinition def ) { return def . isStatic ( ) ; } } ; private final CFMetaData cfm ; private final List < ColumnDefinition > columns ; private final SelectionColumnMapping columnMapping ; private final ResultSet . ResultMetadata metadata ; private final boolean collectTimestamps ; private final boolean collectTTLs ; protected Selection ( CFMetaData cfm , List < ColumnDefinition > columns , SelectionColumnMapping columnMapping , boolean collectTimestamps , boolean collectTTLs ) { this . cfm = cfm ; this . columns = columns ; this . columnMapping = columnMapping ; this . metadata = new ResultSet . ResultMetadata ( columnMapping . getColumnSpecifications ( ) ) ; this . collectTimestamps = collectTimestamps ; this . collectTTLs = collectTTLs ; } public boolean isWildcard ( ) { return false ; } public boolean containsStaticColumns ( ) { if ( ! cfm . hasStaticColumns ( ) ) return false ; if ( isWildcard ( ) ) return true ; return ! Iterables . isEmpty ( Iterables . filter ( columns , STATIC_COLUMN_FILTER ) ) ; } public boolean containsOnlyStaticColumns ( ) { if ( ! containsStaticColumns ( ) ) return false ; if ( isWildcard ( ) ) return false ; for ( ColumnDefinition def : getColumns ( ) ) { if ( ! def . isPartitionKey ( ) & & ! def . isStatic ( ) ) return false ; } return true ; } public boolean containsACollection ( ) { for ( ColumnDefinition def : getColumns ( ) ) if ( def . type . isCollection ( ) & & def . type . isMultiCell ( ) ) return true ; return false ; } public ResultSet . ResultMetadata getResultMetadata ( boolean isJson ) { if ( ! isJson ) return metadata ; ColumnSpecification firstColumn = metadata . names . get ( <int> ) ; ColumnSpecification jsonSpec = new ColumnSpecification ( firstColumn . ksName , firstColumn . cfName , Json . JSON_COLUMN_ID , UTF8Type . instance ) ; return new ResultSet . ResultMetadata ( Arrays . asList ( jsonSpec ) ) ; } public static Selection wildcard ( CFMetaData cfm ) { List < ColumnDefinition > all = new ArrayList < > ( cfm . allColumns ( ) . size ( ) ) ; Iterators . addAll ( all , cfm . allColumnsInSelectOrder ( ) ) ; return new SimpleSelection ( cfm , all , true ) ; } public static Selection forColumns ( CFMetaData cfm , List < ColumnDefinition > columns ) { return new SimpleSelection ( cfm , columns , false ) ; } public int addColumnForOrdering ( ColumnDefinition c ) { columns . add ( c ) ; metadata . addNonSerializedColumn ( c ) ; return columns . size ( ) - <int> ; } public Iterable < Function > getFunctions ( ) { return Collections . emptySet ( ) ; } private static boolean processesSelection ( List < RawSelector > rawSelectors ) { for ( RawSelector rawSelector : rawSelectors ) { if ( rawSelector . processesSelection ( ) ) return true ; } return false ; } public static Selection fromSelectors ( CFMetaData cfm , List < RawSelector > rawSelectors ) throws InvalidRequestException { List < ColumnDefinition > defs = new ArrayList < > ( ) ; SelectorFactories factories = SelectorFactories . createFactoriesAndCollectColumnDefinitions ( RawSelector . toSelectables ( rawSelectors , cfm ) , cfm , defs ) ; SelectionColumnMapping mapping = collectColumnMappings ( cfm , rawSelectors , factories ) ; return ( processesSelection ( rawSelectors ) | | rawSelectors . size ( ) ! = defs . size ( ) ) ? new SelectionWithProcessing ( cfm , defs , mapping , factories ) : new SimpleSelection ( cfm , defs , mapping , false ) ; } public int getResultSetIndex ( ColumnDefinition c ) { return getColumnIndex ( c ) ; } protected final int getColumnIndex ( ColumnDefinition c ) { for ( int i = <int> , m = columns . size ( ) ; i < m ; i + + ) if ( columns . get ( i ) . name . equals ( c . name ) ) return i ; return - <int> ; } private static SelectionColumnMapping collectColumnMappings ( CFMetaData cfm , List < RawSelector > rawSelectors , SelectorFactories factories ) { SelectionColumnMapping selectionColumns = SelectionColumnMapping . newMapping ( ) ; Iterator < RawSelector > iter = rawSelectors . iterator ( ) ; for ( Selector . Factory factory : factories ) { ColumnSpecification colSpec = factory . getColumnSpecification ( cfm ) ; ColumnIdentifier alias = iter . next ( ) . alias ; factory . addColumnMapping ( selectionColumns , alias = = null ? colSpec : colSpec . withAlias ( alias ) ) ; } return selectionColumns ; } protected abstract Selectors newSelectors ( ) throws InvalidRequestException ; public List < ColumnDefinition > getColumns ( ) { return columns ; } public SelectionColumns getColumnMapping ( ) { return columnMapping ; } public ResultSetBuilder resultSetBuilder ( boolean isJons ) throws InvalidRequestException { return new ResultSetBuilder ( isJons ) ; } public abstract boolean isAggregate ( ) ; @Override public String toString ( ) { return Objects . toStringHelper ( this ) . add ( <str> , columns ) . add ( <str> , columnMapping ) . add ( <str> , metadata ) . add ( <str> , collectTimestamps ) . add ( <str> , collectTTLs ) . toString ( ) ; } public class ResultSetBuilder { private final ResultSet resultSet ; private final Selectors selectors ; List < ByteBuffer > current ; final long [ ] timestamps ; final int [ ] ttls ; private final boolean isJson ; private ResultSetBuilder ( boolean isJson ) throws InvalidRequestException { this . resultSet = new ResultSet ( getResultMetadata ( isJson ) . copy ( ) , new ArrayList < List < ByteBuffer > > ( ) ) ; this . selectors = newSelectors ( ) ; this . timestamps = collectTimestamps ? new long [ columns . size ( ) ] : null ; this . ttls = collectTTLs ? new int [ columns . size ( ) ] : null ; this . isJson = isJson ; if ( timestamps ! = null ) Arrays . fill ( timestamps , Long . MIN_VALUE ) ; if ( ttls ! = null ) Arrays . fill ( ttls , - <int> ) ; } public void add ( ByteBuffer v ) { current . add ( v ) ; } public void add ( Cell c , int nowInSec ) { if ( c = = null ) { current . add ( null ) ; return ; } current . add ( value ( c ) ) ; if ( timestamps ! = null ) timestamps [ current . size ( ) - <int> ] = c . timestamp ( ) ; if ( ttls ! = null ) ttls [ current . size ( ) - <int> ] = remainingTTL ( c , nowInSec ) ; } private int remainingTTL ( Cell c , int nowInSec ) { if ( ! c . isExpiring ( ) ) return - <int> ; int remaining = c . localDeletionTime ( ) - nowInSec ; return remaining > = <int> ? remaining : - <int> ; } private ByteBuffer value ( Cell c ) { return c . isCounterCell ( ) ? ByteBufferUtil . bytes ( CounterContext . instance ( ) . total ( c . value ( ) ) ) : c . value ( ) ; } public void newRow ( int protocolVersion ) throws InvalidRequestException { if ( current ! = null ) { selectors . addInputRow ( protocolVersion , this ) ; if ( ! selectors . isAggregate ( ) ) { resultSet . addRow ( getOutputRow ( protocolVersion ) ) ; selectors . reset ( ) ; } } current = new ArrayList < > ( columns . size ( ) ) ; } public ResultSet build ( int protocolVersion ) throws InvalidRequestException { if ( current ! = null ) { selectors . addInputRow ( protocolVersion , this ) ; resultSet . addRow ( getOutputRow ( protocolVersion ) ) ; selectors . reset ( ) ; current = null ; } if ( resultSet . isEmpty ( ) & & selectors . isAggregate ( ) ) resultSet . addRow ( getOutputRow ( protocolVersion ) ) ; return resultSet ; } private List < ByteBuffer > getOutputRow ( int protocolVersion ) { List < ByteBuffer > outputRow = selectors . getOutputRow ( protocolVersion ) ; return isJson ? rowToJson ( outputRow , protocolVersion ) : outputRow ; } private List < ByteBuffer > rowToJson ( List < ByteBuffer > row , int protocolVersion ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < metadata . names . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; ColumnSpecification spec = metadata . names . get ( i ) ; String columnName = spec . name . toString ( ) ; if ( ! columnName . equals ( columnName . toLowerCase ( Locale . US ) ) ) columnName = <str> + columnName + <str> ; ByteBuffer buffer = row . get ( i ) ; sb . append ( <str> ) ; sb . append ( Json . JSON_STRING_ENCODER . quoteAsString ( columnName ) ) ; sb . append ( <str> ) ; if ( buffer = = null ) sb . append ( <str> ) ; else sb . append ( spec . type . toJSONString ( buffer , protocolVersion ) ) ; } sb . append ( <str> ) ; return Collections . singletonList ( UTF8Type . instance . getSerializer ( ) . serialize ( sb . toString ( ) ) ) ; } } private static interface Selectors { public boolean isAggregate ( ) ; public void addInputRow ( int protocolVersion , ResultSetBuilder rs ) throws InvalidRequestException ; public List < ByteBuffer > getOutputRow ( int protocolVersion ) throws InvalidRequestException ; public void reset ( ) ; } private static class SimpleSelection extends Selection { private final boolean isWildcard ; public SimpleSelection ( CFMetaData cfm , List < ColumnDefinition > columns , boolean isWildcard ) { this ( cfm , columns , SelectionColumnMapping . simpleMapping ( columns ) , isWildcard ) ; } public SimpleSelection ( CFMetaData cfm , List < ColumnDefinition > columns , SelectionColumnMapping metadata , boolean isWildcard ) { super ( cfm , columns , metadata , false , false ) ; this . isWildcard = isWildcard ; } @Override public boolean isWildcard ( ) { return isWildcard ; } public boolean isAggregate ( ) { return false ; } protected Selectors newSelectors ( ) { return new Selectors ( ) { private List < ByteBuffer > current ; public void reset ( ) { current = null ; } public List < ByteBuffer > getOutputRow ( int protocolVersion ) { return current ; } public void addInputRow ( int protocolVersion , ResultSetBuilder rs ) throws InvalidRequestException { current = rs . current ; } public boolean isAggregate ( ) { return false ; } } ; } } private static class SelectionWithProcessing extends Selection { private final SelectorFactories factories ; public SelectionWithProcessing ( CFMetaData cfm , List < ColumnDefinition > columns , SelectionColumnMapping metadata , SelectorFactories factories ) throws InvalidRequestException { super ( cfm , columns , metadata , factories . containsWritetimeSelectorFactory ( ) , factories . containsTTLSelectorFactory ( ) ) ; this . factories = factories ; } @Override public Iterable < Function > getFunctions ( ) { return factories . getFunctions ( ) ; } @Override public int getResultSetIndex ( ColumnDefinition c ) { int index = getColumnIndex ( c ) ; if ( index < <int> ) return - <int> ; for ( int i = <int> , m = factories . size ( ) ; i < m ; i + + ) if ( factories . get ( i ) . isSimpleSelectorFactory ( index ) ) return i ; return - <int> ; } @Override public int addColumnForOrdering ( ColumnDefinition c ) { int index = super . addColumnForOrdering ( c ) ; factories . addSelectorForOrdering ( c , index ) ; return factories . size ( ) - <int> ; } public boolean isAggregate ( ) { return factories . doesAggregation ( ) ; } protected Selectors newSelectors ( ) throws InvalidRequestException { return new Selectors ( ) { private final List < Selector > selectors = factories . newInstances ( ) ; public void reset ( ) { for ( Selector selector : selectors ) selector . reset ( ) ; } public boolean isAggregate ( ) { return factories . doesAggregation ( ) ; } public List < ByteBuffer > getOutputRow ( int protocolVersion ) throws InvalidRequestException { List < ByteBuffer > outputRow = new ArrayList < > ( selectors . size ( ) ) ; for ( Selector selector : selectors ) outputRow . add ( selector . getOutput ( protocolVersion ) ) ; return outputRow ; } public void addInputRow ( int protocolVersion , ResultSetBuilder rs ) throws InvalidRequestException { for ( Selector selector : selectors ) selector . addInput ( protocolVersion , rs ) ; } } ; } } } 
