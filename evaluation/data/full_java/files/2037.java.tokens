package org . nd4j . linalg . api . ops . impl . indexaccum ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseIndexAccumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; public class IAMax extends BaseIndexAccumulation { public IAMax ( ) { } public IAMax ( INDArray x , INDArray y , int n ) { super ( x , y , n ) ; } public IAMax ( INDArray x ) { super ( x ) ; } public IAMax ( INDArray x , INDArray y ) { super ( x , y ) ; } public int update ( double accum , int accumIdx , double x , int xIdx ) { return ( FastMath . abs ( accum ) > = FastMath . abs ( x ) ? accumIdx : xIdx ) ; } public int update ( float accum , int accumIdx , float x , int xIdx ) { return ( FastMath . abs ( accum ) > = FastMath . abs ( x ) ? accumIdx : xIdx ) ; } public int update ( double accum , int accumIdx , double x , double y , int idx ) { return ( FastMath . abs ( accum ) > = FastMath . abs ( x ) ? accumIdx : idx ) ; } public int update ( float accum , int accumIdx , float x , float y , int idx ) { return ( FastMath . abs ( accum ) > = FastMath . abs ( x ) ? accumIdx : idx ) ; } public int update ( IComplexNumber accum , int accumIdx , IComplexNumber x , int xIdx ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = x . absoluteValue ( ) . doubleValue ( ) ? accumIdx : xIdx ) ; } @Override public int update ( IComplexNumber accum , int accumIdx , double x , int idx ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = FastMath . abs ( x ) ? accumIdx : idx ) ; } @Override public int update ( IComplexNumber accum , int accumIdx , double x , double y , int idx ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = FastMath . abs ( x ) ? accumIdx : idx ) ; } public int update ( IComplexNumber accum , int accumIdx , IComplexNumber x , IComplexNumber y , int idx ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = x . absoluteValue ( ) . doubleValue ( ) ? accumIdx : idx ) ; } @Override public String name ( ) { return <str> ; } @Override public IComplexNumber op ( IComplexNumber origin , double other ) { return Nd4j . createComplexNumber ( origin . absoluteValue ( ) , <int> ) ; } @Override public IComplexNumber op ( IComplexNumber origin , float other ) { return Nd4j . createComplexNumber ( origin . absoluteValue ( ) , <int> ) ; } @Override public IComplexNumber op ( IComplexNumber origin , IComplexNumber other ) { return Nd4j . createComplexNumber ( origin . absoluteValue ( ) , <int> ) ; } @Override public float op ( float origin , float other ) { return FastMath . abs ( origin ) ; } @Override public double op ( double origin , double other ) { return FastMath . abs ( origin ) ; } @Override public double op ( double origin ) { return origin ; } @Override public float op ( float origin ) { return FastMath . abs ( origin ) ; } @Override public IComplexNumber op ( IComplexNumber origin ) { return Nd4j . createComplexNumber ( origin . absoluteValue ( ) , <int> ) ; } @Override public double zeroDouble ( ) { return <float> ; } @Override public float zeroFloat ( ) { return <float> ; } @Override public IComplexNumber zeroComplex ( ) { return Nd4j . createComplexNumber ( <int> , <int> ) ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new IAMax ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new IAMax ( x . vectorAlongDimension ( index , dimension ) ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new IAMax ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new IAMax ( x . tensorAlongDimension ( index , dimension ) ) ; } } 
