package org . eclipse . debug . internal . ui . views . breakpoints ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . Platform ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointContainer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . OtherBreakpointCategory ; import org . eclipse . debug . internal . ui . model . elements . ElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . ui . IDebugUIConstants ; public class BreakpointContainer extends ElementContentProvider implements IAdaptable , IBreakpointContainer { final private List < IBreakpoint > fBreakpoints = new ArrayList < IBreakpoint > ( ) ; final private List < BreakpointContainer > fChildContainers = new ArrayList < BreakpointContainer > ( ) ; private IAdaptable fCategory ; private IBreakpointOrganizer fOrganizer ; private IBreakpointOrganizer [ ] fNesting ; private boolean fDefaultContainer ; private BreakpointContainer fParent ; private ElementComparator fComparator ; public BreakpointContainer ( IBreakpointOrganizer [ ] organizers , ElementComparator comparator ) { fNesting = organizers ; fComparator = comparator ; } private BreakpointContainer ( BreakpointContainer parent , IAdaptable category , IBreakpointOrganizer organizer , ElementComparator comparator , IBreakpointOrganizer [ ] nesting ) { this ( category , organizer , nesting ) ; fParent = parent ; fComparator = comparator ; } BreakpointContainer ( IAdaptable category , IBreakpointOrganizer organizer , IBreakpointOrganizer [ ] nesting ) { fCategory = category ; fOrganizer = organizer ; fNesting = nesting ; } public void initDefaultContainers ( ModelDelta parentDelta ) { if ( fNesting ! = null & & fNesting . length > <int> ) { IAdaptable [ ] emptyCategories = fNesting [ <int> ] . getCategories ( ) ; if ( emptyCategories ! = null ) { for ( int i = <int> ; i < emptyCategories . length ; i + + ) { IAdaptable empty = emptyCategories [ i ] ; BreakpointContainer container = findExistingContainer ( fChildContainers , empty ) ; if ( container = = null ) { IBreakpointOrganizer [ ] siblings = new IBreakpointOrganizer [ fNesting . length - <int> ] ; System . arraycopy ( fNesting , <int> , siblings , <int> , siblings . length ) ; container = new BreakpointContainer ( this , empty , fNesting [ <int> ] , fComparator , siblings ) ; insertChildContainer ( container ) ; container . fDefaultContainer = true ; int size = container . getChildren ( ) . length ; parentDelta . addNode ( container , fChildContainers . indexOf ( container ) , IModelDelta . INSTALL | IModelDelta . ADDED | IModelDelta . EXPAND , size ) ; } } } } } private int insertBreakpoint ( IBreakpoint breakpoint ) { if ( fBreakpoints . contains ( breakpoint ) | | breakpoint = = null ) { return - <int> ; } int index = fBreakpoints . size ( ) ; for ( ; fComparator ! = null & & index > <int> ; index - - ) { if ( fComparator . compare ( fBreakpoints . get ( index - <int> ) , breakpoint ) < <int> ) { break ; } } if ( index < <int> ) { index = <int> ; } fBreakpoints . add ( index , breakpoint ) ; return index ; } private int insertChildContainer ( BreakpointContainer container ) { int index = fChildContainers . size ( ) ; for ( ; fComparator ! = null & & index > <int> ; index - - ) { if ( fComparator . compare ( fChildContainers . get ( index - <int> ) , container ) < <int> ) { break ; } } if ( index < <int> ) { index = <int> ; } fChildContainers . add ( index , container ) ; return index ; } public ElementComparator getElementComparator ( ) { return fComparator ; } public BreakpointContainer getParent ( ) { return fParent ; } private boolean hasNesting ( ) { return fNesting ! = null & & fNesting . length > <int> ; } private static IAdaptable [ ] getCategories ( IBreakpoint breakpoint , IBreakpointOrganizer organizer ) { IAdaptable [ ] categories = organizer . getCategories ( breakpoint ) ; if ( categories = = null | | categories . length = = <int> ) { categories = OtherBreakpointCategory . getCategories ( organizer ) ; } return categories ; } private static BreakpointContainer findExistingContainer ( List < BreakpointContainer > containers , IAdaptable category ) { for ( BreakpointContainer c : containers ) { if ( category . equals ( c . getCategory ( ) ) ) { return c ; } } return null ; } void addBreakpoint ( IBreakpoint breakpoint ) { addBreakpoint ( breakpoint , new ModelDelta ( null , IModelDelta . NO_CHANGE ) ) ; } public void addBreakpoint ( IBreakpoint breakpoint , ModelDelta rootDelta ) { final int bpIndex = insertBreakpoint ( breakpoint ) ; if ( bpIndex < <int> ) { return ; } if ( hasNesting ( ) ) { IBreakpointOrganizer organizer = fNesting [ <int> ] ; IAdaptable [ ] categories = getCategories ( breakpoint , organizer ) ; for ( int i = <int> ; i < categories . length ; + + i ) { ModelDelta childDelta = null ; IAdaptable category = categories [ i ] ; BreakpointContainer container = findExistingContainer ( fChildContainers , category ) ; if ( container = = null ) { IBreakpointOrganizer [ ] nesting = null ; if ( fNesting . length > <int> ) { nesting = new IBreakpointOrganizer [ fNesting . length - <int> ] ; System . arraycopy ( fNesting , <int> , nesting , <int> , nesting . length ) ; } container = new BreakpointContainer ( this , category , organizer , fComparator , nesting ) ; insertChildContainer ( container ) ; childDelta = rootDelta . addNode ( container , fChildContainers . indexOf ( container ) , IModelDelta . INSERTED | IModelDelta . INSTALL , - <int> ) ; } else { childDelta = rootDelta . addNode ( container , fChildContainers . indexOf ( container ) , IModelDelta . STATE , - <int> ) ; } container . addBreakpoint ( breakpoint , childDelta ) ; childDelta . setChildCount ( container . getChildren ( ) . length ) ; } } else { rootDelta . addNode ( breakpoint , bpIndex , IModelDelta . ADDED | IModelDelta . INSTALL , <int> ) ; rootDelta . setFlags ( rootDelta . getFlags ( ) | IModelDelta . EXPAND ) ; } } public boolean removeBreakpoint ( IBreakpoint breakpoint , ModelDelta rootDelta ) { boolean removed = fBreakpoints . remove ( breakpoint ) ; if ( removed ) { boolean addRemoveBpDelta = getContainers ( ) . length = = <int> ; Iterator < BreakpointContainer > it = fChildContainers . iterator ( ) ; while ( it . hasNext ( ) ) { BreakpointContainer container = it . next ( ) ; if ( container . contains ( breakpoint ) ) { ModelDelta childDelta = null ; if ( ( ! container . isDefaultContainer ( ) ) & & ( container . getBreakpoints ( ) . length < = <int> ) ) { it . remove ( ) ; childDelta = rootDelta . addNode ( container , IModelDelta . REMOVED | IModelDelta . UNINSTALL ) ; } else { childDelta = rootDelta . addNode ( container , IModelDelta . STATE ) ; } container . removeBreakpoint ( breakpoint , childDelta ) ; } } if ( addRemoveBpDelta ) { rootDelta . addNode ( breakpoint , IModelDelta . REMOVED | IModelDelta . UNINSTALL ) ; } } return removed ; } public static void copyOrganizers ( BreakpointContainer destContainer , BreakpointContainer sourceContainer ) { destContainer . fNesting = sourceContainer . fNesting ; destContainer . fOrganizer = sourceContainer . fOrganizer ; destContainer . fCategory = sourceContainer . fCategory ; } private static void updateSelfAndAncestorsBreakpointCache ( BreakpointContainer container , List < IBreakpoint > breakpoints , boolean add ) { if ( container ! = null ) { container . fBreakpoints . removeAll ( breakpoints ) ; if ( add ) { container . fBreakpoints . addAll ( breakpoints ) ; } updateSelfAndAncestorsBreakpointCache ( container . getParent ( ) , breakpoints , add ) ; } } static public void addBreakpoint ( BreakpointContainer destContainer , IBreakpoint breakpoint , ModelDelta destContainerDelta ) { int index = destContainer . insertBreakpoint ( breakpoint ) ; Assert . isTrue ( index > = <int> ) ; List < IBreakpoint > breakpoints = destContainer . fBreakpoints ; destContainerDelta . addNode ( breakpoint , index , IModelDelta . ADDED | IModelDelta . INSTALL , <int> ) ; destContainerDelta . setFlags ( destContainerDelta . getFlags ( ) | IModelDelta . EXPAND ) ; updateSelfAndAncestorsBreakpointCache ( destContainer . getParent ( ) , breakpoints , true ) ; } static public void addChildContainer ( BreakpointContainer destContainer , BreakpointContainer sourceContainer , ModelDelta destContainerDelta ) { destContainer . insertChildContainer ( sourceContainer ) ; sourceContainer . fParent = destContainer ; List < IBreakpoint > breakpoints = Arrays . asList ( sourceContainer . getBreakpoints ( ) ) ; updateSelfAndAncestorsBreakpointCache ( destContainer , breakpoints , true ) ; int index = destContainer . fChildContainers . indexOf ( sourceContainer ) ; int size = sourceContainer . getChildren ( ) . length ; ModelDelta childDelta = destContainerDelta . addNode ( sourceContainer , index , IModelDelta . INSERTED | IModelDelta . INSTALL | IModelDelta . EXPAND , size ) ; appendContainerDelta ( sourceContainer , childDelta ) ; } static private void appendContainerDelta ( BreakpointContainer container , ModelDelta containerDelta ) { Object [ ] children = container . getChildren ( ) ; for ( int i = <int> ; i < children . length ; + + i ) { boolean isBreakpoint = children [ <int> ] instanceof IBreakpoint ; int numChild = isBreakpoint ? <int> : children . length ; int flag = isBreakpoint ? IModelDelta . ADDED | IModelDelta . INSTALL : IModelDelta . INSERTED | IModelDelta . INSTALL | IModelDelta . EXPAND ; ModelDelta childDelta = containerDelta . addNode ( children [ i ] , i , flag , numChild ) ; if ( children [ i ] instanceof BreakpointContainer ) { BreakpointContainer childContainer = ( BreakpointContainer ) children [ i ] ; appendContainerDelta ( childContainer , childDelta ) ; } } } static public void removeBreakpoint ( BreakpointContainer container , IBreakpoint breakpoint , ModelDelta containerDelta ) { container . removeBreakpoint ( breakpoint , containerDelta ) ; List < IBreakpoint > breakpoints = new ArrayList < IBreakpoint > ( ) ; breakpoints . add ( breakpoint ) ; updateSelfAndAncestorsBreakpointCache ( container . getParent ( ) , breakpoints , false ) ; } static public void removeAll ( BreakpointContainer container , ModelDelta delta ) { BreakpointContainer parent = container . getParent ( ) ; if ( parent ! = null ) { parent . fChildContainers . remove ( container ) ; delta = delta . addNode ( container , IModelDelta . UNINSTALL | IModelDelta . REMOVED ) ; } if ( container . fChildContainers . size ( ) = = <int> ) { List < IBreakpoint > breakpoints = new ArrayList < IBreakpoint > ( ) ; Iterator < IBreakpoint > iterator = container . fBreakpoints . iterator ( ) ; while ( iterator . hasNext ( ) ) { IBreakpoint obj = iterator . next ( ) ; breakpoints . add ( obj ) ; delta . addNode ( obj , IModelDelta . UNINSTALL | IModelDelta . REMOVED ) ; iterator . remove ( ) ; } updateSelfAndAncestorsBreakpointCache ( container . getParent ( ) , breakpoints , false ) ; return ; } Iterator < BreakpointContainer > iterator = container . fChildContainers . iterator ( ) ; while ( iterator . hasNext ( ) ) { BreakpointContainer childContainer = iterator . next ( ) ; ModelDelta childDelta = delta . addNode ( childContainer , IModelDelta . REMOVED | IModelDelta . UNINSTALL ) ; iterator . remove ( ) ; removeAll ( childContainer , childDelta ) ; } } boolean isDefaultContainer ( ) { return fDefaultContainer ; } @Override public IBreakpoint [ ] getBreakpoints ( ) { return fBreakpoints . toArray ( new IBreakpoint [ fBreakpoints . size ( ) ] ) ; } @Override public IAdaptable getCategory ( ) { return fCategory ; } public Object [ ] getChildren ( ) { if ( fChildContainers . isEmpty ( ) ) { return getBreakpoints ( ) ; } return getContainers ( ) ; } public int getChildIndex ( Object child ) { if ( fChildContainers . isEmpty ( ) ) { return fBreakpoints . indexOf ( child ) ; } return fChildContainers . indexOf ( child ) ; } public BreakpointContainer [ ] getContainers ( ) { return fChildContainers . toArray ( new BreakpointContainer [ fChildContainers . size ( ) ] ) ; } @Override public IBreakpointOrganizer getOrganizer ( ) { return fOrganizer ; } @Override public boolean contains ( IBreakpoint breakpoint ) { return fBreakpoints . contains ( breakpoint ) ; } public BreakpointContainer [ ] getContainers ( IBreakpoint breakpoint ) { if ( contains ( breakpoint ) ) { BreakpointContainer [ ] containers = getContainers ( ) ; if ( containers . length = = <int> ) { return new BreakpointContainer [ ] { this } ; } ArrayList < BreakpointContainer > list = new ArrayList < BreakpointContainer > ( ) ; for ( int i = <int> ; i < containers . length ; i + + ) { BreakpointContainer container = containers [ i ] ; BreakpointContainer [ ] subcontainers = container . getContainers ( breakpoint ) ; if ( subcontainers ! = null ) { for ( int j = <int> ; j < subcontainers . length ; j + + ) { list . add ( subcontainers [ j ] ) ; } } } return list . toArray ( new BreakpointContainer [ list . size ( ) ] ) ; } return new BreakpointContainer [ <int> ] ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof BreakpointContainer ) { BreakpointContainer container = ( BreakpointContainer ) obj ; if ( ! ( fParent ! = null & & container . fParent ! = null & & fParent . equals ( container . fParent ) | | fParent = = null & & container . fParent = = null ) ) { return false ; } if ( getCategory ( ) ! = null & & container . getCategory ( ) ! = null ) { return getCategory ( ) . equals ( container . getCategory ( ) ) ; } else { return true ; } } return super . equals ( obj ) ; } @Override protected int getChildCount ( Object element , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { return getChildren ( ) . length ; } @Override protected Object [ ] getChildren ( Object parent , int index , int length , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { return getElements ( getChildren ( ) , index , length ) ; } @Override protected boolean supportsContextId ( String id ) { return id . equals ( IDebugUIConstants . ID_BREAKPOINT_VIEW ) ; } @Override public < T > T getAdapter ( Class < T > adapter ) { return Platform . getAdapterManager ( ) . getAdapter ( this , adapter ) ; } } 
