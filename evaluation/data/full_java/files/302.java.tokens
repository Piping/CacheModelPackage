package org . apache . cassandra . db ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . ReadRepairDecision ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . exceptions . UnavailableException ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . locator . NetworkTopologyStrategy ; import org . apache . cassandra . transport . ProtocolException ; public enum ConsistencyLevel { ANY ( <int> ) , ONE ( <int> ) , TWO ( <int> ) , THREE ( <int> ) , QUORUM ( <int> ) , ALL ( <int> ) , LOCAL_QUORUM ( <int> , true ) , EACH_QUORUM ( <int> ) , SERIAL ( <int> ) , LOCAL_SERIAL ( <int> ) , LOCAL_ONE ( <int> , true ) ; private static final Logger logger = LoggerFactory . getLogger ( ConsistencyLevel . class ) ; public final int code ; private final boolean isDCLocal ; private static final ConsistencyLevel [ ] codeIdx ; static { int maxCode = - <int> ; for ( ConsistencyLevel cl : ConsistencyLevel . values ( ) ) maxCode = Math . max ( maxCode , cl . code ) ; codeIdx = new ConsistencyLevel [ maxCode + <int> ] ; for ( ConsistencyLevel cl : ConsistencyLevel . values ( ) ) { if ( codeIdx [ cl . code ] ! = null ) throw new IllegalStateException ( <str> ) ; codeIdx [ cl . code ] = cl ; } } private ConsistencyLevel ( int code ) { this ( code , false ) ; } private ConsistencyLevel ( int code , boolean isDCLocal ) { this . code = code ; this . isDCLocal = isDCLocal ; } public static ConsistencyLevel fromCode ( int code ) { if ( code < <int> | | code > = codeIdx . length ) throw new ProtocolException ( String . format ( <str> , code ) ) ; return codeIdx [ code ] ; } private int quorumFor ( Keyspace keyspace ) { return ( keyspace . getReplicationStrategy ( ) . getReplicationFactor ( ) / <int> ) + <int> ; } private int localQuorumFor ( Keyspace keyspace , String dc ) { return ( keyspace . getReplicationStrategy ( ) instanceof NetworkTopologyStrategy ) ? ( ( ( NetworkTopologyStrategy ) keyspace . getReplicationStrategy ( ) ) . getReplicationFactor ( dc ) / <int> ) + <int> : quorumFor ( keyspace ) ; } public int blockFor ( Keyspace keyspace ) { switch ( this ) { case ONE : case LOCAL_ONE : return <int> ; case ANY : return <int> ; case TWO : return <int> ; case THREE : return <int> ; case QUORUM : case SERIAL : return quorumFor ( keyspace ) ; case ALL : return keyspace . getReplicationStrategy ( ) . getReplicationFactor ( ) ; case LOCAL_QUORUM : case LOCAL_SERIAL : return localQuorumFor ( keyspace , DatabaseDescriptor . getLocalDataCenter ( ) ) ; case EACH_QUORUM : if ( keyspace . getReplicationStrategy ( ) instanceof NetworkTopologyStrategy ) { NetworkTopologyStrategy strategy = ( NetworkTopologyStrategy ) keyspace . getReplicationStrategy ( ) ; int n = <int> ; for ( String dc : strategy . getDatacenters ( ) ) n + = localQuorumFor ( keyspace , dc ) ; return n ; } else { return quorumFor ( keyspace ) ; } default : throw new UnsupportedOperationException ( <str> + toString ( ) ) ; } } public boolean isDatacenterLocal ( ) { return isDCLocal ; } public boolean isLocal ( InetAddress endpoint ) { return DatabaseDescriptor . getLocalDataCenter ( ) . equals ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( endpoint ) ) ; } public int countLocalEndpoints ( Iterable < InetAddress > liveEndpoints ) { int count = <int> ; for ( InetAddress endpoint : liveEndpoints ) if ( isLocal ( endpoint ) ) count + + ; return count ; } private Map < String , Integer > countPerDCEndpoints ( Keyspace keyspace , Iterable < InetAddress > liveEndpoints ) { NetworkTopologyStrategy strategy = ( NetworkTopologyStrategy ) keyspace . getReplicationStrategy ( ) ; Map < String , Integer > dcEndpoints = new HashMap < String , Integer > ( ) ; for ( String dc : strategy . getDatacenters ( ) ) dcEndpoints . put ( dc , <int> ) ; for ( InetAddress endpoint : liveEndpoints ) { String dc = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( endpoint ) ; dcEndpoints . put ( dc , dcEndpoints . get ( dc ) + <int> ) ; } return dcEndpoints ; } public List < InetAddress > filterForQuery ( Keyspace keyspace , List < InetAddress > liveEndpoints ) { return filterForQuery ( keyspace , liveEndpoints , ReadRepairDecision . NONE ) ; } public List < InetAddress > filterForQuery ( Keyspace keyspace , List < InetAddress > liveEndpoints , ReadRepairDecision readRepair ) { if ( this = = EACH_QUORUM & & keyspace . getReplicationStrategy ( ) instanceof NetworkTopologyStrategy ) return filterForEachQuorum ( keyspace , liveEndpoints , readRepair ) ; if ( isDCLocal ) Collections . sort ( liveEndpoints , DatabaseDescriptor . getLocalComparator ( ) ) ; switch ( readRepair ) { case NONE : return liveEndpoints . subList ( <int> , Math . min ( liveEndpoints . size ( ) , blockFor ( keyspace ) ) ) ; case GLOBAL : return liveEndpoints ; case DC_LOCAL : List < InetAddress > local = new ArrayList < InetAddress > ( ) ; List < InetAddress > other = new ArrayList < InetAddress > ( ) ; for ( InetAddress add : liveEndpoints ) { if ( isLocal ( add ) ) local . add ( add ) ; else other . add ( add ) ; } int blockFor = blockFor ( keyspace ) ; if ( local . size ( ) < blockFor ) local . addAll ( other . subList ( <int> , Math . min ( blockFor - local . size ( ) , other . size ( ) ) ) ) ; return local ; default : throw new AssertionError ( ) ; } } private List < InetAddress > filterForEachQuorum ( Keyspace keyspace , List < InetAddress > liveEndpoints , ReadRepairDecision readRepair ) { NetworkTopologyStrategy strategy = ( NetworkTopologyStrategy ) keyspace . getReplicationStrategy ( ) ; if ( readRepair = = ReadRepairDecision . GLOBAL ) return liveEndpoints ; Map < String , List < InetAddress > > dcsEndpoints = new HashMap < > ( ) ; for ( String dc : strategy . getDatacenters ( ) ) dcsEndpoints . put ( dc , new ArrayList < > ( ) ) ; for ( InetAddress add : liveEndpoints ) { String dc = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( add ) ; dcsEndpoints . get ( dc ) . add ( add ) ; } List < InetAddress > waitSet = new ArrayList < > ( ) ; for ( Map . Entry < String , List < InetAddress > > dcEndpoints : dcsEndpoints . entrySet ( ) ) { List < InetAddress > dcEndpoint = dcEndpoints . getValue ( ) ; if ( readRepair = = ReadRepairDecision . DC_LOCAL & & dcEndpoints . getKey ( ) . equals ( DatabaseDescriptor . getLocalDataCenter ( ) ) ) waitSet . addAll ( dcEndpoint ) ; else waitSet . addAll ( dcEndpoint . subList ( <int> , Math . min ( localQuorumFor ( keyspace , dcEndpoints . getKey ( ) ) , dcEndpoint . size ( ) ) ) ) ; } return waitSet ; } public boolean isSufficientLiveNodes ( Keyspace keyspace , Iterable < InetAddress > liveEndpoints ) { switch ( this ) { case ANY : return true ; case LOCAL_ONE : return countLocalEndpoints ( liveEndpoints ) > = <int> ; case LOCAL_QUORUM : return countLocalEndpoints ( liveEndpoints ) > = blockFor ( keyspace ) ; case EACH_QUORUM : if ( keyspace . getReplicationStrategy ( ) instanceof NetworkTopologyStrategy ) { for ( Map . Entry < String , Integer > entry : countPerDCEndpoints ( keyspace , liveEndpoints ) . entrySet ( ) ) { if ( entry . getValue ( ) < localQuorumFor ( keyspace , entry . getKey ( ) ) ) return false ; } return true ; } default : return Iterables . size ( liveEndpoints ) > = blockFor ( keyspace ) ; } } public void assureSufficientLiveNodes ( Keyspace keyspace , Iterable < InetAddress > liveEndpoints ) throws UnavailableException { int blockFor = blockFor ( keyspace ) ; switch ( this ) { case ANY : break ; case LOCAL_ONE : if ( countLocalEndpoints ( liveEndpoints ) = = <int> ) throw new UnavailableException ( this , <int> , <int> ) ; break ; case LOCAL_QUORUM : int localLive = countLocalEndpoints ( liveEndpoints ) ; if ( localLive < blockFor ) { if ( logger . isTraceEnabled ( ) ) { StringBuilder builder = new StringBuilder ( <str> ) ; for ( InetAddress endpoint : liveEndpoints ) { if ( isLocal ( endpoint ) ) builder . append ( endpoint ) . append ( <str> ) ; } builder . append ( <str> ) . append ( blockFor ) . append ( <str> ) . append ( DatabaseDescriptor . getLocalDataCenter ( ) ) . append ( <str> ) ; logger . trace ( builder . toString ( ) ) ; } throw new UnavailableException ( this , blockFor , localLive ) ; } break ; case EACH_QUORUM : if ( keyspace . getReplicationStrategy ( ) instanceof NetworkTopologyStrategy ) { for ( Map . Entry < String , Integer > entry : countPerDCEndpoints ( keyspace , liveEndpoints ) . entrySet ( ) ) { int dcBlockFor = localQuorumFor ( keyspace , entry . getKey ( ) ) ; int dcLive = entry . getValue ( ) ; if ( dcLive < dcBlockFor ) throw new UnavailableException ( this , entry . getKey ( ) , dcBlockFor , dcLive ) ; } break ; } default : int live = Iterables . size ( liveEndpoints ) ; if ( live < blockFor ) { logger . trace ( <str> , Iterables . toString ( liveEndpoints ) , blockFor ) ; throw new UnavailableException ( this , blockFor , live ) ; } break ; } } public void validateForRead ( String keyspaceName ) throws InvalidRequestException { switch ( this ) { case ANY : throw new InvalidRequestException ( <str> ) ; } } public void validateForWrite ( String keyspaceName ) throws InvalidRequestException { switch ( this ) { case SERIAL : case LOCAL_SERIAL : throw new InvalidRequestException ( <str> ) ; } } public void validateForCasCommit ( String keyspaceName ) throws InvalidRequestException { switch ( this ) { case EACH_QUORUM : requireNetworkTopologyStrategy ( keyspaceName ) ; break ; case SERIAL : case LOCAL_SERIAL : throw new InvalidRequestException ( this + <str> ) ; } } public void validateForCas ( ) throws InvalidRequestException { if ( ! isSerialConsistency ( ) ) throw new InvalidRequestException ( <str> ) ; } public boolean isSerialConsistency ( ) { return this = = SERIAL | | this = = LOCAL_SERIAL ; } public void validateCounterForWrite ( CFMetaData metadata ) throws InvalidRequestException { if ( this = = ConsistencyLevel . ANY ) throw new InvalidRequestException ( <str> + metadata . cfName ) ; if ( isSerialConsistency ( ) ) throw new InvalidRequestException ( <str> ) ; } private void requireNetworkTopologyStrategy ( String keyspaceName ) throws InvalidRequestException { AbstractReplicationStrategy strategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; if ( ! ( strategy instanceof NetworkTopologyStrategy ) ) throw new InvalidRequestException ( String . format ( <str> , this , strategy . getClass ( ) . getName ( ) ) ) ; } } 
