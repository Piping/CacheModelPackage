package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . base . Function ; import com . google . common . collect . Multiset . Entry ; import com . google . common . collect . testing . ListTestSuiteBuilder ; import com . google . common . collect . testing . MinimalCollection ; import com . google . common . collect . testing . TestStringListGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . google . SortedMultisetTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringMultisetGenerator ; import com . google . common . collect . testing . google . UnmodifiableCollectionTests ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . easymock . EasyMock ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; public class ImmutableSortedMultisetTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableSortedMultisetTest . class ) ; suite . addTest ( SortedMultisetTestSuiteBuilder . using ( new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { return ImmutableSortedMultiset . copyOf ( elements ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { return ImmutableSortedMultiset . copyOf ( elements ) . asList ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { Set < String > set = Sets . newHashSet ( ) ; ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; for ( String s : elements ) { checkArgument ( set . add ( s ) ) ; builder . addCopies ( s , <int> ) ; } return builder . build ( ) . elementSet ( ) . asList ( ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } public void testCreation_noArgs ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( ) ; assertTrue ( multiset . isEmpty ( ) ) ; } public void testCreation_oneElement ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> ) ) , multiset ) ; } public void testCreation_twoElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> ) ) , multiset ) ; } public void testCreation_threeElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> ) ) , multiset ) ; } public void testCreation_fourElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testCreation_fiveElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testCreation_sixElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testCreation_sevenElements ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testCreation_emptyArray ( ) { String [ ] array = new String [ <int> ] ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( array ) ; assertTrue ( multiset . isEmpty ( ) ) ; } public void testCreation_arrayOfOneElement ( ) { String [ ] array = new String [ ] { <str> } ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( array ) ; assertEquals ( HashMultiset . create ( asList ( <str> ) ) , multiset ) ; } public void testCreation_arrayOfArray ( ) { Comparator < String [ ] > comparator = Ordering . natural ( ) . lexicographical ( ) . onResultOf ( new Function < String [ ] , Iterable < Comparable > > ( ) { @Override public Iterable < Comparable > apply ( String [ ] input ) { return Arrays . < Comparable > asList ( input ) ; } } ) ; String [ ] array = new String [ ] { <str> } ; Multiset < String [ ] > multiset = ImmutableSortedMultiset . orderedBy ( comparator ) . add ( array ) . build ( ) ; Multiset < String [ ] > expected = HashMultiset . create ( ) ; expected . add ( array ) ; assertEquals ( expected , multiset ) ; } public void testCreation_arrayContainingOnlyNull ( ) { String [ ] array = new String [ ] { null } ; try { ImmutableSortedMultiset . copyOf ( array ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCopyOf_collection_empty ( ) { Collection < String > c = MinimalCollection . < String > of ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertTrue ( multiset . isEmpty ( ) ) ; } public void testCopyOf_collection_oneElement ( ) { Collection < String > c = MinimalCollection . of ( <str> ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertEquals ( HashMultiset . create ( asList ( <str> ) ) , multiset ) ; } public void testCopyOf_collection_general ( ) { Collection < String > c = MinimalCollection . of ( <str> , <str> , <str> ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> ) ) , multiset ) ; } public void testCopyOf_collectionContainingNull ( ) { Collection < String > c = MinimalCollection . of ( <str> , null , <str> ) ; try { ImmutableSortedMultiset . copyOf ( c ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCopyOf_multiset_empty ( ) { Multiset < String > c = HashMultiset . create ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertTrue ( multiset . isEmpty ( ) ) ; } public void testCopyOf_multiset_oneElement ( ) { Multiset < String > c = HashMultiset . create ( asList ( <str> ) ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertEquals ( HashMultiset . create ( asList ( <str> ) ) , multiset ) ; } public void testCopyOf_multiset_general ( ) { Multiset < String > c = HashMultiset . create ( asList ( <str> , <str> , <str> ) ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( c ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> ) ) , multiset ) ; } public void testCopyOf_multisetContainingNull ( ) { Multiset < String > c = HashMultiset . create ( asList ( <str> , null , <str> ) ) ; try { ImmutableSortedMultiset . copyOf ( c ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testCopyOf_iterator_empty ( ) { Iterator < String > iterator = Iterators . emptyIterator ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( iterator ) ; assertTrue ( multiset . isEmpty ( ) ) ; } public void testCopyOf_iterator_oneElement ( ) { Iterator < String > iterator = Iterators . singletonIterator ( <str> ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( iterator ) ; assertEquals ( HashMultiset . create ( asList ( <str> ) ) , multiset ) ; } public void testCopyOf_iterator_general ( ) { Iterator < String > iterator = asList ( <str> , <str> , <str> ) . iterator ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( iterator ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> ) ) , multiset ) ; } public void testCopyOf_iteratorContainingNull ( ) { Iterator < String > iterator = asList ( <str> , null , <str> ) . iterator ( ) ; try { ImmutableSortedMultiset . copyOf ( iterator ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } private static class CountingIterable implements Iterable < String > { int count = <int> ; @Override public Iterator < String > iterator ( ) { count + + ; return asList ( <str> , <str> , <str> ) . iterator ( ) ; } } public void testCopyOf_plainIterable ( ) { CountingIterable iterable = new CountingIterable ( ) ; Multiset < String > multiset = ImmutableSortedMultiset . copyOf ( iterable ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> ) ) , multiset ) ; assertEquals ( <int> , iterable . count ) ; } public void testCopyOf_shortcut_empty ( ) { Collection < String > c = ImmutableSortedMultiset . of ( ) ; assertSame ( c , ImmutableSortedMultiset . copyOf ( c ) ) ; } public void testCopyOf_shortcut_singleton ( ) { Collection < String > c = ImmutableSortedMultiset . of ( <str> ) ; assertSame ( c , ImmutableSortedMultiset . copyOf ( c ) ) ; } public void testCopyOf_shortcut_immutableMultiset ( ) { Collection < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; assertSame ( c , ImmutableSortedMultiset . copyOf ( c ) ) ; } public void testBuilderAdd ( ) { ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . add ( <str> ) . add ( <str> ) . add ( <str> ) . add ( <str> ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderAddAll ( ) { List < String > a = asList ( <str> , <str> ) ; List < String > b = asList ( <str> , <str> ) ; ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . addAll ( a ) . addAll ( b ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderAddAllMultiset ( ) { Multiset < String > a = HashMultiset . create ( asList ( <str> , <str> , <str> ) ) ; Multiset < String > b = HashMultiset . create ( asList ( <str> , <str> ) ) ; ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . addAll ( a ) . addAll ( b ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderAddAllIterator ( ) { Iterator < String > iterator = asList ( <str> , <str> , <str> , <str> ) . iterator ( ) ; ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . addAll ( iterator ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderAddCopies ( ) { ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . addCopies ( <str> , <int> ) . addCopies ( <str> , <int> ) . addCopies ( <str> , <int> ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderSetCount ( ) { ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . < String > naturalOrder ( ) . add ( <str> ) . setCount ( <str> , <int> ) . setCount ( <str> , <int> ) . build ( ) ; assertEquals ( HashMultiset . create ( asList ( <str> , <str> , <str> , <str> , <str> ) ) , multiset ) ; } public void testBuilderAddHandlesNullsCorrectly ( ) { ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; try { builder . add ( ( String ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBuilderAddAllHandlesNullsCorrectly ( ) { ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; try { builder . addAll ( ( Collection < String > ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } builder = ImmutableSortedMultiset . naturalOrder ( ) ; List < String > listWithNulls = asList ( <str> , null , <str> ) ; try { builder . addAll ( listWithNulls ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } builder = ImmutableSortedMultiset . naturalOrder ( ) ; Multiset < String > multisetWithNull = LinkedHashMultiset . create ( asList ( <str> , null , <str> ) ) ; try { builder . addAll ( multisetWithNull ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBuilderAddCopiesHandlesNullsCorrectly ( ) { ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; try { builder . addCopies ( null , <int> ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBuilderAddCopiesIllegal ( ) { ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; try { builder . addCopies ( <str> , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testBuilderSetCountHandlesNullsCorrectly ( ) { ImmutableSortedMultiset . Builder < String > builder = new ImmutableSortedMultiset . Builder < String > ( Ordering . natural ( ) . nullsFirst ( ) ) ; try { builder . setCount ( null , <int> ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBuilderSetCountIllegal ( ) { ImmutableSortedMultiset . Builder < String > builder = ImmutableSortedMultiset . naturalOrder ( ) ; try { builder . setCount ( <str> , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testNullPointers ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( ImmutableSortedMultiset . class ) ; } public void testSerialization_empty ( ) { Collection < String > c = ImmutableSortedMultiset . of ( ) ; assertSame ( c , SerializableTester . reserialize ( c ) ) ; } public void testSerialization_multiple ( ) { Collection < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; Collection < String > copy = SerializableTester . reserializeAndAssert ( c ) ; assertThat ( copy ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testSerialization_elementSet ( ) { Multiset < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; Collection < String > copy = SerializableTester . reserializeAndAssert ( c . elementSet ( ) ) ; assertThat ( copy ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testSerialization_entrySet ( ) { Multiset < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; SerializableTester . reserializeAndAssert ( c . entrySet ( ) ) ; } public void testEquals_immutableMultiset ( ) { Collection < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; assertEquals ( c , ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ) ; assertEquals ( c , ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ) ; assertThat ( c ) . isNotEqualTo ( ImmutableSortedMultiset . of ( <str> , <str> ) ) ; assertThat ( c ) . isNotEqualTo ( ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> ) ) ; } public void testIterationOrder ( ) { Collection < String > c = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; assertThat ( c ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testMultisetWrites ( ) { Multiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> ) ; UnmodifiableCollectionTests . assertMultisetIsUnmodifiable ( multiset , <str> ) ; } public void testAsList ( ) { ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . of ( <str> , <str> , <str> , <str> , <str> ) ; ImmutableList < String > list = multiset . asList ( ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> , <str> ) , list ) ; assertTrue ( list instanceof ImmutableAsList ) ; ImmutableList < String > copy = SerializableTester . reserializeAndAssert ( list ) ; assertTrue ( copy instanceof ImmutableAsList ) ; assertEquals ( <int> , list . indexOf ( <str> ) ) ; assertEquals ( <int> , list . lastIndexOf ( <str> ) ) ; } public void testCopyOfDefensiveCopy ( ) { class TestArrayList < E > extends ArrayList < E > { boolean toArrayCalled = false ; @Override public Object [ ] toArray ( ) { toArrayCalled = true ; return super . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] a ) { toArrayCalled = true ; return super . toArray ( a ) ; } } TestArrayList < String > toCopy = new TestArrayList < String > ( ) ; ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . copyOf ( Ordering . natural ( ) , toCopy ) ; assertTrue ( toCopy . toArrayCalled ) ; } @SuppressWarnings ( <str> ) public void testCopyOfSortedDefensiveCopy ( ) { class TestHashSet < E > extends HashSet < E > { boolean toArrayCalled = false ; @Override public Object [ ] toArray ( ) { toArrayCalled = true ; return super . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] a ) { toArrayCalled = true ; return super . toArray ( a ) ; } } SortedMultiset < String > toCopy = EasyMock . createMock ( SortedMultiset . class ) ; TestHashSet < Entry < String > > entrySet = new TestHashSet < Entry < String > > ( ) ; EasyMock . expect ( ( Comparator < Comparable > ) toCopy . comparator ( ) ) . andReturn ( Ordering . natural ( ) ) ; EasyMock . expect ( toCopy . entrySet ( ) ) . andReturn ( entrySet ) ; EasyMock . replay ( toCopy ) ; ImmutableSortedMultiset < String > multiset = ImmutableSortedMultiset . copyOfSorted ( toCopy ) ; EasyMock . verify ( toCopy ) ; assertTrue ( entrySet . toArrayCalled ) ; } private static class IntegerDiv10 implements Comparable < IntegerDiv10 > { final int value ; IntegerDiv10 ( int value ) { this . value = value ; } @Override public int compareTo ( IntegerDiv10 o ) { return value / <int> - o . value / <int> ; } @Override public String toString ( ) { return Integer . toString ( value ) ; } } public void testCopyOfDuplicateInconsistentWithEquals ( ) { IntegerDiv10 three = new IntegerDiv10 ( <int> ) ; IntegerDiv10 eleven = new IntegerDiv10 ( <int> ) ; IntegerDiv10 twelve = new IntegerDiv10 ( <int> ) ; IntegerDiv10 twenty = new IntegerDiv10 ( <int> ) ; List < IntegerDiv10 > original = ImmutableList . of ( three , eleven , twelve , twenty ) ; Multiset < IntegerDiv10 > copy = ImmutableSortedMultiset . copyOf ( original ) ; assertTrue ( copy . contains ( eleven ) ) ; assertTrue ( copy . contains ( twelve ) ) ; } } 
