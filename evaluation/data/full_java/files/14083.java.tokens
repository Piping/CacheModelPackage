package org . gradle . internal . serialize ; import java . util . * ; public class DefaultSerializerRegistry < T > implements SerializerRegistry < T > { private final Map < Class < ? > , Serializer < ? > > serializerMap = new TreeMap < Class < ? > , Serializer < ? > > ( new Comparator < Class < ? > > ( ) { public int compare ( Class < ? > o1 , Class < ? > o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ; private final Set < Class < ? > > javaSerialization = new HashSet < Class < ? > > ( ) ; public < U extends T > void register ( Class < U > implementationType , Serializer < U > serializer ) { serializerMap . put ( implementationType , serializer ) ; } @Override public < U extends T > void useJavaSerialization ( Class < U > implementationType ) { javaSerialization . add ( implementationType ) ; } public Serializer < T > build ( ) { if ( serializerMap . size ( ) = = <int> & & javaSerialization . isEmpty ( ) ) { return ( Serializer < T > ) serializerMap . values ( ) . iterator ( ) . next ( ) ; } return new TaggedTypeSerializer < T > ( serializerMap , javaSerialization ) ; } private static class TypeInfo { final int tag ; final Serializer serializer ; private TypeInfo ( int tag , Serializer serializer ) { this . tag = tag ; this . serializer = serializer ; } } private static class TaggedTypeSerializer < T > implements Serializer < T > { private static final int JAVA_TYPE = <int> ; private static final TypeInfo JAVA_SERIALIZATION = new TypeInfo ( JAVA_TYPE , new DefaultSerializer < Object > ( ) ) ; private final Map < Class < ? > , TypeInfo > serializersByType = new HashMap < Class < ? > , TypeInfo > ( ) ; private final TypeInfo [ ] serializersByTag ; private final Set < Class < ? > > javaSerialization ; public TaggedTypeSerializer ( Map < Class < ? > , Serializer < ? > > serializerMap , Set < Class < ? > > javaSerialization ) { this . javaSerialization = new HashSet < Class < ? > > ( javaSerialization ) ; serializersByTag = new TypeInfo [ <int> + serializerMap . size ( ) ] ; serializersByTag [ JAVA_TYPE ] = JAVA_SERIALIZATION ; int nextTag = <int> ; for ( Map . Entry < Class < ? > , Serializer < ? > > entry : serializerMap . entrySet ( ) ) { add ( nextTag , entry . getKey ( ) , entry . getValue ( ) ) ; nextTag + + ; } } private void add ( int tag , Class < ? > type , Serializer < ? > serializer ) { TypeInfo typeInfo = new TypeInfo ( tag , serializer ) ; serializersByType . put ( type , typeInfo ) ; serializersByTag [ typeInfo . tag ] = typeInfo ; } public T read ( Decoder decoder ) throws Exception { int tag = decoder . readSmallInt ( ) ; TypeInfo typeInfo = tag > = serializersByTag . length ? null : serializersByTag [ tag ] ; if ( typeInfo = = null ) { throw new IllegalArgumentException ( String . format ( <str> , tag ) ) ; } return ( T ) typeInfo . serializer . read ( decoder ) ; } public void write ( Encoder encoder , T value ) throws Exception { TypeInfo typeInfo = map ( value . getClass ( ) ) ; encoder . writeSmallInt ( typeInfo . tag ) ; typeInfo . serializer . write ( encoder , value ) ; } private TypeInfo map ( Class < ? > valueType ) { Class < ? > targetType = Throwable . class . isAssignableFrom ( valueType ) ? Throwable . class : valueType ; TypeInfo typeInfo = serializersByType . get ( targetType ) ; if ( typeInfo ! = null ) { return typeInfo ; } for ( Class < ? > candidate : javaSerialization ) { if ( candidate . isAssignableFrom ( targetType ) ) { return JAVA_SERIALIZATION ; } } throw new IllegalArgumentException ( String . format ( <str> , valueType . getName ( ) ) ) ; } } } 
