package org . elasticsearch . action . admin . cluster . reroute ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeAction ; import org . elasticsearch . cluster . AckedClusterStateUpdateTask ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingExplanations ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; public class TransportClusterRerouteAction extends TransportMasterNodeAction < ClusterRerouteRequest , ClusterRerouteResponse > { private final AllocationService allocationService ; @Inject public TransportClusterRerouteAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , AllocationService allocationService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , ClusterRerouteAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , ClusterRerouteRequest : : new ) ; this . allocationService = allocationService ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected ClusterBlockException checkBlock ( ClusterRerouteRequest request , ClusterState state ) { return state . blocks ( ) . globalBlockedException ( ClusterBlockLevel . METADATA_WRITE ) ; } @Override protected ClusterRerouteResponse newResponse ( ) { return new ClusterRerouteResponse ( ) ; } @Override protected void masterOperation ( final ClusterRerouteRequest request , final ClusterState state , final ActionListener < ClusterRerouteResponse > listener ) { clusterService . submitStateUpdateTask ( <str> , new AckedClusterStateUpdateTask < ClusterRerouteResponse > ( Priority . IMMEDIATE , request , listener ) { private volatile ClusterState clusterStateToSend ; private volatile RoutingExplanations explanations ; @Override protected ClusterRerouteResponse newResponse ( boolean acknowledged ) { return new ClusterRerouteResponse ( acknowledged , clusterStateToSend , explanations ) ; } @Override public void onAckTimeout ( ) { listener . onResponse ( new ClusterRerouteResponse ( false , clusterStateToSend , new RoutingExplanations ( ) ) ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . debug ( <str> , t , source ) ; super . onFailure ( source , t ) ; } @Override public ClusterState execute ( ClusterState currentState ) { RoutingAllocation . Result routingResult = allocationService . reroute ( currentState , request . commands , request . explain ( ) ) ; ClusterState newState = ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; clusterStateToSend = newState ; explanations = routingResult . explanations ( ) ; if ( request . dryRun ) { return currentState ; } return newState ; } } ) ; } } 
