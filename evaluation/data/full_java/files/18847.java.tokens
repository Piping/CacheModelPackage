package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . serialization . ObjectDecoder ; import java . nio . ByteOrder ; import java . util . List ; public class LengthFieldBasedFrameDecoder extends ByteToMessageDecoder { private final ByteOrder byteOrder ; private final int maxFrameLength ; private final int lengthFieldOffset ; private final int lengthFieldLength ; private final int lengthFieldEndOffset ; private final int lengthAdjustment ; private final int initialBytesToStrip ; private final boolean failFast ; private boolean discardingTooLongFrame ; private long tooLongFrameLength ; private long bytesToDiscard ; public LengthFieldBasedFrameDecoder ( int maxFrameLength , int lengthFieldOffset , int lengthFieldLength ) { this ( maxFrameLength , lengthFieldOffset , lengthFieldLength , <int> , <int> ) ; } public LengthFieldBasedFrameDecoder ( int maxFrameLength , int lengthFieldOffset , int lengthFieldLength , int lengthAdjustment , int initialBytesToStrip ) { this ( maxFrameLength , lengthFieldOffset , lengthFieldLength , lengthAdjustment , initialBytesToStrip , true ) ; } public LengthFieldBasedFrameDecoder ( int maxFrameLength , int lengthFieldOffset , int lengthFieldLength , int lengthAdjustment , int initialBytesToStrip , boolean failFast ) { this ( ByteOrder . BIG_ENDIAN , maxFrameLength , lengthFieldOffset , lengthFieldLength , lengthAdjustment , initialBytesToStrip , failFast ) ; } public LengthFieldBasedFrameDecoder ( ByteOrder byteOrder , int maxFrameLength , int lengthFieldOffset , int lengthFieldLength , int lengthAdjustment , int initialBytesToStrip , boolean failFast ) { if ( byteOrder = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxFrameLength < = <int> ) { throw new IllegalArgumentException ( <str> + maxFrameLength ) ; } if ( lengthFieldOffset < <int> ) { throw new IllegalArgumentException ( <str> + lengthFieldOffset ) ; } if ( initialBytesToStrip < <int> ) { throw new IllegalArgumentException ( <str> + initialBytesToStrip ) ; } if ( lengthFieldOffset > maxFrameLength - lengthFieldLength ) { throw new IllegalArgumentException ( <str> + maxFrameLength + <str> + <str> + <str> + lengthFieldOffset + <str> + <str> + lengthFieldLength + <str> ) ; } this . byteOrder = byteOrder ; this . maxFrameLength = maxFrameLength ; this . lengthFieldOffset = lengthFieldOffset ; this . lengthFieldLength = lengthFieldLength ; this . lengthAdjustment = lengthAdjustment ; lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength ; this . initialBytesToStrip = initialBytesToStrip ; this . failFast = failFast ; } @Override protected final void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { Object decoded = decode ( ctx , in ) ; if ( decoded ! = null ) { out . add ( decoded ) ; } } protected Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { if ( discardingTooLongFrame ) { long bytesToDiscard = this . bytesToDiscard ; int localBytesToDiscard = ( int ) Math . min ( bytesToDiscard , in . readableBytes ( ) ) ; in . skipBytes ( localBytesToDiscard ) ; bytesToDiscard - = localBytesToDiscard ; this . bytesToDiscard = bytesToDiscard ; failIfNecessary ( false ) ; } if ( in . readableBytes ( ) < lengthFieldEndOffset ) { return null ; } int actualLengthFieldOffset = in . readerIndex ( ) + lengthFieldOffset ; long frameLength = getUnadjustedFrameLength ( in , actualLengthFieldOffset , lengthFieldLength , byteOrder ) ; if ( frameLength < <int> ) { in . skipBytes ( lengthFieldEndOffset ) ; throw new CorruptedFrameException ( <str> + frameLength ) ; } frameLength + = lengthAdjustment + lengthFieldEndOffset ; if ( frameLength < lengthFieldEndOffset ) { in . skipBytes ( lengthFieldEndOffset ) ; throw new CorruptedFrameException ( <str> + frameLength + <str> + <str> + lengthFieldEndOffset ) ; } if ( frameLength > maxFrameLength ) { long discard = frameLength - in . readableBytes ( ) ; tooLongFrameLength = frameLength ; if ( discard < <int> ) { in . skipBytes ( ( int ) frameLength ) ; } else { discardingTooLongFrame = true ; bytesToDiscard = discard ; in . skipBytes ( in . readableBytes ( ) ) ; } failIfNecessary ( true ) ; return null ; } int frameLengthInt = ( int ) frameLength ; if ( in . readableBytes ( ) < frameLengthInt ) { return null ; } if ( initialBytesToStrip > frameLengthInt ) { in . skipBytes ( frameLengthInt ) ; throw new CorruptedFrameException ( <str> + frameLength + <str> + <str> + initialBytesToStrip ) ; } in . skipBytes ( initialBytesToStrip ) ; int readerIndex = in . readerIndex ( ) ; int actualFrameLength = frameLengthInt - initialBytesToStrip ; ByteBuf frame = extractFrame ( ctx , in , readerIndex , actualFrameLength ) ; in . readerIndex ( readerIndex + actualFrameLength ) ; return frame ; } protected long getUnadjustedFrameLength ( ByteBuf buf , int offset , int length , ByteOrder order ) { buf = buf . order ( order ) ; long frameLength ; switch ( length ) { case <int> : frameLength = buf . getUnsignedByte ( offset ) ; break ; case <int> : frameLength = buf . getUnsignedShort ( offset ) ; break ; case <int> : frameLength = buf . getUnsignedMedium ( offset ) ; break ; case <int> : frameLength = buf . getUnsignedInt ( offset ) ; break ; case <int> : frameLength = buf . getLong ( offset ) ; break ; default : throw new DecoderException ( <str> + lengthFieldLength + <str> ) ; } return frameLength ; } private void failIfNecessary ( boolean firstDetectionOfTooLongFrame ) { if ( bytesToDiscard = = <int> ) { long tooLongFrameLength = this . tooLongFrameLength ; this . tooLongFrameLength = <int> ; discardingTooLongFrame = false ; if ( ! failFast | | failFast & & firstDetectionOfTooLongFrame ) { fail ( tooLongFrameLength ) ; } } else { if ( failFast & & firstDetectionOfTooLongFrame ) { fail ( tooLongFrameLength ) ; } } } protected ByteBuf extractFrame ( ChannelHandlerContext ctx , ByteBuf buffer , int index , int length ) { return buffer . slice ( index , length ) . retain ( ) ; } private void fail ( long frameLength ) { if ( frameLength > <int> ) { throw new TooLongFrameException ( <str> + maxFrameLength + <str> + frameLength + <str> ) ; } else { throw new TooLongFrameException ( <str> + maxFrameLength + <str> ) ; } } } 
