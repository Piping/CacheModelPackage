package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Optional ; import java . util . BitSet ; import java . util . Deque ; import java . util . Iterator ; @Beta @GwtCompatible ( emulated = true ) public abstract class BinaryTreeTraverser < T > extends TreeTraverser < T > { public abstract Optional < T > leftChild ( T root ) ; public abstract Optional < T > rightChild ( T root ) ; @Override public final Iterable < T > children ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return new AbstractIterator < T > ( ) { boolean doneLeft ; boolean doneRight ; @Override protected T computeNext ( ) { if ( ! doneLeft ) { doneLeft = true ; Optional < T > left = leftChild ( root ) ; if ( left . isPresent ( ) ) { return left . get ( ) ; } } if ( ! doneRight ) { doneRight = true ; Optional < T > right = rightChild ( root ) ; if ( right . isPresent ( ) ) { return right . get ( ) ; } } return endOfData ( ) ; } } ; } } ; } @Override UnmodifiableIterator < T > preOrderIterator ( T root ) { return new PreOrderIterator ( root ) ; } private final class PreOrderIterator extends UnmodifiableIterator < T > implements PeekingIterator < T > { private final Deque < T > stack ; PreOrderIterator ( T root ) { this . stack = Platform . newFastestDeque ( <int> ) ; stack . addLast ( root ) ; } @Override public boolean hasNext ( ) { return ! stack . isEmpty ( ) ; } @Override public T next ( ) { T result = stack . removeLast ( ) ; pushIfPresent ( stack , rightChild ( result ) ) ; pushIfPresent ( stack , leftChild ( result ) ) ; return result ; } @Override public T peek ( ) { return stack . getLast ( ) ; } } @Override UnmodifiableIterator < T > postOrderIterator ( T root ) { return new PostOrderIterator ( root ) ; } private final class PostOrderIterator extends UnmodifiableIterator < T > { private final Deque < T > stack ; private final BitSet hasExpanded ; PostOrderIterator ( T root ) { this . stack = Platform . newFastestDeque ( <int> ) ; stack . addLast ( root ) ; this . hasExpanded = new BitSet ( ) ; } @Override public boolean hasNext ( ) { return ! stack . isEmpty ( ) ; } @Override public T next ( ) { while ( true ) { T node = stack . getLast ( ) ; boolean expandedNode = hasExpanded . get ( stack . size ( ) - <int> ) ; if ( expandedNode ) { stack . removeLast ( ) ; hasExpanded . clear ( stack . size ( ) ) ; return node ; } else { hasExpanded . set ( stack . size ( ) - <int> ) ; pushIfPresent ( stack , rightChild ( node ) ) ; pushIfPresent ( stack , leftChild ( node ) ) ; } } } } public final FluentIterable < T > inOrderTraversal ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public UnmodifiableIterator < T > iterator ( ) { return new InOrderIterator ( root ) ; } } ; } private final class InOrderIterator extends AbstractIterator < T > { private final Deque < T > stack ; private final BitSet hasExpandedLeft ; InOrderIterator ( T root ) { this . stack = Platform . newFastestDeque ( <int> ) ; this . hasExpandedLeft = new BitSet ( ) ; stack . addLast ( root ) ; } @Override protected T computeNext ( ) { while ( ! stack . isEmpty ( ) ) { T node = stack . getLast ( ) ; if ( hasExpandedLeft . get ( stack . size ( ) - <int> ) ) { stack . removeLast ( ) ; hasExpandedLeft . clear ( stack . size ( ) ) ; pushIfPresent ( stack , rightChild ( node ) ) ; return node ; } else { hasExpandedLeft . set ( stack . size ( ) - <int> ) ; pushIfPresent ( stack , leftChild ( node ) ) ; } } return endOfData ( ) ; } } private static < T > void pushIfPresent ( Deque < T > stack , Optional < T > node ) { if ( node . isPresent ( ) ) { stack . addLast ( node . get ( ) ) ; } } } 
