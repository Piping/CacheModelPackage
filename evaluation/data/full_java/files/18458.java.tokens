package com . badlogic . gdx . tests ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . nio . LongBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . TimeUtils ; public class BufferUtilsTest extends GdxTest { static final int NUM_MB = <int> ; @Override public void create ( ) { ByteBuffer bb = BufferUtils . newByteBuffer ( <int> ) ; CharBuffer cb = BufferUtils . newCharBuffer ( <int> ) ; ShortBuffer sb = BufferUtils . newShortBuffer ( <int> ) ; IntBuffer ib = BufferUtils . newIntBuffer ( <int> ) ; LongBuffer lb = BufferUtils . newLongBuffer ( <int> ) ; FloatBuffer fb = BufferUtils . newFloatBuffer ( <int> ) ; DoubleBuffer db = BufferUtils . newDoubleBuffer ( <int> ) ; bb . position ( <int> ) ; BufferUtils . copy ( new byte [ ] { <int> , <int> , <int> , <int> } , <int> , bb , <int> ) ; checkInt ( bb . get ( ) , <int> ) ; checkInt ( bb . get ( ) , <int> ) ; checkInt ( bb . get ( ) , <int> ) ; checkInt ( bb . get ( ) , <int> ) ; cb . position ( <int> ) ; BufferUtils . copy ( new char [ ] { <int> , <int> , <int> , <int> } , <int> , cb , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; cb . position ( <int> ) ; BufferUtils . copy ( new char [ ] { <int> , <int> , <int> , <int> } , <int> , cb , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; checkInt ( cb . get ( ) , <int> ) ; sb . position ( <int> ) ; BufferUtils . copy ( new short [ ] { <int> , <int> , <int> , <int> } , <int> , sb , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; sb . position ( <int> ) ; BufferUtils . copy ( new short [ ] { <int> , <int> , <int> , <int> } , <int> , sb , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; checkInt ( sb . get ( ) , <int> ) ; ib . position ( <int> ) ; BufferUtils . copy ( new int [ ] { <int> , <int> , <int> , <int> } , <int> , ib , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; ib . position ( <int> ) ; BufferUtils . copy ( new int [ ] { <int> , <int> , <int> , <int> } , <int> , ib , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; checkInt ( ib . get ( ) , <int> ) ; lb . position ( <int> ) ; BufferUtils . copy ( new long [ ] { <int> , <int> , <int> , <int> } , <int> , lb , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; lb . position ( <int> ) ; BufferUtils . copy ( new long [ ] { <int> , <int> , <int> , <int> } , <int> , lb , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; checkInt ( lb . get ( ) , <int> ) ; fb . position ( <int> ) ; BufferUtils . copy ( new float [ ] { <int> , <int> , <int> , <int> } , <int> , fb , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; fb . position ( <int> ) ; BufferUtils . copy ( new float [ ] { <int> , <int> , <int> , <int> } , <int> , fb , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; checkFloat ( fb . get ( ) , <int> ) ; if ( Gdx . app . getType ( ) ! = ApplicationType . WebGL ) { db . position ( <int> ) ; BufferUtils . copy ( new double [ ] { <int> , <int> , <int> , <int> } , <int> , db , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; db . position ( <int> ) ; BufferUtils . copy ( new double [ ] { <int> , <int> , <int> , <int> } , <int> , db , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; checkFloat ( db . get ( ) , <int> ) ; } ByteBuffer bb2 = BufferUtils . newByteBuffer ( <int> ) ; bb . position ( <int> ) ; BufferUtils . copy ( bb , bb2 , <int> ) ; checkInt ( bb2 . get ( ) , <int> ) ; checkInt ( bb2 . get ( ) , <int> ) ; checkInt ( bb2 . get ( ) , <int> ) ; checkInt ( bb2 . get ( ) , <int> ) ; bench ( ) ; } private void bench ( ) { benchByte ( ) ; benchShort ( ) ; benchInt ( ) ; benchLong ( ) ; benchFloat ( ) ; benchDouble ( ) ; } private void benchByte ( ) { ByteBuffer bb = BufferUtils . newByteBuffer ( <int> * <int> ) ; byte [ ] bytes = new byte [ <int> * <int> ] ; int len = bytes . length ; final int NUM_MB = <int> ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { bb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) bb . put ( bytes [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { bb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) bb . put ( i , bytes [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { bb . clear ( ) ; bb . put ( bytes ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { bb . clear ( ) ; BufferUtils . copy ( bytes , <int> , bb , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void benchShort ( ) { ShortBuffer sb = BufferUtils . newShortBuffer ( <int> * <int> / <int> ) ; short [ ] shorts = new short [ <int> * <int> / <int> ] ; int len = shorts . length ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { sb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) sb . put ( shorts [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { sb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) sb . put ( i , shorts [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { sb . clear ( ) ; sb . put ( shorts ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { sb . clear ( ) ; BufferUtils . copy ( shorts , <int> , sb , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void benchInt ( ) { IntBuffer ib = BufferUtils . newIntBuffer ( <int> * <int> / <int> ) ; int [ ] ints = new int [ <int> * <int> / <int> ] ; int len = ints . length ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { ib . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) ib . put ( ints [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { ib . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) ib . put ( i , ints [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { ib . clear ( ) ; ib . put ( ints ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { ib . clear ( ) ; BufferUtils . copy ( ints , <int> , ib , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void benchLong ( ) { LongBuffer lb = BufferUtils . newLongBuffer ( <int> * <int> / <int> ) ; long [ ] longs = new long [ <int> * <int> / <int> ] ; int len = longs . length ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { lb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) lb . put ( longs [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { lb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) lb . put ( i , longs [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { lb . clear ( ) ; lb . put ( longs ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { lb . clear ( ) ; BufferUtils . copy ( longs , <int> , lb , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void benchFloat ( ) { FloatBuffer fb = BufferUtils . newFloatBuffer ( <int> * <int> / <int> ) ; float [ ] floats = new float [ <int> * <int> / <int> ] ; int len = floats . length ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { fb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) fb . put ( floats [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { fb . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) fb . put ( i , floats [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { fb . clear ( ) ; fb . put ( floats ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { fb . clear ( ) ; BufferUtils . copy ( floats , <int> , fb , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void benchDouble ( ) { DoubleBuffer db = BufferUtils . newDoubleBuffer ( <int> * <int> / <int> ) ; double [ ] doubles = new double [ <int> * <int> / <int> ] ; int len = doubles . length ; long start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { db . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) db . put ( doubles [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { db . clear ( ) ; for ( int i = <int> ; i < len ; i + + ) db . put ( i , doubles [ i ] ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { db . clear ( ) ; db . put ( doubles ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; start = TimeUtils . nanoTime ( ) ; for ( int j = <int> ; j < NUM_MB ; j + + ) { db . clear ( ) ; BufferUtils . copy ( doubles , <int> , db , len ) ; } Gdx . app . log ( <str> , <str> + ( TimeUtils . nanoTime ( ) - start ) / <float> ) ; } private void checkInt ( long val1 , long val2 ) { if ( val1 ! = val2 ) { Gdx . app . error ( <str> , <str> + val1 + <str> + val2 ) ; throw new GdxRuntimeException ( <str> ) ; } } private void checkFloat ( double val1 , double val2 ) { if ( val1 ! = val2 ) { Gdx . app . error ( <str> , <str> + val1 + <str> + val2 ) ; throw new GdxRuntimeException ( <str> ) ; } } } 
