package org . elasticsearch . gateway ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . FailedNodeException ; import org . elasticsearch . action . support . nodes . BaseNodeResponse ; import org . elasticsearch . action . support . nodes . BaseNodesResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . transport . ReceiveTimeoutTransportException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableSet ; public abstract class AsyncShardFetch < T extends BaseNodeResponse > implements Releasable { public interface List < NodesResponse extends BaseNodesResponse < NodeResponse > , NodeResponse extends BaseNodeResponse > { void list ( ShardId shardId , IndexMetaData indexMetaData , String [ ] nodesIds , ActionListener < NodesResponse > listener ) ; } protected final ESLogger logger ; protected final String type ; private final ShardId shardId ; private final List < BaseNodesResponse < T > , T > action ; private final Map < String , NodeEntry < T > > cache = new HashMap < > ( ) ; private final Set < String > nodesToIgnore = new HashSet < > ( ) ; private boolean closed ; @SuppressWarnings ( <str> ) protected AsyncShardFetch ( ESLogger logger , String type , ShardId shardId , List < ? extends BaseNodesResponse < T > , T > action ) { this . logger = logger ; this . type = type ; this . shardId = shardId ; this . action = ( List < BaseNodesResponse < T > , T > ) action ; } @Override public synchronized void close ( ) { this . closed = true ; } public synchronized int getNumberOfInFlightFetches ( ) { int count = <int> ; for ( NodeEntry < T > nodeEntry : cache . values ( ) ) { if ( nodeEntry . isFetching ( ) ) { count + + ; } } return count ; } public synchronized FetchResult < T > fetchData ( DiscoveryNodes nodes , MetaData metaData , Set < String > ignoreNodes ) { if ( closed ) { throw new IllegalStateException ( shardId + <str> ) ; } nodesToIgnore . addAll ( ignoreNodes ) ; fillShardCacheWithDataNodes ( cache , nodes ) ; Set < NodeEntry < T > > nodesToFetch = findNodesToFetch ( cache ) ; if ( nodesToFetch . isEmpty ( ) = = false ) { for ( NodeEntry < T > nodeEntry : nodesToFetch ) { nodeEntry . markAsFetching ( ) ; } String [ ] nodesIds = new String [ nodesToFetch . size ( ) ] ; int index = <int> ; for ( NodeEntry < T > nodeEntry : nodesToFetch ) { nodesIds [ index + + ] = nodeEntry . getNodeId ( ) ; } asyncFetch ( shardId , nodesIds , metaData ) ; } if ( hasAnyNodeFetching ( cache ) = = true ) { return new FetchResult < > ( shardId , null , emptySet ( ) , emptySet ( ) ) ; } else { Map < DiscoveryNode , T > fetchData = new HashMap < > ( ) ; Set < String > failedNodes = new HashSet < > ( ) ; for ( Iterator < Map . Entry < String , NodeEntry < T > > > it = cache . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < String , NodeEntry < T > > entry = it . next ( ) ; String nodeId = entry . getKey ( ) ; NodeEntry < T > nodeEntry = entry . getValue ( ) ; DiscoveryNode node = nodes . get ( nodeId ) ; if ( node ! = null ) { if ( nodeEntry . isFailed ( ) = = true ) { it . remove ( ) ; failedNodes . add ( nodeEntry . getNodeId ( ) ) ; } else { if ( nodeEntry . getValue ( ) ! = null ) { fetchData . put ( node , nodeEntry . getValue ( ) ) ; } } } } Set < String > allIgnoreNodes = unmodifiableSet ( new HashSet < > ( nodesToIgnore ) ) ; nodesToIgnore . clear ( ) ; if ( failedNodes . isEmpty ( ) = = false | | allIgnoreNodes . isEmpty ( ) = = false ) { reroute ( shardId , <str> + failedNodes . size ( ) + <str> + allIgnoreNodes . size ( ) + <str> ) ; } return new FetchResult < > ( shardId , fetchData , failedNodes , allIgnoreNodes ) ; } } protected synchronized void processAsyncFetch ( ShardId shardId , T [ ] responses , FailedNodeException [ ] failures ) { if ( closed ) { logger . trace ( <str> , shardId , type ) ; return ; } logger . trace ( <str> , shardId , type ) ; if ( responses ! = null ) { for ( T response : responses ) { NodeEntry < T > nodeEntry = cache . get ( response . getNode ( ) . getId ( ) ) ; if ( nodeEntry = = null ) { continue ; } if ( nodeEntry . isFailed ( ) ) { logger . trace ( <str> , shardId , nodeEntry . getNodeId ( ) , type , nodeEntry . getFailure ( ) ) ; } else { logger . trace ( <str> , shardId , nodeEntry . getNodeId ( ) , type ) ; nodeEntry . doneFetching ( response ) ; } } } if ( failures ! = null ) { for ( FailedNodeException failure : failures ) { logger . trace ( <str> , shardId , failure , type ) ; NodeEntry < T > nodeEntry = cache . get ( failure . nodeId ( ) ) ; if ( nodeEntry ! = null & & nodeEntry . isFailed ( ) = = false ) { Throwable unwrappedCause = ExceptionsHelper . unwrapCause ( failure . getCause ( ) ) ; if ( unwrappedCause instanceof EsRejectedExecutionException | | unwrappedCause instanceof ReceiveTimeoutTransportException | | unwrappedCause instanceof ElasticsearchTimeoutException ) { nodeEntry . restartFetching ( ) ; } else { logger . warn ( <str> , failure , shardId , type , failure . nodeId ( ) ) ; nodeEntry . doneFetching ( failure . getCause ( ) ) ; } } } } reroute ( shardId , <str> ) ; } protected abstract void reroute ( ShardId shardId , String reason ) ; private void fillShardCacheWithDataNodes ( Map < String , NodeEntry < T > > shardCache , DiscoveryNodes nodes ) { for ( ObjectObjectCursor < String , DiscoveryNode > cursor : nodes . dataNodes ( ) ) { DiscoveryNode node = cursor . value ; if ( shardCache . containsKey ( node . getId ( ) ) = = false ) { shardCache . put ( node . getId ( ) , new NodeEntry < T > ( node . getId ( ) ) ) ; } } for ( Iterator < String > it = shardCache . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String nodeId = it . next ( ) ; if ( nodes . nodeExists ( nodeId ) = = false ) { it . remove ( ) ; } } } private Set < NodeEntry < T > > findNodesToFetch ( Map < String , NodeEntry < T > > shardCache ) { Set < NodeEntry < T > > nodesToFetch = new HashSet < > ( ) ; for ( NodeEntry < T > nodeEntry : shardCache . values ( ) ) { if ( nodeEntry . hasData ( ) = = false & & nodeEntry . isFetching ( ) = = false ) { nodesToFetch . add ( nodeEntry ) ; } } return nodesToFetch ; } private boolean hasAnyNodeFetching ( Map < String , NodeEntry < T > > shardCache ) { for ( NodeEntry < T > nodeEntry : shardCache . values ( ) ) { if ( nodeEntry . isFetching ( ) ) { return true ; } } return false ; } void asyncFetch ( final ShardId shardId , final String [ ] nodesIds , final MetaData metaData ) { IndexMetaData indexMetaData = metaData . index ( shardId . getIndex ( ) ) ; logger . trace ( <str> , shardId , type , nodesIds ) ; action . list ( shardId , indexMetaData , nodesIds , new ActionListener < BaseNodesResponse < T > > ( ) { @Override public void onResponse ( BaseNodesResponse < T > response ) { processAsyncFetch ( shardId , response . getNodes ( ) , response . failures ( ) ) ; } @Override public void onFailure ( Throwable e ) { FailedNodeException [ ] failures = new FailedNodeException [ nodesIds . length ] ; for ( int i = <int> ; i < failures . length ; i + + ) { failures [ i ] = new FailedNodeException ( nodesIds [ i ] , <str> , e ) ; } processAsyncFetch ( shardId , null , failures ) ; } } ) ; } public static class FetchResult < T extends BaseNodeResponse > { private final ShardId shardId ; private final Map < DiscoveryNode , T > data ; private final Set < String > failedNodes ; private final Set < String > ignoreNodes ; public FetchResult ( ShardId shardId , Map < DiscoveryNode , T > data , Set < String > failedNodes , Set < String > ignoreNodes ) { this . shardId = shardId ; this . data = data ; this . failedNodes = failedNodes ; this . ignoreNodes = ignoreNodes ; } public boolean hasData ( ) { return data ! = null ; } public Map < DiscoveryNode , T > getData ( ) { assert data ! = null : <str> ; return this . data ; } public void processAllocation ( RoutingAllocation allocation ) { for ( String ignoreNode : ignoreNodes ) { allocation . addIgnoreShardForNode ( shardId , ignoreNode ) ; } } } static class NodeEntry < T > { private final String nodeId ; private boolean fetching ; @Nullable private T value ; private boolean valueSet ; private Throwable failure ; public NodeEntry ( String nodeId ) { this . nodeId = nodeId ; } String getNodeId ( ) { return this . nodeId ; } boolean isFetching ( ) { return fetching ; } void markAsFetching ( ) { assert fetching = = false : <str> ; fetching = true ; } void doneFetching ( T value ) { assert fetching = = true : <str> ; assert failure = = null : <str> ; this . valueSet = true ; this . value = value ; this . fetching = false ; } void doneFetching ( Throwable failure ) { assert fetching = = true : <str> ; assert valueSet = = false : <str> ; assert failure ! = null : <str> ; this . failure = failure ; this . fetching = false ; } void restartFetching ( ) { assert fetching = = true : <str> ; assert valueSet = = false : <str> ; assert failure = = null : <str> ; this . fetching = false ; } boolean isFailed ( ) { return failure ! = null ; } boolean hasData ( ) { return valueSet = = true | | failure ! = null ; } Throwable getFailure ( ) { assert hasData ( ) : <str> ; return failure ; } @Nullable T getValue ( ) { assert failure = = null : <str> ; assert valueSet = = true : <str> ; return value ; } } } 
