package org . elasticsearch . index . query . functionscore ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . TopDocs ; import org . apache . lucene . search . Weight ; import org . apache . lucene . store . Directory ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . lucene . search . function . FieldValueFactorFunction ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . FunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . LeafScoreFunction ; import org . elasticsearch . common . lucene . search . function . RandomScoreFunction ; import org . elasticsearch . common . lucene . search . function . ScoreFunction ; import org . elasticsearch . common . lucene . search . function . WeightFactorFunction ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . fielddata . AtomicFieldData ; import org . elasticsearch . index . fielddata . AtomicNumericFieldData ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexNumericFieldData ; import org . elasticsearch . index . fielddata . ScriptDocValues ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . query . functionscore . exp . ExponentialDecayFunctionBuilder ; import org . elasticsearch . index . query . functionscore . gauss . GaussDecayFunctionBuilder ; import org . elasticsearch . index . query . functionscore . lin . LinearDecayFunctionBuilder ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . test . ESTestCase ; import org . junit . After ; import org . junit . Before ; import java . io . IOException ; import java . util . Collection ; import java . util . concurrent . ExecutionException ; import static org . hamcrest . core . Is . is ; import static org . hamcrest . core . IsEqual . equalTo ; public class FunctionScoreTests extends ESTestCase { private static final String UNSUPPORTED = <str> ; private static class IndexFieldDataStub implements IndexFieldData < AtomicFieldData > { @Override public MappedFieldType . Names getFieldNames ( ) { return new MappedFieldType . Names ( <str> ) ; } @Override public FieldDataType getFieldDataType ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public AtomicFieldData load ( LeafReaderContext context ) { return new AtomicFieldData ( ) { @Override public ScriptDocValues getScriptValues ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public SortedBinaryDocValues getBytesValues ( ) { return new SortedBinaryDocValues ( ) { @Override public void setDocument ( int docId ) { } @Override public int count ( ) { return <int> ; } @Override public BytesRef valueAt ( int index ) { return new BytesRef ( <str> ) ; } } ; } @Override public long ramBytesUsed ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public Collection < Accountable > getChildResources ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public void close ( ) { } } ; } @Override public AtomicFieldData loadDirect ( LeafReaderContext context ) throws Exception { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public IndexFieldData . XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , IndexFieldData . XFieldComparatorSource . Nested nested ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public Index index ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } } private static class IndexNumericFieldDataStub implements IndexNumericFieldData { @Override public NumericType getNumericType ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public MappedFieldType . Names getFieldNames ( ) { return new MappedFieldType . Names ( <str> ) ; } @Override public FieldDataType getFieldDataType ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public AtomicNumericFieldData load ( LeafReaderContext context ) { return new AtomicNumericFieldData ( ) { @Override public SortedNumericDocValues getLongValues ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public SortedNumericDoubleValues getDoubleValues ( ) { return new SortedNumericDoubleValues ( ) { @Override public void setDocument ( int doc ) { } @Override public double valueAt ( int index ) { return <int> ; } @Override public int count ( ) { return <int> ; } } ; } @Override public ScriptDocValues getScriptValues ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public SortedBinaryDocValues getBytesValues ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public long ramBytesUsed ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public Collection < Accountable > getChildResources ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public void close ( ) { } } ; } @Override public AtomicNumericFieldData loadDirect ( LeafReaderContext context ) throws Exception { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , XFieldComparatorSource . Nested nested ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } @Override public Index index ( ) { throw new UnsupportedOperationException ( UNSUPPORTED ) ; } } private static final ScoreFunction RANDOM_SCORE_FUNCTION = new RandomScoreFunction ( <int> , <int> , new IndexFieldDataStub ( ) ) ; private static final ScoreFunction FIELD_VALUE_FACTOR_FUNCTION = new FieldValueFactorFunction ( <str> , <int> , FieldValueFactorFunction . Modifier . LN , new Double ( <int> ) , null ) ; private static final ScoreFunction GAUSS_DECAY_FUNCTION = new DecayFunctionBuilder . NumericFieldDataScoreFunction ( <int> , <int> , <float> , <int> , GaussDecayFunctionBuilder . GAUSS_DECAY_FUNCTION , new IndexNumericFieldDataStub ( ) , MultiValueMode . MAX ) ; private static final ScoreFunction EXP_DECAY_FUNCTION = new DecayFunctionBuilder . NumericFieldDataScoreFunction ( <int> , <int> , <float> , <int> , ExponentialDecayFunctionBuilder . EXP_DECAY_FUNCTION , new IndexNumericFieldDataStub ( ) , MultiValueMode . MAX ) ; private static final ScoreFunction LIN_DECAY_FUNCTION = new DecayFunctionBuilder . NumericFieldDataScoreFunction ( <int> , <int> , <float> , <int> , LinearDecayFunctionBuilder . LINEAR_DECAY_FUNCTION , new IndexNumericFieldDataStub ( ) , MultiValueMode . MAX ) ; private static final ScoreFunction WEIGHT_FACTOR_FUNCTION = new WeightFactorFunction ( <int> ) ; private static final String TEXT = <str> ; private static final String FIELD = <str> ; private static final Term TERM = new Term ( FIELD , <str> ) ; private Directory dir ; private IndexWriter w ; private DirectoryReader reader ; private IndexSearcher searcher ; @Before public void initSearcher ( ) throws IOException { dir = newDirectory ( ) ; w = new IndexWriter ( dir , newIndexWriterConfig ( new StandardAnalyzer ( ) ) ) ; Document d = new Document ( ) ; d . add ( new TextField ( FIELD , TEXT , Field . Store . YES ) ) ; d . add ( new TextField ( <str> , <str> , Field . Store . YES ) ) ; w . addDocument ( d ) ; w . commit ( ) ; reader = DirectoryReader . open ( w , true ) ; searcher = newSearcher ( reader ) ; } @After public void closeAllTheReaders ( ) throws IOException { reader . close ( ) ; w . close ( ) ; dir . close ( ) ; } public void testExplainFunctionScoreQuery ( ) throws IOException { Explanation functionExplanation = getFunctionScoreExplanation ( searcher , RANDOM_SCORE_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFunctionScoreExplanation ( searcher , FIELD_VALUE_FACTOR_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFunctionScoreExplanation ( searcher , GAUSS_DECAY_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFunctionScoreExplanation ( searcher , EXP_DECAY_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFunctionScoreExplanation ( searcher , LIN_DECAY_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFunctionScoreExplanation ( searcher , WEIGHT_FACTOR_FUNCTION ) ; checkFunctionScoreExplanation ( functionExplanation , <str> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; } public Explanation getFunctionScoreExplanation ( IndexSearcher searcher , ScoreFunction scoreFunction ) throws IOException { FunctionScoreQuery functionScoreQuery = new FunctionScoreQuery ( new TermQuery ( TERM ) , scoreFunction , <float> , CombineFunction . AVG , <int> ) ; Weight weight = searcher . createNormalizedWeight ( functionScoreQuery , true ) ; Explanation explanation = weight . explain ( searcher . getIndexReader ( ) . leaves ( ) . get ( <int> ) , <int> ) ; return explanation . getDetails ( ) [ <int> ] ; } public void checkFunctionScoreExplanation ( Explanation randomExplanation , String functionExpl ) { assertThat ( randomExplanation . getDescription ( ) , equalTo ( <str> ) ) ; assertThat ( randomExplanation . getDetails ( ) [ <int> ] . getDescription ( ) , equalTo ( functionExpl ) ) ; } public void testExplainFiltersFunctionScoreQuery ( ) throws IOException { Explanation functionExplanation = getFiltersFunctionScoreExplanation ( searcher , RANDOM_SCORE_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFiltersFunctionScoreExplanation ( searcher , FIELD_VALUE_FACTOR_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFiltersFunctionScoreExplanation ( searcher , GAUSS_DECAY_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFiltersFunctionScoreExplanation ( searcher , EXP_DECAY_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFiltersFunctionScoreExplanation ( searcher , LIN_DECAY_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; functionExplanation = getFiltersFunctionScoreExplanation ( searcher , RANDOM_SCORE_FUNCTION , FIELD_VALUE_FACTOR_FUNCTION , GAUSS_DECAY_FUNCTION , EXP_DECAY_FUNCTION , LIN_DECAY_FUNCTION ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; checkFiltersFunctionScoreExplanation ( functionExplanation , <str> , <int> ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . toString ( ) , equalTo ( <str> ) ) ; assertThat ( functionExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) [ <int> ] . getDetails ( ) . length , equalTo ( <int> ) ) ; } public Explanation getFiltersFunctionScoreExplanation ( IndexSearcher searcher , ScoreFunction . . . scoreFunctions ) throws IOException { FiltersFunctionScoreQuery filtersFunctionScoreQuery = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . AVG , CombineFunction . AVG , scoreFunctions ) ; return getExplanation ( searcher , filtersFunctionScoreQuery ) . getDetails ( ) [ <int> ] ; } protected Explanation getExplanation ( IndexSearcher searcher , FiltersFunctionScoreQuery filtersFunctionScoreQuery ) throws IOException { Weight weight = searcher . createNormalizedWeight ( filtersFunctionScoreQuery , true ) ; return weight . explain ( searcher . getIndexReader ( ) . leaves ( ) . get ( <int> ) , <int> ) ; } public FiltersFunctionScoreQuery getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode scoreMode , CombineFunction combineFunction , ScoreFunction . . . scoreFunctions ) { FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions = new FiltersFunctionScoreQuery . FilterFunction [ scoreFunctions . length ] ; for ( int i = <int> ; i < scoreFunctions . length ; i + + ) { filterFunctions [ i ] = new FiltersFunctionScoreQuery . FilterFunction ( new TermQuery ( TERM ) , scoreFunctions [ i ] ) ; } return new FiltersFunctionScoreQuery ( new TermQuery ( TERM ) , scoreMode , filterFunctions , Float . MAX_VALUE , Float . MAX_VALUE * - <int> , combineFunction ) ; } public void checkFiltersFunctionScoreExplanation ( Explanation randomExplanation , String functionExpl , int whichFunction ) { assertThat ( randomExplanation . getDescription ( ) , equalTo ( <str> ) ) ; assertThat ( randomExplanation . getDetails ( ) [ <int> ] . getDescription ( ) , equalTo ( <str> ) ) ; assertThat ( randomExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ whichFunction ] . getDescription ( ) , equalTo ( <str> ) ) ; assertThat ( randomExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ whichFunction ] . getDetails ( ) [ <int> ] . getDescription ( ) , equalTo ( <str> + FIELD + <str> + TERM . text ( ) ) ) ; assertThat ( randomExplanation . getDetails ( ) [ <int> ] . getDetails ( ) [ whichFunction ] . getDetails ( ) [ <int> ] . getDescription ( ) , equalTo ( functionExpl ) ) ; } private static float [ ] randomFloats ( int size ) { float [ ] values = new float [ size ] ; for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] = randomFloat ( ) * ( randomBoolean ( ) ? <float> : - <float> ) * randomInt ( <int> ) + <float> ; } return values ; } private static double [ ] randomDoubles ( int size ) { double [ ] values = new double [ size ] ; for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] = randomDouble ( ) * ( randomBoolean ( ) ? <float> : - <float> ) * randomInt ( <int> ) + <float> ; } return values ; } private static class ScoreFunctionStub extends ScoreFunction { private double score ; ScoreFunctionStub ( double score ) { super ( CombineFunction . REPLACE ) ; this . score = score ; } @Override public LeafScoreFunction getLeafScoreFunction ( LeafReaderContext ctx ) throws IOException { return new LeafScoreFunction ( ) { @Override public double score ( int docId , float subQueryScore ) { return score ; } @Override public Explanation explainScore ( int docId , Explanation subQueryScore ) throws IOException { return Explanation . match ( ( float ) score , <str> ) ; } } ; } @Override public boolean needsScores ( ) { return false ; } @Override protected boolean doEquals ( ScoreFunction other ) { return false ; } } public void testSimpleWeightedFunction ( ) throws IOException , ExecutionException , InterruptedException { int numFunctions = randomIntBetween ( <int> , <int> ) ; float [ ] weights = randomFloats ( numFunctions ) ; double [ ] scores = randomDoubles ( numFunctions ) ; ScoreFunctionStub [ ] scoreFunctionStubs = new ScoreFunctionStub [ numFunctions ] ; for ( int i = <int> ; i < numFunctions ; i + + ) { scoreFunctionStubs [ i ] = new ScoreFunctionStub ( scores [ i ] ) ; } WeightFactorFunction [ ] weightFunctionStubs = new WeightFactorFunction [ numFunctions ] ; for ( int i = <int> ; i < numFunctions ; i + + ) { weightFunctionStubs [ i ] = new WeightFactorFunction ( weights [ i ] , scoreFunctionStubs [ i ] ) ; } FiltersFunctionScoreQuery filtersFunctionScoreQueryWithWeights = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY , CombineFunction . REPLACE , weightFunctionStubs ) ; TopDocs topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; float scoreWithWeight = topDocsWithWeights . scoreDocs [ <int> ] . score ; double score = <int> ; for ( int i = <int> ; i < weights . length ; i + + ) { score * = weights [ i ] * scores [ i ] ; } assertThat ( scoreWithWeight / ( float ) score , is ( <float> ) ) ; float explainedScore = getExplanation ( searcher , filtersFunctionScoreQueryWithWeights ) . getValue ( ) ; assertThat ( explainedScore / scoreWithWeight , is ( <float> ) ) ; filtersFunctionScoreQueryWithWeights = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . SUM , CombineFunction . REPLACE , weightFunctionStubs ) ; topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; scoreWithWeight = topDocsWithWeights . scoreDocs [ <int> ] . score ; double sum = <int> ; for ( int i = <int> ; i < weights . length ; i + + ) { sum + = weights [ i ] * scores [ i ] ; } assertThat ( scoreWithWeight / ( float ) sum , is ( <float> ) ) ; explainedScore = getExplanation ( searcher , filtersFunctionScoreQueryWithWeights ) . getValue ( ) ; assertThat ( explainedScore / scoreWithWeight , is ( <float> ) ) ; filtersFunctionScoreQueryWithWeights = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . AVG , CombineFunction . REPLACE , weightFunctionStubs ) ; topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; scoreWithWeight = topDocsWithWeights . scoreDocs [ <int> ] . score ; double norm = <int> ; sum = <int> ; for ( int i = <int> ; i < weights . length ; i + + ) { norm + = weights [ i ] ; sum + = weights [ i ] * scores [ i ] ; } assertThat ( scoreWithWeight / ( float ) ( sum / norm ) , is ( <float> ) ) ; explainedScore = getExplanation ( searcher , filtersFunctionScoreQueryWithWeights ) . getValue ( ) ; assertThat ( explainedScore / scoreWithWeight , is ( <float> ) ) ; filtersFunctionScoreQueryWithWeights = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . MIN , CombineFunction . REPLACE , weightFunctionStubs ) ; topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; scoreWithWeight = topDocsWithWeights . scoreDocs [ <int> ] . score ; double min = Double . POSITIVE_INFINITY ; for ( int i = <int> ; i < weights . length ; i + + ) { min = Math . min ( min , weights [ i ] * scores [ i ] ) ; } assertThat ( scoreWithWeight / ( float ) min , is ( <float> ) ) ; explainedScore = getExplanation ( searcher , filtersFunctionScoreQueryWithWeights ) . getValue ( ) ; assertThat ( explainedScore / scoreWithWeight , is ( <float> ) ) ; filtersFunctionScoreQueryWithWeights = getFiltersFunctionScoreQuery ( FiltersFunctionScoreQuery . ScoreMode . MAX , CombineFunction . REPLACE , weightFunctionStubs ) ; topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; scoreWithWeight = topDocsWithWeights . scoreDocs [ <int> ] . score ; double max = Double . NEGATIVE_INFINITY ; for ( int i = <int> ; i < weights . length ; i + + ) { max = Math . max ( max , weights [ i ] * scores [ i ] ) ; } assertThat ( scoreWithWeight / ( float ) max , is ( <float> ) ) ; explainedScore = getExplanation ( searcher , filtersFunctionScoreQueryWithWeights ) . getValue ( ) ; assertThat ( explainedScore / scoreWithWeight , is ( <float> ) ) ; } public void testWeightOnlyCreatesBoostFunction ( ) throws IOException { FunctionScoreQuery filtersFunctionScoreQueryWithWeights = new FunctionScoreQuery ( new MatchAllDocsQuery ( ) , new WeightFactorFunction ( <int> ) , <float> , CombineFunction . MULTIPLY , <int> ) ; TopDocs topDocsWithWeights = searcher . search ( filtersFunctionScoreQueryWithWeights , <int> ) ; float score = topDocsWithWeights . scoreDocs [ <int> ] . score ; assertThat ( score , equalTo ( <float> ) ) ; } } 
