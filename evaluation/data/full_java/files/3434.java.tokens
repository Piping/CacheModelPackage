package org . nd4j . linalg . api . indexing . shape ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . Indices ; import org . nd4j . linalg . indexing . NDArrayIndex ; import static org . junit . Assert . * ; public class IndexShapeTests extends BaseNd4jTest { public IndexShapeTests ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public IndexShapeTests ( Nd4jBackend backend ) { super ( backend ) ; } public IndexShapeTests ( ) { } public IndexShapeTests ( String name ) { super ( name ) ; } private int [ ] shape = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; @Test public void testSinglePoint ( ) { int [ ] assertion = { <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] indexes = new INDArrayIndex [ ] { NDArrayIndex . point ( <int> ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) } ; int [ ] testShape = Indices . shape ( shape , indexes ) ; assertArrayEquals ( assertion , testShape ) ; int [ ] secondAssertion = { <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] otherCase = new INDArrayIndex [ ] { NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . point ( <int> ) } ; assertArrayEquals ( secondAssertion , Indices . shape ( shape , otherCase ) ) ; int [ ] thridAssertion = { <int> , <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] thirdCase = new INDArrayIndex [ ] { NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . point ( <int> ) , } ; assertArrayEquals ( thridAssertion , Indices . shape ( shape , thirdCase ) ) ; } @Test public void testInterval ( ) { int [ ] basicAssertion = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] basicTest = { NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . all ( ) } ; assertArrayEquals ( basicAssertion , Indices . shape ( shape , basicTest ) ) ; } @Test public void testNewAxis ( ) { int [ ] prependAssertion = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] prependTest = { NDArrayIndex . newAxis ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , } ; assertArrayEquals ( prependAssertion , Indices . shape ( shape , prependTest ) ) ; int [ ] addToMiddle = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] setInMiddleTest = { NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , } ; assertArrayEquals ( addToMiddle , Indices . shape ( shape , setInMiddleTest ) ) ; int [ ] prependAndAddToMiddleAssertion = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; INDArrayIndex [ ] prependAndMiddle = { NDArrayIndex . newAxis ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . newAxis ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , } ; assertArrayEquals ( prependAndAddToMiddleAssertion , Indices . shape ( shape , prependAndMiddle ) ) ; } @Override public char ordering ( ) { return <str> ; } } 
