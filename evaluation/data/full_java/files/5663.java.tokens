package org . elasticsearch . common ; import org . elasticsearch . common . unit . TimeValue ; import java . text . NumberFormat ; import java . util . LinkedList ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; public class StopWatch { private final String id ; private boolean keepTaskList = true ; private final List < TaskInfo > taskList = new LinkedList < > ( ) ; private long startTimeNS ; private boolean running ; private String currentTaskName ; private TaskInfo lastTaskInfo ; private int taskCount ; private long totalTimeNS ; public StopWatch ( ) { this . id = <str> ; } public StopWatch ( String id ) { this . id = id ; } public StopWatch keepTaskList ( boolean keepTaskList ) { this . keepTaskList = keepTaskList ; return this ; } public StopWatch start ( ) throws IllegalStateException { return start ( <str> ) ; } public StopWatch start ( String taskName ) throws IllegalStateException { if ( this . running ) { throw new IllegalStateException ( <str> ) ; } this . startTimeNS = System . nanoTime ( ) ; this . running = true ; this . currentTaskName = taskName ; return this ; } public StopWatch stop ( ) throws IllegalStateException { if ( ! this . running ) { throw new IllegalStateException ( <str> ) ; } long lastTimeNS = System . nanoTime ( ) - this . startTimeNS ; this . totalTimeNS + = lastTimeNS ; this . lastTaskInfo = new TaskInfo ( this . currentTaskName , TimeValue . nsecToMSec ( lastTimeNS ) ) ; if ( this . keepTaskList ) { this . taskList . add ( lastTaskInfo ) ; } + + this . taskCount ; this . running = false ; this . currentTaskName = null ; return this ; } public boolean isRunning ( ) { return this . running ; } public TimeValue lastTaskTime ( ) throws IllegalStateException { if ( this . lastTaskInfo = = null ) { throw new IllegalStateException ( <str> ) ; } return this . lastTaskInfo . getTime ( ) ; } public String lastTaskName ( ) throws IllegalStateException { if ( this . lastTaskInfo = = null ) { throw new IllegalStateException ( <str> ) ; } return this . lastTaskInfo . getTaskName ( ) ; } public TimeValue totalTime ( ) { return new TimeValue ( totalTimeNS , TimeUnit . NANOSECONDS ) ; } public int taskCount ( ) { return taskCount ; } public TaskInfo [ ] taskInfo ( ) { if ( ! this . keepTaskList ) { throw new UnsupportedOperationException ( <str> ) ; } return this . taskList . toArray ( new TaskInfo [ this . taskList . size ( ) ] ) ; } public String shortSummary ( ) { return <str> + this . id + <str> + totalTime ( ) ; } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( shortSummary ( ) ) ; sb . append ( <str> ) ; if ( ! this . keepTaskList ) { sb . append ( <str> ) ; } else { sb . append ( <str> ) ; sb . append ( <str> ) ; sb . append ( <str> ) ; NumberFormat nf = NumberFormat . getNumberInstance ( Locale . ROOT ) ; nf . setMinimumIntegerDigits ( <int> ) ; nf . setGroupingUsed ( false ) ; NumberFormat pf = NumberFormat . getPercentInstance ( Locale . ROOT ) ; pf . setMinimumIntegerDigits ( <int> ) ; pf . setGroupingUsed ( false ) ; for ( TaskInfo task : taskInfo ( ) ) { sb . append ( nf . format ( task . getTime ( ) . millis ( ) ) ) . append ( <str> ) ; sb . append ( pf . format ( task . getTime ( ) . secondsFrac ( ) / totalTime ( ) . secondsFrac ( ) ) ) . append ( <str> ) ; sb . append ( task . getTaskName ( ) ) . append ( <str> ) ; } } return sb . toString ( ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( shortSummary ( ) ) ; if ( this . keepTaskList ) { for ( TaskInfo task : taskInfo ( ) ) { sb . append ( <str> ) . append ( task . getTaskName ( ) ) . append ( <str> ) . append ( task . getTime ( ) ) ; long percent = Math . round ( ( <float> * task . getTime ( ) . millis ( ) ) / totalTime ( ) . millis ( ) ) ; sb . append ( <str> ) . append ( percent ) . append ( <str> ) ; } } else { sb . append ( <str> ) ; } return sb . toString ( ) ; } public static class TaskInfo { private final String taskName ; private final TimeValue timeValue ; private TaskInfo ( String taskName , long timeMillis ) { this . taskName = taskName ; this . timeValue = new TimeValue ( timeMillis , TimeUnit . MILLISECONDS ) ; } public String getTaskName ( ) { return taskName ; } public TimeValue getTime ( ) { return timeValue ; } } } 
