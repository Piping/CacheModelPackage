package com . google . common . math ; import static com . google . common . math . StatsTesting . ALLOWED_ERROR ; import static com . google . common . math . StatsTesting . ALL_MANY_VALUES ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . MANY_VALUES ; import static com . google . common . math . StatsTesting . MANY_VALUES_COUNT ; import static com . google . common . math . StatsTesting . MANY_VALUES_MAX ; import static com . google . common . math . StatsTesting . MANY_VALUES_MEAN ; import static com . google . common . math . StatsTesting . MANY_VALUES_MIN ; import static com . google . common . math . StatsTesting . MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . math . StatsTesting . ONE_VALUE ; import static com . google . common . math . StatsTesting . TWO_VALUES ; import static com . google . common . math . StatsTesting . TWO_VALUES_MAX ; import static com . google . common . math . StatsTesting . TWO_VALUES_MEAN ; import static com . google . common . math . StatsTesting . TWO_VALUES_MIN ; import static com . google . common . math . StatsTesting . TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Math . sqrt ; import com . google . common . collect . ImmutableList ; import com . google . common . math . StatsTesting . ManyValues ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Longs ; import junit . framework . TestCase ; public class StatsAccumulatorTest extends TestCase { private StatsAccumulator emptyAccumulator ; private StatsAccumulator emptyAccumulatorByAddAllEmptyIterable ; private StatsAccumulator oneValueAccumulator ; private StatsAccumulator twoValuesAccumulator ; private StatsAccumulator manyValuesAccumulatorByAddAllIterable ; private StatsAccumulator manyValuesAccumulatorByAddAllIterator ; private StatsAccumulator manyValuesAccumulatorByAddAllVarargs ; private StatsAccumulator manyValuesAccumulatorByRepeatedAdd ; private StatsAccumulator manyValuesAccumulatorByAddAndAddAll ; private StatsAccumulator integerManyValuesAccumulatorByAddAllIterable ; private StatsAccumulator longManyValuesAccumulatorByAddAllIterator ; private StatsAccumulator longManyValuesAccumulatorByAddAllVarargs ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; emptyAccumulator = new StatsAccumulator ( ) ; emptyAccumulatorByAddAllEmptyIterable = new StatsAccumulator ( ) ; emptyAccumulatorByAddAllEmptyIterable . addAll ( ImmutableList . < Double > of ( ) ) ; oneValueAccumulator = new StatsAccumulator ( ) ; oneValueAccumulator . add ( ONE_VALUE ) ; twoValuesAccumulator = new StatsAccumulator ( ) ; twoValuesAccumulator . addAll ( TWO_VALUES ) ; manyValuesAccumulatorByAddAllIterable = new StatsAccumulator ( ) ; manyValuesAccumulatorByAddAllIterable . addAll ( MANY_VALUES ) ; manyValuesAccumulatorByAddAllIterator = new StatsAccumulator ( ) ; manyValuesAccumulatorByAddAllIterator . addAll ( MANY_VALUES . iterator ( ) ) ; manyValuesAccumulatorByAddAllVarargs = new StatsAccumulator ( ) ; manyValuesAccumulatorByAddAllVarargs . addAll ( Doubles . toArray ( MANY_VALUES ) ) ; manyValuesAccumulatorByRepeatedAdd = new StatsAccumulator ( ) ; for ( double value : MANY_VALUES ) { manyValuesAccumulatorByRepeatedAdd . add ( value ) ; } manyValuesAccumulatorByAddAndAddAll = new StatsAccumulator ( ) ; manyValuesAccumulatorByAddAndAddAll . add ( MANY_VALUES . get ( <int> ) ) ; manyValuesAccumulatorByAddAndAddAll . addAll ( MANY_VALUES . subList ( <int> , MANY_VALUES . size ( ) ) ) ; integerManyValuesAccumulatorByAddAllIterable = new StatsAccumulator ( ) ; integerManyValuesAccumulatorByAddAllIterable . addAll ( INTEGER_MANY_VALUES ) ; longManyValuesAccumulatorByAddAllIterator = new StatsAccumulator ( ) ; longManyValuesAccumulatorByAddAllIterator . addAll ( LONG_MANY_VALUES . iterator ( ) ) ; longManyValuesAccumulatorByAddAllVarargs = new StatsAccumulator ( ) ; longManyValuesAccumulatorByAddAllVarargs . addAll ( Longs . toArray ( LONG_MANY_VALUES ) ) ; } public void testCount ( ) { assertThat ( emptyAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( emptyAccumulatorByAddAllEmptyIterable . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( oneValueAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( twoValuesAccumulator . count ( ) ) . isEqualTo ( <int> ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . count ( ) ) . isEqualTo ( MANY_VALUES_COUNT ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . count ( ) ) . isEqualTo ( StatsTesting . INTEGER_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . count ( ) ) . isEqualTo ( StatsTesting . LONG_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . count ( ) ) . isEqualTo ( StatsTesting . LONG_MANY_VALUES_COUNT ) ; } public void testMean ( ) { try { emptyAccumulator . mean ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . mean ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( twoValuesAccumulator . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MEAN ) ; for ( ManyValues values : ALL_MANY_VALUES ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values . asIterable ( ) ) ; double mean = accumulator . mean ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) & & values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isPositiveInfinity ( ) ; } else if ( values . hasAnyNegativeInfinity ( ) ) { assertThat ( mean ) . named ( <str> + values ) . isNegativeInfinity ( ) ; } else { assertThat ( mean ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; } } assertThat ( manyValuesAccumulatorByAddAllIterator . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . mean ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN ) ; } public void testSum ( ) { assertThat ( emptyAccumulator . sum ( ) ) . isEqualTo ( <float> ) ; assertThat ( emptyAccumulatorByAddAllEmptyIterable . sum ( ) ) . isEqualTo ( <float> ) ; assertThat ( oneValueAccumulator . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( twoValuesAccumulator . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MEAN * <int> ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MEAN * MANY_VALUES_COUNT ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MEAN * INTEGER_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . sum ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MEAN * LONG_MANY_VALUES_COUNT ) ; } public void testPopulationVariance ( ) { try { emptyAccumulator . populationVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . populationVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . populationVariance ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( twoValuesAccumulator . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / <int> ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; for ( ManyValues values : ALL_MANY_VALUES ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values . asIterable ( ) . iterator ( ) ) ; double populationVariance = accumulator . populationVariance ( ) ; if ( values . hasAnyNonFinite ( ) ) { assertThat ( populationVariance ) . named ( <str> + values ) . isNaN ( ) ; } else { assertThat ( populationVariance ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; } } assertThat ( manyValuesAccumulatorByAddAllVarargs . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . populationVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ; } public void testPopulationStandardDeviation ( ) { try { emptyAccumulator . populationStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . populationStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . populationStandardDeviation ( ) ) . isWithin ( <float> ) . of ( <float> ) ; assertThat ( twoValuesAccumulator . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS / <int> ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / MANY_VALUES_COUNT ) ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / INTEGER_MANY_VALUES_COUNT ) ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . populationStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / LONG_MANY_VALUES_COUNT ) ) ; } public void testSampleVariance ( ) { try { emptyAccumulator . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { oneValueAccumulator . sampleVariance ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( twoValuesAccumulator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . sampleVariance ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ; } public void testSampleStandardDeviation ( ) { try { emptyAccumulator . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { oneValueAccumulator . sampleStandardDeviation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( twoValuesAccumulator . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( TWO_VALUES_SUM_OF_SQUARES_OF_DELTAS ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( manyValuesAccumulatorByRepeatedAdd . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( INTEGER_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( INTEGER_MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . sampleStandardDeviation ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( sqrt ( LONG_MANY_VALUES_SUM_OF_SQUARES_OF_DELTAS / ( LONG_MANY_VALUES_COUNT - <int> ) ) ) ; } public void testMax ( ) { try { emptyAccumulator . max ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . max ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( twoValuesAccumulator . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MAX ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; for ( ManyValues values : ALL_MANY_VALUES ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values . asArray ( ) ) ; double max = accumulator . max ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( max ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyPositiveInfinity ( ) ) { assertThat ( max ) . named ( <str> + values ) . isPositiveInfinity ( ) ; } else { assertThat ( max ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; } } assertThat ( manyValuesAccumulatorByRepeatedAdd . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; assertThat ( manyValuesAccumulatorByAddAndAddAll . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MAX ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MAX ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MAX ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . max ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MAX ) ; } public void testMin ( ) { try { emptyAccumulator . min ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } try { emptyAccumulatorByAddAllEmptyIterable . min ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertThat ( oneValueAccumulator . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( ONE_VALUE ) ; assertThat ( twoValuesAccumulator . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( TWO_VALUES_MIN ) ; assertThat ( manyValuesAccumulatorByAddAllIterable . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; assertThat ( manyValuesAccumulatorByAddAllIterator . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; assertThat ( manyValuesAccumulatorByAddAllVarargs . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; for ( ManyValues values : ALL_MANY_VALUES ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; for ( double value : values . asIterable ( ) ) { accumulator . add ( value ) ; } double min = accumulator . min ( ) ; if ( values . hasAnyNaN ( ) ) { assertThat ( min ) . named ( <str> + values ) . isNaN ( ) ; } else if ( values . hasAnyNegativeInfinity ( ) ) { assertThat ( min ) . named ( <str> + values ) . isNegativeInfinity ( ) ; } else { assertThat ( min ) . named ( <str> + values ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; } } assertThat ( manyValuesAccumulatorByAddAndAddAll . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( MANY_VALUES_MIN ) ; assertThat ( integerManyValuesAccumulatorByAddAllIterable . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( INTEGER_MANY_VALUES_MIN ) ; assertThat ( longManyValuesAccumulatorByAddAllIterator . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MIN ) ; assertThat ( longManyValuesAccumulatorByAddAllVarargs . min ( ) ) . isWithin ( ALLOWED_ERROR ) . of ( LONG_MANY_VALUES_MIN ) ; } } 
