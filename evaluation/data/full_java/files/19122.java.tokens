package io . netty . handler . codec . http . cookie ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import io . netty . handler . codec . http . HttpHeaderDateFormat ; import java . text . ParsePosition ; import java . util . Date ; public final class ClientCookieDecoder extends CookieDecoder { public static final ClientCookieDecoder STRICT = new ClientCookieDecoder ( true ) ; public static final ClientCookieDecoder LAX = new ClientCookieDecoder ( false ) ; private ClientCookieDecoder ( boolean strict ) { super ( strict ) ; } public Cookie decode ( String header ) { final int headerLen = checkNotNull ( header , <str> ) . length ( ) ; if ( headerLen = = <int> ) { return null ; } CookieBuilder cookieBuilder = null ; loop: for ( int i = <int> ; ; ) { for ( ; ; ) { if ( i = = headerLen ) { break loop ; } char c = header . charAt ( i ) ; if ( c = = <str> ) { break loop ; } else if ( c = = <str> | | c = = <str> | | c = = <hex> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> ) { i + + ; continue ; } break ; } int nameBegin = i ; int nameEnd = i ; int valueBegin = - <int> ; int valueEnd = - <int> ; if ( i ! = headerLen ) { keyValLoop : for ( ; ; ) { char curChar = header . charAt ( i ) ; if ( curChar = = <str> ) { nameEnd = i ; valueBegin = valueEnd = - <int> ; break keyValLoop ; } else if ( curChar = = <str> ) { nameEnd = i ; i + + ; if ( i = = headerLen ) { valueBegin = valueEnd = <int> ; break keyValLoop ; } valueBegin = i ; int semiPos = header . indexOf ( <str> , i ) ; valueEnd = i = semiPos > <int> ? semiPos : headerLen ; break keyValLoop ; } else { i + + ; } if ( i = = headerLen ) { nameEnd = headerLen ; valueBegin = valueEnd = - <int> ; break ; } } } if ( valueEnd > <int> & & header . charAt ( valueEnd - <int> ) = = <str> ) { valueEnd - - ; } if ( cookieBuilder = = null ) { DefaultCookie cookie = initCookie ( header , nameBegin , nameEnd , valueBegin , valueEnd ) ; if ( cookie = = null ) { return null ; } cookieBuilder = new CookieBuilder ( cookie , header ) ; } else { cookieBuilder . appendAttribute ( nameBegin , nameEnd , valueBegin , valueEnd ) ; } } return cookieBuilder . cookie ( ) ; } private static class CookieBuilder { private final String header ; private final DefaultCookie cookie ; private String domain ; private String path ; private long maxAge = Long . MIN_VALUE ; private int expiresStart ; private int expiresEnd ; private boolean secure ; private boolean httpOnly ; public CookieBuilder ( DefaultCookie cookie , String header ) { this . cookie = cookie ; this . header = header ; } private long mergeMaxAgeAndExpires ( ) { if ( maxAge ! = Long . MIN_VALUE ) { return maxAge ; } else { String expires = computeValue ( expiresStart , expiresEnd ) ; if ( expires ! = null ) { Date expiresDate = HttpHeaderDateFormat . get ( ) . parse ( expires , new ParsePosition ( <int> ) ) ; if ( expiresDate ! = null ) { long maxAgeMillis = expiresDate . getTime ( ) - System . currentTimeMillis ( ) ; return maxAgeMillis / <int> + ( maxAgeMillis % <int> ! = <int> ? <int> : <int> ) ; } } } return Long . MIN_VALUE ; } public Cookie cookie ( ) { cookie . setDomain ( domain ) ; cookie . setPath ( path ) ; cookie . setMaxAge ( mergeMaxAgeAndExpires ( ) ) ; cookie . setSecure ( secure ) ; cookie . setHttpOnly ( httpOnly ) ; return cookie ; } public void appendAttribute ( int keyStart , int keyEnd , int valueStart , int valueEnd ) { int length = keyEnd - keyStart ; if ( length = = <int> ) { parse4 ( keyStart , valueStart , valueEnd ) ; } else if ( length = = <int> ) { parse6 ( keyStart , valueStart , valueEnd ) ; } else if ( length = = <int> ) { parse7 ( keyStart , valueStart , valueEnd ) ; } else if ( length = = <int> ) { parse8 ( keyStart , valueStart , valueEnd ) ; } } private void parse4 ( int nameStart , int valueStart , int valueEnd ) { if ( header . regionMatches ( true , nameStart , CookieHeaderNames . PATH , <int> , <int> ) ) { path = computeValue ( valueStart , valueEnd ) ; } } private void parse6 ( int nameStart , int valueStart , int valueEnd ) { if ( header . regionMatches ( true , nameStart , CookieHeaderNames . DOMAIN , <int> , <int> ) ) { domain = computeValue ( valueStart , valueEnd ) ; } else if ( header . regionMatches ( true , nameStart , CookieHeaderNames . SECURE , <int> , <int> ) ) { secure = true ; } } private void setMaxAge ( String value ) { try { maxAge = Math . max ( Long . valueOf ( value ) , <int> L ) ; } catch ( NumberFormatException e1 ) { } } private void parse7 ( int nameStart , int valueStart , int valueEnd ) { if ( header . regionMatches ( true , nameStart , CookieHeaderNames . EXPIRES , <int> , <int> ) ) { expiresStart = valueStart ; expiresEnd = valueEnd ; } else if ( header . regionMatches ( true , nameStart , CookieHeaderNames . MAX_AGE , <int> , <int> ) ) { setMaxAge ( computeValue ( valueStart , valueEnd ) ) ; } } private void parse8 ( int nameStart , int valueStart , int valueEnd ) { if ( header . regionMatches ( true , nameStart , CookieHeaderNames . HTTPONLY , <int> , <int> ) ) { httpOnly = true ; } } private String computeValue ( int valueStart , int valueEnd ) { return valueStart = = - <int> | | valueStart = = valueEnd ? null : header . substring ( valueStart , valueEnd ) ; } } } 
