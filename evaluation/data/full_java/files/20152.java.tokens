package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandler . Sharable ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . ssl . OpenSsl ; import io . netty . handler . ssl . OpenSslContext ; import io . netty . handler . ssl . SslContext ; import io . netty . handler . ssl . SslContextBuilder ; import io . netty . handler . ssl . SslHandler ; import io . netty . handler . ssl . SslHandshakeCompletionEvent ; import io . netty . handler . ssl . SslProvider ; import io . netty . handler . ssl . util . SelfSignedCertificate ; import io . netty . handler . stream . ChunkedWriteHandler ; import io . netty . testsuite . util . TestUtils ; import io . netty . util . concurrent . Future ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . AfterClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . junit . runners . Parameterized ; import org . junit . runners . Parameterized . Parameters ; import javax . net . ssl . SSLEngine ; import java . io . File ; import java . io . IOException ; import java . security . cert . CertificateException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Random ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . sameInstance ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertThat ; @RunWith ( Parameterized . class ) public class SocketSslEchoTest extends AbstractSocketTest { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( SocketSslEchoTest . class ) ; private static final int FIRST_MESSAGE_SIZE = <int> ; private static final Random random = new Random ( ) ; private static final File CERT_FILE ; private static final File KEY_FILE ; static final byte [ ] data = new byte [ <int> ] ; static { random . nextBytes ( data ) ; SelfSignedCertificate ssc ; try { ssc = new SelfSignedCertificate ( ) ; } catch ( CertificateException e ) { throw new Error ( e ) ; } CERT_FILE = ssc . certificate ( ) ; KEY_FILE = ssc . privateKey ( ) ; } protected enum RenegotiationType { NONE , CLIENT_INITIATED , SERVER_INITIATED , } protected static class Renegotiation { static final Renegotiation NONE = new Renegotiation ( RenegotiationType . NONE , null ) ; final RenegotiationType type ; final String cipherSuite ; Renegotiation ( RenegotiationType type , String cipherSuite ) { this . type = type ; this . cipherSuite = cipherSuite ; } @Override public String toString ( ) { if ( type = = RenegotiationType . NONE ) { return <str> ; } return type + <str> + cipherSuite + <str> ; } } @Parameters ( name = <str> + <str> + <str> ) public static Collection < Object [ ] > data ( ) throws Exception { List < SslContext > serverContexts = new ArrayList < SslContext > ( ) ; serverContexts . add ( SslContextBuilder . forServer ( CERT_FILE , KEY_FILE ) . sslProvider ( SslProvider . JDK ) . build ( ) ) ; List < SslContext > clientContexts = new ArrayList < SslContext > ( ) ; clientContexts . add ( SslContextBuilder . forClient ( ) . sslProvider ( SslProvider . JDK ) . trustManager ( CERT_FILE ) . build ( ) ) ; boolean hasOpenSsl = OpenSsl . isAvailable ( ) ; if ( hasOpenSsl ) { serverContexts . add ( SslContextBuilder . forServer ( CERT_FILE , KEY_FILE ) . sslProvider ( SslProvider . OPENSSL ) . build ( ) ) ; clientContexts . add ( SslContextBuilder . forClient ( ) . sslProvider ( SslProvider . OPENSSL ) . trustManager ( CERT_FILE ) . build ( ) ) ; } else { logger . warn ( <str> , OpenSsl . unavailabilityCause ( ) ) ; } List < Object [ ] > params = new ArrayList < Object [ ] > ( ) ; for ( SslContext sc : serverContexts ) { for ( SslContext cc : clientContexts ) { for ( RenegotiationType rt : RenegotiationType . values ( ) ) { if ( rt ! = RenegotiationType . NONE & & ( sc instanceof OpenSslContext | | cc instanceof OpenSslContext ) ) { continue ; } Renegotiation r ; if ( rt = = RenegotiationType . NONE ) { r = Renegotiation . NONE ; } else { r = new Renegotiation ( rt , <str> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { params . add ( new Object [ ] { sc , cc , r , ( i & <int> ) ! = <int> , ( i & <int> ) ! = <int> , ( i & <int> ) ! = <int> , ( i & <int> ) ! = <int> , ( i & <int> ) ! = <int> } ) ; } } } } return params ; } private final SslContext serverCtx ; private final SslContext clientCtx ; private final Renegotiation renegotiation ; private final boolean serverUsesDelegatedTaskExecutor ; private final boolean clientUsesDelegatedTaskExecutor ; private final boolean autoRead ; private final boolean useChunkedWriteHandler ; private final boolean useCompositeByteBuf ; private final AtomicReference < Throwable > clientException = new AtomicReference < Throwable > ( ) ; private final AtomicReference < Throwable > serverException = new AtomicReference < Throwable > ( ) ; private final AtomicInteger clientSendCounter = new AtomicInteger ( ) ; private final AtomicInteger clientRecvCounter = new AtomicInteger ( ) ; private final AtomicInteger serverRecvCounter = new AtomicInteger ( ) ; private final AtomicInteger clientNegoCounter = new AtomicInteger ( ) ; private final AtomicInteger serverNegoCounter = new AtomicInteger ( ) ; private volatile Channel clientChannel ; private volatile Channel serverChannel ; private volatile SslHandler clientSslHandler ; private volatile SslHandler serverSslHandler ; private final EchoClientHandler clientHandler = new EchoClientHandler ( clientRecvCounter , clientNegoCounter , clientException ) ; private final EchoServerHandler serverHandler = new EchoServerHandler ( serverRecvCounter , serverNegoCounter , serverException ) ; public SocketSslEchoTest ( SslContext serverCtx , SslContext clientCtx , Renegotiation renegotiation , boolean serverUsesDelegatedTaskExecutor , boolean clientUsesDelegatedTaskExecutor , boolean autoRead , boolean useChunkedWriteHandler , boolean useCompositeByteBuf ) { this . serverCtx = serverCtx ; this . clientCtx = clientCtx ; this . serverUsesDelegatedTaskExecutor = serverUsesDelegatedTaskExecutor ; this . clientUsesDelegatedTaskExecutor = clientUsesDelegatedTaskExecutor ; this . renegotiation = renegotiation ; this . autoRead = autoRead ; this . useChunkedWriteHandler = useChunkedWriteHandler ; this . useCompositeByteBuf = useCompositeByteBuf ; } @Test ( timeout = <int> ) public void testSslEcho ( ) throws Throwable { run ( ) ; } @AfterClass public static void compressHeapDumps ( ) throws Exception { TestUtils . compressHeapDumps ( ) ; } public void testSslEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { final ExecutorService delegatedTaskExecutor = Executors . newCachedThreadPool ( ) ; reset ( ) ; sb . childOption ( ChannelOption . AUTO_READ , autoRead ) ; cb . option ( ChannelOption . AUTO_READ , autoRead ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override @SuppressWarnings ( <str> ) public void initChannel ( Channel sch ) throws Exception { serverChannel = sch ; if ( serverUsesDelegatedTaskExecutor ) { SSLEngine sse = serverCtx . newEngine ( sch . alloc ( ) ) ; serverSslHandler = new SslHandler ( sse , delegatedTaskExecutor ) ; } else { serverSslHandler = serverCtx . newHandler ( sch . alloc ( ) ) ; } sch . pipeline ( ) . addLast ( <str> , serverSslHandler ) ; if ( useChunkedWriteHandler ) { sch . pipeline ( ) . addLast ( new ChunkedWriteHandler ( ) ) ; } sch . pipeline ( ) . addLast ( <str> , serverHandler ) ; } } ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override @SuppressWarnings ( <str> ) public void initChannel ( Channel sch ) throws Exception { clientChannel = sch ; if ( clientUsesDelegatedTaskExecutor ) { SSLEngine cse = clientCtx . newEngine ( sch . alloc ( ) ) ; clientSslHandler = new SslHandler ( cse , delegatedTaskExecutor ) ; } else { clientSslHandler = clientCtx . newHandler ( sch . alloc ( ) ) ; } sch . pipeline ( ) . addLast ( <str> , clientSslHandler ) ; if ( useChunkedWriteHandler ) { sch . pipeline ( ) . addLast ( new ChunkedWriteHandler ( ) ) ; } sch . pipeline ( ) . addLast ( <str> , clientHandler ) ; } } ) ; final Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; cb . connect ( ) . sync ( ) ; final Future < Channel > clientHandshakeFuture = clientSslHandler . handshakeFuture ( ) ; clientChannel . writeAndFlush ( Unpooled . wrappedBuffer ( data , <int> , FIRST_MESSAGE_SIZE ) ) ; clientSendCounter . set ( FIRST_MESSAGE_SIZE ) ; clientHandshakeFuture . sync ( ) ; boolean needsRenegotiation = renegotiation . type = = RenegotiationType . CLIENT_INITIATED ; Future < Channel > renegoFuture = null ; while ( clientSendCounter . get ( ) < data . length ) { int clientSendCounterVal = clientSendCounter . get ( ) ; int length = Math . min ( random . nextInt ( <int> * <int> ) , data . length - clientSendCounterVal ) ; ByteBuf buf = Unpooled . wrappedBuffer ( data , clientSendCounterVal , length ) ; if ( useCompositeByteBuf ) { buf = Unpooled . compositeBuffer ( ) . addComponent ( buf ) . writerIndex ( buf . writerIndex ( ) ) ; } ChannelFuture future = clientChannel . writeAndFlush ( buf ) ; clientSendCounter . set ( clientSendCounterVal + = length ) ; future . sync ( ) ; if ( needsRenegotiation & & clientSendCounterVal > = data . length / <int> ) { needsRenegotiation = false ; clientSslHandler . engine ( ) . setEnabledCipherSuites ( new String [ ] { renegotiation . cipherSuite } ) ; renegoFuture = clientSslHandler . renegotiate ( ) ; logStats ( <str> ) ; assertThat ( renegoFuture , is ( not ( sameInstance ( clientHandshakeFuture ) ) ) ) ; } } while ( clientRecvCounter . get ( ) < data . length ) { if ( serverException . get ( ) ! = null ) { break ; } if ( serverException . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } while ( serverRecvCounter . get ( ) < data . length ) { if ( serverException . get ( ) ! = null ) { break ; } if ( clientException . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } if ( renegoFuture ! = null ) { renegoFuture . sync ( ) ; } if ( serverHandler . renegoFuture ! = null ) { serverHandler . renegoFuture . sync ( ) ; } serverChannel . close ( ) . awaitUninterruptibly ( ) ; clientChannel . close ( ) . awaitUninterruptibly ( ) ; sc . close ( ) . awaitUninterruptibly ( ) ; delegatedTaskExecutor . shutdown ( ) ; if ( serverException . get ( ) ! = null & & ! ( serverException . get ( ) instanceof IOException ) ) { throw serverException . get ( ) ; } if ( clientException . get ( ) ! = null & & ! ( clientException . get ( ) instanceof IOException ) ) { throw clientException . get ( ) ; } if ( serverException . get ( ) ! = null ) { throw serverException . get ( ) ; } if ( clientException . get ( ) ! = null ) { throw clientException . get ( ) ; } try { switch ( renegotiation . type ) { case SERVER_INITIATED : assertThat ( serverSslHandler . engine ( ) . getSession ( ) . getCipherSuite ( ) , is ( renegotiation . cipherSuite ) ) ; assertThat ( serverNegoCounter . get ( ) , is ( <int> ) ) ; assertThat ( clientNegoCounter . get ( ) , anyOf ( is ( <int> ) , is ( <int> ) ) ) ; break ; case CLIENT_INITIATED : assertThat ( serverNegoCounter . get ( ) , anyOf ( is ( <int> ) , is ( <int> ) ) ) ; assertThat ( clientSslHandler . engine ( ) . getSession ( ) . getCipherSuite ( ) , is ( renegotiation . cipherSuite ) ) ; assertThat ( clientNegoCounter . get ( ) , is ( <int> ) ) ; break ; case NONE : assertThat ( serverNegoCounter . get ( ) , is ( <int> ) ) ; assertThat ( clientNegoCounter . get ( ) , is ( <int> ) ) ; } } finally { logStats ( <str> ) ; } } private void reset ( ) { clientException . set ( null ) ; serverException . set ( null ) ; clientSendCounter . set ( <int> ) ; clientRecvCounter . set ( <int> ) ; serverRecvCounter . set ( <int> ) ; clientNegoCounter . set ( <int> ) ; serverNegoCounter . set ( <int> ) ; clientChannel = null ; serverChannel = null ; clientSslHandler = null ; serverSslHandler = null ; } void logStats ( String message ) { logger . debug ( <str> + <str> + <str> , message , clientSendCounter , clientRecvCounter , clientNegoCounter , clientSslHandler . engine ( ) . getSession ( ) . getCipherSuite ( ) , serverRecvCounter , serverNegoCounter , serverSslHandler . engine ( ) . getSession ( ) . getCipherSuite ( ) ) ; } @Sharable private abstract class EchoHandler extends SimpleChannelInboundHandler < ByteBuf > { protected final AtomicInteger recvCounter ; protected final AtomicInteger negoCounter ; protected final AtomicReference < Throwable > exception ; EchoHandler ( AtomicInteger recvCounter , AtomicInteger negoCounter , AtomicReference < Throwable > exception ) { this . recvCounter = recvCounter ; this . negoCounter = negoCounter ; this . exception = exception ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { if ( ! autoRead ) { ctx . read ( ) ; } } @Override public final void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { try { ctx . flush ( ) ; } finally { if ( ! autoRead ) { ctx . read ( ) ; } } } @Override public final void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof SslHandshakeCompletionEvent ) { SslHandshakeCompletionEvent handshakeEvt = ( SslHandshakeCompletionEvent ) evt ; if ( handshakeEvt . cause ( ) ! = null ) { logger . warn ( <str> , handshakeEvt . cause ( ) ) ; } assertSame ( SslHandshakeCompletionEvent . SUCCESS , evt ) ; negoCounter . incrementAndGet ( ) ; logStats ( <str> ) ; } } @Override public final void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , cause ) ; } exception . compareAndSet ( null , cause ) ; ctx . close ( ) ; } } private class EchoClientHandler extends EchoHandler { EchoClientHandler ( AtomicInteger recvCounter , AtomicInteger negoCounter , AtomicReference < Throwable > exception ) { super ( recvCounter , negoCounter , exception ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { byte [ ] actual = new byte [ in . readableBytes ( ) ] ; in . readBytes ( actual ) ; int lastIdx = recvCounter . get ( ) ; for ( int i = <int> ; i < actual . length ; i + + ) { assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; } recvCounter . addAndGet ( actual . length ) ; } } private class EchoServerHandler extends EchoHandler { volatile Future < Channel > renegoFuture ; EchoServerHandler ( AtomicInteger recvCounter , AtomicInteger negoCounter , AtomicReference < Throwable > exception ) { super ( recvCounter , negoCounter , exception ) ; } @Override public final void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { renegoFuture = null ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { byte [ ] actual = new byte [ in . readableBytes ( ) ] ; in . readBytes ( actual ) ; int lastIdx = recvCounter . get ( ) ; for ( int i = <int> ; i < actual . length ; i + + ) { assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; } ByteBuf buf = Unpooled . wrappedBuffer ( actual ) ; if ( useCompositeByteBuf ) { buf = Unpooled . compositeBuffer ( ) . addComponent ( buf ) . writerIndex ( buf . writerIndex ( ) ) ; } ctx . write ( buf ) ; recvCounter . addAndGet ( actual . length ) ; if ( renegotiation . type = = RenegotiationType . SERVER_INITIATED & & recvCounter . get ( ) > data . length / <int> & & renegoFuture = = null ) { SslHandler sslHandler = ctx . pipeline ( ) . get ( SslHandler . class ) ; Future < Channel > hf = sslHandler . handshakeFuture ( ) ; assertThat ( hf . isDone ( ) , is ( true ) ) ; sslHandler . engine ( ) . setEnabledCipherSuites ( new String [ ] { renegotiation . cipherSuite } ) ; logStats ( <str> ) ; renegoFuture = sslHandler . renegotiate ( ) ; assertThat ( renegoFuture , is ( not ( sameInstance ( hf ) ) ) ) ; assertThat ( renegoFuture , is ( sameInstance ( sslHandler . handshakeFuture ( ) ) ) ) ; assertThat ( renegoFuture . isDone ( ) , is ( false ) ) ; } } } } 
