package org . apache . cassandra . io . compress ; import java . io . * ; import java . nio . ByteBuffer ; import java . util . concurrent . ThreadLocalRandom ; import java . util . zip . Checksum ; import java . util . function . Supplier ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . primitives . Ints ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . util . * ; import org . apache . cassandra . utils . memory . BufferPool ; public class CompressedRandomAccessReader extends RandomAccessReader { private final CompressionMetadata metadata ; private ByteBuffer compressed ; private final Checksum checksum ; private ByteBuffer checksumBytes ; @VisibleForTesting public double getCrcCheckChance ( ) { return metadata . parameters . getCrcCheckChance ( ) ; } protected CompressedRandomAccessReader ( Builder builder ) { super ( builder ) ; this . metadata = builder . metadata ; this . checksum = metadata . checksumType . newInstance ( ) ; if ( regions = = null ) { compressed = allocateBuffer ( metadata . compressor ( ) . initialCompressedBufferLength ( metadata . chunkLength ( ) ) , bufferType ) ; checksumBytes = ByteBuffer . wrap ( new byte [ <int> ] ) ; } } @Override protected void releaseBuffer ( ) { try { if ( buffer ! = null ) { BufferPool . put ( buffer ) ; buffer = null ; } } finally { if ( compressed ! = null ) { BufferPool . put ( compressed ) ; compressed = null ; } } } @Override protected void reBufferStandard ( ) { try { long position = current ( ) ; assert position < metadata . dataLength ; CompressionMetadata . Chunk chunk = metadata . chunkFor ( position ) ; if ( compressed . capacity ( ) < chunk . length ) { BufferPool . put ( compressed ) ; compressed = allocateBuffer ( chunk . length , bufferType ) ; } else { compressed . clear ( ) ; } compressed . limit ( chunk . length ) ; if ( channel . read ( compressed , chunk . offset ) ! = chunk . length ) throw new CorruptBlockException ( getPath ( ) , chunk ) ; compressed . flip ( ) ; buffer . clear ( ) ; try { metadata . compressor ( ) . uncompress ( compressed , buffer ) ; } catch ( IOException e ) { throw new CorruptBlockException ( getPath ( ) , chunk ) ; } finally { buffer . flip ( ) ; } if ( getCrcCheckChance ( ) > ThreadLocalRandom . current ( ) . nextDouble ( ) ) { compressed . rewind ( ) ; metadata . checksumType . update ( checksum , ( compressed ) ) ; if ( checksum ( chunk ) ! = ( int ) checksum . getValue ( ) ) throw new CorruptBlockException ( getPath ( ) , chunk ) ; checksum . reset ( ) ; } bufferOffset = position & ~ ( buffer . capacity ( ) - <int> ) ; buffer . position ( ( int ) ( position - bufferOffset ) ) ; if ( bufferOffset + buffer . limit ( ) > length ( ) ) buffer . limit ( ( int ) ( length ( ) - bufferOffset ) ) ; } catch ( CorruptBlockException e ) { throw new CorruptSSTableException ( e , getPath ( ) ) ; } catch ( IOException e ) { throw new FSReadError ( e , getPath ( ) ) ; } } @Override protected void reBufferMmap ( ) { try { long position = current ( ) ; assert position < metadata . dataLength ; CompressionMetadata . Chunk chunk = metadata . chunkFor ( position ) ; MmappedRegions . Region region = regions . floor ( chunk . offset ) ; long segmentOffset = region . bottom ( ) ; int chunkOffset = Ints . checkedCast ( chunk . offset - segmentOffset ) ; ByteBuffer compressedChunk = region . buffer . duplicate ( ) ; compressedChunk . position ( chunkOffset ) . limit ( chunkOffset + chunk . length ) ; buffer . clear ( ) ; try { metadata . compressor ( ) . uncompress ( compressedChunk , buffer ) ; } catch ( IOException e ) { throw new CorruptBlockException ( getPath ( ) , chunk ) ; } finally { buffer . flip ( ) ; } if ( getCrcCheckChance ( ) > ThreadLocalRandom . current ( ) . nextDouble ( ) ) { compressedChunk . position ( chunkOffset ) . limit ( chunkOffset + chunk . length ) ; metadata . checksumType . update ( checksum , compressedChunk ) ; compressedChunk . limit ( compressedChunk . capacity ( ) ) ; if ( compressedChunk . getInt ( ) ! = ( int ) checksum . getValue ( ) ) throw new CorruptBlockException ( getPath ( ) , chunk ) ; checksum . reset ( ) ; } bufferOffset = position & ~ ( buffer . capacity ( ) - <int> ) ; buffer . position ( ( int ) ( position - bufferOffset ) ) ; if ( bufferOffset + buffer . limit ( ) > length ( ) ) buffer . limit ( ( int ) ( length ( ) - bufferOffset ) ) ; } catch ( CorruptBlockException e ) { throw new CorruptSSTableException ( e , getPath ( ) ) ; } } private int checksum ( CompressionMetadata . Chunk chunk ) throws IOException { long position = chunk . offset + chunk . length ; checksumBytes . clear ( ) ; if ( channel . read ( checksumBytes , position ) ! = checksumBytes . capacity ( ) ) throw new CorruptBlockException ( getPath ( ) , chunk ) ; return checksumBytes . getInt ( <int> ) ; } @Override public long length ( ) { return metadata . dataLength ; } @Override public String toString ( ) { return String . format ( <str> , getPath ( ) , metadata . chunkLength ( ) , metadata . dataLength ) ; } public final static class Builder extends RandomAccessReader . Builder { private final CompressionMetadata metadata ; public Builder ( ICompressedFile file ) { super ( file . channel ( ) ) ; this . metadata = applyMetadata ( file . getMetadata ( ) ) ; this . regions = file . regions ( ) ; } public Builder ( ChannelProxy channel , CompressionMetadata metadata ) { super ( channel ) ; this . metadata = applyMetadata ( metadata ) ; } private CompressionMetadata applyMetadata ( CompressionMetadata metadata ) { this . overrideLength = metadata . compressedFileLength ; this . bufferSize = metadata . chunkLength ( ) ; this . bufferType = metadata . compressor ( ) . preferredBufferType ( ) ; assert Integer . bitCount ( this . bufferSize ) = = <int> ; return metadata ; } @Override protected ByteBuffer createBuffer ( ) { buffer = allocateBuffer ( bufferSize , bufferType ) ; buffer . limit ( <int> ) ; return buffer ; } @Override public RandomAccessReader build ( ) { return new CompressedRandomAccessReader ( this ) ; } } } 
