package org . eclipse . debug . tests . viewer . model ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . test . performance . Performance ; import org . eclipse . test . performance . PerformanceMeter ; import org . eclipse . ui . PlatformUI ; abstract public class PerformanceTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public PerformanceTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fVirtualItemValidator = new VisibleVirtualItemValidator ( <int> , Integer . MAX_VALUE ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } abstract protected IInternalTreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } abstract protected int getTestModelDepth ( ) ; protected VisibleVirtualItemValidator fVirtualItemValidator ; public void testRefreshStruct ( ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeMultiLevelElements ( model , getTestModelDepth ( ) , <str> ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setAllAppendix ( <str> + i ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( TreePath . EMPTY , element , - <int> , false , false ) ; meter . start ( ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } public void testRefreshStruct2 ( ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeMultiLevelElements2 ( model , new int [ ] { <int> , <int> , <int> } , <str> ) ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fVirtualItemValidator . setVisibleRange ( <int> , <int> ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setAllAppendix ( <str> + i ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( ) ; meter . start ( ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } public void testRefreshStructReplaceElements ( ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeMultiLevelElements ( model , getTestModelDepth ( ) , <str> ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setElementChildren ( TreePath . EMPTY , TestModel . makeMultiLevelElements ( model , getTestModelDepth ( ) , <str> + i + <str> ) ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( TreePath . EMPTY , element , - <int> , false , false ) ; meter . start ( ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } public void testRefreshList ( ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; int numElements = ( int ) Math . pow ( <int> , getTestModelDepth ( ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeSingleLevelModelElements ( model , numElements , <str> ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setAllAppendix ( <str> + i ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( TreePath . EMPTY , element , - <int> , false , false ) ; meter . start ( ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } public void testSaveAndRestore ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; fViewer . setSelection ( new TreeSelection ( model . findElement ( <str> ) ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setAllAppendix ( <str> + i ) ; fListener . reset ( true , false ) ; meter . start ( ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } public void testRefreshListFiltered ( ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; int numElements = ( int ) Math . pow ( <int> , getTestModelDepth ( ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeSingleLevelModelElements ( model , numElements , <str> ) ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . addFilter ( new ViewerFilter ( ) { @Override public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( element instanceof TestElement ) { String id = ( ( TestElement ) element ) . getID ( ) ; if ( id . startsWith ( <str> ) ) { id = id . substring ( <str> . length ( ) ) ; } if ( id . length ( ) > = <int> & & ( id . charAt ( <int> ) = = <str> | | id . charAt ( <int> ) = = <str> | | id . charAt ( <int> ) = = <str> | | id . charAt ( <int> ) = = <str> | | id . charAt ( <int> ) = = <str> ) ) { return false ; } } return true ; } } ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; Performance perf = Performance . getDefault ( ) ; PerformanceMeter meter = perf . createPerformanceMeter ( perf . getDefaultScenarioId ( this ) ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { model . setAllAppendix ( <str> + i ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( TreePath . EMPTY , element , - <int> , false , false ) ; meter . start ( ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } meter . stop ( ) ; System . gc ( ) ; } meter . commit ( ) ; perf . assertPerformance ( meter ) ; } finally { meter . dispose ( ) ; } } } 
