package org . apache . lucene . search . vectorhighlight ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . BlendedTermQuery ; import org . apache . lucene . search . * ; import org . apache . lucene . search . spans . SpanTermQuery ; import org . elasticsearch . common . lucene . search . MultiPhrasePrefixQuery ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . FunctionScoreQuery ; import java . io . IOException ; import java . util . Collection ; import java . util . List ; public class CustomFieldQuery extends FieldQuery { public static final ThreadLocal < Boolean > highlightFilters = new ThreadLocal < > ( ) ; public CustomFieldQuery ( Query query , IndexReader reader , FastVectorHighlighter highlighter ) throws IOException { this ( query , reader , highlighter . isPhraseHighlight ( ) , highlighter . isFieldMatch ( ) ) ; } public CustomFieldQuery ( Query query , IndexReader reader , boolean phraseHighlight , boolean fieldMatch ) throws IOException { super ( query , reader , phraseHighlight , fieldMatch ) ; highlightFilters . remove ( ) ; } @Override void flatten ( Query sourceQuery , IndexReader reader , Collection < Query > flatQueries , float boost ) throws IOException { if ( sourceQuery instanceof SpanTermQuery ) { super . flatten ( new TermQuery ( ( ( SpanTermQuery ) sourceQuery ) . getTerm ( ) ) , reader , flatQueries , boost ) ; } else if ( sourceQuery instanceof ConstantScoreQuery ) { flatten ( ( ( ConstantScoreQuery ) sourceQuery ) . getQuery ( ) , reader , flatQueries , boost ) ; } else if ( sourceQuery instanceof FunctionScoreQuery ) { flatten ( ( ( FunctionScoreQuery ) sourceQuery ) . getSubQuery ( ) , reader , flatQueries , boost ) ; } else if ( sourceQuery instanceof MultiPhrasePrefixQuery ) { flatten ( sourceQuery . rewrite ( reader ) , reader , flatQueries , boost ) ; } else if ( sourceQuery instanceof FiltersFunctionScoreQuery ) { flatten ( ( ( FiltersFunctionScoreQuery ) sourceQuery ) . getSubQuery ( ) , reader , flatQueries , boost ) ; } else if ( sourceQuery instanceof MultiPhraseQuery ) { MultiPhraseQuery q = ( ( MultiPhraseQuery ) sourceQuery ) ; convertMultiPhraseQuery ( <int> , new int [ q . getTermArrays ( ) . size ( ) ] , q , q . getTermArrays ( ) , q . getPositions ( ) , reader , flatQueries ) ; } else if ( sourceQuery instanceof BlendedTermQuery ) { final BlendedTermQuery blendedTermQuery = ( BlendedTermQuery ) sourceQuery ; flatten ( blendedTermQuery . rewrite ( reader ) , reader , flatQueries , boost ) ; } else { super . flatten ( sourceQuery , reader , flatQueries , boost ) ; } } private void convertMultiPhraseQuery ( int currentPos , int [ ] termsIdx , MultiPhraseQuery orig , List < Term [ ] > terms , int [ ] pos , IndexReader reader , Collection < Query > flatQueries ) throws IOException { if ( currentPos = = <int> ) { int numTerms = <int> ; for ( Term [ ] currentPosTerm : terms ) { numTerms + = currentPosTerm . length ; } if ( numTerms > <int> ) { for ( Term [ ] currentPosTerm : terms ) { for ( Term term : currentPosTerm ) { super . flatten ( new TermQuery ( term ) , reader , flatQueries , orig . getBoost ( ) ) ; } } return ; } } if ( currentPos = = terms . size ( ) ) { PhraseQuery . Builder queryBuilder = new PhraseQuery . Builder ( ) ; queryBuilder . setSlop ( orig . getSlop ( ) ) ; for ( int i = <int> ; i < termsIdx . length ; i + + ) { queryBuilder . add ( terms . get ( i ) [ termsIdx [ i ] ] , pos [ i ] ) ; } Query query = queryBuilder . build ( ) ; this . flatten ( query , reader , flatQueries , orig . getBoost ( ) ) ; } else { Term [ ] t = terms . get ( currentPos ) ; for ( int i = <int> ; i < t . length ; i + + ) { termsIdx [ currentPos ] = i ; convertMultiPhraseQuery ( currentPos + <int> , termsIdx , orig , terms , pos , reader , flatQueries ) ; } } } } 
