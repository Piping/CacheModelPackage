package org . apache . cassandra . io . util ; import java . io . DataInput ; import java . io . DataOutput ; import java . io . File ; import java . io . IOException ; import java . util . function . Supplier ; import com . google . common . util . concurrent . RateLimiter ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . compress . CompressedSequentialWriter ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . IndexSummary ; import org . apache . cassandra . io . sstable . IndexSummaryBuilder ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . utils . CLibrary ; import org . apache . cassandra . utils . concurrent . RefCounted ; import org . apache . cassandra . utils . concurrent . SharedCloseableImpl ; import static org . apache . cassandra . utils . Throwables . maybeFail ; public abstract class SegmentedFile extends SharedCloseableImpl { public final ChannelProxy channel ; public final int bufferSize ; public final long length ; public final long onDiskLength ; SegmentedFile ( Cleanup cleanup , ChannelProxy channel , int bufferSize , long length ) { this ( cleanup , channel , bufferSize , length , length ) ; } protected SegmentedFile ( Cleanup cleanup , ChannelProxy channel , int bufferSize , long length , long onDiskLength ) { super ( cleanup ) ; this . channel = channel ; this . bufferSize = bufferSize ; this . length = length ; this . onDiskLength = onDiskLength ; } protected SegmentedFile ( SegmentedFile copy ) { super ( copy ) ; channel = copy . channel ; bufferSize = copy . bufferSize ; length = copy . length ; onDiskLength = copy . onDiskLength ; } public String path ( ) { return channel . filePath ( ) ; } protected static class Cleanup implements RefCounted . Tidy { final ChannelProxy channel ; protected Cleanup ( ChannelProxy channel ) { this . channel = channel ; } public String name ( ) { return channel . filePath ( ) ; } public void tidy ( ) { channel . close ( ) ; } } public abstract SegmentedFile sharedCopy ( ) ; public RandomAccessReader createReader ( ) { return new RandomAccessReader . Builder ( channel ) . overrideLength ( length ) . bufferSize ( bufferSize ) . build ( ) ; } public RandomAccessReader createReader ( RateLimiter limiter ) { return new RandomAccessReader . Builder ( channel ) . overrideLength ( length ) . bufferSize ( bufferSize ) . limiter ( limiter ) . build ( ) ; } public FileDataInput createReader ( long position ) { RandomAccessReader reader = createReader ( ) ; reader . seek ( position ) ; return reader ; } public void dropPageCache ( long before ) { CLibrary . trySkipCache ( channel . getFileDescriptor ( ) , <int> , before , path ( ) ) ; } public static Builder getBuilder ( Config . DiskAccessMode mode , boolean compressed ) { return compressed ? new CompressedSegmentedFile . Builder ( null ) : mode = = Config . DiskAccessMode . mmap ? new MmappedSegmentedFile . Builder ( ) : new BufferedSegmentedFile . Builder ( ) ; } public static Builder getCompressedBuilder ( CompressedSequentialWriter writer ) { return new CompressedSegmentedFile . Builder ( writer ) ; } public static abstract class Builder implements AutoCloseable { private ChannelProxy channel ; protected abstract SegmentedFile complete ( ChannelProxy channel , int bufferSize , long overrideLength ) ; @SuppressWarnings ( <str> ) private SegmentedFile complete ( String path , int bufferSize , long overrideLength ) { ChannelProxy channelCopy = getChannel ( path ) ; try { return complete ( channelCopy , bufferSize , overrideLength ) ; } catch ( Throwable t ) { channelCopy . close ( ) ; throw t ; } } public SegmentedFile buildData ( Descriptor desc , StatsMetadata stats , IndexSummaryBuilder . ReadableBoundary boundary ) { return complete ( desc . filenameFor ( Component . DATA ) , bufferSize ( stats ) , boundary . dataLength ) ; } public SegmentedFile buildData ( Descriptor desc , StatsMetadata stats ) { return complete ( desc . filenameFor ( Component . DATA ) , bufferSize ( stats ) , - <int> ) ; } public SegmentedFile buildIndex ( Descriptor desc , IndexSummary indexSummary , IndexSummaryBuilder . ReadableBoundary boundary ) { return complete ( desc . filenameFor ( Component . PRIMARY_INDEX ) , bufferSize ( desc , indexSummary ) , boundary . indexLength ) ; } public SegmentedFile buildIndex ( Descriptor desc , IndexSummary indexSummary ) { return complete ( desc . filenameFor ( Component . PRIMARY_INDEX ) , bufferSize ( desc , indexSummary ) , - <int> ) ; } private static int bufferSize ( StatsMetadata stats ) { return bufferSize ( stats . estimatedPartitionSize . percentile ( DatabaseDescriptor . getDiskOptimizationEstimatePercentile ( ) ) ) ; } private static int bufferSize ( Descriptor desc , IndexSummary indexSummary ) { File file = new File ( desc . filenameFor ( Component . PRIMARY_INDEX ) ) ; return bufferSize ( file . length ( ) / indexSummary . size ( ) ) ; } static int bufferSize ( long recordSize ) { Config . DiskOptimizationStrategy strategy = DatabaseDescriptor . getDiskOptimizationStrategy ( ) ; if ( strategy = = Config . DiskOptimizationStrategy . ssd ) { double pageCrossProbability = ( recordSize % <int> ) / <float> ; if ( ( pageCrossProbability - DatabaseDescriptor . getDiskOptimizationPageCrossChance ( ) ) > - <float> ) recordSize + = <int> ; return roundBufferSize ( recordSize ) ; } else if ( strategy = = Config . DiskOptimizationStrategy . spinning ) { return roundBufferSize ( recordSize + <int> ) ; } else { throw new IllegalStateException ( <str> + strategy ) ; } } static int roundBufferSize ( long size ) { if ( size < = <int> ) return <int> ; size = ( size + <int> ) & ~ <int> ; return ( int ) Math . min ( size , <int> < < <int> ) ; } public void serializeBounds ( DataOutput out , Version version ) throws IOException { if ( ! version . hasBoundaries ( ) ) return ; out . writeUTF ( DatabaseDescriptor . getDiskAccessMode ( ) . name ( ) ) ; } public void deserializeBounds ( DataInput in , Version version ) throws IOException { if ( ! version . hasBoundaries ( ) ) return ; if ( ! in . readUTF ( ) . equals ( DatabaseDescriptor . getDiskAccessMode ( ) . name ( ) ) ) throw new IOException ( <str> ) ; } public Throwable close ( Throwable accumulate ) { if ( channel ! = null ) return channel . close ( accumulate ) ; return accumulate ; } public void close ( ) { maybeFail ( close ( null ) ) ; } private ChannelProxy getChannel ( String path ) { if ( channel ! = null ) { if ( channel . filePath ( ) . equals ( path ) ) return channel . sharedCopy ( ) ; else channel . close ( ) ; } channel = new ChannelProxy ( path ) ; return channel . sharedCopy ( ) ; } } @Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + <str> + path ( ) + <str> + <str> + length + <str> ; } } 
