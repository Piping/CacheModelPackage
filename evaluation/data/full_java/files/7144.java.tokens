package org . elasticsearch . search . aggregations . bucket ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . util . packed . PackedInts ; import org . apache . lucene . util . packed . PackedLongValues ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . LongHash ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . BucketCollector ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class BestBucketsDeferringCollector extends DeferringBucketCollector { private static class Entry { final LeafReaderContext context ; final PackedLongValues docDeltas ; final PackedLongValues buckets ; public Entry ( LeafReaderContext context , PackedLongValues docDeltas , PackedLongValues buckets ) { this . context = context ; this . docDeltas = docDeltas ; this . buckets = buckets ; } } final List < Entry > entries = new ArrayList < > ( ) ; BucketCollector collector ; LeafReaderContext context ; PackedLongValues . Builder docDeltas ; PackedLongValues . Builder buckets ; long maxBucket = - <int> ; boolean finished = false ; LongHash selectedBuckets ; public BestBucketsDeferringCollector ( ) { } @Override public boolean needsScores ( ) { if ( collector = = null ) { throw new IllegalStateException ( ) ; } return collector . needsScores ( ) ; } public void setDeferredCollector ( Iterable < BucketCollector > deferredCollectors ) { this . collector = BucketCollector . wrap ( deferredCollectors ) ; } private void finishLeaf ( ) { if ( context ! = null ) { entries . add ( new Entry ( context , docDeltas . build ( ) , buckets . build ( ) ) ) ; } context = null ; docDeltas = null ; buckets = null ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx ) throws IOException { finishLeaf ( ) ; context = ctx ; docDeltas = PackedLongValues . packedBuilder ( PackedInts . DEFAULT ) ; buckets = PackedLongValues . packedBuilder ( PackedInts . DEFAULT ) ; return new LeafBucketCollector ( ) { int lastDoc = <int> ; @Override public void collect ( int doc , long bucket ) throws IOException { docDeltas . add ( doc - lastDoc ) ; buckets . add ( bucket ) ; lastDoc = doc ; maxBucket = Math . max ( maxBucket , bucket ) ; } } ; } @Override public void preCollection ( ) throws IOException { } @Override public void postCollection ( ) throws IOException { finishLeaf ( ) ; finished = true ; } @Override public void prepareSelectedBuckets ( long . . . selectedBuckets ) throws IOException { if ( ! finished ) { throw new IllegalStateException ( <str> ) ; } if ( this . selectedBuckets ! = null ) { throw new IllegalStateException ( <str> ) ; } final LongHash hash = new LongHash ( selectedBuckets . length , BigArrays . NON_RECYCLING_INSTANCE ) ; for ( long bucket : selectedBuckets ) { hash . add ( bucket ) ; } this . selectedBuckets = hash ; collector . preCollection ( ) ; if ( collector . needsScores ( ) ) { throw new IllegalStateException ( <str> ) ; } for ( Entry entry : entries ) { final LeafBucketCollector leafCollector = collector . getLeafCollector ( entry . context ) ; leafCollector . setScorer ( Lucene . illegalScorer ( <str> + SubAggCollectionMode . BREADTH_FIRST + <str> ) ) ; final PackedLongValues . Iterator docDeltaIterator = entry . docDeltas . iterator ( ) ; final PackedLongValues . Iterator buckets = entry . buckets . iterator ( ) ; int doc = <int> ; for ( long i = <int> , end = entry . docDeltas . size ( ) ; i < end ; + + i ) { doc + = docDeltaIterator . next ( ) ; final long bucket = buckets . next ( ) ; final long rebasedBucket = hash . find ( bucket ) ; if ( rebasedBucket ! = - <int> ) { leafCollector . collect ( doc , rebasedBucket ) ; } } } collector . postCollection ( ) ; } @Override public Aggregator wrap ( final Aggregator in ) { return new WrappedAggregator ( in ) { @Override public InternalAggregation buildAggregation ( long bucket ) throws IOException { if ( selectedBuckets = = null ) { throw new IllegalStateException ( <str> ) ; } final long rebasedBucket = selectedBuckets . find ( bucket ) ; if ( rebasedBucket = = - <int> ) { throw new IllegalStateException ( <str> ) ; } return in . buildAggregation ( rebasedBucket ) ; } } ; } } 
