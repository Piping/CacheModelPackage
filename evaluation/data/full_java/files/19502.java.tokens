package io . netty . handler . codec . socks ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socks . SocksInitResponseDecoder . State ; import java . util . List ; public class SocksInitResponseDecoder extends ReplayingDecoder < State > { private SocksProtocolVersion version ; private SocksAuthScheme authScheme ; private SocksResponse msg = SocksCommonUtils . UNKNOWN_SOCKS_RESPONSE ; public SocksInitResponseDecoder ( ) { super ( State . CHECK_PROTOCOL_VERSION ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf byteBuf , List < Object > out ) throws Exception { switch ( state ( ) ) { case CHECK_PROTOCOL_VERSION : { version = SocksProtocolVersion . valueOf ( byteBuf . readByte ( ) ) ; if ( version ! = SocksProtocolVersion . SOCKS5 ) { break ; } checkpoint ( State . READ_PREFFERED_AUTH_TYPE ) ; } case READ_PREFFERED_AUTH_TYPE : { authScheme = SocksAuthScheme . valueOf ( byteBuf . readByte ( ) ) ; msg = new SocksInitResponse ( authScheme ) ; break ; } } ctx . pipeline ( ) . remove ( this ) ; out . add ( msg ) ; } enum State { CHECK_PROTOCOL_VERSION , READ_PREFFERED_AUTH_TYPE } } 
