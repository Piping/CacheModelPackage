package com . badlogic . gdx . utils ; import java . util . Comparator ; public class DelayedRemovalArray < T > extends Array < T > { private int iterating ; private IntArray remove = new IntArray ( <int> ) ; public DelayedRemovalArray ( ) { super ( ) ; } public DelayedRemovalArray ( Array array ) { super ( array ) ; } public DelayedRemovalArray ( boolean ordered , int capacity , Class arrayType ) { super ( ordered , capacity , arrayType ) ; } public DelayedRemovalArray ( boolean ordered , int capacity ) { super ( ordered , capacity ) ; } public DelayedRemovalArray ( boolean ordered , T [ ] array , int startIndex , int count ) { super ( ordered , array , startIndex , count ) ; } public DelayedRemovalArray ( Class arrayType ) { super ( arrayType ) ; } public DelayedRemovalArray ( int capacity ) { super ( capacity ) ; } public DelayedRemovalArray ( T [ ] array ) { super ( array ) ; } public void begin ( ) { iterating + + ; } public void end ( ) { if ( iterating = = <int> ) throw new IllegalStateException ( <str> ) ; iterating - - ; if ( iterating = = <int> ) { for ( int i = <int> , n = remove . size ; i < n ; i + + ) removeIndex ( remove . pop ( ) ) ; } } private void remove ( int index ) { for ( int i = <int> , n = remove . size ; i < n ; i + + ) { int removeIndex = remove . get ( i ) ; if ( index = = removeIndex ) return ; if ( index < removeIndex ) { remove . insert ( i , index ) ; return ; } } remove . add ( index ) ; } public boolean removeValue ( T value , boolean identity ) { if ( iterating > <int> ) { int index = indexOf ( value , identity ) ; if ( index = = - <int> ) return false ; remove ( index ) ; return true ; } return super . removeValue ( value , identity ) ; } public T removeIndex ( int index ) { if ( iterating > <int> ) { remove ( index ) ; return get ( index ) ; } return super . removeIndex ( index ) ; } public void removeRange ( int start , int end ) { if ( iterating > <int> ) { for ( int i = end ; i > = start ; i - - ) remove ( i ) ; } else super . removeRange ( start , end ) ; } public void set ( int index , T value ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . set ( index , value ) ; } public void insert ( int index , T value ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . insert ( index , value ) ; } public void swap ( int first , int second ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . swap ( first , second ) ; } public T pop ( ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; return super . pop ( ) ; } public void clear ( ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . clear ( ) ; } public void sort ( ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . sort ( ) ; } public void sort ( Comparator < ? super T > comparator ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . sort ( comparator ) ; } public void reverse ( ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . reverse ( ) ; } public void shuffle ( ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . shuffle ( ) ; } public void truncate ( int newSize ) { if ( iterating > <int> ) throw new IllegalStateException ( <str> ) ; super . truncate ( newSize ) ; } static public < T > DelayedRemovalArray < T > with ( T . . . array ) { return new DelayedRemovalArray ( array ) ; } } 
