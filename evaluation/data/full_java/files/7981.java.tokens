package org . elasticsearch . common . util ; import org . elasticsearch . common . util . CancellableThreads . Interruptable ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . util . concurrent . CountDownLatch ; public class CancellableThreadsTests extends ESTestCase { public static class CustomException extends RuntimeException { public CustomException ( String msg ) { super ( msg ) ; } } private class TestPlan { public final int id ; public final boolean busySpin ; public final boolean exceptBeforeCancel ; public final boolean exitBeforeCancel ; public final boolean exceptAfterCancel ; public final boolean presetInterrupt ; private TestPlan ( int id ) { this . id = id ; this . busySpin = randomBoolean ( ) ; this . exceptBeforeCancel = randomBoolean ( ) ; this . exitBeforeCancel = randomBoolean ( ) ; this . exceptAfterCancel = randomBoolean ( ) ; this . presetInterrupt = randomBoolean ( ) ; } } public void testCancellableThreads ( ) throws InterruptedException { Thread [ ] threads = new Thread [ randomIntBetween ( <int> , <int> ) ] ; final TestPlan [ ] plans = new TestPlan [ threads . length ] ; final Throwable [ ] throwables = new Throwable [ threads . length ] ; final boolean [ ] interrupted = new boolean [ threads . length ] ; final CancellableThreads cancellableThreads = new CancellableThreads ( ) ; final CountDownLatch readyForCancel = new CountDownLatch ( threads . length ) ; for ( int i = <int> ; i < threads . length ; i + + ) { final TestPlan plan = new TestPlan ( i ) ; plans [ i ] = plan ; threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { if ( plan . presetInterrupt ) { Thread . currentThread ( ) . interrupt ( ) ; } cancellableThreads . execute ( new Interruptable ( ) { @Override public void run ( ) throws InterruptedException { assertFalse ( <str> , Thread . currentThread ( ) . isInterrupted ( ) ) ; if ( plan . exceptBeforeCancel ) { throw new CustomException ( <str> + plan . id + <str> ) ; } else if ( plan . exitBeforeCancel ) { return ; } readyForCancel . countDown ( ) ; try { if ( plan . busySpin ) { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { } } else { Thread . sleep ( <int> ) ; } } finally { if ( plan . exceptAfterCancel ) { throw new CustomException ( <str> + plan . id + <str> ) ; } } } } ) ; } catch ( Throwable t ) { throwables [ plan . id ] = t ; } if ( plan . exceptBeforeCancel | | plan . exitBeforeCancel ) { readyForCancel . countDown ( ) ; } interrupted [ plan . id ] = Thread . currentThread ( ) . isInterrupted ( ) ; } } ) ; threads [ i ] . setDaemon ( true ) ; threads [ i ] . start ( ) ; } readyForCancel . await ( ) ; cancellableThreads . cancel ( <str> ) ; for ( Thread thread : threads ) { thread . join ( <int> ) ; assertFalse ( thread . isAlive ( ) ) ; } for ( int i = <int> ; i < threads . length ; i + + ) { TestPlan plan = plans [ i ] ; if ( plan . exceptBeforeCancel ) { assertThat ( throwables [ i ] , Matchers . instanceOf ( CustomException . class ) ) ; } else if ( plan . exitBeforeCancel ) { assertNull ( throwables [ i ] ) ; } else { assertThat ( throwables [ i ] , Matchers . instanceOf ( CancellableThreads . ExecutionCancelledException . class ) ) ; if ( plan . exceptAfterCancel ) { assertThat ( throwables [ i ] . getSuppressed ( ) , Matchers . arrayContaining ( Matchers . instanceOf ( CustomException . class ) ) ) ; } else { assertThat ( throwables [ i ] . getSuppressed ( ) , Matchers . emptyArray ( ) ) ; } } assertThat ( interrupted [ plan . id ] , Matchers . equalTo ( plan . presetInterrupt ) ) ; } } } 
