package org . elasticsearch . search . aggregations . bucket . terms ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . SortedNumericDocValues ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . util . LongHash ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . bucket . terms . support . BucketPriorityQueue ; import org . elasticsearch . search . aggregations . bucket . terms . support . IncludeExclude ; import org . elasticsearch . search . aggregations . bucket . terms . support . IncludeExclude . LongFilter ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . format . ValueFormat ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public class LongTermsAggregator extends TermsAggregator { protected final ValuesSource . Numeric valuesSource ; protected final ValueFormatter formatter ; protected final LongHash bucketOrds ; private boolean showTermDocCountError ; private LongFilter longFilter ; public LongTermsAggregator ( String name , AggregatorFactories factories , ValuesSource . Numeric valuesSource , ValueFormat format , Terms . Order order , BucketCountThresholds bucketCountThresholds , AggregationContext aggregationContext , Aggregator parent , SubAggCollectionMode subAggCollectMode , boolean showTermDocCountError , IncludeExclude . LongFilter longFilter , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , bucketCountThresholds , order , subAggCollectMode , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; this . showTermDocCountError = showTermDocCountError ; this . formatter = format . formatter ( ) ; this . longFilter = longFilter ; bucketOrds = new LongHash ( <int> , aggregationContext . bigArrays ( ) ) ; } @Override public boolean needsScores ( ) { return ( valuesSource ! = null & & valuesSource . needsScores ( ) ) | | super . needsScores ( ) ; } protected SortedNumericDocValues getValues ( ValuesSource . Numeric valuesSource , LeafReaderContext ctx ) throws IOException { return valuesSource . longValues ( ctx ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { final SortedNumericDocValues values = getValues ( valuesSource , ctx ) ; return new LeafBucketCollectorBase ( sub , values ) { @Override public void collect ( int doc , long owningBucketOrdinal ) throws IOException { assert owningBucketOrdinal = = <int> ; values . setDocument ( doc ) ; final int valuesCount = values . count ( ) ; long previous = Long . MAX_VALUE ; for ( int i = <int> ; i < valuesCount ; + + i ) { final long val = values . valueAt ( i ) ; if ( previous ! = val | | i = = <int> ) { if ( ( longFilter = = null ) | | ( longFilter . accept ( val ) ) ) { long bucketOrdinal = bucketOrds . add ( val ) ; if ( bucketOrdinal < <int> ) { bucketOrdinal = - <int> - bucketOrdinal ; collectExistingBucket ( sub , doc , bucketOrdinal ) ; } else { collectBucket ( sub , doc , bucketOrdinal ) ; } } previous = val ; } } } } ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { assert owningBucketOrdinal = = <int> ; if ( bucketCountThresholds . getMinDocCount ( ) = = <int> & & ( order ! = InternalOrder . COUNT_DESC | | bucketOrds . size ( ) < bucketCountThresholds . getRequiredSize ( ) ) ) { for ( LeafReaderContext ctx : context . searchContext ( ) . searcher ( ) . getTopReaderContext ( ) . leaves ( ) ) { final SortedNumericDocValues values = getValues ( valuesSource , ctx ) ; for ( int docId = <int> ; docId < ctx . reader ( ) . maxDoc ( ) ; + + docId ) { values . setDocument ( docId ) ; final int valueCount = values . count ( ) ; for ( int i = <int> ; i < valueCount ; + + i ) { bucketOrds . add ( values . valueAt ( i ) ) ; } } } } final int size = ( int ) Math . min ( bucketOrds . size ( ) , bucketCountThresholds . getShardSize ( ) ) ; long otherDocCount = <int> ; BucketPriorityQueue ordered = new BucketPriorityQueue ( size , order . comparator ( this ) ) ; LongTerms . Bucket spare = null ; for ( long i = <int> ; i < bucketOrds . size ( ) ; i + + ) { if ( spare = = null ) { spare = new LongTerms . Bucket ( <int> , <int> , null , showTermDocCountError , <int> , formatter ) ; } spare . term = bucketOrds . get ( i ) ; spare . docCount = bucketDocCount ( i ) ; otherDocCount + = spare . docCount ; spare . bucketOrd = i ; if ( bucketCountThresholds . getShardMinDocCount ( ) < = spare . docCount ) { spare = ( LongTerms . Bucket ) ordered . insertWithOverflow ( spare ) ; } } final InternalTerms . Bucket [ ] list = new InternalTerms . Bucket [ ordered . size ( ) ] ; long survivingBucketOrds [ ] = new long [ ordered . size ( ) ] ; for ( int i = ordered . size ( ) - <int> ; i > = <int> ; - - i ) { final LongTerms . Bucket bucket = ( LongTerms . Bucket ) ordered . pop ( ) ; survivingBucketOrds [ i ] = bucket . bucketOrd ; list [ i ] = bucket ; otherDocCount - = bucket . docCount ; } runDeferredCollections ( survivingBucketOrds ) ; for ( int i = <int> ; i < list . length ; i + + ) { list [ i ] . aggregations = bucketAggregations ( list [ i ] . bucketOrd ) ; list [ i ] . docCountError = <int> ; } return new LongTerms ( name , order , formatter , bucketCountThresholds . getRequiredSize ( ) , bucketCountThresholds . getShardSize ( ) , bucketCountThresholds . getMinDocCount ( ) , Arrays . asList ( list ) , showTermDocCountError , <int> , otherDocCount , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new LongTerms ( name , order , formatter , bucketCountThresholds . getRequiredSize ( ) , bucketCountThresholds . getShardSize ( ) , bucketCountThresholds . getMinDocCount ( ) , Collections . < InternalTerms . Bucket > emptyList ( ) , showTermDocCountError , <int> , <int> , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public void doClose ( ) { Releasables . close ( bucketOrds ) ; } } 
