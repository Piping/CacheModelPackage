package org . nd4j . linalg . indexing ; import com . google . common . primitives . Ints ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . util . ArrayUtil ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class NDArrayIndex implements INDArrayIndex { private int [ ] indices = new int [ <int> ] ; private boolean isInterval = false ; private static NDArrayIndexEmpty EMPTY = new NDArrayIndexEmpty ( ) ; private static NewAxis NEW_AXIS = new NewAxis ( ) ; public static INDArrayIndex point ( int point ) { return new PointIndex ( point ) ; } public static INDArrayIndex [ ] indexesFor ( int . . . shape ) { INDArrayIndex [ ] ret = new INDArrayIndex [ shape . length ] ; for ( int i = <int> ; i < shape . length ; i + + ) { ret [ i ] = NDArrayIndex . point ( shape [ i ] ) ; } return ret ; } public static int offset ( INDArray arr , int . . . offsets ) { return offset ( arr . stride ( ) , offsets ) ; } public static int offset ( INDArray arr , INDArrayIndex . . . indices ) { return offset ( arr . stride ( ) , Indices . offsets ( arr . shape ( ) , indices ) ) ; } public static void updateForNewAxes ( INDArray arr , INDArrayIndex . . . indexes ) { int numNewAxes = NDArrayIndex . numNewAxis ( indexes ) ; if ( numNewAxes > = <int> & & ( indexes [ <int> ] . length ( ) > <int> | | indexes [ <int> ] instanceof NDArrayIndexAll ) ) { List < Integer > newShape = new ArrayList < > ( ) ; List < Integer > newStrides = new ArrayList < > ( ) ; int currDimension = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] instanceof NewAxis ) { newShape . add ( <int> ) ; newStrides . add ( <int> ) ; } else { newShape . add ( arr . size ( currDimension ) ) ; newStrides . add ( arr . size ( currDimension ) ) ; currDimension + + ; } } while ( currDimension < arr . rank ( ) ) { newShape . add ( currDimension ) ; newStrides . add ( currDimension ) ; currDimension + + ; } int [ ] newShapeArr = Ints . toArray ( newShape ) ; int [ ] newStrideArr = Ints . toArray ( newStrides ) ; arr . setShape ( newShapeArr ) ; arr . setStride ( newStrideArr ) ; } else { if ( numNewAxes > <int> ) { int [ ] newShape = Ints . concat ( ArrayUtil . nTimes ( numNewAxes , <int> ) , arr . shape ( ) ) ; int [ ] newStrides = Ints . concat ( new int [ numNewAxes ] , arr . stride ( ) ) ; arr . setShape ( newShape ) ; arr . setStride ( newStrides ) ; } } } public static int offset ( int [ ] strides , int [ ] offsets ) { int ret = <int> ; if ( ArrayUtil . prod ( offsets ) = = <int> ) { for ( int i = <int> ; i < offsets . length ; i + + ) { ret + = offsets [ i ] * strides [ i ] ; } } else { for ( int i = <int> ; i < offsets . length ; i + + ) { ret + = offsets [ i ] * strides [ i ] ; } } return ret ; } public static INDArrayIndex [ ] nTimes ( INDArrayIndex copy , int n ) { INDArrayIndex [ ] ret = new INDArrayIndex [ n ] ; for ( int i = <int> ; i < n ; i + + ) { ret [ i ] = copy ; } return ret ; } public NDArrayIndex ( int . . . indices ) { this . indices = indices ; } public static INDArrayIndex empty ( ) { return EMPTY ; } public static INDArrayIndex all ( ) { return new NDArrayIndexAll ( true ) ; } public static INDArrayIndex newAxis ( ) { return NEW_AXIS ; } public static INDArrayIndex [ ] resolve ( INDArray arr , INDArrayIndex . . . intendedIndexes ) { return resolve ( NDArrayIndex . allFor ( arr ) , intendedIndexes ) ; } public static int numPoints ( INDArrayIndex . . . indexes ) { int ret = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) if ( indexes [ i ] instanceof PointIndex ) ret + + ; return ret ; } public static INDArrayIndex [ ] resolve ( int [ ] shape , INDArrayIndex . . . intendedIndexes ) { if ( intendedIndexes . length > = shape . length | | Shape . isVector ( shape ) & & intendedIndexes . length = = <int> ) { if ( Shape . isRowVectorShape ( shape ) & & intendedIndexes . length = = <int> ) { INDArrayIndex [ ] ret = new INDArrayIndex [ <int> ] ; ret [ <int> ] = NDArrayIndex . point ( <int> ) ; int size ; if ( <int> = = shape [ <int> ] & & shape . length = = <int> ) size = shape [ <int> ] ; else size = shape [ <int> ] ; ret [ <int> ] = validate ( size , intendedIndexes [ <int> ] ) ; return ret ; } List < INDArrayIndex > retList = new ArrayList < > ( intendedIndexes . length ) ; for ( int i = <int> ; i < intendedIndexes . length ; i + + ) { if ( i < shape . length ) retList . add ( validate ( shape [ i ] , intendedIndexes [ i ] ) ) ; else retList . add ( intendedIndexes [ i ] ) ; } return retList . toArray ( new INDArrayIndex [ retList . size ( ) ] ) ; } List < INDArrayIndex > retList = new ArrayList < > ( intendedIndexes . length + <int> ) ; int numNewAxes = <int> ; if ( Shape . isMatrix ( shape ) & & intendedIndexes . length = = <int> ) { retList . add ( validate ( shape [ <int> ] , intendedIndexes [ <int> ] ) ) ; retList . add ( NDArrayIndex . all ( ) ) ; } else { for ( int i = <int> ; i < intendedIndexes . length ; i + + ) { retList . add ( validate ( shape [ i ] , intendedIndexes [ i ] ) ) ; if ( intendedIndexes [ i ] instanceof NewAxis ) numNewAxes + + ; } } int length = shape . length + numNewAxes ; while ( retList . size ( ) < length ) retList . add ( NDArrayIndex . all ( ) ) ; return retList . toArray ( new INDArrayIndex [ retList . size ( ) ] ) ; } protected static INDArrayIndex validate ( int size , INDArrayIndex index ) { if ( ( index instanceof IntervalIndex | | index instanceof PointIndex ) & & size < = index . current ( ) & & size > <int> ) throw new IllegalArgumentException ( <str> + index . current ( ) + <str> + size ) ; if ( index instanceof IntervalIndex & & size < index . end ( ) ) { int begin = ( ( IntervalIndex ) index ) . begin ; index = NDArrayIndex . interval ( begin , index . stride ( ) , size ) ; } return index ; } public static INDArrayIndex [ ] resolve ( INDArrayIndex [ ] allIndex , INDArrayIndex . . . intendedIndexes ) { int numNewAxes = numNewAxis ( intendedIndexes ) ; INDArrayIndex [ ] all = new INDArrayIndex [ allIndex . length + numNewAxes ] ; Arrays . fill ( all , NDArrayIndex . all ( ) ) ; for ( int i = <int> ; i < allIndex . length ; i + + ) { if ( i > = intendedIndexes . length ) break ; if ( intendedIndexes [ i ] instanceof NDArrayIndex ) { NDArrayIndex idx = ( NDArrayIndex ) intendedIndexes [ i ] ; if ( idx . indices . length = = <int> ) intendedIndexes [ i ] = new PointIndex ( idx . indices [ <int> ] ) ; } all [ i ] = intendedIndexes [ i ] ; } return all ; } public static int numNewAxis ( INDArrayIndex . . . axes ) { int ret = <int> ; for ( INDArrayIndex index : axes ) if ( index instanceof NewAxis ) ret + + ; return ret ; } public static INDArrayIndex [ ] allFor ( INDArray arr ) { INDArrayIndex [ ] ret = new INDArrayIndex [ arr . rank ( ) ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = NDArrayIndex . all ( ) ; return ret ; } public static INDArrayIndex [ ] createCoveringShape ( int [ ] shape ) { INDArrayIndex [ ] ret = new INDArrayIndex [ shape . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) { ret [ i ] = NDArrayIndex . interval ( <int> , shape [ i ] ) ; } return ret ; } public static INDArrayIndex [ ] rangeOfLength ( INDArrayIndex [ ] indexes ) { INDArrayIndex [ ] indexesRet = new INDArrayIndex [ indexes . length ] ; for ( int i = <int> ; i < indexes . length ; i + + ) indexesRet [ i ] = NDArrayIndex . interval ( <int> , indexes [ i ] . length ( ) ) ; return indexesRet ; } public static INDArrayIndex [ ] create ( INDArray index ) { if ( index . isMatrix ( ) ) { NDArrayIndex [ ] ret = new NDArrayIndex [ index . rows ( ) ] ; for ( int i = <int> ; i < index . rows ( ) ; i + + ) { INDArray row = index . getRow ( i ) ; int [ ] nums = new int [ index . getRow ( i ) . columns ( ) ] ; for ( int j = <int> ; j < row . columns ( ) ; j + + ) { nums [ j ] = ( int ) row . getFloat ( j ) ; } NDArrayIndex idx = new NDArrayIndex ( nums ) ; ret [ i ] = idx ; } return ret ; } else if ( index . isVector ( ) ) { int [ ] indices = ArrayUtil . toInts ( index ) ; return new NDArrayIndex [ ] { new NDArrayIndex ( indices ) } ; } throw new IllegalArgumentException ( <str> ) ; } public static INDArrayIndex interval ( int begin , int stride , int end ) { if ( Math . abs ( begin - end ) < <int> ) end + + ; if ( stride > <int> & & Math . abs ( begin - end ) = = <int> ) { end * = stride ; } return interval ( begin , stride , end , false ) ; } public static INDArrayIndex interval ( int begin , int stride , int end , boolean inclusive ) { assert begin < = end : <str> ; INDArrayIndex index = new IntervalIndex ( inclusive , stride ) ; index . init ( begin , end ) ; return index ; } public static INDArrayIndex interval ( int begin , int end ) { return interval ( begin , <int> , end , false ) ; } public static INDArrayIndex interval ( int begin , int end , boolean inclusive ) { return interval ( begin , <int> , end , inclusive ) ; } @Override public int end ( ) { if ( indices ! = null & & indices . length > <int> ) return indices [ indices . length - <int> ] ; return <int> ; } @Override public int offset ( ) { if ( indices . length < <int> ) return <int> ; return indices [ <int> ] ; } @Override public int length ( ) { return indices . length ; } @Override public int stride ( ) { return <int> ; } @Override public int current ( ) { return <int> ; } @Override public boolean hasNext ( ) { return false ; } @Override public int next ( ) { return <int> ; } @Override public void reverse ( ) { ArrayUtil . reverse ( indices ) ; } @Override public String toString ( ) { return <str> + <str> + Arrays . toString ( indices ) + <str> ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof INDArrayIndex ) ) return false ; NDArrayIndex that = ( NDArrayIndex ) o ; if ( ! Arrays . equals ( indices , that . indices ) ) return false ; return true ; } @Override public int hashCode ( ) { return Arrays . hashCode ( indices ) ; } @Override public boolean isInterval ( ) { return isInterval ; } @Override public void setInterval ( boolean isInterval ) { this . isInterval = isInterval ; } @Override public void init ( INDArray arr , int begin , int dimension ) { } @Override public void init ( INDArray arr , int dimension ) { } @Override public void init ( int begin , int end ) { } @Override public void reset ( ) { } } 
