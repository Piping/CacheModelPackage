package org . elasticsearch . test . rest . section ; import org . elasticsearch . Version ; import org . elasticsearch . test . VersionUtils ; import org . elasticsearch . test . rest . support . Features ; import java . util . ArrayList ; import java . util . List ; public class SkipSection { public static final SkipSection EMPTY = new SkipSection ( ) ; private final Version lowerVersion ; private final Version upperVersion ; private final List < String > features ; private final String reason ; private SkipSection ( ) { this . lowerVersion = null ; this . upperVersion = null ; this . features = new ArrayList < > ( ) ; this . reason = null ; } public SkipSection ( String versionRange , List < String > features , String reason ) { assert features ! = null ; assert versionRange ! = null & & features . isEmpty ( ) | | versionRange = = null & & features . isEmpty ( ) = = false ; Version [ ] versions = parseVersionRange ( versionRange ) ; this . lowerVersion = versions [ <int> ] ; this . upperVersion = versions [ <int> ] ; this . features = features ; this . reason = reason ; } public Version getLowerVersion ( ) { return lowerVersion ; } public Version getUpperVersion ( ) { return upperVersion ; } public List < String > getFeatures ( ) { return features ; } public String getReason ( ) { return reason ; } public boolean skip ( Version currentVersion ) { if ( isEmpty ( ) ) { return false ; } if ( isVersionCheck ( ) ) { return currentVersion . onOrAfter ( lowerVersion ) & & currentVersion . onOrBefore ( upperVersion ) ; } else { return Features . areAllSupported ( features ) = = false ; } } public boolean isVersionCheck ( ) { return features . isEmpty ( ) ; } public boolean isEmpty ( ) { return EMPTY . equals ( this ) ; } private Version [ ] parseVersionRange ( String versionRange ) { if ( versionRange = = null ) { return new Version [ ] { null , null } ; } if ( versionRange . trim ( ) . equals ( <str> ) ) { return new Version [ ] { VersionUtils . getFirstVersion ( ) , Version . CURRENT } ; } String [ ] skipVersions = versionRange . split ( <str> ) ; if ( skipVersions . length > <int> ) { throw new IllegalArgumentException ( <str> + versionRange ) ; } String lower = skipVersions [ <int> ] . trim ( ) ; String upper = skipVersions [ <int> ] . trim ( ) ; return new Version [ ] { lower . isEmpty ( ) ? VersionUtils . getFirstVersion ( ) : Version . fromString ( lower ) , upper . isEmpty ( ) ? Version . CURRENT : Version . fromString ( upper ) } ; } } 
