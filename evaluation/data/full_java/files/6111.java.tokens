package org . elasticsearch . common . util . concurrent ; import org . elasticsearch . ElasticsearchGenerationException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . atomic . AtomicReferenceArray ; public class AtomicArray < E > { private static final AtomicArray EMPTY = new AtomicArray ( <int> ) ; @SuppressWarnings ( <str> ) public static < E > E empty ( ) { return ( E ) EMPTY ; } private final AtomicReferenceArray < E > array ; private volatile List < Entry < E > > nonNullList ; public AtomicArray ( int size ) { array = new AtomicReferenceArray < > ( size ) ; } public int length ( ) { return array . length ( ) ; } public void set ( int i , E value ) { array . set ( i , value ) ; if ( nonNullList ! = null ) { nonNullList = null ; } } public final void setOnce ( int i , E value ) { if ( array . compareAndSet ( i , null , value ) = = false ) { throw new IllegalStateException ( <str> + i + <str> ) ; } if ( nonNullList ! = null ) { nonNullList = null ; } } public E get ( int i ) { return array . get ( i ) ; } public List < Entry < E > > asList ( ) { if ( nonNullList = = null ) { if ( array = = null | | array . length ( ) = = <int> ) { nonNullList = Collections . emptyList ( ) ; } else { List < Entry < E > > list = new ArrayList < > ( array . length ( ) ) ; for ( int i = <int> ; i < array . length ( ) ; i + + ) { E e = array . get ( i ) ; if ( e ! = null ) { list . add ( new Entry < > ( i , e ) ) ; } } nonNullList = list ; } } return nonNullList ; } public E [ ] toArray ( E [ ] a ) { if ( a . length ! = array . length ( ) ) { throw new ElasticsearchGenerationException ( <str> ) ; } for ( int i = <int> ; i < array . length ( ) ; i + + ) { a [ i ] = array . get ( i ) ; } return a ; } public static class Entry < E > { public final int index ; public final E value ; public Entry ( int index , E value ) { this . index = index ; this . value = value ; } } } 
