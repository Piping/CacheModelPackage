package org . elasticsearch . env ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . SegmentInfos ; import org . apache . lucene . store . * ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . FsDirectoryService ; import org . elasticsearch . monitor . fs . FsInfo ; import org . elasticsearch . monitor . fs . FsProbe ; import java . io . Closeable ; import java . io . IOException ; import java . nio . file . * ; import java . util . * ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static java . util . Collections . unmodifiableSet ; public class NodeEnvironment extends AbstractComponent implements Closeable { public static class NodePath { public final Path path ; public final Path indicesPath ; public final FileStore fileStore ; public final Boolean spins ; public NodePath ( Path path , Environment environment ) throws IOException { this . path = path ; this . indicesPath = path . resolve ( INDICES_FOLDER ) ; this . fileStore = Environment . getFileStore ( path ) ; if ( fileStore . supportsFileAttributeView ( <str> ) ) { this . spins = ( Boolean ) fileStore . getAttribute ( <str> ) ; } else { this . spins = null ; } } public Path resolve ( ShardId shardId ) { return resolve ( shardId . index ( ) ) . resolve ( Integer . toString ( shardId . id ( ) ) ) ; } public Path resolve ( Index index ) { return indicesPath . resolve ( index . name ( ) ) ; } @Override public String toString ( ) { return <str> + <str> + path + <str> + spins + <str> ; } } private final NodePath [ ] nodePaths ; private final Path sharedDataPath ; private final Lock [ ] locks ; private final boolean addNodeId ; private final int localNodeId ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; private final Map < ShardId , InternalShardLock > shardLocks = new HashMap < > ( ) ; public static final String ADD_NODE_ID_TO_CUSTOM_PATH = <str> ; public static final String SETTING_ENABLE_LUCENE_SEGMENT_INFOS_TRACE = <str> ; public static final String NODES_FOLDER = <str> ; public static final String INDICES_FOLDER = <str> ; public static final String NODE_LOCK_FILENAME = <str> ; @Inject @SuppressForbidden ( reason = <str> ) public NodeEnvironment ( Settings settings , Environment environment ) throws IOException { super ( settings ) ; this . addNodeId = settings . getAsBoolean ( ADD_NODE_ID_TO_CUSTOM_PATH , true ) ; if ( ! DiscoveryNode . nodeRequiresLocalStorage ( settings ) ) { nodePaths = null ; sharedDataPath = null ; locks = null ; localNodeId = - <int> ; return ; } final NodePath [ ] nodePaths = new NodePath [ environment . dataWithClusterFiles ( ) . length ] ; final Lock [ ] locks = new Lock [ nodePaths . length ] ; sharedDataPath = environment . sharedDataFile ( ) ; int localNodeId = - <int> ; IOException lastException = null ; int maxLocalStorageNodes = settings . getAsInt ( <str> , <int> ) ; for ( int possibleLockId = <int> ; possibleLockId < maxLocalStorageNodes ; possibleLockId + + ) { for ( int dirIndex = <int> ; dirIndex < environment . dataWithClusterFiles ( ) . length ; dirIndex + + ) { Path dir = environment . dataWithClusterFiles ( ) [ dirIndex ] . resolve ( NODES_FOLDER ) . resolve ( Integer . toString ( possibleLockId ) ) ; Files . createDirectories ( dir ) ; try ( Directory luceneDir = FSDirectory . open ( dir , NativeFSLockFactory . INSTANCE ) ) { logger . trace ( <str> , dir . toAbsolutePath ( ) ) ; try { locks [ dirIndex ] = luceneDir . obtainLock ( NODE_LOCK_FILENAME ) ; nodePaths [ dirIndex ] = new NodePath ( dir , environment ) ; localNodeId = possibleLockId ; } catch ( LockObtainFailedException ex ) { logger . trace ( <str> , dir . toAbsolutePath ( ) ) ; releaseAndNullLocks ( locks ) ; break ; } } catch ( IOException e ) { logger . trace ( <str> , e , dir . toAbsolutePath ( ) ) ; lastException = new IOException ( <str> + dir . toAbsolutePath ( ) , e ) ; releaseAndNullLocks ( locks ) ; break ; } } if ( locks [ <int> ] ! = null ) { break ; } } if ( locks [ <int> ] = = null ) { throw new IllegalStateException ( <str> + Arrays . toString ( environment . dataWithClusterFiles ( ) ) , lastException ) ; } this . localNodeId = localNodeId ; this . locks = locks ; this . nodePaths = nodePaths ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , nodePaths , localNodeId ) ; } maybeLogPathDetails ( ) ; if ( settings . getAsBoolean ( SETTING_ENABLE_LUCENE_SEGMENT_INFOS_TRACE , false ) ) { SegmentInfos . setInfoStream ( System . out ) ; } } private static void releaseAndNullLocks ( Lock [ ] locks ) { for ( int i = <int> ; i < locks . length ; i + + ) { if ( locks [ i ] ! = null ) { IOUtils . closeWhileHandlingException ( locks [ i ] ) ; } locks [ i ] = null ; } } private void maybeLogPathDetails ( ) throws IOException { if ( logger . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( NodePath nodePath : nodePaths ) { sb . append ( <str> ) . append ( <str> ) . append ( nodePath . path . toAbsolutePath ( ) ) ; String spinsDesc ; if ( nodePath . spins = = null ) { spinsDesc = <str> ; } else if ( nodePath . spins ) { spinsDesc = <str> ; } else { spinsDesc = <str> ; } FsInfo . Path fsPath = FsProbe . getFSInfo ( nodePath ) ; sb . append ( <str> ) . append ( fsPath . getFree ( ) ) . append ( <str> ) . append ( fsPath . getAvailable ( ) ) . append ( <str> ) . append ( fsPath . getTotal ( ) ) . append ( <str> ) . append ( spinsDesc ) . append ( <str> ) . append ( fsPath . getMount ( ) ) . append ( <str> ) . append ( fsPath . getType ( ) ) . append ( <str> ) ; } logger . debug ( sb . toString ( ) ) ; } else if ( logger . isInfoEnabled ( ) ) { FsInfo . Path totFSPath = new FsInfo . Path ( ) ; Set < String > allTypes = new HashSet < > ( ) ; Set < String > allSpins = new HashSet < > ( ) ; Set < String > allMounts = new HashSet < > ( ) ; for ( NodePath nodePath : nodePaths ) { FsInfo . Path fsPath = FsProbe . getFSInfo ( nodePath ) ; String mount = fsPath . getMount ( ) ; if ( allMounts . contains ( mount ) = = false ) { allMounts . add ( mount ) ; String type = fsPath . getType ( ) ; if ( type ! = null ) { allTypes . add ( type ) ; } Boolean spins = fsPath . getSpins ( ) ; if ( spins = = null ) { allSpins . add ( <str> ) ; } else if ( spins . booleanValue ( ) ) { allSpins . add ( <str> ) ; } else { allSpins . add ( <str> ) ; } totFSPath . add ( fsPath ) ; } } logger . info ( String . format ( Locale . ROOT , <str> , nodePaths . length , allMounts , totFSPath . getAvailable ( ) , totFSPath . getTotal ( ) , toString ( allSpins ) , toString ( allTypes ) ) ) ; } } private static String toString ( Collection < String > items ) { StringBuilder b = new StringBuilder ( ) ; for ( String item : items ) { if ( b . length ( ) > <int> ) { b . append ( <str> ) ; } b . append ( item ) ; } return b . toString ( ) ; } public void deleteShardDirectorySafe ( ShardId shardId , IndexSettings indexSettings ) throws IOException { final Path [ ] paths = availableShardPaths ( shardId ) ; logger . trace ( <str> , shardId , paths ) ; try ( ShardLock lock = shardLock ( shardId ) ) { deleteShardDirectoryUnderLock ( lock , indexSettings ) ; } } public static void acquireFSLockForPaths ( IndexSettings indexSettings , Path . . . shardPaths ) throws IOException { Lock [ ] locks = new Lock [ shardPaths . length ] ; Directory [ ] dirs = new Directory [ shardPaths . length ] ; try { for ( int i = <int> ; i < shardPaths . length ; i + + ) { Path p = shardPaths [ i ] . resolve ( <str> ) ; dirs [ i ] = new SimpleFSDirectory ( p , FsDirectoryService . buildLockFactory ( indexSettings ) ) ; try { locks [ i ] = dirs [ i ] . obtainLock ( IndexWriter . WRITE_LOCK_NAME ) ; } catch ( IOException ex ) { throw new LockObtainFailedException ( <str> + IndexWriter . WRITE_LOCK_NAME + <str> + p ) ; } } } finally { IOUtils . closeWhileHandlingException ( locks ) ; IOUtils . closeWhileHandlingException ( dirs ) ; } } public void deleteShardDirectoryUnderLock ( ShardLock lock , IndexSettings indexSettings ) throws IOException { final ShardId shardId = lock . getShardId ( ) ; assert isShardLocked ( shardId ) : <str> + shardId + <str> ; final Path [ ] paths = availableShardPaths ( shardId ) ; logger . trace ( <str> , shardId , paths ) ; acquireFSLockForPaths ( indexSettings , paths ) ; IOUtils . rm ( paths ) ; if ( indexSettings . hasCustomDataPath ( ) ) { Path customLocation = resolveCustomLocation ( indexSettings , shardId ) ; logger . trace ( <str> , shardId , customLocation ) ; acquireFSLockForPaths ( indexSettings , customLocation ) ; logger . trace ( <str> , shardId , customLocation ) ; IOUtils . rm ( customLocation ) ; } logger . trace ( <str> , shardId , paths ) ; assert FileSystemUtils . exists ( paths ) = = false ; } private boolean isShardLocked ( ShardId id ) { try { shardLock ( id , <int> ) . close ( ) ; return false ; } catch ( IOException ex ) { return true ; } } public void deleteIndexDirectorySafe ( Index index , long lockTimeoutMS , IndexSettings indexSettings ) throws IOException { final List < ShardLock > locks = lockAllForIndex ( index , indexSettings , lockTimeoutMS ) ; try { deleteIndexDirectoryUnderLock ( index , indexSettings ) ; } finally { IOUtils . closeWhileHandlingException ( locks ) ; } } public void deleteIndexDirectoryUnderLock ( Index index , IndexSettings indexSettings ) throws IOException { final Path [ ] indexPaths = indexPaths ( index ) ; logger . trace ( <str> , index , indexPaths . length , indexPaths ) ; IOUtils . rm ( indexPaths ) ; if ( indexSettings . hasCustomDataPath ( ) ) { Path customLocation = resolveCustomLocation ( indexSettings , index . name ( ) ) ; logger . trace ( <str> , index , customLocation ) ; IOUtils . rm ( customLocation ) ; } } public List < ShardLock > lockAllForIndex ( Index index , IndexSettings settings , long lockTimeoutMS ) throws IOException { final int numShards = settings . getNumberOfShards ( ) ; if ( numShards < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } logger . trace ( <str> , index , numShards ) ; List < ShardLock > allLocks = new ArrayList < > ( numShards ) ; boolean success = false ; long startTimeNS = System . nanoTime ( ) ; try { for ( int i = <int> ; i < numShards ; i + + ) { long timeoutLeftMS = Math . max ( <int> , lockTimeoutMS - TimeValue . nsecToMSec ( ( System . nanoTime ( ) - startTimeNS ) ) ) ; allLocks . add ( shardLock ( new ShardId ( index , i ) , timeoutLeftMS ) ) ; } success = true ; } finally { if ( success = = false ) { logger . trace ( <str> , index ) ; IOUtils . closeWhileHandlingException ( allLocks ) ; } } return allLocks ; } public ShardLock shardLock ( ShardId id ) throws IOException { return shardLock ( id , <int> ) ; } public ShardLock shardLock ( final ShardId id , long lockTimeoutMS ) throws IOException { logger . trace ( <str> , id , lockTimeoutMS ) ; final InternalShardLock shardLock ; final boolean acquired ; synchronized ( shardLocks ) { if ( shardLocks . containsKey ( id ) ) { shardLock = shardLocks . get ( id ) ; shardLock . incWaitCount ( ) ; acquired = false ; } else { shardLock = new InternalShardLock ( id ) ; shardLocks . put ( id , shardLock ) ; acquired = true ; } } if ( acquired = = false ) { boolean success = false ; try { shardLock . acquire ( lockTimeoutMS ) ; success = true ; } finally { if ( success = = false ) { shardLock . decWaitCount ( ) ; } } } logger . trace ( <str> , id ) ; return new ShardLock ( id ) { @Override protected void closeInternal ( ) { shardLock . release ( ) ; logger . trace ( <str> , id ) ; } } ; } public Set < ShardId > lockedShards ( ) { synchronized ( shardLocks ) { return unmodifiableSet ( new HashSet < > ( shardLocks . keySet ( ) ) ) ; } } private final class InternalShardLock { private final Semaphore mutex = new Semaphore ( <int> ) ; private int waitCount = <int> ; private ShardId shardId ; InternalShardLock ( ShardId id ) { shardId = id ; mutex . acquireUninterruptibly ( ) ; } protected void release ( ) { mutex . release ( ) ; decWaitCount ( ) ; } void incWaitCount ( ) { synchronized ( shardLocks ) { assert waitCount > <int> : <str> + waitCount + <str> ; waitCount + + ; } } private void decWaitCount ( ) { synchronized ( shardLocks ) { assert waitCount > <int> : <str> + waitCount + <str> ; - - waitCount ; logger . trace ( <str> , shardId , waitCount ) ; if ( waitCount = = <int> ) { logger . trace ( <str> , shardId ) ; InternalShardLock remove = shardLocks . remove ( shardId ) ; assert remove ! = null : <str> ; } } } void acquire ( long timeoutInMillis ) throws LockObtainFailedException { try { if ( mutex . tryAcquire ( timeoutInMillis , TimeUnit . MILLISECONDS ) = = false ) { throw new LockObtainFailedException ( <str> + shardId + <str> + timeoutInMillis + <str> ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new LockObtainFailedException ( <str> + shardId + <str> , e ) ; } } } public int localNodeId ( ) { return this . localNodeId ; } public boolean hasNodeFile ( ) { return nodePaths ! = null & & locks ! = null ; } public Path [ ] nodeDataPaths ( ) { assert assertEnvIsLocked ( ) ; if ( nodePaths = = null | | locks = = null ) { throw new IllegalStateException ( <str> ) ; } Path [ ] paths = new Path [ nodePaths . length ] ; for ( int i = <int> ; i < paths . length ; i + + ) { paths [ i ] = nodePaths [ i ] . path ; } return paths ; } public NodePath [ ] nodePaths ( ) { assert assertEnvIsLocked ( ) ; if ( nodePaths = = null | | locks = = null ) { throw new IllegalStateException ( <str> ) ; } return nodePaths ; } public Path [ ] indexPaths ( Index index ) { assert assertEnvIsLocked ( ) ; Path [ ] indexPaths = new Path [ nodePaths . length ] ; for ( int i = <int> ; i < nodePaths . length ; i + + ) { indexPaths [ i ] = nodePaths [ i ] . indicesPath . resolve ( index . name ( ) ) ; } return indexPaths ; } public Path [ ] availableShardPaths ( ShardId shardId ) { assert assertEnvIsLocked ( ) ; final NodePath [ ] nodePaths = nodePaths ( ) ; final Path [ ] shardLocations = new Path [ nodePaths . length ] ; for ( int i = <int> ; i < nodePaths . length ; i + + ) { shardLocations [ i ] = nodePaths [ i ] . resolve ( shardId ) ; } return shardLocations ; } public Set < String > findAllIndices ( ) throws IOException { if ( nodePaths = = null | | locks = = null ) { throw new IllegalStateException ( <str> ) ; } assert assertEnvIsLocked ( ) ; Set < String > indices = new HashSet < > ( ) ; for ( NodePath nodePath : nodePaths ) { Path indicesLocation = nodePath . indicesPath ; if ( Files . isDirectory ( indicesLocation ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( indicesLocation ) ) { for ( Path index : stream ) { if ( Files . isDirectory ( index ) ) { indices . add ( index . getFileName ( ) . toString ( ) ) ; } } } } } return indices ; } public Set < ShardId > findAllShardIds ( final Index index ) throws IOException { assert index ! = null ; if ( nodePaths = = null | | locks = = null ) { throw new IllegalStateException ( <str> ) ; } assert assertEnvIsLocked ( ) ; final Set < ShardId > shardIds = new HashSet < > ( ) ; String indexName = index . name ( ) ; for ( final NodePath nodePath : nodePaths ) { Path location = nodePath . indicesPath ; if ( Files . isDirectory ( location ) ) { try ( DirectoryStream < Path > indexStream = Files . newDirectoryStream ( location ) ) { for ( Path indexPath : indexStream ) { if ( indexName . equals ( indexPath . getFileName ( ) . toString ( ) ) ) { shardIds . addAll ( findAllShardsForIndex ( indexPath ) ) ; } } } } } return shardIds ; } private static Set < ShardId > findAllShardsForIndex ( Path indexPath ) throws IOException { Set < ShardId > shardIds = new HashSet < > ( ) ; if ( Files . isDirectory ( indexPath ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( indexPath ) ) { String currentIndex = indexPath . getFileName ( ) . toString ( ) ; for ( Path shardPath : stream ) { String fileName = shardPath . getFileName ( ) . toString ( ) ; if ( Files . isDirectory ( shardPath ) & & fileName . chars ( ) . allMatch ( Character : : isDigit ) ) { int shardId = Integer . parseInt ( fileName ) ; ShardId id = new ShardId ( currentIndex , shardId ) ; shardIds . add ( id ) ; } } } } return shardIds ; } @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) & & locks ! = null ) { for ( Lock lock : locks ) { try { logger . trace ( <str> , lock ) ; lock . close ( ) ; } catch ( IOException e ) { logger . trace ( <str> , e , lock ) ; } } } } private boolean assertEnvIsLocked ( ) { if ( ! closed . get ( ) & & locks ! = null ) { for ( Lock lock : locks ) { try { lock . ensureValid ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; return false ; } } } return true ; } public void ensureAtomicMoveSupported ( ) throws IOException { final NodePath [ ] nodePaths = nodePaths ( ) ; for ( NodePath nodePath : nodePaths ) { assert Files . isDirectory ( nodePath . path ) : nodePath . path + <str> ; final Path src = nodePath . path . resolve ( <str> ) ; Files . createFile ( src ) ; final Path target = nodePath . path . resolve ( <str> ) ; try { Files . move ( src , target , StandardCopyOption . ATOMIC_MOVE ) ; } catch ( AtomicMoveNotSupportedException ex ) { throw new IllegalStateException ( <str> + nodePath . path + <str> , ex ) ; } finally { Files . deleteIfExists ( src ) ; Files . deleteIfExists ( target ) ; } } } Settings getSettings ( ) { return settings ; } private Path resolveCustomLocation ( IndexSettings indexSettings ) { String customDataDir = indexSettings . customDataPath ( ) ; if ( customDataDir ! = null ) { assert sharedDataPath ! = null ; if ( addNodeId ) { return sharedDataPath . resolve ( customDataDir ) . resolve ( Integer . toString ( this . localNodeId ) ) ; } else { return sharedDataPath . resolve ( customDataDir ) ; } } else { throw new IllegalArgumentException ( <str> + IndexMetaData . SETTING_DATA_PATH + <str> ) ; } } private Path resolveCustomLocation ( IndexSettings indexSettings , final String indexName ) { return resolveCustomLocation ( indexSettings ) . resolve ( indexName ) ; } public Path resolveCustomLocation ( IndexSettings indexSettings , final ShardId shardId ) { return resolveCustomLocation ( indexSettings , shardId . index ( ) . name ( ) ) . resolve ( Integer . toString ( shardId . id ( ) ) ) ; } public static Path shardStatePathToDataPath ( Path shardPath ) { int count = shardPath . getNameCount ( ) ; assert Integer . parseInt ( shardPath . getName ( count - <int> ) . toString ( ) ) > = <int> ; assert <str> . equals ( shardPath . getName ( count - <int> ) . toString ( ) ) ; return shardPath . getParent ( ) . getParent ( ) . getParent ( ) ; } } 
