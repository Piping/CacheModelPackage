package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . BitmapFont . BitmapFontData ; import com . badlogic . gdx . graphics . g2d . GlyphLayout ; import com . badlogic . gdx . graphics . g2d . GlyphLayout . GlyphRun ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Group ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener . ChangeEvent ; import com . badlogic . gdx . scenes . scene2d . utils . ClickListener ; import com . badlogic . gdx . scenes . scene2d . utils . Disableable ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . UIUtils ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Clipboard ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . Pools ; import com . badlogic . gdx . utils . TimeUtils ; import com . badlogic . gdx . utils . Timer ; import com . badlogic . gdx . utils . Timer . Task ; public class TextField extends Widget implements Disableable { static private final char BACKSPACE = <int> ; static protected final char ENTER_DESKTOP = <str> ; static protected final char ENTER_ANDROID = <str> ; static private final char TAB = <str> ; static private final char DELETE = <int> ; static private final char BULLET = <int> ; static private final Vector2 tmp1 = new Vector2 ( ) ; static private final Vector2 tmp2 = new Vector2 ( ) ; static private final Vector2 tmp3 = new Vector2 ( ) ; static public float keyRepeatInitialTime = <float> ; static public float keyRepeatTime = <float> ; protected String text ; protected int cursor , selectionStart ; protected boolean hasSelection ; protected boolean writeEnters ; protected final GlyphLayout layout = new GlyphLayout ( ) ; protected final FloatArray glyphPositions = new FloatArray ( ) ; TextFieldStyle style ; private String messageText ; protected CharSequence displayText ; Clipboard clipboard ; InputListener inputListener ; TextFieldListener listener ; TextFieldFilter filter ; OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard ( ) ; boolean focusTraversal = true , onlyFontChars = true , disabled ; private int textHAlign = Align . left ; private float selectionX , selectionWidth ; boolean passwordMode ; private StringBuilder passwordBuffer ; private char passwordCharacter = BULLET ; protected float fontOffset , textHeight , textOffset ; float renderOffset ; private int visibleTextStart , visibleTextEnd ; private int maxLength = <int> ; private float blinkTime = <float> ; boolean cursorOn = true ; long lastBlink ; KeyRepeatTask keyRepeatTask = new KeyRepeatTask ( ) ; boolean programmaticChangeEvents ; public TextField ( String text , Skin skin ) { this ( text , skin . get ( TextFieldStyle . class ) ) ; } public TextField ( String text , Skin skin , String styleName ) { this ( text , skin . get ( styleName , TextFieldStyle . class ) ) ; } public TextField ( String text , TextFieldStyle style ) { setStyle ( style ) ; clipboard = Gdx . app . getClipboard ( ) ; initialize ( ) ; setText ( text ) ; setSize ( getPrefWidth ( ) , getPrefHeight ( ) ) ; } protected void initialize ( ) { addListener ( inputListener = createInputListener ( ) ) ; } protected InputListener createInputListener ( ) { return new TextFieldClickListener ( ) ; } protected int letterUnderCursor ( float x ) { x - = renderOffset + textOffset ; int index = glyphPositions . size - <int> ; float [ ] glyphPositions = this . glyphPositions . items ; for ( int i = <int> , n = this . glyphPositions . size ; i < n ; i + + ) { if ( glyphPositions [ i ] > x ) { index = i - <int> ; break ; } } return Math . max ( <int> , index ) ; } protected boolean isWordCharacter ( char c ) { return ( c > = <str> & & c < = <str> ) | | ( c > = <str> & & c < = <str> ) | | ( c > = <str> & & c < = <str> ) ; } protected int [ ] wordUnderCursor ( int at ) { String text = this . text ; int start = at , right = text . length ( ) , left = <int> , index = start ; for ( ; index < right ; index + + ) { if ( ! isWordCharacter ( text . charAt ( index ) ) ) { right = index ; break ; } } for ( index = start - <int> ; index > - <int> ; index - - ) { if ( ! isWordCharacter ( text . charAt ( index ) ) ) { left = index + <int> ; break ; } } return new int [ ] { left , right } ; } int [ ] wordUnderCursor ( float x ) { return wordUnderCursor ( letterUnderCursor ( x ) ) ; } boolean withinMaxLength ( int size ) { return maxLength < = <int> | | size < maxLength ; } public void setMaxLength ( int maxLength ) { this . maxLength = maxLength ; } public int getMaxLength ( ) { return this . maxLength ; } public void setOnlyFontChars ( boolean onlyFontChars ) { this . onlyFontChars = onlyFontChars ; } public void setStyle ( TextFieldStyle style ) { if ( style = = null ) throw new IllegalArgumentException ( <str> ) ; this . style = style ; textHeight = style . font . getCapHeight ( ) - style . font . getDescent ( ) * <int> ; invalidateHierarchy ( ) ; } public TextFieldStyle getStyle ( ) { return style ; } protected void calculateOffsets ( ) { float visibleWidth = getWidth ( ) ; if ( style . background ! = null ) visibleWidth - = style . background . getLeftWidth ( ) + style . background . getRightWidth ( ) ; float position = glyphPositions . get ( cursor ) ; float distance = position - Math . abs ( renderOffset ) ; if ( distance < = <int> ) { if ( cursor > <int> ) renderOffset = - glyphPositions . get ( cursor - <int> ) ; else renderOffset = <int> ; } else if ( distance > visibleWidth ) { renderOffset - = distance - visibleWidth ; } visibleTextStart = <int> ; textOffset = <int> ; float start = Math . abs ( renderOffset ) ; int glyphCount = glyphPositions . size ; float [ ] glyphPositions = this . glyphPositions . items ; float startPos = <int> ; for ( int i = <int> ; i < glyphCount ; i + + ) { if ( glyphPositions [ i ] > = start ) { visibleTextStart = i ; startPos = glyphPositions [ i ] ; textOffset = startPos - start ; break ; } } visibleTextEnd = Math . min ( displayText . length ( ) , cursor + <int> ) ; for ( ; visibleTextEnd < = displayText . length ( ) ; visibleTextEnd + + ) { if ( glyphPositions [ visibleTextEnd ] - startPos > visibleWidth ) break ; } visibleTextEnd = Math . max ( <int> , visibleTextEnd - <int> ) ; if ( hasSelection ) { int minIndex = Math . min ( cursor , selectionStart ) ; int maxIndex = Math . max ( cursor , selectionStart ) ; float minX = Math . max ( glyphPositions [ minIndex ] , startPos ) ; float maxX = Math . min ( glyphPositions [ maxIndex ] , glyphPositions [ visibleTextEnd ] ) ; selectionX = minX ; selectionWidth = maxX - minX - style . font . getData ( ) . cursorX ; } if ( ( textHAlign & Align . left ) = = <int> ) { textOffset = visibleWidth - ( glyphPositions [ visibleTextEnd ] - startPos ) ; if ( ( textHAlign & Align . center ) ! = <int> ) textOffset = Math . round ( textOffset * <float> ) ; if ( hasSelection ) selectionX + = textOffset ; } } @Override public void draw ( Batch batch , float parentAlpha ) { Stage stage = getStage ( ) ; boolean focused = stage ! = null & & stage . getKeyboardFocus ( ) = = this ; if ( ! focused ) keyRepeatTask . cancel ( ) ; final BitmapFont font = style . font ; final Color fontColor = ( disabled & & style . disabledFontColor ! = null ) ? style . disabledFontColor : ( ( focused & & style . focusedFontColor ! = null ) ? style . focusedFontColor : style . fontColor ) ; final Drawable selection = style . selection ; final Drawable cursorPatch = style . cursor ; final Drawable background = ( disabled & & style . disabledBackground ! = null ) ? style . disabledBackground : ( ( focused & & style . focusedBackground ! = null ) ? style . focusedBackground : style . background ) ; Color color = getColor ( ) ; float x = getX ( ) ; float y = getY ( ) ; float width = getWidth ( ) ; float height = getHeight ( ) ; batch . setColor ( color . r , color . g , color . b , color . a * parentAlpha ) ; float bgLeftWidth = <int> , bgRightWidth = <int> ; if ( background ! = null ) { background . draw ( batch , x , y , width , height ) ; bgLeftWidth = background . getLeftWidth ( ) ; bgRightWidth = background . getRightWidth ( ) ; } float textY = getTextY ( font , background ) ; calculateOffsets ( ) ; if ( focused & & hasSelection & & selection ! = null ) { drawSelection ( selection , batch , font , x + bgLeftWidth , y + textY ) ; } float yOffset = font . isFlipped ( ) ? - textHeight : <int> ; if ( displayText . length ( ) = = <int> ) { if ( ! focused & & messageText ! = null ) { if ( style . messageFontColor ! = null ) { font . setColor ( style . messageFontColor . r , style . messageFontColor . g , style . messageFontColor . b , style . messageFontColor . a * color . a * parentAlpha ) ; } else font . setColor ( <float> , <float> , <float> , color . a * parentAlpha ) ; BitmapFont messageFont = style . messageFont ! = null ? style . messageFont : font ; messageFont . draw ( batch , messageText , x + bgLeftWidth , y + textY + yOffset , <int> , messageText . length ( ) , width - bgLeftWidth - bgRightWidth , textHAlign , false , <str> ) ; } } else { font . setColor ( fontColor . r , fontColor . g , fontColor . b , fontColor . a * color . a * parentAlpha ) ; drawText ( batch , font , x + bgLeftWidth , y + textY + yOffset ) ; } if ( focused & & ! disabled ) { blink ( ) ; if ( cursorOn & & cursorPatch ! = null ) { drawCursor ( cursorPatch , batch , font , x + bgLeftWidth , y + textY ) ; } } } protected float getTextY ( BitmapFont font , Drawable background ) { float height = getHeight ( ) ; float textY = textHeight / <int> + font . getDescent ( ) ; if ( background ! = null ) { float bottom = background . getBottomHeight ( ) ; textY = textY + ( height - background . getTopHeight ( ) - bottom ) / <int> + bottom ; } else { textY = textY + height / <int> ; } if ( font . usesIntegerPositions ( ) ) textY = ( int ) textY ; return textY ; } protected void drawSelection ( Drawable selection , Batch batch , BitmapFont font , float x , float y ) { selection . draw ( batch , x + selectionX + renderOffset + fontOffset , y - textHeight - font . getDescent ( ) , selectionWidth , textHeight ) ; } protected void drawText ( Batch batch , BitmapFont font , float x , float y ) { font . draw ( batch , displayText , x + textOffset , y , visibleTextStart , visibleTextEnd , <int> , Align . left , false ) ; } protected void drawCursor ( Drawable cursorPatch , Batch batch , BitmapFont font , float x , float y ) { cursorPatch . draw ( batch , x + textOffset + glyphPositions . get ( cursor ) - glyphPositions . get ( visibleTextStart ) + fontOffset + font . getData ( ) . cursorX , y - textHeight - font . getDescent ( ) , cursorPatch . getMinWidth ( ) , textHeight ) ; } void updateDisplayText ( ) { BitmapFont font = style . font ; BitmapFontData data = font . getData ( ) ; String text = this . text ; int textLength = text . length ( ) ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = <int> ; i < textLength ; i + + ) { char c = text . charAt ( i ) ; buffer . append ( data . hasGlyph ( c ) ? c : <str> ) ; } String newDisplayText = buffer . toString ( ) ; if ( passwordMode & & data . hasGlyph ( passwordCharacter ) ) { if ( passwordBuffer = = null ) passwordBuffer = new StringBuilder ( newDisplayText . length ( ) ) ; if ( passwordBuffer . length ( ) > textLength ) passwordBuffer . setLength ( textLength ) ; else { for ( int i = passwordBuffer . length ( ) ; i < textLength ; i + + ) passwordBuffer . append ( passwordCharacter ) ; } displayText = passwordBuffer ; } else displayText = newDisplayText ; layout . setText ( font , displayText ) ; glyphPositions . clear ( ) ; float x = <int> ; if ( layout . runs . size > <int> ) { GlyphRun run = layout . runs . first ( ) ; FloatArray xAdvances = run . xAdvances ; fontOffset = xAdvances . first ( ) ; for ( int i = <int> , n = xAdvances . size ; i < n ; i + + ) { glyphPositions . add ( x ) ; x + = xAdvances . get ( i ) ; } } else fontOffset = <int> ; glyphPositions . add ( x ) ; if ( selectionStart > newDisplayText . length ( ) ) selectionStart = textLength ; } private void blink ( ) { if ( ! Gdx . graphics . isContinuousRendering ( ) ) { cursorOn = true ; return ; } long time = TimeUtils . nanoTime ( ) ; if ( ( time - lastBlink ) / <float> > blinkTime ) { cursorOn = ! cursorOn ; lastBlink = time ; } } public void copy ( ) { if ( hasSelection & & ! passwordMode ) { clipboard . setContents ( text . substring ( Math . min ( cursor , selectionStart ) , Math . max ( cursor , selectionStart ) ) ) ; } } public void cut ( ) { cut ( programmaticChangeEvents ) ; } void cut ( boolean fireChangeEvent ) { if ( hasSelection & & ! passwordMode ) { copy ( ) ; cursor = delete ( fireChangeEvent ) ; updateDisplayText ( ) ; } } void paste ( String content , boolean fireChangeEvent ) { if ( content = = null ) return ; StringBuilder buffer = new StringBuilder ( ) ; int textLength = text . length ( ) ; if ( hasSelection ) textLength - = Math . abs ( cursor - selectionStart ) ; BitmapFontData data = style . font . getData ( ) ; for ( int i = <int> , n = content . length ( ) ; i < n ; i + + ) { if ( ! withinMaxLength ( textLength + buffer . length ( ) ) ) break ; char c = content . charAt ( i ) ; if ( ! ( writeEnters & & ( c = = ENTER_ANDROID | | c = = ENTER_DESKTOP ) ) ) { if ( onlyFontChars & & ! data . hasGlyph ( c ) ) continue ; if ( filter ! = null & & ! filter . acceptChar ( this , c ) ) continue ; } buffer . append ( c ) ; } content = buffer . toString ( ) ; if ( hasSelection ) cursor = delete ( fireChangeEvent ) ; if ( fireChangeEvent ) changeText ( text , insert ( cursor , content , text ) ) ; else text = insert ( cursor , content , text ) ; updateDisplayText ( ) ; cursor + = content . length ( ) ; } String insert ( int position , CharSequence text , String to ) { if ( to . length ( ) = = <int> ) return text . toString ( ) ; return to . substring ( <int> , position ) + text + to . substring ( position , to . length ( ) ) ; } int delete ( boolean fireChangeEvent ) { int from = selectionStart ; int to = cursor ; int minIndex = Math . min ( from , to ) ; int maxIndex = Math . max ( from , to ) ; String newText = ( minIndex > <int> ? text . substring ( <int> , minIndex ) : <str> ) + ( maxIndex < text . length ( ) ? text . substring ( maxIndex , text . length ( ) ) : <str> ) ; if ( fireChangeEvent ) changeText ( text , newText ) ; else text = newText ; clearSelection ( ) ; return minIndex ; } public void next ( boolean up ) { Stage stage = getStage ( ) ; if ( stage = = null ) return ; getParent ( ) . localToStageCoordinates ( tmp1 . set ( getX ( ) , getY ( ) ) ) ; TextField textField = findNextTextField ( stage . getActors ( ) , null , tmp2 , tmp1 , up ) ; if ( textField = = null ) { if ( up ) tmp1 . set ( Float . MIN_VALUE , Float . MIN_VALUE ) ; else tmp1 . set ( Float . MAX_VALUE , Float . MAX_VALUE ) ; textField = findNextTextField ( getStage ( ) . getActors ( ) , null , tmp2 , tmp1 , up ) ; } if ( textField ! = null ) stage . setKeyboardFocus ( textField ) ; else Gdx . input . setOnscreenKeyboardVisible ( false ) ; } private TextField findNextTextField ( Array < Actor > actors , TextField best , Vector2 bestCoords , Vector2 currentCoords , boolean up ) { for ( int i = <int> , n = actors . size ; i < n ; i + + ) { Actor actor = actors . get ( i ) ; if ( actor = = this ) continue ; if ( actor instanceof TextField ) { TextField textField = ( TextField ) actor ; if ( textField . isDisabled ( ) | | ! textField . focusTraversal ) continue ; Vector2 actorCoords = actor . getParent ( ) . localToStageCoordinates ( tmp3 . set ( actor . getX ( ) , actor . getY ( ) ) ) ; if ( ( actorCoords . y < currentCoords . y | | ( actorCoords . y = = currentCoords . y & & actorCoords . x > currentCoords . x ) ) ^ up ) { if ( best = = null | | ( actorCoords . y > bestCoords . y | | ( actorCoords . y = = bestCoords . y & & actorCoords . x < bestCoords . x ) ) ^ up ) { best = ( TextField ) actor ; bestCoords . set ( actorCoords ) ; } } } else if ( actor instanceof Group ) best = findNextTextField ( ( ( Group ) actor ) . getChildren ( ) , best , bestCoords , currentCoords , up ) ; } return best ; } public InputListener getDefaultInputListener ( ) { return inputListener ; } public void setTextFieldListener ( TextFieldListener listener ) { this . listener = listener ; } public void setTextFieldFilter ( TextFieldFilter filter ) { this . filter = filter ; } public TextFieldFilter getTextFieldFilter ( ) { return filter ; } public void setFocusTraversal ( boolean focusTraversal ) { this . focusTraversal = focusTraversal ; } public String getMessageText ( ) { return messageText ; } public void setMessageText ( String messageText ) { this . messageText = messageText ; } public void appendText ( String str ) { if ( str = = null ) str = <str> ; clearSelection ( ) ; cursor = text . length ( ) ; paste ( str , programmaticChangeEvents ) ; } public void setText ( String str ) { if ( str = = null ) str = <str> ; if ( str . equals ( text ) ) return ; clearSelection ( ) ; String oldText = text ; text = <str> ; paste ( str , false ) ; if ( programmaticChangeEvents ) changeText ( oldText , text ) ; cursor = <int> ; } public String getText ( ) { return text ; } boolean changeText ( String oldText , String newText ) { if ( newText . equals ( oldText ) ) return false ; text = newText ; ChangeEvent changeEvent = Pools . obtain ( ChangeEvent . class ) ; boolean cancelled = fire ( changeEvent ) ; text = cancelled ? oldText : newText ; Pools . free ( changeEvent ) ; return ! cancelled ; } public void setProgrammaticChangeEvents ( boolean programmaticChangeEvents ) { this . programmaticChangeEvents = programmaticChangeEvents ; } public int getSelectionStart ( ) { return selectionStart ; } public String getSelection ( ) { return hasSelection ? text . substring ( Math . min ( selectionStart , cursor ) , Math . max ( selectionStart , cursor ) ) : <str> ; } public void setSelection ( int selectionStart , int selectionEnd ) { if ( selectionStart < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( selectionEnd < <int> ) throw new IllegalArgumentException ( <str> ) ; selectionStart = Math . min ( text . length ( ) , selectionStart ) ; selectionEnd = Math . min ( text . length ( ) , selectionEnd ) ; if ( selectionEnd = = selectionStart ) { clearSelection ( ) ; return ; } if ( selectionEnd < selectionStart ) { int temp = selectionEnd ; selectionEnd = selectionStart ; selectionStart = temp ; } hasSelection = true ; this . selectionStart = selectionStart ; cursor = selectionEnd ; } public void selectAll ( ) { setSelection ( <int> , text . length ( ) ) ; } public void clearSelection ( ) { hasSelection = false ; } public void setCursorPosition ( int cursorPosition ) { if ( cursorPosition < <int> ) throw new IllegalArgumentException ( <str> ) ; clearSelection ( ) ; cursor = Math . min ( cursorPosition , text . length ( ) ) ; } public int getCursorPosition ( ) { return cursor ; } public OnscreenKeyboard getOnscreenKeyboard ( ) { return keyboard ; } public void setOnscreenKeyboard ( OnscreenKeyboard keyboard ) { this . keyboard = keyboard ; } public void setClipboard ( Clipboard clipboard ) { this . clipboard = clipboard ; } public float getPrefWidth ( ) { return <int> ; } public float getPrefHeight ( ) { float prefHeight = textHeight ; if ( style . background ! = null ) { prefHeight = Math . max ( prefHeight + style . background . getBottomHeight ( ) + style . background . getTopHeight ( ) , style . background . getMinHeight ( ) ) ; } return prefHeight ; } public void setAlignment ( int alignment ) { this . textHAlign = alignment ; } public void setPasswordMode ( boolean passwordMode ) { this . passwordMode = passwordMode ; updateDisplayText ( ) ; } public boolean isPasswordMode ( ) { return passwordMode ; } public void setPasswordCharacter ( char passwordCharacter ) { this . passwordCharacter = passwordCharacter ; if ( passwordMode ) updateDisplayText ( ) ; } public void setBlinkTime ( float blinkTime ) { this . blinkTime = blinkTime ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public boolean isDisabled ( ) { return disabled ; } protected void moveCursor ( boolean forward , boolean jump ) { int limit = forward ? text . length ( ) : <int> ; int charOffset = forward ? <int> : - <int> ; while ( ( forward ? + + cursor < limit : - - cursor > limit ) & & jump ) { if ( ! continueCursor ( cursor , charOffset ) ) break ; } } protected boolean continueCursor ( int index , int offset ) { char c = text . charAt ( index + offset ) ; return isWordCharacter ( c ) ; } class KeyRepeatTask extends Task { int keycode ; public void run ( ) { inputListener . keyDown ( null , keycode ) ; } } static public interface TextFieldListener { public void keyTyped ( TextField textField , char c ) ; } static public interface TextFieldFilter { public boolean acceptChar ( TextField textField , char c ) ; static public class DigitsOnlyFilter implements TextFieldFilter { @Override public boolean acceptChar ( TextField textField , char c ) { return Character . isDigit ( c ) ; } } } static public interface OnscreenKeyboard { public void show ( boolean visible ) ; } static public class DefaultOnscreenKeyboard implements OnscreenKeyboard { @Override public void show ( boolean visible ) { Gdx . input . setOnscreenKeyboardVisible ( visible ) ; } } public class TextFieldClickListener extends ClickListener { public void clicked ( InputEvent event , float x , float y ) { int count = getTapCount ( ) % <int> ; if ( count = = <int> ) clearSelection ( ) ; if ( count = = <int> ) { int [ ] array = wordUnderCursor ( x ) ; setSelection ( array [ <int> ] , array [ <int> ] ) ; } if ( count = = <int> ) selectAll ( ) ; } public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { if ( ! super . touchDown ( event , x , y , pointer , button ) ) return false ; if ( pointer = = <int> & & button ! = <int> ) return false ; if ( disabled ) return true ; setCursorPosition ( x , y ) ; selectionStart = cursor ; Stage stage = getStage ( ) ; if ( stage ! = null ) stage . setKeyboardFocus ( TextField . this ) ; keyboard . show ( true ) ; hasSelection = true ; return true ; } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { super . touchDragged ( event , x , y , pointer ) ; setCursorPosition ( x , y ) ; } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { if ( selectionStart = = cursor ) hasSelection = false ; super . touchUp ( event , x , y , pointer , button ) ; } protected void setCursorPosition ( float x , float y ) { lastBlink = <int> ; cursorOn = false ; cursor = letterUnderCursor ( x ) ; } protected void goHome ( boolean jump ) { cursor = <int> ; } protected void goEnd ( boolean jump ) { cursor = text . length ( ) ; } public boolean keyDown ( InputEvent event , int keycode ) { if ( disabled ) return false ; lastBlink = <int> ; cursorOn = false ; Stage stage = getStage ( ) ; if ( stage = = null | | stage . getKeyboardFocus ( ) ! = TextField . this ) return false ; boolean repeat = false ; boolean ctrl = UIUtils . ctrl ( ) ; boolean jump = ctrl & & ! passwordMode ; if ( ctrl ) { if ( keycode = = Keys . V ) { paste ( clipboard . getContents ( ) , true ) ; repeat = true ; } if ( keycode = = Keys . C | | keycode = = Keys . INSERT ) { copy ( ) ; return true ; } if ( keycode = = Keys . X ) { cut ( true ) ; return true ; } if ( keycode = = Keys . A ) { selectAll ( ) ; return true ; } } if ( UIUtils . shift ( ) ) { if ( keycode = = Keys . INSERT ) paste ( clipboard . getContents ( ) , true ) ; if ( keycode = = Keys . FORWARD_DEL ) cut ( true ) ; selection : { int temp = cursor ; keys : { if ( keycode = = Keys . LEFT ) { moveCursor ( false , jump ) ; repeat = true ; break keys ; } if ( keycode = = Keys . RIGHT ) { moveCursor ( true , jump ) ; repeat = true ; break keys ; } if ( keycode = = Keys . HOME ) { goHome ( jump ) ; break keys ; } if ( keycode = = Keys . END ) { goEnd ( jump ) ; break keys ; } break selection ; } if ( ! hasSelection ) { selectionStart = temp ; hasSelection = true ; } } } else { if ( keycode = = Keys . LEFT ) { moveCursor ( false , jump ) ; clearSelection ( ) ; repeat = true ; } if ( keycode = = Keys . RIGHT ) { moveCursor ( true , jump ) ; clearSelection ( ) ; repeat = true ; } if ( keycode = = Keys . HOME ) { goHome ( jump ) ; clearSelection ( ) ; } if ( keycode = = Keys . END ) { goEnd ( jump ) ; clearSelection ( ) ; } } cursor = MathUtils . clamp ( cursor , <int> , text . length ( ) ) ; if ( repeat ) { scheduleKeyRepeatTask ( keycode ) ; } return true ; } protected void scheduleKeyRepeatTask ( int keycode ) { if ( ! keyRepeatTask . isScheduled ( ) | | keyRepeatTask . keycode ! = keycode ) { keyRepeatTask . keycode = keycode ; keyRepeatTask . cancel ( ) ; Timer . schedule ( keyRepeatTask , keyRepeatInitialTime , keyRepeatTime ) ; } } public boolean keyUp ( InputEvent event , int keycode ) { if ( disabled ) return false ; keyRepeatTask . cancel ( ) ; return true ; } public boolean keyTyped ( InputEvent event , char character ) { if ( disabled ) return false ; switch ( character ) { case BACKSPACE : case TAB : case ENTER_ANDROID : case ENTER_DESKTOP : break ; default : if ( character < <int> ) return false ; } Stage stage = getStage ( ) ; if ( stage = = null | | stage . getKeyboardFocus ( ) ! = TextField . this ) return false ; if ( UIUtils . isMac & & Gdx . input . isKeyPressed ( Keys . SYM ) ) return true ; if ( ( character = = TAB | | character = = ENTER_ANDROID ) & & focusTraversal ) { next ( UIUtils . shift ( ) ) ; } else { boolean delete = character = = DELETE ; boolean backspace = character = = BACKSPACE ; boolean enter = character = = ENTER_DESKTOP | | character = = ENTER_ANDROID ; boolean add = enter ? writeEnters : ( ! onlyFontChars | | style . font . getData ( ) . hasGlyph ( character ) ) ; boolean remove = backspace | | delete ; if ( add | | remove ) { String oldText = text ; int oldCursor = cursor ; if ( hasSelection ) cursor = delete ( false ) ; else { if ( backspace & & cursor > <int> ) { text = text . substring ( <int> , cursor - <int> ) + text . substring ( cursor - - ) ; renderOffset = <int> ; } if ( delete & & cursor < text . length ( ) ) { text = text . substring ( <int> , cursor ) + text . substring ( cursor + <int> ) ; } } if ( add & & ! remove ) { if ( ! enter & & filter ! = null & & ! filter . acceptChar ( TextField . this , character ) ) return true ; if ( ! withinMaxLength ( text . length ( ) ) ) return true ; String insertion = enter ? <str> : String . valueOf ( character ) ; text = insert ( cursor + + , insertion , text ) ; } if ( ! changeText ( oldText , text ) ) cursor = oldCursor ; updateDisplayText ( ) ; } } if ( listener ! = null ) listener . keyTyped ( TextField . this , character ) ; return true ; } } static public class TextFieldStyle { public BitmapFont font ; public Color fontColor ; public Color focusedFontColor , disabledFontColor ; public Drawable background , focusedBackground , disabledBackground , cursor , selection ; public BitmapFont messageFont ; public Color messageFontColor ; public TextFieldStyle ( ) { } public TextFieldStyle ( BitmapFont font , Color fontColor , Drawable cursor , Drawable selection , Drawable background ) { this . background = background ; this . cursor = cursor ; this . font = font ; this . fontColor = fontColor ; this . selection = selection ; } public TextFieldStyle ( TextFieldStyle style ) { this . messageFont = style . messageFont ; if ( style . messageFontColor ! = null ) this . messageFontColor = new Color ( style . messageFontColor ) ; this . background = style . background ; this . focusedBackground = style . focusedBackground ; this . disabledBackground = style . disabledBackground ; this . cursor = style . cursor ; this . font = style . font ; if ( style . fontColor ! = null ) this . fontColor = new Color ( style . fontColor ) ; if ( style . focusedFontColor ! = null ) this . focusedFontColor = new Color ( style . focusedFontColor ) ; if ( style . disabledFontColor ! = null ) this . disabledFontColor = new Color ( style . disabledFontColor ) ; this . selection = style . selection ; } } } 
