package org . gradle . play . plugins ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . Action ; import org . gradle . api . Incubating ; import org . gradle . api . InvalidUserCodeException ; import org . gradle . api . Task ; import org . gradle . api . file . CopySpec ; import org . gradle . api . internal . file . FileOperations ; import org . gradle . api . internal . file . copy . CopySpecInternal ; import org . gradle . api . tasks . Copy ; import org . gradle . api . tasks . application . CreateStartScripts ; import org . gradle . api . tasks . bundling . Zip ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . jvm . tasks . Jar ; import org . gradle . model . * ; import org . gradle . play . PlayApplicationBinarySpec ; import org . gradle . play . distribution . PlayDistribution ; import org . gradle . play . distribution . PlayDistributionContainer ; import org . gradle . play . internal . PlayApplicationBinarySpecInternal ; import org . gradle . play . internal . distribution . DefaultPlayDistribution ; import org . gradle . play . internal . distribution . DefaultPlayDistributionContainer ; import java . io . File ; import java . util . Collections ; import java . util . Map ; @SuppressWarnings ( <str> ) @Incubating public class PlayDistributionPlugin extends RuleSource { public static final String DISTRIBUTION_GROUP = <str> ; @Model PlayDistributionContainer distributions ( ServiceRegistry serviceRegistry ) { Instantiator instantiator = serviceRegistry . get ( Instantiator . class ) ; return new DefaultPlayDistributionContainer ( instantiator ) ; } @Mutate void createLifecycleTasks ( ModelMap < Task > tasks ) { tasks . create ( <str> , new Action < Task > ( ) { @Override public void execute ( Task task ) { task . setDescription ( <str> ) ; task . setGroup ( DISTRIBUTION_GROUP ) ; } } ) ; tasks . create ( <str> , new Action < Task > ( ) { @Override public void execute ( Task task ) { task . setDescription ( <str> ) ; task . setGroup ( DISTRIBUTION_GROUP ) ; } } ) ; } @Defaults void createDistributions ( @Path ( <str> ) PlayDistributionContainer distributions , ModelMap < PlayApplicationBinarySpecInternal > playBinaries , PlayPluginConfigurations configurations , ServiceRegistry serviceRegistry ) { FileOperations fileOperations = serviceRegistry . get ( FileOperations . class ) ; Instantiator instantiator = serviceRegistry . get ( Instantiator . class ) ; for ( PlayApplicationBinarySpecInternal binary : playBinaries ) { PlayDistribution distribution = instantiator . newInstance ( DefaultPlayDistribution . class , binary . getProjectScopedName ( ) , fileOperations . copySpec ( ) , binary ) ; distribution . setBaseName ( binary . getProjectScopedName ( ) ) ; distributions . add ( distribution ) ; } } @Mutate void createDistributionContentTasks ( ModelMap < Task > tasks , final @Path ( <str> ) File buildDir , final @Path ( <str> ) PlayDistributionContainer distributions , final PlayPluginConfigurations configurations ) { for ( final PlayDistribution distribution : distributions . withType ( PlayDistribution . class ) ) { final PlayApplicationBinarySpec binary = distribution . getBinary ( ) ; if ( binary = = null ) { throw new InvalidUserCodeException ( String . format ( <str> , distribution . getName ( ) ) ) ; } final File distJarDir = new File ( buildDir , String . format ( <str> , distribution . getName ( ) ) ) ; final String jarTaskName = String . format ( <str> , StringUtils . capitalize ( distribution . getName ( ) ) ) ; tasks . create ( jarTaskName , Jar . class , new Action < Jar > ( ) { @Override public void execute ( Jar jar ) { jar . setDescription ( <str> + binary + <str> ) ; jar . dependsOn ( binary . getTasks ( ) . withType ( Jar . class ) ) ; jar . from ( jar . getProject ( ) . zipTree ( binary . getJarFile ( ) ) ) ; jar . setDestinationDir ( distJarDir ) ; jar . setArchiveName ( binary . getJarFile ( ) . getName ( ) ) ; Map < String , Object > classpath = Maps . newHashMap ( ) ; classpath . put ( <str> , new PlayManifestClasspath ( configurations . getPlayRun ( ) , binary . getAssetsJarFile ( ) ) ) ; jar . getManifest ( ) . attributes ( classpath ) ; } } ) ; final Task distributionJar = tasks . get ( jarTaskName ) ; final File scriptsDir = new File ( buildDir , String . format ( <str> , distribution . getName ( ) ) ) ; String createStartScriptsTaskName = String . format ( <str> , StringUtils . capitalize ( distribution . getName ( ) ) ) ; tasks . create ( createStartScriptsTaskName , CreateStartScripts . class , new Action < CreateStartScripts > ( ) { @Override public void execute ( CreateStartScripts createStartScripts ) { createStartScripts . setDescription ( <str> + binary + <str> ) ; createStartScripts . setClasspath ( distributionJar . getOutputs ( ) . getFiles ( ) ) ; createStartScripts . setMainClassName ( <str> ) ; createStartScripts . setApplicationName ( distribution . getName ( ) ) ; createStartScripts . setOutputDir ( scriptsDir ) ; } } ) ; Task createStartScripts = tasks . get ( createStartScriptsTaskName ) ; CopySpecInternal distSpec = ( CopySpecInternal ) distribution . getContents ( ) ; CopySpec libSpec = distSpec . addChild ( ) . into ( <str> ) ; libSpec . from ( distributionJar ) ; libSpec . from ( binary . getAssetsJarFile ( ) ) ; libSpec . from ( configurations . getPlayRun ( ) . getAllArtifacts ( ) ) ; CopySpec binSpec = distSpec . addChild ( ) . into ( <str> ) ; binSpec . from ( createStartScripts ) ; binSpec . setFileMode ( <oct> ) ; CopySpec confSpec = distSpec . addChild ( ) . into ( <str> ) ; confSpec . from ( <str> ) . exclude ( <str> ) ; distSpec . from ( <str> ) ; } } @Mutate void createDistributionZipTasks ( ModelMap < Task > tasks , final @Path ( <str> ) File buildDir , PlayDistributionContainer distributions ) { for ( final PlayDistribution distribution : distributions . withType ( PlayDistribution . class ) ) { final String stageTaskName = String . format ( <str> , StringUtils . capitalize ( distribution . getName ( ) ) ) ; final File stageDir = new File ( buildDir , <str> ) ; final String baseName = StringUtils . isNotEmpty ( distribution . getBaseName ( ) ) ? distribution . getBaseName ( ) : distribution . getName ( ) ; tasks . create ( stageTaskName , Copy . class , new Action < Copy > ( ) { @Override public void execute ( Copy copy ) { copy . setDescription ( <str> + distribution . getName ( ) + <str> ) ; copy . setDestinationDir ( stageDir ) ; CopySpecInternal baseSpec = copy . getRootSpec ( ) . addChild ( ) ; baseSpec . into ( baseName ) ; baseSpec . with ( distribution . getContents ( ) ) ; } } ) ; tasks . named ( <str> , new Action < Task > ( ) { @Override public void execute ( Task task ) { task . dependsOn ( stageTaskName ) ; } } ) ; final Task stageTask = tasks . get ( stageTaskName ) ; final String distributionTaskName = String . format ( <str> , StringUtils . capitalize ( distribution . getName ( ) ) ) ; tasks . create ( distributionTaskName , Zip . class , new Action < Zip > ( ) { @Override public void execute ( final Zip zip ) { zip . setDescription ( <str> + distribution . getName ( ) + <str> ) ; zip . setArchiveName ( String . format ( <str> , baseName ) ) ; zip . setDestinationDir ( new File ( buildDir , <str> ) ) ; zip . from ( stageTask ) ; } } ) ; tasks . named ( <str> , new Action < Task > ( ) { @Override public void execute ( Task task ) { task . dependsOn ( distributionTaskName ) ; } } ) ; } } static class PlayManifestClasspath { final PlayPluginConfigurations . PlayConfiguration playConfiguration ; final File assetsJarFile ; public PlayManifestClasspath ( PlayPluginConfigurations . PlayConfiguration playConfiguration , File assetsJarFile ) { this . playConfiguration = playConfiguration ; this . assetsJarFile = assetsJarFile ; } @Override public String toString ( ) { return Joiner . on ( <str> ) . join ( Iterables . transform ( Iterables . concat ( playConfiguration . getAllArtifacts ( ) , Collections . singleton ( assetsJarFile ) ) , new Function < File , String > ( ) { @Override public String apply ( File input ) { return input . getName ( ) ; } } ) ) ; } } } 
