package org . gradle . launcher . daemon . client ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . internal . io . TextStream ; import org . gradle . util . DisconnectableInputStream ; import org . gradle . util . LineBufferingOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . channels . AsynchronousCloseException ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class InputForwarder implements Stoppable { private final InputStream input ; private final TextStream handler ; private final ExecutorFactory executorFactory ; private final int bufferSize ; private StoppableExecutor forwardingExecuter ; private DisconnectableInputStream disconnectableInput ; private LineBufferingOutputStream outputBuffer ; private final Lock lifecycleLock = new ReentrantLock ( ) ; private boolean started ; private boolean stopped ; public InputForwarder ( InputStream input , TextStream handler , ExecutorFactory executerFactory , int bufferSize ) { this . input = input ; this . handler = handler ; this . executorFactory = executerFactory ; this . bufferSize = bufferSize ; } public InputForwarder start ( ) { lifecycleLock . lock ( ) ; try { if ( started ) { throw new IllegalStateException ( <str> ) ; } disconnectableInput = new DisconnectableInputStream ( input , bufferSize ) ; outputBuffer = new LineBufferingOutputStream ( handler , bufferSize ) ; forwardingExecuter = executorFactory . create ( <str> ) ; forwardingExecuter . execute ( new Runnable ( ) { public void run ( ) { byte [ ] buffer = new byte [ bufferSize ] ; int readCount ; Throwable readFailure = null ; try { while ( true ) { try { readCount = disconnectableInput . read ( buffer , <int> , bufferSize ) ; if ( readCount < <int> ) { break ; } } catch ( AsynchronousCloseException e ) { break ; } catch ( IOException e ) { readFailure = e ; break ; } outputBuffer . write ( buffer , <int> , readCount ) ; } outputBuffer . flush ( ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { handler . endOfStream ( readFailure ) ; } } } ) ; started = true ; } finally { lifecycleLock . unlock ( ) ; } return this ; } public void stop ( ) { lifecycleLock . lock ( ) ; try { if ( ! stopped ) { try { disconnectableInput . close ( ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } forwardingExecuter . stop ( ) ; stopped = true ; } } finally { lifecycleLock . unlock ( ) ; } } } 
