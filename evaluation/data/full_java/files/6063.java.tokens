package org . elasticsearch . common . transport ; import com . carrotsearch . hppc . IntArrayList ; import java . util . StringTokenizer ; public class PortsRange { private final String portRange ; public PortsRange ( String portRange ) { this . portRange = portRange ; } public int [ ] ports ( ) throws NumberFormatException { final IntArrayList ports = new IntArrayList ( ) ; iterate ( new PortCallback ( ) { @Override public boolean onPortNumber ( int portNumber ) { ports . add ( portNumber ) ; return false ; } } ) ; return ports . toArray ( ) ; } public boolean iterate ( PortCallback callback ) throws NumberFormatException { StringTokenizer st = new StringTokenizer ( portRange , <str> ) ; boolean success = false ; while ( st . hasMoreTokens ( ) & & ! success ) { String portToken = st . nextToken ( ) . trim ( ) ; int index = portToken . indexOf ( <str> ) ; if ( index = = - <int> ) { int portNumber = Integer . parseInt ( portToken . trim ( ) ) ; success = callback . onPortNumber ( portNumber ) ; if ( success ) { break ; } } else { int startPort = Integer . parseInt ( portToken . substring ( <int> , index ) . trim ( ) ) ; int endPort = Integer . parseInt ( portToken . substring ( index + <int> ) . trim ( ) ) ; if ( endPort < startPort ) { throw new IllegalArgumentException ( <str> + startPort + <str> + endPort + <str> ) ; } for ( int i = startPort ; i < = endPort ; i + + ) { success = callback . onPortNumber ( i ) ; if ( success ) { break ; } } } } return success ; } public static interface PortCallback { boolean onPortNumber ( int portNumber ) ; } } 
