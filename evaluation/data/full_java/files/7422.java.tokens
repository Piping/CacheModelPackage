package org . elasticsearch . search . aggregations . pipeline . having ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . Script . ScriptField ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class BucketSelectorParser implements PipelineAggregator . Parser { public static final ParseField FORMAT = new ParseField ( <str> ) ; public static final ParseField GAP_POLICY = new ParseField ( <str> ) ; public static final ParseField PARAMS_FIELD = new ParseField ( <str> ) ; @Override public String type ( ) { return BucketSelectorPipelineAggregator . TYPE . name ( ) ; } @Override public PipelineAggregatorFactory parse ( String reducerName , XContentParser parser , SearchContext context ) throws IOException { XContentParser . Token token ; Script script = null ; String currentFieldName = null ; Map < String , String > bucketsPathsMap = null ; GapPolicy gapPolicy = GapPolicy . SKIP ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { bucketsPathsMap = new HashMap < > ( ) ; bucketsPathsMap . put ( <str> , parser . text ( ) ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , GAP_POLICY ) ) { gapPolicy = GapPolicy . parse ( context , parser . text ( ) , parser . getTokenLocation ( ) ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , ScriptField . SCRIPT ) ) { script = Script . parse ( parser , context . parseFieldMatcher ( ) ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { List < String > paths = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String path = parser . text ( ) ; paths . add ( path ) ; } bucketsPathsMap = new HashMap < > ( ) ; for ( int i = <int> ; i < paths . size ( ) ; i + + ) { bucketsPathsMap . put ( <str> + i , paths . get ( i ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , ScriptField . SCRIPT ) ) { script = Script . parse ( parser , context . parseFieldMatcher ( ) ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { Map < String , Object > map = parser . map ( ) ; bucketsPathsMap = new HashMap < > ( ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { bucketsPathsMap . put ( entry . getKey ( ) , String . valueOf ( entry . getValue ( ) ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + reducerName + <str> , parser . getTokenLocation ( ) ) ; } } if ( bucketsPathsMap = = null ) { throw new SearchParseException ( context , <str> + BUCKETS_PATH . getPreferredName ( ) + <str> + reducerName + <str> , parser . getTokenLocation ( ) ) ; } if ( script = = null ) { throw new SearchParseException ( context , <str> + ScriptField . SCRIPT . getPreferredName ( ) + <str> + reducerName + <str> , parser . getTokenLocation ( ) ) ; } return new BucketSelectorPipelineAggregator . Factory ( reducerName , bucketsPathsMap , script , gapPolicy ) ; } } 
