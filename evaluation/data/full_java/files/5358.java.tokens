package org . elasticsearch . action . search ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentFactory ; import java . io . IOException ; import java . util . Arrays ; import java . util . Iterator ; public class MultiSearchResponse extends ActionResponse implements Iterable < MultiSearchResponse . Item > , ToXContent { public static class Item implements Streamable { private SearchResponse response ; private Throwable throwable ; Item ( ) { } public Item ( SearchResponse response , Throwable throwable ) { this . response = response ; this . throwable = throwable ; } public boolean isFailure ( ) { return throwable ! = null ; } @Nullable public String getFailureMessage ( ) { return throwable = = null ? null : throwable . getMessage ( ) ; } @Nullable public SearchResponse getResponse ( ) { return this . response ; } public static Item readItem ( StreamInput in ) throws IOException { Item item = new Item ( ) ; item . readFrom ( in ) ; return item ; } @Override public void readFrom ( StreamInput in ) throws IOException { if ( in . readBoolean ( ) ) { this . response = new SearchResponse ( ) ; response . readFrom ( in ) ; } else { throwable = in . readThrowable ( ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { if ( response ! = null ) { out . writeBoolean ( true ) ; response . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; out . writeThrowable ( throwable ) ; } } public Throwable getFailure ( ) { return throwable ; } } private Item [ ] items ; MultiSearchResponse ( ) { } public MultiSearchResponse ( Item [ ] items ) { this . items = items ; } @Override public Iterator < Item > iterator ( ) { return Arrays . stream ( items ) . iterator ( ) ; } public Item [ ] getResponses ( ) { return this . items ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; items = new Item [ in . readVInt ( ) ] ; for ( int i = <int> ; i < items . length ; i + + ) { items [ i ] = Item . readItem ( in ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( items . length ) ; for ( Item item : items ) { item . writeTo ( out ) ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startArray ( Fields . RESPONSES ) ; for ( Item item : items ) { builder . startObject ( ) ; if ( item . isFailure ( ) ) { ElasticsearchException . renderThrowable ( builder , params , item . getFailure ( ) ) ; } else { item . getResponse ( ) . toXContent ( builder , params ) ; } builder . endObject ( ) ; } builder . endArray ( ) ; return builder ; } static final class Fields { static final XContentBuilderString RESPONSES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString ERROR = new XContentBuilderString ( <str> ) ; static final XContentBuilderString ROOT_CAUSE = new XContentBuilderString ( <str> ) ; } @Override public String toString ( ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; toXContent ( builder , EMPTY_PARAMS ) ; builder . endObject ( ) ; return builder . string ( ) ; } catch ( IOException e ) { return <str> + e . getMessage ( ) + <str> ; } } } 
