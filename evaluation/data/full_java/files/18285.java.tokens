package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Touchable ; import com . badlogic . gdx . scenes . scene2d . ui . Label . LabelStyle ; import com . badlogic . gdx . scenes . scene2d . ui . Value . Fixed ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . Layout ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . Pools ; public class Table extends WidgetGroup { static public Color debugTableColor = new Color ( <int> , <int> , <int> , <int> ) ; static public Color debugCellColor = new Color ( <int> , <int> , <int> , <int> ) ; static public Color debugActorColor = new Color ( <int> , <int> , <int> , <int> ) ; static final Pool < Cell > cellPool = new Pool < Cell > ( ) { protected Cell newObject ( ) { return new Cell ( ) ; } } ; static private float [ ] columnWeightedWidth , rowWeightedHeight ; private int columns , rows ; private boolean implicitEndRow ; private final Array < Cell > cells = new Array ( <int> ) ; private final Cell cellDefaults ; private final Array < Cell > columnDefaults = new Array ( <int> ) ; private Cell rowDefaults ; private boolean sizeInvalid = true ; private float [ ] columnMinWidth , rowMinHeight ; private float [ ] columnPrefWidth , rowPrefHeight ; private float tableMinWidth , tableMinHeight ; private float tablePrefWidth , tablePrefHeight ; private float [ ] columnWidth , rowHeight ; private float [ ] expandWidth , expandHeight ; Value padTop = backgroundTop , padLeft = backgroundLeft , padBottom = backgroundBottom , padRight = backgroundRight ; int align = Align . center ; Debug debug = Debug . none ; Array < DebugRect > debugRects ; Drawable background ; private boolean clip ; private Skin skin ; boolean round = true ; public Table ( ) { this ( null ) ; } public Table ( Skin skin ) { this . skin = skin ; cellDefaults = obtainCell ( ) ; setTransform ( false ) ; setTouchable ( Touchable . childrenOnly ) ; } private Cell obtainCell ( ) { Cell cell = cellPool . obtain ( ) ; cell . setLayout ( this ) ; return cell ; } public void draw ( Batch batch , float parentAlpha ) { validate ( ) ; if ( isTransform ( ) ) { applyTransform ( batch , computeTransform ( ) ) ; drawBackground ( batch , parentAlpha , <int> , <int> ) ; if ( clip ) { batch . flush ( ) ; float padLeft = this . padLeft . get ( this ) , padBottom = this . padBottom . get ( this ) ; if ( clipBegin ( padLeft , padBottom , getWidth ( ) - padLeft - padRight . get ( this ) , getHeight ( ) - padBottom - padTop . get ( this ) ) ) { drawChildren ( batch , parentAlpha ) ; batch . flush ( ) ; clipEnd ( ) ; } } else drawChildren ( batch , parentAlpha ) ; resetTransform ( batch ) ; } else { drawBackground ( batch , parentAlpha , getX ( ) , getY ( ) ) ; super . draw ( batch , parentAlpha ) ; } } protected void drawBackground ( Batch batch , float parentAlpha , float x , float y ) { if ( background = = null ) return ; Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , color . a * parentAlpha ) ; background . draw ( batch , x , y , getWidth ( ) , getHeight ( ) ) ; } public void setBackground ( String drawableName ) { if ( skin = = null ) throw new IllegalStateException ( <str> ) ; setBackground ( skin . getDrawable ( drawableName ) ) ; } public void setBackground ( Drawable background ) { if ( this . background = = background ) return ; float padTopOld = getPadTop ( ) , padLeftOld = getPadLeft ( ) , padBottomOld = getPadBottom ( ) , padRightOld = getPadRight ( ) ; this . background = background ; float padTopNew = getPadTop ( ) , padLeftNew = getPadLeft ( ) , padBottomNew = getPadBottom ( ) , padRightNew = getPadRight ( ) ; if ( padTopOld + padBottomOld ! = padTopNew + padBottomNew | | padLeftOld + padRightOld ! = padLeftNew + padRightNew ) invalidateHierarchy ( ) ; else if ( padTopOld ! = padTopNew | | padLeftOld ! = padLeftNew | | padBottomOld ! = padBottomNew | | padRightOld ! = padRightNew ) invalidate ( ) ; } public Table background ( Drawable background ) { setBackground ( background ) ; return this ; } public Table background ( String drawableName ) { setBackground ( drawableName ) ; return this ; } public Drawable getBackground ( ) { return background ; } public Actor hit ( float x , float y , boolean touchable ) { if ( clip ) { if ( touchable & & getTouchable ( ) = = Touchable . disabled ) return null ; if ( x < <int> | | x > = getWidth ( ) | | y < <int> | | y > = getHeight ( ) ) return null ; } return super . hit ( x , y , touchable ) ; } public void setClip ( boolean enabled ) { clip = enabled ; setTransform ( enabled ) ; invalidate ( ) ; } public boolean getClip ( ) { return clip ; } public void invalidate ( ) { sizeInvalid = true ; super . invalidate ( ) ; } public < T extends Actor > Cell < T > add ( T actor ) { Cell < T > cell = obtainCell ( ) ; cell . actor = actor ; if ( implicitEndRow ) { implicitEndRow = false ; rows - - ; cells . peek ( ) . endRow = false ; } Array < Cell > cells = this . cells ; int cellCount = cells . size ; if ( cellCount > <int> ) { Cell lastCell = cells . peek ( ) ; if ( ! lastCell . endRow ) { cell . column = lastCell . column + lastCell . colspan ; cell . row = lastCell . row ; } else { cell . column = <int> ; cell . row = lastCell . row + <int> ; } if ( cell . row > <int> ) { outer : for ( int i = cellCount - <int> ; i > = <int> ; i - - ) { Cell other = cells . get ( i ) ; for ( int column = other . column , nn = column + other . colspan ; column < nn ; column + + ) { if ( column = = cell . column ) { cell . cellAboveIndex = i ; break outer ; } } } } } else { cell . column = <int> ; cell . row = <int> ; } cells . add ( cell ) ; cell . set ( cellDefaults ) ; if ( cell . column < columnDefaults . size ) { Cell columnCell = columnDefaults . get ( cell . column ) ; if ( columnCell ! = null ) cell . merge ( columnCell ) ; } cell . merge ( rowDefaults ) ; if ( actor ! = null ) addActor ( actor ) ; return cell ; } public void add ( Actor . . . actors ) { for ( int i = <int> , n = actors . length ; i < n ; i + + ) add ( actors [ i ] ) ; } public Cell < Label > add ( CharSequence text ) { if ( skin = = null ) throw new IllegalStateException ( <str> ) ; return add ( new Label ( text , skin ) ) ; } public Cell < Label > add ( CharSequence text , String labelStyleName ) { if ( skin = = null ) throw new IllegalStateException ( <str> ) ; return add ( new Label ( text , skin . get ( labelStyleName , LabelStyle . class ) ) ) ; } public Cell < Label > add ( CharSequence text , String fontName , Color color ) { if ( skin = = null ) throw new IllegalStateException ( <str> ) ; return add ( new Label ( text , new LabelStyle ( skin . getFont ( fontName ) , color ) ) ) ; } public Cell < Label > add ( CharSequence text , String fontName , String colorName ) { if ( skin = = null ) throw new IllegalStateException ( <str> ) ; return add ( new Label ( text , new LabelStyle ( skin . getFont ( fontName ) , skin . getColor ( colorName ) ) ) ) ; } public Cell add ( ) { return add ( ( Actor ) null ) ; } public Cell < Stack > stack ( Actor . . . actors ) { Stack stack = new Stack ( ) ; if ( actors ! = null ) { for ( int i = <int> , n = actors . length ; i < n ; i + + ) stack . addActor ( actors [ i ] ) ; } return add ( stack ) ; } public boolean removeActor ( Actor actor ) { return removeActor ( actor , true ) ; } public boolean removeActor ( Actor actor , boolean unfocus ) { if ( ! super . removeActor ( actor , unfocus ) ) return false ; Cell cell = getCell ( actor ) ; if ( cell ! = null ) cell . actor = null ; return true ; } public void clearChildren ( ) { Array < Cell > cells = this . cells ; for ( int i = cells . size - <int> ; i > = <int> ; i - - ) { Cell cell = cells . get ( i ) ; Actor actor = cell . actor ; if ( actor ! = null ) actor . remove ( ) ; } cellPool . freeAll ( cells ) ; cells . clear ( ) ; rows = <int> ; columns = <int> ; if ( rowDefaults ! = null ) cellPool . free ( rowDefaults ) ; rowDefaults = null ; implicitEndRow = false ; super . clearChildren ( ) ; } public void reset ( ) { clear ( ) ; padTop = backgroundTop ; padLeft = backgroundLeft ; padBottom = backgroundBottom ; padRight = backgroundRight ; align = Align . center ; debug ( Debug . none ) ; cellDefaults . reset ( ) ; for ( int i = <int> , n = columnDefaults . size ; i < n ; i + + ) { Cell columnCell = columnDefaults . get ( i ) ; if ( columnCell ! = null ) cellPool . free ( columnCell ) ; } columnDefaults . clear ( ) ; } public Cell row ( ) { if ( cells . size > <int> ) { endRow ( ) ; invalidate ( ) ; } if ( rowDefaults ! = null ) cellPool . free ( rowDefaults ) ; rowDefaults = obtainCell ( ) ; rowDefaults . clear ( ) ; return rowDefaults ; } private void endRow ( ) { Array < Cell > cells = this . cells ; int rowColumns = <int> ; for ( int i = cells . size - <int> ; i > = <int> ; i - - ) { Cell cell = cells . get ( i ) ; if ( cell . endRow ) break ; rowColumns + = cell . colspan ; } columns = Math . max ( columns , rowColumns ) ; rows + + ; cells . peek ( ) . endRow = true ; } public Cell columnDefaults ( int column ) { Cell cell = columnDefaults . size > column ? columnDefaults . get ( column ) : null ; if ( cell = = null ) { cell = obtainCell ( ) ; cell . clear ( ) ; if ( column > = columnDefaults . size ) { for ( int i = columnDefaults . size ; i < column ; i + + ) columnDefaults . add ( null ) ; columnDefaults . add ( cell ) ; } else columnDefaults . set ( column , cell ) ; } return cell ; } public < T extends Actor > Cell < T > getCell ( T actor ) { Array < Cell > cells = this . cells ; for ( int i = <int> , n = cells . size ; i < n ; i + + ) { Cell c = cells . get ( i ) ; if ( c . actor = = actor ) return c ; } return null ; } public Array < Cell > getCells ( ) { return cells ; } public float getPrefWidth ( ) { if ( sizeInvalid ) computeSize ( ) ; float width = tablePrefWidth ; if ( background ! = null ) return Math . max ( width , background . getMinWidth ( ) ) ; return width ; } public float getPrefHeight ( ) { if ( sizeInvalid ) computeSize ( ) ; float height = tablePrefHeight ; if ( background ! = null ) return Math . max ( height , background . getMinHeight ( ) ) ; return height ; } public float getMinWidth ( ) { if ( sizeInvalid ) computeSize ( ) ; return tableMinWidth ; } public float getMinHeight ( ) { if ( sizeInvalid ) computeSize ( ) ; return tableMinHeight ; } public Cell defaults ( ) { return cellDefaults ; } public Table pad ( Value pad ) { if ( pad = = null ) throw new IllegalArgumentException ( <str> ) ; padTop = pad ; padLeft = pad ; padBottom = pad ; padRight = pad ; sizeInvalid = true ; return this ; } public Table pad ( Value top , Value left , Value bottom , Value right ) { if ( top = = null ) throw new IllegalArgumentException ( <str> ) ; if ( left = = null ) throw new IllegalArgumentException ( <str> ) ; if ( bottom = = null ) throw new IllegalArgumentException ( <str> ) ; if ( right = = null ) throw new IllegalArgumentException ( <str> ) ; padTop = top ; padLeft = left ; padBottom = bottom ; padRight = right ; sizeInvalid = true ; return this ; } public Table padTop ( Value padTop ) { if ( padTop = = null ) throw new IllegalArgumentException ( <str> ) ; this . padTop = padTop ; sizeInvalid = true ; return this ; } public Table padLeft ( Value padLeft ) { if ( padLeft = = null ) throw new IllegalArgumentException ( <str> ) ; this . padLeft = padLeft ; sizeInvalid = true ; return this ; } public Table padBottom ( Value padBottom ) { if ( padBottom = = null ) throw new IllegalArgumentException ( <str> ) ; this . padBottom = padBottom ; sizeInvalid = true ; return this ; } public Table padRight ( Value padRight ) { if ( padRight = = null ) throw new IllegalArgumentException ( <str> ) ; this . padRight = padRight ; sizeInvalid = true ; return this ; } public Table pad ( float pad ) { pad ( new Fixed ( pad ) ) ; return this ; } public Table pad ( float top , float left , float bottom , float right ) { padTop = new Fixed ( top ) ; padLeft = new Fixed ( left ) ; padBottom = new Fixed ( bottom ) ; padRight = new Fixed ( right ) ; sizeInvalid = true ; return this ; } public Table padTop ( float padTop ) { this . padTop = new Fixed ( padTop ) ; sizeInvalid = true ; return this ; } public Table padLeft ( float padLeft ) { this . padLeft = new Fixed ( padLeft ) ; sizeInvalid = true ; return this ; } public Table padBottom ( float padBottom ) { this . padBottom = new Fixed ( padBottom ) ; sizeInvalid = true ; return this ; } public Table padRight ( float padRight ) { this . padRight = new Fixed ( padRight ) ; sizeInvalid = true ; return this ; } public Table align ( int align ) { this . align = align ; return this ; } public Table center ( ) { align = Align . center ; return this ; } public Table top ( ) { align | = Align . top ; align & = ~ Align . bottom ; return this ; } public Table left ( ) { align | = Align . left ; align & = ~ Align . right ; return this ; } public Table bottom ( ) { align | = Align . bottom ; align & = ~ Align . top ; return this ; } public Table right ( ) { align | = Align . right ; align & = ~ Align . left ; return this ; } public void setDebug ( boolean enabled ) { debug ( enabled ? Debug . all : Debug . none ) ; } public Table debug ( ) { super . debug ( ) ; return this ; } public Table debugAll ( ) { super . debugAll ( ) ; return this ; } public Table debugTable ( ) { super . setDebug ( true ) ; if ( debug ! = Debug . table ) { this . debug = Debug . table ; invalidate ( ) ; } return this ; } public Table debugCell ( ) { super . setDebug ( true ) ; if ( debug ! = Debug . cell ) { this . debug = Debug . cell ; invalidate ( ) ; } return this ; } public Table debugActor ( ) { super . setDebug ( true ) ; if ( debug ! = Debug . actor ) { this . debug = Debug . actor ; invalidate ( ) ; } return this ; } public Table debug ( Debug debug ) { super . setDebug ( debug ! = Debug . none ) ; if ( this . debug ! = debug ) { this . debug = debug ; if ( debug = = Debug . none ) clearDebugRects ( ) ; else invalidate ( ) ; } return this ; } public Debug getTableDebug ( ) { return debug ; } public Value getPadTopValue ( ) { return padTop ; } public float getPadTop ( ) { return padTop . get ( this ) ; } public Value getPadLeftValue ( ) { return padLeft ; } public float getPadLeft ( ) { return padLeft . get ( this ) ; } public Value getPadBottomValue ( ) { return padBottom ; } public float getPadBottom ( ) { return padBottom . get ( this ) ; } public Value getPadRightValue ( ) { return padRight ; } public float getPadRight ( ) { return padRight . get ( this ) ; } public float getPadX ( ) { return padLeft . get ( this ) + padRight . get ( this ) ; } public float getPadY ( ) { return padTop . get ( this ) + padBottom . get ( this ) ; } public int getAlign ( ) { return align ; } public int getRow ( float y ) { Array < Cell > cells = this . cells ; int row = <int> ; y + = getPadTop ( ) ; int i = <int> , n = cells . size ; if ( n = = <int> ) return - <int> ; if ( n = = <int> ) return <int> ; while ( i < n ) { Cell c = cells . get ( i + + ) ; if ( c . actorY + c . computedPadTop < y ) break ; if ( c . endRow ) row + + ; } return row ; } public void setSkin ( Skin skin ) { this . skin = skin ; } public void setRound ( boolean round ) { this . round = round ; } public int getRows ( ) { return rows ; } public int getColumns ( ) { return columns ; } public float getRowHeight ( int rowIndex ) { return rowHeight [ rowIndex ] ; } public float getColumnWidth ( int columnIndex ) { return columnWidth [ columnIndex ] ; } private float [ ] ensureSize ( float [ ] array , int size ) { if ( array = = null | | array . length < size ) return new float [ size ] ; for ( int i = <int> , n = array . length ; i < n ; i + + ) array [ i ] = <int> ; return array ; } public void layout ( ) { float width = getWidth ( ) ; float height = getHeight ( ) ; layout ( <int> , <int> , width , height ) ; Array < Cell > cells = this . cells ; if ( round ) { for ( int i = <int> , n = cells . size ; i < n ; i + + ) { Cell c = cells . get ( i ) ; float actorWidth = Math . round ( c . actorWidth ) ; float actorHeight = Math . round ( c . actorHeight ) ; float actorX = Math . round ( c . actorX ) ; float actorY = height - Math . round ( c . actorY ) - actorHeight ; c . setActorBounds ( actorX , actorY , actorWidth , actorHeight ) ; Actor actor = c . actor ; if ( actor ! = null ) actor . setBounds ( actorX , actorY , actorWidth , actorHeight ) ; } } else { for ( int i = <int> , n = cells . size ; i < n ; i + + ) { Cell c = cells . get ( i ) ; float actorHeight = c . actorHeight ; float actorY = height - c . actorY - actorHeight ; c . setActorY ( actorY ) ; Actor actor = c . actor ; if ( actor ! = null ) actor . setBounds ( c . actorX , actorY , c . actorWidth , actorHeight ) ; } } Array < Actor > children = getChildren ( ) ; for ( int i = <int> , n = children . size ; i < n ; i + + ) { Actor child = children . get ( i ) ; if ( child instanceof Layout ) ( ( Layout ) child ) . validate ( ) ; } } private void computeSize ( ) { sizeInvalid = false ; Array < Cell > cells = this . cells ; int cellCount = cells . size ; if ( cellCount > <int> & & ! cells . peek ( ) . endRow ) { endRow ( ) ; implicitEndRow = true ; } else implicitEndRow = false ; int columns = this . columns , rows = this . rows ; float [ ] columnMinWidth = this . columnMinWidth = ensureSize ( this . columnMinWidth , columns ) ; float [ ] rowMinHeight = this . rowMinHeight = ensureSize ( this . rowMinHeight , rows ) ; float [ ] columnPrefWidth = this . columnPrefWidth = ensureSize ( this . columnPrefWidth , columns ) ; float [ ] rowPrefHeight = this . rowPrefHeight = ensureSize ( this . rowPrefHeight , rows ) ; float [ ] columnWidth = this . columnWidth = ensureSize ( this . columnWidth , columns ) ; float [ ] rowHeight = this . rowHeight = ensureSize ( this . rowHeight , rows ) ; float [ ] expandWidth = this . expandWidth = ensureSize ( this . expandWidth , columns ) ; float [ ] expandHeight = this . expandHeight = ensureSize ( this . expandHeight , rows ) ; float spaceRightLast = <int> ; for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; int column = c . column , row = c . row , colspan = c . colspan ; Actor a = c . actor ; if ( c . expandY ! = <int> & & expandHeight [ row ] = = <int> ) expandHeight [ row ] = c . expandY ; if ( colspan = = <int> & & c . expandX ! = <int> & & expandWidth [ column ] = = <int> ) expandWidth [ column ] = c . expandX ; c . computedPadLeft = c . padLeft . get ( a ) + ( column = = <int> ? <int> : Math . max ( <int> , c . spaceLeft . get ( a ) - spaceRightLast ) ) ; c . computedPadTop = c . padTop . get ( a ) ; if ( c . cellAboveIndex ! = - <int> ) { Cell above = cells . get ( c . cellAboveIndex ) ; c . computedPadTop + = Math . max ( <int> , c . spaceTop . get ( a ) - above . spaceBottom . get ( a ) ) ; } float spaceRight = c . spaceRight . get ( a ) ; c . computedPadRight = c . padRight . get ( a ) + ( ( column + colspan ) = = columns ? <int> : spaceRight ) ; c . computedPadBottom = c . padBottom . get ( a ) + ( row = = rows - <int> ? <int> : c . spaceBottom . get ( a ) ) ; spaceRightLast = spaceRight ; float prefWidth = c . prefWidth . get ( a ) ; float prefHeight = c . prefHeight . get ( a ) ; float minWidth = c . minWidth . get ( a ) ; float minHeight = c . minHeight . get ( a ) ; float maxWidth = c . maxWidth . get ( a ) ; float maxHeight = c . maxHeight . get ( a ) ; if ( prefWidth < minWidth ) prefWidth = minWidth ; if ( prefHeight < minHeight ) prefHeight = minHeight ; if ( maxWidth > <int> & & prefWidth > maxWidth ) prefWidth = maxWidth ; if ( maxHeight > <int> & & prefHeight > maxHeight ) prefHeight = maxHeight ; if ( colspan = = <int> ) { float hpadding = c . computedPadLeft + c . computedPadRight ; columnPrefWidth [ column ] = Math . max ( columnPrefWidth [ column ] , prefWidth + hpadding ) ; columnMinWidth [ column ] = Math . max ( columnMinWidth [ column ] , minWidth + hpadding ) ; } float vpadding = c . computedPadTop + c . computedPadBottom ; rowPrefHeight [ row ] = Math . max ( rowPrefHeight [ row ] , prefHeight + vpadding ) ; rowMinHeight [ row ] = Math . max ( rowMinHeight [ row ] , minHeight + vpadding ) ; } float uniformMinWidth = <int> , uniformMinHeight = <int> ; float uniformPrefWidth = <int> , uniformPrefHeight = <int> ; for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; int column = c . column ; int expandX = c . expandX ; outer : if ( expandX ! = <int> ) { int nn = column + c . colspan ; for ( int ii = column ; ii < nn ; ii + + ) if ( expandWidth [ ii ] ! = <int> ) break outer ; for ( int ii = column ; ii < nn ; ii + + ) expandWidth [ ii ] = expandX ; } if ( c . uniformX = = Boolean . TRUE & & c . colspan = = <int> ) { float hpadding = c . computedPadLeft + c . computedPadRight ; uniformMinWidth = Math . max ( uniformMinWidth , columnMinWidth [ column ] - hpadding ) ; uniformPrefWidth = Math . max ( uniformPrefWidth , columnPrefWidth [ column ] - hpadding ) ; } if ( c . uniformY = = Boolean . TRUE ) { float vpadding = c . computedPadTop + c . computedPadBottom ; uniformMinHeight = Math . max ( uniformMinHeight , rowMinHeight [ c . row ] - vpadding ) ; uniformPrefHeight = Math . max ( uniformPrefHeight , rowPrefHeight [ c . row ] - vpadding ) ; } } if ( uniformPrefWidth > <int> | | uniformPrefHeight > <int> ) { for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; if ( uniformPrefWidth > <int> & & c . uniformX = = Boolean . TRUE & & c . colspan = = <int> ) { float hpadding = c . computedPadLeft + c . computedPadRight ; columnMinWidth [ c . column ] = uniformMinWidth + hpadding ; columnPrefWidth [ c . column ] = uniformPrefWidth + hpadding ; } if ( uniformPrefHeight > <int> & & c . uniformY = = Boolean . TRUE ) { float vpadding = c . computedPadTop + c . computedPadBottom ; rowMinHeight [ c . row ] = uniformMinHeight + vpadding ; rowPrefHeight [ c . row ] = uniformPrefHeight + vpadding ; } } } for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; int colspan = c . colspan ; if ( colspan = = <int> ) continue ; int column = c . column ; Actor a = c . actor ; float minWidth = c . minWidth . get ( a ) ; float prefWidth = c . prefWidth . get ( a ) ; float maxWidth = c . maxWidth . get ( a ) ; if ( prefWidth < minWidth ) prefWidth = minWidth ; if ( maxWidth > <int> & & prefWidth > maxWidth ) prefWidth = maxWidth ; float spannedMinWidth = - ( c . computedPadLeft + c . computedPadRight ) , spannedPrefWidth = spannedMinWidth ; float totalExpandWidth = <int> ; for ( int ii = column , nn = ii + colspan ; ii < nn ; ii + + ) { spannedMinWidth + = columnMinWidth [ ii ] ; spannedPrefWidth + = columnPrefWidth [ ii ] ; totalExpandWidth + = expandWidth [ ii ] ; } float extraMinWidth = Math . max ( <int> , minWidth - spannedMinWidth ) ; float extraPrefWidth = Math . max ( <int> , prefWidth - spannedPrefWidth ) ; for ( int ii = column , nn = ii + colspan ; ii < nn ; ii + + ) { float ratio = totalExpandWidth = = <int> ? <float> / colspan : expandWidth [ ii ] / totalExpandWidth ; columnMinWidth [ ii ] + = extraMinWidth * ratio ; columnPrefWidth [ ii ] + = extraPrefWidth * ratio ; } } tableMinWidth = <int> ; tableMinHeight = <int> ; tablePrefWidth = <int> ; tablePrefHeight = <int> ; for ( int i = <int> ; i < columns ; i + + ) { tableMinWidth + = columnMinWidth [ i ] ; tablePrefWidth + = columnPrefWidth [ i ] ; } for ( int i = <int> ; i < rows ; i + + ) { tableMinHeight + = rowMinHeight [ i ] ; tablePrefHeight + = Math . max ( rowMinHeight [ i ] , rowPrefHeight [ i ] ) ; } float hpadding = padLeft . get ( this ) + padRight . get ( this ) ; float vpadding = padTop . get ( this ) + padBottom . get ( this ) ; tableMinWidth = tableMinWidth + hpadding ; tableMinHeight = tableMinHeight + vpadding ; tablePrefWidth = Math . max ( tablePrefWidth + hpadding , tableMinWidth ) ; tablePrefHeight = Math . max ( tablePrefHeight + vpadding , tableMinHeight ) ; } private void layout ( float layoutX , float layoutY , float layoutWidth , float layoutHeight ) { Array < Cell > cells = this . cells ; int cellCount = cells . size ; if ( sizeInvalid ) computeSize ( ) ; float padLeft = this . padLeft . get ( this ) ; float hpadding = padLeft + padRight . get ( this ) ; float padTop = this . padTop . get ( this ) ; float vpadding = padTop + padBottom . get ( this ) ; int columns = this . columns , rows = this . rows ; float [ ] expandWidth = this . expandWidth , expandHeight = this . expandHeight ; float [ ] columnWidth = this . columnWidth , rowHeight = this . rowHeight ; float totalExpandWidth = <int> , totalExpandHeight = <int> ; for ( int i = <int> ; i < columns ; i + + ) totalExpandWidth + = expandWidth [ i ] ; for ( int i = <int> ; i < rows ; i + + ) totalExpandHeight + = expandHeight [ i ] ; float [ ] columnWeightedWidth ; float totalGrowWidth = tablePrefWidth - tableMinWidth ; if ( totalGrowWidth = = <int> ) columnWeightedWidth = columnMinWidth ; else { float extraWidth = Math . min ( totalGrowWidth , Math . max ( <int> , layoutWidth - tableMinWidth ) ) ; columnWeightedWidth = Table . columnWeightedWidth = ensureSize ( Table . columnWeightedWidth , columns ) ; float [ ] columnMinWidth = this . columnMinWidth , columnPrefWidth = this . columnPrefWidth ; for ( int i = <int> ; i < columns ; i + + ) { float growWidth = columnPrefWidth [ i ] - columnMinWidth [ i ] ; float growRatio = growWidth / totalGrowWidth ; columnWeightedWidth [ i ] = columnMinWidth [ i ] + extraWidth * growRatio ; } } float [ ] rowWeightedHeight ; float totalGrowHeight = tablePrefHeight - tableMinHeight ; if ( totalGrowHeight = = <int> ) rowWeightedHeight = rowMinHeight ; else { rowWeightedHeight = Table . rowWeightedHeight = ensureSize ( Table . rowWeightedHeight , rows ) ; float extraHeight = Math . min ( totalGrowHeight , Math . max ( <int> , layoutHeight - tableMinHeight ) ) ; float [ ] rowMinHeight = this . rowMinHeight , rowPrefHeight = this . rowPrefHeight ; for ( int i = <int> ; i < rows ; i + + ) { float growHeight = rowPrefHeight [ i ] - rowMinHeight [ i ] ; float growRatio = growHeight / totalGrowHeight ; rowWeightedHeight [ i ] = rowMinHeight [ i ] + extraHeight * growRatio ; } } for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; int column = c . column , row = c . row ; Actor a = c . actor ; float spannedWeightedWidth = <int> ; int colspan = c . colspan ; for ( int ii = column , nn = ii + colspan ; ii < nn ; ii + + ) spannedWeightedWidth + = columnWeightedWidth [ ii ] ; float weightedHeight = rowWeightedHeight [ row ] ; float prefWidth = c . prefWidth . get ( a ) ; float prefHeight = c . prefHeight . get ( a ) ; float minWidth = c . minWidth . get ( a ) ; float minHeight = c . minHeight . get ( a ) ; float maxWidth = c . maxWidth . get ( a ) ; float maxHeight = c . maxHeight . get ( a ) ; if ( prefWidth < minWidth ) prefWidth = minWidth ; if ( prefHeight < minHeight ) prefHeight = minHeight ; if ( maxWidth > <int> & & prefWidth > maxWidth ) prefWidth = maxWidth ; if ( maxHeight > <int> & & prefHeight > maxHeight ) prefHeight = maxHeight ; c . actorWidth = Math . min ( spannedWeightedWidth - c . computedPadLeft - c . computedPadRight , prefWidth ) ; c . actorHeight = Math . min ( weightedHeight - c . computedPadTop - c . computedPadBottom , prefHeight ) ; if ( colspan = = <int> ) columnWidth [ column ] = Math . max ( columnWidth [ column ] , spannedWeightedWidth ) ; rowHeight [ row ] = Math . max ( rowHeight [ row ] , weightedHeight ) ; } if ( totalExpandWidth > <int> ) { float extra = layoutWidth - hpadding ; for ( int i = <int> ; i < columns ; i + + ) extra - = columnWidth [ i ] ; float used = <int> ; int lastIndex = <int> ; for ( int i = <int> ; i < columns ; i + + ) { if ( expandWidth [ i ] = = <int> ) continue ; float amount = extra * expandWidth [ i ] / totalExpandWidth ; columnWidth [ i ] + = amount ; used + = amount ; lastIndex = i ; } columnWidth [ lastIndex ] + = extra - used ; } if ( totalExpandHeight > <int> ) { float extra = layoutHeight - vpadding ; for ( int i = <int> ; i < rows ; i + + ) extra - = rowHeight [ i ] ; float used = <int> ; int lastIndex = <int> ; for ( int i = <int> ; i < rows ; i + + ) { if ( expandHeight [ i ] = = <int> ) continue ; float amount = extra * expandHeight [ i ] / totalExpandHeight ; rowHeight [ i ] + = amount ; used + = amount ; lastIndex = i ; } rowHeight [ lastIndex ] + = extra - used ; } for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; int colspan = c . colspan ; if ( colspan = = <int> ) continue ; float extraWidth = <int> ; for ( int column = c . column , nn = column + colspan ; column < nn ; column + + ) extraWidth + = columnWeightedWidth [ column ] - columnWidth [ column ] ; extraWidth - = Math . max ( <int> , c . computedPadLeft + c . computedPadRight ) ; extraWidth / = colspan ; if ( extraWidth > <int> ) { for ( int column = c . column , nn = column + colspan ; column < nn ; column + + ) columnWidth [ column ] + = extraWidth ; } } float tableWidth = hpadding , tableHeight = vpadding ; for ( int i = <int> ; i < columns ; i + + ) tableWidth + = columnWidth [ i ] ; for ( int i = <int> ; i < rows ; i + + ) tableHeight + = rowHeight [ i ] ; int align = this . align ; float x = layoutX + padLeft ; if ( ( align & Align . right ) ! = <int> ) x + = layoutWidth - tableWidth ; else if ( ( align & Align . left ) = = <int> ) x + = ( layoutWidth - tableWidth ) / <int> ; float y = layoutY + padTop ; if ( ( align & Align . bottom ) ! = <int> ) y + = layoutHeight - tableHeight ; else if ( ( align & Align . top ) = = <int> ) y + = ( layoutHeight - tableHeight ) / <int> ; float currentX = x , currentY = y ; for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; float spannedCellWidth = <int> ; for ( int column = c . column , nn = column + c . colspan ; column < nn ; column + + ) spannedCellWidth + = columnWidth [ column ] ; spannedCellWidth - = c . computedPadLeft + c . computedPadRight ; currentX + = c . computedPadLeft ; float fillX = c . fillX , fillY = c . fillY ; if ( fillX > <int> ) { c . actorWidth = Math . max ( spannedCellWidth * fillX , c . minWidth . get ( c . actor ) ) ; float maxWidth = c . maxWidth . get ( c . actor ) ; if ( maxWidth > <int> ) c . actorWidth = Math . min ( c . actorWidth , maxWidth ) ; } if ( fillY > <int> ) { c . actorHeight = Math . max ( rowHeight [ c . row ] * fillY - c . computedPadTop - c . computedPadBottom , c . minHeight . get ( c . actor ) ) ; float maxHeight = c . maxHeight . get ( c . actor ) ; if ( maxHeight > <int> ) c . actorHeight = Math . min ( c . actorHeight , maxHeight ) ; } align = c . align ; if ( ( align & Align . left ) ! = <int> ) c . actorX = currentX ; else if ( ( align & Align . right ) ! = <int> ) c . actorX = currentX + spannedCellWidth - c . actorWidth ; else c . actorX = currentX + ( spannedCellWidth - c . actorWidth ) / <int> ; if ( ( align & Align . top ) ! = <int> ) c . actorY = currentY + c . computedPadTop ; else if ( ( align & Align . bottom ) ! = <int> ) c . actorY = currentY + rowHeight [ c . row ] - c . actorHeight - c . computedPadBottom ; else c . actorY = currentY + ( rowHeight [ c . row ] - c . actorHeight + c . computedPadTop - c . computedPadBottom ) / <int> ; if ( c . endRow ) { currentX = x ; currentY + = rowHeight [ c . row ] ; } else currentX + = spannedCellWidth + c . computedPadRight ; } if ( debug = = Debug . none ) return ; clearDebugRects ( ) ; currentX = x ; currentY = y ; if ( debug = = Debug . table | | debug = = Debug . all ) { addDebugRect ( layoutX , layoutY , layoutWidth , layoutHeight , debugTableColor ) ; addDebugRect ( x , y , tableWidth - hpadding , tableHeight - vpadding , debugTableColor ) ; } for ( int i = <int> ; i < cellCount ; i + + ) { Cell c = cells . get ( i ) ; if ( debug = = Debug . actor | | debug = = Debug . all ) addDebugRect ( c . actorX , c . actorY , c . actorWidth , c . actorHeight , debugActorColor ) ; float spannedCellWidth = <int> ; for ( int column = c . column , nn = column + c . colspan ; column < nn ; column + + ) spannedCellWidth + = columnWidth [ column ] ; spannedCellWidth - = c . computedPadLeft + c . computedPadRight ; currentX + = c . computedPadLeft ; if ( debug = = Debug . cell | | debug = = Debug . all ) { addDebugRect ( currentX , currentY + c . computedPadTop , spannedCellWidth , rowHeight [ c . row ] - c . computedPadTop - c . computedPadBottom , debugCellColor ) ; } if ( c . endRow ) { currentX = x ; currentY + = rowHeight [ c . row ] ; } else currentX + = spannedCellWidth + c . computedPadRight ; } } private void clearDebugRects ( ) { if ( debugRects = = null ) return ; DebugRect . pool . freeAll ( debugRects ) ; debugRects . clear ( ) ; } private void addDebugRect ( float x , float y , float w , float h , Color color ) { if ( debugRects = = null ) debugRects = new Array ( ) ; DebugRect rect = DebugRect . pool . obtain ( ) ; rect . color = color ; rect . set ( x , getHeight ( ) - y - h , w , h ) ; debugRects . add ( rect ) ; } public void drawDebug ( ShapeRenderer shapes ) { if ( isTransform ( ) ) { applyTransform ( shapes , computeTransform ( ) ) ; drawDebugRects ( shapes ) ; if ( clip ) { shapes . flush ( ) ; float x = <int> , y = <int> , width = getWidth ( ) , height = getHeight ( ) ; if ( background ! = null ) { x = padLeft . get ( this ) ; y = padBottom . get ( this ) ; width - = x + padRight . get ( this ) ; height - = y + padTop . get ( this ) ; } if ( clipBegin ( x , y , width , height ) ) { drawDebugChildren ( shapes ) ; clipEnd ( ) ; } } else drawDebugChildren ( shapes ) ; resetTransform ( shapes ) ; } else { drawDebugRects ( shapes ) ; super . drawDebug ( shapes ) ; } } protected void drawDebugBounds ( ShapeRenderer shapes ) { } private void drawDebugRects ( ShapeRenderer shapes ) { if ( debugRects = = null | | ! getDebug ( ) ) return ; shapes . set ( ShapeType . Line ) ; shapes . setColor ( getStage ( ) . getDebugColor ( ) ) ; float x = <int> , y = <int> ; if ( ! isTransform ( ) ) { x = getX ( ) ; y = getY ( ) ; } for ( int i = <int> , n = debugRects . size ; i < n ; i + + ) { DebugRect debugRect = debugRects . get ( i ) ; shapes . setColor ( debugRect . color ) ; shapes . rect ( x + debugRect . x , y + debugRect . y , debugRect . width , debugRect . height ) ; } } public Skin getSkin ( ) { return skin ; } static public class DebugRect extends Rectangle { static Pool < DebugRect > pool = Pools . get ( DebugRect . class ) ; Color color ; } static public enum Debug { none , all , table , cell , actor } static public Value backgroundTop = new Value ( ) { public float get ( Actor context ) { Drawable background = ( ( Table ) context ) . background ; return background = = null ? <int> : background . getTopHeight ( ) ; } } ; static public Value backgroundLeft = new Value ( ) { public float get ( Actor context ) { Drawable background = ( ( Table ) context ) . background ; return background = = null ? <int> : background . getLeftWidth ( ) ; } } ; static public Value backgroundBottom = new Value ( ) { public float get ( Actor context ) { Drawable background = ( ( Table ) context ) . background ; return background = = null ? <int> : background . getBottomHeight ( ) ; } } ; static public Value backgroundRight = new Value ( ) { public float get ( Actor context ) { Drawable background = ( ( Table ) context ) . background ; return background = = null ? <int> : background . getRightWidth ( ) ; } } ; } 
