package org . gradle . messaging . remote . internal . inet ; import org . gradle . internal . UncheckedException ; import org . gradle . messaging . remote . Address ; import org . gradle . messaging . remote . internal . ConnectCompletion ; import org . gradle . messaging . remote . internal . ConnectException ; import org . gradle . messaging . remote . internal . OutgoingConnector ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . net . * ; import java . nio . channels . SocketChannel ; import java . util . List ; public class TcpOutgoingConnector implements OutgoingConnector { private static final Logger LOGGER = LoggerFactory . getLogger ( TcpOutgoingConnector . class ) ; private static final int CONNECT_TIMEOUT = <int> ; private static final int MAXIMUM_RETRIES = <int> ; public ConnectCompletion connect ( Address destinationAddress ) throws ConnectException { if ( ! ( destinationAddress instanceof InetEndpoint ) ) { throw new IllegalArgumentException ( String . format ( <str> , destinationAddress ) ) ; } InetEndpoint address = ( InetEndpoint ) destinationAddress ; LOGGER . debug ( <str> , address ) ; List < InetAddress > candidateAddresses = address . getCandidates ( ) ; try { Exception lastFailure = null ; for ( InetAddress candidate : candidateAddresses ) { LOGGER . debug ( <str> , candidate ) ; SocketChannel socketChannel ; try { socketChannel = tryConnect ( address , candidate ) ; } catch ( SocketException e ) { LOGGER . debug ( <str> , candidate ) ; lastFailure = e ; continue ; } catch ( SocketTimeoutException e ) { LOGGER . debug ( <str> , candidate ) ; lastFailure = e ; continue ; } LOGGER . debug ( <str> , socketChannel . socket ( ) . getRemoteSocketAddress ( ) ) ; return new SocketConnectCompletion ( socketChannel ) ; } throw new ConnectException ( String . format ( <str> , destinationAddress , candidateAddresses ) , lastFailure ) ; } catch ( ConnectException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , destinationAddress , candidateAddresses ) , e ) ; } } private SocketChannel tryConnect ( InetEndpoint address , InetAddress candidate ) throws IOException { SocketChannel socketChannel = SocketChannel . open ( ) ; try { socketChannel . socket ( ) . connect ( new InetSocketAddress ( candidate , address . getPort ( ) ) , CONNECT_TIMEOUT ) ; if ( ! detectSelfConnect ( socketChannel ) ) { return socketChannel ; } socketChannel . close ( ) ; } catch ( IOException e ) { socketChannel . close ( ) ; throw e ; } catch ( Throwable e ) { socketChannel . close ( ) ; throw UncheckedException . throwAsUncheckedException ( e ) ; } throw new java . net . ConnectException ( String . format ( <str> , candidate , address . getPort ( ) ) ) ; } boolean detectSelfConnect ( SocketChannel socketChannel ) { Socket socket = socketChannel . socket ( ) ; SocketAddress localAddress = socket . getLocalSocketAddress ( ) ; SocketAddress remoteAddress = socket . getRemoteSocketAddress ( ) ; if ( localAddress . equals ( remoteAddress ) ) { LOGGER . debug ( <str> , localAddress , remoteAddress ) ; return true ; } return false ; } } 
