package org . apache . cassandra . streaming ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CancellationException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; public class StreamTransferTaskTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) ) ; } @Test public void testScheduleTimeout ( ) throws Exception { String ks = KEYSPACE1 ; String cf = <str> ; InetAddress peer = FBUtilities . getBroadcastAddress ( ) ; StreamSession session = new StreamSession ( peer , peer , null , <int> , true , false ) ; ColumnFamilyStore cfs = Keyspace . open ( ks ) . getColumnFamilyStore ( cf ) ; for ( int i = <int> ; i < <int> ; i + + ) { SchemaLoader . insertData ( ks , cf , i , <int> ) ; cfs . forceBlockingFlush ( ) ; } StreamTransferTask task = new StreamTransferTask ( session , cfs . metadata . cfId ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) { List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( new Range < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) ) ; task . addTransferFile ( sstable . selfRef ( ) , <int> , sstable . getPositionsForRanges ( ranges ) , <int> ) ; } assertEquals ( <int> , task . getTotalNumberOfFiles ( ) ) ; Future f = task . scheduleTimeout ( <int> , <int> , TimeUnit . NANOSECONDS ) ; f . get ( ) ; f = task . scheduleTimeout ( <int> , <int> , TimeUnit . MILLISECONDS ) ; task . complete ( <int> ) ; try { f . get ( ) ; Assert . assertTrue ( false ) ; } catch ( CancellationException ex ) { } assertEquals ( StreamSession . State . WAIT_COMPLETE , session . state ( ) ) ; assertNull ( task . scheduleTimeout ( <int> , <int> , TimeUnit . SECONDS ) ) ; } } 
