package org . elasticsearch . cluster ; import com . carrotsearch . hppc . ObjectContainer ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . cluster . ClusterState . Custom ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class SnapshotsInProgress extends AbstractDiffable < Custom > implements Custom { public static final String TYPE = <str> ; public static final SnapshotsInProgress PROTO = new SnapshotsInProgress ( ) ; @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; SnapshotsInProgress that = ( SnapshotsInProgress ) o ; if ( ! entries . equals ( that . entries ) ) return false ; return true ; } @Override public int hashCode ( ) { return entries . hashCode ( ) ; } public static class Entry { private final State state ; private final SnapshotId snapshotId ; private final boolean includeGlobalState ; private final ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ; private final List < String > indices ; private final ImmutableOpenMap < String , List < ShardId > > waitingIndices ; private final long startTime ; public Entry ( SnapshotId snapshotId , boolean includeGlobalState , State state , List < String > indices , long startTime , ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ) { this . state = state ; this . snapshotId = snapshotId ; this . includeGlobalState = includeGlobalState ; this . indices = indices ; this . startTime = startTime ; if ( shards = = null ) { this . shards = ImmutableOpenMap . of ( ) ; this . waitingIndices = ImmutableOpenMap . of ( ) ; } else { this . shards = shards ; this . waitingIndices = findWaitingIndices ( shards ) ; } } public Entry ( Entry entry , State state , ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ) { this ( entry . snapshotId , entry . includeGlobalState , state , entry . indices , entry . startTime , shards ) ; } public Entry ( Entry entry , ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ) { this ( entry , entry . state , shards ) ; } public SnapshotId snapshotId ( ) { return this . snapshotId ; } public ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ( ) { return this . shards ; } public State state ( ) { return state ; } public List < String > indices ( ) { return indices ; } public ImmutableOpenMap < String , List < ShardId > > waitingIndices ( ) { return waitingIndices ; } public boolean includeGlobalState ( ) { return includeGlobalState ; } public long startTime ( ) { return startTime ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Entry entry = ( Entry ) o ; if ( includeGlobalState ! = entry . includeGlobalState ) return false ; if ( startTime ! = entry . startTime ) return false ; if ( ! indices . equals ( entry . indices ) ) return false ; if ( ! shards . equals ( entry . shards ) ) return false ; if ( ! snapshotId . equals ( entry . snapshotId ) ) return false ; if ( state ! = entry . state ) return false ; if ( ! waitingIndices . equals ( entry . waitingIndices ) ) return false ; return true ; } @Override public int hashCode ( ) { int result = state . hashCode ( ) ; result = <int> * result + snapshotId . hashCode ( ) ; result = <int> * result + ( includeGlobalState ? <int> : <int> ) ; result = <int> * result + shards . hashCode ( ) ; result = <int> * result + indices . hashCode ( ) ; result = <int> * result + waitingIndices . hashCode ( ) ; result = <int> * result + Long . hashCode ( startTime ) ; return result ; } private ImmutableOpenMap < String , List < ShardId > > findWaitingIndices ( ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ) { Map < String , List < ShardId > > waitingIndicesMap = new HashMap < > ( ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > entry : shards ) { if ( entry . value . state ( ) = = State . WAITING ) { List < ShardId > waitingShards = waitingIndicesMap . get ( entry . key . getIndex ( ) ) ; if ( waitingShards = = null ) { waitingShards = new ArrayList < > ( ) ; waitingIndicesMap . put ( entry . key . getIndex ( ) , waitingShards ) ; } waitingShards . add ( entry . key ) ; } } if ( waitingIndicesMap . isEmpty ( ) ) { return ImmutableOpenMap . of ( ) ; } ImmutableOpenMap . Builder < String , List < ShardId > > waitingIndicesBuilder = ImmutableOpenMap . builder ( ) ; for ( Map . Entry < String , List < ShardId > > entry : waitingIndicesMap . entrySet ( ) ) { waitingIndicesBuilder . put ( entry . getKey ( ) , Collections . unmodifiableList ( entry . getValue ( ) ) ) ; } return waitingIndicesBuilder . build ( ) ; } } public static boolean completed ( ObjectContainer < ShardSnapshotStatus > shards ) { for ( ObjectCursor < ShardSnapshotStatus > status : shards ) { if ( status . value . state ( ) . completed ( ) = = false ) { return false ; } } return true ; } public static class ShardSnapshotStatus { private State state ; private String nodeId ; private String reason ; private ShardSnapshotStatus ( ) { } public ShardSnapshotStatus ( String nodeId ) { this ( nodeId , State . INIT ) ; } public ShardSnapshotStatus ( String nodeId , State state ) { this ( nodeId , state , null ) ; } public ShardSnapshotStatus ( String nodeId , State state , String reason ) { this . nodeId = nodeId ; this . state = state ; this . reason = reason ; } public State state ( ) { return state ; } public String nodeId ( ) { return nodeId ; } public String reason ( ) { return reason ; } public static ShardSnapshotStatus readShardSnapshotStatus ( StreamInput in ) throws IOException { ShardSnapshotStatus shardSnapshotStatus = new ShardSnapshotStatus ( ) ; shardSnapshotStatus . readFrom ( in ) ; return shardSnapshotStatus ; } public void readFrom ( StreamInput in ) throws IOException { nodeId = in . readOptionalString ( ) ; state = State . fromValue ( in . readByte ( ) ) ; reason = in . readOptionalString ( ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeOptionalString ( nodeId ) ; out . writeByte ( state . value ) ; out . writeOptionalString ( reason ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; ShardSnapshotStatus status = ( ShardSnapshotStatus ) o ; if ( nodeId ! = null ? ! nodeId . equals ( status . nodeId ) : status . nodeId ! = null ) return false ; if ( reason ! = null ? ! reason . equals ( status . reason ) : status . reason ! = null ) return false ; if ( state ! = status . state ) return false ; return true ; } @Override public int hashCode ( ) { int result = state ! = null ? state . hashCode ( ) : <int> ; result = <int> * result + ( nodeId ! = null ? nodeId . hashCode ( ) : <int> ) ; result = <int> * result + ( reason ! = null ? reason . hashCode ( ) : <int> ) ; return result ; } } public static enum State { INIT ( ( byte ) <int> , false , false ) , STARTED ( ( byte ) <int> , false , false ) , SUCCESS ( ( byte ) <int> , true , false ) , FAILED ( ( byte ) <int> , true , true ) , ABORTED ( ( byte ) <int> , false , true ) , MISSING ( ( byte ) <int> , true , true ) , WAITING ( ( byte ) <int> , false , false ) ; private byte value ; private boolean completed ; private boolean failed ; State ( byte value , boolean completed , boolean failed ) { this . value = value ; this . completed = completed ; this . failed = failed ; } public byte value ( ) { return value ; } public boolean completed ( ) { return completed ; } public boolean failed ( ) { return failed ; } public static State fromValue ( byte value ) { switch ( value ) { case <int> : return INIT ; case <int> : return STARTED ; case <int> : return SUCCESS ; case <int> : return FAILED ; case <int> : return ABORTED ; case <int> : return MISSING ; case <int> : return WAITING ; default : throw new IllegalArgumentException ( <str> + value + <str> ) ; } } } private final List < Entry > entries ; public SnapshotsInProgress ( List < Entry > entries ) { this . entries = entries ; } public SnapshotsInProgress ( Entry . . . entries ) { this . entries = Arrays . asList ( entries ) ; } public List < Entry > entries ( ) { return this . entries ; } public Entry snapshot ( SnapshotId snapshotId ) { for ( Entry entry : entries ) { if ( snapshotId . equals ( entry . snapshotId ( ) ) ) { return entry ; } } return null ; } @Override public String type ( ) { return TYPE ; } @Override public SnapshotsInProgress readFrom ( StreamInput in ) throws IOException { Entry [ ] entries = new Entry [ in . readVInt ( ) ] ; for ( int i = <int> ; i < entries . length ; i + + ) { SnapshotId snapshotId = SnapshotId . readSnapshotId ( in ) ; boolean includeGlobalState = in . readBoolean ( ) ; State state = State . fromValue ( in . readByte ( ) ) ; int indices = in . readVInt ( ) ; List < String > indexBuilder = new ArrayList < > ( ) ; for ( int j = <int> ; j < indices ; j + + ) { indexBuilder . add ( in . readString ( ) ) ; } long startTime = in . readLong ( ) ; ImmutableOpenMap . Builder < ShardId , ShardSnapshotStatus > builder = ImmutableOpenMap . builder ( ) ; int shards = in . readVInt ( ) ; for ( int j = <int> ; j < shards ; j + + ) { ShardId shardId = ShardId . readShardId ( in ) ; String nodeId = in . readOptionalString ( ) ; State shardState = State . fromValue ( in . readByte ( ) ) ; builder . put ( shardId , new ShardSnapshotStatus ( nodeId , shardState ) ) ; } entries [ i ] = new Entry ( snapshotId , includeGlobalState , state , Collections . unmodifiableList ( indexBuilder ) , startTime , builder . build ( ) ) ; } return new SnapshotsInProgress ( entries ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( entries . size ( ) ) ; for ( Entry entry : entries ) { entry . snapshotId ( ) . writeTo ( out ) ; out . writeBoolean ( entry . includeGlobalState ( ) ) ; out . writeByte ( entry . state ( ) . value ( ) ) ; out . writeVInt ( entry . indices ( ) . size ( ) ) ; for ( String index : entry . indices ( ) ) { out . writeString ( index ) ; } out . writeLong ( entry . startTime ( ) ) ; out . writeVInt ( entry . shards ( ) . size ( ) ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardEntry : entry . shards ( ) ) { shardEntry . key . writeTo ( out ) ; out . writeOptionalString ( shardEntry . value . nodeId ( ) ) ; out . writeByte ( shardEntry . value . state ( ) . value ( ) ) ; } } } static final class Fields { static final XContentBuilderString REPOSITORY = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SNAPSHOTS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SNAPSHOT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INCLUDE_GLOBAL_STATE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STATE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDICES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDEX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SHARD = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NODE = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startArray ( Fields . SNAPSHOTS ) ; for ( Entry entry : entries ) { toXContent ( entry , builder , params ) ; } builder . endArray ( ) ; return builder ; } public void toXContent ( Entry entry , XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( ) ; builder . field ( Fields . REPOSITORY , entry . snapshotId ( ) . getRepository ( ) ) ; builder . field ( Fields . SNAPSHOT , entry . snapshotId ( ) . getSnapshot ( ) ) ; builder . field ( Fields . INCLUDE_GLOBAL_STATE , entry . includeGlobalState ( ) ) ; builder . field ( Fields . STATE , entry . state ( ) ) ; builder . startArray ( Fields . INDICES ) ; { for ( String index : entry . indices ( ) ) { builder . value ( index ) ; } } builder . endArray ( ) ; builder . timeValueField ( Fields . START_TIME_MILLIS , Fields . START_TIME , entry . startTime ( ) ) ; builder . startArray ( Fields . SHARDS ) ; { for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardEntry : entry . shards ) { ShardId shardId = shardEntry . key ; ShardSnapshotStatus status = shardEntry . value ; builder . startObject ( ) ; { builder . field ( Fields . INDEX , shardId . getIndex ( ) ) ; builder . field ( Fields . SHARD , shardId . getId ( ) ) ; builder . field ( Fields . STATE , status . state ( ) ) ; builder . field ( Fields . NODE , status . nodeId ( ) ) ; } builder . endObject ( ) ; } } builder . endArray ( ) ; builder . endObject ( ) ; } } 
