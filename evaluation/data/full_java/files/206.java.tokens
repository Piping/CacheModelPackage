package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . Term . Terminal ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . MultiCBuilder ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . index . SecondaryIndexManager ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkNotNull ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; public abstract class MultiColumnRestriction extends AbstractRestriction { protected final List < ColumnDefinition > columnDefs ; public MultiColumnRestriction ( List < ColumnDefinition > columnDefs ) { this . columnDefs = columnDefs ; } @Override public boolean isMultiColumn ( ) { return true ; } @Override public ColumnDefinition getFirstColumn ( ) { return columnDefs . get ( <int> ) ; } @Override public ColumnDefinition getLastColumn ( ) { return columnDefs . get ( columnDefs . size ( ) - <int> ) ; } @Override public Collection < ColumnDefinition > getColumnDefs ( ) { return columnDefs ; } @Override public final Restriction mergeWith ( Restriction otherRestriction ) throws InvalidRequestException { if ( ! otherRestriction . isMultiColumn ( ) & & ( ( SingleColumnRestriction ) otherRestriction ) . canBeConvertedToMultiColumnRestriction ( ) ) { return doMergeWith ( ( ( SingleColumnRestriction ) otherRestriction ) . toMultiColumnRestriction ( ) ) ; } return doMergeWith ( otherRestriction ) ; } protected abstract Restriction doMergeWith ( Restriction otherRestriction ) throws InvalidRequestException ; protected final String getColumnsInCommons ( Restriction otherRestriction ) { Set < ColumnDefinition > commons = new HashSet < > ( getColumnDefs ( ) ) ; commons . retainAll ( otherRestriction . getColumnDefs ( ) ) ; StringBuilder builder = new StringBuilder ( ) ; for ( ColumnDefinition columnDefinition : commons ) { if ( builder . length ( ) ! = <int> ) builder . append ( <str> ) ; builder . append ( columnDefinition . name ) ; } return builder . toString ( ) ; } @Override public final boolean hasSupportingIndex ( SecondaryIndexManager indexManager ) { for ( Index index : indexManager . listIndexes ( ) ) if ( isSupportedBy ( index ) ) return true ; return false ; } protected abstract boolean isSupportedBy ( Index index ) ; public static class EQRestriction extends MultiColumnRestriction { protected final Term value ; public EQRestriction ( List < ColumnDefinition > columnDefs , Term value ) { super ( columnDefs ) ; this . value = value ; } @Override public Iterable < Function > getFunctions ( ) { return value . getFunctions ( ) ; } @Override public String toString ( ) { return String . format ( <str> , value ) ; } @Override public Restriction doMergeWith ( Restriction otherRestriction ) throws InvalidRequestException { throw invalidRequest ( <str> , getColumnsInCommons ( otherRestriction ) ) ; } @Override protected boolean isSupportedBy ( Index index ) { for ( ColumnDefinition column : columnDefs ) if ( index . supportsExpression ( column , Operator . EQ ) ) return true ; return false ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { Tuples . Value t = ( ( Tuples . Value ) value . bind ( options ) ) ; List < ByteBuffer > values = t . getElements ( ) ; for ( int i = <int> , m = values . size ( ) ; i < m ; i + + ) { builder . addElementToAll ( values . get ( i ) ) ; checkFalse ( builder . containsNull ( ) , <str> , columnDefs . get ( i ) . name ) ; } return builder ; } @Override public final void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexMananger , QueryOptions options ) throws InvalidRequestException { Tuples . Value t = ( ( Tuples . Value ) value . bind ( options ) ) ; List < ByteBuffer > values = t . getElements ( ) ; for ( int i = <int> , m = columnDefs . size ( ) ; i < m ; i + + ) { ColumnDefinition columnDef = columnDefs . get ( i ) ; filter . add ( columnDef , Operator . EQ , values . get ( i ) ) ; } } } public abstract static class INRestriction extends MultiColumnRestriction { public INRestriction ( List < ColumnDefinition > columnDefs ) { super ( columnDefs ) ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { List < List < ByteBuffer > > splitInValues = splitValues ( options ) ; builder . addAllElementsToAll ( splitInValues ) ; if ( builder . containsNull ( ) ) throw invalidRequest ( <str> , ColumnDefinition . toIdentifiers ( columnDefs ) ) ; return builder ; } @Override public boolean isIN ( ) { return true ; } @Override public Restriction doMergeWith ( Restriction otherRestriction ) throws InvalidRequestException { throw invalidRequest ( <str> , getColumnsInCommons ( otherRestriction ) ) ; } @Override protected boolean isSupportedBy ( Index index ) { for ( ColumnDefinition column : columnDefs ) if ( index . supportsExpression ( column , Operator . IN ) ) return true ; return false ; } @Override public final void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexManager , QueryOptions options ) throws InvalidRequestException { List < List < ByteBuffer > > splitInValues = splitValues ( options ) ; checkTrue ( splitInValues . size ( ) = = <int> , <str> ) ; List < ByteBuffer > values = splitInValues . get ( <int> ) ; for ( int i = <int> , m = columnDefs . size ( ) ; i < m ; i + + ) { ColumnDefinition columnDef = columnDefs . get ( i ) ; filter . add ( columnDef , Operator . EQ , values . get ( i ) ) ; } } protected abstract List < List < ByteBuffer > > splitValues ( QueryOptions options ) throws InvalidRequestException ; } public static class InRestrictionWithValues extends INRestriction { protected final List < Term > values ; public InRestrictionWithValues ( List < ColumnDefinition > columnDefs , List < Term > values ) { super ( columnDefs ) ; this . values = values ; } @Override public Iterable < Function > getFunctions ( ) { return Terms . getFunctions ( values ) ; } @Override public String toString ( ) { return String . format ( <str> , values ) ; } @Override protected List < List < ByteBuffer > > splitValues ( QueryOptions options ) throws InvalidRequestException { List < List < ByteBuffer > > buffers = new ArrayList < > ( values . size ( ) ) ; for ( Term value : values ) { Term . MultiItemTerminal term = ( Term . MultiItemTerminal ) value . bind ( options ) ; buffers . add ( term . getElements ( ) ) ; } return buffers ; } } public static class InRestrictionWithMarker extends INRestriction { protected final AbstractMarker marker ; public InRestrictionWithMarker ( List < ColumnDefinition > columnDefs , AbstractMarker marker ) { super ( columnDefs ) ; this . marker = marker ; } @Override public Iterable < Function > getFunctions ( ) { return Collections . emptySet ( ) ; } @Override public String toString ( ) { return <str> ; } @Override protected List < List < ByteBuffer > > splitValues ( QueryOptions options ) throws InvalidRequestException { Tuples . InMarker inMarker = ( Tuples . InMarker ) marker ; Tuples . InValue inValue = inMarker . bind ( options ) ; checkNotNull ( inValue , <str> ) ; return inValue . getSplitValues ( ) ; } } public static class SliceRestriction extends MultiColumnRestriction { private final TermSlice slice ; public SliceRestriction ( List < ColumnDefinition > columnDefs , Bound bound , boolean inclusive , Term term ) { this ( columnDefs , TermSlice . newInstance ( bound , inclusive , term ) ) ; } SliceRestriction ( List < ColumnDefinition > columnDefs , TermSlice slice ) { super ( columnDefs ) ; this . slice = slice ; } @Override public boolean isSlice ( ) { return true ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { throw new UnsupportedOperationException ( ) ; } @Override public MultiCBuilder appendBoundTo ( MultiCBuilder builder , Bound bound , QueryOptions options ) { List < ByteBuffer > vals = componentBounds ( bound , options ) ; for ( int i = <int> , m = vals . size ( ) ; i < m ; i + + ) { ByteBuffer v = checkNotNull ( vals . get ( i ) , <str> , columnDefs . get ( i ) . name ) ; builder . addElementToAll ( v ) ; } return builder ; } @Override protected boolean isSupportedBy ( Index index ) { for ( ColumnDefinition def : columnDefs ) if ( slice . isSupportedBy ( def , index ) ) return true ; return false ; } @Override public boolean hasBound ( Bound b ) { return slice . hasBound ( b ) ; } @Override public Iterable < Function > getFunctions ( ) { return slice . getFunctions ( ) ; } @Override public boolean isInclusive ( Bound b ) { return slice . isInclusive ( b ) ; } @Override public Restriction doMergeWith ( Restriction otherRestriction ) throws InvalidRequestException { checkTrue ( otherRestriction . isSlice ( ) , <str> , getColumnsInCommons ( otherRestriction ) ) ; if ( ! getFirstColumn ( ) . equals ( otherRestriction . getFirstColumn ( ) ) ) { ColumnDefinition column = getFirstColumn ( ) . position ( ) > otherRestriction . getFirstColumn ( ) . position ( ) ? getFirstColumn ( ) : otherRestriction . getFirstColumn ( ) ; throw invalidRequest ( <str> , column . name ) ; } checkFalse ( hasBound ( Bound . START ) & & otherRestriction . hasBound ( Bound . START ) , <str> , getColumnsInCommons ( otherRestriction ) ) ; checkFalse ( hasBound ( Bound . END ) & & otherRestriction . hasBound ( Bound . END ) , <str> , getColumnsInCommons ( otherRestriction ) ) ; SliceRestriction otherSlice = ( SliceRestriction ) otherRestriction ; List < ColumnDefinition > newColumnDefs = columnDefs . size ( ) > = otherSlice . columnDefs . size ( ) ? columnDefs : otherSlice . columnDefs ; return new SliceRestriction ( newColumnDefs , slice . merge ( otherSlice . slice ) ) ; } @Override public final void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexManager , QueryOptions options ) throws InvalidRequestException { throw invalidRequest ( <str> ) ; } @Override public String toString ( ) { return <str> + slice ; } private List < ByteBuffer > componentBounds ( Bound b , QueryOptions options ) throws InvalidRequestException { Terminal terminal = slice . bound ( b ) . bind ( options ) ; if ( terminal instanceof Tuples . Value ) { return ( ( Tuples . Value ) terminal ) . getElements ( ) ; } return Collections . singletonList ( terminal . get ( options . getProtocolVersion ( ) ) ) ; } } public static class NotNullRestriction extends MultiColumnRestriction { public NotNullRestriction ( List < ColumnDefinition > columnDefs ) { super ( columnDefs ) ; assert columnDefs . size ( ) = = <int> ; } @Override public Iterable < Function > getFunctions ( ) { return Collections . emptyList ( ) ; } @Override public boolean isNotNull ( ) { return true ; } @Override public String toString ( ) { return <str> ; } @Override public Restriction doMergeWith ( Restriction otherRestriction ) throws InvalidRequestException { throw invalidRequest ( <str> , getColumnsInCommons ( otherRestriction ) ) ; } @Override protected boolean isSupportedBy ( Index index ) { for ( ColumnDefinition column : columnDefs ) if ( index . supportsExpression ( column , Operator . IS_NOT ) ) return true ; return false ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public final void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexMananger , QueryOptions options ) throws InvalidRequestException { throw new UnsupportedOperationException ( <str> ) ; } } } 
