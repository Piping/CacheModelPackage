package org . gradle . jvm . tasks . api ; import com . google . common . collect . Maps ; import org . apache . commons . io . FileUtils ; import org . gradle . api . DefaultTask ; import org . gradle . api . Incubating ; import org . gradle . api . tasks . * ; import org . gradle . api . tasks . incremental . IncrementalTaskInputs ; import org . gradle . api . tasks . incremental . InputFileDetails ; import org . gradle . internal . ErroringAction ; import org . gradle . internal . IoActions ; import org . gradle . jvm . tasks . api . internal . ApiClassExtractor ; import java . io . * ; import java . util . Map ; import java . util . Set ; import java . util . SortedMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . jar . JarEntry ; import java . util . jar . JarOutputStream ; @Incubating public class ApiJar extends DefaultTask { private Set < String > exportedPackages ; private File runtimeClassesDir ; private File destinationDir ; private String archiveName ; private File apiClassesDir ; @Input public Set < String > getExportedPackages ( ) { return exportedPackages ; } public void setExportedPackages ( Set < String > exportedPackages ) { this . exportedPackages = exportedPackages ; } @OutputDirectory public File getDestinationDir ( ) { return destinationDir ; } public void setDestinationDir ( File destinationDir ) { this . destinationDir = destinationDir ; } public File getApiClassesDir ( ) { return apiClassesDir ; } public void setApiClassesDir ( File apiClassesDir ) { this . apiClassesDir = apiClassesDir ; } @InputDirectory @SkipWhenEmpty public File getRuntimeClassesDir ( ) { return runtimeClassesDir ; } public void setRuntimeClassesDir ( File runtimeClassesDir ) { this . runtimeClassesDir = runtimeClassesDir ; } @Input public String getArchiveName ( ) { return archiveName ; } public void setArchiveName ( String archiveName ) { this . archiveName = archiveName ; } @TaskAction public void createApiJar ( final IncrementalTaskInputs inputs ) throws Exception { final File archivePath = new File ( destinationDir , archiveName ) ; if ( ! inputs . isIncremental ( ) ) { FileUtils . deleteQuietly ( archivePath ) ; FileUtils . deleteDirectory ( apiClassesDir ) ; } destinationDir . mkdirs ( ) ; apiClassesDir . mkdirs ( ) ; final ApiClassExtractor apiClassExtractor = new ApiClassExtractor ( exportedPackages ) ; final AtomicBoolean updated = new AtomicBoolean ( ) ; final Map < File , byte [ ] > apiClasses = Maps . newHashMap ( ) ; inputs . outOfDate ( new ErroringAction < InputFileDetails > ( ) { @Override protected void doExecute ( InputFileDetails inputFileDetails ) throws Exception { updated . set ( true ) ; File originalClassFile = inputFileDetails . getFile ( ) ; if ( ! apiClassExtractor . shouldExtractApiClassFrom ( originalClassFile ) ) { return ; } final byte [ ] apiClassBytes = apiClassExtractor . extractApiClassFrom ( originalClassFile ) ; apiClasses . put ( originalClassFile , apiClassBytes ) ; File apiClassFile = apiClassFileFor ( originalClassFile ) ; apiClassFile . getParentFile ( ) . mkdirs ( ) ; IoActions . withResource ( new FileOutputStream ( apiClassFile ) , new ErroringAction < OutputStream > ( ) { @Override protected void doExecute ( OutputStream outputStream ) throws Exception { outputStream . write ( apiClassBytes ) ; } } ) ; } } ) ; inputs . removed ( new ErroringAction < InputFileDetails > ( ) { @Override protected void doExecute ( InputFileDetails removedOriginalClassFile ) throws Exception { updated . set ( true ) ; deleteApiClassFileFor ( removedOriginalClassFile . getFile ( ) ) ; } } ) ; if ( updated . get ( ) ) { IoActions . withResource ( new JarOutputStream ( new BufferedOutputStream ( new FileOutputStream ( archivePath ) , <int> ) ) , new ErroringAction < JarOutputStream > ( ) { private final SortedMap < String , File > sortedFiles = Maps . newTreeMap ( ) ; private void writeEntries ( JarOutputStream jos ) throws Exception { for ( Map . Entry < String , File > entry : sortedFiles . entrySet ( ) ) { JarEntry je = new JarEntry ( entry . getKey ( ) ) ; je . setTime ( <int> ) ; File originalClassFile = entry . getValue ( ) ; byte [ ] apiClassBytes = apiClasses . get ( originalClassFile ) ; if ( apiClassBytes = = null ) { apiClassBytes = FileUtils . readFileToByteArray ( originalClassFile ) ; } je . setSize ( apiClassBytes . length ) ; jos . putNextEntry ( je ) ; jos . write ( apiClassBytes ) ; jos . closeEntry ( ) ; } } private void collectFiles ( String relativePath , File f ) throws Exception { String path = <str> . equals ( relativePath ) ? f . getName ( ) : relativePath + <str> + f . getName ( ) ; if ( f . isFile ( ) ) { sortedFiles . put ( path , f ) ; } else if ( f . isDirectory ( ) ) { for ( File file : f . listFiles ( ) ) { String root = relativePath = = null ? <str> : path ; collectFiles ( root , file ) ; } } } @Override protected void doExecute ( final JarOutputStream jos ) throws Exception { writeManifest ( jos ) ; collectFiles ( null , apiClassesDir ) ; writeEntries ( jos ) ; jos . close ( ) ; } private void writeManifest ( JarOutputStream jos ) throws IOException { JarEntry je = new JarEntry ( <str> ) ; je . setTime ( <int> ) ; jos . putNextEntry ( je ) ; jos . write ( <str> . getBytes ( ) ) ; jos . closeEntry ( ) ; } } ) ; } } private File apiClassFileFor ( File originalClassFile ) { StringBuilder sb = new StringBuilder ( originalClassFile . getName ( ) ) ; File cur = originalClassFile . getParentFile ( ) ; while ( ! cur . equals ( runtimeClassesDir ) ) { sb . insert ( <int> , cur . getName ( ) + File . separator ) ; cur = cur . getParentFile ( ) ; } return new File ( apiClassesDir , sb . toString ( ) ) ; } private void deleteApiClassFileFor ( File originalClassFile ) { File apiClassFile = apiClassFileFor ( originalClassFile ) ; if ( apiClassFile . exists ( ) ) { FileUtils . deleteQuietly ( apiClassFile ) ; } } } 
