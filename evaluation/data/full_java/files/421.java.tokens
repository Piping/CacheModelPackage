package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . util . Collection ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Optional ; import java . util . Set ; import java . util . function . Function ; import java . util . stream . Collectors ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . Throwables ; public class LogReplicaSet { private static final Logger logger = LoggerFactory . getLogger ( LogReplicaSet . class ) ; private final Map < File , LogReplica > replicasByFile = new LinkedHashMap < > ( ) ; private Collection < LogReplica > replicas ( ) { return replicasByFile . values ( ) ; } void addReplicas ( List < File > replicas ) { replicas . forEach ( this : : addReplica ) ; } void addReplica ( File file ) { File folder = file . getParentFile ( ) ; assert ! replicasByFile . containsKey ( folder ) ; replicasByFile . put ( folder , LogReplica . open ( file ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , file ) ; } void maybeCreateReplica ( File folder , String fileName , Set < LogRecord > records ) { if ( replicasByFile . containsKey ( folder ) ) return ; final LogReplica replica = LogReplica . create ( folder , fileName ) ; records . forEach ( replica : : append ) ; replicasByFile . put ( folder , replica ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , replica ) ; } Throwable syncFolder ( Throwable accumulate ) { return Throwables . perform ( accumulate , replicas ( ) . stream ( ) . map ( s - > s : : syncFolder ) ) ; } Throwable delete ( Throwable accumulate ) { return Throwables . perform ( accumulate , replicas ( ) . stream ( ) . map ( s - > s : : delete ) ) ; } private static boolean isPrefixMatch ( String first , String second ) { return first . length ( ) > = second . length ( ) ? first . startsWith ( second ) : second . startsWith ( first ) ; } boolean readRecords ( Set < LogRecord > records ) { Map < File , List < String > > linesByReplica = replicas ( ) . stream ( ) . map ( LogReplica : : file ) . collect ( Collectors . toMap ( Function . < File > identity ( ) , FileUtils : : readLines ) ) ; int maxNumLines = linesByReplica . values ( ) . stream ( ) . map ( List : : size ) . reduce ( <int> , Integer : : max ) ; for ( int i = <int> ; i < maxNumLines ; i + + ) { String firstLine = null ; boolean partial = false ; for ( Map . Entry < File , List < String > > entry : linesByReplica . entrySet ( ) ) { List < String > currentLines = entry . getValue ( ) ; if ( i > = currentLines . size ( ) ) continue ; String currentLine = currentLines . get ( i ) ; if ( firstLine = = null ) { firstLine = currentLine ; continue ; } if ( ! isPrefixMatch ( firstLine , currentLine ) ) { logger . error ( <str> , entry . getKey ( ) . getName ( ) , currentLine , firstLine ) ; return false ; } if ( ! firstLine . equals ( currentLine ) ) { if ( i = = currentLines . size ( ) - <int> ) { logger . warn ( <str> , entry . getKey ( ) . getName ( ) , currentLine , firstLine ) ; if ( currentLine . length ( ) > firstLine . length ( ) ) firstLine = currentLine ; partial = true ; } else { logger . error ( <str> , entry . getKey ( ) . getName ( ) , currentLine , firstLine ) ; return false ; } } } LogRecord record = LogRecord . make ( firstLine ) ; if ( records . contains ( record ) ) { logger . error ( <str> , record , record . fileName ( ) ) ; return false ; } if ( partial ) record . setPartial ( ) ; records . add ( record ) ; if ( record . isFinal ( ) & & i ! = ( maxNumLines - <int> ) ) { logger . error ( <str> , record . fileName ( ) ) ; return false ; } } return true ; } void append ( LogRecord record ) { Throwable err = Throwables . perform ( null , replicas ( ) . stream ( ) . map ( r - > ( ) - > r . append ( record ) ) ) ; if ( err ! = null ) { if ( ! record . isFinal ( ) | | err . getSuppressed ( ) . length = = replicas ( ) . size ( ) - <int> ) Throwables . maybeFail ( err ) ; logger . error ( <str> , record , this ) ; } } boolean exists ( ) { Optional < Boolean > ret = replicas ( ) . stream ( ) . map ( LogReplica : : exists ) . reduce ( Boolean : : logicalAnd ) ; return ret . isPresent ( ) ? ret . get ( ) : false ; } void close ( ) { Throwables . maybeFail ( Throwables . perform ( null , replicas ( ) . stream ( ) . map ( r - > r : : close ) ) ) ; } @Override public String toString ( ) { Optional < String > ret = replicas ( ) . stream ( ) . map ( LogReplica : : toString ) . reduce ( String : : concat ) ; return ret . isPresent ( ) ? ret . get ( ) : <str> ; } @VisibleForTesting List < File > getFiles ( ) { return replicas ( ) . stream ( ) . map ( LogReplica : : file ) . collect ( Collectors . toList ( ) ) ; } @VisibleForTesting List < String > getFilePaths ( ) { return replicas ( ) . stream ( ) . map ( LogReplica : : file ) . map ( File : : getPath ) . collect ( Collectors . toList ( ) ) ; } } 
