package org . nd4j . linalg . api . rng . distribution . impl ; import org . apache . commons . math3 . special . Gamma ; import org . apache . commons . math3 . util . FastMath ; import org . apache . commons . math3 . util . MathUtils ; public class SaddlePointExpansion { private static final double HALF_LOG_2_PI = <float> * FastMath . log ( MathUtils . TWO_PI ) ; private static final double [ ] EXACT_STIRLING_ERRORS = { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } ; private SaddlePointExpansion ( ) { super ( ) ; } public static double getStirlingError ( double z ) { double ret ; if ( z < <float> ) { double z2 = <float> * z ; if ( FastMath . floor ( z2 ) = = z2 ) { ret = EXACT_STIRLING_ERRORS [ ( int ) z2 ] ; } else { ret = Gamma . logGamma ( z + <float> ) - ( z + <float> ) * FastMath . log ( z ) + z - HALF_LOG_2_PI ; } } else { double z2 = z * z ; ret = ( <float> - ( <float> - ( <float> - ( <float> - <float> / z2 ) / z2 ) / z2 ) / z2 ) / z ; } return ret ; } public static double getDeviancePart ( double x , double mu ) { double ret ; if ( FastMath . abs ( x - mu ) < <float> * ( x + mu ) ) { double d = x - mu ; double v = d / ( x + mu ) ; double s1 = v * d ; double s = Double . NaN ; double ej = <float> * x * v ; v = v * v ; int j = <int> ; while ( s1 ! = s ) { s = s1 ; ej * = v ; s1 = s + ej / ( ( j * <int> ) + <int> ) ; + + j ; } ret = s1 ; } else { ret = x * FastMath . log ( x / mu ) + mu - x ; } return ret ; } public static double logBinomialProbability ( int x , int n , double p , double q ) { double ret ; if ( x = = <int> ) { if ( p < <float> ) { ret = - getDeviancePart ( n , n * q ) - n * p ; } else { ret = n * FastMath . log ( q ) ; } } else if ( x = = n ) { if ( q < <float> ) { ret = - getDeviancePart ( n , n * p ) - n * q ; } else { ret = n * FastMath . log ( p ) ; } } else { ret = getStirlingError ( n ) - getStirlingError ( x ) - getStirlingError ( n - x ) - getDeviancePart ( x , n * p ) - getDeviancePart ( n - x , n * q ) ; double f = ( MathUtils . TWO_PI * x * ( n - x ) ) / n ; ret = - <float> * FastMath . log ( f ) + ret ; } return ret ; } } 
