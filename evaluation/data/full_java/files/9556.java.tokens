package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static java . lang . Math . max ; import static java . util . concurrent . TimeUnit . MICROSECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Stopwatch ; import com . google . common . util . concurrent . SmoothRateLimiter . SmoothBursty ; import com . google . common . util . concurrent . SmoothRateLimiter . SmoothWarmingUp ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; import javax . annotation . concurrent . ThreadSafe ; @ThreadSafe @Beta public abstract class RateLimiter { public static RateLimiter create ( double permitsPerSecond ) { return create ( SleepingStopwatch . createFromSystemTimer ( ) , permitsPerSecond ) ; } @VisibleForTesting static RateLimiter create ( SleepingStopwatch stopwatch , double permitsPerSecond ) { RateLimiter rateLimiter = new SmoothBursty ( stopwatch , <float> ) ; rateLimiter . setRate ( permitsPerSecond ) ; return rateLimiter ; } public static RateLimiter create ( double permitsPerSecond , long warmupPeriod , TimeUnit unit ) { checkArgument ( warmupPeriod > = <int> , <str> , warmupPeriod ) ; return create ( SleepingStopwatch . createFromSystemTimer ( ) , permitsPerSecond , warmupPeriod , unit , <float> ) ; } @VisibleForTesting static RateLimiter create ( SleepingStopwatch stopwatch , double permitsPerSecond , long warmupPeriod , TimeUnit unit , double coldFactor ) { RateLimiter rateLimiter = new SmoothWarmingUp ( stopwatch , warmupPeriod , unit , coldFactor ) ; rateLimiter . setRate ( permitsPerSecond ) ; return rateLimiter ; } private final SleepingStopwatch stopwatch ; private volatile Object mutexDoNotUseDirectly ; private Object mutex ( ) { Object mutex = mutexDoNotUseDirectly ; if ( mutex = = null ) { synchronized ( this ) { mutex = mutexDoNotUseDirectly ; if ( mutex = = null ) { mutexDoNotUseDirectly = mutex = new Object ( ) ; } } } return mutex ; } RateLimiter ( SleepingStopwatch stopwatch ) { this . stopwatch = checkNotNull ( stopwatch ) ; } public final void setRate ( double permitsPerSecond ) { checkArgument ( permitsPerSecond > <float> & & ! Double . isNaN ( permitsPerSecond ) , <str> ) ; synchronized ( mutex ( ) ) { doSetRate ( permitsPerSecond , stopwatch . readMicros ( ) ) ; } } abstract void doSetRate ( double permitsPerSecond , long nowMicros ) ; public final double getRate ( ) { synchronized ( mutex ( ) ) { return doGetRate ( ) ; } } abstract double doGetRate ( ) ; public double acquire ( ) { return acquire ( <int> ) ; } public double acquire ( int permits ) { long microsToWait = reserve ( permits ) ; stopwatch . sleepMicrosUninterruptibly ( microsToWait ) ; return <float> * microsToWait / SECONDS . toMicros ( <int> ) ; } final long reserve ( int permits ) { checkPermits ( permits ) ; synchronized ( mutex ( ) ) { return reserveAndGetWaitLength ( permits , stopwatch . readMicros ( ) ) ; } } public boolean tryAcquire ( long timeout , TimeUnit unit ) { return tryAcquire ( <int> , timeout , unit ) ; } public boolean tryAcquire ( int permits ) { return tryAcquire ( permits , <int> , MICROSECONDS ) ; } public boolean tryAcquire ( ) { return tryAcquire ( <int> , <int> , MICROSECONDS ) ; } public boolean tryAcquire ( int permits , long timeout , TimeUnit unit ) { long timeoutMicros = max ( unit . toMicros ( timeout ) , <int> ) ; checkPermits ( permits ) ; long microsToWait ; synchronized ( mutex ( ) ) { long nowMicros = stopwatch . readMicros ( ) ; if ( ! canAcquire ( nowMicros , timeoutMicros ) ) { return false ; } else { microsToWait = reserveAndGetWaitLength ( permits , nowMicros ) ; } } stopwatch . sleepMicrosUninterruptibly ( microsToWait ) ; return true ; } private boolean canAcquire ( long nowMicros , long timeoutMicros ) { return queryEarliestAvailable ( nowMicros ) - timeoutMicros < = nowMicros ; } final long reserveAndGetWaitLength ( int permits , long nowMicros ) { long momentAvailable = reserveEarliestAvailable ( permits , nowMicros ) ; return max ( momentAvailable - nowMicros , <int> ) ; } abstract long queryEarliestAvailable ( long nowMicros ) ; abstract long reserveEarliestAvailable ( int permits , long nowMicros ) ; @Override public String toString ( ) { return String . format ( Locale . ROOT , <str> , getRate ( ) ) ; } abstract static class SleepingStopwatch { protected SleepingStopwatch ( ) { } protected abstract long readMicros ( ) ; protected abstract void sleepMicrosUninterruptibly ( long micros ) ; public static final SleepingStopwatch createFromSystemTimer ( ) { return new SleepingStopwatch ( ) { final Stopwatch stopwatch = Stopwatch . createStarted ( ) ; @Override protected long readMicros ( ) { return stopwatch . elapsed ( MICROSECONDS ) ; } @Override protected void sleepMicrosUninterruptibly ( long micros ) { if ( micros > <int> ) { Uninterruptibles . sleepUninterruptibly ( micros , MICROSECONDS ) ; } } } ; } } private static int checkPermits ( int permits ) { checkArgument ( permits > <int> , <str> , permits ) ; return permits ; } } 
