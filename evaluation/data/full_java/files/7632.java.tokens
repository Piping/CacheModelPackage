package org . elasticsearch . snapshots ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . apache . lucene . index . IndexCommit ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . SnapshotsInProgress ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . engine . SnapshotFailedEngineException ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . snapshots . IndexShardSnapshotFailedException ; import org . elasticsearch . index . snapshots . IndexShardSnapshotStatus ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . EmptyTransportResponseHandler ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . cluster . SnapshotsInProgress . completed ; public class SnapshotShardsService extends AbstractLifecycleComponent < SnapshotShardsService > implements ClusterStateListener { public static final String UPDATE_SNAPSHOT_ACTION_NAME = <str> ; private final ClusterService clusterService ; private final IndicesService indicesService ; private final SnapshotsService snapshotsService ; private final TransportService transportService ; private final ThreadPool threadPool ; private final Lock shutdownLock = new ReentrantLock ( ) ; private final Condition shutdownCondition = shutdownLock . newCondition ( ) ; private volatile Map < SnapshotId , SnapshotShards > shardSnapshots = emptyMap ( ) ; private final BlockingQueue < UpdateIndexShardSnapshotStatusRequest > updatedSnapshotStateQueue = ConcurrentCollections . newBlockingQueue ( ) ; @Inject public SnapshotShardsService ( Settings settings , ClusterService clusterService , SnapshotsService snapshotsService , ThreadPool threadPool , TransportService transportService , IndicesService indicesService ) { super ( settings ) ; this . indicesService = indicesService ; this . snapshotsService = snapshotsService ; this . transportService = transportService ; this . clusterService = clusterService ; this . threadPool = threadPool ; if ( DiscoveryNode . dataNode ( settings ) ) { clusterService . addLast ( this ) ; } if ( DiscoveryNode . masterNode ( settings ) ) { transportService . registerRequestHandler ( UPDATE_SNAPSHOT_ACTION_NAME , UpdateIndexShardSnapshotStatusRequest : : new , ThreadPool . Names . SAME , new UpdateSnapshotStateRequestHandler ( ) ) ; } } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { shutdownLock . lock ( ) ; try { while ( ! shardSnapshots . isEmpty ( ) & & shutdownCondition . await ( <int> , TimeUnit . SECONDS ) ) { } } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } finally { shutdownLock . unlock ( ) ; } } @Override protected void doClose ( ) { clusterService . remove ( this ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { try { SnapshotsInProgress prev = event . previousState ( ) . custom ( SnapshotsInProgress . TYPE ) ; SnapshotsInProgress curr = event . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( prev = = null ) { if ( curr ! = null ) { processIndexShardSnapshots ( event ) ; } } else if ( prev . equals ( curr ) = = false ) { processIndexShardSnapshots ( event ) ; } String masterNodeId = event . state ( ) . nodes ( ) . masterNodeId ( ) ; if ( masterNodeId ! = null & & masterNodeId . equals ( event . previousState ( ) . nodes ( ) . masterNodeId ( ) ) = = false ) { syncShardStatsOnNewMaster ( event ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } public Map < ShardId , IndexShardSnapshotStatus > currentSnapshotShards ( SnapshotId snapshotId ) { SnapshotShards snapshotShards = shardSnapshots . get ( snapshotId ) ; if ( snapshotShards = = null ) { return null ; } else { return snapshotShards . shards ; } } private void processIndexShardSnapshots ( ClusterChangedEvent event ) { SnapshotsInProgress snapshotsInProgress = event . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; Map < SnapshotId , SnapshotShards > survivors = new HashMap < > ( ) ; for ( Map . Entry < SnapshotId , SnapshotShards > entry : shardSnapshots . entrySet ( ) ) { if ( snapshotsInProgress ! = null & & snapshotsInProgress . snapshot ( entry . getKey ( ) ) ! = null ) { survivors . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } Map < SnapshotId , Map < ShardId , IndexShardSnapshotStatus > > newSnapshots = new HashMap < > ( ) ; final String localNodeId = clusterService . localNode ( ) . id ( ) ; if ( snapshotsInProgress ! = null ) { for ( SnapshotsInProgress . Entry entry : snapshotsInProgress . entries ( ) ) { if ( entry . state ( ) = = SnapshotsInProgress . State . STARTED ) { Map < ShardId , IndexShardSnapshotStatus > startedShards = new HashMap < > ( ) ; SnapshotShards snapshotShards = shardSnapshots . get ( entry . snapshotId ( ) ) ; for ( ObjectObjectCursor < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shard : entry . shards ( ) ) { if ( localNodeId . equals ( shard . value . nodeId ( ) ) ) { if ( shard . value . state ( ) = = SnapshotsInProgress . State . INIT & & ( snapshotShards = = null | | ! snapshotShards . shards . containsKey ( shard . key ) ) ) { logger . trace ( <str> , shard . key ) ; startedShards . put ( shard . key , new IndexShardSnapshotStatus ( ) ) ; } } } if ( ! startedShards . isEmpty ( ) ) { newSnapshots . put ( entry . snapshotId ( ) , startedShards ) ; if ( snapshotShards ! = null ) { Map < ShardId , IndexShardSnapshotStatus > shards = new HashMap < > ( ) ; shards . putAll ( snapshotShards . shards ) ; shards . putAll ( startedShards ) ; survivors . put ( entry . snapshotId ( ) , new SnapshotShards ( unmodifiableMap ( shards ) ) ) ; } else { survivors . put ( entry . snapshotId ( ) , new SnapshotShards ( unmodifiableMap ( startedShards ) ) ) ; } } } else if ( entry . state ( ) = = SnapshotsInProgress . State . ABORTED ) { SnapshotShards snapshotShards = shardSnapshots . get ( entry . snapshotId ( ) ) ; if ( snapshotShards ! = null ) { for ( ObjectObjectCursor < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shard : entry . shards ( ) ) { IndexShardSnapshotStatus snapshotStatus = snapshotShards . shards . get ( shard . key ) ; if ( snapshotStatus ! = null ) { switch ( snapshotStatus . stage ( ) ) { case INIT : case STARTED : snapshotStatus . abort ( ) ; break ; case FINALIZE : logger . debug ( <str> , entry . snapshotId ( ) , shard . key ) ; break ; case DONE : logger . debug ( <str> , entry . snapshotId ( ) , shard . key ) ; updateIndexShardSnapshotStatus ( entry . snapshotId ( ) , shard . key , new SnapshotsInProgress . ShardSnapshotStatus ( event . state ( ) . nodes ( ) . localNodeId ( ) , SnapshotsInProgress . State . SUCCESS ) ) ; break ; case FAILURE : logger . debug ( <str> , entry . snapshotId ( ) , shard . key ) ; updateIndexShardSnapshotStatus ( entry . snapshotId ( ) , shard . key , new SnapshotsInProgress . ShardSnapshotStatus ( event . state ( ) . nodes ( ) . localNodeId ( ) , SnapshotsInProgress . State . FAILED , snapshotStatus . failure ( ) ) ) ; break ; default : throw new IllegalStateException ( <str> + snapshotStatus . stage ( ) ) ; } } } } } } } shutdownLock . lock ( ) ; try { shardSnapshots = unmodifiableMap ( survivors ) ; if ( shardSnapshots . isEmpty ( ) ) { shutdownCondition . signalAll ( ) ; } } finally { shutdownLock . unlock ( ) ; } if ( newSnapshots . isEmpty ( ) = = false ) { Executor executor = threadPool . executor ( ThreadPool . Names . SNAPSHOT ) ; for ( final Map . Entry < SnapshotId , Map < ShardId , IndexShardSnapshotStatus > > entry : newSnapshots . entrySet ( ) ) { for ( final Map . Entry < ShardId , IndexShardSnapshotStatus > shardEntry : entry . getValue ( ) . entrySet ( ) ) { final ShardId shardId = shardEntry . getKey ( ) ; try { final IndexShard indexShard = indicesService . indexServiceSafe ( shardId . getIndex ( ) ) . getShardOrNull ( shardId . id ( ) ) ; executor . execute ( new AbstractRunnable ( ) { @Override public void doRun ( ) { snapshot ( indexShard , entry . getKey ( ) , shardEntry . getValue ( ) ) ; updateIndexShardSnapshotStatus ( entry . getKey ( ) , shardId , new SnapshotsInProgress . ShardSnapshotStatus ( localNodeId , SnapshotsInProgress . State . SUCCESS ) ) ; } @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , t , shardId , entry . getKey ( ) ) ; updateIndexShardSnapshotStatus ( entry . getKey ( ) , shardId , new SnapshotsInProgress . ShardSnapshotStatus ( localNodeId , SnapshotsInProgress . State . FAILED , ExceptionsHelper . detailedMessage ( t ) ) ) ; } } ) ; } catch ( Throwable t ) { updateIndexShardSnapshotStatus ( entry . getKey ( ) , shardId , new SnapshotsInProgress . ShardSnapshotStatus ( localNodeId , SnapshotsInProgress . State . FAILED , ExceptionsHelper . detailedMessage ( t ) ) ) ; } } } } } private void snapshot ( final IndexShard indexShard , final SnapshotId snapshotId , final IndexShardSnapshotStatus snapshotStatus ) { IndexShardRepository indexShardRepository = snapshotsService . getRepositoriesService ( ) . indexShardRepository ( snapshotId . getRepository ( ) ) ; ShardId shardId = indexShard . shardId ( ) ; if ( ! indexShard . routingEntry ( ) . primary ( ) ) { throw new IndexShardSnapshotFailedException ( shardId , <str> ) ; } if ( indexShard . routingEntry ( ) . relocating ( ) ) { throw new IndexShardSnapshotFailedException ( shardId , <str> ) ; } if ( indexShard . state ( ) = = IndexShardState . CREATED | | indexShard . state ( ) = = IndexShardState . RECOVERING ) { throw new IndexShardSnapshotFailedException ( shardId , <str> ) ; } try { IndexCommit snapshotIndexCommit = indexShard . snapshotIndex ( true ) ; try { indexShardRepository . snapshot ( snapshotId , shardId , snapshotIndexCommit , snapshotStatus ) ; if ( logger . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( snapshotId . getSnapshot ( ) ) . append ( <str> ) . append ( indexShardRepository ) . append ( <str> ) . append ( TimeValue . timeValueMillis ( snapshotStatus . time ( ) ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( snapshotStatus . indexVersion ( ) ) . append ( <str> ) . append ( snapshotStatus . numberOfFiles ( ) ) . append ( <str> ) . append ( new ByteSizeValue ( snapshotStatus . totalSize ( ) ) ) . append ( <str> ) ; logger . debug ( sb . toString ( ) ) ; } } finally { indexShard . releaseSnapshot ( snapshotIndexCommit ) ; } } catch ( SnapshotFailedEngineException e ) { throw e ; } catch ( IndexShardSnapshotFailedException e ) { throw e ; } catch ( Throwable e ) { throw new IndexShardSnapshotFailedException ( shardId , <str> , e ) ; } } private void syncShardStatsOnNewMaster ( ClusterChangedEvent event ) { SnapshotsInProgress snapshotsInProgress = event . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshotsInProgress = = null ) { return ; } for ( SnapshotsInProgress . Entry snapshot : snapshotsInProgress . entries ( ) ) { if ( snapshot . state ( ) = = SnapshotsInProgress . State . STARTED | | snapshot . state ( ) = = SnapshotsInProgress . State . ABORTED ) { Map < ShardId , IndexShardSnapshotStatus > localShards = currentSnapshotShards ( snapshot . snapshotId ( ) ) ; if ( localShards ! = null ) { ImmutableOpenMap < ShardId , SnapshotsInProgress . ShardSnapshotStatus > masterShards = snapshot . shards ( ) ; for ( Map . Entry < ShardId , IndexShardSnapshotStatus > localShard : localShards . entrySet ( ) ) { ShardId shardId = localShard . getKey ( ) ; IndexShardSnapshotStatus localShardStatus = localShard . getValue ( ) ; SnapshotsInProgress . ShardSnapshotStatus masterShard = masterShards . get ( shardId ) ; if ( masterShard ! = null & & masterShard . state ( ) . completed ( ) = = false ) { if ( localShardStatus . stage ( ) = = IndexShardSnapshotStatus . Stage . DONE ) { logger . debug ( <str> , snapshot . snapshotId ( ) , shardId ) ; updateIndexShardSnapshotStatus ( snapshot . snapshotId ( ) , shardId , new SnapshotsInProgress . ShardSnapshotStatus ( event . state ( ) . nodes ( ) . localNodeId ( ) , SnapshotsInProgress . State . SUCCESS ) ) ; } else if ( localShard . getValue ( ) . stage ( ) = = IndexShardSnapshotStatus . Stage . FAILURE ) { logger . debug ( <str> , snapshot . snapshotId ( ) , shardId ) ; updateIndexShardSnapshotStatus ( snapshot . snapshotId ( ) , shardId , new SnapshotsInProgress . ShardSnapshotStatus ( event . state ( ) . nodes ( ) . localNodeId ( ) , SnapshotsInProgress . State . FAILED , localShardStatus . failure ( ) ) ) ; } } } } } } } private static class SnapshotShards { private final Map < ShardId , IndexShardSnapshotStatus > shards ; private SnapshotShards ( Map < ShardId , IndexShardSnapshotStatus > shards ) { this . shards = shards ; } } public static class UpdateIndexShardSnapshotStatusRequest extends TransportRequest { private SnapshotId snapshotId ; private ShardId shardId ; private SnapshotsInProgress . ShardSnapshotStatus status ; private volatile boolean processed ; public UpdateIndexShardSnapshotStatusRequest ( ) { } public UpdateIndexShardSnapshotStatusRequest ( SnapshotId snapshotId , ShardId shardId , SnapshotsInProgress . ShardSnapshotStatus status ) { this . snapshotId = snapshotId ; this . shardId = shardId ; this . status = status ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; snapshotId = SnapshotId . readSnapshotId ( in ) ; shardId = ShardId . readShardId ( in ) ; status = SnapshotsInProgress . ShardSnapshotStatus . readShardSnapshotStatus ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; snapshotId . writeTo ( out ) ; shardId . writeTo ( out ) ; status . writeTo ( out ) ; } public SnapshotId snapshotId ( ) { return snapshotId ; } public ShardId shardId ( ) { return shardId ; } public SnapshotsInProgress . ShardSnapshotStatus status ( ) { return status ; } @Override public String toString ( ) { return <str> + snapshotId + <str> + shardId + <str> + status . state ( ) + <str> ; } public void markAsProcessed ( ) { processed = true ; } public boolean isProcessed ( ) { return processed ; } } public void updateIndexShardSnapshotStatus ( SnapshotId snapshotId , ShardId shardId , SnapshotsInProgress . ShardSnapshotStatus status ) { UpdateIndexShardSnapshotStatusRequest request = new UpdateIndexShardSnapshotStatusRequest ( snapshotId , shardId , status ) ; try { if ( clusterService . state ( ) . nodes ( ) . localNodeMaster ( ) ) { innerUpdateSnapshotState ( request ) ; } else { transportService . sendRequest ( clusterService . state ( ) . nodes ( ) . masterNode ( ) , UPDATE_SNAPSHOT_ACTION_NAME , request , EmptyTransportResponseHandler . INSTANCE_SAME ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t , request . snapshotId ( ) , request . status ( ) ) ; } } private void innerUpdateSnapshotState ( final UpdateIndexShardSnapshotStatusRequest request ) { logger . trace ( <str> , request ) ; updatedSnapshotStateQueue . add ( request ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { private final List < UpdateIndexShardSnapshotStatusRequest > drainedRequests = new ArrayList < > ( ) ; @Override public ClusterState execute ( ClusterState currentState ) { if ( request . isProcessed ( ) ) { return currentState ; } updatedSnapshotStateQueue . drainTo ( drainedRequests ) ; final int batchSize = drainedRequests . size ( ) ; if ( batchSize = = <int> ) { return currentState ; } final SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots ! = null ) { int changedCount = <int> ; final List < SnapshotsInProgress . Entry > entries = new ArrayList < > ( ) ; for ( SnapshotsInProgress . Entry entry : snapshots . entries ( ) ) { ImmutableOpenMap . Builder < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shards = ImmutableOpenMap . builder ( ) ; boolean updated = false ; for ( int i = <int> ; i < batchSize ; i + + ) { final UpdateIndexShardSnapshotStatusRequest updateSnapshotState = drainedRequests . get ( i ) ; updateSnapshotState . markAsProcessed ( ) ; if ( entry . snapshotId ( ) . equals ( updateSnapshotState . snapshotId ( ) ) ) { logger . trace ( <str> , updateSnapshotState . snapshotId ( ) , updateSnapshotState . shardId ( ) , updateSnapshotState . status ( ) . state ( ) ) ; if ( updated = = false ) { shards . putAll ( entry . shards ( ) ) ; updated = true ; } shards . put ( updateSnapshotState . shardId ( ) , updateSnapshotState . status ( ) ) ; changedCount + + ; } } if ( updated ) { if ( completed ( shards . values ( ) ) = = false ) { entries . add ( new SnapshotsInProgress . Entry ( entry , shards . build ( ) ) ) ; } else { SnapshotsInProgress . Entry updatedEntry = new SnapshotsInProgress . Entry ( entry , SnapshotsInProgress . State . SUCCESS , shards . build ( ) ) ; entries . add ( updatedEntry ) ; snapshotsService . endSnapshot ( updatedEntry ) ; logger . info ( <str> , updatedEntry . snapshotId ( ) ) ; } } else { entries . add ( entry ) ; } } if ( changedCount > <int> ) { logger . trace ( <str> , changedCount ) ; final SnapshotsInProgress updatedSnapshots = new SnapshotsInProgress ( entries . toArray ( new SnapshotsInProgress . Entry [ entries . size ( ) ] ) ) ; return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , updatedSnapshots ) . build ( ) ; } } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { for ( UpdateIndexShardSnapshotStatusRequest request : drainedRequests ) { logger . warn ( <str> , t , request . snapshotId ( ) , request . shardId ( ) , request . status ( ) ) ; } } } ) ; } class UpdateSnapshotStateRequestHandler implements TransportRequestHandler < UpdateIndexShardSnapshotStatusRequest > { @Override public void messageReceived ( UpdateIndexShardSnapshotStatusRequest request , final TransportChannel channel ) throws Exception { innerUpdateSnapshotState ( request ) ; channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } } 
