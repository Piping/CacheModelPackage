package org . nd4j . linalg . jcublas . kernel ; import com . google . common . collect . HashBasedTable ; import com . google . common . collect . Table ; import jcuda . Pointer ; import jcuda . driver . CUfunction ; import jcuda . driver . CUmodule ; import jcuda . driver . JCudaDriver ; import jcuda . jcublas . JCublas ; import jcuda . runtime . JCuda ; import jcuda . utils . KernelLauncher ; import org . apache . commons . io . FileUtils ; import org . apache . commons . io . IOUtils ; import org . apache . commons . lang3 . StringUtils ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . jcublas . CublasPointer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . jcublas . context . CudaContext ; import org . reflections . Reflections ; import org . reflections . scanners . ResourcesScanner ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . nd4j . linalg . io . ClassPathResource ; import java . io . * ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . util . * ; import java . util . regex . Pattern ; public class KernelFunctionLoader { public final static String NAME_SPACE = <str> ; public final static String DOUBLE = NAME_SPACE + <str> ; public final static String FLOAT = NAME_SPACE + <str> ; public final static String CACHE_COMPILED = NAME_SPACE + <str> ; public final static String FUNCTION_KEY = <str> ; private Map < String , String > paths = new HashMap < > ( ) ; private static KernelFunctionLoader INSTANCE ; private boolean alreadyCompiled = false ; private static Table < String , String , KernelLauncher > launchers = HashBasedTable . create ( ) ; private boolean init = false ; private static Logger log = LoggerFactory . getLogger ( KernelFunctionLoader . class ) ; private String kernelPath ; private String [ ] modules ; public final static String PRINT_KERNEL_NAME = <str> ; private static KernelLauncher printFunction ; private KernelFunctionLoader ( ) { } public static synchronized KernelFunctionLoader getInstance ( ) { if ( INSTANCE = = null ) { INSTANCE = new KernelFunctionLoader ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { @Override public void run ( ) { INSTANCE . unload ( ) ; } } ) ) ; try { INSTANCE . load ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return INSTANCE ; } public static KernelLauncher launcher ( String functionName , String dataType ) { KernelLauncher launcher = KernelFunctionLoader . getInstance ( ) . get ( functionName , dataType ) ; return launcher ; } public boolean exists ( String functionName ) { return get ( functionName , <str> ) ! = null | | get ( functionName , <str> ) ! = null ; } public KernelLauncher get ( String functionName , String dataType ) { String name = functionName + <str> + dataType ; if ( ! launchers . containsRow ( Thread . currentThread ( ) . getName ( ) ) ) { try { loadModules ( modules , kernelPath ) ; log . debug ( <str> + Thread . currentThread ( ) . getName ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } KernelLauncher launcher = launchers . get ( Thread . currentThread ( ) . getName ( ) , name ) ; if ( launcher = = null ) { name = functionName + <str> + <str> + dataType ; launcher = launchers . get ( Thread . currentThread ( ) . getName ( ) , name ) ; if ( launcher = = null ) return null ; } return launcher ; } public void unload ( ) { init = false ; } public void load ( ) throws Exception { if ( init ) return ; ClassPathResource res = new ClassPathResource ( <str> , KernelFunctionLoader . class . getClassLoader ( ) ) ; if ( ! res . exists ( ) ) throw new IllegalStateException ( <str> ) ; Properties props = new Properties ( ) ; props . load ( res . getInputStream ( ) ) ; log . info ( <str> ) ; compileAndLoad ( props ) ; init = true ; } private void compileAndLoad ( Properties props ) throws IOException { compileAndLoad ( props , <int> ) ; } private void compileAndLoad ( Properties props , int compiledAttempts ) throws IOException { String f = props . getProperty ( FUNCTION_KEY ) ; String tmpDir = System . getProperty ( <str> ) ; StringBuffer dir = new StringBuffer ( ) ; this . kernelPath = dir . append ( tmpDir ) . append ( File . separator ) . append ( <str> ) . append ( File . separator ) . append ( <str> ) . append ( File . separator ) . toString ( ) ; File tmpDir2 = new File ( tmpDir + File . separator + <str> + File . separatorChar + <str> ) ; boolean shouldCompile = ! tmpDir2 . exists ( ) | | tmpDir2 . exists ( ) & & tmpDir2 . listFiles ( ) . length < = <int> | | alreadyCompiled ; String [ ] split = f . split ( <str> ) ; this . modules = split ; if ( shouldCompile ) { loadCudaKernels ( ) ; } else { log . info ( <str> ) ; for ( String module : split ) { String path = kernelPath + module + <str> ; String nameDouble = module + <str> ; String nameFloat = module + <str> ; paths . put ( nameDouble , path ) ; paths . put ( nameFloat , path ) ; } } try { loadModules ( split , kernelPath ) ; alreadyCompiled = true ; } catch ( IOException e1 ) { if ( ! shouldCompile & & compiledAttempts < <int> ) { log . warn ( <str> ) ; FileUtils . deleteDirectory ( new File ( kernelPath ) ) ; props . setProperty ( CACHE_COMPILED , String . valueOf ( true ) ) ; compileAndLoad ( props , compiledAttempts + <int> ) ; } else throw new RuntimeException ( e1 ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void printBuffer ( JCudaBuffer buffer , CudaContext ctx ) throws Exception { CublasPointer pointer = new CublasPointer ( buffer , ctx ) ; pointer . copyToHost ( ) ; JCublas . printVector ( buffer . length ( ) , pointer . getDevicePointer ( ) ) ; buffer . asNio ( ) . rewind ( ) ; ByteBuffer pointer2 = pointer . getHostPointer ( ) . getByteBuffer ( <int> , buffer . getElementSize ( ) * buffer . length ( ) ) ; FloatBuffer intBuffer = pointer2 . asFloatBuffer ( ) ; for ( int i = <int> ; i < buffer . length ( ) ; i + + ) { System . out . println ( <str> + i + <str> + intBuffer . get ( i ) ) ; } JCuda . cudaDeviceSynchronize ( ) ; } private void loadModules ( String [ ] split , String kernelPath ) throws Exception { for ( String module : split ) { log . debug ( <str> + module ) ; String path = kernelPath + module + <str> ; if ( ! new File ( path ) . exists ( ) ) throw new IllegalStateException ( <str> + path + <str> ) ; String name = module ; paths . put ( name , path ) ; KernelLauncher launch = KernelLauncher . load ( path , name , <str> ) ; KernelLauncher doubleLauncher = KernelLauncher . load ( name , <str> , launch . getModule ( ) ) ; launchers . put ( Thread . currentThread ( ) . getName ( ) , name + <str> , doubleLauncher ) ; launchers . put ( Thread . currentThread ( ) . getName ( ) , name + <str> , launch ) ; if ( printFunction = = null ) { printFunction = KernelLauncher . load ( PRINT_KERNEL_NAME , launch . getModule ( ) ) ; } } } private void loadCudaKernels ( ) throws IOException { Set < String > resources = new Reflections ( <str> , new ResourcesScanner ( ) ) . getResources ( Pattern . compile ( <str> ) ) ; for ( String resource : resources ) { extract ( resource ) ; } File outputDir = new File ( System . getProperty ( <str> ) + File . separator + <str> , <str> ) ; outputDir . mkdirs ( ) ; log . info ( <str> ) ; String [ ] commands = { <str> , <str> , <str> } ; ProcessBuilder probuilder = new ProcessBuilder ( commands ) ; probuilder . directory ( new File ( System . getProperty ( <str> ) + File . separator + <str> ) ) ; Process process = probuilder . start ( ) ; InputStream is = process . getInputStream ( ) ; try { process . waitFor ( ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; List < String > list = IOUtils . readLines ( bis , <str> ) ; for ( String item : list ) { log . info ( item ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public String extract ( String file ) throws IOException { String tmpDir = System . getProperty ( <str> ) ; String [ ] split = file . split ( <str> ) ; String [ ] newArray = new String [ split . length - <int> ] ; for ( int i = <int> , j = <int> ; j < split . length ; i + + , j + + ) { newArray [ i ] = split [ j ] ; } String split2 = StringUtils . join ( newArray , <str> ) ; File dataDir = new File ( tmpDir , split2 ) ; if ( ! dataDir . getParentFile ( ) . exists ( ) ) dataDir . mkdirs ( ) ; return loadFile ( file , dataDir ) ; } private String loadFile ( String file , File dataDir ) throws IOException { ClassPathResource resource = new ClassPathResource ( file , KernelFunctionLoader . class . getClassLoader ( ) ) ; if ( ! resource . exists ( ) ) throw new IllegalStateException ( <str> + resource ) ; File out = dataDir ; if ( ! out . getParentFile ( ) . exists ( ) ) out . getParentFile ( ) . mkdirs ( ) ; if ( out . exists ( ) ) out . delete ( ) ; out . createNewFile ( ) ; BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( out ) ) ; IOUtils . copy ( resource . getInputStream ( ) , bos ) ; bos . flush ( ) ; bos . close ( ) ; return out . getAbsolutePath ( ) ; } } 
