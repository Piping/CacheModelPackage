package clojure . lang ; import java . util . Collection ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class PersistentQueue extends Obj implements IPersistentList , Collection , Counted , IHashEq { final public static PersistentQueue EMPTY = new PersistentQueue ( null , <int> , null , null ) ; final int cnt ; final ISeq f ; final PersistentVector r ; int _hash = - <int> ; int _hasheq = - <int> ; PersistentQueue ( IPersistentMap meta , int cnt , ISeq f , PersistentVector r ) { super ( meta ) ; this . cnt = cnt ; this . f = f ; this . r = r ; } public boolean equiv ( Object obj ) { if ( ! ( obj instanceof Sequential ) ) return false ; ISeq ms = RT . seq ( obj ) ; for ( ISeq s = seq ( ) ; s ! = null ; s = s . next ( ) , ms = ms . next ( ) ) { if ( ms = = null | | ! Util . equiv ( s . first ( ) , ms . first ( ) ) ) return false ; } return ms = = null ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof Sequential ) ) return false ; ISeq ms = RT . seq ( obj ) ; for ( ISeq s = seq ( ) ; s ! = null ; s = s . next ( ) , ms = ms . next ( ) ) { if ( ms = = null | | ! Util . equals ( s . first ( ) , ms . first ( ) ) ) return false ; } return ms = = null ; } public int hashCode ( ) { if ( _hash = = - <int> ) { int hash = <int> ; for ( ISeq s = seq ( ) ; s ! = null ; s = s . next ( ) ) { hash = <int> * hash + ( s . first ( ) = = null ? <int> : s . first ( ) . hashCode ( ) ) ; } this . _hash = hash ; } return _hash ; } public int hasheq ( ) { if ( _hasheq = = - <int> ) { _hasheq = Murmur3 . hashOrdered ( this ) ; } return _hasheq ; } public Object peek ( ) { return RT . first ( f ) ; } public PersistentQueue pop ( ) { if ( f = = null ) return this ; ISeq f1 = f . next ( ) ; PersistentVector r1 = r ; if ( f1 = = null ) { f1 = RT . seq ( r ) ; r1 = null ; } return new PersistentQueue ( meta ( ) , cnt - <int> , f1 , r1 ) ; } public int count ( ) { return cnt ; } public ISeq seq ( ) { if ( f = = null ) return null ; return new Seq ( f , RT . seq ( r ) ) ; } public PersistentQueue cons ( Object o ) { if ( f = = null ) return new PersistentQueue ( meta ( ) , cnt + <int> , RT . list ( o ) , null ) ; else return new PersistentQueue ( meta ( ) , cnt + <int> , f , ( r ! = null ? r : PersistentVector . EMPTY ) . cons ( o ) ) ; } public IPersistentCollection empty ( ) { return EMPTY . withMeta ( meta ( ) ) ; } public PersistentQueue withMeta ( IPersistentMap meta ) { return new PersistentQueue ( meta , cnt , f , r ) ; } static class Seq extends ASeq { final ISeq f ; final ISeq rseq ; Seq ( ISeq f , ISeq rseq ) { this . f = f ; this . rseq = rseq ; } Seq ( IPersistentMap meta , ISeq f , ISeq rseq ) { super ( meta ) ; this . f = f ; this . rseq = rseq ; } public Object first ( ) { return f . first ( ) ; } public ISeq next ( ) { ISeq f1 = f . next ( ) ; ISeq r1 = rseq ; if ( f1 = = null ) { if ( rseq = = null ) return null ; f1 = rseq ; r1 = null ; } return new Seq ( f1 , r1 ) ; } public int count ( ) { return RT . count ( f ) + RT . count ( rseq ) ; } public Seq withMeta ( IPersistentMap meta ) { return new Seq ( meta , f , rseq ) ; } } public Object [ ] toArray ( ) { return RT . seqToArray ( seq ( ) ) ; } public boolean add ( Object o ) { throw new UnsupportedOperationException ( ) ; } public boolean remove ( Object o ) { throw new UnsupportedOperationException ( ) ; } public boolean addAll ( Collection c ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public boolean retainAll ( Collection c ) { throw new UnsupportedOperationException ( ) ; } public boolean removeAll ( Collection c ) { throw new UnsupportedOperationException ( ) ; } public boolean containsAll ( Collection c ) { for ( Object o : c ) { if ( contains ( o ) ) return true ; } return false ; } public Object [ ] toArray ( Object [ ] a ) { return RT . seqToPassedArray ( seq ( ) , a ) ; } public int size ( ) { return count ( ) ; } public boolean isEmpty ( ) { return count ( ) = = <int> ; } public boolean contains ( Object o ) { for ( ISeq s = seq ( ) ; s ! = null ; s = s . next ( ) ) { if ( Util . equiv ( s . first ( ) , o ) ) return true ; } return false ; } public Iterator iterator ( ) { return new Iterator ( ) { private ISeq fseq = f ; private final Iterator riter = r ! = null ? r . iterator ( ) : null ; public boolean hasNext ( ) { return ( ( fseq ! = null & & fseq . seq ( ) ! = null ) | | ( riter ! = null & & riter . hasNext ( ) ) ) ; } public Object next ( ) { if ( fseq ! = null ) { Object ret = fseq . first ( ) ; fseq = fseq . next ( ) ; return ret ; } else if ( riter ! = null & & riter . hasNext ( ) ) return riter . next ( ) ; else throw new NoSuchElementException ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } 
