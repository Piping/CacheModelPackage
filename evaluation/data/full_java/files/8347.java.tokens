package org . elasticsearch . indices . memory . breaker ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . LeafReader ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . indices . refresh . RefreshResponse ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . MockEngineFactoryPlugin ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . indices . fielddata . cache . IndicesFieldDataCache ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . engine . MockEngineSupport ; import org . elasticsearch . test . engine . ThrowingLeafReaderWrapper ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Random ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAllSuccessful ; import static org . hamcrest . Matchers . equalTo ; public class RandomExceptionCircuitBreakerIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( RandomExceptionDirectoryReaderWrapper . TestPlugin . class ) ; } public void testBreakerWithRandomExceptions ( ) throws IOException , InterruptedException , ExecutionException { for ( NodeStats node : client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . execute ( ) . actionGet ( ) . getNodes ( ) ) { assertThat ( <str> , node . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; } String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , randomBoolean ( ) ) . endObject ( ) . startObject ( <str> ) . field ( <str> , randomFrom ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> ) ) ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; final double topLevelRate ; final double lowLevelRate ; if ( frequently ( ) ) { if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { lowLevelRate = <float> / between ( <int> , <int> ) ; topLevelRate = <float> ; } else { topLevelRate = <float> / between ( <int> , <int> ) ; lowLevelRate = <float> ; } } else { lowLevelRate = <float> / between ( <int> , <int> ) ; topLevelRate = <float> / between ( <int> , <int> ) ; } } else { topLevelRate = <float> ; lowLevelRate = <float> ; } Settings . Builder settings = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( EXCEPTION_TOP_LEVEL_RATIO_KEY , topLevelRate ) . put ( EXCEPTION_LOW_LEVEL_RATIO_KEY , lowLevelRate ) . put ( MockEngineSupport . WRAP_READER_RATIO , <float> ) ; logger . info ( <str> , settings . build ( ) . getAsMap ( ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) . execute ( ) . actionGet ( ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . health ( Requests . clusterHealthRequest ( ) . waitForYellowStatus ( ) . timeout ( TimeValue . timeValueSeconds ( <int> ) ) ) . get ( ) ; final int numDocs ; if ( clusterHealthResponse . isTimedOut ( ) ) { logger . info ( <str> ) ; numDocs = <int> ; } else { numDocs = between ( <int> , <int> ) ; } for ( int i = <int> ; i < numDocs ; i + + ) { try { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setTimeout ( TimeValue . timeValueSeconds ( <int> ) ) . setSource ( <str> , randomUnicodeOfLengthBetween ( <int> , <int> ) , <str> , i ) . get ( ) ; } catch ( ElasticsearchException ex ) { } } logger . info ( <str> ) ; RefreshResponse refreshResponse = client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . get ( ) ; final boolean refreshFailed = refreshResponse . getShardFailures ( ) . length ! = <int> | | refreshResponse . getFailedShards ( ) ! = <int> ; logger . info ( <str> , refreshFailed , refreshResponse . getFailedShards ( ) , refreshResponse . getShardFailures ( ) . length , refreshResponse . getSuccessfulShards ( ) , refreshResponse . getTotalShards ( ) ) ; final int numSearches = scaledRandomIntBetween ( <int> , <int> ) ; NodesStatsResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . execute ( ) . actionGet ( ) ; for ( NodeStats stats : resp . getNodes ( ) ) { assertThat ( <str> , stats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; } for ( int i = <int> ; i < numSearches ; i + + ) { SearchRequestBuilder searchRequestBuilder = client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : case <int> : case <int> : searchRequestBuilder . addSort ( <str> , SortOrder . ASC ) ; case <int> : case <int> : default : searchRequestBuilder . addSort ( <str> , SortOrder . ASC ) ; } boolean success = false ; try { searchRequestBuilder . get ( ) ; success = true ; } catch ( SearchPhaseExecutionException ex ) { logger . info ( <str> , ex . getMessage ( ) ) ; } if ( frequently ( ) ) { ensureGreen ( <str> ) ; assertAllSuccessful ( client ( ) . admin ( ) . indices ( ) . prepareClearCache ( <str> ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ) ; for ( String node : internalCluster ( ) . getNodeNames ( ) ) { final IndicesFieldDataCache fdCache = internalCluster ( ) . getInstance ( IndicesFieldDataCache . class , node ) ; fdCache . getCache ( ) . refresh ( ) ; } NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . execute ( ) . actionGet ( ) ; for ( NodeStats stats : nodeStats . getNodes ( ) ) { assertThat ( <str> + success + <str> + mapping , stats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; } } } } public static final String EXCEPTION_TOP_LEVEL_RATIO_KEY = <str> ; public static final String EXCEPTION_LOW_LEVEL_RATIO_KEY = <str> ; public static class RandomExceptionDirectoryReaderWrapper extends MockEngineSupport . DirectoryReaderWrapper { public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( MockEngineFactoryPlugin . MockEngineReaderModule module ) { module . setReaderClass ( RandomExceptionDirectoryReaderWrapper . class ) ; } } private final Settings settings ; static class ThrowingSubReaderWrapper extends SubReaderWrapper implements ThrowingLeafReaderWrapper . Thrower { private final Random random ; private final double topLevelRatio ; private final double lowLevelRatio ; ThrowingSubReaderWrapper ( Settings settings ) { final long seed = settings . getAsLong ( SETTING_INDEX_SEED , <int> l ) ; this . topLevelRatio = settings . getAsDouble ( EXCEPTION_TOP_LEVEL_RATIO_KEY , <float> ) ; this . lowLevelRatio = settings . getAsDouble ( EXCEPTION_LOW_LEVEL_RATIO_KEY , <float> ) ; this . random = new Random ( seed ) ; } @Override public LeafReader wrap ( LeafReader reader ) { return new ThrowingLeafReaderWrapper ( reader , this ) ; } @Override public void maybeThrow ( ThrowingLeafReaderWrapper . Flags flag ) throws IOException { switch ( flag ) { case Fields : break ; case TermVectors : break ; case Terms : case TermsEnum : if ( random . nextDouble ( ) < topLevelRatio ) { throw new IOException ( <str> + flag . name ( ) + <str> ) ; } case Intersect : break ; case Norms : break ; case NumericDocValues : break ; case BinaryDocValues : break ; case SortedDocValues : break ; case SortedSetDocValues : break ; case DocsEnum : case DocsAndPositionsEnum : if ( random . nextDouble ( ) < lowLevelRatio ) { throw new IOException ( <str> + flag . name ( ) + <str> ) ; } break ; } } @Override public boolean wrapTerms ( String field ) { return field . startsWith ( <str> ) ; } } public RandomExceptionDirectoryReaderWrapper ( DirectoryReader in , Settings settings ) throws IOException { super ( in , new ThrowingSubReaderWrapper ( settings ) ) ; this . settings = settings ; } @Override protected DirectoryReader doWrapDirectoryReader ( DirectoryReader in ) throws IOException { return new RandomExceptionDirectoryReaderWrapper ( in , settings ) ; } } } 
