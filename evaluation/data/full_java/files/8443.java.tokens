package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . BoolQueryBuilder ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . search . aggregations . bucket . filters . Filters ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . metrics . avg . Avg ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . avg ; import static org . elasticsearch . search . aggregations . AggregationBuilders . filters ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class FiltersIT extends ESIntegTestCase { static int numDocs , numTag1Docs , numTag2Docs , numOtherDocs ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; numDocs = randomIntBetween ( <int> , <int> ) ; numTag1Docs = randomIntBetween ( <int> , numDocs - <int> ) ; numTag2Docs = randomIntBetween ( <int> , numDocs - numTag1Docs ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numTag1Docs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . field ( <str> , i + <int> ) . field ( <str> , <str> ) . endObject ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; if ( randomBoolean ( ) ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; } } for ( int i = numTag1Docs ; i < ( numTag1Docs + numTag2Docs ) ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . field ( <str> , i ) . field ( <str> , <str> ) . field ( <str> , <str> + i ) . endObject ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; if ( randomBoolean ( ) ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; } } for ( int i = numTag1Docs + numTag2Docs ; i < numDocs ; i + + ) { numOtherDocs + + ; XContentBuilder source = jsonBuilder ( ) . startObject ( ) . field ( <str> , i ) . field ( <str> , <str> ) . field ( <str> , <str> + i ) . endObject ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; if ( randomBoolean ( ) ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( source ) ) ; } } prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i * <int> ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testSimple ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; } public void testEmptyFilterDeclarations ( ) throws Exception { QueryBuilder emptyFilter = new BoolQueryBuilder ( ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . filter ( <str> , emptyFilter ) . filter ( <str> , termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; Filters . Bucket allBucket = filters . getBucketByKey ( <str> ) ; assertThat ( allBucket . getDocCount ( ) , equalTo ( ( long ) numDocs ) ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; } public void testWithSubAggregation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) . subAggregation ( avg ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) filters . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) filters . getProperty ( <str> ) ; Object [ ] propertiesCounts = ( Object [ ] ) filters . getProperty ( <str> ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; long sum = <int> ; for ( int i = <int> ; i < numTag1Docs ; + + i ) { sum + = i + <int> ; } assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Avg avgValue = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgValue , notNullValue ( ) ) ; assertThat ( avgValue . getName ( ) , equalTo ( <str> ) ) ; assertThat ( avgValue . getValue ( ) , equalTo ( ( double ) sum / numTag1Docs ) ) ; assertThat ( ( String ) propertiesKeys [ <int> ] , equalTo ( <str> ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( ( long ) numTag1Docs ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( ( double ) sum / numTag1Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; sum = <int> ; for ( int i = numTag1Docs ; i < ( numTag1Docs + numTag2Docs ) ; + + i ) { sum + = i ; } assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; avgValue = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgValue , notNullValue ( ) ) ; assertThat ( avgValue . getName ( ) , equalTo ( <str> ) ) ; assertThat ( avgValue . getValue ( ) , equalTo ( ( double ) sum / numTag2Docs ) ) ; assertThat ( ( String ) propertiesKeys [ <int> ] , equalTo ( <str> ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( ( long ) numTag2Docs ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( ( double ) sum / numTag2Docs ) ) ; } public void testWithContextBasedSubAggregation ( ) throws Exception { try { client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) . subAggregation ( avg ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> + <str> ) ; } catch ( ElasticsearchException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testEmptyAggregation ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( <int> ) . minDocCount ( <int> ) . subAggregation ( filters ( <str> ) . filter ( <str> , matchAllQuery ( ) ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; Histogram histo = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , Matchers . notNullValue ( ) ) ; Histogram . Bucket bucket = histo . getBuckets ( ) . get ( <int> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; Filters filters = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; Filters . Bucket all = filters . getBucketByKey ( <str> ) ; assertThat ( all , Matchers . notNullValue ( ) ) ; assertThat ( all . getKeyAsString ( ) , equalTo ( <str> ) ) ; assertThat ( all . getDocCount ( ) , is ( <int> l ) ) ; } public void testSimpleNonKeyed ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . filter ( termQuery ( <str> , <str> ) ) . filter ( termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Collection < ? extends Filters . Bucket > buckets = filters . getBuckets ( ) ; Iterator < ? extends Filters . Bucket > itr = buckets . iterator ( ) ; Filters . Bucket bucket = itr . next ( ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; bucket = itr . next ( ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; } public void testOtherBucket ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . otherBucket ( true ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numOtherDocs ) ) ; } public void testOtherNamedBucket ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . otherBucketKey ( <str> ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numOtherDocs ) ) ; } public void testOtherNonKeyed ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . otherBucket ( true ) . filter ( termQuery ( <str> , <str> ) ) . filter ( termQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Collection < ? extends Filters . Bucket > buckets = filters . getBuckets ( ) ; Iterator < ? extends Filters . Bucket > itr = buckets . iterator ( ) ; Filters . Bucket bucket = itr . next ( ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; bucket = itr . next ( ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; bucket = itr . next ( ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numOtherDocs ) ) ; } public void testOtherWithSubAggregation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( filters ( <str> ) . otherBucket ( true ) . filter ( <str> , termQuery ( <str> , <str> ) ) . filter ( <str> , termQuery ( <str> , <str> ) ) . subAggregation ( avg ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filters filters = response . getAggregations ( ) . get ( <str> ) ; assertThat ( filters , notNullValue ( ) ) ; assertThat ( filters . getName ( ) , equalTo ( <str> ) ) ; assertThat ( filters . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) filters . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) filters . getProperty ( <str> ) ; Object [ ] propertiesCounts = ( Object [ ] ) filters . getProperty ( <str> ) ; Filters . Bucket bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag1Docs ) ) ; long sum = <int> ; for ( int i = <int> ; i < numTag1Docs ; + + i ) { sum + = i + <int> ; } assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Avg avgValue = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgValue , notNullValue ( ) ) ; assertThat ( avgValue . getName ( ) , equalTo ( <str> ) ) ; assertThat ( avgValue . getValue ( ) , equalTo ( ( double ) sum / numTag1Docs ) ) ; assertThat ( ( String ) propertiesKeys [ <int> ] , equalTo ( <str> ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( ( long ) numTag1Docs ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( ( double ) sum / numTag1Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numTag2Docs ) ) ; sum = <int> ; for ( int i = numTag1Docs ; i < ( numTag1Docs + numTag2Docs ) ; + + i ) { sum + = i ; } assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; avgValue = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgValue , notNullValue ( ) ) ; assertThat ( avgValue . getName ( ) , equalTo ( <str> ) ) ; assertThat ( avgValue . getValue ( ) , equalTo ( ( double ) sum / numTag2Docs ) ) ; assertThat ( ( String ) propertiesKeys [ <int> ] , equalTo ( <str> ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( ( long ) numTag2Docs ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( ( double ) sum / numTag2Docs ) ) ; bucket = filters . getBucketByKey ( <str> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numOtherDocs ) ) ; sum = <int> ; for ( int i = numTag1Docs + numTag2Docs ; i < numDocs ; + + i ) { sum + = i ; } assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; avgValue = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgValue , notNullValue ( ) ) ; assertThat ( avgValue . getName ( ) , equalTo ( <str> ) ) ; assertThat ( avgValue . getValue ( ) , equalTo ( ( double ) sum / numOtherDocs ) ) ; assertThat ( ( String ) propertiesKeys [ <int> ] , equalTo ( <str> ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( ( long ) numOtherDocs ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( ( double ) sum / numOtherDocs ) ) ; } } 
