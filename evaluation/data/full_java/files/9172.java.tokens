package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkElementIndex ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Objects ; import com . google . common . collect . Maps . IteratorBasedAbstractMap ; import com . google . j2objc . annotations . WeakOuter ; import java . io . Serializable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import javax . annotation . Nullable ; @Beta @GwtCompatible ( emulated = true ) public final class ArrayTable < R , C , V > extends AbstractTable < R , C , V > implements Serializable { public static < R , C , V > ArrayTable < R , C , V > create ( Iterable < ? extends R > rowKeys , Iterable < ? extends C > columnKeys ) { return new ArrayTable < R , C , V > ( rowKeys , columnKeys ) ; } public static < R , C , V > ArrayTable < R , C , V > create ( Table < R , C , V > table ) { return ( table instanceof ArrayTable < ? , ? , ? > ) ? new ArrayTable < R , C , V > ( ( ArrayTable < R , C , V > ) table ) : new ArrayTable < R , C , V > ( table ) ; } private final ImmutableList < R > rowList ; private final ImmutableList < C > columnList ; private final ImmutableMap < R , Integer > rowKeyToIndex ; private final ImmutableMap < C , Integer > columnKeyToIndex ; private final V [ ] [ ] array ; private ArrayTable ( Iterable < ? extends R > rowKeys , Iterable < ? extends C > columnKeys ) { this . rowList = ImmutableList . copyOf ( rowKeys ) ; this . columnList = ImmutableList . copyOf ( columnKeys ) ; checkArgument ( ! rowList . isEmpty ( ) ) ; checkArgument ( ! columnList . isEmpty ( ) ) ; rowKeyToIndex = Maps . indexMap ( rowList ) ; columnKeyToIndex = Maps . indexMap ( columnList ) ; @SuppressWarnings ( <str> ) V [ ] [ ] tmpArray = ( V [ ] [ ] ) new Object [ rowList . size ( ) ] [ columnList . size ( ) ] ; array = tmpArray ; eraseAll ( ) ; } private ArrayTable ( Table < R , C , V > table ) { this ( table . rowKeySet ( ) , table . columnKeySet ( ) ) ; putAll ( table ) ; } private ArrayTable ( ArrayTable < R , C , V > table ) { rowList = table . rowList ; columnList = table . columnList ; rowKeyToIndex = table . rowKeyToIndex ; columnKeyToIndex = table . columnKeyToIndex ; @SuppressWarnings ( <str> ) V [ ] [ ] copy = ( V [ ] [ ] ) new Object [ rowList . size ( ) ] [ columnList . size ( ) ] ; array = copy ; eraseAll ( ) ; for ( int i = <int> ; i < rowList . size ( ) ; i + + ) { System . arraycopy ( table . array [ i ] , <int> , copy [ i ] , <int> , table . array [ i ] . length ) ; } } private abstract static class ArrayMap < K , V > extends IteratorBasedAbstractMap < K , V > { private final ImmutableMap < K , Integer > keyIndex ; private ArrayMap ( ImmutableMap < K , Integer > keyIndex ) { this . keyIndex = keyIndex ; } @Override public Set < K > keySet ( ) { return keyIndex . keySet ( ) ; } K getKey ( int index ) { return keyIndex . keySet ( ) . asList ( ) . get ( index ) ; } abstract String getKeyRole ( ) ; @Nullable abstract V getValue ( int index ) ; @Nullable abstract V setValue ( int index , V newValue ) ; @Override public int size ( ) { return keyIndex . size ( ) ; } @Override public boolean isEmpty ( ) { return keyIndex . isEmpty ( ) ; } @Override Iterator < Entry < K , V > > entryIterator ( ) { return new AbstractIndexedListIterator < Entry < K , V > > ( size ( ) ) { @Override protected Entry < K , V > get ( final int index ) { return new AbstractMapEntry < K , V > ( ) { @Override public K getKey ( ) { return ArrayMap . this . getKey ( index ) ; } @Override public V getValue ( ) { return ArrayMap . this . getValue ( index ) ; } @Override public V setValue ( V value ) { return ArrayMap . this . setValue ( index , value ) ; } } ; } } ; } @Override public boolean containsKey ( @Nullable Object key ) { return keyIndex . containsKey ( key ) ; } @Override public V get ( @Nullable Object key ) { Integer index = keyIndex . get ( key ) ; if ( index = = null ) { return null ; } else { return getValue ( index ) ; } } @Override public V put ( K key , V value ) { Integer index = keyIndex . get ( key ) ; if ( index = = null ) { throw new IllegalArgumentException ( getKeyRole ( ) + <str> + key + <str> + keyIndex . keySet ( ) ) ; } return setValue ( index , value ) ; } @Override public V remove ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } } public ImmutableList < R > rowKeyList ( ) { return rowList ; } public ImmutableList < C > columnKeyList ( ) { return columnList ; } public V at ( int rowIndex , int columnIndex ) { checkElementIndex ( rowIndex , rowList . size ( ) ) ; checkElementIndex ( columnIndex , columnList . size ( ) ) ; return array [ rowIndex ] [ columnIndex ] ; } public V set ( int rowIndex , int columnIndex , @Nullable V value ) { checkElementIndex ( rowIndex , rowList . size ( ) ) ; checkElementIndex ( columnIndex , columnList . size ( ) ) ; V oldValue = array [ rowIndex ] [ columnIndex ] ; array [ rowIndex ] [ columnIndex ] = value ; return oldValue ; } @GwtIncompatible ( <str> ) public V [ ] [ ] toArray ( Class < V > valueClass ) { @SuppressWarnings ( <str> ) V [ ] [ ] copy = ( V [ ] [ ] ) Array . newInstance ( valueClass , new int [ ] { rowList . size ( ) , columnList . size ( ) } ) ; for ( int i = <int> ; i < rowList . size ( ) ; i + + ) { System . arraycopy ( array [ i ] , <int> , copy [ i ] , <int> , array [ i ] . length ) ; } return copy ; } @Override @Deprecated public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public void eraseAll ( ) { for ( V [ ] row : array ) { Arrays . fill ( row , null ) ; } } @Override public boolean contains ( @Nullable Object rowKey , @Nullable Object columnKey ) { return containsRow ( rowKey ) & & containsColumn ( columnKey ) ; } @Override public boolean containsColumn ( @Nullable Object columnKey ) { return columnKeyToIndex . containsKey ( columnKey ) ; } @Override public boolean containsRow ( @Nullable Object rowKey ) { return rowKeyToIndex . containsKey ( rowKey ) ; } @Override public boolean containsValue ( @Nullable Object value ) { for ( V [ ] row : array ) { for ( V element : row ) { if ( Objects . equal ( value , element ) ) { return true ; } } } return false ; } @Override public V get ( @Nullable Object rowKey , @Nullable Object columnKey ) { Integer rowIndex = rowKeyToIndex . get ( rowKey ) ; Integer columnIndex = columnKeyToIndex . get ( columnKey ) ; return ( rowIndex = = null | | columnIndex = = null ) ? null : at ( rowIndex , columnIndex ) ; } @Override public boolean isEmpty ( ) { return false ; } @Override public V put ( R rowKey , C columnKey , @Nullable V value ) { checkNotNull ( rowKey ) ; checkNotNull ( columnKey ) ; Integer rowIndex = rowKeyToIndex . get ( rowKey ) ; checkArgument ( rowIndex ! = null , <str> , rowKey , rowList ) ; Integer columnIndex = columnKeyToIndex . get ( columnKey ) ; checkArgument ( columnIndex ! = null , <str> , columnKey , columnList ) ; return set ( rowIndex , columnIndex , value ) ; } @Override public void putAll ( Table < ? extends R , ? extends C , ? extends V > table ) { super . putAll ( table ) ; } @Override @Deprecated public V remove ( Object rowKey , Object columnKey ) { throw new UnsupportedOperationException ( ) ; } public V erase ( @Nullable Object rowKey , @Nullable Object columnKey ) { Integer rowIndex = rowKeyToIndex . get ( rowKey ) ; Integer columnIndex = columnKeyToIndex . get ( columnKey ) ; if ( rowIndex = = null | | columnIndex = = null ) { return null ; } return set ( rowIndex , columnIndex , null ) ; } @Override public int size ( ) { return rowList . size ( ) * columnList . size ( ) ; } @Override public Set < Cell < R , C , V > > cellSet ( ) { return super . cellSet ( ) ; } @Override Iterator < Cell < R , C , V > > cellIterator ( ) { return new AbstractIndexedListIterator < Cell < R , C , V > > ( size ( ) ) { @Override protected Cell < R , C , V > get ( final int index ) { return new Tables . AbstractCell < R , C , V > ( ) { final int rowIndex = index / columnList . size ( ) ; final int columnIndex = index % columnList . size ( ) ; @Override public R getRowKey ( ) { return rowList . get ( rowIndex ) ; } @Override public C getColumnKey ( ) { return columnList . get ( columnIndex ) ; } @Override public V getValue ( ) { return at ( rowIndex , columnIndex ) ; } } ; } } ; } @Override public Map < R , V > column ( C columnKey ) { checkNotNull ( columnKey ) ; Integer columnIndex = columnKeyToIndex . get ( columnKey ) ; return ( columnIndex = = null ) ? ImmutableMap . < R , V > of ( ) : new Column ( columnIndex ) ; } private class Column extends ArrayMap < R , V > { final int columnIndex ; Column ( int columnIndex ) { super ( rowKeyToIndex ) ; this . columnIndex = columnIndex ; } @Override String getKeyRole ( ) { return <str> ; } @Override V getValue ( int index ) { return at ( index , columnIndex ) ; } @Override V setValue ( int index , V newValue ) { return set ( index , columnIndex , newValue ) ; } } @Override public ImmutableSet < C > columnKeySet ( ) { return columnKeyToIndex . keySet ( ) ; } private transient ColumnMap columnMap ; @Override public Map < C , Map < R , V > > columnMap ( ) { ColumnMap map = columnMap ; return ( map = = null ) ? columnMap = new ColumnMap ( ) : map ; } @WeakOuter private class ColumnMap extends ArrayMap < C , Map < R , V > > { private ColumnMap ( ) { super ( columnKeyToIndex ) ; } @Override String getKeyRole ( ) { return <str> ; } @Override Map < R , V > getValue ( int index ) { return new Column ( index ) ; } @Override Map < R , V > setValue ( int index , Map < R , V > newValue ) { throw new UnsupportedOperationException ( ) ; } @Override public Map < R , V > put ( C key , Map < R , V > value ) { throw new UnsupportedOperationException ( ) ; } } @Override public Map < C , V > row ( R rowKey ) { checkNotNull ( rowKey ) ; Integer rowIndex = rowKeyToIndex . get ( rowKey ) ; return ( rowIndex = = null ) ? ImmutableMap . < C , V > of ( ) : new Row ( rowIndex ) ; } private class Row extends ArrayMap < C , V > { final int rowIndex ; Row ( int rowIndex ) { super ( columnKeyToIndex ) ; this . rowIndex = rowIndex ; } @Override String getKeyRole ( ) { return <str> ; } @Override V getValue ( int index ) { return at ( rowIndex , index ) ; } @Override V setValue ( int index , V newValue ) { return set ( rowIndex , index , newValue ) ; } } @Override public ImmutableSet < R > rowKeySet ( ) { return rowKeyToIndex . keySet ( ) ; } private transient RowMap rowMap ; @Override public Map < R , Map < C , V > > rowMap ( ) { RowMap map = rowMap ; return ( map = = null ) ? rowMap = new RowMap ( ) : map ; } @WeakOuter private class RowMap extends ArrayMap < R , Map < C , V > > { private RowMap ( ) { super ( rowKeyToIndex ) ; } @Override String getKeyRole ( ) { return <str> ; } @Override Map < C , V > getValue ( int index ) { return new Row ( index ) ; } @Override Map < C , V > setValue ( int index , Map < C , V > newValue ) { throw new UnsupportedOperationException ( ) ; } @Override public Map < C , V > put ( R key , Map < C , V > value ) { throw new UnsupportedOperationException ( ) ; } } @Override public Collection < V > values ( ) { return super . values ( ) ; } private static final long serialVersionUID = <int> ; } 
