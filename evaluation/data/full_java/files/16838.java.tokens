package com . badlogic . gdx . backends . gwt ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . Input . Buttons ; import com . badlogic . gdx . backends . gwt . widgets . TextInputDialogBox ; import com . badlogic . gdx . backends . gwt . widgets . TextInputDialogBox . TextInputDialogListener ; import com . badlogic . gdx . utils . IntMap ; import com . badlogic . gdx . utils . IntSet ; import com . badlogic . gdx . utils . TimeUtils ; import com . gargoylesoftware . htmlunit . javascript . host . Navigator ; import com . google . gwt . core . client . JavaScriptObject ; import com . google . gwt . core . client . JsArray ; import com . google . gwt . dom . client . CanvasElement ; import com . google . gwt . dom . client . Document ; import com . google . gwt . dom . client . Element ; import com . google . gwt . dom . client . NativeEvent ; import com . google . gwt . dom . client . Touch ; import com . google . gwt . event . dom . client . KeyCodes ; import com . google . gwt . logging . client . ConsoleLogHandler ; public class GwtInput implements Input { static final int MAX_TOUCHES = <int> ; boolean justTouched = false ; private IntMap < Integer > touchMap = new IntMap < Integer > ( <int> ) ; private boolean [ ] touched = new boolean [ MAX_TOUCHES ] ; private int [ ] touchX = new int [ MAX_TOUCHES ] ; private int [ ] touchY = new int [ MAX_TOUCHES ] ; private int [ ] deltaX = new int [ MAX_TOUCHES ] ; private int [ ] deltaY = new int [ MAX_TOUCHES ] ; IntSet pressedButtons = new IntSet ( ) ; int pressedKeyCount = <int> ; boolean [ ] pressedKeys = new boolean [ <int> ] ; boolean keyJustPressed = false ; boolean [ ] justPressedKeys = new boolean [ <int> ] ; InputProcessor processor ; char lastKeyCharPressed ; float keyRepeatTimer ; long currentEventTimeStamp ; final CanvasElement canvas ; boolean hasFocus = true ; public GwtInput ( CanvasElement canvas ) { this . canvas = canvas ; hookEvents ( ) ; } void reset ( ) { justTouched = false ; if ( keyJustPressed ) { keyJustPressed = false ; for ( int i = <int> ; i < justPressedKeys . length ; i + + ) { justPressedKeys [ i ] = false ; } } } @Override public float getAccelerometerX ( ) { return <int> ; } @Override public float getAccelerometerY ( ) { return <int> ; } @Override public float getAccelerometerZ ( ) { return <int> ; } @Override public int getX ( ) { return touchX [ <int> ] ; } @Override public int getX ( int pointer ) { return touchX [ pointer ] ; } @Override public int getDeltaX ( ) { return deltaX [ <int> ] ; } @Override public int getDeltaX ( int pointer ) { return deltaX [ pointer ] ; } @Override public int getY ( ) { return touchY [ <int> ] ; } @Override public int getY ( int pointer ) { return touchY [ pointer ] ; } @Override public int getDeltaY ( ) { return deltaY [ <int> ] ; } @Override public int getDeltaY ( int pointer ) { return deltaY [ pointer ] ; } @Override public boolean isTouched ( ) { for ( int pointer = <int> ; pointer < MAX_TOUCHES ; pointer + + ) { if ( touched [ pointer ] ) { return true ; } } return false ; } @Override public boolean justTouched ( ) { return justTouched ; } @Override public boolean isTouched ( int pointer ) { return touched [ pointer ] ; } @Override public boolean isButtonPressed ( int button ) { return button = = Buttons . LEFT & & touched [ <int> ] ; } @Override public boolean isKeyPressed ( int key ) { if ( key = = Keys . ANY_KEY ) { return pressedKeyCount > <int> ; } if ( key < <int> | | key > <int> ) { return false ; } return pressedKeys [ key ] ; } @Override public boolean isKeyJustPressed ( int key ) { if ( key = = Keys . ANY_KEY ) { return keyJustPressed ; } if ( key < <int> | | key > <int> ) { return false ; } return justPressedKeys [ key ] ; } public void getTextInput ( TextInputListener listener , String title , String text , String hint ) { TextInputDialogBox dialog = new TextInputDialogBox ( title , text , hint ) ; final TextInputListener capturedListener = listener ; dialog . setListener ( new TextInputDialogListener ( ) { @Override public void onPositive ( String text ) { if ( capturedListener ! = null ) { capturedListener . input ( text ) ; } } @Override public void onNegative ( ) { if ( capturedListener ! = null ) { capturedListener . canceled ( ) ; } } } ) ; } @Override public void setOnscreenKeyboardVisible ( boolean visible ) { } @Override public void vibrate ( int milliseconds ) { } @Override public void vibrate ( long [ ] pattern , int repeat ) { } @Override public void cancelVibrate ( ) { } @Override public float getAzimuth ( ) { return <int> ; } @Override public float getPitch ( ) { return <int> ; } @Override public float getRoll ( ) { return <int> ; } @Override public void getRotationMatrix ( float [ ] matrix ) { } @Override public long getCurrentEventTime ( ) { return currentEventTimeStamp ; } @Override public void setCatchBackKey ( boolean catchBack ) { } @Override public boolean isCatchBackKey ( ) { return false ; } @Override public void setCatchMenuKey ( boolean catchMenu ) { } @Override public boolean isCatchMenuKey ( ) { return false ; } @Override public void setInputProcessor ( InputProcessor processor ) { this . processor = processor ; } @Override public InputProcessor getInputProcessor ( ) { return processor ; } @Override public boolean isPeripheralAvailable ( Peripheral peripheral ) { if ( peripheral = = Peripheral . Accelerometer ) return false ; if ( peripheral = = Peripheral . Compass ) return false ; if ( peripheral = = Peripheral . HardwareKeyboard ) return true ; if ( peripheral = = Peripheral . MultitouchScreen ) return isTouchScreen ( ) ; if ( peripheral = = Peripheral . OnscreenKeyboard ) return false ; if ( peripheral = = Peripheral . Vibrator ) return false ; return false ; } @Override public int getRotation ( ) { return <int> ; } @Override public Orientation getNativeOrientation ( ) { return Orientation . Landscape ; } private native boolean isCursorCatchedJSNI ( ) ; private native void setCursorCatchedJSNI ( CanvasElement element ) ; private native void exitCursorCatchedJSNI ( ) ; private native float getMovementXJSNI ( NativeEvent event ) ; private native float getMovementYJSNI ( NativeEvent event ) ; private static native boolean isTouchScreen ( ) ; @Override public void setCursorCatched ( boolean catched ) { if ( catched ) setCursorCatchedJSNI ( canvas ) ; else exitCursorCatchedJSNI ( ) ; } @Override public boolean isCursorCatched ( ) { return isCursorCatchedJSNI ( ) ; } @Override public void setCursorPosition ( int x , int y ) { } static native void addEventListener ( JavaScriptObject target , String name , GwtInput handler , boolean capture ) ; private static native float getMouseWheelVelocity ( NativeEvent evt ) ; protected static native String getMouseWheelEvent ( ) ; protected int getRelativeX ( NativeEvent e , CanvasElement target ) { float xScaleRatio = target . getWidth ( ) * <float> / target . getClientWidth ( ) ; return Math . round ( xScaleRatio * ( e . getClientX ( ) - target . getAbsoluteLeft ( ) + target . getScrollLeft ( ) + target . getOwnerDocument ( ) . getScrollLeft ( ) ) ) ; } protected int getRelativeY ( NativeEvent e , CanvasElement target ) { float yScaleRatio = target . getHeight ( ) * <float> / target . getClientHeight ( ) ; return Math . round ( yScaleRatio * ( e . getClientY ( ) - target . getAbsoluteTop ( ) + target . getScrollTop ( ) + target . getOwnerDocument ( ) . getScrollTop ( ) ) ) ; } protected int getRelativeX ( Touch touch , CanvasElement target ) { float xScaleRatio = target . getWidth ( ) * <float> / target . getClientWidth ( ) ; return Math . round ( xScaleRatio * touch . getRelativeX ( target ) ) ; } protected int getRelativeY ( Touch touch , CanvasElement target ) { float yScaleRatio = target . getHeight ( ) * <float> / target . getClientHeight ( ) ; return Math . round ( yScaleRatio * touch . getRelativeY ( target ) ) ; } private void hookEvents ( ) { addEventListener ( canvas , <str> , this , true ) ; addEventListener ( Document . get ( ) , <str> , this , true ) ; addEventListener ( canvas , <str> , this , true ) ; addEventListener ( Document . get ( ) , <str> , this , true ) ; addEventListener ( canvas , <str> , this , true ) ; addEventListener ( Document . get ( ) , <str> , this , true ) ; addEventListener ( canvas , getMouseWheelEvent ( ) , this , true ) ; addEventListener ( Document . get ( ) , <str> , this , false ) ; addEventListener ( Document . get ( ) , <str> , this , false ) ; addEventListener ( Document . get ( ) , <str> , this , false ) ; addEventListener ( canvas , <str> , this , true ) ; addEventListener ( canvas , <str> , this , true ) ; addEventListener ( canvas , <str> , this , true ) ; addEventListener ( canvas , <str> , this , true ) ; } private int getButton ( int button ) { if ( button = = NativeEvent . BUTTON_LEFT ) return Buttons . LEFT ; if ( button = = NativeEvent . BUTTON_RIGHT ) return Buttons . RIGHT ; if ( button = = NativeEvent . BUTTON_MIDDLE ) return Buttons . MIDDLE ; return Buttons . LEFT ; } private void handleEvent ( NativeEvent e ) { if ( e . getType ( ) . equals ( <str> ) ) { if ( ! e . getEventTarget ( ) . equals ( canvas ) | | touched [ <int> ] ) { float mouseX = getRelativeX ( e , canvas ) ; float mouseY = getRelativeY ( e , canvas ) ; if ( mouseX < <int> | | mouseX > Gdx . graphics . getWidth ( ) | | mouseY < <int> | | mouseY > Gdx . graphics . getHeight ( ) ) { hasFocus = false ; } return ; } hasFocus = true ; this . justTouched = true ; this . touched [ <int> ] = true ; this . pressedButtons . add ( getButton ( e . getButton ( ) ) ) ; this . deltaX [ <int> ] = <int> ; this . deltaY [ <int> ] = <int> ; if ( isCursorCatched ( ) ) { this . touchX [ <int> ] + = getMovementXJSNI ( e ) ; this . touchY [ <int> ] + = getMovementYJSNI ( e ) ; } else { this . touchX [ <int> ] = getRelativeX ( e , canvas ) ; this . touchY [ <int> ] = getRelativeY ( e , canvas ) ; } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; if ( processor ! = null ) processor . touchDown ( touchX [ <int> ] , touchY [ <int> ] , <int> , getButton ( e . getButton ( ) ) ) ; } if ( e . getType ( ) . equals ( <str> ) ) { if ( isCursorCatched ( ) ) { this . deltaX [ <int> ] = ( int ) getMovementXJSNI ( e ) ; this . deltaY [ <int> ] = ( int ) getMovementYJSNI ( e ) ; this . touchX [ <int> ] + = getMovementXJSNI ( e ) ; this . touchY [ <int> ] + = getMovementYJSNI ( e ) ; } else { this . deltaX [ <int> ] = getRelativeX ( e , canvas ) - touchX [ <int> ] ; this . deltaY [ <int> ] = getRelativeY ( e , canvas ) - touchY [ <int> ] ; this . touchX [ <int> ] = getRelativeX ( e , canvas ) ; this . touchY [ <int> ] = getRelativeY ( e , canvas ) ; } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; if ( processor ! = null ) { if ( touched [ <int> ] ) processor . touchDragged ( touchX [ <int> ] , touchY [ <int> ] , <int> ) ; else processor . mouseMoved ( touchX [ <int> ] , touchY [ <int> ] ) ; } } if ( e . getType ( ) . equals ( <str> ) ) { if ( ! touched [ <int> ] ) return ; this . pressedButtons . remove ( getButton ( e . getButton ( ) ) ) ; this . touched [ <int> ] = pressedButtons . size > <int> ; if ( isCursorCatched ( ) ) { this . deltaX [ <int> ] = ( int ) getMovementXJSNI ( e ) ; this . deltaY [ <int> ] = ( int ) getMovementYJSNI ( e ) ; this . touchX [ <int> ] + = getMovementXJSNI ( e ) ; this . touchY [ <int> ] + = getMovementYJSNI ( e ) ; } else { this . deltaX [ <int> ] = getRelativeX ( e , canvas ) - touchX [ <int> ] ; this . deltaY [ <int> ] = getRelativeY ( e , canvas ) - touchY [ <int> ] ; this . touchX [ <int> ] = getRelativeX ( e , canvas ) ; this . touchY [ <int> ] = getRelativeY ( e , canvas ) ; } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; this . touched [ <int> ] = false ; if ( processor ! = null ) processor . touchUp ( touchX [ <int> ] , touchY [ <int> ] , <int> , getButton ( e . getButton ( ) ) ) ; } if ( e . getType ( ) . equals ( getMouseWheelEvent ( ) ) ) { if ( processor ! = null ) { processor . scrolled ( ( int ) getMouseWheelVelocity ( e ) ) ; } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; e . preventDefault ( ) ; } if ( e . getType ( ) . equals ( <str> ) & & hasFocus ) { int code = keyForCode ( e . getKeyCode ( ) ) ; if ( code = = <int> ) { e . preventDefault ( ) ; if ( processor ! = null ) { processor . keyDown ( code ) ; processor . keyTyped ( <str> ) ; } } else { if ( ! pressedKeys [ code ] ) { pressedKeyCount + + ; pressedKeys [ code ] = true ; keyJustPressed = true ; justPressedKeys [ code ] = true ; if ( processor ! = null ) { processor . keyDown ( code ) ; } } } } if ( e . getType ( ) . equals ( <str> ) & & hasFocus ) { char c = ( char ) e . getCharCode ( ) ; if ( processor ! = null ) processor . keyTyped ( c ) ; } if ( e . getType ( ) . equals ( <str> ) & & hasFocus ) { int code = keyForCode ( e . getKeyCode ( ) ) ; if ( pressedKeys [ code ] ) { pressedKeyCount - - ; pressedKeys [ code ] = false ; } if ( processor ! = null ) { processor . keyUp ( code ) ; } } if ( e . getType ( ) . equals ( <str> ) ) { this . justTouched = true ; JsArray < Touch > touches = e . getChangedTouches ( ) ; for ( int i = <int> , j = touches . length ( ) ; i < j ; i + + ) { Touch touch = touches . get ( i ) ; int real = touch . getIdentifier ( ) ; int touchId ; touchMap . put ( real , touchId = getAvailablePointer ( ) ) ; touched [ touchId ] = true ; touchX [ touchId ] = getRelativeX ( touch , canvas ) ; touchY [ touchId ] = getRelativeY ( touch , canvas ) ; deltaX [ touchId ] = <int> ; deltaY [ touchId ] = <int> ; if ( processor ! = null ) { processor . touchDown ( touchX [ touchId ] , touchY [ touchId ] , touchId , Buttons . LEFT ) ; } } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; e . preventDefault ( ) ; } if ( e . getType ( ) . equals ( <str> ) ) { JsArray < Touch > touches = e . getChangedTouches ( ) ; for ( int i = <int> , j = touches . length ( ) ; i < j ; i + + ) { Touch touch = touches . get ( i ) ; int real = touch . getIdentifier ( ) ; int touchId = touchMap . get ( real ) ; deltaX [ touchId ] = getRelativeX ( touch , canvas ) - touchX [ touchId ] ; deltaY [ touchId ] = getRelativeY ( touch , canvas ) - touchY [ touchId ] ; touchX [ touchId ] = getRelativeX ( touch , canvas ) ; touchY [ touchId ] = getRelativeY ( touch , canvas ) ; if ( processor ! = null ) { processor . touchDragged ( touchX [ touchId ] , touchY [ touchId ] , touchId ) ; } } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; e . preventDefault ( ) ; } if ( e . getType ( ) . equals ( <str> ) ) { JsArray < Touch > touches = e . getChangedTouches ( ) ; for ( int i = <int> , j = touches . length ( ) ; i < j ; i + + ) { Touch touch = touches . get ( i ) ; int real = touch . getIdentifier ( ) ; int touchId = touchMap . get ( real ) ; touchMap . remove ( real ) ; touched [ touchId ] = false ; deltaX [ touchId ] = getRelativeX ( touch , canvas ) - touchX [ touchId ] ; deltaY [ touchId ] = getRelativeY ( touch , canvas ) - touchY [ touchId ] ; touchX [ touchId ] = getRelativeX ( touch , canvas ) ; touchY [ touchId ] = getRelativeY ( touch , canvas ) ; if ( processor ! = null ) { processor . touchUp ( touchX [ touchId ] , touchY [ touchId ] , touchId , Buttons . LEFT ) ; } } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; e . preventDefault ( ) ; } if ( e . getType ( ) . equals ( <str> ) ) { JsArray < Touch > touches = e . getChangedTouches ( ) ; for ( int i = <int> , j = touches . length ( ) ; i < j ; i + + ) { Touch touch = touches . get ( i ) ; int real = touch . getIdentifier ( ) ; int touchId = touchMap . get ( real ) ; touchMap . remove ( real ) ; touched [ touchId ] = false ; deltaX [ touchId ] = getRelativeX ( touch , canvas ) - touchX [ touchId ] ; deltaY [ touchId ] = getRelativeY ( touch , canvas ) - touchY [ touchId ] ; touchX [ touchId ] = getRelativeX ( touch , canvas ) ; touchY [ touchId ] = getRelativeY ( touch , canvas ) ; if ( processor ! = null ) { processor . touchUp ( touchX [ touchId ] , touchY [ touchId ] , touchId , Buttons . LEFT ) ; } } this . currentEventTimeStamp = TimeUtils . nanoTime ( ) ; e . preventDefault ( ) ; } } private int getAvailablePointer ( ) { for ( int i = <int> ; i < MAX_TOUCHES ; i + + ) { if ( ! touchMap . containsValue ( i , false ) ) return i ; } return - <int> ; } private static int keyForCode ( int keyCode ) { switch ( keyCode ) { case KeyCodes . KEY_ALT : return Keys . ALT_LEFT ; case KeyCodes . KEY_BACKSPACE : return Keys . BACKSPACE ; case KeyCodes . KEY_CTRL : return Keys . CONTROL_LEFT ; case KeyCodes . KEY_DELETE : return Keys . DEL ; case KeyCodes . KEY_DOWN : return Keys . DOWN ; case KeyCodes . KEY_END : return Keys . END ; case KeyCodes . KEY_ENTER : return Keys . ENTER ; case KeyCodes . KEY_ESCAPE : return Keys . ESCAPE ; case KeyCodes . KEY_HOME : return Keys . HOME ; case KeyCodes . KEY_LEFT : return Keys . LEFT ; case KeyCodes . KEY_PAGEDOWN : return Keys . PAGE_DOWN ; case KeyCodes . KEY_PAGEUP : return Keys . PAGE_UP ; case KeyCodes . KEY_RIGHT : return Keys . RIGHT ; case KeyCodes . KEY_SHIFT : return Keys . SHIFT_LEFT ; case KeyCodes . KEY_TAB : return Keys . TAB ; case KeyCodes . KEY_UP : return Keys . UP ; case KEY_PAUSE : return Keys . UNKNOWN ; case KEY_CAPS_LOCK : return Keys . UNKNOWN ; case KEY_SPACE : return Keys . SPACE ; case KEY_INSERT : return Keys . INSERT ; case KEY_0 : return Keys . NUM_0 ; case KEY_1 : return Keys . NUM_1 ; case KEY_2 : return Keys . NUM_2 ; case KEY_3 : return Keys . NUM_3 ; case KEY_4 : return Keys . NUM_4 ; case KEY_5 : return Keys . NUM_5 ; case KEY_6 : return Keys . NUM_6 ; case KEY_7 : return Keys . NUM_7 ; case KEY_8 : return Keys . NUM_8 ; case KEY_9 : return Keys . NUM_9 ; case KEY_A : return Keys . A ; case KEY_B : return Keys . B ; case KEY_C : return Keys . C ; case KEY_D : return Keys . D ; case KEY_E : return Keys . E ; case KEY_F : return Keys . F ; case KEY_G : return Keys . G ; case KEY_H : return Keys . H ; case KEY_I : return Keys . I ; case KEY_J : return Keys . J ; case KEY_K : return Keys . K ; case KEY_L : return Keys . L ; case KEY_M : return Keys . M ; case KEY_N : return Keys . N ; case KEY_O : return Keys . O ; case KEY_P : return Keys . P ; case KEY_Q : return Keys . Q ; case KEY_R : return Keys . R ; case KEY_S : return Keys . S ; case KEY_T : return Keys . T ; case KEY_U : return Keys . U ; case KEY_V : return Keys . V ; case KEY_W : return Keys . W ; case KEY_X : return Keys . X ; case KEY_Y : return Keys . Y ; case KEY_Z : return Keys . Z ; case KEY_LEFT_WINDOW_KEY : return Keys . UNKNOWN ; case KEY_RIGHT_WINDOW_KEY : return Keys . UNKNOWN ; case KEY_NUMPAD0 : return Keys . NUMPAD_0 ; case KEY_NUMPAD1 : return Keys . NUMPAD_1 ; case KEY_NUMPAD2 : return Keys . NUMPAD_2 ; case KEY_NUMPAD3 : return Keys . NUMPAD_3 ; case KEY_NUMPAD4 : return Keys . NUMPAD_4 ; case KEY_NUMPAD5 : return Keys . NUMPAD_5 ; case KEY_NUMPAD6 : return Keys . NUMPAD_6 ; case KEY_NUMPAD7 : return Keys . NUMPAD_7 ; case KEY_NUMPAD8 : return Keys . NUMPAD_8 ; case KEY_NUMPAD9 : return Keys . NUMPAD_9 ; case KEY_MULTIPLY : return Keys . UNKNOWN ; case KEY_ADD : return Keys . PLUS ; case KEY_SUBTRACT : return Keys . MINUS ; case KEY_DECIMAL_POINT_KEY : return Keys . PERIOD ; case KEY_DIVIDE : return Keys . UNKNOWN ; case KEY_F1 : return Keys . F1 ; case KEY_F2 : return Keys . F2 ; case KEY_F3 : return Keys . F3 ; case KEY_F4 : return Keys . F4 ; case KEY_F5 : return Keys . F5 ; case KEY_F6 : return Keys . F6 ; case KEY_F7 : return Keys . F7 ; case KEY_F8 : return Keys . F8 ; case KEY_F9 : return Keys . F9 ; case KEY_F10 : return Keys . F10 ; case KEY_F11 : return Keys . F11 ; case KEY_F12 : return Keys . F12 ; case KEY_NUM_LOCK : return Keys . NUM ; case KEY_SCROLL_LOCK : return Keys . UNKNOWN ; case KEY_SEMICOLON : return Keys . SEMICOLON ; case KEY_EQUALS : return Keys . EQUALS ; case KEY_COMMA : return Keys . COMMA ; case KEY_DASH : return Keys . MINUS ; case KEY_PERIOD : return Keys . PERIOD ; case KEY_FORWARD_SLASH : return Keys . SLASH ; case KEY_GRAVE_ACCENT : return Keys . UNKNOWN ; case KEY_OPEN_BRACKET : return Keys . LEFT_BRACKET ; case KEY_BACKSLASH : return Keys . BACKSLASH ; case KEY_CLOSE_BRACKET : return Keys . RIGHT_BRACKET ; case KEY_SINGLE_QUOTE : return Keys . APOSTROPHE ; default : return Keys . UNKNOWN ; } } private static final int KEY_PAUSE = <int> ; private static final int KEY_CAPS_LOCK = <int> ; private static final int KEY_SPACE = <int> ; private static final int KEY_INSERT = <int> ; private static final int KEY_0 = <int> ; private static final int KEY_1 = <int> ; private static final int KEY_2 = <int> ; private static final int KEY_3 = <int> ; private static final int KEY_4 = <int> ; private static final int KEY_5 = <int> ; private static final int KEY_6 = <int> ; private static final int KEY_7 = <int> ; private static final int KEY_8 = <int> ; private static final int KEY_9 = <int> ; private static final int KEY_A = <int> ; private static final int KEY_B = <int> ; private static final int KEY_C = <int> ; private static final int KEY_D = <int> ; private static final int KEY_E = <int> ; private static final int KEY_F = <int> ; private static final int KEY_G = <int> ; private static final int KEY_H = <int> ; private static final int KEY_I = <int> ; private static final int KEY_J = <int> ; private static final int KEY_K = <int> ; private static final int KEY_L = <int> ; private static final int KEY_M = <int> ; private static final int KEY_N = <int> ; private static final int KEY_O = <int> ; private static final int KEY_P = <int> ; private static final int KEY_Q = <int> ; private static final int KEY_R = <int> ; private static final int KEY_S = <int> ; private static final int KEY_T = <int> ; private static final int KEY_U = <int> ; private static final int KEY_V = <int> ; private static final int KEY_W = <int> ; private static final int KEY_X = <int> ; private static final int KEY_Y = <int> ; private static final int KEY_Z = <int> ; private static final int KEY_LEFT_WINDOW_KEY = <int> ; private static final int KEY_RIGHT_WINDOW_KEY = <int> ; private static final int KEY_SELECT_KEY = <int> ; private static final int KEY_NUMPAD0 = <int> ; private static final int KEY_NUMPAD1 = <int> ; private static final int KEY_NUMPAD2 = <int> ; private static final int KEY_NUMPAD3 = <int> ; private static final int KEY_NUMPAD4 = <int> ; private static final int KEY_NUMPAD5 = <int> ; private static final int KEY_NUMPAD6 = <int> ; private static final int KEY_NUMPAD7 = <int> ; private static final int KEY_NUMPAD8 = <int> ; private static final int KEY_NUMPAD9 = <int> ; private static final int KEY_MULTIPLY = <int> ; private static final int KEY_ADD = <int> ; private static final int KEY_SUBTRACT = <int> ; private static final int KEY_DECIMAL_POINT_KEY = <int> ; private static final int KEY_DIVIDE = <int> ; private static final int KEY_F1 = <int> ; private static final int KEY_F2 = <int> ; private static final int KEY_F3 = <int> ; private static final int KEY_F4 = <int> ; private static final int KEY_F5 = <int> ; private static final int KEY_F6 = <int> ; private static final int KEY_F7 = <int> ; private static final int KEY_F8 = <int> ; private static final int KEY_F9 = <int> ; private static final int KEY_F10 = <int> ; private static final int KEY_F11 = <int> ; private static final int KEY_F12 = <int> ; private static final int KEY_NUM_LOCK = <int> ; private static final int KEY_SCROLL_LOCK = <int> ; private static final int KEY_SEMICOLON = <int> ; private static final int KEY_EQUALS = <int> ; private static final int KEY_COMMA = <int> ; private static final int KEY_DASH = <int> ; private static final int KEY_PERIOD = <int> ; private static final int KEY_FORWARD_SLASH = <int> ; private static final int KEY_GRAVE_ACCENT = <int> ; private static final int KEY_OPEN_BRACKET = <int> ; private static final int KEY_BACKSLASH = <int> ; private static final int KEY_CLOSE_BRACKET = <int> ; private static final int KEY_SINGLE_QUOTE = <int> ; } 
