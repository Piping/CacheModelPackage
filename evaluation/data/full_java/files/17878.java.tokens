package com . badlogic . gdx . tools . texturepacker ; import com . badlogic . gdx . tools . texturepacker . TexturePacker . Alias ; import com . badlogic . gdx . tools . texturepacker . TexturePacker . Rect ; import com . badlogic . gdx . tools . texturepacker . TexturePacker . Settings ; import com . badlogic . gdx . utils . Array ; import java . awt . Graphics2D ; import java . awt . Image ; import java . awt . RenderingHints ; import java . awt . image . BufferedImage ; import java . awt . image . WritableRaster ; import java . io . File ; import java . io . IOException ; import java . math . BigInteger ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . imageio . ImageIO ; public class ImageProcessor { static private final BufferedImage emptyImage = new BufferedImage ( <int> , <int> , BufferedImage . TYPE_4BYTE_ABGR ) ; static private Pattern indexPattern = Pattern . compile ( <str> ) ; private String rootPath ; private final Settings settings ; private final HashMap < String , Rect > crcs = new HashMap ( ) ; private final Array < Rect > rects = new Array ( ) ; private float scale = <int> ; public ImageProcessor ( File rootDir , Settings settings ) { this . settings = settings ; if ( rootDir ! = null ) { rootPath = rootDir . getAbsolutePath ( ) . replace ( <str> , <str> ) ; if ( ! rootPath . endsWith ( <str> ) ) rootPath + = <str> ; } } public ImageProcessor ( Settings settings ) { this ( null , settings ) ; } public void addImage ( File file ) { BufferedImage image ; try { image = ImageIO . read ( file ) ; } catch ( IOException ex ) { throw new RuntimeException ( <str> + file , ex ) ; } if ( image = = null ) throw new RuntimeException ( <str> + file ) ; String name = file . getAbsolutePath ( ) . replace ( <str> , <str> ) ; if ( rootPath ! = null ) { if ( ! name . startsWith ( rootPath ) ) throw new RuntimeException ( <str> + name + <str> + rootPath ) ; name = name . substring ( rootPath . length ( ) ) ; } int dotIndex = name . lastIndexOf ( <str> ) ; if ( dotIndex ! = - <int> ) name = name . substring ( <int> , dotIndex ) ; Rect rect = addImage ( image , name ) ; if ( rect ! = null & & settings . limitMemory ) rect . unloadImage ( file ) ; } public Rect addImage ( BufferedImage image , String name ) { Rect rect = processImage ( image , name ) ; if ( rect = = null ) { if ( ! settings . silent ) System . out . println ( <str> + name ) ; return null ; } if ( settings . alias ) { String crc = hash ( rect . getImage ( this ) ) ; Rect existing = crcs . get ( crc ) ; if ( existing ! = null ) { if ( ! settings . silent ) System . out . println ( rect . name + <str> + existing . name + <str> ) ; existing . aliases . add ( new Alias ( rect ) ) ; return null ; } crcs . put ( crc , rect ) ; } rects . add ( rect ) ; return rect ; } public void setScale ( float scale ) { this . scale = scale ; } public Array < Rect > getImages ( ) { return rects ; } public void clear ( ) { rects . clear ( ) ; crcs . clear ( ) ; } Rect processImage ( BufferedImage image , String name ) { if ( scale < = <int> ) throw new IllegalArgumentException ( <str> + scale ) ; int width = image . getWidth ( ) , height = image . getHeight ( ) ; if ( image . getType ( ) ! = BufferedImage . TYPE_4BYTE_ABGR ) { BufferedImage newImage = new BufferedImage ( width , height , BufferedImage . TYPE_4BYTE_ABGR ) ; newImage . getGraphics ( ) . drawImage ( image , <int> , <int> , null ) ; image = newImage ; } boolean isPatch = name . endsWith ( <str> ) ; int [ ] splits = null , pads = null ; Rect rect = null ; if ( isPatch ) { name = name . substring ( <int> , name . length ( ) - <int> ) ; splits = getSplits ( image , name ) ; pads = getPads ( image , name , splits ) ; width - = <int> ; height - = <int> ; BufferedImage newImage = new BufferedImage ( width , height , BufferedImage . TYPE_4BYTE_ABGR ) ; newImage . getGraphics ( ) . drawImage ( image , <int> , <int> , width , height , <int> , <int> , width + <int> , height + <int> , null ) ; image = newImage ; } if ( scale ! = <int> ) { int originalWidth = width , originalHeight = height ; width = Math . round ( width * scale ) ; height = Math . round ( height * scale ) ; BufferedImage newImage = new BufferedImage ( width , height , BufferedImage . TYPE_4BYTE_ABGR ) ; if ( scale < <int> ) { newImage . getGraphics ( ) . drawImage ( image . getScaledInstance ( width , height , Image . SCALE_AREA_AVERAGING ) , <int> , <int> , null ) ; } else { Graphics2D g = ( Graphics2D ) newImage . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; g . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; g . drawImage ( image , <int> , <int> , width , height , null ) ; } image = newImage ; } if ( isPatch ) { rect = new Rect ( image , <int> , <int> , width , height , true ) ; rect . splits = splits ; rect . pads = pads ; rect . canRotate = false ; } else { rect = stripWhitespace ( image ) ; if ( rect = = null ) return null ; } int index = - <int> ; if ( settings . useIndexes ) { Matcher matcher = indexPattern . matcher ( name ) ; if ( matcher . matches ( ) ) { name = matcher . group ( <int> ) ; index = Integer . parseInt ( matcher . group ( <int> ) ) ; } } rect . name = name ; rect . index = index ; return rect ; } private Rect stripWhitespace ( BufferedImage source ) { WritableRaster alphaRaster = source . getAlphaRaster ( ) ; if ( alphaRaster = = null | | ( ! settings . stripWhitespaceX & & ! settings . stripWhitespaceY ) ) return new Rect ( source , <int> , <int> , source . getWidth ( ) , source . getHeight ( ) , false ) ; final byte [ ] a = new byte [ <int> ] ; int top = <int> ; int bottom = source . getHeight ( ) ; if ( settings . stripWhitespaceX ) { outer : for ( int y = <int> ; y < source . getHeight ( ) ; y + + ) { for ( int x = <int> ; x < source . getWidth ( ) ; x + + ) { alphaRaster . getDataElements ( x , y , a ) ; int alpha = a [ <int> ] ; if ( alpha < <int> ) alpha + = <int> ; if ( alpha > settings . alphaThreshold ) break outer ; } top + + ; } outer : for ( int y = source . getHeight ( ) ; - - y > = top ; ) { for ( int x = <int> ; x < source . getWidth ( ) ; x + + ) { alphaRaster . getDataElements ( x , y , a ) ; int alpha = a [ <int> ] ; if ( alpha < <int> ) alpha + = <int> ; if ( alpha > settings . alphaThreshold ) break outer ; } bottom - - ; } } int left = <int> ; int right = source . getWidth ( ) ; if ( settings . stripWhitespaceY ) { outer : for ( int x = <int> ; x < source . getWidth ( ) ; x + + ) { for ( int y = top ; y < bottom ; y + + ) { alphaRaster . getDataElements ( x , y , a ) ; int alpha = a [ <int> ] ; if ( alpha < <int> ) alpha + = <int> ; if ( alpha > settings . alphaThreshold ) break outer ; } left + + ; } outer : for ( int x = source . getWidth ( ) ; - - x > = left ; ) { for ( int y = top ; y < bottom ; y + + ) { alphaRaster . getDataElements ( x , y , a ) ; int alpha = a [ <int> ] ; if ( alpha < <int> ) alpha + = <int> ; if ( alpha > settings . alphaThreshold ) break outer ; } right - - ; } } int newWidth = right - left ; int newHeight = bottom - top ; if ( newWidth < = <int> | | newHeight < = <int> ) { if ( settings . ignoreBlankImages ) return null ; else return new Rect ( emptyImage , <int> , <int> , <int> , <int> , false ) ; } return new Rect ( source , left , top , newWidth , newHeight , false ) ; } static private String splitError ( int x , int y , int [ ] rgba , String name ) { throw new RuntimeException ( <str> + name + <str> + x + <str> + y + <str> + rgba [ <int> ] + <str> + rgba [ <int> ] + <str> + rgba [ <int> ] + <str> + rgba [ <int> ] ) ; } private int [ ] getSplits ( BufferedImage image , String name ) { WritableRaster raster = image . getRaster ( ) ; int startX = getSplitPoint ( raster , name , <int> , <int> , true , true ) ; int endX = getSplitPoint ( raster , name , startX , <int> , false , true ) ; int startY = getSplitPoint ( raster , name , <int> , <int> , true , false ) ; int endY = getSplitPoint ( raster , name , <int> , startY , false , false ) ; getSplitPoint ( raster , name , endX + <int> , <int> , true , true ) ; getSplitPoint ( raster , name , <int> , endY + <int> , true , false ) ; if ( startX = = <int> & & endX = = <int> & & startY = = <int> & & endY = = <int> ) return null ; if ( startX ! = <int> ) { startX - - ; endX = raster . getWidth ( ) - <int> - ( endX - <int> ) ; } else { endX = raster . getWidth ( ) - <int> ; } if ( startY ! = <int> ) { startY - - ; endY = raster . getHeight ( ) - <int> - ( endY - <int> ) ; } else { endY = raster . getHeight ( ) - <int> ; } if ( scale ! = <int> ) { startX = ( int ) Math . round ( startX * scale ) ; endX = ( int ) Math . round ( endX * scale ) ; startY = ( int ) Math . round ( startY * scale ) ; endY = ( int ) Math . round ( endY * scale ) ; } return new int [ ] { startX , endX , startY , endY } ; } private int [ ] getPads ( BufferedImage image , String name , int [ ] splits ) { WritableRaster raster = image . getRaster ( ) ; int bottom = raster . getHeight ( ) - <int> ; int right = raster . getWidth ( ) - <int> ; int startX = getSplitPoint ( raster , name , <int> , bottom , true , true ) ; int startY = getSplitPoint ( raster , name , right , <int> , true , false ) ; int endX = <int> ; int endY = <int> ; if ( startX ! = <int> ) endX = getSplitPoint ( raster , name , startX + <int> , bottom , false , true ) ; if ( startY ! = <int> ) endY = getSplitPoint ( raster , name , right , startY + <int> , false , false ) ; getSplitPoint ( raster , name , endX + <int> , bottom , true , true ) ; getSplitPoint ( raster , name , right , endY + <int> , true , false ) ; if ( startX = = <int> & & endX = = <int> & & startY = = <int> & & endY = = <int> ) { return null ; } if ( startX = = <int> & & endX = = <int> ) { startX = - <int> ; endX = - <int> ; } else { if ( startX > <int> ) { startX - - ; endX = raster . getWidth ( ) - <int> - ( endX - <int> ) ; } else { endX = raster . getWidth ( ) - <int> ; } } if ( startY = = <int> & & endY = = <int> ) { startY = - <int> ; endY = - <int> ; } else { if ( startY > <int> ) { startY - - ; endY = raster . getHeight ( ) - <int> - ( endY - <int> ) ; } else { endY = raster . getHeight ( ) - <int> ; } } if ( scale ! = <int> ) { startX = ( int ) Math . round ( startX * scale ) ; endX = ( int ) Math . round ( endX * scale ) ; startY = ( int ) Math . round ( startY * scale ) ; endY = ( int ) Math . round ( endY * scale ) ; } int [ ] pads = new int [ ] { startX , endX , startY , endY } ; if ( splits ! = null & & Arrays . equals ( pads , splits ) ) { return null ; } return pads ; } static private int getSplitPoint ( WritableRaster raster , String name , int startX , int startY , boolean startPoint , boolean xAxis ) { int [ ] rgba = new int [ <int> ] ; int next = xAxis ? startX : startY ; int end = xAxis ? raster . getWidth ( ) : raster . getHeight ( ) ; int breakA = startPoint ? <int> : <int> ; int x = startX ; int y = startY ; while ( next ! = end ) { if ( xAxis ) x = next ; else y = next ; raster . getPixel ( x , y , rgba ) ; if ( rgba [ <int> ] = = breakA ) return next ; if ( ! startPoint & & ( rgba [ <int> ] ! = <int> | | rgba [ <int> ] ! = <int> | | rgba [ <int> ] ! = <int> | | rgba [ <int> ] ! = <int> ) ) splitError ( x , y , rgba , name ) ; next + + ; } return <int> ; } static private String hash ( BufferedImage image ) { try { MessageDigest digest = MessageDigest . getInstance ( <str> ) ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; if ( image . getType ( ) ! = BufferedImage . TYPE_INT_ARGB ) { BufferedImage newImage = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; newImage . getGraphics ( ) . drawImage ( image , <int> , <int> , null ) ; image = newImage ; } WritableRaster raster = image . getRaster ( ) ; int [ ] pixels = new int [ width ] ; for ( int y = <int> ; y < height ; y + + ) { raster . getDataElements ( <int> , y , width , <int> , pixels ) ; for ( int x = <int> ; x < width ; x + + ) hash ( digest , pixels [ x ] ) ; } hash ( digest , width ) ; hash ( digest , height ) ; return new BigInteger ( <int> , digest . digest ( ) ) . toString ( <int> ) ; } catch ( NoSuchAlgorithmException ex ) { throw new RuntimeException ( ex ) ; } } static private void hash ( MessageDigest digest , int value ) { digest . update ( ( byte ) ( value > > <int> ) ) ; digest . update ( ( byte ) ( value > > <int> ) ) ; digest . update ( ( byte ) ( value > > <int> ) ) ; digest . update ( ( byte ) value ) ; } } 
