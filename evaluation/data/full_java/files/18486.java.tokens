package com . badlogic . gdx . tests ; import java . util . ArrayList ; import java . util . List ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . Gdx2DPixmap ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . tests . utils . GdxTest ; public class Gdx2DTest extends GdxTest { SpriteBatch batch ; List < Sprite > sprites ; Texture textureFromPixmap ( Gdx2DPixmap pixmap ) { Texture texture = new Texture ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , Format . RGB565 ) ; texture . bind ( ) ; Gdx . gl . glTexImage2D ( GL20 . GL_TEXTURE_2D , <int> , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; return texture ; } void drawToPixmap ( Gdx2DPixmap pixmap ) { pixmap . clear ( Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . setPixel ( <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; int clearColor = <int> ; int pixelColor = <int> ; switch ( pixmap . getFormat ( ) ) { case Gdx2DPixmap . GDX2D_FORMAT_ALPHA : clearColor = Color . rgba8888 ( <int> , <int> , <int> , <float> ) ; pixelColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; break ; case Gdx2DPixmap . GDX2D_FORMAT_LUMINANCE_ALPHA : clearColor = <hex> ; pixelColor = <hex> ; break ; case Gdx2DPixmap . GDX2D_FORMAT_RGB565 : clearColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; pixelColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; break ; case Gdx2DPixmap . GDX2D_FORMAT_RGB888 : clearColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; pixelColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; break ; case Gdx2DPixmap . GDX2D_FORMAT_RGBA4444 : clearColor = <hex> ; pixelColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; break ; case Gdx2DPixmap . GDX2D_FORMAT_RGBA8888 : clearColor = Color . rgba8888 ( <int> , <int> , <int> , <float> ) ; pixelColor = Color . rgba8888 ( <int> , <int> , <int> , <int> ) ; } if ( pixmap . getPixel ( <int> , <int> ) ! = clearColor ) throw new RuntimeException ( <str> + pixmap . getFormatString ( ) ) ; if ( pixmap . getPixel ( <int> , <int> ) ! = pixelColor ) throw new RuntimeException ( <str> + pixmap . getFormatString ( ) ) ; pixmap . drawLine ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawRect ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . fillRect ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . drawCircle ( <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . fillCircle ( <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . fillTriangle ( <int> , <int> , <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <float> , <int> , <float> ) ) ; pixmap . drawLine ( <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawLine ( <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawLine ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawLine ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawRect ( - <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawRect ( <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawRect ( - <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . drawRect ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <int> ) ) ; pixmap . fillRect ( - <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . fillRect ( <int> , - <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . fillRect ( - <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; pixmap . fillRect ( <int> , <int> , <int> , <int> , Color . rgba8888 ( <int> , <int> , <int> , <float> ) ) ; } Gdx2DPixmap [ ] testPixmaps ( ) { int [ ] formats = { Gdx2DPixmap . GDX2D_FORMAT_ALPHA , Gdx2DPixmap . GDX2D_FORMAT_LUMINANCE_ALPHA , Gdx2DPixmap . GDX2D_FORMAT_RGB565 , Gdx2DPixmap . GDX2D_FORMAT_RGB888 , Gdx2DPixmap . GDX2D_FORMAT_RGBA4444 , Gdx2DPixmap . GDX2D_FORMAT_RGBA8888 } ; Gdx2DPixmap [ ] pixmaps = new Gdx2DPixmap [ formats . length ] ; for ( int i = <int> ; i < pixmaps . length ; i + + ) { Gdx2DPixmap pixmap = new Gdx2DPixmap ( <int> , <int> , formats [ i ] ) ; drawToPixmap ( pixmap ) ; pixmaps [ i ] = pixmap ; } return pixmaps ; } @Override public void create ( ) { batch = new SpriteBatch ( ) ; sprites = new ArrayList < Sprite > ( ) ; Gdx2DPixmap [ ] pixmaps = testPixmaps ( ) ; Gdx2DPixmap composite = new Gdx2DPixmap ( <int> , <int> , Gdx2DPixmap . GDX2D_FORMAT_RGBA8888 ) ; composite . clear ( <int> ) ; Gdx2DPixmap . setBlend ( Gdx2DPixmap . GDX2D_BLEND_NONE ) ; for ( int i = <int> ; i < pixmaps . length ; i + + ) { Gdx2DPixmap . setScale ( Gdx2DPixmap . GDX2D_SCALE_NEAREST ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; Gdx2DPixmap . setScale ( Gdx2DPixmap . GDX2D_SCALE_LINEAR ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; composite . drawPixmap ( pixmaps [ i ] , <int> , <int> , <int> , <int> , i * <int> , <int> , <int> , <int> ) ; Sprite sprite = new Sprite ( textureFromPixmap ( pixmaps [ i ] ) ) ; sprite . setPosition ( <int> + i * <int> , <int> ) ; sprites . add ( sprite ) ; } Sprite sprite = new Sprite ( textureFromPixmap ( composite ) ) ; sprite . setPosition ( <int> , <int> ) ; sprites . add ( sprite ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <float> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; batch . begin ( ) ; for ( int i = <int> ; i < sprites . size ( ) ; i + + ) { sprites . get ( i ) . draw ( batch ) ; } batch . end ( ) ; } } 
