package io . netty . channel . pool ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . EventLoop ; import io . netty . util . AttributeKey ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import java . util . Deque ; import static io . netty . util . internal . ObjectUtil . * ; public class SimpleChannelPool implements ChannelPool { private static final AttributeKey < SimpleChannelPool > POOL_KEY = AttributeKey . newInstance ( <str> ) ; private static final IllegalStateException FULL_EXCEPTION = new IllegalStateException ( <str> ) ; private static final IllegalStateException UNHEALTHY_NON_OFFERED_TO_POOL = new IllegalStateException ( <str> ) ; static { FULL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; UNHEALTHY_NON_OFFERED_TO_POOL . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private final Deque < Channel > deque = PlatformDependent . newConcurrentDeque ( ) ; private final ChannelPoolHandler handler ; private final ChannelHealthChecker healthCheck ; private final Bootstrap bootstrap ; private final boolean releaseHealthCheck ; public SimpleChannelPool ( Bootstrap bootstrap , final ChannelPoolHandler handler ) { this ( bootstrap , handler , ChannelHealthChecker . ACTIVE ) ; } public SimpleChannelPool ( Bootstrap bootstrap , final ChannelPoolHandler handler , ChannelHealthChecker healthCheck ) { this ( bootstrap , handler , healthCheck , true ) ; } public SimpleChannelPool ( Bootstrap bootstrap , final ChannelPoolHandler handler , ChannelHealthChecker healthCheck , boolean releaseHealthCheck ) { this . handler = checkNotNull ( handler , <str> ) ; this . healthCheck = checkNotNull ( healthCheck , <str> ) ; this . releaseHealthCheck = releaseHealthCheck ; this . bootstrap = checkNotNull ( bootstrap , <str> ) . clone ( ) ; this . bootstrap . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { assert ch . eventLoop ( ) . inEventLoop ( ) ; handler . channelCreated ( ch ) ; } } ) ; } @Override public final Future < Channel > acquire ( ) { return acquire ( bootstrap . group ( ) . next ( ) . < Channel > newPromise ( ) ) ; } @Override public Future < Channel > acquire ( final Promise < Channel > promise ) { checkNotNull ( promise , <str> ) ; return acquireHealthyFromPoolOrNew ( promise ) ; } private Future < Channel > acquireHealthyFromPoolOrNew ( final Promise < Channel > promise ) { try { final Channel ch = pollChannel ( ) ; if ( ch = = null ) { Bootstrap bs = bootstrap . clone ( ) ; bs . attr ( POOL_KEY , this ) ; ChannelFuture f = connectChannel ( bs ) ; if ( f . isDone ( ) ) { notifyConnect ( f , promise ) ; } else { f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { notifyConnect ( future , promise ) ; } } ) ; } return promise ; } EventLoop loop = ch . eventLoop ( ) ; if ( loop . inEventLoop ( ) ) { doHealthCheck ( ch , promise ) ; } else { loop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { doHealthCheck ( ch , promise ) ; } } ) ; } } catch ( Throwable cause ) { promise . setFailure ( cause ) ; } return promise ; } private static void notifyConnect ( ChannelFuture future , Promise < Channel > promise ) { if ( future . isSuccess ( ) ) { promise . setSuccess ( future . channel ( ) ) ; } else { promise . setFailure ( future . cause ( ) ) ; } } private void doHealthCheck ( final Channel ch , final Promise < Channel > promise ) { assert ch . eventLoop ( ) . inEventLoop ( ) ; Future < Boolean > f = healthCheck . isHealthy ( ch ) ; if ( f . isDone ( ) ) { notifyHealthCheck ( f , ch , promise ) ; } else { f . addListener ( new FutureListener < Boolean > ( ) { @Override public void operationComplete ( Future < Boolean > future ) throws Exception { notifyHealthCheck ( future , ch , promise ) ; } } ) ; } } private void notifyHealthCheck ( Future < Boolean > future , Channel ch , Promise < Channel > promise ) { assert ch . eventLoop ( ) . inEventLoop ( ) ; if ( future . isSuccess ( ) ) { if ( future . getNow ( ) = = Boolean . TRUE ) { try { ch . attr ( POOL_KEY ) . set ( this ) ; handler . channelAcquired ( ch ) ; promise . setSuccess ( ch ) ; } catch ( Throwable cause ) { closeAndFail ( ch , cause , promise ) ; } } else { closeChannel ( ch ) ; acquireHealthyFromPoolOrNew ( promise ) ; } } else { closeChannel ( ch ) ; acquireHealthyFromPoolOrNew ( promise ) ; } } protected ChannelFuture connectChannel ( Bootstrap bs ) { return bs . connect ( ) ; } @Override public final Future < Void > release ( Channel channel ) { return release ( channel , channel . eventLoop ( ) . < Void > newPromise ( ) ) ; } @Override public Future < Void > release ( final Channel channel , final Promise < Void > promise ) { checkNotNull ( channel , <str> ) ; checkNotNull ( promise , <str> ) ; try { EventLoop loop = channel . eventLoop ( ) ; if ( loop . inEventLoop ( ) ) { doReleaseChannel ( channel , promise ) ; } else { loop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { doReleaseChannel ( channel , promise ) ; } } ) ; } } catch ( Throwable cause ) { closeAndFail ( channel , cause , promise ) ; } return promise ; } private void doReleaseChannel ( Channel channel , Promise < Void > promise ) { assert channel . eventLoop ( ) . inEventLoop ( ) ; if ( channel . attr ( POOL_KEY ) . getAndSet ( null ) ! = this ) { closeAndFail ( channel , new IllegalArgumentException ( <str> + channel + <str> ) , promise ) ; } else { try { if ( releaseHealthCheck ) { doHealthCheckOnRelease ( channel , promise ) ; } else { releaseAndOffer ( channel , promise ) ; } } catch ( Throwable cause ) { closeAndFail ( channel , cause , promise ) ; } } } private void doHealthCheckOnRelease ( final Channel channel , final Promise < Void > promise ) throws Exception { final Future < Boolean > f = healthCheck . isHealthy ( channel ) ; if ( f . isDone ( ) ) { releaseAndOfferIfHealthy ( channel , promise , f ) ; } else { f . addListener ( new FutureListener < Boolean > ( ) { @Override public void operationComplete ( Future < Boolean > future ) throws Exception { releaseAndOfferIfHealthy ( channel , promise , f ) ; } } ) ; } } private void releaseAndOfferIfHealthy ( Channel channel , Promise < Void > promise , Future < Boolean > future ) throws Exception { if ( future . getNow ( ) ) { releaseAndOffer ( channel , promise ) ; } else { handler . channelReleased ( channel ) ; closeAndFail ( channel , UNHEALTHY_NON_OFFERED_TO_POOL , promise ) ; } } private void releaseAndOffer ( Channel channel , Promise < Void > promise ) throws Exception { if ( offerChannel ( channel ) ) { handler . channelReleased ( channel ) ; promise . setSuccess ( null ) ; } else { closeAndFail ( channel , FULL_EXCEPTION , promise ) ; } } private static void closeChannel ( Channel channel ) { channel . attr ( POOL_KEY ) . getAndSet ( null ) ; channel . close ( ) ; } private static void closeAndFail ( Channel channel , Throwable cause , Promise < ? > promise ) { closeChannel ( channel ) ; promise . setFailure ( cause ) ; } protected Channel pollChannel ( ) { return deque . pollLast ( ) ; } protected boolean offerChannel ( Channel channel ) { return deque . offer ( channel ) ; } @Override public void close ( ) { for ( ; ; ) { Channel channel = pollChannel ( ) ; if ( channel = = null ) { break ; } channel . close ( ) ; } } } 
