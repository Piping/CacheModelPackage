package io . netty . buffer ; import io . netty . util . ResourceLeak ; import io . netty . util . internal . EmptyArrays ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . ScatteringByteChannel ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . NoSuchElementException ; public class CompositeByteBuf extends AbstractReferenceCountedByteBuf implements Iterable < ByteBuf > { private static final ByteBuffer EMPTY_NIO_BUFFER = Unpooled . EMPTY_BUFFER . nioBuffer ( ) ; private static final Iterator < ByteBuf > EMPTY_ITERATOR = Collections . < ByteBuf > emptyList ( ) . iterator ( ) ; private final ResourceLeak leak ; private final ByteBufAllocator alloc ; private final boolean direct ; private final List < Component > components = new ArrayList < Component > ( ) ; private final int maxNumComponents ; private boolean freed ; public CompositeByteBuf ( ByteBufAllocator alloc , boolean direct , int maxNumComponents ) { super ( Integer . MAX_VALUE ) ; if ( alloc = = null ) { throw new NullPointerException ( <str> ) ; } this . alloc = alloc ; this . direct = direct ; this . maxNumComponents = maxNumComponents ; leak = leakDetector . open ( this ) ; } public CompositeByteBuf ( ByteBufAllocator alloc , boolean direct , int maxNumComponents , ByteBuf . . . buffers ) { super ( Integer . MAX_VALUE ) ; if ( alloc = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxNumComponents < <int> ) { throw new IllegalArgumentException ( <str> + maxNumComponents + <str> ) ; } this . alloc = alloc ; this . direct = direct ; this . maxNumComponents = maxNumComponents ; addComponents0 ( <int> , buffers ) ; consolidateIfNeeded ( ) ; setIndex ( <int> , capacity ( ) ) ; leak = leakDetector . open ( this ) ; } public CompositeByteBuf ( ByteBufAllocator alloc , boolean direct , int maxNumComponents , Iterable < ByteBuf > buffers ) { super ( Integer . MAX_VALUE ) ; if ( alloc = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxNumComponents < <int> ) { throw new IllegalArgumentException ( <str> + maxNumComponents + <str> ) ; } this . alloc = alloc ; this . direct = direct ; this . maxNumComponents = maxNumComponents ; addComponents0 ( <int> , buffers ) ; consolidateIfNeeded ( ) ; setIndex ( <int> , capacity ( ) ) ; leak = leakDetector . open ( this ) ; } public CompositeByteBuf addComponent ( ByteBuf buffer ) { addComponent0 ( components . size ( ) , buffer ) ; consolidateIfNeeded ( ) ; return this ; } public CompositeByteBuf addComponents ( ByteBuf . . . buffers ) { addComponents0 ( components . size ( ) , buffers ) ; consolidateIfNeeded ( ) ; return this ; } public CompositeByteBuf addComponents ( Iterable < ByteBuf > buffers ) { addComponents0 ( components . size ( ) , buffers ) ; consolidateIfNeeded ( ) ; return this ; } public CompositeByteBuf addComponent ( int cIndex , ByteBuf buffer ) { addComponent0 ( cIndex , buffer ) ; consolidateIfNeeded ( ) ; return this ; } private int addComponent0 ( int cIndex , ByteBuf buffer ) { checkComponentIndex ( cIndex ) ; if ( buffer = = null ) { throw new NullPointerException ( <str> ) ; } int readableBytes = buffer . readableBytes ( ) ; Component c = new Component ( buffer . order ( ByteOrder . BIG_ENDIAN ) . slice ( ) ) ; if ( cIndex = = components . size ( ) ) { components . add ( c ) ; if ( cIndex = = <int> ) { c . endOffset = readableBytes ; } else { Component prev = components . get ( cIndex - <int> ) ; c . offset = prev . endOffset ; c . endOffset = c . offset + readableBytes ; } } else { components . add ( cIndex , c ) ; if ( readableBytes ! = <int> ) { updateComponentOffsets ( cIndex ) ; } } return cIndex ; } public CompositeByteBuf addComponents ( int cIndex , ByteBuf . . . buffers ) { addComponents0 ( cIndex , buffers ) ; consolidateIfNeeded ( ) ; return this ; } private int addComponents0 ( int cIndex , ByteBuf . . . buffers ) { checkComponentIndex ( cIndex ) ; if ( buffers = = null ) { throw new NullPointerException ( <str> ) ; } for ( ByteBuf b : buffers ) { if ( b = = null ) { break ; } cIndex = addComponent0 ( cIndex , b ) + <int> ; int size = components . size ( ) ; if ( cIndex > size ) { cIndex = size ; } } return cIndex ; } public CompositeByteBuf addComponents ( int cIndex , Iterable < ByteBuf > buffers ) { addComponents0 ( cIndex , buffers ) ; consolidateIfNeeded ( ) ; return this ; } private int addComponents0 ( int cIndex , Iterable < ByteBuf > buffers ) { if ( buffers = = null ) { throw new NullPointerException ( <str> ) ; } if ( buffers instanceof ByteBuf ) { return addComponent0 ( cIndex , ( ByteBuf ) buffers ) ; } if ( ! ( buffers instanceof Collection ) ) { List < ByteBuf > list = new ArrayList < ByteBuf > ( ) ; for ( ByteBuf b : buffers ) { list . add ( b ) ; } buffers = list ; } Collection < ByteBuf > col = ( Collection < ByteBuf > ) buffers ; return addComponents0 ( cIndex , col . toArray ( new ByteBuf [ col . size ( ) ] ) ) ; } private void consolidateIfNeeded ( ) { final int numComponents = components . size ( ) ; if ( numComponents > maxNumComponents ) { final int capacity = components . get ( numComponents - <int> ) . endOffset ; ByteBuf consolidated = allocBuffer ( capacity ) ; for ( int i = <int> ; i < numComponents ; i + + ) { Component c = components . get ( i ) ; ByteBuf b = c . buf ; consolidated . writeBytes ( b ) ; c . freeIfNecessary ( ) ; } Component c = new Component ( consolidated ) ; c . endOffset = c . length ; components . clear ( ) ; components . add ( c ) ; } } private void checkComponentIndex ( int cIndex ) { ensureAccessible ( ) ; if ( cIndex < <int> | | cIndex > components . size ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> , cIndex , components . size ( ) ) ) ; } } private void checkComponentIndex ( int cIndex , int numComponents ) { ensureAccessible ( ) ; if ( cIndex < <int> | | cIndex + numComponents > components . size ( ) ) { throw new IndexOutOfBoundsException ( String . format ( <str> + <str> , cIndex , numComponents , components . size ( ) ) ) ; } } private void updateComponentOffsets ( int cIndex ) { int size = components . size ( ) ; if ( size < = cIndex ) { return ; } Component c = components . get ( cIndex ) ; if ( cIndex = = <int> ) { c . offset = <int> ; c . endOffset = c . length ; cIndex + + ; } for ( int i = cIndex ; i < size ; i + + ) { Component prev = components . get ( i - <int> ) ; Component cur = components . get ( i ) ; cur . offset = prev . endOffset ; cur . endOffset = cur . offset + cur . length ; } } public CompositeByteBuf removeComponent ( int cIndex ) { checkComponentIndex ( cIndex ) ; Component comp = components . remove ( cIndex ) ; comp . freeIfNecessary ( ) ; if ( comp . length > <int> ) { updateComponentOffsets ( cIndex ) ; } return this ; } public CompositeByteBuf removeComponents ( int cIndex , int numComponents ) { checkComponentIndex ( cIndex , numComponents ) ; if ( numComponents = = <int> ) { return this ; } List < Component > toRemove = components . subList ( cIndex , cIndex + numComponents ) ; boolean needsUpdate = false ; for ( Component c : toRemove ) { if ( c . length > <int> ) { needsUpdate = true ; } c . freeIfNecessary ( ) ; } toRemove . clear ( ) ; if ( needsUpdate ) { updateComponentOffsets ( cIndex ) ; } return this ; } @Override public Iterator < ByteBuf > iterator ( ) { ensureAccessible ( ) ; if ( components . isEmpty ( ) ) { return EMPTY_ITERATOR ; } return new CompositeByteBufIterator ( ) ; } public List < ByteBuf > decompose ( int offset , int length ) { checkIndex ( offset , length ) ; if ( length = = <int> ) { return Collections . emptyList ( ) ; } int componentId = toComponentIndex ( offset ) ; List < ByteBuf > slice = new ArrayList < ByteBuf > ( components . size ( ) ) ; Component firstC = components . get ( componentId ) ; ByteBuf first = firstC . buf . duplicate ( ) ; first . readerIndex ( offset - firstC . offset ) ; ByteBuf buf = first ; int bytesToSlice = length ; do { int readableBytes = buf . readableBytes ( ) ; if ( bytesToSlice < = readableBytes ) { buf . writerIndex ( buf . readerIndex ( ) + bytesToSlice ) ; slice . add ( buf ) ; break ; } else { slice . add ( buf ) ; bytesToSlice - = readableBytes ; componentId + + ; buf = components . get ( componentId ) . buf . duplicate ( ) ; } } while ( bytesToSlice > <int> ) ; for ( int i = <int> ; i < slice . size ( ) ; i + + ) { slice . set ( i , slice . get ( i ) . slice ( ) ) ; } return slice ; } @Override public boolean isDirect ( ) { int size = components . size ( ) ; if ( size = = <int> ) { return false ; } for ( int i = <int> ; i < size ; i + + ) { if ( ! components . get ( i ) . buf . isDirect ( ) ) { return false ; } } return true ; } @Override public boolean hasArray ( ) { switch ( components . size ( ) ) { case <int> : return true ; case <int> : return components . get ( <int> ) . buf . hasArray ( ) ; default : return false ; } } @Override public byte [ ] array ( ) { switch ( components . size ( ) ) { case <int> : return EmptyArrays . EMPTY_BYTES ; case <int> : return components . get ( <int> ) . buf . array ( ) ; default : throw new UnsupportedOperationException ( ) ; } } @Override public int arrayOffset ( ) { switch ( components . size ( ) ) { case <int> : return <int> ; case <int> : return components . get ( <int> ) . buf . arrayOffset ( ) ; default : throw new UnsupportedOperationException ( ) ; } } @Override public boolean hasMemoryAddress ( ) { switch ( components . size ( ) ) { case <int> : return Unpooled . EMPTY_BUFFER . hasMemoryAddress ( ) ; case <int> : return components . get ( <int> ) . buf . hasMemoryAddress ( ) ; default : return false ; } } @Override public long memoryAddress ( ) { switch ( components . size ( ) ) { case <int> : return Unpooled . EMPTY_BUFFER . memoryAddress ( ) ; case <int> : return components . get ( <int> ) . buf . memoryAddress ( ) ; default : throw new UnsupportedOperationException ( ) ; } } @Override public int capacity ( ) { final int numComponents = components . size ( ) ; if ( numComponents = = <int> ) { return <int> ; } return components . get ( numComponents - <int> ) . endOffset ; } @Override public CompositeByteBuf capacity ( int newCapacity ) { ensureAccessible ( ) ; if ( newCapacity < <int> | | newCapacity > maxCapacity ( ) ) { throw new IllegalArgumentException ( <str> + newCapacity ) ; } int oldCapacity = capacity ( ) ; if ( newCapacity > oldCapacity ) { final int paddingLength = newCapacity - oldCapacity ; ByteBuf padding ; int nComponents = components . size ( ) ; if ( nComponents < maxNumComponents ) { padding = allocBuffer ( paddingLength ) ; padding . setIndex ( <int> , paddingLength ) ; addComponent0 ( components . size ( ) , padding ) ; } else { padding = allocBuffer ( paddingLength ) ; padding . setIndex ( <int> , paddingLength ) ; addComponent0 ( components . size ( ) , padding ) ; consolidateIfNeeded ( ) ; } } else if ( newCapacity < oldCapacity ) { int bytesToTrim = oldCapacity - newCapacity ; for ( ListIterator < Component > i = components . listIterator ( components . size ( ) ) ; i . hasPrevious ( ) ; ) { Component c = i . previous ( ) ; if ( bytesToTrim > = c . length ) { bytesToTrim - = c . length ; i . remove ( ) ; continue ; } Component newC = new Component ( c . buf . slice ( <int> , c . length - bytesToTrim ) ) ; newC . offset = c . offset ; newC . endOffset = newC . offset + newC . length ; i . set ( newC ) ; break ; } if ( readerIndex ( ) > newCapacity ) { setIndex ( newCapacity , newCapacity ) ; } else if ( writerIndex ( ) > newCapacity ) { writerIndex ( newCapacity ) ; } } return this ; } @Override public ByteBufAllocator alloc ( ) { return alloc ; } @Override public ByteOrder order ( ) { return ByteOrder . BIG_ENDIAN ; } public int numComponents ( ) { return components . size ( ) ; } public int maxNumComponents ( ) { return maxNumComponents ; } public int toComponentIndex ( int offset ) { checkIndex ( offset ) ; for ( int low = <int> , high = components . size ( ) ; low < = high ; ) { int mid = low + high > > > <int> ; Component c = components . get ( mid ) ; if ( offset > = c . endOffset ) { low = mid + <int> ; } else if ( offset < c . offset ) { high = mid - <int> ; } else { return mid ; } } throw new Error ( <str> ) ; } public int toByteIndex ( int cIndex ) { checkComponentIndex ( cIndex ) ; return components . get ( cIndex ) . offset ; } @Override public byte getByte ( int index ) { return _getByte ( index ) ; } @Override protected byte _getByte ( int index ) { Component c = findComponent ( index ) ; return c . buf . getByte ( index - c . offset ) ; } @Override protected short _getShort ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getShort ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( short ) ( ( _getByte ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ) ; } else { return ( short ) ( _getByte ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ) ; } } @Override protected short _getShortLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getShortLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( short ) ( _getByte ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ) ; } else { return ( short ) ( ( _getByte ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ) ; } } @Override protected int _getUnsignedMedium ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getUnsignedMedium ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getShort ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ; } else { return _getShort ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected int _getUnsignedMediumLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getUnsignedMediumLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getShortLE ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getShortLE ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ; } } @Override protected int _getInt ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getInt ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getShort ( index ) & <hex> ) < < <int> | _getShort ( index + <int> ) & <hex> ; } else { return _getShort ( index ) & <hex> | ( _getShort ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected int _getIntLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getIntLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getShortLE ( index ) & <hex> | ( _getShortLE ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getShortLE ( index ) & <hex> ) < < <int> | _getShortLE ( index + <int> ) & <hex> ; } } @Override protected long _getLong ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getLong ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getInt ( index ) & <hex> ) < < <int> | _getInt ( index + <int> ) & <hex> ; } else { return _getInt ( index ) & <hex> | ( _getInt ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected long _getLongLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getLongLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getIntLE ( index ) & <hex> | ( _getIntLE ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getIntLE ( index ) & <hex> ) < < <int> | _getIntLE ( index + <int> ) & <hex> ; } } @Override public CompositeByteBuf getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { checkDstIndex ( index , length , dstIndex , dst . length ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; index + = localLength ; dstIndex + = localLength ; length - = localLength ; i + + ; } return this ; } @Override public CompositeByteBuf getBytes ( int index , ByteBuffer dst ) { int limit = dst . limit ( ) ; int length = dst . remaining ( ) ; checkIndex ( index , length ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; try { while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; dst . limit ( dst . position ( ) + localLength ) ; s . getBytes ( index - adjustment , dst ) ; index + = localLength ; length - = localLength ; i + + ; } } finally { dst . limit ( limit ) ; } return this ; } @Override public CompositeByteBuf getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { checkDstIndex ( index , length , dstIndex , dst . capacity ( ) ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; index + = localLength ; dstIndex + = localLength ; length - = localLength ; i + + ; } return this ; } @Override public int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException { int count = nioBufferCount ( ) ; if ( count = = <int> ) { return out . write ( internalNioBuffer ( index , length ) ) ; } else { long writtenBytes = out . write ( nioBuffers ( index , length ) ) ; if ( writtenBytes > Integer . MAX_VALUE ) { return Integer . MAX_VALUE ; } else { return ( int ) writtenBytes ; } } } @Override public CompositeByteBuf getBytes ( int index , OutputStream out , int length ) throws IOException { checkIndex ( index , length ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , out , localLength ) ; index + = localLength ; length - = localLength ; i + + ; } return this ; } @Override public CompositeByteBuf setByte ( int index , int value ) { Component c = findComponent ( index ) ; c . buf . setByte ( index - c . offset , value ) ; return this ; } @Override protected void _setByte ( int index , int value ) { setByte ( index , value ) ; } @Override public CompositeByteBuf setShort ( int index , int value ) { return ( CompositeByteBuf ) super . setShort ( index , value ) ; } @Override protected void _setShort ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setShort ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setByte ( index , ( byte ) ( value > > > <int> ) ) ; _setByte ( index + <int> , ( byte ) value ) ; } else { _setByte ( index , ( byte ) value ) ; _setByte ( index + <int> , ( byte ) ( value > > > <int> ) ) ; } } @Override protected void _setShortLE ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setShortLE ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setByte ( index , ( byte ) value ) ; _setByte ( index + <int> , ( byte ) ( value > > > <int> ) ) ; } else { _setByte ( index , ( byte ) ( value > > > <int> ) ) ; _setByte ( index + <int> , ( byte ) value ) ; } } @Override public CompositeByteBuf setMedium ( int index , int value ) { return ( CompositeByteBuf ) super . setMedium ( index , value ) ; } @Override protected void _setMedium ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setMedium ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setShort ( index , ( short ) ( value > > <int> ) ) ; _setByte ( index + <int> , ( byte ) value ) ; } else { _setShort ( index , ( short ) value ) ; _setByte ( index + <int> , ( byte ) ( value > > > <int> ) ) ; } } @Override protected void _setMediumLE ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setMediumLE ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setShortLE ( index , ( short ) value ) ; _setByte ( index + <int> , ( byte ) ( value > > > <int> ) ) ; } else { _setShortLE ( index , ( short ) ( value > > <int> ) ) ; _setByte ( index + <int> , ( byte ) value ) ; } } @Override public CompositeByteBuf setInt ( int index , int value ) { return ( CompositeByteBuf ) super . setInt ( index , value ) ; } @Override protected void _setInt ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setInt ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setShort ( index , ( short ) ( value > > > <int> ) ) ; _setShort ( index + <int> , ( short ) value ) ; } else { _setShort ( index , ( short ) value ) ; _setShort ( index + <int> , ( short ) ( value > > > <int> ) ) ; } } @Override protected void _setIntLE ( int index , int value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setIntLE ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setShortLE ( index , ( short ) value ) ; _setShortLE ( index + <int> , ( short ) ( value > > > <int> ) ) ; } else { _setShortLE ( index , ( short ) ( value > > > <int> ) ) ; _setShortLE ( index + <int> , ( short ) value ) ; } } @Override public CompositeByteBuf setLong ( int index , long value ) { return ( CompositeByteBuf ) super . setLong ( index , value ) ; } @Override protected void _setLong ( int index , long value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setLong ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setInt ( index , ( int ) ( value > > > <int> ) ) ; _setInt ( index + <int> , ( int ) value ) ; } else { _setInt ( index , ( int ) value ) ; _setInt ( index + <int> , ( int ) ( value > > > <int> ) ) ; } } @Override protected void _setLongLE ( int index , long value ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { c . buf . setLongLE ( index - c . offset , value ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { _setIntLE ( index , ( int ) value ) ; _setIntLE ( index + <int> , ( int ) ( value > > > <int> ) ) ; } else { _setIntLE ( index , ( int ) ( value > > > <int> ) ) ; _setIntLE ( index + <int> , ( int ) value ) ; } } @Override public CompositeByteBuf setBytes ( int index , byte [ ] src , int srcIndex , int length ) { checkSrcIndex ( index , length , srcIndex , src . length ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . setBytes ( index - adjustment , src , srcIndex , localLength ) ; index + = localLength ; srcIndex + = localLength ; length - = localLength ; i + + ; } return this ; } @Override public CompositeByteBuf setBytes ( int index , ByteBuffer src ) { int limit = src . limit ( ) ; int length = src . remaining ( ) ; checkIndex ( index , length ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; try { while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; src . limit ( src . position ( ) + localLength ) ; s . setBytes ( index - adjustment , src ) ; index + = localLength ; length - = localLength ; i + + ; } } finally { src . limit ( limit ) ; } return this ; } @Override public CompositeByteBuf setBytes ( int index , ByteBuf src , int srcIndex , int length ) { checkSrcIndex ( index , length , srcIndex , src . capacity ( ) ) ; if ( length = = <int> ) { return this ; } int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . setBytes ( index - adjustment , src , srcIndex , localLength ) ; index + = localLength ; srcIndex + = localLength ; length - = localLength ; i + + ; } return this ; } @Override public int setBytes ( int index , InputStream in , int length ) throws IOException { checkIndex ( index , length ) ; if ( length = = <int> ) { return in . read ( EmptyArrays . EMPTY_BYTES ) ; } int i = toComponentIndex ( index ) ; int readBytes = <int> ; do { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; int localReadBytes = s . setBytes ( index - adjustment , in , localLength ) ; if ( localReadBytes < <int> ) { if ( readBytes = = <int> ) { return - <int> ; } else { break ; } } if ( localReadBytes = = localLength ) { index + = localLength ; length - = localLength ; readBytes + = localLength ; i + + ; } else { index + = localReadBytes ; length - = localReadBytes ; readBytes + = localReadBytes ; } } while ( length > <int> ) ; return readBytes ; } @Override public int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException { checkIndex ( index , length ) ; if ( length = = <int> ) { return in . read ( EMPTY_NIO_BUFFER ) ; } int i = toComponentIndex ( index ) ; int readBytes = <int> ; do { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; int localReadBytes = s . setBytes ( index - adjustment , in , localLength ) ; if ( localReadBytes = = <int> ) { break ; } if ( localReadBytes < <int> ) { if ( readBytes = = <int> ) { return - <int> ; } else { break ; } } if ( localReadBytes = = localLength ) { index + = localLength ; length - = localLength ; readBytes + = localLength ; i + + ; } else { index + = localReadBytes ; length - = localReadBytes ; readBytes + = localReadBytes ; } } while ( length > <int> ) ; return readBytes ; } @Override public ByteBuf copy ( int index , int length ) { checkIndex ( index , length ) ; ByteBuf dst = Unpooled . buffer ( length ) ; if ( length ! = <int> ) { copyTo ( index , length , toComponentIndex ( index ) , dst ) ; } return dst ; } private void copyTo ( int index , int length , int componentId , ByteBuf dst ) { int dstIndex = <int> ; int i = componentId ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; index + = localLength ; dstIndex + = localLength ; length - = localLength ; i + + ; } dst . writerIndex ( dst . capacity ( ) ) ; } public ByteBuf component ( int cIndex ) { return internalComponent ( cIndex ) . duplicate ( ) ; } public ByteBuf componentAtOffset ( int offset ) { return internalComponentAtOffset ( offset ) . duplicate ( ) ; } public ByteBuf internalComponent ( int cIndex ) { checkComponentIndex ( cIndex ) ; return components . get ( cIndex ) . buf ; } public ByteBuf internalComponentAtOffset ( int offset ) { return findComponent ( offset ) . buf ; } private Component findComponent ( int offset ) { checkIndex ( offset ) ; for ( int low = <int> , high = components . size ( ) ; low < = high ; ) { int mid = low + high > > > <int> ; Component c = components . get ( mid ) ; if ( offset > = c . endOffset ) { low = mid + <int> ; } else if ( offset < c . offset ) { high = mid - <int> ; } else { assert c . length ! = <int> ; return c ; } } throw new Error ( <str> ) ; } @Override public int nioBufferCount ( ) { switch ( components . size ( ) ) { case <int> : return <int> ; case <int> : return components . get ( <int> ) . buf . nioBufferCount ( ) ; default : int count = <int> ; int componentsCount = components . size ( ) ; for ( int i = <int> ; i < componentsCount ; i + + ) { Component c = components . get ( i ) ; count + = c . buf . nioBufferCount ( ) ; } return count ; } } @Override public ByteBuffer internalNioBuffer ( int index , int length ) { switch ( components . size ( ) ) { case <int> : return EMPTY_NIO_BUFFER ; case <int> : return components . get ( <int> ) . buf . internalNioBuffer ( index , length ) ; default : throw new UnsupportedOperationException ( ) ; } } @Override public ByteBuffer nioBuffer ( int index , int length ) { checkIndex ( index , length ) ; switch ( components . size ( ) ) { case <int> : return EMPTY_NIO_BUFFER ; case <int> : ByteBuf buf = components . get ( <int> ) . buf ; if ( buf . nioBufferCount ( ) = = <int> ) { return components . get ( <int> ) . buf . nioBuffer ( index , length ) ; } } ByteBuffer merged = ByteBuffer . allocate ( length ) . order ( order ( ) ) ; ByteBuffer [ ] buffers = nioBuffers ( index , length ) ; for ( ByteBuffer buf : buffers ) { merged . put ( buf ) ; } merged . flip ( ) ; return merged ; } @Override public ByteBuffer [ ] nioBuffers ( int index , int length ) { checkIndex ( index , length ) ; if ( length = = <int> ) { return new ByteBuffer [ ] { EMPTY_NIO_BUFFER } ; } List < ByteBuffer > buffers = new ArrayList < ByteBuffer > ( components . size ( ) ) ; int i = toComponentIndex ( index ) ; while ( length > <int> ) { Component c = components . get ( i ) ; ByteBuf s = c . buf ; int adjustment = c . offset ; int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; switch ( s . nioBufferCount ( ) ) { case <int> : throw new UnsupportedOperationException ( ) ; case <int> : buffers . add ( s . nioBuffer ( index - adjustment , localLength ) ) ; break ; default : Collections . addAll ( buffers , s . nioBuffers ( index - adjustment , localLength ) ) ; } index + = localLength ; length - = localLength ; i + + ; } return buffers . toArray ( new ByteBuffer [ buffers . size ( ) ] ) ; } public CompositeByteBuf consolidate ( ) { ensureAccessible ( ) ; final int numComponents = numComponents ( ) ; if ( numComponents < = <int> ) { return this ; } final Component last = components . get ( numComponents - <int> ) ; final int capacity = last . endOffset ; final ByteBuf consolidated = allocBuffer ( capacity ) ; for ( int i = <int> ; i < numComponents ; i + + ) { Component c = components . get ( i ) ; ByteBuf b = c . buf ; consolidated . writeBytes ( b ) ; c . freeIfNecessary ( ) ; } components . clear ( ) ; components . add ( new Component ( consolidated ) ) ; updateComponentOffsets ( <int> ) ; return this ; } public CompositeByteBuf consolidate ( int cIndex , int numComponents ) { checkComponentIndex ( cIndex , numComponents ) ; if ( numComponents < = <int> ) { return this ; } final int endCIndex = cIndex + numComponents ; final Component last = components . get ( endCIndex - <int> ) ; final int capacity = last . endOffset - components . get ( cIndex ) . offset ; final ByteBuf consolidated = allocBuffer ( capacity ) ; for ( int i = cIndex ; i < endCIndex ; i + + ) { Component c = components . get ( i ) ; ByteBuf b = c . buf ; consolidated . writeBytes ( b ) ; c . freeIfNecessary ( ) ; } components . subList ( cIndex + <int> , endCIndex ) . clear ( ) ; components . set ( cIndex , new Component ( consolidated ) ) ; updateComponentOffsets ( cIndex ) ; return this ; } public CompositeByteBuf discardReadComponents ( ) { ensureAccessible ( ) ; final int readerIndex = readerIndex ( ) ; if ( readerIndex = = <int> ) { return this ; } int writerIndex = writerIndex ( ) ; if ( readerIndex = = writerIndex & & writerIndex = = capacity ( ) ) { for ( Component c : components ) { c . freeIfNecessary ( ) ; } components . clear ( ) ; setIndex ( <int> , <int> ) ; adjustMarkers ( readerIndex ) ; return this ; } int firstComponentId = toComponentIndex ( readerIndex ) ; for ( int i = <int> ; i < firstComponentId ; i + + ) { components . get ( i ) . freeIfNecessary ( ) ; } components . subList ( <int> , firstComponentId ) . clear ( ) ; Component first = components . get ( <int> ) ; int offset = first . offset ; updateComponentOffsets ( <int> ) ; setIndex ( readerIndex - offset , writerIndex - offset ) ; adjustMarkers ( offset ) ; return this ; } @Override public CompositeByteBuf discardReadBytes ( ) { ensureAccessible ( ) ; final int readerIndex = readerIndex ( ) ; if ( readerIndex = = <int> ) { return this ; } int writerIndex = writerIndex ( ) ; if ( readerIndex = = writerIndex & & writerIndex = = capacity ( ) ) { for ( Component c : components ) { c . freeIfNecessary ( ) ; } components . clear ( ) ; setIndex ( <int> , <int> ) ; adjustMarkers ( readerIndex ) ; return this ; } int firstComponentId = toComponentIndex ( readerIndex ) ; for ( int i = <int> ; i < firstComponentId ; i + + ) { components . get ( i ) . freeIfNecessary ( ) ; } components . subList ( <int> , firstComponentId ) . clear ( ) ; Component c = components . get ( <int> ) ; int adjustment = readerIndex - c . offset ; if ( adjustment = = c . length ) { components . remove ( <int> ) ; } else { Component newC = new Component ( c . buf . slice ( adjustment , c . length - adjustment ) ) ; components . set ( <int> , newC ) ; } updateComponentOffsets ( <int> ) ; setIndex ( <int> , writerIndex - readerIndex ) ; adjustMarkers ( readerIndex ) ; return this ; } private ByteBuf allocBuffer ( int capacity ) { if ( direct ) { return alloc ( ) . directBuffer ( capacity ) ; } return alloc ( ) . heapBuffer ( capacity ) ; } @Override public String toString ( ) { String result = super . toString ( ) ; result = result . substring ( <int> , result . length ( ) - <int> ) ; return result + <str> + components . size ( ) + <str> ; } private static final class Component { final ByteBuf buf ; final int length ; int offset ; int endOffset ; Component ( ByteBuf buf ) { this . buf = buf ; length = buf . readableBytes ( ) ; } void freeIfNecessary ( ) { buf . release ( ) ; } } @Override public CompositeByteBuf readerIndex ( int readerIndex ) { return ( CompositeByteBuf ) super . readerIndex ( readerIndex ) ; } @Override public CompositeByteBuf writerIndex ( int writerIndex ) { return ( CompositeByteBuf ) super . writerIndex ( writerIndex ) ; } @Override public CompositeByteBuf setIndex ( int readerIndex , int writerIndex ) { return ( CompositeByteBuf ) super . setIndex ( readerIndex , writerIndex ) ; } @Override public CompositeByteBuf clear ( ) { return ( CompositeByteBuf ) super . clear ( ) ; } @Override public CompositeByteBuf markReaderIndex ( ) { return ( CompositeByteBuf ) super . markReaderIndex ( ) ; } @Override public CompositeByteBuf resetReaderIndex ( ) { return ( CompositeByteBuf ) super . resetReaderIndex ( ) ; } @Override public CompositeByteBuf markWriterIndex ( ) { return ( CompositeByteBuf ) super . markWriterIndex ( ) ; } @Override public CompositeByteBuf resetWriterIndex ( ) { return ( CompositeByteBuf ) super . resetWriterIndex ( ) ; } @Override public CompositeByteBuf ensureWritable ( int minWritableBytes ) { return ( CompositeByteBuf ) super . ensureWritable ( minWritableBytes ) ; } @Override public CompositeByteBuf getBytes ( int index , ByteBuf dst ) { return ( CompositeByteBuf ) super . getBytes ( index , dst ) ; } @Override public CompositeByteBuf getBytes ( int index , ByteBuf dst , int length ) { return ( CompositeByteBuf ) super . getBytes ( index , dst , length ) ; } @Override public CompositeByteBuf getBytes ( int index , byte [ ] dst ) { return ( CompositeByteBuf ) super . getBytes ( index , dst ) ; } @Override public CompositeByteBuf setBoolean ( int index , boolean value ) { return ( CompositeByteBuf ) super . setBoolean ( index , value ) ; } @Override public CompositeByteBuf setChar ( int index , int value ) { return ( CompositeByteBuf ) super . setChar ( index , value ) ; } @Override public CompositeByteBuf setFloat ( int index , float value ) { return ( CompositeByteBuf ) super . setFloat ( index , value ) ; } @Override public CompositeByteBuf setDouble ( int index , double value ) { return ( CompositeByteBuf ) super . setDouble ( index , value ) ; } @Override public CompositeByteBuf setBytes ( int index , ByteBuf src ) { return ( CompositeByteBuf ) super . setBytes ( index , src ) ; } @Override public CompositeByteBuf setBytes ( int index , ByteBuf src , int length ) { return ( CompositeByteBuf ) super . setBytes ( index , src , length ) ; } @Override public CompositeByteBuf setBytes ( int index , byte [ ] src ) { return ( CompositeByteBuf ) super . setBytes ( index , src ) ; } @Override public CompositeByteBuf setZero ( int index , int length ) { return ( CompositeByteBuf ) super . setZero ( index , length ) ; } @Override public CompositeByteBuf readBytes ( ByteBuf dst ) { return ( CompositeByteBuf ) super . readBytes ( dst ) ; } @Override public CompositeByteBuf readBytes ( ByteBuf dst , int length ) { return ( CompositeByteBuf ) super . readBytes ( dst , length ) ; } @Override public CompositeByteBuf readBytes ( ByteBuf dst , int dstIndex , int length ) { return ( CompositeByteBuf ) super . readBytes ( dst , dstIndex , length ) ; } @Override public CompositeByteBuf readBytes ( byte [ ] dst ) { return ( CompositeByteBuf ) super . readBytes ( dst ) ; } @Override public CompositeByteBuf readBytes ( byte [ ] dst , int dstIndex , int length ) { return ( CompositeByteBuf ) super . readBytes ( dst , dstIndex , length ) ; } @Override public CompositeByteBuf readBytes ( ByteBuffer dst ) { return ( CompositeByteBuf ) super . readBytes ( dst ) ; } @Override public CompositeByteBuf readBytes ( OutputStream out , int length ) throws IOException { return ( CompositeByteBuf ) super . readBytes ( out , length ) ; } @Override public CompositeByteBuf skipBytes ( int length ) { return ( CompositeByteBuf ) super . skipBytes ( length ) ; } @Override public CompositeByteBuf writeBoolean ( boolean value ) { return ( CompositeByteBuf ) super . writeBoolean ( value ) ; } @Override public CompositeByteBuf writeByte ( int value ) { return ( CompositeByteBuf ) super . writeByte ( value ) ; } @Override public CompositeByteBuf writeShort ( int value ) { return ( CompositeByteBuf ) super . writeShort ( value ) ; } @Override public CompositeByteBuf writeMedium ( int value ) { return ( CompositeByteBuf ) super . writeMedium ( value ) ; } @Override public CompositeByteBuf writeInt ( int value ) { return ( CompositeByteBuf ) super . writeInt ( value ) ; } @Override public CompositeByteBuf writeLong ( long value ) { return ( CompositeByteBuf ) super . writeLong ( value ) ; } @Override public CompositeByteBuf writeChar ( int value ) { return ( CompositeByteBuf ) super . writeChar ( value ) ; } @Override public CompositeByteBuf writeFloat ( float value ) { return ( CompositeByteBuf ) super . writeFloat ( value ) ; } @Override public CompositeByteBuf writeDouble ( double value ) { return ( CompositeByteBuf ) super . writeDouble ( value ) ; } @Override public CompositeByteBuf writeBytes ( ByteBuf src ) { return ( CompositeByteBuf ) super . writeBytes ( src ) ; } @Override public CompositeByteBuf writeBytes ( ByteBuf src , int length ) { return ( CompositeByteBuf ) super . writeBytes ( src , length ) ; } @Override public CompositeByteBuf writeBytes ( ByteBuf src , int srcIndex , int length ) { return ( CompositeByteBuf ) super . writeBytes ( src , srcIndex , length ) ; } @Override public CompositeByteBuf writeBytes ( byte [ ] src ) { return ( CompositeByteBuf ) super . writeBytes ( src ) ; } @Override public CompositeByteBuf writeBytes ( byte [ ] src , int srcIndex , int length ) { return ( CompositeByteBuf ) super . writeBytes ( src , srcIndex , length ) ; } @Override public CompositeByteBuf writeBytes ( ByteBuffer src ) { return ( CompositeByteBuf ) super . writeBytes ( src ) ; } @Override public CompositeByteBuf writeZero ( int length ) { return ( CompositeByteBuf ) super . writeZero ( length ) ; } @Override public CompositeByteBuf retain ( int increment ) { return ( CompositeByteBuf ) super . retain ( increment ) ; } @Override public CompositeByteBuf retain ( ) { return ( CompositeByteBuf ) super . retain ( ) ; } @Override public CompositeByteBuf touch ( ) { if ( leak ! = null ) { leak . record ( ) ; } return this ; } @Override public CompositeByteBuf touch ( Object hint ) { if ( leak ! = null ) { leak . record ( hint ) ; } return this ; } @Override public ByteBuffer [ ] nioBuffers ( ) { return nioBuffers ( readerIndex ( ) , readableBytes ( ) ) ; } @Override public CompositeByteBuf discardSomeReadBytes ( ) { return discardReadComponents ( ) ; } @Override protected void deallocate ( ) { if ( freed ) { return ; } freed = true ; int size = components . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { components . get ( i ) . freeIfNecessary ( ) ; } if ( leak ! = null ) { leak . close ( ) ; } } @Override public ByteBuf unwrap ( ) { return null ; } private final class CompositeByteBufIterator implements Iterator < ByteBuf > { private final int size = components . size ( ) ; private int index ; @Override public boolean hasNext ( ) { return size > index ; } @Override public ByteBuf next ( ) { if ( size ! = components . size ( ) ) { throw new ConcurrentModificationException ( ) ; } if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } try { return components . get ( index + + ) . buf ; } catch ( IndexOutOfBoundsException e ) { throw new ConcurrentModificationException ( ) ; } } @Override public void remove ( ) { throw new UnsupportedOperationException ( <str> ) ; } } } 
