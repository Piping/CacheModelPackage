package org . elasticsearch . messy . tests ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . elasticsearch . action . Action ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionModule ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestBuilder ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . admin . indices . refresh . RefreshRequest ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . indexedscripts . put . PutIndexedScriptRequest ; import org . elasticsearch . action . indexedscripts . put . PutIndexedScriptResponse ; import org . elasticsearch . action . percolate . PercolateResponse ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . action . termvectors . MultiTermVectorsRequest ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . FilterClient ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . http . HttpServerTransport ; import org . elasticsearch . index . query . BoolQueryBuilder ; import org . elasticsearch . index . query . GeoShapeQueryBuilder ; import org . elasticsearch . index . query . MoreLikeThisQueryBuilder ; import org . elasticsearch . index . query . MoreLikeThisQueryBuilder . Item ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . TermsQueryBuilder ; import org . elasticsearch . index . query . functionscore . script . ScriptScoreFunctionBuilder ; import org . elasticsearch . indices . cache . query . terms . TermsLookup ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . script . groovy . GroovyPlugin ; import org . elasticsearch . script . groovy . GroovyScriptEngineService ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . rest . client . http . HttpRequestBuilder ; import org . elasticsearch . test . rest . client . http . HttpResponse ; import org . junit . After ; import org . junit . Before ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . CopyOnWriteArrayList ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . node . Node . HTTP_ENABLED ; import static org . elasticsearch . rest . RestStatus . OK ; import static org . elasticsearch . search . suggest . SuggestBuilders . phraseSuggestion ; import static org . elasticsearch . test . ESIntegTestCase . Scope . SUITE ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSuggestionSize ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . hasStatus ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; @ClusterScope ( scope = SUITE ) public class ContextAndHeaderTransportTests extends ESIntegTestCase { private static final List < ActionRequest > requests = new CopyOnWriteArrayList < > ( ) ; private String randomHeaderKey = randomAsciiOfLength ( <int> ) ; private String randomHeaderValue = randomAsciiOfLength ( <int> ) ; private String queryIndex = <str> + randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . ROOT ) ; private String lookupIndex = <str> + randomAsciiOfLength ( <int> ) . toLowerCase ( Locale . ROOT ) ; @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , <str> ) . put ( HTTP_ENABLED , true ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( ActionLoggingPlugin . class , GroovyPlugin . class ) ; } @Before public void createIndices ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . build ( ) ; assertAcked ( transportClient ( ) . admin ( ) . indices ( ) . prepareCreate ( lookupIndex ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ) ; assertAcked ( transportClient ( ) . admin ( ) . indices ( ) . prepareCreate ( queryIndex ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ) ; ensureGreen ( queryIndex , lookupIndex ) ; requests . clear ( ) ; } @After public void checkAllRequestsContainHeaders ( ) { assertRequestsContainHeader ( IndexRequest . class ) ; assertRequestsContainHeader ( RefreshRequest . class ) ; } public void testThatTermsLookupGetRequestContainsContextAndHeaders ( ) throws Exception { transportClient ( ) . prepareIndex ( lookupIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . array ( <str> , <str> , <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( queryIndex , lookupIndex ) . get ( ) ; TermsQueryBuilder termsLookupFilterBuilder = QueryBuilders . termsLookupQuery ( <str> , new TermsLookup ( lookupIndex , <str> , <str> , <str> ) ) ; BoolQueryBuilder queryBuilder = QueryBuilders . boolQuery ( ) . must ( QueryBuilders . matchAllQuery ( ) ) . must ( termsLookupFilterBuilder ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setQuery ( queryBuilder ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertGetRequestsContainHeaders ( ) ; } public void testThatGeoShapeQueryGetRequestContainsContextAndHeaders ( ) throws Exception { transportClient ( ) . prepareIndex ( lookupIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( lookupIndex , queryIndex ) . get ( ) ; GeoShapeQueryBuilder queryBuilder = QueryBuilders . geoShapeQuery ( <str> , <str> , <str> ) . indexedShapeIndex ( lookupIndex ) . indexedShapePath ( <str> ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setQuery ( queryBuilder ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertThat ( requests , hasSize ( greaterThan ( <int> ) ) ) ; assertGetRequestsContainHeaders ( ) ; } public void testThatMoreLikeThisQueryMultiTermVectorRequestContainsContextAndHeaders ( ) throws Exception { transportClient ( ) . prepareIndex ( lookupIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( lookupIndex , queryIndex ) . get ( ) ; MoreLikeThisQueryBuilder moreLikeThisQueryBuilder = QueryBuilders . moreLikeThisQuery ( new String [ ] { <str> } , null , new Item [ ] { new Item ( lookupIndex , <str> , <str> ) } ) . minTermFreq ( <int> ) . minDocFreq ( <int> ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setQuery ( moreLikeThisQueryBuilder ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertRequestsContainHeader ( MultiTermVectorsRequest . class ) ; } public void testThatPercolatingExistingDocumentGetRequestContainsContextAndHeaders ( ) throws Exception { transportClient ( ) . prepareIndex ( lookupIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ) . get ( ) ; transportClient ( ) . prepareIndex ( lookupIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( lookupIndex ) . get ( ) ; GetRequest getRequest = transportClient ( ) . prepareGet ( lookupIndex , <str> , <str> ) . request ( ) ; PercolateResponse response = transportClient ( ) . preparePercolate ( ) . setDocumentType ( <str> ) . setGetRequest ( getRequest ) . get ( ) ; assertThat ( response . getCount ( ) , is ( <int> ) ) ; assertGetRequestsContainHeaders ( ) ; } public void testThatIndexedScriptGetRequestContainsContextAndHeaders ( ) throws Exception { PutIndexedScriptResponse scriptResponse = transportClient ( ) . preparePutIndexedScript ( GroovyScriptEngineService . NAME , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . string ( ) ) . get ( ) ; assertThat ( scriptResponse . isCreated ( ) , is ( true ) ) ; transportClient ( ) . prepareIndex ( queryIndex , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; transportClient ( ) . admin ( ) . indices ( ) . prepareRefresh ( queryIndex ) . get ( ) ; SearchResponse searchResponse = transportClient ( ) . prepareSearch ( queryIndex ) . setQuery ( QueryBuilders . functionScoreQuery ( new ScriptScoreFunctionBuilder ( new Script ( <str> , ScriptType . INDEXED , <str> , null ) ) ) . boostMode ( CombineFunction . REPLACE ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertHitCount ( searchResponse , <int> ) ; assertThat ( searchResponse . getHits ( ) . getMaxScore ( ) , is ( <float> ) ) ; assertGetRequestsContainHeaders ( <str> ) ; assertRequestsContainHeader ( PutIndexedScriptRequest . class ) ; } public void testThatRelevantHttpHeadersBecomeRequestHeaders ( ) throws Exception { String releventHeaderName = <str> + randomHeaderKey ; for ( RestController restController : internalCluster ( ) . getDataNodeInstances ( RestController . class ) ) { restController . registerRelevantHeaders ( releventHeaderName ) ; } CloseableHttpClient httpClient = HttpClients . createDefault ( ) ; HttpResponse response = new HttpRequestBuilder ( httpClient ) . httpTransport ( internalCluster ( ) . getDataNodeInstance ( HttpServerTransport . class ) ) . addHeader ( randomHeaderKey , randomHeaderValue ) . addHeader ( releventHeaderName , randomHeaderValue ) . path ( <str> + queryIndex + <str> ) . execute ( ) ; assertThat ( response , hasStatus ( OK ) ) ; List < SearchRequest > searchRequests = getRequests ( SearchRequest . class ) ; assertThat ( searchRequests , hasSize ( greaterThan ( <int> ) ) ) ; for ( SearchRequest searchRequest : searchRequests ) { assertThat ( searchRequest . hasHeader ( releventHeaderName ) , is ( true ) ) ; assertThat ( searchRequest . hasHeader ( randomHeaderKey ) , is ( false ) ) ; } } private < T > List < T > getRequests ( Class < T > clazz ) { List < T > results = new ArrayList < > ( ) ; for ( ActionRequest request : requests ) { if ( request . getClass ( ) . equals ( clazz ) ) { results . add ( ( T ) request ) ; } } return results ; } private void assertRequestsContainHeader ( Class < ? extends ActionRequest > clazz ) { List < ? extends ActionRequest > classRequests = getRequests ( clazz ) ; for ( ActionRequest request : classRequests ) { assertRequestContainsHeader ( request ) ; } } private void assertGetRequestsContainHeaders ( ) { assertGetRequestsContainHeaders ( this . lookupIndex ) ; } private void assertGetRequestsContainHeaders ( String index ) { List < GetRequest > getRequests = getRequests ( GetRequest . class ) ; assertThat ( getRequests , hasSize ( greaterThan ( <int> ) ) ) ; for ( GetRequest request : getRequests ) { if ( ! request . index ( ) . equals ( index ) ) { continue ; } assertRequestContainsHeader ( request ) ; } } private void assertRequestContainsHeader ( ActionRequest request ) { String msg = String . format ( Locale . ROOT , <str> , randomHeaderKey , request . getClass ( ) . getName ( ) ) ; if ( request instanceof IndexRequest ) { IndexRequest indexRequest = ( IndexRequest ) request ; msg = String . format ( Locale . ROOT , <str> , randomHeaderKey , indexRequest . index ( ) , indexRequest . type ( ) , indexRequest . id ( ) ) ; } assertThat ( msg , request . hasHeader ( randomHeaderKey ) , is ( true ) ) ; assertThat ( request . getHeader ( randomHeaderKey ) . toString ( ) , is ( randomHeaderValue ) ) ; } private Client transportClient ( ) { Client transportClient = internalCluster ( ) . transportClient ( ) ; FilterClient filterClient = new FilterClient ( transportClient ) { @Override protected < Request extends ActionRequest , Response extends ActionResponse , RequestBuilder extends ActionRequestBuilder < Request , Response , RequestBuilder > > void doExecute ( Action < Request , Response , RequestBuilder > action , Request request , ActionListener < Response > listener ) { request . putHeader ( randomHeaderKey , randomHeaderValue ) ; super . doExecute ( action , request , listener ) ; } } ; return filterClient ; } public static class ActionLoggingPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } @Override public Collection < Module > nodeModules ( ) { return Collections . < Module > singletonList ( new ActionLoggingModule ( ) ) ; } public void onModule ( ActionModule module ) { module . registerFilter ( LoggingFilter . class ) ; } } public static class ActionLoggingModule extends AbstractModule { @Override protected void configure ( ) { bind ( LoggingFilter . class ) . asEagerSingleton ( ) ; } } public static class LoggingFilter extends ActionFilter . Simple { @Inject public LoggingFilter ( Settings settings ) { super ( settings ) ; } @Override public int order ( ) { return <int> ; } @Override protected boolean apply ( String action , ActionRequest request , ActionListener listener ) { requests . add ( request ) ; return true ; } @Override protected boolean apply ( String action , ActionResponse response , ActionListener listener ) { return true ; } } } 
