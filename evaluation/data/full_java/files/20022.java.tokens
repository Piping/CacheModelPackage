package io . netty . handler . traffic ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPromise ; import io . netty . util . Attribute ; import io . netty . util . AttributeKey ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . concurrent . TimeUnit ; public abstract class AbstractTrafficShapingHandler extends ChannelDuplexHandler { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractTrafficShapingHandler . class ) ; public static final long DEFAULT_CHECK_INTERVAL = <int> ; public static final long DEFAULT_MAX_TIME = <int> ; static final long DEFAULT_MAX_SIZE = <int> * <int> * <int> ; static final long MINIMAL_WAIT = <int> ; protected TrafficCounter trafficCounter ; private volatile long writeLimit ; private volatile long readLimit ; protected volatile long maxTime = DEFAULT_MAX_TIME ; protected volatile long checkInterval = DEFAULT_CHECK_INTERVAL ; static final AttributeKey < Boolean > READ_SUSPENDED = AttributeKey . valueOf ( AbstractTrafficShapingHandler . class . getName ( ) + <str> ) ; static final AttributeKey < Runnable > REOPEN_TASK = AttributeKey . valueOf ( AbstractTrafficShapingHandler . class . getName ( ) + <str> ) ; volatile long maxWriteDelay = <int> * DEFAULT_CHECK_INTERVAL ; volatile long maxWriteSize = DEFAULT_MAX_SIZE ; final int userDefinedWritabilityIndex ; static final int CHANNEL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX = <int> ; static final int GLOBAL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX = <int> ; static final int GLOBALCHANNEL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX = <int> ; void setTrafficCounter ( TrafficCounter newTrafficCounter ) { trafficCounter = newTrafficCounter ; } int userDefinedWritabilityIndex ( ) { if ( this instanceof GlobalChannelTrafficShapingHandler ) { return GLOBALCHANNEL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX ; } else if ( this instanceof GlobalTrafficShapingHandler ) { return GLOBAL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX ; } else { return CHANNEL_DEFAULT_USER_DEFINED_WRITABILITY_INDEX ; } } protected AbstractTrafficShapingHandler ( long writeLimit , long readLimit , long checkInterval , long maxTime ) { if ( maxTime < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } userDefinedWritabilityIndex = userDefinedWritabilityIndex ( ) ; this . writeLimit = writeLimit ; this . readLimit = readLimit ; this . checkInterval = checkInterval ; this . maxTime = maxTime ; } protected AbstractTrafficShapingHandler ( long writeLimit , long readLimit , long checkInterval ) { this ( writeLimit , readLimit , checkInterval , DEFAULT_MAX_TIME ) ; } protected AbstractTrafficShapingHandler ( long writeLimit , long readLimit ) { this ( writeLimit , readLimit , DEFAULT_CHECK_INTERVAL , DEFAULT_MAX_TIME ) ; } protected AbstractTrafficShapingHandler ( ) { this ( <int> , <int> , DEFAULT_CHECK_INTERVAL , DEFAULT_MAX_TIME ) ; } protected AbstractTrafficShapingHandler ( long checkInterval ) { this ( <int> , <int> , checkInterval , DEFAULT_MAX_TIME ) ; } public void configure ( long newWriteLimit , long newReadLimit , long newCheckInterval ) { configure ( newWriteLimit , newReadLimit ) ; configure ( newCheckInterval ) ; } public void configure ( long newWriteLimit , long newReadLimit ) { writeLimit = newWriteLimit ; readLimit = newReadLimit ; if ( trafficCounter ! = null ) { trafficCounter . resetAccounting ( TrafficCounter . milliSecondFromNano ( ) ) ; } } public void configure ( long newCheckInterval ) { checkInterval = newCheckInterval ; if ( trafficCounter ! = null ) { trafficCounter . configure ( checkInterval ) ; } } public long getWriteLimit ( ) { return writeLimit ; } public void setWriteLimit ( long writeLimit ) { this . writeLimit = writeLimit ; if ( trafficCounter ! = null ) { trafficCounter . resetAccounting ( TrafficCounter . milliSecondFromNano ( ) ) ; } } public long getReadLimit ( ) { return readLimit ; } public void setReadLimit ( long readLimit ) { this . readLimit = readLimit ; if ( trafficCounter ! = null ) { trafficCounter . resetAccounting ( TrafficCounter . milliSecondFromNano ( ) ) ; } } public long getCheckInterval ( ) { return checkInterval ; } public void setCheckInterval ( long checkInterval ) { this . checkInterval = checkInterval ; if ( trafficCounter ! = null ) { trafficCounter . configure ( checkInterval ) ; } } public void setMaxTimeWait ( long maxTime ) { if ( maxTime < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxTime = maxTime ; } public long getMaxTimeWait ( ) { return maxTime ; } public long getMaxWriteDelay ( ) { return maxWriteDelay ; } public void setMaxWriteDelay ( long maxWriteDelay ) { if ( maxWriteDelay < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxWriteDelay = maxWriteDelay ; } public long getMaxWriteSize ( ) { return maxWriteSize ; } public void setMaxWriteSize ( long maxWriteSize ) { this . maxWriteSize = maxWriteSize ; } protected void doAccounting ( TrafficCounter counter ) { } static final class ReopenReadTimerTask implements Runnable { final ChannelHandlerContext ctx ; ReopenReadTimerTask ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @Override public void run ( ) { ChannelConfig config = ctx . channel ( ) . config ( ) ; if ( ! config . isAutoRead ( ) & & isHandlerActive ( ctx ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } ctx . attr ( READ_SUSPENDED ) . set ( false ) ; } else { if ( logger . isDebugEnabled ( ) ) { if ( config . isAutoRead ( ) & & ! isHandlerActive ( ctx ) ) { logger . debug ( <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } else { logger . debug ( <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } } ctx . attr ( READ_SUSPENDED ) . set ( false ) ; config . setAutoRead ( true ) ; ctx . channel ( ) . read ( ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } } } void releaseReadSuspended ( ChannelHandlerContext ctx ) { ctx . attr ( READ_SUSPENDED ) . set ( false ) ; ctx . channel ( ) . config ( ) . setAutoRead ( true ) ; } @Override public void channelRead ( final ChannelHandlerContext ctx , final Object msg ) throws Exception { long size = calculateSize ( msg ) ; long now = TrafficCounter . milliSecondFromNano ( ) ; if ( size > <int> ) { long wait = trafficCounter . readTimeToWait ( size , readLimit , maxTime , now ) ; wait = checkWaitReadTime ( ctx , wait , now ) ; if ( wait > = MINIMAL_WAIT ) { ChannelConfig config = ctx . channel ( ) . config ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + wait + <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } if ( config . isAutoRead ( ) & & isHandlerActive ( ctx ) ) { config . setAutoRead ( false ) ; ctx . attr ( READ_SUSPENDED ) . set ( true ) ; Attribute < Runnable > attr = ctx . attr ( REOPEN_TASK ) ; Runnable reopenTask = attr . get ( ) ; if ( reopenTask = = null ) { reopenTask = new ReopenReadTimerTask ( ctx ) ; attr . set ( reopenTask ) ; } ctx . executor ( ) . schedule ( reopenTask , wait , TimeUnit . MILLISECONDS ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + config . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) + <str> + wait ) ; } } } } informReadOperation ( ctx , now ) ; ctx . fireChannelRead ( msg ) ; } long checkWaitReadTime ( final ChannelHandlerContext ctx , long wait , final long now ) { return wait ; } void informReadOperation ( final ChannelHandlerContext ctx , final long now ) { } protected static boolean isHandlerActive ( ChannelHandlerContext ctx ) { Boolean suspended = ctx . attr ( READ_SUSPENDED ) . get ( ) ; return suspended = = null | | Boolean . FALSE . equals ( suspended ) ; } @Override public void read ( ChannelHandlerContext ctx ) { if ( isHandlerActive ( ctx ) ) { ctx . read ( ) ; } } @Override public void write ( final ChannelHandlerContext ctx , final Object msg , final ChannelPromise promise ) throws Exception { long size = calculateSize ( msg ) ; long now = TrafficCounter . milliSecondFromNano ( ) ; if ( size > <int> ) { long wait = trafficCounter . writeTimeToWait ( size , writeLimit , maxTime , now ) ; if ( wait > = MINIMAL_WAIT ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + wait + <str> + ctx . channel ( ) . config ( ) . isAutoRead ( ) + <str> + isHandlerActive ( ctx ) ) ; } submitWrite ( ctx , msg , size , wait , now , promise ) ; return ; } } submitWrite ( ctx , msg , size , <int> , now , promise ) ; } @Deprecated protected void submitWrite ( final ChannelHandlerContext ctx , final Object msg , final long delay , final ChannelPromise promise ) { submitWrite ( ctx , msg , calculateSize ( msg ) , delay , TrafficCounter . milliSecondFromNano ( ) , promise ) ; } abstract void submitWrite ( ChannelHandlerContext ctx , Object msg , long size , long delay , long now , ChannelPromise promise ) ; @Override public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { setUserDefinedWritability ( ctx , true ) ; super . channelRegistered ( ctx ) ; } void setUserDefinedWritability ( ChannelHandlerContext ctx , boolean writable ) { ChannelOutboundBuffer cob = ctx . channel ( ) . unsafe ( ) . outboundBuffer ( ) ; if ( cob ! = null ) { cob . setUserDefinedWritability ( userDefinedWritabilityIndex , writable ) ; } } void checkWriteSuspend ( ChannelHandlerContext ctx , long delay , long queueSize ) { if ( queueSize > maxWriteSize | | delay > maxWriteDelay ) { setUserDefinedWritability ( ctx , false ) ; } } void releaseWriteSuspended ( ChannelHandlerContext ctx ) { setUserDefinedWritability ( ctx , true ) ; } public TrafficCounter trafficCounter ( ) { return trafficCounter ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( <int> ) . append ( <str> ) . append ( writeLimit ) . append ( <str> ) . append ( readLimit ) . append ( <str> ) . append ( checkInterval ) . append ( <str> ) . append ( maxWriteDelay ) . append ( <str> ) . append ( maxWriteSize ) . append ( <str> ) ; if ( trafficCounter ! = null ) { builder . append ( trafficCounter ) ; } else { builder . append ( <str> ) ; } return builder . toString ( ) ; } protected long calculateSize ( Object msg ) { if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . readableBytes ( ) ; } if ( msg instanceof ByteBufHolder ) { return ( ( ByteBufHolder ) msg ) . content ( ) . readableBytes ( ) ; } return - <int> ; } } 
