package io . netty . handler . codec . http2 ; import java . util . Arrays ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . max ; import static java . lang . Math . min ; public final class PriorityStreamByteDistributor implements StreamByteDistributor { private final Http2Connection connection ; private final Http2Connection . PropertyKey stateKey ; private final WriteVisitor writeVisitor = new WriteVisitor ( ) ; public PriorityStreamByteDistributor ( Http2Connection connection ) { this . connection = checkNotNull ( connection , <str> ) ; stateKey = connection . newKey ( ) ; connection . connectionStream ( ) . setProperty ( stateKey , new PriorityState ( connection . connectionStream ( ) ) ) ; connection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamAdded ( Http2Stream stream ) { stream . setProperty ( stateKey , new PriorityState ( stream ) ) ; } @Override public void onStreamClosed ( Http2Stream stream ) { state ( stream ) . close ( ) ; } @Override public void onPriorityTreeParentChanged ( Http2Stream stream , Http2Stream oldParent ) { Http2Stream parent = stream . parent ( ) ; if ( parent ! = null ) { long delta = state ( stream ) . unallocatedStreamableBytesForTree ( ) ; if ( delta ! = <int> ) { state ( parent ) . unallocatedStreamableBytesForTreeChanged ( delta ) ; } } } @Override public void onPriorityTreeParentChanging ( Http2Stream stream , Http2Stream newParent ) { Http2Stream parent = stream . parent ( ) ; if ( parent ! = null ) { long delta = state ( stream ) . unallocatedStreamableBytesForTree ( ) ; if ( delta ! = <int> ) { state ( parent ) . unallocatedStreamableBytesForTreeChanged ( - delta ) ; } } } } ) ; } @Override public void updateStreamableBytes ( StreamState streamState ) { state ( streamState . stream ( ) ) . updateStreamableBytes ( streamState . streamableBytes ( ) , streamState . hasFrame ( ) ) ; } @Override public boolean distribute ( int maxBytes , Writer writer ) throws Http2Exception { checkNotNull ( writer , <str> ) ; if ( maxBytes > <int> ) { allocateBytesForTree ( connection . connectionStream ( ) , maxBytes ) ; } writeVisitor . writeAllocatedBytes ( writer ) ; return state ( connection . connectionStream ( ) ) . unallocatedStreamableBytesForTree ( ) > <int> ; } int unallocatedStreamableBytes ( Http2Stream stream ) { return state ( stream ) . unallocatedStreamableBytes ( ) ; } long unallocatedStreamableBytesForTree ( Http2Stream stream ) { return state ( stream ) . unallocatedStreamableBytesForTree ( ) ; } private int allocateBytesForTree ( Http2Stream parent , int connectionWindowSize ) { PriorityState state = state ( parent ) ; if ( state . unallocatedStreamableBytesForTree ( ) < = <int> ) { return <int> ; } if ( state . unallocatedStreamableBytesForTree ( ) < = connectionWindowSize ) { SimpleChildFeeder childFeeder = new SimpleChildFeeder ( connectionWindowSize ) ; forEachChild ( parent , childFeeder ) ; return childFeeder . bytesAllocated ; } ChildFeeder childFeeder = new ChildFeeder ( parent , connectionWindowSize ) ; forEachChild ( parent , childFeeder ) ; childFeeder . feedHungryChildren ( ) ; return childFeeder . bytesAllocated ; } private void forEachChild ( Http2Stream parent , Http2StreamVisitor childFeeder ) { try { parent . forEachChild ( childFeeder ) ; } catch ( Http2Exception e ) { throw new IllegalStateException ( e ) ; } } private PriorityState state ( Http2Stream stream ) { return checkNotNull ( stream , <str> ) . getProperty ( stateKey ) ; } private final class ChildFeeder implements Http2StreamVisitor { final int maxSize ; int totalWeight ; int connectionWindow ; int nextTotalWeight ; int nextConnectionWindow ; int bytesAllocated ; Http2Stream [ ] stillHungry ; int nextTail ; ChildFeeder ( Http2Stream parent , int connectionWindow ) { maxSize = parent . numChildren ( ) ; totalWeight = parent . totalChildWeights ( ) ; this . connectionWindow = connectionWindow ; this . nextConnectionWindow = connectionWindow ; } @Override public boolean visit ( Http2Stream child ) { int connectionWindowChunk = max ( <int> , ( int ) ( connectionWindow * ( child . weight ( ) / ( double ) totalWeight ) ) ) ; int bytesForTree = min ( nextConnectionWindow , connectionWindowChunk ) ; PriorityState state = state ( child ) ; int bytesForChild = min ( state . unallocatedStreamableBytes ( ) , bytesForTree ) ; if ( bytesForChild > <int> ) { state . allocate ( bytesForChild ) ; bytesAllocated + = bytesForChild ; nextConnectionWindow - = bytesForChild ; bytesForTree - = bytesForChild ; } if ( bytesForTree > <int> ) { int childBytesAllocated = allocateBytesForTree ( child , bytesForTree ) ; bytesAllocated + = childBytesAllocated ; nextConnectionWindow - = childBytesAllocated ; } if ( nextConnectionWindow > <int> ) { if ( state . unallocatedStreamableBytesForTree ( ) > <int> ) { stillHungry ( child ) ; } return true ; } return false ; } void feedHungryChildren ( ) { if ( stillHungry = = null ) { return ; } totalWeight = nextTotalWeight ; connectionWindow = nextConnectionWindow ; for ( int tail = nextTail ; tail > <int> & & connectionWindow > <int> ; ) { nextTotalWeight = <int> ; nextTail = <int> ; for ( int head = <int> ; head < tail & & nextConnectionWindow > <int> ; + + head ) { if ( ! visit ( stillHungry [ head ] ) ) { break ; } } connectionWindow = nextConnectionWindow ; totalWeight = nextTotalWeight ; tail = nextTail ; } } void stillHungry ( Http2Stream child ) { ensureSpaceIsAllocated ( nextTail ) ; stillHungry [ nextTail + + ] = child ; nextTotalWeight + = child . weight ( ) ; } void ensureSpaceIsAllocated ( int index ) { if ( stillHungry = = null ) { stillHungry = new Http2Stream [ max ( <int> , maxSize > > > <int> ) ] ; } else if ( index = = stillHungry . length ) { stillHungry = Arrays . copyOf ( stillHungry , min ( maxSize , stillHungry . length < < <int> ) ) ; } } } private final class SimpleChildFeeder implements Http2StreamVisitor { int bytesAllocated ; int connectionWindow ; SimpleChildFeeder ( int connectionWindow ) { this . connectionWindow = connectionWindow ; } @Override public boolean visit ( Http2Stream child ) { PriorityState childState = state ( child ) ; int bytesForChild = childState . unallocatedStreamableBytes ( ) ; if ( bytesForChild > <int> | | childState . hasFrame ( ) ) { childState . allocate ( bytesForChild ) ; bytesAllocated + = bytesForChild ; connectionWindow - = bytesForChild ; } int childBytesAllocated = allocateBytesForTree ( child , connectionWindow ) ; bytesAllocated + = childBytesAllocated ; connectionWindow - = childBytesAllocated ; return true ; } } private final class PriorityState { final Http2Stream stream ; boolean hasFrame ; int streamableBytes ; int allocated ; long unallocatedStreamableBytesForTree ; PriorityState ( Http2Stream stream ) { this . stream = stream ; } void unallocatedStreamableBytesForTreeChanged ( long delta ) { unallocatedStreamableBytesForTree + = delta ; if ( ! stream . isRoot ( ) ) { state ( stream . parent ( ) ) . unallocatedStreamableBytesForTreeChanged ( delta ) ; } } void allocate ( int bytes ) { allocated + = bytes ; if ( bytes ! = <int> ) { unallocatedStreamableBytesForTreeChanged ( - bytes ) ; } } void resetAllocated ( ) { allocate ( - allocated ) ; } void updateStreamableBytes ( int newStreamableBytes , boolean hasFrame ) { assert hasFrame | | newStreamableBytes = = <int> ; this . hasFrame = hasFrame ; int delta = newStreamableBytes - streamableBytes ; if ( delta ! = <int> ) { streamableBytes = newStreamableBytes ; unallocatedStreamableBytesForTreeChanged ( delta ) ; } } void close ( ) { resetAllocated ( ) ; updateStreamableBytes ( <int> , false ) ; } boolean hasFrame ( ) { return hasFrame ; } int unallocatedStreamableBytes ( ) { return streamableBytes - allocated ; } long unallocatedStreamableBytesForTree ( ) { return unallocatedStreamableBytesForTree ; } } private final class WriteVisitor implements Http2StreamVisitor { private boolean iterating ; private Writer writer ; void writeAllocatedBytes ( Writer writer ) throws Http2Exception { if ( iterating ) { throw connectionError ( INTERNAL_ERROR , <str> ) ; } this . writer = writer ; try { iterating = true ; connection . forEachActiveStream ( this ) ; } finally { iterating = false ; } } @Override public boolean visit ( Http2Stream stream ) throws Http2Exception { PriorityState state = state ( stream ) ; int allocated = state . allocated ; state . resetAllocated ( ) ; try { writer . write ( stream , allocated ) ; } catch ( Throwable t ) { throw connectionError ( INTERNAL_ERROR , t , <str> ) ; } return true ; } } } 
