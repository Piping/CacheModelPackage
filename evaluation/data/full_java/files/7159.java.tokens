package org . elasticsearch . search . aggregations . bucket . children ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . SortedDocValues ; import org . apache . lucene . search . * ; import org . apache . lucene . util . Bits ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . util . LongArray ; import org . elasticsearch . common . util . LongObjectPagedHashMap ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . NonCollectingAggregator ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import java . io . IOException ; import java . util . Arrays ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class ParentToChildrenAggregator extends SingleBucketAggregator { private final String parentType ; private final Weight childFilter ; private final Weight parentFilter ; private final ValuesSource . Bytes . WithOrdinals . ParentChild valuesSource ; private final LongArray parentOrdToBuckets ; private final LongObjectPagedHashMap < long [ ] > parentOrdToOtherBuckets ; private boolean multipleBucketsPerParentOrd = false ; private Set < LeafReaderContext > replay = new LinkedHashSet < > ( ) ; public ParentToChildrenAggregator ( String name , AggregatorFactories factories , AggregationContext aggregationContext , Aggregator parent , String parentType , Query childFilter , Query parentFilter , ValuesSource . Bytes . WithOrdinals . ParentChild valuesSource , long maxOrd , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . parentType = parentType ; this . childFilter = aggregationContext . searchContext ( ) . searcher ( ) . createNormalizedWeight ( childFilter , false ) ; this . parentFilter = aggregationContext . searchContext ( ) . searcher ( ) . createNormalizedWeight ( parentFilter , false ) ; this . parentOrdToBuckets = aggregationContext . bigArrays ( ) . newLongArray ( maxOrd , false ) ; this . parentOrdToBuckets . fill ( <int> , maxOrd , - <int> ) ; this . parentOrdToOtherBuckets = new LongObjectPagedHashMap < > ( aggregationContext . bigArrays ( ) ) ; this . valuesSource = valuesSource ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { return new InternalChildren ( name , bucketDocCount ( owningBucketOrdinal ) , bucketAggregations ( owningBucketOrdinal ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalChildren ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { if ( valuesSource = = null ) { return LeafBucketCollector . NO_OP_COLLECTOR ; } if ( replay = = null ) { throw new IllegalStateException ( ) ; } final SortedDocValues globalOrdinals = valuesSource . globalOrdinalsValues ( parentType , ctx ) ; assert globalOrdinals ! = null ; Scorer parentScorer = parentFilter . scorer ( ctx ) ; final Bits parentDocs = Lucene . asSequentialAccessBits ( ctx . reader ( ) . maxDoc ( ) , parentScorer ) ; if ( childFilter . scorer ( ctx ) ! = null ) { replay . add ( ctx ) ; } return new LeafBucketCollector ( ) { @Override public void collect ( int docId , long bucket ) throws IOException { if ( parentDocs . get ( docId ) ) { long globalOrdinal = globalOrdinals . getOrd ( docId ) ; if ( globalOrdinal ! = - <int> ) { if ( parentOrdToBuckets . get ( globalOrdinal ) = = - <int> ) { parentOrdToBuckets . set ( globalOrdinal , bucket ) ; } else { long [ ] bucketOrds = parentOrdToOtherBuckets . get ( globalOrdinal ) ; if ( bucketOrds ! = null ) { bucketOrds = Arrays . copyOf ( bucketOrds , bucketOrds . length + <int> ) ; bucketOrds [ bucketOrds . length - <int> ] = bucket ; parentOrdToOtherBuckets . put ( globalOrdinal , bucketOrds ) ; } else { parentOrdToOtherBuckets . put ( globalOrdinal , new long [ ] { bucket } ) ; } multipleBucketsPerParentOrd = true ; } } } } } ; } @Override protected void doPostCollection ( ) throws IOException { final Set < LeafReaderContext > replay = this . replay ; this . replay = null ; for ( LeafReaderContext ctx : replay ) { DocIdSetIterator childDocsIter = childFilter . scorer ( ctx ) ; if ( childDocsIter = = null ) { continue ; } final LeafBucketCollector sub = collectableSubAggregators . getLeafCollector ( ctx ) ; final SortedDocValues globalOrdinals = valuesSource . globalOrdinalsValues ( parentType , ctx ) ; sub . setScorer ( new ConstantScoreScorer ( null , <float> , childDocsIter ) ) ; final Bits liveDocs = ctx . reader ( ) . getLiveDocs ( ) ; for ( int docId = childDocsIter . nextDoc ( ) ; docId ! = DocIdSetIterator . NO_MORE_DOCS ; docId = childDocsIter . nextDoc ( ) ) { if ( liveDocs ! = null & & liveDocs . get ( docId ) = = false ) { continue ; } long globalOrdinal = globalOrdinals . getOrd ( docId ) ; if ( globalOrdinal ! = - <int> ) { long bucketOrd = parentOrdToBuckets . get ( globalOrdinal ) ; if ( bucketOrd ! = - <int> ) { collectBucket ( sub , docId , bucketOrd ) ; if ( multipleBucketsPerParentOrd ) { long [ ] otherBucketOrds = parentOrdToOtherBuckets . get ( globalOrdinal ) ; if ( otherBucketOrds ! = null ) { for ( long otherBucketOrd : otherBucketOrds ) { collectBucket ( sub , docId , otherBucketOrd ) ; } } } } } } } } @Override protected void doClose ( ) { Releasables . close ( parentOrdToBuckets , parentOrdToOtherBuckets ) ; } public static class Factory extends ValuesSourceAggregatorFactory < ValuesSource . Bytes . WithOrdinals . ParentChild > { private final String parentType ; private final Query parentFilter ; private final Query childFilter ; public Factory ( String name , ValuesSourceConfig < ValuesSource . Bytes . WithOrdinals . ParentChild > config , String parentType , Query parentFilter , Query childFilter ) { super ( name , InternalChildren . TYPE . name ( ) , config ) ; this . parentType = parentType ; this . parentFilter = parentFilter ; this . childFilter = childFilter ; } @Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new NonCollectingAggregator ( name , aggregationContext , parent , pipelineAggregators , metaData ) { @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalChildren ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } } ; } @Override protected Aggregator doCreateInternal ( ValuesSource . Bytes . WithOrdinals . ParentChild valuesSource , AggregationContext aggregationContext , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { long maxOrd = valuesSource . globalMaxOrd ( aggregationContext . searchContext ( ) . searcher ( ) , parentType ) ; return new ParentToChildrenAggregator ( name , factories , aggregationContext , parent , parentType , childFilter , parentFilter , valuesSource , maxOrd , pipelineAggregators , metaData ) ; } } } 
