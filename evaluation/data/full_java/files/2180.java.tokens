package org . nd4j . linalg . dataset ; import com . google . common . base . Function ; import com . google . common . collect . Lists ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . dataset . api . iterator . DataSetIterator ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . BooleanIndexing ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . indexing . conditions . Condition ; import org . nd4j . linalg . util . FeatureUtil ; import org . nd4j . linalg . util . MathUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . util . * ; public class DataSet implements org . nd4j . linalg . dataset . api . DataSet { private static final long serialVersionUID = <int> ; private static Logger log = LoggerFactory . getLogger ( DataSet . class ) ; private List < String > columnNames = new ArrayList < > ( ) ; private List < String > labelNames = new ArrayList < > ( ) ; private INDArray features , labels ; private String id = UUID . randomUUID ( ) . toString ( ) ; public DataSet ( ) { this ( Nd4j . zeros ( new int [ ] { <int> , <int> } ) , Nd4j . zeros ( new int [ ] { <int> , <int> } ) ) ; } public DataSet ( INDArray first , INDArray second ) { if ( first . size ( <int> ) ! = second . size ( <int> ) ) throw new IllegalStateException ( <str> + first . size ( <int> ) + <str> + second . size ( <int> ) ) ; this . features = first ; this . labels = second ; } public static DataSet empty ( ) { return new DataSet ( Nd4j . zeros ( new int [ ] { <int> , <int> } ) , Nd4j . zeros ( new int [ ] { <int> , <int> } ) ) ; } public static DataSet merge ( List < DataSet > data , boolean clone ) { if ( data . isEmpty ( ) ) throw new IllegalArgumentException ( <str> ) ; DataSet first = data . get ( <int> ) ; if ( first . getFeatures ( ) . rank ( ) = = <int> & & first . getLabels ( ) . rank ( ) = = <int> ) { return mergeTimeSeries ( data ) ; } int numExamples = totalExamples ( data ) ; INDArray in = Nd4j . create ( numExamples , first . getFeatures ( ) . columns ( ) ) ; INDArray out = Nd4j . create ( numExamples , first . getLabels ( ) . columns ( ) ) ; int count = <int> ; for ( int i = <int> ; i < data . size ( ) ; i + + ) { DataSet d1 = data . get ( i ) ; for ( int j = <int> ; j < d1 . numExamples ( ) ; j + + ) { DataSet example = d1 . get ( j ) ; in . putRow ( count , clone ? example . getFeatures ( ) . dup ( ) : example . getFeatures ( ) ) ; out . putRow ( count , clone ? example . getLabels ( ) . dup ( ) : example . getLabels ( ) ) ; count + + ; } } return new DataSet ( in , out ) ; } private static DataSet mergeTimeSeries ( List < DataSet > data ) { DataSet first = data . get ( <int> ) ; int numExamples = totalExamples ( data ) ; int nIn = first . getFeatureMatrix ( ) . size ( <int> ) ; int nOut = first . getLabels ( ) . size ( <int> ) ; int tsLength = first . getFeatureMatrix ( ) . size ( <int> ) ; INDArray in = Nd4j . create ( numExamples , nIn , tsLength ) ; INDArray out = Nd4j . create ( numExamples , nOut , tsLength ) ; int rowCount = <int> ; for ( DataSet ds : data ) { INDArray f = ds . getFeatures ( ) ; INDArray l = ds . getLabels ( ) ; int nEx = f . size ( <int> ) ; in . get ( NDArrayIndex . interval ( rowCount , rowCount + nEx ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) . assign ( f ) ; out . get ( NDArrayIndex . interval ( rowCount , rowCount + nEx ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) . assign ( l ) ; rowCount + = nEx ; } return new DataSet ( in , out ) ; } public static DataSet merge ( List < DataSet > data ) { if ( data . isEmpty ( ) ) throw new IllegalArgumentException ( <str> ) ; return merge ( data , false ) ; } private static int totalExamples ( Collection < DataSet > coll ) { int count = <int> ; for ( DataSet d : coll ) count + = d . numExamples ( ) ; return count ; } @Override public org . nd4j . linalg . dataset . api . DataSet getRange ( int from , int to ) { return new DataSet ( features . get ( NDArrayIndex . interval ( from , to ) ) , labels . get ( NDArrayIndex . interval ( from , to ) ) ) ; } @Override public void load ( File from ) { try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( from ) ) ; DataInputStream dis = new DataInputStream ( bis ) ; features = Nd4j . read ( dis ) ; labels = Nd4j . read ( dis ) ; dis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @Override public void save ( File to ) { try { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( to ) ) ; DataOutputStream dis = new DataOutputStream ( bos ) ; Nd4j . write ( getFeatureMatrix ( ) , dis ) ; Nd4j . write ( getLabels ( ) , dis ) ; dis . flush ( ) ; dis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @Override public DataSetIterator iterateWithMiniBatches ( ) { return null ; } @Override public String id ( ) { return id ; } @Override public INDArray getFeatures ( ) { return features ; } @Override public void setFeatures ( INDArray features ) { this . features = features ; } @Override public Map < Integer , Double > labelCounts ( ) { Map < Integer , Double > ret = new HashMap < > ( ) ; if ( labels = = null ) return ret ; int nTensors = labels . tensorssAlongDimension ( <int> ) ; for ( int i = <int> ; i < nTensors ; i + + ) { INDArray row = labels . tensorAlongDimension ( i , <int> ) ; int maxIdx = Nd4j . getBlasWrapper ( ) . iamax ( row ) ; if ( maxIdx < <int> ) throw new IllegalStateException ( <str> + Nd4j . getBlasWrapper ( ) . getClass ( ) . getName ( ) ) ; if ( ret . get ( maxIdx ) = = null ) ret . put ( maxIdx , <float> ) ; else ret . put ( maxIdx , ret . get ( maxIdx ) + <float> ) ; } return ret ; } @Override public void apply ( Condition condition , Function < Number , Number > function ) { BooleanIndexing . applyWhere ( getFeatureMatrix ( ) , condition , function ) ; } @Override public DataSet copy ( ) { DataSet ret = new DataSet ( getFeatures ( ) . dup ( ) , getLabels ( ) . dup ( ) ) ; ret . setColumnNames ( getColumnNames ( ) ) ; ret . setLabelNames ( getLabelNames ( ) ) ; return ret ; } @Override public DataSet reshape ( int rows , int cols ) { DataSet ret = new DataSet ( getFeatures ( ) . reshape ( new int [ ] { rows , cols } ) , getLabels ( ) ) ; return ret ; } @Override public void multiplyBy ( double num ) { getFeatures ( ) . muli ( Nd4j . scalar ( num ) ) ; } @Override public void divideBy ( int num ) { getFeatures ( ) . divi ( Nd4j . scalar ( num ) ) ; } @Override public void shuffle ( ) { long seed = System . currentTimeMillis ( ) ; Nd4j . shuffle ( getFeatureMatrix ( ) , new Random ( seed ) , <int> ) ; Nd4j . shuffle ( getLabels ( ) , new Random ( seed ) , <int> ) ; } @Override public void squishToRange ( double min , double max ) { for ( int i = <int> ; i < getFeatures ( ) . length ( ) ; i + + ) { double curr = ( double ) getFeatures ( ) . getScalar ( i ) . element ( ) ; if ( curr < min ) getFeatures ( ) . put ( i , Nd4j . scalar ( min ) ) ; else if ( curr > max ) getFeatures ( ) . put ( i , Nd4j . scalar ( max ) ) ; } } @Override public void scaleMinAndMax ( double min , double max ) { FeatureUtil . scaleMinMax ( min , max , getFeatureMatrix ( ) ) ; } @Override public void scale ( ) { FeatureUtil . scaleByMax ( getFeatures ( ) ) ; } @Override public void addFeatureVector ( INDArray toAdd ) { setFeatures ( Nd4j . hstack ( getFeatureMatrix ( ) , toAdd ) ) ; } @Override public void addFeatureVector ( INDArray feature , int example ) { getFeatures ( ) . putRow ( example , feature ) ; } @Override public void normalize ( ) { FeatureUtil . normalizeMatrix ( getFeatures ( ) ) ; } @Override public void binarize ( ) { binarize ( <int> ) ; } @Override public void binarize ( double cutoff ) { INDArray linear = getFeatureMatrix ( ) . linearView ( ) ; for ( int i = <int> ; i < getFeatures ( ) . length ( ) ; i + + ) { double curr = linear . getDouble ( i ) ; if ( curr > cutoff ) getFeatures ( ) . putScalar ( i , <int> ) ; else getFeatures ( ) . putScalar ( i , <int> ) ; } } @Override public void normalizeZeroMeanZeroUnitVariance ( ) { INDArray columnMeans = getFeatures ( ) . mean ( <int> ) ; INDArray columnStds = getFeatureMatrix ( ) . std ( <int> ) ; setFeatures ( getFeatures ( ) . subiRowVector ( columnMeans ) ) ; columnStds . addi ( Nd4j . scalar ( Nd4j . EPS_THRESHOLD ) ) ; setFeatures ( getFeatures ( ) . diviRowVector ( columnStds ) ) ; } @Override public int numInputs ( ) { return getFeatures ( ) . columns ( ) ; } @Override public void validate ( ) { if ( getFeatures ( ) . size ( <int> ) ! = getLabels ( ) . size ( <int> ) ) throw new IllegalStateException ( <str> ) ; } @Override public int outcome ( ) { if ( this . numExamples ( ) > <int> ) throw new IllegalStateException ( <str> ) ; return Nd4j . getBlasWrapper ( ) . iamax ( getLabels ( ) ) ; } @Override public void setNewNumberOfLabels ( int labels ) { int examples = numExamples ( ) ; INDArray newOutcomes = Nd4j . create ( examples , labels ) ; setLabels ( newOutcomes ) ; } @Override public void setOutcome ( int example , int label ) { if ( example > numExamples ( ) ) throw new IllegalArgumentException ( <str> + example ) ; if ( label > numOutcomes ( ) | | label < <int> ) throw new IllegalArgumentException ( <str> ) ; INDArray outcome = FeatureUtil . toOutcomeVector ( label , numOutcomes ( ) ) ; getLabels ( ) . putRow ( example , outcome ) ; } @Override public DataSet get ( int i ) { if ( i > numExamples ( ) | | i < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( i = = <int> & & numExamples ( ) = = <int> ) return this ; return new DataSet ( getFeatures ( ) . getRow ( i ) , getLabels ( ) . getRow ( i ) ) ; } @Override public DataSet get ( int [ ] i ) { return new DataSet ( getFeatures ( ) . getRows ( i ) , getLabels ( ) . getRows ( i ) ) ; } @Override public List < DataSet > batchBy ( int num ) { List < DataSet > batched = Lists . newArrayList ( ) ; for ( List < DataSet > splitBatch : Lists . partition ( asList ( ) , num ) ) { batched . add ( DataSet . merge ( splitBatch ) ) ; } return batched ; } @Override public DataSet filterBy ( int [ ] labels ) { List < DataSet > list = asList ( ) ; List < DataSet > newList = new ArrayList < > ( ) ; List < Integer > labelList = new ArrayList < > ( ) ; for ( int i : labels ) labelList . add ( i ) ; for ( DataSet d : list ) { int outcome = d . outcome ( ) ; if ( labelList . contains ( outcome ) ) { newList . add ( d ) ; } } return DataSet . merge ( newList ) ; } @Override public void filterAndStrip ( int [ ] labels ) { DataSet filtered = filterBy ( labels ) ; List < Integer > newLabels = new ArrayList < > ( ) ; Map < Integer , Integer > labelMap = new HashMap < > ( ) ; for ( int i = <int> ; i < labels . length ; i + + ) labelMap . put ( labels [ i ] , i ) ; for ( int i = <int> ; i < filtered . numExamples ( ) ; i + + ) { DataSet example = filtered . get ( i ) ; int o2 = example . outcome ( ) ; Integer outcome = labelMap . get ( o2 ) ; newLabels . add ( outcome ) ; } INDArray newLabelMatrix = Nd4j . create ( filtered . numExamples ( ) , labels . length ) ; if ( newLabelMatrix . rows ( ) ! = newLabels . size ( ) ) throw new IllegalStateException ( <str> ) ; for ( int i = <int> ; i < newLabelMatrix . rows ( ) ; i + + ) { Integer i2 = newLabels . get ( i ) ; if ( i2 = = null ) throw new IllegalStateException ( <str> + i ) ; INDArray newRow = FeatureUtil . toOutcomeVector ( i2 , labels . length ) ; newLabelMatrix . putRow ( i , newRow ) ; } setFeatures ( filtered . getFeatures ( ) ) ; setLabels ( newLabelMatrix ) ; } @Override public List < DataSet > dataSetBatches ( int num ) { List < List < DataSet > > list = Lists . partition ( asList ( ) , num ) ; List < DataSet > ret = new ArrayList < > ( ) ; for ( List < DataSet > l : list ) ret . add ( DataSet . merge ( l ) ) ; return ret ; } @Override public List < DataSet > sortAndBatchByNumLabels ( ) { sortByLabel ( ) ; return batchByNumLabels ( ) ; } @Override public List < DataSet > batchByNumLabels ( ) { return batchBy ( numOutcomes ( ) ) ; } @Override public List < DataSet > asList ( ) { List < DataSet > list = new ArrayList < > ( numExamples ( ) ) ; for ( int i = <int> ; i < numExamples ( ) ; i + + ) { list . add ( new DataSet ( getFeatures ( ) . getRow ( i ) , getLabels ( ) . getRow ( i ) ) ) ; } return list ; } @Override public SplitTestAndTrain splitTestAndTrain ( int numHoldout , Random rng ) { if ( numHoldout > = numExamples ( ) ) throw new IllegalArgumentException ( <str> ) ; DataSet first = new DataSet ( getFeatureMatrix ( ) . get ( NDArrayIndex . interval ( <int> , numHoldout ) ) , getLabels ( ) . get ( NDArrayIndex . interval ( <int> , numHoldout ) ) ) ; DataSet second = new DataSet ( getFeatureMatrix ( ) . get ( NDArrayIndex . interval ( numHoldout , numExamples ( ) ) ) , getLabels ( ) . get ( NDArrayIndex . interval ( numHoldout , numExamples ( ) ) ) ) ; return new SplitTestAndTrain ( first , second ) ; } @Override public SplitTestAndTrain splitTestAndTrain ( int numHoldout ) { return splitTestAndTrain ( numHoldout , new Random ( ) ) ; } @Override public INDArray getLabels ( ) { return labels ; } @Override public void setLabels ( INDArray labels ) { this . labels = labels ; } @Override public INDArray getFeatureMatrix ( ) { return getFeatures ( ) ; } @Override public void sortByLabel ( ) { Map < Integer , Queue < DataSet > > map = new HashMap < > ( ) ; List < DataSet > data = asList ( ) ; int numLabels = numOutcomes ( ) ; int examples = numExamples ( ) ; for ( DataSet d : data ) { int label = d . outcome ( ) ; Queue < DataSet > q = map . get ( label ) ; if ( q = = null ) { q = new ArrayDeque < > ( ) ; map . put ( label , q ) ; } q . add ( d ) ; } for ( Map . Entry < Integer , Queue < DataSet > > label : map . entrySet ( ) ) { log . info ( <str> + label + <str> + label . getValue ( ) . size ( ) + <str> ) ; } boolean optimal = true ; for ( int i = <int> ; i < examples ; i + + ) { if ( optimal ) { for ( int j = <int> ; j < numLabels ; j + + ) { Queue < DataSet > q = map . get ( j ) ; if ( q = = null ) { optimal = false ; break ; } DataSet next = q . poll ( ) ; if ( next ! = null ) { addRow ( next , i ) ; i + + ; } else { optimal = false ; break ; } } } else { DataSet add = null ; for ( Queue < DataSet > q : map . values ( ) ) { if ( ! q . isEmpty ( ) ) { add = q . poll ( ) ; break ; } } addRow ( add , i ) ; } } } @Override public void addRow ( DataSet d , int i ) { if ( i > numExamples ( ) | | d = = null ) throw new IllegalArgumentException ( <str> ) ; getFeatures ( ) . putRow ( i , d . getFeatures ( ) ) ; getLabels ( ) . putRow ( i , d . getLabels ( ) ) ; } private int getLabel ( DataSet data ) { Float f = data . getLabels ( ) . maxNumber ( ) . floatValue ( ) ; return f . intValue ( ) ; } @Override public INDArray exampleSums ( ) { return getFeatures ( ) . sum ( <int> ) ; } @Override public INDArray exampleMaxs ( ) { return getFeatures ( ) . max ( <int> ) ; } @Override public INDArray exampleMeans ( ) { return getFeatures ( ) . mean ( <int> ) ; } @Override public DataSet sample ( int numSamples ) { return sample ( numSamples , Nd4j . getRandom ( ) ) ; } @Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng ) { return sample ( numSamples , rng , false ) ; } @Override public DataSet sample ( int numSamples , boolean withReplacement ) { return sample ( numSamples , Nd4j . getRandom ( ) , withReplacement ) ; } @Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { INDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; INDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; Set < Integer > added = new HashSet < > ( ) ; for ( int i = <int> ; i < numSamples ; i + + ) { int picked = rng . nextInt ( numExamples ( ) ) ; if ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; examples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; outcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; } return new DataSet ( examples , outcomes ) ; } @Override public void roundToTheNearest ( int roundTo ) { for ( int i = <int> ; i < getFeatures ( ) . length ( ) ; i + + ) { double curr = ( double ) getFeatures ( ) . getScalar ( i ) . element ( ) ; getFeatures ( ) . put ( i , Nd4j . scalar ( MathUtils . roundDouble ( curr , roundTo ) ) ) ; } } @Override public int numOutcomes ( ) { return getLabels ( ) . columns ( ) ; } @Override public int numExamples ( ) { return getFeatures ( ) . size ( <int> ) ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( <str> ) . append ( getFeatures ( ) . toString ( ) . replaceAll ( <str> , <str> ) ) . append ( <str> ) . append ( getLabels ( ) . toString ( ) . replaceAll ( <str> , <str> ) ) ; return builder . toString ( ) ; } @Override public List < String > getLabelNames ( ) { return labelNames ; } @Override public void setLabelNames ( List < String > labelNames ) { this . labelNames = labelNames ; } @Override public List < String > getColumnNames ( ) { return columnNames ; } @Override public void setColumnNames ( List < String > columnNames ) { this . columnNames = columnNames ; } @Override public SplitTestAndTrain splitTestAndTrain ( double percentTrain ) { int numPercent = ( int ) ( percentTrain * numExamples ( ) ) ; return splitTestAndTrain ( numPercent ) ; } @Override public Iterator < DataSet > iterator ( ) { return asList ( ) . iterator ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof DataSet ) ) return false ; DataSet dataSet = ( DataSet ) o ; if ( getFeatures ( ) ! = null ? ! getFeatures ( ) . equals ( dataSet . getFeatures ( ) ) : dataSet . getFeatures ( ) ! = null ) return false ; return ! ( getLabels ( ) ! = null ? ! getLabels ( ) . equals ( dataSet . getLabels ( ) ) : dataSet . getLabels ( ) ! = null ) ; } @Override public int hashCode ( ) { int result = getFeatures ( ) ! = null ? getFeatures ( ) . hashCode ( ) : <int> ; result = <int> * result + ( getLabels ( ) ! = null ? getLabels ( ) . hashCode ( ) : <int> ) ; return result ; } } 
