package com . google . common . util . concurrent ; import com . google . common . base . Preconditions ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . concurrent . Executor ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . concurrent . GuardedBy ; final class SerializingExecutor implements Executor { private static final Logger log = Logger . getLogger ( SerializingExecutor . class . getName ( ) ) ; private final Executor executor ; @GuardedBy ( <str> ) private final Deque < Runnable > queue = new ArrayDeque < Runnable > ( ) ; @GuardedBy ( <str> ) private boolean isWorkerRunning = false ; @GuardedBy ( <str> ) private int suspensions = <int> ; private final Object internalLock = new Object ( ) ; public SerializingExecutor ( Executor executor ) { this . executor = Preconditions . checkNotNull ( executor ) ; } public void execute ( Runnable task ) { synchronized ( internalLock ) { queue . add ( task ) ; } startQueueWorker ( ) ; } public void executeFirst ( Runnable task ) { synchronized ( internalLock ) { queue . addFirst ( task ) ; } startQueueWorker ( ) ; } public void suspend ( ) { synchronized ( internalLock ) { suspensions + + ; } } public void resume ( ) { synchronized ( internalLock ) { Preconditions . checkState ( suspensions > <int> ) ; suspensions - - ; } startQueueWorker ( ) ; } private void startQueueWorker ( ) { synchronized ( internalLock ) { if ( queue . peek ( ) = = null ) { return ; } if ( suspensions > <int> ) { return ; } if ( isWorkerRunning ) { return ; } isWorkerRunning = true ; } boolean executionRejected = true ; try { executor . execute ( new QueueWorker ( ) ) ; executionRejected = false ; } finally { if ( executionRejected ) { synchronized ( internalLock ) { isWorkerRunning = false ; } } } } private final class QueueWorker implements Runnable { @Override public void run ( ) { try { workOnQueue ( ) ; } catch ( Error e ) { synchronized ( internalLock ) { isWorkerRunning = false ; } throw e ; } } private void workOnQueue ( ) { while ( true ) { Runnable task = null ; synchronized ( internalLock ) { if ( suspensions = = <int> ) { task = queue . poll ( ) ; } if ( task = = null ) { isWorkerRunning = false ; return ; } } try { task . run ( ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + task , e ) ; } } } } } 
