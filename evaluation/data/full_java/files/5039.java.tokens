package org . elasticsearch . action . admin . cluster . stats ; import com . carrotsearch . hppc . ObjectObjectHashMap ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . admin . indices . stats . CommonStats ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . index . cache . query . QueryCacheStats ; import org . elasticsearch . index . engine . SegmentsStats ; import org . elasticsearch . index . fielddata . FieldDataStats ; import org . elasticsearch . index . percolator . PercolateStats ; import org . elasticsearch . index . shard . DocsStats ; import org . elasticsearch . index . store . StoreStats ; import org . elasticsearch . search . suggest . completion . CompletionStats ; import java . io . IOException ; public class ClusterStatsIndices implements ToXContent , Streamable { private int indexCount ; private ShardStats shards ; private DocsStats docs ; private StoreStats store ; private FieldDataStats fieldData ; private QueryCacheStats queryCache ; private CompletionStats completion ; private SegmentsStats segments ; private PercolateStats percolate ; private ClusterStatsIndices ( ) { } public ClusterStatsIndices ( ClusterStatsNodeResponse [ ] nodeResponses ) { ObjectObjectHashMap < String , ShardStats > countsPerIndex = new ObjectObjectHashMap < > ( ) ; this . docs = new DocsStats ( ) ; this . store = new StoreStats ( ) ; this . fieldData = new FieldDataStats ( ) ; this . queryCache = new QueryCacheStats ( ) ; this . completion = new CompletionStats ( ) ; this . segments = new SegmentsStats ( ) ; this . percolate = new PercolateStats ( ) ; for ( ClusterStatsNodeResponse r : nodeResponses ) { for ( org . elasticsearch . action . admin . indices . stats . ShardStats shardStats : r . shardsStats ( ) ) { ShardStats indexShardStats = countsPerIndex . get ( shardStats . getShardRouting ( ) . getIndex ( ) ) ; if ( indexShardStats = = null ) { indexShardStats = new ShardStats ( ) ; countsPerIndex . put ( shardStats . getShardRouting ( ) . getIndex ( ) , indexShardStats ) ; } indexShardStats . total + + ; CommonStats shardCommonStats = shardStats . getStats ( ) ; if ( shardStats . getShardRouting ( ) . primary ( ) ) { indexShardStats . primaries + + ; docs . add ( shardCommonStats . docs ) ; } store . add ( shardCommonStats . store ) ; fieldData . add ( shardCommonStats . fieldData ) ; queryCache . add ( shardCommonStats . queryCache ) ; completion . add ( shardCommonStats . completion ) ; segments . add ( shardCommonStats . segments ) ; percolate . add ( shardCommonStats . percolate ) ; } } shards = new ShardStats ( ) ; indexCount = countsPerIndex . size ( ) ; for ( ObjectObjectCursor < String , ShardStats > indexCountsCursor : countsPerIndex ) { shards . addIndexShardCount ( indexCountsCursor . value ) ; } } public int getIndexCount ( ) { return indexCount ; } public ShardStats getShards ( ) { return this . shards ; } public DocsStats getDocs ( ) { return docs ; } public StoreStats getStore ( ) { return store ; } public FieldDataStats getFieldData ( ) { return fieldData ; } public QueryCacheStats getQueryCache ( ) { return queryCache ; } public CompletionStats getCompletion ( ) { return completion ; } public SegmentsStats getSegments ( ) { return segments ; } public PercolateStats getPercolate ( ) { return percolate ; } @Override public void readFrom ( StreamInput in ) throws IOException { indexCount = in . readVInt ( ) ; shards = ShardStats . readShardStats ( in ) ; docs = DocsStats . readDocStats ( in ) ; store = StoreStats . readStoreStats ( in ) ; fieldData = FieldDataStats . readFieldDataStats ( in ) ; queryCache = QueryCacheStats . readQueryCacheStats ( in ) ; completion = CompletionStats . readCompletionStats ( in ) ; segments = SegmentsStats . readSegmentsStats ( in ) ; percolate = PercolateStats . readPercolateStats ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( indexCount ) ; shards . writeTo ( out ) ; docs . writeTo ( out ) ; store . writeTo ( out ) ; fieldData . writeTo ( out ) ; queryCache . writeTo ( out ) ; completion . writeTo ( out ) ; segments . writeTo ( out ) ; percolate . writeTo ( out ) ; } public static ClusterStatsIndices readIndicesStats ( StreamInput in ) throws IOException { ClusterStatsIndices indicesStats = new ClusterStatsIndices ( ) ; indicesStats . readFrom ( in ) ; return indicesStats ; } static final class Fields { static final XContentBuilderString COUNT = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . COUNT , indexCount ) ; shards . toXContent ( builder , params ) ; docs . toXContent ( builder , params ) ; store . toXContent ( builder , params ) ; fieldData . toXContent ( builder , params ) ; queryCache . toXContent ( builder , params ) ; completion . toXContent ( builder , params ) ; segments . toXContent ( builder , params ) ; percolate . toXContent ( builder , params ) ; return builder ; } public static class ShardStats implements ToXContent , Streamable { int indices ; int total ; int primaries ; int minIndexShards = - <int> ; int maxIndexShards = - <int> ; int minIndexPrimaryShards = - <int> ; int maxIndexPrimaryShards = - <int> ; double minIndexReplication = - <int> ; double totalIndexReplication = <int> ; double maxIndexReplication = - <int> ; public ShardStats ( ) { } public int getIndices ( ) { return this . indices ; } public int getTotal ( ) { return this . total ; } public int getPrimaries ( ) { return this . primaries ; } public double getReplication ( ) { if ( primaries = = <int> ) { return <int> ; } return ( ( ( double ) ( total - primaries ) ) / primaries ) ; } public int getMaxIndexShards ( ) { return this . maxIndexShards ; } public int getMinIndexShards ( ) { return this . minIndexShards ; } public double getAvgIndexShards ( ) { if ( this . indices = = <int> ) { return - <int> ; } return ( ( double ) this . total ) / this . indices ; } public int getMaxIndexPrimaryShards ( ) { return this . maxIndexPrimaryShards ; } public int getMinIndexPrimaryShards ( ) { return this . minIndexPrimaryShards ; } public double getAvgIndexPrimaryShards ( ) { if ( this . indices = = <int> ) { return - <int> ; } return ( ( double ) this . primaries ) / this . indices ; } public double getMinIndexReplication ( ) { return this . minIndexReplication ; } public double getAvgIndexReplication ( ) { if ( indices = = <int> ) { return - <int> ; } return this . totalIndexReplication / this . indices ; } public double getMaxIndexReplication ( ) { return this . maxIndexReplication ; } public void addIndexShardCount ( ShardStats indexShardCount ) { this . indices + + ; this . primaries + = indexShardCount . primaries ; this . total + = indexShardCount . total ; this . totalIndexReplication + = indexShardCount . getReplication ( ) ; if ( this . indices = = <int> ) { minIndexPrimaryShards = indexShardCount . primaries ; maxIndexPrimaryShards = indexShardCount . primaries ; minIndexShards = indexShardCount . total ; maxIndexShards = indexShardCount . total ; minIndexReplication = indexShardCount . getReplication ( ) ; maxIndexReplication = minIndexReplication ; } else { minIndexShards = Math . min ( minIndexShards , indexShardCount . total ) ; minIndexPrimaryShards = Math . min ( minIndexPrimaryShards , indexShardCount . primaries ) ; minIndexReplication = Math . min ( minIndexReplication , indexShardCount . getReplication ( ) ) ; maxIndexShards = Math . max ( maxIndexShards , indexShardCount . total ) ; maxIndexPrimaryShards = Math . max ( maxIndexPrimaryShards , indexShardCount . primaries ) ; maxIndexReplication = Math . max ( maxIndexReplication , indexShardCount . getReplication ( ) ) ; } } public static ShardStats readShardStats ( StreamInput in ) throws IOException { ShardStats c = new ShardStats ( ) ; c . readFrom ( in ) ; return c ; } @Override public void readFrom ( StreamInput in ) throws IOException { indices = in . readVInt ( ) ; total = in . readVInt ( ) ; primaries = in . readVInt ( ) ; minIndexShards = in . readVInt ( ) ; maxIndexShards = in . readVInt ( ) ; minIndexPrimaryShards = in . readVInt ( ) ; maxIndexPrimaryShards = in . readVInt ( ) ; minIndexReplication = in . readDouble ( ) ; totalIndexReplication = in . readDouble ( ) ; maxIndexReplication = in . readDouble ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( indices ) ; out . writeVInt ( total ) ; out . writeVInt ( primaries ) ; out . writeVInt ( minIndexShards ) ; out . writeVInt ( maxIndexShards ) ; out . writeVInt ( minIndexPrimaryShards ) ; out . writeVInt ( maxIndexPrimaryShards ) ; out . writeDouble ( minIndexReplication ) ; out . writeDouble ( totalIndexReplication ) ; out . writeDouble ( maxIndexReplication ) ; } static final class Fields { static final XContentBuilderString SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PRIMARIES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString REPLICATION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MIN = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MAX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString AVG = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDEX = new XContentBuilderString ( <str> ) ; } private void addIntMinMax ( XContentBuilderString field , int min , int max , double avg , XContentBuilder builder ) throws IOException { builder . startObject ( field ) ; builder . field ( Fields . MIN , min ) ; builder . field ( Fields . MAX , max ) ; builder . field ( Fields . AVG , avg ) ; builder . endObject ( ) ; } private void addDoubleMinMax ( XContentBuilderString field , double min , double max , double avg , XContentBuilder builder ) throws IOException { builder . startObject ( field ) ; builder . field ( Fields . MIN , min ) ; builder . field ( Fields . MAX , max ) ; builder . field ( Fields . AVG , avg ) ; builder . endObject ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . SHARDS ) ; if ( indices > <int> ) { builder . field ( Fields . TOTAL , total ) ; builder . field ( Fields . PRIMARIES , primaries ) ; builder . field ( Fields . REPLICATION , getReplication ( ) ) ; builder . startObject ( Fields . INDEX ) ; addIntMinMax ( Fields . SHARDS , minIndexShards , maxIndexShards , getAvgIndexShards ( ) , builder ) ; addIntMinMax ( Fields . PRIMARIES , minIndexPrimaryShards , maxIndexPrimaryShards , getAvgIndexPrimaryShards ( ) , builder ) ; addDoubleMinMax ( Fields . REPLICATION , minIndexReplication , maxIndexReplication , getAvgIndexReplication ( ) , builder ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return builder ; } @Override public String toString ( ) { return <str> + total + <str> + primaries + <str> ; } } } 
