package org . nd4j . linalg . api . shape . loop . two ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . api . shape . StridePermutation ; import org . nd4j . linalg . util . ArrayUtil ; import java . io . Serializable ; @Data @AllArgsConstructor @NoArgsConstructor @Builder public class RawArrayIterationInformation2 implements Serializable { private int nDim ; private int aOffset = - <int> ; private int bOffset = - <int> ; private int [ ] aStrides ; private int [ ] bStrides ; private int [ ] shape ; private DataBuffer a ; private DataBuffer b ; public RawArrayIterationInformation2 computeOut ( ) { int aOffset = this . aOffset ; int bOffset = this . bOffset ; int [ ] aStrides = ArrayUtil . copy ( this . aStrides ) ; int [ ] bStrides = ArrayUtil . copy ( this . bStrides ) ; int [ ] shape = ArrayUtil . copy ( this . shape ) ; int nDim = this . nDim ; StridePermutation [ ] perms = Shape . createSortedStrides ( aStrides ) ; for ( int i = <int> ; i < nDim ; i + + ) { int iPerm = perms [ nDim - i - <int> ] . getPermutation ( ) ; shape [ i ] = this . shape [ iPerm ] ; aStrides [ i ] = aStrides [ iPerm ] ; bStrides [ i ] = bStrides [ iPerm ] ; } for ( int i = <int> ; i < nDim ; i + + ) { int outStrideA = aStrides [ i ] ; int outStrideB = bStrides [ i ] ; int shapeI = shape [ i ] ; if ( outStrideA < <int> ) { aOffset + = outStrideA * shapeI - <int> ; bOffset + = outStrideB * shapeI - <int> ; aStrides [ i ] - = outStrideA ; bStrides [ i ] - = outStrideB ; } } int i = <int> ; for ( int j = <int> ; j < nDim ; j + + ) { if ( shape [ i ] = = <int> ) { shape [ i ] = shape [ j ] ; aStrides [ i ] = aStrides [ j ] ; bStrides [ i ] = aStrides [ j ] ; } else if ( shape [ j ] = = <int> ) { } else if ( aStrides [ i ] * shape [ i ] = = aStrides [ j ] & & bStrides [ i ] * shape [ i ] = = bStrides [ j ] ) { shape [ i ] * = shape [ j ] ; } else { i + + ; shape [ i ] = shape [ j ] ; aStrides [ i ] = aStrides [ j ] ; bStrides [ i ] = bStrides [ j ] ; } } nDim = i + <int> ; if ( nDim = = <int> ) { nDim = <int> ; shape = this . shape ; aStrides = this . aStrides ; bStrides = this . bStrides ; } return RawArrayIterationInformation2 . builder ( ) . aOffset ( aOffset ) . a ( a ) . b ( b ) . bOffset ( bOffset ) . aStrides ( aStrides ) . bStrides ( bStrides ) . shape ( shape ) . nDim ( nDim ) . build ( ) ; } } 
