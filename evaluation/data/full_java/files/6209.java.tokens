package org . elasticsearch . gateway ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . settings . Settings ; import java . util . * ; public abstract class PrimaryShardAllocator extends AbstractComponent { public static final String INDEX_RECOVERY_INITIAL_SHARDS = <str> ; private final String initialShards ; public PrimaryShardAllocator ( Settings settings ) { super ( settings ) ; this . initialShards = settings . get ( <str> , settings . get ( <str> , <str> ) ) ; logger . debug ( <str> , initialShards ) ; } public boolean allocateUnassigned ( RoutingAllocation allocation ) { boolean changed = false ; final RoutingNodes routingNodes = allocation . routingNodes ( ) ; final MetaData metaData = routingNodes . metaData ( ) ; final RoutingNodes . UnassignedShards . UnassignedIterator unassignedIterator = routingNodes . unassigned ( ) . iterator ( ) ; while ( unassignedIterator . hasNext ( ) ) { ShardRouting shard = unassignedIterator . next ( ) ; if ( needToFindPrimaryCopy ( shard ) = = false ) { continue ; } AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > shardState = fetchData ( shard , allocation ) ; if ( shardState . hasData ( ) = = false ) { logger . trace ( <str> , shard ) ; allocation . setHasPendingAsyncFetch ( ) ; unassignedIterator . removeAndIgnore ( ) ; continue ; } IndexMetaData indexMetaData = metaData . index ( shard . getIndex ( ) ) ; Settings indexSettings = Settings . builder ( ) . put ( settings ) . put ( indexMetaData . getSettings ( ) ) . build ( ) ; NodesAndVersions nodesAndVersions = buildNodesAndVersions ( shard , recoverOnAnyNode ( indexSettings ) , allocation . getIgnoreNodes ( shard . shardId ( ) ) , shardState ) ; logger . debug ( <str> , shard . index ( ) , shard . id ( ) , nodesAndVersions . allocationsFound , shard , nodesAndVersions . highestVersion ) ; if ( isEnoughAllocationsFound ( shard , indexMetaData , nodesAndVersions ) = = false ) { if ( shard . restoreSource ( ) = = null ) { unassignedIterator . removeAndIgnore ( ) ; logger . debug ( <str> , shard . index ( ) , shard . id ( ) , nodesAndVersions . allocationsFound ) ; } else { logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard . restoreSource ( ) ) ; } continue ; } NodesToAllocate nodesToAllocate = buildNodesToAllocate ( shard , allocation , nodesAndVersions ) ; if ( nodesToAllocate . yesNodes . isEmpty ( ) = = false ) { DiscoveryNode node = nodesToAllocate . yesNodes . get ( <int> ) ; logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , node ) ; changed = true ; unassignedIterator . initialize ( node . id ( ) , nodesAndVersions . highestVersion , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ; } else if ( nodesToAllocate . throttleNodes . isEmpty ( ) = = true & & nodesToAllocate . noNodes . isEmpty ( ) = = false ) { DiscoveryNode node = nodesToAllocate . noNodes . get ( <int> ) ; logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , node ) ; changed = true ; unassignedIterator . initialize ( node . id ( ) , nodesAndVersions . highestVersion , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ; } else { logger . debug ( <str> , shard . index ( ) , shard . id ( ) , shard , nodesToAllocate . throttleNodes ) ; unassignedIterator . removeAndIgnore ( ) ; } } return changed ; } boolean needToFindPrimaryCopy ( ShardRouting shard ) { if ( shard . primary ( ) = = false ) { return false ; } if ( shard . allocatedPostIndexCreate ( ) = = false ) { return false ; } return true ; } private boolean isEnoughAllocationsFound ( ShardRouting shard , IndexMetaData indexMetaData , NodesAndVersions nodesAndVersions ) { int requiredAllocation = <int> ; if ( shard . restoreSource ( ) = = null ) { try { String initialShards = indexMetaData . getSettings ( ) . get ( INDEX_RECOVERY_INITIAL_SHARDS , settings . get ( INDEX_RECOVERY_INITIAL_SHARDS , this . initialShards ) ) ; if ( <str> . equals ( initialShards ) ) { if ( indexMetaData . getNumberOfReplicas ( ) > <int> ) { requiredAllocation = ( ( <int> + indexMetaData . getNumberOfReplicas ( ) ) / <int> ) + <int> ; } } else if ( <str> . equals ( initialShards ) | | <str> . equals ( initialShards ) ) { if ( indexMetaData . getNumberOfReplicas ( ) > <int> ) { requiredAllocation = ( ( <int> + indexMetaData . getNumberOfReplicas ( ) ) / <int> ) ; } } else if ( <str> . equals ( initialShards ) ) { requiredAllocation = <int> ; } else if ( <str> . equals ( initialShards ) | | <str> . equals ( initialShards ) ) { requiredAllocation = indexMetaData . getNumberOfReplicas ( ) + <int> ; } else if ( <str> . equals ( initialShards ) | | <str> . equals ( initialShards ) ) { if ( indexMetaData . getNumberOfReplicas ( ) > <int> ) { requiredAllocation = indexMetaData . getNumberOfReplicas ( ) ; } } else { requiredAllocation = Integer . parseInt ( initialShards ) ; } } catch ( Exception e ) { logger . warn ( <str> , shard . index ( ) , shard . id ( ) , initialShards , shard ) ; } } return nodesAndVersions . allocationsFound > = requiredAllocation ; } private NodesToAllocate buildNodesToAllocate ( ShardRouting shard , RoutingAllocation allocation , NodesAndVersions nodesAndVersions ) { List < DiscoveryNode > yesNodes = new ArrayList < > ( ) ; List < DiscoveryNode > throttledNodes = new ArrayList < > ( ) ; List < DiscoveryNode > noNodes = new ArrayList < > ( ) ; for ( DiscoveryNode discoNode : nodesAndVersions . nodes ) { RoutingNode node = allocation . routingNodes ( ) . node ( discoNode . id ( ) ) ; if ( node = = null ) { continue ; } Decision decision = allocation . deciders ( ) . canAllocate ( shard , node , allocation ) ; if ( decision . type ( ) = = Decision . Type . THROTTLE ) { throttledNodes . add ( discoNode ) ; } else if ( decision . type ( ) = = Decision . Type . NO ) { noNodes . add ( discoNode ) ; } else { yesNodes . add ( discoNode ) ; } } return new NodesToAllocate ( Collections . unmodifiableList ( yesNodes ) , Collections . unmodifiableList ( throttledNodes ) , Collections . unmodifiableList ( noNodes ) ) ; } NodesAndVersions buildNodesAndVersions ( ShardRouting shard , boolean recoveryOnAnyNode , Set < String > ignoreNodes , AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > shardState ) { final Map < DiscoveryNode , Long > nodesWithVersion = new HashMap < > ( ) ; int numberOfAllocationsFound = <int> ; long highestVersion = - <int> ; for ( TransportNodesListGatewayStartedShards . NodeGatewayStartedShards nodeShardState : shardState . getData ( ) . values ( ) ) { long version = nodeShardState . version ( ) ; DiscoveryNode node = nodeShardState . getNode ( ) ; if ( ignoreNodes . contains ( node . id ( ) ) ) { continue ; } if ( nodeShardState . storeException ( ) = = null ) { logger . trace ( <str> , shard , nodeShardState . getNode ( ) , version ) ; } else { logger . trace ( <str> , nodeShardState . storeException ( ) , shard , nodeShardState . getNode ( ) , version ) ; version = - <int> ; } if ( recoveryOnAnyNode ) { numberOfAllocationsFound + + ; if ( version > highestVersion ) { highestVersion = version ; } nodesWithVersion . put ( node , version ) ; } else if ( version ! = - <int> ) { numberOfAllocationsFound + + ; if ( version > highestVersion ) { highestVersion = version ; nodesWithVersion . clear ( ) ; nodesWithVersion . put ( node , version ) ; } else if ( version = = highestVersion ) { nodesWithVersion . put ( node , version ) ; } } } List < DiscoveryNode > nodesWithHighestVersion = new ArrayList < > ( ) ; nodesWithHighestVersion . addAll ( nodesWithVersion . keySet ( ) ) ; CollectionUtil . timSort ( nodesWithHighestVersion , new Comparator < DiscoveryNode > ( ) { @Override public int compare ( DiscoveryNode o1 , DiscoveryNode o2 ) { return Long . compare ( nodesWithVersion . get ( o2 ) , nodesWithVersion . get ( o1 ) ) ; } } ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( DiscoveryNode n : nodesWithVersion . keySet ( ) ) { sb . append ( <str> ) . append ( n . getName ( ) ) . append ( <str> ) . append ( <str> ) . append ( nodesWithVersion . get ( n ) ) . append ( <str> ) ; } sb . append ( <str> ) ; logger . trace ( <str> , shard , sb . toString ( ) ) ; } return new NodesAndVersions ( Collections . unmodifiableList ( nodesWithHighestVersion ) , numberOfAllocationsFound , highestVersion ) ; } private boolean recoverOnAnyNode ( Settings idxSettings ) { return IndexMetaData . isOnSharedFilesystem ( idxSettings ) & & idxSettings . getAsBoolean ( IndexMetaData . SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE , false ) ; } protected abstract AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > fetchData ( ShardRouting shard , RoutingAllocation allocation ) ; static class NodesAndVersions { public final List < DiscoveryNode > nodes ; public final int allocationsFound ; public final long highestVersion ; public NodesAndVersions ( List < DiscoveryNode > nodes , int allocationsFound , long highestVersion ) { this . nodes = nodes ; this . allocationsFound = allocationsFound ; this . highestVersion = highestVersion ; } } static class NodesToAllocate { final List < DiscoveryNode > yesNodes ; final List < DiscoveryNode > throttleNodes ; final List < DiscoveryNode > noNodes ; public NodesToAllocate ( List < DiscoveryNode > yesNodes , List < DiscoveryNode > throttleNodes , List < DiscoveryNode > noNodes ) { this . yesNodes = yesNodes ; this . throttleNodes = throttleNodes ; this . noNodes = noNodes ; } } } 
