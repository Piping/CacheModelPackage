package org . elasticsearch . index . cache . bitset ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . index . * ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . join . BitSetProducer ; import org . apache . lucene . store . RAMDirectory ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . BitSet ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . lucene . index . ElasticsearchDirectoryReader ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . IndicesWarmer ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import java . io . IOException ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import static org . hamcrest . Matchers . equalTo ; public class BitSetFilterCacheTests extends ESTestCase { private static final IndexSettings INDEX_SETTINGS = IndexSettingsModule . newIndexSettings ( new Index ( <str> ) , Settings . EMPTY ) ; private final IndicesWarmer warmer = new IndicesWarmer ( Settings . EMPTY , null ) ; private static int matchCount ( BitSetProducer producer , IndexReader reader ) throws IOException { int count = <int> ; for ( LeafReaderContext ctx : reader . leaves ( ) ) { final BitSet bitSet = producer . getBitSet ( ctx ) ; if ( bitSet ! = null ) { count + = bitSet . cardinality ( ) ; } } return count ; } public void testInvalidateEntries ( ) throws Exception { IndexWriter writer = new IndexWriter ( new RAMDirectory ( ) , new IndexWriterConfig ( new StandardAnalyzer ( ) ) . setMergePolicy ( new LogByteSizeMergePolicy ( ) ) ) ; Document document = new Document ( ) ; document . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; writer . addDocument ( document ) ; writer . commit ( ) ; document = new Document ( ) ; document . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; writer . addDocument ( document ) ; writer . commit ( ) ; document = new Document ( ) ; document . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; writer . addDocument ( document ) ; writer . commit ( ) ; IndexReader reader = DirectoryReader . open ( writer , false ) ; IndexSearcher searcher = new IndexSearcher ( reader ) ; BitsetFilterCache cache = new BitsetFilterCache ( INDEX_SETTINGS , warmer , new BitsetFilterCache . Listener ( ) { @Override public void onCache ( ShardId shardId , Accountable accountable ) { } @Override public void onRemoval ( ShardId shardId , Accountable accountable ) { } } ) ; BitSetProducer filter = cache . getBitSetProducer ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; assertThat ( matchCount ( filter , reader ) , equalTo ( <int> ) ) ; assertThat ( matchCount ( filter , reader ) , equalTo ( <int> ) ) ; assertThat ( cache . getLoadedFilters ( ) . weight ( ) , equalTo ( <int> ) ) ; writer . forceMerge ( <int> ) ; reader . close ( ) ; reader = DirectoryReader . open ( writer , false ) ; searcher = new IndexSearcher ( reader ) ; assertThat ( matchCount ( filter , reader ) , equalTo ( <int> ) ) ; assertThat ( matchCount ( filter , reader ) , equalTo ( <int> ) ) ; assertThat ( cache . getLoadedFilters ( ) . weight ( ) , equalTo ( <int> ) ) ; reader . close ( ) ; writer . close ( ) ; assertThat ( cache . getLoadedFilters ( ) . weight ( ) , equalTo ( <int> L ) ) ; } public void testListener ( ) throws IOException { IndexWriter writer = new IndexWriter ( new RAMDirectory ( ) , new IndexWriterConfig ( new StandardAnalyzer ( ) ) . setMergePolicy ( new LogByteSizeMergePolicy ( ) ) ) ; Document document = new Document ( ) ; document . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; writer . addDocument ( document ) ; writer . commit ( ) ; final DirectoryReader writerReader = DirectoryReader . open ( writer , false ) ; final IndexReader reader = randomBoolean ( ) ? writerReader : ElasticsearchDirectoryReader . wrap ( writerReader , new ShardId ( <str> , <int> ) ) ; final AtomicLong stats = new AtomicLong ( ) ; final AtomicInteger onCacheCalls = new AtomicInteger ( ) ; final AtomicInteger onRemoveCalls = new AtomicInteger ( ) ; final BitsetFilterCache cache = new BitsetFilterCache ( INDEX_SETTINGS , warmer , new BitsetFilterCache . Listener ( ) { @Override public void onCache ( ShardId shardId , Accountable accountable ) { onCacheCalls . incrementAndGet ( ) ; stats . addAndGet ( accountable . ramBytesUsed ( ) ) ; if ( writerReader ! = reader ) { assertNotNull ( shardId ) ; assertEquals ( <str> , shardId . index ( ) . name ( ) ) ; assertEquals ( <int> , shardId . id ( ) ) ; } else { assertNull ( shardId ) ; } } @Override public void onRemoval ( ShardId shardId , Accountable accountable ) { onRemoveCalls . incrementAndGet ( ) ; stats . addAndGet ( - accountable . ramBytesUsed ( ) ) ; if ( writerReader ! = reader ) { assertNotNull ( shardId ) ; assertEquals ( <str> , shardId . index ( ) . name ( ) ) ; assertEquals ( <int> , shardId . id ( ) ) ; } else { assertNull ( shardId ) ; } } } ) ; BitSetProducer filter = cache . getBitSetProducer ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; assertThat ( matchCount ( filter , reader ) , equalTo ( <int> ) ) ; assertTrue ( stats . get ( ) > <int> ) ; assertEquals ( <int> , onCacheCalls . get ( ) ) ; assertEquals ( <int> , onRemoveCalls . get ( ) ) ; IOUtils . close ( reader , writer ) ; assertEquals ( <int> , onRemoveCalls . get ( ) ) ; assertEquals ( <int> , stats . get ( ) ) ; } public void testSetNullListener ( ) { try { new BitsetFilterCache ( INDEX_SETTINGS , warmer , null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { assertEquals ( <str> , ex . getMessage ( ) ) ; } } } 
