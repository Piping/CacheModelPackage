package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import static com . google . common . collect . BoundType . CLOSED ; import com . google . common . primitives . Ints ; import java . util . Comparator ; import javax . annotation . Nullable ; @SuppressWarnings ( <str> ) final class RegularImmutableSortedMultiset < E > extends ImmutableSortedMultiset < E > { private static final long [ ] ZERO_CUMULATIVE_COUNTS = { <int> } ; static final ImmutableSortedMultiset < Comparable > NATURAL_EMPTY_MULTISET = new RegularImmutableSortedMultiset < Comparable > ( Ordering . natural ( ) ) ; private final transient RegularImmutableSortedSet < E > elementSet ; private final transient long [ ] cumulativeCounts ; private final transient int offset ; private final transient int length ; RegularImmutableSortedMultiset ( Comparator < ? super E > comparator ) { this . elementSet = ImmutableSortedSet . emptySet ( comparator ) ; this . cumulativeCounts = ZERO_CUMULATIVE_COUNTS ; this . offset = <int> ; this . length = <int> ; } RegularImmutableSortedMultiset ( RegularImmutableSortedSet < E > elementSet , long [ ] cumulativeCounts , int offset , int length ) { this . elementSet = elementSet ; this . cumulativeCounts = cumulativeCounts ; this . offset = offset ; this . length = length ; } private int getCount ( int index ) { return ( int ) ( cumulativeCounts [ offset + index + <int> ] - cumulativeCounts [ offset + index ] ) ; } @Override Entry < E > getEntry ( int index ) { return Multisets . immutableEntry ( elementSet . asList ( ) . get ( index ) , getCount ( index ) ) ; } @Override public Entry < E > firstEntry ( ) { return isEmpty ( ) ? null : getEntry ( <int> ) ; } @Override public Entry < E > lastEntry ( ) { return isEmpty ( ) ? null : getEntry ( length - <int> ) ; } @Override public int count ( @Nullable Object element ) { int index = elementSet . indexOf ( element ) ; return ( index > = <int> ) ? getCount ( index ) : <int> ; } @Override public int size ( ) { long size = cumulativeCounts [ offset + length ] - cumulativeCounts [ offset ] ; return Ints . saturatedCast ( size ) ; } @Override public ImmutableSortedSet < E > elementSet ( ) { return elementSet ; } @Override public ImmutableSortedMultiset < E > headMultiset ( E upperBound , BoundType boundType ) { return getSubMultiset ( <int> , elementSet . headIndex ( upperBound , checkNotNull ( boundType ) = = CLOSED ) ) ; } @Override public ImmutableSortedMultiset < E > tailMultiset ( E lowerBound , BoundType boundType ) { return getSubMultiset ( elementSet . tailIndex ( lowerBound , checkNotNull ( boundType ) = = CLOSED ) , length ) ; } ImmutableSortedMultiset < E > getSubMultiset ( int from , int to ) { checkPositionIndexes ( from , to , length ) ; if ( from = = to ) { return emptyMultiset ( comparator ( ) ) ; } else if ( from = = <int> & & to = = length ) { return this ; } else { RegularImmutableSortedSet < E > subElementSet = ( RegularImmutableSortedSet < E > ) elementSet . getSubSet ( from , to ) ; return new RegularImmutableSortedMultiset < E > ( subElementSet , cumulativeCounts , offset + from , to - from ) ; } } @Override boolean isPartialView ( ) { return offset > <int> | | length < cumulativeCounts . length - <int> ; } } 
