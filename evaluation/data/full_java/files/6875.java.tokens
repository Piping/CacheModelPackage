package org . elasticsearch . indices . recovery ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RestoreSource ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; public class RecoveryState implements ToXContent , Streamable { public static enum Stage { INIT ( ( byte ) <int> ) , INDEX ( ( byte ) <int> ) , VERIFY_INDEX ( ( byte ) <int> ) , TRANSLOG ( ( byte ) <int> ) , FINALIZE ( ( byte ) <int> ) , DONE ( ( byte ) <int> ) ; private static final Stage [ ] STAGES = new Stage [ Stage . values ( ) . length ] ; static { for ( Stage stage : Stage . values ( ) ) { assert stage . id ( ) < STAGES . length & & stage . id ( ) > = <int> ; STAGES [ stage . id ] = stage ; } } private final byte id ; Stage ( byte id ) { this . id = id ; } public byte id ( ) { return id ; } public static Stage fromId ( byte id ) { if ( id < <int> | | id > = STAGES . length ) { throw new IllegalArgumentException ( <str> + id + <str> ) ; } return STAGES [ id ] ; } } public static enum Type { STORE ( ( byte ) <int> ) , SNAPSHOT ( ( byte ) <int> ) , REPLICA ( ( byte ) <int> ) , RELOCATION ( ( byte ) <int> ) ; private static final Type [ ] TYPES = new Type [ Type . values ( ) . length ] ; static { for ( Type type : Type . values ( ) ) { assert type . id ( ) < TYPES . length & & type . id ( ) > = <int> ; TYPES [ type . id ] = type ; } } private final byte id ; Type ( byte id ) { this . id = id ; } public byte id ( ) { return id ; } public static Type fromId ( byte id ) { if ( id < <int> | | id > = TYPES . length ) { throw new IllegalArgumentException ( <str> + id + <str> ) ; } return TYPES [ id ] ; } } private Stage stage ; private final Index index = new Index ( ) ; private final Translog translog = new Translog ( ) ; private final VerifyIndex verifyIndex = new VerifyIndex ( ) ; private final Timer timer = new Timer ( ) ; private Type type ; private ShardId shardId ; private RestoreSource restoreSource ; private DiscoveryNode sourceNode ; private DiscoveryNode targetNode ; private boolean primary = false ; private RecoveryState ( ) { } public RecoveryState ( ShardId shardId , boolean primary , Type type , DiscoveryNode sourceNode , DiscoveryNode targetNode ) { this ( shardId , primary , type , sourceNode , null , targetNode ) ; } public RecoveryState ( ShardId shardId , boolean primary , Type type , RestoreSource restoreSource , DiscoveryNode targetNode ) { this ( shardId , primary , type , null , restoreSource , targetNode ) ; } private RecoveryState ( ShardId shardId , boolean primary , Type type , @Nullable DiscoveryNode sourceNode , @Nullable RestoreSource restoreSource , DiscoveryNode targetNode ) { this . shardId = shardId ; this . primary = primary ; this . type = type ; this . sourceNode = sourceNode ; this . restoreSource = restoreSource ; this . targetNode = targetNode ; stage = Stage . INIT ; timer . start ( ) ; } public ShardId getShardId ( ) { return shardId ; } public synchronized Stage getStage ( ) { return this . stage ; } private void validateAndSetStage ( Stage expected , Stage next ) { if ( stage ! = expected ) { throw new IllegalStateException ( <str> + next + <str> + stage + <str> + expected + <str> ) ; } stage = next ; } public synchronized RecoveryState setStage ( Stage stage ) { switch ( stage ) { case INIT : this . stage = Stage . INIT ; getIndex ( ) . reset ( ) ; getVerifyIndex ( ) . reset ( ) ; getTranslog ( ) . reset ( ) ; break ; case INDEX : validateAndSetStage ( Stage . INIT , stage ) ; getIndex ( ) . start ( ) ; break ; case VERIFY_INDEX : validateAndSetStage ( Stage . INDEX , stage ) ; getIndex ( ) . stop ( ) ; getVerifyIndex ( ) . start ( ) ; break ; case TRANSLOG : validateAndSetStage ( Stage . VERIFY_INDEX , stage ) ; getVerifyIndex ( ) . stop ( ) ; getTranslog ( ) . start ( ) ; break ; case FINALIZE : validateAndSetStage ( Stage . TRANSLOG , stage ) ; getTranslog ( ) . stop ( ) ; break ; case DONE : validateAndSetStage ( Stage . FINALIZE , stage ) ; getTimer ( ) . stop ( ) ; break ; default : throw new IllegalArgumentException ( <str> + stage + <str> ) ; } return this ; } public Index getIndex ( ) { return index ; } public VerifyIndex getVerifyIndex ( ) { return this . verifyIndex ; } public Translog getTranslog ( ) { return translog ; } public Timer getTimer ( ) { return timer ; } public Type getType ( ) { return type ; } public DiscoveryNode getSourceNode ( ) { return sourceNode ; } public DiscoveryNode getTargetNode ( ) { return targetNode ; } public RestoreSource getRestoreSource ( ) { return restoreSource ; } public boolean getPrimary ( ) { return primary ; } public static RecoveryState readRecoveryState ( StreamInput in ) throws IOException { RecoveryState recoveryState = new RecoveryState ( ) ; recoveryState . readFrom ( in ) ; return recoveryState ; } @Override public synchronized void readFrom ( StreamInput in ) throws IOException { timer . readFrom ( in ) ; type = Type . fromId ( in . readByte ( ) ) ; stage = Stage . fromId ( in . readByte ( ) ) ; shardId = ShardId . readShardId ( in ) ; restoreSource = RestoreSource . readOptionalRestoreSource ( in ) ; targetNode = DiscoveryNode . readNode ( in ) ; if ( in . readBoolean ( ) ) { sourceNode = DiscoveryNode . readNode ( in ) ; } index . readFrom ( in ) ; translog . readFrom ( in ) ; verifyIndex . readFrom ( in ) ; primary = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { timer . writeTo ( out ) ; out . writeByte ( type . id ( ) ) ; out . writeByte ( stage . id ( ) ) ; shardId . writeTo ( out ) ; out . writeOptionalStreamable ( restoreSource ) ; targetNode . writeTo ( out ) ; out . writeBoolean ( sourceNode ! = null ) ; if ( sourceNode ! = null ) { sourceNode . writeTo ( out ) ; } index . writeTo ( out ) ; translog . writeTo ( out ) ; verifyIndex . writeTo ( out ) ; out . writeBoolean ( primary ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . ID , shardId . id ( ) ) ; builder . field ( Fields . TYPE , type . toString ( ) ) ; builder . field ( Fields . STAGE , stage . toString ( ) ) ; builder . field ( Fields . PRIMARY , primary ) ; builder . dateValueField ( Fields . START_TIME_IN_MILLIS , Fields . START_TIME , timer . startTime ) ; if ( timer . stopTime > <int> ) { builder . dateValueField ( Fields . STOP_TIME_IN_MILLIS , Fields . STOP_TIME , timer . stopTime ) ; } builder . timeValueField ( Fields . TOTAL_TIME_IN_MILLIS , Fields . TOTAL_TIME , timer . time ( ) ) ; if ( restoreSource ! = null ) { builder . field ( Fields . SOURCE ) ; restoreSource . toXContent ( builder , params ) ; } else { builder . startObject ( Fields . SOURCE ) ; builder . field ( Fields . ID , sourceNode . id ( ) ) ; builder . field ( Fields . HOST , sourceNode . getHostName ( ) ) ; builder . field ( Fields . TRANSPORT_ADDRESS , sourceNode . address ( ) . toString ( ) ) ; builder . field ( Fields . IP , sourceNode . getHostAddress ( ) ) ; builder . field ( Fields . NAME , sourceNode . name ( ) ) ; builder . endObject ( ) ; } builder . startObject ( Fields . TARGET ) ; builder . field ( Fields . ID , targetNode . id ( ) ) ; builder . field ( Fields . HOST , targetNode . getHostName ( ) ) ; builder . field ( Fields . TRANSPORT_ADDRESS , targetNode . address ( ) . toString ( ) ) ; builder . field ( Fields . IP , targetNode . getHostAddress ( ) ) ; builder . field ( Fields . NAME , targetNode . name ( ) ) ; builder . endObject ( ) ; builder . startObject ( Fields . INDEX ) ; index . toXContent ( builder , params ) ; builder . endObject ( ) ; builder . startObject ( Fields . TRANSLOG ) ; translog . toXContent ( builder , params ) ; builder . endObject ( ) ; builder . startObject ( Fields . VERIFY_INDEX ) ; verifyIndex . toXContent ( builder , params ) ; builder . endObject ( ) ; return builder ; } static final class Fields { static final XContentBuilderString ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TYPE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STAGE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PRIMARY = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STOP_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STOP_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SOURCE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HOST = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TRANSPORT_ADDRESS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString IP = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TARGET = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDEX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TRANSLOG = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_ON_START = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VERIFY_INDEX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString RECOVERED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString RECOVERED_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString CHECK_INDEX_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString CHECK_INDEX_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString LENGTH = new XContentBuilderString ( <str> ) ; static final XContentBuilderString LENGTH_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FILES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString REUSED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString REUSED_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PERCENT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DETAILS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SIZE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SOURCE_THROTTLE_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SOURCE_THROTTLE_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TARGET_THROTTLE_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TARGET_THROTTLE_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; } public static class Timer implements Streamable { protected long startTime = <int> ; protected long startNanoTime = <int> ; protected long time = - <int> ; protected long stopTime = <int> ; public synchronized void start ( ) { assert startTime = = <int> : <str> ; startTime = System . currentTimeMillis ( ) ; startNanoTime = System . nanoTime ( ) ; } public synchronized long startTime ( ) { return startTime ; } public synchronized long time ( ) { if ( startNanoTime = = <int> ) { return <int> ; } if ( time > = <int> ) { return time ; } return Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - startNanoTime ) ) ; } public synchronized long stopTime ( ) { return stopTime ; } public synchronized void stop ( ) { assert stopTime = = <int> : <str> ; stopTime = Math . max ( System . currentTimeMillis ( ) , startTime ) ; time = TimeValue . nsecToMSec ( System . nanoTime ( ) - startNanoTime ) ; assert time > = <int> ; } public synchronized void reset ( ) { startTime = <int> ; startNanoTime = <int> ; time = - <int> ; stopTime = <int> ; } @Override public synchronized void readFrom ( StreamInput in ) throws IOException { startTime = in . readVLong ( ) ; startNanoTime = in . readVLong ( ) ; stopTime = in . readVLong ( ) ; time = in . readVLong ( ) ; } @Override public synchronized void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( startTime ) ; out . writeVLong ( startNanoTime ) ; out . writeVLong ( stopTime ) ; out . writeVLong ( time ( ) ) ; } } public static class VerifyIndex extends Timer implements ToXContent , Streamable { private volatile long checkIndexTime ; public void reset ( ) { super . reset ( ) ; checkIndexTime = <int> ; } public long checkIndexTime ( ) { return checkIndexTime ; } public void checkIndexTime ( long checkIndexTime ) { this . checkIndexTime = checkIndexTime ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; checkIndexTime = in . readVLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVLong ( checkIndexTime ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . timeValueField ( Fields . CHECK_INDEX_TIME_IN_MILLIS , Fields . CHECK_INDEX_TIME , checkIndexTime ) ; builder . timeValueField ( Fields . TOTAL_TIME_IN_MILLIS , Fields . TOTAL_TIME , time ( ) ) ; return builder ; } } public static class Translog extends Timer implements ToXContent , Streamable { public static final int UNKNOWN = - <int> ; private int recovered ; private int total = UNKNOWN ; private int totalOnStart = UNKNOWN ; public synchronized void reset ( ) { super . reset ( ) ; recovered = <int> ; total = UNKNOWN ; totalOnStart = UNKNOWN ; } public synchronized void incrementRecoveredOperations ( ) { recovered + + ; assert total = = UNKNOWN | | total > = recovered : <str> + total + <str> + recovered + <str> ; } public synchronized void decrementRecoveredOperations ( int ops ) { recovered - = ops ; assert recovered > = <int> : <str> + recovered + <str> + ops + <str> ; assert total = = UNKNOWN | | total > = recovered : <str> + total + <str> + recovered + <str> ; } public synchronized int recoveredOperations ( ) { return recovered ; } public synchronized int totalOperations ( ) { return total ; } public synchronized void totalOperations ( int total ) { this . total = total ; assert total = = UNKNOWN | | total > = recovered : <str> + total + <str> + recovered + <str> ; } public synchronized int totalOperationsOnStart ( ) { return this . totalOnStart ; } public synchronized void totalOperationsOnStart ( int total ) { this . totalOnStart = total ; } public synchronized float recoveredPercent ( ) { if ( total = = UNKNOWN ) { return - <float> ; } if ( total = = <int> ) { return <float> ; } return recovered * <float> / total ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; recovered = in . readVInt ( ) ; total = in . readVInt ( ) ; totalOnStart = in . readVInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( recovered ) ; out . writeVInt ( total ) ; out . writeVInt ( totalOnStart ) ; } @Override public synchronized XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . RECOVERED , recovered ) ; builder . field ( Fields . TOTAL , total ) ; builder . field ( Fields . PERCENT , String . format ( Locale . ROOT , <str> , recoveredPercent ( ) ) ) ; builder . field ( Fields . TOTAL_ON_START , totalOnStart ) ; builder . timeValueField ( Fields . TOTAL_TIME_IN_MILLIS , Fields . TOTAL_TIME , time ( ) ) ; return builder ; } } public static class File implements ToXContent , Streamable { private String name ; private long length ; private long recovered ; private boolean reused ; public File ( ) { } public File ( String name , long length , boolean reused ) { assert name ! = null ; this . name = name ; this . length = length ; this . reused = reused ; } void addRecoveredBytes ( long bytes ) { assert reused = = false : <str> ; assert bytes > = <int> : <str> + bytes + <str> ; recovered + = bytes ; } public String name ( ) { return name ; } public long length ( ) { return length ; } public long recovered ( ) { return recovered ; } public boolean reused ( ) { return reused ; } boolean fullyRecovered ( ) { return reused = = false & & length = = recovered ; } public static File readFile ( StreamInput in ) throws IOException { File file = new File ( ) ; file . readFrom ( in ) ; return file ; } @Override public void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; length = in . readVLong ( ) ; recovered = in . readVLong ( ) ; reused = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeVLong ( length ) ; out . writeVLong ( recovered ) ; out . writeBoolean ( reused ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( Fields . NAME , name ) ; builder . byteSizeField ( Fields . LENGTH_IN_BYTES , Fields . LENGTH , length ) ; builder . field ( Fields . REUSED , reused ) ; builder . byteSizeField ( Fields . RECOVERED_IN_BYTES , Fields . RECOVERED , recovered ) ; builder . endObject ( ) ; return builder ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof File ) { File other = ( File ) obj ; return name . equals ( other . name ) & & length = = other . length ( ) & & reused = = other . reused ( ) & & recovered = = other . recovered ( ) ; } return false ; } @Override public int hashCode ( ) { int result = name . hashCode ( ) ; result = <int> * result + Long . hashCode ( length ) ; result = <int> * result + Long . hashCode ( recovered ) ; result = <int> * result + ( reused ? <int> : <int> ) ; return result ; } @Override public String toString ( ) { return <str> + name + <str> + reused + <str> + length + <str> + recovered + <str> ; } } public static class Index extends Timer implements ToXContent , Streamable { private Map < String , File > fileDetails = new HashMap < > ( ) ; public final static long UNKNOWN = - <int> ; private long version = UNKNOWN ; private long sourceThrottlingInNanos = UNKNOWN ; private long targetThrottleTimeInNanos = UNKNOWN ; public synchronized List < File > fileDetails ( ) { return Collections . unmodifiableList ( new ArrayList < > ( fileDetails . values ( ) ) ) ; } public synchronized void reset ( ) { super . reset ( ) ; version = UNKNOWN ; fileDetails . clear ( ) ; sourceThrottlingInNanos = UNKNOWN ; targetThrottleTimeInNanos = UNKNOWN ; } public synchronized void addFileDetail ( String name , long length , boolean reused ) { File file = new File ( name , length , reused ) ; File existing = fileDetails . put ( name , file ) ; assert existing = = null : <str> + name + <str> ; } public synchronized void addRecoveredBytesToFile ( String name , long bytes ) { File file = fileDetails . get ( name ) ; file . addRecoveredBytes ( bytes ) ; } public synchronized long version ( ) { return this . version ; } public synchronized void addSourceThrottling ( long timeInNanos ) { if ( sourceThrottlingInNanos = = UNKNOWN ) { sourceThrottlingInNanos = timeInNanos ; } else { sourceThrottlingInNanos + = timeInNanos ; } } public synchronized void addTargetThrottling ( long timeInNanos ) { if ( targetThrottleTimeInNanos = = UNKNOWN ) { targetThrottleTimeInNanos = timeInNanos ; } else { targetThrottleTimeInNanos + = timeInNanos ; } } public synchronized TimeValue sourceThrottling ( ) { return TimeValue . timeValueNanos ( sourceThrottlingInNanos ) ; } public synchronized TimeValue targetThrottling ( ) { return TimeValue . timeValueNanos ( targetThrottleTimeInNanos ) ; } public synchronized int totalFileCount ( ) { return fileDetails . size ( ) ; } public synchronized int totalRecoverFiles ( ) { int total = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) = = false ) { total + + ; } } return total ; } public synchronized int recoveredFileCount ( ) { int count = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . fullyRecovered ( ) ) { count + + ; } } return count ; } public synchronized float recoveredFilesPercent ( ) { int total = <int> ; int recovered = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) = = false ) { total + + ; if ( file . fullyRecovered ( ) ) { recovered + + ; } } } if ( total = = <int> & & fileDetails . size ( ) = = <int> ) { return <float> ; } if ( total = = recovered ) { return <float> ; } else { float result = <float> * ( recovered / ( float ) total ) ; return result ; } } public synchronized long totalBytes ( ) { long total = <int> ; for ( File file : fileDetails . values ( ) ) { total + = file . length ( ) ; } return total ; } public synchronized long recoveredBytes ( ) { long recovered = <int> ; for ( File file : fileDetails . values ( ) ) { recovered + = file . recovered ( ) ; } return recovered ; } public synchronized long totalRecoverBytes ( ) { long total = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) = = false ) { total + = file . length ( ) ; } } return total ; } public synchronized long totalReuseBytes ( ) { long total = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) ) { total + = file . length ( ) ; } } return total ; } public synchronized float recoveredBytesPercent ( ) { long total = <int> ; long recovered = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) = = false ) { total + = file . length ( ) ; recovered + = file . recovered ( ) ; } } if ( total = = <int> & & fileDetails . size ( ) = = <int> ) { return <float> ; } if ( total = = recovered ) { return <float> ; } else { return <float> * recovered / total ; } } public synchronized int reusedFileCount ( ) { int reused = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) ) { reused + + ; } } return reused ; } public synchronized long reusedBytes ( ) { long reused = <int> ; for ( File file : fileDetails . values ( ) ) { if ( file . reused ( ) ) { reused + = file . length ( ) ; } } return reused ; } public synchronized void updateVersion ( long version ) { this . version = version ; } @Override public synchronized void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { File file = File . readFile ( in ) ; fileDetails . put ( file . name , file ) ; } sourceThrottlingInNanos = in . readLong ( ) ; targetThrottleTimeInNanos = in . readLong ( ) ; } @Override public synchronized void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; final File [ ] files = fileDetails . values ( ) . toArray ( new File [ <int> ] ) ; out . writeVInt ( files . length ) ; for ( File file : files ) { file . writeTo ( out ) ; } out . writeLong ( sourceThrottlingInNanos ) ; out . writeLong ( targetThrottleTimeInNanos ) ; } @Override public synchronized XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . SIZE ) ; builder . byteSizeField ( Fields . TOTAL_IN_BYTES , Fields . TOTAL , totalBytes ( ) ) ; builder . byteSizeField ( Fields . REUSED_IN_BYTES , Fields . REUSED , reusedBytes ( ) ) ; builder . byteSizeField ( Fields . RECOVERED_IN_BYTES , Fields . RECOVERED , recoveredBytes ( ) ) ; builder . field ( Fields . PERCENT , String . format ( Locale . ROOT , <str> , recoveredBytesPercent ( ) ) ) ; builder . endObject ( ) ; builder . startObject ( Fields . FILES ) ; builder . field ( Fields . TOTAL , totalFileCount ( ) ) ; builder . field ( Fields . REUSED , reusedFileCount ( ) ) ; builder . field ( Fields . RECOVERED , recoveredFileCount ( ) ) ; builder . field ( Fields . PERCENT , String . format ( Locale . ROOT , <str> , recoveredFilesPercent ( ) ) ) ; if ( params . paramAsBoolean ( <str> , false ) ) { builder . startArray ( Fields . DETAILS ) ; for ( File file : fileDetails . values ( ) ) { file . toXContent ( builder , params ) ; } builder . endArray ( ) ; } builder . endObject ( ) ; builder . timeValueField ( Fields . TOTAL_TIME_IN_MILLIS , Fields . TOTAL_TIME , time ( ) ) ; builder . timeValueField ( Fields . SOURCE_THROTTLE_TIME_IN_MILLIS , Fields . SOURCE_THROTTLE_TIME , sourceThrottling ( ) ) ; builder . timeValueField ( Fields . TARGET_THROTTLE_TIME_IN_MILLIS , Fields . TARGET_THROTTLE_TIME , targetThrottling ( ) ) ; return builder ; } @Override public synchronized String toString ( ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; toXContent ( builder , EMPTY_PARAMS ) ; builder . endObject ( ) ; return builder . string ( ) ; } catch ( IOException e ) { return <str> + e . getMessage ( ) + <str> ; } } } } 
