package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; @GwtCompatible ( emulated = true ) public class ImmutableTableTest extends AbstractTableReadTest { @Override protected Table < String , Integer , Character > create ( Object . . . data ) { ImmutableTable . Builder < String , Integer , Character > builder = ImmutableTable . builder ( ) ; for ( int i = <int> ; i < data . length ; i = i + <int> ) { builder . put ( ( String ) data [ i ] , ( Integer ) data [ i + <int> ] , ( Character ) data [ i + <int> ] ) ; } return builder . build ( ) ; } public void testBuilder ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) ; assertEquals ( ImmutableTable . of ( ) , builder . build ( ) ) ; assertEquals ( ImmutableTable . of ( <str> , <int> , <str> ) , builder . put ( <str> , <int> , <str> ) . build ( ) ) ; Table < Character , Integer , String > expectedTable = HashBasedTable . create ( ) ; expectedTable . put ( <str> , <int> , <str> ) ; expectedTable . put ( <str> , <int> , <str> ) ; expectedTable . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > otherTable = HashBasedTable . create ( ) ; otherTable . put ( <str> , <int> , <str> ) ; otherTable . put ( <str> , <int> , <str> ) ; assertEquals ( expectedTable , builder . putAll ( otherTable ) . build ( ) ) ; } public void testBuilder_withImmutableCell ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) ; assertEquals ( ImmutableTable . of ( <str> , <int> , <str> ) , builder . put ( Tables . immutableCell ( <str> , <int> , <str> ) ) . build ( ) ) ; } public void testBuilder_withImmutableCellAndNullContents ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) ; try { builder . put ( Tables . immutableCell ( ( Character ) null , <int> , <str> ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } try { builder . put ( Tables . immutableCell ( <str> , ( Integer ) null , <str> ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } try { builder . put ( Tables . immutableCell ( <str> , <int> , ( String ) null ) ) ; fail ( ) ; } catch ( NullPointerException e ) { } } private static class StringHolder { String string ; } public void testBuilder_withMutableCell ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) ; final StringHolder holder = new StringHolder ( ) ; holder . string = <str> ; Table . Cell < Character , Integer , String > mutableCell = new Tables . AbstractCell < Character , Integer , String > ( ) { @Override public Character getRowKey ( ) { return <str> ; } @Override public Integer getColumnKey ( ) { return <int> ; } @Override public String getValue ( ) { return holder . string ; } } ; builder . put ( mutableCell ) ; holder . string = <str> ; assertEquals ( ImmutableTable . of ( <str> , <int> , <str> ) , builder . build ( ) ) ; } public void testBuilder_noDuplicates ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) . put ( <str> , <int> , <str> ) . put ( <str> , <int> , <str> ) ; try { builder . build ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } } public void testBuilder_noNulls ( ) { ImmutableTable . Builder < Character , Integer , String > builder = new ImmutableTable . Builder < Character , Integer , String > ( ) ; try { builder . put ( null , <int> , <str> ) ; fail ( ) ; } catch ( NullPointerException e ) { } try { builder . put ( <str> , null , <str> ) ; fail ( ) ; } catch ( NullPointerException e ) { } try { builder . put ( <str> , <int> , null ) ; fail ( ) ; } catch ( NullPointerException e ) { } } private static < R , C , V > void validateTableCopies ( Table < R , C , V > original ) { Table < R , C , V > copy = ImmutableTable . copyOf ( original ) ; assertEquals ( original , copy ) ; validateViewOrdering ( original , copy ) ; Table < R , C , V > built = ImmutableTable . < R , C , V > builder ( ) . putAll ( original ) . build ( ) ; assertEquals ( original , built ) ; validateViewOrdering ( original , built ) ; } private static < R , C , V > void validateViewOrdering ( Table < R , C , V > original , Table < R , C , V > copy ) { assertTrue ( Iterables . elementsEqual ( original . cellSet ( ) , copy . cellSet ( ) ) ) ; assertTrue ( Iterables . elementsEqual ( original . rowKeySet ( ) , copy . rowKeySet ( ) ) ) ; assertTrue ( Iterables . elementsEqual ( original . values ( ) , copy . values ( ) ) ) ; } public void testCopyOf ( ) { Table < Character , Integer , String > table = TreeBasedTable . create ( ) ; validateTableCopies ( table ) ; table . put ( <str> , <int> , <str> ) ; validateTableCopies ( table ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; validateTableCopies ( table ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( ImmutableTable . copyOf ( table ) . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testCopyOfSparse ( ) { Table < Character , Integer , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; validateTableCopies ( table ) ; } public void testCopyOfDense ( ) { Table < Character , Integer , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; validateTableCopies ( table ) ; } public void testBuilder_orderRowsAndColumnsBy_putAll ( ) { Table < Character , Integer , String > table = HashBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; Table < Character , Integer , String > copy = builder . orderRowsBy ( Ordering . natural ( ) ) . orderColumnsBy ( Ordering . natural ( ) ) . putAll ( table ) . build ( ) ; assertThat ( copy . rowKeySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( copy . columnKeySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( copy . values ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( copy . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testBuilder_orderRowsAndColumnsBy_sparse ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderRowsBy ( Ordering . natural ( ) ) ; builder . orderColumnsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . columnKeySet ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( table . values ( ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( table . column ( <int> ) . keySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testBuilder_orderRowsAndColumnsBy_dense ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderRowsBy ( Ordering . natural ( ) ) ; builder . orderColumnsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . columnKeySet ( ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( table . values ( ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( table . column ( <int> ) . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testBuilder_orderRowsBy_sparse ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderRowsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . column ( <int> ) . keySet ( ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testBuilder_orderRowsBy_dense ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderRowsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . column ( <int> ) . keySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testBuilder_orderColumnsBy_sparse ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderColumnsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . columnKeySet ( ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testBuilder_orderColumnsBy_dense ( ) { ImmutableTable . Builder < Character , Integer , String > builder = ImmutableTable . builder ( ) ; builder . orderColumnsBy ( Ordering . natural ( ) ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; builder . put ( <str> , <int> , <str> ) ; Table < Character , Integer , String > table = builder . build ( ) ; assertThat ( table . columnKeySet ( ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testOverflowCondition ( ) { ImmutableTable . Builder < Integer , Integer , String > builder = ImmutableTable . builder ( ) ; for ( int i = <int> ; i < <hex> ; i + + ) { builder . put ( i , <int> , <str> ) ; builder . put ( <int> , i , <str> ) ; } assertTrue ( builder . build ( ) instanceof SparseImmutableTable ) ; } } 
