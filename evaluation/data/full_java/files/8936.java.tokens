package org . elasticsearch . cache . recycler ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . recycler . Recycler . V ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . threadpool . ThreadPool ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Random ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class MockPageCacheRecycler extends PageCacheRecycler { private static final ConcurrentMap < Object , Throwable > ACQUIRED_PAGES = new ConcurrentHashMap < > ( ) ; public static void ensureAllPagesAreReleased ( ) throws Exception { final Map < Object , Throwable > masterCopy = new HashMap < > ( ACQUIRED_PAGES ) ; if ( ! masterCopy . isEmpty ( ) ) { boolean success = ESTestCase . awaitBusy ( ( ) - > Sets . haveEmptyIntersection ( masterCopy . keySet ( ) , ACQUIRED_PAGES . keySet ( ) ) ) ; if ( ! success ) { masterCopy . keySet ( ) . retainAll ( ACQUIRED_PAGES . keySet ( ) ) ; ACQUIRED_PAGES . keySet ( ) . removeAll ( masterCopy . keySet ( ) ) ; if ( ! masterCopy . isEmpty ( ) ) { final Throwable t = masterCopy . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ; throw new RuntimeException ( masterCopy . size ( ) + <str> , t ) ; } } } } private final Random random ; @Inject public MockPageCacheRecycler ( Settings settings , ThreadPool threadPool ) { super ( settings , threadPool ) ; final long seed = settings . getAsLong ( InternalTestCluster . SETTING_CLUSTER_NODE_SEED , <int> L ) ; random = new Random ( seed ) ; } private < T > V < T > wrap ( final V < T > v ) { ACQUIRED_PAGES . put ( v , new Throwable ( ) ) ; return new V < T > ( ) { @Override public void close ( ) { final Throwable t = ACQUIRED_PAGES . remove ( v ) ; if ( t = = null ) { throw new IllegalStateException ( <str> ) ; } final T ref = v ( ) ; if ( ref instanceof Object [ ] ) { Arrays . fill ( ( Object [ ] ) ref , <int> , Array . getLength ( ref ) , null ) ; } else if ( ref instanceof byte [ ] ) { Arrays . fill ( ( byte [ ] ) ref , <int> , Array . getLength ( ref ) , ( byte ) random . nextInt ( <int> ) ) ; } else if ( ref instanceof long [ ] ) { Arrays . fill ( ( long [ ] ) ref , <int> , Array . getLength ( ref ) , random . nextLong ( ) ) ; } else if ( ref instanceof int [ ] ) { Arrays . fill ( ( int [ ] ) ref , <int> , Array . getLength ( ref ) , random . nextInt ( ) ) ; } else if ( ref instanceof double [ ] ) { Arrays . fill ( ( double [ ] ) ref , <int> , Array . getLength ( ref ) , random . nextDouble ( ) - <float> ) ; } else if ( ref instanceof float [ ] ) { Arrays . fill ( ( float [ ] ) ref , <int> , Array . getLength ( ref ) , random . nextFloat ( ) - <float> ) ; } else { for ( int i = <int> ; i < Array . getLength ( ref ) ; + + i ) { Array . set ( ref , i , ( byte ) random . nextInt ( <int> ) ) ; } } v . close ( ) ; } @Override public T v ( ) { return v . v ( ) ; } @Override public boolean isRecycled ( ) { return v . isRecycled ( ) ; } } ; } @Override public V < byte [ ] > bytePage ( boolean clear ) { final V < byte [ ] > page = super . bytePage ( clear ) ; if ( ! clear ) { Arrays . fill ( page . v ( ) , <int> , page . v ( ) . length , ( byte ) random . nextInt ( <int> < < <int> ) ) ; } return wrap ( page ) ; } @Override public V < int [ ] > intPage ( boolean clear ) { final V < int [ ] > page = super . intPage ( clear ) ; if ( ! clear ) { Arrays . fill ( page . v ( ) , <int> , page . v ( ) . length , random . nextInt ( ) ) ; } return wrap ( page ) ; } @Override public V < long [ ] > longPage ( boolean clear ) { final V < long [ ] > page = super . longPage ( clear ) ; if ( ! clear ) { Arrays . fill ( page . v ( ) , <int> , page . v ( ) . length , random . nextLong ( ) ) ; } return wrap ( page ) ; } @Override public V < Object [ ] > objectPage ( ) { return wrap ( super . objectPage ( ) ) ; } } 
