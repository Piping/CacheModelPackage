package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . util . concurrent . Service . State . FAILED ; import static com . google . common . util . concurrent . Service . State . NEW ; import static com . google . common . util . concurrent . Service . State . RUNNING ; import static com . google . common . util . concurrent . Service . State . STARTING ; import static com . google . common . util . concurrent . Service . State . STOPPING ; import static com . google . common . util . concurrent . Service . State . TERMINATED ; import com . google . common . annotations . Beta ; import com . google . common . util . concurrent . ListenerCallQueue . Callback ; import com . google . common . util . concurrent . Monitor . Guard ; import com . google . common . util . concurrent . Service . State ; import com . google . j2objc . annotations . WeakOuter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import javax . annotation . Nullable ; import javax . annotation . concurrent . GuardedBy ; import javax . annotation . concurrent . Immutable ; @Beta public abstract class AbstractService implements Service { private static final Callback < Listener > STARTING_CALLBACK = new Callback < Listener > ( <str> ) { @Override void call ( Listener listener ) { listener . starting ( ) ; } } ; private static final Callback < Listener > RUNNING_CALLBACK = new Callback < Listener > ( <str> ) { @Override void call ( Listener listener ) { listener . running ( ) ; } } ; private static final Callback < Listener > STOPPING_FROM_STARTING_CALLBACK = stoppingCallback ( STARTING ) ; private static final Callback < Listener > STOPPING_FROM_RUNNING_CALLBACK = stoppingCallback ( RUNNING ) ; private static final Callback < Listener > TERMINATED_FROM_NEW_CALLBACK = terminatedCallback ( NEW ) ; private static final Callback < Listener > TERMINATED_FROM_RUNNING_CALLBACK = terminatedCallback ( RUNNING ) ; private static final Callback < Listener > TERMINATED_FROM_STOPPING_CALLBACK = terminatedCallback ( STOPPING ) ; private static Callback < Listener > terminatedCallback ( final State from ) { return new Callback < Listener > ( <str> + from + <str> ) { @Override void call ( Listener listener ) { listener . terminated ( from ) ; } } ; } private static Callback < Listener > stoppingCallback ( final State from ) { return new Callback < Listener > ( <str> + from + <str> ) { @Override void call ( Listener listener ) { listener . stopping ( from ) ; } } ; } private final Monitor monitor = new Monitor ( ) ; private final Guard isStartable = new IsStartableGuard ( ) ; @WeakOuter private final class IsStartableGuard extends Guard { IsStartableGuard ( ) { super ( AbstractService . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return state ( ) = = NEW ; } } private final Guard isStoppable = new IsStoppableGuard ( ) ; @WeakOuter private final class IsStoppableGuard extends Guard { IsStoppableGuard ( ) { super ( AbstractService . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return state ( ) . compareTo ( RUNNING ) < = <int> ; } } private final Guard hasReachedRunning = new HasReachedRunningGuard ( ) ; @WeakOuter private final class HasReachedRunningGuard extends Guard { HasReachedRunningGuard ( ) { super ( AbstractService . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return state ( ) . compareTo ( RUNNING ) > = <int> ; } } private final Guard isStopped = new IsStoppedGuard ( ) ; @WeakOuter private final class IsStoppedGuard extends Guard { IsStoppedGuard ( ) { super ( AbstractService . this . monitor ) ; } @Override public boolean isSatisfied ( ) { return state ( ) . isTerminal ( ) ; } } @GuardedBy ( <str> ) private final List < ListenerCallQueue < Listener > > listeners = Collections . synchronizedList ( new ArrayList < ListenerCallQueue < Listener > > ( ) ) ; @GuardedBy ( <str> ) private volatile StateSnapshot snapshot = new StateSnapshot ( NEW ) ; protected AbstractService ( ) { } protected abstract void doStart ( ) ; protected abstract void doStop ( ) ; @Override public final Service startAsync ( ) { if ( monitor . enterIf ( isStartable ) ) { try { snapshot = new StateSnapshot ( STARTING ) ; starting ( ) ; doStart ( ) ; } catch ( Throwable startupFailure ) { notifyFailed ( startupFailure ) ; } finally { monitor . leave ( ) ; executeListeners ( ) ; } } else { throw new IllegalStateException ( <str> + this + <str> ) ; } return this ; } @Override public final Service stopAsync ( ) { if ( monitor . enterIf ( isStoppable ) ) { try { State previous = state ( ) ; switch ( previous ) { case NEW : snapshot = new StateSnapshot ( TERMINATED ) ; terminated ( NEW ) ; break ; case STARTING : snapshot = new StateSnapshot ( STARTING , true , null ) ; stopping ( STARTING ) ; break ; case RUNNING : snapshot = new StateSnapshot ( STOPPING ) ; stopping ( RUNNING ) ; doStop ( ) ; break ; case STOPPING : case TERMINATED : case FAILED : throw new AssertionError ( <str> + previous ) ; default : throw new AssertionError ( <str> + previous ) ; } } catch ( Throwable shutdownFailure ) { notifyFailed ( shutdownFailure ) ; } finally { monitor . leave ( ) ; executeListeners ( ) ; } } return this ; } @Override public final void awaitRunning ( ) { monitor . enterWhenUninterruptibly ( hasReachedRunning ) ; try { checkCurrentState ( RUNNING ) ; } finally { monitor . leave ( ) ; } } @Override public final void awaitRunning ( long timeout , TimeUnit unit ) throws TimeoutException { if ( monitor . enterWhenUninterruptibly ( hasReachedRunning , timeout , unit ) ) { try { checkCurrentState ( RUNNING ) ; } finally { monitor . leave ( ) ; } } else { throw new TimeoutException ( <str> + this + <str> ) ; } } @Override public final void awaitTerminated ( ) { monitor . enterWhenUninterruptibly ( isStopped ) ; try { checkCurrentState ( TERMINATED ) ; } finally { monitor . leave ( ) ; } } @Override public final void awaitTerminated ( long timeout , TimeUnit unit ) throws TimeoutException { if ( monitor . enterWhenUninterruptibly ( isStopped , timeout , unit ) ) { try { checkCurrentState ( TERMINATED ) ; } finally { monitor . leave ( ) ; } } else { throw new TimeoutException ( <str> + this + <str> + <str> + state ( ) ) ; } } @GuardedBy ( <str> ) private void checkCurrentState ( State expected ) { State actual = state ( ) ; if ( actual ! = expected ) { if ( actual = = FAILED ) { throw new IllegalStateException ( <str> + expected + <str> , failureCause ( ) ) ; } throw new IllegalStateException ( <str> + expected + <str> + actual ) ; } } protected final void notifyStarted ( ) { monitor . enter ( ) ; try { if ( snapshot . state ! = STARTING ) { IllegalStateException failure = new IllegalStateException ( <str> + snapshot . state ) ; notifyFailed ( failure ) ; throw failure ; } if ( snapshot . shutdownWhenStartupFinishes ) { snapshot = new StateSnapshot ( STOPPING ) ; doStop ( ) ; } else { snapshot = new StateSnapshot ( RUNNING ) ; running ( ) ; } } finally { monitor . leave ( ) ; executeListeners ( ) ; } } protected final void notifyStopped ( ) { monitor . enter ( ) ; try { State previous = snapshot . state ; if ( previous ! = STOPPING & & previous ! = RUNNING ) { IllegalStateException failure = new IllegalStateException ( <str> + previous ) ; notifyFailed ( failure ) ; throw failure ; } snapshot = new StateSnapshot ( TERMINATED ) ; terminated ( previous ) ; } finally { monitor . leave ( ) ; executeListeners ( ) ; } } protected final void notifyFailed ( Throwable cause ) { checkNotNull ( cause ) ; monitor . enter ( ) ; try { State previous = state ( ) ; switch ( previous ) { case NEW : case TERMINATED : throw new IllegalStateException ( <str> + previous , cause ) ; case RUNNING : case STARTING : case STOPPING : snapshot = new StateSnapshot ( FAILED , false , cause ) ; failed ( previous , cause ) ; break ; case FAILED : break ; default : throw new AssertionError ( <str> + previous ) ; } } finally { monitor . leave ( ) ; executeListeners ( ) ; } } @Override public final boolean isRunning ( ) { return state ( ) = = RUNNING ; } @Override public final State state ( ) { return snapshot . externalState ( ) ; } @Override public final Throwable failureCause ( ) { return snapshot . failureCause ( ) ; } @Override public final void addListener ( Listener listener , Executor executor ) { checkNotNull ( listener , <str> ) ; checkNotNull ( executor , <str> ) ; monitor . enter ( ) ; try { if ( ! state ( ) . isTerminal ( ) ) { listeners . add ( new ListenerCallQueue < Listener > ( listener , executor ) ) ; } } finally { monitor . leave ( ) ; } } @Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + <str> + state ( ) + <str> ; } private void executeListeners ( ) { if ( ! monitor . isOccupiedByCurrentThread ( ) ) { for ( int i = <int> ; i < listeners . size ( ) ; i + + ) { listeners . get ( i ) . execute ( ) ; } } } @GuardedBy ( <str> ) private void starting ( ) { STARTING_CALLBACK . enqueueOn ( listeners ) ; } @GuardedBy ( <str> ) private void running ( ) { RUNNING_CALLBACK . enqueueOn ( listeners ) ; } @GuardedBy ( <str> ) private void stopping ( final State from ) { if ( from = = State . STARTING ) { STOPPING_FROM_STARTING_CALLBACK . enqueueOn ( listeners ) ; } else if ( from = = State . RUNNING ) { STOPPING_FROM_RUNNING_CALLBACK . enqueueOn ( listeners ) ; } else { throw new AssertionError ( ) ; } } @GuardedBy ( <str> ) private void terminated ( final State from ) { switch ( from ) { case NEW : TERMINATED_FROM_NEW_CALLBACK . enqueueOn ( listeners ) ; break ; case RUNNING : TERMINATED_FROM_RUNNING_CALLBACK . enqueueOn ( listeners ) ; break ; case STOPPING : TERMINATED_FROM_STOPPING_CALLBACK . enqueueOn ( listeners ) ; break ; case STARTING : case TERMINATED : case FAILED : default : throw new AssertionError ( ) ; } } @GuardedBy ( <str> ) private void failed ( final State from , final Throwable cause ) { new Callback < Listener > ( <str> + from + <str> + cause + <str> ) { @Override void call ( Listener listener ) { listener . failed ( from , cause ) ; } } . enqueueOn ( listeners ) ; } @Immutable private static final class StateSnapshot { final State state ; final boolean shutdownWhenStartupFinishes ; @Nullable final Throwable failure ; StateSnapshot ( State internalState ) { this ( internalState , false , null ) ; } StateSnapshot ( State internalState , boolean shutdownWhenStartupFinishes , @Nullable Throwable failure ) { checkArgument ( ! shutdownWhenStartupFinishes | | internalState = = STARTING , <str> , internalState ) ; checkArgument ( ! ( failure ! = null ^ internalState = = FAILED ) , <str> + <str> , internalState , failure ) ; this . state = internalState ; this . shutdownWhenStartupFinishes = shutdownWhenStartupFinishes ; this . failure = failure ; } State externalState ( ) { if ( shutdownWhenStartupFinishes & & state = = STARTING ) { return STOPPING ; } else { return state ; } } Throwable failureCause ( ) { checkState ( state = = FAILED , <str> , state ) ; return failure ; } } } 
