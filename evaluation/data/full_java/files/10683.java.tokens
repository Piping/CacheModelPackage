package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import static com . google . common . util . concurrent . MoreExecutors . newDirectExecutorService ; import static com . google . common . util . concurrent . Runnables . doNothing ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; public class WrappingExecutorServiceTest extends TestCase { private static final String RESULT_VALUE = <str> ; public void testDelegations ( ) throws InterruptedException { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; assertFalse ( testExecutor . awaitTermination ( <int> , TimeUnit . MILLISECONDS ) ) ; mock . assertLastMethodCalled ( <str> ) ; assertFalse ( testExecutor . isTerminated ( ) ) ; mock . assertLastMethodCalled ( <str> ) ; assertFalse ( testExecutor . isShutdown ( ) ) ; mock . assertLastMethodCalled ( <str> ) ; testExecutor . shutdown ( ) ; mock . assertLastMethodCalled ( <str> ) ; List < Runnable > list = testExecutor . shutdownNow ( ) ; mock . assertLastMethodCalled ( <str> ) ; assertEquals ( ImmutableList . of ( ) , list ) ; } public void testExecute ( ) { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; testExecutor . execute ( doNothing ( ) ) ; mock . assertLastMethodCalled ( <str> ) ; } public void testSubmit ( ) throws InterruptedException , ExecutionException { { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; Future < ? > f = testExecutor . submit ( doNothing ( ) ) ; mock . assertLastMethodCalled ( <str> ) ; f . get ( ) ; } { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; Future < String > f = testExecutor . submit ( doNothing ( ) , RESULT_VALUE ) ; mock . assertLastMethodCalled ( <str> ) ; assertEquals ( RESULT_VALUE , f . get ( ) ) ; } { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; Callable < String > task = Callables . returning ( RESULT_VALUE ) ; Future < String > f = testExecutor . submit ( task ) ; mock . assertLastMethodCalled ( <str> ) ; assertEquals ( RESULT_VALUE , f . get ( ) ) ; } } public void testInvokeAll ( ) throws InterruptedException , ExecutionException { List < Callable < String > > tasks = createTasks ( <int> ) ; { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; List < Future < String > > futures = testExecutor . invokeAll ( tasks ) ; mock . assertLastMethodCalled ( <str> ) ; checkResults ( futures ) ; } { MockExecutor mock = new MockExecutor ( ) ; TimeUnit unit = TimeUnit . SECONDS ; long timeout = <int> ; TestExecutor testExecutor = new TestExecutor ( mock ) ; List < Future < String > > futures = testExecutor . invokeAll ( tasks , timeout , unit ) ; mock . assertMethodWithTimeout ( <str> , timeout , unit ) ; checkResults ( futures ) ; } } public void testInvokeAny ( ) throws InterruptedException , ExecutionException , TimeoutException { List < Callable < String > > tasks = createTasks ( <int> ) ; { MockExecutor mock = new MockExecutor ( ) ; TestExecutor testExecutor = new TestExecutor ( mock ) ; String s = testExecutor . invokeAny ( tasks ) ; assertEquals ( <str> , s ) ; mock . assertLastMethodCalled ( <str> ) ; } { MockExecutor mock = new MockExecutor ( ) ; TimeUnit unit = TimeUnit . SECONDS ; long timeout = <int> ; TestExecutor testExecutor = new TestExecutor ( mock ) ; String s = testExecutor . invokeAny ( tasks , timeout , unit ) ; assertEquals ( RESULT_VALUE + <str> , s ) ; mock . assertMethodWithTimeout ( <str> , timeout , unit ) ; } } private static void checkResults ( List < Future < String > > futures ) throws InterruptedException , ExecutionException { for ( int i = <int> ; i < futures . size ( ) ; i + + ) { assertEquals ( RESULT_VALUE + i , futures . get ( i ) . get ( ) ) ; } } private static List < Callable < String > > createTasks ( int n ) { List < Callable < String > > callables = Lists . newArrayList ( ) ; for ( int i = <int> ; i < n ; i + + ) { callables . add ( Callables . returning ( RESULT_VALUE + i ) ) ; } return callables ; } private static final class WrappedCallable < T > implements Callable < T > { private final Callable < T > delegate ; public WrappedCallable ( Callable < T > delegate ) { this . delegate = delegate ; } @Override public T call ( ) throws Exception { return delegate . call ( ) ; } } private static final class WrappedRunnable implements Runnable { private final Runnable delegate ; public WrappedRunnable ( Runnable delegate ) { this . delegate = delegate ; } @Override public void run ( ) { delegate . run ( ) ; } } private static final class TestExecutor extends WrappingExecutorService { public TestExecutor ( MockExecutor mock ) { super ( mock ) ; } @Override protected < T > Callable < T > wrapTask ( Callable < T > callable ) { return new WrappedCallable < T > ( callable ) ; } @Override protected Runnable wrapTask ( Runnable command ) { return new WrappedRunnable ( command ) ; } } private static final class MockExecutor implements ExecutorService { private String lastMethodCalled = <str> ; private long lastTimeoutInMillis = - <int> ; private ExecutorService inline = newDirectExecutorService ( ) ; public void assertLastMethodCalled ( String method ) { assertEquals ( method , lastMethodCalled ) ; } public void assertMethodWithTimeout ( String method , long timeout , TimeUnit unit ) { assertLastMethodCalled ( method + <str> ) ; assertEquals ( unit . toMillis ( timeout ) , lastTimeoutInMillis ) ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) { lastMethodCalled = <str> ; return false ; } @Override public < T > List < Future < T > > invokeAll ( Collection < ? extends Callable < T > > tasks ) throws InterruptedException { lastMethodCalled = <str> ; assertTaskWrapped ( tasks ) ; return inline . invokeAll ( tasks ) ; } @Override public < T > List < Future < T > > invokeAll ( Collection < ? extends Callable < T > > tasks , long timeout , TimeUnit unit ) throws InterruptedException { assertTaskWrapped ( tasks ) ; lastMethodCalled = <str> ; lastTimeoutInMillis = unit . toMillis ( timeout ) ; return inline . invokeAll ( tasks , timeout , unit ) ; } @Override public < T > T invokeAny ( Collection < ? extends Callable < T > > tasks ) throws ExecutionException , InterruptedException { assertTaskWrapped ( tasks ) ; lastMethodCalled = <str> ; return inline . submit ( Iterables . get ( tasks , <int> ) ) . get ( ) ; } @Override public < T > T invokeAny ( Collection < ? extends Callable < T > > tasks , long timeout , TimeUnit unit ) throws ExecutionException , InterruptedException , TimeoutException { assertTaskWrapped ( tasks ) ; lastMethodCalled = <str> ; lastTimeoutInMillis = unit . toMillis ( timeout ) ; return inline . submit ( Iterables . get ( tasks , <int> ) ) . get ( timeout , unit ) ; } @Override public boolean isShutdown ( ) { lastMethodCalled = <str> ; return false ; } @Override public boolean isTerminated ( ) { lastMethodCalled = <str> ; return false ; } @Override public void shutdown ( ) { lastMethodCalled = <str> ; } @Override public List < Runnable > shutdownNow ( ) { lastMethodCalled = <str> ; return ImmutableList . of ( ) ; } @Override public < T > Future < T > submit ( Callable < T > task ) { lastMethodCalled = <str> ; assertThat ( task ) . isInstanceOf ( WrappedCallable . class ) ; return inline . submit ( task ) ; } @Override public Future < ? > submit ( Runnable task ) { lastMethodCalled = <str> ; assertThat ( task ) . isInstanceOf ( WrappedRunnable . class ) ; return inline . submit ( task ) ; } @Override public < T > Future < T > submit ( Runnable task , T result ) { lastMethodCalled = <str> ; assertThat ( task ) . isInstanceOf ( WrappedRunnable . class ) ; return inline . submit ( task , result ) ; } @Override public void execute ( Runnable command ) { lastMethodCalled = <str> ; assertThat ( command ) . isInstanceOf ( WrappedRunnable . class ) ; inline . execute ( command ) ; } private static < T > void assertTaskWrapped ( Collection < ? extends Callable < T > > tasks ) { Predicate < Object > p = Predicates . instanceOf ( WrappedCallable . class ) ; assertTrue ( Iterables . all ( tasks , p ) ) ; } } } 
