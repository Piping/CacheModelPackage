package org . apache . cassandra . db . compaction ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . db . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . CompactionParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . FBUtilities ; public class LongLeveledCompactionStrategyTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARDLVL = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { Map < String , String > leveledOptions = new HashMap < > ( ) ; leveledOptions . put ( <str> , <str> ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARDLVL ) . compaction ( CompactionParams . lcs ( leveledOptions ) ) ) ; } @Test public void testParallelLeveledCompaction ( ) throws Exception { String ksname = KEYSPACE1 ; String cfname = <str> ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cfname ) ; store . disableAutoCompaction ( ) ; LeveledCompactionStrategy lcs = ( LeveledCompactionStrategy ) store . getCompactionStrategyManager ( ) . getStrategies ( ) . get ( <int> ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> * <int> ] ) ; int rows = <int> ; int columns = <int> ; for ( int r = <int> ; r < rows ; r + + ) { DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; UpdateBuilder builder = UpdateBuilder . create ( store . metadata , key ) ; for ( int c = <int> ; c < columns ; c + + ) builder . newRow ( <str> + c ) . add ( <str> , value ) ; Mutation rm = new Mutation ( builder . build ( ) ) ; rm . apply ( ) ; store . forceBlockingFlush ( ) ; } ExecutorService executor = new ThreadPoolExecutor ( <int> , <int> , Long . MAX_VALUE , TimeUnit . SECONDS , new LinkedBlockingDeque < Runnable > ( ) ) ; List < Runnable > tasks = new ArrayList < Runnable > ( ) ; while ( true ) { while ( true ) { final AbstractCompactionTask nextTask = lcs . getNextBackgroundTask ( Integer . MIN_VALUE ) ; if ( nextTask = = null ) break ; tasks . add ( new Runnable ( ) { public void run ( ) { nextTask . execute ( null ) ; } } ) ; } if ( tasks . isEmpty ( ) ) break ; List < Future < ? > > futures = new ArrayList < Future < ? > > ( tasks . size ( ) ) ; for ( Runnable r : tasks ) futures . add ( executor . submit ( r ) ) ; FBUtilities . waitOnFutures ( futures ) ; tasks . clear ( ) ; } LeveledManifest manifest = lcs . manifest ; int levels = manifest . getLevelCount ( ) ; for ( int level = <int> ; level < levels ; level + + ) { List < SSTableReader > sstables = manifest . getLevel ( level ) ; assert ( double ) SSTableReader . getTotalBytes ( sstables ) / LeveledManifest . maxBytesForLevel ( level , <int> * <int> * <int> ) < <float> ; for ( SSTableReader sstable : sstables ) { assert level = = sstable . getSSTableLevel ( ) ; if ( level > <int> ) { Set < SSTableReader > overlaps = LeveledManifest . overlapping ( sstable , sstables ) ; assert overlaps . size ( ) = = <int> & & overlaps . contains ( sstable ) ; } } } } } 
