package org . gradle . messaging . remote . internal . hub ; import org . gradle . api . Action ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . ThreadSafe ; import org . gradle . internal . serialize . Serializer ; import org . gradle . internal . serialize . Serializers ; import org . gradle . internal . serialize . kryo . JavaSerializer ; import org . gradle . internal . serialize . StatefulSerializer ; import org . gradle . internal . serialize . kryo . TypeSafeSerializer ; import org . gradle . messaging . dispatch . MethodInvocation ; import org . gradle . messaging . dispatch . ProxyDispatchAdapter ; import org . gradle . messaging . dispatch . ReflectionDispatch ; import org . gradle . messaging . remote . ObjectConnection ; import org . gradle . messaging . remote . internal . ConnectCompletion ; import org . gradle . messaging . remote . internal . Connection ; import org . gradle . messaging . remote . internal . KryoBackedMessageSerializer ; import org . gradle . messaging . remote . internal . MessageSerializer ; import org . gradle . messaging . remote . internal . hub . protocol . InterHubMessage ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class MessageHubBackedObjectConnection implements ObjectConnection { private static final Logger LOGGER = LoggerFactory . getLogger ( MessageHubBackedObjectConnection . class ) ; private final MessageHub hub ; private ConnectCompletion completion ; private Connection < InterHubMessage > connection ; private ClassLoader methodParamClassLoader ; private Serializer < Object [ ] > paramSerializer ; public MessageHubBackedObjectConnection ( ExecutorFactory executorFactory , ConnectCompletion completion ) { this . hub = new MessageHub ( completion . toString ( ) , executorFactory , new Action < Throwable > ( ) { public void execute ( Throwable throwable ) { LOGGER . error ( <str> , throwable ) ; } } ) ; this . completion = completion ; } public < T > void addIncoming ( Class < T > type , T instance ) { if ( methodParamClassLoader = = null ) { methodParamClassLoader = type . getClassLoader ( ) ; } hub . addHandler ( type . getName ( ) , new ReflectionDispatch ( instance ) ) ; } public < T > T addOutgoing ( Class < T > type ) { if ( methodParamClassLoader = = null ) { methodParamClassLoader = type . getClassLoader ( ) ; } ProxyDispatchAdapter < T > adapter = new ProxyDispatchAdapter < T > ( hub . getOutgoing ( type . getName ( ) , MethodInvocation . class ) , type , ThreadSafe . class ) ; return adapter . getSource ( ) ; } public void useDefaultSerialization ( ClassLoader methodParamClassLoader ) { this . methodParamClassLoader = methodParamClassLoader ; } public void useParameterSerializer ( Serializer < Object [ ] > serializer ) { this . paramSerializer = serializer ; } public void connect ( ) { if ( methodParamClassLoader = = null ) { methodParamClassLoader = getClass ( ) . getClassLoader ( ) ; } StatefulSerializer < Object [ ] > paramSerializer ; if ( this . paramSerializer ! = null ) { paramSerializer = Serializers . stateful ( this . paramSerializer ) ; } else { paramSerializer = new JavaSerializer < Object [ ] > ( methodParamClassLoader ) ; } MessageSerializer < InterHubMessage > serializer = new KryoBackedMessageSerializer < InterHubMessage > ( new InterHubMessageSerializer ( new TypeSafeSerializer < MethodInvocation > ( MethodInvocation . class , new MethodInvocationSerializer ( methodParamClassLoader , paramSerializer ) ) ) ) ; connection = completion . create ( serializer ) ; hub . addConnection ( connection ) ; completion = null ; } public void requestStop ( ) { hub . requestStop ( ) ; } public void stop ( ) { CompositeStoppable . stoppable ( hub , connection ) . stop ( ) ; } } 
