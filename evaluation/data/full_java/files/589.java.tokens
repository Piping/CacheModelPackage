package org . apache . cassandra . gms ; import java . io . * ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . TimeUnit ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import javax . management . openmbean . CompositeData ; import javax . management . openmbean . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . FBUtilities ; public class FailureDetector implements IFailureDetector , FailureDetectorMBean { private static final Logger logger = LoggerFactory . getLogger ( FailureDetector . class ) ; public static final String MBEAN_NAME = <str> ; private static final int SAMPLE_SIZE = <int> ; protected static final long INITIAL_VALUE_NANOS = TimeUnit . NANOSECONDS . convert ( getInitialValue ( ) , TimeUnit . MILLISECONDS ) ; private static final int DEBUG_PERCENTAGE = <int> ; private static final long DEFAULT_MAX_PAUSE = <int> * <int> ; private static final long MAX_LOCAL_PAUSE_IN_NANOS = getMaxLocalPause ( ) ; private long lastInterpret = System . nanoTime ( ) ; private long lastPause = <int> L ; private static long getMaxLocalPause ( ) { if ( System . getProperty ( <str> ) ! = null ) { long pause = Long . parseLong ( System . getProperty ( <str> ) ) ; logger . warn ( <str> , pause ) ; return pause * <int> ; } else return DEFAULT_MAX_PAUSE ; } public static final IFailureDetector instance = new FailureDetector ( ) ; private final double PHI_FACTOR = <float> / Math . log ( <float> ) ; private final ConcurrentHashMap < InetAddress , ArrivalWindow > arrivalSamples = new ConcurrentHashMap < > ( ) ; private final List < IFailureDetectionEventListener > fdEvntListeners = new CopyOnWriteArrayList < > ( ) ; public FailureDetector ( ) { try { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } private static long getInitialValue ( ) { String newvalue = System . getProperty ( <str> ) ; if ( newvalue = = null ) { return Gossiper . intervalInMillis * <int> ; } else { logger . info ( <str> , newvalue ) ; return Integer . parseInt ( newvalue ) ; } } public String getAllEndpointStates ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < InetAddress , EndpointState > entry : Gossiper . instance . endpointStateMap . entrySet ( ) ) { sb . append ( entry . getKey ( ) ) . append ( <str> ) ; appendEndpointState ( sb , entry . getValue ( ) ) ; } return sb . toString ( ) ; } public Map < String , String > getSimpleStates ( ) { Map < String , String > nodesStatus = new HashMap < String , String > ( Gossiper . instance . endpointStateMap . size ( ) ) ; for ( Map . Entry < InetAddress , EndpointState > entry : Gossiper . instance . endpointStateMap . entrySet ( ) ) { if ( entry . getValue ( ) . isAlive ( ) ) nodesStatus . put ( entry . getKey ( ) . toString ( ) , <str> ) ; else nodesStatus . put ( entry . getKey ( ) . toString ( ) , <str> ) ; } return nodesStatus ; } public int getDownEndpointCount ( ) { int count = <int> ; for ( Map . Entry < InetAddress , EndpointState > entry : Gossiper . instance . endpointStateMap . entrySet ( ) ) { if ( ! entry . getValue ( ) . isAlive ( ) ) count + + ; } return count ; } public int getUpEndpointCount ( ) { int count = <int> ; for ( Map . Entry < InetAddress , EndpointState > entry : Gossiper . instance . endpointStateMap . entrySet ( ) ) { if ( entry . getValue ( ) . isAlive ( ) ) count + + ; } return count ; } @Override public TabularData getPhiValues ( ) throws OpenDataException { final CompositeType ct = new CompositeType ( <str> , <str> , new String [ ] { <str> , <str> } , new String [ ] { <str> , <str> } , new OpenType [ ] { SimpleType . STRING , SimpleType . DOUBLE } ) ; final TabularDataSupport results = new TabularDataSupport ( new TabularType ( <str> , <str> , ct , new String [ ] { <str> } ) ) ; for ( final Map . Entry < InetAddress , ArrivalWindow > entry : arrivalSamples . entrySet ( ) ) { final ArrivalWindow window = entry . getValue ( ) ; if ( window . mean ( ) > <int> ) { final double phi = window . getLastReportedPhi ( ) ; if ( phi ! = Double . MIN_VALUE ) { final CompositeData data = new CompositeDataSupport ( ct , new String [ ] { <str> , <str> } , new Object [ ] { entry . getKey ( ) . toString ( ) , phi * PHI_FACTOR } ) ; results . put ( data ) ; } } } return results ; } public String getEndpointState ( String address ) throws UnknownHostException { StringBuilder sb = new StringBuilder ( ) ; EndpointState endpointState = Gossiper . instance . getEndpointStateForEndpoint ( InetAddress . getByName ( address ) ) ; appendEndpointState ( sb , endpointState ) ; return sb . toString ( ) ; } private void appendEndpointState ( StringBuilder sb , EndpointState endpointState ) { sb . append ( <str> ) . append ( endpointState . getHeartBeatState ( ) . getGeneration ( ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( endpointState . getHeartBeatState ( ) . getHeartBeatVersion ( ) ) . append ( <str> ) ; for ( Map . Entry < ApplicationState , VersionedValue > state : endpointState . states ( ) ) { if ( state . getKey ( ) = = ApplicationState . TOKENS ) continue ; sb . append ( <str> ) . append ( state . getKey ( ) ) . append ( <str> ) . append ( state . getValue ( ) . version ) . append ( <str> ) . append ( state . getValue ( ) . value ) . append ( <str> ) ; } VersionedValue tokens = endpointState . getApplicationState ( ApplicationState . TOKENS ) ; if ( tokens ! = null ) { sb . append ( <str> ) . append ( tokens . version ) . append ( <str> ) ; } else { sb . append ( <str> ) ; } } public void dumpInterArrivalTimes ( ) { File file = FileUtils . createTempFile ( <str> , <str> ) ; try ( OutputStream os = new BufferedOutputStream ( new FileOutputStream ( file , true ) ) ) { os . write ( toString ( ) . getBytes ( ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , file ) ; } } public void setPhiConvictThreshold ( double phi ) { DatabaseDescriptor . setPhiConvictThreshold ( phi ) ; } public double getPhiConvictThreshold ( ) { return DatabaseDescriptor . getPhiConvictThreshold ( ) ; } public boolean isAlive ( InetAddress ep ) { if ( ep . equals ( FBUtilities . getBroadcastAddress ( ) ) ) return true ; EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( ep ) ; if ( epState = = null ) logger . error ( <str> , ep ) ; return epState ! = null & & epState . isAlive ( ) ; } public void report ( InetAddress ep ) { long now = System . nanoTime ( ) ; ArrivalWindow heartbeatWindow = arrivalSamples . get ( ep ) ; if ( heartbeatWindow = = null ) { heartbeatWindow = new ArrivalWindow ( SAMPLE_SIZE ) ; heartbeatWindow . add ( now , ep ) ; heartbeatWindow = arrivalSamples . putIfAbsent ( ep , heartbeatWindow ) ; if ( heartbeatWindow ! = null ) heartbeatWindow . add ( now , ep ) ; } else { heartbeatWindow . add ( now , ep ) ; } if ( logger . isTraceEnabled ( ) & & heartbeatWindow ! = null ) logger . info ( <str> , ep , heartbeatWindow . mean ( ) ) ; } public void interpret ( InetAddress ep ) { ArrivalWindow hbWnd = arrivalSamples . get ( ep ) ; if ( hbWnd = = null ) { return ; } long now = System . nanoTime ( ) ; long diff = now - lastInterpret ; lastInterpret = now ; if ( diff > MAX_LOCAL_PAUSE_IN_NANOS ) { logger . warn ( <str> , diff , MAX_LOCAL_PAUSE_IN_NANOS ) ; lastPause = now ; return ; } if ( System . nanoTime ( ) - lastPause < MAX_LOCAL_PAUSE_IN_NANOS ) { logger . debug ( <str> ) ; return ; } double phi = hbWnd . phi ( now ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ep , phi ) ; if ( PHI_FACTOR * phi > getPhiConvictThreshold ( ) ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , new Object [ ] { ep , PHI_FACTOR * phi , getPhiConvictThreshold ( ) , hbWnd , hbWnd . mean ( ) } ) ; for ( IFailureDetectionEventListener listener : fdEvntListeners ) { listener . convict ( ep , phi ) ; } } else if ( logger . isDebugEnabled ( ) & & ( PHI_FACTOR * phi * DEBUG_PERCENTAGE / <float> > getPhiConvictThreshold ( ) ) ) { logger . debug ( <str> , ep , phi ) ; } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , ep , phi ) ; logger . trace ( <str> , ep , hbWnd . mean ( ) ) ; } } public void forceConviction ( InetAddress ep ) { logger . debug ( <str> , ep ) ; for ( IFailureDetectionEventListener listener : fdEvntListeners ) { listener . convict ( ep , getPhiConvictThreshold ( ) ) ; } } public void remove ( InetAddress ep ) { arrivalSamples . remove ( ep ) ; } public void registerFailureDetectionEventListener ( IFailureDetectionEventListener listener ) { fdEvntListeners . add ( listener ) ; } public void unregisterFailureDetectionEventListener ( IFailureDetectionEventListener listener ) { fdEvntListeners . remove ( listener ) ; } public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; Set < InetAddress > eps = arrivalSamples . keySet ( ) ; sb . append ( <str> ) ; for ( InetAddress ep : eps ) { ArrivalWindow hWnd = arrivalSamples . get ( ep ) ; sb . append ( ep + <str> ) ; sb . append ( hWnd ) ; sb . append ( System . getProperty ( <str> ) ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } } class ArrayBackedBoundedStats { private final long [ ] arrivalIntervals ; private long sum = <int> ; private int index = <int> ; private boolean isFilled = false ; private volatile double mean = <int> ; public ArrayBackedBoundedStats ( final int size ) { arrivalIntervals = new long [ size ] ; } public void add ( long interval ) { if ( index = = arrivalIntervals . length ) { isFilled = true ; index = <int> ; } if ( isFilled ) sum = sum - arrivalIntervals [ index ] ; arrivalIntervals [ index + + ] = interval ; sum + = interval ; mean = ( double ) sum / size ( ) ; } private int size ( ) { return isFilled ? arrivalIntervals . length : index ; } public double mean ( ) { return mean ; } public long [ ] getArrivalIntervals ( ) { return arrivalIntervals ; } } class ArrivalWindow { private static final Logger logger = LoggerFactory . getLogger ( ArrivalWindow . class ) ; private long tLast = <int> L ; private final ArrayBackedBoundedStats arrivalIntervals ; private double lastReportedPhi = Double . MIN_VALUE ; private final long MAX_INTERVAL_IN_NANO = getMaxInterval ( ) ; ArrivalWindow ( int size ) { arrivalIntervals = new ArrayBackedBoundedStats ( size ) ; } private static long getMaxInterval ( ) { String newvalue = System . getProperty ( <str> ) ; if ( newvalue = = null ) { return FailureDetector . INITIAL_VALUE_NANOS ; } else { logger . info ( <str> , newvalue ) ; return TimeUnit . NANOSECONDS . convert ( Integer . parseInt ( newvalue ) , TimeUnit . MILLISECONDS ) ; } } synchronized void add ( long value , InetAddress ep ) { assert tLast > = <int> ; if ( tLast > <int> L ) { long interArrivalTime = ( value - tLast ) ; if ( interArrivalTime < = MAX_INTERVAL_IN_NANO ) { arrivalIntervals . add ( interArrivalTime ) ; logger . trace ( <str> , interArrivalTime , ep ) ; } else { logger . debug ( <str> , interArrivalTime , ep ) ; } } else { arrivalIntervals . add ( FailureDetector . INITIAL_VALUE_NANOS ) ; } tLast = value ; } double mean ( ) { return arrivalIntervals . mean ( ) ; } double phi ( long tnow ) { assert arrivalIntervals . mean ( ) > <int> & & tLast > <int> ; long t = tnow - tLast ; lastReportedPhi = t / mean ( ) ; return lastReportedPhi ; } double getLastReportedPhi ( ) { return lastReportedPhi ; } public String toString ( ) { return Arrays . toString ( arrivalIntervals . getArrivalIntervals ( ) ) ; } } 
