package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; public class HttpContentEncoderTest { private static final class TestEncoder extends HttpContentEncoder { @Override protected Result beginEncode ( HttpResponse headers , String acceptEncoding ) { return new Result ( <str> , new EmbeddedChannel ( new MessageToByteEncoder < ByteBuf > ( ) { @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { out . writeBytes ( String . valueOf ( in . readableBytes ( ) ) . getBytes ( CharsetUtil . US_ASCII ) ) ; in . skipBytes ( in . readableBytes ( ) ) ; } } ) ) ; } } @Test public void testSplitContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; ch . writeOutbound ( new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; ch . writeOutbound ( new DefaultLastHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; assertEncodedResponse ( ch ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testChunkedContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; ch . writeOutbound ( new DefaultLastHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testChunkedContentWithTrailingHeader ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ) ; LastHttpContent content = new DefaultLastHttpContent ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ; content . trailingHeaders ( ) . set ( of ( <str> ) , of ( <str> ) ) ; ch . writeOutbound ( content ) ; HttpContent chunk ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; assertEquals ( <str> , ( ( LastHttpContent ) chunk ) . trailingHeaders ( ) . get ( of ( <str> ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testFullContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ; res . headers ( ) . set ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; ch . writeOutbound ( res ) ; assertEncodedResponse ( ch ) ; HttpContent c = ch . readOutbound ( ) ; assertThat ( c . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( c . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; c . release ( ) ; LastHttpContent last = ch . readOutbound ( ) ; assertThat ( last . content ( ) . readableBytes ( ) , is ( <int> ) ) ; last . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptySplitContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; ch . writeOutbound ( new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ) ; assertEncodedResponse ( ch ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; HttpContent chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertThat ( chunk , is ( instanceOf ( HttpContent . class ) ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( false ) ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptyFullContent ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ; ch . writeOutbound ( res ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( res . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; res . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptyFullContentWithTrailer ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; ch . writeInbound ( new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , Unpooled . EMPTY_BUFFER ) ; res . trailingHeaders ( ) . set ( of ( <str> ) , of ( <str> ) ) ; ch . writeOutbound ( res ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( FullHttpResponse . class ) ) ) ; res = ( FullHttpResponse ) o ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( nullValue ( ) ) ) ; assertThat ( res . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( res . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertEquals ( <str> , res . trailingHeaders ( ) . get ( of ( <str> ) ) ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testEmptyHeadResponse ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; HttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . HEAD , <str> ) ; ch . writeInbound ( req ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; assertEmptyResponse ( ch ) ; } @Test public void testHttp304Response ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; HttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> ) ; req . headers ( ) . set ( HttpHeaderNames . ACCEPT_ENCODING , HttpHeaderValues . GZIP ) ; ch . writeInbound ( req ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . NOT_MODIFIED ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; assertEmptyResponse ( ch ) ; } @Test public void testConnect200Response ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; HttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . CONNECT , <str> ) ; ch . writeInbound ( req ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; assertEmptyResponse ( ch ) ; } @Test public void testConnectFailureResponse ( ) throws Exception { String content = <str> ; EmbeddedChannel ch = new EmbeddedChannel ( new TestEncoder ( ) ) ; HttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . CONNECT , <str> ) ; ch . writeInbound ( req ) ; HttpResponse res = new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . METHOD_NOT_ALLOWED ) ; res . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; ch . writeOutbound ( res ) ; ch . writeOutbound ( new DefaultHttpContent ( Unpooled . wrappedBuffer ( content . getBytes ( CharsetUtil . UTF_8 ) ) ) ) ; ch . writeOutbound ( LastHttpContent . EMPTY_LAST_CONTENT ) ; assertEncodedResponse ( ch ) ; Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( HttpContent . class ) ) ) ; HttpContent chunk = ( HttpContent ) o ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk . content ( ) . isReadable ( ) , is ( true ) ) ; assertThat ( chunk . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; chunk . release ( ) ; chunk = ch . readOutbound ( ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } private static void assertEmptyResponse ( EmbeddedChannel ch ) { Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( HttpResponse . class ) ) ) ; HttpResponse res = ( HttpResponse ) o ; assertThat ( res , is ( not ( instanceOf ( HttpContent . class ) ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( <str> ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) , is ( nullValue ( ) ) ) ; HttpContent chunk = ch . readOutbound ( ) ; assertThat ( chunk , is ( instanceOf ( LastHttpContent . class ) ) ) ; chunk . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; } private static void assertEncodedResponse ( EmbeddedChannel ch ) { Object o = ch . readOutbound ( ) ; assertThat ( o , is ( instanceOf ( HttpResponse . class ) ) ) ; HttpResponse res = ( HttpResponse ) o ; assertThat ( res , is ( not ( instanceOf ( HttpContent . class ) ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( <str> ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) , is ( nullValue ( ) ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) , is ( <str> ) ) ; } } 
