package org . gradle . model . internal . manage . schema . extract ; import com . google . common . base . Equivalence ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . * ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; public class CandidateMethods { private final Map < String , Map < Equivalence . Wrapper < Method > , Collection < Method > > > candidates ; public CandidateMethods ( Map < String , Map < Equivalence . Wrapper < Method > , Collection < Method > > > candidates ) { this . candidates = candidates ; } boolean isEmpty ( ) { return candidates . isEmpty ( ) ; } public Iterable < String > methodNames ( ) { return candidates . keySet ( ) ; } public Map < Equivalence . Wrapper < Method > , Collection < Method > > allMethods ( ) { ImmutableMap . Builder < Equivalence . Wrapper < Method > , Collection < Method > > builder = ImmutableMap . builder ( ) ; for ( Map < Equivalence . Wrapper < Method > , Collection < Method > > candidatesForSomeName : candidates . values ( ) ) { builder . putAll ( candidatesForSomeName ) ; } return builder . build ( ) ; } Map < Equivalence . Wrapper < Method > , Collection < Method > > methodsNamed ( String methodName ) { if ( candidates . containsKey ( methodName ) ) { return candidates . get ( methodName ) ; } return Collections . < Equivalence . Wrapper < Method > , Collection < Method > > emptyMap ( ) ; } public Map < Equivalence . Wrapper < Method > , Collection < Method > > overriddenMethodsNamed ( String methodName ) { if ( candidates . containsKey ( methodName ) ) { return Maps . filterValues ( candidates . get ( methodName ) , new Predicate < Collection < Method > > ( ) { @Override public boolean apply ( Collection < Method > equivalentMethods ) { return equivalentMethods . size ( ) > <int> ; } } ) ; } return Collections . < Equivalence . Wrapper < Method > , Collection < Method > > emptyMap ( ) ; } public Map < Equivalence . Wrapper < Method > , Collection < Method > > overloadedMethodsNamed ( String methodName , Collection < Equivalence . Wrapper < Method > > excludes ) { return Maps . filterKeys ( overloadedMethodsNamed ( methodName ) , Predicates . not ( Predicates . in ( excludes ) ) ) ; } Map < Equivalence . Wrapper < Method > , Collection < Method > > overloadedMethodsNamed ( String methodName ) { if ( candidates . containsKey ( methodName ) ) { Map < Equivalence . Wrapper < Method > , Collection < Method > > overloadeds = candidates . get ( methodName ) ; if ( overloadeds . size ( ) > <int> ) { return overloadeds ; } } return Collections . < Equivalence . Wrapper < Method > , Collection < Method > > emptyMap ( ) ; } } 
