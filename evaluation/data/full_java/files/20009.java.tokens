package io . netty . handler . stream ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . nio . ByteBuffer ; import java . nio . channels . ReadableByteChannel ; public class ChunkedNioStream implements ChunkedInput < ByteBuf > { private final ReadableByteChannel in ; private final int chunkSize ; private long offset ; private final ByteBuffer byteBuffer ; public ChunkedNioStream ( ReadableByteChannel in ) { this ( in , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; } public ChunkedNioStream ( ReadableByteChannel in , int chunkSize ) { if ( in = = null ) { throw new NullPointerException ( <str> ) ; } if ( chunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + chunkSize + <str> ) ; } this . in = in ; offset = <int> ; this . chunkSize = chunkSize ; byteBuffer = ByteBuffer . allocate ( chunkSize ) ; } public long transferredBytes ( ) { return offset ; } @Override public boolean isEndOfInput ( ) throws Exception { if ( byteBuffer . position ( ) > <int> ) { return false ; } if ( in . isOpen ( ) ) { int b = in . read ( byteBuffer ) ; if ( b < <int> ) { return true ; } else { offset + = b ; return false ; } } return true ; } @Override public void close ( ) throws Exception { in . close ( ) ; } @Override public ByteBuf readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( isEndOfInput ( ) ) { return null ; } int readBytes = byteBuffer . position ( ) ; for ( ; ; ) { int localReadBytes = in . read ( byteBuffer ) ; if ( localReadBytes < <int> ) { break ; } readBytes + = localReadBytes ; offset + = localReadBytes ; if ( readBytes = = chunkSize ) { break ; } } byteBuffer . flip ( ) ; boolean release = true ; ByteBuf buffer = ctx . alloc ( ) . buffer ( byteBuffer . remaining ( ) ) ; try { buffer . writeBytes ( byteBuffer ) ; byteBuffer . clear ( ) ; release = false ; return buffer ; } finally { if ( release ) { buffer . release ( ) ; } } } @Override public long length ( ) { return - <int> ; } @Override public long progress ( ) { return offset ; } } 
