package org . apache . cassandra . utils . concurrent ; import java . util . * ; import javax . annotation . Nullable ; import com . google . common . base . Function ; import com . google . common . base . Throwables ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import static org . apache . cassandra . utils . Throwables . maybeFail ; import static org . apache . cassandra . utils . Throwables . merge ; public final class Refs < T extends RefCounted < T > > extends AbstractCollection < T > implements AutoCloseable { private final Map < T , Ref < T > > references ; public Refs ( ) { this . references = new HashMap < > ( ) ; } public Refs ( Map < T , Ref < T > > references ) { this . references = new HashMap < > ( references ) ; } public void release ( ) { try { release ( references . values ( ) ) ; } finally { references . clear ( ) ; } } public void close ( ) { release ( ) ; } public Ref < T > get ( T referenced ) { return references . get ( referenced ) ; } public void release ( T referenced ) { Ref ref = references . remove ( referenced ) ; if ( ref = = null ) throw new IllegalStateException ( <str> + referenced ) ; ref . release ( ) ; } public boolean releaseIfHolds ( T referenced ) { Ref ref = references . remove ( referenced ) ; if ( ref ! = null ) ref . release ( ) ; return ref ! = null ; } public void relaseAllExcept ( Collection < T > keep ) { Collection < T > release = new ArrayList < > ( references . keySet ( ) ) ; release . retainAll ( keep ) ; release ( release ) ; } public void release ( Collection < T > release ) { List < Ref < T > > refs = new ArrayList < > ( ) ; List < T > notPresent = null ; for ( T obj : release ) { Ref < T > ref = references . remove ( obj ) ; if ( ref = = null ) { if ( notPresent = = null ) notPresent = new ArrayList < > ( ) ; notPresent . add ( obj ) ; } else { refs . add ( ref ) ; } } IllegalStateException notPresentFail = null ; if ( notPresent ! = null ) { notPresentFail = new IllegalStateException ( <str> + notPresent + <str> ) ; notPresentFail . fillInStackTrace ( ) ; } try { release ( refs ) ; } catch ( Throwable t ) { if ( notPresentFail ! = null ) t . addSuppressed ( notPresentFail ) ; } if ( notPresentFail ! = null ) throw notPresentFail ; } public boolean tryRef ( T t ) { Ref < T > ref = t . tryRef ( ) ; if ( ref = = null ) return false ; ref = references . put ( t , ref ) ; if ( ref ! = null ) ref . release ( ) ; return true ; } public Iterator < T > iterator ( ) { return Iterators . unmodifiableIterator ( references . keySet ( ) . iterator ( ) ) ; } public int size ( ) { return references . size ( ) ; } public Refs < T > addAll ( Refs < T > add ) { List < Ref < T > > overlap = new ArrayList < > ( ) ; for ( Map . Entry < T , Ref < T > > e : add . references . entrySet ( ) ) { if ( this . references . containsKey ( e . getKey ( ) ) ) overlap . add ( e . getValue ( ) ) ; else this . references . put ( e . getKey ( ) , e . getValue ( ) ) ; } add . references . clear ( ) ; release ( overlap ) ; return this ; } public static < T extends RefCounted < T > > Refs < T > tryRef ( Iterable < T > reference ) { HashMap < T , Ref < T > > refs = new HashMap < > ( ) ; for ( T rc : reference ) { Ref < T > ref = rc . tryRef ( ) ; if ( ref = = null ) { release ( refs . values ( ) ) ; return null ; } refs . put ( rc , ref ) ; } return new Refs < T > ( refs ) ; } public static < T extends RefCounted < T > > Refs < T > ref ( Iterable < T > reference ) { Refs < T > refs = tryRef ( reference ) ; if ( refs ! = null ) return refs ; throw new IllegalStateException ( ) ; } public static void release ( Iterable < ? extends Ref < ? > > refs ) { maybeFail ( release ( refs , null ) ) ; } public static Throwable release ( Iterable < ? extends Ref < ? > > refs , Throwable accumulate ) { for ( Ref ref : refs ) { try { ref . release ( ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } } return accumulate ; } public static < T extends SelfRefCounted < T > > Iterable < Ref < T > > selfRefs ( Iterable < T > refs ) { return Iterables . transform ( refs , new Function < T , Ref < T > > ( ) { @Nullable public Ref < T > apply ( T t ) { return t . selfRef ( ) ; } } ) ; } } 
