package com . google . common . graph ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import com . google . common . annotations . Beta ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import java . util . Iterator ; import java . util . Set ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta public final class Graphs { public static final GraphConfig MULTIGRAPH = config ( ) . multigraph ( ) ; private Graphs ( ) { } @SuppressWarnings ( <str> ) @CheckReturnValue public static < N > N oppositeNode ( UndirectedGraph < N , ? > undirectedGraph , Object edge , Object node ) { checkNotNull ( edge , <str> ) ; checkNotNull ( node , <str> ) ; Set < N > incidentNodes = undirectedGraph . incidentNodes ( edge ) ; checkArgument ( incidentNodes . contains ( node ) , <str> , edge , node ) ; for ( N incidentNode : incidentNodes ) { if ( ! incidentNode . equals ( node ) ) { return incidentNode ; } } return ( N ) node ; } public static < N , E > boolean addEdge ( Graph < N , E > graph , E edge , Iterable < N > nodes ) { checkNotNull ( graph , <str> ) ; checkNotNull ( nodes , <str> ) ; checkNotNull ( edge , <str> ) ; if ( graph instanceof Hypergraph ) { return ( ( Hypergraph < N , E > ) graph ) . addEdge ( edge , nodes ) ; } Iterator < N > it = nodes . iterator ( ) ; checkArgument ( it . hasNext ( ) , <str> , nodes ) ; N n1 = it . next ( ) ; if ( it . hasNext ( ) ) { N n2 = it . next ( ) ; checkArgument ( ! it . hasNext ( ) , <str> , nodes ) ; return graph . addEdge ( edge , n1 , n2 ) ; } else { return graph . addEdge ( edge , n1 , n1 ) ; } } @CheckReturnValue public static < N , E > DirectedGraph < N , E > copyOf ( DirectedGraph < N , E > graph ) { checkNotNull ( graph , <str> ) ; DirectedGraph < N , E > copy = createDirected ( graph . config ( ) . expectedNodeCount ( graph . nodes ( ) . size ( ) ) . expectedEdgeCount ( graph . edges ( ) . size ( ) ) ) ; mergeNodesFrom ( graph , copy ) ; mergeEdgesFrom ( graph , copy ) ; return copy ; } @CheckReturnValue public static < N , E > DirectedGraph < N , E > copyOf ( DirectedGraph < N , E > graph , Predicate < ? super N > nodePredicate , Predicate < ? super E > edgePredicate ) { checkNotNull ( graph , <str> ) ; checkNotNull ( nodePredicate , <str> ) ; checkNotNull ( edgePredicate , <str> ) ; DirectedGraph < N , E > copy = createDirected ( graph . config ( ) . expectedNodeCount ( graph . nodes ( ) . size ( ) ) . expectedEdgeCount ( graph . edges ( ) . size ( ) ) ) ; mergeNodesFrom ( graph , copy , nodePredicate ) ; if ( edgePredicate . equals ( Predicates . < E > alwaysFalse ( ) ) ) { return copy ; } for ( E edge : graph . edges ( ) ) { if ( edgePredicate . apply ( edge ) ) { N source = graph . source ( edge ) ; N target = graph . target ( edge ) ; if ( nodePredicate . apply ( source ) & & nodePredicate . apply ( target ) ) { copy . addEdge ( edge , source , target ) ; } } } return copy ; } public static < N , E > void mergeNodesFrom ( Graph < N , E > original , Graph < N , E > copy ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; for ( N node : original . nodes ( ) ) { copy . addNode ( node ) ; } } public static < N , E > void mergeNodesFrom ( Graph < N , E > original , Graph < N , E > copy , Predicate < ? super N > nodePredicate ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; checkNotNull ( nodePredicate , <str> ) ; if ( nodePredicate . equals ( Predicates . < N > alwaysFalse ( ) ) ) { return ; } if ( nodePredicate . equals ( Predicates . < N > alwaysTrue ( ) ) ) { mergeNodesFrom ( original , copy ) ; } else { for ( N node : original . nodes ( ) ) { if ( nodePredicate . apply ( node ) ) { copy . addNode ( node ) ; } } } } public static < N , E > void mergeEdgesFrom ( DirectedGraph < N , E > original , DirectedGraph < N , E > copy ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; for ( E edge : original . edges ( ) ) { copy . addEdge ( edge , original . source ( edge ) , original . target ( edge ) ) ; } } public static < N , E > void mergeEdgesFrom ( DirectedGraph < N , E > original , DirectedGraph < N , E > copy , Predicate < ? super E > edgePredicate ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; checkNotNull ( edgePredicate , <str> ) ; if ( edgePredicate . equals ( Predicates . < E > alwaysFalse ( ) ) ) { return ; } if ( edgePredicate . equals ( Predicates . < E > alwaysTrue ( ) ) ) { mergeEdgesFrom ( original , copy ) ; } else { for ( E edge : original . edges ( ) ) { if ( edgePredicate . apply ( edge ) ) { copy . addEdge ( edge , original . source ( edge ) , original . target ( edge ) ) ; } } } } @CheckReturnValue public static < N , E > UndirectedGraph < N , E > copyOf ( UndirectedGraph < N , E > graph ) { checkNotNull ( graph , <str> ) ; UndirectedGraph < N , E > copy = createUndirected ( graph . config ( ) . expectedNodeCount ( graph . nodes ( ) . size ( ) ) . expectedEdgeCount ( graph . edges ( ) . size ( ) ) ) ; mergeNodesFrom ( graph , copy ) ; mergeEdgesFrom ( graph , copy ) ; return copy ; } @CheckReturnValue public static < N , E > UndirectedGraph < N , E > copyOf ( UndirectedGraph < N , E > graph , Predicate < ? super N > nodePredicate , Predicate < ? super E > edgePredicate ) { checkNotNull ( graph , <str> ) ; checkNotNull ( nodePredicate , <str> ) ; checkNotNull ( edgePredicate , <str> ) ; UndirectedGraph < N , E > copy = createUndirected ( graph . config ( ) . expectedNodeCount ( graph . nodes ( ) . size ( ) ) . expectedEdgeCount ( graph . edges ( ) . size ( ) ) ) ; mergeNodesFrom ( graph , copy , nodePredicate ) ; for ( E edge : graph . edges ( ) ) { if ( edgePredicate . apply ( edge ) ) { boolean nodesOk = true ; Set < N > incidentNodes = graph . incidentNodes ( edge ) ; for ( N node : incidentNodes ) { nodesOk & = nodePredicate . apply ( node ) ; } if ( nodesOk ) { addEdge ( copy , edge , incidentNodes ) ; } } } return copy ; } public static < N , E > void mergeEdgesFrom ( Graph < N , E > original , Graph < N , E > copy ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; for ( E edge : original . edges ( ) ) { addEdge ( copy , edge , original . incidentNodes ( edge ) ) ; } } public static < N , E > void mergeEdgesFrom ( Graph < N , E > original , Graph < N , E > copy , Predicate < ? super E > edgePredicate ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; checkNotNull ( edgePredicate , <str> ) ; if ( edgePredicate . equals ( Predicates . < E > alwaysFalse ( ) ) ) { return ; } if ( edgePredicate . equals ( Predicates . < E > alwaysTrue ( ) ) ) { mergeEdgesFrom ( original , copy ) ; } else { for ( E edge : original . edges ( ) ) { if ( edgePredicate . apply ( edge ) ) { addEdge ( copy , edge , original . incidentNodes ( edge ) ) ; } } } } public static < N , E > void copyFrom ( Graph < N , E > original , Graph < N , E > copy , Predicate < ? super N > nodePredicate , Predicate < ? super E > edgePredicate ) { checkNotNull ( original , <str> ) ; checkNotNull ( copy , <str> ) ; checkNotNull ( nodePredicate , <str> ) ; checkNotNull ( edgePredicate , <str> ) ; mergeNodesFrom ( original , copy , nodePredicate ) ; mergeEdgesFrom ( original , copy , edgePredicate ) ; } @CheckReturnValue public static GraphConfig config ( ) { return new GraphConfig ( ) ; } @CheckReturnValue public static < N , E > DirectedGraph < N , E > createDirected ( ) { return new IncidenceSetDirectedGraph < N , E > ( config ( ) ) ; } @CheckReturnValue public static < N , E > DirectedGraph < N , E > createDirected ( GraphConfig config ) { return new IncidenceSetDirectedGraph < N , E > ( config ) ; } @CheckReturnValue public static < N , E > UndirectedGraph < N , E > createUndirected ( ) { return new IncidenceSetUndirectedGraph < N , E > ( config ( ) ) ; } @CheckReturnValue public static < N , E > UndirectedGraph < N , E > createUndirected ( GraphConfig config ) { return new IncidenceSetUndirectedGraph < N , E > ( config ) ; } @CheckReturnValue public static < N , E > boolean equal ( @Nullable DirectedGraph < ? , ? > g1 , @Nullable DirectedGraph < ? , ? > g2 ) { if ( g1 = = g2 ) { return true ; } if ( g1 = = null | | g2 = = null ) { return false ; } if ( ! g1 . nodes ( ) . equals ( g2 . nodes ( ) ) | | ! g1 . edges ( ) . equals ( g2 . edges ( ) ) ) { return false ; } for ( Object e : g1 . edges ( ) ) { if ( ! g1 . source ( e ) . equals ( g2 . source ( e ) ) | | ! g1 . target ( e ) . equals ( g2 . target ( e ) ) ) { return false ; } } return true ; } @CheckReturnValue public static boolean equal ( @Nullable Graph < ? , ? > g1 , @Nullable Graph < ? , ? > g2 ) { if ( g1 = = g2 ) { return true ; } if ( g1 = = null | | g2 = = null ) { return false ; } if ( ! g1 . nodes ( ) . equals ( g2 . nodes ( ) ) | | ! g1 . edges ( ) . equals ( g2 . edges ( ) ) ) { return false ; } for ( Object e : g1 . edges ( ) ) { if ( ! g1 . incidentNodes ( e ) . equals ( g2 . incidentNodes ( e ) ) ) { return false ; } } return true ; } @CheckReturnValue public static < E > Predicate < E > noSelfLoopPredicate ( final Graph < ? , E > graph ) { checkNotNull ( graph , <str> ) ; return new Predicate < E > ( ) { @Override public boolean apply ( E edge ) { checkState ( graph . edges ( ) . contains ( edge ) , <str> , edge ) ; return graph . incidentNodes ( edge ) . size ( ) ! = <int> ; } } ; } } 
