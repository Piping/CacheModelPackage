package org . elasticsearch . action . support . single . instance ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . PlainActionFuture ; import org . elasticsearch . action . support . replication . ClusterStateCreationUtils ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . test . transport . CapturingTransport ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportService ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . function . Supplier ; import static org . hamcrest . core . IsEqual . equalTo ; public class TransportInstanceSingleOperationActionTests extends ESTestCase { private static ThreadPool THREAD_POOL ; private TestClusterService clusterService ; private CapturingTransport transport ; private TransportService transportService ; private TestTransportInstanceSingleOperationAction action ; public static class Request extends InstanceShardOperationRequest < Request > { public Request ( ) { } } public static class Response extends ActionResponse { public Response ( ) { } } class TestTransportInstanceSingleOperationAction extends TransportInstanceSingleOperationAction < Request , Response > { private final Map < ShardId , Object > shards = new HashMap < > ( ) ; public TestTransportInstanceSingleOperationAction ( Settings settings , String actionName , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , Supplier < Request > request ) { super ( settings , actionName , THREAD_POOL , TransportInstanceSingleOperationActionTests . this . clusterService , transportService , actionFilters , indexNameExpressionResolver , request ) ; } public Map < ShardId , Object > getResults ( ) { return shards ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected void shardOperation ( Request request , ActionListener < Response > listener ) { throw new UnsupportedOperationException ( <str> ) ; } @Override protected Response newResponse ( ) { return new Response ( ) ; } @Override protected boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) { return true ; } @Override protected ShardIterator shards ( ClusterState clusterState , Request request ) { return clusterState . routingTable ( ) . index ( request . concreteIndex ( ) ) . shard ( request . shardId ) . primaryShardIt ( ) ; } } class MyResolver extends IndexNameExpressionResolver { public MyResolver ( ) { super ( Settings . EMPTY ) ; } @Override public String [ ] concreteIndices ( ClusterState state , IndicesRequest request ) { return request . indices ( ) ; } } @BeforeClass public static void startThreadPool ( ) { THREAD_POOL = new ThreadPool ( TransportInstanceSingleOperationActionTests . class . getSimpleName ( ) ) ; } @Before public void setUp ( ) throws Exception { super . setUp ( ) ; transport = new CapturingTransport ( ) ; clusterService = new TestClusterService ( THREAD_POOL ) ; transportService = new TransportService ( transport , THREAD_POOL ) ; transportService . start ( ) ; action = new TestTransportInstanceSingleOperationAction ( Settings . EMPTY , <str> , transportService , new ActionFilters ( new HashSet < ActionFilter > ( ) ) , new MyResolver ( ) , Request : : new ) ; } @AfterClass public static void destroyThreadPool ( ) { ThreadPool . terminate ( THREAD_POOL , <int> , TimeUnit . SECONDS ) ; THREAD_POOL = null ; } public void testGlobalBlock ( ) { Request request = new Request ( ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; ClusterBlocks . Builder block = ClusterBlocks . builder ( ) . addGlobalBlock ( new ClusterBlock ( <int> , <str> , false , true , RestStatus . SERVICE_UNAVAILABLE , ClusterBlockLevel . ALL ) ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . blocks ( block ) ) ; try { action . new AsyncSingleAction ( request , listener ) . start ( ) ; listener . get ( ) ; fail ( <str> ) ; } catch ( Throwable t ) { if ( ExceptionsHelper . unwrap ( t , ClusterBlockException . class ) = = null ) { logger . info ( <str> , t ) ; fail ( <str> ) ; } } } public void testBasicRequestWorks ( ) throws InterruptedException , ExecutionException , TimeoutException { Request request = new Request ( ) . index ( <str> ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , randomBoolean ( ) , ShardRoutingState . STARTED ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; transport . handleResponse ( transport . capturedRequests ( ) [ <int> ] . requestId , new Response ( ) ) ; listener . get ( ) ; } public void testFailureWithoutRetry ( ) throws Exception { Request request = new Request ( ) . index ( <str> ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , randomBoolean ( ) , ShardRoutingState . STARTED ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; long requestId = transport . capturedRequests ( ) [ <int> ] . requestId ; transport . clear ( ) ; transport . handleResponse ( requestId , new TransportException ( <str> , new Exception ( <str> ) ) ) ; try { assertTrue ( listener . isDone ( ) ) ; listener . get ( ) ; fail ( <str> ) ; } catch ( ExecutionException t ) { if ( ExceptionsHelper . unwrap ( t , TransportException . class ) = = null ) { logger . info ( <str> , t ) ; fail ( <str> ) ; } } } public void testSuccessAfterRetryWithClusterStateUpdate ( ) throws Exception { Request request = new Request ( ) . index ( <str> ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; boolean local = randomBoolean ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , local , ShardRoutingState . INITIALIZING ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , local , ShardRoutingState . STARTED ) ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; transport . handleResponse ( transport . capturedRequests ( ) [ <int> ] . requestId , new Response ( ) ) ; listener . get ( ) ; } public void testSuccessAfterRetryWithExcpetionFromTransport ( ) throws Exception { Request request = new Request ( ) . index ( <str> ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; boolean local = randomBoolean ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , local , ShardRoutingState . STARTED ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; long requestId = transport . capturedRequests ( ) [ <int> ] . requestId ; transport . clear ( ) ; DiscoveryNode node = clusterService . state ( ) . getNodes ( ) . getLocalNode ( ) ; transport . handleResponse ( requestId , new ConnectTransportException ( node , <str> ) ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , local , ShardRoutingState . STARTED ) ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; transport . handleResponse ( transport . capturedRequests ( ) [ <int> ] . requestId , new Response ( ) ) ; listener . get ( ) ; } public void testRetryOfAnAlreadyTimedOutRequest ( ) throws Exception { Request request = new Request ( ) . index ( <str> ) . timeout ( new TimeValue ( <int> , TimeUnit . MILLISECONDS ) ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , randomBoolean ( ) , ShardRoutingState . STARTED ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; long requestId = transport . capturedRequests ( ) [ <int> ] . requestId ; transport . clear ( ) ; DiscoveryNode node = clusterService . state ( ) . getNodes ( ) . getLocalNode ( ) ; transport . handleResponse ( requestId , new ConnectTransportException ( node , <str> ) ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; } } ) ; requestId = transport . capturedRequests ( ) [ <int> ] . requestId ; transport . handleResponse ( requestId , new ConnectTransportException ( node , <str> ) ) ; try { assertTrue ( listener . isDone ( ) ) ; listener . get ( ) ; fail ( <str> ) ; } catch ( ExecutionException t ) { if ( ExceptionsHelper . unwrap ( t , ConnectTransportException . class ) = = null ) { logger . info ( <str> , t ) ; fail ( <str> ) ; } } } public void testUnresolvableRequestDoesNotHang ( ) throws InterruptedException , ExecutionException , TimeoutException { action = new TestTransportInstanceSingleOperationAction ( Settings . EMPTY , <str> , transportService , new ActionFilters ( new HashSet < ActionFilter > ( ) ) , new MyResolver ( ) , Request : : new ) { @Override protected boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) { return false ; } } ; Request request = new Request ( ) . index ( <str> ) ; request . shardId = <int> ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; clusterService . setState ( ClusterStateCreationUtils . state ( <str> , randomBoolean ( ) , ShardRoutingState . STARTED ) ) ; action . new AsyncSingleAction ( request , listener ) . start ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; try { listener . get ( ) ; } catch ( Throwable t ) { if ( ExceptionsHelper . unwrap ( t , IllegalStateException . class ) = = null ) { logger . info ( <str> , t ) ; fail ( <str> ) ; } } } } 
