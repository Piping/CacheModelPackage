package org . elasticsearch . common . cache ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import java . util . * ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . LongAdder ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . function . BiFunction ; import java . util . function . ToLongBiFunction ; public class Cache < K , V > { private long expireAfterAccess = - <int> ; private boolean entriesExpireAfterAccess ; private long expireAfterWrite = - <int> ; private boolean entriesExpireAfterWrite ; private int count = <int> ; private long weight = <int> ; private long maximumWeight = - <int> ; private ToLongBiFunction < K , V > weigher = ( k , v ) - > <int> ; private RemovalListener < K , V > removalListener = notification - > { } ; Cache ( ) { } void setExpireAfterAccess ( long expireAfterAccess ) { if ( expireAfterAccess < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . expireAfterAccess = expireAfterAccess ; this . entriesExpireAfterAccess = true ; } void setExpireAfterWrite ( long expireAfterWrite ) { if ( expireAfterWrite < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . expireAfterWrite = expireAfterWrite ; this . entriesExpireAfterWrite = true ; } void setMaximumWeight ( long maximumWeight ) { if ( maximumWeight < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maximumWeight = maximumWeight ; } void setWeigher ( ToLongBiFunction < K , V > weigher ) { Objects . requireNonNull ( weigher ) ; this . weigher = weigher ; } void setRemovalListener ( RemovalListener < K , V > removalListener ) { Objects . requireNonNull ( removalListener ) ; this . removalListener = removalListener ; } protected long now ( ) { return entriesExpireAfterAccess | | entriesExpireAfterWrite ? System . nanoTime ( ) : <int> ; } enum State { NEW , EXISTING , DELETED } static class Entry < K , V > { final K key ; final V value ; long writeTime ; volatile long accessTime ; Entry < K , V > before ; Entry < K , V > after ; State state = State . NEW ; public Entry ( K key , V value , long writeTime ) { this . key = key ; this . value = value ; this . writeTime = this . accessTime = writeTime ; } } private static class CacheSegment < K , V > { ReadWriteLock segmentLock = new ReentrantReadWriteLock ( ) ; ReleasableLock readLock = new ReleasableLock ( segmentLock . readLock ( ) ) ; ReleasableLock writeLock = new ReleasableLock ( segmentLock . writeLock ( ) ) ; Map < K , CompletableFuture < Entry < K , V > > > map = new HashMap < > ( ) ; SegmentStats segmentStats = new SegmentStats ( ) ; Entry < K , V > get ( K key , long now ) { CompletableFuture < Entry < K , V > > future ; Entry < K , V > entry = null ; try ( ReleasableLock ignored = readLock . acquire ( ) ) { future = map . get ( key ) ; } if ( future ! = null ) { try { entry = future . handle ( ( ok , ex ) - > { if ( ok ! = null ) { segmentStats . hit ( ) ; ok . accessTime = now ; return ok ; } else { segmentStats . miss ( ) ; return null ; } } ) . get ( ) ; } catch ( ExecutionException | InterruptedException e ) { throw new IllegalStateException ( e ) ; } } else { segmentStats . miss ( ) ; } return entry ; } Tuple < Entry < K , V > , Entry < K , V > > put ( K key , V value , long now ) { Entry < K , V > entry = new Entry < > ( key , value , now ) ; Entry < K , V > existing = null ; try ( ReleasableLock ignored = writeLock . acquire ( ) ) { try { CompletableFuture < Entry < K , V > > future = map . put ( key , CompletableFuture . completedFuture ( entry ) ) ; if ( future ! = null ) { existing = future . handle ( ( ok , ex ) - > { if ( ok ! = null ) { return ok ; } else { return null ; } } ) . get ( ) ; } } catch ( ExecutionException | InterruptedException e ) { throw new IllegalStateException ( e ) ; } } return Tuple . tuple ( entry , existing ) ; } Entry < K , V > remove ( K key ) { CompletableFuture < Entry < K , V > > future ; Entry < K , V > entry = null ; try ( ReleasableLock ignored = writeLock . acquire ( ) ) { future = map . remove ( key ) ; } if ( future ! = null ) { try { entry = future . handle ( ( ok , ex ) - > { if ( ok ! = null ) { segmentStats . eviction ( ) ; return ok ; } else { return null ; } } ) . get ( ) ; } catch ( ExecutionException | InterruptedException e ) { throw new IllegalStateException ( e ) ; } } return entry ; } private static class SegmentStats { private final LongAdder hits = new LongAdder ( ) ; private final LongAdder misses = new LongAdder ( ) ; private final LongAdder evictions = new LongAdder ( ) ; void hit ( ) { hits . increment ( ) ; } void miss ( ) { misses . increment ( ) ; } void eviction ( ) { evictions . increment ( ) ; } } } public static final int NUMBER_OF_SEGMENTS = <int> ; private final CacheSegment < K , V > [ ] segments = new CacheSegment [ NUMBER_OF_SEGMENTS ] ; { for ( int i = <int> ; i < segments . length ; i + + ) { segments [ i ] = new CacheSegment < > ( ) ; } } Entry < K , V > head ; Entry < K , V > tail ; private ReleasableLock lruLock = new ReleasableLock ( new ReentrantLock ( ) ) ; public V get ( K key ) { return get ( key , now ( ) ) ; } private V get ( K key , long now ) { CacheSegment < K , V > segment = getCacheSegment ( key ) ; Entry < K , V > entry = segment . get ( key , now ) ; if ( entry = = null | | isExpired ( entry , now ) ) { return null ; } else { promote ( entry , now ) ; return entry . value ; } } public V computeIfAbsent ( K key , CacheLoader < K , V > loader ) throws ExecutionException { long now = now ( ) ; V value = get ( key , now ) ; if ( value = = null ) { CacheSegment < K , V > segment = getCacheSegment ( key ) ; CompletableFuture < Entry < K , V > > future ; CompletableFuture < Entry < K , V > > completableFuture = new CompletableFuture < > ( ) ; try ( ReleasableLock ignored = segment . writeLock . acquire ( ) ) { future = segment . map . putIfAbsent ( key , completableFuture ) ; } BiFunction < ? super Entry < K , V > , Throwable , ? extends V > handler = ( ok , ex ) - > { if ( ok ! = null ) { try ( ReleasableLock ignored = lruLock . acquire ( ) ) { promote ( ok , now ) ; } return ok . value ; } else { try ( ReleasableLock ignored = segment . writeLock . acquire ( ) ) { CompletableFuture < Entry < K , V > > sanity = segment . map . get ( key ) ; if ( sanity ! = null & & sanity . isCompletedExceptionally ( ) ) { segment . map . remove ( key ) ; } } return null ; } } ; CompletableFuture < V > completableValue ; if ( future = = null ) { future = completableFuture ; completableValue = future . handle ( handler ) ; V loaded ; try { loaded = loader . load ( key ) ; } catch ( Exception e ) { future . completeExceptionally ( e ) ; throw new ExecutionException ( e ) ; } if ( loaded = = null ) { NullPointerException npe = new NullPointerException ( <str> ) ; future . completeExceptionally ( npe ) ; throw new ExecutionException ( npe ) ; } else { future . complete ( new Entry < > ( key , loaded , now ) ) ; } } else { completableValue = future . handle ( handler ) ; } try { value = completableValue . get ( ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( e ) ; } } return value ; } public void put ( K key , V value ) { long now = now ( ) ; put ( key , value , now ) ; } private void put ( K key , V value , long now ) { CacheSegment < K , V > segment = getCacheSegment ( key ) ; Tuple < Entry < K , V > , Entry < K , V > > tuple = segment . put ( key , value , now ) ; boolean replaced = false ; try ( ReleasableLock ignored = lruLock . acquire ( ) ) { if ( tuple . v2 ( ) ! = null & & tuple . v2 ( ) . state = = State . EXISTING ) { if ( unlink ( tuple . v2 ( ) ) ) { replaced = true ; } } promote ( tuple . v1 ( ) , now ) ; } if ( replaced ) { removalListener . onRemoval ( new RemovalNotification ( tuple . v2 ( ) . key , tuple . v2 ( ) . value , RemovalNotification . RemovalReason . REPLACED ) ) ; } } public void invalidate ( K key ) { CacheSegment < K , V > segment = getCacheSegment ( key ) ; Entry < K , V > entry = segment . remove ( key ) ; if ( entry ! = null ) { try ( ReleasableLock ignored = lruLock . acquire ( ) ) { delete ( entry , RemovalNotification . RemovalReason . INVALIDATED ) ; } } } public void invalidateAll ( ) { Entry < K , V > h ; boolean [ ] haveSegmentLock = new boolean [ NUMBER_OF_SEGMENTS ] ; try { for ( int i = <int> ; i < NUMBER_OF_SEGMENTS ; i + + ) { segments [ i ] . segmentLock . writeLock ( ) . lock ( ) ; haveSegmentLock [ i ] = true ; } try ( ReleasableLock ignored = lruLock . acquire ( ) ) { h = head ; Arrays . stream ( segments ) . forEach ( segment - > segment . map = new HashMap < > ( ) ) ; Entry < K , V > current = head ; while ( current ! = null ) { current . state = State . DELETED ; current = current . after ; } head = tail = null ; count = <int> ; weight = <int> ; } } finally { for ( int i = NUMBER_OF_SEGMENTS - <int> ; i > = <int> ; i - - ) { if ( haveSegmentLock [ i ] ) { segments [ i ] . segmentLock . writeLock ( ) . unlock ( ) ; } } } while ( h ! = null ) { removalListener . onRemoval ( new RemovalNotification < > ( h . key , h . value , RemovalNotification . RemovalReason . INVALIDATED ) ) ; h = h . after ; } } public void refresh ( ) { long now = now ( ) ; try ( ReleasableLock ignored = lruLock . acquire ( ) ) { evict ( now ) ; } } public int count ( ) { return count ; } public long weight ( ) { return weight ; } public Iterable < K > keys ( ) { return ( ) - > new Iterator < K > ( ) { private CacheIterator iterator = new CacheIterator ( head ) ; @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public K next ( ) { return iterator . next ( ) . key ; } @Override public void remove ( ) { iterator . remove ( ) ; } } ; } public Iterable < V > values ( ) { return ( ) - > new Iterator < V > ( ) { private CacheIterator iterator = new CacheIterator ( head ) ; @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public V next ( ) { return iterator . next ( ) . value ; } } ; } private class CacheIterator implements Iterator < Entry < K , V > > { private Entry < K , V > current ; private Entry < K , V > next ; CacheIterator ( Entry < K , V > head ) { current = null ; next = head ; } @Override public boolean hasNext ( ) { return next ! = null ; } @Override public Entry < K , V > next ( ) { current = next ; next = next . after ; return current ; } @Override public void remove ( ) { Entry < K , V > entry = current ; if ( entry ! = null ) { CacheSegment < K , V > segment = getCacheSegment ( entry . key ) ; segment . remove ( entry . key ) ; try ( ReleasableLock ignored = lruLock . acquire ( ) ) { current = null ; delete ( entry , RemovalNotification . RemovalReason . INVALIDATED ) ; } } } } public CacheStats stats ( ) { long hits = <int> ; long misses = <int> ; long evictions = <int> ; for ( int i = <int> ; i < segments . length ; i + + ) { hits + = segments [ i ] . segmentStats . hits . longValue ( ) ; misses + = segments [ i ] . segmentStats . misses . longValue ( ) ; evictions + = segments [ i ] . segmentStats . evictions . longValue ( ) ; } return new CacheStats ( hits , misses , evictions ) ; } public static class CacheStats { private long hits ; private long misses ; private long evictions ; public CacheStats ( long hits , long misses , long evictions ) { this . hits = hits ; this . misses = misses ; this . evictions = evictions ; } public long getHits ( ) { return hits ; } public long getMisses ( ) { return misses ; } public long getEvictions ( ) { return evictions ; } } private boolean promote ( Entry < K , V > entry , long now ) { boolean promoted = true ; try ( ReleasableLock ignored = lruLock . acquire ( ) ) { switch ( entry . state ) { case DELETED : promoted = false ; break ; case EXISTING : relinkAtHead ( entry ) ; break ; case NEW : linkAtHead ( entry ) ; break ; } if ( promoted ) { evict ( now ) ; } } return promoted ; } private void evict ( long now ) { assert lruLock . isHeldByCurrentThread ( ) ; while ( tail ! = null & & shouldPrune ( tail , now ) ) { CacheSegment < K , V > segment = getCacheSegment ( tail . key ) ; Entry < K , V > entry = tail ; if ( segment ! = null ) { segment . remove ( tail . key ) ; } delete ( entry , RemovalNotification . RemovalReason . EVICTED ) ; } } private void delete ( Entry < K , V > entry , RemovalNotification . RemovalReason removalReason ) { assert lruLock . isHeldByCurrentThread ( ) ; if ( unlink ( entry ) ) { removalListener . onRemoval ( new RemovalNotification < > ( entry . key , entry . value , removalReason ) ) ; } } private boolean shouldPrune ( Entry < K , V > entry , long now ) { return exceedsWeight ( ) | | isExpired ( entry , now ) ; } private boolean exceedsWeight ( ) { return maximumWeight ! = - <int> & & weight > maximumWeight ; } private boolean isExpired ( Entry < K , V > entry , long now ) { return ( entriesExpireAfterAccess & & now - entry . accessTime > expireAfterAccess ) | | ( entriesExpireAfterWrite & & now - entry . writeTime > expireAfterWrite ) ; } private boolean unlink ( Entry < K , V > entry ) { assert lruLock . isHeldByCurrentThread ( ) ; if ( entry . state = = State . EXISTING ) { final Entry < K , V > before = entry . before ; final Entry < K , V > after = entry . after ; if ( before = = null ) { assert head = = entry ; head = after ; if ( head ! = null ) { head . before = null ; } } else { before . after = after ; entry . before = null ; } if ( after = = null ) { assert tail = = entry ; tail = before ; if ( tail ! = null ) { tail . after = null ; } } else { after . before = before ; entry . after = null ; } count - - ; weight - = weigher . applyAsLong ( entry . key , entry . value ) ; entry . state = State . DELETED ; return true ; } else { return false ; } } private void linkAtHead ( Entry < K , V > entry ) { assert lruLock . isHeldByCurrentThread ( ) ; Entry < K , V > h = head ; entry . before = null ; entry . after = head ; head = entry ; if ( h = = null ) { tail = entry ; } else { h . before = entry ; } count + + ; weight + = weigher . applyAsLong ( entry . key , entry . value ) ; entry . state = State . EXISTING ; } private void relinkAtHead ( Entry < K , V > entry ) { assert lruLock . isHeldByCurrentThread ( ) ; if ( head ! = entry ) { unlink ( entry ) ; linkAtHead ( entry ) ; } } private CacheSegment < K , V > getCacheSegment ( K key ) { return segments [ key . hashCode ( ) & <hex> ] ; } } 
