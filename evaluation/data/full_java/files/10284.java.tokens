package com . google . common . cache ; import static com . google . common . cache . CacheBuilder . EMPTY_STATS ; import static com . google . common . cache . LocalCacheTest . SMALL_MAX_SIZE ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . cache . LocalCache . LocalLoadingCache ; import com . google . common . cache . LocalCache . Segment ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . lang . Thread . UncaughtExceptionHandler ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; public class LocalLoadingCacheTest extends TestCase { private static < K , V > LocalLoadingCache < K , V > makeCache ( CacheBuilder < K , V > builder , CacheLoader < ? super K , V > loader ) { return new LocalLoadingCache < K , V > ( builder , loader ) ; } private CacheBuilder < Object , Object > createCacheBuilder ( ) { return CacheBuilder . newBuilder ( ) . recordStats ( ) ; } public void testComputingFunction ( ) { CacheLoader < Object , Object > loader = new CacheLoader < Object , Object > ( ) { @Override public Object load ( Object from ) { return new Object ( ) ; } } ; LocalLoadingCache < Object , Object > cache = makeCache ( createCacheBuilder ( ) , loader ) ; assertSame ( loader , cache . localCache . defaultLoader ) ; } public void testNullParameters ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; CacheLoader < Object , Object > loader = identityLoader ( ) ; tester . testAllPublicInstanceMethods ( makeCache ( createCacheBuilder ( ) , loader ) ) ; } public void testStats ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object one = new Object ( ) ; cache . getUnchecked ( one ) ; CacheStats stats = cache . stats ( ) ; assertEquals ( <int> , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> , stats . hitRate ( ) ) ; assertEquals ( <int> , stats . missCount ( ) ) ; assertEquals ( <float> , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadCount ( ) ) ; long totalLoadTime = stats . totalLoadTime ( ) ; assertTrue ( totalLoadTime > = <int> ) ; assertTrue ( stats . averageLoadPenalty ( ) > = <float> ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; cache . getUnchecked ( one ) ; stats = cache . stats ( ) ; assertEquals ( <int> , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> / <int> , stats . hitRate ( ) ) ; assertEquals ( <int> , stats . missCount ( ) ) ; assertEquals ( <float> / <int> , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadCount ( ) ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; Object two = new Object ( ) ; cache . getUnchecked ( two ) ; stats = cache . stats ( ) ; assertEquals ( <int> , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> / <int> , stats . hitRate ( ) ) ; assertEquals ( <int> , stats . missCount ( ) ) ; assertEquals ( <float> / <int> , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadCount ( ) ) ; assertTrue ( stats . totalLoadTime ( ) > = totalLoadTime ) ; totalLoadTime = stats . totalLoadTime ( ) ; assertTrue ( stats . averageLoadPenalty ( ) > = <float> ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; Object three = new Object ( ) ; cache . getUnchecked ( three ) ; stats = cache . stats ( ) ; assertEquals ( <int> , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> / <int> , stats . hitRate ( ) ) ; assertEquals ( <int> , stats . missCount ( ) ) ; assertEquals ( <float> / <int> , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadCount ( ) ) ; assertTrue ( stats . totalLoadTime ( ) > = totalLoadTime ) ; totalLoadTime = stats . totalLoadTime ( ) ; assertTrue ( stats . averageLoadPenalty ( ) > = <float> ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; } public void testStatsNoops ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) . concurrencyLevel ( <int> ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; ConcurrentMap < Object , Object > map = cache . localCache ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object one = new Object ( ) ; assertNull ( map . put ( one , one ) ) ; assertSame ( one , map . get ( one ) ) ; assertTrue ( map . containsKey ( one ) ) ; assertTrue ( map . containsValue ( one ) ) ; Object two = new Object ( ) ; assertSame ( one , map . replace ( one , two ) ) ; assertTrue ( map . containsKey ( one ) ) ; assertFalse ( map . containsValue ( one ) ) ; Object three = new Object ( ) ; assertTrue ( map . replace ( one , two , three ) ) ; assertTrue ( map . remove ( one , three ) ) ; assertFalse ( map . containsKey ( one ) ) ; assertFalse ( map . containsValue ( one ) ) ; assertNull ( map . putIfAbsent ( two , three ) ) ; assertSame ( three , map . remove ( two ) ) ; assertNull ( map . put ( three , one ) ) ; assertNull ( map . put ( one , two ) ) ; assertThat ( map ) . containsEntry ( three , one ) ; assertThat ( map ) . containsEntry ( one , two ) ; map . clear ( ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; } public void testNoStats ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object one = new Object ( ) ; cache . getUnchecked ( one ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; cache . getUnchecked ( one ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object two = new Object ( ) ; cache . getUnchecked ( two ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object three = new Object ( ) ; cache . getUnchecked ( three ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; } public void testRecordStats ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) . recordStats ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; assertEquals ( <int> , cache . stats ( ) . hitCount ( ) ) ; assertEquals ( <int> , cache . stats ( ) . missCount ( ) ) ; Object one = new Object ( ) ; cache . getUnchecked ( one ) ; assertEquals ( <int> , cache . stats ( ) . hitCount ( ) ) ; assertEquals ( <int> , cache . stats ( ) . missCount ( ) ) ; cache . getUnchecked ( one ) ; assertEquals ( <int> , cache . stats ( ) . hitCount ( ) ) ; assertEquals ( <int> , cache . stats ( ) . missCount ( ) ) ; Object two = new Object ( ) ; cache . getUnchecked ( two ) ; assertEquals ( <int> , cache . stats ( ) . hitCount ( ) ) ; assertEquals ( <int> , cache . stats ( ) . missCount ( ) ) ; Object three = new Object ( ) ; cache . getUnchecked ( three ) ; assertEquals ( <int> , cache . stats ( ) . hitCount ( ) ) ; assertEquals ( <int> , cache . stats ( ) . missCount ( ) ) ; } public void testAsMap ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; assertEquals ( EMPTY_STATS , cache . stats ( ) ) ; Object one = new Object ( ) ; Object two = new Object ( ) ; Object three = new Object ( ) ; ConcurrentMap < Object , Object > map = cache . asMap ( ) ; assertNull ( map . put ( one , two ) ) ; assertSame ( two , map . get ( one ) ) ; map . putAll ( ImmutableMap . of ( two , three ) ) ; assertSame ( three , map . get ( two ) ) ; assertSame ( two , map . putIfAbsent ( one , three ) ) ; assertSame ( two , map . get ( one ) ) ; assertNull ( map . putIfAbsent ( three , one ) ) ; assertSame ( one , map . get ( three ) ) ; assertSame ( two , map . replace ( one , three ) ) ; assertSame ( three , map . get ( one ) ) ; assertFalse ( map . replace ( one , two , three ) ) ; assertSame ( three , map . get ( one ) ) ; assertTrue ( map . replace ( one , three , two ) ) ; assertSame ( two , map . get ( one ) ) ; assertEquals ( <int> , map . size ( ) ) ; map . clear ( ) ; assertTrue ( map . isEmpty ( ) ) ; assertEquals ( <int> , map . size ( ) ) ; cache . getUnchecked ( one ) ; assertEquals ( <int> , map . size ( ) ) ; assertSame ( one , map . get ( one ) ) ; assertTrue ( map . containsKey ( one ) ) ; assertTrue ( map . containsValue ( one ) ) ; assertSame ( one , map . remove ( one ) ) ; assertEquals ( <int> , map . size ( ) ) ; cache . getUnchecked ( one ) ; assertEquals ( <int> , map . size ( ) ) ; assertFalse ( map . remove ( one , two ) ) ; assertTrue ( map . remove ( one , one ) ) ; assertEquals ( <int> , map . size ( ) ) ; cache . getUnchecked ( one ) ; Map < Object , Object > newMap = ImmutableMap . of ( one , one ) ; assertEquals ( newMap , map ) ; assertEquals ( newMap . entrySet ( ) , map . entrySet ( ) ) ; assertEquals ( newMap . keySet ( ) , map . keySet ( ) ) ; Set < Object > expectedValues = ImmutableSet . of ( one ) ; Set < Object > actualValues = ImmutableSet . copyOf ( map . values ( ) ) ; assertEquals ( expectedValues , actualValues ) ; } public void testAsMapRecency ( ) { CacheBuilder < Object , Object > builder = createCacheBuilder ( ) . concurrencyLevel ( <int> ) . maximumSize ( SMALL_MAX_SIZE ) ; LocalLoadingCache < Object , Object > cache = makeCache ( builder , identityLoader ( ) ) ; Segment < Object , Object > segment = cache . localCache . segments [ <int> ] ; ConcurrentMap < Object , Object > map = cache . asMap ( ) ; Object one = new Object ( ) ; assertSame ( one , cache . getUnchecked ( one ) ) ; assertTrue ( segment . recencyQueue . isEmpty ( ) ) ; assertSame ( one , map . get ( one ) ) ; assertSame ( one , segment . recencyQueue . peek ( ) . getKey ( ) ) ; assertSame ( one , cache . getUnchecked ( one ) ) ; assertFalse ( segment . recencyQueue . isEmpty ( ) ) ; } public void testRecursiveComputation ( ) throws InterruptedException { final AtomicReference < LoadingCache < Integer , String > > cacheRef = new AtomicReference < LoadingCache < Integer , String > > ( ) ; CacheLoader < Integer , String > recursiveLoader = new CacheLoader < Integer , String > ( ) { @Override public String load ( Integer key ) { if ( key > <int> ) { return key + <str> + cacheRef . get ( ) . getUnchecked ( key - <int> ) ; } else { return <str> ; } } } ; LoadingCache < Integer , String > recursiveCache = new CacheBuilder < Integer , String > ( ) . weakKeys ( ) . weakValues ( ) . build ( recursiveLoader ) ; cacheRef . set ( recursiveCache ) ; assertEquals ( <str> , recursiveCache . getUnchecked ( <int> ) ) ; recursiveLoader = new CacheLoader < Integer , String > ( ) { @Override public String load ( Integer key ) { return cacheRef . get ( ) . getUnchecked ( key ) ; } } ; recursiveCache = new CacheBuilder < Integer , String > ( ) . weakKeys ( ) . weakValues ( ) . build ( recursiveLoader ) ; cacheRef . set ( recursiveCache ) ; final CountDownLatch doneSignal = new CountDownLatch ( <int> ) ; Thread thread = new Thread ( ) { @Override public void run ( ) { try { cacheRef . get ( ) . getUnchecked ( <int> ) ; } finally { doneSignal . countDown ( ) ; } } } ; thread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { @Override public void uncaughtException ( Thread t , Throwable e ) { } } ) ; thread . start ( ) ; boolean done = doneSignal . await ( <int> , TimeUnit . SECONDS ) ; if ( ! done ) { StringBuilder builder = new StringBuilder ( ) ; for ( StackTraceElement trace : thread . getStackTrace ( ) ) { builder . append ( <str> ) . append ( trace ) . append ( <str> ) ; } fail ( builder . toString ( ) ) ; } } } 
