package org . apache . cassandra . stress . operations . userdefined ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import com . datastax . driver . core . BatchStatement ; import com . datastax . driver . core . BoundStatement ; import com . datastax . driver . core . PreparedStatement ; import com . datastax . driver . core . Statement ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . stress . generate . * ; import org . apache . cassandra . stress . settings . StressSettings ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . stress . util . ThriftClient ; import org . apache . cassandra . stress . util . Timer ; public class SchemaInsert extends SchemaStatement { private final BatchStatement . Type batchType ; public SchemaInsert ( Timer timer , StressSettings settings , PartitionGenerator generator , SeedManager seedManager , Distribution batchSize , RatioDistribution useRatio , RatioDistribution rowPopulation , Integer thriftId , PreparedStatement statement , ConsistencyLevel cl , BatchStatement . Type batchType ) { super ( timer , settings , new DataSpec ( generator , seedManager , batchSize , useRatio , rowPopulation ) , statement , thriftId , cl ) ; this . batchType = batchType ; } private class JavaDriverRun extends Runner { final JavaDriverClient client ; private JavaDriverRun ( JavaDriverClient client ) { this . client = client ; } public boolean run ( ) throws Exception { List < BoundStatement > stmts = new ArrayList < > ( ) ; partitionCount = partitions . size ( ) ; for ( PartitionIterator iterator : partitions ) while ( iterator . hasNext ( ) ) stmts . add ( bindRow ( iterator . next ( ) ) ) ; rowCount + = stmts . size ( ) ; for ( int j = <int> ; j < stmts . size ( ) ; j + = <int> ) { List < BoundStatement > substmts = stmts . subList ( j , Math . min ( j + stmts . size ( ) , j + <int> ) ) ; Statement stmt ; if ( stmts . size ( ) = = <int> ) { stmt = substmts . get ( <int> ) ; } else { BatchStatement batch = new BatchStatement ( batchType ) ; batch . setConsistencyLevel ( JavaDriverClient . from ( cl ) ) ; batch . addAll ( substmts ) ; stmt = batch ; } client . getSession ( ) . execute ( stmt ) ; } return true ; } } private class ThriftRun extends Runner { final ThriftClient client ; private ThriftRun ( ThriftClient client ) { this . client = client ; } public boolean run ( ) throws Exception { for ( PartitionIterator iterator : partitions ) { while ( iterator . hasNext ( ) ) { client . execute_prepared_cql3_query ( thriftId , iterator . getToken ( ) , thriftRowArgs ( iterator . next ( ) ) , settings . command . consistencyLevel ) ; rowCount + = <int> ; } } return true ; } } @Override public void run ( JavaDriverClient client ) throws IOException { timeWithRetry ( new JavaDriverRun ( client ) ) ; } public boolean isWrite ( ) { return true ; } @Override public void run ( ThriftClient client ) throws IOException { timeWithRetry ( new ThriftRun ( client ) ) ; } } 
