package org . elasticsearch . index . analysis ; import org . apache . commons . codec . Encoder ; import org . apache . commons . codec . language . * ; import org . apache . commons . codec . language . bm . Languages . LanguageSet ; import org . apache . commons . codec . language . bm . NameType ; import org . apache . commons . codec . language . bm . PhoneticEngine ; import org . apache . commons . codec . language . bm . RuleType ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . phonetic . BeiderMorseFilter ; import org . apache . lucene . analysis . phonetic . DoubleMetaphoneFilter ; import org . apache . lucene . analysis . phonetic . PhoneticFilter ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . phonetic . HaasePhonetik ; import org . elasticsearch . index . analysis . phonetic . KoelnerPhonetik ; import org . elasticsearch . index . analysis . phonetic . Nysiis ; import java . util . Arrays ; import java . util . HashSet ; public class PhoneticTokenFilterFactory extends AbstractTokenFilterFactory { private final Encoder encoder ; private final boolean replace ; private int maxcodelength ; private String [ ] languageset ; private NameType nametype ; private RuleType ruletype ; @Inject public PhoneticTokenFilterFactory ( IndexSettings indexSettings , Environment environment , String name , Settings settings ) { super ( indexSettings , name , settings ) ; this . languageset = null ; this . nametype = null ; this . ruletype = null ; this . maxcodelength = <int> ; this . replace = settings . getAsBoolean ( <str> , true ) ; String encodername = settings . get ( <str> , <str> ) ; if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Metaphone ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Soundex ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Caverphone1 ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Caverphone2 ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Caverphone2 ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) | | <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new RefinedSoundex ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new ColognePhonetic ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) | | <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = null ; this . maxcodelength = settings . getAsInt ( <str> , <int> ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) | | <str> . equalsIgnoreCase ( encodername ) | | <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = null ; this . languageset = settings . getAsArray ( <str> ) ; String ruleType = settings . get ( <str> , <str> ) ; if ( <str> . equalsIgnoreCase ( ruleType ) ) { ruletype = RuleType . APPROX ; } else if ( <str> . equalsIgnoreCase ( ruleType ) ) { ruletype = RuleType . EXACT ; } else { throw new IllegalArgumentException ( <str> + ruleType + <str> ) ; } String nameType = settings . get ( <str> , <str> ) ; if ( <str> . equalsIgnoreCase ( nameType ) ) { nametype = NameType . GENERIC ; } else if ( <str> . equalsIgnoreCase ( nameType ) ) { nametype = NameType . ASHKENAZI ; } else if ( <str> . equalsIgnoreCase ( nameType ) ) { nametype = NameType . SEPHARDIC ; } } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new KoelnerPhonetik ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new HaasePhonetik ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new Nysiis ( ) ; } else if ( <str> . equalsIgnoreCase ( encodername ) ) { this . encoder = new DaitchMokotoffSoundex ( ) ; } else { throw new IllegalArgumentException ( <str> + encodername + <str> ) ; } } @Override public TokenStream create ( TokenStream tokenStream ) { if ( encoder = = null ) { if ( ruletype ! = null & & nametype ! = null ) { if ( languageset ! = null ) { final LanguageSet languages = LanguageSet . from ( new HashSet ( Arrays . asList ( languageset ) ) ) ; return new BeiderMorseFilter ( tokenStream , new PhoneticEngine ( nametype , ruletype , true ) , languages ) ; } return new BeiderMorseFilter ( tokenStream , new PhoneticEngine ( nametype , ruletype , true ) ) ; } if ( maxcodelength > <int> ) { return new DoubleMetaphoneFilter ( tokenStream , maxcodelength , ! replace ) ; } } else { return new PhoneticFilter ( tokenStream , encoder , ! replace ) ; } throw new IllegalArgumentException ( <str> ) ; } } 
