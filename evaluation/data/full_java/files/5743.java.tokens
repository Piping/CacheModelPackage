package org . elasticsearch . common . http . client ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . Build ; import org . elasticsearch . ElasticsearchCorruptionException ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Base64 ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . hash . MessageDigests ; import org . elasticsearch . common . unit . TimeValue ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . nio . file . Path ; import java . nio . file . attribute . FileTime ; import java . util . List ; public class HttpDownloadHelper { private boolean useTimestamp = false ; private boolean skipExisting = false ; public boolean download ( URL source , Path dest , @Nullable DownloadProgress progress , TimeValue timeout ) throws Exception { if ( Files . exists ( dest ) & & skipExisting ) { return true ; } if ( progress = = null ) { progress = new NullProgress ( ) ; } long timestamp = <int> ; boolean hasTimestamp = false ; if ( useTimestamp & & Files . exists ( dest ) ) { timestamp = Files . getLastModifiedTime ( dest ) . toMillis ( ) ; hasTimestamp = true ; } GetThread getThread = new GetThread ( source , dest , hasTimestamp , timestamp , progress ) ; try { getThread . setDaemon ( true ) ; getThread . start ( ) ; getThread . join ( timeout . millis ( ) ) ; if ( getThread . isAlive ( ) ) { throw new ElasticsearchTimeoutException ( <str> + timeout + <str> ) ; } } catch ( InterruptedException ie ) { return false ; } finally { getThread . closeStreams ( ) ; } return getThread . wasSuccessful ( ) ; } public interface Checksummer { String checksum ( byte [ ] filebytes ) ; String name ( ) ; } public static Checksummer SHA1_CHECKSUM = new Checksummer ( ) { @Override public String checksum ( byte [ ] filebytes ) { return MessageDigests . toHexString ( MessageDigests . sha1 ( ) . digest ( filebytes ) ) ; } @Override public String name ( ) { return <str> ; } } ; public static Checksummer MD5_CHECKSUM = new Checksummer ( ) { @Override public String checksum ( byte [ ] filebytes ) { return MessageDigests . toHexString ( MessageDigests . md5 ( ) . digest ( filebytes ) ) ; } @Override public String name ( ) { return <str> ; } } ; public boolean downloadAndVerifyChecksum ( URL checksumURL , Path originalFile , Path checksumFile , @Nullable DownloadProgress progress , TimeValue timeout , Checksummer hashFunc ) throws Exception { try { if ( download ( checksumURL , checksumFile , progress , timeout ) ) { byte [ ] fileBytes = Files . readAllBytes ( originalFile ) ; List < String > checksumLines = Files . readAllLines ( checksumFile , StandardCharsets . UTF_8 ) ; if ( checksumLines . size ( ) ! = <int> ) { throw new ElasticsearchCorruptionException ( <str> + hashFunc . name ( ) + <str> + checksumLines . size ( ) ) ; } String checksumHex = checksumLines . get ( <int> ) ; String fileHex = hashFunc . checksum ( fileBytes ) ; if ( fileHex . equals ( checksumHex ) = = false ) { throw new ElasticsearchCorruptionException ( <str> + hashFunc . name ( ) + <str> + fileHex + <str> + checksumHex + <str> ) ; } return true ; } } catch ( FileNotFoundException | NoSuchFileException e ) { return false ; } finally { IOUtils . deleteFilesIgnoringExceptions ( checksumFile ) ; } return false ; } public interface DownloadProgress { void beginDownload ( ) ; void onTick ( ) ; void endDownload ( ) ; } public static class NullProgress implements DownloadProgress { @Override public void beginDownload ( ) { } @Override public void onTick ( ) { } @Override public void endDownload ( ) { } } public static class VerboseProgress implements DownloadProgress { private int dots = <int> ; PrintWriter writer ; public VerboseProgress ( PrintWriter writer ) { this . writer = writer ; } @Override public void beginDownload ( ) { writer . print ( <str> ) ; dots = <int> ; } @Override public void onTick ( ) { writer . print ( <str> ) ; if ( dots + + > <int> ) { writer . flush ( ) ; dots = <int> ; } } @Override public void endDownload ( ) { writer . println ( <str> ) ; writer . flush ( ) ; } } private class GetThread extends Thread { private final URL source ; private final Path dest ; private final boolean hasTimestamp ; private final long timestamp ; private final DownloadProgress progress ; private boolean success = false ; private IOException ioexception = null ; private InputStream is = null ; private OutputStream os = null ; private URLConnection connection ; private int redirections = <int> ; GetThread ( URL source , Path dest , boolean h , long t , DownloadProgress p ) { this . source = source ; this . dest = dest ; hasTimestamp = h ; timestamp = t ; progress = p ; } @Override public void run ( ) { try { success = get ( ) ; } catch ( IOException ioex ) { ioexception = ioex ; } } private boolean get ( ) throws IOException { connection = openConnection ( source ) ; if ( connection = = null ) { return false ; } boolean downloadSucceeded = downloadFile ( ) ; if ( downloadSucceeded & & useTimestamp ) { updateTimeStamp ( ) ; } return downloadSucceeded ; } private boolean redirectionAllowed ( URL aSource , URL aDest ) throws IOException { redirections + + ; if ( redirections > <int> ) { String message = <str> + <int> + <str> ; throw new IOException ( message ) ; } return true ; } private URLConnection openConnection ( URL aSource ) throws IOException { URLConnection connection = aSource . openConnection ( ) ; if ( hasTimestamp ) { connection . setIfModifiedSince ( timestamp ) ; } boolean isSecureProcotol = <str> . equalsIgnoreCase ( aSource . getProtocol ( ) ) ; boolean isAuthInfoSet = ! Strings . isNullOrEmpty ( aSource . getUserInfo ( ) ) ; if ( isAuthInfoSet ) { if ( ! isSecureProcotol ) { throw new IOException ( <str> ) ; } String basicAuth = Base64 . encodeBytes ( aSource . getUserInfo ( ) . getBytes ( StandardCharsets . UTF_8 ) ) ; connection . setRequestProperty ( <str> , <str> + basicAuth ) ; } if ( connection instanceof HttpURLConnection ) { ( ( HttpURLConnection ) connection ) . setInstanceFollowRedirects ( false ) ; connection . setUseCaches ( true ) ; connection . setConnectTimeout ( <int> ) ; } connection . setRequestProperty ( <str> , Version . CURRENT . toString ( ) ) ; connection . setRequestProperty ( <str> , Build . CURRENT . shortHash ( ) ) ; connection . setRequestProperty ( <str> , <str> ) ; connection . connect ( ) ; if ( connection instanceof HttpURLConnection ) { HttpURLConnection httpConnection = ( HttpURLConnection ) connection ; int responseCode = httpConnection . getResponseCode ( ) ; if ( responseCode = = HttpURLConnection . HTTP_MOVED_PERM | | responseCode = = HttpURLConnection . HTTP_MOVED_TEMP | | responseCode = = HttpURLConnection . HTTP_SEE_OTHER ) { String newLocation = httpConnection . getHeaderField ( <str> ) ; URL newURL = new URL ( newLocation ) ; if ( ! redirectionAllowed ( aSource , newURL ) ) { return null ; } return openConnection ( newURL ) ; } long lastModified = httpConnection . getLastModified ( ) ; if ( responseCode = = HttpURLConnection . HTTP_NOT_MODIFIED | | ( lastModified ! = <int> & & hasTimestamp & & timestamp > = lastModified ) ) { return null ; } if ( responseCode = = HttpURLConnection . HTTP_UNAUTHORIZED ) { String message = <str> ; throw new IOException ( message ) ; } } return connection ; } private boolean downloadFile ( ) throws FileNotFoundException , IOException { IOException lastEx = null ; for ( int i = <int> ; i < <int> ; i + + ) { try { is = connection . getInputStream ( ) ; break ; } catch ( IOException ex ) { lastEx = ex ; } } if ( is = = null ) { throw lastEx ; } os = Files . newOutputStream ( dest ) ; progress . beginDownload ( ) ; boolean finished = false ; try { byte [ ] buffer = new byte [ <int> * <int> ] ; int length ; while ( ! isInterrupted ( ) & & ( length = is . read ( buffer ) ) > = <int> ) { os . write ( buffer , <int> , length ) ; progress . onTick ( ) ; } finished = ! isInterrupted ( ) ; } finally { if ( ! finished ) { IOUtils . closeWhileHandlingException ( os , is ) ; IOUtils . deleteFilesIgnoringExceptions ( dest ) ; } else { IOUtils . close ( os , is ) ; } } progress . endDownload ( ) ; return true ; } private void updateTimeStamp ( ) throws IOException { long remoteTimestamp = connection . getLastModified ( ) ; if ( remoteTimestamp ! = <int> ) { Files . setLastModifiedTime ( dest , FileTime . fromMillis ( remoteTimestamp ) ) ; } } boolean wasSuccessful ( ) throws IOException { if ( ioexception ! = null ) { throw ioexception ; } return success ; } void closeStreams ( ) throws IOException { interrupt ( ) ; if ( success ) { IOUtils . close ( is , os ) ; } else { IOUtils . closeWhileHandlingException ( is , os ) ; if ( dest ! = null & & Files . exists ( dest ) ) { IOUtils . deleteFilesIgnoringExceptions ( dest ) ; } } } } } 
