package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . DelimiterBasedFrameDecoder ; import io . netty . handler . codec . Delimiters ; import io . netty . handler . codec . string . StringDecoder ; import io . netty . handler . codec . string . StringEncoder ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . io . IOException ; import java . util . Random ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . * ; public class SocketStringEchoTest extends AbstractSocketTest { static final Random random = new Random ( ) ; static final String [ ] data = new String [ <int> ] ; static { for ( int i = <int> ; i < data . length ; i + + ) { int eLen = random . nextInt ( <int> ) ; char [ ] e = new char [ eLen ] ; for ( int j = <int> ; j < eLen ; j + + ) { e [ j ] = ( char ) ( <str> + random . nextInt ( <int> ) ) ; } data [ i ] = new String ( e ) ; } } @Test public void testStringEcho ( ) throws Throwable { run ( ) ; } public void testStringEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { testStringEcho ( sb , cb , true ) ; } @Test public void testStringEchoNotAutoRead ( ) throws Throwable { run ( ) ; } public void testStringEchoNotAutoRead ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { testStringEcho ( sb , cb , false ) ; } private static void testStringEcho ( ServerBootstrap sb , Bootstrap cb , boolean autoRead ) throws Throwable { sb . childOption ( ChannelOption . AUTO_READ , autoRead ) ; cb . option ( ChannelOption . AUTO_READ , autoRead ) ; final StringEchoHandler sh = new StringEchoHandler ( autoRead ) ; final StringEchoHandler ch = new StringEchoHandler ( autoRead ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override public void initChannel ( Channel sch ) throws Exception { sch . pipeline ( ) . addLast ( <str> , new DelimiterBasedFrameDecoder ( <int> , Delimiters . lineDelimiter ( ) ) ) ; sch . pipeline ( ) . addLast ( <str> , new StringDecoder ( CharsetUtil . ISO_8859_1 ) ) ; sch . pipeline ( ) . addBefore ( <str> , <str> , new StringEncoder ( CharsetUtil . ISO_8859_1 ) ) ; sch . pipeline ( ) . addAfter ( <str> , <str> , sh ) ; } } ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override public void initChannel ( Channel sch ) throws Exception { sch . pipeline ( ) . addLast ( <str> , new DelimiterBasedFrameDecoder ( <int> , Delimiters . lineDelimiter ( ) ) ) ; sch . pipeline ( ) . addLast ( <str> , new StringDecoder ( CharsetUtil . ISO_8859_1 ) ) ; sch . pipeline ( ) . addBefore ( <str> , <str> , new StringEncoder ( CharsetUtil . ISO_8859_1 ) ) ; sch . pipeline ( ) . addAfter ( <str> , <str> , ch ) ; } } ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; for ( String element : data ) { String delimiter = random . nextBoolean ( ) ? <str> : <str> ; cc . writeAndFlush ( element + delimiter ) ; } while ( ch . counter < data . length ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } while ( sh . counter < data . length ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } sh . channel . close ( ) . sync ( ) ; ch . channel . close ( ) . sync ( ) ; sc . close ( ) . sync ( ) ; if ( sh . exception . get ( ) ! = null & & ! ( sh . exception . get ( ) instanceof IOException ) ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null & & ! ( ch . exception . get ( ) instanceof IOException ) ) { throw ch . exception . get ( ) ; } if ( sh . exception . get ( ) ! = null ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null ) { throw ch . exception . get ( ) ; } } static class StringEchoHandler extends SimpleChannelInboundHandler < String > { private final boolean autoRead ; volatile Channel channel ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; volatile int counter ; StringEchoHandler ( boolean autoRead ) { this . autoRead = autoRead ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { channel = ctx . channel ( ) ; if ( ! autoRead ) { ctx . read ( ) ; } } @Override public void channelRead0 ( ChannelHandlerContext ctx , String msg ) throws Exception { assertEquals ( data [ counter ] , msg ) ; if ( channel . parent ( ) ! = null ) { String delimiter = random . nextBoolean ( ) ? <str> : <str> ; channel . write ( msg + delimiter ) ; } counter + + ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { try { ctx . flush ( ) ; } finally { if ( ! autoRead ) { ctx . read ( ) ; } } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { ctx . close ( ) ; } } } } 
