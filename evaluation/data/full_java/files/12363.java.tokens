package org . gradle . api . internal ; import groovy . lang . Closure ; import groovy . lang . MissingPropertyException ; import org . gradle . api . * ; import org . gradle . api . specs . Spec ; import org . gradle . api . specs . Specs ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . util . ConfigureUtil ; import org . gradle . util . GUtil ; import org . gradle . util . TestClosure ; import org . gradle . util . TestUtil ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . util . Iterator ; import static org . gradle . util . TestUtil . call ; import static org . gradle . util . TestUtil . toClosure ; import static org . gradle . util . WrapUtil . toList ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class DefaultNamedDomainObjectSetTest { private final org . gradle . internal . reflect . Instantiator instantiator = new ClassGeneratorBackedInstantiator ( new AsmBackedClassGenerator ( ) , DirectInstantiator . INSTANCE ) ; private final Namer < Bean > namer = new Namer < Bean > ( ) { public String determineName ( Bean bean ) { return bean . name ; } } ; @SuppressWarnings ( <str> ) private final DefaultNamedDomainObjectSet < Bean > container = instantiator . newInstance ( DefaultNamedDomainObjectSet . class , Bean . class , instantiator , namer ) ; private final JUnit4Mockery context = new JUnit4Mockery ( ) ; @Test public void usesTypeNameToGenerateDisplayName ( ) { assertThat ( container . getTypeDisplayName ( ) , equalTo ( <str> ) ) ; assertThat ( container . getDisplayName ( ) , equalTo ( <str> ) ) ; } @Test public void canGetAllDomainObjectsForEmptyContainer ( ) { assertTrue ( container . isEmpty ( ) ) ; } @Test public void canGetAllDomainObjectsOrderedByName ( ) { Bean bean1 = new Bean ( <str> ) ; Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; container . add ( bean2 ) ; container . add ( bean1 ) ; container . add ( bean3 ) ; assertThat ( toList ( container ) , equalTo ( toList ( bean1 , bean2 , bean3 ) ) ) ; } @Test public void canIterateOverEmptyContainer ( ) { Iterator < Bean > iterator = container . iterator ( ) ; assertFalse ( iterator . hasNext ( ) ) ; } @Test public void canIterateOverDomainObjectsOrderedByName ( ) { Bean bean1 = new Bean ( <str> ) ; Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; container . add ( bean2 ) ; container . add ( bean1 ) ; container . add ( bean3 ) ; Iterator < Bean > iterator = container . iterator ( ) ; assertThat ( iterator . next ( ) , sameInstance ( bean1 ) ) ; assertThat ( iterator . next ( ) , sameInstance ( bean2 ) ) ; assertThat ( iterator . next ( ) , sameInstance ( bean3 ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } @Test public void canGetAllDomainObjectsAsMapForEmptyContainer ( ) { assertTrue ( container . getAsMap ( ) . isEmpty ( ) ) ; } @Test public void canGetAllDomainObjectsAsMap ( ) { Bean bean1 = new Bean ( <str> ) ; Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; container . add ( bean2 ) ; container . add ( bean1 ) ; container . add ( bean3 ) ; assertThat ( container . getAsMap ( ) , equalTo ( GUtil . map ( <str> , bean1 , <str> , bean2 , <str> , bean3 ) ) ) ; } @Test public void canGetAllMatchingDomainObjectsOrderedByName ( ) { Bean bean1 = new Bean ( <str> ) ; final Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element = = bean2 ; } } ; container . add ( bean1 ) ; container . add ( bean2 ) ; container . add ( bean3 ) ; assertThat ( toList ( container . matching ( spec ) ) , equalTo ( toList ( bean2 ) ) ) ; } @Test public void getAllMatchingDomainObjectsReturnsEmptySetWhenNoMatches ( ) { Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return false ; } } ; container . add ( new Bean ( <str> ) ) ; assertTrue ( container . matching ( spec ) . isEmpty ( ) ) ; } @Test public void canGetFilteredCollectionContainingAllObjectsWhichMeetSpec ( ) { final Bean bean1 = new Bean ( <str> ) ; Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element ! = bean1 ; } } ; TestClosure testClosure = new TestClosure ( ) { public Object call ( Object param ) { return param ! = bean1 ; } } ; container . add ( bean1 ) ; container . add ( bean2 ) ; container . add ( bean3 ) ; assertThat ( toList ( container . matching ( spec ) ) , equalTo ( toList ( bean2 , bean3 ) ) ) ; assertThat ( toList ( container . matching ( TestUtil . toClosure ( testClosure ) ) ) , equalTo ( toList ( bean2 , bean3 ) ) ) ; assertThat ( container . matching ( spec ) . findByName ( <str> ) , nullValue ( ) ) ; assertThat ( container . matching ( spec ) . findByName ( <str> ) , sameInstance ( bean2 ) ) ; } @Test public void canGetFilteredCollectionContainingAllObjectsWhichHaveType ( ) { class OtherBean extends Bean { public OtherBean ( String name ) { super ( name ) ; } } Bean bean1 = new Bean ( <str> ) ; OtherBean bean2 = new OtherBean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; container . add ( bean1 ) ; container . add ( bean2 ) ; container . add ( bean3 ) ; assertThat ( toList ( container . withType ( Bean . class ) ) , equalTo ( toList ( bean1 , bean2 , bean3 ) ) ) ; assertThat ( toList ( container . withType ( OtherBean . class ) ) , equalTo ( toList ( bean2 ) ) ) ; assertThat ( container . withType ( OtherBean . class ) . findByName ( <str> ) , nullValue ( ) ) ; assertThat ( container . withType ( OtherBean . class ) . findByName ( <str> ) , sameInstance ( bean2 ) ) ; } @Test public void canExecuteActionForAllElementsInATypeFilteredCollection ( ) { class OtherBean extends Bean { public OtherBean ( String name ) { super ( name ) ; } public OtherBean ( ) { } } final Action < OtherBean > action = context . mock ( Action . class ) ; Bean bean1 = new Bean ( <str> ) ; final OtherBean bean2 = new OtherBean ( <str> ) ; container . add ( bean1 ) ; container . add ( bean2 ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean2 ) ; } } ) ; container . withType ( OtherBean . class , action ) ; } @Test public void canExecuteClosureForAllElementsInATypeFilteredCollection ( ) { class OtherBean extends Bean { public OtherBean ( String name ) { super ( name ) ; } public OtherBean ( ) { } } final TestClosure closure = context . mock ( TestClosure . class ) ; Bean bean1 = new Bean ( <str> ) ; final OtherBean bean2 = new OtherBean ( <str> ) ; container . add ( bean1 ) ; container . add ( bean2 ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( bean2 ) ; } } ) ; container . withType ( OtherBean . class , TestUtil . toClosure ( closure ) ) ; } @Test public void filteredCollectionIsLive ( ) { final Bean bean1 = new Bean ( <str> ) ; Bean bean2 = new Bean ( <str> ) ; Bean bean3 = new Bean ( <str> ) ; Bean bean4 = new Bean ( <str> ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element ! = bean1 ; } } ; container . add ( bean1 ) ; DomainObjectCollection < Bean > filteredCollection = container . matching ( spec ) ; assertTrue ( filteredCollection . isEmpty ( ) ) ; container . add ( bean2 ) ; container . add ( bean3 ) ; assertThat ( toList ( filteredCollection ) , equalTo ( toList ( bean2 , bean3 ) ) ) ; container . add ( bean4 ) ; assertThat ( toList ( filteredCollection ) , equalTo ( toList ( bean2 , bean3 , bean4 ) ) ) ; assertThat ( container . removeByName ( <str> ) , sameInstance ( bean2 ) ) ; assertThat ( toList ( filteredCollection ) , equalTo ( toList ( bean3 , bean4 ) ) ) ; } @Test public void filteredCollectionExecutesActionWhenMatchingObjectAdded ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; } } ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element = = bean ; } } ; container . matching ( spec ) . whenObjectAdded ( action ) ; container . add ( bean ) ; container . add ( new Bean ( ) ) ; } @Test public void filteredCollectionExecutesClosureWhenMatchingObjectAdded ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( bean ) ; } } ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element = = bean ; } } ; container . matching ( spec ) . whenObjectAdded ( TestUtil . toClosure ( closure ) ) ; container . add ( bean ) ; container . add ( new Bean ( ) ) ; } @Test public void canChainFilteredCollections ( ) { final Bean bean = new Bean ( <str> ) ; final Bean bean2 = new Bean ( <str> ) ; final Bean bean3 = new Bean ( <str> ) ; Spec < Bean > spec = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element ! = bean ; } } ; Spec < Bean > spec2 = new Spec < Bean > ( ) { public boolean isSatisfiedBy ( Bean element ) { return element ! = bean2 ; } } ; container . add ( bean ) ; container . add ( bean2 ) ; container . add ( bean3 ) ; DomainObjectCollection < Bean > collection = container . matching ( spec ) . matching ( spec2 ) ; assertThat ( toList ( collection ) , equalTo ( toList ( bean3 ) ) ) ; } @Test public void canGetDomainObjectByName ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; assertThat ( container . getByName ( <str> ) , sameInstance ( bean ) ) ; assertThat ( container . getAt ( <str> ) , sameInstance ( bean ) ) ; } @Test public void getDomainObjectByNameFailsForUnknownDomainObject ( ) { try { container . getByName ( <str> ) ; fail ( ) ; } catch ( UnknownDomainObjectException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } } @Test public void getDomainObjectInvokesRuleForUnknownDomainObject ( ) { Bean bean = new Bean ( ) ; addRuleFor ( bean ) ; assertThat ( container . getByName ( <str> ) , sameInstance ( bean ) ) ; } @Test public void canConfigureDomainObjectByName ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; assertThat ( container . getByName ( <str> , toClosure ( <str> ) ) , sameInstance ( bean ) ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; } @Test public void configureDomainObjectInvokesRuleForUnknownDomainObject ( ) { Bean bean = new Bean ( ) ; addRuleFor ( bean ) ; assertThat ( container . getByName ( <str> , toClosure ( <str> ) ) , sameInstance ( bean ) ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; } @Test public void canFindDomainObjectByName ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; assertThat ( container . findByName ( <str> ) , sameInstance ( bean ) ) ; } @Test public void findDomainObjectByNameReturnsNullForUnknownDomainObject ( ) { assertThat ( container . findByName ( <str> ) , nullValue ( ) ) ; } @Test public void findDomainObjectByNameInvokesRulesForUnknownDomainObject ( ) { Bean bean = new Bean ( <str> ) ; addRuleFor ( bean ) ; assertThat ( container . findByName ( <str> ) , sameInstance ( bean ) ) ; } @Test public void findDomainObjectByNameInvokesNestedRulesOnlyOnceForUnknownDomainObject ( ) { final Bean bean1 = new Bean ( <str> ) ; final Bean bean2 = new Bean ( <str> ) ; container . addRule ( new Rule ( ) { public String getDescription ( ) { return <str> ; } public void apply ( String domainObjectName ) { if ( domainObjectName . equals ( <str> ) ) { container . add ( bean1 ) ; } } } ) ; container . addRule ( new Rule ( ) { private boolean applyHasBeenCalled ; public String getDescription ( ) { return <str> ; } public void apply ( String domainObjectName ) { if ( domainObjectName . equals ( <str> ) ) { assertThat ( applyHasBeenCalled , equalTo ( false ) ) ; container . findByName ( <str> ) ; container . findByName ( <str> ) ; container . add ( bean2 ) ; applyHasBeenCalled = true ; } } } ) ; container . findByName ( <str> ) ; assertThat ( toList ( container ) , equalTo ( toList ( bean1 , bean2 ) ) ) ; } @Test public void callsActionWhenObjectAdded ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; } } ) ; container . whenObjectAdded ( action ) ; container . add ( bean ) ; } @Test public void callsClosureWhenObjectAdded ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( bean ) ; } } ) ; container . whenObjectAdded ( TestUtil . toClosure ( closure ) ) ; container . add ( bean ) ; } @Test public void doesNotCallActionWhenDuplicateObjectAdded ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; container . add ( bean ) ; container . whenObjectAdded ( action ) ; container . add ( bean ) ; } @Test public void callsActionWhenObjectsAdded ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; final Bean bean2 = new Bean ( <str> ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; one ( action ) . execute ( bean2 ) ; } } ) ; container . whenObjectAdded ( action ) ; container . addAll ( toList ( bean , bean2 ) ) ; } @Test public void doesNotCallActionWhenDuplicateObjectsAdded ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; final Bean bean2 = new Bean ( <str> ) ; container . add ( bean ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean2 ) ; } } ) ; container . whenObjectAdded ( action ) ; container . addAll ( toList ( bean , bean2 ) ) ; } @Test public void callsActionWhenObjectRemoved ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; } } ) ; container . whenObjectRemoved ( action ) ; container . add ( bean ) ; container . removeByName ( <str> ) ; } @Test public void doesNotCallActionWhenUnknownObjectRemoved ( ) { final Action < Bean > action = context . mock ( Action . class ) ; container . whenObjectRemoved ( action ) ; container . remove ( new Bean ( ) ) ; } @Test public void allCallsActionForEachExistingObject ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; } } ) ; container . add ( bean ) ; container . all ( action ) ; } @Test public void allCallsClosureForEachExistingObject ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( bean ) ; } } ) ; container . add ( bean ) ; container . all ( TestUtil . toClosure ( closure ) ) ; } @Test public void allCallsActionForEachNewObject ( ) { final Action < Bean > action = context . mock ( Action . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( bean ) ; } } ) ; container . all ( action ) ; container . add ( bean ) ; } @Test public void allCallsClosureForEachNewObject ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; final Bean bean = new Bean ( ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( bean ) ; } } ) ; container . all ( TestUtil . toClosure ( closure ) ) ; container . add ( bean ) ; } @Test public void eachObjectIsAvailableAsADynamicProperty ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; assertTrue ( container . withType ( Bean . class ) . findByName ( <str> ) ! = null ) ; assertTrue ( container . getAsDynamicObject ( ) . hasProperty ( <str> ) ) ; assertThat ( container . getAsDynamicObject ( ) . getProperty ( <str> ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( container . getAsDynamicObject ( ) . getProperties ( ) . get ( <str> ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( call ( <str> , container ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( call ( <str> , container . withType ( Bean . class ) ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( call ( <str> , container . matching ( Specs . satisfyAll ( ) ) ) , sameInstance ( ( Object ) bean ) ) ; } @Test public void eachObjectIsAvailableUsingAnIndex ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; assertThat ( call ( <str> , container ) , sameInstance ( ( Object ) bean ) ) ; } @Test public void cannotGetUnknownProperty ( ) { assertFalse ( container . getAsDynamicObject ( ) . hasProperty ( <str> ) ) ; try { container . getAsDynamicObject ( ) . getProperty ( <str> ) ; fail ( ) ; } catch ( MissingPropertyException e ) { } } @Test public void dynamicPropertyAccessInvokesRulesForUnknownDomainObject ( ) { Bean bean = new Bean ( ) ; addRuleFor ( bean ) ; assertTrue ( container . getAsDynamicObject ( ) . hasProperty ( <str> ) ) ; assertThat ( container . getAsDynamicObject ( ) . getProperty ( <str> ) , sameInstance ( ( Object ) bean ) ) ; } @Test public void eachObjectIsAvailableAsConfigureMethod ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; Closure closure = toClosure ( <str> ) ; assertTrue ( container . getAsDynamicObject ( ) . hasMethod ( <str> , closure ) ) ; container . getAsDynamicObject ( ) . invokeMethod ( <str> , closure ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; call ( <str> , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; call ( <str> , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; } @Test public void canUseDynamicPropertiesAndMethodsInsideConfigureClosures ( ) { Bean bean = new Bean ( <str> ) ; container . add ( bean ) ; container . add ( bean ) ; container . add ( bean ) ; container . add ( bean ) ; container . add ( bean ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( bean . getBeanProperty ( ) , equalTo ( <str> ) ) ; Bean withType = new Bean ( <str> ) ; container . add ( withType ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( withType . getBeanProperty ( ) , equalTo ( <str> ) ) ; ConfigureUtil . configure ( toClosure ( <str> ) , container ) ; assertThat ( withType . getBeanProperty ( ) , equalTo ( <str> ) ) ; } @Test public void cannotInvokeUnknownMethod ( ) { container . add ( new Bean ( <str> ) ) ; assertMethodUnknown ( <str> ) ; assertMethodUnknown ( <str> , toClosure ( <str> ) ) ; assertMethodUnknown ( <str> ) ; assertMethodUnknown ( <str> , <str> ) ; assertMethodUnknown ( <str> , toClosure ( <str> ) , <str> ) ; } private void assertMethodUnknown ( String name , Object . . . arguments ) { assertFalse ( container . getAsDynamicObject ( ) . hasMethod ( name , arguments ) ) ; try { container . getAsDynamicObject ( ) . invokeMethod ( name , arguments ) ; fail ( ) ; } catch ( groovy . lang . MissingMethodException e ) { } } @Test public void configureMethodInvokesRuleForUnknownDomainObject ( ) { Bean bean = new Bean ( ) ; addRuleFor ( bean ) ; assertTrue ( container . getAsDynamicObject ( ) . hasMethod ( <str> , toClosure ( <str> ) ) ) ; } @Test public void addRuleByClosure ( ) { String testPropertyKey = <str> ; String expectedTaskName = <str> ; Closure ruleClosure = TestUtil . toClosure ( String . format ( <str> , testPropertyKey , expectedTaskName ) ) ; container . addRule ( <str> , ruleClosure ) ; container . getRules ( ) . get ( <int> ) . apply ( expectedTaskName ) ; assertThat ( System . getProperty ( testPropertyKey ) , equalTo ( expectedTaskName ) ) ; System . getProperties ( ) . remove ( testPropertyKey ) ; } private void addRuleFor ( final Bean bean ) { container . addRule ( new Rule ( ) { public String getDescription ( ) { throw new UnsupportedOperationException ( ) ; } public void apply ( String taskName ) { container . add ( bean ) ; } } ) ; } private class Bean { public final String name ; private String beanProperty ; public Bean ( ) { this ( <str> ) ; } public Bean ( String name ) { this . name = name ; } public String getBeanProperty ( ) { return beanProperty ; } public void setBeanProperty ( String beanProperty ) { this . beanProperty = beanProperty ; } } } 
