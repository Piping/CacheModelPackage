package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . Serialization . FieldSetter ; import com . google . common . math . IntMath ; import com . google . common . primitives . Ints ; import com . google . j2objc . annotations . WeakOuter ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicInteger ; import javax . annotation . Nullable ; public final class ConcurrentHashMultiset < E > extends AbstractMultiset < E > implements Serializable { private final transient ConcurrentMap < E , AtomicInteger > countMap ; private static class FieldSettersHolder { static final FieldSetter < ConcurrentHashMultiset > COUNT_MAP_FIELD_SETTER = Serialization . getFieldSetter ( ConcurrentHashMultiset . class , <str> ) ; } public static < E > ConcurrentHashMultiset < E > create ( ) { return new ConcurrentHashMultiset < E > ( new ConcurrentHashMap < E , AtomicInteger > ( ) ) ; } public static < E > ConcurrentHashMultiset < E > create ( Iterable < ? extends E > elements ) { ConcurrentHashMultiset < E > multiset = ConcurrentHashMultiset . create ( ) ; Iterables . addAll ( multiset , elements ) ; return multiset ; } @Beta public static < E > ConcurrentHashMultiset < E > create ( MapMaker mapMaker ) { return new ConcurrentHashMultiset < E > ( mapMaker . < E , AtomicInteger > makeMap ( ) ) ; } @VisibleForTesting ConcurrentHashMultiset ( ConcurrentMap < E , AtomicInteger > countMap ) { checkArgument ( countMap . isEmpty ( ) ) ; this . countMap = countMap ; } @Override public int count ( @Nullable Object element ) { AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; return ( existingCounter = = null ) ? <int> : existingCounter . get ( ) ; } @Override public int size ( ) { long sum = <int> L ; for ( AtomicInteger value : countMap . values ( ) ) { sum + = value . get ( ) ; } return Ints . saturatedCast ( sum ) ; } @Override public Object [ ] toArray ( ) { return snapshot ( ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return snapshot ( ) . toArray ( array ) ; } private List < E > snapshot ( ) { List < E > list = Lists . newArrayListWithExpectedSize ( size ( ) ) ; for ( Multiset . Entry < E > entry : entrySet ( ) ) { E element = entry . getElement ( ) ; for ( int i = entry . getCount ( ) ; i > <int> ; i - - ) { list . add ( element ) ; } } return list ; } @Override public int add ( E element , int occurrences ) { checkNotNull ( element ) ; if ( occurrences = = <int> ) { return count ( element ) ; } CollectPreconditions . checkPositive ( occurrences , <str> ) ; while ( true ) { AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; if ( existingCounter = = null ) { existingCounter = countMap . putIfAbsent ( element , new AtomicInteger ( occurrences ) ) ; if ( existingCounter = = null ) { return <int> ; } } while ( true ) { int oldValue = existingCounter . get ( ) ; if ( oldValue ! = <int> ) { try { int newValue = IntMath . checkedAdd ( oldValue , occurrences ) ; if ( existingCounter . compareAndSet ( oldValue , newValue ) ) { return oldValue ; } } catch ( ArithmeticException overflow ) { throw new IllegalArgumentException ( <str> + occurrences + <str> + oldValue ) ; } } else { AtomicInteger newCounter = new AtomicInteger ( occurrences ) ; if ( ( countMap . putIfAbsent ( element , newCounter ) = = null ) | | countMap . replace ( element , existingCounter , newCounter ) ) { return <int> ; } break ; } } } } @Override public int remove ( @Nullable Object element , int occurrences ) { if ( occurrences = = <int> ) { return count ( element ) ; } CollectPreconditions . checkPositive ( occurrences , <str> ) ; AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; if ( existingCounter = = null ) { return <int> ; } while ( true ) { int oldValue = existingCounter . get ( ) ; if ( oldValue ! = <int> ) { int newValue = Math . max ( <int> , oldValue - occurrences ) ; if ( existingCounter . compareAndSet ( oldValue , newValue ) ) { if ( newValue = = <int> ) { countMap . remove ( element , existingCounter ) ; } return oldValue ; } } else { return <int> ; } } } public boolean removeExactly ( @Nullable Object element , int occurrences ) { if ( occurrences = = <int> ) { return true ; } CollectPreconditions . checkPositive ( occurrences , <str> ) ; AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; if ( existingCounter = = null ) { return false ; } while ( true ) { int oldValue = existingCounter . get ( ) ; if ( oldValue < occurrences ) { return false ; } int newValue = oldValue - occurrences ; if ( existingCounter . compareAndSet ( oldValue , newValue ) ) { if ( newValue = = <int> ) { countMap . remove ( element , existingCounter ) ; } return true ; } } } @Override public int setCount ( E element , int count ) { checkNotNull ( element ) ; checkNonnegative ( count , <str> ) ; while ( true ) { AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; if ( existingCounter = = null ) { if ( count = = <int> ) { return <int> ; } else { existingCounter = countMap . putIfAbsent ( element , new AtomicInteger ( count ) ) ; if ( existingCounter = = null ) { return <int> ; } } } while ( true ) { int oldValue = existingCounter . get ( ) ; if ( oldValue = = <int> ) { if ( count = = <int> ) { return <int> ; } else { AtomicInteger newCounter = new AtomicInteger ( count ) ; if ( ( countMap . putIfAbsent ( element , newCounter ) = = null ) | | countMap . replace ( element , existingCounter , newCounter ) ) { return <int> ; } } break ; } else { if ( existingCounter . compareAndSet ( oldValue , count ) ) { if ( count = = <int> ) { countMap . remove ( element , existingCounter ) ; } return oldValue ; } } } } } @Override public boolean setCount ( E element , int expectedOldCount , int newCount ) { checkNotNull ( element ) ; checkNonnegative ( expectedOldCount , <str> ) ; checkNonnegative ( newCount , <str> ) ; AtomicInteger existingCounter = Maps . safeGet ( countMap , element ) ; if ( existingCounter = = null ) { if ( expectedOldCount ! = <int> ) { return false ; } else if ( newCount = = <int> ) { return true ; } else { return countMap . putIfAbsent ( element , new AtomicInteger ( newCount ) ) = = null ; } } int oldValue = existingCounter . get ( ) ; if ( oldValue = = expectedOldCount ) { if ( oldValue = = <int> ) { if ( newCount = = <int> ) { countMap . remove ( element , existingCounter ) ; return true ; } else { AtomicInteger newCounter = new AtomicInteger ( newCount ) ; return ( countMap . putIfAbsent ( element , newCounter ) = = null ) | | countMap . replace ( element , existingCounter , newCounter ) ; } } else { if ( existingCounter . compareAndSet ( oldValue , newCount ) ) { if ( newCount = = <int> ) { countMap . remove ( element , existingCounter ) ; } return true ; } } } return false ; } @Override Set < E > createElementSet ( ) { final Set < E > delegate = countMap . keySet ( ) ; return new ForwardingSet < E > ( ) { @Override protected Set < E > delegate ( ) { return delegate ; } @Override public boolean contains ( @Nullable Object object ) { return object ! = null & & Collections2 . safeContains ( delegate , object ) ; } @Override public boolean containsAll ( Collection < ? > collection ) { return standardContainsAll ( collection ) ; } @Override public boolean remove ( Object object ) { return object ! = null & & Collections2 . safeRemove ( delegate , object ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return standardRemoveAll ( c ) ; } } ; } @Override public Set < Multiset . Entry < E > > createEntrySet ( ) { return new EntrySet ( ) ; } @Override int distinctElements ( ) { return countMap . size ( ) ; } @Override public boolean isEmpty ( ) { return countMap . isEmpty ( ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > readOnlyIterator = new AbstractIterator < Entry < E > > ( ) { private Iterator < Map . Entry < E , AtomicInteger > > mapEntries = countMap . entrySet ( ) . iterator ( ) ; @Override protected Entry < E > computeNext ( ) { while ( true ) { if ( ! mapEntries . hasNext ( ) ) { return endOfData ( ) ; } Map . Entry < E , AtomicInteger > mapEntry = mapEntries . next ( ) ; int count = mapEntry . getValue ( ) . get ( ) ; if ( count ! = <int> ) { return Multisets . immutableEntry ( mapEntry . getKey ( ) , count ) ; } } } } ; return new ForwardingIterator < Entry < E > > ( ) { private Entry < E > last ; @Override protected Iterator < Entry < E > > delegate ( ) { return readOnlyIterator ; } @Override public Entry < E > next ( ) { last = super . next ( ) ; return last ; } @Override public void remove ( ) { checkRemove ( last ! = null ) ; ConcurrentHashMultiset . this . setCount ( last . getElement ( ) , <int> ) ; last = null ; } } ; } @Override public void clear ( ) { countMap . clear ( ) ; } @WeakOuter private class EntrySet extends AbstractMultiset < E > . EntrySet { @Override ConcurrentHashMultiset < E > multiset ( ) { return ConcurrentHashMultiset . this ; } @Override public Object [ ] toArray ( ) { return snapshot ( ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return snapshot ( ) . toArray ( array ) ; } private List < Multiset . Entry < E > > snapshot ( ) { List < Multiset . Entry < E > > list = Lists . newArrayListWithExpectedSize ( size ( ) ) ; Iterators . addAll ( list , iterator ( ) ) ; return list ; } } private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( countMap ) ; } private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; @SuppressWarnings ( <str> ) ConcurrentMap < E , Integer > deserializedCountMap = ( ConcurrentMap < E , Integer > ) stream . readObject ( ) ; FieldSettersHolder . COUNT_MAP_FIELD_SETTER . set ( this , deserializedCountMap ) ; } private static final long serialVersionUID = <int> ; } 
