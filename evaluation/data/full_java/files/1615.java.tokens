package org . apache . cassandra . service ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . Iterators ; import com . google . common . collect . Sets ; import org . junit . * ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . ByteType ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . net . * ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . Util . assertClustering ; import static org . apache . cassandra . Util . assertColumn ; import static org . apache . cassandra . Util . assertColumns ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class DataResolverTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; public static final String CF_COLLECTION = <str> ; private int addressSuffix = <int> ; private DecoratedKey dk ; private Keyspace ks ; private ColumnFamilyStore cfs ; private ColumnFamilyStore cfs2 ; private CFMetaData cfm ; private CFMetaData cfm2 ; private ColumnDefinition m ; private int nowInSec ; private ReadCommand command ; private MessageRecorder messageRecorder ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { CFMetaData cfMetadata = CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARD ) . addPartitionKey ( <str> , BytesType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) ; CFMetaData cfMetaData2 = CFMetaData . Builder . create ( KEYSPACE1 , CF_COLLECTION ) . addPartitionKey ( <str> , ByteType . instance ) . addRegularColumn ( <str> , MapType . getInstance ( IntegerType . instance , IntegerType . instance , true ) ) . build ( ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , cfMetadata , cfMetaData2 ) ; } @Before public void setup ( ) { dk = Util . dk ( <str> ) ; ks = Keyspace . open ( KEYSPACE1 ) ; cfs = ks . getColumnFamilyStore ( CF_STANDARD ) ; cfm = cfs . metadata ; cfs2 = ks . getColumnFamilyStore ( CF_COLLECTION ) ; cfm2 = cfs2 . metadata ; m = cfm2 . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ; nowInSec = FBUtilities . nowInSeconds ( ) ; command = Util . cmd ( cfs , dk ) . withNowInSeconds ( nowInSec ) . build ( ) ; } @Before public void injectMessageSink ( ) { messageRecorder = new MessageRecorder ( ) ; MessagingService . instance ( ) . addMessageSink ( messageRecorder ) ; } @After public void removeMessageSink ( ) { MessagingService . instance ( ) . clearMessageSinks ( ) ; } @Test public void testResolveNewerSingleRow ( ) throws UnknownHostException { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } @Test public void testResolveDisjointSingleRow ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer2 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } @Test public void testResolveDisjointMultipleRows ( ) throws UnknownHostException { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ) { try ( RowIterator rows = data . next ( ) ) { Row row = rows . next ( ) ; assertClustering ( cfm , row , <str> ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; row = rows . next ( ) ; assertClustering ( cfm , row , <str> ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; assertFalse ( rows . hasNext ( ) ) ; assertFalse ( data . hasNext ( ) ) ; } } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer2 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } @Test public void testResolveDisjointMultipleRowsWithRangeTombstones ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; RangeTombstone tombstone1 = tombstone ( <str> , <str> , <int> , nowInSec ) ; RangeTombstone tombstone2 = tombstone ( <str> , <str> , <int> , nowInSec ) ; PartitionUpdate update = new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . addRangeTombstone ( tombstone1 ) . addRangeTombstone ( tombstone2 ) . buildUpdate ( ) ; InetAddress peer1 = peer ( ) ; UnfilteredPartitionIterator iter1 = iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . addRangeTombstone ( tombstone1 ) . addRangeTombstone ( tombstone2 ) . buildUpdate ( ) ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter1 ) ) ; InetAddress peer2 = peer ( ) ; UnfilteredPartitionIterator iter2 = iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter2 ) ) ; InetAddress peer3 = peer ( ) ; UnfilteredPartitionIterator iter3 = iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ; resolver . preprocess ( readResponseMessage ( peer3 , iter3 ) ) ; InetAddress peer4 = peer ( ) ; UnfilteredPartitionIterator iter4 = iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ; resolver . preprocess ( readResponseMessage ( peer4 , iter4 ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ) { try ( RowIterator rows = data . next ( ) ) { Row row = rows . next ( ) ; assertClustering ( cfm , row , <str> ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; row = rows . next ( ) ; assertClustering ( cfm , row , <str> ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; assertFalse ( rows . hasNext ( ) ) ; } } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer2 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , null , tombstone1 , tombstone2 ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer3 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , null , tombstone1 , tombstone2 ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer4 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , null , tombstone1 , tombstone2 ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } @Test public void testResolveWithOneEmpty ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , EmptyIterators . unfilteredPartition ( cfm , false ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer2 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } @Test public void testResolveWithBothEmpty ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; resolver . preprocess ( readResponseMessage ( peer ( ) , EmptyIterators . unfilteredPartition ( cfm , false ) ) ) ; resolver . preprocess ( readResponseMessage ( peer ( ) , EmptyIterators . unfilteredPartition ( cfm , false ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ) { assertFalse ( data . hasNext ( ) ) ; } assertTrue ( messageRecorder . sent . isEmpty ( ) ) ; } @Test public void testResolveDeleted ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> L , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , fullPartitionDelete ( cfm , dk , <int> , nowInSec ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ) { assertFalse ( data . hasNext ( ) ) ; } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , new DeletionTime ( <int> , nowInSec ) ) ; assertRepairContainsNoColumns ( msg ) ; } @Test public void testResolveMultipleDeleted ( ) { DataResolver resolver = new DataResolver ( ks , command , ConsistencyLevel . ALL , <int> ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , fullPartitionDelete ( cfm , dk , <int> , nowInSec ) ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer3 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer3 , iter ( new RowUpdateBuilder ( cfm , nowInSec , <int> , dk ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ) ) ) ; InetAddress peer4 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer4 , fullPartitionDelete ( cfm , dk , <int> , nowInSec ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; assertColumn ( cfm , row , <str> , <str> , <int> ) ; } assertEquals ( <int> , messageRecorder . sent . size ( ) ) ; MessageOut msg = getSentMessage ( peer1 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , new DeletionTime ( <int> , nowInSec ) ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer2 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , new DeletionTime ( <int> , nowInSec ) ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; msg = getSentMessage ( peer3 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsDeletions ( msg , new DeletionTime ( <int> , nowInSec ) ) ; assertRepairContainsNoColumns ( msg ) ; msg = getSentMessage ( peer4 ) ; assertRepairMetadata ( msg ) ; assertRepairContainsNoDeletions ( msg ) ; assertRepairContainsColumn ( msg , <str> , <str> , <str> , <int> ) ; } private static ByteBuffer bb ( int b ) { return ByteBufferUtil . bytes ( b ) ; } private Cell mapCell ( int k , int v , long ts ) { return BufferCell . live ( cfm2 , m , ts , bb ( v ) , CellPath . create ( bb ( k ) ) ) ; } @Test public void testResolveComplexDelete ( ) { ReadCommand cmd = Util . cmd ( cfs2 , dk ) . withNowInSeconds ( nowInSec ) . build ( ) ; DataResolver resolver = new DataResolver ( ks , cmd , ConsistencyLevel . ALL , <int> ) ; long [ ] ts = { <int> , <int> } ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( Clustering . EMPTY ) ; builder . addComplexDeletion ( m , new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ) ; builder . addCell ( mapCell ( <int> , <int> , ts [ <int> ] ) ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; builder . newRow ( Clustering . EMPTY ) ; DeletionTime expectedCmplxDelete = new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ; builder . addComplexDeletion ( m , expectedCmplxDelete ) ; Cell expectedCell = mapCell ( <int> , <int> , ts [ <int> ] ) ; builder . addCell ( expectedCell ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; Assert . assertNull ( row . getCell ( m , CellPath . create ( bb ( <int> ) ) ) ) ; Assert . assertNotNull ( row . getCell ( m , CellPath . create ( bb ( <int> ) ) ) ) ; } MessageOut < Mutation > msg ; msg = getSentMessage ( peer1 ) ; Iterator < Row > rowIter = msg . payload . getPartitionUpdate ( cfm2 . cfId ) . iterator ( ) ; assertTrue ( rowIter . hasNext ( ) ) ; Row row = rowIter . next ( ) ; assertFalse ( rowIter . hasNext ( ) ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; assertEquals ( expectedCmplxDelete , cd . complexDeletion ( ) ) ; Assert . assertNull ( messageRecorder . sent . get ( peer2 ) ) ; } @Test public void testResolveDeletedCollection ( ) { ReadCommand cmd = Util . cmd ( cfs2 , dk ) . withNowInSeconds ( nowInSec ) . build ( ) ; DataResolver resolver = new DataResolver ( ks , cmd , ConsistencyLevel . ALL , <int> ) ; long [ ] ts = { <int> , <int> } ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( Clustering . EMPTY ) ; builder . addComplexDeletion ( m , new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ) ; builder . addCell ( mapCell ( <int> , <int> , ts [ <int> ] ) ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; builder . newRow ( Clustering . EMPTY ) ; DeletionTime expectedCmplxDelete = new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ; builder . addComplexDeletion ( m , expectedCmplxDelete ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ) { assertFalse ( data . hasNext ( ) ) ; } MessageOut < Mutation > msg ; msg = getSentMessage ( peer1 ) ; Iterator < Row > rowIter = msg . payload . getPartitionUpdate ( cfm2 . cfId ) . iterator ( ) ; assertTrue ( rowIter . hasNext ( ) ) ; Row row = rowIter . next ( ) ; assertFalse ( rowIter . hasNext ( ) ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Collections . emptySet ( ) , Sets . newHashSet ( cd ) ) ; assertEquals ( expectedCmplxDelete , cd . complexDeletion ( ) ) ; Assert . assertNull ( messageRecorder . sent . get ( peer2 ) ) ; } @Test public void testResolveNewCollection ( ) { ReadCommand cmd = Util . cmd ( cfs2 , dk ) . withNowInSeconds ( nowInSec ) . build ( ) ; DataResolver resolver = new DataResolver ( ks , cmd , ConsistencyLevel . ALL , <int> ) ; long [ ] ts = { <int> , <int> } ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( Clustering . EMPTY ) ; DeletionTime expectedCmplxDelete = new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ; builder . addComplexDeletion ( m , expectedCmplxDelete ) ; Cell expectedCell = mapCell ( <int> , <int> , ts [ <int> ] ) ; builder . addCell ( expectedCell ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . emptyUpdate ( cfm2 , dk ) ) ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; } Assert . assertNull ( messageRecorder . sent . get ( peer1 ) ) ; MessageOut < Mutation > msg ; msg = getSentMessage ( peer2 ) ; Iterator < Row > rowIter = msg . payload . getPartitionUpdate ( cfm2 . cfId ) . iterator ( ) ; assertTrue ( rowIter . hasNext ( ) ) ; Row row = rowIter . next ( ) ; assertFalse ( rowIter . hasNext ( ) ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Sets . newHashSet ( expectedCell ) , Sets . newHashSet ( cd ) ) ; assertEquals ( expectedCmplxDelete , cd . complexDeletion ( ) ) ; } @Test public void testResolveNewCollectionOverwritingDeleted ( ) { ReadCommand cmd = Util . cmd ( cfs2 , dk ) . withNowInSeconds ( nowInSec ) . build ( ) ; DataResolver resolver = new DataResolver ( ks , cmd , ConsistencyLevel . ALL , <int> ) ; long [ ] ts = { <int> , <int> } ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( Clustering . EMPTY ) ; builder . addComplexDeletion ( m , new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ) ; InetAddress peer1 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer1 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; builder . newRow ( Clustering . EMPTY ) ; DeletionTime expectedCmplxDelete = new DeletionTime ( ts [ <int> ] - <int> , nowInSec ) ; builder . addComplexDeletion ( m , expectedCmplxDelete ) ; Cell expectedCell = mapCell ( <int> , <int> , ts [ <int> ] ) ; builder . addCell ( expectedCell ) ; InetAddress peer2 = peer ( ) ; resolver . preprocess ( readResponseMessage ( peer2 , iter ( PartitionUpdate . singleRowUpdate ( cfm2 , dk , builder . build ( ) ) ) , cmd ) ) ; try ( PartitionIterator data = resolver . resolve ( ) ; RowIterator rows = Iterators . getOnlyElement ( data ) ) { Row row = Iterators . getOnlyElement ( rows ) ; assertColumns ( row , <str> ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; } MessageOut < Mutation > msg ; msg = getSentMessage ( peer1 ) ; Row row = Iterators . getOnlyElement ( msg . payload . getPartitionUpdate ( cfm2 . cfId ) . iterator ( ) ) ; ComplexColumnData cd = row . getComplexColumnData ( m ) ; assertEquals ( Collections . singleton ( expectedCell ) , Sets . newHashSet ( cd ) ) ; assertEquals ( expectedCmplxDelete , cd . complexDeletion ( ) ) ; Assert . assertNull ( messageRecorder . sent . get ( peer2 ) ) ; } private InetAddress peer ( ) { try { return InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , ( byte ) addressSuffix + + } ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } private MessageOut < Mutation > getSentMessage ( InetAddress target ) { MessageOut < Mutation > message = messageRecorder . sent . get ( target ) ; assertNotNull ( String . format ( <str> , target ) , message ) ; return message ; } private void assertRepairContainsDeletions ( MessageOut < Mutation > message , DeletionTime deletionTime , RangeTombstone . . . rangeTombstones ) { PartitionUpdate update = ( ( Mutation ) message . payload ) . getPartitionUpdates ( ) . iterator ( ) . next ( ) ; DeletionInfo deletionInfo = update . deletionInfo ( ) ; if ( deletionTime ! = null ) assertEquals ( deletionTime , deletionInfo . getPartitionDeletion ( ) ) ; assertEquals ( rangeTombstones . length , deletionInfo . rangeCount ( ) ) ; Iterator < RangeTombstone > ranges = deletionInfo . rangeIterator ( false ) ; int i = <int> ; while ( ranges . hasNext ( ) ) { assertEquals ( ranges . next ( ) , rangeTombstones [ i + + ] ) ; } } private void assertRepairContainsNoDeletions ( MessageOut < Mutation > message ) { PartitionUpdate update = ( ( Mutation ) message . payload ) . getPartitionUpdates ( ) . iterator ( ) . next ( ) ; assertTrue ( update . deletionInfo ( ) . isLive ( ) ) ; } private void assertRepairContainsColumn ( MessageOut < Mutation > message , String clustering , String columnName , String value , long timestamp ) { PartitionUpdate update = ( ( Mutation ) message . payload ) . getPartitionUpdates ( ) . iterator ( ) . next ( ) ; Row row = update . getRow ( update . metadata ( ) . comparator . make ( clustering ) ) ; assertNotNull ( row ) ; assertColumn ( cfm , row , columnName , value , timestamp ) ; } private void assertRepairContainsNoColumns ( MessageOut < Mutation > message ) { PartitionUpdate update = ( ( Mutation ) message . payload ) . getPartitionUpdates ( ) . iterator ( ) . next ( ) ; assertFalse ( update . iterator ( ) . hasNext ( ) ) ; } private void assertRepairMetadata ( MessageOut < Mutation > message ) { assertEquals ( MessagingService . Verb . READ_REPAIR , message . verb ) ; PartitionUpdate update = ( ( Mutation ) message . payload ) . getPartitionUpdates ( ) . iterator ( ) . next ( ) ; assertEquals ( update . metadata ( ) . ksName , cfm . ksName ) ; assertEquals ( update . metadata ( ) . cfName , cfm . cfName ) ; } public MessageIn < ReadResponse > readResponseMessage ( InetAddress from , UnfilteredPartitionIterator partitionIterator ) { return readResponseMessage ( from , partitionIterator , command ) ; } public MessageIn < ReadResponse > readResponseMessage ( InetAddress from , UnfilteredPartitionIterator partitionIterator , ReadCommand cmd ) { return MessageIn . create ( from , ReadResponse . createRemoteDataResponse ( partitionIterator , cmd . columnFilter ( ) ) , Collections . EMPTY_MAP , MessagingService . Verb . REQUEST_RESPONSE , MessagingService . current_version , MessageIn . createTimestamp ( ) ) ; } private RangeTombstone tombstone ( Object start , Object end , long markedForDeleteAt , int localDeletionTime ) { return new RangeTombstone ( Slice . make ( cfm . comparator . make ( start ) , cfm . comparator . make ( end ) ) , new DeletionTime ( markedForDeleteAt , localDeletionTime ) ) ; } private UnfilteredPartitionIterator fullPartitionDelete ( CFMetaData cfm , DecoratedKey dk , long timestamp , int nowInSec ) { return new SingletonUnfilteredPartitionIterator ( PartitionUpdate . fullPartitionDelete ( cfm , dk , timestamp , nowInSec ) . unfilteredIterator ( ) , false ) ; } private static class MessageRecorder implements IMessageSink { Map < InetAddress , MessageOut > sent = new HashMap < > ( ) ; public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) { sent . put ( to , message ) ; return false ; } public boolean allowIncomingMessage ( MessageIn message , int id ) { return false ; } } private UnfilteredPartitionIterator iter ( PartitionUpdate update ) { return new SingletonUnfilteredPartitionIterator ( update . unfilteredIterator ( ) , false ) ; } } 
