package com . google . common . cache ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . truth . Truth . assertThat ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertFalse ; import static junit . framework . Assert . assertNotNull ; import static junit . framework . Assert . assertNotSame ; import static junit . framework . Assert . assertNull ; import static junit . framework . Assert . assertSame ; import static junit . framework . Assert . assertTrue ; import com . google . common . base . Preconditions ; import com . google . common . cache . LocalCache . LocalLoadingCache ; import com . google . common . cache . LocalCache . ReferenceEntry ; import com . google . common . cache . LocalCache . Segment ; import com . google . common . cache . LocalCache . ValueReference ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . FakeTicker ; import java . lang . ref . Reference ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReferenceArray ; import javax . annotation . Nullable ; class CacheTesting { @SuppressWarnings ( <str> ) static < K , V > void simulateValueReclamation ( Cache < K , V > cache , K key ) { ReferenceEntry < K , V > entry = getReferenceEntry ( cache , key ) ; if ( entry ! = null ) { ValueReference < K , V > valueRef = entry . getValueReference ( ) ; Preconditions . checkState ( valueRef instanceof Reference ) ; Reference < V > ref = ( Reference < V > ) valueRef ; if ( ref ! = null ) { ref . clear ( ) ; } } } @SuppressWarnings ( <str> ) static < K , V > void simulateKeyReclamation ( Cache < K , V > cache , K key ) { ReferenceEntry < K , V > entry = getReferenceEntry ( cache , key ) ; Preconditions . checkState ( entry instanceof Reference ) ; Reference < ? > ref = ( Reference < ? > ) entry ; if ( ref ! = null ) { ref . clear ( ) ; } } static < K , V > ReferenceEntry < K , V > getReferenceEntry ( Cache < K , V > cache , K key ) { checkNotNull ( cache ) ; checkNotNull ( key ) ; LocalCache < K , V > map = toLocalCache ( cache ) ; return map . getEntry ( key ) ; } static < K , V > void forceExpandSegment ( Cache < K , V > cache , K key ) { checkNotNull ( cache ) ; checkNotNull ( key ) ; LocalCache < K , V > map = toLocalCache ( cache ) ; int hash = map . hash ( key ) ; Segment < K , V > segment = map . segmentFor ( hash ) ; segment . expand ( ) ; } static < K , V > LocalCache < K , V > toLocalCache ( Cache < K , V > cache ) { if ( cache instanceof LocalLoadingCache ) { return ( ( LocalLoadingCache < K , V > ) cache ) . localCache ; } throw new IllegalArgumentException ( <str> + cache . getClass ( ) + <str> ) ; } static boolean hasLocalCache ( Cache < ? , ? > cache ) { return ( checkNotNull ( cache ) instanceof LocalLoadingCache ) ; } static void drainRecencyQueues ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { LocalCache < ? , ? > map = toLocalCache ( cache ) ; for ( Segment < ? , ? > segment : map . segments ) { drainRecencyQueue ( segment ) ; } } } static void drainRecencyQueue ( Segment < ? , ? > segment ) { segment . lock ( ) ; try { segment . cleanUp ( ) ; } finally { segment . unlock ( ) ; } } static void drainReferenceQueues ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { drainReferenceQueues ( toLocalCache ( cache ) ) ; } } static void drainReferenceQueues ( LocalCache < ? , ? > cchm ) { for ( LocalCache . Segment < ? , ? > segment : cchm . segments ) { drainReferenceQueue ( segment ) ; } } static void drainReferenceQueue ( LocalCache . Segment < ? , ? > segment ) { segment . lock ( ) ; try { segment . drainReferenceQueues ( ) ; } finally { segment . unlock ( ) ; } } static int getTotalSegmentSize ( Cache < ? , ? > cache ) { LocalCache < ? , ? > map = toLocalCache ( cache ) ; int totalSize = <int> ; for ( Segment < ? , ? > segment : map . segments ) { totalSize + = segment . maxSegmentWeight ; } return totalSize ; } static void checkValidState ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { checkValidState ( toLocalCache ( cache ) ) ; } } static void checkValidState ( LocalCache < ? , ? > cchm ) { for ( Segment < ? , ? > segment : cchm . segments ) { segment . cleanUp ( ) ; assertFalse ( segment . isLocked ( ) ) ; Map < ? , ? > table = segmentTable ( segment ) ; segment . cleanUp ( ) ; assertThat ( table . size ( ) ) . isAtMost ( segment . count ) ; for ( Entry < ? , ? > entry : table . entrySet ( ) ) { assertNotNull ( entry . getKey ( ) ) ; assertNotNull ( entry . getValue ( ) ) ; assertSame ( entry . getValue ( ) , cchm . get ( entry . getKey ( ) ) ) ; } } checkEviction ( cchm ) ; checkExpiration ( cchm ) ; } static void checkExpiration ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { checkExpiration ( toLocalCache ( cache ) ) ; } } static void checkExpiration ( LocalCache < ? , ? > cchm ) { for ( Segment < ? , ? > segment : cchm . segments ) { if ( cchm . usesWriteQueue ( ) ) { Set < ReferenceEntry < ? , ? > > entries = Sets . newIdentityHashSet ( ) ; ReferenceEntry < ? , ? > prev = null ; for ( ReferenceEntry < ? , ? > current : segment . writeQueue ) { assertTrue ( entries . add ( current ) ) ; if ( prev ! = null ) { assertSame ( prev , current . getPreviousInWriteQueue ( ) ) ; assertSame ( prev . getNextInWriteQueue ( ) , current ) ; assertThat ( prev . getWriteTime ( ) ) . isAtMost ( current . getWriteTime ( ) ) ; } Object key = current . getKey ( ) ; if ( key ! = null ) { assertSame ( current , segment . getEntry ( key , current . getHash ( ) ) ) ; } prev = current ; } assertEquals ( segment . count , entries . size ( ) ) ; } else { assertTrue ( segment . writeQueue . isEmpty ( ) ) ; } if ( cchm . usesAccessQueue ( ) ) { Set < ReferenceEntry < ? , ? > > entries = Sets . newIdentityHashSet ( ) ; ReferenceEntry < ? , ? > prev = null ; for ( ReferenceEntry < ? , ? > current : segment . accessQueue ) { assertTrue ( entries . add ( current ) ) ; if ( prev ! = null ) { assertSame ( prev , current . getPreviousInAccessQueue ( ) ) ; assertSame ( prev . getNextInAccessQueue ( ) , current ) ; assertTrue ( prev . getAccessTime ( ) < = current . getAccessTime ( ) | | prev . getAccessTime ( ) - current . getAccessTime ( ) < <int> ) ; } Object key = current . getKey ( ) ; if ( key ! = null ) { assertSame ( current , segment . getEntry ( key , current . getHash ( ) ) ) ; } prev = current ; } assertEquals ( segment . count , entries . size ( ) ) ; } else { assertTrue ( segment . accessQueue . isEmpty ( ) ) ; } } } static void checkEviction ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { checkEviction ( toLocalCache ( cache ) ) ; } } static void checkEviction ( LocalCache < ? , ? > map ) { if ( map . evictsBySize ( ) ) { for ( Segment < ? , ? > segment : map . segments ) { drainRecencyQueue ( segment ) ; assertEquals ( <int> , segment . recencyQueue . size ( ) ) ; assertEquals ( <int> , segment . readCount . get ( ) ) ; ReferenceEntry < ? , ? > prev = null ; for ( ReferenceEntry < ? , ? > current : segment . accessQueue ) { if ( prev ! = null ) { assertSame ( prev , current . getPreviousInAccessQueue ( ) ) ; assertSame ( prev . getNextInAccessQueue ( ) , current ) ; } Object key = current . getKey ( ) ; if ( key ! = null ) { assertSame ( current , segment . getEntry ( key , current . getHash ( ) ) ) ; } prev = current ; } } } else { for ( Segment < ? , ? > segment : map . segments ) { assertEquals ( <int> , segment . recencyQueue . size ( ) ) ; } } } static int segmentSize ( Segment < ? , ? > segment ) { Map < ? , ? > map = segmentTable ( segment ) ; return map . size ( ) ; } static < K , V > Map < K , V > segmentTable ( Segment < K , V > segment ) { AtomicReferenceArray < ? extends ReferenceEntry < K , V > > table = segment . table ; Map < K , V > map = Maps . newLinkedHashMap ( ) ; for ( int i = <int> ; i < table . length ( ) ; i + + ) { for ( ReferenceEntry < K , V > entry = table . get ( i ) ; entry ! = null ; entry = entry . getNext ( ) ) { K key = entry . getKey ( ) ; V value = entry . getValueReference ( ) . get ( ) ; if ( key ! = null & & value ! = null ) { assertNull ( map . put ( key , value ) ) ; } } } return map ; } static int writeQueueSize ( Cache < ? , ? > cache ) { LocalCache < ? , ? > cchm = toLocalCache ( cache ) ; int size = <int> ; for ( Segment < ? , ? > segment : cchm . segments ) { size + = writeQueueSize ( segment ) ; } return size ; } static int writeQueueSize ( Segment < ? , ? > segment ) { return segment . writeQueue . size ( ) ; } static int accessQueueSize ( Cache < ? , ? > cache ) { LocalCache < ? , ? > cchm = toLocalCache ( cache ) ; int size = <int> ; for ( Segment < ? , ? > segment : cchm . segments ) { size + = accessQueueSize ( segment ) ; } return size ; } static int accessQueueSize ( Segment < ? , ? > segment ) { return segment . accessQueue . size ( ) ; } static int expirationQueueSize ( Cache < ? , ? > cache ) { return Math . max ( accessQueueSize ( cache ) , writeQueueSize ( cache ) ) ; } static void processPendingNotifications ( Cache < ? , ? > cache ) { if ( hasLocalCache ( cache ) ) { LocalCache < ? , ? > cchm = toLocalCache ( cache ) ; cchm . processPendingNotifications ( ) ; } } interface Receiver < T > { void accept ( @Nullable T object ) ; } static void checkRecency ( LoadingCache < Integer , Integer > cache , int maxSize , Receiver < ReferenceEntry < Integer , Integer > > operation ) { checkNotNull ( operation ) ; if ( hasLocalCache ( cache ) ) { warmUp ( cache , <int> , <int> * maxSize ) ; LocalCache < Integer , Integer > cchm = toLocalCache ( cache ) ; Segment < ? , ? > segment = cchm . segments [ <int> ] ; drainRecencyQueue ( segment ) ; assertEquals ( maxSize , accessQueueSize ( cache ) ) ; assertEquals ( maxSize , cache . size ( ) ) ; ReferenceEntry < ? , ? > originalHead = segment . accessQueue . peek ( ) ; @SuppressWarnings ( <str> ) ReferenceEntry < Integer , Integer > entry = ( ReferenceEntry ) originalHead ; operation . accept ( entry ) ; drainRecencyQueue ( segment ) ; assertNotSame ( originalHead , segment . accessQueue . peek ( ) ) ; assertEquals ( cache . size ( ) , accessQueueSize ( cache ) ) ; } } static void warmUp ( LoadingCache < Integer , Integer > map , int start , int end ) { checkNotNull ( map ) ; for ( int i = start ; i < end ; i + + ) { map . getUnchecked ( i ) ; } } static void expireEntries ( Cache < ? , ? > cache , long expiringTime , FakeTicker ticker ) { checkNotNull ( ticker ) ; expireEntries ( toLocalCache ( cache ) , expiringTime , ticker ) ; } static void expireEntries ( LocalCache < ? , ? > cchm , long expiringTime , FakeTicker ticker ) { for ( Segment < ? , ? > segment : cchm . segments ) { drainRecencyQueue ( segment ) ; } ticker . advance ( <int> * expiringTime , TimeUnit . MILLISECONDS ) ; long now = ticker . read ( ) ; for ( Segment < ? , ? > segment : cchm . segments ) { expireEntries ( segment , now ) ; assertEquals ( <str> , <int> , writeQueueSize ( segment ) ) ; assertEquals ( <str> , <int> , accessQueueSize ( segment ) ) ; assertEquals ( <str> , <int> , segmentSize ( segment ) ) ; } cchm . processPendingNotifications ( ) ; } static void expireEntries ( Segment < ? , ? > segment , long now ) { segment . lock ( ) ; try { segment . expireEntries ( now ) ; segment . cleanUp ( ) ; } finally { segment . unlock ( ) ; } } static void checkEmpty ( Cache < ? , ? > cache ) { assertEquals ( <int> , cache . size ( ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( null ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsValue ( null ) ) ; assertFalse ( cache . asMap ( ) . containsValue ( <int> ) ) ; checkEmpty ( cache . asMap ( ) ) ; } static void checkEmpty ( ConcurrentMap < ? , ? > map ) { checkEmpty ( map . keySet ( ) ) ; checkEmpty ( map . values ( ) ) ; checkEmpty ( map . entrySet ( ) ) ; assertEquals ( ImmutableMap . of ( ) , map ) ; assertEquals ( ImmutableMap . of ( ) . hashCode ( ) , map . hashCode ( ) ) ; assertEquals ( ImmutableMap . of ( ) . toString ( ) , map . toString ( ) ) ; if ( map instanceof LocalCache ) { LocalCache < ? , ? > cchm = ( LocalCache < ? , ? > ) map ; checkValidState ( cchm ) ; assertTrue ( cchm . isEmpty ( ) ) ; assertEquals ( <int> , cchm . size ( ) ) ; for ( LocalCache . Segment < ? , ? > segment : cchm . segments ) { assertEquals ( <int> , segment . count ) ; assertEquals ( <int> , segmentSize ( segment ) ) ; assertTrue ( segment . writeQueue . isEmpty ( ) ) ; assertTrue ( segment . accessQueue . isEmpty ( ) ) ; } } } static void checkEmpty ( Collection < ? > collection ) { assertTrue ( collection . isEmpty ( ) ) ; assertEquals ( <int> , collection . size ( ) ) ; assertFalse ( collection . iterator ( ) . hasNext ( ) ) ; assertThat ( collection . toArray ( ) ) . isEmpty ( ) ; assertThat ( collection . toArray ( new Object [ <int> ] ) ) . isEmpty ( ) ; if ( collection instanceof Set ) { new EqualsTester ( ) . addEqualityGroup ( ImmutableSet . of ( ) , collection ) . addEqualityGroup ( ImmutableSet . of ( <str> ) ) . testEquals ( ) ; } else if ( collection instanceof List ) { new EqualsTester ( ) . addEqualityGroup ( ImmutableList . of ( ) , collection ) . addEqualityGroup ( ImmutableList . of ( <str> ) ) . testEquals ( ) ; } } } 
