package org . elasticsearch . common . unit ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . metadata . MetaDataIndexUpgradeService ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . settings . Settings ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public class ByteSizeValue implements Streamable { private long size ; private ByteSizeUnit sizeUnit ; private ByteSizeValue ( ) { } public ByteSizeValue ( long bytes ) { this ( bytes , ByteSizeUnit . BYTES ) ; } public ByteSizeValue ( long size , ByteSizeUnit sizeUnit ) { this . size = size ; this . sizeUnit = sizeUnit ; } public int bytesAsInt ( ) { long bytes = bytes ( ) ; if ( bytes > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( <str> + toString ( ) + <str> ) ; } return ( int ) bytes ; } public long bytes ( ) { return sizeUnit . toBytes ( size ) ; } public long getBytes ( ) { return bytes ( ) ; } public long kb ( ) { return sizeUnit . toKB ( size ) ; } public long getKb ( ) { return kb ( ) ; } public long mb ( ) { return sizeUnit . toMB ( size ) ; } public long getMb ( ) { return mb ( ) ; } public long gb ( ) { return sizeUnit . toGB ( size ) ; } public long getGb ( ) { return gb ( ) ; } public long tb ( ) { return sizeUnit . toTB ( size ) ; } public long getTb ( ) { return tb ( ) ; } public long pb ( ) { return sizeUnit . toPB ( size ) ; } public long getPb ( ) { return pb ( ) ; } public double kbFrac ( ) { return ( ( double ) bytes ( ) ) / ByteSizeUnit . C1 ; } public double getKbFrac ( ) { return kbFrac ( ) ; } public double mbFrac ( ) { return ( ( double ) bytes ( ) ) / ByteSizeUnit . C2 ; } public double getMbFrac ( ) { return mbFrac ( ) ; } public double gbFrac ( ) { return ( ( double ) bytes ( ) ) / ByteSizeUnit . C3 ; } public double getGbFrac ( ) { return gbFrac ( ) ; } public double tbFrac ( ) { return ( ( double ) bytes ( ) ) / ByteSizeUnit . C4 ; } public double getTbFrac ( ) { return tbFrac ( ) ; } public double pbFrac ( ) { return ( ( double ) bytes ( ) ) / ByteSizeUnit . C5 ; } public double getPbFrac ( ) { return pbFrac ( ) ; } @Override public String toString ( ) { long bytes = bytes ( ) ; double value = bytes ; String suffix = <str> ; if ( bytes > = ByteSizeUnit . C5 ) { value = pbFrac ( ) ; suffix = <str> ; } else if ( bytes > = ByteSizeUnit . C4 ) { value = tbFrac ( ) ; suffix = <str> ; } else if ( bytes > = ByteSizeUnit . C3 ) { value = gbFrac ( ) ; suffix = <str> ; } else if ( bytes > = ByteSizeUnit . C2 ) { value = mbFrac ( ) ; suffix = <str> ; } else if ( bytes > = ByteSizeUnit . C1 ) { value = kbFrac ( ) ; suffix = <str> ; } return Strings . format1Decimals ( value , suffix ) ; } public static ByteSizeValue parseBytesSizeValue ( String sValue , String settingName ) throws ElasticsearchParseException { return parseBytesSizeValue ( sValue , null , settingName ) ; } public static ByteSizeValue parseBytesSizeValue ( String sValue , ByteSizeValue defaultValue , String settingName ) throws ElasticsearchParseException { settingName = Objects . requireNonNull ( settingName ) ; assert settingName . startsWith ( <str> ) = = false | | MetaDataIndexUpgradeService . INDEX_BYTES_SIZE_SETTINGS . contains ( settingName ) ; if ( sValue = = null ) { return defaultValue ; } long bytes ; try { String lowerSValue = sValue . toLowerCase ( Locale . ROOT ) . trim ( ) ; if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C1 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C1 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C2 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C2 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C3 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C3 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C4 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C4 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C5 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = ( long ) ( Double . parseDouble ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) ) * ByteSizeUnit . C5 ) ; } else if ( lowerSValue . endsWith ( <str> ) ) { bytes = Long . parseLong ( lowerSValue . substring ( <int> , lowerSValue . length ( ) - <int> ) . trim ( ) ) ; } else if ( lowerSValue . equals ( <str> ) ) { bytes = - <int> ; } else if ( lowerSValue . equals ( <str> ) ) { bytes = <int> ; } else { if ( Settings . getSettingsRequireUnits ( ) ) { throw new ElasticsearchParseException ( <str> , settingName , sValue ) ; } else { bytes = Long . parseLong ( sValue ) ; } } } catch ( NumberFormatException e ) { throw new ElasticsearchParseException ( <str> , e , sValue ) ; } return new ByteSizeValue ( bytes , ByteSizeUnit . BYTES ) ; } public static ByteSizeValue readBytesSizeValue ( StreamInput in ) throws IOException { ByteSizeValue sizeValue = new ByteSizeValue ( ) ; sizeValue . readFrom ( in ) ; return sizeValue ; } @Override public void readFrom ( StreamInput in ) throws IOException { size = in . readVLong ( ) ; sizeUnit = ByteSizeUnit . BYTES ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( bytes ( ) ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } ByteSizeValue sizeValue = ( ByteSizeValue ) o ; return bytes ( ) = = sizeValue . bytes ( ) ; } @Override public int hashCode ( ) { int result = Long . hashCode ( size ) ; result = <int> * result + ( sizeUnit ! = null ? sizeUnit . hashCode ( ) : <int> ) ; return result ; } } 
