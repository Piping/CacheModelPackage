package org . apache . cassandra . cql3 . statements ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . IndexName ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . db . KeyspaceNotDefinedException ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . Event ; import org . apache . cassandra . transport . messages . ResultMessage ; public class DropIndexStatement extends SchemaAlteringStatement { public final String indexName ; public final boolean ifExists ; public DropIndexStatement ( IndexName indexName , boolean ifExists ) { super ( indexName . getCfName ( ) ) ; this . indexName = indexName . getIdx ( ) ; this . ifExists = ifExists ; } public String columnFamily ( ) { CFMetaData cfm = lookupIndexedTable ( ) ; return cfm = = null ? null : cfm . cfName ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { CFMetaData cfm = lookupIndexedTable ( ) ; if ( cfm = = null ) return ; state . hasColumnFamilyAccess ( cfm . ksName , cfm . cfName , Permission . ALTER ) ; } public void validate ( ClientState state ) { } @Override public ResultMessage execute ( QueryState state , QueryOptions options ) throws RequestValidationException { Event . SchemaChange ce = announceMigration ( false ) ; return ce = = null ? null : new ResultMessage . SchemaChange ( ce ) ; } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws InvalidRequestException , ConfigurationException { CFMetaData cfm = lookupIndexedTable ( ) ; if ( cfm = = null ) return null ; CFMetaData updatedCfm = cfm . copy ( ) ; updatedCfm . indexes ( updatedCfm . getIndexes ( ) . without ( indexName ) ) ; MigrationManager . announceColumnFamilyUpdate ( updatedCfm , false , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . UPDATED , Event . SchemaChange . Target . TABLE , cfm . ksName , cfm . cfName ) ; } private CFMetaData lookupIndexedTable ( ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( keyspace ( ) ) ; if ( ksm = = null ) throw new KeyspaceNotDefinedException ( <str> + keyspace ( ) + <str> ) ; return ksm . findIndexedTable ( indexName ) . orElseGet ( ( ) - > { if ( ifExists ) return null ; else throw new InvalidRequestException ( String . format ( <str> + <str> , indexName , keyspace ( ) ) ) ; } ) ; } } 
