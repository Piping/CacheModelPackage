package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . socket . oio . OioDatagramChannel ; import io . netty . util . NetUtil ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static org . junit . Assert . * ; public class DatagramMulticastTest extends AbstractDatagramTest { @Test public void testMulticast ( ) throws Throwable { run ( ) ; } public void testMulticast ( Bootstrap sb , Bootstrap cb ) throws Throwable { MulticastTestHandler mhandler = new MulticastTestHandler ( ) ; sb . handler ( new SimpleChannelInboundHandler < Object > ( ) { @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { } } ) ; cb . handler ( mhandler ) ; sb . option ( ChannelOption . IP_MULTICAST_IF , NetUtil . LOOPBACK_IF ) ; sb . option ( ChannelOption . SO_REUSEADDR , true ) ; cb . option ( ChannelOption . IP_MULTICAST_IF , NetUtil . LOOPBACK_IF ) ; cb . option ( ChannelOption . SO_REUSEADDR , true ) ; cb . localAddress ( addr . getPort ( ) ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; if ( sc instanceof OioDatagramChannel ) { sc . close ( ) . awaitUninterruptibly ( ) ; return ; } DatagramChannel cc = ( DatagramChannel ) cb . bind ( ) . sync ( ) . channel ( ) ; String group = <str> ; InetSocketAddress groupAddress = new InetSocketAddress ( group , addr . getPort ( ) ) ; cc . joinGroup ( groupAddress , NetUtil . LOOPBACK_IF ) . sync ( ) ; sc . writeAndFlush ( new DatagramPacket ( Unpooled . copyInt ( <int> ) , groupAddress ) ) . sync ( ) ; assertTrue ( mhandler . await ( ) ) ; cc . leaveGroup ( groupAddress , NetUtil . LOOPBACK_IF ) . sync ( ) ; Thread . sleep ( <int> ) ; sc . writeAndFlush ( new DatagramPacket ( Unpooled . copyInt ( <int> ) , groupAddress ) ) . sync ( ) ; mhandler . await ( ) ; sc . close ( ) . awaitUninterruptibly ( ) ; cc . close ( ) . awaitUninterruptibly ( ) ; } private static final class MulticastTestHandler extends SimpleChannelInboundHandler < DatagramPacket > { private final CountDownLatch latch = new CountDownLatch ( <int> ) ; private boolean done ; private volatile boolean fail ; @Override protected void channelRead0 ( ChannelHandlerContext ctx , DatagramPacket msg ) throws Exception { if ( done ) { fail = true ; } assertEquals ( <int> , msg . content ( ) . readInt ( ) ) ; latch . countDown ( ) ; done = true ; } public boolean await ( ) throws Exception { boolean success = latch . await ( <int> , TimeUnit . SECONDS ) ; if ( fail ) { fail ( ) ; } return success ; } } } 
