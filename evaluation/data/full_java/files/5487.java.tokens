package org . elasticsearch . bootstrap ; import com . sun . jna . Native ; import com . sun . jna . Pointer ; import org . apache . lucene . util . Constants ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . monitor . jvm . JvmInfo ; import java . nio . file . Path ; import static org . elasticsearch . bootstrap . JNAKernel32Library . SizeT ; class JNANatives { private JNANatives ( ) { } private static final ESLogger logger = Loggers . getLogger ( JNANatives . class ) ; static boolean LOCAL_MLOCKALL = false ; static boolean LOCAL_SECCOMP = false ; static boolean LOCAL_SECCOMP_ALL = false ; static void tryMlockall ( ) { int errno = Integer . MIN_VALUE ; String errMsg = null ; boolean rlimitSuccess = false ; long softLimit = <int> ; long hardLimit = <int> ; try { int result = JNACLibrary . mlockall ( JNACLibrary . MCL_CURRENT ) ; if ( result = = <int> ) { LOCAL_MLOCKALL = true ; return ; } errno = Native . getLastError ( ) ; errMsg = JNACLibrary . strerror ( errno ) ; if ( Constants . LINUX | | Constants . MAC_OS_X ) { JNACLibrary . Rlimit rlimit = new JNACLibrary . Rlimit ( ) ; if ( JNACLibrary . getrlimit ( JNACLibrary . RLIMIT_MEMLOCK , rlimit ) = = <int> ) { rlimitSuccess = true ; softLimit = rlimit . rlim_cur . longValue ( ) ; hardLimit = rlimit . rlim_max . longValue ( ) ; } else { logger . warn ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } } } catch ( UnsatisfiedLinkError e ) { return ; } logger . warn ( <str> + errno + <str> + errMsg ) ; logger . warn ( <str> ) ; if ( errno = = JNACLibrary . ENOMEM ) { if ( rlimitSuccess ) { logger . warn ( <str> + rlimitToString ( softLimit ) + <str> + rlimitToString ( hardLimit ) ) ; if ( Constants . LINUX ) { String user = System . getProperty ( <str> ) ; logger . warn ( <str> + <str> + user + <str> + <str> + user + <str> + <str> + user + <str> ) ; logger . warn ( <str> ) ; } } else { logger . warn ( <str> ) ; } } } static String rlimitToString ( long value ) { assert Constants . LINUX | | Constants . MAC_OS_X ; if ( value = = JNACLibrary . RLIM_INFINITY ) { return <str> ; } else { return Long . toString ( value ) ; } } static boolean definitelyRunningAsRoot ( ) { if ( Constants . WINDOWS ) { return false ; } try { return JNACLibrary . geteuid ( ) = = <int> ; } catch ( UnsatisfiedLinkError e ) { return false ; } } static void tryVirtualLock ( ) { JNAKernel32Library kernel = JNAKernel32Library . getInstance ( ) ; Pointer process = null ; try { process = kernel . GetCurrentProcess ( ) ; SizeT size = new SizeT ( JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapInit ( ) . getBytes ( ) + ( <int> * <int> ) ) ; if ( ! kernel . SetProcessWorkingSetSize ( process , size , size ) ) { logger . warn ( <str> + Native . getLastError ( ) ) ; } else { JNAKernel32Library . MemoryBasicInformation memInfo = new JNAKernel32Library . MemoryBasicInformation ( ) ; long address = <int> ; while ( kernel . VirtualQueryEx ( process , new Pointer ( address ) , memInfo , memInfo . size ( ) ) ! = <int> ) { boolean lockable = memInfo . State . longValue ( ) = = JNAKernel32Library . MEM_COMMIT & & ( memInfo . Protect . longValue ( ) & JNAKernel32Library . PAGE_NOACCESS ) ! = JNAKernel32Library . PAGE_NOACCESS & & ( memInfo . Protect . longValue ( ) & JNAKernel32Library . PAGE_GUARD ) ! = JNAKernel32Library . PAGE_GUARD ; if ( lockable ) { kernel . VirtualLock ( memInfo . BaseAddress , new SizeT ( memInfo . RegionSize . longValue ( ) ) ) ; } address + = memInfo . RegionSize . longValue ( ) ; } LOCAL_MLOCKALL = true ; } } catch ( UnsatisfiedLinkError e ) { } finally { if ( process ! = null ) { kernel . CloseHandle ( process ) ; } } } static void addConsoleCtrlHandler ( ConsoleCtrlHandler handler ) { if ( Constants . WINDOWS ) { try { boolean result = JNAKernel32Library . getInstance ( ) . addConsoleCtrlHandler ( handler ) ; if ( result ) { logger . debug ( <str> ) ; } else { logger . warn ( <str> + Native . getLastError ( ) + <str> ) ; } } catch ( UnsatisfiedLinkError e ) { } } } static void trySeccomp ( Path tmpFile ) { try { int ret = Seccomp . init ( tmpFile ) ; LOCAL_SECCOMP = true ; if ( ret = = <int> ) { LOCAL_SECCOMP_ALL = true ; } } catch ( Throwable t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , t ) ; } logger . warn ( <str> , t ) ; } } } 
