package io . netty . buffer ; import io . netty . util . concurrent . FastThreadLocal ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class PooledByteBufAllocator extends AbstractByteBufAllocator { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PooledByteBufAllocator . class ) ; private static final int DEFAULT_NUM_HEAP_ARENA ; private static final int DEFAULT_NUM_DIRECT_ARENA ; private static final int DEFAULT_PAGE_SIZE ; private static final int DEFAULT_MAX_ORDER ; private static final int DEFAULT_TINY_CACHE_SIZE ; private static final int DEFAULT_SMALL_CACHE_SIZE ; private static final int DEFAULT_NORMAL_CACHE_SIZE ; private static final int DEFAULT_MAX_CACHED_BUFFER_CAPACITY ; private static final int DEFAULT_CACHE_TRIM_INTERVAL ; private static final int MIN_PAGE_SIZE = <int> ; private static final int MAX_CHUNK_SIZE = ( int ) ( ( ( long ) Integer . MAX_VALUE + <int> ) / <int> ) ; static { int defaultPageSize = SystemPropertyUtil . getInt ( <str> , <int> ) ; Throwable pageSizeFallbackCause = null ; try { validateAndCalculatePageShifts ( defaultPageSize ) ; } catch ( Throwable t ) { pageSizeFallbackCause = t ; defaultPageSize = <int> ; } DEFAULT_PAGE_SIZE = defaultPageSize ; int defaultMaxOrder = SystemPropertyUtil . getInt ( <str> , <int> ) ; Throwable maxOrderFallbackCause = null ; try { validateAndCalculateChunkSize ( DEFAULT_PAGE_SIZE , defaultMaxOrder ) ; } catch ( Throwable t ) { maxOrderFallbackCause = t ; defaultMaxOrder = <int> ; } DEFAULT_MAX_ORDER = defaultMaxOrder ; final Runtime runtime = Runtime . getRuntime ( ) ; final int defaultMinNumArena = runtime . availableProcessors ( ) * <int> ; final int defaultChunkSize = DEFAULT_PAGE_SIZE < < DEFAULT_MAX_ORDER ; DEFAULT_NUM_HEAP_ARENA = Math . max ( <int> , SystemPropertyUtil . getInt ( <str> , ( int ) Math . min ( defaultMinNumArena , runtime . maxMemory ( ) / defaultChunkSize / <int> / <int> ) ) ) ; DEFAULT_NUM_DIRECT_ARENA = Math . max ( <int> , SystemPropertyUtil . getInt ( <str> , ( int ) Math . min ( defaultMinNumArena , PlatformDependent . maxDirectMemory ( ) / defaultChunkSize / <int> / <int> ) ) ) ; DEFAULT_TINY_CACHE_SIZE = SystemPropertyUtil . getInt ( <str> , <int> ) ; DEFAULT_SMALL_CACHE_SIZE = SystemPropertyUtil . getInt ( <str> , <int> ) ; DEFAULT_NORMAL_CACHE_SIZE = SystemPropertyUtil . getInt ( <str> , <int> ) ; DEFAULT_MAX_CACHED_BUFFER_CAPACITY = SystemPropertyUtil . getInt ( <str> , <int> * <int> ) ; DEFAULT_CACHE_TRIM_INTERVAL = SystemPropertyUtil . getInt ( <str> , <int> ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , DEFAULT_NUM_HEAP_ARENA ) ; logger . debug ( <str> , DEFAULT_NUM_DIRECT_ARENA ) ; if ( pageSizeFallbackCause = = null ) { logger . debug ( <str> , DEFAULT_PAGE_SIZE ) ; } else { logger . debug ( <str> , DEFAULT_PAGE_SIZE , pageSizeFallbackCause ) ; } if ( maxOrderFallbackCause = = null ) { logger . debug ( <str> , DEFAULT_MAX_ORDER ) ; } else { logger . debug ( <str> , DEFAULT_MAX_ORDER , maxOrderFallbackCause ) ; } logger . debug ( <str> , DEFAULT_PAGE_SIZE < < DEFAULT_MAX_ORDER ) ; logger . debug ( <str> , DEFAULT_TINY_CACHE_SIZE ) ; logger . debug ( <str> , DEFAULT_SMALL_CACHE_SIZE ) ; logger . debug ( <str> , DEFAULT_NORMAL_CACHE_SIZE ) ; logger . debug ( <str> , DEFAULT_MAX_CACHED_BUFFER_CAPACITY ) ; logger . debug ( <str> , DEFAULT_CACHE_TRIM_INTERVAL ) ; } } public static final PooledByteBufAllocator DEFAULT = new PooledByteBufAllocator ( PlatformDependent . directBufferPreferred ( ) ) ; private final PoolArena < byte [ ] > [ ] heapArenas ; private final PoolArena < ByteBuffer > [ ] directArenas ; private final int tinyCacheSize ; private final int smallCacheSize ; private final int normalCacheSize ; private final List < PoolArenaMetric > heapArenaMetrics ; private final List < PoolArenaMetric > directArenaMetrics ; private final PoolThreadLocalCache threadCache ; public PooledByteBufAllocator ( ) { this ( false ) ; } public PooledByteBufAllocator ( boolean preferDirect ) { this ( preferDirect , DEFAULT_NUM_HEAP_ARENA , DEFAULT_NUM_DIRECT_ARENA , DEFAULT_PAGE_SIZE , DEFAULT_MAX_ORDER ) ; } public PooledByteBufAllocator ( int nHeapArena , int nDirectArena , int pageSize , int maxOrder ) { this ( false , nHeapArena , nDirectArena , pageSize , maxOrder ) ; } public PooledByteBufAllocator ( boolean preferDirect , int nHeapArena , int nDirectArena , int pageSize , int maxOrder ) { this ( preferDirect , nHeapArena , nDirectArena , pageSize , maxOrder , DEFAULT_TINY_CACHE_SIZE , DEFAULT_SMALL_CACHE_SIZE , DEFAULT_NORMAL_CACHE_SIZE ) ; } public PooledByteBufAllocator ( boolean preferDirect , int nHeapArena , int nDirectArena , int pageSize , int maxOrder , int tinyCacheSize , int smallCacheSize , int normalCacheSize ) { super ( preferDirect ) ; threadCache = new PoolThreadLocalCache ( ) ; this . tinyCacheSize = tinyCacheSize ; this . smallCacheSize = smallCacheSize ; this . normalCacheSize = normalCacheSize ; final int chunkSize = validateAndCalculateChunkSize ( pageSize , maxOrder ) ; if ( nHeapArena < <int> ) { throw new IllegalArgumentException ( <str> + nHeapArena + <str> ) ; } if ( nDirectArena < <int> ) { throw new IllegalArgumentException ( <str> + nDirectArena + <str> ) ; } int pageShifts = validateAndCalculatePageShifts ( pageSize ) ; if ( nHeapArena > <int> ) { heapArenas = newArenaArray ( nHeapArena ) ; List < PoolArenaMetric > metrics = new ArrayList < PoolArenaMetric > ( heapArenas . length ) ; for ( int i = <int> ; i < heapArenas . length ; i + + ) { PoolArena . HeapArena arena = new PoolArena . HeapArena ( this , pageSize , maxOrder , pageShifts , chunkSize ) ; heapArenas [ i ] = arena ; metrics . add ( arena ) ; } heapArenaMetrics = Collections . unmodifiableList ( metrics ) ; } else { heapArenas = null ; heapArenaMetrics = Collections . emptyList ( ) ; } if ( nDirectArena > <int> ) { directArenas = newArenaArray ( nDirectArena ) ; List < PoolArenaMetric > metrics = new ArrayList < PoolArenaMetric > ( directArenas . length ) ; for ( int i = <int> ; i < directArenas . length ; i + + ) { PoolArena . DirectArena arena = new PoolArena . DirectArena ( this , pageSize , maxOrder , pageShifts , chunkSize ) ; directArenas [ i ] = arena ; metrics . add ( arena ) ; } directArenaMetrics = Collections . unmodifiableList ( metrics ) ; } else { directArenas = null ; directArenaMetrics = Collections . emptyList ( ) ; } } @SuppressWarnings ( <str> ) private static < T > PoolArena < T > [ ] newArenaArray ( int size ) { return new PoolArena [ size ] ; } private static int validateAndCalculatePageShifts ( int pageSize ) { if ( pageSize < MIN_PAGE_SIZE ) { throw new IllegalArgumentException ( <str> + pageSize + <str> + MIN_PAGE_SIZE + <str> ) ; } if ( ( pageSize & pageSize - <int> ) ! = <int> ) { throw new IllegalArgumentException ( <str> + pageSize + <str> ) ; } return Integer . SIZE - <int> - Integer . numberOfLeadingZeros ( pageSize ) ; } private static int validateAndCalculateChunkSize ( int pageSize , int maxOrder ) { if ( maxOrder > <int> ) { throw new IllegalArgumentException ( <str> + maxOrder + <str> ) ; } int chunkSize = pageSize ; for ( int i = maxOrder ; i > <int> ; i - - ) { if ( chunkSize > MAX_CHUNK_SIZE / <int> ) { throw new IllegalArgumentException ( String . format ( <str> , pageSize , maxOrder , MAX_CHUNK_SIZE ) ) ; } chunkSize < < = <int> ; } return chunkSize ; } @Override protected ByteBuf newHeapBuffer ( int initialCapacity , int maxCapacity ) { PoolThreadCache cache = threadCache . get ( ) ; PoolArena < byte [ ] > heapArena = cache . heapArena ; ByteBuf buf ; if ( heapArena ! = null ) { buf = heapArena . allocate ( cache , initialCapacity , maxCapacity ) ; } else { buf = new UnpooledHeapByteBuf ( this , initialCapacity , maxCapacity ) ; } return toLeakAwareBuffer ( buf ) ; } @Override protected ByteBuf newDirectBuffer ( int initialCapacity , int maxCapacity ) { PoolThreadCache cache = threadCache . get ( ) ; PoolArena < ByteBuffer > directArena = cache . directArena ; ByteBuf buf ; if ( directArena ! = null ) { buf = directArena . allocate ( cache , initialCapacity , maxCapacity ) ; } else { if ( PlatformDependent . hasUnsafe ( ) ) { buf = new UnpooledUnsafeDirectByteBuf ( this , initialCapacity , maxCapacity ) ; } else { buf = new UnpooledDirectByteBuf ( this , initialCapacity , maxCapacity ) ; } } return toLeakAwareBuffer ( buf ) ; } public static int defaultNumHeapArena ( ) { return DEFAULT_NUM_HEAP_ARENA ; } public static int defaultNumDirectArena ( ) { return DEFAULT_NUM_DIRECT_ARENA ; } public static int defaultPageSize ( ) { return DEFAULT_PAGE_SIZE ; } public static int defaultMaxOrder ( ) { return DEFAULT_MAX_ORDER ; } public static int defaultTinyCacheSize ( ) { return DEFAULT_TINY_CACHE_SIZE ; } public static int defaultSmallCacheSize ( ) { return DEFAULT_SMALL_CACHE_SIZE ; } public static int defaultNormalCacheSize ( ) { return DEFAULT_NORMAL_CACHE_SIZE ; } @Override public boolean isDirectBufferPooled ( ) { return directArenas ! = null ; } @Deprecated public boolean hasThreadLocalCache ( ) { return threadCache . isSet ( ) ; } @Deprecated public void freeThreadLocalCache ( ) { threadCache . remove ( ) ; } final class PoolThreadLocalCache extends FastThreadLocal < PoolThreadCache > { private final AtomicInteger index = new AtomicInteger ( ) ; final AtomicInteger caches = new AtomicInteger ( ) ; @Override protected PoolThreadCache initialValue ( ) { caches . incrementAndGet ( ) ; final int idx = index . getAndIncrement ( ) ; final PoolArena < byte [ ] > heapArena ; final PoolArena < ByteBuffer > directArena ; if ( heapArenas ! = null ) { heapArena = heapArenas [ Math . abs ( idx % heapArenas . length ) ] ; } else { heapArena = null ; } if ( directArenas ! = null ) { directArena = directArenas [ Math . abs ( idx % directArenas . length ) ] ; } else { directArena = null ; } return new PoolThreadCache ( heapArena , directArena , tinyCacheSize , smallCacheSize , normalCacheSize , DEFAULT_MAX_CACHED_BUFFER_CAPACITY , DEFAULT_CACHE_TRIM_INTERVAL ) ; } @Override protected void onRemoval ( PoolThreadCache value ) { value . free ( ) ; caches . decrementAndGet ( ) ; } } public int numHeapArenas ( ) { return heapArenaMetrics . size ( ) ; } public int numDirectArenas ( ) { return directArenaMetrics . size ( ) ; } public List < PoolArenaMetric > heapArenas ( ) { return heapArenaMetrics ; } public List < PoolArenaMetric > directArenas ( ) { return directArenaMetrics ; } public int numThreadLocalCaches ( ) { return threadCache . caches . get ( ) ; } public int tinyCacheSize ( ) { return tinyCacheSize ; } public int smallCacheSize ( ) { return smallCacheSize ; } public int normalCacheSize ( ) { return normalCacheSize ; } final PoolThreadCache threadCache ( ) { return threadCache . get ( ) ; } } 
