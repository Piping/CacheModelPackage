package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . Objects ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public class RangeTombstoneBoundMarker extends AbstractRangeTombstoneMarker { private final DeletionTime deletion ; public RangeTombstoneBoundMarker ( RangeTombstone . Bound bound , DeletionTime deletion ) { super ( bound ) ; assert ! bound . isBoundary ( ) ; this . deletion = deletion ; } public RangeTombstoneBoundMarker ( Slice . Bound bound , DeletionTime deletion ) { this ( new RangeTombstone . Bound ( bound . kind ( ) , bound . getRawValues ( ) ) , deletion ) ; } public static RangeTombstoneBoundMarker inclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues , DeletionTime deletion ) { RangeTombstone . Bound bound = RangeTombstone . Bound . inclusiveOpen ( reversed , boundValues ) ; return new RangeTombstoneBoundMarker ( bound , deletion ) ; } public static RangeTombstoneBoundMarker exclusiveOpen ( boolean reversed , ByteBuffer [ ] boundValues , DeletionTime deletion ) { RangeTombstone . Bound bound = RangeTombstone . Bound . exclusiveOpen ( reversed , boundValues ) ; return new RangeTombstoneBoundMarker ( bound , deletion ) ; } public static RangeTombstoneBoundMarker inclusiveClose ( boolean reversed , ByteBuffer [ ] boundValues , DeletionTime deletion ) { RangeTombstone . Bound bound = RangeTombstone . Bound . inclusiveClose ( reversed , boundValues ) ; return new RangeTombstoneBoundMarker ( bound , deletion ) ; } public static RangeTombstoneBoundMarker exclusiveClose ( boolean reversed , ByteBuffer [ ] boundValues , DeletionTime deletion ) { RangeTombstone . Bound bound = RangeTombstone . Bound . exclusiveClose ( reversed , boundValues ) ; return new RangeTombstoneBoundMarker ( bound , deletion ) ; } public boolean isBoundary ( ) { return false ; } public DeletionTime deletionTime ( ) { return deletion ; } public DeletionTime openDeletionTime ( boolean reversed ) { if ( ! isOpen ( reversed ) ) throw new IllegalStateException ( ) ; return deletion ; } public DeletionTime closeDeletionTime ( boolean reversed ) { if ( isOpen ( reversed ) ) throw new IllegalStateException ( ) ; return deletion ; } public boolean openIsInclusive ( boolean reversed ) { if ( ! isOpen ( reversed ) ) throw new IllegalStateException ( ) ; return bound . isInclusive ( ) ; } public boolean closeIsInclusive ( boolean reversed ) { if ( isOpen ( reversed ) ) throw new IllegalStateException ( ) ; return bound . isInclusive ( ) ; } public RangeTombstone . Bound openBound ( boolean reversed ) { return isOpen ( reversed ) ? clustering ( ) : null ; } public RangeTombstone . Bound closeBound ( boolean reversed ) { return isClose ( reversed ) ? clustering ( ) : null ; } public RangeTombstoneBoundMarker copy ( AbstractAllocator allocator ) { return new RangeTombstoneBoundMarker ( clustering ( ) . copy ( allocator ) , deletion ) ; } public void digest ( MessageDigest digest ) { bound . digest ( digest ) ; deletion . digest ( digest ) ; } public String toString ( CFMetaData metadata ) { return <str> + bound . toString ( metadata ) + <str> + deletion . markedForDeleteAt ( ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof RangeTombstoneBoundMarker ) ) return false ; RangeTombstoneBoundMarker that = ( RangeTombstoneBoundMarker ) other ; return this . bound . equals ( that . bound ) & & this . deletion . equals ( that . deletion ) ; } @Override public int hashCode ( ) { return Objects . hash ( bound , deletion ) ; } } 
