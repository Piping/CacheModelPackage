package org . elasticsearch . plugins ; import org . apache . http . impl . client . HttpClients ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . Version ; import org . elasticsearch . common . Base64 ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . cli . CliTool ; import org . elasticsearch . common . cli . CliTool . ExitStatus ; import org . elasticsearch . common . cli . CliToolTestCase . CaptureOutputTerminal ; import org . elasticsearch . common . hash . MessageDigests ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . junit . annotations . Network ; import org . elasticsearch . test . rest . client . http . HttpRequestBuilder ; import org . elasticsearch . test . rest . client . http . HttpResponse ; import org . jboss . netty . bootstrap . ServerBootstrap ; import org . jboss . netty . channel . * ; import org . jboss . netty . channel . socket . nio . NioServerSocketChannelFactory ; import org . jboss . netty . handler . codec . http . * ; import org . jboss . netty . handler . ssl . SslContext ; import org . jboss . netty . handler . ssl . SslHandler ; import org . jboss . netty . handler . ssl . util . InsecureTrustManagerFactory ; import org . jboss . netty . handler . ssl . util . SelfSignedCertificate ; import org . junit . After ; import org . junit . Before ; import javax . net . ssl . HttpsURLConnection ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLSocketFactory ; import java . io . BufferedWriter ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . nio . charset . StandardCharsets ; import java . nio . file . FileVisitResult ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . SimpleFileVisitor ; import java . nio . file . StandardOpenOption ; import java . nio . file . attribute . BasicFileAttributes ; import java . nio . file . attribute . PosixFileAttributeView ; import java . nio . file . attribute . PosixFileAttributes ; import java . nio . file . attribute . PosixFilePermission ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import java . util . jar . JarOutputStream ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; import static org . elasticsearch . common . cli . CliTool . ExitStatus . USAGE ; import static org . elasticsearch . common . cli . CliToolTestCase . args ; import static org . elasticsearch . common . io . FileTestUtils . assertFileContent ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . ESIntegTestCase . Scope ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . * ; import static org . hamcrest . Matchers . * ; import static org . jboss . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , transportClientRatio = <float> ) @LuceneTestCase.SuppressFileSystems ( <str> ) @SuppressForbidden ( reason = <str> ) public class PluginManagerTests extends ESIntegTestCase { private Environment environment ; private CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; @Before public void setup ( ) throws Exception { environment = buildInitialSettings ( ) ; System . setProperty ( <str> , environment . settings ( ) . get ( <str> ) ) ; Path binDir = environment . binFile ( ) ; if ( ! Files . exists ( binDir ) ) { Files . createDirectories ( binDir ) ; } Path configDir = environment . configFile ( ) ; if ( ! Files . exists ( configDir ) ) { Files . createDirectories ( configDir ) ; } } @After public void clearPathHome ( ) { System . clearProperty ( <str> ) ; } private void writeSha1 ( Path file , boolean corrupt ) throws IOException { String sha1Hex = MessageDigests . toHexString ( MessageDigests . sha1 ( ) . digest ( Files . readAllBytes ( file ) ) ) ; try ( BufferedWriter out = Files . newBufferedWriter ( file . resolveSibling ( file . getFileName ( ) + <str> ) , StandardCharsets . UTF_8 ) ) { out . write ( sha1Hex ) ; if ( corrupt ) { out . write ( <str> ) ; } } } private void writeMd5 ( Path file , boolean corrupt ) throws IOException { String md5Hex = MessageDigests . toHexString ( MessageDigests . md5 ( ) . digest ( Files . readAllBytes ( file ) ) ) ; try ( BufferedWriter out = Files . newBufferedWriter ( file . resolveSibling ( file . getFileName ( ) + <str> ) , StandardCharsets . UTF_8 ) ) { out . write ( md5Hex ) ; if ( corrupt ) { out . write ( <str> ) ; } } } private String createPlugin ( final Path structure , String . . . properties ) throws IOException { PluginTestUtil . writeProperties ( structure , properties ) ; Path zip = createTempDir ( ) . resolve ( structure . getFileName ( ) + <str> ) ; try ( ZipOutputStream stream = new ZipOutputStream ( Files . newOutputStream ( zip ) ) ) { Files . walkFileTree ( structure , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { stream . putNextEntry ( new ZipEntry ( structure . relativize ( file ) . toString ( ) ) ) ; Files . copy ( file , stream ) ; return FileVisitResult . CONTINUE ; } } ) ; } if ( randomBoolean ( ) ) { writeSha1 ( zip , false ) ; } else if ( randomBoolean ( ) ) { writeMd5 ( zip , false ) ; } return zip . toUri ( ) . toURL ( ) . toString ( ) ; } private String createPluginWithBadChecksum ( final Path structure , String . . . properties ) throws IOException { PluginTestUtil . writeProperties ( structure , properties ) ; Path zip = createTempDir ( ) . resolve ( structure . getFileName ( ) + <str> ) ; try ( ZipOutputStream stream = new ZipOutputStream ( Files . newOutputStream ( zip ) ) ) { Files . walkFileTree ( structure , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { stream . putNextEntry ( new ZipEntry ( structure . relativize ( file ) . toString ( ) ) ) ; Files . copy ( file , stream ) ; return FileVisitResult . CONTINUE ; } } ) ; } if ( randomBoolean ( ) ) { writeSha1 ( zip , true ) ; } else { writeMd5 ( zip , true ) ; } return zip . toUri ( ) . toURL ( ) . toString ( ) ; } public void testThatPluginNameMustBeSupplied ( ) throws IOException { Path pluginDir = createTempDir ( ) . resolve ( <str> ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , <str> , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; assertStatus ( <str> , USAGE ) ; } public void testLocalPluginInstallWithBinAndConfig ( ) throws Exception { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; Path binDir = environment . binFile ( ) ; Path pluginBinDir = binDir . resolve ( pluginName ) ; Path pluginConfigDir = environment . configFile ( ) . resolve ( pluginName ) ; assertStatusOk ( <str> + pluginUrl + <str> ) ; terminal . getTerminalOutput ( ) . clear ( ) ; assertStatusOk ( <str> ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( pluginName ) ) ) ; assertDirectoryExists ( pluginBinDir ) ; assertDirectoryExists ( pluginConfigDir ) ; Path toolFile = pluginBinDir . resolve ( <str> ) ; assertFileExists ( toolFile ) ; PosixFileAttributeView view = Files . getFileAttributeView ( toolFile , PosixFileAttributeView . class ) ; if ( view ! = null ) { PosixFileAttributes attributes = view . readAttributes ( ) ; assertThat ( attributes . permissions ( ) , hasItem ( PosixFilePermission . OWNER_EXECUTE ) ) ; assertThat ( attributes . permissions ( ) , hasItem ( PosixFilePermission . OWNER_READ ) ) ; } } public void testLocalPluginInstallWithBinAndConfigInAlreadyExistingConfigDir_7890 ( ) throws Exception { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; Path pluginConfigDir = environment . configFile ( ) . resolve ( pluginName ) ; assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginUrl ) ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertStatusOk ( <str> + pluginName ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginUrl ) ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertStatusOk ( <str> + pluginName ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . write ( pluginDir . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) . resolve ( <str> ) , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginUrl ) ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; assertFileContent ( pluginConfigDir , <str> , <str> ) ; } public void testLocalPluginInstallWithBinOnly_7152 ( ) throws Exception { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , <str> , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; Path binDir = environment . binFile ( ) ; Path pluginBinDir = binDir . resolve ( pluginName ) ; assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginUrl ) ) ; assertThatPluginIsListed ( pluginName ) ; assertDirectoryExists ( pluginBinDir ) ; } public void testListInstalledEmpty ( ) throws IOException { assertStatusOk ( <str> ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testListInstalledEmptyWithExistingPluginDirectory ( ) throws IOException { Files . createDirectory ( environment . pluginsFile ( ) ) ; assertStatusOk ( <str> ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testInstallPluginVerbose ( ) throws IOException { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; System . err . println ( <str> + pluginUrl + <str> ) ; ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl + <str> ) ) ; assertThat ( <str> + terminal . getTerminalOutput ( ) , status , is ( ExitStatus . OK ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThatPluginIsListed ( pluginName ) ; } public void testInstallPlugin ( ) throws IOException { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl ) ) ; assertThat ( <str> + terminal . getTerminalOutput ( ) , status , is ( ExitStatus . OK ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThatPluginIsListed ( pluginName ) ; } @Deprecated public void testAlreadyInstalledNotIsolated ( ) throws Exception { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir ) ; Path pluginJar = pluginDir . resolve ( <str> ) ; try ( ZipOutputStream out = new JarOutputStream ( Files . newOutputStream ( pluginJar , StandardOpenOption . CREATE ) ) ) { out . putNextEntry ( new ZipEntry ( <str> ) ) ; out . closeEntry ( ) ; } String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> , <str> , <str> ) ; ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl ) ) ; assertEquals ( <str> + terminal . getTerminalOutput ( ) , ExitStatus . OK , status ) ; status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl ) ) ; List < String > output = terminal . getTerminalOutput ( ) ; assertEquals ( <str> + output , ExitStatus . IO_ERROR , status ) ; boolean foundExpectedMessage = false ; for ( String line : output ) { foundExpectedMessage | = line . contains ( <str> ) ; } assertTrue ( foundExpectedMessage ) ; } public void testInstallSitePluginVerbose ( ) throws IOException { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , <str> ) ; ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl + <str> ) ) ; assertThat ( <str> + terminal . getTerminalOutput ( ) , status , is ( ExitStatus . OK ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThatPluginIsListed ( pluginName ) ; assertFileExists ( environment . pluginsFile ( ) . resolve ( pluginName ) . resolve ( <str> ) ) ; } public void testInstallSitePlugin ( ) throws IOException { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , <str> ) ; ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( <str> + pluginUrl ) ) ; assertThat ( <str> + terminal . getTerminalOutput ( ) , status , is ( ExitStatus . OK ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThatPluginIsListed ( pluginName ) ; assertFileExists ( environment . pluginsFile ( ) . resolve ( pluginName ) . resolve ( <str> ) ) ; } public void testInstallPluginWithBadChecksum ( ) throws IOException { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; Files . createDirectories ( pluginDir . resolve ( <str> ) ) ; Files . createFile ( pluginDir . resolve ( <str> ) . resolve ( <str> ) ) ; String pluginUrl = createPluginWithBadChecksum ( pluginDir , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertStatus ( String . format ( Locale . ROOT , <str> , pluginUrl ) , ExitStatus . IO_ERROR ) ; assertThatPluginIsNotListed ( pluginName ) ; assertFileNotExists ( environment . pluginsFile ( ) . resolve ( pluginName ) . resolve ( <str> ) ) ; } private void singlePluginInstallAndRemove ( String pluginDescriptor , String pluginName , String pluginCoordinates ) throws IOException { logger . info ( <str> , pluginDescriptor ) ; if ( pluginCoordinates = = null ) { assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginDescriptor ) ) ; } else { assertStatusOk ( String . format ( Locale . ROOT , <str> , pluginCoordinates ) ) ; } assertThatPluginIsListed ( pluginName ) ; terminal . getTerminalOutput ( ) . clear ( ) ; assertStatusOk ( <str> + pluginDescriptor ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> + pluginDescriptor ) ) ) ; terminal . getTerminalOutput ( ) . clear ( ) ; assertStatusOk ( <str> ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( pluginName ) ) ) ) ; } @Network @AwaitsFix ( bugUrl = <str> ) public void testInstallPluginWithElasticsearchDownloadService ( ) throws IOException { assumeTrue ( <str> , isDownloadServiceWorking ( <str> , <int> , <str> ) ) ; singlePluginInstallAndRemove ( <str> , <str> , null ) ; } @Network @AwaitsFix ( bugUrl = <str> ) public void testInstallPluginWithMavenCentral ( ) throws IOException { assumeTrue ( <str> , isDownloadServiceWorking ( <str> , <int> , <str> ) ) ; assumeTrue ( <str> , isDownloadServiceWorking ( <str> , <int> , <str> ) ) ; singlePluginInstallAndRemove ( <str> , <str> , null ) ; } @Network @AwaitsFix ( bugUrl = <str> ) public void testInstallPluginWithGithub ( ) throws IOException { assumeTrue ( <str> , isDownloadServiceWorking ( <str> , <int> , <str> ) ) ; singlePluginInstallAndRemove ( <str> , <str> , null ) ; } private boolean isDownloadServiceWorking ( String host , int port , String resource ) { try { String protocol = port = = <int> ? <str> : <str> ; HttpResponse response = new HttpRequestBuilder ( HttpClients . createDefault ( ) ) . protocol ( protocol ) . host ( host ) . port ( port ) . path ( resource ) . execute ( ) ; if ( response . getStatusCode ( ) ! = <int> ) { logger . warn ( <str> , host , resource ) ; return false ; } return true ; } catch ( Throwable t ) { logger . warn ( <str> , host , resource ) ; } return false ; } public void testRemovePlugin ( ) throws Exception { String pluginName = <str> ; Path pluginDir = createTempDir ( ) . resolve ( pluginName ) ; String pluginUrl = createPlugin ( pluginDir , <str> , <str> , <str> , pluginName , <str> , <str> , <str> , Version . CURRENT . toString ( ) , <str> , System . getProperty ( <str> ) , <str> , <str> , <str> , <str> ) ; singlePluginInstallAndRemove ( <str> , <str> , pluginUrl ) ; singlePluginInstallAndRemove ( <str> , <str> , pluginUrl ) ; singlePluginInstallAndRemove ( <str> , <str> , pluginUrl ) ; } public void testRemovePlugin_NullName_ThrowsException ( ) throws IOException { assertStatus ( <str> , USAGE ) ; } public void testRemovePluginWithURLForm ( ) throws Exception { assertStatus ( <str> , USAGE ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testForbiddenPluginNames ( ) throws IOException { assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; assertStatus ( <str> , USAGE ) ; } public void testOfficialPluginName_ThrowsException ( ) throws IOException { PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; PluginManager . checkForOfficialPlugins ( <str> ) ; try { PluginManager . checkForOfficialPlugins ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testThatBasicAuthIsRejectedOnHttp ( ) throws Exception { assertStatus ( String . format ( Locale . ROOT , <str> ) , CliTool . ExitStatus . IO_ERROR ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testThatBasicAuthIsSupportedWithHttps ( ) throws Exception { assumeTrue ( <str> , System . getSecurityManager ( ) = = null ) ; SSLSocketFactory defaultSocketFactory = HttpsURLConnection . getDefaultSSLSocketFactory ( ) ; ServerBootstrap serverBootstrap = new ServerBootstrap ( new NioServerSocketChannelFactory ( ) ) ; SelfSignedCertificate ssc = null ; try { try { ssc = new SelfSignedCertificate ( <str> ) ; } catch ( Exception e ) { assumeNoException ( <str> , e ) ; } SSLContext sc = SSLContext . getInstance ( <str> ) ; sc . init ( null , InsecureTrustManagerFactory . INSTANCE . getTrustManagers ( ) , null ) ; HttpsURLConnection . setDefaultSSLSocketFactory ( sc . getSocketFactory ( ) ) ; final List < HttpRequest > requests = new ArrayList < > ( ) ; final SslContext sslContext = SslContext . newServerContext ( ssc . certificate ( ) , ssc . privateKey ( ) ) ; serverBootstrap . setPipelineFactory ( new ChannelPipelineFactory ( ) { @Override public ChannelPipeline getPipeline ( ) throws Exception { return Channels . pipeline ( new SslHandler ( sslContext . newEngine ( ) ) , new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) , new LoggingServerHandler ( requests ) ) ; } } ) ; Channel channel = serverBootstrap . bind ( new InetSocketAddress ( InetAddress . getByName ( <str> ) , <int> ) ) ; int port = ( ( InetSocketAddress ) channel . getLocalAddress ( ) ) . getPort ( ) ; assertStatus ( String . format ( Locale . ROOT , <str> , port ) , ExitStatus . IO_ERROR ) ; assertThat ( terminal . getTerminalOutput ( ) , not ( hasItem ( containsString ( <str> ) ) ) ) ; assertThat ( requests , hasSize ( <int> ) ) ; String msg = String . format ( Locale . ROOT , <str> , terminal . getTerminalOutput ( ) ) ; assertThat ( msg , requests . get ( <int> ) . headers ( ) . contains ( <str> ) , is ( true ) ) ; assertThat ( msg , requests . get ( <int> ) . headers ( ) . get ( <str> ) , is ( <str> + Base64 . encodeBytes ( <str> . getBytes ( StandardCharsets . UTF_8 ) ) ) ) ; } finally { HttpsURLConnection . setDefaultSSLSocketFactory ( defaultSocketFactory ) ; serverBootstrap . releaseExternalResources ( ) ; if ( ssc ! = null ) { ssc . delete ( ) ; } } } private static class LoggingServerHandler extends SimpleChannelUpstreamHandler { private List < HttpRequest > requests ; public LoggingServerHandler ( List < HttpRequest > requests ) { this . requests = requests ; } @Override public void messageReceived ( final ChannelHandlerContext ctx , final MessageEvent e ) throws InterruptedException { final HttpRequest request = ( HttpRequest ) e . getMessage ( ) ; requests . add ( request ) ; final org . jboss . netty . handler . codec . http . HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , HttpResponseStatus . BAD_REQUEST ) ; ctx . getChannel ( ) . write ( response ) ; } } private Environment buildInitialSettings ( ) throws IOException { Settings settings = settingsBuilder ( ) . put ( <str> , true ) . put ( <str> , createTempDir ( ) ) . build ( ) ; return InternalSettingsPreparer . prepareEnvironment ( settings , null ) ; } private void assertStatusOk ( String command ) { assertStatus ( command , ExitStatus . OK ) ; } private void assertStatus ( String command , ExitStatus exitStatus ) { ExitStatus status = new PluginManagerCliParser ( terminal ) . execute ( args ( command ) ) ; assertThat ( <str> + terminal . getTerminalOutput ( ) , status , is ( exitStatus ) ) ; } private void assertThatPluginIsListed ( String pluginName ) { terminal . getTerminalOutput ( ) . clear ( ) ; assertStatusOk ( <str> ) ; String message = String . format ( Locale . ROOT , <str> , terminal . getTerminalOutput ( ) ) ; assertThat ( message , terminal . getTerminalOutput ( ) , hasItem ( containsString ( pluginName ) ) ) ; } private void assertThatPluginIsNotListed ( String pluginName ) { terminal . getTerminalOutput ( ) . clear ( ) ; assertStatusOk ( <str> ) ; String message = String . format ( Locale . ROOT , <str> , terminal . getTerminalOutput ( ) ) ; assertFalse ( message , terminal . getTerminalOutput ( ) . contains ( pluginName ) ) ; } } 
