package io . netty . handler . codec . marshalling ; import org . jboss . marshalling . ByteInput ; import java . io . IOException ; class LimitingByteInput implements ByteInput { private static final TooBigObjectException EXCEPTION = new TooBigObjectException ( ) ; private final ByteInput input ; private final long limit ; private long read ; LimitingByteInput ( ByteInput input , long limit ) { if ( limit < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . input = input ; this . limit = limit ; } @Override public void close ( ) throws IOException { } @Override public int available ( ) throws IOException { return readable ( input . available ( ) ) ; } @Override public int read ( ) throws IOException { int readable = readable ( <int> ) ; if ( readable > <int> ) { int b = input . read ( ) ; read + + ; return b ; } else { throw EXCEPTION ; } } @Override public int read ( byte [ ] array ) throws IOException { return read ( array , <int> , array . length ) ; } @Override public int read ( byte [ ] array , int offset , int length ) throws IOException { int readable = readable ( length ) ; if ( readable > <int> ) { int i = input . read ( array , offset , readable ) ; read + = i ; return i ; } else { throw EXCEPTION ; } } @Override public long skip ( long bytes ) throws IOException { int readable = readable ( ( int ) bytes ) ; if ( readable > <int> ) { long i = input . skip ( readable ) ; read + = i ; return i ; } else { throw EXCEPTION ; } } private int readable ( int length ) { return ( int ) Math . min ( length , limit - read ) ; } static final class TooBigObjectException extends IOException { private static final long serialVersionUID = <int> ; } } 
