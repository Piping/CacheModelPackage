package org . apache . cassandra . cql3 ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . serializers . MarshalException ; import org . codehaus . jackson . io . JsonStringEncoder ; import org . codehaus . jackson . map . ObjectMapper ; public class Json { public static final ObjectMapper JSON_OBJECT_MAPPER = new ObjectMapper ( ) ; public static final JsonStringEncoder JSON_STRING_ENCODER = new JsonStringEncoder ( ) ; public static final ColumnIdentifier JSON_COLUMN_ID = new ColumnIdentifier ( <str> , true ) ; public static Object decodeJson ( String json ) { try { return JSON_OBJECT_MAPPER . readValue ( json , Object . class ) ; } catch ( IOException exc ) { throw new MarshalException ( <str> + exc . getMessage ( ) ) ; } } public interface Raw { public Prepared prepareAndCollectMarkers ( CFMetaData metadata , Collection < ColumnDefinition > receivers , VariableSpecifications boundNames ) ; } public static class Literal implements Raw { private final String text ; public Literal ( String text ) { this . text = text ; } public Prepared prepareAndCollectMarkers ( CFMetaData metadata , Collection < ColumnDefinition > receivers , VariableSpecifications boundNames ) { return new PreparedLiteral ( parseJson ( text , receivers ) ) ; } } public static class Marker implements Raw { protected final int bindIndex ; public Marker ( int bindIndex ) { this . bindIndex = bindIndex ; } public Prepared prepareAndCollectMarkers ( CFMetaData metadata , Collection < ColumnDefinition > receivers , VariableSpecifications boundNames ) { boundNames . add ( bindIndex , makeReceiver ( metadata ) ) ; return new PreparedMarker ( bindIndex , receivers ) ; } private ColumnSpecification makeReceiver ( CFMetaData metadata ) { return new ColumnSpecification ( metadata . ksName , metadata . cfName , JSON_COLUMN_ID , UTF8Type . instance ) ; } } public static abstract class Prepared { public abstract Term . Raw getRawTermForColumn ( ColumnDefinition def ) ; } private static class PreparedLiteral extends Prepared { private final Map < ColumnIdentifier , Term > columnMap ; public PreparedLiteral ( Map < ColumnIdentifier , Term > columnMap ) { this . columnMap = columnMap ; } public Term . Raw getRawTermForColumn ( ColumnDefinition def ) { Term value = columnMap . get ( def . name ) ; return value = = null ? Constants . NULL_LITERAL : new ColumnValue ( value ) ; } } private static class PreparedMarker extends Prepared { private final int bindIndex ; private final Collection < ColumnDefinition > columns ; public PreparedMarker ( int bindIndex , Collection < ColumnDefinition > columns ) { this . bindIndex = bindIndex ; this . columns = columns ; } public RawDelayedColumnValue getRawTermForColumn ( ColumnDefinition def ) { return new RawDelayedColumnValue ( this , def ) ; } } private static class ColumnValue extends Term . Raw { private final Term term ; public ColumnValue ( Term term ) { this . term = term ; } @Override public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { return term ; } @Override public TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { return TestResult . NOT_ASSIGNABLE ; } public String getText ( ) { return term . toString ( ) ; } } private static class RawDelayedColumnValue extends Term . Raw { private final PreparedMarker marker ; private final ColumnDefinition column ; public RawDelayedColumnValue ( PreparedMarker prepared , ColumnDefinition column ) { this . marker = prepared ; this . column = column ; } @Override public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { return new DelayedColumnValue ( marker , column ) ; } @Override public TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { return TestResult . WEAKLY_ASSIGNABLE ; } public String getText ( ) { return marker . toString ( ) ; } } private static class DelayedColumnValue extends Term . NonTerminal { private final PreparedMarker marker ; private final ColumnDefinition column ; public DelayedColumnValue ( PreparedMarker prepared , ColumnDefinition column ) { this . marker = prepared ; this . column = column ; } @Override public void collectMarkerSpecification ( VariableSpecifications boundNames ) { } @Override public boolean containsBindMarker ( ) { return true ; } @Override public Terminal bind ( QueryOptions options ) throws InvalidRequestException { Term term = options . getJsonColumnValue ( marker . bindIndex , column . name , marker . columns ) ; return term = = null ? null : term . bind ( options ) ; } @Override public Iterable < Function > getFunctions ( ) { return Collections . emptyList ( ) ; } } public static Map < ColumnIdentifier , Term > parseJson ( String jsonString , Collection < ColumnDefinition > expectedReceivers ) { try { Map < String , Object > valueMap = JSON_OBJECT_MAPPER . readValue ( jsonString , Map . class ) ; if ( valueMap = = null ) throw new InvalidRequestException ( <str> ) ; handleCaseSensitivity ( valueMap ) ; Map < ColumnIdentifier , Term > columnMap = new HashMap < > ( expectedReceivers . size ( ) ) ; for ( ColumnSpecification spec : expectedReceivers ) { Object parsedJsonObject = valueMap . remove ( spec . name . toString ( ) ) ; if ( parsedJsonObject = = null ) { columnMap . put ( spec . name , null ) ; } else { try { columnMap . put ( spec . name , spec . type . fromJSONObject ( parsedJsonObject ) ) ; } catch ( MarshalException exc ) { throw new InvalidRequestException ( String . format ( <str> , spec . name , exc . getMessage ( ) ) ) ; } } } if ( ! valueMap . isEmpty ( ) ) { throw new InvalidRequestException ( String . format ( <str> , valueMap . keySet ( ) . iterator ( ) . next ( ) ) ) ; } return columnMap ; } catch ( IOException exc ) { throw new InvalidRequestException ( String . format ( <str> , exc . toString ( ) , jsonString ) ) ; } catch ( MarshalException exc ) { throw new InvalidRequestException ( exc . getMessage ( ) ) ; } } public static void handleCaseSensitivity ( Map < String , Object > valueMap ) { for ( String mapKey : new ArrayList < > ( valueMap . keySet ( ) ) ) { if ( mapKey . startsWith ( <str> ) & & mapKey . endsWith ( <str> ) ) { valueMap . put ( mapKey . substring ( <int> , mapKey . length ( ) - <int> ) , valueMap . remove ( mapKey ) ) ; continue ; } String lowered = mapKey . toLowerCase ( Locale . US ) ; if ( ! mapKey . equals ( lowered ) ) valueMap . put ( lowered , valueMap . remove ( mapKey ) ) ; } } } 
