package org . apache . cassandra . net ; import java . io . DataInputStream ; import java . io . DataOutput ; import java . io . IOException ; import java . net . InetAddress ; import java . net . Socket ; import java . net . SocketException ; import java . nio . ByteBuffer ; import java . nio . channels . Channels ; import java . nio . channels . WritableByteChannel ; import java . util . * ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . zip . Checksum ; import javax . net . ssl . SSLHandshakeException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import net . jpountz . lz4 . LZ4BlockOutputStream ; import net . jpountz . lz4 . LZ4Compressor ; import net . jpountz . lz4 . LZ4Factory ; import net . jpountz . xxhash . XXHashFactory ; import org . apache . cassandra . io . util . DataOutputStreamPlus ; import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; import org . apache . cassandra . io . util . WrappedDataOutputStreamPlus ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . CoalescingStrategies ; import org . apache . cassandra . utils . CoalescingStrategies . Coalescable ; import org . apache . cassandra . utils . CoalescingStrategies . CoalescingStrategy ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . NanoTimeToCurrentTimeMillis ; import org . apache . cassandra . utils . UUIDGen ; import org . xerial . snappy . SnappyOutputStream ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import com . google . common . util . concurrent . Uninterruptibles ; public class OutboundTcpConnection extends Thread { private static final Logger logger = LoggerFactory . getLogger ( OutboundTcpConnection . class ) ; private static final String PREFIX = Config . PROPERTY_PREFIX ; private static final String INTRADC_TCP_NODELAY_PROPERTY = PREFIX + <str> ; private static final boolean INTRADC_TCP_NODELAY = Boolean . valueOf ( System . getProperty ( INTRADC_TCP_NODELAY_PROPERTY , <str> ) ) ; private static final String BUFFER_SIZE_PROPERTY = PREFIX + <str> ; private static final int BUFFER_SIZE = Integer . getInteger ( BUFFER_SIZE_PROPERTY , <int> * <int> ) ; private static CoalescingStrategy newCoalescingStrategy ( String displayName ) { return CoalescingStrategies . newCoalescingStrategy ( DatabaseDescriptor . getOtcCoalescingStrategy ( ) , DatabaseDescriptor . getOtcCoalescingWindow ( ) , logger , displayName ) ; } static { String strategy = DatabaseDescriptor . getOtcCoalescingStrategy ( ) ; switch ( strategy ) { case <str> : break ; case <str> : case <str> : case <str> : logger . info ( <str> , strategy ) ; break ; default : newCoalescingStrategy ( <str> ) ; } int coalescingWindow = DatabaseDescriptor . getOtcCoalescingWindow ( ) ; if ( coalescingWindow ! = Config . otc_coalescing_window_us_default ) logger . info ( <str> , coalescingWindow ) ; if ( coalescingWindow < <int> ) throw new ExceptionInInitializerError ( <str> + coalescingWindow ) ; } private static final MessageOut CLOSE_SENTINEL = new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) ; private volatile boolean isStopped = false ; private static final int OPEN_RETRY_DELAY = <int> ; public static final int WAIT_FOR_VERSION_MAX_TIME = <int> ; private static final int NO_VERSION = Integer . MIN_VALUE ; static final int LZ4_HASH_SEED = <hex> ; private final BlockingQueue < QueuedMessage > backlog = new LinkedBlockingQueue < > ( ) ; private final OutboundTcpConnectionPool poolReference ; private final CoalescingStrategy cs ; private DataOutputStreamPlus out ; private Socket socket ; private volatile long completed ; private final AtomicLong dropped = new AtomicLong ( ) ; private volatile int currentMsgBufferCount = <int> ; private int targetVersion = MessagingService . current_version ; public OutboundTcpConnection ( OutboundTcpConnectionPool pool ) { super ( <str> + pool . endPoint ( ) ) ; this . poolReference = pool ; cs = newCoalescingStrategy ( pool . endPoint ( ) . getHostAddress ( ) ) ; } private static boolean isLocalDC ( InetAddress targetHost ) { String remoteDC = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( targetHost ) ; String localDC = DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ; return remoteDC . equals ( localDC ) ; } public void enqueue ( MessageOut < ? > message , int id ) { if ( backlog . size ( ) > <int> ) expireMessages ( ) ; try { backlog . put ( new QueuedMessage ( message , id ) ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } } void closeSocket ( boolean destroyThread ) { backlog . clear ( ) ; isStopped = destroyThread ; enqueue ( CLOSE_SENTINEL , - <int> ) ; } void softCloseSocket ( ) { enqueue ( CLOSE_SENTINEL , - <int> ) ; } public int getTargetVersion ( ) { return targetVersion ; } public void run ( ) { final int drainedMessageSize = <int> ; final List < QueuedMessage > drainedMessages = new ArrayList < > ( drainedMessageSize ) ; outer: while ( true ) { try { cs . coalesce ( backlog , drainedMessages , drainedMessageSize ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } currentMsgBufferCount = drainedMessages . size ( ) ; int count = drainedMessages . size ( ) ; for ( QueuedMessage qm : drainedMessages ) { try { MessageOut < ? > m = qm . message ; if ( m = = CLOSE_SENTINEL ) { disconnect ( ) ; if ( isStopped ) break outer ; continue ; } if ( qm . isTimedOut ( TimeUnit . MILLISECONDS . toNanos ( m . getTimeout ( ) ) , System . nanoTime ( ) ) ) dropped . incrementAndGet ( ) ; else if ( socket ! = null | | connect ( ) ) writeConnected ( qm , count = = <int> & & backlog . isEmpty ( ) ) ; else backlog . clear ( ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; logger . error ( <str> , poolReference . endPoint ( ) , e ) ; } currentMsgBufferCount = - - count ; } drainedMessages . clear ( ) ; } } public int getPendingMessages ( ) { return backlog . size ( ) + currentMsgBufferCount ; } public long getCompletedMesssages ( ) { return completed ; } public long getDroppedMessages ( ) { return dropped . get ( ) ; } private boolean shouldCompressConnection ( ) { return DatabaseDescriptor . internodeCompression ( ) = = Config . InternodeCompression . all | | ( DatabaseDescriptor . internodeCompression ( ) = = Config . InternodeCompression . dc & & ! isLocalDC ( poolReference . endPoint ( ) ) ) ; } private void writeConnected ( QueuedMessage qm , boolean flush ) { try { byte [ ] sessionBytes = qm . message . parameters . get ( Tracing . TRACE_HEADER ) ; if ( sessionBytes ! = null ) { UUID sessionId = UUIDGen . getUUID ( ByteBuffer . wrap ( sessionBytes ) ) ; TraceState state = Tracing . instance . get ( sessionId ) ; String message = String . format ( <str> , qm . message . verb , poolReference . endPoint ( ) ) ; if ( state = = null ) { byte [ ] traceTypeBytes = qm . message . parameters . get ( Tracing . TRACE_TYPE ) ; Tracing . TraceType traceType = traceTypeBytes = = null ? Tracing . TraceType . QUERY : Tracing . TraceType . deserialize ( traceTypeBytes [ <int> ] ) ; TraceState . mutateWithTracing ( ByteBuffer . wrap ( sessionBytes ) , message , - <int> , traceType . getTTL ( ) ) ; } else { state . trace ( message ) ; if ( qm . message . verb = = MessagingService . Verb . REQUEST_RESPONSE ) Tracing . instance . doneWithNonLocalSession ( state ) ; } } long timestampMillis = NanoTimeToCurrentTimeMillis . convert ( qm . timestampNanos ) ; writeInternal ( qm . message , qm . id , timestampMillis ) ; completed + + ; if ( flush ) out . flush ( ) ; } catch ( Exception e ) { disconnect ( ) ; if ( e instanceof IOException | | e . getCause ( ) instanceof IOException ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , poolReference . endPoint ( ) , e ) ; if ( qm . shouldRetry ( ) ) { try { backlog . put ( new RetriedQueuedMessage ( qm ) ) ; } catch ( InterruptedException e1 ) { throw new AssertionError ( e1 ) ; } } } else { logger . error ( <str> , poolReference . endPoint ( ) , e ) ; } } } private void writeInternal ( MessageOut message , int id , long timestamp ) throws IOException { out . writeInt ( MessagingService . PROTOCOL_MAGIC ) ; if ( targetVersion < MessagingService . VERSION_20 ) out . writeUTF ( String . valueOf ( id ) ) ; else out . writeInt ( id ) ; out . writeInt ( ( int ) timestamp ) ; message . serialize ( out , targetVersion ) ; } private static void writeHeader ( DataOutput out , int version , boolean compressionEnabled ) throws IOException { int header = <int> ; if ( compressionEnabled ) header | = <int> ; header | = ( version < < <int> ) ; out . writeInt ( header ) ; } private void disconnect ( ) { if ( socket ! = null ) { try { socket . close ( ) ; } catch ( IOException e ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> + poolReference . endPoint ( ) , e ) ; } out = null ; socket = null ; } } @SuppressWarnings ( <str> ) private boolean connect ( ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , poolReference . endPoint ( ) ) ; long start = System . nanoTime ( ) ; long timeout = TimeUnit . MILLISECONDS . toNanos ( DatabaseDescriptor . getRpcTimeout ( ) ) ; while ( System . nanoTime ( ) - start < timeout ) { targetVersion = MessagingService . instance ( ) . getVersion ( poolReference . endPoint ( ) ) ; try { socket = poolReference . newSocket ( ) ; socket . setKeepAlive ( true ) ; if ( isLocalDC ( poolReference . endPoint ( ) ) ) { socket . setTcpNoDelay ( INTRADC_TCP_NODELAY ) ; } else { socket . setTcpNoDelay ( DatabaseDescriptor . getInterDCTcpNoDelay ( ) ) ; } if ( DatabaseDescriptor . getInternodeSendBufferSize ( ) ! = null ) { try { socket . setSendBufferSize ( DatabaseDescriptor . getInternodeSendBufferSize ( ) ) ; } catch ( SocketException se ) { logger . warn ( <str> , se ) ; } } WritableByteChannel ch = socket . getChannel ( ) ; out = new BufferedDataOutputStreamPlus ( ch ! = null ? ch : Channels . newChannel ( socket . getOutputStream ( ) ) , BUFFER_SIZE ) ; out . writeInt ( MessagingService . PROTOCOL_MAGIC ) ; writeHeader ( out , targetVersion , shouldCompressConnection ( ) ) ; out . flush ( ) ; DataInputStream in = new DataInputStream ( socket . getInputStream ( ) ) ; int maxTargetVersion = handshakeVersion ( in ) ; if ( maxTargetVersion = = NO_VERSION ) { logger . trace ( <str> , maxTargetVersion ) ; if ( DatabaseDescriptor . getSeeds ( ) . contains ( poolReference . endPoint ( ) ) ) logger . warn ( <str> , maxTargetVersion ) ; disconnect ( ) ; continue ; } else { MessagingService . instance ( ) . setVersion ( poolReference . endPoint ( ) , maxTargetVersion ) ; } if ( targetVersion > maxTargetVersion ) { logger . trace ( <str> , maxTargetVersion ) ; disconnect ( ) ; return false ; } if ( targetVersion < maxTargetVersion & & targetVersion < MessagingService . current_version ) { logger . trace ( <str> , maxTargetVersion , targetVersion ) ; softCloseSocket ( ) ; } out . writeInt ( MessagingService . current_version ) ; CompactEndpointSerializationHelper . serialize ( FBUtilities . getBroadcastAddress ( ) , out ) ; if ( shouldCompressConnection ( ) ) { out . flush ( ) ; logger . trace ( <str> ) ; if ( targetVersion < MessagingService . VERSION_21 ) { out = new WrappedDataOutputStreamPlus ( new SnappyOutputStream ( socket . getOutputStream ( ) ) ) ; } else { LZ4Compressor compressor = LZ4Factory . fastestInstance ( ) . fastCompressor ( ) ; Checksum checksum = XXHashFactory . fastestInstance ( ) . newStreamingHash32 ( LZ4_HASH_SEED ) . asChecksum ( ) ; out = new WrappedDataOutputStreamPlus ( new LZ4BlockOutputStream ( socket . getOutputStream ( ) , <int> < < <int> , compressor , checksum , true ) ) ; } } return true ; } catch ( SSLHandshakeException e ) { logger . error ( <str> + socket , e ) ; socket = null ; return false ; } catch ( IOException e ) { socket = null ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> + poolReference . endPoint ( ) , e ) ; Uninterruptibles . sleepUninterruptibly ( OPEN_RETRY_DELAY , TimeUnit . MILLISECONDS ) ; } } return false ; } private int handshakeVersion ( final DataInputStream inputStream ) { final AtomicInteger version = new AtomicInteger ( NO_VERSION ) ; final CountDownLatch versionLatch = new CountDownLatch ( <int> ) ; new Thread ( <str> + poolReference . endPoint ( ) ) { @Override public void run ( ) { try { logger . info ( <str> , poolReference . endPoint ( ) ) ; version . set ( inputStream . readInt ( ) ) ; } catch ( IOException ex ) { final String msg = <str> + poolReference . endPoint ( ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( msg , ex ) ; else logger . info ( msg ) ; } finally { versionLatch . countDown ( ) ; } } } . start ( ) ; try { versionLatch . await ( WAIT_FOR_VERSION_MAX_TIME , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ex ) { throw new AssertionError ( ex ) ; } return version . get ( ) ; } private void expireMessages ( ) { Iterator < QueuedMessage > iter = backlog . iterator ( ) ; while ( iter . hasNext ( ) ) { QueuedMessage qm = iter . next ( ) ; if ( ! qm . droppable ) continue ; if ( qm . timestampNanos > = System . nanoTime ( ) - qm . message . getTimeout ( ) ) return ; iter . remove ( ) ; dropped . incrementAndGet ( ) ; } } private static class QueuedMessage implements Coalescable { final MessageOut < ? > message ; final int id ; final long timestampNanos ; final boolean droppable ; QueuedMessage ( MessageOut < ? > message , int id ) { this . message = message ; this . id = id ; this . timestampNanos = System . nanoTime ( ) ; this . droppable = MessagingService . DROPPABLE_VERBS . contains ( message . verb ) ; } boolean isTimedOut ( long maxTimeNanos , long nowNanos ) { return droppable & & timestampNanos < nowNanos - maxTimeNanos ; } boolean shouldRetry ( ) { return ! droppable ; } public long timestampNanos ( ) { return timestampNanos ; } } private static class RetriedQueuedMessage extends QueuedMessage { RetriedQueuedMessage ( QueuedMessage msg ) { super ( msg . message , msg . id ) ; } boolean shouldRetry ( ) { return false ; } } } 
