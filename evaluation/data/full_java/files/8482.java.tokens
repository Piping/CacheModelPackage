package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . search . aggregations . metrics . ValuesSourceMetricsAggregationBuilder ; import org . elasticsearch . search . aggregations . metrics . avg . AvgBuilder ; import org . elasticsearch . search . aggregations . metrics . max . MaxBuilder ; import org . elasticsearch . search . aggregations . metrics . min . MinBuilder ; import org . elasticsearch . search . aggregations . metrics . sum . SumBuilder ; import org . elasticsearch . test . ESTestCase ; import java . util . ArrayList ; public class PipelineAggregationHelperTests extends ESTestCase { public static ArrayList < MockBucket > generateHistogram ( int interval , int size , double gapProbability , double runProbability ) { ArrayList < MockBucket > values = new ArrayList < > ( size ) ; boolean lastWasGap = false ; boolean emptyHisto = true ; for ( int i = <int> ; i < size ; i + + ) { MockBucket bucket = new MockBucket ( ) ; if ( randomDouble ( ) < gapProbability ) { bucket . count = <int> ; bucket . docValues = new double [ <int> ] ; lastWasGap = true ; } else if ( lastWasGap & & randomDouble ( ) < runProbability ) { bucket . count = <int> ; bucket . docValues = new double [ <int> ] ; lastWasGap = true ; } else { bucket . count = randomIntBetween ( <int> , <int> ) ; bucket . docValues = new double [ bucket . count ] ; for ( int j = <int> ; j < bucket . count ; j + + ) { bucket . docValues [ j ] = randomDouble ( ) * randomIntBetween ( - <int> , <int> ) ; } lastWasGap = false ; emptyHisto = false ; } bucket . key = i * interval ; values . add ( bucket ) ; } if ( emptyHisto ) { int idx = randomIntBetween ( <int> , values . size ( ) - <int> ) ; MockBucket bucket = values . get ( idx ) ; bucket . count = randomIntBetween ( <int> , <int> ) ; bucket . docValues = new double [ bucket . count ] ; for ( int j = <int> ; j < bucket . count ; j + + ) { bucket . docValues [ j ] = randomDouble ( ) * randomIntBetween ( - <int> , <int> ) ; } values . set ( idx , bucket ) ; } return values ; } public static class MockBucket { public int count ; public double [ ] docValues ; public long key ; } public static double calculateMetric ( double [ ] values , ValuesSourceMetricsAggregationBuilder metric ) { if ( metric instanceof MinBuilder ) { double accumulator = Double . POSITIVE_INFINITY ; for ( double value : values ) { accumulator = Math . min ( accumulator , value ) ; } return accumulator ; } else if ( metric instanceof MaxBuilder ) { double accumulator = Double . NEGATIVE_INFINITY ; for ( double value : values ) { accumulator = Math . max ( accumulator , value ) ; } return accumulator ; } else if ( metric instanceof SumBuilder ) { double accumulator = <int> ; for ( double value : values ) { accumulator + = value ; } return accumulator ; } else if ( metric instanceof AvgBuilder ) { double accumulator = <int> ; for ( double value : values ) { accumulator + = value ; } return accumulator / values . length ; } return <float> ; } } 
