package org . apache . cassandra . tools ; import java . io . IOException ; import java . io . PrintStream ; import java . lang . management . ManagementFactory ; import java . lang . management . MemoryMXBean ; import java . lang . management . MemoryUsage ; import java . lang . management . RuntimeMXBean ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . rmi . server . RMIClientSocketFactory ; import java . rmi . server . RMISocketFactory ; import java . util . AbstractMap ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import javax . management . JMX ; import javax . management . MBeanServerConnection ; import javax . management . MalformedObjectNameException ; import javax . management . ObjectName ; import javax . management . openmbean . CompositeData ; import javax . management . openmbean . OpenDataException ; import javax . management . openmbean . TabularData ; import javax . management . remote . JMXConnector ; import javax . management . remote . JMXConnectorFactory ; import javax . management . remote . JMXServiceURL ; import javax . rmi . ssl . SslRMIClientSocketFactory ; import org . apache . cassandra . batchlog . BatchlogManager ; import org . apache . cassandra . batchlog . BatchlogManagerMBean ; import org . apache . cassandra . db . ColumnFamilyStoreMBean ; import org . apache . cassandra . db . HintedHandOffManagerMBean ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . compaction . CompactionManagerMBean ; import org . apache . cassandra . gms . FailureDetector ; import org . apache . cassandra . gms . FailureDetectorMBean ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . gms . GossiperMBean ; import org . apache . cassandra . db . HintedHandOffManager ; import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; import org . apache . cassandra . metrics . CassandraMetricsRegistry ; import org . apache . cassandra . metrics . TableMetrics . Sampler ; import org . apache . cassandra . metrics . StorageMetrics ; import org . apache . cassandra . metrics . TableMetrics ; import org . apache . cassandra . metrics . ThreadPoolMetrics ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . net . MessagingServiceMBean ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . service . CacheServiceMBean ; import org . apache . cassandra . service . GCInspector ; import org . apache . cassandra . service . GCInspectorMXBean ; import org . apache . cassandra . service . StorageProxy ; import org . apache . cassandra . service . StorageProxyMBean ; import org . apache . cassandra . service . StorageServiceMBean ; import org . apache . cassandra . streaming . StreamManagerMBean ; import org . apache . cassandra . streaming . StreamState ; import org . apache . cassandra . streaming . management . StreamStateCompositeData ; import com . google . common . base . Function ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import com . google . common . collect . Sets ; import com . google . common . util . concurrent . Uninterruptibles ; public class NodeProbe implements AutoCloseable { private static final String fmtUrl = <str> ; private static final String ssObjName = <str> ; private static final int defaultPort = <int> ; final String host ; final int port ; private String username ; private String password ; private JMXConnector jmxc ; private MBeanServerConnection mbeanServerConn ; private CompactionManagerMBean compactionProxy ; private StorageServiceMBean ssProxy ; private GossiperMBean gossProxy ; private MemoryMXBean memProxy ; private GCInspectorMXBean gcProxy ; private RuntimeMXBean runtimeProxy ; private StreamManagerMBean streamProxy ; public MessagingServiceMBean msProxy ; private FailureDetectorMBean fdProxy ; private CacheServiceMBean cacheService ; private StorageProxyMBean spProxy ; private HintedHandOffManagerMBean hhProxy ; private BatchlogManagerMBean bmProxy ; private boolean failed ; public NodeProbe ( String host , int port , String username , String password ) throws IOException { assert username ! = null & & ! username . isEmpty ( ) & & password ! = null & & ! password . isEmpty ( ) : <str> ; this . host = host ; this . port = port ; this . username = username ; this . password = password ; connect ( ) ; } public NodeProbe ( String host , int port ) throws IOException { this . host = host ; this . port = port ; connect ( ) ; } public NodeProbe ( String host ) throws IOException { this . host = host ; this . port = defaultPort ; connect ( ) ; } private void connect ( ) throws IOException { JMXServiceURL jmxUrl = new JMXServiceURL ( String . format ( fmtUrl , host , port ) ) ; Map < String , Object > env = new HashMap < String , Object > ( ) ; if ( username ! = null ) { String [ ] creds = { username , password } ; env . put ( JMXConnector . CREDENTIALS , creds ) ; } env . put ( <str> , getRMIClientSocketFactory ( ) ) ; jmxc = JMXConnectorFactory . connect ( jmxUrl , env ) ; mbeanServerConn = jmxc . getMBeanServerConnection ( ) ; try { ObjectName name = new ObjectName ( ssObjName ) ; ssProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageServiceMBean . class ) ; name = new ObjectName ( MessagingService . MBEAN_NAME ) ; msProxy = JMX . newMBeanProxy ( mbeanServerConn , name , MessagingServiceMBean . class ) ; name = new ObjectName ( StreamManagerMBean . OBJECT_NAME ) ; streamProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StreamManagerMBean . class ) ; name = new ObjectName ( CompactionManager . MBEAN_OBJECT_NAME ) ; compactionProxy = JMX . newMBeanProxy ( mbeanServerConn , name , CompactionManagerMBean . class ) ; name = new ObjectName ( FailureDetector . MBEAN_NAME ) ; fdProxy = JMX . newMBeanProxy ( mbeanServerConn , name , FailureDetectorMBean . class ) ; name = new ObjectName ( CacheService . MBEAN_NAME ) ; cacheService = JMX . newMBeanProxy ( mbeanServerConn , name , CacheServiceMBean . class ) ; name = new ObjectName ( StorageProxy . MBEAN_NAME ) ; spProxy = JMX . newMBeanProxy ( mbeanServerConn , name , StorageProxyMBean . class ) ; name = new ObjectName ( HintedHandOffManager . MBEAN_NAME ) ; hhProxy = JMX . newMBeanProxy ( mbeanServerConn , name , HintedHandOffManagerMBean . class ) ; name = new ObjectName ( GCInspector . MBEAN_NAME ) ; gcProxy = JMX . newMBeanProxy ( mbeanServerConn , name , GCInspectorMXBean . class ) ; name = new ObjectName ( Gossiper . MBEAN_NAME ) ; gossProxy = JMX . newMBeanProxy ( mbeanServerConn , name , GossiperMBean . class ) ; name = new ObjectName ( BatchlogManager . MBEAN_NAME ) ; bmProxy = JMX . newMBeanProxy ( mbeanServerConn , name , BatchlogManagerMBean . class ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( <str> , e ) ; } memProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , ManagementFactory . MEMORY_MXBEAN_NAME , MemoryMXBean . class ) ; runtimeProxy = ManagementFactory . newPlatformMXBeanProxy ( mbeanServerConn , ManagementFactory . RUNTIME_MXBEAN_NAME , RuntimeMXBean . class ) ; } private RMIClientSocketFactory getRMIClientSocketFactory ( ) throws IOException { if ( Boolean . parseBoolean ( System . getProperty ( <str> ) ) ) return new SslRMIClientSocketFactory ( ) ; else return RMISocketFactory . getDefaultSocketFactory ( ) ; } public void close ( ) throws IOException { jmxc . close ( ) ; } public int forceKeyspaceCleanup ( String keyspaceName , String . . . tables ) throws IOException , ExecutionException , InterruptedException { return ssProxy . forceKeyspaceCleanup ( keyspaceName , tables ) ; } public int scrub ( boolean disableSnapshot , boolean skipCorrupted , boolean checkData , String keyspaceName , String . . . tables ) throws IOException , ExecutionException , InterruptedException { return ssProxy . scrub ( disableSnapshot , skipCorrupted , checkData , keyspaceName , tables ) ; } public int verify ( boolean extendedVerify , String keyspaceName , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { return ssProxy . verify ( extendedVerify , keyspaceName , tableNames ) ; } public int upgradeSSTables ( String keyspaceName , boolean excludeCurrentVersion , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { return ssProxy . upgradeSSTables ( keyspaceName , excludeCurrentVersion , tableNames ) ; } public void forceKeyspaceCleanup ( PrintStream out , String keyspaceName , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { if ( forceKeyspaceCleanup ( keyspaceName , tableNames ) ! = <int> ) { failed = true ; out . println ( <str> + keyspaceName + <str> ) ; } } public void scrub ( PrintStream out , boolean disableSnapshot , boolean skipCorrupted , boolean checkData , String keyspaceName , String . . . tables ) throws IOException , ExecutionException , InterruptedException { if ( scrub ( disableSnapshot , skipCorrupted , checkData , keyspaceName , tables ) ! = <int> ) { failed = true ; out . println ( <str> + keyspaceName + <str> ) ; } } public void verify ( PrintStream out , boolean extendedVerify , String keyspaceName , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { if ( verify ( extendedVerify , keyspaceName , tableNames ) ! = <int> ) { failed = true ; out . println ( <str> + keyspaceName + <str> ) ; } } public void upgradeSSTables ( PrintStream out , String keyspaceName , boolean excludeCurrentVersion , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { if ( upgradeSSTables ( keyspaceName , excludeCurrentVersion , tableNames ) ! = <int> ) { failed = true ; out . println ( <str> + keyspaceName + <str> ) ; } } public void forceKeyspaceCompaction ( boolean splitOutput , String keyspaceName , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { ssProxy . forceKeyspaceCompaction ( splitOutput , keyspaceName , tableNames ) ; } public void forceKeyspaceFlush ( String keyspaceName , String . . . tableNames ) throws IOException , ExecutionException , InterruptedException { ssProxy . forceKeyspaceFlush ( keyspaceName , tableNames ) ; } public void repairAsync ( final PrintStream out , final String keyspace , Map < String , String > options ) throws IOException { RepairRunner runner = new RepairRunner ( out , ssProxy , keyspace , options ) ; try { jmxc . addConnectionNotificationListener ( runner , null , null ) ; ssProxy . addNotificationListener ( runner , null , null ) ; runner . run ( ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } finally { try { ssProxy . removeNotificationListener ( runner ) ; jmxc . removeConnectionNotificationListener ( runner ) ; } catch ( Throwable e ) { out . println ( <str> + e ) ; } } } public Map < Sampler , CompositeData > getPartitionSample ( String ks , String cf , int capacity , int duration , int count , List < Sampler > samplers ) throws OpenDataException { ColumnFamilyStoreMBean cfsProxy = getCfsProxy ( ks , cf ) ; for ( Sampler sampler : samplers ) { cfsProxy . beginLocalSampling ( sampler . name ( ) , capacity ) ; } Uninterruptibles . sleepUninterruptibly ( duration , TimeUnit . MILLISECONDS ) ; Map < Sampler , CompositeData > result = Maps . newHashMap ( ) ; for ( Sampler sampler : samplers ) { result . put ( sampler , cfsProxy . finishLocalSampling ( sampler . name ( ) , count ) ) ; } return result ; } public void invalidateCounterCache ( ) { cacheService . invalidateCounterCache ( ) ; } public void invalidateKeyCache ( ) { cacheService . invalidateKeyCache ( ) ; } public void invalidateRowCache ( ) { cacheService . invalidateRowCache ( ) ; } public void drain ( ) throws IOException , InterruptedException , ExecutionException { ssProxy . drain ( ) ; } public Map < String , String > getTokenToEndpointMap ( ) { return ssProxy . getTokenToEndpointMap ( ) ; } public List < String > getLiveNodes ( ) { return ssProxy . getLiveNodes ( ) ; } public List < String > getJoiningNodes ( ) { return ssProxy . getJoiningNodes ( ) ; } public List < String > getLeavingNodes ( ) { return ssProxy . getLeavingNodes ( ) ; } public List < String > getMovingNodes ( ) { return ssProxy . getMovingNodes ( ) ; } public List < String > getUnreachableNodes ( ) { return ssProxy . getUnreachableNodes ( ) ; } public Map < String , String > getLoadMap ( ) { return ssProxy . getLoadMap ( ) ; } public Map < InetAddress , Float > getOwnership ( ) { return ssProxy . getOwnership ( ) ; } public Map < InetAddress , Float > effectiveOwnership ( String keyspace ) throws IllegalStateException { return ssProxy . effectiveOwnership ( keyspace ) ; } public CacheServiceMBean getCacheServiceMBean ( ) { String cachePath = <str> ; try { return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( cachePath ) , CacheServiceMBean . class ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public double [ ] getAndResetGCStats ( ) { return gcProxy . getAndResetStats ( ) ; } public Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > getColumnFamilyStoreMBeanProxies ( ) { try { return new ColumnFamilyStoreMBeanIterator ( mbeanServerConn ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( <str> , e ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } public CompactionManagerMBean getCompactionManagerProxy ( ) { return compactionProxy ; } public List < String > getTokens ( ) { return ssProxy . getTokens ( ) ; } public List < String > getTokens ( String endpoint ) { try { return ssProxy . getTokens ( endpoint ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } public String getLocalHostId ( ) { return ssProxy . getLocalHostId ( ) ; } public Map < String , String > getHostIdMap ( ) { return ssProxy . getEndpointToHostId ( ) ; } public String getLoadString ( ) { return ssProxy . getLoadString ( ) ; } public String getReleaseVersion ( ) { return ssProxy . getReleaseVersion ( ) ; } public int getCurrentGenerationNumber ( ) { return ssProxy . getCurrentGenerationNumber ( ) ; } public long getUptime ( ) { return runtimeProxy . getUptime ( ) ; } public MemoryUsage getHeapMemoryUsage ( ) { return memProxy . getHeapMemoryUsage ( ) ; } public void takeSnapshot ( String snapshotName , String table , String . . . keyspaces ) throws IOException { if ( table ! = null ) { if ( keyspaces . length ! = <int> ) { throw new IOException ( <str> ) ; } ssProxy . takeTableSnapshot ( keyspaces [ <int> ] , table , snapshotName ) ; } else ssProxy . takeSnapshot ( snapshotName , keyspaces ) ; } public void takeMultipleTableSnapshot ( String snapshotName , String . . . tableList ) throws IOException { if ( null ! = tableList & & tableList . length ! = <int> ) { ssProxy . takeMultipleTableSnapshot ( snapshotName , tableList ) ; } else { throw new IOException ( <str> ) ; } } public void clearSnapshot ( String tag , String . . . keyspaces ) throws IOException { ssProxy . clearSnapshot ( tag , keyspaces ) ; } public Map < String , TabularData > getSnapshotDetails ( ) { return ssProxy . getSnapshotDetails ( ) ; } public long trueSnapshotsSize ( ) { return ssProxy . trueSnapshotsSize ( ) ; } public boolean isJoined ( ) { return ssProxy . isJoined ( ) ; } public void joinRing ( ) throws IOException { ssProxy . joinRing ( ) ; } public void decommission ( ) throws InterruptedException { ssProxy . decommission ( ) ; } public void move ( String newToken ) throws IOException { ssProxy . move ( newToken ) ; } public void removeNode ( String token ) { ssProxy . removeNode ( token ) ; } public String getRemovalStatus ( ) { return ssProxy . getRemovalStatus ( ) ; } public void forceRemoveCompletion ( ) { ssProxy . forceRemoveCompletion ( ) ; } public void assassinateEndpoint ( String address ) throws UnknownHostException { gossProxy . assassinateEndpoint ( address ) ; } public void setCompactionThreshold ( String ks , String cf , int minimumCompactionThreshold , int maximumCompactionThreshold ) { ColumnFamilyStoreMBean cfsProxy = getCfsProxy ( ks , cf ) ; cfsProxy . setCompactionThresholds ( minimumCompactionThreshold , maximumCompactionThreshold ) ; } public void disableAutoCompaction ( String ks , String . . . tables ) throws IOException { ssProxy . disableAutoCompaction ( ks , tables ) ; } public void enableAutoCompaction ( String ks , String . . . tableNames ) throws IOException { ssProxy . enableAutoCompaction ( ks , tableNames ) ; } public void setIncrementalBackupsEnabled ( boolean enabled ) { ssProxy . setIncrementalBackupsEnabled ( enabled ) ; } public boolean isIncrementalBackupsEnabled ( ) { return ssProxy . isIncrementalBackupsEnabled ( ) ; } public void setCacheCapacities ( int keyCacheCapacity , int rowCacheCapacity , int counterCacheCapacity ) { try { String keyCachePath = <str> ; CacheServiceMBean cacheMBean = JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( keyCachePath ) , CacheServiceMBean . class ) ; cacheMBean . setKeyCacheCapacityInMB ( keyCacheCapacity ) ; cacheMBean . setRowCacheCapacityInMB ( rowCacheCapacity ) ; cacheMBean . setCounterCacheCapacityInMB ( counterCacheCapacity ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public void setCacheKeysToSave ( int keyCacheKeysToSave , int rowCacheKeysToSave , int counterCacheKeysToSave ) { try { String keyCachePath = <str> ; CacheServiceMBean cacheMBean = JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( keyCachePath ) , CacheServiceMBean . class ) ; cacheMBean . setKeyCacheKeysToSave ( keyCacheKeysToSave ) ; cacheMBean . setRowCacheKeysToSave ( rowCacheKeysToSave ) ; cacheMBean . setCounterCacheKeysToSave ( counterCacheKeysToSave ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public void setHintedHandoffThrottleInKB ( int throttleInKB ) { ssProxy . setHintedHandoffThrottleInKB ( throttleInKB ) ; } public List < InetAddress > getEndpoints ( String keyspace , String cf , String key ) { return ssProxy . getNaturalEndpoints ( keyspace , cf , key ) ; } public List < String > getSSTables ( String keyspace , String cf , String key ) { ColumnFamilyStoreMBean cfsProxy = getCfsProxy ( keyspace , cf ) ; return cfsProxy . getSSTablesForKey ( key ) ; } public Set < StreamState > getStreamStatus ( ) { return Sets . newHashSet ( Iterables . transform ( streamProxy . getCurrentStreams ( ) , new Function < CompositeData , StreamState > ( ) { public StreamState apply ( CompositeData input ) { return StreamStateCompositeData . fromCompositeData ( input ) ; } } ) ) ; } public String getOperationMode ( ) { return ssProxy . getOperationMode ( ) ; } public boolean isStarting ( ) { return ssProxy . isStarting ( ) ; } public void truncate ( String keyspaceName , String tableName ) { try { ssProxy . truncate ( keyspaceName , tableName ) ; } catch ( TimeoutException e ) { throw new RuntimeException ( <str> , e ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } public EndpointSnitchInfoMBean getEndpointSnitchInfoProxy ( ) { try { return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> ) , EndpointSnitchInfoMBean . class ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public ColumnFamilyStoreMBean getCfsProxy ( String ks , String cf ) { ColumnFamilyStoreMBean cfsProxy = null ; try { String type = cf . contains ( <str> ) ? <str> : <str> ; Set < ObjectName > beans = mbeanServerConn . queryNames ( new ObjectName ( <str> + type + <str> + ks + <str> + cf ) , null ) ; if ( beans . isEmpty ( ) ) throw new MalformedObjectNameException ( <str> ) ; assert beans . size ( ) = = <int> ; for ( ObjectName bean : beans ) cfsProxy = JMX . newMBeanProxy ( mbeanServerConn , bean , ColumnFamilyStoreMBean . class ) ; } catch ( MalformedObjectNameException mone ) { System . err . println ( <str> + ks + <str> + cf + <str> ) ; System . exit ( <int> ) ; } catch ( IOException e ) { System . err . println ( <str> + ks + <str> + cf + <str> + e ) ; System . exit ( <int> ) ; } return cfsProxy ; } public StorageProxyMBean getSpProxy ( ) { return spProxy ; } public String getEndpoint ( ) { Map < String , String > hostIdToEndpoint = ssProxy . getHostIdToEndpoint ( ) ; return hostIdToEndpoint . get ( ssProxy . getLocalHostId ( ) ) ; } public String getDataCenter ( ) { try { return getEndpointSnitchInfoProxy ( ) . getDatacenter ( getEndpoint ( ) ) ; } catch ( UnknownHostException e ) { return <str> ; } } public String getRack ( ) { try { return getEndpointSnitchInfoProxy ( ) . getRack ( getEndpoint ( ) ) ; } catch ( UnknownHostException e ) { return <str> ; } } public List < String > getKeyspaces ( ) { return ssProxy . getKeyspaces ( ) ; } public List < String > getNonSystemKeyspaces ( ) { return ssProxy . getNonSystemKeyspaces ( ) ; } public String getClusterName ( ) { return ssProxy . getClusterName ( ) ; } public String getPartitioner ( ) { return ssProxy . getPartitionerName ( ) ; } public void disableHintedHandoff ( ) { spProxy . setHintedHandoffEnabled ( false ) ; } public void enableHintedHandoff ( ) { spProxy . setHintedHandoffEnabled ( true ) ; } public boolean isHandoffEnabled ( ) { return spProxy . getHintedHandoffEnabled ( ) ; } public void enableHintsForDC ( String dc ) { spProxy . enableHintsForDC ( dc ) ; } public void disableHintsForDC ( String dc ) { spProxy . disableHintsForDC ( dc ) ; } public Set < String > getHintedHandoffDisabledDCs ( ) { return spProxy . getHintedHandoffDisabledDCs ( ) ; } public void pauseHintsDelivery ( ) { hhProxy . pauseHintsDelivery ( true ) ; } public void resumeHintsDelivery ( ) { hhProxy . pauseHintsDelivery ( false ) ; } public void truncateHints ( final String host ) { hhProxy . deleteHintsForEndpoint ( host ) ; } public void truncateHints ( ) { try { hhProxy . truncateAllHints ( ) ; } catch ( ExecutionException | InterruptedException e ) { throw new RuntimeException ( <str> , e ) ; } } public void refreshSizeEstimates ( ) { try { ssProxy . refreshSizeEstimates ( ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( <str> , e ) ; } } public void stopNativeTransport ( ) { ssProxy . stopNativeTransport ( ) ; } public void startNativeTransport ( ) { ssProxy . startNativeTransport ( ) ; } public boolean isNativeTransportRunning ( ) { return ssProxy . isNativeTransportRunning ( ) ; } public void stopGossiping ( ) { ssProxy . stopGossiping ( ) ; } public void startGossiping ( ) { ssProxy . startGossiping ( ) ; } public boolean isGossipRunning ( ) { return ssProxy . isGossipRunning ( ) ; } public void stopThriftServer ( ) { ssProxy . stopRPCServer ( ) ; } public void startThriftServer ( ) { ssProxy . startRPCServer ( ) ; } public boolean isThriftServerRunning ( ) { return ssProxy . isRPCServerRunning ( ) ; } public void stopCassandraDaemon ( ) { ssProxy . stopDaemon ( ) ; } public boolean isInitialized ( ) { return ssProxy . isInitialized ( ) ; } public void setCompactionThroughput ( int value ) { ssProxy . setCompactionThroughputMbPerSec ( value ) ; } public int getCompactionThroughput ( ) { return ssProxy . getCompactionThroughputMbPerSec ( ) ; } public int getStreamThroughput ( ) { return ssProxy . getStreamThroughputMbPerSec ( ) ; } public double getTraceProbability ( ) { return ssProxy . getTraceProbability ( ) ; } public int getExceptionCount ( ) { return ( int ) StorageMetrics . exceptions . getCount ( ) ; } public Map < String , Integer > getDroppedMessages ( ) { return msProxy . getDroppedMessages ( ) ; } public void loadNewSSTables ( String ksName , String cfName ) { ssProxy . loadNewSSTables ( ksName , cfName ) ; } public void rebuildIndex ( String ksName , String cfName , String . . . idxNames ) { ssProxy . rebuildSecondaryIndex ( ksName , cfName , idxNames ) ; } public String getGossipInfo ( ) { return fdProxy . getAllEndpointStates ( ) ; } public void stop ( String string ) { compactionProxy . stopCompaction ( string ) ; } public void stopById ( String compactionId ) { compactionProxy . stopCompactionById ( compactionId ) ; } public void setStreamThroughput ( int value ) { ssProxy . setStreamThroughputMbPerSec ( value ) ; } public void setTraceProbability ( double value ) { ssProxy . setTraceProbability ( value ) ; } public String getSchemaVersion ( ) { return ssProxy . getSchemaVersion ( ) ; } public List < String > describeRing ( String keyspaceName ) throws IOException { return ssProxy . describeRingJMX ( keyspaceName ) ; } public void rebuild ( String sourceDc ) { ssProxy . rebuild ( sourceDc ) ; } public List < String > sampleKeyRange ( ) { return ssProxy . sampleKeyRange ( ) ; } public void resetLocalSchema ( ) throws IOException { ssProxy . resetLocalSchema ( ) ; } public boolean isFailed ( ) { return failed ; } public long getReadRepairAttempted ( ) { return spProxy . getReadRepairAttempted ( ) ; } public long getReadRepairRepairedBlocking ( ) { return spProxy . getReadRepairRepairedBlocking ( ) ; } public long getReadRepairRepairedBackground ( ) { return spProxy . getReadRepairRepairedBackground ( ) ; } public Object getCacheMetric ( String cacheType , String metricName ) { try { switch ( metricName ) { case <str> : case <str> : case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + cacheType + <str> + metricName ) , CassandraMetricsRegistry . JmxGaugeMBean . class ) . getValue ( ) ; case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + cacheType + <str> + metricName ) , CassandraMetricsRegistry . JmxMeterMBean . class ) . getCount ( ) ; default : throw new RuntimeException ( <str> ) ; } } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public Object getThreadPoolMetric ( String pathName , String poolName , String metricName ) { return ThreadPoolMetrics . getJmxMetric ( mbeanServerConn , pathName , poolName , metricName ) ; } public Multimap < String , String > getThreadPools ( ) { return ThreadPoolMetrics . getJmxThreadPools ( mbeanServerConn ) ; } public Object getColumnFamilyMetric ( String ks , String cf , String metricName ) { try { String type = cf . contains ( <str> ) ? <str> : <str> ; ObjectName oName = new ObjectName ( String . format ( <str> , type , ks , cf , metricName ) ) ; switch ( metricName ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , oName , CassandraMetricsRegistry . JmxGaugeMBean . class ) . getValue ( ) ; case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , oName , CassandraMetricsRegistry . JmxCounterMBean . class ) . getCount ( ) ; case <str> : case <str> : case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , oName , CassandraMetricsRegistry . JmxTimerMBean . class ) ; case <str> : case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , oName , CassandraMetricsRegistry . JmxHistogramMBean . class ) ; default : throw new RuntimeException ( <str> + metricName ) ; } } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public CassandraMetricsRegistry . JmxTimerMBean getProxyMetric ( String scope ) { try { return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + scope + <str> ) , CassandraMetricsRegistry . JmxTimerMBean . class ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public Object getCompactionMetric ( String metricName ) { try { switch ( metricName ) { case <str> : return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + metricName ) , CassandraMetricsRegistry . JmxCounterMBean . class ) ; case <str> : case <str> : return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + metricName ) , CassandraMetricsRegistry . JmxGaugeMBean . class ) . getValue ( ) ; case <str> : return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + metricName ) , CassandraMetricsRegistry . JmxMeterMBean . class ) ; default : throw new RuntimeException ( <str> ) ; } } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public long getStorageMetric ( String metricName ) { try { return JMX . newMBeanProxy ( mbeanServerConn , new ObjectName ( <str> + metricName ) , CassandraMetricsRegistry . JmxCounterMBean . class ) . getCount ( ) ; } catch ( MalformedObjectNameException e ) { throw new RuntimeException ( e ) ; } } public double [ ] metricPercentilesAsArray ( CassandraMetricsRegistry . JmxHistogramMBean metric ) { return new double [ ] { metric . get50thPercentile ( ) , metric . get75thPercentile ( ) , metric . get95thPercentile ( ) , metric . get98thPercentile ( ) , metric . get99thPercentile ( ) , metric . getMin ( ) , metric . getMax ( ) } ; } public double [ ] metricPercentilesAsArray ( CassandraMetricsRegistry . JmxTimerMBean metric ) { return new double [ ] { metric . get50thPercentile ( ) , metric . get75thPercentile ( ) , metric . get95thPercentile ( ) , metric . get98thPercentile ( ) , metric . get99thPercentile ( ) , metric . getMin ( ) , metric . getMax ( ) } ; } public TabularData getCompactionHistory ( ) { return compactionProxy . getCompactionHistory ( ) ; } public void reloadTriggers ( ) { spProxy . reloadTriggerClasses ( ) ; } public void setLoggingLevel ( String classQualifier , String level ) { try { ssProxy . setLoggingLevel ( classQualifier , level ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> + classQualifier + <str> + level + <str> , e ) ; } } public Map < String , String > getLoggingLevels ( ) { return ssProxy . getLoggingLevels ( ) ; } public void resumeBootstrap ( PrintStream out ) throws IOException { BootstrapMonitor monitor = new BootstrapMonitor ( out ) ; try { jmxc . addConnectionNotificationListener ( monitor , null , null ) ; ssProxy . addNotificationListener ( monitor , null , null ) ; if ( ssProxy . resumeBootstrap ( ) ) { out . println ( <str> ) ; monitor . awaitCompletion ( ) ; } else { out . println ( <str> ) ; } } catch ( Exception e ) { throw new IOException ( e ) ; } finally { try { ssProxy . removeNotificationListener ( monitor ) ; jmxc . removeConnectionNotificationListener ( monitor ) ; } catch ( Throwable e ) { out . println ( <str> + e ) ; } } } public void replayBatchlog ( ) throws IOException { try { bmProxy . forceBatchlogReplay ( ) ; } catch ( Exception e ) { throw new IOException ( e ) ; } } public TabularData getFailureDetectorPhilValues ( ) { try { return fdProxy . getPhiValues ( ) ; } catch ( OpenDataException e ) { throw new RuntimeException ( e ) ; } } } class ColumnFamilyStoreMBeanIterator implements Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > { private MBeanServerConnection mbeanServerConn ; Iterator < Entry < String , ColumnFamilyStoreMBean > > mbeans ; public ColumnFamilyStoreMBeanIterator ( MBeanServerConnection mbeanServerConn ) throws MalformedObjectNameException , NullPointerException , IOException { this . mbeanServerConn = mbeanServerConn ; List < Entry < String , ColumnFamilyStoreMBean > > cfMbeans = getCFSMBeans ( mbeanServerConn , <str> ) ; cfMbeans . addAll ( getCFSMBeans ( mbeanServerConn , <str> ) ) ; Collections . sort ( cfMbeans , new Comparator < Entry < String , ColumnFamilyStoreMBean > > ( ) { public int compare ( Entry < String , ColumnFamilyStoreMBean > e1 , Entry < String , ColumnFamilyStoreMBean > e2 ) { int keyspaceNameCmp = e1 . getKey ( ) . compareTo ( e2 . getKey ( ) ) ; if ( keyspaceNameCmp ! = <int> ) return keyspaceNameCmp ; String e1CF [ ] = e1 . getValue ( ) . getColumnFamilyName ( ) . split ( <str> ) ; String e2CF [ ] = e2 . getValue ( ) . getColumnFamilyName ( ) . split ( <str> ) ; assert e1CF . length < = <int> & & e2CF . length < = <int> : <str> ; if ( e1CF . length = = <int> & & e2CF . length = = <int> ) return e1CF [ <int> ] . compareTo ( e2CF [ <int> ] ) ; int cfNameCmp = e1CF [ <int> ] . compareTo ( e2CF [ <int> ] ) ; if ( cfNameCmp ! = <int> ) return cfNameCmp ; if ( e1CF . length = = <int> & & e2CF . length = = <int> ) return e1CF [ <int> ] . compareTo ( e2CF [ <int> ] ) ; return e1CF . length = = <int> ? <int> : - <int> ; } } ) ; mbeans = cfMbeans . iterator ( ) ; } private List < Entry < String , ColumnFamilyStoreMBean > > getCFSMBeans ( MBeanServerConnection mbeanServerConn , String type ) throws MalformedObjectNameException , IOException { ObjectName query = new ObjectName ( <str> + type + <str> ) ; Set < ObjectName > cfObjects = mbeanServerConn . queryNames ( query , null ) ; List < Entry < String , ColumnFamilyStoreMBean > > mbeans = new ArrayList < Entry < String , ColumnFamilyStoreMBean > > ( cfObjects . size ( ) ) ; for ( ObjectName n : cfObjects ) { String keyspaceName = n . getKeyProperty ( <str> ) ; ColumnFamilyStoreMBean cfsProxy = JMX . newMBeanProxy ( mbeanServerConn , n , ColumnFamilyStoreMBean . class ) ; mbeans . add ( new AbstractMap . SimpleImmutableEntry < String , ColumnFamilyStoreMBean > ( keyspaceName , cfsProxy ) ) ; } return mbeans ; } public boolean hasNext ( ) { return mbeans . hasNext ( ) ; } public Entry < String , ColumnFamilyStoreMBean > next ( ) { return mbeans . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } 
