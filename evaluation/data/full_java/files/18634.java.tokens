package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObjectArray ; import com . badlogic . gdx . physics . bullet . dynamics . InternalTickCallback ; import com . badlogic . gdx . physics . bullet . dynamics . btDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; public class InternalTickTest extends BaseBulletTest { static class TestInternalTickCallback extends InternalTickCallback { public TestInternalTickCallback ( btDynamicsWorld dynamicsWorld ) { super ( dynamicsWorld , true ) ; } @Override public void onInternalTick ( btDynamicsWorld dynamicsWorld , float timeStep ) { btCollisionObjectArray objs = dynamicsWorld . getCollisionObjectArray ( ) ; dynamicsWorld . clearForces ( ) ; int idx = <int> ; for ( int i = <int> ; i < objs . size ( ) ; i + + ) { btRigidBody body = ( btRigidBody ) ( objs . at ( i ) ) ; if ( body = = null | | body . isStaticOrKinematicObject ( ) ) continue ; body . applyGravity ( ) ; body . applyCentralForce ( tmpV1 . set ( <float> , <float> + ( float ) ( <float> * Math . random ( ) ) , <float> ) ) ; idx + + ; } } } final int BOXCOUNT_X = <int> ; final int BOXCOUNT_Y = <int> ; final int BOXCOUNT_Z = <int> ; final float BOXOFFSET_X = - <float> ; final float BOXOFFSET_Y = <float> ; final float BOXOFFSET_Z = <float> ; TestInternalTickCallback internalTickCallback ; @Override public void create ( ) { super . create ( ) ; internalTickCallback = new TestInternalTickCallback ( ( btDynamicsWorld ) world . collisionWorld ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; for ( int x = <int> ; x < BOXCOUNT_X ; x + + ) { for ( int y = <int> ; y < BOXCOUNT_Y ; y + + ) { for ( int z = <int> ; z < BOXCOUNT_Z ; z + + ) { world . add ( <str> , BOXOFFSET_X + x , BOXOFFSET_Y + y , BOXOFFSET_Z + z ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; } } } } @Override public void dispose ( ) { super . dispose ( ) ; if ( internalTickCallback ! = null ) internalTickCallback . dispose ( ) ; internalTickCallback = null ; } float toggleTime = <float> ; boolean toggleAttach = false ; @Override public void render ( ) { super . render ( ) ; if ( internalTickCallback = = null ) return ; if ( ( toggleTime + = Gdx . graphics . getDeltaTime ( ) ) > <float> ) { toggleTime - = <float> ; if ( toggleAttach ) internalTickCallback . detach ( ) ; else internalTickCallback . attach ( ) ; toggleAttach = ! toggleAttach ; } } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } } 
