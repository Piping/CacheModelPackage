package org . nd4j . linalg . api . parallel . tasks . cpu . accumulation ; import io . netty . buffer . ByteBuf ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . parallel . tasks . Task ; import java . nio . ByteBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . util . ArrayList ; import java . util . List ; public class CPUAccumulationTask extends BaseCPUAccumulationTask { protected List < Task < Double > > subTasks ; public CPUAccumulationTask ( Accumulation op , int threshold , int n , int offsetX , int offsetY , int incrX , int incrY , boolean outerTask ) { super ( op , threshold , n , offsetX , offsetY , incrX , incrY , outerTask ) ; } public CPUAccumulationTask ( Accumulation op , int threshold , boolean outerTask ) { super ( op , threshold , outerTask ) ; } public CPUAccumulationTask ( Accumulation op , int threshold , int tadIdx , int tadDim , boolean outerTask ) { super ( op , threshold , tadIdx , tadDim , outerTask ) ; } @Override public Double blockUntilComplete ( ) { if ( future = = null ) { invokeAsync ( ) ; } Double accum ; try { accum = future . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( subTasks ! = null ) { accum = op . zeroDouble ( ) ; for ( Task < Double > task : subTasks ) { double subAccum = task . blockUntilComplete ( ) ; accum = op . combineSubResults ( accum , subAccum ) ; } } if ( outerTask & & subTasks ! = null ) { return op . getAndSetFinalResult ( accum ) ; } return accum ; } @Override public Double compute ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; double out ; if ( n > threshold ) { int nFirst = n / <int> ; CPUAccumulationTask first = new CPUAccumulationTask ( op , threshold , nFirst , offsetX , offsetY , incrX , incrY , false ) ; first . fork ( ) ; int nSecond = n - nFirst ; int offsetX2 = offsetX + nFirst * incrX ; int offsetY2 = offsetY + nFirst * incrY ; CPUAccumulationTask second = new CPUAccumulationTask ( op , threshold , nSecond , offsetX2 , offsetY2 , incrX , incrY , false ) ; second . fork ( ) ; out = op . combineSubResults ( first . join ( ) , second . join ( ) ) ; } else { out = execute ( ) ; } if ( outerTask ) { return op . getAndSetFinalResult ( out ) ; } else { return out ; } } @Override public Double call ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; if ( n > threshold ) { int nSubTasks = <int> + n / threshold ; subTasks = new ArrayList < > ( nSubTasks ) ; int taskSize = n / nSubTasks ; int soFar = <int> ; for ( int i = <int> ; i < nSubTasks ; i + + ) { int nInTask ; if ( i = = nSubTasks - <int> ) { nInTask = n - soFar ; } else { nInTask = taskSize ; } int offsetXNew = offsetX + soFar * incrX ; int offsetYNew = offsetY + soFar * incrY ; Task < Double > t = new CPUAccumulationTask ( op , threshold , nInTask , offsetXNew , offsetYNew , incrX , incrY , false ) ; t . invokeAsync ( ) ; subTasks . add ( t ) ; soFar + = nInTask ; } return <float> ; } else { return execute ( ) ; } } private double execute ( ) { DataBuffer x = op . x ( ) . data ( ) ; DataBuffer y = ( op . y ( ) ! = null ? op . y ( ) . data ( ) : null ) ; if ( y ! = null ) { if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; float [ ] yf = ( float [ ] ) y . array ( ) ; float accum = op . zeroFloat ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i ] , yf [ offsetY + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i * incrX ] , yf [ offsetY + i * incrY ] ) ) ; } } return ( double ) accum ; } else { double [ ] xd = ( double [ ] ) x . array ( ) ; double [ ] yd = ( double [ ] ) y . array ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i ] , yd [ offsetY + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i * incrX ] , yd [ offsetY + i * incrY ] ) ) ; } } return accum ; } } else { ByteBuffer nbbx = x . asNio ( ) ; ByteBuffer nbby = y . asNio ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = offsetX ; int byteOffsetY = offsetY ; FloatBuffer floatBufferX = nbbx . asFloatBuffer ( ) ; FloatBuffer floatBufferY = nbby . asFloatBuffer ( ) ; float accum = op . zeroFloat ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < <int> * n ; i + + ) { accum = op . update ( accum , op . op ( floatBufferX . get ( byteOffsetX + i ) , floatBufferY . get ( byteOffsetY + i ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + + ) { accum = op . update ( accum , op . op ( floatBufferX . get ( byteOffsetX + i * incrX ) , floatBufferY . get ( byteOffsetY + i * incrY ) ) ) ; } } return ( double ) accum ; } else { int byteOffsetX = offsetX ; int byteOffsetY = offsetY ; DoubleBuffer doubleBufferX = nbbx . asDoubleBuffer ( ) ; DoubleBuffer doubleBufferY = nbby . asDoubleBuffer ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < <int> * n ; i + + ) { accum = op . update ( accum , op . op ( doubleBufferX . get ( byteOffsetX + i ) , doubleBufferY . get ( byteOffsetY + i ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + + ) { accum = op . update ( accum , op . op ( doubleBufferX . get ( byteOffsetX + i * incrX ) , doubleBufferY . get ( byteOffsetY + i * incrY ) ) ) ; } } return accum ; } } } else { if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; float accum = op . zeroFloat ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i * incrX ] ) ) ; } } return ( double ) accum ; } else { double [ ] xd = ( double [ ] ) x . array ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i * incrX ] ) ) ; } } return accum ; } } else { ByteBuffer nbbx = x . asNio ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = offsetX ; float accum = op . zeroFloat ( ) ; FloatBuffer floatBuffer = nbbx . asFloatBuffer ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( floatBuffer . get ( byteOffsetX + i ) ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( floatBuffer . get ( byteOffsetX + i * incrX ) ) ) ; } } return ( double ) accum ; } else { int byteOffsetX = offsetX ; DoubleBuffer doubleBufferX = nbbx . asDoubleBuffer ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( doubleBufferX . get ( byteOffsetX + i ) ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( doubleBufferX . get ( byteOffsetX + i * incrX ) ) ) ; } } return accum ; } } } } } 
