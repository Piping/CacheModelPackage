package io . netty . handler . timeout ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPromise ; import io . netty . util . concurrent . EventExecutor ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public class IdleStateHandler extends ChannelDuplexHandler { private static final long MIN_TIMEOUT_NANOS = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; private final ChannelFutureListener writeListener = new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { lastWriteTime = System . nanoTime ( ) ; firstWriterIdleEvent = firstAllIdleEvent = true ; } } ; private final long readerIdleTimeNanos ; private final long writerIdleTimeNanos ; private final long allIdleTimeNanos ; volatile ScheduledFuture < ? > readerIdleTimeout ; volatile long lastReadTime ; private boolean firstReaderIdleEvent = true ; volatile ScheduledFuture < ? > writerIdleTimeout ; volatile long lastWriteTime ; private boolean firstWriterIdleEvent = true ; volatile ScheduledFuture < ? > allIdleTimeout ; private boolean firstAllIdleEvent = true ; private volatile int state ; private volatile boolean reading ; public IdleStateHandler ( int readerIdleTimeSeconds , int writerIdleTimeSeconds , int allIdleTimeSeconds ) { this ( readerIdleTimeSeconds , writerIdleTimeSeconds , allIdleTimeSeconds , TimeUnit . SECONDS ) ; } public IdleStateHandler ( long readerIdleTime , long writerIdleTime , long allIdleTime , TimeUnit unit ) { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( readerIdleTime < = <int> ) { readerIdleTimeNanos = <int> ; } else { readerIdleTimeNanos = Math . max ( unit . toNanos ( readerIdleTime ) , MIN_TIMEOUT_NANOS ) ; } if ( writerIdleTime < = <int> ) { writerIdleTimeNanos = <int> ; } else { writerIdleTimeNanos = Math . max ( unit . toNanos ( writerIdleTime ) , MIN_TIMEOUT_NANOS ) ; } if ( allIdleTime < = <int> ) { allIdleTimeNanos = <int> ; } else { allIdleTimeNanos = Math . max ( unit . toNanos ( allIdleTime ) , MIN_TIMEOUT_NANOS ) ; } } public long getReaderIdleTimeInMillis ( ) { return TimeUnit . NANOSECONDS . toMillis ( readerIdleTimeNanos ) ; } public long getWriterIdleTimeInMillis ( ) { return TimeUnit . NANOSECONDS . toMillis ( writerIdleTimeNanos ) ; } public long getAllIdleTimeInMillis ( ) { return TimeUnit . NANOSECONDS . toMillis ( allIdleTimeNanos ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { if ( ctx . channel ( ) . isActive ( ) & & ctx . channel ( ) . isRegistered ( ) ) { initialize ( ctx ) ; } else { } } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { destroy ( ) ; } @Override public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { if ( ctx . channel ( ) . isActive ( ) ) { initialize ( ctx ) ; } super . channelRegistered ( ctx ) ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { initialize ( ctx ) ; super . channelActive ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { destroy ( ) ; super . channelInactive ( ctx ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( readerIdleTimeNanos > <int> | | allIdleTimeNanos > <int> ) { reading = true ; firstReaderIdleEvent = firstAllIdleEvent = true ; } ctx . fireChannelRead ( msg ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { if ( readerIdleTimeNanos > <int> | | allIdleTimeNanos > <int> ) { lastReadTime = System . nanoTime ( ) ; reading = false ; } ctx . fireChannelReadComplete ( ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( writerIdleTimeNanos > <int> | | allIdleTimeNanos > <int> ) { ChannelPromise unvoid = promise . unvoid ( ) ; unvoid . addListener ( writeListener ) ; ctx . write ( msg , unvoid ) ; } else { ctx . write ( msg , promise ) ; } } private void initialize ( ChannelHandlerContext ctx ) { switch ( state ) { case <int> : case <int> : return ; } state = <int> ; EventExecutor loop = ctx . executor ( ) ; lastReadTime = lastWriteTime = System . nanoTime ( ) ; if ( readerIdleTimeNanos > <int> ) { readerIdleTimeout = loop . schedule ( new ReaderIdleTimeoutTask ( ctx ) , readerIdleTimeNanos , TimeUnit . NANOSECONDS ) ; } if ( writerIdleTimeNanos > <int> ) { writerIdleTimeout = loop . schedule ( new WriterIdleTimeoutTask ( ctx ) , writerIdleTimeNanos , TimeUnit . NANOSECONDS ) ; } if ( allIdleTimeNanos > <int> ) { allIdleTimeout = loop . schedule ( new AllIdleTimeoutTask ( ctx ) , allIdleTimeNanos , TimeUnit . NANOSECONDS ) ; } } private void destroy ( ) { state = <int> ; if ( readerIdleTimeout ! = null ) { readerIdleTimeout . cancel ( false ) ; readerIdleTimeout = null ; } if ( writerIdleTimeout ! = null ) { writerIdleTimeout . cancel ( false ) ; writerIdleTimeout = null ; } if ( allIdleTimeout ! = null ) { allIdleTimeout . cancel ( false ) ; allIdleTimeout = null ; } } protected void channelIdle ( ChannelHandlerContext ctx , IdleStateEvent evt ) throws Exception { ctx . fireUserEventTriggered ( evt ) ; } private final class ReaderIdleTimeoutTask implements Runnable { private final ChannelHandlerContext ctx ; ReaderIdleTimeoutTask ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @Override public void run ( ) { if ( ! ctx . channel ( ) . isOpen ( ) ) { return ; } long nextDelay = readerIdleTimeNanos ; if ( ! reading ) { nextDelay - = System . nanoTime ( ) - lastReadTime ; } if ( nextDelay < = <int> ) { readerIdleTimeout = ctx . executor ( ) . schedule ( this , readerIdleTimeNanos , TimeUnit . NANOSECONDS ) ; try { IdleStateEvent event ; if ( firstReaderIdleEvent ) { firstReaderIdleEvent = false ; event = IdleStateEvent . FIRST_READER_IDLE_STATE_EVENT ; } else { event = IdleStateEvent . READER_IDLE_STATE_EVENT ; } channelIdle ( ctx , event ) ; } catch ( Throwable t ) { ctx . fireExceptionCaught ( t ) ; } } else { readerIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . NANOSECONDS ) ; } } } private final class WriterIdleTimeoutTask implements Runnable { private final ChannelHandlerContext ctx ; WriterIdleTimeoutTask ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @Override public void run ( ) { if ( ! ctx . channel ( ) . isOpen ( ) ) { return ; } long lastWriteTime = IdleStateHandler . this . lastWriteTime ; long nextDelay = writerIdleTimeNanos - ( System . nanoTime ( ) - lastWriteTime ) ; if ( nextDelay < = <int> ) { writerIdleTimeout = ctx . executor ( ) . schedule ( this , writerIdleTimeNanos , TimeUnit . NANOSECONDS ) ; try { IdleStateEvent event ; if ( firstWriterIdleEvent ) { firstWriterIdleEvent = false ; event = IdleStateEvent . FIRST_WRITER_IDLE_STATE_EVENT ; } else { event = IdleStateEvent . WRITER_IDLE_STATE_EVENT ; } channelIdle ( ctx , event ) ; } catch ( Throwable t ) { ctx . fireExceptionCaught ( t ) ; } } else { writerIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . NANOSECONDS ) ; } } } private final class AllIdleTimeoutTask implements Runnable { private final ChannelHandlerContext ctx ; AllIdleTimeoutTask ( ChannelHandlerContext ctx ) { this . ctx = ctx ; } @Override public void run ( ) { if ( ! ctx . channel ( ) . isOpen ( ) ) { return ; } long nextDelay = allIdleTimeNanos ; if ( ! reading ) { nextDelay - = System . nanoTime ( ) - Math . max ( lastReadTime , lastWriteTime ) ; } if ( nextDelay < = <int> ) { allIdleTimeout = ctx . executor ( ) . schedule ( this , allIdleTimeNanos , TimeUnit . NANOSECONDS ) ; try { IdleStateEvent event ; if ( firstAllIdleEvent ) { firstAllIdleEvent = false ; event = IdleStateEvent . FIRST_ALL_IDLE_STATE_EVENT ; } else { event = IdleStateEvent . ALL_IDLE_STATE_EVENT ; } channelIdle ( ctx , event ) ; } catch ( Throwable t ) { ctx . fireExceptionCaught ( t ) ; } } else { allIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . NANOSECONDS ) ; } } } } 
