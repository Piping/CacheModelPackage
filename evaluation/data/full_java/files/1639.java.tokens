package org . apache . cassandra . triggers ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . Collection ; import java . util . Collections ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . partitions . Partition ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . thrift . * ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . thrift . protocol . TBinaryProtocol ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . apache . cassandra . utils . ByteBufferUtil . toInt ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class TriggersTest { private static boolean triggerCreated = false ; private static ThriftServer thriftServer ; private static String ksName = <str> ; private static String cfName = <str> ; private static String otherCf = <str> ; @BeforeClass public static void beforeTest ( ) throws ConfigurationException { SchemaLoader . loadSchema ( ) ; } @Before public void setup ( ) throws Exception { StorageService . instance . initServer ( <int> ) ; if ( thriftServer = = null | | ! thriftServer . isRunning ( ) ) { thriftServer = new ThriftServer ( InetAddress . getLocalHost ( ) , <int> , <int> ) ; thriftServer . start ( ) ; } String cql = String . format ( <str> + <str> , ksName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; cql = String . format ( <str> , ksName , cfName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; cql = String . format ( <str> , ksName , otherCf ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; if ( ! triggerCreated ) { cql = String . format ( <str> , ksName , cfName , TestTrigger . class . getName ( ) ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; triggerCreated = true ; } } @AfterClass public static void teardown ( ) { if ( thriftServer ! = null & & thriftServer . isRunning ( ) ) { thriftServer . stop ( ) ; } } @Test public void executeTriggerOnCqlInsert ( ) throws Exception { String cql = String . format ( <str> , ksName , cfName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnCqlBatchInsert ( ) throws Exception { String cql = String . format ( <str> + <str> + <str> , ksName , cfName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnThriftInsert ( ) throws Exception { Cassandra . Client client = new Cassandra . Client ( new TBinaryProtocol ( new TFramedTransportFactory ( ) . openTransport ( InetAddress . getLocalHost ( ) . getHostName ( ) , <int> ) ) ) ; client . set_keyspace ( ksName ) ; client . insert ( bytes ( <int> ) , new ColumnParent ( cfName ) , getColumnForInsert ( <str> , <int> ) , org . apache . cassandra . thrift . ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnThriftBatchUpdate ( ) throws Exception { Cassandra . Client client = new Cassandra . Client ( new TBinaryProtocol ( new TFramedTransportFactory ( ) . openTransport ( InetAddress . getLocalHost ( ) . getHostName ( ) , <int> ) ) ) ; client . set_keyspace ( ksName ) ; org . apache . cassandra . thrift . Mutation mutation = new org . apache . cassandra . thrift . Mutation ( ) ; ColumnOrSuperColumn cosc = new ColumnOrSuperColumn ( ) ; cosc . setColumn ( getColumnForInsert ( <str> , <int> ) ) ; mutation . setColumn_or_supercolumn ( cosc ) ; client . batch_mutate ( Collections . singletonMap ( bytes ( <int> ) , Collections . singletonMap ( cfName , Collections . singletonList ( mutation ) ) ) , org . apache . cassandra . thrift . ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnCqlInsertWithConditions ( ) throws Exception { String cql = String . format ( <str> , ksName , cfName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnCqlBatchWithConditions ( ) throws Exception { String cql = String . format ( <str> + <str> + <str> + <str> , ksName , cfName ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test public void executeTriggerOnThriftCASOperation ( ) throws Exception { Cassandra . Client client = new Cassandra . Client ( new TBinaryProtocol ( new TFramedTransportFactory ( ) . openTransport ( InetAddress . getLocalHost ( ) . getHostName ( ) , <int> ) ) ) ; client . set_keyspace ( ksName ) ; client . cas ( bytes ( <int> ) , cfName , Collections . < Column > emptyList ( ) , Collections . singletonList ( getColumnForInsert ( <str> , <int> ) ) , org . apache . cassandra . thrift . ConsistencyLevel . LOCAL_SERIAL , org . apache . cassandra . thrift . ConsistencyLevel . ONE ) ; assertUpdateIsAugmented ( <int> ) ; } @Test ( expected = RuntimeException . class ) public void onCqlUpdateWithConditionsRejectGeneratedUpdatesForDifferentPartition ( ) throws Exception { String cf = <str> + System . nanoTime ( ) ; try { setupTableWithTrigger ( cf , CrossPartitionTrigger . class ) ; String cql = String . format ( <str> , ksName , cf ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; } finally { assertUpdateNotExecuted ( cf , <int> ) ; } } @Test ( expected = RuntimeException . class ) public void onCqlUpdateWithConditionsRejectGeneratedUpdatesForDifferentTable ( ) throws Exception { String cf = <str> + System . nanoTime ( ) ; try { setupTableWithTrigger ( cf , CrossTableTrigger . class ) ; String cql = String . format ( <str> , ksName , cf ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; } finally { assertUpdateNotExecuted ( cf , <int> ) ; } } @Test ( expected = InvalidRequestException . class ) public void onThriftCASRejectGeneratedUpdatesForDifferentPartition ( ) throws Exception { String cf = <str> + System . nanoTime ( ) ; try { setupTableWithTrigger ( cf , CrossPartitionTrigger . class ) ; Cassandra . Client client = new Cassandra . Client ( new TBinaryProtocol ( new TFramedTransportFactory ( ) . openTransport ( InetAddress . getLocalHost ( ) . getHostName ( ) , <int> ) ) ) ; client . set_keyspace ( ksName ) ; client . cas ( bytes ( <int> ) , cf , Collections . < Column > emptyList ( ) , Collections . singletonList ( getColumnForInsert ( <str> , <int> ) ) , org . apache . cassandra . thrift . ConsistencyLevel . LOCAL_SERIAL , org . apache . cassandra . thrift . ConsistencyLevel . ONE ) ; } finally { assertUpdateNotExecuted ( cf , <int> ) ; } } @Test ( expected = InvalidRequestException . class ) public void onThriftCASRejectGeneratedUpdatesForDifferentCF ( ) throws Exception { String cf = <str> + System . nanoTime ( ) ; try { setupTableWithTrigger ( cf , CrossTableTrigger . class ) ; Cassandra . Client client = new Cassandra . Client ( new TBinaryProtocol ( new TFramedTransportFactory ( ) . openTransport ( InetAddress . getLocalHost ( ) . getHostName ( ) , <int> ) ) ) ; client . set_keyspace ( ksName ) ; client . cas ( bytes ( <int> ) , cf , Collections . < Column > emptyList ( ) , Collections . singletonList ( getColumnForInsert ( <str> , <int> ) ) , org . apache . cassandra . thrift . ConsistencyLevel . LOCAL_SERIAL , org . apache . cassandra . thrift . ConsistencyLevel . ONE ) ; } finally { assertUpdateNotExecuted ( cf , <int> ) ; } } private void setupTableWithTrigger ( String cf , Class < ? extends ITrigger > triggerImpl ) throws RequestExecutionException { String cql = String . format ( <str> , ksName , cf ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; cql = String . format ( <str> , ksName , cf , triggerImpl . getName ( ) ) ; QueryProcessor . process ( cql , ConsistencyLevel . ONE ) ; } private void assertUpdateIsAugmented ( int key ) { UntypedResultSet rs = QueryProcessor . executeInternal ( String . format ( <str> , ksName , cfName , key ) ) ; assertTrue ( String . format ( <str> , key ) , rs . one ( ) . has ( <str> ) ) ; assertEquals ( <int> , rs . one ( ) . getInt ( <str> ) ) ; } private void assertUpdateNotExecuted ( String cf , int key ) { UntypedResultSet rs = QueryProcessor . executeInternal ( String . format ( <str> , ksName , cf , key ) ) ; assertTrue ( rs . isEmpty ( ) ) ; } private org . apache . cassandra . thrift . Column getColumnForInsert ( String columnName , int value ) { org . apache . cassandra . thrift . Column column = new org . apache . cassandra . thrift . Column ( ) ; column . setName ( LegacyLayout . makeLegacyComparator ( Schema . instance . getCFMetaData ( ksName , cfName ) ) . fromString ( columnName ) ) ; column . setValue ( bytes ( value ) ) ; column . setTimestamp ( System . currentTimeMillis ( ) ) ; return column ; } public static class TestTrigger implements ITrigger { public Collection < Mutation > augment ( Partition partition ) { RowUpdateBuilder update = new RowUpdateBuilder ( partition . metadata ( ) , FBUtilities . timestampMicros ( ) , partition . partitionKey ( ) . getKey ( ) ) ; update . add ( <str> , <int> ) ; return Collections . singletonList ( update . build ( ) ) ; } } public static class CrossPartitionTrigger implements ITrigger { public Collection < Mutation > augment ( Partition partition ) { RowUpdateBuilder update = new RowUpdateBuilder ( partition . metadata ( ) , FBUtilities . timestampMicros ( ) , toInt ( partition . partitionKey ( ) . getKey ( ) ) + <int> ) ; update . add ( <str> , <int> ) ; return Collections . singletonList ( update . build ( ) ) ; } } public static class CrossTableTrigger implements ITrigger { public Collection < Mutation > augment ( Partition partition ) { RowUpdateBuilder update = new RowUpdateBuilder ( Schema . instance . getCFMetaData ( ksName , otherCf ) , FBUtilities . timestampMicros ( ) , partition . partitionKey ( ) . getKey ( ) ) ; update . add ( <str> , <int> ) ; return Collections . singletonList ( update . build ( ) ) ; } } } 
