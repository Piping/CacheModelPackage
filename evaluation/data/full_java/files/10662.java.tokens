package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import com . google . common . util . concurrent . ListenerCallQueue . Callback ; import junit . framework . TestCase ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicInteger ; public class ListenerCallQueueTest extends TestCase { private static final Callback < Object > THROWING_CALLBACK = new Callback < Object > ( <str> ) { @Override public void call ( Object object ) { throw new RuntimeException ( ) ; } } ; public void testAddAndExecute ( ) { Object listenerInstance = new Object ( ) ; ListenerCallQueue < Object > queue = new ListenerCallQueue < Object > ( listenerInstance , directExecutor ( ) ) ; AtomicInteger counter = new AtomicInteger ( ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; assertEquals ( <int> , counter . get ( ) ) ; queue . execute ( ) ; assertEquals ( <int> , counter . get ( ) ) ; } public void testAddAndExecute_withExceptions ( ) { Object listenerInstance = new Object ( ) ; ListenerCallQueue < Object > queue = new ListenerCallQueue < Object > ( listenerInstance , directExecutor ( ) ) ; AtomicInteger counter = new AtomicInteger ( ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; assertEquals ( <int> , counter . get ( ) ) ; queue . execute ( ) ; assertEquals ( <int> , counter . get ( ) ) ; } public void testAddAndExecute_multithreaded ( ) throws InterruptedException { ExecutorService service = Executors . newFixedThreadPool ( <int> ) ; try { ListenerCallQueue < Object > queue = new ListenerCallQueue < Object > ( new Object ( ) , service ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; AtomicInteger counter = new AtomicInteger ( ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( countDownCallback ( latch ) ) ; assertEquals ( <int> , counter . get ( ) ) ; queue . execute ( ) ; latch . await ( ) ; assertEquals ( <int> , counter . get ( ) ) ; } finally { service . shutdown ( ) ; } } public void testAddAndExecute_multithreaded_withThrowingRunnable ( ) throws InterruptedException { ExecutorService service = Executors . newFixedThreadPool ( <int> ) ; try { ListenerCallQueue < Object > queue = new ListenerCallQueue < Object > ( new Object ( ) , service ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; AtomicInteger counter = new AtomicInteger ( ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( incrementingCallback ( counter , <int> ) ) ; queue . add ( THROWING_CALLBACK ) ; queue . add ( countDownCallback ( latch ) ) ; assertEquals ( <int> , counter . get ( ) ) ; queue . execute ( ) ; latch . await ( ) ; assertEquals ( <int> , counter . get ( ) ) ; } finally { service . shutdown ( ) ; } } private Callback < Object > incrementingCallback ( final AtomicInteger counter , final int expected ) { return new Callback < Object > ( <str> ) { @Override void call ( Object listener ) { assertEquals ( expected , counter . incrementAndGet ( ) ) ; } } ; } private Callback < Object > countDownCallback ( final CountDownLatch latch ) { return new Callback < Object > ( <str> ) { @Override void call ( Object listener ) { latch . countDown ( ) ; } } ; } } 
