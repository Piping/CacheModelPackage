package io . netty . handler . codec . spdy ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . util . ReferenceCountUtil ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class SpdyHeaderBlockZlibDecoderTest { private static final byte [ ] zlibHeader = { <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; private static final byte [ ] zlibSyncFlush = { <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> } ; private static final int maxHeaderSize = <int> ; private static final String name = <str> ; private static final String value = <str> ; private static final byte [ ] nameBytes = name . getBytes ( ) ; private static final byte [ ] valueBytes = value . getBytes ( ) ; private SpdyHeaderBlockZlibDecoder decoder ; private SpdyHeadersFrame frame ; @Before public void setUp ( ) { decoder = new SpdyHeaderBlockZlibDecoder ( SpdyVersion . SPDY_3_1 , maxHeaderSize ) ; frame = new DefaultSpdyHeadersFrame ( <int> ) ; } @After public void tearDown ( ) { decoder . end ( ) ; } @Test public void testHeaderBlock ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( nameBytes ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( valueBytes ) ; headerBlock . writeBytes ( zlibSyncFlush ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; decoder . endHeaderBlock ( frame ) ; assertFalse ( headerBlock . isReadable ( ) ) ; assertFalse ( frame . isInvalid ( ) ) ; assertEquals ( <int> , frame . headers ( ) . names ( ) . size ( ) ) ; assertTrue ( frame . headers ( ) . contains ( name ) ) ; assertEquals ( <int> , frame . headers ( ) . getAll ( name ) . size ( ) ) ; assertEquals ( value , frame . headers ( ) . get ( name ) ) ; } @Test public void testHeaderBlockMultipleDecodes ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( nameBytes ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( valueBytes ) ; headerBlock . writeBytes ( zlibSyncFlush ) ; int readableBytes = headerBlock . readableBytes ( ) ; for ( int i = <int> ; i < readableBytes ; i + + ) { ByteBuf headerBlockSegment = headerBlock . slice ( i , <int> ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlockSegment , frame ) ; assertFalse ( headerBlockSegment . isReadable ( ) ) ; } decoder . endHeaderBlock ( frame ) ; assertFalse ( frame . isInvalid ( ) ) ; assertEquals ( <int> , frame . headers ( ) . names ( ) . size ( ) ) ; assertTrue ( frame . headers ( ) . contains ( name ) ) ; assertEquals ( <int> , frame . headers ( ) . getAll ( name ) . size ( ) ) ; assertEquals ( value , frame . headers ( ) . get ( name ) ) ; } @Test public void testLargeHeaderName ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeInt ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { headerBlock . writeByte ( <str> ) ; } headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( zlibSyncFlush ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; decoder . endHeaderBlock ( frame ) ; assertFalse ( headerBlock . isReadable ( ) ) ; assertFalse ( frame . isInvalid ( ) ) ; assertFalse ( frame . isTruncated ( ) ) ; assertEquals ( <int> , frame . headers ( ) . names ( ) . size ( ) ) ; } @Test public void testLargeHeaderValue ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeByte ( <str> ) ; headerBlock . writeInt ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { headerBlock . writeByte ( <str> ) ; } headerBlock . writeBytes ( zlibSyncFlush ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; decoder . endHeaderBlock ( frame ) ; assertFalse ( headerBlock . isReadable ( ) ) ; assertFalse ( frame . isInvalid ( ) ) ; assertFalse ( frame . isTruncated ( ) ) ; assertEquals ( <int> , frame . headers ( ) . names ( ) . size ( ) ) ; assertEquals ( <int> , frame . headers ( ) . get ( <str> ) . length ( ) ) ; } @Test ( expected = SpdyProtocolException . class ) public void testHeaderBlockExtraData ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( nameBytes ) ; headerBlock . writeInt ( <int> ) ; headerBlock . writeBytes ( valueBytes ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <int> ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; } @Test ( expected = SpdyProtocolException . class ) public void testHeaderBlockInvalidDictionary ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <int> ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; } @Test ( expected = SpdyProtocolException . class ) public void testHeaderBlockInvalidDeflateBlock ( ) throws Exception { ByteBuf headerBlock = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( <int> ) ) ; headerBlock . writeBytes ( zlibHeader ) ; headerBlock . writeByte ( <int> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; headerBlock . writeByte ( <hex> ) ; decoder . decode ( ByteBufAllocator . DEFAULT , headerBlock , frame ) ; } } 
