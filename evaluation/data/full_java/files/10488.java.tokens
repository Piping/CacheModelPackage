package com . google . common . hash ; import static com . google . common . base . Charsets . UTF_8 ; import static com . google . common . hash . BloomFilterStrategies . BitArray ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . ImmutableSet ; import com . google . common . math . LongMath ; import com . google . common . primitives . Ints ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . math . RoundingMode ; import java . util . Random ; import javax . annotation . Nullable ; public class BloomFilterTest extends TestCase { @AndroidIncompatible public void testLargeBloomFilterDoesntOverflow ( ) { long numBits = Integer . MAX_VALUE ; numBits + + ; BitArray bitArray = new BitArray ( numBits ) ; assertTrue ( <str> + bitArray . bitSize ( ) , bitArray . bitSize ( ) > <int> ) ; } public void testCreateAndCheckMitz32BloomFilterWithKnownFalsePositives ( ) { int numInsertions = <int> ; BloomFilter < String > bf = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , numInsertions , <float> , BloomFilterStrategies . MURMUR128_MITZ_32 ) ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { bf . put ( Integer . toString ( i ) ) ; } for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { assertTrue ( bf . mightContain ( Integer . toString ( i ) ) ) ; } ImmutableSet < Integer > falsePositives = ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) { if ( ! falsePositives . contains ( i ) ) { assertFalse ( <str> + i , bf . mightContain ( Integer . toString ( i ) ) ) ; } } int knownNumberOfFalsePositives = <int> ; int numFpp = <int> ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { if ( bf . mightContain ( Integer . toString ( i ) ) ) { numFpp + + ; } } assertEquals ( knownNumberOfFalsePositives , numFpp ) ; double actualFpp = ( double ) knownNumberOfFalsePositives / numInsertions ; double expectedFpp = bf . expectedFpp ( ) ; assertEquals ( actualFpp , expectedFpp , <float> ) ; } public void testCreateAndCheckBloomFilterWithKnownFalsePositives64 ( ) { int numInsertions = <int> ; BloomFilter < String > bf = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , numInsertions , <float> , BloomFilterStrategies . MURMUR128_MITZ_64 ) ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { bf . put ( Integer . toString ( i ) ) ; } for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { assertTrue ( bf . mightContain ( Integer . toString ( i ) ) ) ; } ImmutableSet < Integer > falsePositives = ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) { if ( ! falsePositives . contains ( i ) ) { assertFalse ( <str> + i , bf . mightContain ( Integer . toString ( i ) ) ) ; } } int knownNumberOfFalsePositives = <int> ; int numFpp = <int> ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { if ( bf . mightContain ( Integer . toString ( i ) ) ) { numFpp + + ; } } assertEquals ( knownNumberOfFalsePositives , numFpp ) ; double actualFpp = ( double ) knownNumberOfFalsePositives / numInsertions ; double expectedFpp = bf . expectedFpp ( ) ; assertEquals ( actualFpp , expectedFpp , <float> ) ; } public void testCreateAndCheckBloomFilterWithKnownUtf8FalsePositives64 ( ) { int numInsertions = <int> ; BloomFilter < String > bf = BloomFilter . create ( Funnels . stringFunnel ( UTF_8 ) , numInsertions , <float> , BloomFilterStrategies . MURMUR128_MITZ_64 ) ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { bf . put ( Integer . toString ( i ) ) ; } for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { assertTrue ( bf . mightContain ( Integer . toString ( i ) ) ) ; } ImmutableSet < Integer > falsePositives = ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) { if ( ! falsePositives . contains ( i ) ) { assertFalse ( <str> + i , bf . mightContain ( Integer . toString ( i ) ) ) ; } } int knownNumberOfFalsePositives = <int> ; int numFpp = <int> ; for ( int i = <int> ; i < numInsertions * <int> ; i + = <int> ) { if ( bf . mightContain ( Integer . toString ( i ) ) ) { numFpp + + ; } } assertEquals ( knownNumberOfFalsePositives , numFpp ) ; double actualFpp = ( double ) knownNumberOfFalsePositives / numInsertions ; double expectedFpp = bf . expectedFpp ( ) ; assertEquals ( actualFpp , expectedFpp , <float> ) ; } public void testBasic ( ) { for ( double fpr = <float> ; fpr < <float> ; fpr * = <int> ) { for ( int expectedInsertions = <int> ; expectedInsertions < = <int> ; expectedInsertions * = <int> ) { checkSanity ( BloomFilter . create ( HashTestUtils . BAD_FUNNEL , expectedInsertions , fpr ) ) ; } } } @SuppressWarnings ( <str> ) public void testPreconditions ( ) { try { BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , - <int> , <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testFailureWhenMoreThan255HashFunctionsAreNeeded ( ) { try { int n = <int> ; double p = <float> ; BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , n , p ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> ) ) ; tester . testAllPublicStaticMethods ( BloomFilter . class ) ; } public void testOptimalHashes ( ) { for ( int n = <int> ; n < <int> ; n + + ) { for ( int m = <int> ; m < <int> ; m + + ) { assertTrue ( BloomFilter . optimalNumOfHashFunctions ( n , m ) > <int> ) ; } } } public void testOptimalNumOfHashFunctionsRounding ( ) { assertEquals ( <int> , BloomFilter . optimalNumOfHashFunctions ( <int> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testOptimalSize ( ) { for ( int n = <int> ; n < <int> ; n + + ) { for ( double fpp = Double . MIN_VALUE ; fpp < <float> ; fpp + = <float> ) { assertTrue ( BloomFilter . optimalNumOfBits ( n , fpp ) > = <int> ) ; } } Random random = new Random ( <int> ) ; for ( int repeats = <int> ; repeats < <int> ; repeats + + ) { assertTrue ( BloomFilter . optimalNumOfBits ( random . nextInt ( <int> < < <int> ) , random . nextDouble ( ) ) > = <int> ) ; } assertEquals ( <int> , BloomFilter . optimalNumOfBits ( Integer . MAX_VALUE , Double . MIN_VALUE ) ) ; try { BloomFilter . create ( HashTestUtils . BAD_FUNNEL , Integer . MAX_VALUE , Double . MIN_VALUE ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected ) . hasMessage ( <str> ) ; } } @SuppressWarnings ( <str> ) @AndroidIncompatible public void testLargeNumberOfInsertions ( ) { BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , Integer . MAX_VALUE / <int> , <float> ) ; BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> * Integer . MAX_VALUE , <float> ) ; } private void checkSanity ( BloomFilter < Object > bf ) { assertFalse ( bf . mightContain ( new Object ( ) ) ) ; assertFalse ( bf . apply ( new Object ( ) ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Object o = new Object ( ) ; bf . put ( o ) ; assertTrue ( bf . mightContain ( o ) ) ; assertTrue ( bf . apply ( o ) ) ; } } public void testCopy ( ) { BloomFilter < String > original = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> ) ; BloomFilter < String > copy = original . copy ( ) ; assertNotSame ( original , copy ) ; assertEquals ( original , copy ) ; } public void testExpectedFpp ( ) { BloomFilter < Object > bf = BloomFilter . create ( HashTestUtils . BAD_FUNNEL , <int> , <float> ) ; double fpp = bf . expectedFpp ( ) ; assertEquals ( <float> , fpp ) ; while ( fpp ! = <float> ) { boolean changed = bf . put ( new Object ( ) ) ; double newFpp = bf . expectedFpp ( ) ; assertTrue ( changed ? newFpp > fpp : newFpp = = fpp ) ; fpp = newFpp ; } } @AndroidIncompatible public void testBitSize ( ) { double fpp = <float> ; for ( int i = <int> ; i < <int> ; i + + ) { long numBits = BloomFilter . optimalNumOfBits ( i , fpp ) ; int arraySize = Ints . checkedCast ( LongMath . divide ( numBits , <int> , RoundingMode . CEILING ) ) ; assertEquals ( arraySize * Long . SIZE , BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , i , fpp ) . bitSize ( ) ) ; } } public void testEquals_empty ( ) { new EqualsTester ( ) . addEqualityGroup ( BloomFilter . create ( Funnels . byteArrayFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . byteArrayFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . byteArrayFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . byteArrayFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ) . addEqualityGroup ( BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> , <float> ) ) . testEquals ( ) ; } public void testEquals ( ) { BloomFilter < String > bf1 = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> ) ; bf1 . put ( <str> ) ; bf1 . put ( <str> ) ; BloomFilter < String > bf2 = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> ) ; bf2 . put ( <str> ) ; bf2 . put ( <str> ) ; new EqualsTester ( ) . addEqualityGroup ( bf1 , bf2 ) . testEquals ( ) ; bf2 . put ( <str> ) ; new EqualsTester ( ) . addEqualityGroup ( bf1 ) . addEqualityGroup ( bf2 ) . testEquals ( ) ; } public void testEqualsWithCustomFunnel ( ) { BloomFilter < Long > bf1 = BloomFilter . create ( new CustomFunnel ( ) , <int> ) ; BloomFilter < Long > bf2 = BloomFilter . create ( new CustomFunnel ( ) , <int> ) ; assertEquals ( bf1 , bf2 ) ; } public void testSerializationWithCustomFunnel ( ) { SerializableTester . reserializeAndAssert ( BloomFilter . create ( new CustomFunnel ( ) , <int> ) ) ; } private static final class CustomFunnel implements Funnel < Long > { @Override public void funnel ( Long value , PrimitiveSink into ) { into . putLong ( value ) ; } @Override public boolean equals ( @Nullable Object object ) { return ( object instanceof CustomFunnel ) ; } @Override public int hashCode ( ) { return <int> ; } } public void testPutReturnValue ( ) { for ( int i = <int> ; i < <int> ; i + + ) { BloomFilter < String > bf = BloomFilter . create ( Funnels . unencodedCharsFunnel ( ) , <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { String value = new Object ( ) . toString ( ) ; boolean mightContain = bf . mightContain ( value ) ; boolean put = bf . put ( value ) ; assertTrue ( mightContain ! = put ) ; } } } public void testPutAll ( ) { int element1 = <int> ; int element2 = <int> ; BloomFilter < Integer > bf1 = BloomFilter . create ( Funnels . integerFunnel ( ) , <int> ) ; bf1 . put ( element1 ) ; assertTrue ( bf1 . mightContain ( element1 ) ) ; assertFalse ( bf1 . mightContain ( element2 ) ) ; BloomFilter < Integer > bf2 = BloomFilter . create ( Funnels . integerFunnel ( ) , <int> ) ; bf2 . put ( element2 ) ; assertFalse ( bf2 . mightContain ( element1 ) ) ; assertTrue ( bf2 . mightContain ( element2 ) ) ; assertTrue ( bf1 . isCompatible ( bf2 ) ) ; bf1 . putAll ( bf2 ) ; assertTrue ( bf1 . mightContain ( element1 ) ) ; assertTrue ( bf1 . mightContain ( element2 ) ) ; assertFalse ( bf2 . mightContain ( element1 ) ) ; assertTrue ( bf2 . mightContain ( element2 ) ) ; } public void testPutAllDifferentSizes ( ) { BloomFilter < Integer > bf1 = BloomFilter . create ( Funnels . integerFunnel ( ) , <int> ) ; BloomFilter < Integer > bf2 = BloomFilter . create ( Funnels . integerFunnel ( ) , <int> ) ; try { assertFalse ( bf1 . isCompatible ( bf2 ) ) ; bf1 . putAll ( bf2 ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { assertFalse ( bf2 . isCompatible ( bf1 ) ) ; bf2 . putAll ( bf1 ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPutAllWithSelf ( ) { BloomFilter < Integer > bf1 = BloomFilter . create ( Funnels . integerFunnel ( ) , <int> ) ; try { assertFalse ( bf1 . isCompatible ( bf1 ) ) ; bf1 . putAll ( bf1 ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testJavaSerialization ( ) { BloomFilter < byte [ ] > bf = BloomFilter . create ( Funnels . byteArrayFunnel ( ) , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { bf . put ( Ints . toByteArray ( i ) ) ; } BloomFilter < byte [ ] > copy = SerializableTester . reserialize ( bf ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertTrue ( copy . mightContain ( Ints . toByteArray ( i ) ) ) ; } assertEquals ( bf . expectedFpp ( ) , copy . expectedFpp ( ) ) ; SerializableTester . reserializeAndAssert ( bf ) ; } public void testCustomSerialization ( ) throws Exception { Funnel < byte [ ] > funnel = Funnels . byteArrayFunnel ( ) ; BloomFilter < byte [ ] > bf = BloomFilter . create ( funnel , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { bf . put ( Ints . toByteArray ( i ) ) ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; bf . writeTo ( out ) ; assertEquals ( bf , BloomFilter . readFrom ( new ByteArrayInputStream ( out . toByteArray ( ) ) , funnel ) ) ; } public void testBloomFilterStrategies ( ) { assertThat ( BloomFilterStrategies . values ( ) ) . hasLength ( <int> ) ; assertEquals ( BloomFilterStrategies . MURMUR128_MITZ_32 , BloomFilterStrategies . values ( ) [ <int> ] ) ; assertEquals ( BloomFilterStrategies . MURMUR128_MITZ_64 , BloomFilterStrategies . values ( ) [ <int> ] ) ; } } 
