package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalShadowLight ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . utils . AnimationController ; import com . badlogic . gdx . graphics . g3d . utils . DepthShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . MeshBuilder ; import com . badlogic . gdx . graphics . g3d . utils . MeshPartBuilder ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . StringBuilder ; public class Animation3DTest extends BaseG3dHudTest { ModelInstance skydome ; Model floorModel ; ModelInstance character ; ModelInstance tree ; AnimationController animation ; DirectionalShadowLight shadowLight ; ModelBatch shadowBatch ; Environment lights ; @Override public void create ( ) { super . create ( ) ; lights = new Environment ( ) ; lights . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; lights . add ( ( shadowLight = new DirectionalShadowLight ( <int> , <int> , <int> f , <int> f , <float> , <int> f ) ) . set ( <float> , <float> , <float> , - <float> , - <float> , - <float> ) ) ; lights . shadowMap = shadowLight ; inputController . rotateLeftKey = inputController . rotateRightKey = inputController . forwardKey = inputController . backwardKey = <int> ; cam . position . set ( <int> , <int> , <int> ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . update ( ) ; modelsWindow . setVisible ( false ) ; assets . load ( <str> , Model . class ) ; assets . load ( <str> , Texture . class ) ; assets . load ( <str> , Texture . class ) ; loading = true ; trForward . translation . set ( <int> , <int> , <float> ) ; trBackward . translation . set ( <int> , <int> , - <float> ) ; trLeft . rotation . setFromAxis ( Vector3 . Y , <int> ) ; trRight . rotation . setFromAxis ( Vector3 . Y , - <int> ) ; ModelBuilder builder = new ModelBuilder ( ) ; builder . begin ( ) ; builder . node ( ) . id = <str> ; MeshPartBuilder part = builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position | Usage . TextureCoordinates | Usage . Normal , new Material ( <str> ) ) ; ( ( MeshBuilder ) part ) . ensureRectangles ( <int> ) ; for ( float x = - <int> f ; x < <int> f ; x + = <int> f ) { for ( float z = - <int> f ; z < <int> f ; z + = <int> f ) { part . rect ( x , <int> , z + <int> f , x + <int> f , <int> , z + <int> f , x + <int> f , <int> , z , x , <int> , z , <int> , <int> , <int> ) ; } } builder . node ( ) . id = <str> ; part = builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position | Usage . TextureCoordinates | Usage . Normal , new Material ( <str> ) ) ; part . rect ( <float> , <float> , - <int> f , <int> f , <float> , - <int> f , <int> f , <int> f , - <int> f , <float> , <int> f , - <int> f , <int> , <int> , <float> ) ; part . setUVRange ( <int> , <int> , <int> , <int> ) ; part . rect ( <int> f , <float> , - <int> f , <float> , <float> , - <int> f , <float> , <int> f , - <int> f , <int> f , <int> f , - <int> f , <int> , <int> , - <float> ) ; floorModel = builder . end ( ) ; shadowBatch = new ModelBatch ( new DepthShaderProvider ( ) ) ; } final AnimationController . Transform trTmp = new AnimationController . Transform ( ) ; final AnimationController . Transform trForward = new AnimationController . Transform ( ) ; final AnimationController . Transform trBackward = new AnimationController . Transform ( ) ; final AnimationController . Transform trRight = new AnimationController . Transform ( ) ; final AnimationController . Transform trLeft = new AnimationController . Transform ( ) ; final Matrix4 tmpMatrix = new Matrix4 ( ) ; final Vector3 tmpVector = new Vector3 ( ) ; int status = <int> ; final static int idle = <int> ; final static int walk = <int> ; final static int back = <int> ; final static int attack = <int> ; float angle = <float> ; @Override public void render ( ) { if ( character ! = null ) { animation . update ( Gdx . graphics . getDeltaTime ( ) ) ; if ( upKey ) { if ( ! animation . inAction ) { trTmp . idt ( ) . lerp ( trForward , Gdx . graphics . getDeltaTime ( ) / animation . current . animation . duration ) ; character . transform . mul ( trTmp . toMatrix4 ( tmpMatrix ) ) ; } if ( status ! = walk ) { animation . animate ( <str> , - <int> , <float> , null , <float> ) ; status = walk ; } } else if ( downKey ) { if ( ! animation . inAction ) { trTmp . idt ( ) . lerp ( trBackward , Gdx . graphics . getDeltaTime ( ) / animation . current . animation . duration ) ; character . transform . mul ( trTmp . toMatrix4 ( tmpMatrix ) ) ; } if ( status ! = back ) { animation . animate ( <str> , - <int> , - <float> , null , <float> ) ; status = back ; } } else if ( status ! = idle ) { animation . animate ( <str> , - <int> , <float> , null , <float> ) ; status = idle ; } if ( rightKey & & ( status = = walk | | status = = back ) & & ! animation . inAction ) { trTmp . idt ( ) . lerp ( trRight , Gdx . graphics . getDeltaTime ( ) / animation . current . animation . duration ) ; character . transform . mul ( trTmp . toMatrix4 ( tmpMatrix ) ) ; } else if ( leftKey & & ( status = = walk | | status = = back ) & & ! animation . inAction ) { trTmp . idt ( ) . lerp ( trLeft , Gdx . graphics . getDeltaTime ( ) / animation . current . animation . duration ) ; character . transform . mul ( trTmp . toMatrix4 ( tmpMatrix ) ) ; } if ( spaceKey & & ! animation . inAction ) { animation . action ( <str> , <int> , <float> , null , <float> ) ; } } if ( character ! = null ) { shadowLight . begin ( character . transform . getTranslation ( tmpVector ) , cam . direction ) ; shadowBatch . begin ( shadowLight . getCamera ( ) ) ; if ( character ! = null ) shadowBatch . render ( character ) ; if ( tree ! = null ) shadowBatch . render ( tree ) ; shadowBatch . end ( ) ; shadowLight . end ( ) ; } super . render ( ) ; } @Override protected void render ( ModelBatch batch , Array < ModelInstance > instances ) { batch . render ( instances , lights ) ; if ( skydome ! = null ) batch . render ( skydome ) ; } @Override protected void getStatus ( StringBuilder stringBuilder ) { super . getStatus ( stringBuilder ) ; stringBuilder . append ( <str> ) ; } @Override protected void onModelClicked ( final String name ) { } @Override protected void onLoaded ( ) { if ( skydome = = null ) { skydome = new ModelInstance ( assets . get ( <str> , Model . class ) ) ; floorModel . getMaterial ( <str> ) . set ( TextureAttribute . createDiffuse ( assets . get ( <str> , Texture . class ) ) ) ; floorModel . getMaterial ( <str> ) . set ( TextureAttribute . createDiffuse ( assets . get ( <str> , Texture . class ) ) , new BlendingAttribute ( ) ) ; instances . add ( new ModelInstance ( floorModel , <str> ) ) ; instances . add ( tree = new ModelInstance ( floorModel , <str> ) ) ; assets . load ( <str> , Model . class ) ; loading = true ; } else if ( character = = null ) { character = new ModelInstance ( assets . get ( <str> , Model . class ) ) ; BoundingBox bbox = new BoundingBox ( ) ; character . calculateBoundingBox ( bbox ) ; character . transform . setToRotation ( Vector3 . Y , <int> ) . trn ( <int> , - bbox . min . y , <int> ) ; instances . add ( character ) ; animation = new AnimationController ( character ) ; animation . animate ( <str> , - <int> , <float> , null , <float> ) ; status = idle ; for ( Animation anim : character . animations ) Gdx . app . log ( <str> , anim . id ) ; } } boolean rightKey , leftKey , upKey , downKey , spaceKey ; @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . LEFT ) leftKey = false ; if ( keycode = = Keys . RIGHT ) rightKey = false ; if ( keycode = = Keys . UP ) upKey = false ; if ( keycode = = Keys . DOWN ) downKey = false ; if ( keycode = = Keys . SPACE ) spaceKey = false ; return super . keyUp ( keycode ) ; } @Override public boolean keyDown ( int keycode ) { if ( keycode = = Keys . LEFT ) leftKey = true ; if ( keycode = = Keys . RIGHT ) rightKey = true ; if ( keycode = = Keys . UP ) upKey = true ; if ( keycode = = Keys . DOWN ) downKey = true ; if ( keycode = = Keys . SPACE ) spaceKey = true ; return super . keyDown ( keycode ) ; } @Override public void dispose ( ) { super . dispose ( ) ; floorModel . dispose ( ) ; shadowLight . dispose ( ) ; } } 
