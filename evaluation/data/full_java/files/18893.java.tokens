package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import java . util . zip . Adler32 ; import java . util . zip . Checksum ; import static io . netty . handler . codec . compression . FastLz . * ; public class FastLzFrameEncoder extends MessageToByteEncoder < ByteBuf > { private final int level ; private final Checksum checksum ; public FastLzFrameEncoder ( ) { this ( LEVEL_AUTO , null ) ; } public FastLzFrameEncoder ( int level ) { this ( level , null ) ; } public FastLzFrameEncoder ( boolean validateChecksums ) { this ( LEVEL_AUTO , validateChecksums ? new Adler32 ( ) : null ) ; } public FastLzFrameEncoder ( int level , Checksum checksum ) { super ( false ) ; if ( level ! = LEVEL_AUTO & & level ! = LEVEL_1 & & level ! = LEVEL_2 ) { throw new IllegalArgumentException ( String . format ( <str> , level , LEVEL_AUTO , LEVEL_1 , LEVEL_2 ) ) ; } this . level = level ; this . checksum = checksum ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { final Checksum checksum = this . checksum ; for ( ; ; ) { if ( ! in . isReadable ( ) ) { return ; } final int idx = in . readerIndex ( ) ; final int length = Math . min ( in . readableBytes ( ) , MAX_CHUNK_LENGTH ) ; final int outputIdx = out . writerIndex ( ) ; out . setMedium ( outputIdx , MAGIC_NUMBER ) ; int outputOffset = outputIdx + CHECKSUM_OFFSET + ( checksum ! = null ? <int> : <int> ) ; final byte blockType ; final int chunkLength ; if ( length < MIN_LENGTH_TO_COMPRESSION ) { blockType = BLOCK_TYPE_NON_COMPRESSED ; out . ensureWritable ( outputOffset + <int> + length ) ; final byte [ ] output = out . array ( ) ; final int outputPtr = out . arrayOffset ( ) + outputOffset + <int> ; if ( checksum ! = null ) { final byte [ ] input ; final int inputPtr ; if ( in . hasArray ( ) ) { input = in . array ( ) ; inputPtr = in . arrayOffset ( ) + idx ; } else { input = new byte [ length ] ; in . getBytes ( idx , input ) ; inputPtr = <int> ; } checksum . reset ( ) ; checksum . update ( input , inputPtr , length ) ; out . setInt ( outputIdx + CHECKSUM_OFFSET , ( int ) checksum . getValue ( ) ) ; System . arraycopy ( input , inputPtr , output , outputPtr , length ) ; } else { in . getBytes ( idx , output , outputPtr , length ) ; } chunkLength = length ; } else { final byte [ ] input ; final int inputPtr ; if ( in . hasArray ( ) ) { input = in . array ( ) ; inputPtr = in . arrayOffset ( ) + idx ; } else { input = new byte [ length ] ; in . getBytes ( idx , input ) ; inputPtr = <int> ; } if ( checksum ! = null ) { checksum . reset ( ) ; checksum . update ( input , inputPtr , length ) ; out . setInt ( outputIdx + CHECKSUM_OFFSET , ( int ) checksum . getValue ( ) ) ; } final int maxOutputLength = calculateOutputBufferLength ( length ) ; out . ensureWritable ( outputOffset + <int> + maxOutputLength ) ; final byte [ ] output = out . array ( ) ; final int outputPtr = out . arrayOffset ( ) + outputOffset + <int> ; final int compressedLength = compress ( input , inputPtr , length , output , outputPtr , level ) ; if ( compressedLength < length ) { blockType = BLOCK_TYPE_COMPRESSED ; chunkLength = compressedLength ; out . setShort ( outputOffset , chunkLength ) ; outputOffset + = <int> ; } else { blockType = BLOCK_TYPE_NON_COMPRESSED ; System . arraycopy ( input , inputPtr , output , outputPtr - <int> , length ) ; chunkLength = length ; } } out . setShort ( outputOffset , length ) ; out . setByte ( outputIdx + OPTIONS_OFFSET , blockType | ( checksum ! = null ? BLOCK_WITH_CHECKSUM : BLOCK_WITHOUT_CHECKSUM ) ) ; out . writerIndex ( outputOffset + <int> + chunkLength ) ; in . skipBytes ( length ) ; } } } 
