package org . elasticsearch . index . fielddata ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . test . ESSingleNodeTestCase ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; public class DisabledFieldDataFormatTests extends ESSingleNodeTestCase { public void test ( ) throws Exception { createIndex ( <str> , Settings . EMPTY , <str> , <str> , <str> ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; + + i ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + i ) . execute ( ) . actionGet ( ) ; } logger . info ( <str> ) ; final int searchCycles = <int> ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; updateFormat ( <str> ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; SearchResponse resp = null ; for ( int i = <int> ; i < searchCycles ; i + + ) { try { resp = client ( ) . prepareSearch ( <str> ) . setPreference ( Integer . toString ( i ) ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) . execute ( ) . actionGet ( ) ; assertFailures ( resp ) ; } catch ( SearchPhaseExecutionException e ) { } } updateFormat ( <str> ) ; for ( int i = <int> ; i < searchCycles ; i + + ) { resp = client ( ) . prepareSearch ( <str> ) . setPreference ( Integer . toString ( i ) ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) . execute ( ) . actionGet ( ) ; assertNoFailures ( resp ) ; } updateFormat ( <str> ) ; for ( int i = <int> ; i < searchCycles ; i + + ) { resp = client ( ) . prepareSearch ( <str> ) . setPreference ( Integer . toString ( i ) ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) . execute ( ) . actionGet ( ) ; assertNoFailures ( resp ) ; } client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < searchCycles ; i + + ) { try { resp = client ( ) . prepareSearch ( <str> ) . setPreference ( Integer . toString ( i ) ) . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) . execute ( ) . actionGet ( ) ; assertFailures ( resp ) ; } catch ( SearchPhaseExecutionException e ) { } } } private void updateFormat ( final String format ) throws Exception { logger . info ( <str> , format ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , format ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) . get ( ) ) ; logger . info ( <str> , format ) ; } } 
