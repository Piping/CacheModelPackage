package org . elasticsearch . search . suggest . phrase ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . search . suggest . SuggestUtils ; import org . elasticsearch . search . suggest . phrase . DirectCandidateGenerator . Candidate ; import java . util . Arrays ; public final class Correction implements Comparable < Correction > { public static final Correction [ ] EMPTY = new Correction [ <int> ] ; public double score ; public final Candidate [ ] candidates ; public Correction ( double score , Candidate [ ] candidates ) { this . score = score ; this . candidates = candidates ; } @Override public String toString ( ) { return <str> + score + <str> + Arrays . toString ( candidates ) + <str> ; } public BytesRef join ( BytesRef separator ) { return join ( separator , null , null ) ; } public BytesRef join ( BytesRef separator , BytesRef preTag , BytesRef postTag ) { return join ( separator , new BytesRefBuilder ( ) , preTag , postTag ) ; } public BytesRef join ( BytesRef separator , BytesRefBuilder result , BytesRef preTag , BytesRef postTag ) { BytesRef [ ] toJoin = new BytesRef [ this . candidates . length ] ; int len = separator . length * this . candidates . length - <int> ; for ( int i = <int> ; i < toJoin . length ; i + + ) { Candidate candidate = candidates [ i ] ; if ( preTag = = null | | candidate . userInput ) { toJoin [ i ] = candidate . term ; } else { final int maxLen = preTag . length + postTag . length + candidate . term . length ; final BytesRefBuilder highlighted = new BytesRefBuilder ( ) ; highlighted . grow ( maxLen ) ; if ( i = = <int> | | candidates [ i - <int> ] . userInput ) { highlighted . append ( preTag ) ; } highlighted . append ( candidate . term ) ; if ( toJoin . length = = i + <int> | | candidates [ i + <int> ] . userInput ) { highlighted . append ( postTag ) ; } toJoin [ i ] = highlighted . get ( ) ; } len + = toJoin [ i ] . length ; } result . grow ( len ) ; return SuggestUtils . join ( separator , result , toJoin ) ; } @Override public int compareTo ( Correction other ) { return compareTo ( other . score , other . candidates ) ; } int compareTo ( double otherScore , Candidate [ ] otherCandidates ) { if ( score = = otherScore ) { int limit = Math . min ( candidates . length , otherCandidates . length ) ; for ( int i = <int> ; i < limit ; i + + ) { int cmp = candidates [ i ] . term . compareTo ( otherCandidates [ i ] . term ) ; if ( cmp ! = <int> ) { return - cmp ; } } return candidates . length - otherCandidates . length ; } else { return Double . compare ( score , otherScore ) ; } } } 
