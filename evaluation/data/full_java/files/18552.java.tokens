package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . TimeUtils ; public class SpriteBatchShaderTest extends GdxTest { int SPRITES = <int> ; long startTime = TimeUtils . nanoTime ( ) ; int frames = <int> ; Texture texture ; Texture texture2 ; SpriteBatch spriteBatch ; int coords [ ] = new int [ SPRITES * <int> ] ; int coords2 [ ] = new int [ SPRITES * <int> ] ; Color col = new Color ( <int> , <int> , <int> , <float> ) ; Mesh mesh ; float vertices [ ] = new float [ SPRITES * <int> * ( <int> + <int> + <int> ) ] ; @Override public void render ( ) { GL20 gl = Gdx . gl20 ; gl . glClearColor ( <float> , <float> , <float> , <int> ) ; gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float begin = <int> ; float end = <int> ; float draw1 = <int> ; float draw2 = <int> ; float drawText = <int> ; long start = TimeUtils . nanoTime ( ) ; spriteBatch . begin ( ) ; begin = ( TimeUtils . nanoTime ( ) - start ) / <float> ; int len = coords . length ; start = TimeUtils . nanoTime ( ) ; for ( int i = <int> ; i < len ; i + = <int> ) spriteBatch . draw ( texture , coords [ i ] , coords [ i + <int> ] , <int> , <int> , <int> , <int> ) ; draw1 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteBatch . setColor ( col ) ; for ( int i = <int> ; i < coords2 . length ; i + = <int> ) spriteBatch . draw ( texture2 , coords2 [ i ] , coords2 [ i + <int> ] , <int> , <int> , <int> , <int> ) ; draw2 = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; drawText = ( TimeUtils . nanoTime ( ) - start ) / <float> ; start = TimeUtils . nanoTime ( ) ; spriteBatch . end ( ) ; end = ( TimeUtils . nanoTime ( ) - start ) / <float> ; if ( TimeUtils . nanoTime ( ) - startTime > <int> ) { Gdx . app . log ( <str> , <str> + frames + <str> + spriteBatch . renderCalls + <str> + begin + <str> + draw1 + <str> + draw2 + <str> + drawText + <str> + end ) ; frames = <int> ; startTime = TimeUtils . nanoTime ( ) ; } frames + + ; } @Override public void create ( ) { spriteBatch = new SpriteBatch ( ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; Pixmap pixmap = new Pixmap ( <int> , <int> , Format . RGB565 ) ; pixmap . setColor ( <int> , <int> , <int> , <float> ) ; pixmap . fill ( ) ; texture2 = new Texture ( pixmap ) ; pixmap . dispose ( ) ; for ( int i = <int> ; i < coords . length ; i + = <int> ) { coords [ i ] = ( int ) ( Math . random ( ) * Gdx . graphics . getWidth ( ) ) ; coords [ i + <int> ] = ( int ) ( Math . random ( ) * Gdx . graphics . getHeight ( ) ) ; coords2 [ i ] = ( int ) ( Math . random ( ) * Gdx . graphics . getWidth ( ) ) ; coords2 [ i + <int> ] = ( int ) ( Math . random ( ) * Gdx . graphics . getHeight ( ) ) ; } } @Override public void dispose ( ) { spriteBatch . dispose ( ) ; texture . dispose ( ) ; texture2 . dispose ( ) ; } } 
