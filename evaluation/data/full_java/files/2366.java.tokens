package org . nd4j . linalg . util ; import org . apache . commons . math3 . random . RandomGenerator ; import org . apache . commons . math3 . util . FastMath ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; public class MathUtils { public static double log2 = Math . log ( <int> ) ; public static double SMALL = <float> ; public static double pow ( double base , double exponent ) { double result = <int> ; if ( exponent = = <int> ) { return result ; } if ( exponent < <int> ) { return <int> / pow ( base , exponent * - <int> ) ; } return FastMath . pow ( base , exponent ) ; } public static double normalize ( double val , double min , double max ) { if ( max < min ) throw new IllegalArgumentException ( <str> ) ; return ( val - min ) / ( max - min ) ; } public static int clamp ( int value , int min , int max ) { if ( value < min ) value = min ; if ( value > max ) value = max ; return value ; } public static int discretize ( double value , double min , double max , int binCount ) { int discreteValue = ( int ) ( binCount * normalize ( value , min , max ) ) ; return clamp ( discreteValue , <int> , binCount - <int> ) ; } public static long nextPowOf2 ( long v ) { v - - ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v | = v > > <int> ; v + + ; return v ; } public static int binomial ( RandomGenerator rng , int n , double p ) { if ( ( p < <int> ) | | ( p > <int> ) ) { return <int> ; } int c = <int> ; for ( int i = <int> ; i < n ; i + + ) { if ( rng . nextDouble ( ) < p ) { c + + ; } } return c ; } public static double uniform ( Random rng , double min , double max ) { return rng . nextDouble ( ) * ( max - min ) + min ; } public static double correlation ( double [ ] residuals , double targetAttribute [ ] ) { double [ ] predictedValues = new double [ residuals . length ] ; for ( int i = <int> ; i < predictedValues . length ; i + + ) { predictedValues [ i ] = targetAttribute [ i ] - residuals [ i ] ; } double ssErr = ssError ( predictedValues , targetAttribute ) ; double total = ssTotal ( residuals , targetAttribute ) ; return <int> - ( ssErr / total ) ; } public static double sigmoid ( double x ) { return <float> / ( <float> + Math . pow ( Math . E , - x ) ) ; } public static double ssReg ( double [ ] residuals , double [ ] targetAttribute ) { double mean = sum ( targetAttribute ) / targetAttribute . length ; double ret = <int> ; for ( int i = <int> ; i < residuals . length ; i + + ) { ret + = Math . pow ( residuals [ i ] - mean , <int> ) ; } return ret ; } public static double ssError ( double [ ] predictedValues , double [ ] targetAttribute ) { double ret = <int> ; for ( int i = <int> ; i < predictedValues . length ; i + + ) { ret + = Math . pow ( targetAttribute [ i ] - predictedValues [ i ] , <int> ) ; } return ret ; } public static double vectorLength ( double [ ] vector ) { double ret = <int> ; if ( vector = = null ) return ret ; else { for ( int i = <int> ; i < vector . length ; i + + ) { ret + = Math . pow ( vector [ i ] , <int> ) ; } } return ret ; } public static double idf ( double totalDocs , double numTimesWordAppearedInADocument ) { return totalDocs > <int> ? Math . log10 ( totalDocs / numTimesWordAppearedInADocument ) : <int> ; } public static double tf ( int count ) { return count > <int> ? <int> + Math . log10 ( count ) : <int> ; } public static double tfidf ( double td , double idf ) { return td * idf ; } private static int charForLetter ( char c ) { char [ ] chars = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( int i = <int> ; i < chars . length ; i + + ) if ( chars [ i ] = = c ) return i ; return - <int> ; } public static double ssTotal ( double [ ] residuals , double [ ] targetAttribute ) { return ssReg ( residuals , targetAttribute ) + ssError ( residuals , targetAttribute ) ; } public static double sum ( double [ ] nums ) { double ret = <int> ; for ( double d : nums ) ret + = d ; return ret ; } public static double [ ] mergeCoords ( double [ ] x , double [ ] y ) { if ( x . length ! = y . length ) throw new IllegalArgumentException ( <str> ) ; double [ ] ret = new double [ x . length + y . length ] ; for ( int i = <int> ; i < x . length ; i + + ) { ret [ i ] = x [ i ] ; ret [ i + <int> ] = y [ i ] ; } return ret ; } public static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { if ( x . size ( ) ! = y . size ( ) ) throw new IllegalArgumentException ( <str> ) ; List < Double > ret = new ArrayList < Double > ( ) ; for ( int i = <int> ; i < x . size ( ) ; i + + ) { ret . add ( x . get ( i ) ) ; ret . add ( y . get ( i ) ) ; } return ret ; } public static double [ ] weightsFor ( List < Double > vector ) { List < double [ ] > coords = coordSplit ( vector ) ; double [ ] x = coords . get ( <int> ) ; double [ ] y = coords . get ( <int> ) ; double meanX = sum ( x ) / x . length ; double meanY = sum ( y ) / y . length ; double sumOfMeanDifferences = sumOfMeanDifferences ( x , y ) ; double xDifferenceOfMean = sumOfMeanDifferencesOnePoint ( x ) ; double w_1 = sumOfMeanDifferences / xDifferenceOfMean ; double w_0 = meanY - ( w_1 ) * meanX ; double [ ] ret = new double [ vector . size ( ) ] ; ret [ <int> ] = w_0 ; ret [ <int> ] = w_1 ; return ret ; } public static double squaredLoss ( double [ ] x , double [ ] y , double w_0 , double w_1 ) { double sum = <int> ; for ( int j = <int> ; j < x . length ; j + + ) { sum + = Math . pow ( ( y [ j ] - ( w_1 * x [ j ] + w_0 ) ) , <int> ) ; } return sum ; } public static double w_1 ( double [ ] x , double [ ] y , int n ) { return ( n * sumOfProducts ( x , y ) - sum ( x ) * sum ( y ) ) / ( n * sumOfSquares ( x ) - Math . pow ( sum ( x ) , <int> ) ) ; } public static double w_0 ( double [ ] x , double [ ] y , int n ) { double weight1 = w_1 ( x , y , n ) ; return ( sum ( y ) - ( weight1 * sum ( x ) ) ) / n ; } public static double [ ] weightsFor ( double [ ] vector ) { List < double [ ] > coords = coordSplit ( vector ) ; double [ ] x = coords . get ( <int> ) ; double [ ] y = coords . get ( <int> ) ; double meanX = sum ( x ) / x . length ; double meanY = sum ( y ) / y . length ; double sumOfMeanDifferences = sumOfMeanDifferences ( x , y ) ; double xDifferenceOfMean = sumOfMeanDifferencesOnePoint ( x ) ; double w_1 = sumOfMeanDifferences / xDifferenceOfMean ; double w_0 = meanY - ( w_1 ) * meanX ; double [ ] ret = new double [ vector . length ] ; ret [ <int> ] = w_0 ; ret [ <int> ] = w_1 ; return ret ; } public static double errorFor ( double actual , double prediction ) { return actual - prediction ; } public static double sumOfMeanDifferences ( double [ ] vector , double [ ] vector2 ) { double mean = sum ( vector ) / vector . length ; double mean2 = sum ( vector2 ) / vector2 . length ; double ret = <int> ; for ( int i = <int> ; i < vector . length ; i + + ) { double vec1Diff = vector [ i ] - mean ; double vec2Diff = vector2 [ i ] - mean2 ; ret + = vec1Diff * vec2Diff ; } return ret ; } public static double sumOfMeanDifferencesOnePoint ( double [ ] vector ) { double mean = sum ( vector ) / vector . length ; double ret = <int> ; for ( int i = <int> ; i < vector . length ; i + + ) { double vec1Diff = Math . pow ( vector [ i ] - mean , <int> ) ; ret + = vec1Diff ; } return ret ; } public static double times ( double [ ] nums ) { if ( nums = = null | | nums . length = = <int> ) return <int> ; double ret = <int> ; for ( int i = <int> ; i < nums . length ; i + + ) ret * = nums [ i ] ; return ret ; } public static double sumOfProducts ( double [ ] . . . nums ) { if ( nums = = null | | nums . length < <int> ) return <int> ; double sum = <int> ; for ( int i = <int> ; i < nums . length ; i + + ) { double [ ] column = column ( i , nums ) ; sum + = times ( column ) ; } return sum ; } private static double [ ] column ( int column , double [ ] . . . nums ) throws IllegalArgumentException { double [ ] ret = new double [ nums . length ] ; for ( int i = <int> ; i < nums . length ; i + + ) { double [ ] curr = nums [ i ] ; ret [ i ] = curr [ column ] ; } return ret ; } public static List < double [ ] > coordSplit ( double [ ] vector ) { if ( vector = = null ) return null ; List < double [ ] > ret = new ArrayList < double [ ] > ( ) ; double [ ] xVals = new double [ vector . length / <int> ] ; double [ ] yVals = new double [ vector . length / <int> ] ; int xTracker = <int> ; int yTracker = <int> ; for ( int i = <int> ; i < vector . length ; i + + ) { if ( i % <int> = = <int> ) xVals [ xTracker + + ] = vector [ i ] ; else yVals [ yTracker + + ] = vector [ i ] ; } ret . add ( xVals ) ; ret . add ( yVals ) ; return ret ; } public static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { int count = <int> ; List < List < Double > > ret = new ArrayList < List < Double > > ( ) ; while ( count < arr . size ( ) ) { List < Double > sublist = arr . subList ( count , count + chunk ) ; count + = chunk ; ret . add ( sublist ) ; } for ( List < Double > lists : ret ) { if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; } return ret ; } public static List < double [ ] > coordSplit ( List < Double > vector ) { if ( vector = = null ) return null ; List < double [ ] > ret = new ArrayList < double [ ] > ( ) ; double [ ] xVals = new double [ vector . size ( ) / <int> ] ; double [ ] yVals = new double [ vector . size ( ) / <int> ] ; int xTracker = <int> ; int yTracker = <int> ; for ( int i = <int> ; i < vector . size ( ) ; i + + ) { if ( i % <int> = = <int> ) xVals [ xTracker + + ] = vector . get ( i ) ; else yVals [ yTracker + + ] = vector . get ( i ) ; } ret . add ( xVals ) ; ret . add ( yVals ) ; return ret ; } public static double [ ] xVals ( double [ ] vector ) { if ( vector = = null ) return null ; double [ ] x = new double [ vector . length / <int> ] ; int count = <int> ; for ( int i = <int> ; i < vector . length ; i + + ) { if ( i % <int> ! = <int> ) x [ count + + ] = vector [ i ] ; } return x ; } public static double [ ] yVals ( double [ ] vector ) { double [ ] y = new double [ vector . length / <int> ] ; int count = <int> ; for ( int i = <int> ; i < vector . length ; i + + ) { if ( i % <int> = = <int> ) y [ count + + ] = vector [ i ] ; } return y ; } public static double sumOfSquares ( double [ ] vector ) { double ret = <int> ; for ( double d : vector ) ret + = Math . pow ( d , <int> ) ; return ret ; } public static double determinationCoefficient ( double [ ] y1 , double [ ] y2 , int n ) { return Math . pow ( correlation ( y1 , y2 ) , <int> ) ; } public static double log2 ( double a ) { if ( a = = <int> ) return <float> ; return Math . log ( a ) / log2 ; } public static double rootMeansSquaredError ( double [ ] real , double [ ] predicted ) { double ret = <int> / real . length ; for ( int i = <int> ; i < real . length ; i + + ) { ret + = Math . pow ( ( real [ i ] - predicted [ i ] ) , <int> ) ; } return Math . sqrt ( ret ) ; } public static double entropy ( double [ ] vector ) { if ( vector = = null ) return <int> ; else if ( vector . length < <int> ) return <int> ; else { double ret = <int> ; for ( double d : vector ) ret + = d * Math . log ( d ) ; return ret ; } } public static int kroneckerDelta ( double i , double j ) { return ( i = = j ) ? <int> : <int> ; } public static double adjustedrSquared ( double rSquared , int numRegressors , int numDataPoints ) { double divide = ( numDataPoints - <int> ) / ( numDataPoints - numRegressors - <int> ) ; double rSquaredDiff = <int> - rSquared ; return <int> - ( rSquaredDiff * divide ) ; } public static double [ ] normalizeToOne ( double [ ] doubles ) { normalize ( doubles , sum ( doubles ) ) ; return doubles ; } public static double min ( double [ ] doubles ) { double ret = doubles [ <int> ] ; for ( double d : doubles ) if ( d < ret ) ret = d ; return ret ; } public static double max ( double [ ] doubles ) { double ret = doubles [ <int> ] ; for ( double d : doubles ) if ( d > ret ) ret = d ; return ret ; } public static void normalize ( double [ ] doubles , double sum ) { if ( Double . isNaN ( sum ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( sum = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } for ( int i = <int> ; i < doubles . length ; i + + ) { doubles [ i ] / = sum ; } } public static double [ ] logs2probs ( double [ ] a ) { double max = a [ maxIndex ( a ) ] ; double sum = <float> ; double [ ] result = new double [ a . length ] ; for ( int i = <int> ; i < a . length ; i + + ) { result [ i ] = Math . exp ( a [ i ] - max ) ; sum + = result [ i ] ; } normalize ( result , sum ) ; return result ; } public static double information ( double [ ] probabilities ) { double total = <float> ; for ( double d : probabilities ) { total + = ( - <float> * log2 ( d ) * d ) ; } return total ; } public static int maxIndex ( double [ ] doubles ) { double maximum = <int> ; int maxIndex = <int> ; for ( int i = <int> ; i < doubles . length ; i + + ) { if ( ( i = = <int> ) | | ( doubles [ i ] > maximum ) ) { maxIndex = i ; maximum = doubles [ i ] ; } } return maxIndex ; } public static double factorial ( double n ) { if ( n = = <int> | | n = = <int> ) return <int> ; for ( double i = n ; i > <int> ; i - - , n * = ( i > <int> ? i : <int> ) ) { } return n ; } public static double probToLogOdds ( double prob ) { if ( gr ( prob , <int> ) | | ( sm ( prob , <int> ) ) ) { throw new IllegalArgumentException ( <str> + <str> + prob ) ; } double p = SMALL + ( <float> - <int> * SMALL ) * prob ; return Math . log ( p / ( <int> - p ) ) ; } public static int round ( double value ) { int roundedValue = value > <int> ? ( int ) ( value + <float> ) : - ( int ) ( Math . abs ( value ) + <float> ) ; return roundedValue ; } public static double permutation ( double n , double r ) { double nFac = MathUtils . factorial ( n ) ; double nMinusRFac = MathUtils . factorial ( ( n - r ) ) ; return nFac / nMinusRFac ; } public static double combination ( double n , double r ) { double nFac = MathUtils . factorial ( n ) ; double rFac = MathUtils . factorial ( r ) ; double nMinusRFac = MathUtils . factorial ( ( n - r ) ) ; return nFac / ( rFac * nMinusRFac ) ; } public static double hypotenuse ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( <int> + r * r ) ; } else if ( b ! = <int> ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( <int> + r * r ) ; } else { r = <float> ; } return r ; } public static int probRound ( double value , Random rand ) { if ( value > = <int> ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + <int> ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + <int> ) ; } else { return - ( int ) lower ; } } } public static double roundDouble ( double value , int afterDecimalPoint ) { double mask = Math . pow ( <float> , ( double ) afterDecimalPoint ) ; return ( double ) ( Math . round ( value * mask ) ) / mask ; } public static float roundFloat ( float value , int afterDecimalPoint ) { float mask = ( float ) Math . pow ( <int> , ( float ) afterDecimalPoint ) ; return ( float ) ( Math . round ( value * mask ) ) / mask ; } public static double bernoullis ( double n , double k , double successProb ) { double combo = MathUtils . combination ( n , k ) ; double p = successProb ; double q = <int> - successProb ; return combo * Math . pow ( p , k ) * Math . pow ( q , n - k ) ; } public static boolean sm ( double a , double b ) { return ( b - a > SMALL ) ; } public static boolean gr ( double a , double b ) { return ( a - b > SMALL ) ; } public static double [ ] fromString ( String data , String separator ) { String [ ] split = data . split ( separator ) ; double [ ] ret = new double [ split . length ] ; for ( int i = <int> ; i < split . length ; i + + ) { ret [ i ] = Double . parseDouble ( split [ i ] ) ; } return ret ; } public static double mean ( double [ ] vector ) { double sum = <int> ; if ( vector . length = = <int> ) { return <int> ; } for ( int i = <int> ; i < vector . length ; i + + ) { sum + = vector [ i ] ; } return sum / ( double ) vector . length ; } public static int toDecimal ( String binary ) { long num = Long . parseLong ( binary ) ; long rem ; while ( num > <int> ) { rem = num % <int> ; num = num / <int> ; if ( rem ! = <int> & & rem ! = <int> ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; return - <int> ; } } int i = Integer . parseInt ( binary , <int> ) ; return i ; } public static int distanceFinderZValue ( double [ ] vector ) { StringBuffer binaryBuffer = new StringBuffer ( ) ; List < String > binaryReps = new ArrayList < String > ( vector . length ) ; for ( int i = <int> ; i < vector . length ; i + + ) { double d = vector [ i ] ; int j = ( int ) d ; String binary = Integer . toBinaryString ( j ) ; binaryReps . add ( binary ) ; } while ( ! binaryReps . isEmpty ( ) ) { for ( int j = <int> ; j < binaryReps . size ( ) ; j + + ) { String curr = binaryReps . get ( j ) ; if ( ! curr . isEmpty ( ) ) { char first = curr . charAt ( <int> ) ; binaryBuffer . append ( first ) ; curr = curr . substring ( <int> ) ; binaryReps . set ( j , curr ) ; } else binaryReps . remove ( j ) ; } } return Integer . parseInt ( binaryBuffer . toString ( ) , <int> ) ; } public static double euclideanDistance ( double [ ] p , double [ ] q ) { double ret = <int> ; for ( int i = <int> ; i < p . length ; i + + ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , <int> ) ; ret + = sq ; } return ret ; } public static double euclideanDistance ( float [ ] p , float [ ] q ) { double ret = <int> ; for ( int i = <int> ; i < p . length ; i + + ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , <int> ) ; ret + = sq ; } return ret ; } public static double [ ] generateUniform ( int l ) { double [ ] ret = new double [ l ] ; Random rgen = new Random ( ) ; for ( int i = <int> ; i < l ; i + + ) { ret [ i ] = rgen . nextDouble ( ) ; } return ret ; } public static double manhattanDistance ( double [ ] p , double [ ] q ) { double ret = <int> ; for ( int i = <int> ; i < p . length ; i + + ) { double difference = p [ i ] - q [ i ] ; ret + = Math . abs ( difference ) ; } return ret ; } public static double [ ] sampleDoublesInInterval ( double [ ] [ ] doubles , int l ) { double [ ] sample = new double [ l ] ; for ( int i = <int> ; i < l ; i + + ) { int rand1 = randomNumberBetween ( <int> , doubles . length - <int> ) ; int rand2 = randomNumberBetween ( <int> , doubles [ i ] . length ) ; sample [ i ] = doubles [ rand1 ] [ rand2 ] ; } return sample ; } public static int randomNumberBetween ( double begin , double end ) { if ( begin > end ) throw new IllegalArgumentException ( <str> ) ; return ( int ) begin + ( int ) ( Math . random ( ) * ( ( end - begin ) + <int> ) ) ; } public static int randomNumberBetween ( double begin , double end , RandomGenerator rng ) { if ( begin > end ) throw new IllegalArgumentException ( <str> ) ; return ( int ) begin + ( int ) ( rng . nextDouble ( ) * ( ( end - begin ) + <int> ) ) ; } public static float randomFloatBetween ( float begin , float end ) { float rand = ( float ) Math . random ( ) ; return begin + ( rand * ( ( end - begin ) ) ) ; } public static double randomDoubleBetween ( double begin , double end ) { return begin + ( Math . random ( ) * ( ( end - begin ) ) ) ; } public double slope ( double x1 , double x2 , double y1 , double y2 ) { return ( y2 - y1 ) / ( x2 - x1 ) ; } } 
