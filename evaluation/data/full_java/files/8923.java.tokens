package org . elasticsearch . common . cli ; import com . google . common . jimfs . Configuration ; import com . google . common . jimfs . Jimfs ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . env . Environment ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . nio . file . FileSystem ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . attribute . GroupPrincipal ; import java . nio . file . attribute . PosixFileAttributeView ; import java . nio . file . attribute . PosixFileAttributes ; import java . nio . file . attribute . PosixFilePermission ; import java . nio . file . attribute . UserPrincipal ; import java . util . Set ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . hasItem ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; public class CheckFileCommandTests extends ESTestCase { private CliToolTestCase . CaptureOutputTerminal captureOutputTerminal = new CliToolTestCase . CaptureOutputTerminal ( ) ; private Configuration jimFsConfiguration = Configuration . unix ( ) . toBuilder ( ) . setAttributeViews ( <str> , <str> , <str> , <str> ) . build ( ) ; private Configuration jimFsConfigurationWithoutPermissions = randomBoolean ( ) ? Configuration . unix ( ) . toBuilder ( ) . setAttributeViews ( <str> ) . build ( ) : Configuration . windows ( ) ; private enum Mode { CHANGE , KEEP , DISABLED } public void testThatCommandLogsErrorMessageOnFail ( ) throws Exception { executeCommand ( jimFsConfiguration , new PermissionCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . CHANGE ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testThatCommandLogsNothingWhenPermissionRemains ( ) throws Exception { executeCommand ( jimFsConfiguration , new PermissionCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . KEEP ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingWhenDisabled ( ) throws Exception { executeCommand ( jimFsConfiguration , new PermissionCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingIfFilesystemDoesNotSupportPermissions ( ) throws Exception { executeCommand ( jimFsConfigurationWithoutPermissions , new PermissionCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsOwnerChange ( ) throws Exception { executeCommand ( jimFsConfiguration , new OwnerCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . CHANGE ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasItem ( allOf ( containsString ( <str> ) , containsString ( <str> ) , containsString ( <str> ) ) ) ) ; } public void testThatCommandLogsNothingIfOwnerRemainsSame ( ) throws Exception { executeCommand ( jimFsConfiguration , new OwnerCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . KEEP ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingIfOwnerIsDisabled ( ) throws Exception { executeCommand ( jimFsConfiguration , new OwnerCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingIfFileSystemDoesNotSupportOwners ( ) throws Exception { executeCommand ( jimFsConfigurationWithoutPermissions , new OwnerCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsIfGroupChanges ( ) throws Exception { executeCommand ( jimFsConfiguration , new GroupCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . CHANGE ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasItem ( allOf ( containsString ( <str> ) , containsString ( <str> ) , containsString ( <str> ) ) ) ) ; } public void testThatCommandLogsNothingIfGroupRemainsSame ( ) throws Exception { executeCommand ( jimFsConfiguration , new GroupCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . KEEP ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingIfGroupIsDisabled ( ) throws Exception { executeCommand ( jimFsConfiguration , new GroupCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandLogsNothingIfFileSystemDoesNotSupportGroups ( ) throws Exception { executeCommand ( jimFsConfigurationWithoutPermissions , new GroupCheckFileCommand ( createTempDir ( ) , captureOutputTerminal , Mode . DISABLED ) ) ; assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandDoesNotLogAnythingOnFileCreation ( ) throws Exception { Configuration configuration = randomBoolean ( ) ? jimFsConfiguration : jimFsConfigurationWithoutPermissions ; try ( FileSystem fs = Jimfs . newFileSystem ( configuration ) ) { Path path = fs . getPath ( randomAsciiOfLength ( <int> ) ) ; Settings settings = Settings . builder ( ) . put ( <str> , createTempDir ( ) . toString ( ) ) . build ( ) ; new CreateFileCommand ( captureOutputTerminal , path ) . execute ( settings , new Environment ( settings ) ) ; assertThat ( Files . exists ( path ) , is ( true ) ) ; } assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } public void testThatCommandWorksIfFileIsDeletedByCommand ( ) throws Exception { Configuration configuration = randomBoolean ( ) ? jimFsConfiguration : jimFsConfigurationWithoutPermissions ; try ( FileSystem fs = Jimfs . newFileSystem ( configuration ) ) { Path path = fs . getPath ( randomAsciiOfLength ( <int> ) ) ; Files . write ( path , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; Settings settings = Settings . builder ( ) . put ( <str> , createTempDir ( ) . toString ( ) ) . build ( ) ; new DeleteFileCommand ( captureOutputTerminal , path ) . execute ( settings , new Environment ( settings ) ) ; assertThat ( Files . exists ( path ) , is ( false ) ) ; } assertThat ( captureOutputTerminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; } private void executeCommand ( Configuration configuration , AbstractTestCheckFileCommand command ) throws Exception { try ( FileSystem fs = Jimfs . newFileSystem ( configuration ) ) { command . execute ( fs ) ; } } abstract class AbstractTestCheckFileCommand extends CheckFileCommand { protected final Mode mode ; protected FileSystem fs ; protected Path [ ] paths ; final Path baseDir ; public AbstractTestCheckFileCommand ( Path baseDir , Terminal terminal , Mode mode ) throws IOException { super ( terminal ) ; this . mode = mode ; this . baseDir = baseDir ; } public CliTool . ExitStatus execute ( FileSystem fs ) throws Exception { this . fs = fs ; this . paths = new Path [ ] { writePath ( fs , <str> , <str> ) , writePath ( fs , <str> , <str> ) , writePath ( fs , <str> , <str> ) } ; Settings settings = Settings . settingsBuilder ( ) . put ( <str> , baseDir . toString ( ) ) . build ( ) ; return super . execute ( Settings . EMPTY , new Environment ( settings ) ) ; } private Path writePath ( FileSystem fs , String name , String content ) throws IOException { Path path = fs . getPath ( name ) ; Files . write ( path , content . getBytes ( StandardCharsets . UTF_8 ) ) ; return path ; } @Override protected Path [ ] pathsForPermissionsCheck ( Settings settings , Environment env ) { return paths ; } } class PermissionCheckFileCommand extends AbstractTestCheckFileCommand { public PermissionCheckFileCommand ( Path baseDir , Terminal terminal , Mode mode ) throws IOException { super ( baseDir , terminal , mode ) ; } @Override public CliTool . ExitStatus doExecute ( Settings settings , Environment env ) throws Exception { int randomInt = randomInt ( paths . length - <int> ) ; Path randomPath = paths [ randomInt ] ; switch ( mode ) { case CHANGE : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; Files . setPosixFilePermissions ( randomPath , Sets . newHashSet ( PosixFilePermission . OWNER_EXECUTE , PosixFilePermission . OTHERS_EXECUTE , PosixFilePermission . GROUP_EXECUTE ) ) ; break ; case KEEP : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; Set < PosixFilePermission > posixFilePermissions = Files . getPosixFilePermissions ( randomPath ) ; Files . setPosixFilePermissions ( randomPath , posixFilePermissions ) ; break ; } return CliTool . ExitStatus . OK ; } } class OwnerCheckFileCommand extends AbstractTestCheckFileCommand { public OwnerCheckFileCommand ( Path baseDir , Terminal terminal , Mode mode ) throws IOException { super ( baseDir , terminal , mode ) ; } @Override public CliTool . ExitStatus doExecute ( Settings settings , Environment env ) throws Exception { int randomInt = randomInt ( paths . length - <int> ) ; Path randomPath = paths [ randomInt ] ; switch ( mode ) { case CHANGE : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; UserPrincipal randomOwner = fs . getUserPrincipalLookupService ( ) . lookupPrincipalByName ( randomAsciiOfLength ( <int> ) ) ; Files . setOwner ( randomPath , randomOwner ) ; break ; case KEEP : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; UserPrincipal originalOwner = Files . getOwner ( randomPath ) ; Files . setOwner ( randomPath , originalOwner ) ; break ; } return CliTool . ExitStatus . OK ; } } class GroupCheckFileCommand extends AbstractTestCheckFileCommand { public GroupCheckFileCommand ( Path baseDir , Terminal terminal , Mode mode ) throws IOException { super ( baseDir , terminal , mode ) ; } @Override public CliTool . ExitStatus doExecute ( Settings settings , Environment env ) throws Exception { int randomInt = randomInt ( paths . length - <int> ) ; Path randomPath = paths [ randomInt ] ; switch ( mode ) { case CHANGE : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; GroupPrincipal randomPrincipal = fs . getUserPrincipalLookupService ( ) . lookupPrincipalByGroupName ( randomAsciiOfLength ( <int> ) ) ; Files . getFileAttributeView ( randomPath , PosixFileAttributeView . class ) . setGroup ( randomPrincipal ) ; break ; case KEEP : Files . write ( randomPath , randomAsciiOfLength ( <int> ) . getBytes ( StandardCharsets . UTF_8 ) ) ; GroupPrincipal groupPrincipal = Files . readAttributes ( randomPath , PosixFileAttributes . class ) . group ( ) ; Files . getFileAttributeView ( randomPath , PosixFileAttributeView . class ) . setGroup ( groupPrincipal ) ; break ; } return CliTool . ExitStatus . OK ; } } class CreateFileCommand extends CheckFileCommand { private final Path pathToCreate ; public CreateFileCommand ( Terminal terminal , Path pathToCreate ) { super ( terminal ) ; this . pathToCreate = pathToCreate ; } @Override public CliTool . ExitStatus doExecute ( Settings settings , Environment env ) throws Exception { Files . write ( pathToCreate , <str> . getBytes ( StandardCharsets . UTF_8 ) ) ; return CliTool . ExitStatus . OK ; } @Override protected Path [ ] pathsForPermissionsCheck ( Settings settings , Environment env ) throws Exception { return new Path [ ] { pathToCreate } ; } } class DeleteFileCommand extends CheckFileCommand { private final Path pathToDelete ; public DeleteFileCommand ( Terminal terminal , Path pathToDelete ) { super ( terminal ) ; this . pathToDelete = pathToDelete ; } @Override public CliTool . ExitStatus doExecute ( Settings settings , Environment env ) throws Exception { Files . delete ( pathToDelete ) ; return CliTool . ExitStatus . OK ; } @Override protected Path [ ] pathsForPermissionsCheck ( Settings settings , Environment env ) throws Exception { return new Path [ ] { pathToDelete } ; } } } 
