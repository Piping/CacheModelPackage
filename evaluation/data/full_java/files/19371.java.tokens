package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMessage ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http2 . Http2CodecUtil . SimpleChannelPromiseAggregator ; import io . netty . util . ReferenceCountUtil ; public class HttpToHttp2ConnectionHandler extends Http2ConnectionHandler { private final boolean validateHeaders ; private int currentStreamId ; public static final class Builder extends BuilderBase < HttpToHttp2ConnectionHandler , Builder > { @Override public HttpToHttp2ConnectionHandler build0 ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder ) { return new HttpToHttp2ConnectionHandler ( decoder , encoder , initialSettings ( ) , isValidateHeaders ( ) ) ; } } protected HttpToHttp2ConnectionHandler ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder , Http2Settings initialSettings , boolean validateHeaders ) { super ( decoder , encoder , initialSettings ) ; this . validateHeaders = validateHeaders ; } private int getStreamId ( HttpHeaders httpHeaders ) throws Exception { return httpHeaders . getInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , connection ( ) . local ( ) . nextStreamId ( ) ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) { if ( ! ( msg instanceof HttpMessage | | msg instanceof HttpContent ) ) { ctx . write ( msg , promise ) ; return ; } boolean release = true ; SimpleChannelPromiseAggregator promiseAggregator = new SimpleChannelPromiseAggregator ( promise , ctx . channel ( ) , ctx . executor ( ) ) ; try { Http2ConnectionEncoder encoder = encoder ( ) ; boolean endStream = false ; if ( msg instanceof HttpMessage ) { final HttpMessage httpMsg = ( HttpMessage ) msg ; currentStreamId = getStreamId ( httpMsg . headers ( ) ) ; Http2Headers http2Headers = HttpConversionUtil . toHttp2Headers ( httpMsg , validateHeaders ) ; endStream = msg instanceof FullHttpMessage & & ! ( ( FullHttpMessage ) msg ) . content ( ) . isReadable ( ) ; encoder . writeHeaders ( ctx , currentStreamId , http2Headers , <int> , endStream , promiseAggregator . newPromise ( ) ) ; } if ( ! endStream & & msg instanceof HttpContent ) { boolean isLastContent = false ; Http2Headers trailers = EmptyHttp2Headers . INSTANCE ; if ( msg instanceof LastHttpContent ) { isLastContent = true ; final LastHttpContent lastContent = ( LastHttpContent ) msg ; trailers = HttpConversionUtil . toHttp2Headers ( lastContent . trailingHeaders ( ) , validateHeaders ) ; } final ByteBuf content = ( ( HttpContent ) msg ) . content ( ) ; endStream = isLastContent & & trailers . isEmpty ( ) ; release = false ; encoder . writeData ( ctx , currentStreamId , content , <int> , endStream , promiseAggregator . newPromise ( ) ) ; if ( ! trailers . isEmpty ( ) ) { encoder . writeHeaders ( ctx , currentStreamId , trailers , <int> , true , promiseAggregator . newPromise ( ) ) ; } } promiseAggregator . doneAllocatingPromises ( ) ; } catch ( Throwable t ) { promiseAggregator . setFailure ( t ) ; } finally { if ( release ) { ReferenceCountUtil . release ( msg ) ; } } } } 
