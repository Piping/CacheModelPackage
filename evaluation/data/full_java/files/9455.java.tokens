package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . math . DoubleUtils . IMPLICIT_BIT ; import static com . google . common . math . DoubleUtils . SIGNIFICAND_BITS ; import static com . google . common . math . DoubleUtils . getSignificand ; import static com . google . common . math . DoubleUtils . isFinite ; import static com . google . common . math . DoubleUtils . isNormal ; import static com . google . common . math . DoubleUtils . scaleNormalize ; import static com . google . common . math . MathPreconditions . checkInRange ; import static com . google . common . math . MathPreconditions . checkNonNegative ; import static com . google . common . math . MathPreconditions . checkRoundingUnnecessary ; import static java . lang . Math . abs ; import static java . lang . Math . copySign ; import static java . lang . Math . getExponent ; import static java . lang . Math . log ; import static java . lang . Math . rint ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . primitives . Booleans ; import java . math . BigInteger ; import java . math . RoundingMode ; import java . util . Iterator ; @GwtCompatible ( emulated = true ) public final class DoubleMath { @GwtIncompatible ( <str> ) static double roundIntermediate ( double x , RoundingMode mode ) { if ( ! isFinite ( x ) ) { throw new ArithmeticException ( <str> ) ; } switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( isMathematicalInteger ( x ) ) ; return x ; case FLOOR : if ( x > = <float> | | isMathematicalInteger ( x ) ) { return x ; } else { return x - <float> ; } case CEILING : if ( x < = <float> | | isMathematicalInteger ( x ) ) { return x ; } else { return x + <float> ; } case DOWN : return x ; case UP : if ( isMathematicalInteger ( x ) ) { return x ; } else { return x + Math . copySign ( <float> , x ) ; } case HALF_EVEN : return rint ( x ) ; case HALF_UP : { double z = rint ( x ) ; if ( abs ( x - z ) = = <float> ) { return x + copySign ( <float> , x ) ; } else { return z ; } } case HALF_DOWN : { double z = rint ( x ) ; if ( abs ( x - z ) = = <float> ) { return x ; } else { return z ; } } default: throw new AssertionError ( ) ; } } @GwtIncompatible ( <str> ) public static int roundToInt ( double x , RoundingMode mode ) { double z = roundIntermediate ( x , mode ) ; checkInRange ( z > MIN_INT_AS_DOUBLE - <float> & z < MAX_INT_AS_DOUBLE + <float> ) ; return ( int ) z ; } private static final double MIN_INT_AS_DOUBLE = - <float> ; private static final double MAX_INT_AS_DOUBLE = <float> - <float> ; @GwtIncompatible ( <str> ) public static long roundToLong ( double x , RoundingMode mode ) { double z = roundIntermediate ( x , mode ) ; checkInRange ( MIN_LONG_AS_DOUBLE - z < <float> & z < MAX_LONG_AS_DOUBLE_PLUS_ONE ) ; return ( long ) z ; } private static final double MIN_LONG_AS_DOUBLE = - <float> ; private static final double MAX_LONG_AS_DOUBLE_PLUS_ONE = <float> ; @GwtIncompatible ( <str> + <str> ) public static BigInteger roundToBigInteger ( double x , RoundingMode mode ) { x = roundIntermediate ( x , mode ) ; if ( MIN_LONG_AS_DOUBLE - x < <float> & x < MAX_LONG_AS_DOUBLE_PLUS_ONE ) { return BigInteger . valueOf ( ( long ) x ) ; } int exponent = getExponent ( x ) ; long significand = getSignificand ( x ) ; BigInteger result = BigInteger . valueOf ( significand ) . shiftLeft ( exponent - SIGNIFICAND_BITS ) ; return ( x < <int> ) ? result . negate ( ) : result ; } @GwtIncompatible ( <str> ) public static boolean isPowerOfTwo ( double x ) { return x > <float> & & isFinite ( x ) & & LongMath . isPowerOfTwo ( getSignificand ( x ) ) ; } public static double log2 ( double x ) { return log ( x ) / LN_2 ; } private static final double LN_2 = log ( <int> ) ; @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static int log2 ( double x , RoundingMode mode ) { checkArgument ( x > <float> & & isFinite ( x ) , <str> ) ; int exponent = getExponent ( x ) ; if ( ! isNormal ( x ) ) { return log2 ( x * IMPLICIT_BIT , mode ) - SIGNIFICAND_BITS ; } boolean increment ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; case FLOOR : increment = false ; break ; case CEILING : increment = ! isPowerOfTwo ( x ) ; break ; case DOWN : increment = exponent < <int> & ! isPowerOfTwo ( x ) ; break ; case UP : increment = exponent > = <int> & ! isPowerOfTwo ( x ) ; break ; case HALF_DOWN : case HALF_EVEN : case HALF_UP : double xScaled = scaleNormalize ( x ) ; increment = ( xScaled * xScaled ) > <float> ; break ; default : throw new AssertionError ( ) ; } return increment ? exponent + <int> : exponent ; } @GwtIncompatible ( <str> ) public static boolean isMathematicalInteger ( double x ) { return isFinite ( x ) & & ( x = = <float> | | SIGNIFICAND_BITS - Long . numberOfTrailingZeros ( getSignificand ( x ) ) < = getExponent ( x ) ) ; } public static double factorial ( int n ) { checkNonNegative ( <str> , n ) ; if ( n > MAX_FACTORIAL ) { return Double . POSITIVE_INFINITY ; } else { double accum = <float> ; for ( int i = <int> + ( n & ~ <hex> ) ; i < = n ; i + + ) { accum * = i ; } return accum * everySixteenthFactorial [ n > > <int> ] ; } } @VisibleForTesting static final int MAX_FACTORIAL = <int> ; @VisibleForTesting static final double [ ] everySixteenthFactorial = { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } ; public static boolean fuzzyEquals ( double a , double b , double tolerance ) { MathPreconditions . checkNonNegative ( <str> , tolerance ) ; return Math . copySign ( a - b , <float> ) < = tolerance | | ( a = = b ) | | ( Double . isNaN ( a ) & & Double . isNaN ( b ) ) ; } public static int fuzzyCompare ( double a , double b , double tolerance ) { if ( fuzzyEquals ( a , b , tolerance ) ) { return <int> ; } else if ( a < b ) { return - <int> ; } else if ( a > b ) { return <int> ; } else { return Booleans . compare ( Double . isNaN ( a ) , Double . isNaN ( b ) ) ; } } @GwtIncompatible ( <str> ) public static double mean ( double . . . values ) { checkArgument ( values . length > <int> , <str> ) ; long count = <int> ; double mean = checkFinite ( values [ <int> ] ) ; for ( int index = <int> ; index < values . length ; + + index ) { checkFinite ( values [ index ] ) ; count + + ; mean + = ( values [ index ] - mean ) / count ; } return mean ; } public static double mean ( int . . . values ) { checkArgument ( values . length > <int> , <str> ) ; long sum = <int> ; for ( int index = <int> ; index < values . length ; + + index ) { sum + = values [ index ] ; } return ( double ) sum / values . length ; } public static double mean ( long . . . values ) { checkArgument ( values . length > <int> , <str> ) ; long count = <int> ; double mean = values [ <int> ] ; for ( int index = <int> ; index < values . length ; + + index ) { count + + ; mean + = ( values [ index ] - mean ) / count ; } return mean ; } @GwtIncompatible ( <str> ) public static double mean ( Iterable < ? extends Number > values ) { return mean ( values . iterator ( ) ) ; } @GwtIncompatible ( <str> ) public static double mean ( Iterator < ? extends Number > values ) { checkArgument ( values . hasNext ( ) , <str> ) ; long count = <int> ; double mean = checkFinite ( values . next ( ) . doubleValue ( ) ) ; while ( values . hasNext ( ) ) { double value = checkFinite ( values . next ( ) . doubleValue ( ) ) ; count + + ; mean + = ( value - mean ) / count ; } return mean ; } @GwtIncompatible ( <str> ) private static double checkFinite ( double argument ) { checkArgument ( isFinite ( argument ) ) ; return argument ; } private DoubleMath ( ) { } } 
