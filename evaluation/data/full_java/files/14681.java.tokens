package org . gradle . language . base . plugins ; import com . google . common . collect . Lists ; import org . gradle . api . * ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . internal . project . taskfactory . ITaskFactory ; import org . gradle . api . tasks . TaskContainer ; import org . gradle . internal . BiAction ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . internal . text . TreeFormatter ; import org . gradle . language . base . LanguageSourceSet ; import org . gradle . language . base . ProjectSourceSet ; import org . gradle . language . base . internal . DefaultProjectSourceSet ; import org . gradle . language . base . internal . LanguageSourceSetFactory ; import org . gradle . language . base . internal . LanguageSourceSetInternal ; import org . gradle . language . base . internal . model . ComponentSpecInitializer ; import org . gradle . language . base . sources . BaseLanguageSourceSet ; import org . gradle . model . * ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . manage . schema . extract . FactoryBasedNodeInitializerExtractionStrategy ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . platform . base . * ; import org . gradle . platform . base . binary . BaseBinarySpec ; import org . gradle . platform . base . internal . BinarySpecInternal ; import javax . inject . Inject ; import java . util . List ; import java . util . Set ; import static org . gradle . model . internal . core . NodePredicate . allLinks ; import static org . gradle . model . internal . core . NodePredicate . allLinksTransitive ; @Incubating public class LanguageBasePlugin implements Plugin < Project > { private final ModelRegistry modelRegistry ; @Inject public LanguageBasePlugin ( ModelRegistry modelRegistry ) { this . modelRegistry = modelRegistry ; } public void apply ( final Project target ) { target . getPluginManager ( ) . apply ( LifecycleBasePlugin . class ) ; applyRules ( modelRegistry ) ; } private void applyRules ( ModelRegistry modelRegistry ) { final String baseDescriptor = LanguageBasePlugin . class . getSimpleName ( ) + <str> ; modelRegistry . configure ( ModelActionRole . Defaults , DirectNodeNoInputsModelAction . of ( ModelReference . of ( <str> ) , new SimpleModelRuleDescriptor ( baseDescriptor + <str> ) , new Action < MutableModelNode > ( ) { @Override public void execute ( MutableModelNode binariesNode ) { binariesNode . applyTo ( allLinks ( ) , ModelActionRole . Finalize , InputUsingModelAction . single ( ModelReference . of ( BinarySpecInternal . class ) , new SimpleModelRuleDescriptor ( baseDescriptor + <str> ) , ModelReference . of ( ITaskFactory . class ) , new BiAction < BinarySpecInternal , ITaskFactory > ( ) { @Override public void execute ( BinarySpecInternal binary , ITaskFactory taskFactory ) { if ( ! binary . isLegacyBinary ( ) ) { TaskInternal binaryLifecycleTask = taskFactory . create ( binary . getProjectScopedName ( ) , DefaultTask . class ) ; binaryLifecycleTask . setGroup ( LifecycleBasePlugin . BUILD_GROUP ) ; binaryLifecycleTask . setDescription ( String . format ( <str> , binary ) ) ; binary . setBuildTask ( binaryLifecycleTask ) ; } } } ) ) ; } } ) ) ; modelRegistry . getRoot ( ) . applyTo ( allLinksTransitive ( ) , ModelActionRole . Defaults , DirectNodeNoInputsModelAction . of ( ModelReference . of ( BinarySpec . class ) , new SimpleModelRuleDescriptor ( baseDescriptor + ComponentSpecInitializer . class . getSimpleName ( ) + <str> ) , ComponentSpecInitializer . binaryAction ( ) ) ) ; } @SuppressWarnings ( <str> ) static class Rules extends RuleSource { @Hidden @Model LanguageSourceSetFactory languageSourceSetFactory ( ServiceRegistry serviceRegistry ) { return new LanguageSourceSetFactory ( <str> , serviceRegistry . get ( FileResolver . class ) ) ; } @Model void binaries ( BinaryContainer binaries ) { } @BinaryType void registerBaseBinarySpec ( BinaryTypeBuilder < BinarySpec > builder ) { builder . defaultImplementation ( BaseBinarySpec . class ) ; builder . internalView ( BinarySpecInternal . class ) ; } @LanguageType void registerBaseLanguageSourceSet ( LanguageTypeBuilder < LanguageSourceSet > builder ) { builder . defaultImplementation ( BaseLanguageSourceSet . class ) ; builder . internalView ( LanguageSourceSetInternal . class ) ; } @Mutate void registerSourceSetNodeInitializer ( NodeInitializerRegistry nodeInitializerRegistry , LanguageSourceSetFactory languageSourceSetFactory ) { nodeInitializerRegistry . registerStrategy ( new FactoryBasedNodeInitializerExtractionStrategy < LanguageSourceSet > ( languageSourceSetFactory ) ) ; } @Model ProjectSourceSet sources ( ServiceRegistry serviceRegistry ) { return serviceRegistry . get ( Instantiator . class ) . newInstance ( DefaultProjectSourceSet . class ) ; } @Validate void validateLanguageSourceSetRegistrations ( LanguageSourceSetFactory instanceFactory ) { instanceFactory . validateRegistrations ( ) ; } @Mutate void copyBinaryTasksToTaskContainer ( TaskContainer tasks , ModelMap < BinarySpec > binaries ) { for ( BinarySpec binary : binaries ) { tasks . addAll ( binary . getTasks ( ) ) ; Task buildTask = binary . getBuildTask ( ) ; if ( buildTask ! = null ) { tasks . add ( buildTask ) ; } } } @Mutate void attachBinariesToAssembleLifecycle ( @Path ( <str> ) Task assemble , ModelMap < BinarySpecInternal > binaries ) { List < BinarySpecInternal > notBuildable = Lists . newArrayList ( ) ; boolean hasBuildableBinaries = false ; for ( BinarySpecInternal binary : binaries ) { if ( ! binary . isLegacyBinary ( ) ) { if ( binary . isBuildable ( ) ) { assemble . dependsOn ( binary ) ; hasBuildableBinaries = true ; } else { notBuildable . add ( binary ) ; } } } if ( ! hasBuildableBinaries & & ! notBuildable . isEmpty ( ) ) { assemble . doFirst ( new CheckForNotBuildableBinariesAction ( notBuildable ) ) ; } } private static class CheckForNotBuildableBinariesAction implements Action < Task > { private final List < BinarySpecInternal > notBuildable ; public CheckForNotBuildableBinariesAction ( List < BinarySpecInternal > notBuildable ) { this . notBuildable = notBuildable ; } @Override public void execute ( Task task ) { Set < ? extends Task > taskDependencies = task . getTaskDependencies ( ) . getDependencies ( task ) ; if ( taskDependencies . isEmpty ( ) ) { TreeFormatter formatter = new TreeFormatter ( ) ; formatter . node ( <str> ) ; formatter . startChildren ( ) ; for ( BinarySpecInternal binary : notBuildable ) { formatter . node ( binary . getDisplayName ( ) ) ; formatter . startChildren ( ) ; binary . getBuildAbility ( ) . explain ( formatter ) ; formatter . endChildren ( ) ; } formatter . endChildren ( ) ; throw new GradleException ( formatter . toString ( ) ) ; } } } } } 
