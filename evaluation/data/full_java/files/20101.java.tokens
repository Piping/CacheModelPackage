package io . netty . resolver ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . Closeable ; import java . net . SocketAddress ; import java . util . IdentityHashMap ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; public abstract class NameResolverGroup < T extends SocketAddress > implements Closeable { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( NameResolverGroup . class ) ; private final Map < EventExecutor , NameResolver < T > > resolvers = new IdentityHashMap < EventExecutor , NameResolver < T > > ( ) ; protected NameResolverGroup ( ) { } public NameResolver < T > getResolver ( final EventExecutor executor ) { if ( executor = = null ) { throw new NullPointerException ( <str> ) ; } if ( executor . isShuttingDown ( ) ) { throw new IllegalStateException ( <str> ) ; } NameResolver < T > r ; synchronized ( resolvers ) { r = resolvers . get ( executor ) ; if ( r = = null ) { final NameResolver < T > newResolver ; try { newResolver = newResolver ( executor ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> , e ) ; } resolvers . put ( executor , newResolver ) ; executor . terminationFuture ( ) . addListener ( new FutureListener < Object > ( ) { @Override public void operationComplete ( Future < Object > future ) throws Exception { resolvers . remove ( executor ) ; newResolver . close ( ) ; } } ) ; r = newResolver ; } } return r ; } protected abstract NameResolver < T > newResolver ( EventExecutor executor ) throws Exception ; @Override @SuppressWarnings ( { <str> , <str> } ) public void close ( ) { final NameResolver < T > [ ] rArray ; synchronized ( resolvers ) { rArray = ( NameResolver < T > [ ] ) resolvers . values ( ) . toArray ( new NameResolver [ resolvers . size ( ) ] ) ; resolvers . clear ( ) ; } for ( NameResolver < T > r : rArray ) { try { r . close ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } } 
