package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class FastLzIntegrationTest extends AbstractIntegrationTest { public static class TestWithChecksum extends AbstractIntegrationTest { @Override protected EmbeddedChannel createEncoder ( ) { return new EmbeddedChannel ( new FastLzFrameEncoder ( true ) ) ; } @Override protected EmbeddedChannel createDecoder ( ) { return new EmbeddedChannel ( new FastLzFrameDecoder ( true ) ) ; } } public static class TestRandomChecksum extends AbstractIntegrationTest { @Override protected EmbeddedChannel createEncoder ( ) { return new EmbeddedChannel ( new FastLzFrameEncoder ( rand . nextBoolean ( ) ) ) ; } @Override protected EmbeddedChannel createDecoder ( ) { return new EmbeddedChannel ( new FastLzFrameDecoder ( rand . nextBoolean ( ) ) ) ; } } @Override protected EmbeddedChannel createEncoder ( ) { return new EmbeddedChannel ( new FastLzFrameEncoder ( rand . nextBoolean ( ) ) ) ; } @Override protected EmbeddedChannel createDecoder ( ) { return new EmbeddedChannel ( new FastLzFrameDecoder ( rand . nextBoolean ( ) ) ) ; } @Override protected void testIdentity ( final byte [ ] data ) { final ByteBuf original = Unpooled . wrappedBuffer ( data ) ; int written = <int> , length = rand . nextInt ( <int> ) ; while ( written + length < data . length ) { ByteBuf in = Unpooled . wrappedBuffer ( data , written , length ) ; encoder . writeOutbound ( in ) ; written + = length ; length = rand . nextInt ( <int> ) ; } ByteBuf in = Unpooled . wrappedBuffer ( data , written , data . length - written ) ; encoder . writeOutbound ( in ) ; encoder . finish ( ) ; ByteBuf msg ; final CompositeByteBuf compressed = Unpooled . compositeBuffer ( ) ; while ( ( msg = encoder . readOutbound ( ) ) ! = null ) { compressed . addComponent ( msg ) ; compressed . writerIndex ( compressed . writerIndex ( ) + msg . readableBytes ( ) ) ; } assertThat ( compressed , is ( notNullValue ( ) ) ) ; final byte [ ] compressedArray = new byte [ compressed . readableBytes ( ) ] ; compressed . readBytes ( compressedArray ) ; written = <int> ; length = rand . nextInt ( <int> ) ; while ( written + length < compressedArray . length ) { in = Unpooled . wrappedBuffer ( compressedArray , written , length ) ; decoder . writeInbound ( in ) ; written + = length ; length = rand . nextInt ( <int> ) ; } in = Unpooled . wrappedBuffer ( compressedArray , written , compressedArray . length - written ) ; decoder . writeInbound ( in ) ; assertFalse ( compressed . isReadable ( ) ) ; final CompositeByteBuf decompressed = Unpooled . compositeBuffer ( ) ; while ( ( msg = decoder . readInbound ( ) ) ! = null ) { decompressed . addComponent ( msg ) ; decompressed . writerIndex ( decompressed . writerIndex ( ) + msg . readableBytes ( ) ) ; } assertEquals ( original , decompressed ) ; compressed . release ( ) ; decompressed . release ( ) ; original . release ( ) ; } } 
