package org . nd4j . linalg . jcublas . gpumetrics ; import jcuda . Sizeof ; import jcuda . driver . CUoccupancyB2DSize ; import jcuda . driver . JCudaDriver ; import jcuda . runtime . cudaDeviceProp ; import jcuda . utils . KernelLauncher ; import lombok . AllArgsConstructor ; import lombok . Data ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . jcublas . kernel . KernelFunctionLoader ; import static jcuda . runtime . JCuda . * ; import org . nd4j . linalg . jcublas . util . PointerUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; @Data @AllArgsConstructor public class GpuMetrics { public GpuMetrics ( ) { } private static Logger log = LoggerFactory . getLogger ( GpuMetrics . class ) ; public final static int MAX_THREADS = <int> ; public final static int MAX_BLOCKS = <int> ; private int gridSize , blockSize , sharedMemory ; private static CUoccupancyB2DSize DOUBLE = new CUoccupancyB2DSize ( ) { @Override public long call ( int blockSize ) { return blockSize * Sizeof . DOUBLE ; } } ; private static CUoccupancyB2DSize FLOAT = new CUoccupancyB2DSize ( ) { @Override public long call ( int blockSize ) { return blockSize * Sizeof . FLOAT ; } } ; public int [ ] getGpuDefinitionInfo ( ) { int [ ] gpuDef = new int [ <int> ] ; gpuDef [ <int> ] = getBlockSize ( ) ; gpuDef [ <int> ] = getGridSize ( ) ; gpuDef [ <int> ] = getSharedMemory ( ) ; gpuDef [ <int> ] = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxSharedMemoryPerBlock ( ) ; return gpuDef ; } public int getGridSize ( ) { return gridSize ; } public int getBlockSize ( ) { return blockSize ; } public int getSharedMemory ( ) { return sharedMemory ; } public static int [ ] getThreadsAndBlocks ( int n , int maxThreads , int maxBlocks ) { cudaDeviceProp prop = new cudaDeviceProp ( ) ; int [ ] devicePointer = new int [ <int> ] ; cudaGetDevice ( devicePointer ) ; cudaGetDeviceProperties ( prop , devicePointer [ <int> ] ) ; int threads = ( n < maxThreads * <int> ) ? PointerUtil . nextPow2 ( ( n + <int> ) / <int> ) : maxThreads ; int blocks = ( n + ( threads * <int> - <int> ) ) / ( threads * <int> ) ; if ( ( float ) threads * blocks > ( float ) prop . maxGridSize [ <int> ] * prop . maxThreadsPerBlock ) { throw new IllegalStateException ( <str> ) ; } if ( blocks > prop . maxGridSize [ <int> ] ) { log . warn ( <str> , blocks , prop . maxGridSize [ <int> ] , threads * <int> , threads ) ; blocks / = <int> ; threads * = <int> ; } blocks = Math . min ( maxBlocks , blocks ) ; return new int [ ] { threads , blocks } ; } public static GpuMetrics blockAndThreads ( String dataType , int n ) { int size = dataType . equals ( <str> ) ? Sizeof . DOUBLE : Sizeof . FLOAT ; int [ ] threadsAndBlocks = getThreadsAndBlocks ( n , MAX_THREADS , MAX_BLOCKS ) ; int sharedMemSize = ( threadsAndBlocks [ <int> ] < = <int> ) ? <int> * threadsAndBlocks [ <int> ] * size : threadsAndBlocks [ <int> ] * size ; return new GpuMetrics ( threadsAndBlocks [ <int> ] , threadsAndBlocks [ <int> ] , sharedMemSize ) ; } public static GpuMetrics blocksAndThreadsOccupancy ( String functionName , String dataType , int n ) { int [ ] gridSize = new int [ <int> ] ; int [ ] blockSize = new int [ <int> ] ; KernelLauncher launcher = KernelFunctionLoader . launcher ( functionName , dataType ) ; CUoccupancyB2DSize size = dataType . equals ( <str> ) ? FLOAT : DOUBLE ; JCudaDriver . cuOccupancyMaxPotentialBlockSize ( gridSize , blockSize , launcher . getFunction ( ) , size , <int> , <int> ) ; int gridSizeRet = ( n + blockSize [ <int> ] - <int> ) / blockSize [ <int> ] ; int blockSizeRet = blockSize [ <int> ] ; if ( blockSizeRet > n ) blockSizeRet = n ; int maxBlockSize = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxThreadsPerBlock ( ) ; if ( blockSizeRet > maxBlockSize ) blockSizeRet = maxBlockSize ; int maxGridSize = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxGrimDimX ( ) ; if ( gridSizeRet > maxGridSize ) gridSizeRet = maxGridSize ; int maxSharedMem = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxSharedMemoryPerBlock ( ) ; int sharedMemSize = blockSizeRet * ( dataType . equals ( <str> ) ? Sizeof . FLOAT : Sizeof . DOUBLE ) ; if ( sharedMemSize > maxSharedMem ) sharedMemSize = maxSharedMem ; return new GpuMetrics ( gridSizeRet , blockSizeRet , sharedMemSize ) ; } public void validate ( ) { int maxGrid = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxThreadsPerBlock ( ) ; int maxBlock = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxBlockDimx ( ) ; int maxShared = ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxSharedMemoryPerBlock ( ) ; if ( gridSize > maxGrid ) throw new IllegalArgumentException ( <str> + maxGrid + <str> + gridSize ) ; if ( blockSize > maxBlock ) throw new IllegalArgumentException ( <str> + maxBlock + <str> + blockSize ) ; if ( sharedMemory > maxShared ) throw new IllegalArgumentException ( <str> + maxShared + <str> + sharedMemory ) ; } public void setSharedMemoryNotOverMax ( int sharedMemory ) { setSharedMemory ( Math . min ( sharedMemory , ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxSharedMemoryPerBlock ( ) - <int> ) ) ; } public void setGridSizeNotOverMax ( int gridSize ) { setGridSize ( Math . min ( gridSize , ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxThreadsPerBlock ( ) ) ) ; } public void setBlockSizeNotOverMax ( int blockSize ) { setBlockSize ( Math . min ( blockSize , ContextHolder . getInstance ( ) . getCurrentGpuInformation ( ) . getMaxBlockDimx ( ) ) ) ; } } 
