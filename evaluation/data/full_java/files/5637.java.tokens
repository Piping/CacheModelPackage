package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; public class ThrottlingAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES = <str> ; public static final int DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES = <int> ; public static final int DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES = <int> ; private volatile int primariesInitialRecoveries ; private volatile int concurrentRecoveries ; @Inject public ThrottlingAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . primariesInitialRecoveries = settings . getAsInt ( CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES , DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES ) ; this . concurrentRecoveries = settings . getAsInt ( CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES , settings . getAsInt ( CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES , DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES ) ) ; logger . debug ( <str> , concurrentRecoveries , primariesInitialRecoveries ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( shardRouting . primary ( ) ) { assert shardRouting . unassigned ( ) | | shardRouting . active ( ) ; if ( shardRouting . unassigned ( ) ) { int primariesInRecovery = <int> ; for ( ShardRouting shard : node ) { if ( shard . initializing ( ) & & shard . primary ( ) & & shard . relocatingNodeId ( ) = = null ) { primariesInRecovery + + ; } } if ( primariesInRecovery > = primariesInitialRecoveries ) { return allocation . decision ( Decision . THROTTLE , NAME , <str> , primariesInRecovery , primariesInitialRecoveries ) ; } else { return allocation . decision ( Decision . YES , NAME , <str> , primariesInitialRecoveries ) ; } } } return canAllocate ( node , allocation ) ; } @Override public Decision canAllocate ( RoutingNode node , RoutingAllocation allocation ) { int currentRecoveries = <int> ; for ( ShardRouting shard : node ) { if ( shard . initializing ( ) ) { currentRecoveries + + ; } } if ( currentRecoveries > = concurrentRecoveries ) { return allocation . decision ( Decision . THROTTLE , NAME , <str> , currentRecoveries , concurrentRecoveries ) ; } else { return allocation . decision ( Decision . YES , NAME , <str> , concurrentRecoveries ) ; } } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { int primariesInitialRecoveries = settings . getAsInt ( CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES , ThrottlingAllocationDecider . this . primariesInitialRecoveries ) ; if ( primariesInitialRecoveries ! = ThrottlingAllocationDecider . this . primariesInitialRecoveries ) { logger . info ( <str> , ThrottlingAllocationDecider . this . primariesInitialRecoveries , primariesInitialRecoveries ) ; ThrottlingAllocationDecider . this . primariesInitialRecoveries = primariesInitialRecoveries ; } int concurrentRecoveries = settings . getAsInt ( CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES , ThrottlingAllocationDecider . this . concurrentRecoveries ) ; if ( concurrentRecoveries ! = ThrottlingAllocationDecider . this . concurrentRecoveries ) { logger . info ( <str> , ThrottlingAllocationDecider . this . concurrentRecoveries , concurrentRecoveries ) ; ThrottlingAllocationDecider . this . concurrentRecoveries = concurrentRecoveries ; } } } } 
