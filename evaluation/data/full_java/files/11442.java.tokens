package org . gradle . api . internal . coerce ; import groovy . lang . MetaProperty ; import org . gradle . api . specs . Spec ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . internal . typeconversion . EnumFromCharSequenceNotationParser ; import java . lang . reflect . Method ; public class StringToEnumTransformer implements MethodArgumentsTransformer , PropertySetTransformer { public static final StringToEnumTransformer INSTANCE = new StringToEnumTransformer ( ) ; public Object [ ] transform ( Object target , final String methodName , Object . . . args ) { if ( args . length ! = <int> | | ! ( args [ <int> ] instanceof CharSequence ) ) { return args ; } final CharSequence charSequenceArg = ( CharSequence ) args [ <int> ] ; Method enumMethod = JavaReflectionUtil . findMethod ( target . getClass ( ) , new Spec < Method > ( ) { @Override public boolean isSatisfiedBy ( Method method ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( method . getName ( ) . equals ( methodName ) & & parameterTypes . length = = <int> ) { Class < ? > parameterType = parameterTypes [ <int> ] ; if ( parameterType . isEnum ( ) ) { return true ; } } return false ; } } ) ; if ( enumMethod = = null ) { return args ; } else { @SuppressWarnings ( <str> ) Class < ? extends Enum > enumType = ( Class < ? extends Enum > ) enumMethod . getParameterTypes ( ) [ <int> ] ; return new Object [ ] { toEnumValue ( enumType , charSequenceArg ) } ; } } @Override public Object transformValue ( Object target , MetaProperty property , Object value ) { if ( value instanceof CharSequence & & property . getType ( ) . isEnum ( ) ) { @SuppressWarnings ( <str> ) Class < ? extends Enum > enumType = ( Class < ? extends Enum > ) property . getType ( ) ; final String setterName = MetaProperty . getSetterName ( property . getName ( ) ) ; Method setter = JavaReflectionUtil . findMethod ( target . getClass ( ) , new Spec < Method > ( ) { @Override public boolean isSatisfiedBy ( Method element ) { return element . getName ( ) . equals ( setterName ) & & element . getParameterTypes ( ) . length = = <int> ; } } ) ; if ( setter = = null | | setter . getParameterTypes ( ) [ <int> ] . equals ( enumType ) ) { return toEnumValue ( enumType , ( CharSequence ) value ) ; } } return value ; } static public < T extends Enum < T > > T toEnumValue ( Class < T > enumType , CharSequence charSequence ) { EnumFromCharSequenceNotationParser < T > notationParser = new EnumFromCharSequenceNotationParser < T > ( enumType ) ; return notationParser . parseNotation ( charSequence ) ; } } 
