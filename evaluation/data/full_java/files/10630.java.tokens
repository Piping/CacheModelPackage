package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import static com . google . common . util . concurrent . AbstractScheduledService . Scheduler . newFixedDelaySchedule ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . util . concurrent . AbstractScheduledService . Scheduler ; import com . google . common . util . concurrent . Service . State ; import com . google . common . util . concurrent . testing . TestingExecutors ; import junit . framework . TestCase ; import java . util . concurrent . BrokenBarrierException ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; public class AbstractScheduledServiceTest extends TestCase { volatile Scheduler configuration = newFixedDelaySchedule ( <int> , <int> , TimeUnit . MILLISECONDS ) ; volatile ScheduledFuture < ? > future = null ; volatile boolean atFixedRateCalled = false ; volatile boolean withFixedDelayCalled = false ; volatile boolean scheduleCalled = false ; final ScheduledExecutorService executor = new ScheduledThreadPoolExecutor ( <int> ) { @Override public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { return future = super . scheduleWithFixedDelay ( command , initialDelay , delay , unit ) ; } } ; public void testServiceStartStop ( ) throws Exception { NullService service = new NullService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertFalse ( future . isDone ( ) ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertTrue ( future . isCancelled ( ) ) ; } private class NullService extends AbstractScheduledService { @Override protected void runOneIteration ( ) throws Exception { } @Override protected Scheduler scheduler ( ) { return configuration ; } @Override protected ScheduledExecutorService executor ( ) { return executor ; } } public void testFailOnExceptionFromRun ( ) throws Exception { TestService service = new TestService ( ) ; service . runException = new Exception ( ) ; service . startAsync ( ) . awaitRunning ( ) ; service . runFirstBarrier . await ( ) ; service . runSecondBarrier . await ( ) ; try { future . get ( ) ; fail ( ) ; } catch ( CancellationException expected ) { } assertEquals ( service . runException , service . failureCause ( ) ) ; assertEquals ( service . state ( ) , Service . State . FAILED ) ; } public void testFailOnExceptionFromStartUp ( ) { TestService service = new TestService ( ) ; service . startUpException = new Exception ( ) ; try { service . startAsync ( ) . awaitRunning ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertEquals ( service . startUpException , e . getCause ( ) ) ; } assertEquals ( <int> , service . numberOfTimesRunCalled . get ( ) ) ; assertEquals ( Service . State . FAILED , service . state ( ) ) ; } public void testFailOnErrorFromStartUpListener ( ) throws InterruptedException { final Error error = new Error ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; TestService service = new TestService ( ) ; service . addListener ( new Service . Listener ( ) { @Override public void running ( ) { throw error ; } @Override public void failed ( State from , Throwable failure ) { assertEquals ( State . RUNNING , from ) ; assertEquals ( error , failure ) ; latch . countDown ( ) ; } } , directExecutor ( ) ) ; service . startAsync ( ) ; latch . await ( ) ; assertEquals ( <int> , service . numberOfTimesRunCalled . get ( ) ) ; assertEquals ( Service . State . FAILED , service . state ( ) ) ; } public void testFailOnExceptionFromShutDown ( ) throws Exception { TestService service = new TestService ( ) ; service . shutDownException = new Exception ( ) ; service . startAsync ( ) . awaitRunning ( ) ; service . runFirstBarrier . await ( ) ; service . stopAsync ( ) ; service . runSecondBarrier . await ( ) ; try { service . awaitTerminated ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertEquals ( service . shutDownException , e . getCause ( ) ) ; } assertEquals ( Service . State . FAILED , service . state ( ) ) ; } public void testRunOneIterationCalledMultipleTimes ( ) throws Exception { TestService service = new TestService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { service . runFirstBarrier . await ( ) ; assertEquals ( i , service . numberOfTimesRunCalled . get ( ) ) ; service . runSecondBarrier . await ( ) ; } service . runFirstBarrier . await ( ) ; service . stopAsync ( ) ; service . runSecondBarrier . await ( ) ; service . stopAsync ( ) . awaitTerminated ( ) ; } public void testExecutorOnlyCalledOnce ( ) throws Exception { TestService service = new TestService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <int> , service . numberOfTimesExecutorCalled . get ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { service . runFirstBarrier . await ( ) ; assertEquals ( i , service . numberOfTimesRunCalled . get ( ) ) ; service . runSecondBarrier . await ( ) ; } service . runFirstBarrier . await ( ) ; service . stopAsync ( ) ; service . runSecondBarrier . await ( ) ; service . stopAsync ( ) . awaitTerminated ( ) ; assertEquals ( <int> , service . numberOfTimesExecutorCalled . get ( ) ) ; } public void testDefaultExecutorIsShutdownWhenServiceIsStopped ( ) throws Exception { final AtomicReference < ScheduledExecutorService > executor = Atomics . newReference ( ) ; AbstractScheduledService service = new AbstractScheduledService ( ) { @Override protected void runOneIteration ( ) throws Exception { } @Override protected ScheduledExecutorService executor ( ) { executor . set ( super . executor ( ) ) ; return executor . get ( ) ; } @Override protected Scheduler scheduler ( ) { return newFixedDelaySchedule ( <int> , <int> , TimeUnit . MILLISECONDS ) ; } } ; service . startAsync ( ) ; assertFalse ( service . executor ( ) . isShutdown ( ) ) ; service . awaitRunning ( ) ; service . stopAsync ( ) ; service . awaitTerminated ( ) ; assertTrue ( executor . get ( ) . awaitTermination ( <int> , TimeUnit . MILLISECONDS ) ) ; } public void testDefaultExecutorIsShutdownWhenServiceFails ( ) throws Exception { final AtomicReference < ScheduledExecutorService > executor = Atomics . newReference ( ) ; AbstractScheduledService service = new AbstractScheduledService ( ) { @Override protected void startUp ( ) throws Exception { throw new Exception ( <str> ) ; } @Override protected void runOneIteration ( ) throws Exception { } @Override protected ScheduledExecutorService executor ( ) { executor . set ( super . executor ( ) ) ; return executor . get ( ) ; } @Override protected Scheduler scheduler ( ) { return newFixedDelaySchedule ( <int> , <int> , TimeUnit . MILLISECONDS ) ; } } ; try { service . startAsync ( ) . awaitRunning ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } assertTrue ( executor . get ( ) . awaitTermination ( <int> , TimeUnit . MILLISECONDS ) ) ; } public void testSchedulerOnlyCalledOnce ( ) throws Exception { TestService service = new TestService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; assertEquals ( <int> , service . numberOfTimesSchedulerCalled . get ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { service . runFirstBarrier . await ( ) ; assertEquals ( i , service . numberOfTimesRunCalled . get ( ) ) ; service . runSecondBarrier . await ( ) ; } service . runFirstBarrier . await ( ) ; service . stopAsync ( ) ; service . runSecondBarrier . await ( ) ; service . awaitTerminated ( ) ; assertEquals ( <int> , service . numberOfTimesSchedulerCalled . get ( ) ) ; } public void testTimeout ( ) { Service service = new AbstractScheduledService ( ) { @Override protected Scheduler scheduler ( ) { return Scheduler . newFixedDelaySchedule ( <int> , <int> , TimeUnit . NANOSECONDS ) ; } @Override protected ScheduledExecutorService executor ( ) { return TestingExecutors . noOpScheduledExecutor ( ) ; } @Override protected void runOneIteration ( ) throws Exception { } @Override protected String serviceName ( ) { return <str> ; } } ; try { service . startAsync ( ) . awaitRunning ( <int> , TimeUnit . MILLISECONDS ) ; fail ( <str> ) ; } catch ( TimeoutException e ) { assertThat ( e ) . hasMessage ( <str> ) ; } } private class TestService extends AbstractScheduledService { CyclicBarrier runFirstBarrier = new CyclicBarrier ( <int> ) ; CyclicBarrier runSecondBarrier = new CyclicBarrier ( <int> ) ; volatile boolean startUpCalled = false ; volatile boolean shutDownCalled = false ; AtomicInteger numberOfTimesRunCalled = new AtomicInteger ( <int> ) ; AtomicInteger numberOfTimesExecutorCalled = new AtomicInteger ( <int> ) ; AtomicInteger numberOfTimesSchedulerCalled = new AtomicInteger ( <int> ) ; volatile Exception runException = null ; volatile Exception startUpException = null ; volatile Exception shutDownException = null ; @Override protected void runOneIteration ( ) throws Exception { assertTrue ( startUpCalled ) ; assertFalse ( shutDownCalled ) ; numberOfTimesRunCalled . incrementAndGet ( ) ; assertEquals ( State . RUNNING , state ( ) ) ; runFirstBarrier . await ( ) ; runSecondBarrier . await ( ) ; if ( runException ! = null ) { throw runException ; } } @Override protected void startUp ( ) throws Exception { assertFalse ( startUpCalled ) ; assertFalse ( shutDownCalled ) ; startUpCalled = true ; assertEquals ( State . STARTING , state ( ) ) ; if ( startUpException ! = null ) { throw startUpException ; } } @Override protected void shutDown ( ) throws Exception { assertTrue ( startUpCalled ) ; assertFalse ( shutDownCalled ) ; shutDownCalled = true ; if ( shutDownException ! = null ) { throw shutDownException ; } } @Override protected ScheduledExecutorService executor ( ) { numberOfTimesExecutorCalled . incrementAndGet ( ) ; return executor ; } @Override protected Scheduler scheduler ( ) { numberOfTimesSchedulerCalled . incrementAndGet ( ) ; return configuration ; } } public static class SchedulerTest extends TestCase { private static final int initialDelay = <int> ; private static final int delay = <int> ; private static final TimeUnit unit = TimeUnit . MILLISECONDS ; final Runnable testRunnable = new Runnable ( ) { @Override public void run ( ) { } } ; boolean called = false ; private void assertSingleCallWithCorrectParameters ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { assertFalse ( called ) ; called = true ; assertEquals ( SchedulerTest . initialDelay , initialDelay ) ; assertEquals ( SchedulerTest . delay , delay ) ; assertEquals ( SchedulerTest . unit , unit ) ; assertEquals ( testRunnable , command ) ; } public void testFixedRateSchedule ( ) { Scheduler schedule = Scheduler . newFixedRateSchedule ( initialDelay , delay , unit ) ; schedule . schedule ( null , new ScheduledThreadPoolExecutor ( <int> ) { @Override public ScheduledFuture < ? > scheduleAtFixedRate ( Runnable command , long initialDelay , long period , TimeUnit unit ) { assertSingleCallWithCorrectParameters ( command , initialDelay , delay , unit ) ; return null ; } } , testRunnable ) ; assertTrue ( called ) ; } public void testFixedDelaySchedule ( ) { Scheduler schedule = newFixedDelaySchedule ( initialDelay , delay , unit ) ; schedule . schedule ( null , new ScheduledThreadPoolExecutor ( <int> ) { @Override public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { assertSingleCallWithCorrectParameters ( command , initialDelay , delay , unit ) ; return null ; } } , testRunnable ) ; assertTrue ( called ) ; } public void testFixedDelayScheduleFarFuturePotentiallyOverflowingScheduleIsNeverReached ( ) throws Exception { TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService ( ) { @Override protected Scheduler scheduler ( ) { return newFixedDelaySchedule ( Long . MAX_VALUE , Long . MAX_VALUE , SECONDS ) ; } } ; service . startAsync ( ) . awaitRunning ( ) ; try { service . firstBarrier . await ( <int> , SECONDS ) ; fail ( ) ; } catch ( TimeoutException expected ) { } assertEquals ( <int> , service . numIterations . get ( ) ) ; service . stopAsync ( ) ; service . awaitTerminated ( ) ; } public void testCustomSchedulerFarFuturePotentiallyOverflowingScheduleIsNeverReached ( ) throws Exception { TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService ( ) { @Override protected Scheduler scheduler ( ) { return new AbstractScheduledService . CustomScheduler ( ) { @Override protected Schedule getNextSchedule ( ) throws Exception { return new Schedule ( Long . MAX_VALUE , SECONDS ) ; } } ; } } ; service . startAsync ( ) . awaitRunning ( ) ; try { service . firstBarrier . await ( <int> , SECONDS ) ; fail ( ) ; } catch ( TimeoutException expected ) { } assertEquals ( <int> , service . numIterations . get ( ) ) ; service . stopAsync ( ) ; service . awaitTerminated ( ) ; } private class TestCustomScheduler extends AbstractScheduledService . CustomScheduler { public AtomicInteger scheduleCounter = new AtomicInteger ( <int> ) ; @Override protected Schedule getNextSchedule ( ) throws Exception { scheduleCounter . incrementAndGet ( ) ; return new Schedule ( <int> , TimeUnit . SECONDS ) ; } } public void testCustomSchedule_startStop ( ) throws Exception { final CyclicBarrier firstBarrier = new CyclicBarrier ( <int> ) ; final CyclicBarrier secondBarrier = new CyclicBarrier ( <int> ) ; final AtomicBoolean shouldWait = new AtomicBoolean ( true ) ; Runnable task = new Runnable ( ) { @Override public void run ( ) { try { if ( shouldWait . get ( ) ) { firstBarrier . await ( ) ; secondBarrier . await ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; TestCustomScheduler scheduler = new TestCustomScheduler ( ) ; Future < ? > future = scheduler . schedule ( null , Executors . newScheduledThreadPool ( <int> ) , task ) ; firstBarrier . await ( ) ; assertEquals ( <int> , scheduler . scheduleCounter . get ( ) ) ; secondBarrier . await ( ) ; firstBarrier . await ( ) ; assertEquals ( <int> , scheduler . scheduleCounter . get ( ) ) ; shouldWait . set ( false ) ; secondBarrier . await ( ) ; future . cancel ( false ) ; } public void testCustomSchedulerServiceStop ( ) throws Exception { TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; service . firstBarrier . await ( ) ; assertEquals ( <int> , service . numIterations . get ( ) ) ; service . stopAsync ( ) ; service . secondBarrier . await ( ) ; service . awaitTerminated ( ) ; Thread . sleep ( unit . toMillis ( <int> * delay ) ) ; assertEquals ( <int> , service . numIterations . get ( ) ) ; } public void testCustomScheduler_deadlock ( ) throws InterruptedException , BrokenBarrierException { final CyclicBarrier inGetNextSchedule = new CyclicBarrier ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { Service service = new AbstractScheduledService ( ) { @Override protected void runOneIteration ( ) { } @Override protected Scheduler scheduler ( ) { return new CustomScheduler ( ) { @Override protected Schedule getNextSchedule ( ) throws Exception { if ( state ( ) ! = State . STARTING ) { inGetNextSchedule . await ( ) ; Thread . yield ( ) ; throw new RuntimeException ( <str> ) ; } return new Schedule ( <int> , TimeUnit . NANOSECONDS ) ; } } ; } } ; service . startAsync ( ) . awaitRunning ( ) ; inGetNextSchedule . await ( ) ; service . stopAsync ( ) ; } } public void testBig ( ) throws Exception { TestAbstractScheduledCustomService service = new TestAbstractScheduledCustomService ( ) { @Override protected Scheduler scheduler ( ) { return new AbstractScheduledService . CustomScheduler ( ) { @Override protected Schedule getNextSchedule ( ) throws Exception { Thread . yield ( ) ; return new Schedule ( <int> , TimeUnit . SECONDS ) ; } } ; } } ; service . useBarriers = false ; service . startAsync ( ) . awaitRunning ( ) ; Thread . sleep ( <int> ) ; service . useBarriers = true ; service . firstBarrier . await ( ) ; int numIterations = service . numIterations . get ( ) ; service . stopAsync ( ) ; service . secondBarrier . await ( ) ; service . awaitTerminated ( ) ; assertEquals ( numIterations , service . numIterations . get ( ) ) ; } private static class TestAbstractScheduledCustomService extends AbstractScheduledService { final AtomicInteger numIterations = new AtomicInteger ( <int> ) ; volatile boolean useBarriers = true ; final CyclicBarrier firstBarrier = new CyclicBarrier ( <int> ) ; final CyclicBarrier secondBarrier = new CyclicBarrier ( <int> ) ; @Override protected void runOneIteration ( ) throws Exception { numIterations . incrementAndGet ( ) ; if ( useBarriers ) { firstBarrier . await ( ) ; secondBarrier . await ( ) ; } } @Override protected ScheduledExecutorService executor ( ) { return Executors . newScheduledThreadPool ( <int> ) ; } @Override protected Scheduler scheduler ( ) { return new CustomScheduler ( ) { @Override protected Schedule getNextSchedule ( ) throws Exception { return new Schedule ( delay , unit ) ; } } ; } } public void testCustomSchedulerFailure ( ) throws Exception { TestFailingCustomScheduledService service = new TestFailingCustomScheduledService ( ) ; service . startAsync ( ) . awaitRunning ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { service . firstBarrier . await ( ) ; assertEquals ( i , service . numIterations . get ( ) ) ; service . secondBarrier . await ( ) ; } Thread . sleep ( <int> ) ; try { service . stopAsync ( ) . awaitTerminated ( <int> , TimeUnit . SECONDS ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertEquals ( State . FAILED , service . state ( ) ) ; } } private static class TestFailingCustomScheduledService extends AbstractScheduledService { final AtomicInteger numIterations = new AtomicInteger ( <int> ) ; final CyclicBarrier firstBarrier = new CyclicBarrier ( <int> ) ; final CyclicBarrier secondBarrier = new CyclicBarrier ( <int> ) ; @Override protected void runOneIteration ( ) throws Exception { numIterations . incrementAndGet ( ) ; firstBarrier . await ( ) ; secondBarrier . await ( ) ; } @Override protected ScheduledExecutorService executor ( ) { return Executors . newScheduledThreadPool ( <int> ) ; } @Override protected Scheduler scheduler ( ) { return new CustomScheduler ( ) { @Override protected Schedule getNextSchedule ( ) throws Exception { if ( numIterations . get ( ) > <int> ) { throw new IllegalStateException ( <str> ) ; } return new Schedule ( delay , unit ) ; } } ; } } } } 
