package org . gradle . api . internal . artifacts . ivyservice . ivyresolve . parser ; import com . google . common . base . Joiner ; import com . google . common . collect . Sets ; import org . apache . ivy . core . IvyPatternHelper ; import org . apache . ivy . core . NormalRelativeUrlResolver ; import org . apache . ivy . core . RelativeUrlResolver ; import org . apache . ivy . core . module . descriptor . * ; import org . apache . ivy . core . module . id . ArtifactId ; import org . apache . ivy . core . module . id . ModuleId ; import org . apache . ivy . core . module . id . ModuleRevisionId ; import org . apache . ivy . plugins . matcher . PatternMatcher ; import org . apache . ivy . plugins . namespace . Namespace ; import org . apache . ivy . plugins . parser . xml . XmlModuleDescriptorParser ; import org . apache . ivy . util . extendable . DefaultExtendableItem ; import org . apache . ivy . util . url . URLHandlerRegistry ; import org . gradle . api . Action ; import org . gradle . api . Transformer ; import org . gradle . api . artifacts . component . ModuleComponentIdentifier ; import org . gradle . api . internal . artifacts . ivyservice . IvyUtil ; import org . gradle . api . internal . artifacts . ivyservice . NamespaceId ; import org . gradle . api . internal . artifacts . ivyservice . ivyresolve . strategy . ResolverStrategy ; import org . gradle . api . internal . component . ArtifactType ; import org . gradle . internal . component . external . model . BuildableIvyModuleResolveMetaData ; import org . gradle . internal . component . external . model . DefaultIvyModuleResolveMetaData ; import org . gradle . internal . component . external . model . DefaultModuleComponentIdentifier ; import org . gradle . internal . component . model . DefaultIvyArtifactName ; import org . gradle . internal . component . model . IvyArtifactName ; import org . gradle . internal . resource . ExternalResource ; import org . gradle . internal . resource . ResourceNotFoundException ; import org . gradle . internal . resource . local . LocallyAvailableExternalResource ; import org . gradle . internal . resource . transfer . UrlExternalResource ; import org . gradle . util . CollectionUtils ; import org . gradle . util . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; import org . xml . sax . helpers . DefaultHandler ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . * ; import static org . gradle . api . internal . artifacts . ivyservice . IvyUtil . createModuleRevisionId ; public class IvyXmlModuleDescriptorParser extends AbstractModuleDescriptorParser < DefaultIvyModuleResolveMetaData > { static final String [ ] DEPENDENCY_REGULAR_ATTRIBUTES = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public static final String IVY_DATE_FORMAT_PATTERN = <str> ; private static final Logger LOGGER = LoggerFactory . getLogger ( IvyXmlModuleDescriptorParser . class ) ; private final ResolverStrategy resolverStrategy ; public IvyXmlModuleDescriptorParser ( ResolverStrategy resolverStrategy ) { this . resolverStrategy = resolverStrategy ; } protected DefaultIvyModuleResolveMetaData doParseDescriptor ( DescriptorParseContext parseContext , LocallyAvailableExternalResource resource , boolean validate ) throws IOException , ParseException { Parser parser = createParser ( parseContext , resource , populateProperties ( ) , resolverStrategy ) ; return doParseDescriptorWithProvidedParser ( parser , validate ) ; } protected Parser createParser ( DescriptorParseContext parseContext , LocallyAvailableExternalResource resource , Map < String , String > properties , ResolverStrategy resolverStrategy ) throws MalformedURLException { return new Parser ( parseContext , resource , resource . getLocalResource ( ) . getFile ( ) . toURI ( ) . toURL ( ) , properties , resolverStrategy ) ; } private DefaultIvyModuleResolveMetaData doParseDescriptorWithProvidedParser ( Parser parser , boolean validate ) throws ParseException { parser . setValidate ( validate ) ; parser . parse ( ) ; DefaultModuleDescriptor moduleDescriptor = parser . getModuleDescriptor ( ) ; postProcess ( moduleDescriptor ) ; return parser . getMetaData ( ) ; } protected void postProcess ( DefaultModuleDescriptor moduleDescriptor ) { } @Override protected String getTypeName ( ) { return <str> ; } private Map < String , String > populateProperties ( ) { HashMap < String , String > properties = new HashMap < String , String > ( ) ; String baseDir = new File ( <str> ) . getAbsolutePath ( ) ; properties . put ( <str> , baseDir ) ; properties . put ( <str> , baseDir ) ; Set < String > propertyNames = CollectionUtils . collect ( System . getProperties ( ) . entrySet ( ) , new Transformer < String , Map . Entry < Object , Object > > ( ) { public String transform ( Map . Entry < Object , Object > entry ) { return entry . getKey ( ) . toString ( ) ; } } ) ; for ( String property : propertyNames ) { properties . put ( property , System . getProperty ( property ) ) ; } return properties ; } protected abstract static class AbstractParser extends DefaultHandler { private static final String DEFAULT_CONF_MAPPING = <str> ; private String defaultConf ; private String defaultConfMapping ; private DefaultDependencyDescriptor defaultConfMappingDescriptor ; private final ExternalResource res ; private final List < String > errors = new ArrayList < String > ( ) ; private final DefaultModuleDescriptor md ; protected BuildableIvyModuleResolveMetaData metaData ; protected AbstractParser ( ExternalResource resource ) { this . res = resource ; md = new DefaultModuleDescriptor ( XmlModuleDescriptorParser . getInstance ( ) , null ) ; } protected void checkErrors ( ) throws ParseException { if ( ! errors . isEmpty ( ) ) { throw new ParseException ( Joiner . on ( TextUtil . getPlatformLineSeparator ( ) ) . join ( errors ) , <int> ) ; } } protected ExternalResource getResource ( ) { return res ; } protected String getDefaultConfMapping ( ) { return defaultConfMapping ; } protected void setDefaultConfMapping ( String defaultConf ) { defaultConfMapping = defaultConf ; } protected void parseDepsConfs ( String confs , DefaultDependencyDescriptor dd ) { parseDepsConfs ( confs , dd , defaultConfMapping ! = null ) ; } protected void parseDepsConfs ( String confs , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande ) { parseDepsConfs ( confs , dd , useDefaultMappingToGuessRightOperande , true ) ; } protected void parseDepsConfs ( String confs , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande , boolean evaluateConditions ) { if ( confs = = null ) { return ; } String [ ] conf = confs . split ( <str> ) ; parseDepsConfs ( conf , dd , useDefaultMappingToGuessRightOperande , evaluateConditions ) ; } protected void parseDepsConfs ( String [ ] conf , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande ) { parseDepsConfs ( conf , dd , useDefaultMappingToGuessRightOperande , true ) ; } protected void parseDepsConfs ( String [ ] conf , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande , boolean evaluateConditions ) { replaceConfigurationWildcards ( md ) ; for ( int i = <int> ; i < conf . length ; i + + ) { String [ ] ops = conf [ i ] . split ( <str> ) ; if ( ops . length = = <int> ) { String [ ] modConfs = ops [ <int> ] . split ( <str> ) ; if ( ! useDefaultMappingToGuessRightOperande ) { for ( int j = <int> ; j < modConfs . length ; j + + ) { dd . addDependencyConfiguration ( modConfs [ j ] . trim ( ) , modConfs [ j ] . trim ( ) ) ; } } else { for ( int j = <int> ; j < modConfs . length ; j + + ) { String [ ] depConfs = getDefaultConfMappingDescriptor ( ) . getDependencyConfigurations ( modConfs [ j ] ) ; if ( depConfs . length > <int> ) { for ( int k = <int> ; k < depConfs . length ; k + + ) { String mappedDependency = evaluateConditions ? evaluateCondition ( depConfs [ k ] . trim ( ) , dd ) : depConfs [ k ] . trim ( ) ; if ( mappedDependency ! = null ) { dd . addDependencyConfiguration ( modConfs [ j ] . trim ( ) , mappedDependency ) ; } } } else { dd . addDependencyConfiguration ( modConfs [ j ] . trim ( ) , modConfs [ j ] . trim ( ) ) ; } } } } else if ( ops . length = = <int> ) { String [ ] modConfs = ops [ <int> ] . split ( <str> ) ; String [ ] depConfs = ops [ <int> ] . split ( <str> ) ; for ( int j = <int> ; j < modConfs . length ; j + + ) { for ( int k = <int> ; k < depConfs . length ; k + + ) { String mappedDependency = evaluateConditions ? evaluateCondition ( depConfs [ k ] . trim ( ) , dd ) : depConfs [ k ] . trim ( ) ; if ( mappedDependency ! = null ) { dd . addDependencyConfiguration ( modConfs [ j ] . trim ( ) , mappedDependency ) ; } } } } else { addError ( <str> + conf [ i ] + <str> + dd ) ; } } if ( md . isMappingOverride ( ) ) { addExtendingConfigurations ( conf , dd , useDefaultMappingToGuessRightOperande ) ; } } private String evaluateCondition ( String conf , DefaultDependencyDescriptor dd ) { if ( conf . charAt ( <int> ) ! = <str> ) { return conf ; } int endConditionIndex = conf . indexOf ( <str> ) ; if ( endConditionIndex = = - <int> ) { addError ( <str> + conf + <str> + dd ) ; return null ; } String condition = conf . substring ( <int> , endConditionIndex ) ; int notEqualIndex = condition . indexOf ( <str> ) ; if ( notEqualIndex = = - <int> ) { int equalIndex = condition . indexOf ( <str> ) ; if ( equalIndex = = - <int> ) { addError ( <str> + conf + <str> + dd . getDependencyRevisionId ( ) ) ; return null ; } String leftOp = condition . substring ( <int> , equalIndex ) . trim ( ) ; String rightOp = condition . substring ( equalIndex + <int> ) . trim ( ) ; if ( leftOp . equals ( <str> ) | | leftOp . equals ( <str> ) ) { leftOp = <str> ; } String attrValue = dd . getAttribute ( leftOp ) ; if ( ! rightOp . equals ( attrValue ) ) { return null ; } } else { String leftOp = condition . substring ( <int> , notEqualIndex ) . trim ( ) ; String rightOp = condition . substring ( notEqualIndex + <int> ) . trim ( ) ; if ( leftOp . equals ( <str> ) | | leftOp . equals ( <str> ) ) { leftOp = <str> ; } String attrValue = dd . getAttribute ( leftOp ) ; if ( rightOp . equals ( attrValue ) ) { return null ; } } return conf . substring ( endConditionIndex + <int> ) ; } private void addExtendingConfigurations ( String [ ] confs , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande ) { for ( int i = <int> ; i < confs . length ; i + + ) { addExtendingConfigurations ( confs [ i ] , dd , useDefaultMappingToGuessRightOperande ) ; } } private void addExtendingConfigurations ( String conf , DefaultDependencyDescriptor dd , boolean useDefaultMappingToGuessRightOperande ) { Set configsToAdd = new HashSet ( ) ; Configuration [ ] configs = md . getConfigurations ( ) ; for ( int i = <int> ; i < configs . length ; i + + ) { String [ ] ext = configs [ i ] . getExtends ( ) ; for ( int j = <int> ; j < ext . length ; j + + ) { if ( conf . equals ( ext [ j ] ) ) { String configName = configs [ i ] . getName ( ) ; configsToAdd . add ( configName ) ; addExtendingConfigurations ( configName , dd , useDefaultMappingToGuessRightOperande ) ; } } } String [ ] confs = ( String [ ] ) configsToAdd . toArray ( new String [ configsToAdd . size ( ) ] ) ; parseDepsConfs ( confs , dd , useDefaultMappingToGuessRightOperande ) ; } protected DependencyDescriptor getDefaultConfMappingDescriptor ( ) { if ( defaultConfMappingDescriptor = = null ) { defaultConfMappingDescriptor = new DefaultDependencyDescriptor ( createModuleRevisionId ( <str> , <str> , <str> ) , false ) ; parseDepsConfs ( defaultConfMapping , defaultConfMappingDescriptor , false , false ) ; } return defaultConfMappingDescriptor ; } protected void addError ( String msg ) { errors . add ( msg + <str> + res . getName ( ) ) ; } public void warning ( SAXParseException ex ) { LOGGER . warn ( <str> , getLocationString ( ex ) , ex . getMessage ( ) ) ; } public void error ( SAXParseException ex ) { addError ( <str> + getLocationString ( ex ) + <str> + ex . getMessage ( ) ) ; } public void fatalError ( SAXParseException ex ) throws SAXException { addError ( <str> + getLocationString ( ex ) + <str> + ex . getMessage ( ) ) ; } private String getLocationString ( SAXParseException ex ) { StringBuffer str = new StringBuffer ( ) ; String systemId = ex . getSystemId ( ) ; if ( systemId ! = null ) { int index = systemId . lastIndexOf ( <str> ) ; if ( index ! = - <int> ) { systemId = systemId . substring ( index + <int> ) ; } str . append ( systemId ) ; } else { str . append ( getResource ( ) . getName ( ) ) ; } str . append ( <str> ) ; str . append ( ex . getLineNumber ( ) ) ; str . append ( <str> ) ; str . append ( ex . getColumnNumber ( ) ) ; return str . toString ( ) ; } protected String getDefaultConf ( ) { return defaultConf ! = null ? defaultConf : ( defaultConfMapping ! = null ? defaultConfMapping : DEFAULT_CONF_MAPPING ) ; } protected void setDefaultConf ( String defaultConf ) { this . defaultConf = defaultConf ; } public DefaultModuleDescriptor getModuleDescriptor ( ) throws ParseException { checkErrors ( ) ; return md ; } public DefaultIvyModuleResolveMetaData getMetaData ( ) { return metaData ; } private void replaceConfigurationWildcards ( ModuleDescriptor md ) { Configuration [ ] configs = md . getConfigurations ( ) ; for ( int i = <int> ; i < configs . length ; i + + ) { configs [ i ] . replaceWildcards ( md ) ; } } protected DefaultModuleDescriptor getMd ( ) { return md ; } } public static class Parser extends AbstractParser { public enum State { NONE , INFO , CONF , PUB , DEP , DEP_ARTIFACT , ARTIFACT_INCLUDE , ARTIFACT_EXCLUDE , CONFLICT , EXCLUDE , DEPS , DESCRIPTION , EXTRA_INFO } private static final List ALLOWED_VERSIONS = Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; private final DescriptorParseContext parseContext ; private final RelativeUrlResolver relativeUrlResolver = new NormalRelativeUrlResolver ( ) ; private final URL descriptorURL ; private boolean validate = true ; private State state = State . NONE ; private PatternMatcher defaultMatcher ; private DefaultDependencyDescriptor dd ; private ConfigurationAware confAware ; private BuildableIvyArtifact artifact ; private String conf ; private boolean artifactsDeclared ; private StringBuffer buffer ; private String descriptorVersion ; private String [ ] publicationsDefaultConf ; final Map < String , String > properties ; final ResolverStrategy resolverStrategy ; public Parser ( DescriptorParseContext parseContext , ExternalResource res , URL descriptorURL , Map < String , String > properties , ResolverStrategy resolverStrategy ) { super ( res ) ; this . parseContext = parseContext ; this . descriptorURL = descriptorURL ; this . properties = properties ; this . resolverStrategy = resolverStrategy ; } public Parser newParser ( ExternalResource res , URL descriptorURL ) { Parser parser = new Parser ( parseContext , res , descriptorURL , properties , resolverStrategy ) ; parser . setValidate ( validate ) ; return parser ; } public void setValidate ( boolean validate ) { this . validate = validate ; } public boolean isValidate ( ) { return validate ; } public DescriptorParseContext getParseContext ( ) { return parseContext ; } public void parse ( ) throws ParseException { getResource ( ) . withContent ( new Action < InputStream > ( ) { public void execute ( InputStream inputStream ) { URL schemaURL = validate ? getSchemaURL ( ) : null ; InputSource inSrc = new InputSource ( inputStream ) ; inSrc . setSystemId ( descriptorURL . toExternalForm ( ) ) ; try { ParserHelper . parse ( inSrc , schemaURL , Parser . this ) ; } catch ( Exception e ) { throw new MetaDataParseException ( <str> , getResource ( ) , e ) ; } } } ) ; checkErrors ( ) ; checkConfigurations ( ) ; replaceConfigurationWildcards ( ) ; if ( ! artifactsDeclared ) { IvyArtifactName implicitArtifact = new DefaultIvyArtifactName ( getMd ( ) . getModuleRevisionId ( ) . getName ( ) , <str> , <str> ) ; Set < String > configurationNames = Sets . newHashSet ( getMd ( ) . getConfigurationsNames ( ) ) ; metaData . addArtifact ( implicitArtifact , configurationNames ) ; } checkErrors ( ) ; getMd ( ) . check ( ) ; } public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { try { if ( state = = State . DESCRIPTION ) { descriptionStarted ( qName , attributes ) ; } else if ( <str> . equals ( qName ) ) { ivyModuleStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { infoStarted ( attributes ) ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { extendsStarted ( attributes ) ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { getMd ( ) . addLicense ( new License ( substitute ( attributes . getValue ( <str> ) ) , substitute ( attributes . getValue ( <str> ) ) ) ) ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { return ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { return ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { getMd ( ) . setHomePage ( substitute ( attributes . getValue ( <str> ) ) ) ; state = State . DESCRIPTION ; buffer = new StringBuffer ( ) ; } else if ( state = = State . INFO & & isOtherNamespace ( qName ) ) { buffer = new StringBuffer ( ) ; state = State . EXTRA_INFO ; } else if ( <str> . equals ( qName ) ) { configurationStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { publicationsStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { dependenciesStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { state = State . CONFLICT ; checkConfigurations ( ) ; } else if ( <str> . equals ( qName ) ) { artifactStarted ( qName , attributes ) ; } else if ( <str> . equals ( qName ) & & state = = State . DEP ) { addIncludeRule ( qName , attributes ) ; } else if ( <str> . equals ( qName ) & & state = = State . DEP ) { addExcludeRule ( qName , attributes ) ; } else if ( <str> . equals ( qName ) & & state = = State . DEPS ) { state = State . EXCLUDE ; parseRule ( qName , attributes ) ; getMd ( ) . addExcludeRule ( ( ExcludeRule ) confAware ) ; } else if ( <str> . equals ( qName ) ) { dependencyStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { confStarted ( attributes ) ; } else if ( <str> . equals ( qName ) ) { dd . addDependencyConfiguration ( conf , substitute ( attributes . getValue ( <str> ) ) ) ; } else if ( ( <str> . equals ( qName ) & & state = = State . DEPS ) | | <str> . equals ( qName ) & & state = = State . CONFLICT ) { LOGGER . debug ( <str> , getResource ( ) . getName ( ) ) ; } else if ( <str> . equals ( qName ) & & state = = State . DEPS ) { LOGGER . debug ( <str> , getResource ( ) . getName ( ) ) ; } else if ( <str> . equals ( qName ) & & state = = State . CONF ) { includeConfStarted ( attributes ) ; } else if ( validate & & state ! = State . EXTRA_INFO & & state ! = State . DESCRIPTION ) { addError ( <str> + qName ) ; } } catch ( Exception ex ) { if ( ex instanceof SAXException ) { throw ( SAXException ) ex ; } SAXException sax = new SAXException ( <str> + ex . getMessage ( ) , ex ) ; sax . initCause ( ex ) ; throw sax ; } } private void extendsStarted ( Attributes attributes ) throws ParseException { String parentOrganisation = attributes . getValue ( <str> ) ; String parentModule = attributes . getValue ( <str> ) ; String parentRevision = attributes . getValue ( <str> ) ; String location = elvis ( attributes . getValue ( <str> ) , <str> ) ; String extendType = elvis ( attributes . getValue ( <str> ) , <str> ) . toLowerCase ( ) ; List < String > extendTypes = Arrays . asList ( extendType . split ( <str> ) ) ; ModuleDescriptor parent ; try { LOGGER . debug ( <str> , location ) ; parent = parseOtherIvyFileOnFileSystem ( location ) ; if ( parent ! = null ) { ModuleId expected = IvyUtil . createModuleId ( parentOrganisation , parentModule ) ; ModuleId pid = parent . getModuleRevisionId ( ) . getModuleId ( ) ; if ( ! expected . equals ( pid ) ) { LOGGER . warn ( <str> , location , expected , pid ) ; parent = null ; } } if ( parent = = null ) { LOGGER . debug ( <str> , parentOrganisation , parentModule , parentRevision ) ; parent = parseOtherIvyFile ( parentOrganisation , parentModule , parentRevision ) ; } } catch ( Exception e ) { throw ( ParseException ) new ParseException ( <str> + parentOrganisation + <str> + parentModule + <str> + parentRevision , <int> ) . initCause ( e ) ; } if ( parent = = null ) { throw new ParseException ( <str> + parentOrganisation + <str> + parentModule + <str> + parentRevision , <int> ) ; } mergeWithOtherModuleDescriptor ( extendTypes , parent ) ; } private void mergeWithOtherModuleDescriptor ( List < String > extendTypes , ModuleDescriptor parent ) { if ( extendTypes . contains ( <str> ) ) { mergeAll ( parent ) ; } else { if ( extendTypes . contains ( <str> ) ) { mergeInfo ( parent ) ; } if ( extendTypes . contains ( <str> ) ) { mergeConfigurations ( parent . getModuleRevisionId ( ) , parent . getConfigurations ( ) ) ; } if ( extendTypes . contains ( <str> ) ) { mergeDependencies ( parent . getDependencies ( ) ) ; } if ( extendTypes . contains ( <str> ) ) { mergeDescription ( parent . getDescription ( ) ) ; } } } private void mergeAll ( ModuleDescriptor parent ) { ModuleRevisionId sourceMrid = parent . getModuleRevisionId ( ) ; mergeInfo ( parent ) ; mergeConfigurations ( sourceMrid , parent . getConfigurations ( ) ) ; mergeDependencies ( parent . getDependencies ( ) ) ; mergeDescription ( parent . getDescription ( ) ) ; } private void mergeInfo ( ModuleDescriptor parent ) { ModuleRevisionId parentMrid = parent . getModuleRevisionId ( ) ; DefaultModuleDescriptor descriptor = getMd ( ) ; ModuleRevisionId currentMrid = descriptor . getModuleRevisionId ( ) ; ModuleRevisionId mergedMrid = createModuleRevisionId ( mergeValue ( parentMrid . getOrganisation ( ) , currentMrid . getOrganisation ( ) ) , currentMrid . getName ( ) , mergeValue ( parentMrid . getBranch ( ) , currentMrid . getBranch ( ) ) , mergeValue ( parentMrid . getRevision ( ) , currentMrid . getRevision ( ) ) , mergeValues ( parentMrid . getQualifiedExtraAttributes ( ) , currentMrid . getQualifiedExtraAttributes ( ) ) ) ; descriptor . setModuleRevisionId ( mergedMrid ) ; descriptor . setResolvedModuleRevisionId ( mergedMrid ) ; descriptor . setStatus ( mergeValue ( parent . getStatus ( ) , descriptor . getStatus ( ) ) ) ; if ( descriptor . getNamespace ( ) = = null & & parent instanceof DefaultModuleDescriptor ) { Namespace parentNamespace = ( ( DefaultModuleDescriptor ) parent ) . getNamespace ( ) ; descriptor . setNamespace ( parentNamespace ) ; } } private static String mergeValue ( String inherited , String override ) { return override = = null ? inherited : override ; } private static Map mergeValues ( Map inherited , Map overrides ) { LinkedHashMap dup = new LinkedHashMap ( inherited . size ( ) + overrides . size ( ) ) ; dup . putAll ( inherited ) ; dup . putAll ( overrides ) ; return dup ; } private void mergeConfigurations ( ModuleRevisionId sourceMrid , Configuration [ ] configurations ) { DefaultModuleDescriptor md = getMd ( ) ; for ( Configuration configuration : configurations ) { LOGGER . debug ( <str> , configuration . getName ( ) ) ; md . addConfiguration ( new Configuration ( configuration , sourceMrid ) ) ; } } private void mergeDependencies ( DependencyDescriptor [ ] dependencies ) { DefaultModuleDescriptor md = getMd ( ) ; for ( DependencyDescriptor dependencyDescriptor : dependencies ) { LOGGER . debug ( <str> , dependencyDescriptor . getDependencyRevisionId ( ) ) ; md . addDependency ( dependencyDescriptor ) ; } } private void mergeDescription ( String description ) { String current = getMd ( ) . getDescription ( ) ; if ( current = = null | | current . trim ( ) . length ( ) = = <int> ) { getMd ( ) . setDescription ( description ) ; } } private ModuleDescriptor parseOtherIvyFileOnFileSystem ( String location ) throws ParseException , IOException { URL url = relativeUrlResolver . getURL ( descriptorURL , location ) ; LOGGER . debug ( <str> , url ) ; ExternalResource resource = UrlExternalResource . open ( url ) ; try { return parseModuleDescriptor ( resource , url ) ; } catch ( ResourceNotFoundException e ) { return null ; } finally { resource . close ( ) ; } } protected ModuleDescriptor parseOtherIvyFile ( String parentOrganisation , String parentModule , String parentRevision ) throws IOException , ParseException , SAXException { ModuleComponentIdentifier importedId = DefaultModuleComponentIdentifier . newId ( parentOrganisation , parentModule , parentRevision ) ; LocallyAvailableExternalResource externalResource = parseContext . getMetaDataArtifact ( importedId , ArtifactType . IVY_DESCRIPTOR ) ; return parseModuleDescriptor ( externalResource , externalResource . getLocalResource ( ) . getFile ( ) . toURI ( ) . toURL ( ) ) ; } private ModuleDescriptor parseModuleDescriptor ( ExternalResource externalResource , URL descriptorURL ) throws ParseException { Parser parser = newParser ( externalResource , descriptorURL ) ; parser . parse ( ) ; return parser . getModuleDescriptor ( ) ; } private void publicationsStarted ( Attributes attributes ) { state = State . PUB ; artifactsDeclared = true ; checkConfigurations ( ) ; String defaultConf = substitute ( attributes . getValue ( <str> ) ) ; if ( defaultConf ! = null ) { this . publicationsDefaultConf = defaultConf . split ( <str> ) ; } } private boolean isOtherNamespace ( String qName ) { return qName . indexOf ( <str> ) ! = - <int> ; } private void includeConfStarted ( Attributes attributes ) throws SAXException , IOException , ParserConfigurationException , ParseException { URL url = relativeUrlResolver . getURL ( descriptorURL , substitute ( attributes . getValue ( <str> ) ) , substitute ( attributes . getValue ( <str> ) ) ) ; if ( url = = null ) { throw new SAXException ( <str> ) ; } Parser parser = newParser ( UrlExternalResource . open ( url ) , url ) ; ParserHelper . parse ( url , null , parser ) ; Configuration [ ] configs = parser . getModuleDescriptor ( ) . getConfigurations ( ) ; for ( Configuration config : configs ) { getMd ( ) . addConfiguration ( config ) ; } if ( parser . getDefaultConfMapping ( ) ! = null ) { LOGGER . debug ( <str> , parser . getDefaultConfMapping ( ) ) ; setDefaultConfMapping ( parser . getDefaultConfMapping ( ) ) ; } if ( parser . getDefaultConf ( ) ! = null ) { LOGGER . debug ( <str> , parser . getDefaultConf ( ) ) ; setDefaultConf ( parser . getDefaultConf ( ) ) ; } if ( parser . getMd ( ) . isMappingOverride ( ) ) { LOGGER . debug ( <str> ) ; getMd ( ) . setMappingOverride ( true ) ; } } private void confStarted ( Attributes attributes ) { String conf = substitute ( attributes . getValue ( <str> ) ) ; switch ( state ) { case CONF : Configuration . Visibility visibility = Configuration . Visibility . getVisibility ( elvis ( substitute ( attributes . getValue ( <str> ) ) , <str> ) ) ; String description = substitute ( attributes . getValue ( <str> ) ) ; String [ ] extend = substitute ( attributes . getValue ( <str> ) ) = = null ? null : substitute ( attributes . getValue ( <str> ) ) . split ( <str> ) ; String transitiveValue = attributes . getValue ( <str> ) ; boolean transitive = ( transitiveValue = = null ) | | Boolean . valueOf ( attributes . getValue ( <str> ) ) ; String deprecated = attributes . getValue ( <str> ) ; Configuration configuration = new Configuration ( conf , visibility , description , extend , transitive , deprecated ) ; fillExtraAttributes ( configuration , attributes , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ) ; getMd ( ) . addConfiguration ( configuration ) ; break ; case PUB : if ( <str> . equals ( conf ) ) { String [ ] confs = getMd ( ) . getConfigurationsNames ( ) ; for ( String confName : confs ) { artifact . addConfiguration ( confName ) ; } } else { artifact . addConfiguration ( conf ) ; } break ; case DEP : this . conf = conf ; String mappeds = substitute ( attributes . getValue ( <str> ) ) ; if ( mappeds ! = null ) { String [ ] mapped = mappeds . split ( <str> ) ; for ( String depConf : mapped ) { dd . addDependencyConfiguration ( conf , depConf . trim ( ) ) ; } } break ; case DEP_ARTIFACT : case ARTIFACT_INCLUDE : case ARTIFACT_EXCLUDE : addConfiguration ( conf ) ; break ; default : if ( validate ) { addError ( <str> + state ) ; } break ; } } private void dependencyStarted ( Attributes attributes ) { state = State . DEP ; String org = substitute ( attributes . getValue ( <str> ) ) ; if ( org = = null ) { org = getMd ( ) . getModuleRevisionId ( ) . getOrganisation ( ) ; } boolean force = Boolean . valueOf ( substitute ( attributes . getValue ( <str> ) ) ) ; boolean changing = Boolean . valueOf ( substitute ( attributes . getValue ( <str> ) ) ) ; String transitiveValue = substitute ( attributes . getValue ( <str> ) ) ; boolean transitive = ( transitiveValue = = null ) ? true : Boolean . valueOf ( transitiveValue ) ; String name = substitute ( attributes . getValue ( <str> ) ) ; String branch = substitute ( attributes . getValue ( <str> ) ) ; String branchConstraint = substitute ( attributes . getValue ( <str> ) ) ; String rev = substitute ( attributes . getValue ( <str> ) ) ; String revConstraint = substitute ( attributes . getValue ( <str> ) ) ; String [ ] ignoredAttributeNames = DEPENDENCY_REGULAR_ATTRIBUTES ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , ignoredAttributeNames ) ; ModuleRevisionId revId = createModuleRevisionId ( org , name , branch , rev , extraAttributes ) ; ModuleRevisionId dynamicId ; if ( ( revConstraint = = null ) & & ( branchConstraint = = null ) ) { dynamicId = createModuleRevisionId ( org , name , branch , rev , extraAttributes , false ) ; } else { if ( branchConstraint = = null ) { dynamicId = createModuleRevisionId ( org , name , null , revConstraint , extraAttributes , false ) ; } else { dynamicId = createModuleRevisionId ( org , name , branchConstraint , revConstraint , extraAttributes ) ; } } dd = new DefaultDependencyDescriptor ( getMd ( ) , revId , dynamicId , force , changing , transitive ) ; getMd ( ) . addDependency ( dd ) ; String confs = substitute ( attributes . getValue ( <str> ) ) ; if ( confs ! = null & & confs . length ( ) > <int> ) { parseDepsConfs ( confs , dd ) ; } } private void artifactStarted ( String qName , Attributes attributes ) throws MalformedURLException { if ( state = = State . PUB ) { String artName = elvis ( substitute ( attributes . getValue ( <str> ) ) , getMd ( ) . getModuleRevisionId ( ) . getName ( ) ) ; String type = elvis ( substitute ( attributes . getValue ( <str> ) ) , <str> ) ; String ext = elvis ( substitute ( attributes . getValue ( <str> ) ) , type ) ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , new String [ ] { <str> , <str> , <str> , <str> } ) ; artifact = new BuildableIvyArtifact ( artName , type , ext , extraAttributes ) ; String confs = substitute ( attributes . getValue ( <str> ) ) ; if ( confs ! = null & & confs . length ( ) > <int> ) { String [ ] conf ; if ( <str> . equals ( confs ) ) { conf = getMd ( ) . getConfigurationsNames ( ) ; } else { conf = confs . split ( <str> ) ; } for ( String confName : conf ) { artifact . addConfiguration ( confName . trim ( ) ) ; } } } else if ( state = = State . DEP ) { addDependencyArtifacts ( qName , attributes ) ; } else if ( validate ) { addError ( <str> + state ) ; } } private void dependenciesStarted ( Attributes attributes ) { state = State . DEPS ; String defaultConf = substitute ( attributes . getValue ( <str> ) ) ; if ( defaultConf ! = null ) { setDefaultConf ( defaultConf ) ; } String defaultConfMapping = substitute ( attributes . getValue ( <str> ) ) ; if ( defaultConfMapping ! = null ) { setDefaultConfMapping ( defaultConfMapping ) ; } String confMappingOverride = substitute ( attributes . getValue ( <str> ) ) ; if ( confMappingOverride ! = null ) { getMd ( ) . setMappingOverride ( Boolean . valueOf ( confMappingOverride ) ) ; } checkConfigurations ( ) ; } private void configurationStarted ( Attributes attributes ) { state = State . CONF ; setDefaultConfMapping ( substitute ( attributes . getValue ( <str> ) ) ) ; setDefaultConf ( substitute ( attributes . getValue ( <str> ) ) ) ; getMd ( ) . setMappingOverride ( Boolean . valueOf ( substitute ( attributes . getValue ( <str> ) ) ) ) ; } private void infoStarted ( Attributes attributes ) { state = State . INFO ; String org = substitute ( attributes . getValue ( <str> ) ) ; String module = substitute ( attributes . getValue ( <str> ) ) ; String revision = substitute ( attributes . getValue ( <str> ) ) ; String branch = substitute ( attributes . getValue ( <str> ) ) ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; getMd ( ) . setModuleRevisionId ( createModuleRevisionId ( org , module , branch , revision , extraAttributes ) ) ; getMd ( ) . setStatus ( elvis ( substitute ( attributes . getValue ( <str> ) ) , <str> ) ) ; getMd ( ) . setDefault ( Boolean . valueOf ( substitute ( attributes . getValue ( <str> ) ) ) ) ; String pubDate = substitute ( attributes . getValue ( <str> ) ) ; if ( pubDate ! = null & & pubDate . length ( ) > <int> ) { try { final SimpleDateFormat ivyDateFormat = new SimpleDateFormat ( IVY_DATE_FORMAT_PATTERN ) ; getMd ( ) . setPublicationDate ( ivyDateFormat . parse ( pubDate ) ) ; } catch ( ParseException e ) { addError ( <str> + pubDate ) ; } } } private void ivyModuleStarted ( Attributes attributes ) throws SAXException { descriptorVersion = attributes . getValue ( <str> ) ; int versionIndex = ALLOWED_VERSIONS . indexOf ( descriptorVersion ) ; if ( versionIndex = = - <int> ) { addError ( <str> + descriptorVersion ) ; throw new SAXException ( <str> + descriptorVersion ) ; } if ( versionIndex > = ALLOWED_VERSIONS . indexOf ( <str> ) ) { LOGGER . debug ( <str> , PatternMatcher . EXACT ) ; defaultMatcher = getMatcher ( PatternMatcher . EXACT ) ; } else { LOGGER . debug ( <str> , PatternMatcher . EXACT_OR_REGEXP ) ; defaultMatcher = getMatcher ( PatternMatcher . EXACT_OR_REGEXP ) ; } for ( int i = <int> ; i < attributes . getLength ( ) ; i + + ) { if ( attributes . getQName ( i ) . startsWith ( <str> ) ) { getMd ( ) . addExtraAttributeNamespace ( attributes . getQName ( i ) . substring ( <str> . length ( ) ) , attributes . getValue ( i ) ) ; } } } private void descriptionStarted ( String qName , Attributes attributes ) { buffer . append ( <str> ) . append ( qName ) ; for ( int i = <int> ; i < attributes . getLength ( ) ; i + + ) { buffer . append ( <str> ) ; buffer . append ( attributes . getQName ( i ) ) ; buffer . append ( <str> ) ; buffer . append ( attributes . getValue ( i ) ) ; buffer . append ( <str> ) ; } buffer . append ( <str> ) ; } private void addDependencyArtifacts ( String tag , Attributes attributes ) throws MalformedURLException { state = State . DEP_ARTIFACT ; parseRule ( tag , attributes ) ; } private void addIncludeRule ( String tag , Attributes attributes ) throws MalformedURLException { state = State . ARTIFACT_INCLUDE ; parseRule ( tag , attributes ) ; } private void addExcludeRule ( String tag , Attributes attributes ) throws MalformedURLException { state = State . ARTIFACT_EXCLUDE ; parseRule ( tag , attributes ) ; } private void parseRule ( String tag , Attributes attributes ) throws MalformedURLException { String name = substitute ( attributes . getValue ( <str> ) ) ; if ( name = = null ) { name = substitute ( attributes . getValue ( <str> ) ) ; if ( name = = null ) { name = <str> . equals ( tag ) ? dd . getDependencyId ( ) . getName ( ) : PatternMatcher . ANY_EXPRESSION ; } } String type = substitute ( attributes . getValue ( <str> ) ) ; if ( type = = null ) { type = <str> . equals ( tag ) ? <str> : PatternMatcher . ANY_EXPRESSION ; } String ext = substitute ( attributes . getValue ( <str> ) ) ; ext = ext ! = null ? ext : type ; if ( state = = State . DEP_ARTIFACT ) { String url = substitute ( attributes . getValue ( <str> ) ) ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , new String [ ] { <str> , <str> , <str> , <str> , <str> } ) ; confAware = new DefaultDependencyArtifactDescriptor ( dd , name , type , ext , url = = null ? null : new URL ( url ) , extraAttributes ) ; } else if ( state = = State . ARTIFACT_INCLUDE ) { PatternMatcher matcher = getPatternMatcher ( attributes . getValue ( <str> ) ) ; String org = elvis ( substitute ( attributes . getValue ( <str> ) ) , PatternMatcher . ANY_EXPRESSION ) ; String module = elvis ( substitute ( attributes . getValue ( <str> ) ) , PatternMatcher . ANY_EXPRESSION ) ; ArtifactId aid = new ArtifactId ( IvyUtil . createModuleId ( org , module ) , name , type , ext ) ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; confAware = new DefaultIncludeRule ( aid , matcher , extraAttributes ) ; } else { PatternMatcher matcher = getPatternMatcher ( attributes . getValue ( <str> ) ) ; String org = elvis ( substitute ( attributes . getValue ( <str> ) ) , PatternMatcher . ANY_EXPRESSION ) ; String module = elvis ( substitute ( attributes . getValue ( <str> ) ) , PatternMatcher . ANY_EXPRESSION ) ; ArtifactId aid = new ArtifactId ( IvyUtil . createModuleId ( org , module ) , name , type , ext ) ; Map < String , String > extraAttributes = getExtraAttributes ( attributes , new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; confAware = new DefaultExcludeRule ( aid , matcher , extraAttributes ) ; } String confs = substitute ( attributes . getValue ( <str> ) ) ; if ( confs ! = null & & confs . length ( ) > <int> ) { String [ ] conf ; if ( <str> . equals ( confs ) ) { conf = getMd ( ) . getConfigurationsNames ( ) ; } else { conf = confs . split ( <str> ) ; } for ( String confName : conf ) { addConfiguration ( confName . trim ( ) ) ; } } } private void addConfiguration ( String c ) { confAware . addConfiguration ( c ) ; if ( state ! = State . EXCLUDE ) { if ( confAware instanceof DependencyArtifactDescriptor ) { dd . addDependencyArtifact ( c , ( DependencyArtifactDescriptor ) confAware ) ; } else if ( confAware instanceof IncludeRule ) { dd . addIncludeRule ( c , ( IncludeRule ) confAware ) ; } else if ( confAware instanceof ExcludeRule ) { dd . addExcludeRule ( c , ( ExcludeRule ) confAware ) ; } } } private PatternMatcher getPatternMatcher ( String m ) { String matcherName = substitute ( m ) ; PatternMatcher matcher = matcherName = = null ? defaultMatcher : getMatcher ( matcherName ) ; if ( matcher = = null ) { throw new IllegalArgumentException ( <str> + matcherName ) ; } return matcher ; } public void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( buffer ! = null ) { buffer . append ( ch , start , length ) ; } } public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( state = = State . PUB & & <str> . equals ( qName ) ) { if ( artifact . getConfigurations ( ) . isEmpty ( ) ) { String [ ] confs = publicationsDefaultConf = = null ? getMd ( ) . getConfigurationsNames ( ) : publicationsDefaultConf ; for ( String confName : confs ) { artifact . addConfiguration ( confName . trim ( ) ) ; } } metaData . addArtifact ( artifact . getArtifact ( ) , artifact . getConfigurations ( ) ) ; artifact = null ; } else if ( <str> . equals ( qName ) ) { checkConfigurations ( ) ; } else if ( ( state = = State . DEP_ARTIFACT & & <str> . equals ( qName ) ) | | ( state = = State . ARTIFACT_INCLUDE & & <str> . equals ( qName ) ) | | ( state = = State . ARTIFACT_EXCLUDE & & <str> . equals ( qName ) ) ) { state = State . DEP ; if ( confAware . getConfigurations ( ) . length = = <int> ) { String [ ] confs = getMd ( ) . getConfigurationsNames ( ) ; for ( String confName : confs ) { addConfiguration ( confName ) ; } } confAware = null ; } else if ( <str> . equals ( qName ) & & state = = State . EXCLUDE ) { if ( confAware . getConfigurations ( ) . length = = <int> ) { String [ ] confs = getMd ( ) . getConfigurationsNames ( ) ; for ( String confName : confs ) { addConfiguration ( confName ) ; } } confAware = null ; state = State . DEPS ; } else if ( <str> . equals ( qName ) & & state = = State . DEP ) { if ( dd . getModuleConfigurations ( ) . length = = <int> ) { parseDepsConfs ( getDefaultConf ( ) , dd ) ; } state = State . DEPS ; } else if ( <str> . equals ( qName ) & & state = = State . DEPS ) { state = State . NONE ; } else if ( state = = State . INFO & & <str> . equals ( qName ) ) { metaData = new BuildableIvyModuleResolveMetaData ( getMd ( ) ) ; state = State . NONE ; } else if ( state = = State . DESCRIPTION & & <str> . equals ( qName ) ) { getMd ( ) . setDescription ( buffer = = null ? <str> : buffer . toString ( ) . trim ( ) ) ; buffer = null ; state = State . INFO ; } else if ( state = = State . EXTRA_INFO ) { getMd ( ) . getExtraInfo ( ) . put ( new NamespaceId ( uri , localName ) , buffer = = null ? <str> : buffer . toString ( ) ) ; buffer = null ; state = State . INFO ; } else if ( state = = State . DESCRIPTION ) { if ( buffer . toString ( ) . endsWith ( <str> + qName + <str> ) ) { buffer . deleteCharAt ( buffer . length ( ) - <int> ) ; buffer . append ( <str> ) ; } else { buffer . append ( <str> ) . append ( qName ) . append ( <str> ) ; } } } private void checkConfigurations ( ) { if ( getMd ( ) . getConfigurations ( ) . length = = <int> ) { getMd ( ) . addConfiguration ( new Configuration ( <str> ) ) ; } } private void replaceConfigurationWildcards ( ) { Configuration [ ] configs = getMd ( ) . getConfigurations ( ) ; for ( Configuration config : configs ) { config . replaceWildcards ( getMd ( ) ) ; } } private URL getSchemaURL ( ) { URL resource = getClass ( ) . getClassLoader ( ) . getResource ( <str> ) ; assert resource ! = null ; return resource ; } private String elvis ( String value , String defaultValue ) { return value ! = null ? value : defaultValue ; } private String substitute ( String value ) { return IvyPatternHelper . substituteVariables ( value , properties ) ; } private Map < String , String > getExtraAttributes ( Attributes attributes , String [ ] ignoredAttributeNames ) { Map < String , String > ret = new HashMap < String , String > ( ) ; Collection ignored = Arrays . asList ( ignoredAttributeNames ) ; for ( int i = <int> ; i < attributes . getLength ( ) ; i + + ) { if ( ! ignored . contains ( attributes . getQName ( i ) ) ) { ret . put ( attributes . getQName ( i ) , substitute ( attributes . getValue ( i ) ) ) ; } } return ret ; } private void fillExtraAttributes ( DefaultExtendableItem item , Attributes attributes , String [ ] ignoredAttNames ) { Map < String , String > extraAttributes = getExtraAttributes ( attributes , ignoredAttNames ) ; for ( String name : extraAttributes . keySet ( ) ) { item . setExtraAttribute ( name , extraAttributes . get ( name ) ) ; } } private PatternMatcher getMatcher ( String matcherName ) { return resolverStrategy . getPatternMatcher ( matcherName ) ; } } public static class ParserHelper { static final String JAXP_SCHEMA_LANGUAGE = <str> ; static final String JAXP_SCHEMA_SOURCE = <str> ; static final String XML_NAMESPACE_PREFIXES = <str> ; static final String W3C_XML_SCHEMA = <str> ; private static SAXParser newSAXParser ( URL schema , InputStream schemaStream ) throws ParserConfigurationException , SAXException { if ( schema = = null ) { SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; parserFactory . setValidating ( false ) ; parserFactory . setNamespaceAware ( true ) ; SAXParser parser = parserFactory . newSAXParser ( ) ; parser . getXMLReader ( ) . setFeature ( XML_NAMESPACE_PREFIXES , true ) ; return parser ; } else { SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; parserFactory . setValidating ( true ) ; parserFactory . setNamespaceAware ( true ) ; SAXParser parser = parserFactory . newSAXParser ( ) ; parser . setProperty ( JAXP_SCHEMA_LANGUAGE , W3C_XML_SCHEMA ) ; parser . setProperty ( JAXP_SCHEMA_SOURCE , schemaStream ) ; parser . getXMLReader ( ) . setFeature ( XML_NAMESPACE_PREFIXES , true ) ; return parser ; } } public static void parse ( URL xmlURL , URL schema , DefaultHandler handler ) throws SAXException , IOException , ParserConfigurationException { InputStream xmlStream = URLHandlerRegistry . getDefault ( ) . openStream ( xmlURL ) ; try { InputSource inSrc = new InputSource ( xmlStream ) ; inSrc . setSystemId ( xmlURL . toExternalForm ( ) ) ; parse ( inSrc , schema , handler ) ; } finally { try { xmlStream . close ( ) ; } catch ( IOException e ) { } } } public static void parse ( InputSource xmlStream , URL schema , DefaultHandler handler ) throws SAXException , IOException , ParserConfigurationException { InputStream schemaStream = null ; try { if ( schema ! = null ) { schemaStream = URLHandlerRegistry . getDefault ( ) . openStream ( schema ) ; } SAXParser parser = newSAXParser ( schema , schemaStream ) ; parser . parse ( xmlStream , handler ) ; } finally { if ( schemaStream ! = null ) { try { schemaStream . close ( ) ; } catch ( IOException ex ) { } } } } } public String toString ( ) { return <str> ; } } 
