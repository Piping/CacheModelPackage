package org . apache . cassandra . io . compress ; import org . apache . cassandra . utils . FBUtilities ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import java . util . zip . DataFormatException ; import java . util . zip . Deflater ; import java . util . zip . Inflater ; public class DeflateCompressor implements ICompressor { public static final DeflateCompressor instance = new DeflateCompressor ( ) ; private final ThreadLocal < Deflater > deflater ; private final ThreadLocal < Inflater > inflater ; public static DeflateCompressor create ( Map < String , String > compressionOptions ) { return instance ; } private DeflateCompressor ( ) { deflater = new ThreadLocal < Deflater > ( ) { @Override protected Deflater initialValue ( ) { return new Deflater ( ) ; } } ; inflater = new ThreadLocal < Inflater > ( ) { @Override protected Inflater initialValue ( ) { return new Inflater ( ) ; } } ; } public Set < String > supportedOptions ( ) { return Collections . emptySet ( ) ; } public int initialCompressedBufferLength ( int sourceLen ) { return sourceLen + ( sourceLen > > <int> ) + ( sourceLen > > <int> ) + ( sourceLen > > <int> ) + <int> ; } public void compress ( ByteBuffer input , ByteBuffer output ) { if ( input . hasArray ( ) & & output . hasArray ( ) ) { int length = compressArray ( input . array ( ) , input . arrayOffset ( ) + input . position ( ) , input . remaining ( ) , output . array ( ) , output . arrayOffset ( ) + output . position ( ) , output . remaining ( ) ) ; input . position ( input . limit ( ) ) ; output . position ( output . position ( ) + length ) ; } else compressBuffer ( input , output ) ; } public int compressArray ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) { Deflater def = deflater . get ( ) ; def . reset ( ) ; def . setInput ( input , inputOffset , inputLength ) ; def . finish ( ) ; if ( def . needsInput ( ) ) return <int> ; int len = def . deflate ( output , outputOffset , maxOutputLength ) ; assert def . finished ( ) ; return len ; } public void compressBuffer ( ByteBuffer input , ByteBuffer output ) { Deflater def = deflater . get ( ) ; def . reset ( ) ; byte [ ] buffer = FBUtilities . getThreadLocalScratchBuffer ( ) ; int chunkLen = buffer . length / <int> ; while ( input . remaining ( ) > chunkLen ) { input . get ( buffer , <int> , chunkLen ) ; def . setInput ( buffer , <int> , chunkLen ) ; while ( ! def . needsInput ( ) ) { int len = def . deflate ( buffer , chunkLen , chunkLen ) ; output . put ( buffer , chunkLen , len ) ; } } int inputLength = input . remaining ( ) ; input . get ( buffer , <int> , inputLength ) ; def . setInput ( buffer , <int> , inputLength ) ; def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buffer , chunkLen , chunkLen ) ; output . put ( buffer , chunkLen , len ) ; } } public void uncompress ( ByteBuffer input , ByteBuffer output ) throws IOException { if ( input . hasArray ( ) & & output . hasArray ( ) ) { int length = uncompress ( input . array ( ) , input . arrayOffset ( ) + input . position ( ) , input . remaining ( ) , output . array ( ) , output . arrayOffset ( ) + output . position ( ) , output . remaining ( ) ) ; input . position ( input . limit ( ) ) ; output . position ( output . position ( ) + length ) ; } else uncompressBuffer ( input , output ) ; } public void uncompressBuffer ( ByteBuffer input , ByteBuffer output ) throws IOException { try { Inflater inf = inflater . get ( ) ; inf . reset ( ) ; byte [ ] buffer = FBUtilities . getThreadLocalScratchBuffer ( ) ; int chunkLen = buffer . length / <int> ; while ( input . remaining ( ) > chunkLen ) { input . get ( buffer , <int> , chunkLen ) ; inf . setInput ( buffer , <int> , chunkLen ) ; while ( ! inf . needsInput ( ) ) { int len = inf . inflate ( buffer , chunkLen , chunkLen ) ; output . put ( buffer , chunkLen , len ) ; } } int inputLength = input . remaining ( ) ; input . get ( buffer , <int> , inputLength ) ; inf . setInput ( buffer , <int> , inputLength ) ; while ( ! inf . needsInput ( ) ) { int len = inf . inflate ( buffer , chunkLen , chunkLen ) ; output . put ( buffer , chunkLen , len ) ; } } catch ( DataFormatException e ) { throw new IOException ( e ) ; } } public int uncompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset ) throws IOException { return uncompress ( input , inputOffset , inputLength , output , outputOffset , output . length - outputOffset ) ; } public int uncompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset , int maxOutputLength ) throws IOException { Inflater inf = inflater . get ( ) ; inf . reset ( ) ; inf . setInput ( input , inputOffset , inputLength ) ; if ( inf . needsInput ( ) ) return <int> ; try { return inf . inflate ( output , outputOffset , maxOutputLength ) ; } catch ( DataFormatException e ) { throw new IOException ( e ) ; } } public boolean supports ( BufferType bufferType ) { return true ; } public BufferType preferredBufferType ( ) { return BufferType . ON_HEAP ; } } 
