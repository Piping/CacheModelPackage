package org . apache . cassandra . tools ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . compaction . * ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . OutputHandler ; import org . apache . commons . cli . * ; import java . util . * ; import java . util . concurrent . TimeUnit ; import static org . apache . cassandra . tools . BulkLoader . CmdLineOptions ; public class StandaloneVerifier { private static final String TOOL_NAME = <str> ; private static final String VERBOSE_OPTION = <str> ; private static final String EXTENDED_OPTION = <str> ; private static final String DEBUG_OPTION = <str> ; private static final String HELP_OPTION = <str> ; public static void main ( String args [ ] ) { Options options = Options . parseArgs ( args ) ; Util . initDatabaseDescriptor ( ) ; try { Schema . instance . loadFromDisk ( false ) ; boolean hasFailed = false ; if ( Schema . instance . getCFMetaData ( options . keyspaceName , options . cfName ) = = null ) throw new IllegalArgumentException ( String . format ( <str> , options . keyspaceName , options . cfName ) ) ; Keyspace keyspace = Keyspace . openWithoutSSTables ( options . keyspaceName ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( options . cfName ) ; OutputHandler handler = new OutputHandler . SystemOutput ( options . verbose , options . debug ) ; Directories . SSTableLister lister = cfs . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) ; boolean extended = options . extended ; List < SSTableReader > sstables = new ArrayList < > ( ) ; for ( Map . Entry < Descriptor , Set < Component > > entry : lister . list ( ) . entrySet ( ) ) { Set < Component > components = entry . getValue ( ) ; if ( ! components . contains ( Component . DATA ) | | ! components . contains ( Component . PRIMARY_INDEX ) ) continue ; try { SSTableReader sstable = SSTableReader . openNoValidation ( entry . getKey ( ) , components , cfs ) ; sstables . add ( sstable ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; System . err . println ( String . format ( <str> , entry . getKey ( ) , e . getMessage ( ) ) ) ; if ( options . debug ) e . printStackTrace ( System . err ) ; } } for ( SSTableReader sstable : sstables ) { try { try ( Verifier verifier = new Verifier ( cfs , sstable , handler , true ) ) { verifier . verify ( extended ) ; } catch ( CorruptSSTableException cs ) { System . err . println ( String . format ( <str> , sstable , cs . getMessage ( ) ) ) ; hasFailed = true ; } } catch ( Exception e ) { System . err . println ( String . format ( <str> , sstable , e . getMessage ( ) ) ) ; e . printStackTrace ( System . err ) ; } } CompactionManager . instance . finishCompactionsAndShutdown ( <int> , TimeUnit . MINUTES ) ; System . exit ( hasFailed ? <int> : <int> ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; if ( options . debug ) e . printStackTrace ( System . err ) ; System . exit ( <int> ) ; } } private static class Options { public final String keyspaceName ; public final String cfName ; public boolean debug ; public boolean verbose ; public boolean extended ; private Options ( String keyspaceName , String cfName ) { this . keyspaceName = keyspaceName ; this . cfName = cfName ; } public static Options parseArgs ( String cmdArgs [ ] ) { CommandLineParser parser = new GnuParser ( ) ; CmdLineOptions options = getCmdLineOptions ( ) ; try { CommandLine cmd = parser . parse ( options , cmdArgs , false ) ; if ( cmd . hasOption ( HELP_OPTION ) ) { printUsage ( options ) ; System . exit ( <int> ) ; } String [ ] args = cmd . getArgs ( ) ; if ( args . length ! = <int> ) { String msg = args . length < <int> ? <str> : <str> ; System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } String keyspaceName = args [ <int> ] ; String cfName = args [ <int> ] ; Options opts = new Options ( keyspaceName , cfName ) ; opts . debug = cmd . hasOption ( DEBUG_OPTION ) ; opts . verbose = cmd . hasOption ( VERBOSE_OPTION ) ; opts . extended = cmd . hasOption ( EXTENDED_OPTION ) ; return opts ; } catch ( ParseException e ) { errorMsg ( e . getMessage ( ) , options ) ; return null ; } } private static void errorMsg ( String msg , CmdLineOptions options ) { System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } private static CmdLineOptions getCmdLineOptions ( ) { CmdLineOptions options = new CmdLineOptions ( ) ; options . addOption ( null , DEBUG_OPTION , <str> ) ; options . addOption ( <str> , EXTENDED_OPTION , <str> ) ; options . addOption ( <str> , VERBOSE_OPTION , <str> ) ; options . addOption ( <str> , HELP_OPTION , <str> ) ; return options ; } public static void printUsage ( CmdLineOptions options ) { String usage = String . format ( <str> , TOOL_NAME ) ; StringBuilder header = new StringBuilder ( ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; new HelpFormatter ( ) . printHelp ( usage , header . toString ( ) , options , <str> ) ; } } } 
