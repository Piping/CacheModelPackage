package com . badlogic . gdx . utils . compression . lzma ; import java . io . IOException ; import com . badlogic . gdx . utils . compression . ICodeProgress ; import com . badlogic . gdx . utils . compression . rangecoder . BitTreeEncoder ; public class Encoder { public static final int EMatchFinderTypeBT2 = <int> ; public static final int EMatchFinderTypeBT4 = <int> ; static final int kIfinityPrice = <hex> ; static byte [ ] g_FastPos = new byte [ <int> < < <int> ] ; static { int kFastSlots = <int> ; int c = <int> ; g_FastPos [ <int> ] = <int> ; g_FastPos [ <int> ] = <int> ; for ( int slotFast = <int> ; slotFast < kFastSlots ; slotFast + + ) { int k = ( <int> < < ( ( slotFast > > <int> ) - <int> ) ) ; for ( int j = <int> ; j < k ; j + + , c + + ) g_FastPos [ c ] = ( byte ) slotFast ; } } static int GetPosSlot ( int pos ) { if ( pos < ( <int> < < <int> ) ) return g_FastPos [ pos ] ; if ( pos < ( <int> < < <int> ) ) return ( g_FastPos [ pos > > <int> ] + <int> ) ; return ( g_FastPos [ pos > > <int> ] + <int> ) ; } static int GetPosSlot2 ( int pos ) { if ( pos < ( <int> < < <int> ) ) return ( g_FastPos [ pos > > <int> ] + <int> ) ; if ( pos < ( <int> < < <int> ) ) return ( g_FastPos [ pos > > <int> ] + <int> ) ; return ( g_FastPos [ pos > > <int> ] + <int> ) ; } int _state = Base . StateInit ( ) ; byte _previousByte ; int [ ] _repDistances = new int [ Base . kNumRepDistances ] ; void BaseInit ( ) { _state = Base . StateInit ( ) ; _previousByte = <int> ; for ( int i = <int> ; i < Base . kNumRepDistances ; i + + ) _repDistances [ i ] = <int> ; } static final int kDefaultDictionaryLogSize = <int> ; static final int kNumFastBytesDefault = <hex> ; class LiteralEncoder { class Encoder2 { short [ ] m_Encoders = new short [ <hex> ] ; public void Init ( ) { com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( m_Encoders ) ; } public void Encode ( com . badlogic . gdx . utils . compression . rangecoder . Encoder rangeEncoder , byte symbol ) throws IOException { int context = <int> ; for ( int i = <int> ; i > = <int> ; i - - ) { int bit = ( ( symbol > > i ) & <int> ) ; rangeEncoder . Encode ( m_Encoders , context , bit ) ; context = ( context < < <int> ) | bit ; } } public void EncodeMatched ( com . badlogic . gdx . utils . compression . rangecoder . Encoder rangeEncoder , byte matchByte , byte symbol ) throws IOException { int context = <int> ; boolean same = true ; for ( int i = <int> ; i > = <int> ; i - - ) { int bit = ( ( symbol > > i ) & <int> ) ; int state = context ; if ( same ) { int matchBit = ( ( matchByte > > i ) & <int> ) ; state + = ( ( <int> + matchBit ) < < <int> ) ; same = ( matchBit = = bit ) ; } rangeEncoder . Encode ( m_Encoders , state , bit ) ; context = ( context < < <int> ) | bit ; } } public int GetPrice ( boolean matchMode , byte matchByte , byte symbol ) { int price = <int> ; int context = <int> ; int i = <int> ; if ( matchMode ) { for ( ; i > = <int> ; i - - ) { int matchBit = ( matchByte > > i ) & <int> ; int bit = ( symbol > > i ) & <int> ; price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice ( m_Encoders [ ( ( <int> + matchBit ) < < <int> ) + context ] , bit ) ; context = ( context < < <int> ) | bit ; if ( matchBit ! = bit ) { i - - ; break ; } } } for ( ; i > = <int> ; i - - ) { int bit = ( symbol > > i ) & <int> ; price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice ( m_Encoders [ context ] , bit ) ; context = ( context < < <int> ) | bit ; } return price ; } } Encoder2 [ ] m_Coders ; int m_NumPrevBits ; int m_NumPosBits ; int m_PosMask ; public void Create ( int numPosBits , int numPrevBits ) { if ( m_Coders ! = null & & m_NumPrevBits = = numPrevBits & & m_NumPosBits = = numPosBits ) return ; m_NumPosBits = numPosBits ; m_PosMask = ( <int> < < numPosBits ) - <int> ; m_NumPrevBits = numPrevBits ; int numStates = <int> < < ( m_NumPrevBits + m_NumPosBits ) ; m_Coders = new Encoder2 [ numStates ] ; for ( int i = <int> ; i < numStates ; i + + ) m_Coders [ i ] = new Encoder2 ( ) ; } public void Init ( ) { int numStates = <int> < < ( m_NumPrevBits + m_NumPosBits ) ; for ( int i = <int> ; i < numStates ; i + + ) m_Coders [ i ] . Init ( ) ; } public Encoder2 GetSubCoder ( int pos , byte prevByte ) { return m_Coders [ ( ( pos & m_PosMask ) < < m_NumPrevBits ) + ( ( prevByte & <hex> ) > > > ( <int> - m_NumPrevBits ) ) ] ; } } class LenEncoder { short [ ] _choice = new short [ <int> ] ; BitTreeEncoder [ ] _lowCoder = new BitTreeEncoder [ Base . kNumPosStatesEncodingMax ] ; BitTreeEncoder [ ] _midCoder = new BitTreeEncoder [ Base . kNumPosStatesEncodingMax ] ; BitTreeEncoder _highCoder = new BitTreeEncoder ( Base . kNumHighLenBits ) ; public LenEncoder ( ) { for ( int posState = <int> ; posState < Base . kNumPosStatesEncodingMax ; posState + + ) { _lowCoder [ posState ] = new BitTreeEncoder ( Base . kNumLowLenBits ) ; _midCoder [ posState ] = new BitTreeEncoder ( Base . kNumMidLenBits ) ; } } public void Init ( int numPosStates ) { com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _choice ) ; for ( int posState = <int> ; posState < numPosStates ; posState + + ) { _lowCoder [ posState ] . Init ( ) ; _midCoder [ posState ] . Init ( ) ; } _highCoder . Init ( ) ; } public void Encode ( com . badlogic . gdx . utils . compression . rangecoder . Encoder rangeEncoder , int symbol , int posState ) throws IOException { if ( symbol < Base . kNumLowLenSymbols ) { rangeEncoder . Encode ( _choice , <int> , <int> ) ; _lowCoder [ posState ] . Encode ( rangeEncoder , symbol ) ; } else { symbol - = Base . kNumLowLenSymbols ; rangeEncoder . Encode ( _choice , <int> , <int> ) ; if ( symbol < Base . kNumMidLenSymbols ) { rangeEncoder . Encode ( _choice , <int> , <int> ) ; _midCoder [ posState ] . Encode ( rangeEncoder , symbol ) ; } else { rangeEncoder . Encode ( _choice , <int> , <int> ) ; _highCoder . Encode ( rangeEncoder , symbol - Base . kNumMidLenSymbols ) ; } } } public void SetPrices ( int posState , int numSymbols , int [ ] prices , int st ) { int a0 = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _choice [ <int> ] ) ; int a1 = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _choice [ <int> ] ) ; int b0 = a1 + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _choice [ <int> ] ) ; int b1 = a1 + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _choice [ <int> ] ) ; int i = <int> ; for ( i = <int> ; i < Base . kNumLowLenSymbols ; i + + ) { if ( i > = numSymbols ) return ; prices [ st + i ] = a0 + _lowCoder [ posState ] . GetPrice ( i ) ; } for ( ; i < Base . kNumLowLenSymbols + Base . kNumMidLenSymbols ; i + + ) { if ( i > = numSymbols ) return ; prices [ st + i ] = b0 + _midCoder [ posState ] . GetPrice ( i - Base . kNumLowLenSymbols ) ; } for ( ; i < numSymbols ; i + + ) prices [ st + i ] = b1 + _highCoder . GetPrice ( i - Base . kNumLowLenSymbols - Base . kNumMidLenSymbols ) ; } } ; public static final int kNumLenSpecSymbols = Base . kNumLowLenSymbols + Base . kNumMidLenSymbols ; class LenPriceTableEncoder extends LenEncoder { int [ ] _prices = new int [ Base . kNumLenSymbols < < Base . kNumPosStatesBitsEncodingMax ] ; int _tableSize ; int [ ] _counters = new int [ Base . kNumPosStatesEncodingMax ] ; public void SetTableSize ( int tableSize ) { _tableSize = tableSize ; } public int GetPrice ( int symbol , int posState ) { return _prices [ posState * Base . kNumLenSymbols + symbol ] ; } void UpdateTable ( int posState ) { SetPrices ( posState , _tableSize , _prices , posState * Base . kNumLenSymbols ) ; _counters [ posState ] = _tableSize ; } public void UpdateTables ( int numPosStates ) { for ( int posState = <int> ; posState < numPosStates ; posState + + ) UpdateTable ( posState ) ; } public void Encode ( com . badlogic . gdx . utils . compression . rangecoder . Encoder rangeEncoder , int symbol , int posState ) throws IOException { super . Encode ( rangeEncoder , symbol , posState ) ; if ( - - _counters [ posState ] = = <int> ) UpdateTable ( posState ) ; } } static final int kNumOpts = <int> < < <int> ; class Optimal { public int State ; public boolean Prev1IsChar ; public boolean Prev2 ; public int PosPrev2 ; public int BackPrev2 ; public int Price ; public int PosPrev ; public int BackPrev ; public int Backs0 ; public int Backs1 ; public int Backs2 ; public int Backs3 ; public void MakeAsChar ( ) { BackPrev = - <int> ; Prev1IsChar = false ; } public void MakeAsShortRep ( ) { BackPrev = <int> ; ; Prev1IsChar = false ; } public boolean IsShortRep ( ) { return ( BackPrev = = <int> ) ; } } ; Optimal [ ] _optimum = new Optimal [ kNumOpts ] ; com . badlogic . gdx . utils . compression . lz . BinTree _matchFinder = null ; com . badlogic . gdx . utils . compression . rangecoder . Encoder _rangeEncoder = new com . badlogic . gdx . utils . compression . rangecoder . Encoder ( ) ; short [ ] _isMatch = new short [ Base . kNumStates < < Base . kNumPosStatesBitsMax ] ; short [ ] _isRep = new short [ Base . kNumStates ] ; short [ ] _isRepG0 = new short [ Base . kNumStates ] ; short [ ] _isRepG1 = new short [ Base . kNumStates ] ; short [ ] _isRepG2 = new short [ Base . kNumStates ] ; short [ ] _isRep0Long = new short [ Base . kNumStates < < Base . kNumPosStatesBitsMax ] ; BitTreeEncoder [ ] _posSlotEncoder = new BitTreeEncoder [ Base . kNumLenToPosStates ] ; short [ ] _posEncoders = new short [ Base . kNumFullDistances - Base . kEndPosModelIndex ] ; BitTreeEncoder _posAlignEncoder = new BitTreeEncoder ( Base . kNumAlignBits ) ; LenPriceTableEncoder _lenEncoder = new LenPriceTableEncoder ( ) ; LenPriceTableEncoder _repMatchLenEncoder = new LenPriceTableEncoder ( ) ; LiteralEncoder _literalEncoder = new LiteralEncoder ( ) ; int [ ] _matchDistances = new int [ Base . kMatchMaxLen * <int> + <int> ] ; int _numFastBytes = kNumFastBytesDefault ; int _longestMatchLength ; int _numDistancePairs ; int _additionalOffset ; int _optimumEndIndex ; int _optimumCurrentIndex ; boolean _longestMatchWasFound ; int [ ] _posSlotPrices = new int [ <int> < < ( Base . kNumPosSlotBits + Base . kNumLenToPosStatesBits ) ] ; int [ ] _distancesPrices = new int [ Base . kNumFullDistances < < Base . kNumLenToPosStatesBits ] ; int [ ] _alignPrices = new int [ Base . kAlignTableSize ] ; int _alignPriceCount ; int _distTableSize = ( kDefaultDictionaryLogSize * <int> ) ; int _posStateBits = <int> ; int _posStateMask = ( <int> - <int> ) ; int _numLiteralPosStateBits = <int> ; int _numLiteralContextBits = <int> ; int _dictionarySize = ( <int> < < kDefaultDictionaryLogSize ) ; int _dictionarySizePrev = - <int> ; int _numFastBytesPrev = - <int> ; long nowPos64 ; boolean _finished ; java . io . InputStream _inStream ; int _matchFinderType = EMatchFinderTypeBT4 ; boolean _writeEndMark = false ; boolean _needReleaseMFStream = false ; void Create ( ) { if ( _matchFinder = = null ) { com . badlogic . gdx . utils . compression . lz . BinTree bt = new com . badlogic . gdx . utils . compression . lz . BinTree ( ) ; int numHashBytes = <int> ; if ( _matchFinderType = = EMatchFinderTypeBT2 ) numHashBytes = <int> ; bt . SetType ( numHashBytes ) ; _matchFinder = bt ; } _literalEncoder . Create ( _numLiteralPosStateBits , _numLiteralContextBits ) ; if ( _dictionarySize = = _dictionarySizePrev & & _numFastBytesPrev = = _numFastBytes ) return ; _matchFinder . Create ( _dictionarySize , kNumOpts , _numFastBytes , Base . kMatchMaxLen + <int> ) ; _dictionarySizePrev = _dictionarySize ; _numFastBytesPrev = _numFastBytes ; } public Encoder ( ) { for ( int i = <int> ; i < kNumOpts ; i + + ) _optimum [ i ] = new Optimal ( ) ; for ( int i = <int> ; i < Base . kNumLenToPosStates ; i + + ) _posSlotEncoder [ i ] = new BitTreeEncoder ( Base . kNumPosSlotBits ) ; } void SetWriteEndMarkerMode ( boolean writeEndMarker ) { _writeEndMark = writeEndMarker ; } void Init ( ) { BaseInit ( ) ; _rangeEncoder . Init ( ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isMatch ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isRep0Long ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isRep ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isRepG0 ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isRepG1 ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _isRepG2 ) ; com . badlogic . gdx . utils . compression . rangecoder . Encoder . InitBitModels ( _posEncoders ) ; _literalEncoder . Init ( ) ; for ( int i = <int> ; i < Base . kNumLenToPosStates ; i + + ) _posSlotEncoder [ i ] . Init ( ) ; _lenEncoder . Init ( <int> < < _posStateBits ) ; _repMatchLenEncoder . Init ( <int> < < _posStateBits ) ; _posAlignEncoder . Init ( ) ; _longestMatchWasFound = false ; _optimumEndIndex = <int> ; _optimumCurrentIndex = <int> ; _additionalOffset = <int> ; } int ReadMatchDistances ( ) throws java . io . IOException { int lenRes = <int> ; _numDistancePairs = _matchFinder . GetMatches ( _matchDistances ) ; if ( _numDistancePairs > <int> ) { lenRes = _matchDistances [ _numDistancePairs - <int> ] ; if ( lenRes = = _numFastBytes ) lenRes + = _matchFinder . GetMatchLen ( ( int ) lenRes - <int> , _matchDistances [ _numDistancePairs - <int> ] , Base . kMatchMaxLen - lenRes ) ; } _additionalOffset + + ; return lenRes ; } void MovePos ( int num ) throws java . io . IOException { if ( num > <int> ) { _matchFinder . Skip ( num ) ; _additionalOffset + = num ; } } int GetRepLen1Price ( int state , int posState ) { return com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRepG0 [ state ] ) + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRep0Long [ ( state < < Base . kNumPosStatesBitsMax ) + posState ] ) ; } int GetPureRepPrice ( int repIndex , int state , int posState ) { int price ; if ( repIndex = = <int> ) { price = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRepG0 [ state ] ) ; price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep0Long [ ( state < < Base . kNumPosStatesBitsMax ) + posState ] ) ; } else { price = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRepG0 [ state ] ) ; if ( repIndex = = <int> ) price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRepG1 [ state ] ) ; else { price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRepG1 [ state ] ) ; price + = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice ( _isRepG2 [ state ] , repIndex - <int> ) ; } } return price ; } int GetRepPrice ( int repIndex , int len , int state , int posState ) { int price = _repMatchLenEncoder . GetPrice ( len - Base . kMatchMinLen , posState ) ; return price + GetPureRepPrice ( repIndex , state , posState ) ; } int GetPosLenPrice ( int pos , int len , int posState ) { int price ; int lenToPosState = Base . GetLenToPosState ( len ) ; if ( pos < Base . kNumFullDistances ) price = _distancesPrices [ ( lenToPosState * Base . kNumFullDistances ) + pos ] ; else price = _posSlotPrices [ ( lenToPosState < < Base . kNumPosSlotBits ) + GetPosSlot2 ( pos ) ] + _alignPrices [ pos & Base . kAlignMask ] ; return price + _lenEncoder . GetPrice ( len - Base . kMatchMinLen , posState ) ; } int Backward ( int cur ) { _optimumEndIndex = cur ; int posMem = _optimum [ cur ] . PosPrev ; int backMem = _optimum [ cur ] . BackPrev ; do { if ( _optimum [ cur ] . Prev1IsChar ) { _optimum [ posMem ] . MakeAsChar ( ) ; _optimum [ posMem ] . PosPrev = posMem - <int> ; if ( _optimum [ cur ] . Prev2 ) { _optimum [ posMem - <int> ] . Prev1IsChar = false ; _optimum [ posMem - <int> ] . PosPrev = _optimum [ cur ] . PosPrev2 ; _optimum [ posMem - <int> ] . BackPrev = _optimum [ cur ] . BackPrev2 ; } } int posPrev = posMem ; int backCur = backMem ; backMem = _optimum [ posPrev ] . BackPrev ; posMem = _optimum [ posPrev ] . PosPrev ; _optimum [ posPrev ] . BackPrev = backCur ; _optimum [ posPrev ] . PosPrev = cur ; cur = posPrev ; } while ( cur > <int> ) ; backRes = _optimum [ <int> ] . BackPrev ; _optimumCurrentIndex = _optimum [ <int> ] . PosPrev ; return _optimumCurrentIndex ; } int [ ] reps = new int [ Base . kNumRepDistances ] ; int [ ] repLens = new int [ Base . kNumRepDistances ] ; int backRes ; int GetOptimum ( int position ) throws IOException { if ( _optimumEndIndex ! = _optimumCurrentIndex ) { int lenRes = _optimum [ _optimumCurrentIndex ] . PosPrev - _optimumCurrentIndex ; backRes = _optimum [ _optimumCurrentIndex ] . BackPrev ; _optimumCurrentIndex = _optimum [ _optimumCurrentIndex ] . PosPrev ; return lenRes ; } _optimumCurrentIndex = _optimumEndIndex = <int> ; int lenMain , numDistancePairs ; if ( ! _longestMatchWasFound ) { lenMain = ReadMatchDistances ( ) ; } else { lenMain = _longestMatchLength ; _longestMatchWasFound = false ; } numDistancePairs = _numDistancePairs ; int numAvailableBytes = _matchFinder . GetNumAvailableBytes ( ) + <int> ; if ( numAvailableBytes < <int> ) { backRes = - <int> ; return <int> ; } if ( numAvailableBytes > Base . kMatchMaxLen ) numAvailableBytes = Base . kMatchMaxLen ; int repMaxIndex = <int> ; int i ; for ( i = <int> ; i < Base . kNumRepDistances ; i + + ) { reps [ i ] = _repDistances [ i ] ; repLens [ i ] = _matchFinder . GetMatchLen ( <int> - <int> , reps [ i ] , Base . kMatchMaxLen ) ; if ( repLens [ i ] > repLens [ repMaxIndex ] ) repMaxIndex = i ; } if ( repLens [ repMaxIndex ] > = _numFastBytes ) { backRes = repMaxIndex ; int lenRes = repLens [ repMaxIndex ] ; MovePos ( lenRes - <int> ) ; return lenRes ; } if ( lenMain > = _numFastBytes ) { backRes = _matchDistances [ numDistancePairs - <int> ] + Base . kNumRepDistances ; MovePos ( lenMain - <int> ) ; return lenMain ; } byte currentByte = _matchFinder . GetIndexByte ( <int> - <int> ) ; byte matchByte = _matchFinder . GetIndexByte ( <int> - _repDistances [ <int> ] - <int> - <int> ) ; if ( lenMain < <int> & & currentByte ! = matchByte & & repLens [ repMaxIndex ] < <int> ) { backRes = - <int> ; return <int> ; } _optimum [ <int> ] . State = _state ; int posState = ( position & _posStateMask ) ; _optimum [ <int> ] . Price = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isMatch [ ( _state < < Base . kNumPosStatesBitsMax ) + posState ] ) + _literalEncoder . GetSubCoder ( position , _previousByte ) . GetPrice ( ! Base . StateIsCharState ( _state ) , matchByte , currentByte ) ; _optimum [ <int> ] . MakeAsChar ( ) ; int matchPrice = com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isMatch [ ( _state < < Base . kNumPosStatesBitsMax ) + posState ] ) ; int repMatchPrice = matchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep [ _state ] ) ; if ( matchByte = = currentByte ) { int shortRepPrice = repMatchPrice + GetRepLen1Price ( _state , posState ) ; if ( shortRepPrice < _optimum [ <int> ] . Price ) { _optimum [ <int> ] . Price = shortRepPrice ; _optimum [ <int> ] . MakeAsShortRep ( ) ; } } int lenEnd = ( ( lenMain > = repLens [ repMaxIndex ] ) ? lenMain : repLens [ repMaxIndex ] ) ; if ( lenEnd < <int> ) { backRes = _optimum [ <int> ] . BackPrev ; return <int> ; } _optimum [ <int> ] . PosPrev = <int> ; _optimum [ <int> ] . Backs0 = reps [ <int> ] ; _optimum [ <int> ] . Backs1 = reps [ <int> ] ; _optimum [ <int> ] . Backs2 = reps [ <int> ] ; _optimum [ <int> ] . Backs3 = reps [ <int> ] ; int len = lenEnd ; do _optimum [ len - - ] . Price = kIfinityPrice ; while ( len > = <int> ) ; for ( i = <int> ; i < Base . kNumRepDistances ; i + + ) { int repLen = repLens [ i ] ; if ( repLen < <int> ) continue ; int price = repMatchPrice + GetPureRepPrice ( i , _state , posState ) ; do { int curAndLenPrice = price + _repMatchLenEncoder . GetPrice ( repLen - <int> , posState ) ; Optimal optimum = _optimum [ repLen ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = <int> ; optimum . BackPrev = i ; optimum . Prev1IsChar = false ; } } while ( - - repLen > = <int> ) ; } int normalMatchPrice = matchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRep [ _state ] ) ; len = ( ( repLens [ <int> ] > = <int> ) ? repLens [ <int> ] + <int> : <int> ) ; if ( len < = lenMain ) { int offs = <int> ; while ( len > _matchDistances [ offs ] ) offs + = <int> ; for ( ; ; len + + ) { int distance = _matchDistances [ offs + <int> ] ; int curAndLenPrice = normalMatchPrice + GetPosLenPrice ( distance , len , posState ) ; Optimal optimum = _optimum [ len ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = <int> ; optimum . BackPrev = distance + Base . kNumRepDistances ; optimum . Prev1IsChar = false ; } if ( len = = _matchDistances [ offs ] ) { offs + = <int> ; if ( offs = = numDistancePairs ) break ; } } } int cur = <int> ; while ( true ) { cur + + ; if ( cur = = lenEnd ) return Backward ( cur ) ; int newLen = ReadMatchDistances ( ) ; numDistancePairs = _numDistancePairs ; if ( newLen > = _numFastBytes ) { _longestMatchLength = newLen ; _longestMatchWasFound = true ; return Backward ( cur ) ; } position + + ; int posPrev = _optimum [ cur ] . PosPrev ; int state ; if ( _optimum [ cur ] . Prev1IsChar ) { posPrev - - ; if ( _optimum [ cur ] . Prev2 ) { state = _optimum [ _optimum [ cur ] . PosPrev2 ] . State ; if ( _optimum [ cur ] . BackPrev2 < Base . kNumRepDistances ) state = Base . StateUpdateRep ( state ) ; else state = Base . StateUpdateMatch ( state ) ; } else state = _optimum [ posPrev ] . State ; state = Base . StateUpdateChar ( state ) ; } else state = _optimum [ posPrev ] . State ; if ( posPrev = = cur - <int> ) { if ( _optimum [ cur ] . IsShortRep ( ) ) state = Base . StateUpdateShortRep ( state ) ; else state = Base . StateUpdateChar ( state ) ; } else { int pos ; if ( _optimum [ cur ] . Prev1IsChar & & _optimum [ cur ] . Prev2 ) { posPrev = _optimum [ cur ] . PosPrev2 ; pos = _optimum [ cur ] . BackPrev2 ; state = Base . StateUpdateRep ( state ) ; } else { pos = _optimum [ cur ] . BackPrev ; if ( pos < Base . kNumRepDistances ) state = Base . StateUpdateRep ( state ) ; else state = Base . StateUpdateMatch ( state ) ; } Optimal opt = _optimum [ posPrev ] ; if ( pos < Base . kNumRepDistances ) { if ( pos = = <int> ) { reps [ <int> ] = opt . Backs0 ; reps [ <int> ] = opt . Backs1 ; reps [ <int> ] = opt . Backs2 ; reps [ <int> ] = opt . Backs3 ; } else if ( pos = = <int> ) { reps [ <int> ] = opt . Backs1 ; reps [ <int> ] = opt . Backs0 ; reps [ <int> ] = opt . Backs2 ; reps [ <int> ] = opt . Backs3 ; } else if ( pos = = <int> ) { reps [ <int> ] = opt . Backs2 ; reps [ <int> ] = opt . Backs0 ; reps [ <int> ] = opt . Backs1 ; reps [ <int> ] = opt . Backs3 ; } else { reps [ <int> ] = opt . Backs3 ; reps [ <int> ] = opt . Backs0 ; reps [ <int> ] = opt . Backs1 ; reps [ <int> ] = opt . Backs2 ; } } else { reps [ <int> ] = ( pos - Base . kNumRepDistances ) ; reps [ <int> ] = opt . Backs0 ; reps [ <int> ] = opt . Backs1 ; reps [ <int> ] = opt . Backs2 ; } } _optimum [ cur ] . State = state ; _optimum [ cur ] . Backs0 = reps [ <int> ] ; _optimum [ cur ] . Backs1 = reps [ <int> ] ; _optimum [ cur ] . Backs2 = reps [ <int> ] ; _optimum [ cur ] . Backs3 = reps [ <int> ] ; int curPrice = _optimum [ cur ] . Price ; currentByte = _matchFinder . GetIndexByte ( <int> - <int> ) ; matchByte = _matchFinder . GetIndexByte ( <int> - reps [ <int> ] - <int> - <int> ) ; posState = ( position & _posStateMask ) ; int curAnd1Price = curPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isMatch [ ( state < < Base . kNumPosStatesBitsMax ) + posState ] ) + _literalEncoder . GetSubCoder ( position , _matchFinder . GetIndexByte ( <int> - <int> ) ) . GetPrice ( ! Base . StateIsCharState ( state ) , matchByte , currentByte ) ; Optimal nextOptimum = _optimum [ cur + <int> ] ; boolean nextIsChar = false ; if ( curAnd1Price < nextOptimum . Price ) { nextOptimum . Price = curAnd1Price ; nextOptimum . PosPrev = cur ; nextOptimum . MakeAsChar ( ) ; nextIsChar = true ; } matchPrice = curPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isMatch [ ( state < < Base . kNumPosStatesBitsMax ) + posState ] ) ; repMatchPrice = matchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep [ state ] ) ; if ( matchByte = = currentByte & & ! ( nextOptimum . PosPrev < cur & & nextOptimum . BackPrev = = <int> ) ) { int shortRepPrice = repMatchPrice + GetRepLen1Price ( state , posState ) ; if ( shortRepPrice < = nextOptimum . Price ) { nextOptimum . Price = shortRepPrice ; nextOptimum . PosPrev = cur ; nextOptimum . MakeAsShortRep ( ) ; nextIsChar = true ; } } int numAvailableBytesFull = _matchFinder . GetNumAvailableBytes ( ) + <int> ; numAvailableBytesFull = Math . min ( kNumOpts - <int> - cur , numAvailableBytesFull ) ; numAvailableBytes = numAvailableBytesFull ; if ( numAvailableBytes < <int> ) continue ; if ( numAvailableBytes > _numFastBytes ) numAvailableBytes = _numFastBytes ; if ( ! nextIsChar & & matchByte ! = currentByte ) { int t = Math . min ( numAvailableBytesFull - <int> , _numFastBytes ) ; int lenTest2 = _matchFinder . GetMatchLen ( <int> , reps [ <int> ] , t ) ; if ( lenTest2 > = <int> ) { int state2 = Base . StateUpdateChar ( state ) ; int posStateNext = ( position + <int> ) & _posStateMask ; int nextRepMatchPrice = curAnd1Price + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isMatch [ ( state2 < < Base . kNumPosStatesBitsMax ) + posStateNext ] ) + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep [ state2 ] ) ; { int offset = cur + <int> + lenTest2 ; while ( lenEnd < offset ) _optimum [ + + lenEnd ] . Price = kIfinityPrice ; int curAndLenPrice = nextRepMatchPrice + GetRepPrice ( <int> , lenTest2 , state2 , posStateNext ) ; Optimal optimum = _optimum [ offset ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = cur + <int> ; optimum . BackPrev = <int> ; optimum . Prev1IsChar = true ; optimum . Prev2 = false ; } } } } int startLen = <int> ; for ( int repIndex = <int> ; repIndex < Base . kNumRepDistances ; repIndex + + ) { int lenTest = _matchFinder . GetMatchLen ( <int> - <int> , reps [ repIndex ] , numAvailableBytes ) ; if ( lenTest < <int> ) continue ; int lenTestTemp = lenTest ; do { while ( lenEnd < cur + lenTest ) _optimum [ + + lenEnd ] . Price = kIfinityPrice ; int curAndLenPrice = repMatchPrice + GetRepPrice ( repIndex , lenTest , state , posState ) ; Optimal optimum = _optimum [ cur + lenTest ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = cur ; optimum . BackPrev = repIndex ; optimum . Prev1IsChar = false ; } } while ( - - lenTest > = <int> ) ; lenTest = lenTestTemp ; if ( repIndex = = <int> ) startLen = lenTest + <int> ; if ( lenTest < numAvailableBytesFull ) { int t = Math . min ( numAvailableBytesFull - <int> - lenTest , _numFastBytes ) ; int lenTest2 = _matchFinder . GetMatchLen ( lenTest , reps [ repIndex ] , t ) ; if ( lenTest2 > = <int> ) { int state2 = Base . StateUpdateRep ( state ) ; int posStateNext = ( position + lenTest ) & _posStateMask ; int curAndLenCharPrice = repMatchPrice + GetRepPrice ( repIndex , lenTest , state , posState ) + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isMatch [ ( state2 < < Base . kNumPosStatesBitsMax ) + posStateNext ] ) + _literalEncoder . GetSubCoder ( position + lenTest , _matchFinder . GetIndexByte ( lenTest - <int> - <int> ) ) . GetPrice ( true , _matchFinder . GetIndexByte ( lenTest - <int> - ( reps [ repIndex ] + <int> ) ) , _matchFinder . GetIndexByte ( lenTest - <int> ) ) ; state2 = Base . StateUpdateChar ( state2 ) ; posStateNext = ( position + lenTest + <int> ) & _posStateMask ; int nextMatchPrice = curAndLenCharPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isMatch [ ( state2 < < Base . kNumPosStatesBitsMax ) + posStateNext ] ) ; int nextRepMatchPrice = nextMatchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep [ state2 ] ) ; { int offset = lenTest + <int> + lenTest2 ; while ( lenEnd < cur + offset ) _optimum [ + + lenEnd ] . Price = kIfinityPrice ; int curAndLenPrice = nextRepMatchPrice + GetRepPrice ( <int> , lenTest2 , state2 , posStateNext ) ; Optimal optimum = _optimum [ cur + offset ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = cur + lenTest + <int> ; optimum . BackPrev = <int> ; optimum . Prev1IsChar = true ; optimum . Prev2 = true ; optimum . PosPrev2 = cur ; optimum . BackPrev2 = repIndex ; } } } } } if ( newLen > numAvailableBytes ) { newLen = numAvailableBytes ; for ( numDistancePairs = <int> ; newLen > _matchDistances [ numDistancePairs ] ; numDistancePairs + = <int> ) ; _matchDistances [ numDistancePairs ] = newLen ; numDistancePairs + = <int> ; } if ( newLen > = startLen ) { normalMatchPrice = matchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isRep [ state ] ) ; while ( lenEnd < cur + newLen ) _optimum [ + + lenEnd ] . Price = kIfinityPrice ; int offs = <int> ; while ( startLen > _matchDistances [ offs ] ) offs + = <int> ; for ( int lenTest = startLen ; ; lenTest + + ) { int curBack = _matchDistances [ offs + <int> ] ; int curAndLenPrice = normalMatchPrice + GetPosLenPrice ( curBack , lenTest , posState ) ; Optimal optimum = _optimum [ cur + lenTest ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = cur ; optimum . BackPrev = curBack + Base . kNumRepDistances ; optimum . Prev1IsChar = false ; } if ( lenTest = = _matchDistances [ offs ] ) { if ( lenTest < numAvailableBytesFull ) { int t = Math . min ( numAvailableBytesFull - <int> - lenTest , _numFastBytes ) ; int lenTest2 = _matchFinder . GetMatchLen ( lenTest , curBack , t ) ; if ( lenTest2 > = <int> ) { int state2 = Base . StateUpdateMatch ( state ) ; int posStateNext = ( position + lenTest ) & _posStateMask ; int curAndLenCharPrice = curAndLenPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice0 ( _isMatch [ ( state2 < < Base . kNumPosStatesBitsMax ) + posStateNext ] ) + _literalEncoder . GetSubCoder ( position + lenTest , _matchFinder . GetIndexByte ( lenTest - <int> - <int> ) ) . GetPrice ( true , _matchFinder . GetIndexByte ( lenTest - ( curBack + <int> ) - <int> ) , _matchFinder . GetIndexByte ( lenTest - <int> ) ) ; state2 = Base . StateUpdateChar ( state2 ) ; posStateNext = ( position + lenTest + <int> ) & _posStateMask ; int nextMatchPrice = curAndLenCharPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isMatch [ ( state2 < < Base . kNumPosStatesBitsMax ) + posStateNext ] ) ; int nextRepMatchPrice = nextMatchPrice + com . badlogic . gdx . utils . compression . rangecoder . Encoder . GetPrice1 ( _isRep [ state2 ] ) ; int offset = lenTest + <int> + lenTest2 ; while ( lenEnd < cur + offset ) _optimum [ + + lenEnd ] . Price = kIfinityPrice ; curAndLenPrice = nextRepMatchPrice + GetRepPrice ( <int> , lenTest2 , state2 , posStateNext ) ; optimum = _optimum [ cur + offset ] ; if ( curAndLenPrice < optimum . Price ) { optimum . Price = curAndLenPrice ; optimum . PosPrev = cur + lenTest + <int> ; optimum . BackPrev = <int> ; optimum . Prev1IsChar = true ; optimum . Prev2 = true ; optimum . PosPrev2 = cur ; optimum . BackPrev2 = curBack + Base . kNumRepDistances ; } } } offs + = <int> ; if ( offs = = numDistancePairs ) break ; } } } } } boolean ChangePair ( int smallDist , int bigDist ) { int kDif = <int> ; return ( smallDist < ( <int> < < ( <int> - kDif ) ) & & bigDist > = ( smallDist < < kDif ) ) ; } void WriteEndMarker ( int posState ) throws IOException { if ( ! _writeEndMark ) return ; _rangeEncoder . Encode ( _isMatch , ( _state < < Base . kNumPosStatesBitsMax ) + posState , <int> ) ; _rangeEncoder . Encode ( _isRep , _state , <int> ) ; _state = Base . StateUpdateMatch ( _state ) ; int len = Base . kMatchMinLen ; _lenEncoder . Encode ( _rangeEncoder , len - Base . kMatchMinLen , posState ) ; int posSlot = ( <int> < < Base . kNumPosSlotBits ) - <int> ; int lenToPosState = Base . GetLenToPosState ( len ) ; _posSlotEncoder [ lenToPosState ] . Encode ( _rangeEncoder , posSlot ) ; int footerBits = <int> ; int posReduced = ( <int> < < footerBits ) - <int> ; _rangeEncoder . EncodeDirectBits ( posReduced > > Base . kNumAlignBits , footerBits - Base . kNumAlignBits ) ; _posAlignEncoder . ReverseEncode ( _rangeEncoder , posReduced & Base . kAlignMask ) ; } void Flush ( int nowPos ) throws IOException { ReleaseMFStream ( ) ; WriteEndMarker ( nowPos & _posStateMask ) ; _rangeEncoder . FlushData ( ) ; _rangeEncoder . FlushStream ( ) ; } public void CodeOneBlock ( long [ ] inSize , long [ ] outSize , boolean [ ] finished ) throws IOException { inSize [ <int> ] = <int> ; outSize [ <int> ] = <int> ; finished [ <int> ] = true ; if ( _inStream ! = null ) { _matchFinder . SetStream ( _inStream ) ; _matchFinder . Init ( ) ; _needReleaseMFStream = true ; _inStream = null ; } if ( _finished ) return ; _finished = true ; long progressPosValuePrev = nowPos64 ; if ( nowPos64 = = <int> ) { if ( _matchFinder . GetNumAvailableBytes ( ) = = <int> ) { Flush ( ( int ) nowPos64 ) ; return ; } ReadMatchDistances ( ) ; int posState = ( int ) ( nowPos64 ) & _posStateMask ; _rangeEncoder . Encode ( _isMatch , ( _state < < Base . kNumPosStatesBitsMax ) + posState , <int> ) ; _state = Base . StateUpdateChar ( _state ) ; byte curByte = _matchFinder . GetIndexByte ( <int> - _additionalOffset ) ; _literalEncoder . GetSubCoder ( ( int ) ( nowPos64 ) , _previousByte ) . Encode ( _rangeEncoder , curByte ) ; _previousByte = curByte ; _additionalOffset - - ; nowPos64 + + ; } if ( _matchFinder . GetNumAvailableBytes ( ) = = <int> ) { Flush ( ( int ) nowPos64 ) ; return ; } while ( true ) { int len = GetOptimum ( ( int ) nowPos64 ) ; int pos = backRes ; int posState = ( ( int ) nowPos64 ) & _posStateMask ; int complexState = ( _state < < Base . kNumPosStatesBitsMax ) + posState ; if ( len = = <int> & & pos = = - <int> ) { _rangeEncoder . Encode ( _isMatch , complexState , <int> ) ; byte curByte = _matchFinder . GetIndexByte ( ( int ) ( <int> - _additionalOffset ) ) ; LiteralEncoder . Encoder2 subCoder = _literalEncoder . GetSubCoder ( ( int ) nowPos64 , _previousByte ) ; if ( ! Base . StateIsCharState ( _state ) ) { byte matchByte = _matchFinder . GetIndexByte ( ( int ) ( <int> - _repDistances [ <int> ] - <int> - _additionalOffset ) ) ; subCoder . EncodeMatched ( _rangeEncoder , matchByte , curByte ) ; } else subCoder . Encode ( _rangeEncoder , curByte ) ; _previousByte = curByte ; _state = Base . StateUpdateChar ( _state ) ; } else { _rangeEncoder . Encode ( _isMatch , complexState , <int> ) ; if ( pos < Base . kNumRepDistances ) { _rangeEncoder . Encode ( _isRep , _state , <int> ) ; if ( pos = = <int> ) { _rangeEncoder . Encode ( _isRepG0 , _state , <int> ) ; if ( len = = <int> ) _rangeEncoder . Encode ( _isRep0Long , complexState , <int> ) ; else _rangeEncoder . Encode ( _isRep0Long , complexState , <int> ) ; } else { _rangeEncoder . Encode ( _isRepG0 , _state , <int> ) ; if ( pos = = <int> ) _rangeEncoder . Encode ( _isRepG1 , _state , <int> ) ; else { _rangeEncoder . Encode ( _isRepG1 , _state , <int> ) ; _rangeEncoder . Encode ( _isRepG2 , _state , pos - <int> ) ; } } if ( len = = <int> ) _state = Base . StateUpdateShortRep ( _state ) ; else { _repMatchLenEncoder . Encode ( _rangeEncoder , len - Base . kMatchMinLen , posState ) ; _state = Base . StateUpdateRep ( _state ) ; } int distance = _repDistances [ pos ] ; if ( pos ! = <int> ) { for ( int i = pos ; i > = <int> ; i - - ) _repDistances [ i ] = _repDistances [ i - <int> ] ; _repDistances [ <int> ] = distance ; } } else { _rangeEncoder . Encode ( _isRep , _state , <int> ) ; _state = Base . StateUpdateMatch ( _state ) ; _lenEncoder . Encode ( _rangeEncoder , len - Base . kMatchMinLen , posState ) ; pos - = Base . kNumRepDistances ; int posSlot = GetPosSlot ( pos ) ; int lenToPosState = Base . GetLenToPosState ( len ) ; _posSlotEncoder [ lenToPosState ] . Encode ( _rangeEncoder , posSlot ) ; if ( posSlot > = Base . kStartPosModelIndex ) { int footerBits = ( int ) ( ( posSlot > > <int> ) - <int> ) ; int baseVal = ( ( <int> | ( posSlot & <int> ) ) < < footerBits ) ; int posReduced = pos - baseVal ; if ( posSlot < Base . kEndPosModelIndex ) BitTreeEncoder . ReverseEncode ( _posEncoders , baseVal - posSlot - <int> , _rangeEncoder , footerBits , posReduced ) ; else { _rangeEncoder . EncodeDirectBits ( posReduced > > Base . kNumAlignBits , footerBits - Base . kNumAlignBits ) ; _posAlignEncoder . ReverseEncode ( _rangeEncoder , posReduced & Base . kAlignMask ) ; _alignPriceCount + + ; } } int distance = pos ; for ( int i = Base . kNumRepDistances - <int> ; i > = <int> ; i - - ) _repDistances [ i ] = _repDistances [ i - <int> ] ; _repDistances [ <int> ] = distance ; _matchPriceCount + + ; } _previousByte = _matchFinder . GetIndexByte ( len - <int> - _additionalOffset ) ; } _additionalOffset - = len ; nowPos64 + = len ; if ( _additionalOffset = = <int> ) { if ( _matchPriceCount > = ( <int> < < <int> ) ) FillDistancesPrices ( ) ; if ( _alignPriceCount > = Base . kAlignTableSize ) FillAlignPrices ( ) ; inSize [ <int> ] = nowPos64 ; outSize [ <int> ] = _rangeEncoder . GetProcessedSizeAdd ( ) ; if ( _matchFinder . GetNumAvailableBytes ( ) = = <int> ) { Flush ( ( int ) nowPos64 ) ; return ; } if ( nowPos64 - progressPosValuePrev > = ( <int> < < <int> ) ) { _finished = false ; finished [ <int> ] = false ; return ; } } } } void ReleaseMFStream ( ) { if ( _matchFinder ! = null & & _needReleaseMFStream ) { _matchFinder . ReleaseStream ( ) ; _needReleaseMFStream = false ; } } void SetOutStream ( java . io . OutputStream outStream ) { _rangeEncoder . SetStream ( outStream ) ; } void ReleaseOutStream ( ) { _rangeEncoder . ReleaseStream ( ) ; } void ReleaseStreams ( ) { ReleaseMFStream ( ) ; ReleaseOutStream ( ) ; } void SetStreams ( java . io . InputStream inStream , java . io . OutputStream outStream , long inSize , long outSize ) { _inStream = inStream ; _finished = false ; Create ( ) ; SetOutStream ( outStream ) ; Init ( ) ; { FillDistancesPrices ( ) ; FillAlignPrices ( ) ; } _lenEncoder . SetTableSize ( _numFastBytes + <int> - Base . kMatchMinLen ) ; _lenEncoder . UpdateTables ( <int> < < _posStateBits ) ; _repMatchLenEncoder . SetTableSize ( _numFastBytes + <int> - Base . kMatchMinLen ) ; _repMatchLenEncoder . UpdateTables ( <int> < < _posStateBits ) ; nowPos64 = <int> ; } long [ ] processedInSize = new long [ <int> ] ; long [ ] processedOutSize = new long [ <int> ] ; boolean [ ] finished = new boolean [ <int> ] ; public void Code ( java . io . InputStream inStream , java . io . OutputStream outStream , long inSize , long outSize , ICodeProgress progress ) throws IOException { _needReleaseMFStream = false ; try { SetStreams ( inStream , outStream , inSize , outSize ) ; while ( true ) { CodeOneBlock ( processedInSize , processedOutSize , finished ) ; if ( finished [ <int> ] ) return ; if ( progress ! = null ) { progress . SetProgress ( processedInSize [ <int> ] , processedOutSize [ <int> ] ) ; } } } finally { ReleaseStreams ( ) ; } } public static final int kPropSize = <int> ; byte [ ] properties = new byte [ kPropSize ] ; public void WriteCoderProperties ( java . io . OutputStream outStream ) throws IOException { properties [ <int> ] = ( byte ) ( ( _posStateBits * <int> + _numLiteralPosStateBits ) * <int> + _numLiteralContextBits ) ; for ( int i = <int> ; i < <int> ; i + + ) properties [ <int> + i ] = ( byte ) ( _dictionarySize > > ( <int> * i ) ) ; outStream . write ( properties , <int> , kPropSize ) ; } int [ ] tempPrices = new int [ Base . kNumFullDistances ] ; int _matchPriceCount ; void FillDistancesPrices ( ) { for ( int i = Base . kStartPosModelIndex ; i < Base . kNumFullDistances ; i + + ) { int posSlot = GetPosSlot ( i ) ; int footerBits = ( int ) ( ( posSlot > > <int> ) - <int> ) ; int baseVal = ( ( <int> | ( posSlot & <int> ) ) < < footerBits ) ; tempPrices [ i ] = BitTreeEncoder . ReverseGetPrice ( _posEncoders , baseVal - posSlot - <int> , footerBits , i - baseVal ) ; } for ( int lenToPosState = <int> ; lenToPosState < Base . kNumLenToPosStates ; lenToPosState + + ) { int posSlot ; BitTreeEncoder encoder = _posSlotEncoder [ lenToPosState ] ; int st = ( lenToPosState < < Base . kNumPosSlotBits ) ; for ( posSlot = <int> ; posSlot < _distTableSize ; posSlot + + ) _posSlotPrices [ st + posSlot ] = encoder . GetPrice ( posSlot ) ; for ( posSlot = Base . kEndPosModelIndex ; posSlot < _distTableSize ; posSlot + + ) _posSlotPrices [ st + posSlot ] + = ( ( ( ( posSlot > > <int> ) - <int> ) - Base . kNumAlignBits ) < < com . badlogic . gdx . utils . compression . rangecoder . Encoder . kNumBitPriceShiftBits ) ; int st2 = lenToPosState * Base . kNumFullDistances ; int i ; for ( i = <int> ; i < Base . kStartPosModelIndex ; i + + ) _distancesPrices [ st2 + i ] = _posSlotPrices [ st + i ] ; for ( ; i < Base . kNumFullDistances ; i + + ) _distancesPrices [ st2 + i ] = _posSlotPrices [ st + GetPosSlot ( i ) ] + tempPrices [ i ] ; } _matchPriceCount = <int> ; } void FillAlignPrices ( ) { for ( int i = <int> ; i < Base . kAlignTableSize ; i + + ) _alignPrices [ i ] = _posAlignEncoder . ReverseGetPrice ( i ) ; _alignPriceCount = <int> ; } public boolean SetAlgorithm ( int algorithm ) { return true ; } public boolean SetDictionarySize ( int dictionarySize ) { int kDicLogSizeMaxCompress = <int> ; if ( dictionarySize < ( <int> < < Base . kDicLogSizeMin ) | | dictionarySize > ( <int> < < kDicLogSizeMaxCompress ) ) return false ; _dictionarySize = dictionarySize ; int dicLogSize ; for ( dicLogSize = <int> ; dictionarySize > ( <int> < < dicLogSize ) ; dicLogSize + + ) ; _distTableSize = dicLogSize * <int> ; return true ; } public boolean SetNumFastBytes ( int numFastBytes ) { if ( numFastBytes < <int> | | numFastBytes > Base . kMatchMaxLen ) return false ; _numFastBytes = numFastBytes ; return true ; } public boolean SetMatchFinder ( int matchFinderIndex ) { if ( matchFinderIndex < <int> | | matchFinderIndex > <int> ) return false ; int matchFinderIndexPrev = _matchFinderType ; _matchFinderType = matchFinderIndex ; if ( _matchFinder ! = null & & matchFinderIndexPrev ! = _matchFinderType ) { _dictionarySizePrev = - <int> ; _matchFinder = null ; } return true ; } public boolean SetLcLpPb ( int lc , int lp , int pb ) { if ( lp < <int> | | lp > Base . kNumLitPosStatesBitsEncodingMax | | lc < <int> | | lc > Base . kNumLitContextBitsMax | | pb < <int> | | pb > Base . kNumPosStatesBitsEncodingMax ) return false ; _numLiteralPosStateBits = lp ; _numLiteralContextBits = lc ; _posStateBits = pb ; _posStateMask = ( ( <int> ) < < _posStateBits ) - <int> ; return true ; } public void SetEndMarkerMode ( boolean endMarkerMode ) { _writeEndMark = endMarkerMode ; } } 
