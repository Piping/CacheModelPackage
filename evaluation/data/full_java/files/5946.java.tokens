package org . elasticsearch . common . io . stream ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . util . BitUtil ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . text . StringAndBytesText ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . index . query . functionscore . ScoreFunctionBuilder ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import java . io . ByteArrayInputStream ; import java . io . EOFException ; import java . io . FileNotFoundException ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . NoSuchFileException ; import java . util . ArrayList ; import java . util . Date ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . function . Supplier ; import static org . elasticsearch . ElasticsearchException . readException ; import static org . elasticsearch . ElasticsearchException . readStackTrace ; public abstract class StreamInput extends InputStream { private final NamedWriteableRegistry namedWriteableRegistry ; private Version version = Version . CURRENT ; protected StreamInput ( ) { this . namedWriteableRegistry = new NamedWriteableRegistry ( ) ; } protected StreamInput ( NamedWriteableRegistry namedWriteableRegistry ) { this . namedWriteableRegistry = namedWriteableRegistry ; } public Version getVersion ( ) { return this . version ; } public void setVersion ( Version version ) { this . version = version ; } public abstract byte readByte ( ) throws IOException ; public abstract void readBytes ( byte [ ] b , int offset , int len ) throws IOException ; public BytesReference readBytesReference ( ) throws IOException { int length = readVInt ( ) ; return readBytesReference ( length ) ; } public BytesReference readBytesReference ( int length ) throws IOException { if ( length = = <int> ) { return BytesArray . EMPTY ; } byte [ ] bytes = new byte [ length ] ; readBytes ( bytes , <int> , length ) ; return new BytesArray ( bytes , <int> , length ) ; } public BytesRef readBytesRef ( ) throws IOException { int length = readVInt ( ) ; return readBytesRef ( length ) ; } public BytesRef readBytesRef ( int length ) throws IOException { if ( length = = <int> ) { return new BytesRef ( ) ; } byte [ ] bytes = new byte [ length ] ; readBytes ( bytes , <int> , length ) ; return new BytesRef ( bytes , <int> , length ) ; } public void readFully ( byte [ ] b ) throws IOException { readBytes ( b , <int> , b . length ) ; } public short readShort ( ) throws IOException { return ( short ) ( ( ( readByte ( ) & <hex> ) < < <int> ) | ( readByte ( ) & <hex> ) ) ; } public int readInt ( ) throws IOException { return ( ( readByte ( ) & <hex> ) < < <int> ) | ( ( readByte ( ) & <hex> ) < < <int> ) | ( ( readByte ( ) & <hex> ) < < <int> ) | ( readByte ( ) & <hex> ) ; } public int readVInt ( ) throws IOException { byte b = readByte ( ) ; int i = b & <hex> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; assert ( b & <hex> ) = = <int> ; return i | ( ( b & <hex> ) < < <int> ) ; } public long readLong ( ) throws IOException { return ( ( ( long ) readInt ( ) ) < < <int> ) | ( readInt ( ) & <hex> ) ; } public long readVLong ( ) throws IOException { byte b = readByte ( ) ; long i = b & <hex> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; i | = ( b & <hex> ) < < <int> ; if ( ( b & <hex> ) = = <int> ) { return i ; } b = readByte ( ) ; assert ( b & <hex> ) = = <int> ; return i | ( ( b & <hex> ) < < <int> ) ; } public long readZLong ( ) throws IOException { long accumulator = <int> L ; int i = <int> ; long currentByte ; while ( ( ( currentByte = readByte ( ) ) & <hex> ) ! = <int> ) { accumulator | = ( currentByte & <hex> ) < < i ; i + = <int> ; if ( i > <int> ) { throw new IOException ( <str> ) ; } } return BitUtil . zigZagDecode ( accumulator | ( currentByte < < i ) ) ; } @Nullable public Text readOptionalText ( ) throws IOException { int length = readInt ( ) ; if ( length = = - <int> ) { return null ; } return new StringAndBytesText ( readBytesReference ( length ) ) ; } public Text readText ( ) throws IOException { int length = readInt ( ) ; return new StringAndBytesText ( readBytesReference ( length ) ) ; } @Nullable public String readOptionalString ( ) throws IOException { if ( readBoolean ( ) ) { return readString ( ) ; } return null ; } @Nullable public Integer readOptionalVInt ( ) throws IOException { if ( readBoolean ( ) ) { return readVInt ( ) ; } return null ; } private final CharsRefBuilder spare = new CharsRefBuilder ( ) ; public String readString ( ) throws IOException { final int charCount = readVInt ( ) ; spare . clear ( ) ; spare . grow ( charCount ) ; int c ; while ( spare . length ( ) < charCount ) { c = readByte ( ) & <hex> ; switch ( c > > <int> ) { case <int> : case <int> : case <int> : case <int> : case <int> : case <int> : case <int> : case <int> : spare . append ( ( char ) c ) ; break ; case <int> : case <int> : spare . append ( ( char ) ( ( c & <hex> ) < < <int> | readByte ( ) & <hex> ) ) ; break ; case <int> : spare . append ( ( char ) ( ( c & <hex> ) < < <int> | ( readByte ( ) & <hex> ) < < <int> | ( readByte ( ) & <hex> ) < < <int> ) ) ; break ; } } return spare . toString ( ) ; } public final float readFloat ( ) throws IOException { return Float . intBitsToFloat ( readInt ( ) ) ; } public final double readDouble ( ) throws IOException { return Double . longBitsToDouble ( readLong ( ) ) ; } public final boolean readBoolean ( ) throws IOException { return readByte ( ) ! = <int> ; } @Nullable public final Boolean readOptionalBoolean ( ) throws IOException { byte val = readByte ( ) ; if ( val = = <int> ) { return null ; } if ( val = = <int> ) { return true ; } return false ; } @Override public abstract void reset ( ) throws IOException ; @Override public abstract void close ( ) throws IOException ; public String [ ] readStringArray ( ) throws IOException { int size = readVInt ( ) ; if ( size = = <int> ) { return Strings . EMPTY_ARRAY ; } String [ ] ret = new String [ size ] ; for ( int i = <int> ; i < size ; i + + ) { ret [ i ] = readString ( ) ; } return ret ; } public String [ ] readOptionalStringArray ( ) throws IOException { if ( readBoolean ( ) ) { return readStringArray ( ) ; } return null ; } @Nullable @SuppressWarnings ( <str> ) public Map < String , Object > readMap ( ) throws IOException { return ( Map < String , Object > ) readGenericValue ( ) ; } @SuppressWarnings ( { <str> } ) @Nullable public Object readGenericValue ( ) throws IOException { byte type = readByte ( ) ; switch ( type ) { case - <int> : return null ; case <int> : return readString ( ) ; case <int> : return readInt ( ) ; case <int> : return readLong ( ) ; case <int> : return readFloat ( ) ; case <int> : return readDouble ( ) ; case <int> : return readBoolean ( ) ; case <int> : int bytesSize = readVInt ( ) ; byte [ ] value = new byte [ bytesSize ] ; readBytes ( value , <int> , bytesSize ) ; return value ; case <int> : int size = readVInt ( ) ; List list = new ArrayList ( size ) ; for ( int i = <int> ; i < size ; i + + ) { list . add ( readGenericValue ( ) ) ; } return list ; case <int> : int size8 = readVInt ( ) ; Object [ ] list8 = new Object [ size8 ] ; for ( int i = <int> ; i < size8 ; i + + ) { list8 [ i ] = readGenericValue ( ) ; } return list8 ; case <int> : int size9 = readVInt ( ) ; Map map9 = new LinkedHashMap ( size9 ) ; for ( int i = <int> ; i < size9 ; i + + ) { map9 . put ( readString ( ) , readGenericValue ( ) ) ; } return map9 ; case <int> : int size10 = readVInt ( ) ; Map map10 = new HashMap ( size10 ) ; for ( int i = <int> ; i < size10 ; i + + ) { map10 . put ( readString ( ) , readGenericValue ( ) ) ; } return map10 ; case <int> : return readByte ( ) ; case <int> : return new Date ( readLong ( ) ) ; case <int> : final String timeZoneId = readString ( ) ; return new DateTime ( readLong ( ) , DateTimeZone . forID ( timeZoneId ) ) ; case <int> : return readBytesReference ( ) ; case <int> : return readText ( ) ; case <int> : return readShort ( ) ; case <int> : return readIntArray ( ) ; case <int> : return readLongArray ( ) ; case <int> : return readFloatArray ( ) ; case <int> : return readDoubleArray ( ) ; case <int> : return readBytesRef ( ) ; case <int> : return readGeoPoint ( ) ; default : throw new IOException ( <str> + type + <str> ) ; } } public GeoPoint readGeoPoint ( ) throws IOException { return new GeoPoint ( readDouble ( ) , readDouble ( ) ) ; } public int [ ] readIntArray ( ) throws IOException { int length = readVInt ( ) ; int [ ] values = new int [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readInt ( ) ; } return values ; } public int [ ] readVIntArray ( ) throws IOException { int length = readVInt ( ) ; int [ ] values = new int [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readVInt ( ) ; } return values ; } public long [ ] readLongArray ( ) throws IOException { int length = readVInt ( ) ; long [ ] values = new long [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readLong ( ) ; } return values ; } public long [ ] readVLongArray ( ) throws IOException { int length = readVInt ( ) ; long [ ] values = new long [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readVLong ( ) ; } return values ; } public float [ ] readFloatArray ( ) throws IOException { int length = readVInt ( ) ; float [ ] values = new float [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readFloat ( ) ; } return values ; } public double [ ] readDoubleArray ( ) throws IOException { int length = readVInt ( ) ; double [ ] values = new double [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readDouble ( ) ; } return values ; } public byte [ ] readByteArray ( ) throws IOException { int length = readVInt ( ) ; byte [ ] values = new byte [ length ] ; for ( int i = <int> ; i < length ; i + + ) { values [ i ] = readByte ( ) ; } return values ; } public < T extends Streamable > T readOptionalStreamable ( Supplier < T > supplier ) throws IOException { if ( readBoolean ( ) ) { T streamable = supplier . get ( ) ; streamable . readFrom ( this ) ; return streamable ; } else { return null ; } } public < T extends Throwable > T readThrowable ( ) throws IOException { if ( readBoolean ( ) ) { int key = readVInt ( ) ; switch ( key ) { case <int> : final int ord = readVInt ( ) ; return ( T ) readException ( this , ord ) ; case <int> : String msg1 = readOptionalString ( ) ; String resource1 = readOptionalString ( ) ; return ( T ) readStackTrace ( new CorruptIndexException ( msg1 , resource1 , readThrowable ( ) ) , this ) ; case <int> : String resource2 = readOptionalString ( ) ; int version2 = readInt ( ) ; int minVersion2 = readInt ( ) ; int maxVersion2 = readInt ( ) ; return ( T ) readStackTrace ( new IndexFormatTooNewException ( resource2 , version2 , minVersion2 , maxVersion2 ) , this ) ; case <int> : String resource3 = readOptionalString ( ) ; if ( readBoolean ( ) ) { int version3 = readInt ( ) ; int minVersion3 = readInt ( ) ; int maxVersion3 = readInt ( ) ; return ( T ) readStackTrace ( new IndexFormatTooOldException ( resource3 , version3 , minVersion3 , maxVersion3 ) , this ) ; } else { String version3 = readOptionalString ( ) ; return ( T ) readStackTrace ( new IndexFormatTooOldException ( resource3 , version3 ) , this ) ; } case <int> : return ( T ) readStackTrace ( new NullPointerException ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new NumberFormatException ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new IllegalArgumentException ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new AlreadyClosedException ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new EOFException ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new SecurityException ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new StringIndexOutOfBoundsException ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new ArrayIndexOutOfBoundsException ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new AssertionError ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new FileNotFoundException ( readOptionalString ( ) ) , this ) ; case <int> : final String file = readOptionalString ( ) ; final String other = readOptionalString ( ) ; final String reason = readOptionalString ( ) ; readOptionalString ( ) ; return ( T ) readStackTrace ( new NoSuchFileException ( file , other , reason ) , this ) ; case <int> : return ( T ) readStackTrace ( new OutOfMemoryError ( readOptionalString ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new IllegalStateException ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new LockObtainFailedException ( readOptionalString ( ) , readThrowable ( ) ) , this ) ; case <int> : return ( T ) readStackTrace ( new InterruptedException ( readOptionalString ( ) ) , this ) ; default : assert false : <str> + key ; } } return null ; } < C > C readNamedWriteable ( @SuppressWarnings ( <str> ) Class < C > categoryClass ) throws IOException { throw new UnsupportedOperationException ( <str> ) ; } public QueryBuilder readQuery ( ) throws IOException { return readNamedWriteable ( QueryBuilder . class ) ; } public ScoreFunctionBuilder < ? > readScoreFunction ( ) throws IOException { return readNamedWriteable ( ScoreFunctionBuilder . class ) ; } public static StreamInput wrap ( BytesReference reference ) { if ( reference . hasArray ( ) = = false ) { reference = reference . toBytesArray ( ) ; } return wrap ( reference . array ( ) , reference . arrayOffset ( ) , reference . length ( ) ) ; } public static StreamInput wrap ( byte [ ] bytes ) { return wrap ( bytes , <int> , bytes . length ) ; } public static StreamInput wrap ( byte [ ] bytes , int offset , int length ) { return new InputStreamStreamInput ( new ByteArrayInputStream ( bytes , offset , length ) ) ; } } 
