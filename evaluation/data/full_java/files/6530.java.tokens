package org . elasticsearch . index . mapper ; import org . elasticsearch . common . collect . CopyOnWriteHashMap ; import org . elasticsearch . common . regex . Regex ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Objects ; import java . util . Set ; class FieldTypeLookup implements Iterable < MappedFieldType > { private final CopyOnWriteHashMap < String , MappedFieldTypeReference > fullNameToFieldType ; private final CopyOnWriteHashMap < String , Set < String > > fullNameToTypes ; private final CopyOnWriteHashMap < String , MappedFieldTypeReference > indexNameToFieldType ; private final CopyOnWriteHashMap < String , Set < String > > indexNameToTypes ; public FieldTypeLookup ( ) { fullNameToFieldType = new CopyOnWriteHashMap < > ( ) ; fullNameToTypes = new CopyOnWriteHashMap < > ( ) ; indexNameToFieldType = new CopyOnWriteHashMap < > ( ) ; indexNameToTypes = new CopyOnWriteHashMap < > ( ) ; } private FieldTypeLookup ( CopyOnWriteHashMap < String , MappedFieldTypeReference > fullName , CopyOnWriteHashMap < String , Set < String > > fullNameToTypes , CopyOnWriteHashMap < String , MappedFieldTypeReference > indexName , CopyOnWriteHashMap < String , Set < String > > indexNameToTypes ) { this . fullNameToFieldType = fullName ; this . fullNameToTypes = fullNameToTypes ; this . indexNameToFieldType = indexName ; this . indexNameToTypes = indexNameToTypes ; } private static CopyOnWriteHashMap < String , Set < String > > addType ( CopyOnWriteHashMap < String , Set < String > > map , String key , String type ) { Set < String > types = map . get ( key ) ; if ( types = = null ) { return map . copyAndPut ( key , Collections . singleton ( type ) ) ; } else if ( types . contains ( type ) ) { return map ; } else { Set < String > newTypes = new HashSet < > ( types . size ( ) + <int> ) ; newTypes . addAll ( types ) ; newTypes . add ( type ) ; assert newTypes . size ( ) = = types . size ( ) + <int> ; newTypes = Collections . unmodifiableSet ( newTypes ) ; return map . copyAndPut ( key , newTypes ) ; } } public FieldTypeLookup copyAndAddAll ( String type , Collection < FieldMapper > newFieldMappers ) { Objects . requireNonNull ( type , <str> ) ; if ( MapperService . DEFAULT_MAPPING . equals ( type ) ) { throw new IllegalArgumentException ( <str> ) ; } CopyOnWriteHashMap < String , MappedFieldTypeReference > fullName = this . fullNameToFieldType ; CopyOnWriteHashMap < String , Set < String > > fullNameToTypes = this . fullNameToTypes ; CopyOnWriteHashMap < String , MappedFieldTypeReference > indexName = this . indexNameToFieldType ; CopyOnWriteHashMap < String , Set < String > > indexNameToTypes = this . indexNameToTypes ; for ( FieldMapper fieldMapper : newFieldMappers ) { MappedFieldType fieldType = fieldMapper . fieldType ( ) ; MappedFieldTypeReference fullNameRef = fullName . get ( fieldType . names ( ) . fullName ( ) ) ; MappedFieldTypeReference indexNameRef = indexName . get ( fieldType . names ( ) . indexName ( ) ) ; if ( fullNameRef = = null & & indexNameRef = = null ) { fullName = fullName . copyAndPut ( fieldType . names ( ) . fullName ( ) , fieldMapper . fieldTypeReference ( ) ) ; indexName = indexName . copyAndPut ( fieldType . names ( ) . indexName ( ) , fieldMapper . fieldTypeReference ( ) ) ; } else if ( fullNameRef = = null ) { fullName = fullName . copyAndPut ( fieldType . names ( ) . fullName ( ) , indexNameRef ) ; indexNameRef . set ( fieldMapper . fieldType ( ) ) ; fieldMapper . setFieldTypeReference ( indexNameRef ) ; } else if ( indexNameRef = = null ) { indexName = indexName . copyAndPut ( fieldType . names ( ) . indexName ( ) , fullNameRef ) ; fullNameRef . set ( fieldMapper . fieldType ( ) ) ; fieldMapper . setFieldTypeReference ( fullNameRef ) ; } else if ( fullNameRef = = indexNameRef ) { fullNameRef . set ( fieldMapper . fieldType ( ) ) ; fieldMapper . setFieldTypeReference ( fullNameRef ) ; } else { throw new IllegalStateException ( <str> + fieldType . names ( ) . fullName ( ) + <str> + fieldType . names ( ) . indexName ( ) ) ; } fullNameToTypes = addType ( fullNameToTypes , fieldType . names ( ) . fullName ( ) , type ) ; indexNameToTypes = addType ( indexNameToTypes , fieldType . names ( ) . indexName ( ) , type ) ; } return new FieldTypeLookup ( fullName , fullNameToTypes , indexName , indexNameToTypes ) ; } private static boolean beStrict ( String type , Set < String > types , boolean updateAllTypes ) { assert types . size ( ) > = <int> ; if ( updateAllTypes ) { return false ; } else if ( types . size ( ) = = <int> & & types . contains ( type ) ) { return false ; } else { return true ; } } public void checkCompatibility ( String type , Collection < FieldMapper > fieldMappers , boolean updateAllTypes ) { for ( FieldMapper fieldMapper : fieldMappers ) { MappedFieldTypeReference ref = fullNameToFieldType . get ( fieldMapper . fieldType ( ) . names ( ) . fullName ( ) ) ; if ( ref ! = null ) { List < String > conflicts = new ArrayList < > ( ) ; final Set < String > types = fullNameToTypes . get ( fieldMapper . fieldType ( ) . names ( ) . fullName ( ) ) ; boolean strict = beStrict ( type , types , updateAllTypes ) ; ref . get ( ) . checkCompatibility ( fieldMapper . fieldType ( ) , conflicts , strict ) ; if ( conflicts . isEmpty ( ) = = false ) { throw new IllegalArgumentException ( <str> + fieldMapper . fieldType ( ) . names ( ) . fullName ( ) + <str> + conflicts . toString ( ) ) ; } } MappedFieldTypeReference indexNameRef = indexNameToFieldType . get ( fieldMapper . fieldType ( ) . names ( ) . indexName ( ) ) ; if ( indexNameRef ! = null ) { List < String > conflicts = new ArrayList < > ( ) ; final Set < String > types = indexNameToTypes . get ( fieldMapper . fieldType ( ) . names ( ) . indexName ( ) ) ; boolean strict = beStrict ( type , types , updateAllTypes ) ; indexNameRef . get ( ) . checkCompatibility ( fieldMapper . fieldType ( ) , conflicts , strict ) ; if ( conflicts . isEmpty ( ) = = false ) { throw new IllegalArgumentException ( <str> + fieldMapper . fieldType ( ) . names ( ) . fullName ( ) + <str> + conflicts . toString ( ) ) ; } } } } public MappedFieldType get ( String field ) { MappedFieldTypeReference ref = fullNameToFieldType . get ( field ) ; if ( ref = = null ) return null ; return ref . get ( ) ; } public Set < String > getTypes ( String field ) { Set < String > types = fullNameToTypes . get ( field ) ; if ( types = = null ) { types = Collections . emptySet ( ) ; } return types ; } public MappedFieldType getByIndexName ( String field ) { MappedFieldTypeReference ref = indexNameToFieldType . get ( field ) ; if ( ref = = null ) return null ; return ref . get ( ) ; } public Set < String > getTypesByIndexName ( String field ) { Set < String > types = indexNameToTypes . get ( field ) ; if ( types = = null ) { types = Collections . emptySet ( ) ; } return types ; } public Collection < String > simpleMatchToIndexNames ( String pattern ) { Set < String > fields = new HashSet < > ( ) ; for ( MappedFieldType fieldType : this ) { if ( Regex . simpleMatch ( pattern , fieldType . names ( ) . fullName ( ) ) ) { fields . add ( fieldType . names ( ) . indexName ( ) ) ; } else if ( Regex . simpleMatch ( pattern , fieldType . names ( ) . indexName ( ) ) ) { fields . add ( fieldType . names ( ) . indexName ( ) ) ; } } return fields ; } public Collection < String > simpleMatchToFullName ( String pattern ) { Set < String > fields = new HashSet < > ( ) ; for ( MappedFieldType fieldType : this ) { if ( Regex . simpleMatch ( pattern , fieldType . names ( ) . fullName ( ) ) ) { fields . add ( fieldType . names ( ) . fullName ( ) ) ; } else if ( Regex . simpleMatch ( pattern , fieldType . names ( ) . indexName ( ) ) ) { fields . add ( fieldType . names ( ) . fullName ( ) ) ; } } return fields ; } public Iterator < MappedFieldType > iterator ( ) { return fullNameToFieldType . values ( ) . stream ( ) . map ( ( p ) - > p . get ( ) ) . iterator ( ) ; } } 
