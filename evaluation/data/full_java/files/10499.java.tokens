package com . google . common . hash ; import static com . google . common . base . Charsets . UTF_8 ; import static com . google . common . io . BaseEncoding . base16 ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . ImmutableTable ; import com . google . common . collect . Table ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import sun . security . jca . ProviderList ; import sun . security . jca . Providers ; import java . security . Key ; import java . util . Arrays ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . SecretKeySpec ; public class MacHashFunctionTest extends TestCase { private static final ImmutableSet < String > INPUTS = ImmutableSet . of ( <str> , <str> , <str> ) ; private static final SecretKey MD5_KEY = new SecretKeySpec ( <str> . getBytes ( UTF_8 ) , <str> ) ; private static final SecretKey SHA1_KEY = new SecretKeySpec ( <str> . getBytes ( UTF_8 ) , <str> ) ; private static final SecretKey SHA256_KEY = new SecretKeySpec ( <str> . getBytes ( UTF_8 ) , <str> ) ; private static final SecretKey SHA512_KEY = new SecretKeySpec ( <str> . getBytes ( UTF_8 ) , <str> ) ; private static final ImmutableTable < String , SecretKey , HashFunction > ALGORITHMS = new ImmutableTable . Builder < String , SecretKey , HashFunction > ( ) . put ( <str> , MD5_KEY , Hashing . hmacMd5 ( MD5_KEY ) ) . put ( <str> , SHA1_KEY , Hashing . hmacSha1 ( SHA1_KEY ) ) . put ( <str> , SHA256_KEY , Hashing . hmacSha256 ( SHA256_KEY ) ) . put ( <str> , SHA512_KEY , Hashing . hmacSha512 ( SHA512_KEY ) ) . build ( ) ; public void testNulls ( ) { NullPointerTester tester = new NullPointerTester ( ) . setDefault ( String . class , <str> ) . setDefault ( Key . class , MD5_KEY ) ; tester . testAllPublicConstructors ( MacHashFunction . class ) ; tester . testAllPublicInstanceMethods ( new MacHashFunction ( <str> , MD5_KEY , <str> ) ) ; } public void testHashing ( ) throws Exception { for ( String stringToTest : INPUTS ) { for ( Table . Cell < String , SecretKey , HashFunction > cell : ALGORITHMS . cellSet ( ) ) { String algorithm = cell . getRowKey ( ) ; SecretKey key = cell . getColumnKey ( ) ; HashFunction hashFunc = cell . getValue ( ) ; assertMacHashing ( HashTestUtils . ascii ( stringToTest ) , algorithm , key , hashFunc ) ; } } } @SuppressWarnings ( <str> ) @AndroidIncompatible public void testNoProviders ( ) { ProviderList providers = Providers . getProviderList ( ) ; Providers . setProviderList ( ProviderList . newList ( ) ) ; try { Hashing . hmacMd5 ( MD5_KEY ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } finally { Providers . setProviderList ( providers ) ; } } public void testMultipleUpdates ( ) throws Exception { Mac mac = Mac . getInstance ( <str> ) ; mac . init ( SHA1_KEY ) ; mac . update ( <str> . getBytes ( UTF_8 ) ) ; mac . update ( <str> . getBytes ( UTF_8 ) ) ; assertEquals ( HashCode . fromBytes ( mac . doFinal ( ) ) , Hashing . hmacSha1 ( SHA1_KEY ) . newHasher ( ) . putString ( <str> , UTF_8 ) . putString ( <str> , UTF_8 ) . hash ( ) ) ; } public void testMultipleUpdatesDoFinal ( ) throws Exception { Mac mac = Mac . getInstance ( <str> ) ; mac . init ( SHA1_KEY ) ; mac . update ( <str> . getBytes ( UTF_8 ) ) ; mac . update ( <str> . getBytes ( UTF_8 ) ) ; assertEquals ( HashCode . fromBytes ( mac . doFinal ( <str> . getBytes ( UTF_8 ) ) ) , Hashing . hmacSha1 ( SHA1_KEY ) . newHasher ( ) . putString ( <str> , UTF_8 ) . putString ( <str> , UTF_8 ) . putString ( <str> , UTF_8 ) . hash ( ) ) ; } @SuppressWarnings ( <str> ) public void testCustomKey ( ) throws Exception { SecretKey customKey = new SecretKey ( ) { @Override public String getAlgorithm ( ) { return <str> ; } @Override public byte [ ] getEncoded ( ) { return new byte [ <int> ] ; } @Override public String getFormat ( ) { return <str> ; } } ; assertEquals ( <str> , Hashing . hmacMd5 ( customKey ) . hashString ( <str> , UTF_8 ) . toString ( ) ) ; } @SuppressWarnings ( <str> ) public void testBadKey_emptyKey ( ) throws Exception { SecretKey badKey = new SecretKey ( ) { @Override public String getAlgorithm ( ) { return <str> ; } @Override public byte [ ] getEncoded ( ) { return null ; } @Override public String getFormat ( ) { return <str> ; } } ; try { Hashing . hmacMd5 ( badKey ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } catch ( NullPointerException toleratedOnAndroid ) { } } public void testEmptyInputs ( ) throws Exception { String knownOutput = <str> ; Mac mac = Mac . getInstance ( <str> ) ; mac . init ( MD5_KEY ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( ) ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( MD5_KEY ) . newHasher ( ) . hash ( ) . toString ( ) ) ; } public void testEmptyInputs_mixedAlgorithms ( ) throws Exception { String knownOutput = <str> ; Mac mac = Mac . getInstance ( <str> ) ; mac . init ( SHA1_KEY ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( ) ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( SHA1_KEY ) . newHasher ( ) . hash ( ) . toString ( ) ) ; } public void testKnownInputs ( ) throws Exception { String knownOutput = <str> ; String input = <str> ; Mac mac = Mac . getInstance ( <str> ) ; mac . init ( MD5_KEY ) ; mac . update ( input . getBytes ( UTF_8 ) ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( ) ) . toString ( ) ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( input . getBytes ( UTF_8 ) ) ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( MD5_KEY ) . hashString ( input , UTF_8 ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( MD5_KEY ) . hashBytes ( input . getBytes ( UTF_8 ) ) . toString ( ) ) ; } public void testKnownInputs_mixedAlgorithms ( ) throws Exception { String knownOutput = <str> ; String input = <str> ; Mac mac = Mac . getInstance ( <str> ) ; mac . init ( SHA1_KEY ) ; mac . update ( input . getBytes ( UTF_8 ) ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( ) ) . toString ( ) ) ; assertEquals ( knownOutput , HashCode . fromBytes ( mac . doFinal ( input . getBytes ( UTF_8 ) ) ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( SHA1_KEY ) . hashString ( input , UTF_8 ) . toString ( ) ) ; assertEquals ( knownOutput , Hashing . hmacMd5 ( SHA1_KEY ) . hashBytes ( input . getBytes ( UTF_8 ) ) . toString ( ) ) ; } public void testPutAfterHash ( ) { Hasher hasher = Hashing . hmacMd5 ( MD5_KEY ) . newHasher ( ) ; assertEquals ( <str> , hasher . putString ( <str> , UTF_8 ) . hash ( ) . toString ( ) ) ; try { hasher . putInt ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @SuppressWarnings ( <str> ) public void testHashTwice ( ) { Hasher hasher = Hashing . hmacMd5 ( MD5_KEY ) . newHasher ( ) ; assertEquals ( <str> , hasher . putString ( <str> , UTF_8 ) . hash ( ) . toString ( ) ) ; try { hasher . hash ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testToString ( ) { byte [ ] keyData = <str> . getBytes ( UTF_8 ) ; assertEquals ( <str> , Hashing . hmacMd5 ( MD5_KEY ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacMd5 ( keyData ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha1 ( SHA1_KEY ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha1 ( keyData ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha256 ( SHA256_KEY ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha256 ( keyData ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha512 ( SHA512_KEY ) . toString ( ) ) ; assertEquals ( <str> , Hashing . hmacSha512 ( keyData ) . toString ( ) ) ; } private static void assertMacHashing ( byte [ ] input , String algorithm , SecretKey key , HashFunction hashFunc ) throws Exception { Mac mac = Mac . getInstance ( algorithm ) ; mac . init ( key ) ; mac . update ( input ) ; assertEquals ( HashCode . fromBytes ( mac . doFinal ( ) ) , hashFunc . hashBytes ( input ) ) ; assertEquals ( HashCode . fromBytes ( mac . doFinal ( input ) ) , hashFunc . hashBytes ( input ) ) ; } public void testRfc2202_hmacSha1_case1 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case2 ( ) { byte [ ] key = <str> . getBytes ( UTF_8 ) ; String data = <str> ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case3 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; byte [ ] data = fillByteArray ( <int> , <hex> ) ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case4 ( ) { byte [ ] key = base16 ( ) . lowerCase ( ) . decode ( <str> ) ; byte [ ] data = fillByteArray ( <int> , <hex> ) ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case5 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case6 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacSha1_case7 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkSha1 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case1 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case2 ( ) { byte [ ] key = <str> . getBytes ( UTF_8 ) ; String data = <str> ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case3 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; byte [ ] data = fillByteArray ( <int> , <hex> ) ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case4 ( ) { byte [ ] key = base16 ( ) . lowerCase ( ) . decode ( <str> ) ; byte [ ] data = fillByteArray ( <int> , <hex> ) ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case5 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case6 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkMd5 ( <str> , key , data ) ; } public void testRfc2202_hmacMd5_case7 ( ) { byte [ ] key = fillByteArray ( <int> , <hex> ) ; String data = <str> ; checkMd5 ( <str> , key , data ) ; } private static void checkSha1 ( String expected , byte [ ] key , String data ) { checkSha1 ( expected , key , data . getBytes ( UTF_8 ) ) ; } private static void checkSha1 ( String expected , byte [ ] key , byte [ ] data ) { checkHmac ( expected , Hashing . hmacSha1 ( key ) , data ) ; } private static void checkMd5 ( String expected , byte [ ] key , String data ) { checkMd5 ( expected , key , data . getBytes ( UTF_8 ) ) ; } private static void checkMd5 ( String expected , byte [ ] key , byte [ ] data ) { checkHmac ( expected , Hashing . hmacMd5 ( key ) , data ) ; } private static void checkHmac ( String expected , HashFunction hashFunc , byte [ ] data ) { assertEquals ( HashCode . fromString ( expected ) , hashFunc . hashBytes ( data ) ) ; } private static byte [ ] fillByteArray ( int size , int toFillWith ) { byte [ ] array = new byte [ size ] ; Arrays . fill ( array , ( byte ) toFillWith ) ; return array ; } } 
