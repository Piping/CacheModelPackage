package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerAppender ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . handler . codec . PrematureChannelClosureException ; import io . netty . util . internal . OneTimeTask ; import java . util . ArrayDeque ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . atomic . AtomicLong ; public final class HttpClientCodec extends ChannelHandlerAppender implements HttpClientUpgradeHandler . SourceCodec { private final Queue < HttpMethod > queue = new ArrayDeque < HttpMethod > ( ) ; private boolean done ; private final AtomicLong requestResponseCounter = new AtomicLong ( ) ; private final boolean failOnMissingResponse ; public HttpClientCodec ( ) { this ( <int> , <int> , <int> , false ) ; } public HttpClientCodec ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { this ( maxInitialLineLength , maxHeaderSize , maxChunkSize , false ) ; } public HttpClientCodec ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , boolean failOnMissingResponse ) { this ( maxInitialLineLength , maxHeaderSize , maxChunkSize , failOnMissingResponse , true ) ; } public HttpClientCodec ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , boolean failOnMissingResponse , boolean validateHeaders ) { add ( new Decoder ( maxInitialLineLength , maxHeaderSize , maxChunkSize , validateHeaders ) ) ; add ( new Encoder ( ) ) ; this . failOnMissingResponse = failOnMissingResponse ; } @Override public void upgradeFrom ( ChannelHandlerContext ctx ) { final ChannelPipeline p = ctx . pipeline ( ) ; ctx . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { p . remove ( decoder ( ) ) ; } } ) ; p . remove ( encoder ( ) ) ; } public HttpRequestEncoder encoder ( ) { return handlerAt ( <int> ) ; } public HttpResponseDecoder decoder ( ) { return handlerAt ( <int> ) ; } public void setSingleDecode ( boolean singleDecode ) { decoder ( ) . setSingleDecode ( singleDecode ) ; } public boolean isSingleDecode ( ) { return decoder ( ) . isSingleDecode ( ) ; } private final class Encoder extends HttpRequestEncoder { @Override protected void encode ( ChannelHandlerContext ctx , Object msg , List < Object > out ) throws Exception { if ( msg instanceof HttpRequest & & ! done ) { queue . offer ( ( ( HttpRequest ) msg ) . method ( ) ) ; } super . encode ( ctx , msg , out ) ; if ( failOnMissingResponse ) { if ( msg instanceof LastHttpContent ) { requestResponseCounter . incrementAndGet ( ) ; } } } } private final class Decoder extends HttpResponseDecoder { Decoder ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , boolean validateHeaders ) { super ( maxInitialLineLength , maxHeaderSize , maxChunkSize , validateHeaders ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buffer , List < Object > out ) throws Exception { if ( done ) { int readable = actualReadableBytes ( ) ; if ( readable = = <int> ) { return ; } out . add ( buffer . readBytes ( readable ) ) ; } else { int oldSize = out . size ( ) ; super . decode ( ctx , buffer , out ) ; if ( failOnMissingResponse ) { int size = out . size ( ) ; for ( int i = oldSize ; i < size ; i + + ) { decrement ( out . get ( i ) ) ; } } } } private void decrement ( Object msg ) { if ( msg = = null ) { return ; } if ( msg instanceof LastHttpContent ) { requestResponseCounter . decrementAndGet ( ) ; } } @Override protected boolean isContentAlwaysEmpty ( HttpMessage msg ) { final int statusCode = ( ( HttpResponse ) msg ) . status ( ) . code ( ) ; if ( statusCode = = <int> ) { return true ; } HttpMethod method = queue . poll ( ) ; char firstChar = method . name ( ) . charAt ( <int> ) ; switch ( firstChar ) { case <str> : if ( HttpMethod . HEAD . equals ( method ) ) { return true ; } break ; case <str> : if ( statusCode = = <int> ) { if ( HttpMethod . CONNECT . equals ( method ) ) { done = true ; queue . clear ( ) ; return true ; } } break ; } return super . isContentAlwaysEmpty ( msg ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { super . channelInactive ( ctx ) ; if ( failOnMissingResponse ) { long missingResponses = requestResponseCounter . get ( ) ; if ( missingResponses > <int> ) { ctx . fireExceptionCaught ( new PrematureChannelClosureException ( <str> + missingResponses + <str> ) ) ; } } } } } 
