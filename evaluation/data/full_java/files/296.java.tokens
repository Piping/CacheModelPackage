package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . * ; import org . apache . cassandra . cache . IMeasurableMemory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; public interface ClusteringPrefix extends IMeasurableMemory , Clusterable { public static final Serializer serializer = new Serializer ( ) ; public enum Kind { EXCL_END_BOUND ( <int> , - <int> ) , INCL_START_BOUND ( <int> , - <int> ) , EXCL_END_INCL_START_BOUNDARY ( <int> , - <int> ) , STATIC_CLUSTERING ( <int> , - <int> ) , CLUSTERING ( <int> , <int> ) , INCL_END_EXCL_START_BOUNDARY ( <int> , <int> ) , INCL_END_BOUND ( <int> , <int> ) , EXCL_START_BOUND ( <int> , <int> ) ; private final int comparison ; public final int comparedToClustering ; private Kind ( int comparison , int comparedToClustering ) { this . comparison = comparison ; this . comparedToClustering = comparedToClustering ; } public static int compare ( Kind k1 , Kind k2 ) { return Integer . compare ( k1 . comparison , k2 . comparison ) ; } public Kind invert ( ) { switch ( this ) { case EXCL_START_BOUND : return INCL_END_BOUND ; case INCL_START_BOUND : return EXCL_END_BOUND ; case EXCL_END_BOUND : return INCL_START_BOUND ; case INCL_END_BOUND : return EXCL_START_BOUND ; case EXCL_END_INCL_START_BOUNDARY : return INCL_END_EXCL_START_BOUNDARY ; case INCL_END_EXCL_START_BOUNDARY : return EXCL_END_INCL_START_BOUNDARY ; default : return this ; } } public boolean isBound ( ) { switch ( this ) { case INCL_START_BOUND : case INCL_END_BOUND : case EXCL_START_BOUND : case EXCL_END_BOUND : return true ; } return false ; } public boolean isBoundary ( ) { switch ( this ) { case INCL_END_EXCL_START_BOUNDARY : case EXCL_END_INCL_START_BOUNDARY : return true ; } return false ; } public boolean isStart ( ) { switch ( this ) { case INCL_START_BOUND : case EXCL_END_INCL_START_BOUNDARY : case INCL_END_EXCL_START_BOUNDARY : case EXCL_START_BOUND : return true ; default : return false ; } } public boolean isEnd ( ) { switch ( this ) { case INCL_END_BOUND : case EXCL_END_INCL_START_BOUNDARY : case INCL_END_EXCL_START_BOUNDARY : case EXCL_END_BOUND : return true ; default : return false ; } } public boolean isOpen ( boolean reversed ) { return isBoundary ( ) | | ( reversed ? isEnd ( ) : isStart ( ) ) ; } public boolean isClose ( boolean reversed ) { return isBoundary ( ) | | ( reversed ? isStart ( ) : isEnd ( ) ) ; } public Kind closeBoundOfBoundary ( boolean reversed ) { assert isBoundary ( ) ; return reversed ? ( this = = INCL_END_EXCL_START_BOUNDARY ? EXCL_START_BOUND : INCL_START_BOUND ) : ( this = = INCL_END_EXCL_START_BOUNDARY ? INCL_END_BOUND : EXCL_END_BOUND ) ; } public Kind openBoundOfBoundary ( boolean reversed ) { assert isBoundary ( ) ; return reversed ? ( this = = INCL_END_EXCL_START_BOUNDARY ? INCL_END_BOUND : EXCL_END_BOUND ) : ( this = = INCL_END_EXCL_START_BOUNDARY ? EXCL_START_BOUND : INCL_START_BOUND ) ; } } public Kind kind ( ) ; public int size ( ) ; public ByteBuffer get ( int i ) ; public void digest ( MessageDigest digest ) ; public int dataSize ( ) ; public String toString ( CFMetaData metadata ) ; public ByteBuffer [ ] getRawValues ( ) ; public static class Serializer { public void serialize ( ClusteringPrefix clustering , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { assert clustering . kind ( ) ! = Kind . STATIC_CLUSTERING ; if ( clustering . kind ( ) = = Kind . CLUSTERING ) { out . writeByte ( clustering . kind ( ) . ordinal ( ) ) ; Clustering . serializer . serialize ( ( Clustering ) clustering , out , version , types ) ; } else { Slice . Bound . serializer . serialize ( ( Slice . Bound ) clustering , out , version , types ) ; } } public ClusteringPrefix deserialize ( DataInputPlus in , int version , List < AbstractType < ? > > types ) throws IOException { Kind kind = Kind . values ( ) [ in . readByte ( ) ] ; assert kind ! = Kind . STATIC_CLUSTERING ; if ( kind = = Kind . CLUSTERING ) return Clustering . serializer . deserialize ( in , version , types ) ; else return Slice . Bound . serializer . deserializeValues ( in , kind , version , types ) ; } public long serializedSize ( ClusteringPrefix clustering , int version , List < AbstractType < ? > > types ) { assert clustering . kind ( ) ! = Kind . STATIC_CLUSTERING ; if ( clustering . kind ( ) = = Kind . CLUSTERING ) return <int> + Clustering . serializer . serializedSize ( ( Clustering ) clustering , version , types ) ; else return Slice . Bound . serializer . serializedSize ( ( Slice . Bound ) clustering , version , types ) ; } void serializeValuesWithoutSize ( ClusteringPrefix clustering , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { int offset = <int> ; int clusteringSize = clustering . size ( ) ; while ( offset < clusteringSize ) { int limit = Math . min ( clusteringSize , offset + <int> ) ; out . writeUnsignedVInt ( makeHeader ( clustering , offset , limit ) ) ; while ( offset < limit ) { ByteBuffer v = clustering . get ( offset ) ; if ( v ! = null & & v . hasRemaining ( ) ) types . get ( offset ) . writeValue ( v , out ) ; offset + + ; } } } long valuesWithoutSizeSerializedSize ( ClusteringPrefix clustering , int version , List < AbstractType < ? > > types ) { long result = <int> ; int offset = <int> ; int clusteringSize = clustering . size ( ) ; while ( offset < clusteringSize ) { int limit = Math . min ( clusteringSize , offset + <int> ) ; result + = TypeSizes . sizeofUnsignedVInt ( makeHeader ( clustering , offset , limit ) ) ; offset = limit ; } for ( int i = <int> ; i < clusteringSize ; i + + ) { ByteBuffer v = clustering . get ( i ) ; if ( v = = null | | ! v . hasRemaining ( ) ) continue ; result + = types . get ( i ) . writtenLength ( v ) ; } return result ; } ByteBuffer [ ] deserializeValuesWithoutSize ( DataInputPlus in , int size , int version , List < AbstractType < ? > > types ) throws IOException { assert size > <int> ; ByteBuffer [ ] values = new ByteBuffer [ size ] ; int offset = <int> ; while ( offset < size ) { long header = in . readUnsignedVInt ( ) ; int limit = Math . min ( size , offset + <int> ) ; while ( offset < limit ) { values [ offset ] = isNull ( header , offset ) ? null : ( isEmpty ( header , offset ) ? ByteBufferUtil . EMPTY_BYTE_BUFFER : types . get ( offset ) . readValue ( in ) ) ; offset + + ; } } return values ; } private static long makeHeader ( ClusteringPrefix clustering , int offset , int limit ) { long header = <int> ; for ( int i = offset ; i < limit ; i + + ) { ByteBuffer v = clustering . get ( i ) ; if ( v = = null ) header | = ( <int> < < ( i * <int> ) + <int> ) ; else if ( ! v . hasRemaining ( ) ) header | = ( <int> < < ( i * <int> ) ) ; } return header ; } private static boolean isNull ( long header , int i ) { long mask = <int> < < ( i * <int> ) + <int> ; return ( header & mask ) ! = <int> ; } private static boolean isEmpty ( long header , int i ) { long mask = <int> < < ( i * <int> ) ; return ( header & mask ) ! = <int> ; } } public static class Deserializer { private final ClusteringComparator comparator ; private final DataInputPlus in ; private final SerializationHeader serializationHeader ; private boolean nextIsRow ; private long nextHeader ; private int nextSize ; private ClusteringPrefix . Kind nextKind ; private int deserializedSize ; private ByteBuffer [ ] nextValues ; public Deserializer ( ClusteringComparator comparator , DataInputPlus in , SerializationHeader header ) { this . comparator = comparator ; this . in = in ; this . serializationHeader = header ; } public void prepare ( int flags , int extendedFlags ) throws IOException { assert ! UnfilteredSerializer . isStatic ( extendedFlags ) : <str> + flags ; this . nextIsRow = UnfilteredSerializer . kind ( flags ) = = Unfiltered . Kind . ROW ; this . nextKind = nextIsRow ? Kind . CLUSTERING : ClusteringPrefix . Kind . values ( ) [ in . readByte ( ) ] ; this . nextSize = nextIsRow ? comparator . size ( ) : in . readUnsignedShort ( ) ; this . deserializedSize = <int> ; if ( nextValues = = null | | nextValues . length ! = nextSize ) this . nextValues = new ByteBuffer [ nextSize ] ; } public int compareNextTo ( Slice . Bound bound ) throws IOException { if ( bound = = Slice . Bound . TOP ) return - <int> ; for ( int i = <int> ; i < bound . size ( ) ; i + + ) { if ( ! hasComponent ( i ) ) return nextKind . comparedToClustering ; int cmp = comparator . compareComponent ( i , nextValues [ i ] , bound . get ( i ) ) ; if ( cmp ! = <int> ) return cmp ; } if ( bound . size ( ) = = nextSize ) return nextKind . compareTo ( bound . kind ( ) ) ; return - bound . kind ( ) . comparedToClustering ; } private boolean hasComponent ( int i ) throws IOException { if ( i > = nextSize ) return false ; while ( deserializedSize < = i ) deserializeOne ( ) ; return true ; } private boolean deserializeOne ( ) throws IOException { if ( deserializedSize = = nextSize ) return false ; if ( ( deserializedSize % <int> ) = = <int> ) nextHeader = in . readUnsignedVInt ( ) ; int i = deserializedSize + + ; nextValues [ i ] = Serializer . isNull ( nextHeader , i ) ? null : ( Serializer . isEmpty ( nextHeader , i ) ? ByteBufferUtil . EMPTY_BYTE_BUFFER : serializationHeader . clusteringTypes ( ) . get ( i ) . readValue ( in ) ) ; return true ; } private void deserializeAll ( ) throws IOException { while ( deserializeOne ( ) ) continue ; } public RangeTombstone . Bound deserializeNextBound ( ) throws IOException { assert ! nextIsRow ; deserializeAll ( ) ; RangeTombstone . Bound bound = new RangeTombstone . Bound ( nextKind , nextValues ) ; nextValues = null ; return bound ; } public Clustering deserializeNextClustering ( ) throws IOException { assert nextIsRow ; deserializeAll ( ) ; Clustering clustering = new Clustering ( nextValues ) ; nextValues = null ; return clustering ; } public ClusteringPrefix . Kind skipNext ( ) throws IOException { for ( int i = deserializedSize ; i < nextSize ; i + + ) { if ( ( i % <int> ) = = <int> ) nextHeader = in . readUnsignedVInt ( ) ; if ( ! Serializer . isNull ( nextHeader , i ) & & ! Serializer . isEmpty ( nextHeader , i ) ) serializationHeader . clusteringTypes ( ) . get ( i ) . skipValue ( in ) ; } deserializedSize = nextSize ; return nextKind ; } } } 
