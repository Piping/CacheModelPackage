package org . eclipse . debug . tests . viewer . model ; import java . util . ArrayList ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ISelectionChangedListener ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class SelectionTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public SelectionTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } abstract protected ITreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } private static class SelectionListener implements ISelectionChangedListener { private final List < SelectionChangedEvent > fEvents = new ArrayList < SelectionChangedEvent > ( <int> ) ; @Override public void selectionChanged ( SelectionChangedEvent event ) { fEvents . add ( event ) ; } } private TestModel makeMultiLevelModel ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; return model ; } public void testSimpleSetSelection ( ) throws InterruptedException { TestModel model = makeMultiLevelModel ( ) ; SelectionListener listener = new SelectionListener ( ) ; fViewer . addSelectionChangedListener ( listener ) ; TreeSelection selection = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( selection , true , false ) ; assertTrue ( listener . fEvents . size ( ) = = <int> ) ; ISelection viewerSelection = fViewer . getSelection ( ) ; assertEquals ( selection , viewerSelection ) ; } public void testSelectionPolicy ( ) throws InterruptedException { final TestModel model = makeMultiLevelModel ( ) ; TreeSelection selection_3_3_3 = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( selection_3_3_3 , true , false ) ; assertEquals ( selection_3_3_3 , fViewer . getSelection ( ) ) ; model . setSelectionPolicy ( new IModelSelectionPolicy ( ) { @Override public ISelection replaceInvalidSelection ( ISelection invalidSelection , ISelection newSelection ) { return null ; } @Override public boolean overrides ( ISelection existing , ISelection candidate , IPresentationContext context ) { return false ; } @Override public boolean isSticky ( ISelection selection , IPresentationContext context ) { return true ; } @Override public boolean contains ( ISelection selection , IPresentationContext context ) { return true ; } } ) ; TreeSelection selection_3_3_1 = new TreeSelection ( model . findElement ( <str> ) ) ; fViewer . setSelection ( selection_3_3_1 , true , false ) ; assertEquals ( selection_3_3_3 , fViewer . getSelection ( ) ) ; fViewer . setSelection ( selection_3_3_1 , true , true ) ; assertEquals ( selection_3_3_1 , fViewer . getSelection ( ) ) ; TreePath path_3_3_3 = model . findElement ( <str> ) ; ModelDelta baseDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; ModelDelta delta_3_3_3 = model . getElementDelta ( baseDelta , path_3_3_3 , false ) ; delta_3_3_3 . setFlags ( IModelDelta . SELECT ) ; fViewer . updateViewer ( baseDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertEquals ( selection_3_3_1 , fViewer . getSelection ( ) ) ; delta_3_3_3 . setFlags ( IModelDelta . SELECT | IModelDelta . FORCE ) ; fViewer . updateViewer ( baseDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertEquals ( selection_3_3_3 , fViewer . getSelection ( ) ) ; } public void testSelectRemove ( ) throws InterruptedException { TestModel model = makeMultiLevelModel ( ) ; TreePath elementPath = model . findElement ( <str> ) ; TreeSelection selection = new TreeSelection ( elementPath ) ; fViewer . setSelection ( selection , true , false ) ; TreePath removePath = model . findElement ( <str> ) ; TreePath parentPath = removePath . getParentPath ( ) ; int removeIndex = model . getElement ( parentPath ) . indexOf ( model . getElement ( removePath ) ) ; ModelDelta delta = model . removeElementChild ( removePath . getParentPath ( ) , removeIndex ) ; SelectionListener listener = new SelectionListener ( ) ; fViewer . addSelectionChangedListener ( listener ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ITestModelUpdatesListenerConstants . MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ISelection viewerSelection = fViewer . getSelection ( ) ; assertTrue ( viewerSelection . isEmpty ( ) ) ; } public void testSelectRemoveRefreshStruct ( ) throws InterruptedException { TestModel model = makeMultiLevelModel ( ) ; TreePath elementPath = model . findElement ( <str> ) ; TreeSelection selection = new TreeSelection ( elementPath ) ; fViewer . setSelection ( selection , true , false ) ; TreePath removePath = model . findElement ( <str> ) ; TreePath parentPath = removePath . getParentPath ( ) ; int removeIndex = model . getElement ( parentPath ) . indexOf ( model . getElement ( removePath ) ) ; model . removeElementChild ( removePath . getParentPath ( ) , removeIndex ) ; SelectionListener listener = new SelectionListener ( ) ; fViewer . addSelectionChangedListener ( listener ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ITestModelUpdatesListenerConstants . ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ISelection viewerSelection = fViewer . getSelection ( ) ; assertTrue ( viewerSelection . isEmpty ( ) ) ; } } 
