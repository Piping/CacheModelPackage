package org . elasticsearch . search . fetch . version ; import org . apache . lucene . index . Term ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . fetch . FetchSubPhase ; import org . elasticsearch . search . internal . InternalSearchHit ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Map ; import static java . util . Collections . singletonMap ; public class VersionFetchSubPhase implements FetchSubPhase { private static final Map < String , ? extends SearchParseElement > PARSE_ELEMENTS = singletonMap ( <str> , new VersionParseElement ( ) ) ; @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { return PARSE_ELEMENTS ; } @Override public boolean hitsExecutionNeeded ( SearchContext context ) { return false ; } @Override public void hitsExecute ( SearchContext context , InternalSearchHit [ ] hits ) { } @Override public boolean hitExecutionNeeded ( SearchContext context ) { return context . version ( ) ; } @Override public void hitExecute ( SearchContext context , HitContext hitContext ) { long version ; try { BytesRef uid = Uid . createUidAsBytes ( hitContext . hit ( ) . type ( ) , hitContext . hit ( ) . id ( ) ) ; version = Versions . loadVersion ( hitContext . readerContext ( ) . reader ( ) , new Term ( UidFieldMapper . NAME , uid ) ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } if ( version < <int> ) { version = - <int> ; } hitContext . hit ( ) . version ( version ) ; } } 
