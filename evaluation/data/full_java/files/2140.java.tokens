package org . nd4j . linalg . api . parallel . tasks . cpu . misc ; import io . netty . buffer . ByteBuf ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . parallel . tasks . Task ; import org . nd4j . linalg . api . parallel . tasks . TaskExecutorProvider ; import org . nd4j . linalg . convolution . Convolution ; import org . nd4j . linalg . factory . Nd4j ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Future ; import java . util . concurrent . RecursiveTask ; public class CPUIm2ColTask extends RecursiveTask < INDArray > implements Task < INDArray > { protected Future < INDArray > future ; protected List < CPUIm2ColTask > subTasks ; protected final INDArray img ; protected INDArray out ; protected final int kernelHeight ; protected final int kernelWidth ; protected final int strideY ; protected final int strideX ; protected final int padHeight ; protected final int padWidth ; protected final boolean coverAll ; protected final int parallelThreshold ; protected final int exampleFrom ; protected final int exampleTo ; protected final int depthFrom ; protected final int depthTo ; protected final int xOutFrom ; protected final int xOutTo ; protected final int yOutFrom ; protected final int yOutTo ; public CPUIm2ColTask ( INDArray img , int kernelHeight , int kernelWidth , int strideY , int strideX , int padHeight , int padWidth , boolean coverAll , int parallelThreshold ) { this ( img , getNewOutputArray ( img , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , coverAll ) , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , <int> , img . size ( <int> ) , <int> , img . size ( <int> ) , <int> , Convolution . outSize ( img . size ( <int> ) , kernelHeight , strideY , padHeight , coverAll ) , <int> , Convolution . outSize ( img . size ( <int> ) , kernelWidth , strideX , padWidth , coverAll ) , coverAll , parallelThreshold ) ; } public CPUIm2ColTask ( INDArray img , INDArray out , int kernelHeight , int kernelWidth , int strideY , int strideX , int padHeight , int padWidth , int exampleFrom , int exampleTo , int depthFrom , int depthTo , int yOutFrom , int yOutTo , int xOutFrom , int xOutTo , boolean coverAll , int parallelThreshold ) { this . img = img ; this . out = out ; this . kernelHeight = kernelHeight ; this . kernelWidth = kernelWidth ; this . strideY = strideY ; this . strideX = strideX ; this . padHeight = padHeight ; this . padWidth = padWidth ; this . coverAll = coverAll ; this . parallelThreshold = parallelThreshold ; this . exampleFrom = exampleFrom ; this . exampleTo = exampleTo ; this . depthFrom = depthFrom ; this . depthTo = depthTo ; this . xOutFrom = xOutFrom ; this . xOutTo = xOutTo ; this . yOutFrom = yOutFrom ; this . yOutTo = yOutTo ; } private static INDArray getNewOutputArray ( INDArray img , int kernelHeight , int kernelWidth , int strideY , int strideX , int padHeight , int padWidth , boolean coverAll ) { int n = img . size ( <int> ) ; int c = img . size ( <int> ) ; int h = img . size ( <int> ) ; int w = img . size ( <int> ) ; int outHeight = Convolution . outSize ( h , kernelHeight , strideY , padHeight , coverAll ) ; int outWidth = Convolution . outSize ( w , kernelWidth , strideX , padWidth , coverAll ) ; return Nd4j . create ( n , c , kernelHeight , kernelWidth , outHeight , outWidth ) ; } @Override protected INDArray compute ( ) { splitOrExecute ( true ) ; return out ; } @Override public INDArray call ( ) { splitOrExecute ( true ) ; return null ; } private void splitOrExecute ( final boolean forkJoin ) { if ( ! forkJoin ) subTasks = new ArrayList < > ( ) ; if ( parallelThreshold ! = Integer . MAX_VALUE & & opSize ( ) > parallelThreshold ) { CPUIm2ColTask first ; CPUIm2ColTask second ; int temp ; if ( ( temp = exampleTo - exampleFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleFrom + countFirst , depthFrom , depthTo , yOutFrom , yOutTo , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; if ( forkJoin ) first . fork ( ) ; else { first . invokeAsync ( ) ; subTasks . add ( first ) ; } second = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom + countFirst , exampleTo , depthFrom , depthTo , yOutFrom , yOutTo , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; if ( forkJoin ) second . fork ( ) ; else { second . invokeAsync ( ) ; subTasks . add ( second ) ; } } else if ( ( temp = depthTo - depthFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom , depthFrom + countFirst , yOutFrom , yOutTo , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; first . fork ( ) ; second = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom + countFirst , depthTo , yOutFrom , yOutTo , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; second . fork ( ) ; } else if ( ( temp = yOutTo - yOutFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom , depthTo , yOutFrom , yOutFrom + countFirst , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; if ( forkJoin ) first . fork ( ) ; else { first . invokeAsync ( ) ; subTasks . add ( first ) ; } second = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom , depthTo , yOutFrom + countFirst , yOutTo , xOutFrom , xOutTo , coverAll , parallelThreshold ) ; if ( forkJoin ) second . fork ( ) ; else { second . invokeAsync ( ) ; subTasks . add ( second ) ; } } else if ( ( temp = xOutTo - xOutFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom , depthTo , yOutFrom , yOutTo , xOutFrom , xOutFrom + countFirst , coverAll , parallelThreshold ) ; if ( forkJoin ) first . fork ( ) ; else { first . invokeAsync ( ) ; subTasks . add ( first ) ; } second = new CPUIm2ColTask ( img , out , kernelHeight , kernelWidth , strideY , strideX , padHeight , padWidth , exampleFrom , exampleTo , depthFrom , depthTo , yOutFrom , yOutTo , xOutFrom + countFirst , xOutTo , coverAll , parallelThreshold ) ; if ( forkJoin ) second . fork ( ) ; else { second . invokeAsync ( ) ; subTasks . add ( second ) ; } } else { execute ( ) ; return ; } if ( forkJoin ) { first . join ( ) ; second . join ( ) ; } } else { execute ( ) ; } } private int opSize ( ) { return ( exampleTo - exampleFrom ) * ( depthTo - depthFrom ) * ( xOutTo - xOutFrom ) * ( yOutTo - yOutFrom ) * kernelHeight * kernelWidth ; } private void execute ( ) { DataBuffer dbIn = img . data ( ) ; if ( dbIn . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( dbIn . dataType ( ) = = DataBuffer . Type . FLOAT ) { doHeapFloat ( ) ; } else { doHeapDouble ( ) ; } } else { if ( dbIn . dataType ( ) = = DataBuffer . Type . FLOAT ) { doDirectFloat ( ) ; } else { doDirectDouble ( ) ; } } } private void doHeapFloat ( ) { DataBuffer dbIn = img . data ( ) ; DataBuffer dbOut = out . data ( ) ; int outArrayOffset = out . offset ( ) ; int [ ] outShape = out . shape ( ) ; int [ ] outStride = out . stride ( ) ; int inArrayOffset = img . offset ( ) ; int [ ] inShape = img . shape ( ) ; int [ ] inStride = img . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2 = inStride [ <int> ] ; final int inStride3 = inStride [ <int> ] ; final int outStride2 = outStride [ <int> ] ; final int outStride3 = outStride [ <int> ] ; final int inShape2 = inShape [ <int> ] ; final int inShape3 = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; float [ ] fIn = ( float [ ] ) dbIn . array ( ) ; float [ ] fOut = ( float [ ] ) dbOut . array ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = xOutFrom ; x < xOutTo ; x + + ) { for ( int y = yOutFrom ; y < yOutTo ; y + + ) { outIndices [ <int> ] = y ; outIndices [ <int> ] = x ; int baseOffsetOut = getOffsetUnsafe6 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetIn = getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2 < = outStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxX = baseOffsetOut + patchX * outStride3 ; int inBufferIdxX = baseOffsetIn + patchX * inStride3 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) fOut [ outBufferIdxX + patchY * outStride2 ] = <float> ; else { fOut [ outBufferIdxX + patchY * outStride2 ] = fIn [ inBufferIdxX + patchY * inStride2 ] ; } } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxY = baseOffsetOut + patchY * outStride2 ; int inBufferIdxY = baseOffsetIn + patchY * inStride2 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) fOut [ outBufferIdxY + patchX * outStride3 ] = <float> ; else { fOut [ outBufferIdxY + patchX * outStride3 ] = fIn [ inBufferIdxY + patchX * inStride3 ] ; } } } } } else { int i = y * strideY ; int j = x * strideX ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetIn = getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2 < = outStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxX = baseOffsetOut + patchX * outStride3 ; int inBufferIdxX = baseOffsetIn + patchX * inStride3 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { fOut [ outBufferIdxX + patchY * outStride2 ] = fIn [ inBufferIdxX + patchY * inStride2 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxY = baseOffsetOut + patchY * outStride2 ; int inBufferIdxY = baseOffsetIn + patchY * inStride2 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { fOut [ outBufferIdxY + patchX * outStride3 ] = fIn [ inBufferIdxY + patchX * inStride3 ] ; } } } } } } } } } private void doHeapDouble ( ) { DataBuffer dbIn = img . data ( ) ; DataBuffer dbOut = out . data ( ) ; int outArrayOffset = out . offset ( ) ; int [ ] outShape = out . shape ( ) ; int [ ] outStride = out . stride ( ) ; int inArrayOffset = img . offset ( ) ; int [ ] inShape = img . shape ( ) ; int [ ] inStride = img . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2 = inStride [ <int> ] ; final int inStride3 = inStride [ <int> ] ; final int outStride2 = outStride [ <int> ] ; final int outStride3 = outStride [ <int> ] ; final int inShape2 = inShape [ <int> ] ; final int inShape3 = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; double [ ] dIn = ( double [ ] ) dbIn . array ( ) ; double [ ] dOut = ( double [ ] ) dbOut . array ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = xOutFrom ; x < xOutTo ; x + + ) { for ( int y = yOutFrom ; y < yOutTo ; y + + ) { outIndices [ <int> ] = y ; outIndices [ <int> ] = x ; int baseOffsetOut = getOffsetUnsafe6 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetIn = getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2 < = outStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxX = baseOffsetOut + patchX * outStride3 ; int inBufferIdxX = baseOffsetIn + patchX * inStride3 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) dOut [ outBufferIdxX + patchY * outStride2 ] = <float> ; else { dOut [ outBufferIdxX + patchY * outStride2 ] = dIn [ inBufferIdxX + patchY * inStride2 ] ; } } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxY = baseOffsetOut + patchY * outStride2 ; int inBufferIdxY = baseOffsetIn + patchY * inStride2 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape [ <int> ] | | j + patchX > = inShape [ <int> ] ) dOut [ outBufferIdxY + patchX * outStride3 ] = <float> ; else { dOut [ outBufferIdxY + patchX * outStride3 ] = dIn [ inBufferIdxY + patchX * inStride3 ] ; } } } } } else { int i = y * strideY ; int j = x * strideX ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetIn = getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2 < = outStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxX = baseOffsetOut + patchX * outStride3 ; int inBufferIdxX = baseOffsetIn + patchX * inStride3 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { dOut [ outBufferIdxX + patchY * outStride2 ] = dIn [ inBufferIdxX + patchY * inStride2 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxY = baseOffsetOut + patchY * outStride2 ; int inBufferIdxY = baseOffsetIn + patchY * inStride2 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { dOut [ outBufferIdxY + patchX * outStride3 ] = dIn [ inBufferIdxY + patchX * inStride3 ] ; } } } } } } } } } private void doDirectFloat ( ) { DataBuffer dbIn = img . data ( ) ; DataBuffer dbOut = out . data ( ) ; int outArrayOffset = out . offset ( ) ; int [ ] outShape = out . shape ( ) ; int [ ] outStride = out . stride ( ) ; int inArrayOffset = img . offset ( ) ; int [ ] inShape = img . shape ( ) ; int [ ] inStride = img . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2_times4 = inStride [ <int> ] * <int> ; final int inStride3_times4 = inStride [ <int> ] * <int> ; final int outStride2_times4 = outStride [ <int> ] * <int> ; final int outStride3_times4 = outStride [ <int> ] * <int> ; final int inShape2 = inShape [ <int> ] ; final int inShape3 = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; ByteBuf nbbIn = dbIn . asNetty ( ) ; ByteBuf nbbOut = dbOut . asNetty ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = xOutFrom ; x < xOutTo ; x + + ) { for ( int y = yOutFrom ; y < yOutTo ; y + + ) { outIndices [ <int> ] = y ; outIndices [ <int> ] = x ; int baseOffsetOutBytes = <int> * getOffsetUnsafe6 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetInBytes = <int> * getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2_times4 < = outStride3_times4 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times4 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times4 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) nbbOut . setFloat ( outBufferIdxXBytes + patchY * outStride2_times4 , <float> ) ; else { nbbOut . setFloat ( outBufferIdxXBytes + patchY * outStride2_times4 , nbbIn . getFloat ( inBufferIdxXBytes + patchY * inStride2_times4 ) ) ; } } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times4 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times4 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) nbbOut . setFloat ( outBufferIdxYBytes + patchX * outStride3_times4 , <float> ) ; else { nbbOut . setFloat ( outBufferIdxYBytes + patchX * outStride3_times4 , nbbIn . getFloat ( inBufferIdxYBytes + patchX * inStride3_times4 ) ) ; } } } } } else { int i = y * strideY ; int j = x * strideX ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetInBytes = <int> * getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2_times4 < = outStride3_times4 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times4 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times4 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { nbbOut . setFloat ( outBufferIdxXBytes + patchY * outStride2_times4 , nbbIn . getFloat ( inBufferIdxXBytes + patchY * inStride2_times4 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times4 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times4 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { nbbOut . setFloat ( outBufferIdxYBytes + patchX * outStride3_times4 , nbbIn . getFloat ( inBufferIdxYBytes + patchX * inStride3_times4 ) ) ; } } } } } } } } } private void doDirectDouble ( ) { DataBuffer dbIn = img . data ( ) ; DataBuffer dbOut = out . data ( ) ; int outArrayOffset = out . offset ( ) ; int [ ] outShape = out . shape ( ) ; int [ ] outStride = out . stride ( ) ; int inArrayOffset = img . offset ( ) ; int [ ] inShape = img . shape ( ) ; int [ ] inStride = img . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2_times8 = inStride [ <int> ] * <int> ; final int inStride3_times8 = inStride [ <int> ] * <int> ; final int outStride2_times8 = outStride [ <int> ] * <int> ; final int outStride3_times8 = outStride [ <int> ] * <int> ; final int inShape2 = inShape [ <int> ] ; final int inShape3 = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; ByteBuf nbbIn = dbIn . asNetty ( ) ; ByteBuf nbbOut = dbOut . asNetty ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = xOutFrom ; x < xOutTo ; x + + ) { for ( int y = yOutFrom ; y < yOutTo ; y + + ) { outIndices [ <int> ] = y ; outIndices [ <int> ] = x ; int baseOffsetOutBytes = <int> * getOffsetUnsafe6 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetInBytes = <int> * getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2_times8 < = outStride3_times8 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times8 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times8 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape2 | | j + patchX > = inShape3 ) nbbOut . setDouble ( outBufferIdxXBytes + patchY * outStride2_times8 , <float> ) ; else { nbbOut . setDouble ( outBufferIdxXBytes + patchY * outStride2_times8 , nbbIn . getDouble ( inBufferIdxXBytes + patchY * inStride2_times8 ) ) ; } } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times8 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times8 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( i + patchY < <int> | | j + patchX < <int> | | i + patchY > = inShape [ <int> ] | | j + patchX > = inShape [ <int> ] ) nbbOut . setDouble ( outBufferIdxYBytes + patchX * outStride3_times8 , <float> ) ; else { nbbOut . setDouble ( outBufferIdxYBytes + patchX * outStride3_times8 , nbbIn . getDouble ( inBufferIdxYBytes + patchX * inStride3_times8 ) ) ; } } } } } else { int i = y * strideY ; int j = x * strideX ; inIndices [ <int> ] = i ; inIndices [ <int> ] = j ; int baseOffsetInBytes = <int> * getOffsetUnsafe4 ( inArrayOffset , inShape , inStride , inIndices ) ; if ( outStride2_times8 < = outStride3_times8 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times8 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times8 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { nbbOut . setDouble ( outBufferIdxXBytes + patchY * outStride2_times8 , nbbIn . getDouble ( inBufferIdxXBytes + patchY * inStride2_times8 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times8 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times8 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { nbbOut . setDouble ( outBufferIdxYBytes + patchX * outStride3_times8 , nbbIn . getDouble ( inBufferIdxYBytes + patchX * inStride3_times8 ) ) ; } } } } } } } } } private static int getOffsetUnsafe4 ( int baseOffset , int [ ] shape , int [ ] stride , int [ ] indices ) { int offset = baseOffset ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; return offset ; } private static int getOffsetUnsafe6 ( int baseOffset , int [ ] shape , int [ ] stride , int [ ] indices ) { int offset = baseOffset ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; return offset ; } @Override public INDArray invokeBlocking ( ) { invokeAsync ( ) ; return blockUntilComplete ( ) ; } @Override public void invokeAsync ( ) { future = TaskExecutorProvider . getTaskExecutor ( ) . executeAsync ( this ) ; } @Override public INDArray blockUntilComplete ( ) { try { future . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( subTasks ! = null ) { for ( CPUIm2ColTask task : subTasks ) { task . blockUntilComplete ( ) ; } } return out ; } } 
