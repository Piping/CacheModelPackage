package io . netty . util . concurrent ; import io . netty . util . Signal ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . InternalThreadLocalMap ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . ArrayDeque ; import java . util . concurrent . CancellationException ; import java . util . concurrent . TimeUnit ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; public class DefaultPromise < V > extends AbstractFuture < V > implements Promise < V > { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DefaultPromise . class ) ; private static final InternalLogger rejectedExecutionLogger = InternalLoggerFactory . getInstance ( DefaultPromise . class . getName ( ) + <str> ) ; private static final int MAX_LISTENER_STACK_DEPTH = <int> ; private static final Signal SUCCESS = Signal . valueOf ( DefaultPromise . class , <str> ) ; private static final Signal UNCANCELLABLE = Signal . valueOf ( DefaultPromise . class , <str> ) ; private static final CauseHolder CANCELLATION_CAUSE_HOLDER = new CauseHolder ( new CancellationException ( ) ) ; static { CANCELLATION_CAUSE_HOLDER . cause . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private final EventExecutor executor ; private volatile Object result ; private Object listeners ; private LateListeners lateListeners ; private short waiters ; public DefaultPromise ( EventExecutor executor ) { if ( executor = = null ) { throw new NullPointerException ( <str> ) ; } this . executor = executor ; } protected DefaultPromise ( ) { executor = null ; } protected EventExecutor executor ( ) { return executor ; } @Override public boolean isCancelled ( ) { return isCancelled0 ( result ) ; } private static boolean isCancelled0 ( Object result ) { return result instanceof CauseHolder & & ( ( CauseHolder ) result ) . cause instanceof CancellationException ; } @Override public boolean isCancellable ( ) { return result = = null ; } @Override public boolean isDone ( ) { return isDone0 ( result ) ; } private static boolean isDone0 ( Object result ) { return result ! = null & & result ! = UNCANCELLABLE ; } @Override public boolean isSuccess ( ) { Object result = this . result ; if ( result = = null | | result = = UNCANCELLABLE ) { return false ; } return ! ( result instanceof CauseHolder ) ; } @Override public Throwable cause ( ) { Object result = this . result ; if ( result instanceof CauseHolder ) { return ( ( CauseHolder ) result ) . cause ; } return null ; } @Override public Promise < V > addListener ( GenericFutureListener < ? extends Future < ? super V > > listener ) { if ( listener = = null ) { throw new NullPointerException ( <str> ) ; } if ( isDone ( ) ) { notifyLateListener ( listener ) ; return this ; } synchronized ( this ) { if ( ! isDone ( ) ) { if ( listeners = = null ) { listeners = listener ; } else { if ( listeners instanceof DefaultFutureListeners ) { ( ( DefaultFutureListeners ) listeners ) . add ( listener ) ; } else { final GenericFutureListener < ? extends Future < V > > firstListener = ( GenericFutureListener < ? extends Future < V > > ) listeners ; listeners = new DefaultFutureListeners ( firstListener , listener ) ; } } return this ; } } notifyLateListener ( listener ) ; return this ; } @Override public Promise < V > addListeners ( GenericFutureListener < ? extends Future < ? super V > > . . . listeners ) { if ( listeners = = null ) { throw new NullPointerException ( <str> ) ; } for ( GenericFutureListener < ? extends Future < ? super V > > l : listeners ) { if ( l = = null ) { break ; } addListener ( l ) ; } return this ; } @Override public Promise < V > removeListener ( GenericFutureListener < ? extends Future < ? super V > > listener ) { if ( listener = = null ) { throw new NullPointerException ( <str> ) ; } if ( isDone ( ) ) { return this ; } synchronized ( this ) { if ( ! isDone ( ) ) { if ( listeners instanceof DefaultFutureListeners ) { ( ( DefaultFutureListeners ) listeners ) . remove ( listener ) ; } else if ( listeners = = listener ) { listeners = null ; } } } return this ; } @Override public Promise < V > removeListeners ( GenericFutureListener < ? extends Future < ? super V > > . . . listeners ) { if ( listeners = = null ) { throw new NullPointerException ( <str> ) ; } for ( GenericFutureListener < ? extends Future < ? super V > > l : listeners ) { if ( l = = null ) { break ; } removeListener ( l ) ; } return this ; } @Override public Promise < V > sync ( ) throws InterruptedException { await ( ) ; rethrowIfFailed ( ) ; return this ; } @Override public Promise < V > syncUninterruptibly ( ) { awaitUninterruptibly ( ) ; rethrowIfFailed ( ) ; return this ; } private void rethrowIfFailed ( ) { Throwable cause = cause ( ) ; if ( cause = = null ) { return ; } PlatformDependent . throwException ( cause ) ; } @Override public Promise < V > await ( ) throws InterruptedException { if ( isDone ( ) ) { return this ; } if ( Thread . interrupted ( ) ) { throw new InterruptedException ( toString ( ) ) ; } synchronized ( this ) { while ( ! isDone ( ) ) { checkDeadLock ( ) ; incWaiters ( ) ; try { wait ( ) ; } finally { decWaiters ( ) ; } } } return this ; } @Override public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { return await0 ( unit . toNanos ( timeout ) , true ) ; } @Override public boolean await ( long timeoutMillis ) throws InterruptedException { return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , true ) ; } @Override public Promise < V > awaitUninterruptibly ( ) { if ( isDone ( ) ) { return this ; } boolean interrupted = false ; synchronized ( this ) { while ( ! isDone ( ) ) { checkDeadLock ( ) ; incWaiters ( ) ; try { wait ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } finally { decWaiters ( ) ; } } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } return this ; } @Override public boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) { try { return await0 ( unit . toNanos ( timeout ) , false ) ; } catch ( InterruptedException e ) { throw new InternalError ( ) ; } } @Override public boolean awaitUninterruptibly ( long timeoutMillis ) { try { return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , false ) ; } catch ( InterruptedException e ) { throw new InternalError ( ) ; } } private boolean await0 ( long timeoutNanos , boolean interruptable ) throws InterruptedException { if ( isDone ( ) ) { return true ; } if ( timeoutNanos < = <int> ) { return isDone ( ) ; } if ( interruptable & & Thread . interrupted ( ) ) { throw new InterruptedException ( toString ( ) ) ; } long startTime = System . nanoTime ( ) ; long waitTime = timeoutNanos ; boolean interrupted = false ; try { synchronized ( this ) { if ( isDone ( ) ) { return true ; } if ( waitTime < = <int> ) { return isDone ( ) ; } checkDeadLock ( ) ; incWaiters ( ) ; try { for ( ; ; ) { try { wait ( waitTime / <int> , ( int ) ( waitTime % <int> ) ) ; } catch ( InterruptedException e ) { if ( interruptable ) { throw e ; } else { interrupted = true ; } } if ( isDone ( ) ) { return true ; } else { waitTime = timeoutNanos - ( System . nanoTime ( ) - startTime ) ; if ( waitTime < = <int> ) { return isDone ( ) ; } } } } finally { decWaiters ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } protected void checkDeadLock ( ) { EventExecutor e = executor ( ) ; if ( e ! = null & & e . inEventLoop ( ) ) { throw new BlockingOperationException ( toString ( ) ) ; } } @Override public Promise < V > setSuccess ( V result ) { if ( setSuccess0 ( result ) ) { notifyListeners ( ) ; return this ; } throw new IllegalStateException ( <str> + this ) ; } @Override public boolean trySuccess ( V result ) { if ( setSuccess0 ( result ) ) { notifyListeners ( ) ; return true ; } return false ; } @Override public Promise < V > setFailure ( Throwable cause ) { if ( setFailure0 ( cause ) ) { notifyListeners ( ) ; return this ; } throw new IllegalStateException ( <str> + this , cause ) ; } @Override public boolean tryFailure ( Throwable cause ) { if ( setFailure0 ( cause ) ) { notifyListeners ( ) ; return true ; } return false ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { Object result = this . result ; if ( isDone0 ( result ) | | result = = UNCANCELLABLE ) { return false ; } synchronized ( this ) { result = this . result ; if ( isDone0 ( result ) | | result = = UNCANCELLABLE ) { return false ; } this . result = CANCELLATION_CAUSE_HOLDER ; if ( hasWaiters ( ) ) { notifyAll ( ) ; } } notifyListeners ( ) ; return true ; } @Override public boolean setUncancellable ( ) { Object result = this . result ; if ( isDone0 ( result ) ) { return ! isCancelled0 ( result ) ; } synchronized ( this ) { result = this . result ; if ( isDone0 ( result ) ) { return ! isCancelled0 ( result ) ; } this . result = UNCANCELLABLE ; } return true ; } private boolean setFailure0 ( Throwable cause ) { if ( cause = = null ) { throw new NullPointerException ( <str> ) ; } if ( isDone ( ) ) { return false ; } synchronized ( this ) { if ( isDone ( ) ) { return false ; } result = new CauseHolder ( cause ) ; if ( hasWaiters ( ) ) { notifyAll ( ) ; } } return true ; } private boolean setSuccess0 ( V result ) { if ( isDone ( ) ) { return false ; } synchronized ( this ) { if ( isDone ( ) ) { return false ; } if ( result = = null ) { this . result = SUCCESS ; } else { this . result = result ; } if ( hasWaiters ( ) ) { notifyAll ( ) ; } } return true ; } @Override @SuppressWarnings ( <str> ) public V getNow ( ) { Object result = this . result ; if ( result instanceof CauseHolder | | result = = SUCCESS ) { return null ; } return ( V ) result ; } private boolean hasWaiters ( ) { return waiters > <int> ; } private void incWaiters ( ) { if ( waiters = = Short . MAX_VALUE ) { throw new IllegalStateException ( <str> + this ) ; } waiters + + ; } private void decWaiters ( ) { waiters - - ; } private void notifyListeners ( ) { Object listeners = this . listeners ; if ( listeners = = null ) { return ; } EventExecutor executor = executor ( ) ; if ( executor . inEventLoop ( ) ) { final InternalThreadLocalMap threadLocals = InternalThreadLocalMap . get ( ) ; final int stackDepth = threadLocals . futureListenerStackDepth ( ) ; if ( stackDepth < MAX_LISTENER_STACK_DEPTH ) { threadLocals . setFutureListenerStackDepth ( stackDepth + <int> ) ; try { if ( listeners instanceof DefaultFutureListeners ) { notifyListeners0 ( this , ( DefaultFutureListeners ) listeners ) ; } else { final GenericFutureListener < ? extends Future < V > > l = ( GenericFutureListener < ? extends Future < V > > ) listeners ; notifyListener0 ( this , l ) ; } } finally { this . listeners = null ; threadLocals . setFutureListenerStackDepth ( stackDepth ) ; } return ; } } if ( listeners instanceof DefaultFutureListeners ) { final DefaultFutureListeners dfl = ( DefaultFutureListeners ) listeners ; execute ( executor , new OneTimeTask ( ) { @Override public void run ( ) { notifyListeners0 ( DefaultPromise . this , dfl ) ; DefaultPromise . this . listeners = null ; } } ) ; } else { final GenericFutureListener < ? extends Future < V > > l = ( GenericFutureListener < ? extends Future < V > > ) listeners ; execute ( executor , new OneTimeTask ( ) { @Override public void run ( ) { notifyListener0 ( DefaultPromise . this , l ) ; DefaultPromise . this . listeners = null ; } } ) ; } } private static void notifyListeners0 ( Future < ? > future , DefaultFutureListeners listeners ) { final GenericFutureListener < ? > [ ] a = listeners . listeners ( ) ; final int size = listeners . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { notifyListener0 ( future , a [ i ] ) ; } } private void notifyLateListener ( final GenericFutureListener < ? > l ) { final EventExecutor executor = executor ( ) ; if ( executor . inEventLoop ( ) ) { if ( listeners = = null & & ( lateListeners = = null | | lateListeners . isEmpty ( ) ) ) { final InternalThreadLocalMap threadLocals = InternalThreadLocalMap . get ( ) ; final int stackDepth = threadLocals . futureListenerStackDepth ( ) ; if ( stackDepth < MAX_LISTENER_STACK_DEPTH ) { threadLocals . setFutureListenerStackDepth ( stackDepth + <int> ) ; try { notifyListener0 ( this , l ) ; } finally { threadLocals . setFutureListenerStackDepth ( stackDepth ) ; } return ; } } else { LateListeners lateListeners = this . lateListeners ; if ( lateListeners = = null ) { this . lateListeners = lateListeners = new LateListeners ( ) ; } lateListeners . add ( l ) ; execute ( executor , lateListeners ) ; return ; } } execute ( executor , new LateListenerNotifier ( l ) ) ; } protected static void notifyListener ( final EventExecutor eventExecutor , final Future < ? > future , final GenericFutureListener < ? > l ) { if ( eventExecutor . inEventLoop ( ) ) { final InternalThreadLocalMap threadLocals = InternalThreadLocalMap . get ( ) ; final int stackDepth = threadLocals . futureListenerStackDepth ( ) ; if ( stackDepth < MAX_LISTENER_STACK_DEPTH ) { threadLocals . setFutureListenerStackDepth ( stackDepth + <int> ) ; try { notifyListener0 ( future , l ) ; } finally { threadLocals . setFutureListenerStackDepth ( stackDepth ) ; } return ; } } execute ( eventExecutor , new OneTimeTask ( ) { @Override public void run ( ) { notifyListener0 ( future , l ) ; } } ) ; } private static void execute ( EventExecutor executor , Runnable task ) { try { executor . execute ( task ) ; } catch ( Throwable t ) { rejectedExecutionLogger . error ( <str> , t ) ; } } @SuppressWarnings ( { <str> , <str> } ) static void notifyListener0 ( Future future , GenericFutureListener l ) { try { l . operationComplete ( future ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> + l . getClass ( ) . getName ( ) + <str> , t ) ; } } } private synchronized Object progressiveListeners ( ) { Object listeners = this . listeners ; if ( listeners = = null ) { return null ; } if ( listeners instanceof DefaultFutureListeners ) { DefaultFutureListeners dfl = ( DefaultFutureListeners ) listeners ; int progressiveSize = dfl . progressiveSize ( ) ; switch ( progressiveSize ) { case <int> : return null ; case <int> : for ( GenericFutureListener < ? > l : dfl . listeners ( ) ) { if ( l instanceof GenericProgressiveFutureListener ) { return l ; } } return null ; } GenericFutureListener < ? > [ ] array = dfl . listeners ( ) ; GenericProgressiveFutureListener < ? > [ ] copy = new GenericProgressiveFutureListener [ progressiveSize ] ; for ( int i = <int> , j = <int> ; j < progressiveSize ; i + + ) { GenericFutureListener < ? > l = array [ i ] ; if ( l instanceof GenericProgressiveFutureListener ) { copy [ j + + ] = ( GenericProgressiveFutureListener < ? > ) l ; } } return copy ; } else if ( listeners instanceof GenericProgressiveFutureListener ) { return listeners ; } else { return null ; } } @SuppressWarnings ( <str> ) void notifyProgressiveListeners ( final long progress , final long total ) { final Object listeners = progressiveListeners ( ) ; if ( listeners = = null ) { return ; } final ProgressiveFuture < V > self = ( ProgressiveFuture < V > ) this ; EventExecutor executor = executor ( ) ; if ( executor . inEventLoop ( ) ) { if ( listeners instanceof GenericProgressiveFutureListener [ ] ) { notifyProgressiveListeners0 ( self , ( GenericProgressiveFutureListener < ? > [ ] ) listeners , progress , total ) ; } else { notifyProgressiveListener0 ( self , ( GenericProgressiveFutureListener < ProgressiveFuture < V > > ) listeners , progress , total ) ; } } else { if ( listeners instanceof GenericProgressiveFutureListener [ ] ) { final GenericProgressiveFutureListener < ? > [ ] array = ( GenericProgressiveFutureListener < ? > [ ] ) listeners ; execute ( executor , new OneTimeTask ( ) { @Override public void run ( ) { notifyProgressiveListeners0 ( self , array , progress , total ) ; } } ) ; } else { final GenericProgressiveFutureListener < ProgressiveFuture < V > > l = ( GenericProgressiveFutureListener < ProgressiveFuture < V > > ) listeners ; execute ( executor , new OneTimeTask ( ) { @Override public void run ( ) { notifyProgressiveListener0 ( self , l , progress , total ) ; } } ) ; } } } private static void notifyProgressiveListeners0 ( ProgressiveFuture < ? > future , GenericProgressiveFutureListener < ? > [ ] listeners , long progress , long total ) { for ( GenericProgressiveFutureListener < ? > l : listeners ) { if ( l = = null ) { break ; } notifyProgressiveListener0 ( future , l , progress , total ) ; } } @SuppressWarnings ( { <str> , <str> } ) private static void notifyProgressiveListener0 ( ProgressiveFuture future , GenericProgressiveFutureListener l , long progress , long total ) { try { l . operationProgressed ( future , progress , total ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> + l . getClass ( ) . getName ( ) + <str> , t ) ; } } } private static final class CauseHolder { final Throwable cause ; CauseHolder ( Throwable cause ) { this . cause = cause ; } } @Override public String toString ( ) { return toStringBuilder ( ) . toString ( ) ; } protected StringBuilder toStringBuilder ( ) { StringBuilder buf = new StringBuilder ( <int> ) . append ( StringUtil . simpleClassName ( this ) ) . append ( <str> ) . append ( Integer . toHexString ( hashCode ( ) ) ) ; Object result = this . result ; if ( result = = SUCCESS ) { buf . append ( <str> ) ; } else if ( result = = UNCANCELLABLE ) { buf . append ( <str> ) ; } else if ( result instanceof CauseHolder ) { buf . append ( <str> ) . append ( ( ( CauseHolder ) result ) . cause ) . append ( <str> ) ; } else if ( result ! = null ) { buf . append ( <str> ) . append ( result ) . append ( <str> ) ; } else { buf . append ( <str> ) ; } return buf ; } private final class LateListeners extends ArrayDeque < GenericFutureListener < ? > > implements Runnable { private static final long serialVersionUID = - <int> ; LateListeners ( ) { super ( <int> ) ; } @Override public void run ( ) { final EventExecutor executor = executor ( ) ; if ( listeners = = null | | executor = = ImmediateEventExecutor . INSTANCE ) { for ( ; ; ) { GenericFutureListener < ? > l = poll ( ) ; if ( l = = null ) { break ; } notifyListener0 ( DefaultPromise . this , l ) ; } } else { execute ( executor , this ) ; } } } private final class LateListenerNotifier implements Runnable { private GenericFutureListener < ? > l ; LateListenerNotifier ( GenericFutureListener < ? > l ) { this . l = l ; } @Override public void run ( ) { LateListeners lateListeners = DefaultPromise . this . lateListeners ; if ( l ! = null ) { if ( lateListeners = = null ) { DefaultPromise . this . lateListeners = lateListeners = new LateListeners ( ) ; } lateListeners . add ( l ) ; l = null ; } lateListeners . run ( ) ; } } } 
