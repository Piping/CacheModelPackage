package io . netty . buffer ; import org . junit . Test ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . ScatteringByteChannel ; import static io . netty . buffer . Unpooled . * ; import static org . easymock . EasyMock . * ; import static org . junit . Assert . * ; public class ReadOnlyByteBufTest { @Test ( expected = NullPointerException . class ) public void shouldNotAllowNullInConstructor ( ) { new ReadOnlyByteBuf ( null ) ; } @Test public void testUnmodifiableBuffer ( ) { assertTrue ( unmodifiableBuffer ( buffer ( <int> ) ) instanceof ReadOnlyByteBuf ) ; } @Test public void testUnwrap ( ) { ByteBuf buf = buffer ( <int> ) ; assertSame ( buf , unmodifiableBuffer ( buf ) . unwrap ( ) ) ; } @Test public void shouldHaveSameByteOrder ( ) { ByteBuf buf = buffer ( <int> ) ; assertSame ( BIG_ENDIAN , unmodifiableBuffer ( buf ) . order ( ) ) ; buf = buf . order ( LITTLE_ENDIAN ) ; assertSame ( LITTLE_ENDIAN , unmodifiableBuffer ( buf ) . order ( ) ) ; } @Test public void shouldReturnReadOnlyDerivedBuffer ( ) { ByteBuf buf = unmodifiableBuffer ( buffer ( <int> ) ) ; assertTrue ( buf . duplicate ( ) instanceof ReadOnlyByteBuf ) ; assertTrue ( buf . slice ( ) instanceof ReadOnlyByteBuf ) ; assertTrue ( buf . slice ( <int> , <int> ) instanceof ReadOnlyByteBuf ) ; assertTrue ( buf . duplicate ( ) instanceof ReadOnlyByteBuf ) ; } @Test public void shouldReturnWritableCopy ( ) { ByteBuf buf = unmodifiableBuffer ( buffer ( <int> ) ) ; assertFalse ( buf . copy ( ) instanceof ReadOnlyByteBuf ) ; } @Test public void shouldForwardReadCallsBlindly ( ) throws Exception { ByteBuf buf = createStrictMock ( ByteBuf . class ) ; expect ( buf . order ( ) ) . andReturn ( BIG_ENDIAN ) . anyTimes ( ) ; expect ( buf . maxCapacity ( ) ) . andReturn ( <int> ) . anyTimes ( ) ; expect ( buf . readerIndex ( ) ) . andReturn ( <int> ) . anyTimes ( ) ; expect ( buf . writerIndex ( ) ) . andReturn ( <int> ) . anyTimes ( ) ; expect ( buf . capacity ( ) ) . andReturn ( <int> ) . anyTimes ( ) ; expect ( buf . getBytes ( <int> , ( GatheringByteChannel ) null , <int> ) ) . andReturn ( <int> ) ; expect ( buf . getBytes ( <int> , ( OutputStream ) null , <int> ) ) . andReturn ( buf ) ; expect ( buf . getBytes ( <int> , ( byte [ ] ) null , <int> , <int> ) ) . andReturn ( buf ) ; expect ( buf . getBytes ( <int> , ( ByteBuf ) null , <int> , <int> ) ) . andReturn ( buf ) ; expect ( buf . getBytes ( <int> , ( ByteBuffer ) null ) ) . andReturn ( buf ) ; expect ( buf . getByte ( <int> ) ) . andReturn ( Byte . valueOf ( ( byte ) <int> ) ) ; expect ( buf . getShort ( <int> ) ) . andReturn ( Short . valueOf ( ( short ) <int> ) ) ; expect ( buf . getUnsignedMedium ( <int> ) ) . andReturn ( <int> ) ; expect ( buf . getInt ( <int> ) ) . andReturn ( <int> ) ; expect ( buf . getLong ( <int> ) ) . andReturn ( <int> ) ; ByteBuffer bb = ByteBuffer . allocate ( <int> ) ; expect ( buf . nioBuffer ( <int> , <int> ) ) . andReturn ( bb ) ; expect ( buf . capacity ( ) ) . andReturn ( <int> ) ; replay ( buf ) ; ByteBuf roBuf = unmodifiableBuffer ( buf ) ; assertEquals ( <int> , roBuf . getBytes ( <int> , ( GatheringByteChannel ) null , <int> ) ) ; roBuf . getBytes ( <int> , ( OutputStream ) null , <int> ) ; roBuf . getBytes ( <int> , ( byte [ ] ) null , <int> , <int> ) ; roBuf . getBytes ( <int> , ( ByteBuf ) null , <int> , <int> ) ; roBuf . getBytes ( <int> , ( ByteBuffer ) null ) ; assertEquals ( ( byte ) <int> , roBuf . getByte ( <int> ) ) ; assertEquals ( ( short ) <int> , roBuf . getShort ( <int> ) ) ; assertEquals ( <int> , roBuf . getUnsignedMedium ( <int> ) ) ; assertEquals ( <int> , roBuf . getInt ( <int> ) ) ; assertEquals ( <int> , roBuf . getLong ( <int> ) ) ; ByteBuffer roBB = roBuf . nioBuffer ( <int> , <int> ) ; assertEquals ( <int> , roBB . capacity ( ) ) ; assertTrue ( roBB . isReadOnly ( ) ) ; assertEquals ( <int> , roBuf . capacity ( ) ) ; verify ( buf ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectDiscardReadBytes ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . discardReadBytes ( ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetByte ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setByte ( <int> , ( byte ) <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetShort ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setShort ( <int> , ( short ) <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetMedium ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setMedium ( <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetInt ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setInt ( <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetLong ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setLong ( <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetBytes1 ( ) throws IOException { unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( <int> , ( InputStream ) null , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetBytes2 ( ) throws IOException { unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( <int> , ( ScatteringByteChannel ) null , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetBytes3 ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( <int> , ( byte [ ] ) null , <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetBytes4 ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( <int> , ( ByteBuf ) null , <int> , <int> ) ; } @Test ( expected = UnsupportedOperationException . class ) public void shouldRejectSetBytes5 ( ) { unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( <int> , ( ByteBuffer ) null ) ; } public void shouldIndicateNotWriteable ( ) { assertFalse ( unmodifiableBuffer ( buffer ( <int> ) ) . isWritable ( ) ) ; } public void shouldIndicteNotWritableAnyNumber ( ) { assertFalse ( unmodifiableBuffer ( buffer ( <int> ) ) . isWritable ( <int> ) ) ; } } 
