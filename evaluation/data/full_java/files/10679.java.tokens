package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . Callables . returning ; import static com . google . common . util . concurrent . TestPlatform . verifyThreadWasNotInterrupted ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import junit . framework . TestCase ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; @GwtCompatible ( emulated = true ) public class TrustedListenableFutureTaskTest extends TestCase { public void testSuccessful ( ) throws Exception { TrustedListenableFutureTask < Integer > task = TrustedListenableFutureTask . create ( returning ( <int> ) ) ; assertFalse ( task . isDone ( ) ) ; task . run ( ) ; assertTrue ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; assertEquals ( <int> , task . get ( ) . intValue ( ) ) ; } public void testCancelled ( ) throws Exception { TrustedListenableFutureTask < Integer > task = TrustedListenableFutureTask . create ( returning ( <int> ) ) ; assertFalse ( task . isDone ( ) ) ; task . cancel ( false ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertFalse ( task . wasInterrupted ( ) ) ; try { task . get ( ) ; fail ( ) ; } catch ( CancellationException expected ) { } verifyThreadWasNotInterrupted ( ) ; } public void testFailed ( ) throws Exception { final Exception e = new Exception ( ) ; TrustedListenableFutureTask < Integer > task = TrustedListenableFutureTask . create ( new Callable < Integer > ( ) { @Override public Integer call ( ) throws Exception { throw e ; } } ) ; task . run ( ) ; assertTrue ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; try { task . get ( ) ; fail ( ) ; } catch ( ExecutionException executionException ) { assertEquals ( e , executionException . getCause ( ) ) ; } } @GwtIncompatible ( <str> ) public void testCancel_interrupted ( ) throws Exception { final AtomicBoolean interruptedExceptionThrown = new AtomicBoolean ( ) ; final CountDownLatch enterLatch = new CountDownLatch ( <int> ) ; final CountDownLatch exitLatch = new CountDownLatch ( <int> ) ; final TrustedListenableFutureTask < Integer > task = TrustedListenableFutureTask . create ( new Callable < Integer > ( ) { @Override public Integer call ( ) throws Exception { enterLatch . countDown ( ) ; try { new CountDownLatch ( <int> ) . await ( ) ; throw new AssertionError ( ) ; } catch ( InterruptedException e ) { interruptedExceptionThrown . set ( true ) ; throw e ; } finally { } } } ) ; assertFalse ( task . isDone ( ) ) ; Thread thread = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { task . run ( ) ; } finally { exitLatch . countDown ( ) ; } } } ) ; thread . start ( ) ; enterLatch . await ( ) ; assertFalse ( task . isDone ( ) ) ; task . cancel ( true ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertTrue ( task . wasInterrupted ( ) ) ; try { task . get ( ) ; fail ( ) ; } catch ( CancellationException expected ) { } exitLatch . await ( ) ; assertTrue ( interruptedExceptionThrown . get ( ) ) ; } @GwtIncompatible ( <str> ) public void testRunIdempotency ( ) throws Exception { final int numThreads = <int> ; final ExecutorService executor = Executors . newFixedThreadPool ( numThreads ) ; for ( int i = <int> ; i < <int> ; i + + ) { final AtomicInteger counter = new AtomicInteger ( ) ; final TrustedListenableFutureTask < Integer > task = TrustedListenableFutureTask . create ( new Callable < Integer > ( ) { @Override public Integer call ( ) { return counter . incrementAndGet ( ) ; } } ) ; final CyclicBarrier barrier = new CyclicBarrier ( numThreads + <int> ) ; Runnable wrapper = new Runnable ( ) { @Override public void run ( ) { awaitUnchecked ( barrier ) ; task . run ( ) ; awaitUnchecked ( barrier ) ; } } ; for ( int j = <int> ; j < <int> ; j + + ) { executor . execute ( wrapper ) ; } barrier . await ( ) ; barrier . await ( ) ; assertEquals ( <int> , task . get ( ) . intValue ( ) ) ; assertEquals ( <int> , counter . get ( ) ) ; } executor . shutdown ( ) ; } @GwtIncompatible ( <str> ) private int awaitUnchecked ( CyclicBarrier barrier ) { try { return barrier . await ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } 
