package io . netty . channel ; import io . netty . buffer . ByteBufAllocator ; import io . netty . util . DefaultAttributeMap ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . net . ConnectException ; import java . net . InetSocketAddress ; import java . net . NoRouteToHostException ; import java . net . SocketAddress ; import java . net . SocketException ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . NotYetConnectedException ; import java . util . concurrent . Executor ; import java . util . concurrent . RejectedExecutionException ; public abstract class AbstractChannel extends DefaultAttributeMap implements Channel { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractChannel . class ) ; static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException ( ) ; static final NotYetConnectedException NOT_YET_CONNECTED_EXCEPTION = new NotYetConnectedException ( ) ; static { CLOSED_CHANNEL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; NOT_YET_CONNECTED_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private MessageSizeEstimator . Handle estimatorHandle ; private final Channel parent ; private final ChannelId id ; private final Unsafe unsafe ; private final ChannelPipeline pipeline ; private final ChannelFuture succeededFuture = new SucceededChannelFuture ( this , null ) ; private final VoidChannelPromise voidPromise = new VoidChannelPromise ( this , true ) ; private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise ( this , false ) ; private final CloseFuture closeFuture = new CloseFuture ( this ) ; private volatile SocketAddress localAddress ; private volatile SocketAddress remoteAddress ; private volatile EventLoop eventLoop ; private volatile boolean registered ; private boolean strValActive ; private String strVal ; protected AbstractChannel ( Channel parent ) { this . parent = parent ; id = DefaultChannelId . newInstance ( ) ; unsafe = newUnsafe ( ) ; pipeline = new DefaultChannelPipeline ( this ) ; } protected AbstractChannel ( Channel parent , ChannelId id ) { this . parent = parent ; this . id = id ; unsafe = newUnsafe ( ) ; pipeline = new DefaultChannelPipeline ( this ) ; } @Override public final ChannelId id ( ) { return id ; } @Override public boolean isWritable ( ) { ChannelOutboundBuffer buf = unsafe . outboundBuffer ( ) ; return buf ! = null & & buf . isWritable ( ) ; } @Override public long bytesBeforeUnwritable ( ) { ChannelOutboundBuffer buf = unsafe . outboundBuffer ( ) ; return buf ! = null ? buf . bytesBeforeUnwritable ( ) : <int> ; } @Override public long bytesBeforeWritable ( ) { ChannelOutboundBuffer buf = unsafe . outboundBuffer ( ) ; return buf ! = null ? buf . bytesBeforeWritable ( ) : Long . MAX_VALUE ; } @Override public Channel parent ( ) { return parent ; } @Override public ChannelPipeline pipeline ( ) { return pipeline ; } @Override public ByteBufAllocator alloc ( ) { return config ( ) . getAllocator ( ) ; } @Override public EventLoop eventLoop ( ) { EventLoop eventLoop = this . eventLoop ; if ( eventLoop = = null ) { throw new IllegalStateException ( <str> ) ; } return eventLoop ; } @Override public SocketAddress localAddress ( ) { SocketAddress localAddress = this . localAddress ; if ( localAddress = = null ) { try { this . localAddress = localAddress = unsafe ( ) . localAddress ( ) ; } catch ( Throwable t ) { return null ; } } return localAddress ; } protected void invalidateLocalAddress ( ) { localAddress = null ; } @Override public SocketAddress remoteAddress ( ) { SocketAddress remoteAddress = this . remoteAddress ; if ( remoteAddress = = null ) { try { this . remoteAddress = remoteAddress = unsafe ( ) . remoteAddress ( ) ; } catch ( Throwable t ) { return null ; } } return remoteAddress ; } protected void invalidateRemoteAddress ( ) { remoteAddress = null ; } @Override public boolean isRegistered ( ) { return registered ; } @Override public ChannelFuture bind ( SocketAddress localAddress ) { return pipeline . bind ( localAddress ) ; } @Override public ChannelFuture connect ( SocketAddress remoteAddress ) { return pipeline . connect ( remoteAddress ) ; } @Override public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) { return pipeline . connect ( remoteAddress , localAddress ) ; } @Override public ChannelFuture disconnect ( ) { return pipeline . disconnect ( ) ; } @Override public ChannelFuture close ( ) { return pipeline . close ( ) ; } @Override public ChannelFuture deregister ( ) { return pipeline . deregister ( ) ; } @Override public Channel flush ( ) { pipeline . flush ( ) ; return this ; } @Override public ChannelFuture bind ( SocketAddress localAddress , ChannelPromise promise ) { return pipeline . bind ( localAddress , promise ) ; } @Override public ChannelFuture connect ( SocketAddress remoteAddress , ChannelPromise promise ) { return pipeline . connect ( remoteAddress , promise ) ; } @Override public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) { return pipeline . connect ( remoteAddress , localAddress , promise ) ; } @Override public ChannelFuture disconnect ( ChannelPromise promise ) { return pipeline . disconnect ( promise ) ; } @Override public ChannelFuture close ( ChannelPromise promise ) { return pipeline . close ( promise ) ; } @Override public ChannelFuture deregister ( ChannelPromise promise ) { return pipeline . deregister ( promise ) ; } @Override public Channel read ( ) { pipeline . read ( ) ; return this ; } @Override public ChannelFuture write ( Object msg ) { return pipeline . write ( msg ) ; } @Override public ChannelFuture write ( Object msg , ChannelPromise promise ) { return pipeline . write ( msg , promise ) ; } @Override public ChannelFuture writeAndFlush ( Object msg ) { return pipeline . writeAndFlush ( msg ) ; } @Override public ChannelFuture writeAndFlush ( Object msg , ChannelPromise promise ) { return pipeline . writeAndFlush ( msg , promise ) ; } @Override public ChannelPromise newPromise ( ) { return new DefaultChannelPromise ( this ) ; } @Override public ChannelProgressivePromise newProgressivePromise ( ) { return new DefaultChannelProgressivePromise ( this ) ; } @Override public ChannelFuture newSucceededFuture ( ) { return succeededFuture ; } @Override public ChannelFuture newFailedFuture ( Throwable cause ) { return new FailedChannelFuture ( this , null , cause ) ; } @Override public ChannelFuture closeFuture ( ) { return closeFuture ; } @Override public Unsafe unsafe ( ) { return unsafe ; } protected abstract AbstractUnsafe newUnsafe ( ) ; @Override public final int hashCode ( ) { return id . hashCode ( ) ; } @Override public final boolean equals ( Object o ) { return this = = o ; } @Override public final int compareTo ( Channel o ) { if ( this = = o ) { return <int> ; } return id ( ) . compareTo ( o . id ( ) ) ; } @Override public String toString ( ) { boolean active = isActive ( ) ; if ( strValActive = = active & & strVal ! = null ) { return strVal ; } SocketAddress remoteAddr = remoteAddress ( ) ; SocketAddress localAddr = localAddress ( ) ; if ( remoteAddr ! = null ) { SocketAddress srcAddr ; SocketAddress dstAddr ; if ( parent = = null ) { srcAddr = localAddr ; dstAddr = remoteAddr ; } else { srcAddr = remoteAddr ; dstAddr = localAddr ; } StringBuilder buf = new StringBuilder ( <int> ) . append ( <str> ) . append ( id . asShortText ( ) ) . append ( <str> ) . append ( srcAddr ) . append ( active ? <str> : <str> ) . append ( dstAddr ) . append ( <str> ) ; strVal = buf . toString ( ) ; } else if ( localAddr ! = null ) { StringBuilder buf = new StringBuilder ( <int> ) . append ( <str> ) . append ( id . asShortText ( ) ) . append ( <str> ) . append ( localAddr ) . append ( <str> ) ; strVal = buf . toString ( ) ; } else { StringBuilder buf = new StringBuilder ( <int> ) . append ( <str> ) . append ( id . asShortText ( ) ) . append ( <str> ) ; strVal = buf . toString ( ) ; } strValActive = active ; return strVal ; } @Override public final ChannelPromise voidPromise ( ) { return voidPromise ; } final MessageSizeEstimator . Handle estimatorHandle ( ) { if ( estimatorHandle = = null ) { estimatorHandle = config ( ) . getMessageSizeEstimator ( ) . newHandle ( ) ; } return estimatorHandle ; } protected abstract class AbstractUnsafe implements Unsafe { private ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer ( AbstractChannel . this ) ; private RecvByteBufAllocator . Handle recvHandle ; private boolean inFlush0 ; private boolean neverRegistered = true ; @Override public RecvByteBufAllocator . Handle recvBufAllocHandle ( ) { if ( recvHandle = = null ) { recvHandle = config ( ) . getRecvByteBufAllocator ( ) . newHandle ( ) ; } return recvHandle ; } @Override public final ChannelHandlerInvoker invoker ( ) { return eventLoop ( ) . asInvoker ( ) ; } @Override public final ChannelOutboundBuffer outboundBuffer ( ) { return outboundBuffer ; } @Override public final SocketAddress localAddress ( ) { return localAddress0 ( ) ; } @Override public final SocketAddress remoteAddress ( ) { return remoteAddress0 ( ) ; } @Override public final void register ( EventLoop eventLoop , final ChannelPromise promise ) { if ( eventLoop = = null ) { throw new NullPointerException ( <str> ) ; } if ( isRegistered ( ) ) { promise . setFailure ( new IllegalStateException ( <str> ) ) ; return ; } if ( ! isCompatible ( eventLoop ) ) { promise . setFailure ( new IllegalStateException ( <str> + eventLoop . getClass ( ) . getName ( ) ) ) ; return ; } AbstractChannel . this . eventLoop = eventLoop ; if ( eventLoop . inEventLoop ( ) ) { register0 ( promise ) ; } else { try { eventLoop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { register0 ( promise ) ; } } ) ; } catch ( Throwable t ) { logger . warn ( <str> , AbstractChannel . this , t ) ; closeForcibly ( ) ; closeFuture . setClosed ( ) ; safeSetFailure ( promise , t ) ; } } } private void register0 ( ChannelPromise promise ) { try { if ( ! promise . setUncancellable ( ) | | ! ensureOpen ( promise ) ) { return ; } boolean firstRegistration = neverRegistered ; doRegister ( ) ; neverRegistered = false ; registered = true ; safeSetSuccess ( promise ) ; pipeline . fireChannelRegistered ( ) ; if ( firstRegistration & & isActive ( ) ) { pipeline . fireChannelActive ( ) ; } } catch ( Throwable t ) { closeForcibly ( ) ; closeFuture . setClosed ( ) ; safeSetFailure ( promise , t ) ; } } @Override public final void bind ( final SocketAddress localAddress , final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) | | ! ensureOpen ( promise ) ) { return ; } if ( Boolean . TRUE . equals ( config ( ) . getOption ( ChannelOption . SO_BROADCAST ) ) & & localAddress instanceof InetSocketAddress & & ! ( ( InetSocketAddress ) localAddress ) . getAddress ( ) . isAnyLocalAddress ( ) & & ! PlatformDependent . isWindows ( ) & & ! PlatformDependent . isRoot ( ) ) { logger . warn ( <str> + <str> + <str> + localAddress + <str> ) ; } boolean wasActive = isActive ( ) ; try { doBind ( localAddress ) ; } catch ( Throwable t ) { safeSetFailure ( promise , t ) ; closeIfClosed ( ) ; return ; } if ( ! wasActive & & isActive ( ) ) { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { pipeline . fireChannelActive ( ) ; } } ) ; } safeSetSuccess ( promise ) ; } @Override public final void disconnect ( final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) ) { return ; } boolean wasActive = isActive ( ) ; try { doDisconnect ( ) ; } catch ( Throwable t ) { safeSetFailure ( promise , t ) ; closeIfClosed ( ) ; return ; } if ( wasActive & & ! isActive ( ) ) { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { pipeline . fireChannelInactive ( ) ; } } ) ; } safeSetSuccess ( promise ) ; closeIfClosed ( ) ; } @Override public final void close ( final ChannelPromise promise ) { close ( promise , CLOSED_CHANNEL_EXCEPTION , false ) ; } private void close ( final ChannelPromise promise , final Throwable cause , final boolean notify ) { if ( ! promise . setUncancellable ( ) ) { return ; } final ChannelOutboundBuffer outboundBuffer = this . outboundBuffer ; if ( outboundBuffer = = null ) { if ( ! ( promise instanceof VoidChannelPromise ) ) { closeFuture . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { promise . setSuccess ( ) ; } } ) ; } return ; } if ( closeFuture . isDone ( ) ) { safeSetSuccess ( promise ) ; return ; } final boolean wasActive = isActive ( ) ; this . outboundBuffer = null ; Executor closeExecutor = closeExecutor ( ) ; if ( closeExecutor ! = null ) { closeExecutor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { try { doClose0 ( promise ) ; } finally { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { outboundBuffer . failFlushed ( cause , notify ) ; outboundBuffer . close ( CLOSED_CHANNEL_EXCEPTION ) ; fireChannelInactiveAndDeregister ( wasActive ) ; } } ) ; } } } ) ; } else { try { doClose0 ( promise ) ; } finally { outboundBuffer . failFlushed ( cause , notify ) ; outboundBuffer . close ( CLOSED_CHANNEL_EXCEPTION ) ; } if ( inFlush0 ) { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { fireChannelInactiveAndDeregister ( wasActive ) ; } } ) ; } else { fireChannelInactiveAndDeregister ( wasActive ) ; } } } private void doClose0 ( ChannelPromise promise ) { try { doClose ( ) ; closeFuture . setClosed ( ) ; safeSetSuccess ( promise ) ; } catch ( Throwable t ) { closeFuture . setClosed ( ) ; safeSetFailure ( promise , t ) ; } } private void fireChannelInactiveAndDeregister ( final boolean wasActive ) { if ( wasActive & & ! isActive ( ) ) { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { pipeline . fireChannelInactive ( ) ; } } ) ; } deregister ( voidPromise ( ) ) ; } @Override public final void closeForcibly ( ) { try { doClose ( ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } @Override public final void deregister ( final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) ) { return ; } if ( ! registered ) { safeSetSuccess ( promise ) ; return ; } try { doDeregister ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } finally { if ( registered ) { registered = false ; invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { pipeline . fireChannelUnregistered ( ) ; } } ) ; safeSetSuccess ( promise ) ; } else { safeSetSuccess ( promise ) ; } } } @Override public final void beginRead ( ) { if ( ! isActive ( ) ) { return ; } try { doBeginRead ( ) ; } catch ( final Exception e ) { invokeLater ( new OneTimeTask ( ) { @Override public void run ( ) { pipeline . fireExceptionCaught ( e ) ; } } ) ; close ( voidPromise ( ) ) ; } } @Override public final void write ( Object msg , ChannelPromise promise ) { ChannelOutboundBuffer outboundBuffer = this . outboundBuffer ; if ( outboundBuffer = = null ) { safeSetFailure ( promise , CLOSED_CHANNEL_EXCEPTION ) ; ReferenceCountUtil . release ( msg ) ; return ; } int size ; try { msg = filterOutboundMessage ( msg ) ; size = estimatorHandle ( ) . size ( msg ) ; if ( size < <int> ) { size = <int> ; } } catch ( Throwable t ) { safeSetFailure ( promise , t ) ; ReferenceCountUtil . release ( msg ) ; return ; } outboundBuffer . addMessage ( msg , size , promise ) ; } @Override public final void flush ( ) { ChannelOutboundBuffer outboundBuffer = this . outboundBuffer ; if ( outboundBuffer = = null ) { return ; } outboundBuffer . addFlush ( ) ; flush0 ( ) ; } @SuppressWarnings ( <str> ) protected void flush0 ( ) { if ( inFlush0 ) { return ; } final ChannelOutboundBuffer outboundBuffer = this . outboundBuffer ; if ( outboundBuffer = = null | | outboundBuffer . isEmpty ( ) ) { return ; } inFlush0 = true ; if ( ! isActive ( ) ) { try { if ( isOpen ( ) ) { outboundBuffer . failFlushed ( NOT_YET_CONNECTED_EXCEPTION , true ) ; } else { outboundBuffer . failFlushed ( CLOSED_CHANNEL_EXCEPTION , false ) ; } } finally { inFlush0 = false ; } return ; } try { doWrite ( outboundBuffer ) ; } catch ( Throwable t ) { if ( t instanceof IOException & & config ( ) . isAutoClose ( ) ) { close ( voidPromise ( ) , t , false ) ; } else { outboundBuffer . failFlushed ( t , true ) ; } } finally { inFlush0 = false ; } } @Override public final ChannelPromise voidPromise ( ) { return unsafeVoidPromise ; } protected final boolean ensureOpen ( ChannelPromise promise ) { if ( isOpen ( ) ) { return true ; } safeSetFailure ( promise , CLOSED_CHANNEL_EXCEPTION ) ; return false ; } protected final void safeSetSuccess ( ChannelPromise promise ) { if ( ! ( promise instanceof VoidChannelPromise ) & & ! promise . trySuccess ( ) ) { logger . warn ( <str> , promise ) ; } } protected final void safeSetFailure ( ChannelPromise promise , Throwable cause ) { if ( ! ( promise instanceof VoidChannelPromise ) & & ! promise . tryFailure ( cause ) ) { logger . warn ( <str> , promise , cause ) ; } } protected final void closeIfClosed ( ) { if ( isOpen ( ) ) { return ; } close ( voidPromise ( ) ) ; } private void invokeLater ( Runnable task ) { try { eventLoop ( ) . execute ( task ) ; } catch ( RejectedExecutionException e ) { logger . warn ( <str> , e ) ; } } protected final Throwable annotateConnectException ( Throwable cause , SocketAddress remoteAddress ) { if ( cause instanceof ConnectException ) { Throwable newT = new ConnectException ( cause . getMessage ( ) + <str> + remoteAddress ) ; newT . setStackTrace ( cause . getStackTrace ( ) ) ; cause = newT ; } else if ( cause instanceof NoRouteToHostException ) { Throwable newT = new NoRouteToHostException ( cause . getMessage ( ) + <str> + remoteAddress ) ; newT . setStackTrace ( cause . getStackTrace ( ) ) ; cause = newT ; } else if ( cause instanceof SocketException ) { Throwable newT = new SocketException ( cause . getMessage ( ) + <str> + remoteAddress ) ; newT . setStackTrace ( cause . getStackTrace ( ) ) ; cause = newT ; } return cause ; } protected Executor closeExecutor ( ) { return null ; } } protected abstract boolean isCompatible ( EventLoop loop ) ; protected abstract SocketAddress localAddress0 ( ) ; protected abstract SocketAddress remoteAddress0 ( ) ; protected void doRegister ( ) throws Exception { } protected abstract void doBind ( SocketAddress localAddress ) throws Exception ; protected abstract void doDisconnect ( ) throws Exception ; protected abstract void doClose ( ) throws Exception ; protected void doDeregister ( ) throws Exception { } protected abstract void doBeginRead ( ) throws Exception ; protected abstract void doWrite ( ChannelOutboundBuffer in ) throws Exception ; protected Object filterOutboundMessage ( Object msg ) throws Exception { return msg ; } static final class CloseFuture extends DefaultChannelPromise { CloseFuture ( AbstractChannel ch ) { super ( ch ) ; } @Override public ChannelPromise setSuccess ( ) { throw new IllegalStateException ( ) ; } @Override public ChannelPromise setFailure ( Throwable cause ) { throw new IllegalStateException ( ) ; } @Override public boolean trySuccess ( ) { throw new IllegalStateException ( ) ; } @Override public boolean tryFailure ( Throwable cause ) { throw new IllegalStateException ( ) ; } boolean setClosed ( ) { return super . trySuccess ( ) ; } } } 
