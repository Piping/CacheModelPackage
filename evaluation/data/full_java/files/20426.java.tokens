package io . netty . channel . epoll ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFactory ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . channel . socket . nio . NioDatagramChannel ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . channel . unix . DomainSocketAddress ; import io . netty . testsuite . transport . TestsuitePermutation ; import io . netty . testsuite . transport . TestsuitePermutation . BootstrapFactory ; import io . netty . testsuite . transport . socket . SocketTestPermutation ; import io . netty . util . concurrent . DefaultThreadFactory ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; class EpollSocketTestPermutation extends SocketTestPermutation { static final EpollSocketTestPermutation INSTANCE = new EpollSocketTestPermutation ( ) ; static final EventLoopGroup EPOLL_BOSS_GROUP = new EpollEventLoopGroup ( BOSSES , new DefaultThreadFactory ( <str> , true ) ) ; static final EventLoopGroup EPOLL_WORKER_GROUP = new EpollEventLoopGroup ( WORKERS , new DefaultThreadFactory ( <str> , true ) ) ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( EpollSocketTestPermutation . class ) ; @Override public List < TestsuitePermutation . BootstrapComboFactory < ServerBootstrap , Bootstrap > > socket ( ) { List < TestsuitePermutation . BootstrapComboFactory < ServerBootstrap , Bootstrap > > list = combo ( serverSocket ( ) , clientSocket ( ) ) ; list . remove ( list . size ( ) - <int> ) ; return list ; } @SuppressWarnings ( <str> ) @Override public List < BootstrapFactory < ServerBootstrap > > serverSocket ( ) { List < BootstrapFactory < ServerBootstrap > > toReturn = new ArrayList < BootstrapFactory < ServerBootstrap > > ( ) ; toReturn . add ( new BootstrapFactory < ServerBootstrap > ( ) { @Override public ServerBootstrap newInstance ( ) { return new ServerBootstrap ( ) . group ( EPOLL_BOSS_GROUP , EPOLL_WORKER_GROUP ) . channel ( EpollServerSocketChannel . class ) ; } } ) ; if ( isServerFastOpen ( ) ) { toReturn . add ( new BootstrapFactory < ServerBootstrap > ( ) { @Override public ServerBootstrap newInstance ( ) { ServerBootstrap serverBootstrap = new ServerBootstrap ( ) . group ( EPOLL_BOSS_GROUP , EPOLL_WORKER_GROUP ) . channel ( EpollServerSocketChannel . class ) ; serverBootstrap . option ( EpollChannelOption . TCP_FASTOPEN , <int> ) ; return serverBootstrap ; } } ) ; } toReturn . add ( new BootstrapFactory < ServerBootstrap > ( ) { @Override public ServerBootstrap newInstance ( ) { return new ServerBootstrap ( ) . group ( nioBossGroup , nioWorkerGroup ) . channel ( NioServerSocketChannel . class ) ; } } ) ; return toReturn ; } @SuppressWarnings ( <str> ) @Override public List < BootstrapFactory < Bootstrap > > clientSocket ( ) { return Arrays . asList ( new BootstrapFactory < Bootstrap > ( ) { @Override public Bootstrap newInstance ( ) { return new Bootstrap ( ) . group ( EPOLL_WORKER_GROUP ) . channel ( EpollSocketChannel . class ) ; } } , new BootstrapFactory < Bootstrap > ( ) { @Override public Bootstrap newInstance ( ) { return new Bootstrap ( ) . group ( nioWorkerGroup ) . channel ( NioSocketChannel . class ) ; } } ) ; } @Override public List < TestsuitePermutation . BootstrapComboFactory < Bootstrap , Bootstrap > > datagram ( ) { @SuppressWarnings ( <str> ) List < BootstrapFactory < Bootstrap > > bfs = Arrays . asList ( new BootstrapFactory < Bootstrap > ( ) { @Override public Bootstrap newInstance ( ) { return new Bootstrap ( ) . group ( nioWorkerGroup ) . channelFactory ( new ChannelFactory < Channel > ( ) { @Override public Channel newChannel ( ) { return new NioDatagramChannel ( InternetProtocolFamily . IPv4 ) ; } @Override public String toString ( ) { return NioDatagramChannel . class . getSimpleName ( ) + <str> ; } } ) ; } } , new BootstrapFactory < Bootstrap > ( ) { @Override public Bootstrap newInstance ( ) { return new Bootstrap ( ) . group ( EPOLL_WORKER_GROUP ) . channel ( EpollDatagramChannel . class ) ; } } ) ; return combo ( bfs , bfs ) ; } public List < TestsuitePermutation . BootstrapComboFactory < ServerBootstrap , Bootstrap > > domainSocket ( ) { List < TestsuitePermutation . BootstrapComboFactory < ServerBootstrap , Bootstrap > > list = combo ( serverDomainSocket ( ) , clientDomainSocket ( ) ) ; return list ; } public List < BootstrapFactory < ServerBootstrap > > serverDomainSocket ( ) { return Collections . < BootstrapFactory < ServerBootstrap > > singletonList ( new BootstrapFactory < ServerBootstrap > ( ) { @Override public ServerBootstrap newInstance ( ) { return new ServerBootstrap ( ) . group ( EPOLL_BOSS_GROUP , EPOLL_WORKER_GROUP ) . channel ( EpollServerDomainSocketChannel . class ) ; } } ) ; } public List < BootstrapFactory < Bootstrap > > clientDomainSocket ( ) { return Collections . < BootstrapFactory < Bootstrap > > singletonList ( new BootstrapFactory < Bootstrap > ( ) { @Override public Bootstrap newInstance ( ) { return new Bootstrap ( ) . group ( EPOLL_WORKER_GROUP ) . channel ( EpollDomainSocketChannel . class ) ; } } ) ; } public boolean isServerFastOpen ( ) { return AccessController . doPrivileged ( new PrivilegedAction < Integer > ( ) { @Override public Integer run ( ) { int fastopen = <int> ; File file = new File ( <str> ) ; if ( file . exists ( ) ) { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; fastopen = Integer . parseInt ( in . readLine ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , file , fastopen ) ; } } catch ( Exception e ) { logger . debug ( <str> , file , e ) ; } finally { if ( in ! = null ) { try { in . close ( ) ; } catch ( Exception e ) { } } } } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , file , fastopen ) ; } } return fastopen ; } } ) = = <int> ; } public static DomainSocketAddress newSocketAddress ( ) { try { File file = File . createTempFile ( <str> , <str> ) ; file . delete ( ) ; return new DomainSocketAddress ( file ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } } 
