package org . elasticsearch . discovery . zen ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; public class ElectMasterServiceTests extends ESTestCase { ElectMasterService electMasterService ( ) { return new ElectMasterService ( Settings . EMPTY , Version . CURRENT ) ; } List < DiscoveryNode > generateRandomNodes ( ) { int count = scaledRandomIntBetween ( <int> , <int> ) ; ArrayList < DiscoveryNode > nodes = new ArrayList < > ( count ) ; Map < String , String > master = new HashMap < > ( ) ; master . put ( <str> , <str> ) ; Map < String , String > nonMaster = new HashMap < > ( ) ; nonMaster . put ( <str> , <str> ) ; for ( int i = <int> ; i < count ; i + + ) { Map < String , String > attributes = randomBoolean ( ) ? master : nonMaster ; DiscoveryNode node = new DiscoveryNode ( <str> + i , <str> + i , DummyTransportAddress . INSTANCE , attributes , Version . CURRENT ) ; nodes . add ( node ) ; } Collections . shuffle ( nodes , random ( ) ) ; return nodes ; } public void testSortByMasterLikelihood ( ) { List < DiscoveryNode > nodes = generateRandomNodes ( ) ; List < DiscoveryNode > sortedNodes = electMasterService ( ) . sortByMasterLikelihood ( nodes ) ; assertEquals ( nodes . size ( ) , sortedNodes . size ( ) ) ; DiscoveryNode prevNode = sortedNodes . get ( <int> ) ; for ( int i = <int> ; i < sortedNodes . size ( ) ; i + + ) { DiscoveryNode node = sortedNodes . get ( i ) ; if ( ! prevNode . masterNode ( ) ) { assertFalse ( node . masterNode ( ) ) ; } else if ( node . masterNode ( ) ) { assertTrue ( prevNode . id ( ) . compareTo ( node . id ( ) ) < <int> ) ; } prevNode = node ; } } public void testElectMaster ( ) { List < DiscoveryNode > nodes = generateRandomNodes ( ) ; ElectMasterService service = electMasterService ( ) ; int min_master_nodes = randomIntBetween ( <int> , nodes . size ( ) ) ; service . minimumMasterNodes ( min_master_nodes ) ; int master_nodes = <int> ; for ( DiscoveryNode node : nodes ) { if ( node . masterNode ( ) ) { master_nodes + + ; } } DiscoveryNode master = null ; if ( service . hasEnoughMasterNodes ( nodes ) ) { master = service . electMaster ( nodes ) ; } if ( master_nodes = = <int> ) { assertNull ( master ) ; } else if ( min_master_nodes > <int> & & master_nodes < min_master_nodes ) { assertNull ( master ) ; } else { for ( DiscoveryNode node : nodes ) { if ( node . masterNode ( ) ) { assertTrue ( master . id ( ) . compareTo ( node . id ( ) ) < = <int> ) ; } } } } } 
