package org . elasticsearch ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . rest . RestStatus ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public final class ExceptionsHelper { private static final ESLogger logger = Loggers . getLogger ( ExceptionsHelper . class ) ; public static RuntimeException convertToRuntime ( Throwable t ) { if ( t instanceof RuntimeException ) { return ( RuntimeException ) t ; } return new ElasticsearchException ( t ) ; } public static ElasticsearchException convertToElastic ( Throwable t ) { if ( t instanceof ElasticsearchException ) { return ( ElasticsearchException ) t ; } return new ElasticsearchException ( t ) ; } public static RestStatus status ( Throwable t ) { if ( t ! = null ) { if ( t instanceof ElasticsearchException ) { return ( ( ElasticsearchException ) t ) . status ( ) ; } else if ( t instanceof IllegalArgumentException ) { return RestStatus . BAD_REQUEST ; } } return RestStatus . INTERNAL_SERVER_ERROR ; } public static Throwable unwrapCause ( Throwable t ) { int counter = <int> ; Throwable result = t ; while ( result instanceof ElasticsearchWrapperException ) { if ( result . getCause ( ) = = null ) { return result ; } if ( result . getCause ( ) = = result ) { return result ; } if ( counter + + > <int> ) { logger . warn ( <str> , t ) ; return result ; } result = result . getCause ( ) ; } return result ; } public static String detailedMessage ( Throwable t ) { return detailedMessage ( t , false , <int> ) ; } public static String detailedMessage ( Throwable t , boolean newLines , int initialCounter ) { if ( t = = null ) { return <str> ; } int counter = initialCounter + <int> ; if ( t . getCause ( ) ! = null ) { StringBuilder sb = new StringBuilder ( ) ; while ( t ! = null ) { sb . append ( t . getClass ( ) . getSimpleName ( ) ) ; if ( t . getMessage ( ) ! = null ) { sb . append ( <str> ) ; sb . append ( t . getMessage ( ) ) ; sb . append ( <str> ) ; } if ( ! newLines ) { sb . append ( <str> ) ; } t = t . getCause ( ) ; if ( t ! = null ) { if ( newLines ) { sb . append ( <str> ) ; for ( int i = <int> ; i < counter ; i + + ) { sb . append ( <str> ) ; } } else { sb . append ( <str> ) ; } } counter + + ; } return sb . toString ( ) ; } else { return t . getClass ( ) . getSimpleName ( ) + <str> + t . getMessage ( ) + <str> ; } } public static String stackTrace ( Throwable e ) { StringWriter stackTraceStringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stackTraceStringWriter ) ; e . printStackTrace ( printWriter ) ; return stackTraceStringWriter . toString ( ) ; } public static < T extends Throwable > void rethrowAndSuppress ( List < T > exceptions ) throws T { T main = null ; for ( T ex : exceptions ) { main = useOrSuppress ( main , ex ) ; } if ( main ! = null ) { throw main ; } } public static < T extends Throwable > void maybeThrowRuntimeAndSuppress ( List < T > exceptions ) { T main = null ; for ( T ex : exceptions ) { main = useOrSuppress ( main , ex ) ; } if ( main ! = null ) { throw new ElasticsearchException ( main ) ; } } public static < T extends Throwable > T useOrSuppress ( T first , T second ) { if ( first = = null ) { return second ; } else { first . addSuppressed ( second ) ; } return first ; } public static IOException unwrapCorruption ( Throwable t ) { return ( IOException ) unwrap ( t , CorruptIndexException . class , IndexFormatTooOldException . class , IndexFormatTooNewException . class ) ; } public static Throwable unwrap ( Throwable t , Class < ? > . . . clazzes ) { if ( t ! = null ) { do { for ( Class < ? > clazz : clazzes ) { if ( clazz . isInstance ( t ) ) { return t ; } } } while ( ( t = t . getCause ( ) ) ! = null ) ; } return null ; } public static boolean isOOM ( Throwable t ) { return t ! = null & & ( t instanceof OutOfMemoryError | | ( t instanceof IllegalStateException & & t . getMessage ( ) ! = null & & t . getMessage ( ) . contains ( <str> ) ) ) ; } public static boolean reThrowIfNotNull ( @Nullable Throwable e ) { if ( e ! = null ) { if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else { throw new RuntimeException ( e ) ; } } return true ; } public static ShardOperationFailedException [ ] groupBy ( ShardOperationFailedException [ ] failures ) { List < ShardOperationFailedException > uniqueFailures = new ArrayList < > ( ) ; Set < GroupBy > reasons = new HashSet < > ( ) ; for ( ShardOperationFailedException failure : failures ) { GroupBy reason = new GroupBy ( failure . getCause ( ) ) ; if ( reasons . contains ( reason ) = = false ) { reasons . add ( reason ) ; uniqueFailures . add ( failure ) ; } } return uniqueFailures . toArray ( new ShardOperationFailedException [ <int> ] ) ; } static class GroupBy { final String reason ; final String index ; final Class < ? extends Throwable > causeType ; public GroupBy ( Throwable t ) { if ( t instanceof ElasticsearchException ) { index = ( ( ElasticsearchException ) t ) . getIndex ( ) ; } else { index = null ; } reason = t . getMessage ( ) ; causeType = t . getClass ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; GroupBy groupBy = ( GroupBy ) o ; if ( ! causeType . equals ( groupBy . causeType ) ) return false ; if ( index ! = null ? ! index . equals ( groupBy . index ) : groupBy . index ! = null ) return false ; if ( reason ! = null ? ! reason . equals ( groupBy . reason ) : groupBy . reason ! = null ) return false ; return true ; } @Override public int hashCode ( ) { int result = reason ! = null ? reason . hashCode ( ) : <int> ; result = <int> * result + ( index ! = null ? index . hashCode ( ) : <int> ) ; result = <int> * result + causeType . hashCode ( ) ; return result ; } } } 
