package org . apache . cassandra . io . compress ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import com . google . common . annotations . VisibleForTesting ; import net . jpountz . lz4 . LZ4Exception ; import net . jpountz . lz4 . LZ4Factory ; import org . apache . cassandra . schema . CompressionParams ; public class LZ4Compressor implements ICompressor { private static final int INTEGER_BYTES = <int> ; @VisibleForTesting public static final LZ4Compressor instance = new LZ4Compressor ( ) ; public static LZ4Compressor create ( Map < String , String > args ) { return instance ; } private final net . jpountz . lz4 . LZ4Compressor compressor ; private final net . jpountz . lz4 . LZ4FastDecompressor decompressor ; private LZ4Compressor ( ) { final LZ4Factory lz4Factory = LZ4Factory . fastestInstance ( ) ; compressor = lz4Factory . fastCompressor ( ) ; decompressor = lz4Factory . fastDecompressor ( ) ; } public int initialCompressedBufferLength ( int chunkLength ) { return INTEGER_BYTES + compressor . maxCompressedLength ( chunkLength ) ; } public void compress ( ByteBuffer input , ByteBuffer output ) throws IOException { int len = input . remaining ( ) ; output . put ( ( byte ) len ) ; output . put ( ( byte ) ( len > > > <int> ) ) ; output . put ( ( byte ) ( len > > > <int> ) ) ; output . put ( ( byte ) ( len > > > <int> ) ) ; try { compressor . compress ( input , output ) ; } catch ( LZ4Exception e ) { throw new IOException ( e ) ; } } public int uncompress ( byte [ ] input , int inputOffset , int inputLength , byte [ ] output , int outputOffset ) throws IOException { final int decompressedLength = ( input [ inputOffset ] & <hex> ) | ( ( input [ inputOffset + <int> ] & <hex> ) < < <int> ) | ( ( input [ inputOffset + <int> ] & <hex> ) < < <int> ) | ( ( input [ inputOffset + <int> ] & <hex> ) < < <int> ) ; final int compressedLength ; try { compressedLength = decompressor . decompress ( input , inputOffset + INTEGER_BYTES , output , outputOffset , decompressedLength ) ; } catch ( LZ4Exception e ) { throw new IOException ( e ) ; } if ( compressedLength ! = inputLength - INTEGER_BYTES ) { throw new IOException ( <str> ) ; } return decompressedLength ; } public void uncompress ( ByteBuffer input , ByteBuffer output ) throws IOException { final int decompressedLength = ( input . get ( ) & <hex> ) | ( ( input . get ( ) & <hex> ) < < <int> ) | ( ( input . get ( ) & <hex> ) < < <int> ) | ( ( input . get ( ) & <hex> ) < < <int> ) ; try { int compressedLength = decompressor . decompress ( input , input . position ( ) , output , output . position ( ) , decompressedLength ) ; input . position ( input . position ( ) + compressedLength ) ; output . position ( output . position ( ) + decompressedLength ) ; } catch ( LZ4Exception e ) { throw new IOException ( e ) ; } if ( input . remaining ( ) > <int> ) { throw new IOException ( <str> + input . remaining ( ) + <str> ) ; } } public Set < String > supportedOptions ( ) { return new HashSet < > ( ) ; } public BufferType preferredBufferType ( ) { return BufferType . OFF_HEAP ; } public boolean supports ( BufferType bufferType ) { return true ; } } 
