package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . InternalContext ; import org . elasticsearch . common . inject . internal . InternalFactory ; import org . elasticsearch . common . inject . spi . Dependency ; class SingleParameterInjector < T > { private static final Object [ ] NO_ARGUMENTS = { } ; private final Dependency < T > dependency ; private final InternalFactory < ? extends T > factory ; SingleParameterInjector ( Dependency < T > dependency , InternalFactory < ? extends T > factory ) { this . dependency = dependency ; this . factory = factory ; } private T inject ( Errors errors , InternalContext context ) throws ErrorsException { context . setDependency ( dependency ) ; try { return factory . get ( errors . withSource ( dependency ) , context , dependency ) ; } finally { context . setDependency ( null ) ; } } static Object [ ] getAll ( Errors errors , InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws ErrorsException { if ( parameterInjectors = = null ) { return NO_ARGUMENTS ; } int numErrorsBefore = errors . size ( ) ; int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ; for ( int i = <int> ; i < size ; i + + ) { SingleParameterInjector < ? > parameterInjector = parameterInjectors [ i ] ; try { parameters [ i ] = parameterInjector . inject ( errors , context ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } errors . throwIfNewErrors ( numErrorsBefore ) ; return parameters ; } } 
