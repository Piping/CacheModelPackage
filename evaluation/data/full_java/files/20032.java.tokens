package io . netty . handler . ssl ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import static org . junit . Assume . assumeNoException ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerAdapter ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . ssl . JdkApplicationProtocolNegotiator . ProtocolSelector ; import io . netty . handler . ssl . JdkApplicationProtocolNegotiator . ProtocolSelectorFactory ; import io . netty . handler . ssl . ApplicationProtocolConfig . Protocol ; import io . netty . handler . ssl . ApplicationProtocolConfig . SelectedListenerFailureBehavior ; import io . netty . handler . ssl . ApplicationProtocolConfig . SelectorFailureBehavior ; import io . netty . handler . ssl . util . InsecureTrustManagerFactory ; import io . netty . handler . ssl . util . SelfSignedCertificate ; import io . netty . util . NetUtil ; import java . net . InetSocketAddress ; import java . security . cert . CertificateException ; import java . util . List ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLException ; import javax . net . ssl . SSLHandshakeException ; import org . junit . Test ; public class JdkSslEngineTest extends SSLEngineTest { private static final String PREFERRED_APPLICATION_LEVEL_PROTOCOL = <str> ; private static final String FALLBACK_APPLICATION_LEVEL_PROTOCOL = <str> ; private static final String APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE = <str> ; @Test public void testNpn ( ) throws Exception { try { if ( ! JdkNpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . NPN ) ; } ApplicationProtocolConfig apn = failingNegotiator ( Protocol . NPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; mySetup ( apn ) ; runTest ( ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testNpnNoCompatibleProtocolsNoHandshakeFailure ( ) throws Exception { try { if ( ! JdkNpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . NPN ) ; } ApplicationProtocolConfig clientApn = acceptingNegotiator ( Protocol . NPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = acceptingNegotiator ( Protocol . NPN , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; mySetup ( serverApn , clientApn ) ; runTest ( null ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testNpnNoCompatibleProtocolsClientHandshakeFailure ( ) throws Exception { try { if ( ! JdkNpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . NPN ) ; } ApplicationProtocolConfig clientApn = failingNegotiator ( Protocol . NPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = acceptingNegotiator ( Protocol . NPN , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; mySetup ( serverApn , clientApn ) ; assertTrue ( clientLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( clientException instanceof SSLHandshakeException ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testNpnNoCompatibleProtocolsServerHandshakeFailure ( ) throws Exception { try { if ( ! JdkNpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . NPN ) ; } ApplicationProtocolConfig clientApn = acceptingNegotiator ( Protocol . NPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = failingNegotiator ( Protocol . NPN , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; mySetup ( serverApn , clientApn ) ; assertTrue ( serverLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( serverException instanceof SSLHandshakeException ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testAlpn ( ) throws Exception { try { if ( ! JdkAlpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . ALPN ) ; } ApplicationProtocolConfig apn = failingNegotiator ( Protocol . ALPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; mySetup ( apn ) ; runTest ( ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testAlpnNoCompatibleProtocolsNoHandshakeFailure ( ) throws Exception { try { if ( ! JdkAlpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . ALPN ) ; } ApplicationProtocolConfig clientApn = acceptingNegotiator ( Protocol . ALPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = acceptingNegotiator ( Protocol . ALPN , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; mySetup ( serverApn , clientApn ) ; runTest ( null ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testAlpnNoCompatibleProtocolsServerHandshakeFailure ( ) throws Exception { try { if ( ! JdkAlpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . ALPN ) ; } ApplicationProtocolConfig clientApn = acceptingNegotiator ( Protocol . ALPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = failingNegotiator ( Protocol . ALPN , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; mySetup ( serverApn , clientApn ) ; assertTrue ( serverLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( serverException instanceof SSLHandshakeException ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testAlpnCompatibleProtocolsDifferentClientOrder ( ) throws Exception { try { if ( ! JdkAlpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . ALPN ) ; } ApplicationProtocolConfig clientApn = acceptingNegotiator ( Protocol . ALPN , FALLBACK_APPLICATION_LEVEL_PROTOCOL , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; ApplicationProtocolConfig serverApn = failingNegotiator ( Protocol . ALPN , PREFERRED_APPLICATION_LEVEL_PROTOCOL , FALLBACK_APPLICATION_LEVEL_PROTOCOL ) ; mySetup ( serverApn , clientApn ) ; assertNull ( serverException ) ; runTest ( PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } @Test public void testAlpnNoCompatibleProtocolsClientHandshakeFailure ( ) throws Exception { try { if ( ! JdkAlpnSslEngine . isAvailable ( ) ) { throw tlsExtensionNotFound ( Protocol . ALPN ) ; } SelfSignedCertificate ssc = new SelfSignedCertificate ( ) ; JdkApplicationProtocolNegotiator clientApn = new JdkAlpnApplicationProtocolNegotiator ( true , true , PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; JdkApplicationProtocolNegotiator serverApn = new JdkAlpnApplicationProtocolNegotiator ( new ProtocolSelectorFactory ( ) { @Override public ProtocolSelector newSelector ( SSLEngine engine , Set < String > supportedProtocols ) { return new ProtocolSelector ( ) { @Override public void unsupported ( ) { } @Override public String select ( List < String > protocols ) { return APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ; } } ; } } , JdkBaseApplicationProtocolNegotiator . FAIL_SELECTION_LISTENER_FACTORY , APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE ) ; SslContext serverSslCtx = new JdkSslServerContext ( ssc . certificate ( ) , ssc . privateKey ( ) , null , null , IdentityCipherSuiteFilter . INSTANCE , serverApn , <int> , <int> ) ; SslContext clientSslCtx = new JdkSslClientContext ( null , InsecureTrustManagerFactory . INSTANCE , null , IdentityCipherSuiteFilter . INSTANCE , clientApn , <int> , <int> ) ; mySetup ( serverSslCtx , clientSslCtx ) ; assertTrue ( clientLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( clientException instanceof SSLHandshakeException ) ; } catch ( SkipTestException e ) { assumeNoException ( e ) ; } } private void mySetup ( ApplicationProtocolConfig apn ) throws InterruptedException , SSLException , CertificateException { mySetup ( apn , apn ) ; } private void mySetup ( ApplicationProtocolConfig serverApn , ApplicationProtocolConfig clientApn ) throws InterruptedException , SSLException , CertificateException { SelfSignedCertificate ssc = new SelfSignedCertificate ( ) ; mySetup ( SslContextBuilder . forServer ( ssc . certificate ( ) , ssc . privateKey ( ) , null ) . sslProvider ( sslProvider ( ) ) . ciphers ( null , IdentityCipherSuiteFilter . INSTANCE ) . applicationProtocolConfig ( serverApn ) . sessionCacheSize ( <int> ) . sessionTimeout ( <int> ) . build ( ) , SslContextBuilder . forClient ( ) . sslProvider ( sslProvider ( ) ) . applicationProtocolConfig ( clientApn ) . trustManager ( InsecureTrustManagerFactory . INSTANCE ) . ciphers ( null , IdentityCipherSuiteFilter . INSTANCE ) . sessionCacheSize ( <int> ) . sessionTimeout ( <int> ) . build ( ) ) ; } private void mySetup ( SslContext serverCtx , SslContext clientCtx ) throws InterruptedException , SSLException , CertificateException { serverSslCtx = serverCtx ; clientSslCtx = clientCtx ; serverConnectedChannel = null ; sb = new ServerBootstrap ( ) ; cb = new Bootstrap ( ) ; sb . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) ; sb . channel ( NioServerSocketChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( serverSslCtx . newHandler ( ch . alloc ( ) ) ) ; p . addLast ( new MessageDelegatorChannelHandler ( serverReceiver , serverLatch ) ) ; p . addLast ( new ChannelHandlerAdapter ( ) { @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( cause . getCause ( ) instanceof SSLHandshakeException ) { serverException = cause . getCause ( ) ; serverLatch . countDown ( ) ; } else { ctx . fireExceptionCaught ( cause ) ; } } } ) ; serverConnectedChannel = ch ; } } ) ; cb . group ( new NioEventLoopGroup ( ) ) ; cb . channel ( NioSocketChannel . class ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( clientSslCtx . newHandler ( ch . alloc ( ) ) ) ; p . addLast ( new MessageDelegatorChannelHandler ( clientReceiver , clientLatch ) ) ; p . addLast ( new ChannelHandlerAdapter ( ) { @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( cause . getCause ( ) instanceof SSLHandshakeException ) { clientException = cause . getCause ( ) ; clientLatch . countDown ( ) ; } else { ctx . fireExceptionCaught ( cause ) ; } } } ) ; } } ) ; serverChannel = sb . bind ( new InetSocketAddress ( <int> ) ) . sync ( ) . channel ( ) ; int port = ( ( InetSocketAddress ) serverChannel . localAddress ( ) ) . getPort ( ) ; ChannelFuture ccf = cb . connect ( new InetSocketAddress ( NetUtil . LOCALHOST , port ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; clientChannel = ccf . channel ( ) ; } private void runTest ( ) throws Exception { runTest ( PREFERRED_APPLICATION_LEVEL_PROTOCOL ) ; } @Override protected SslProvider sslProvider ( ) { return SslProvider . JDK ; } private ApplicationProtocolConfig failingNegotiator ( Protocol protocol , String . . . supportedProtocols ) { return new ApplicationProtocolConfig ( protocol , SelectorFailureBehavior . FATAL_ALERT , SelectedListenerFailureBehavior . FATAL_ALERT , supportedProtocols ) ; } private ApplicationProtocolConfig acceptingNegotiator ( Protocol protocol , String . . . supportedProtocols ) { return new ApplicationProtocolConfig ( protocol , SelectorFailureBehavior . NO_ADVERTISE , SelectedListenerFailureBehavior . ACCEPT , supportedProtocols ) ; } private SkipTestException tlsExtensionNotFound ( Protocol protocol ) { throw new SkipTestException ( protocol + <str> ) ; } private static final class SkipTestException extends RuntimeException { public SkipTestException ( String message ) { super ( message ) ; } } } 
