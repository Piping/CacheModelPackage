package org . apache . cassandra . thrift ; import java . util . * ; import java . util . regex . Matcher ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Strings ; import com . google . common . collect . Maps ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . CompactTables ; import org . apache . cassandra . db . LegacyLayout ; import org . apache . cassandra . db . WriteType ; import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . io . compress . ICompressor ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . locator . LocalStrategy ; import org . apache . cassandra . schema . * ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . UUIDGen ; public class ThriftConversion { public static org . apache . cassandra . db . ConsistencyLevel fromThrift ( ConsistencyLevel cl ) { switch ( cl ) { case ANY : return org . apache . cassandra . db . ConsistencyLevel . ANY ; case ONE : return org . apache . cassandra . db . ConsistencyLevel . ONE ; case TWO : return org . apache . cassandra . db . ConsistencyLevel . TWO ; case THREE : return org . apache . cassandra . db . ConsistencyLevel . THREE ; case QUORUM : return org . apache . cassandra . db . ConsistencyLevel . QUORUM ; case ALL : return org . apache . cassandra . db . ConsistencyLevel . ALL ; case LOCAL_QUORUM : return org . apache . cassandra . db . ConsistencyLevel . LOCAL_QUORUM ; case EACH_QUORUM : return org . apache . cassandra . db . ConsistencyLevel . EACH_QUORUM ; case SERIAL : return org . apache . cassandra . db . ConsistencyLevel . SERIAL ; case LOCAL_SERIAL : return org . apache . cassandra . db . ConsistencyLevel . LOCAL_SERIAL ; case LOCAL_ONE : return org . apache . cassandra . db . ConsistencyLevel . LOCAL_ONE ; } throw new AssertionError ( ) ; } public static ConsistencyLevel toThrift ( org . apache . cassandra . db . ConsistencyLevel cl ) { switch ( cl ) { case ANY : return ConsistencyLevel . ANY ; case ONE : return ConsistencyLevel . ONE ; case TWO : return ConsistencyLevel . TWO ; case THREE : return ConsistencyLevel . THREE ; case QUORUM : return ConsistencyLevel . QUORUM ; case ALL : return ConsistencyLevel . ALL ; case LOCAL_QUORUM : return ConsistencyLevel . LOCAL_QUORUM ; case EACH_QUORUM : return ConsistencyLevel . EACH_QUORUM ; case SERIAL : return ConsistencyLevel . SERIAL ; case LOCAL_SERIAL : return ConsistencyLevel . LOCAL_SERIAL ; case LOCAL_ONE : return ConsistencyLevel . LOCAL_ONE ; } throw new AssertionError ( ) ; } public static RuntimeException rethrow ( RequestExecutionException e ) throws UnavailableException , TimedOutException { if ( e instanceof RequestFailureException ) throw toThrift ( ( RequestFailureException ) e ) ; else if ( e instanceof RequestTimeoutException ) throw toThrift ( ( RequestTimeoutException ) e ) ; else throw new UnavailableException ( ) ; } public static InvalidRequestException toThrift ( RequestValidationException e ) { return new InvalidRequestException ( e . getMessage ( ) ) ; } public static UnavailableException toThrift ( org . apache . cassandra . exceptions . UnavailableException e ) { return new UnavailableException ( ) ; } public static AuthenticationException toThrift ( org . apache . cassandra . exceptions . AuthenticationException e ) { return new AuthenticationException ( e . getMessage ( ) ) ; } public static TimedOutException toThrift ( RequestTimeoutException e ) { TimedOutException toe = new TimedOutException ( ) ; if ( e instanceof WriteTimeoutException ) { WriteTimeoutException wte = ( WriteTimeoutException ) e ; toe . setAcknowledged_by ( wte . received ) ; if ( wte . writeType = = WriteType . BATCH_LOG ) toe . setAcknowledged_by_batchlog ( false ) ; else if ( wte . writeType = = WriteType . BATCH ) toe . setAcknowledged_by_batchlog ( true ) ; else if ( wte . writeType = = WriteType . CAS ) toe . setPaxos_in_progress ( true ) ; } return toe ; } public static TimedOutException toThrift ( RequestFailureException e ) { return new TimedOutException ( ) ; } public static RowFilter rowFilterFromThrift ( CFMetaData metadata , List < IndexExpression > exprs ) { if ( exprs = = null | | exprs . isEmpty ( ) ) return RowFilter . NONE ; RowFilter converted = RowFilter . forThrift ( exprs . size ( ) ) ; for ( IndexExpression expr : exprs ) converted . addThriftExpression ( metadata , expr . column_name , Operator . valueOf ( expr . op . name ( ) ) , expr . value ) ; return converted ; } public static KeyspaceMetadata fromThrift ( KsDef ksd , CFMetaData . . . cfDefs ) throws ConfigurationException { Class < ? extends AbstractReplicationStrategy > cls = AbstractReplicationStrategy . getClass ( ksd . strategy_class ) ; if ( cls . equals ( LocalStrategy . class ) ) throw new ConfigurationException ( <str> ) ; Map < String , String > replicationMap = new HashMap < > ( ) ; if ( ksd . strategy_options ! = null ) replicationMap . putAll ( ksd . strategy_options ) ; replicationMap . put ( ReplicationParams . CLASS , cls . getName ( ) ) ; return KeyspaceMetadata . create ( ksd . name , KeyspaceParams . create ( ksd . durable_writes , replicationMap ) , Tables . of ( cfDefs ) ) ; } public static KsDef toThrift ( KeyspaceMetadata ksm ) { List < CfDef > cfDefs = new ArrayList < > ( ) ; for ( CFMetaData cfm : ksm . tables ) if ( cfm . isThriftCompatible ( ) ) cfDefs . add ( toThrift ( cfm ) ) ; KsDef ksdef = new KsDef ( ksm . name , ksm . params . replication . klass . getName ( ) , cfDefs ) ; ksdef . setStrategy_options ( ksm . params . replication . options ) ; ksdef . setDurable_writes ( ksm . params . durableWrites ) ; return ksdef ; } public static CFMetaData fromThrift ( CfDef cf_def ) throws org . apache . cassandra . exceptions . InvalidRequestException , ConfigurationException { boolean isDense = cf_def . column_metadata = = null | | cf_def . column_metadata . isEmpty ( ) ; return internalFromThrift ( cf_def , true , Collections . < ColumnDefinition > emptyList ( ) , isDense ) ; } public static CFMetaData fromThriftForUpdate ( CfDef cf_def , CFMetaData toUpdate ) throws org . apache . cassandra . exceptions . InvalidRequestException , ConfigurationException { return internalFromThrift ( cf_def , false , toUpdate . allColumns ( ) , toUpdate . isDense ( ) ) ; } private static boolean isSuper ( String thriftColumnType ) throws org . apache . cassandra . exceptions . InvalidRequestException { switch ( thriftColumnType . toLowerCase ( ) ) { case <str> : return false ; case <str> : return true ; default : throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + thriftColumnType ) ; } } private static CFMetaData internalFromThrift ( CfDef cf_def , boolean isCreation , Collection < ColumnDefinition > previousCQLMetadata , boolean isDense ) throws org . apache . cassandra . exceptions . InvalidRequestException , ConfigurationException { applyImplicitDefaults ( cf_def ) ; try { boolean isSuper = isSuper ( cf_def . column_type ) ; AbstractType < ? > rawComparator = TypeParser . parse ( cf_def . comparator_type ) ; AbstractType < ? > subComparator = isSuper ? cf_def . subcomparator_type = = null ? BytesType . instance : TypeParser . parse ( cf_def . subcomparator_type ) : null ; AbstractType < ? > keyValidator = cf_def . isSetKey_validation_class ( ) ? TypeParser . parse ( cf_def . key_validation_class ) : BytesType . instance ; AbstractType < ? > defaultValidator = TypeParser . parse ( cf_def . default_validation_class ) ; List < ColumnDefinition > defs = fromThrift ( cf_def . keyspace , cf_def . name , rawComparator , subComparator , cf_def . column_metadata ) ; boolean hasKeyAlias = cf_def . isSetKey_alias ( ) & & keyValidator ! = null & & ! ( keyValidator instanceof CompositeType ) ; if ( hasKeyAlias ) defs . add ( ColumnDefinition . partitionKeyDef ( cf_def . keyspace , cf_def . name , UTF8Type . instance . getString ( cf_def . key_alias ) , keyValidator , <int> ) ) ; for ( ColumnDefinition def : previousCQLMetadata ) { if ( def . isPartOfCellName ( false , isSuper ) ) continue ; if ( def . kind = = ColumnDefinition . Kind . PARTITION_KEY & & hasKeyAlias ) continue ; defs . add ( def ) ; } UUID cfId = Schema . instance . getId ( cf_def . keyspace , cf_def . name ) ; if ( cfId = = null ) cfId = UUIDGen . getTimeUUID ( ) ; boolean isCompound = ! isSuper & & ( rawComparator instanceof CompositeType ) ; boolean isCounter = defaultValidator instanceof CounterColumnType ; if ( isCreation ) { addDefaultCQLMetadata ( defs , cf_def . keyspace , cf_def . name , hasKeyAlias ? null : keyValidator , rawComparator , subComparator , defaultValidator ) ; } boolean isView = false ; CFMetaData newCFMD = CFMetaData . create ( cf_def . keyspace , cf_def . name , cfId , isDense , isCompound , isSuper , isCounter , isView , defs , DatabaseDescriptor . getPartitioner ( ) ) ; newCFMD . indexes ( indexDefsFromThrift ( newCFMD , cf_def . keyspace , cf_def . name , rawComparator , subComparator , cf_def . column_metadata ) ) ; if ( cf_def . isSetGc_grace_seconds ( ) ) newCFMD . gcGraceSeconds ( cf_def . gc_grace_seconds ) ; newCFMD . compaction ( compactionParamsFromThrift ( cf_def ) ) ; if ( cf_def . isSetBloom_filter_fp_chance ( ) ) newCFMD . bloomFilterFpChance ( cf_def . bloom_filter_fp_chance ) ; if ( cf_def . isSetMemtable_flush_period_in_ms ( ) ) newCFMD . memtableFlushPeriod ( cf_def . memtable_flush_period_in_ms ) ; if ( cf_def . isSetCaching ( ) | | cf_def . isSetCells_per_row_to_cache ( ) ) newCFMD . caching ( cachingFromThrift ( cf_def . caching , cf_def . cells_per_row_to_cache ) ) ; if ( cf_def . isSetRead_repair_chance ( ) ) newCFMD . readRepairChance ( cf_def . read_repair_chance ) ; if ( cf_def . isSetDefault_time_to_live ( ) ) newCFMD . defaultTimeToLive ( cf_def . default_time_to_live ) ; if ( cf_def . isSetDclocal_read_repair_chance ( ) ) newCFMD . dcLocalReadRepairChance ( cf_def . dclocal_read_repair_chance ) ; if ( cf_def . isSetMin_index_interval ( ) ) newCFMD . minIndexInterval ( cf_def . min_index_interval ) ; if ( cf_def . isSetMax_index_interval ( ) ) newCFMD . maxIndexInterval ( cf_def . max_index_interval ) ; if ( cf_def . isSetSpeculative_retry ( ) ) newCFMD . speculativeRetry ( SpeculativeRetryParam . fromString ( cf_def . speculative_retry ) ) ; if ( cf_def . isSetTriggers ( ) ) newCFMD . triggers ( triggerDefinitionsFromThrift ( cf_def . triggers ) ) ; if ( cf_def . isSetComment ( ) ) newCFMD . comment ( cf_def . comment ) ; if ( cf_def . isSetCompression_options ( ) ) newCFMD . compression ( compressionParametersFromThrift ( cf_def . compression_options ) ) ; return newCFMD ; } catch ( SyntaxException | MarshalException e ) { throw new ConfigurationException ( e . getMessage ( ) ) ; } } @SuppressWarnings ( <str> ) private static CompactionParams compactionParamsFromThrift ( CfDef cf_def ) { Class < ? extends AbstractCompactionStrategy > klass = CFMetaData . createCompactionStrategy ( cf_def . compaction_strategy ) ; Map < String , String > options = new HashMap < > ( cf_def . compaction_strategy_options ) ; int minThreshold = cf_def . min_compaction_threshold ; int maxThreshold = cf_def . max_compaction_threshold ; if ( CompactionParams . supportsThresholdParams ( klass ) ) { options . putIfAbsent ( CompactionParams . Option . MIN_THRESHOLD . toString ( ) , Integer . toString ( minThreshold ) ) ; options . putIfAbsent ( CompactionParams . Option . MAX_THRESHOLD . toString ( ) , Integer . toString ( maxThreshold ) ) ; } return CompactionParams . create ( klass , options ) ; } private static CompressionParams compressionParametersFromThrift ( Map < String , String > compression_options ) { CompressionParams compressionParameter = CompressionParams . fromMap ( compression_options ) ; compressionParameter . validate ( ) ; return compressionParameter ; } private static void addDefaultCQLMetadata ( Collection < ColumnDefinition > defs , String ks , String cf , AbstractType < ? > keyValidator , AbstractType < ? > comparator , AbstractType < ? > subComparator , AbstractType < ? > defaultValidator ) { CompactTables . DefaultNames names = CompactTables . defaultNameGenerator ( defs ) ; if ( keyValidator ! = null ) { if ( keyValidator instanceof CompositeType ) { List < AbstractType < ? > > subTypes = ( ( CompositeType ) keyValidator ) . types ; for ( int i = <int> ; i < subTypes . size ( ) ; i + + ) defs . add ( ColumnDefinition . partitionKeyDef ( ks , cf , names . defaultPartitionKeyName ( ) , subTypes . get ( i ) , i ) ) ; } else { defs . add ( ColumnDefinition . partitionKeyDef ( ks , cf , names . defaultPartitionKeyName ( ) , keyValidator , <int> ) ) ; } } if ( subComparator ! = null ) { defs . add ( ColumnDefinition . clusteringDef ( ks , cf , names . defaultClusteringName ( ) , comparator , <int> ) ) ; defs . add ( ColumnDefinition . regularDef ( ks , cf , CompactTables . SUPER_COLUMN_MAP_COLUMN_STR , MapType . getInstance ( subComparator , defaultValidator , true ) ) ) ; } else { List < AbstractType < ? > > subTypes = comparator instanceof CompositeType ? ( ( CompositeType ) comparator ) . types : Collections . < AbstractType < ? > > singletonList ( comparator ) ; for ( int i = <int> ; i < subTypes . size ( ) ; i + + ) defs . add ( ColumnDefinition . clusteringDef ( ks , cf , names . defaultClusteringName ( ) , subTypes . get ( i ) , i ) ) ; defs . add ( ColumnDefinition . regularDef ( ks , cf , names . defaultCompactValueName ( ) , defaultValidator ) ) ; } } @SuppressWarnings ( <str> ) private static void applyImplicitDefaults ( org . apache . cassandra . thrift . CfDef cf_def ) { if ( ! cf_def . isSetComment ( ) ) cf_def . setComment ( <str> ) ; if ( ! cf_def . isSetMin_compaction_threshold ( ) ) cf_def . setMin_compaction_threshold ( CompactionParams . DEFAULT_MIN_THRESHOLD ) ; if ( ! cf_def . isSetMax_compaction_threshold ( ) ) cf_def . setMax_compaction_threshold ( CompactionParams . DEFAULT_MAX_THRESHOLD ) ; if ( ! cf_def . isSetCompaction_strategy ( ) ) cf_def . setCompaction_strategy ( CompactionParams . DEFAULT . klass ( ) . getSimpleName ( ) ) ; if ( ! cf_def . isSetCompaction_strategy_options ( ) ) cf_def . setCompaction_strategy_options ( Collections . emptyMap ( ) ) ; if ( ! cf_def . isSetCompression_options ( ) ) cf_def . setCompression_options ( Collections . singletonMap ( CompressionParams . SSTABLE_COMPRESSION , CompressionParams . DEFAULT . klass ( ) . getCanonicalName ( ) ) ) ; if ( ! cf_def . isSetDefault_time_to_live ( ) ) cf_def . setDefault_time_to_live ( TableParams . DEFAULT_DEFAULT_TIME_TO_LIVE ) ; if ( ! cf_def . isSetDclocal_read_repair_chance ( ) ) cf_def . setDclocal_read_repair_chance ( TableParams . DEFAULT_DCLOCAL_READ_REPAIR_CHANCE ) ; if ( ! cf_def . isSetMin_index_interval ( ) ) { if ( cf_def . isSetIndex_interval ( ) ) cf_def . setMin_index_interval ( cf_def . getIndex_interval ( ) ) ; else cf_def . setMin_index_interval ( TableParams . DEFAULT_MIN_INDEX_INTERVAL ) ; } if ( ! cf_def . isSetMax_index_interval ( ) ) { cf_def . setMax_index_interval ( Math . max ( cf_def . min_index_interval , TableParams . DEFAULT_MAX_INDEX_INTERVAL ) ) ; } } public static CfDef toThrift ( CFMetaData cfm ) { CfDef def = new CfDef ( cfm . ksName , cfm . cfName ) ; def . setColumn_type ( cfm . isSuper ( ) ? <str> : <str> ) ; if ( cfm . isSuper ( ) ) { def . setComparator_type ( cfm . comparator . subtype ( <int> ) . toString ( ) ) ; def . setSubcomparator_type ( cfm . thriftColumnNameType ( ) . toString ( ) ) ; } else { def . setComparator_type ( LegacyLayout . makeLegacyComparator ( cfm ) . toString ( ) ) ; } def . setComment ( cfm . params . comment ) ; def . setRead_repair_chance ( cfm . params . readRepairChance ) ; def . setDclocal_read_repair_chance ( cfm . params . dcLocalReadRepairChance ) ; def . setGc_grace_seconds ( cfm . params . gcGraceSeconds ) ; def . setDefault_validation_class ( cfm . makeLegacyDefaultValidator ( ) . toString ( ) ) ; def . setKey_validation_class ( cfm . getKeyValidator ( ) . toString ( ) ) ; def . setMin_compaction_threshold ( cfm . params . compaction . minCompactionThreshold ( ) ) ; def . setMax_compaction_threshold ( cfm . params . compaction . maxCompactionThreshold ( ) ) ; if ( cfm . partitionKeyColumns ( ) . size ( ) = = <int> ) def . setKey_alias ( cfm . partitionKeyColumns ( ) . get ( <int> ) . name . bytes ) ; def . setColumn_metadata ( columnDefinitionsToThrift ( cfm , cfm . allColumns ( ) ) ) ; def . setCompaction_strategy ( cfm . params . compaction . klass ( ) . getName ( ) ) ; def . setCompaction_strategy_options ( cfm . params . compaction . options ( ) ) ; def . setCompression_options ( compressionParametersToThrift ( cfm . params . compression ) ) ; def . setBloom_filter_fp_chance ( cfm . params . bloomFilterFpChance ) ; def . setMin_index_interval ( cfm . params . minIndexInterval ) ; def . setMax_index_interval ( cfm . params . maxIndexInterval ) ; def . setMemtable_flush_period_in_ms ( cfm . params . memtableFlushPeriodInMs ) ; def . setCaching ( toThrift ( cfm . params . caching ) ) ; def . setCells_per_row_to_cache ( toThriftCellsPerRow ( cfm . params . caching ) ) ; def . setDefault_time_to_live ( cfm . params . defaultTimeToLive ) ; def . setSpeculative_retry ( cfm . params . speculativeRetry . toString ( ) ) ; def . setTriggers ( triggerDefinitionsToThrift ( cfm . getTriggers ( ) ) ) ; return def ; } public static ColumnDefinition fromThrift ( String ksName , String cfName , AbstractType < ? > thriftComparator , AbstractType < ? > thriftSubcomparator , ColumnDef thriftColumnDef ) throws SyntaxException , ConfigurationException { boolean isSuper = thriftSubcomparator ! = null ; AbstractType < ? > comparator = thriftSubcomparator = = null ? thriftComparator : thriftSubcomparator ; try { comparator . validate ( thriftColumnDef . name ) ; } catch ( MarshalException e ) { throw new ConfigurationException ( String . format ( <str> , ByteBufferUtil . bytesToHex ( thriftColumnDef . name ) , comparator ) ) ; } ColumnDefinition . Kind kind = isSuper ? ColumnDefinition . Kind . REGULAR : ColumnDefinition . Kind . STATIC ; return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( ByteBufferUtil . clone ( thriftColumnDef . name ) , comparator ) , TypeParser . parse ( thriftColumnDef . validation_class ) , ColumnDefinition . NO_POSITION , kind ) ; } private static List < ColumnDefinition > fromThrift ( String ksName , String cfName , AbstractType < ? > thriftComparator , AbstractType < ? > thriftSubcomparator , List < ColumnDef > thriftDefs ) throws SyntaxException , ConfigurationException { if ( thriftDefs = = null ) return new ArrayList < > ( ) ; List < ColumnDefinition > defs = new ArrayList < > ( thriftDefs . size ( ) ) ; for ( ColumnDef thriftColumnDef : thriftDefs ) defs . add ( fromThrift ( ksName , cfName , thriftComparator , thriftSubcomparator , thriftColumnDef ) ) ; return defs ; } private static Indexes indexDefsFromThrift ( CFMetaData cfm , String ksName , String cfName , AbstractType < ? > thriftComparator , AbstractType < ? > thriftSubComparator , List < ColumnDef > thriftDefs ) { if ( thriftDefs = = null ) return Indexes . none ( ) ; Set < String > indexNames = new HashSet < > ( ) ; Indexes . Builder indexes = Indexes . builder ( ) ; for ( ColumnDef def : thriftDefs ) { if ( def . isSetIndex_type ( ) ) { ColumnDefinition column = fromThrift ( ksName , cfName , thriftComparator , thriftSubComparator , def ) ; String indexName = def . getIndex_name ( ) ; if ( Strings . isNullOrEmpty ( indexName ) ) indexName = Indexes . getAvailableIndexName ( ksName , cfName , column . name . toString ( ) ) ; if ( indexNames . contains ( indexName ) ) throw new ConfigurationException ( <str> + indexName ) ; indexNames . add ( indexName ) ; Map < String , String > indexOptions = def . getIndex_options ( ) ; if ( indexOptions ! = null & & indexOptions . containsKey ( IndexTarget . TARGET_OPTION_NAME ) ) throw new ConfigurationException ( <str> ) ; IndexMetadata . Kind kind = IndexMetadata . Kind . valueOf ( def . index_type . name ( ) ) ; indexes . add ( IndexMetadata . fromLegacyMetadata ( cfm , column , indexName , kind , indexOptions ) ) ; } } return indexes . build ( ) ; } @VisibleForTesting public static ColumnDef toThrift ( CFMetaData cfMetaData , ColumnDefinition column ) { ColumnDef cd = new ColumnDef ( ) ; cd . setName ( ByteBufferUtil . clone ( column . name . bytes ) ) ; cd . setValidation_class ( column . type . toString ( ) ) ; IndexMetadata matchedIndex = null ; for ( IndexMetadata index : cfMetaData . getIndexes ( ) ) { Pair < ColumnDefinition , IndexTarget . Type > target = CassandraIndex . parseTarget ( cfMetaData , index ) ; if ( target . left . equals ( column ) ) { if ( matchedIndex ! = null ) return cd ; matchedIndex = index ; } } if ( matchedIndex ! = null ) { cd . setIndex_type ( org . apache . cassandra . thrift . IndexType . valueOf ( matchedIndex . kind . name ( ) ) ) ; cd . setIndex_name ( matchedIndex . name ) ; Map < String , String > filteredOptions = Maps . filterKeys ( matchedIndex . options , s - > ! IndexTarget . TARGET_OPTION_NAME . equals ( s ) ) ; cd . setIndex_options ( filteredOptions . isEmpty ( ) ? null : Maps . newHashMap ( filteredOptions ) ) ; } return cd ; } private static List < ColumnDef > columnDefinitionsToThrift ( CFMetaData metadata , Collection < ColumnDefinition > columns ) { List < ColumnDef > thriftDefs = new ArrayList < > ( columns . size ( ) ) ; for ( ColumnDefinition def : columns ) if ( def . isPartOfCellName ( metadata . isCQLTable ( ) , metadata . isSuper ( ) ) ) thriftDefs . add ( ThriftConversion . toThrift ( metadata , def ) ) ; return thriftDefs ; } private static Triggers triggerDefinitionsFromThrift ( List < TriggerDef > thriftDefs ) { Triggers . Builder triggers = Triggers . builder ( ) ; for ( TriggerDef thriftDef : thriftDefs ) triggers . add ( new TriggerMetadata ( thriftDef . getName ( ) , thriftDef . getOptions ( ) . get ( TriggerMetadata . CLASS ) ) ) ; return triggers . build ( ) ; } private static List < TriggerDef > triggerDefinitionsToThrift ( Triggers triggers ) { List < TriggerDef > thriftDefs = new ArrayList < > ( ) ; for ( TriggerMetadata def : triggers ) { TriggerDef td = new TriggerDef ( ) ; td . setName ( def . name ) ; td . setOptions ( Collections . singletonMap ( TriggerMetadata . CLASS , def . classOption ) ) ; thriftDefs . add ( td ) ; } return thriftDefs ; } @SuppressWarnings ( <str> ) public static Map < String , String > compressionParametersToThrift ( CompressionParams parameters ) { if ( ! parameters . isEnabled ( ) ) return Collections . emptyMap ( ) ; Map < String , String > options = new HashMap < > ( parameters . getOtherOptions ( ) ) ; Class < ? extends ICompressor > klass = parameters . getSstableCompressor ( ) . getClass ( ) ; options . put ( CompressionParams . SSTABLE_COMPRESSION , klass . getName ( ) ) ; options . put ( CompressionParams . CHUNK_LENGTH_KB , parameters . chunkLengthInKB ( ) ) ; return options ; } private static String toThrift ( CachingParams caching ) { if ( caching . cacheRows ( ) & & caching . cacheKeys ( ) ) return <str> ; if ( caching . cacheRows ( ) ) return <str> ; if ( caching . cacheKeys ( ) ) return <str> ; return <str> ; } private static CachingParams cachingFromTrhfit ( String caching ) { switch ( caching . toUpperCase ( ) ) { case <str> : return CachingParams . CACHE_EVERYTHING ; case <str> : return new CachingParams ( false , Integer . MAX_VALUE ) ; case <str> : return CachingParams . CACHE_KEYS ; case <str> : return CachingParams . CACHE_NOTHING ; default : throw new ConfigurationException ( String . format ( <str> , caching ) ) ; } } private static String toThriftCellsPerRow ( CachingParams caching ) { return caching . cacheAllRows ( ) ? <str> : String . valueOf ( caching . rowsPerPartitionToCache ( ) ) ; } private static int fromThriftCellsPerRow ( String value ) { return <str> . equals ( value ) ? Integer . MAX_VALUE : Integer . parseInt ( value ) ; } public static CachingParams cachingFromThrift ( String caching , String cellsPerRow ) { boolean cacheKeys = true ; int rowsPerPartitionToCache = <int> ; if ( caching ! = null ) { CachingParams parsed = cachingFromTrhfit ( caching ) ; cacheKeys = parsed . cacheKeys ( ) ; rowsPerPartitionToCache = parsed . rowsPerPartitionToCache ( ) ; } if ( cellsPerRow ! = null & & rowsPerPartitionToCache > <int> ) rowsPerPartitionToCache = fromThriftCellsPerRow ( cellsPerRow ) ; return new CachingParams ( cacheKeys , rowsPerPartitionToCache ) ; } } 
