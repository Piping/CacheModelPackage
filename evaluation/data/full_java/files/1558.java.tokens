package org . apache . cassandra . io . sstable ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import com . google . common . base . Joiner ; import com . google . common . collect . Sets ; import org . junit . After ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . compaction . CompactionInfo ; import org . apache . cassandra . db . compaction . CompactionInterruptedException ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . metrics . CompactionMetrics ; import org . apache . cassandra . metrics . RestorableMeter ; import org . apache . cassandra . schema . CachingParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import static com . google . common . collect . ImmutableMap . of ; import static java . util . Arrays . asList ; import static org . apache . cassandra . io . sstable . Downsampling . BASE_SAMPLING_LEVEL ; import static org . apache . cassandra . io . sstable . IndexSummaryRedistribution . DOWNSAMPLE_THESHOLD ; import static org . apache . cassandra . io . sstable . IndexSummaryRedistribution . UPSAMPLE_THRESHOLD ; import static org . apache . cassandra . io . sstable . IndexSummaryManager . redistributeSummaries ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class IndexSummaryManagerTest { private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryManagerTest . class ) ; int originalMinIndexInterval ; int originalMaxIndexInterval ; long originalCapacity ; private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARDLOWiINTERVAL = <str> ; private static final String CF_STANDARDRACE = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARDLOWiINTERVAL ) . minIndexInterval ( <int> ) . maxIndexInterval ( <int> ) . caching ( CachingParams . CACHE_NOTHING ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARDRACE ) . minIndexInterval ( <int> ) . maxIndexInterval ( <int> ) . caching ( CachingParams . CACHE_NOTHING ) ) ; } @Before public void beforeTest ( ) { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; originalMinIndexInterval = cfs . metadata . params . minIndexInterval ; originalMaxIndexInterval = cfs . metadata . params . maxIndexInterval ; originalCapacity = IndexSummaryManager . instance . getMemoryPoolCapacityInMB ( ) ; } @After public void afterTest ( ) { for ( CompactionInfo . Holder holder : CompactionMetrics . getCompactions ( ) ) { holder . stop ( ) ; } String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . metadata . minIndexInterval ( originalMinIndexInterval ) ; cfs . metadata . maxIndexInterval ( originalMaxIndexInterval ) ; IndexSummaryManager . instance . setMemoryPoolCapacityInMB ( originalCapacity ) ; } private static long totalOffHeapSize ( List < SSTableReader > sstables ) { long total = <int> ; for ( SSTableReader sstable : sstables ) total + = sstable . getIndexSummaryOffHeapSize ( ) ; return total ; } private static List < SSTableReader > resetSummaries ( ColumnFamilyStore cfs , List < SSTableReader > sstables , long originalOffHeapSize ) throws IOException { for ( SSTableReader sstable : sstables ) sstable . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , originalOffHeapSize * sstables . size ( ) ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL , sstable . getIndexSummarySamplingLevel ( ) ) ; return sstables ; } private void validateData ( ColumnFamilyStore cfs , int numPartition ) { for ( int i = <int> ; i < numPartition ; i + + ) { Row row = Util . getOnlyRowUnfiltered ( Util . cmd ( cfs , String . format ( <str> , i ) ) . build ( ) ) ; Cell cell = row . getCell ( cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ) ; assertNotNull ( cell ) ; assertEquals ( <int> , cell . value ( ) . array ( ) . length ) ; } } private Comparator < SSTableReader > hotnessComparator = new Comparator < SSTableReader > ( ) { public int compare ( SSTableReader o1 , SSTableReader o2 ) { return Double . compare ( o1 . getReadMeter ( ) . fifteenMinuteRate ( ) , o2 . getReadMeter ( ) . fifteenMinuteRate ( ) ) ; } } ; private void createSSTables ( String ksname , String cfname , int numSSTables , int numPartition ) { Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ArrayList < Future > futures = new ArrayList < > ( numSSTables ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; for ( int sstable = <int> ; sstable < numSSTables ; sstable + + ) { for ( int p = <int> ; p < numPartition ; p + + ) { String key = String . format ( <str> , p ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; } futures . add ( cfs . forceFlush ( ) ) ; } for ( Future future : futures ) { try { future . get ( ) ; } catch ( InterruptedException | ExecutionException e ) { throw new RuntimeException ( e ) ; } } assertEquals ( numSSTables , cfs . getLiveSSTables ( ) . size ( ) ) ; validateData ( cfs , numPartition ) ; } @Test public void testChangeMinIndexInterval ( ) throws IOException { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; int numSSTables = <int> ; int numRows = <int> ; createSSTables ( ksname , cfname , numSSTables , numRows ) ; List < SSTableReader > sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) sstable . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; for ( SSTableReader sstable : sstables ) assertEquals ( cfs . metadata . params . minIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; cfs . metadata . minIndexInterval ( originalMinIndexInterval * <int> ) ; IndexSummaryManager . instance . redistributeSummaries ( ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) { assertEquals ( cfs . metadata . params . minIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / cfs . metadata . params . minIndexInterval , sstable . getIndexSummarySize ( ) ) ; } cfs . metadata . minIndexInterval ( originalMinIndexInterval ) ; IndexSummaryManager . instance . redistributeSummaries ( ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) { assertEquals ( cfs . metadata . params . minIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / cfs . metadata . params . minIndexInterval , sstable . getIndexSummarySize ( ) ) ; } cfs . metadata . minIndexInterval ( originalMinIndexInterval / <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; long summarySpace = sstable . getIndexSummaryOffHeapSize ( ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( asList ( sstable ) , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , summarySpace ) ; } sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertEquals ( originalMinIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / originalMinIndexInterval , sstable . getIndexSummarySize ( ) ) ; double previousInterval = sstable . getEffectiveIndexInterval ( ) ; int previousSize = sstable . getIndexSummarySize ( ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( asList ( sstable ) , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( long ) Math . ceil ( summarySpace * <float> ) ) ; } sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertEquals ( previousSize * <float> , ( double ) sstable . getIndexSummarySize ( ) , <int> ) ; assertEquals ( previousInterval * ( <float> / <float> ) , sstable . getEffectiveIndexInterval ( ) , <float> ) ; cfs . metadata . minIndexInterval ( originalMinIndexInterval ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( asList ( sstable ) , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( long ) Math . ceil ( summarySpace / <float> ) ) ; } sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertEquals ( originalMinIndexInterval * <int> , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / ( originalMinIndexInterval * <int> ) , sstable . getIndexSummarySize ( ) ) ; cfs . metadata . minIndexInterval ( originalMinIndexInterval * <int> ) ; cfs . metadata . maxIndexInterval ( originalMinIndexInterval * <int> ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( asList ( sstable ) , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , <int> ) ; } sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertEquals ( cfs . metadata . params . minIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; } @Test public void testChangeMaxIndexInterval ( ) throws IOException { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; int numSSTables = <int> ; int numRows = <int> ; createSSTables ( ksname , cfname , numSSTables , numRows ) ; List < SSTableReader > sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) sstable . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , <int> ) ; } sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) assertEquals ( cfs . metadata . params . maxIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; cfs . metadata . maxIndexInterval ( cfs . metadata . params . maxIndexInterval / <int> ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , <int> ) ; } sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) { assertEquals ( cfs . metadata . params . maxIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / cfs . metadata . params . maxIndexInterval , sstable . getIndexSummarySize ( ) ) ; } cfs . metadata . maxIndexInterval ( cfs . metadata . params . maxIndexInterval * <int> ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , <int> ) ; } for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) { assertEquals ( cfs . metadata . params . maxIndexInterval , sstable . getEffectiveIndexInterval ( ) , <float> ) ; assertEquals ( numRows / cfs . metadata . params . maxIndexInterval , sstable . getIndexSummarySize ( ) ) ; } } @Test ( timeout = <int> ) public void testRedistributeSummaries ( ) throws IOException { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; int numSSTables = <int> ; int numRows = <int> ; createSSTables ( ksname , cfname , numSSTables , numRows ) ; int minSamplingLevel = ( BASE_SAMPLING_LEVEL * cfs . metadata . params . minIndexInterval ) / cfs . metadata . params . maxIndexInterval ; List < SSTableReader > sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) sstable . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; long singleSummaryOffHeapSpace = sstables . get ( <int> ) . getIndexSummaryOffHeapSize ( ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * numSSTables ) ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL , sstable . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( singleSummaryOffHeapSpace * numSSTables , totalOffHeapSize ( sstables ) ) ; validateData ( cfs , numRows ) ; assert sstables . size ( ) = = <int> ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * ( numSSTables / <int> ) ) ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstable . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * ( numSSTables / <int> ) ) ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstable . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * ( numSSTables / <int> ) + <int> ) ) ; } assert sstables . size ( ) = = <int> ; for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstable . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * numSSTables ) ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( BASE_SAMPLING_LEVEL , sstable . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * <int> ) ) ; } Collections . sort ( sstables , hotnessComparator ) ; assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; double lowerRate = <float> * ( DOWNSAMPLE_THESHOLD + ( DOWNSAMPLE_THESHOLD * <float> ) ) ; double higherRate = <float> * ( UPSAMPLE_THRESHOLD - ( UPSAMPLE_THRESHOLD * <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( lowerRate , lowerRate ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( higherRate , higherRate ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * <int> ) ) ; } Collections . sort ( sstables , hotnessComparator ) ; assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL / <int> , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; sstables = resetSummaries ( cfs , sstables , singleSummaryOffHeapSpace ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( singleSummaryOffHeapSpace * <int> ) + <int> ) ; } Collections . sort ( sstables , hotnessComparator ) ; if ( sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) = = minSamplingLevel ) assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; else assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <int> , <int> ) ) ; sstables . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , ( long ) ( singleSummaryOffHeapSpace + ( singleSummaryOffHeapSpace * ( <float> / BASE_SAMPLING_LEVEL ) ) ) ) ; } Collections . sort ( sstables , hotnessComparator ) ; assertEquals ( <int> , sstables . get ( <int> ) . getIndexSummarySize ( ) ) ; assertEquals ( <int> , sstables . get ( <int> ) . getIndexSummarySize ( ) ) ; assertTrue ( sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) > minSamplingLevel ) ; assertTrue ( sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) < BASE_SAMPLING_LEVEL ) ; assertEquals ( BASE_SAMPLING_LEVEL , sstables . get ( <int> ) . getIndexSummarySamplingLevel ( ) ) ; validateData ( cfs , numRows ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { sstables = redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , <int> ) ; } for ( SSTableReader sstable : sstables ) assertEquals ( <int> , sstable . getIndexSummarySize ( ) ) ; validateData ( cfs , numRows ) ; } @Test public void testRebuildAtSamplingLevel ( ) throws IOException { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numRows = <int> ; for ( int row = <int> ; row < numRows ; row + + ) { String key = String . format ( <str> , row ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; List < SSTableReader > sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; assertEquals ( <int> , sstables . size ( ) ) ; SSTableReader original = sstables . get ( <int> ) ; SSTableReader sstable = original ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( asList ( sstable ) , OperationType . UNKNOWN ) ) { for ( int samplingLevel = <int> ; samplingLevel < BASE_SAMPLING_LEVEL ; samplingLevel + + ) { sstable = sstable . cloneWithNewSummarySamplingLevel ( cfs , samplingLevel ) ; assertEquals ( samplingLevel , sstable . getIndexSummarySamplingLevel ( ) ) ; int expectedSize = ( numRows * samplingLevel ) / ( sstable . metadata . params . minIndexInterval * BASE_SAMPLING_LEVEL ) ; assertEquals ( expectedSize , sstable . getIndexSummarySize ( ) , <int> ) ; txn . update ( sstable , true ) ; txn . checkpoint ( ) ; } txn . finish ( ) ; } } @Test public void testJMXFunctions ( ) throws IOException { IndexSummaryManager manager = IndexSummaryManager . instance ; manager . setResizeIntervalInMinutes ( - <int> ) ; assertNull ( manager . getTimeToNextResize ( TimeUnit . MINUTES ) ) ; manager . setResizeIntervalInMinutes ( <int> ) ; assertEquals ( <int> , manager . getResizeIntervalInMinutes ( ) ) ; assertEquals ( <int> , manager . getTimeToNextResize ( TimeUnit . MINUTES ) , <int> ) ; manager . setResizeIntervalInMinutes ( <int> ) ; assertEquals ( <int> , manager . getResizeIntervalInMinutes ( ) ) ; assertEquals ( <int> , manager . getTimeToNextResize ( TimeUnit . MINUTES ) , <int> ) ; assertTrue ( manager . getMemoryPoolCapacityInMB ( ) > = <int> ) ; manager . setMemoryPoolCapacityInMB ( <int> ) ; assertEquals ( <int> , manager . getMemoryPoolCapacityInMB ( ) ) ; String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numSSTables = <int> ; int numRows = <int> ; for ( int sstable = <int> ; sstable < numSSTables ; sstable + + ) { for ( int row = <int> ; row < numRows ; row + + ) { String key = String . format ( <str> , row ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } assertTrue ( manager . getAverageIndexInterval ( ) > = cfs . metadata . params . minIndexInterval ) ; Map < String , Integer > intervals = manager . getIndexIntervals ( ) ; for ( Map . Entry < String , Integer > entry : intervals . entrySet ( ) ) if ( entry . getKey ( ) . contains ( CF_STANDARDLOWiINTERVAL ) ) assertEquals ( cfs . metadata . params . minIndexInterval , entry . getValue ( ) , <float> ) ; manager . setMemoryPoolCapacityInMB ( <int> ) ; manager . redistributeSummaries ( ) ; assertTrue ( manager . getAverageIndexInterval ( ) > cfs . metadata . params . minIndexInterval ) ; intervals = manager . getIndexIntervals ( ) ; for ( Map . Entry < String , Integer > entry : intervals . entrySet ( ) ) { if ( entry . getKey ( ) . contains ( CF_STANDARDLOWiINTERVAL ) ) assertTrue ( entry . getValue ( ) > = cfs . metadata . params . minIndexInterval ) ; } } @Test public void testCancelIndex ( ) throws Exception { String ksname = KEYSPACE1 ; String cfname = CF_STANDARDLOWiINTERVAL ; Keyspace keyspace = Keyspace . open ( ksname ) ; final ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; final int numSSTables = <int> ; int numRows = <int> ; createSSTables ( ksname , cfname , numSSTables , numRows ) ; final List < SSTableReader > sstables = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; for ( SSTableReader sstable : sstables ) sstable . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; final long singleSummaryOffHeapSpace = sstables . get ( <int> ) . getIndexSummaryOffHeapSize ( ) ; final AtomicReference < CompactionInterruptedException > exception = new AtomicReference < > ( ) ; Thread t = new Thread ( new Runnable ( ) { public void run ( ) { try { try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . UNKNOWN ) ) { redistributeSummaries ( Collections . EMPTY_LIST , of ( cfs . metadata . cfId , txn ) , singleSummaryOffHeapSpace ) ; } } catch ( CompactionInterruptedException ex ) { exception . set ( ex ) ; } catch ( IOException ignored ) { } } } ) ; t . start ( ) ; while ( CompactionManager . instance . getActiveCompactions ( ) = = <int> & & t . isAlive ( ) ) Thread . sleep ( <int> ) ; CompactionManager . instance . stopCompaction ( <str> ) ; t . join ( ) ; assertNotNull ( <str> , exception . get ( ) ) ; assertTrue ( <str> , CompactionMetrics . getCompactions ( ) . isEmpty ( ) ) ; Set < SSTableReader > beforeRedistributionSSTables = new HashSet < > ( sstables ) ; Set < SSTableReader > afterCancelSSTables = new HashSet < > ( cfs . getLiveSSTables ( ) ) ; Set < SSTableReader > disjoint = Sets . symmetricDifference ( beforeRedistributionSSTables , afterCancelSSTables ) ; assertTrue ( String . format ( <str> , Joiner . on ( <str> ) . join ( disjoint ) ) , disjoint . isEmpty ( ) ) ; validateData ( cfs , numRows ) ; } } 
