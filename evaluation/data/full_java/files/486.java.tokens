package org . apache . cassandra . db . partitions ; import java . io . IOError ; import java . io . IOException ; import java . security . MessageDigest ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . transform . FilteredPartitions ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . MergeIterator ; public abstract class UnfilteredPartitionIterators { private static final Serializer serializer = new Serializer ( ) ; private static final Comparator < UnfilteredRowIterator > partitionComparator = ( p1 , p2 ) - > p1 . partitionKey ( ) . compareTo ( p2 . partitionKey ( ) ) ; private UnfilteredPartitionIterators ( ) { } public interface MergeListener { public UnfilteredRowIterators . MergeListener getRowMergeListener ( DecoratedKey partitionKey , List < UnfilteredRowIterator > versions ) ; public void close ( ) ; } @SuppressWarnings ( <str> ) public static UnfilteredRowIterator getOnlyElement ( final UnfilteredPartitionIterator iter , SinglePartitionReadCommand command ) { UnfilteredRowIterator toReturn = iter . hasNext ( ) ? iter . next ( ) : EmptyIterators . unfilteredRow ( command . metadata ( ) , command . partitionKey ( ) , command . clusteringIndexFilter ( ) . isReversed ( ) ) ; class Close extends Transformation { public void onPartitionClose ( ) { boolean hadNext = iter . hasNext ( ) ; iter . close ( ) ; assert ! hadNext ; } } return Transformation . apply ( toReturn , new Close ( ) ) ; } public static PartitionIterator mergeAndFilter ( List < UnfilteredPartitionIterator > iterators , int nowInSec , MergeListener listener ) { return filter ( merge ( iterators , nowInSec , listener ) , nowInSec ) ; } public static PartitionIterator filter ( final UnfilteredPartitionIterator iterator , final int nowInSec ) { return FilteredPartitions . filter ( iterator , nowInSec ) ; } public static UnfilteredPartitionIterator merge ( final List < ? extends UnfilteredPartitionIterator > iterators , final int nowInSec , final MergeListener listener ) { assert listener ! = null ; assert ! iterators . isEmpty ( ) ; final boolean isForThrift = iterators . get ( <int> ) . isForThrift ( ) ; final CFMetaData metadata = iterators . get ( <int> ) . metadata ( ) ; final MergeIterator < UnfilteredRowIterator , UnfilteredRowIterator > merged = MergeIterator . get ( iterators , partitionComparator , new MergeIterator . Reducer < UnfilteredRowIterator , UnfilteredRowIterator > ( ) { private final List < UnfilteredRowIterator > toMerge = new ArrayList < > ( iterators . size ( ) ) ; private DecoratedKey partitionKey ; private boolean isReverseOrder ; public void reduce ( int idx , UnfilteredRowIterator current ) { partitionKey = current . partitionKey ( ) ; isReverseOrder = current . isReverseOrder ( ) ; toMerge . set ( idx , current ) ; } protected UnfilteredRowIterator getReduced ( ) { UnfilteredRowIterators . MergeListener rowListener = listener . getRowMergeListener ( partitionKey , toMerge ) ; for ( int i = <int> ; i < toMerge . size ( ) ; i + + ) if ( toMerge . get ( i ) = = null ) toMerge . set ( i , EmptyIterators . unfilteredRow ( metadata , partitionKey , isReverseOrder ) ) ; return UnfilteredRowIterators . merge ( toMerge , nowInSec , rowListener ) ; } protected void onKeyChange ( ) { toMerge . clear ( ) ; for ( int i = <int> ; i < iterators . size ( ) ; i + + ) toMerge . add ( null ) ; } } ) ; return new AbstractUnfilteredPartitionIterator ( ) { public boolean isForThrift ( ) { return isForThrift ; } public CFMetaData metadata ( ) { return metadata ; } public boolean hasNext ( ) { return merged . hasNext ( ) ; } public UnfilteredRowIterator next ( ) { return merged . next ( ) ; } @Override public void close ( ) { merged . close ( ) ; } } ; } public static UnfilteredPartitionIterator mergeLazily ( final List < ? extends UnfilteredPartitionIterator > iterators , final int nowInSec ) { assert ! iterators . isEmpty ( ) ; if ( iterators . size ( ) = = <int> ) return iterators . get ( <int> ) ; final boolean isForThrift = iterators . get ( <int> ) . isForThrift ( ) ; final CFMetaData metadata = iterators . get ( <int> ) . metadata ( ) ; final MergeIterator < UnfilteredRowIterator , UnfilteredRowIterator > merged = MergeIterator . get ( iterators , partitionComparator , new MergeIterator . Reducer < UnfilteredRowIterator , UnfilteredRowIterator > ( ) { private final List < UnfilteredRowIterator > toMerge = new ArrayList < > ( iterators . size ( ) ) ; @Override public boolean trivialReduceIsTrivial ( ) { return false ; } public void reduce ( int idx , UnfilteredRowIterator current ) { toMerge . add ( current ) ; } protected UnfilteredRowIterator getReduced ( ) { return new LazilyInitializedUnfilteredRowIterator ( toMerge . get ( <int> ) . partitionKey ( ) ) { protected UnfilteredRowIterator initializeIterator ( ) { return UnfilteredRowIterators . merge ( toMerge , nowInSec ) ; } } ; } protected void onKeyChange ( ) { toMerge . clear ( ) ; } } ) ; return new AbstractUnfilteredPartitionIterator ( ) { public boolean isForThrift ( ) { return isForThrift ; } public CFMetaData metadata ( ) { return metadata ; } public boolean hasNext ( ) { return merged . hasNext ( ) ; } public UnfilteredRowIterator next ( ) { return merged . next ( ) ; } @Override public void close ( ) { merged . close ( ) ; } } ; } public static void digest ( UnfilteredPartitionIterator iterator , MessageDigest digest , int version ) { try ( UnfilteredPartitionIterator iter = iterator ) { while ( iter . hasNext ( ) ) { try ( UnfilteredRowIterator partition = iter . next ( ) ) { UnfilteredRowIterators . digest ( partition , digest , version ) ; } } } } public static Serializer serializerForIntraNode ( ) { return serializer ; } public static UnfilteredPartitionIterator loggingIterator ( UnfilteredPartitionIterator iterator , final String id , final boolean fullDetails ) { class Logging extends Transformation < UnfilteredRowIterator > { public UnfilteredRowIterator applyToPartition ( UnfilteredRowIterator partition ) { return UnfilteredRowIterators . loggingIterator ( partition , id , fullDetails ) ; } } return Transformation . apply ( iterator , new Logging ( ) ) ; } public static class Serializer { public void serialize ( UnfilteredPartitionIterator iter , ColumnFilter selection , DataOutputPlus out , int version ) throws IOException { assert version > = MessagingService . VERSION_30 ; out . writeBoolean ( iter . isForThrift ( ) ) ; while ( iter . hasNext ( ) ) { out . writeBoolean ( true ) ; try ( UnfilteredRowIterator partition = iter . next ( ) ) { UnfilteredRowIteratorSerializer . serializer . serialize ( partition , selection , out , version ) ; } } out . writeBoolean ( false ) ; } public UnfilteredPartitionIterator deserialize ( final DataInputPlus in , final int version , final CFMetaData metadata , final ColumnFilter selection , final SerializationHelper . Flag flag ) throws IOException { assert version > = MessagingService . VERSION_30 ; final boolean isForThrift = in . readBoolean ( ) ; return new AbstractUnfilteredPartitionIterator ( ) { private UnfilteredRowIterator next ; private boolean hasNext ; private boolean nextReturned = true ; public boolean isForThrift ( ) { return isForThrift ; } public CFMetaData metadata ( ) { return metadata ; } public boolean hasNext ( ) { if ( ! nextReturned ) return hasNext ; if ( next ! = null & & next . hasNext ( ) ) throw new IllegalStateException ( <str> ) ; try { hasNext = in . readBoolean ( ) ; nextReturned = false ; return hasNext ; } catch ( IOException e ) { throw new IOError ( e ) ; } } public UnfilteredRowIterator next ( ) { if ( nextReturned & & ! hasNext ( ) ) throw new NoSuchElementException ( ) ; try { nextReturned = true ; next = UnfilteredRowIteratorSerializer . serializer . deserialize ( in , version , metadata , selection , flag ) ; return next ; } catch ( IOException e ) { throw new IOError ( e ) ; } } @Override public void close ( ) { if ( next ! = null ) next . close ( ) ; } } ; } } } 
