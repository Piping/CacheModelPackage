package org . apache . cassandra . io . compress ; import java . io . FileInputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . concurrent . ThreadLocalRandom ; public class CompressorPerformance { public static void testPerformances ( ) throws IOException { for ( ICompressor compressor : new ICompressor [ ] { SnappyCompressor . instance , DeflateCompressor . instance , LZ4Compressor . instance , SnappyCompressor . instance } ) { for ( BufferType in : BufferType . values ( ) ) { if ( compressor . supports ( in ) ) { for ( BufferType out : BufferType . values ( ) ) { if ( compressor . supports ( out ) ) { for ( int i = <int> ; i < <int> ; + + i ) testPerformance ( compressor , in , out ) ; System . out . println ( ) ; } } } } } } static ByteBuffer dataSource ; static int bufLen ; private static void testPerformance ( ICompressor compressor , BufferType in , BufferType out ) throws IOException { int len = dataSource . capacity ( ) ; int bufLen = compressor . initialCompressedBufferLength ( len ) ; ByteBuffer input = in . allocate ( bufLen ) ; ByteBuffer output = out . allocate ( bufLen ) ; int checksum = <int> ; int count = <int> ; long time = System . nanoTime ( ) ; for ( int i = <int> ; i < count ; + + i ) { output . clear ( ) ; compressor . compress ( dataSource , output ) ; checksum + = output . get ( ThreadLocalRandom . current ( ) . nextInt ( output . position ( ) ) ) ; dataSource . rewind ( ) ; } long timec = System . nanoTime ( ) - time ; output . flip ( ) ; input . put ( output ) ; input . flip ( ) ; time = System . nanoTime ( ) ; for ( int i = <int> ; i < count ; + + i ) { output . clear ( ) ; compressor . uncompress ( input , output ) ; checksum + = output . get ( ThreadLocalRandom . current ( ) . nextInt ( output . position ( ) ) ) ; input . rewind ( ) ; } long timed = System . nanoTime ( ) - time ; System . out . format ( <str> , compressor . getClass ( ) . getSimpleName ( ) , in , out , <float> * timec / ( count * len ) , Math . scalb ( <float> , - <int> ) * count * len / timec , <float> * timed / ( count * len ) , Math . scalb ( <float> , - <int> ) * count * len / timed , checksum = = <int> ? <str> : <str> ) ; } public static void main ( String [ ] args ) throws IOException { try ( FileInputStream fis = new FileInputStream ( <str> ) ) { int len = ( int ) fis . getChannel ( ) . size ( ) ; dataSource = ByteBuffer . allocateDirect ( len ) ; while ( dataSource . hasRemaining ( ) ) { fis . getChannel ( ) . read ( dataSource ) ; } dataSource . flip ( ) ; } testPerformances ( ) ; } } 
