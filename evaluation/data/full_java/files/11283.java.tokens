package org . gradle . api . internal ; import groovy . lang . Closure ; import groovy . lang . MissingPropertyException ; import org . gradle . api . * ; import org . gradle . api . internal . collections . CollectionEventRegister ; import org . gradle . api . internal . collections . CollectionFilter ; import org . gradle . api . internal . plugins . DefaultConvention ; import org . gradle . api . plugins . Convention ; import org . gradle . api . plugins . ExtensionContainer ; import org . gradle . api . specs . Spec ; import org . gradle . api . specs . Specs ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . util . ConfigureUtil ; import java . util . * ; public class DefaultNamedDomainObjectCollection < T > extends DefaultDomainObjectCollection < T > implements NamedDomainObjectCollection < T > , DynamicObjectAware { private final Instantiator instantiator ; private final Namer < ? super T > namer ; private final Index < T > index ; private final ContainerElementsDynamicObject elementsDynamicObject = new ContainerElementsDynamicObject ( ) ; private final Convention convention ; private final DynamicObject dynamicObject ; private final List < Rule > rules = new ArrayList < Rule > ( ) ; private Set < String > applyingRulesFor = new HashSet < String > ( ) ; public DefaultNamedDomainObjectCollection ( Class < ? extends T > type , Collection < T > store , Instantiator instantiator , Namer < ? super T > namer ) { super ( type , store ) ; this . instantiator = instantiator ; this . convention = new DefaultConvention ( instantiator ) ; this . dynamicObject = new ExtensibleDynamicObject ( this , new ContainerDynamicObject ( elementsDynamicObject ) , convention ) ; this . namer = namer ; this . index = new UnfilteredIndex < T > ( ) ; index ( ) ; } protected void index ( ) { for ( T t : getStore ( ) ) { index . put ( namer . determineName ( t ) , t ) ; } } protected DefaultNamedDomainObjectCollection ( Class < ? extends T > type , Collection < T > store , CollectionEventRegister < T > eventRegister , Index < T > index , Instantiator instantiator , Namer < ? super T > namer ) { super ( type , store , eventRegister ) ; this . instantiator = instantiator ; this . convention = new DefaultConvention ( instantiator ) ; this . dynamicObject = new ExtensibleDynamicObject ( this , new ContainerDynamicObject ( elementsDynamicObject ) , convention ) ; this . namer = namer ; this . index = index ; } public DefaultNamedDomainObjectCollection ( DefaultNamedDomainObjectCollection < ? super T > collection , CollectionFilter < T > filter , Instantiator instantiator , Namer < ? super T > namer ) { this ( filter . getType ( ) , collection . filteredStore ( filter ) , collection . filteredEvents ( filter ) , collection . filteredIndex ( filter ) , instantiator , namer ) ; } public boolean add ( T o ) { if ( ! hasWithName ( namer . determineName ( o ) ) ) { return super . add ( o ) ; } else { handleAttemptToAddItemWithNonUniqueName ( o ) ; return false ; } } @Override protected void didAdd ( T toAdd ) { index . put ( namer . determineName ( toAdd ) , toAdd ) ; } @Override public void clear ( ) { super . clear ( ) ; index . clear ( ) ; } @Override protected void didRemove ( T t ) { index . remove ( namer . determineName ( t ) ) ; } protected void handleAttemptToAddItemWithNonUniqueName ( T o ) { } protected void assertCanAdd ( String name ) { if ( hasWithName ( name ) ) { throw new InvalidUserDataException ( String . format ( <str> , getTypeDisplayName ( ) , name , getTypeDisplayName ( ) ) ) ; } } protected void assertCanAdd ( T t ) { assertCanAdd ( getNamer ( ) . determineName ( t ) ) ; } public Namer < T > getNamer ( ) { return ( Namer ) this . namer ; } protected Instantiator getInstantiator ( ) { return instantiator ; } protected < S extends T > Index < S > filteredIndex ( CollectionFilter < S > filter ) { return index . filter ( filter ) ; } protected < S extends T > DefaultNamedDomainObjectCollection < S > filtered ( CollectionFilter < S > filter ) { return instantiator . newInstance ( DefaultNamedDomainObjectCollection . class , this , filter , instantiator , namer ) ; } public String getDisplayName ( ) { return String . format ( <str> , getTypeDisplayName ( ) ) ; } public SortedMap < String , T > getAsMap ( ) { return index . asMap ( ) ; } public SortedSet < String > getNames ( ) { return index . asMap ( ) . navigableKeySet ( ) ; } public < S extends T > NamedDomainObjectCollection < S > withType ( Class < S > type ) { return filtered ( createFilter ( type ) ) ; } public NamedDomainObjectCollection < T > matching ( Spec < ? super T > spec ) { return filtered ( createFilter ( spec ) ) ; } public NamedDomainObjectCollection < T > matching ( Closure spec ) { return matching ( Specs . < T > convertClosureToSpec ( spec ) ) ; } public T findByName ( String name ) { T value = findByNameWithoutRules ( name ) ; if ( value ! = null ) { return value ; } applyRules ( name ) ; return findByNameWithoutRules ( name ) ; } protected boolean hasWithName ( String name ) { return findByNameWithoutRules ( name ) ! = null ; } protected T findByNameWithoutRules ( String name ) { return index . get ( name ) ; } protected T removeByName ( String name ) { T it = getByName ( name ) ; if ( it ! = null ) { if ( remove ( it ) ) { return it ; } else { throw new IllegalStateException ( String . format ( <str> , it , name ) ) ; } } else { return null ; } } public T getByName ( String name ) throws UnknownDomainObjectException { T t = findByName ( name ) ; if ( t = = null ) { throw createNotFoundException ( name ) ; } return t ; } public T getByName ( String name , Closure configureClosure ) throws UnknownDomainObjectException { T t = getByName ( name ) ; ConfigureUtil . configure ( configureClosure , t ) ; return t ; } public T getAt ( String name ) throws UnknownDomainObjectException { return getByName ( name ) ; } public DynamicObject getAsDynamicObject ( ) { return dynamicObject ; } public Convention getConvention ( ) { return convention ; } public ExtensionContainer getExtensions ( ) { return convention ; } protected DynamicObject getElementsAsDynamicObject ( ) { return elementsDynamicObject ; } private void applyRules ( String name ) { if ( applyingRulesFor . contains ( name ) ) { return ; } applyingRulesFor . add ( name ) ; try { for ( Rule rule : rules ) { rule . apply ( name ) ; } } finally { applyingRulesFor . remove ( name ) ; } } public Rule addRule ( Rule rule ) { rules . add ( rule ) ; return rule ; } public Rule addRule ( final String description , final Closure ruleAction ) { Rule rule = new Rule ( ) { public String getDescription ( ) { return description ; } public void apply ( String taskName ) { ruleAction . call ( taskName ) ; } @Override public String toString ( ) { return <str> + description ; } } ; rules . add ( rule ) ; return rule ; } public List < Rule > getRules ( ) { return Collections . unmodifiableList ( rules ) ; } protected UnknownDomainObjectException createNotFoundException ( String name ) { return new UnknownDomainObjectException ( String . format ( <str> , getTypeDisplayName ( ) , name ) ) ; } protected String getTypeDisplayName ( ) { return getType ( ) . getSimpleName ( ) ; } private class ContainerDynamicObject extends CompositeDynamicObject { private ContainerDynamicObject ( ContainerElementsDynamicObject elementsDynamicObject ) { setObjects ( new BeanDynamicObject ( DefaultNamedDomainObjectCollection . this ) , elementsDynamicObject , convention . getExtensionsAsDynamicObject ( ) ) ; } @Override protected String getDisplayName ( ) { return DefaultNamedDomainObjectCollection . this . getDisplayName ( ) ; } } private class ContainerElementsDynamicObject extends AbstractDynamicObject { @Override protected String getDisplayName ( ) { return DefaultNamedDomainObjectCollection . this . getDisplayName ( ) ; } @Override public boolean hasProperty ( String name ) { return findByName ( name ) ! = null ; } @Override public T getProperty ( String name ) throws MissingPropertyException { T t = findByName ( name ) ; if ( t = = null ) { return ( T ) super . getProperty ( name ) ; } return t ; } @Override public Map < String , T > getProperties ( ) { return getAsMap ( ) ; } @Override public boolean hasMethod ( String name , Object . . . arguments ) { return isConfigureMethod ( name , arguments ) ; } @Override public Object invokeMethod ( String name , Object . . . arguments ) throws groovy . lang . MissingMethodException { if ( isConfigureMethod ( name , arguments ) ) { return ConfigureUtil . configure ( ( Closure ) arguments [ <int> ] , getByName ( name ) ) ; } else { return super . invokeMethod ( name , arguments ) ; } } private boolean isConfigureMethod ( String name , Object . . . arguments ) { return ( arguments . length = = <int> & & arguments [ <int> ] instanceof Closure ) & & hasProperty ( name ) ; } } protected static interface Index < T > { void put ( String name , T value ) ; T get ( String name ) ; void remove ( String name ) ; void clear ( ) ; NavigableMap < String , T > asMap ( ) ; < S extends T > Index < S > filter ( CollectionFilter < S > filter ) ; } protected static class UnfilteredIndex < T > implements Index < T > { private final NavigableMap < String , T > map = new TreeMap < String , T > ( ) ; @Override public NavigableMap < String , T > asMap ( ) { return map ; } @Override public void put ( String name , T value ) { map . put ( name , value ) ; } @Override public T get ( String name ) { return map . get ( name ) ; } @Override public void remove ( String name ) { map . remove ( name ) ; } @Override public void clear ( ) { map . clear ( ) ; } @Override public < S extends T > Index < S > filter ( CollectionFilter < S > filter ) { return new FilteredIndex < S > ( this , filter ) ; } } private static class FilteredIndex < T > implements Index < T > { private final Index < ? super T > delegate ; private final CollectionFilter < T > filter ; public FilteredIndex ( Index < ? super T > delegate , CollectionFilter < T > filter ) { this . delegate = delegate ; this . filter = filter ; } @Override public void put ( String name , T value ) { throw new UnsupportedOperationException ( ) ; } @Override public T get ( String name ) { return filter . filter ( delegate . get ( name ) ) ; } @Override public void remove ( String name ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override public NavigableMap < String , T > asMap ( ) { NavigableMap < String , ? super T > delegateMap = delegate . asMap ( ) ; NavigableMap < String , T > filtered = new TreeMap < String , T > ( ) ; for ( Map . Entry < String , ? super T > entry : delegateMap . entrySet ( ) ) { T obj = filter . filter ( entry . getValue ( ) ) ; if ( obj ! = null ) { filtered . put ( entry . getKey ( ) , obj ) ; } } return filtered ; } @Override public < S extends T > Index < S > filter ( CollectionFilter < S > filter ) { return new FilteredIndex < S > ( delegate , this . filter . and ( filter ) ) ; } } } 
