package org . apache . cassandra . transport ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . Map ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . BatchQueryOptions ; import org . apache . cassandra . cql3 . CQLStatement ; import org . apache . cassandra . cql3 . QueryHandler ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . statements . BatchStatement ; import org . apache . cassandra . cql3 . statements . ParsedStatement ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . messages . BatchMessage ; import org . apache . cassandra . transport . messages . ExecuteMessage ; import org . apache . cassandra . transport . messages . PrepareMessage ; import org . apache . cassandra . transport . messages . QueryMessage ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . MD5Digest ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public class MessagePayloadTest extends CQLTester { public static Map < String , ByteBuffer > requestPayload ; public static Map < String , ByteBuffer > responsePayload ; private static Field cqlQueryHandlerField ; private static boolean modifiersAccessible ; @BeforeClass public static void makeCqlQueryHandlerAccessible ( ) { try { cqlQueryHandlerField = ClientState . class . getDeclaredField ( <str> ) ; cqlQueryHandlerField . setAccessible ( true ) ; Field modifiersField = Field . class . getDeclaredField ( <str> ) ; modifiersAccessible = modifiersField . isAccessible ( ) ; modifiersField . setAccessible ( true ) ; modifiersField . setInt ( cqlQueryHandlerField , cqlQueryHandlerField . getModifiers ( ) & ~ Modifier . FINAL ) ; } catch ( IllegalAccessException | NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } @AfterClass public static void resetCqlQueryHandlerField ( ) { if ( cqlQueryHandlerField = = null ) return ; try { Field modifiersField = Field . class . getDeclaredField ( <str> ) ; modifiersField . setAccessible ( true ) ; modifiersField . setInt ( cqlQueryHandlerField , cqlQueryHandlerField . getModifiers ( ) | Modifier . FINAL ) ; cqlQueryHandlerField . setAccessible ( false ) ; modifiersField . setAccessible ( modifiersAccessible ) ; } catch ( IllegalAccessException | NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } @After public void dropCreatedTable ( ) { try { QueryProcessor . executeOnceInternal ( <str> + KEYSPACE + <str> ) ; } catch ( Throwable t ) { } } @Test public void testMessagePayload ( ) throws Throwable { QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; try { requireNetwork ( ) ; Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , nativePort ) ; try { client . connect ( false ) ; Map < String , ByteBuffer > reqMap ; Map < String , ByteBuffer > respMap ; QueryMessage queryMessage = new QueryMessage ( <str> + KEYSPACE + <str> , QueryOptions . DEFAULT ) ; PrepareMessage prepareMessage = new PrepareMessage ( <str> + KEYSPACE + <str> ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = respMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; queryMessage . setCustomPayload ( reqMap ) ; Message . Response queryResponse = client . execute ( queryMessage ) ; payloadEquals ( reqMap , requestPayload ) ; payloadEquals ( respMap , queryResponse . getCustomPayload ( ) ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = respMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; prepareMessage . setCustomPayload ( reqMap ) ; ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; payloadEquals ( reqMap , requestPayload ) ; payloadEquals ( respMap , prepareResponse . getCustomPayload ( ) ) ; ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = respMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; executeMessage . setCustomPayload ( reqMap ) ; Message . Response executeResponse = client . execute ( executeMessage ) ; payloadEquals ( reqMap , requestPayload ) ; payloadEquals ( respMap , executeResponse . getCustomPayload ( ) ) ; BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , Collections . < Object > singletonList ( <str> + KEYSPACE + <str> ) , Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , QueryOptions . DEFAULT ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = respMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; batchMessage . setCustomPayload ( reqMap ) ; Message . Response batchResponse = client . execute ( batchMessage ) ; payloadEquals ( reqMap , requestPayload ) ; payloadEquals ( respMap , batchResponse . getCustomPayload ( ) ) ; } finally { client . close ( ) ; } } finally { cqlQueryHandlerField . set ( null , queryHandler ) ; } } @Test public void testMessagePayloadVersion3 ( ) throws Throwable { QueryHandler queryHandler = ( QueryHandler ) cqlQueryHandlerField . get ( null ) ; cqlQueryHandlerField . set ( null , new TestQueryHandler ( ) ) ; try { requireNetwork ( ) ; Assert . assertSame ( TestQueryHandler . class , ClientState . getCQLQueryHandler ( ) . getClass ( ) ) ; SimpleClient client = new SimpleClient ( nativeAddr . getHostAddress ( ) , nativePort , Server . VERSION_3 ) ; try { client . connect ( false ) ; Map < String , ByteBuffer > reqMap ; QueryMessage queryMessage = new QueryMessage ( <str> + KEYSPACE + <str> , QueryOptions . DEFAULT ) ; PrepareMessage prepareMessage = new PrepareMessage ( <str> + KEYSPACE + <str> ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; queryMessage . setCustomPayload ( reqMap ) ; try { client . execute ( queryMessage ) ; Assert . fail ( ) ; } catch ( RuntimeException e ) { Assert . assertTrue ( e . getCause ( ) instanceof ProtocolException ) ; } queryMessage . setCustomPayload ( null ) ; client . execute ( queryMessage ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; prepareMessage . setCustomPayload ( reqMap ) ; try { client . execute ( prepareMessage ) ; Assert . fail ( ) ; } catch ( RuntimeException e ) { Assert . assertTrue ( e . getCause ( ) instanceof ProtocolException ) ; } prepareMessage . setCustomPayload ( null ) ; ResultMessage . Prepared prepareResponse = ( ResultMessage . Prepared ) client . execute ( prepareMessage ) ; ExecuteMessage executeMessage = new ExecuteMessage ( prepareResponse . statementId , QueryOptions . DEFAULT ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; executeMessage . setCustomPayload ( reqMap ) ; try { client . execute ( executeMessage ) ; Assert . fail ( ) ; } catch ( RuntimeException e ) { Assert . assertTrue ( e . getCause ( ) instanceof ProtocolException ) ; } BatchMessage batchMessage = new BatchMessage ( BatchStatement . Type . UNLOGGED , Collections . < Object > singletonList ( <str> + KEYSPACE + <str> ) , Collections . singletonList ( Collections . < ByteBuffer > emptyList ( ) ) , QueryOptions . DEFAULT ) ; reqMap = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; responsePayload = Collections . singletonMap ( <str> , bytes ( <int> ) ) ; batchMessage . setCustomPayload ( reqMap ) ; try { client . execute ( batchMessage ) ; Assert . fail ( ) ; } catch ( RuntimeException e ) { Assert . assertTrue ( e . getCause ( ) instanceof ProtocolException ) ; } } finally { client . close ( ) ; } } finally { cqlQueryHandlerField . set ( null , queryHandler ) ; } } private static void payloadEquals ( Map < String , ByteBuffer > map1 , Map < String , ByteBuffer > map2 ) { Assert . assertNotNull ( map1 ) ; Assert . assertNotNull ( map2 ) ; Assert . assertEquals ( map1 . keySet ( ) , map2 . keySet ( ) ) ; for ( Map . Entry < String , ByteBuffer > e : map1 . entrySet ( ) ) Assert . assertEquals ( e . getValue ( ) , map2 . get ( e . getKey ( ) ) ) ; } public static class TestQueryHandler implements QueryHandler { public ParsedStatement . Prepared getPrepared ( MD5Digest id ) { return QueryProcessor . instance . getPrepared ( id ) ; } public ParsedStatement . Prepared getPreparedForThrift ( Integer id ) { return QueryProcessor . instance . getPreparedForThrift ( id ) ; } public ResultMessage . Prepared prepare ( String query , QueryState state , Map < String , ByteBuffer > customPayload ) throws RequestValidationException { if ( customPayload ! = null ) requestPayload = customPayload ; ResultMessage . Prepared result = QueryProcessor . instance . prepare ( query , state , customPayload ) ; if ( customPayload ! = null ) { result . setCustomPayload ( responsePayload ) ; responsePayload = null ; } return result ; } public ResultMessage process ( String query , QueryState state , QueryOptions options , Map < String , ByteBuffer > customPayload ) throws RequestExecutionException , RequestValidationException { if ( customPayload ! = null ) requestPayload = customPayload ; ResultMessage result = QueryProcessor . instance . process ( query , state , options , customPayload ) ; if ( customPayload ! = null ) { result . setCustomPayload ( responsePayload ) ; responsePayload = null ; } return result ; } public ResultMessage processBatch ( BatchStatement statement , QueryState state , BatchQueryOptions options , Map < String , ByteBuffer > customPayload ) throws RequestExecutionException , RequestValidationException { if ( customPayload ! = null ) requestPayload = customPayload ; ResultMessage result = QueryProcessor . instance . processBatch ( statement , state , options , customPayload ) ; if ( customPayload ! = null ) { result . setCustomPayload ( responsePayload ) ; responsePayload = null ; } return result ; } public ResultMessage processPrepared ( CQLStatement statement , QueryState state , QueryOptions options , Map < String , ByteBuffer > customPayload ) throws RequestExecutionException , RequestValidationException { if ( customPayload ! = null ) requestPayload = customPayload ; ResultMessage result = QueryProcessor . instance . processPrepared ( statement , state , options , customPayload ) ; if ( customPayload ! = null ) { result . setCustomPayload ( responsePayload ) ; responsePayload = null ; } return result ; } } } 
