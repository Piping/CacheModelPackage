package com . google . common . util . concurrent ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . TearDownStack ; import junit . framework . TestCase ; import java . util . Random ; import java . util . concurrent . TimeUnit ; public abstract class MonitorTestCase extends TestCase { public class TestGuard extends Monitor . Guard { private volatile boolean satisfied ; public TestGuard ( boolean satisfied ) { super ( MonitorTestCase . this . monitor ) ; this . satisfied = satisfied ; } @Override public boolean isSatisfied ( ) { return this . satisfied ; } public void setSatisfied ( boolean satisfied ) { this . satisfied = satisfied ; } } private final boolean interruptible ; private Monitor monitor ; private final TearDownStack tearDownStack = new TearDownStack ( true ) ; private TestThread < Monitor > thread1 ; private TestThread < Monitor > thread2 ; protected MonitorTestCase ( boolean interruptible ) { this . interruptible = interruptible ; } @Override protected final void setUp ( ) throws Exception { boolean fair = new Random ( ) . nextBoolean ( ) ; monitor = new Monitor ( fair ) ; tearDownStack . addTearDown ( thread1 = new TestThread < Monitor > ( monitor , <str> ) ) ; tearDownStack . addTearDown ( thread2 = new TestThread < Monitor > ( monitor , <str> ) ) ; } @Override protected final void tearDown ( ) { tearDownStack . runTearDown ( ) ; } private String enter ( ) { return interruptible ? <str> : <str> ; } private String tryEnter ( ) { return <str> ; } private String enterIf ( ) { return interruptible ? <str> : <str> ; } private String tryEnterIf ( ) { return <str> ; } private String enterWhen ( ) { return interruptible ? <str> : <str> ; } private String waitFor ( ) { return interruptible ? <str> : <str> ; } private String leave ( ) { return <str> ; } public final void testMutualExclusion ( ) throws Exception { thread1 . callAndAssertReturns ( enter ( ) ) ; thread2 . callAndAssertBlocks ( enter ( ) ) ; thread1 . callAndAssertReturns ( leave ( ) ) ; thread2 . assertPriorCallReturns ( enter ( ) ) ; } public final void testTryEnter ( ) throws Exception { thread1 . callAndAssertReturns ( true , tryEnter ( ) ) ; thread2 . callAndAssertReturns ( false , tryEnter ( ) ) ; thread1 . callAndAssertReturns ( true , tryEnter ( ) ) ; thread2 . callAndAssertReturns ( false , tryEnter ( ) ) ; thread1 . callAndAssertReturns ( leave ( ) ) ; thread2 . callAndAssertReturns ( false , tryEnter ( ) ) ; thread1 . callAndAssertReturns ( leave ( ) ) ; thread2 . callAndAssertReturns ( true , tryEnter ( ) ) ; } public final void testSystemStateMethods ( ) throws Exception { checkSystemStateMethods ( <int> ) ; thread1 . callAndAssertReturns ( enter ( ) ) ; checkSystemStateMethods ( <int> ) ; thread1 . callAndAssertReturns ( enter ( ) ) ; checkSystemStateMethods ( <int> ) ; thread1 . callAndAssertReturns ( leave ( ) ) ; checkSystemStateMethods ( <int> ) ; thread1 . callAndAssertReturns ( leave ( ) ) ; checkSystemStateMethods ( <int> ) ; } private void checkSystemStateMethods ( int enterCount ) throws Exception { thread1 . callAndAssertReturns ( enterCount ! = <int> , <str> ) ; thread1 . callAndAssertReturns ( enterCount ! = <int> , <str> ) ; thread1 . callAndAssertReturns ( enterCount , <str> ) ; thread2 . callAndAssertReturns ( enterCount ! = <int> , <str> ) ; thread2 . callAndAssertReturns ( false , <str> ) ; thread2 . callAndAssertReturns ( <int> , <str> ) ; } public final void testEnterWhen_initiallyTrue ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread1 . callAndAssertReturns ( enterWhen ( ) , guard ) ; } public final void testEnterWhen_initiallyFalse ( ) throws Exception { TestGuard guard = new TestGuard ( false ) ; thread1 . callAndAssertWaits ( enterWhen ( ) , guard ) ; monitor . enter ( ) ; guard . setSatisfied ( true ) ; monitor . leave ( ) ; thread1 . assertPriorCallReturns ( enterWhen ( ) ) ; } public final void testEnterWhen_alreadyOccupied ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread2 . callAndAssertReturns ( enter ( ) ) ; thread1 . callAndAssertBlocks ( enterWhen ( ) , guard ) ; thread2 . callAndAssertReturns ( leave ( ) ) ; thread1 . assertPriorCallReturns ( enterWhen ( ) ) ; } public final void testEnterIf_initiallyTrue ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread1 . callAndAssertReturns ( true , enterIf ( ) , guard ) ; thread2 . callAndAssertBlocks ( enter ( ) ) ; } public final void testEnterIf_initiallyFalse ( ) throws Exception { TestGuard guard = new TestGuard ( false ) ; thread1 . callAndAssertReturns ( false , enterIf ( ) , guard ) ; thread2 . callAndAssertReturns ( enter ( ) ) ; } public final void testEnterIf_alreadyOccupied ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread2 . callAndAssertReturns ( enter ( ) ) ; thread1 . callAndAssertBlocks ( enterIf ( ) , guard ) ; thread2 . callAndAssertReturns ( leave ( ) ) ; thread1 . assertPriorCallReturns ( true , enterIf ( ) ) ; } public final void testTryEnterIf_initiallyTrue ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread1 . callAndAssertReturns ( true , tryEnterIf ( ) , guard ) ; thread2 . callAndAssertBlocks ( enter ( ) ) ; } public final void testTryEnterIf_initiallyFalse ( ) throws Exception { TestGuard guard = new TestGuard ( false ) ; thread1 . callAndAssertReturns ( false , tryEnterIf ( ) , guard ) ; thread2 . callAndAssertReturns ( enter ( ) ) ; } public final void testTryEnterIf_alreadyOccupied ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread2 . callAndAssertReturns ( enter ( ) ) ; thread1 . callAndAssertReturns ( false , tryEnterIf ( ) , guard ) ; } public final void testWaitFor_initiallyTrue ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread1 . callAndAssertReturns ( enter ( ) ) ; thread1 . callAndAssertReturns ( waitFor ( ) , guard ) ; } public final void testWaitFor_initiallyFalse ( ) throws Exception { TestGuard guard = new TestGuard ( false ) ; thread1 . callAndAssertReturns ( enter ( ) ) ; thread1 . callAndAssertWaits ( waitFor ( ) , guard ) ; monitor . enter ( ) ; guard . setSatisfied ( true ) ; monitor . leave ( ) ; thread1 . assertPriorCallReturns ( waitFor ( ) ) ; } public final void testWaitFor_withoutEnter ( ) throws Exception { TestGuard guard = new TestGuard ( true ) ; thread1 . callAndAssertThrows ( IllegalMonitorStateException . class , waitFor ( ) , guard ) ; } public void testNulls ( ) { monitor . enter ( ) ; new NullPointerTester ( ) . setDefault ( TimeUnit . class , TimeUnit . SECONDS ) . setDefault ( Monitor . Guard . class , new TestGuard ( true ) ) . testAllPublicInstanceMethods ( monitor ) ; } } 
