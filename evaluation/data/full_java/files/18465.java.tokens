package com . badlogic . gdx . tests ; import java . util . Random ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class CullTest extends GdxTest implements ApplicationListener { Model sphere ; Camera cam ; SpriteBatch batch ; ModelBatch modelBatch ; BitmapFont font ; ModelInstance [ ] instances = new ModelInstance [ <int> ] ; final Vector3 pos = new Vector3 ( ) ; @Override public void create ( ) { ModelBuilder builder = new ModelBuilder ( ) ; sphere = builder . createSphere ( <float> , <float> , <float> , <int> , <int> , new Material ( new ColorAttribute ( ColorAttribute . Diffuse , Color . WHITE ) ) , Usage . Position | Usage . Normal ) ; cam = new OrthographicCamera ( <int> , <int> * ( Gdx . graphics . getWidth ( ) / ( float ) Gdx . graphics . getHeight ( ) ) ) ; cam . near = <int> ; cam . far = <int> ; Random rand = new Random ( ) ; for ( int i = <int> ; i < instances . length ; i + + ) { pos . set ( rand . nextFloat ( ) * <int> - rand . nextFloat ( ) * <int> , rand . nextFloat ( ) * <int> - rand . nextFloat ( ) * <int> , rand . nextFloat ( ) * - <int> - <int> ) ; instances [ i ] = new ModelInstance ( sphere , pos ) ; } modelBatch = new ModelBatch ( ) ; batch = new SpriteBatch ( ) ; font = new BitmapFont ( ) ; } @Override public void render ( ) { GL20 gl = Gdx . gl20 ; gl . glClearColor ( <int> , <int> , <int> , <int> ) ; gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; gl . glEnable ( GL20 . GL_DEPTH_TEST ) ; cam . update ( ) ; modelBatch . begin ( cam ) ; int visible = <int> ; for ( int i = <int> ; i < instances . length ; i + + ) { instances [ i ] . transform . getTranslation ( pos ) ; if ( cam . frustum . sphereInFrustum ( pos , <int> ) ) { ( ( ColorAttribute ) instances [ i ] . materials . get ( <int> ) . get ( ColorAttribute . Diffuse ) ) . color . set ( Color . WHITE ) ; visible + + ; } else { ( ( ColorAttribute ) instances [ i ] . materials . get ( <int> ) . get ( ColorAttribute . Diffuse ) ) . color . set ( Color . RED ) ; } modelBatch . render ( instances [ i ] ) ; } modelBatch . end ( ) ; if ( Gdx . input . isKeyPressed ( Keys . A ) ) cam . rotate ( <int> * Gdx . graphics . getDeltaTime ( ) , <int> , <int> , <int> ) ; if ( Gdx . input . isKeyPressed ( Keys . D ) ) cam . rotate ( - <int> * Gdx . graphics . getDeltaTime ( ) , <int> , <int> , <int> ) ; gl . glDisable ( GL20 . GL_DEPTH_TEST ) ; batch . begin ( ) ; font . draw ( batch , <str> + visible + <str> + <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; batch . end ( ) ; } @Override public void dispose ( ) { batch . dispose ( ) ; font . dispose ( ) ; sphere . dispose ( ) ; } } 
