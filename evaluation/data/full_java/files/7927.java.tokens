package org . elasticsearch . common . io . stream ; import org . elasticsearch . common . bytes . ByteBufferBytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; public class StreamTests extends ESTestCase { public void testRandomVLongSerialization ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { long write = randomLong ( ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeZLong ( write ) ; long read = out . bytes ( ) . streamInput ( ) . readZLong ( ) ; assertEquals ( write , read ) ; } } public void testSpecificVLongSerialization ( ) throws IOException { List < Tuple < Long , byte [ ] > > values = Arrays . asList ( new Tuple < > ( <int> L , new byte [ ] { <int> } ) , new Tuple < > ( - <int> , new byte [ ] { <int> } ) , new Tuple < > ( <int> , new byte [ ] { <int> } ) , new Tuple < > ( - <int> , new byte [ ] { <int> } ) , new Tuple < > ( <int> , new byte [ ] { <int> } ) , new Tuple < > ( Long . MIN_VALUE , new byte [ ] { - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> } ) , new Tuple < > ( Long . MAX_VALUE , new byte [ ] { - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> } ) ) ; for ( Tuple < Long , byte [ ] > value : values ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeZLong ( value . v1 ( ) ) ; assertArrayEquals ( Long . toString ( value . v1 ( ) ) , value . v2 ( ) , out . bytes ( ) . toBytes ( ) ) ; ByteBufferBytesReference bytes = new ByteBufferBytesReference ( ByteBuffer . wrap ( value . v2 ( ) ) ) ; assertEquals ( Arrays . toString ( value . v2 ( ) ) , ( long ) value . v1 ( ) , bytes . streamInput ( ) . readZLong ( ) ) ; } } public void testLinkedHashMap ( ) throws IOException { int size = randomIntBetween ( <int> , <int> ) ; boolean accessOrder = randomBoolean ( ) ; List < Tuple < String , Integer > > list = new ArrayList < > ( size ) ; LinkedHashMap < String , Integer > write = new LinkedHashMap < > ( size , <float> , accessOrder ) ; for ( int i = <int> ; i < size ; i + + ) { int value = randomInt ( ) ; list . add ( new Tuple < > ( Integer . toString ( i ) , value ) ) ; write . put ( Integer . toString ( i ) , value ) ; } if ( accessOrder ) { Collections . shuffle ( list , random ( ) ) ; for ( Tuple < String , Integer > entry : list ) { write . get ( entry . v1 ( ) ) ; } } BytesStreamOutput out = new BytesStreamOutput ( ) ; out . writeGenericValue ( write ) ; LinkedHashMap < String , Integer > read = ( LinkedHashMap < String , Integer > ) out . bytes ( ) . streamInput ( ) . readGenericValue ( ) ; assertEquals ( size , read . size ( ) ) ; int index = <int> ; for ( Map . Entry < String , Integer > entry : read . entrySet ( ) ) { assertEquals ( list . get ( index ) . v1 ( ) , entry . getKey ( ) ) ; assertEquals ( list . get ( index ) . v2 ( ) , entry . getValue ( ) ) ; index + + ; } } } 
