package org . eclipse . debug . internal . ui . elements . adapters ; import java . math . BigInteger ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . DebugPluginImages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . memory . provisional . AbstractAsyncTableRendering ; import org . eclipse . debug . internal . ui . memory . provisional . MemoryViewPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . provisional . AsynchronousLabelAdapter ; import org . eclipse . debug . internal . ui . views . launch . DebugElementHelper ; import org . eclipse . debug . internal . ui . views . memory . renderings . AbstractBaseTableRendering ; import org . eclipse . debug . internal . ui . views . memory . renderings . MemorySegment ; import org . eclipse . debug . internal . ui . views . memory . renderings . TableRenderingContentDescriptor ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . memory . IMemoryBlockTablePresentation ; import org . eclipse . debug . ui . memory . MemoryRenderingElement ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . IColorProvider ; import org . eclipse . jface . viewers . IFontProvider ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; public class MemorySegmentLabelAdapter extends AsynchronousLabelAdapter { @Override protected String [ ] getLabels ( Object element , IPresentationContext context ) throws CoreException { if ( context instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext tableRenderingContext = ( MemoryViewPresentationContext ) context ; if ( tableRenderingContext . getRendering ( ) ! = null & & tableRenderingContext . getRendering ( ) instanceof AbstractAsyncTableRendering ) { AbstractAsyncTableRendering tableRendering = ( AbstractAsyncTableRendering ) tableRenderingContext . getRendering ( ) ; TableRenderingContentDescriptor descriptor = tableRendering . getAdapter ( TableRenderingContentDescriptor . class ) ; if ( descriptor ! = null ) { String addressStr = getColumnText ( element , <int> , tableRendering , descriptor ) ; int numColumns = tableRendering . getAddressableUnitPerLine ( ) / tableRendering . getAddressableUnitPerColumn ( ) ; String [ ] labels = new String [ numColumns + <int> ] ; labels [ <int> ] = addressStr ; for ( int i = <int> ; i < = numColumns ; i + + ) { labels [ i + <int> ] = getColumnText ( element , i + <int> , tableRendering , tableRendering . getAdapter ( TableRenderingContentDescriptor . class ) ) ; } labels [ labels . length - <int> ] = IInternalDebugCoreConstants . EMPTY_STRING ; return labels ; } } } return new String [ <int> ] ; } private String getColumnText ( Object element , int columnIndex , AbstractAsyncTableRendering tableRendering , TableRenderingContentDescriptor descriptor ) { String columnLabel = null ; if ( columnIndex = = <int> ) { IMemoryBlockTablePresentation presentation = tableRendering . getMemoryBlock ( ) . getAdapter ( IMemoryBlockTablePresentation . class ) ; if ( presentation ! = null ) { String rowLabel = presentation . getRowLabel ( tableRendering . getMemoryBlock ( ) , ( ( MemorySegment ) element ) . getAddress ( ) ) ; if ( rowLabel ! = null ) return rowLabel ; } columnLabel = ( ( MemorySegment ) element ) . getAddress ( ) . toString ( <int> ) . toUpperCase ( ) ; int addressSize = descriptor . getAddressSize ( ) ; int prefillLength = addressSize * <int> - columnLabel . length ( ) ; StringBuffer buf = new StringBuffer ( ) ; if ( prefillLength > <int> ) { for ( int i = <int> ; i < prefillLength ; i + + ) { buf . append ( <str> ) ; } } buf . append ( columnLabel ) ; return buf . toString ( ) ; } else if ( columnIndex > ( tableRendering . getBytesPerLine ( ) / tableRendering . getBytesPerColumn ( ) ) ) { columnLabel = <str> ; } else { if ( element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; if ( segment . getBytes ( ) . length ! = tableRendering . getBytesPerLine ( ) ) return IInternalDebugCoreConstants . EMPTY_STRING ; } ILabelProvider labelProvider = tableRendering . getAdapter ( ILabelProvider . class ) ; if ( labelProvider ! = null & & columnIndex > <int> ) { MemoryRenderingElement renderingElement = getMemoryRenderingElement ( element , columnIndex , tableRendering ) ; if ( renderingElement ! = null ) { String label = labelProvider . getText ( renderingElement ) ; if ( label ! = null ) return label ; } } int start = ( columnIndex - <int> ) * tableRendering . getBytesPerColumn ( ) ; MemoryByte [ ] bytes = ( ( MemorySegment ) element ) . getBytes ( start , tableRendering . getBytesPerColumn ( ) ) ; BigInteger address = ( ( MemorySegment ) element ) . getAddress ( ) ; address = address . add ( BigInteger . valueOf ( start ) ) ; columnLabel = tableRendering . getString ( tableRendering . getRenderingId ( ) , address , bytes ) ; } return columnLabel ; } @Override protected ImageDescriptor [ ] getImageDescriptors ( Object element , IPresentationContext context ) throws CoreException { if ( context instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext tableRenderingContext = ( MemoryViewPresentationContext ) context ; if ( tableRenderingContext . getRendering ( ) ! = null & & tableRenderingContext . getRendering ( ) instanceof AbstractAsyncTableRendering ) { AbstractAsyncTableRendering tableRendering = ( AbstractAsyncTableRendering ) tableRenderingContext . getRendering ( ) ; int numColumns = tableRendering . getAddressableUnitPerLine ( ) / tableRendering . getAddressableUnitPerColumn ( ) ; ImageDescriptor [ ] images = new ImageDescriptor [ numColumns + <int> ] ; for ( int i = <int> ; i < = numColumns ; i + + ) { images [ i ] = getColumnImageDescriptor ( element , i , tableRendering ) ; } images [ images . length - <int> ] = null ; return images ; } } return new ImageDescriptor [ <int> ] ; } private ImageDescriptor getColumnImageDescriptor ( Object element , int columnIndex , AbstractAsyncTableRendering tableRendering ) { if ( columnIndex = = <int> ) return DebugPluginImages . getImageDescriptor ( IInternalDebugUIConstants . IMG_OBJECT_MEMORY ) ; if ( element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; if ( segment . getBytes ( ) . length ! = tableRendering . getBytesPerLine ( ) ) return null ; ILabelProvider labelProvider = tableRendering . getAdapter ( ILabelProvider . class ) ; if ( labelProvider ! = null & & columnIndex > <int> ) { MemoryRenderingElement renderingElement = getMemoryRenderingElement ( element , columnIndex , tableRendering ) ; if ( renderingElement ! = null ) { Image image = labelProvider . getImage ( renderingElement ) ; if ( image ! = null ) { return DebugElementHelper . getImageDescriptor ( image ) ; } } } int start = ( columnIndex - <int> ) * tableRendering . getBytesPerColumn ( ) ; MemoryByte [ ] bytes = ( ( MemorySegment ) element ) . getBytes ( start , tableRendering . getBytesPerColumn ( ) ) ; boolean allKnown = true ; boolean unchanged = true ; for ( int i = <int> ; i < bytes . length ; i + + ) { if ( ! bytes [ i ] . isHistoryKnown ( ) ) allKnown = false ; if ( bytes [ i ] . isChanged ( ) ) unchanged = false ; } if ( allKnown ) { if ( ! unchanged ) return DebugPluginImages . getImageDescriptor ( IInternalDebugUIConstants . IMG_OBJECT_MEMORY_CHANGED ) ; } } return DebugPluginImages . getImageDescriptor ( IInternalDebugUIConstants . IMG_OBJECT_MEMORY ) ; } @Override protected FontData [ ] getFontDatas ( Object element , IPresentationContext context ) throws CoreException { if ( context instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext tableRenderingContext = ( MemoryViewPresentationContext ) context ; if ( tableRenderingContext . getRendering ( ) ! = null & & tableRenderingContext . getRendering ( ) instanceof AbstractAsyncTableRendering ) { AbstractAsyncTableRendering tableRendering = ( AbstractAsyncTableRendering ) tableRenderingContext . getRendering ( ) ; int numColumns = tableRendering . getAddressableUnitPerLine ( ) / tableRendering . getAddressableUnitPerColumn ( ) ; FontData [ ] fontData = new FontData [ numColumns + <int> ] ; for ( int i = <int> ; i < fontData . length - <int> ; i + + ) { fontData [ i ] = getColumnFontData ( element , i , tableRendering ) ; } return fontData ; } } return new FontData [ <int> ] ; } private FontData getColumnFontData ( Object element , int columnIndex , AbstractAsyncTableRendering tableRendering ) { if ( element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; if ( segment . getBytes ( ) . length ! = tableRendering . getBytesPerLine ( ) ) return null ; IFontProvider fontProvider = tableRendering . getAdapter ( IFontProvider . class ) ; if ( fontProvider ! = null & & columnIndex > <int> ) { MemoryRenderingElement renderingElement = getMemoryRenderingElement ( element , columnIndex , tableRendering ) ; if ( renderingElement ! = null ) { Font font = fontProvider . getFont ( renderingElement ) ; if ( font ! = null ) return font . getFontData ( ) [ <int> ] ; } } } return null ; } @Override protected RGB [ ] getForegrounds ( Object element , IPresentationContext context ) throws CoreException { if ( context instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext tableRenderingContext = ( MemoryViewPresentationContext ) context ; if ( tableRenderingContext . getRendering ( ) ! = null & & tableRenderingContext . getRendering ( ) instanceof AbstractAsyncTableRendering ) { AbstractAsyncTableRendering tableRendering = ( AbstractAsyncTableRendering ) tableRenderingContext . getRendering ( ) ; int numColumns = tableRendering . getAddressableUnitPerLine ( ) / tableRendering . getAddressableUnitPerColumn ( ) ; RGB [ ] colors = new RGB [ numColumns + <int> ] ; for ( int i = <int> ; i < colors . length - <int> ; i + + ) { colors [ i ] = getColumnForeground ( element , i , tableRendering ) ; } colors [ colors . length - <int> ] = null ; return colors ; } } return new RGB [ <int> ] ; } private RGB getColumnBackground ( Object element , int columnIndex , AbstractAsyncTableRendering tableRendering ) { if ( columnIndex = = <int> ) return null ; if ( element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; if ( segment . getBytes ( ) . length ! = tableRendering . getBytesPerLine ( ) ) return null ; IColorProvider colorProvider = tableRendering . getAdapter ( IColorProvider . class ) ; if ( colorProvider ! = null & & columnIndex > <int> ) { MemoryRenderingElement renderingElement = getMemoryRenderingElement ( element , columnIndex , tableRendering ) ; if ( renderingElement ! = null ) { Color color = colorProvider . getBackground ( renderingElement ) ; if ( color ! = null ) return color . getRGB ( ) ; } } } return null ; } private RGB getColumnForeground ( Object element , int columnIndex , AbstractAsyncTableRendering tableRendering ) { if ( columnIndex = = <int> ) return null ; if ( element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; if ( segment . getBytes ( ) . length ! = tableRendering . getBytesPerLine ( ) ) return null ; IColorProvider colorProvider = tableRendering . getAdapter ( IColorProvider . class ) ; if ( colorProvider ! = null & & columnIndex > <int> ) { MemoryRenderingElement renderingElement = getMemoryRenderingElement ( element , columnIndex , tableRendering ) ; if ( renderingElement ! = null ) { Color color = colorProvider . getForeground ( renderingElement ) ; if ( color ! = null ) return color . getRGB ( ) ; } } int start = ( columnIndex - <int> ) * tableRendering . getBytesPerColumn ( ) ; MemoryByte [ ] bytes = segment . getBytes ( start , tableRendering . getBytesPerColumn ( ) ) ; boolean allKnown = true ; boolean unchanged = true ; for ( int i = <int> ; i < bytes . length ; i + + ) { if ( ! bytes [ i ] . isHistoryKnown ( ) ) allKnown = false ; if ( bytes [ i ] . isChanged ( ) ) unchanged = false ; } if ( allKnown ) { if ( ! unchanged ) return DebugUIPlugin . getPreferenceColor ( IDebugUIConstants . PREF_CHANGED_DEBUG_ELEMENT_COLOR ) . getRGB ( ) ; return DebugUIPlugin . getPreferenceColor ( IDebugUIConstants . PREF_MEMORY_HISTORY_KNOWN_COLOR ) . getRGB ( ) ; } return DebugUIPlugin . getPreferenceColor ( IDebugUIConstants . PREF_MEMORY_HISTORY_UNKNOWN_COLOR ) . getRGB ( ) ; } return null ; } @Override protected RGB [ ] getBackgrounds ( Object element , IPresentationContext context ) throws CoreException { if ( context instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext tableRenderingContext = ( MemoryViewPresentationContext ) context ; if ( tableRenderingContext . getRendering ( ) ! = null & & tableRenderingContext . getRendering ( ) instanceof AbstractAsyncTableRendering ) { AbstractAsyncTableRendering tableRendering = ( AbstractAsyncTableRendering ) tableRenderingContext . getRendering ( ) ; int numColumns = tableRendering . getAddressableUnitPerLine ( ) / tableRendering . getAddressableUnitPerColumn ( ) ; RGB [ ] colors = new RGB [ numColumns + <int> ] ; for ( int i = <int> ; i < colors . length - <int> ; i + + ) { colors [ i ] = getColumnBackground ( element , i , tableRendering ) ; } colors [ colors . length - <int> ] = null ; return colors ; } } return new RGB [ <int> ] ; } private MemoryRenderingElement getMemoryRenderingElement ( Object element , int columnIndex , AbstractBaseTableRendering rendering ) { if ( element instanceof MemorySegment ) { MemorySegment line = ( MemorySegment ) element ; BigInteger address = line . getAddress ( ) ; int offset = ( columnIndex - <int> ) * rendering . getBytesPerColumn ( ) ; if ( offset < rendering . getBytesPerLine ( ) & & ( offset + rendering . getBytesPerColumn ( ) ) < = rendering . getBytesPerLine ( ) ) { return getMemoryRenderingElement ( line , address , offset , rendering ) ; } } return null ; } private MemoryRenderingElement getMemoryRenderingElement ( MemorySegment line , BigInteger lineAddress , int offset , AbstractBaseTableRendering rendering ) { BigInteger cellAddress = lineAddress . add ( BigInteger . valueOf ( offset ) ) ; MemoryByte [ ] bytes = line . getBytes ( offset , rendering . getBytesPerColumn ( ) ) ; MemoryByte [ ] copy = new MemoryByte [ bytes . length ] ; System . arraycopy ( bytes , <int> , copy , <int> , bytes . length ) ; MemoryRenderingElement renderingElement = new MemoryRenderingElement ( rendering , cellAddress , copy ) ; return renderingElement ; } } 
