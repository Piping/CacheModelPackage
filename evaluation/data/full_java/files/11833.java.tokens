package org . gradle . cache . internal ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . cache . internal . filelock . * ; import org . gradle . cache . internal . locklistener . FileLockContentionHandler ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . Factory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . id . IdGenerator ; import org . gradle . internal . id . RandomLongIdGenerator ; import org . gradle . util . GFileUtils ; import java . io . File ; import java . io . IOException ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArraySet ; import static org . gradle . internal . UncheckedException . throwAsUncheckedException ; public class DefaultFileLockManager implements FileLockManager { private static final Logger LOGGER = Logging . getLogger ( DefaultFileLockManager . class ) ; public static final int DEFAULT_LOCK_TIMEOUT = <int> ; private final Set < File > lockedFiles = new CopyOnWriteArraySet < File > ( ) ; private final ProcessMetaDataProvider metaDataProvider ; private final int lockTimeoutMs ; private final IdGenerator < Long > generator ; private final FileLockContentionHandler fileLockContentionHandler ; private final long shortTimeoutMs = <int> ; public DefaultFileLockManager ( ProcessMetaDataProvider metaDataProvider , FileLockContentionHandler fileLockContentionHandler ) { this ( metaDataProvider , DEFAULT_LOCK_TIMEOUT , fileLockContentionHandler ) ; } public DefaultFileLockManager ( ProcessMetaDataProvider metaDataProvider , int lockTimeoutMs , FileLockContentionHandler fileLockContentionHandler ) { this ( metaDataProvider , lockTimeoutMs , fileLockContentionHandler , new RandomLongIdGenerator ( ) ) ; } DefaultFileLockManager ( ProcessMetaDataProvider metaDataProvider , int lockTimeoutMs , FileLockContentionHandler fileLockContentionHandler , IdGenerator < Long > generator ) { this . metaDataProvider = metaDataProvider ; this . lockTimeoutMs = lockTimeoutMs ; this . fileLockContentionHandler = fileLockContentionHandler ; this . generator = generator ; } public FileLock lock ( File target , LockOptions options , String targetDisplayName ) throws LockTimeoutException { return lock ( target , options , targetDisplayName , <str> ) ; } public FileLock lock ( File target , LockOptions options , String targetDisplayName , String operationDisplayName ) { if ( options . getMode ( ) = = LockMode . None ) { throw new UnsupportedOperationException ( String . format ( <str> , options ) ) ; } File canonicalTarget = GFileUtils . canonicalise ( target ) ; if ( ! lockedFiles . add ( canonicalTarget ) ) { throw new IllegalStateException ( String . format ( <str> , targetDisplayName ) ) ; } try { int port = fileLockContentionHandler . reservePort ( ) ; return new DefaultFileLock ( canonicalTarget , options , targetDisplayName , operationDisplayName , port ) ; } catch ( Throwable t ) { lockedFiles . remove ( canonicalTarget ) ; throw throwAsUncheckedException ( t ) ; } } public void allowContention ( FileLock fileLock , Runnable whenContended ) { DefaultFileLock internalLock = ( DefaultFileLock ) fileLock ; fileLockContentionHandler . start ( internalLock . lockId , whenContended ) ; } private class DefaultFileLock extends AbstractFileAccess implements FileLock { private final File lockFile ; private final File target ; private final LockMode mode ; private final String displayName ; private final String operationDisplayName ; private java . nio . channels . FileLock lock ; private LockFileAccess lockFileAccess ; private LockState lockState ; private int port ; private final long lockId ; public DefaultFileLock ( File target , LockOptions options , String displayName , String operationDisplayName , int port ) throws Throwable { this . port = port ; this . lockId = generator . generateId ( ) ; if ( options . getMode ( ) = = LockMode . None ) { throw new UnsupportedOperationException ( <str> ) ; } this . target = target ; this . displayName = displayName ; this . operationDisplayName = operationDisplayName ; if ( target . isDirectory ( ) ) { lockFile = new File ( target , target . getName ( ) + <str> ) ; } else { lockFile = new File ( target . getParentFile ( ) , target . getName ( ) + <str> ) ; } GFileUtils . mkdirs ( lockFile . getParentFile ( ) ) ; lockFile . createNewFile ( ) ; LockStateSerializer stateProtocol = options . isUseCrossVersionImplementation ( ) ? new Version1LockStateSerializer ( ) : new DefaultLockStateSerializer ( ) ; lockFileAccess = new LockFileAccess ( lockFile , new LockStateAccess ( stateProtocol ) ) ; try { lockState = lock ( options . getMode ( ) ) ; } catch ( Throwable t ) { lockFileAccess . close ( ) ; throw t ; } this . mode = lock . isShared ( ) ? LockMode . Shared : LockMode . Exclusive ; } public boolean isLockFile ( File file ) { return file . equals ( lockFile ) ; } public boolean getUnlockedCleanly ( ) { assertOpen ( ) ; return ! lockState . isDirty ( ) ; } public State getState ( ) { assertOpen ( ) ; return lockState ; } public < T > T readFile ( Factory < ? extends T > action ) throws LockTimeoutException , FileIntegrityViolationException { assertOpenAndIntegral ( ) ; return action . create ( ) ; } public void updateFile ( Runnable action ) throws LockTimeoutException , FileIntegrityViolationException { assertOpenAndIntegral ( ) ; doWriteAction ( action ) ; } public void writeFile ( Runnable action ) throws LockTimeoutException { assertOpen ( ) ; doWriteAction ( action ) ; } private void doWriteAction ( Runnable action ) { if ( mode ! = LockMode . Exclusive ) { throw new InsufficientLockModeException ( <str> ) ; } try { lockState = lockFileAccess . markDirty ( lockState ) ; action . run ( ) ; lockState = lockFileAccess . markClean ( lockState ) ; } catch ( Throwable t ) { throw throwAsUncheckedException ( t ) ; } } private void assertOpen ( ) { if ( lock = = null ) { throw new IllegalStateException ( <str> ) ; } } private void assertOpenAndIntegral ( ) { assertOpen ( ) ; if ( lockState . isDirty ( ) ) { throw new FileIntegrityViolationException ( String . format ( <str> , target ) ) ; } } public void close ( ) { CompositeStoppable stoppable = new CompositeStoppable ( ) ; stoppable . add ( new Stoppable ( ) { public void stop ( ) { try { fileLockContentionHandler . stop ( lockId ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> + displayName , e ) ; } } } ) ; stoppable . add ( new Stoppable ( ) { public void stop ( ) { if ( lockFileAccess = = null ) { return ; } try { LOGGER . debug ( <str> , displayName ) ; try { if ( lock ! = null & & ! lock . isShared ( ) ) { java . nio . channels . FileLock info ; try { info = lockInformationRegion ( LockMode . Exclusive , System . currentTimeMillis ( ) + shortTimeoutMs ) ; } catch ( InterruptedException e ) { throw throwAsUncheckedException ( e ) ; } if ( info ! = null ) { try { lockFileAccess . clearLockInfo ( ) ; } finally { info . release ( ) ; } } } } finally { lockFileAccess . close ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( <str> + displayName , e ) ; } } } ) ; stoppable . add ( new Stoppable ( ) { public void stop ( ) { lock = null ; lockFileAccess = null ; lockedFiles . remove ( target ) ; } } ) ; stoppable . stop ( ) ; } public LockMode getMode ( ) { return mode ; } private LockState lock ( FileLockManager . LockMode lockMode ) throws Throwable { LOGGER . debug ( <str> , lockMode . toString ( ) . toLowerCase ( ) , displayName ) ; long waitUntil = System . currentTimeMillis ( ) + lockTimeoutMs ; java . nio . channels . FileLock stateRegionLock = lockStateRegion ( lockMode , waitUntil ) ; if ( stateRegionLock = = null ) { LockInfo lockInfo = readInformationRegion ( System . currentTimeMillis ( ) + shortTimeoutMs ) ; throw new LockTimeoutException ( String . format ( <str> , displayName , lockInfo . pid , metaDataProvider . getProcessIdentifier ( ) , lockInfo . operation , operationDisplayName , lockFile ) ) ; } try { LockState lockState ; if ( ! stateRegionLock . isShared ( ) ) { lockState = lockFileAccess . ensureLockState ( ) ; java . nio . channels . FileLock informationRegionLock = lockInformationRegion ( LockMode . Exclusive , System . currentTimeMillis ( ) + shortTimeoutMs ) ; if ( informationRegionLock = = null ) { throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; } try { lockFileAccess . writeLockInfo ( port , lockId , metaDataProvider . getProcessIdentifier ( ) , operationDisplayName ) ; } finally { informationRegionLock . release ( ) ; } } else { lockState = lockFileAccess . readLockState ( ) ; } LOGGER . debug ( <str> ) ; lock = stateRegionLock ; return lockState ; } catch ( Throwable t ) { stateRegionLock . release ( ) ; throw t ; } } private LockInfo readInformationRegion ( long waitUntil ) throws IOException , InterruptedException { LockInfo out = new LockInfo ( ) ; java . nio . channels . FileLock informationRegionLock = lockInformationRegion ( LockMode . Shared , waitUntil ) ; if ( informationRegionLock = = null ) { LOGGER . debug ( <str> , displayName ) ; } else { try { out = lockFileAccess . readLockInfo ( ) ; } finally { informationRegionLock . release ( ) ; } } return out ; } private java . nio . channels . FileLock lockStateRegion ( LockMode lockMode , final long waitUntil ) throws IOException , InterruptedException { do { java . nio . channels . FileLock fileLock = lockFileAccess . tryLockState ( lockMode = = LockMode . Shared ) ; if ( fileLock ! = null ) { return fileLock ; } if ( port ! = - <int> ) { LockInfo lockInfo = readInformationRegion ( System . currentTimeMillis ( ) ) ; if ( lockInfo . port ! = - <int> ) { LOGGER . debug ( <str> , lockInfo . pid , lockInfo . operation , lockInfo . port ) ; fileLockContentionHandler . pingOwner ( lockInfo . port , lockInfo . lockId , displayName ) ; } else { LOGGER . debug ( <str> ) ; } } Thread . sleep ( <int> ) ; } while ( System . currentTimeMillis ( ) < waitUntil ) ; return null ; } private java . nio . channels . FileLock lockInformationRegion ( LockMode lockMode , long waitUntil ) throws IOException , InterruptedException { do { java . nio . channels . FileLock fileLock = lockFileAccess . tryLockInfo ( lockMode = = LockMode . Shared ) ; if ( fileLock ! = null ) { return fileLock ; } Thread . sleep ( <int> ) ; } while ( System . currentTimeMillis ( ) < waitUntil ) ; return null ; } } } 
