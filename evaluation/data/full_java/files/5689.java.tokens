package org . elasticsearch . common . bytes ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . common . io . Channels ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . netty . NettyUtils ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . ByteArray ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import java . io . EOFException ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . channels . GatheringByteChannel ; import java . util . Arrays ; public class PagedBytesReference implements BytesReference { private static final int PAGE_SIZE = BigArrays . BYTE_PAGE_SIZE ; private final BigArrays bigarrays ; protected final ByteArray bytearray ; private final int offset ; private final int length ; private int hash = <int> ; public PagedBytesReference ( BigArrays bigarrays , ByteArray bytearray , int length ) { this ( bigarrays , bytearray , <int> , length ) ; } public PagedBytesReference ( BigArrays bigarrays , ByteArray bytearray , int from , int length ) { this . bigarrays = bigarrays ; this . bytearray = bytearray ; this . offset = from ; this . length = length ; } @Override public byte get ( int index ) { return bytearray . get ( offset + index ) ; } @Override public int length ( ) { return length ; } @Override public BytesReference slice ( int from , int length ) { if ( from < <int> | | ( from + length ) > length ( ) ) { throw new IllegalArgumentException ( <str> + length ( ) + <str> + from + <str> + length + <str> ) ; } return new PagedBytesReference ( bigarrays , bytearray , offset + from , length ) ; } @Override public StreamInput streamInput ( ) { return new PagedBytesReferenceStreamInput ( bytearray , offset , length ) ; } @Override public void writeTo ( OutputStream os ) throws IOException { if ( length = = <int> ) { return ; } BytesRef ref = new BytesRef ( ) ; int written = <int> ; if ( offset ! = <int> ) { int fragmentSize = Math . min ( length , PAGE_SIZE - ( offset % PAGE_SIZE ) ) ; bytearray . get ( offset , fragmentSize , ref ) ; os . write ( ref . bytes , ref . offset , fragmentSize ) ; written + = fragmentSize ; } while ( written < length ) { int remaining = length - written ; int bulkSize = ( remaining > PAGE_SIZE ) ? PAGE_SIZE : remaining ; bytearray . get ( offset + written , bulkSize , ref ) ; os . write ( ref . bytes , ref . offset , bulkSize ) ; written + = bulkSize ; } } @Override public void writeTo ( GatheringByteChannel channel ) throws IOException { if ( length = = <int> ) { return ; } int currentLength = length ; int currentOffset = offset ; BytesRef ref = new BytesRef ( ) ; while ( currentLength > <int> ) { int fragmentSize = Math . min ( currentLength , PAGE_SIZE - ( currentOffset % PAGE_SIZE ) ) ; boolean newArray = bytearray . get ( currentOffset , fragmentSize , ref ) ; assert ! newArray : <str> + currentOffset + <str> + fragmentSize + <str> ; Channels . writeToChannel ( ref . bytes , ref . offset , ref . length , channel ) ; currentLength - = ref . length ; currentOffset + = ref . length ; } assert currentLength = = <int> ; } @Override public byte [ ] toBytes ( ) { if ( length = = <int> ) { return BytesRef . EMPTY_BYTES ; } BytesRef ref = new BytesRef ( ) ; bytearray . get ( offset , length , ref ) ; byte [ ] result = ref . bytes ; if ( result . length ! = length | | ref . offset ! = <int> ) { result = Arrays . copyOfRange ( result , ref . offset , ref . offset + length ) ; } return result ; } @Override public BytesArray toBytesArray ( ) { BytesRef ref = new BytesRef ( ) ; bytearray . get ( offset , length , ref ) ; return new BytesArray ( ref ) ; } @Override public BytesArray copyBytesArray ( ) { BytesRef ref = new BytesRef ( ) ; boolean copied = bytearray . get ( offset , length , ref ) ; if ( copied ) { return new BytesArray ( ref . bytes , ref . offset , ref . length ) ; } else { byte [ ] copy = Arrays . copyOfRange ( ref . bytes , ref . offset , ref . offset + ref . length ) ; return new BytesArray ( copy ) ; } } @Override public ChannelBuffer toChannelBuffer ( ) { if ( length = = <int> ) { return ChannelBuffers . EMPTY_BUFFER ; } ChannelBuffer [ ] buffers ; ChannelBuffer currentBuffer = null ; BytesRef ref = new BytesRef ( ) ; int pos = <int> ; if ( offset ! = <int> ) { int fragmentSize = Math . min ( length , PAGE_SIZE - ( offset % PAGE_SIZE ) ) ; bytearray . get ( offset , fragmentSize , ref ) ; currentBuffer = ChannelBuffers . wrappedBuffer ( ref . bytes , ref . offset , fragmentSize ) ; pos + = fragmentSize ; } if ( pos = = length & & currentBuffer ! = null ) { return currentBuffer ; } int numBuffers = countRequiredBuffers ( ( currentBuffer ! = null ? <int> : <int> ) , length - pos ) ; buffers = new ChannelBuffer [ numBuffers ] ; int bufferSlot = <int> ; if ( currentBuffer ! = null ) { buffers [ bufferSlot ] = currentBuffer ; bufferSlot + + ; } while ( pos < length ) { int remaining = length - pos ; int bulkSize = ( remaining > PAGE_SIZE ) ? PAGE_SIZE : remaining ; bytearray . get ( offset + pos , bulkSize , ref ) ; currentBuffer = ChannelBuffers . wrappedBuffer ( ref . bytes , ref . offset , bulkSize ) ; buffers [ bufferSlot ] = currentBuffer ; bufferSlot + + ; pos + = bulkSize ; } assert ( numBuffers = = bufferSlot ) ; return ChannelBuffers . wrappedBuffer ( NettyUtils . DEFAULT_GATHERING , buffers ) ; } @Override public boolean hasArray ( ) { return ( offset + length < = PAGE_SIZE ) ; } @Override public byte [ ] array ( ) { if ( hasArray ( ) ) { if ( length = = <int> ) { return BytesRef . EMPTY_BYTES ; } BytesRef ref = new BytesRef ( ) ; bytearray . get ( offset , length , ref ) ; return ref . bytes ; } throw new IllegalStateException ( <str> ) ; } @Override public int arrayOffset ( ) { if ( hasArray ( ) ) { BytesRef ref = new BytesRef ( ) ; bytearray . get ( offset , length , ref ) ; return ref . offset ; } throw new IllegalStateException ( <str> ) ; } @Override public String toUtf8 ( ) { if ( length ( ) = = <int> ) { return <str> ; } byte [ ] bytes = toBytes ( ) ; final CharsRefBuilder ref = new CharsRefBuilder ( ) ; ref . copyUTF8Bytes ( bytes , offset , length ) ; return ref . toString ( ) ; } @Override public BytesRef toBytesRef ( ) { BytesRef bref = new BytesRef ( ) ; bytearray . get ( offset , length , bref ) ; return bref ; } @Override public BytesRef copyBytesRef ( ) { byte [ ] bytes = toBytes ( ) ; return new BytesRef ( bytes , offset , length ) ; } @Override public int hashCode ( ) { if ( hash = = <int> ) { int tmphash = <int> ; for ( int i = <int> ; i < length ; i + + ) { tmphash = <int> * tmphash + bytearray . get ( offset + i ) ; } hash = tmphash ; } return hash ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( ! ( obj instanceof PagedBytesReference ) ) { return BytesReference . Helper . bytesEqual ( this , ( BytesReference ) obj ) ; } PagedBytesReference other = ( PagedBytesReference ) obj ; if ( length ! = other . length ) { return false ; } ByteArray otherArray = other . bytearray ; int otherOffset = other . offset ; for ( int i = <int> ; i < length ; i + + ) { if ( bytearray . get ( offset + i ) ! = otherArray . get ( otherOffset + i ) ) { return false ; } } return true ; } private int countRequiredBuffers ( int initialCount , int numBytes ) { int numBuffers = initialCount ; int pages = numBytes / PAGE_SIZE ; numBuffers + = ( pages = = <int> ) ? <int> : pages ; numBuffers + = ( pages > <int> & & numBytes % PAGE_SIZE > <int> ) ? <int> : <int> ; return numBuffers ; } private static class PagedBytesReferenceStreamInput extends StreamInput { private final ByteArray bytearray ; private final BytesRef ref ; private final int offset ; private final int length ; private int pos ; private int mark ; public PagedBytesReferenceStreamInput ( ByteArray bytearray , int offset , int length ) { this . bytearray = bytearray ; this . ref = new BytesRef ( ) ; this . offset = offset ; this . length = length ; this . pos = <int> ; if ( offset + length > bytearray . size ( ) ) { throw new IndexOutOfBoundsException ( <str> ) ; } } @Override public byte readByte ( ) throws IOException { if ( pos > = length ) { throw new EOFException ( ) ; } return bytearray . get ( offset + pos + + ) ; } @Override public void readBytes ( byte [ ] b , int bOffset , int len ) throws IOException { if ( len > offset + length ) { throw new IndexOutOfBoundsException ( <str> + len + <str> + length + <str> + pos ) ; } read ( b , bOffset , len ) ; } @Override public int read ( ) throws IOException { return ( pos < length ) ? bytearray . get ( offset + pos + + ) : - <int> ; } @Override public int read ( final byte [ ] b , final int bOffset , final int len ) throws IOException { if ( len = = <int> ) { return <int> ; } if ( pos > = offset + length ) { return - <int> ; } final int numBytesToCopy = Math . min ( len , length - pos ) ; long byteArrayOffset = offset + pos ; int copiedBytes = <int> ; while ( copiedBytes < numBytesToCopy ) { long pageFragment = PAGE_SIZE - ( byteArrayOffset % PAGE_SIZE ) ; int bulkSize = ( int ) Math . min ( pageFragment , numBytesToCopy - copiedBytes ) ; boolean copied = bytearray . get ( byteArrayOffset , bulkSize , ref ) ; assert ( copied = = false ) ; System . arraycopy ( ref . bytes , ref . offset , b , bOffset + copiedBytes , bulkSize ) ; copiedBytes + = bulkSize ; byteArrayOffset + = bulkSize ; } pos + = copiedBytes ; return copiedBytes ; } @Override public boolean markSupported ( ) { return true ; } @Override public void mark ( int readlimit ) { this . mark = pos ; } @Override public void reset ( ) throws IOException { pos = mark ; } @Override public void close ( ) throws IOException { } } } 
