package org . elasticsearch . search . aggregations . bucket . terms ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class TermsParametersParser extends AbstractTermsParametersParser { private static final TermsAggregator . BucketCountThresholds DEFAULT_BUCKET_COUNT_THRESHOLDS = new TermsAggregator . BucketCountThresholds ( <int> , <int> , <int> , - <int> ) ; public List < OrderElement > getOrderElements ( ) { return orderElements ; } public boolean showTermDocCountError ( ) { return showTermDocCountError ; } List < OrderElement > orderElements ; private boolean showTermDocCountError = false ; public TermsParametersParser ( ) { orderElements = new ArrayList < > ( <int> ) ; orderElements . add ( new OrderElement ( <str> , false ) ) ; } @Override public void parseSpecial ( String aggregationName , XContentParser parser , SearchContext context , XContentParser . Token token , String currentFieldName ) throws IOException { if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { this . orderElements = Collections . singletonList ( parseOrderParam ( aggregationName , parser , context ) ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { orderElements = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . START_OBJECT ) { OrderElement orderParam = parseOrderParam ( aggregationName , parser , context ) ; orderElements . add ( orderParam ) ; } else { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , SHOW_TERM_DOC_COUNT_ERROR ) ) { showTermDocCountError = parser . booleanValue ( ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } private OrderElement parseOrderParam ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { XContentParser . Token token ; OrderElement orderParam = null ; String orderKey = null ; boolean orderAsc = false ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { orderKey = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { String dir = parser . text ( ) ; if ( <str> . equalsIgnoreCase ( dir ) ) { orderAsc = true ; } else if ( <str> . equalsIgnoreCase ( dir ) ) { orderAsc = false ; } else { throw new SearchParseException ( context , <str> + dir + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( orderKey = = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } else { orderParam = new OrderElement ( orderKey , orderAsc ) ; } return orderParam ; } static class OrderElement { private final String key ; private final boolean asc ; public OrderElement ( String key , boolean asc ) { this . key = key ; this . asc = asc ; } public String key ( ) { return key ; } public boolean asc ( ) { return asc ; } } @Override public TermsAggregator . BucketCountThresholds getDefaultBucketCountThresholds ( ) { return new TermsAggregator . BucketCountThresholds ( DEFAULT_BUCKET_COUNT_THRESHOLDS ) ; } } 
