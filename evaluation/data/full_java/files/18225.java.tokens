package com . badlogic . gdx . scenes . scene2d ; import static com . badlogic . gdx . utils . Align . * ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . InputEvent . Type ; import com . badlogic . gdx . scenes . scene2d . utils . ActorGestureListener ; import com . badlogic . gdx . scenes . scene2d . utils . ClickListener ; import com . badlogic . gdx . scenes . scene2d . utils . ScissorStack ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . DelayedRemovalArray ; import com . badlogic . gdx . utils . Pools ; public class Actor { private Stage stage ; Group parent ; private final DelayedRemovalArray < EventListener > listeners = new DelayedRemovalArray ( <int> ) ; private final DelayedRemovalArray < EventListener > captureListeners = new DelayedRemovalArray ( <int> ) ; private final Array < Action > actions = new Array ( <int> ) ; private String name ; private Touchable touchable = Touchable . enabled ; private boolean visible = true , debug ; float x , y ; float width , height ; float originX , originY ; float scaleX = <int> , scaleY = <int> ; float rotation ; final Color color = new Color ( <int> , <int> , <int> , <int> ) ; private Object userObject ; public void draw ( Batch batch , float parentAlpha ) { } public void act ( float delta ) { Array < Action > actions = this . actions ; if ( actions . size > <int> ) { if ( stage ! = null & & stage . getActionsRequestRendering ( ) ) Gdx . graphics . requestRendering ( ) ; for ( int i = <int> ; i < actions . size ; i + + ) { Action action = actions . get ( i ) ; if ( action . act ( delta ) & & i < actions . size ) { Action current = actions . get ( i ) ; int actionIndex = current = = action ? i : actions . indexOf ( action , true ) ; if ( actionIndex ! = - <int> ) { actions . removeIndex ( actionIndex ) ; action . setActor ( null ) ; i - - ; } } } } } public boolean fire ( Event event ) { if ( event . getStage ( ) = = null ) event . setStage ( getStage ( ) ) ; event . setTarget ( this ) ; Array < Group > ancestors = Pools . obtain ( Array . class ) ; Group parent = this . parent ; while ( parent ! = null ) { ancestors . add ( parent ) ; parent = parent . parent ; } try { Object [ ] ancestorsArray = ancestors . items ; for ( int i = ancestors . size - <int> ; i > = <int> ; i - - ) { Group currentTarget = ( Group ) ancestorsArray [ i ] ; currentTarget . notify ( event , true ) ; if ( event . isStopped ( ) ) return event . isCancelled ( ) ; } notify ( event , true ) ; if ( event . isStopped ( ) ) return event . isCancelled ( ) ; notify ( event , false ) ; if ( ! event . getBubbles ( ) ) return event . isCancelled ( ) ; if ( event . isStopped ( ) ) return event . isCancelled ( ) ; for ( int i = <int> , n = ancestors . size ; i < n ; i + + ) { ( ( Group ) ancestorsArray [ i ] ) . notify ( event , false ) ; if ( event . isStopped ( ) ) return event . isCancelled ( ) ; } return event . isCancelled ( ) ; } finally { ancestors . clear ( ) ; Pools . free ( ancestors ) ; } } public boolean notify ( Event event , boolean capture ) { if ( event . getTarget ( ) = = null ) throw new IllegalArgumentException ( <str> ) ; DelayedRemovalArray < EventListener > listeners = capture ? captureListeners : this . listeners ; if ( listeners . size = = <int> ) return event . isCancelled ( ) ; event . setListenerActor ( this ) ; event . setCapture ( capture ) ; if ( event . getStage ( ) = = null ) event . setStage ( stage ) ; listeners . begin ( ) ; for ( int i = <int> , n = listeners . size ; i < n ; i + + ) { EventListener listener = listeners . get ( i ) ; if ( listener . handle ( event ) ) { event . handle ( ) ; if ( event instanceof InputEvent ) { InputEvent inputEvent = ( InputEvent ) event ; if ( inputEvent . getType ( ) = = Type . touchDown ) { event . getStage ( ) . addTouchFocus ( listener , this , inputEvent . getTarget ( ) , inputEvent . getPointer ( ) , inputEvent . getButton ( ) ) ; } } } } listeners . end ( ) ; return event . isCancelled ( ) ; } public Actor hit ( float x , float y , boolean touchable ) { if ( touchable & & this . touchable ! = Touchable . enabled ) return null ; return x > = <int> & & x < width & & y > = <int> & & y < height ? this : null ; } public boolean remove ( ) { if ( parent ! = null ) return parent . removeActor ( this , true ) ; return false ; } public boolean addListener ( EventListener listener ) { if ( ! listeners . contains ( listener , true ) ) { listeners . add ( listener ) ; return true ; } return false ; } public boolean removeListener ( EventListener listener ) { return listeners . removeValue ( listener , true ) ; } public Array < EventListener > getListeners ( ) { return listeners ; } public boolean addCaptureListener ( EventListener listener ) { if ( ! captureListeners . contains ( listener , true ) ) captureListeners . add ( listener ) ; return true ; } public boolean removeCaptureListener ( EventListener listener ) { return captureListeners . removeValue ( listener , true ) ; } public Array < EventListener > getCaptureListeners ( ) { return captureListeners ; } public void addAction ( Action action ) { action . setActor ( this ) ; actions . add ( action ) ; if ( stage ! = null & & stage . getActionsRequestRendering ( ) ) Gdx . graphics . requestRendering ( ) ; } public void removeAction ( Action action ) { if ( actions . removeValue ( action , true ) ) action . setActor ( null ) ; } public Array < Action > getActions ( ) { return actions ; } public boolean hasActions ( ) { return actions . size > <int> ; } public void clearActions ( ) { for ( int i = actions . size - <int> ; i > = <int> ; i - - ) actions . get ( i ) . setActor ( null ) ; actions . clear ( ) ; } public void clearListeners ( ) { listeners . clear ( ) ; captureListeners . clear ( ) ; } public void clear ( ) { clearActions ( ) ; clearListeners ( ) ; } public Stage getStage ( ) { return stage ; } protected void setStage ( Stage stage ) { this . stage = stage ; } public boolean isDescendantOf ( Actor actor ) { if ( actor = = null ) throw new IllegalArgumentException ( <str> ) ; Actor parent = this ; while ( true ) { if ( parent = = null ) return false ; if ( parent = = actor ) return true ; parent = parent . parent ; } } public boolean isAscendantOf ( Actor actor ) { if ( actor = = null ) throw new IllegalArgumentException ( <str> ) ; while ( true ) { if ( actor = = null ) return false ; if ( actor = = this ) return true ; actor = actor . parent ; } } public boolean hasParent ( ) { return parent ! = null ; } public Group getParent ( ) { return parent ; } protected void setParent ( Group parent ) { this . parent = parent ; } public boolean isTouchable ( ) { return touchable = = Touchable . enabled ; } public Touchable getTouchable ( ) { return touchable ; } public void setTouchable ( Touchable touchable ) { this . touchable = touchable ; } public boolean isVisible ( ) { return visible ; } public void setVisible ( boolean visible ) { this . visible = visible ; } public Object getUserObject ( ) { return userObject ; } public void setUserObject ( Object userObject ) { this . userObject = userObject ; } public float getX ( ) { return x ; } public float getX ( int alignment ) { float x = this . x ; if ( ( alignment & right ) ! = <int> ) x + = width ; else if ( ( alignment & left ) = = <int> ) x + = width / <int> ; return x ; } public void setX ( float x ) { if ( this . x ! = x ) { this . x = x ; positionChanged ( ) ; } } public float getY ( ) { return y ; } public void setY ( float y ) { if ( this . y ! = y ) { this . y = y ; positionChanged ( ) ; } } public float getY ( int alignment ) { float y = this . y ; if ( ( alignment & top ) ! = <int> ) y + = height ; else if ( ( alignment & bottom ) = = <int> ) y + = height / <int> ; return y ; } public void setPosition ( float x , float y ) { if ( this . x ! = x | | this . y ! = y ) { this . x = x ; this . y = y ; positionChanged ( ) ; } } public void setPosition ( float x , float y , int alignment ) { if ( ( alignment & right ) ! = <int> ) x - = width ; else if ( ( alignment & left ) = = <int> ) x - = width / <int> ; if ( ( alignment & top ) ! = <int> ) y - = height ; else if ( ( alignment & bottom ) = = <int> ) y - = height / <int> ; if ( this . x ! = x | | this . y ! = y ) { this . x = x ; this . y = y ; positionChanged ( ) ; } } public void moveBy ( float x , float y ) { if ( x ! = <int> | | y ! = <int> ) { this . x + = x ; this . y + = y ; positionChanged ( ) ; } } public float getWidth ( ) { return width ; } public void setWidth ( float width ) { if ( this . width ! = width ) { this . width = width ; sizeChanged ( ) ; } } public float getHeight ( ) { return height ; } public void setHeight ( float height ) { if ( this . height ! = height ) { this . height = height ; sizeChanged ( ) ; } } public float getTop ( ) { return y + height ; } public float getRight ( ) { return x + width ; } protected void positionChanged ( ) { } protected void sizeChanged ( ) { } protected void rotationChanged ( ) { } public void setSize ( float width , float height ) { if ( this . width ! = width | | this . height ! = height ) { this . width = width ; this . height = height ; sizeChanged ( ) ; } } public void sizeBy ( float size ) { if ( size ! = <int> ) { width + = size ; height + = size ; sizeChanged ( ) ; } } public void sizeBy ( float width , float height ) { if ( width ! = <int> | | height ! = <int> ) { this . width + = width ; this . height + = height ; sizeChanged ( ) ; } } public void setBounds ( float x , float y , float width , float height ) { if ( this . x ! = x | | this . y ! = y ) { this . x = x ; this . y = y ; positionChanged ( ) ; } if ( this . width ! = width | | this . height ! = height ) { this . width = width ; this . height = height ; sizeChanged ( ) ; } } public float getOriginX ( ) { return originX ; } public void setOriginX ( float originX ) { this . originX = originX ; } public float getOriginY ( ) { return originY ; } public void setOriginY ( float originY ) { this . originY = originY ; } public void setOrigin ( float originX , float originY ) { this . originX = originX ; this . originY = originY ; } public void setOrigin ( int alignment ) { if ( ( alignment & left ) ! = <int> ) originX = <int> ; else if ( ( alignment & right ) ! = <int> ) originX = width ; else originX = width / <int> ; if ( ( alignment & bottom ) ! = <int> ) originY = <int> ; else if ( ( alignment & top ) ! = <int> ) originY = height ; else originY = height / <int> ; } public float getScaleX ( ) { return scaleX ; } public void setScaleX ( float scaleX ) { this . scaleX = scaleX ; } public float getScaleY ( ) { return scaleY ; } public void setScaleY ( float scaleY ) { this . scaleY = scaleY ; } public void setScale ( float scaleXY ) { this . scaleX = scaleXY ; this . scaleY = scaleXY ; } public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ; } public void scaleBy ( float scale ) { scaleX + = scale ; scaleY + = scale ; } public void scaleBy ( float scaleX , float scaleY ) { this . scaleX + = scaleX ; this . scaleY + = scaleY ; } public float getRotation ( ) { return rotation ; } public void setRotation ( float degrees ) { if ( this . rotation ! = degrees ) { this . rotation = degrees ; rotationChanged ( ) ; } } public void rotateBy ( float amountInDegrees ) { if ( amountInDegrees ! = <int> ) { rotation + = amountInDegrees ; rotationChanged ( ) ; } } public void setColor ( Color color ) { this . color . set ( color ) ; } public void setColor ( float r , float g , float b , float a ) { color . set ( r , g , b , a ) ; } public Color getColor ( ) { return color ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public void toFront ( ) { setZIndex ( Integer . MAX_VALUE ) ; } public void toBack ( ) { setZIndex ( <int> ) ; } public void setZIndex ( int index ) { if ( index < <int> ) throw new IllegalArgumentException ( <str> ) ; Group parent = this . parent ; if ( parent = = null ) return ; Array < Actor > children = parent . children ; if ( children . size = = <int> ) return ; index = Math . min ( index , children . size - <int> ) ; if ( index = = children . indexOf ( this , true ) ) return ; if ( ! children . removeValue ( this , true ) ) return ; children . insert ( index , this ) ; } public int getZIndex ( ) { Group parent = this . parent ; if ( parent = = null ) return - <int> ; return parent . children . indexOf ( this , true ) ; } public boolean clipBegin ( ) { return clipBegin ( x , y , width , height ) ; } public boolean clipBegin ( float x , float y , float width , float height ) { if ( width < = <int> | | height < = <int> ) return false ; Rectangle tableBounds = Rectangle . tmp ; tableBounds . x = x ; tableBounds . y = y ; tableBounds . width = width ; tableBounds . height = height ; Stage stage = this . stage ; Rectangle scissorBounds = Pools . obtain ( Rectangle . class ) ; stage . calculateScissors ( tableBounds , scissorBounds ) ; if ( ScissorStack . pushScissors ( scissorBounds ) ) return true ; Pools . free ( scissorBounds ) ; return false ; } public void clipEnd ( ) { Pools . free ( ScissorStack . popScissors ( ) ) ; } public Vector2 screenToLocalCoordinates ( Vector2 screenCoords ) { Stage stage = this . stage ; if ( stage = = null ) return screenCoords ; return stageToLocalCoordinates ( stage . screenToStageCoordinates ( screenCoords ) ) ; } public Vector2 stageToLocalCoordinates ( Vector2 stageCoords ) { if ( parent ! = null ) parent . stageToLocalCoordinates ( stageCoords ) ; parentToLocalCoordinates ( stageCoords ) ; return stageCoords ; } public Vector2 localToStageCoordinates ( Vector2 localCoords ) { return localToAscendantCoordinates ( null , localCoords ) ; } public Vector2 localToParentCoordinates ( Vector2 localCoords ) { final float rotation = - this . rotation ; final float scaleX = this . scaleX ; final float scaleY = this . scaleY ; final float x = this . x ; final float y = this . y ; if ( rotation = = <int> ) { if ( scaleX = = <int> & & scaleY = = <int> ) { localCoords . x + = x ; localCoords . y + = y ; } else { final float originX = this . originX ; final float originY = this . originY ; localCoords . x = ( localCoords . x - originX ) * scaleX + originX + x ; localCoords . y = ( localCoords . y - originY ) * scaleY + originY + y ; } } else { final float cos = ( float ) Math . cos ( rotation * MathUtils . degreesToRadians ) ; final float sin = ( float ) Math . sin ( rotation * MathUtils . degreesToRadians ) ; final float originX = this . originX ; final float originY = this . originY ; final float tox = ( localCoords . x - originX ) * scaleX ; final float toy = ( localCoords . y - originY ) * scaleY ; localCoords . x = ( tox * cos + toy * sin ) + originX + x ; localCoords . y = ( tox * - sin + toy * cos ) + originY + y ; } return localCoords ; } public Vector2 localToAscendantCoordinates ( Actor ascendant , Vector2 localCoords ) { Actor actor = this ; while ( actor ! = null ) { actor . localToParentCoordinates ( localCoords ) ; actor = actor . parent ; if ( actor = = ascendant ) break ; } return localCoords ; } public Vector2 parentToLocalCoordinates ( Vector2 parentCoords ) { final float rotation = this . rotation ; final float scaleX = this . scaleX ; final float scaleY = this . scaleY ; final float childX = x ; final float childY = y ; if ( rotation = = <int> ) { if ( scaleX = = <int> & & scaleY = = <int> ) { parentCoords . x - = childX ; parentCoords . y - = childY ; } else { final float originX = this . originX ; final float originY = this . originY ; parentCoords . x = ( parentCoords . x - childX - originX ) / scaleX + originX ; parentCoords . y = ( parentCoords . y - childY - originY ) / scaleY + originY ; } } else { final float cos = ( float ) Math . cos ( rotation * MathUtils . degreesToRadians ) ; final float sin = ( float ) Math . sin ( rotation * MathUtils . degreesToRadians ) ; final float originX = this . originX ; final float originY = this . originY ; final float tox = parentCoords . x - childX - originX ; final float toy = parentCoords . y - childY - originY ; parentCoords . x = ( tox * cos + toy * sin ) / scaleX + originX ; parentCoords . y = ( tox * - sin + toy * cos ) / scaleY + originY ; } return parentCoords ; } public void drawDebug ( ShapeRenderer shapes ) { drawDebugBounds ( shapes ) ; } protected void drawDebugBounds ( ShapeRenderer shapes ) { if ( ! debug ) return ; shapes . set ( ShapeType . Line ) ; shapes . setColor ( stage . getDebugColor ( ) ) ; shapes . rect ( x , y , originX , originY , width , height , scaleX , scaleY , rotation ) ; } public void setDebug ( boolean enabled ) { debug = enabled ; if ( enabled ) Stage . debug = true ; } public boolean getDebug ( ) { return debug ; } public Actor debug ( ) { setDebug ( true ) ; return this ; } public String toString ( ) { String name = this . name ; if ( name = = null ) { name = getClass ( ) . getName ( ) ; int dotIndex = name . lastIndexOf ( <str> ) ; if ( dotIndex ! = - <int> ) name = name . substring ( dotIndex + <int> ) ; } return name ; } } 
