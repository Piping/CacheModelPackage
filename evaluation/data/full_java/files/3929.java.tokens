package org . eclipse . debug . tests . viewer . model ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ICheckUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class ContentTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public ContentTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , true , true ) ; fShell . open ( ) ; } abstract protected IInternalTreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } public void testSimpleSingleLevel ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , true ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; assertTrue ( fListener . checkCoalesced ( TreePath . EMPTY , <int> , <int> ) ) ; } public void testSimpleMultiLevel ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , true ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; assertTrue ( fListener . checkCoalesced ( TreePath . EMPTY , <int> , <int> ) ) ; } class TestModelWithCapturedUpdates extends TestModel { boolean fCaptureLabelUpdates = false ; boolean fCaptureChildrenUpdates = false ; List < IViewerUpdate > fCapturedUpdates = Collections . synchronizedList ( new ArrayList < IViewerUpdate > ( ) ) ; @Override public void update ( IChildrenUpdate [ ] updates ) { for ( int i = <int> ; i < updates . length ; i + + ) { TestElement element = ( TestElement ) updates [ i ] . getElement ( ) ; int endOffset = updates [ i ] . getOffset ( ) + updates [ i ] . getLength ( ) ; for ( int j = updates [ i ] . getOffset ( ) ; j < endOffset ; j + + ) { if ( j < element . getChildren ( ) . length ) { updates [ i ] . setChild ( element . getChildren ( ) [ j ] , j ) ; } } if ( fCaptureChildrenUpdates ) { fCapturedUpdates . add ( updates [ i ] ) ; } else { updates [ i ] . done ( ) ; } } } @Override public void update ( ILabelUpdate [ ] updates ) { for ( int i = <int> ; i < updates . length ; i + + ) { TestElement element = ( TestElement ) updates [ i ] . getElement ( ) ; updates [ i ] . setLabel ( element . getLabel ( ) , <int> ) ; if ( updates [ i ] instanceof ICheckUpdate & & Boolean . TRUE . equals ( updates [ i ] . getPresentationContext ( ) . getProperty ( ICheckUpdate . PROP_CHECK ) ) ) { ( ( ICheckUpdate ) updates [ i ] ) . setChecked ( element . getChecked ( ) , element . getGrayed ( ) ) ; } if ( fCaptureLabelUpdates ) { fCapturedUpdates . add ( updates [ i ] ) ; } else { updates [ i ] . done ( ) ; } } } } public void testLabelUpdatesCompletedOutOfSequence1 ( ) throws InterruptedException { TestModelWithCapturedUpdates model = new TestModelWithCapturedUpdates ( ) ; model . fCaptureLabelUpdates = true ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( model . fCapturedUpdates . size ( ) < model . getRootElement ( ) . fChildren . length ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } List < IViewerUpdate > firstUpdates = model . fCapturedUpdates ; model . fCapturedUpdates = new ArrayList < IViewerUpdate > ( <int> ) ; model . getElement ( model . findElement ( <str> ) ) . setLabelAppendix ( <str> ) ; model . getElement ( model . findElement ( <str> ) ) . setLabelAppendix ( <str> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( model . fCapturedUpdates . size ( ) < model . getRootElement ( ) . fChildren . length ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } for ( int i = <int> ; i < model . fCapturedUpdates . size ( ) ; i + + ) { ( ( ILabelUpdate ) model . fCapturedUpdates . get ( i ) ) . done ( ) ; } for ( int i = <int> ; i < firstUpdates . size ( ) ; i + + ) { ILabelUpdate capturedUpdate = ( ILabelUpdate ) firstUpdates . get ( i ) ; assertTrue ( capturedUpdate . isCanceled ( ) ) ; capturedUpdate . done ( ) ; } while ( ! fListener . isFinished ( CHILDREN_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testLabelUpdatesCompletedOutOfSequence2 ( ) throws InterruptedException { TestModelWithCapturedUpdates model = new TestModelWithCapturedUpdates ( ) ; model . fCaptureLabelUpdates = true ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( model . fCapturedUpdates . size ( ) < model . getRootElement ( ) . fChildren . length ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } List < IViewerUpdate > firstUpdates = model . fCapturedUpdates ; model . fCapturedUpdates = new ArrayList < IViewerUpdate > ( <int> ) ; model . setElementChildren ( TreePath . EMPTY , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( model . fCapturedUpdates . size ( ) < model . getRootElement ( ) . fChildren . length ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } for ( int i = <int> ; i < model . fCapturedUpdates . size ( ) ; i + + ) { ( ( ILabelUpdate ) model . fCapturedUpdates . get ( i ) ) . done ( ) ; } for ( int i = <int> ; i < firstUpdates . size ( ) ; i + + ) { ILabelUpdate capturedUpdate = ( ILabelUpdate ) firstUpdates . get ( i ) ; assertTrue ( capturedUpdate . isCanceled ( ) ) ; capturedUpdate . done ( ) ; } while ( ! fListener . isFinished ( CHILDREN_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void _x_testChildrenUpdatesCompletedOutOfSequence ( ) throws InterruptedException { TestModelWithCapturedUpdates model = new TestModelWithCapturedUpdates ( ) ; model . fCaptureChildrenUpdates = true ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! areCapturedChildrenUpdatesComplete ( model . fCapturedUpdates , model . getRootElement ( ) . fChildren . length ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } IChildrenUpdate [ ] firstUpdates = model . fCapturedUpdates . toArray ( new IChildrenUpdate [ <int> ] ) ; model . fCapturedUpdates . clear ( ) ; model . setElementChildren ( TreePath . EMPTY , new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! areCapturedChildrenUpdatesComplete ( model . fCapturedUpdates , model . getRootElement ( ) . fChildren . length ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } for ( int i = <int> ; i < model . fCapturedUpdates . size ( ) ; i + + ) { ( ( IChildrenUpdate ) model . fCapturedUpdates . get ( i ) ) . done ( ) ; } for ( int i = <int> ; i < firstUpdates . length ; i + + ) { firstUpdates [ i ] . done ( ) ; } while ( ! fListener . isFinished ( CHILDREN_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } private boolean areCapturedChildrenUpdatesComplete ( List < IViewerUpdate > capturedUpdates , int childCount ) { List < Integer > expectedChildren = new ArrayList < Integer > ( ) ; for ( int i = <int> ; i < childCount ; i + + ) { expectedChildren . add ( Integer . valueOf ( i ) ) ; } IChildrenUpdate [ ] updates = capturedUpdates . toArray ( new IChildrenUpdate [ <int> ] ) ; for ( int i = <int> ; i < updates . length ; i + + ) { for ( int j = <int> ; j < updates [ i ] . getLength ( ) ; j + + ) { expectedChildren . remove ( Integer . valueOf ( updates [ i ] . getOffset ( ) + j ) ) ; } } return expectedChildren . isEmpty ( ) ; } } 
