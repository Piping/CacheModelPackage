package org . elasticsearch . index . suggest . stats ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . suggest . SuggestRequestBuilder ; import org . elasticsearch . action . suggest . SuggestResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . search . suggest . phrase . PhraseSuggestionBuilder ; import org . elasticsearch . search . suggest . term . TermSuggestionBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashSet ; import java . util . Set ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAllSuccessful ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( minNumDataNodes = <int> ) public class SuggestStatsIT extends ESIntegTestCase { @Override protected int numberOfReplicas ( ) { return <int> ; } public void testSimpleStats ( ) throws Exception { client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . clear ( ) . execute ( ) . actionGet ( ) ; final int numNodes = cluster ( ) . numDataNodes ( ) ; assertThat ( numNodes , greaterThanOrEqualTo ( <int> ) ) ; final int shardsIdx1 = randomIntBetween ( <int> , <int> ) ; final int shardsIdx2 = Math . max ( numNodes - shardsIdx1 , randomIntBetween ( <int> , <int> ) ) ; final int totalShards = shardsIdx1 + shardsIdx2 ; assertThat ( numNodes , lessThanOrEqualTo ( totalShards ) ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , shardsIdx1 ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) . addMapping ( <str> , <str> , <str> ) ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , shardsIdx2 ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) . addMapping ( <str> , <str> , <str> ) ) ; assertThat ( shardsIdx1 + shardsIdx2 , equalTo ( numAssignedShards ( <str> , <str> ) ) ) ; assertThat ( numAssignedShards ( <str> , <str> ) , greaterThanOrEqualTo ( <int> ) ) ; ensureGreen ( ) ; for ( int i = <int> ; i < randomIntBetween ( <int> , <int> ) ; i + + ) { index ( <str> + ( ( i % <int> ) + <int> ) , <str> , <str> + i , <str> , <str> + i ) ; } refresh ( ) ; int suggestAllIdx = scaledRandomIntBetween ( <int> , <int> ) ; int suggestIdx1 = scaledRandomIntBetween ( <int> , <int> ) ; int suggestIdx2 = scaledRandomIntBetween ( <int> , <int> ) ; long startTime = System . currentTimeMillis ( ) ; for ( int i = <int> ; i < suggestAllIdx ; i + + ) { SuggestResponse suggestResponse = addSuggestions ( internalCluster ( ) . clientNodeClient ( ) . prepareSuggest ( ) , i ) . get ( ) ; assertAllSuccessful ( suggestResponse ) ; } for ( int i = <int> ; i < suggestIdx1 ; i + + ) { SuggestResponse suggestResponse = addSuggestions ( internalCluster ( ) . clientNodeClient ( ) . prepareSuggest ( <str> ) , i ) . get ( ) ; assertAllSuccessful ( suggestResponse ) ; } for ( int i = <int> ; i < suggestIdx2 ; i + + ) { SuggestResponse suggestResponse = addSuggestions ( internalCluster ( ) . clientNodeClient ( ) . prepareSuggest ( <str> ) , i ) . get ( ) ; assertAllSuccessful ( suggestResponse ) ; } long endTime = System . currentTimeMillis ( ) ; IndicesStatsResponse indicesStats = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . execute ( ) . actionGet ( ) ; assertThat ( indicesStats . getTotal ( ) . getSuggest ( ) . getCurrent ( ) , equalTo ( <int> l ) ) ; assertThat ( indicesStats . getTotal ( ) . getSuggest ( ) . getCount ( ) , equalTo ( ( long ) ( suggestAllIdx * totalShards + suggestIdx1 * shardsIdx1 + suggestIdx2 * shardsIdx2 ) ) ) ; assertThat ( indicesStats . getIndices ( ) . get ( <str> ) . getTotal ( ) . getSuggest ( ) . getCount ( ) , equalTo ( ( long ) ( ( suggestAllIdx + suggestIdx1 ) * shardsIdx1 ) ) ) ; assertThat ( indicesStats . getIndices ( ) . get ( <str> ) . getTotal ( ) . getSuggest ( ) . getCount ( ) , equalTo ( ( long ) ( ( suggestAllIdx + suggestIdx2 ) * shardsIdx2 ) ) ) ; logger . info ( <str> , suggestAllIdx , suggestIdx1 , suggestIdx2 , endTime - startTime ) ; assertThat ( indicesStats . getTotal ( ) . getSuggest ( ) . getTimeInMillis ( ) , greaterThan ( <int> l ) ) ; assertThat ( indicesStats . getTotal ( ) . getSuggest ( ) . getTimeInMillis ( ) , lessThanOrEqualTo ( totalShards * ( endTime - startTime ) ) ) ; NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . execute ( ) . actionGet ( ) ; NodeStats [ ] nodes = nodeStats . getNodes ( ) ; Set < String > nodeIdsWithIndex = nodeIdsWithIndex ( <str> , <str> ) ; int num = <int> ; for ( NodeStats stat : nodes ) { SuggestStats suggestStats = stat . getIndices ( ) . getSuggest ( ) ; logger . info ( <str> , stat . getNode ( ) ) ; if ( nodeIdsWithIndex . contains ( stat . getNode ( ) . getId ( ) ) ) { assertThat ( suggestStats . getCount ( ) , greaterThan ( <int> l ) ) ; assertThat ( suggestStats . getTimeInMillis ( ) , greaterThan ( <int> l ) ) ; num + + ; } else { assertThat ( suggestStats . getCount ( ) , equalTo ( <int> l ) ) ; assertThat ( suggestStats . getTimeInMillis ( ) , equalTo ( <int> l ) ) ; } } assertThat ( num , greaterThan ( <int> ) ) ; } private SuggestRequestBuilder addSuggestions ( SuggestRequestBuilder request , int i ) { for ( int s = <int> ; s < randomIntBetween ( <int> , <int> ) ; s + + ) { if ( randomBoolean ( ) ) { request . addSuggestion ( new PhraseSuggestionBuilder ( <str> + s ) . field ( <str> ) . text ( <str> + i + <str> + ( i - <int> ) ) ) ; } else { request . addSuggestion ( new TermSuggestionBuilder ( <str> + s ) . field ( <str> ) . text ( <str> + i ) ) ; } } return request ; } private Set < String > nodeIdsWithIndex ( String . . . indices ) { ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; GroupShardsIterator allAssignedShardsGrouped = state . routingTable ( ) . allAssignedShardsGrouped ( indices , true ) ; Set < String > nodes = new HashSet < > ( ) ; for ( ShardIterator shardIterator : allAssignedShardsGrouped ) { for ( ShardRouting routing : shardIterator . asUnordered ( ) ) { if ( routing . active ( ) ) { nodes . add ( routing . currentNodeId ( ) ) ; } } } return nodes ; } protected int numAssignedShards ( String . . . indices ) { ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; GroupShardsIterator allAssignedShardsGrouped = state . routingTable ( ) . allAssignedShardsGrouped ( indices , true ) ; return allAssignedShardsGrouped . size ( ) ; } } 
