package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Cubemap ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . CubemapAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . shaders . DefaultShader . Config ; import com . badlogic . gdx . graphics . g3d . utils . CameraInputController ; import com . badlogic . gdx . graphics . g3d . utils . DefaultShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . graphics . glutils . KTXTextureData ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . tests . utils . GdxTest ; public class KTXTest extends GdxTest { private PerspectiveCamera perspectiveCamera ; private CameraInputController inputController ; private ModelBatch modelBatch ; private Model model ; private ModelInstance instance ; private Environment environment ; private Cubemap cubemap ; private OrthographicCamera orthoCamera ; private Texture image ; private SpriteBatch batch ; private ShaderProgram etc1aShader ; private float time ; @Override public void create ( ) { String cubemapVS = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; String cubemapFS = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; modelBatch = new ModelBatch ( new DefaultShaderProvider ( new Config ( cubemapVS , cubemapFS ) ) ) ; cubemap = new Cubemap ( new KTXTextureData ( Gdx . files . internal ( <str> ) , true ) ) ; cubemap . setFilter ( TextureFilter . MipMapLinearLinear , TextureFilter . Linear ) ; environment = new Environment ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; environment . add ( new DirectionalLight ( ) . set ( <float> , <float> , <float> , - <float> , - <float> , - <float> ) ) ; environment . set ( new CubemapAttribute ( CubemapAttribute . EnvironmentMap , cubemap ) ) ; perspectiveCamera = new PerspectiveCamera ( <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; perspectiveCamera . position . set ( <int> f , <int> f , <int> f ) ; perspectiveCamera . lookAt ( <int> , <int> , <int> ) ; perspectiveCamera . near = <float> ; perspectiveCamera . far = <int> f ; perspectiveCamera . update ( ) ; ModelBuilder modelBuilder = new ModelBuilder ( ) ; model = modelBuilder . createBox ( <float> , <float> , <float> , new Material ( ColorAttribute . createDiffuse ( Color . GREEN ) ) , Usage . Position | Usage . Normal ) ; instance = new ModelInstance ( model ) ; Gdx . input . setInputProcessor ( new InputMultiplexer ( this , inputController = new CameraInputController ( perspectiveCamera ) ) ) ; String etc1aVS = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; String etc1aFS = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; etc1aShader = new ShaderProgram ( etc1aVS , etc1aFS ) ; orthoCamera = new OrthographicCamera ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; image = new Texture ( <str> ) ; batch = new SpriteBatch ( <int> , etc1aShader ) ; } @Override public void render ( ) { time + = Gdx . graphics . getDeltaTime ( ) ; inputController . update ( ) ; int gw = Gdx . graphics . getWidth ( ) , gh = Gdx . graphics . getHeight ( ) ; int pw = gw > gh ? gw / <int> : gw , ph = gw > gh ? gh : gh / <int> ; Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; Gdx . gl . glViewport ( gw - pw , gh - ph , pw , ph ) ; perspectiveCamera . viewportWidth = pw ; perspectiveCamera . viewportHeight = ph ; perspectiveCamera . update ( ) ; modelBatch . begin ( perspectiveCamera ) ; modelBatch . render ( instance , environment ) ; modelBatch . end ( ) ; Gdx . gl . glViewport ( <int> , <int> , pw , ph ) ; orthoCamera . viewportWidth = pw ; orthoCamera . viewportHeight = ph ; orthoCamera . update ( ) ; batch . setProjectionMatrix ( orthoCamera . combined ) ; batch . begin ( ) ; float s = <float> + <float> * ( <int> + MathUtils . sinDeg ( time * <float> ) ) ; float w = s * image . getWidth ( ) , h = s * image . getHeight ( ) / <int> , x = - w / <int> , y = - h / <int> ; batch . setShader ( null ) ; batch . disableBlending ( ) ; batch . draw ( image , - pw / <int> , - ph / <int> , pw , ph , <int> , <int> , <int> , <int> ) ; batch . setShader ( etc1aShader ) ; batch . enableBlending ( ) ; batch . draw ( image , x , y , w , h , <int> , <float> , <int> , <int> ) ; batch . end ( ) ; } @Override public void dispose ( ) { modelBatch . dispose ( ) ; model . dispose ( ) ; cubemap . dispose ( ) ; image . dispose ( ) ; batch . dispose ( ) ; etc1aShader . dispose ( ) ; } public boolean needsGL20 ( ) { return true ; } public void resume ( ) { } public void resize ( int width , int height ) { } public void pause ( ) { } } 
