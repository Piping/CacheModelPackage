package org . elasticsearch . action . admin . indices . shards ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . ImmutableOpenIntMap ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . transport . NodeDisconnectedException ; import java . io . IOException ; import java . util . * ; import static org . hamcrest . Matchers . equalTo ; public class IndicesShardStoreResponseTests extends ESTestCase { public void testBasicSerialization ( ) throws Exception { ImmutableOpenMap . Builder < String , ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > > indexStoreStatuses = ImmutableOpenMap . builder ( ) ; List < IndicesShardStoresResponse . Failure > failures = new ArrayList < > ( ) ; ImmutableOpenIntMap . Builder < List < IndicesShardStoresResponse . StoreStatus > > storeStatuses = ImmutableOpenIntMap . builder ( ) ; DiscoveryNode node1 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; DiscoveryNode node2 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; List < IndicesShardStoresResponse . StoreStatus > storeStatusList = new ArrayList < > ( ) ; storeStatusList . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . PRIMARY , null ) ) ; storeStatusList . add ( new IndicesShardStoresResponse . StoreStatus ( node2 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . REPLICA , null ) ) ; storeStatusList . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . UNUSED , new IOException ( <str> ) ) ) ; storeStatuses . put ( <int> , storeStatusList ) ; storeStatuses . put ( <int> , storeStatusList ) ; ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > storesMap = storeStatuses . build ( ) ; indexStoreStatuses . put ( <str> , storesMap ) ; indexStoreStatuses . put ( <str> , storesMap ) ; failures . add ( new IndicesShardStoresResponse . Failure ( <str> , <str> , <int> , new NodeDisconnectedException ( node1 , <str> ) ) ) ; IndicesShardStoresResponse storesResponse = new IndicesShardStoresResponse ( indexStoreStatuses . build ( ) , Collections . unmodifiableList ( failures ) ) ; XContentBuilder contentBuilder = XContentFactory . jsonBuilder ( ) ; contentBuilder . startObject ( ) ; storesResponse . toXContent ( contentBuilder , ToXContent . EMPTY_PARAMS ) ; contentBuilder . endObject ( ) ; BytesReference bytes = contentBuilder . bytes ( ) ; try ( XContentParser parser = XContentFactory . xContent ( XContentType . JSON ) . createParser ( bytes ) ) { Map < String , Object > map = parser . map ( ) ; List failureList = ( List ) map . get ( <str> ) ; assertThat ( failureList . size ( ) , equalTo ( <int> ) ) ; HashMap failureMap = ( HashMap ) failureList . get ( <int> ) ; assertThat ( failureMap . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( ( ( String ) failureMap . get ( <str> ) ) , equalTo ( <str> ) ) ; assertThat ( failureMap . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( ( ( int ) failureMap . get ( <str> ) ) , equalTo ( <int> ) ) ; assertThat ( failureMap . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( ( ( String ) failureMap . get ( <str> ) ) , equalTo ( <str> ) ) ; Map < String , Object > indices = ( Map < String , Object > ) map . get ( <str> ) ; for ( String index : new String [ ] { <str> , <str> } ) { assertThat ( indices . containsKey ( index ) , equalTo ( true ) ) ; Map < String , Object > shards = ( ( Map < String , Object > ) ( ( Map < String , Object > ) indices . get ( index ) ) . get ( <str> ) ) ; assertThat ( shards . size ( ) , equalTo ( <int> ) ) ; for ( String shardId : shards . keySet ( ) ) { HashMap shardStoresStatus = ( HashMap ) shards . get ( shardId ) ; assertThat ( shardStoresStatus . containsKey ( <str> ) , equalTo ( true ) ) ; List stores = ( ArrayList ) shardStoresStatus . get ( <str> ) ; assertThat ( stores . size ( ) , equalTo ( storeStatusList . size ( ) ) ) ; for ( int i = <int> ; i < stores . size ( ) ; i + + ) { HashMap storeInfo = ( ( HashMap ) stores . get ( i ) ) ; IndicesShardStoresResponse . StoreStatus storeStatus = storeStatusList . get ( i ) ; assertThat ( storeInfo . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( ( ( int ) storeInfo . get ( <str> ) ) , equalTo ( ( ( int ) storeStatus . getVersion ( ) ) ) ) ; assertThat ( storeInfo . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( ( ( String ) storeInfo . get ( <str> ) ) , equalTo ( storeStatus . getAllocation ( ) . value ( ) ) ) ; assertThat ( storeInfo . containsKey ( storeStatus . getNode ( ) . id ( ) ) , equalTo ( true ) ) ; if ( storeStatus . getStoreException ( ) ! = null ) { assertThat ( storeInfo . containsKey ( <str> ) , equalTo ( true ) ) ; } } } } } } public void testStoreStatusOrdering ( ) throws Exception { DiscoveryNode node1 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; List < IndicesShardStoresResponse . StoreStatus > orderedStoreStatuses = new ArrayList < > ( ) ; orderedStoreStatuses . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . PRIMARY , null ) ) ; orderedStoreStatuses . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . PRIMARY , null ) ) ; orderedStoreStatuses . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . REPLICA , null ) ) ; orderedStoreStatuses . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . UNUSED , null ) ) ; orderedStoreStatuses . add ( new IndicesShardStoresResponse . StoreStatus ( node1 , <int> , IndicesShardStoresResponse . StoreStatus . Allocation . REPLICA , new IOException ( <str> ) ) ) ; List < IndicesShardStoresResponse . StoreStatus > storeStatuses = new ArrayList < > ( orderedStoreStatuses ) ; Collections . shuffle ( storeStatuses , random ( ) ) ; CollectionUtil . timSort ( storeStatuses ) ; assertThat ( storeStatuses , equalTo ( orderedStoreStatuses ) ) ; } } 
