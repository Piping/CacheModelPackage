package org . gradle . launcher . daemon . registry ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . cache . PersistentStateCache ; import org . gradle . cache . internal . FileIntegrityViolationSuppressingPersistentStateCacheDecorator ; import org . gradle . cache . internal . FileLockManager ; import org . gradle . cache . internal . OnDemandFileAccess ; import org . gradle . cache . internal . SimpleStateCache ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . messaging . remote . Address ; import org . gradle . internal . serialize . DefaultSerializer ; import java . io . File ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class PersistentDaemonRegistry implements DaemonRegistry { private final PersistentStateCache < DaemonRegistryContent > cache ; private final Lock lock = new ReentrantLock ( ) ; private final File registryFile ; private static final Logger LOGGER = Logging . getLogger ( PersistentDaemonRegistry . class ) ; public PersistentDaemonRegistry ( File registryFile , FileLockManager fileLockManager ) { this . registryFile = registryFile ; cache = new FileIntegrityViolationSuppressingPersistentStateCacheDecorator < DaemonRegistryContent > ( new SimpleStateCache < DaemonRegistryContent > ( registryFile , new OnDemandFileAccess ( registryFile , <str> , fileLockManager ) , new DefaultSerializer < DaemonRegistryContent > ( ) ) ) ; } public List < DaemonInfo > getAll ( ) { lock . lock ( ) ; try { DaemonRegistryContent content = cache . get ( ) ; if ( content = = null ) { return new LinkedList < DaemonInfo > ( ) ; } return content . getInfos ( ) ; } finally { lock . unlock ( ) ; } } public List < DaemonInfo > getIdle ( ) { lock . lock ( ) ; try { List < DaemonInfo > out = new LinkedList < DaemonInfo > ( ) ; List < DaemonInfo > all = getAll ( ) ; for ( DaemonInfo d : all ) { if ( d . isIdle ( ) ) { out . add ( d ) ; } } return out ; } finally { lock . unlock ( ) ; } } public List < DaemonInfo > getBusy ( ) { lock . lock ( ) ; try { List < DaemonInfo > out = new LinkedList < DaemonInfo > ( ) ; List < DaemonInfo > all = getAll ( ) ; for ( DaemonInfo d : all ) { if ( ! d . isIdle ( ) ) { out . add ( d ) ; } } return out ; } finally { lock . unlock ( ) ; } } public void remove ( final Address address ) { lock . lock ( ) ; LOGGER . debug ( <str> , address ) ; try { cache . update ( new PersistentStateCache . UpdateAction < DaemonRegistryContent > ( ) { public DaemonRegistryContent update ( DaemonRegistryContent oldValue ) { if ( oldValue = = null ) { return oldValue ; } oldValue . removeInfo ( address ) ; return oldValue ; } } ) ; } finally { lock . unlock ( ) ; } } public void markBusy ( final Address address ) { lock . lock ( ) ; LOGGER . debug ( <str> , address ) ; try { cache . update ( new PersistentStateCache . UpdateAction < DaemonRegistryContent > ( ) { public DaemonRegistryContent update ( DaemonRegistryContent oldValue ) { DaemonInfo daemonInfo = oldValue ! = null ? oldValue . getInfo ( address ) : null ; if ( daemonInfo ! = null ) { daemonInfo . setIdle ( false ) ; } return oldValue ; } } ) ; } finally { lock . unlock ( ) ; } } public void markIdle ( final Address address ) { lock . lock ( ) ; LOGGER . debug ( <str> , address ) ; try { cache . update ( new PersistentStateCache . UpdateAction < DaemonRegistryContent > ( ) { public DaemonRegistryContent update ( DaemonRegistryContent oldValue ) { DaemonInfo daemonInfo = oldValue ! = null ? oldValue . getInfo ( address ) : null ; if ( daemonInfo ! = null ) { daemonInfo . setIdle ( true ) ; } return oldValue ; } } ) ; } finally { lock . unlock ( ) ; } } public void store ( final Address address , final DaemonContext daemonContext , final String password , final boolean idle ) { lock . lock ( ) ; LOGGER . debug ( <str> , address , daemonContext ) ; try { cache . update ( new PersistentStateCache . UpdateAction < DaemonRegistryContent > ( ) { public DaemonRegistryContent update ( DaemonRegistryContent oldValue ) { if ( oldValue = = null ) { oldValue = new DaemonRegistryContent ( ) ; } DaemonInfo daemonInfo = new DaemonInfo ( address , daemonContext , password , idle ) ; oldValue . setStatus ( address , daemonInfo ) ; return oldValue ; } } ) ; } finally { lock . unlock ( ) ; } } public String toString ( ) { return String . format ( <str> , registryFile ) ; } } 
