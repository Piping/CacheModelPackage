package org . apache . cassandra . db . partitions ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . io . util . * ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . btree . BTree ; import org . apache . cassandra . utils . btree . UpdateFunction ; public class PartitionUpdate extends AbstractBTreePartition { protected static final Logger logger = LoggerFactory . getLogger ( PartitionUpdate . class ) ; public static final PartitionUpdateSerializer serializer = new PartitionUpdateSerializer ( ) ; private final int createdAtInSec = FBUtilities . nowInSeconds ( ) ; private boolean isBuilt ; private boolean canReOpen = true ; private Holder holder ; private BTree . Builder < Row > rowBuilder ; private MutableDeletionInfo deletionInfo ; private final boolean canHaveShadowedData ; private PartitionUpdate ( CFMetaData metadata , DecoratedKey key , PartitionColumns columns , MutableDeletionInfo deletionInfo , int initialRowCapacity , boolean canHaveShadowedData ) { super ( metadata , key ) ; this . deletionInfo = deletionInfo ; this . holder = new Holder ( columns , BTree . empty ( ) , deletionInfo , Rows . EMPTY_STATIC_ROW , EncodingStats . NO_STATS ) ; this . canHaveShadowedData = canHaveShadowedData ; rowBuilder = builder ( initialRowCapacity ) ; } private PartitionUpdate ( CFMetaData metadata , DecoratedKey key , Holder holder , MutableDeletionInfo deletionInfo , boolean canHaveShadowedData ) { super ( metadata , key ) ; this . holder = holder ; this . deletionInfo = deletionInfo ; this . isBuilt = true ; this . canHaveShadowedData = canHaveShadowedData ; } public PartitionUpdate ( CFMetaData metadata , DecoratedKey key , PartitionColumns columns , int initialRowCapacity ) { this ( metadata , key , columns , MutableDeletionInfo . live ( ) , initialRowCapacity , true ) ; } public PartitionUpdate ( CFMetaData metadata , ByteBuffer key , PartitionColumns columns , int initialRowCapacity ) { this ( metadata , metadata . decorateKey ( key ) , columns , initialRowCapacity ) ; } public static PartitionUpdate emptyUpdate ( CFMetaData metadata , DecoratedKey key ) { MutableDeletionInfo deletionInfo = MutableDeletionInfo . live ( ) ; Holder holder = new Holder ( PartitionColumns . NONE , BTree . empty ( ) , deletionInfo , Rows . EMPTY_STATIC_ROW , EncodingStats . NO_STATS ) ; return new PartitionUpdate ( metadata , key , holder , deletionInfo , false ) ; } public static PartitionUpdate fullPartitionDelete ( CFMetaData metadata , DecoratedKey key , long timestamp , int nowInSec ) { MutableDeletionInfo deletionInfo = new MutableDeletionInfo ( timestamp , nowInSec ) ; Holder holder = new Holder ( PartitionColumns . NONE , BTree . empty ( ) , deletionInfo , Rows . EMPTY_STATIC_ROW , EncodingStats . NO_STATS ) ; return new PartitionUpdate ( metadata , key , holder , deletionInfo , false ) ; } public static PartitionUpdate singleRowUpdate ( CFMetaData metadata , DecoratedKey key , Row row ) { MutableDeletionInfo deletionInfo = MutableDeletionInfo . live ( ) ; if ( row . isStatic ( ) ) { Holder holder = new Holder ( new PartitionColumns ( Columns . from ( row . columns ( ) ) , Columns . NONE ) , BTree . empty ( ) , deletionInfo , row , EncodingStats . NO_STATS ) ; return new PartitionUpdate ( metadata , key , holder , deletionInfo , false ) ; } else { Holder holder = new Holder ( new PartitionColumns ( Columns . NONE , Columns . from ( row . columns ( ) ) ) , BTree . singleton ( row ) , deletionInfo , Rows . EMPTY_STATIC_ROW , EncodingStats . NO_STATS ) ; return new PartitionUpdate ( metadata , key , holder , deletionInfo , false ) ; } } public static PartitionUpdate singleRowUpdate ( CFMetaData metadata , ByteBuffer key , Row row ) { return singleRowUpdate ( metadata , metadata . decorateKey ( key ) , row ) ; } public static PartitionUpdate fromIterator ( UnfilteredRowIterator iterator ) { Holder holder = build ( iterator , <int> ) ; MutableDeletionInfo deletionInfo = ( MutableDeletionInfo ) holder . deletionInfo ; return new PartitionUpdate ( iterator . metadata ( ) , iterator . partitionKey ( ) , holder , deletionInfo , false ) ; } public static PartitionUpdate fromIterator ( RowIterator iterator ) { MutableDeletionInfo deletionInfo = MutableDeletionInfo . live ( ) ; Holder holder = build ( iterator , deletionInfo , true , <int> ) ; return new PartitionUpdate ( iterator . metadata ( ) , iterator . partitionKey ( ) , holder , deletionInfo , false ) ; } protected boolean canHaveShadowedData ( ) { return canHaveShadowedData ; } public static PartitionUpdate fromBytes ( ByteBuffer bytes , int version , DecoratedKey key ) { if ( bytes = = null ) return null ; try { return serializer . deserialize ( new DataInputBuffer ( bytes , true ) , version , SerializationHelper . Flag . LOCAL , version < MessagingService . VERSION_30 ? key : null ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static ByteBuffer toBytes ( PartitionUpdate update , int version ) { try ( DataOutputBuffer out = new DataOutputBuffer ( ) ) { serializer . serialize ( update , out , version ) ; return ByteBuffer . wrap ( out . getData ( ) , <int> , out . getLength ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static PartitionUpdate fullPartitionDelete ( CFMetaData metadata , ByteBuffer key , long timestamp , int nowInSec ) { return fullPartitionDelete ( metadata , metadata . decorateKey ( key ) , timestamp , nowInSec ) ; } public static PartitionUpdate merge ( List < PartitionUpdate > updates ) { assert ! updates . isEmpty ( ) ; final int size = updates . size ( ) ; if ( size = = <int> ) return Iterables . getOnlyElement ( updates ) ; int nowInSecs = FBUtilities . nowInSeconds ( ) ; List < UnfilteredRowIterator > asIterators = Lists . transform ( updates , AbstractBTreePartition : : unfilteredIterator ) ; return fromIterator ( UnfilteredRowIterators . merge ( asIterators , nowInSecs ) ) ; } public void updateAllTimestamp ( long newTimestamp ) { Holder holder = holder ( ) ; deletionInfo . updateAllTimestamp ( newTimestamp - <int> ) ; Object [ ] tree = BTree . < Row > transformAndFilter ( holder . tree , ( x ) - > x . updateAllTimestamp ( newTimestamp ) ) ; Row staticRow = holder . staticRow . updateAllTimestamp ( newTimestamp ) ; EncodingStats newStats = EncodingStats . Collector . collect ( staticRow , BTree . < Row > iterator ( tree ) , deletionInfo ) ; this . holder = new Holder ( holder . columns , tree , deletionInfo , staticRow , newStats ) ; } public int operationCount ( ) { return rowCount ( ) + ( staticRow ( ) . isEmpty ( ) ? <int> : <int> ) + deletionInfo . rangeCount ( ) + ( deletionInfo . getPartitionDeletion ( ) . isLive ( ) ? <int> : <int> ) ; } public int dataSize ( ) { int size = <int> ; for ( Row row : this ) { size + = row . clustering ( ) . dataSize ( ) ; for ( ColumnData cd : row ) size + = cd . dataSize ( ) ; } return size ; } @Override public PartitionColumns columns ( ) { return holder . columns ; } protected Holder holder ( ) { maybeBuild ( ) ; return holder ; } public EncodingStats stats ( ) { return holder ( ) . stats ; } public synchronized void allowNewUpdates ( ) { if ( ! canReOpen ) throw new IllegalStateException ( <str> ) ; isBuilt = false ; if ( rowBuilder = = null ) rowBuilder = builder ( <int> ) ; } private BTree . Builder < Row > builder ( int initialCapacity ) { return BTree . < Row > builder ( metadata . comparator , initialCapacity ) . setQuickResolver ( ( a , b ) - > Rows . merge ( a , b , createdAtInSec ) ) ; } @Override public Iterator < Row > iterator ( ) { maybeBuild ( ) ; return super . iterator ( ) ; } @Override public SliceableUnfilteredRowIterator sliceableUnfilteredIterator ( ColumnFilter columns , boolean reversed ) { maybeBuild ( ) ; return super . sliceableUnfilteredIterator ( columns , reversed ) ; } public void validate ( ) { for ( Row row : this ) { metadata ( ) . comparator . validate ( row . clustering ( ) ) ; for ( ColumnData cd : row ) cd . validate ( ) ; } } public long maxTimestamp ( ) { maybeBuild ( ) ; long maxTimestamp = deletionInfo . maxTimestamp ( ) ; for ( Row row : this ) { maxTimestamp = Math . max ( maxTimestamp , row . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; for ( ColumnData cd : row ) { if ( cd . column ( ) . isSimple ( ) ) { maxTimestamp = Math . max ( maxTimestamp , ( ( Cell ) cd ) . timestamp ( ) ) ; } else { ComplexColumnData complexData = ( ComplexColumnData ) cd ; maxTimestamp = Math . max ( maxTimestamp , complexData . complexDeletion ( ) . markedForDeleteAt ( ) ) ; for ( Cell cell : complexData ) maxTimestamp = Math . max ( maxTimestamp , cell . timestamp ( ) ) ; } } } return maxTimestamp ; } public List < CounterMark > collectCounterMarks ( ) { assert metadata ( ) . isCounter ( ) ; maybeBuild ( ) ; canReOpen = false ; List < CounterMark > l = new ArrayList < > ( ) ; for ( Row row : this ) { for ( Cell cell : row . cells ( ) ) { if ( cell . isCounterCell ( ) ) l . add ( new CounterMark ( row , cell . column ( ) , cell . path ( ) ) ) ; } } return l ; } private void assertNotBuilt ( ) { if ( isBuilt ) throw new IllegalStateException ( <str> ) ; } public void addPartitionDeletion ( DeletionTime deletionTime ) { assertNotBuilt ( ) ; deletionInfo . add ( deletionTime ) ; } public void add ( RangeTombstone range ) { assertNotBuilt ( ) ; deletionInfo . add ( range , metadata . comparator ) ; } public void add ( Row row ) { if ( row . isEmpty ( ) ) return ; assertNotBuilt ( ) ; if ( row . isStatic ( ) ) { assert columns ( ) . statics . containsAll ( row . columns ( ) ) : columns ( ) . statics + <str> + row . columns ( ) ; Row staticRow = holder . staticRow . isEmpty ( ) ? row : Rows . merge ( holder . staticRow , row , createdAtInSec ) ; holder = new Holder ( holder . columns , holder . tree , holder . deletionInfo , staticRow , holder . stats ) ; } else { assert columns ( ) . regulars . containsAll ( row . columns ( ) ) : columns ( ) . regulars + <str> + row . columns ( ) ; rowBuilder . add ( row ) ; } } private void maybeBuild ( ) { if ( isBuilt ) return ; build ( ) ; } private synchronized void build ( ) { if ( isBuilt ) return ; Holder holder = this . holder ; Object [ ] cur = holder . tree ; Object [ ] add = rowBuilder . build ( ) ; Object [ ] merged = BTree . < Row > merge ( cur , add , metadata . comparator , UpdateFunction . Simple . of ( ( a , b ) - > Rows . merge ( a , b , createdAtInSec ) ) ) ; assert deletionInfo = = holder . deletionInfo ; EncodingStats newStats = EncodingStats . Collector . collect ( holder . staticRow , BTree . < Row > iterator ( merged ) , deletionInfo ) ; this . holder = new Holder ( holder . columns , merged , holder . deletionInfo , holder . staticRow , newStats ) ; rowBuilder = null ; isBuilt = true ; } public static class PartitionUpdateSerializer { public void serialize ( PartitionUpdate update , DataOutputPlus out , int version ) throws IOException { try ( UnfilteredRowIterator iter = update . sliceableUnfilteredIterator ( ) ) { assert ! iter . isReverseOrder ( ) ; if ( version < MessagingService . VERSION_30 ) { LegacyLayout . serializeAsLegacyPartition ( iter , out , version ) ; } else { CFMetaData . serializer . serialize ( update . metadata ( ) , out , version ) ; UnfilteredRowIteratorSerializer . serializer . serialize ( iter , null , out , version , update . rowCount ( ) ) ; } } } public PartitionUpdate deserialize ( DataInputPlus in , int version , SerializationHelper . Flag flag , ByteBuffer key ) throws IOException { if ( version > = MessagingService . VERSION_30 ) { assert key = = null ; return deserialize30 ( in , version , flag ) ; } else { assert key ! = null ; return deserializePre30 ( in , version , flag , key ) ; } } public PartitionUpdate deserialize ( DataInputPlus in , int version , SerializationHelper . Flag flag , DecoratedKey key ) throws IOException { if ( version > = MessagingService . VERSION_30 ) { return deserialize30 ( in , version , flag ) ; } else { assert key ! = null ; return deserializePre30 ( in , version , flag , key . getKey ( ) ) ; } } private static PartitionUpdate deserialize30 ( DataInputPlus in , int version , SerializationHelper . Flag flag ) throws IOException { CFMetaData metadata = CFMetaData . serializer . deserialize ( in , version ) ; UnfilteredRowIteratorSerializer . Header header = UnfilteredRowIteratorSerializer . serializer . deserializeHeader ( metadata , null , in , version , flag ) ; if ( header . isEmpty ) return emptyUpdate ( metadata , header . key ) ; assert ! header . isReversed ; assert header . rowEstimate > = <int> ; MutableDeletionInfo . Builder deletionBuilder = MutableDeletionInfo . builder ( header . partitionDeletion , metadata . comparator , false ) ; BTree . Builder < Row > rows = BTree . builder ( metadata . comparator , header . rowEstimate ) ; rows . auto ( false ) ; try ( UnfilteredRowIterator partition = UnfilteredRowIteratorSerializer . serializer . deserialize ( in , version , metadata , flag , header ) ) { while ( partition . hasNext ( ) ) { Unfiltered unfiltered = partition . next ( ) ; if ( unfiltered . kind ( ) = = Unfiltered . Kind . ROW ) rows . add ( ( Row ) unfiltered ) ; else deletionBuilder . add ( ( RangeTombstoneMarker ) unfiltered ) ; } } MutableDeletionInfo deletionInfo = deletionBuilder . build ( ) ; return new PartitionUpdate ( metadata , header . key , new Holder ( header . sHeader . columns ( ) , rows . build ( ) , deletionInfo , header . staticRow , header . sHeader . stats ( ) ) , deletionInfo , false ) ; } private static PartitionUpdate deserializePre30 ( DataInputPlus in , int version , SerializationHelper . Flag flag , ByteBuffer key ) throws IOException { try ( UnfilteredRowIterator iterator = LegacyLayout . deserializeLegacyPartition ( in , version , flag , key ) ) { assert iterator ! = null ; return PartitionUpdate . fromIterator ( iterator ) ; } } public long serializedSize ( PartitionUpdate update , int version ) { try ( UnfilteredRowIterator iter = update . sliceableUnfilteredIterator ( ) ) { if ( version < MessagingService . VERSION_30 ) return LegacyLayout . serializedSizeAsLegacyPartition ( iter , version ) ; return CFMetaData . serializer . serializedSize ( update . metadata ( ) , version ) + UnfilteredRowIteratorSerializer . serializer . serializedSize ( iter , null , version , update . rowCount ( ) ) ; } } } public static class CounterMark { private final Row row ; private final ColumnDefinition column ; private final CellPath path ; private CounterMark ( Row row , ColumnDefinition column , CellPath path ) { this . row = row ; this . column = column ; this . path = path ; } public Clustering clustering ( ) { return row . clustering ( ) ; } public ColumnDefinition column ( ) { return column ; } public CellPath path ( ) { return path ; } public ByteBuffer value ( ) { return path = = null ? row . getCell ( column ) . value ( ) : row . getCell ( column , path ) . value ( ) ; } public void setValue ( ByteBuffer value ) { assert row instanceof BTreeRow ; ( ( BTreeRow ) row ) . setValue ( column , path , value ) ; } } } 
