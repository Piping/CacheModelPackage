package com . badlogic . gdx . graphics . glutils ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Disposable ; public class ShapeRenderer implements Disposable { public enum ShapeType { Point ( GL20 . GL_POINTS ) , Line ( GL20 . GL_LINES ) , Filled ( GL20 . GL_TRIANGLES ) ; private final int glType ; ShapeType ( int glType ) { this . glType = glType ; } public int getGlType ( ) { return glType ; } } private final ImmediateModeRenderer renderer ; private boolean matrixDirty = false ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private final Vector2 tmp = new Vector2 ( ) ; private final Color color = new Color ( <int> , <int> , <int> , <int> ) ; private ShapeType shapeType ; private boolean autoShapeType ; private float defaultRectLineWidth = <float> ; public ShapeRenderer ( ) { this ( <int> ) ; } public ShapeRenderer ( int maxVertices ) { this ( maxVertices , null ) ; } public ShapeRenderer ( int maxVertices , ShaderProgram defaultShader ) { if ( defaultShader = = null ) { renderer = new ImmediateModeRenderer20 ( maxVertices , false , true , <int> ) ; } else { renderer = new ImmediateModeRenderer20 ( maxVertices , false , true , <int> , defaultShader ) ; } projectionMatrix . setToOrtho2D ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; matrixDirty = true ; } public void setColor ( Color color ) { this . color . set ( color ) ; } public void setColor ( float r , float g , float b , float a ) { this . color . set ( r , g , b , a ) ; } public Color getColor ( ) { return color ; } public void updateMatrices ( ) { matrixDirty = true ; } public void setProjectionMatrix ( Matrix4 matrix ) { projectionMatrix . set ( matrix ) ; matrixDirty = true ; } public Matrix4 getProjectionMatrix ( ) { return projectionMatrix ; } public void setTransformMatrix ( Matrix4 matrix ) { transformMatrix . set ( matrix ) ; matrixDirty = true ; } public Matrix4 getTransformMatrix ( ) { return transformMatrix ; } public void identity ( ) { transformMatrix . idt ( ) ; matrixDirty = true ; } public void translate ( float x , float y , float z ) { transformMatrix . translate ( x , y , z ) ; matrixDirty = true ; } public void rotate ( float axisX , float axisY , float axisZ , float degrees ) { transformMatrix . rotate ( axisX , axisY , axisZ , degrees ) ; matrixDirty = true ; } public void scale ( float scaleX , float scaleY , float scaleZ ) { transformMatrix . scale ( scaleX , scaleY , scaleZ ) ; matrixDirty = true ; } public void setAutoShapeType ( boolean autoShapeType ) { this . autoShapeType = autoShapeType ; } public void begin ( ) { if ( ! autoShapeType ) throw new IllegalStateException ( <str> ) ; begin ( ShapeType . Line ) ; } public void begin ( ShapeType type ) { if ( shapeType ! = null ) throw new IllegalStateException ( <str> ) ; shapeType = type ; if ( matrixDirty ) { combinedMatrix . set ( projectionMatrix ) ; Matrix4 . mul ( combinedMatrix . val , transformMatrix . val ) ; matrixDirty = false ; } renderer . begin ( combinedMatrix , shapeType . getGlType ( ) ) ; } public void set ( ShapeType type ) { if ( shapeType = = type ) return ; if ( shapeType = = null ) throw new IllegalStateException ( <str> ) ; if ( ! autoShapeType ) throw new IllegalStateException ( <str> ) ; end ( ) ; begin ( type ) ; } public void point ( float x , float y , float z ) { if ( shapeType = = ShapeType . Line ) { float size = defaultRectLineWidth * <float> ; line ( x - size , y - size , z , x + size , y + size , z ) ; return ; } else if ( shapeType = = ShapeType . Filled ) { float size = defaultRectLineWidth * <float> ; box ( x - size , y - size , z - size , defaultRectLineWidth , defaultRectLineWidth , defaultRectLineWidth ) ; return ; } check ( ShapeType . Point , null , <int> ) ; renderer . color ( color ) ; renderer . vertex ( x , y , z ) ; } public final void line ( float x , float y , float z , float x2 , float y2 , float z2 ) { line ( x , y , z , x2 , y2 , z2 , color , color ) ; } public final void line ( Vector3 v0 , Vector3 v1 ) { line ( v0 . x , v0 . y , v0 . z , v1 . x , v1 . y , v1 . z , color , color ) ; } public final void line ( float x , float y , float x2 , float y2 ) { line ( x , y , <float> , x2 , y2 , <float> , color , color ) ; } public final void line ( Vector2 v0 , Vector2 v1 ) { line ( v0 . x , v0 . y , <float> , v1 . x , v1 . y , <float> , color , color ) ; } public final void line ( float x , float y , float x2 , float y2 , Color c1 , Color c2 ) { line ( x , y , <float> , x2 , y2 , <float> , c1 , c2 ) ; } public void line ( float x , float y , float z , float x2 , float y2 , float z2 , Color c1 , Color c2 ) { if ( shapeType = = ShapeType . Filled ) { rectLine ( x , y , x2 , y2 , defaultRectLineWidth ) ; return ; } check ( ShapeType . Line , null , <int> ) ; renderer . color ( c1 . r , c1 . g , c1 . b , c1 . a ) ; renderer . vertex ( x , y , z ) ; renderer . color ( c2 . r , c2 . g , c2 . b , c2 . a ) ; renderer . vertex ( x2 , y2 , z2 ) ; } public void curve ( float x1 , float y1 , float cx1 , float cy1 , float cx2 , float cy2 , float x2 , float y2 , int segments ) { check ( ShapeType . Line , null , segments * <int> + <int> ) ; float colorBits = color . toFloatBits ( ) ; float subdiv_step = <float> / segments ; float subdiv_step2 = subdiv_step * subdiv_step ; float subdiv_step3 = subdiv_step * subdiv_step * subdiv_step ; float pre1 = <int> * subdiv_step ; float pre2 = <int> * subdiv_step2 ; float pre4 = <int> * subdiv_step2 ; float pre5 = <int> * subdiv_step3 ; float tmp1x = x1 - cx1 * <int> + cx2 ; float tmp1y = y1 - cy1 * <int> + cy2 ; float tmp2x = ( cx1 - cx2 ) * <int> - x1 + x2 ; float tmp2y = ( cy1 - cy2 ) * <int> - y1 + y2 ; float fx = x1 ; float fy = y1 ; float dfx = ( cx1 - x1 ) * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3 ; float dfy = ( cy1 - y1 ) * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3 ; float ddfx = tmp1x * pre4 + tmp2x * pre5 ; float ddfy = tmp1y * pre4 + tmp2y * pre5 ; float dddfx = tmp2x * pre5 ; float dddfy = tmp2y * pre5 ; while ( segments - - > <int> ) { renderer . color ( colorBits ) ; renderer . vertex ( fx , fy , <int> ) ; fx + = dfx ; fy + = dfy ; dfx + = ddfx ; dfy + = ddfy ; ddfx + = dddfx ; ddfy + = dddfy ; renderer . color ( colorBits ) ; renderer . vertex ( fx , fy , <int> ) ; } renderer . color ( colorBits ) ; renderer . vertex ( fx , fy , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; } public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; float colorBits = color . toFloatBits ( ) ; if ( shapeType = = ShapeType . Line ) { renderer . color ( colorBits ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 , y1 , <int> ) ; } else { renderer . color ( colorBits ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x3 , y3 , <int> ) ; } } public void triangle ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , Color col1 , Color col2 , Color col3 ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; if ( shapeType = = ShapeType . Line ) { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; } else { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; } } public void rect ( float x , float y , float width , float height ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; float colorBits = color . toFloatBits ( ) ; if ( shapeType = = ShapeType . Line ) { renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; } else { renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; } } public void rect ( float x , float y , float width , float height , Color col1 , Color col2 , Color col3 , Color col4 ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; if ( shapeType = = ShapeType . Line ) { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x , y , <int> ) ; } else { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x + width , y , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x + width , y + height , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x , y + height , <int> ) ; renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x , y , <int> ) ; } } public void rect ( float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float degrees ) { rect ( x , y , originX , originY , width , height , scaleX , scaleY , degrees , color , color , color , color ) ; } public void rect ( float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float degrees , Color col1 , Color col2 , Color col3 , Color col4 ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; float cos = MathUtils . cosDeg ( degrees ) ; float sin = MathUtils . sinDeg ( degrees ) ; float fx = - originX ; float fy = - originY ; float fx2 = width - originX ; float fy2 = height - originY ; if ( scaleX ! = <int> | | scaleY ! = <int> ) { fx * = scaleX ; fy * = scaleY ; fx2 * = scaleX ; fy2 * = scaleY ; } float worldOriginX = x + originX ; float worldOriginY = y + originY ; float x1 = cos * fx - sin * fy + worldOriginX ; float y1 = sin * fx + cos * fy + worldOriginY ; float x2 = cos * fx2 - sin * fy + worldOriginX ; float y2 = sin * fx2 + cos * fy + worldOriginY ; float x3 = cos * fx2 - sin * fy2 + worldOriginX ; float y3 = sin * fx2 + cos * fy2 + worldOriginY ; float x4 = x1 + ( x3 - x2 ) ; float y4 = y3 - ( y2 - y1 ) ; if ( shapeType = = ShapeType . Line ) { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x4 , y4 , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x4 , y4 , <int> ) ; renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; } else { renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( col2 . r , col2 . g , col2 . b , col2 . a ) ; renderer . vertex ( x2 , y2 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col3 . r , col3 . g , col3 . b , col3 . a ) ; renderer . vertex ( x3 , y3 , <int> ) ; renderer . color ( col4 . r , col4 . g , col4 . b , col4 . a ) ; renderer . vertex ( x4 , y4 , <int> ) ; renderer . color ( col1 . r , col1 . g , col1 . b , col1 . a ) ; renderer . vertex ( x1 , y1 , <int> ) ; } } public void rectLine ( float x1 , float y1 , float x2 , float y2 , float width ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; float colorBits = color . toFloatBits ( ) ; Vector2 t = tmp . set ( y2 - y1 , x1 - x2 ) . nor ( ) ; width * = <float> ; float tx = t . x * width ; float ty = t . y * width ; if ( shapeType = = ShapeType . Line ) { renderer . color ( colorBits ) ; renderer . vertex ( x1 + tx , y1 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 - tx , y1 - ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 + tx , y2 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 - tx , y2 - ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 + tx , y2 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 + tx , y1 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 - tx , y2 - ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 - tx , y1 - ty , <int> ) ; } else { renderer . color ( colorBits ) ; renderer . vertex ( x1 + tx , y1 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 - tx , y1 - ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 + tx , y2 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 - tx , y2 - ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 + tx , y2 + ty , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x1 - tx , y1 - ty , <int> ) ; } } public void rectLine ( Vector2 p1 , Vector2 p2 , float width ) { rectLine ( p1 . x , p1 . y , p2 . x , p2 . y , width ) ; } public void box ( float x , float y , float z , float width , float height , float depth ) { depth = - depth ; float colorBits = color . toFloatBits ( ) ; if ( shapeType = = ShapeType . Line ) { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; } else { check ( ShapeType . Line , ShapeType . Filled , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y + height , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + depth ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + width , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; } } public void x ( float x , float y , float size ) { line ( x - size , y - size , x + size , y + size ) ; line ( x - size , y + size , x + size , y - size ) ; } public void x ( Vector2 p , float size ) { x ( p . x , p . y , size ) ; } public void arc ( float x , float y , float radius , float start , float degrees ) { arc ( x , y , radius , start , degrees , Math . max ( <int> , ( int ) ( <int> * ( float ) Math . cbrt ( radius ) * ( degrees / <float> ) ) ) ) ; } public void arc ( float x , float y , float radius , float start , float degrees , int segments ) { if ( segments < = <int> ) throw new IllegalArgumentException ( <str> ) ; float colorBits = color . toFloatBits ( ) ; float theta = ( <int> * MathUtils . PI * ( degrees / <float> ) ) / segments ; float cos = MathUtils . cos ( theta ) ; float sin = MathUtils . sin ( theta ) ; float cx = radius * MathUtils . cos ( start * MathUtils . degreesToRadians ) ; float cy = radius * MathUtils . sin ( start * MathUtils . degreesToRadians ) ; if ( shapeType = = ShapeType . Line ) { check ( ShapeType . Line , ShapeType . Filled , segments * <int> + <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; float temp = cx ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } else { check ( ShapeType . Line , ShapeType . Filled , segments * <int> + <int> ) ; for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; float temp = cx ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } float temp = cx ; cx = <int> ; cy = <int> ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } public void circle ( float x , float y , float radius ) { circle ( x , y , radius , Math . max ( <int> , ( int ) ( <int> * ( float ) Math . cbrt ( radius ) ) ) ) ; } public void circle ( float x , float y , float radius , int segments ) { if ( segments < = <int> ) throw new IllegalArgumentException ( <str> ) ; float colorBits = color . toFloatBits ( ) ; float angle = <int> * MathUtils . PI / segments ; float cos = MathUtils . cos ( angle ) ; float sin = MathUtils . sin ( angle ) ; float cx = radius , cy = <int> ; if ( shapeType = = ShapeType . Line ) { check ( ShapeType . Line , ShapeType . Filled , segments * <int> + <int> ) ; for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; float temp = cx ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } else { check ( ShapeType . Line , ShapeType . Filled , segments * <int> + <int> ) ; segments - - ; for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; float temp = cx ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x , y , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } float temp = cx ; cx = radius ; cy = <int> ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , <int> ) ; } public void ellipse ( float x , float y , float width , float height ) { ellipse ( x , y , width , height , Math . max ( <int> , ( int ) ( <int> * ( float ) Math . cbrt ( Math . max ( width * <float> , height * <float> ) ) ) ) ) ; } public void ellipse ( float x , float y , float width , float height , int segments ) { if ( segments < = <int> ) throw new IllegalArgumentException ( <str> ) ; check ( ShapeType . Line , ShapeType . Filled , segments * <int> ) ; float colorBits = color . toFloatBits ( ) ; float angle = <int> * MathUtils . PI / segments ; float cx = x + width / <int> , cy = y + height / <int> ; if ( shapeType = = ShapeType . Line ) { for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( cx + ( width * <float> * MathUtils . cos ( i * angle ) ) , cy + ( height * <float> * MathUtils . sin ( i * angle ) ) , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( cx + ( width * <float> * MathUtils . cos ( ( i + <int> ) * angle ) ) , cy + ( height * <float> * MathUtils . sin ( ( i + <int> ) * angle ) ) , <int> ) ; } } else { for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( cx + ( width * <float> * MathUtils . cos ( i * angle ) ) , cy + ( height * <float> * MathUtils . sin ( i * angle ) ) , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( cx , cy , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( cx + ( width * <float> * MathUtils . cos ( ( i + <int> ) * angle ) ) , cy + ( height * <float> * MathUtils . sin ( ( i + <int> ) * angle ) ) , <int> ) ; } } } public void cone ( float x , float y , float z , float radius , float height ) { cone ( x , y , z , radius , height , Math . max ( <int> , ( int ) ( <int> * ( float ) Math . sqrt ( radius ) ) ) ) ; } public void cone ( float x , float y , float z , float radius , float height , int segments ) { if ( segments < = <int> ) throw new IllegalArgumentException ( <str> ) ; check ( ShapeType . Line , ShapeType . Filled , segments * <int> + <int> ) ; float colorBits = color . toFloatBits ( ) ; float angle = <int> * MathUtils . PI / segments ; float cos = MathUtils . cos ( angle ) ; float sin = MathUtils . sin ( angle ) ; float cx = radius , cy = <int> ; if ( shapeType = = ShapeType . Line ) { for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + height ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; float temp = cx ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; } else { segments - - ; for ( int i = <int> ; i < segments ; i + + ) { renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; float temp = cx ; float temp2 = cy ; cx = cos * cx - sin * cy ; cy = sin * temp + cos * cy ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + temp , y + temp2 , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + height ) ; } renderer . color ( colorBits ) ; renderer . vertex ( x , y , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; } float temp = cx ; float temp2 = cy ; cx = radius ; cy = <int> ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; if ( shapeType ! = ShapeType . Line ) { renderer . color ( colorBits ) ; renderer . vertex ( x + temp , y + temp2 , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x + cx , y + cy , z ) ; renderer . color ( colorBits ) ; renderer . vertex ( x , y , z + height ) ; } } public void polygon ( float [ ] vertices , int offset , int count ) { if ( count < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( count % <int> ! = <int> ) throw new IllegalArgumentException ( <str> ) ; check ( ShapeType . Line , null , count ) ; float colorBits = color . toFloatBits ( ) ; float firstX = vertices [ <int> ] ; float firstY = vertices [ <int> ] ; for ( int i = offset , n = offset + count ; i < n ; i + = <int> ) { float x1 = vertices [ i ] ; float y1 = vertices [ i + <int> ] ; float x2 ; float y2 ; if ( i + <int> > = count ) { x2 = firstX ; y2 = firstY ; } else { x2 = vertices [ i + <int> ] ; y2 = vertices [ i + <int> ] ; } renderer . color ( colorBits ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; } } public void polygon ( float [ ] vertices ) { polygon ( vertices , <int> , vertices . length ) ; } public void polyline ( float [ ] vertices , int offset , int count ) { if ( count < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( count % <int> ! = <int> ) throw new IllegalArgumentException ( <str> ) ; check ( ShapeType . Line , null , count ) ; float colorBits = color . toFloatBits ( ) ; for ( int i = offset , n = offset + count - <int> ; i < n ; i + = <int> ) { float x1 = vertices [ i ] ; float y1 = vertices [ i + <int> ] ; float x2 ; float y2 ; x2 = vertices [ i + <int> ] ; y2 = vertices [ i + <int> ] ; renderer . color ( colorBits ) ; renderer . vertex ( x1 , y1 , <int> ) ; renderer . color ( colorBits ) ; renderer . vertex ( x2 , y2 , <int> ) ; } } public void polyline ( float [ ] vertices ) { polyline ( vertices , <int> , vertices . length ) ; } private void check ( ShapeType preferred , ShapeType other , int newVertices ) { if ( shapeType = = null ) throw new IllegalStateException ( <str> ) ; if ( shapeType ! = preferred & & shapeType ! = other ) { if ( ! autoShapeType ) { if ( other = = null ) throw new IllegalStateException ( <str> + preferred + <str> ) ; else throw new IllegalStateException ( <str> + preferred + <str> + other + <str> ) ; } end ( ) ; begin ( preferred ) ; } else if ( matrixDirty ) { ShapeType type = shapeType ; end ( ) ; begin ( type ) ; } else if ( renderer . getMaxVertices ( ) - renderer . getNumVertices ( ) < newVertices ) { ShapeType type = shapeType ; end ( ) ; begin ( type ) ; } } public void end ( ) { renderer . end ( ) ; shapeType = null ; } public void flush ( ) { ShapeType type = shapeType ; end ( ) ; begin ( type ) ; } public ShapeType getCurrentType ( ) { return shapeType ; } public ImmediateModeRenderer getRenderer ( ) { return renderer ; } public boolean isDrawing ( ) { return shapeType ! = null ; } public void dispose ( ) { renderer . dispose ( ) ; } } 
