package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import com . google . common . base . Preconditions ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . charset . Charset ; abstract class AbstractStreamingHashFunction implements HashFunction { @Override public < T > HashCode hashObject ( T instance , Funnel < ? super T > funnel ) { return newHasher ( ) . putObject ( instance , funnel ) . hash ( ) ; } @Override public HashCode hashUnencodedChars ( CharSequence input ) { return newHasher ( ) . putUnencodedChars ( input ) . hash ( ) ; } @Override public HashCode hashString ( CharSequence input , Charset charset ) { return newHasher ( ) . putString ( input , charset ) . hash ( ) ; } @Override public HashCode hashInt ( int input ) { return newHasher ( ) . putInt ( input ) . hash ( ) ; } @Override public HashCode hashLong ( long input ) { return newHasher ( ) . putLong ( input ) . hash ( ) ; } @Override public HashCode hashBytes ( byte [ ] input ) { return newHasher ( ) . putBytes ( input ) . hash ( ) ; } @Override public HashCode hashBytes ( byte [ ] input , int off , int len ) { return newHasher ( ) . putBytes ( input , off , len ) . hash ( ) ; } @Override public Hasher newHasher ( int expectedInputSize ) { Preconditions . checkArgument ( expectedInputSize > = <int> ) ; return newHasher ( ) ; } protected static abstract class AbstractStreamingHasher extends AbstractHasher { private final ByteBuffer buffer ; private final int bufferSize ; private final int chunkSize ; protected AbstractStreamingHasher ( int chunkSize ) { this ( chunkSize , chunkSize ) ; } protected AbstractStreamingHasher ( int chunkSize , int bufferSize ) { checkArgument ( bufferSize % chunkSize = = <int> ) ; this . buffer = ByteBuffer . allocate ( bufferSize + <int> ) . order ( ByteOrder . LITTLE_ENDIAN ) ; this . bufferSize = bufferSize ; this . chunkSize = chunkSize ; } protected abstract void process ( ByteBuffer bb ) ; protected void processRemaining ( ByteBuffer bb ) { bb . position ( bb . limit ( ) ) ; bb . limit ( chunkSize + <int> ) ; while ( bb . position ( ) < chunkSize ) { bb . putLong ( <int> ) ; } bb . limit ( chunkSize ) ; bb . flip ( ) ; process ( bb ) ; } @Override public final Hasher putBytes ( byte [ ] bytes ) { return putBytes ( bytes , <int> , bytes . length ) ; } @Override public final Hasher putBytes ( byte [ ] bytes , int off , int len ) { return putBytes ( ByteBuffer . wrap ( bytes , off , len ) . order ( ByteOrder . LITTLE_ENDIAN ) ) ; } private Hasher putBytes ( ByteBuffer readBuffer ) { if ( readBuffer . remaining ( ) < = buffer . remaining ( ) ) { buffer . put ( readBuffer ) ; munchIfFull ( ) ; return this ; } int bytesToCopy = bufferSize - buffer . position ( ) ; for ( int i = <int> ; i < bytesToCopy ; i + + ) { buffer . put ( readBuffer . get ( ) ) ; } munch ( ) ; while ( readBuffer . remaining ( ) > = chunkSize ) { process ( readBuffer ) ; } buffer . put ( readBuffer ) ; return this ; } @Override public final Hasher putUnencodedChars ( CharSequence charSequence ) { for ( int i = <int> ; i < charSequence . length ( ) ; i + + ) { putChar ( charSequence . charAt ( i ) ) ; } return this ; } @Override public final Hasher putByte ( byte b ) { buffer . put ( b ) ; munchIfFull ( ) ; return this ; } @Override public final Hasher putShort ( short s ) { buffer . putShort ( s ) ; munchIfFull ( ) ; return this ; } @Override public final Hasher putChar ( char c ) { buffer . putChar ( c ) ; munchIfFull ( ) ; return this ; } @Override public final Hasher putInt ( int i ) { buffer . putInt ( i ) ; munchIfFull ( ) ; return this ; } @Override public final Hasher putLong ( long l ) { buffer . putLong ( l ) ; munchIfFull ( ) ; return this ; } @Override public final < T > Hasher putObject ( T instance , Funnel < ? super T > funnel ) { funnel . funnel ( instance , this ) ; return this ; } @Override public final HashCode hash ( ) { munch ( ) ; buffer . flip ( ) ; if ( buffer . remaining ( ) > <int> ) { processRemaining ( buffer ) ; } return makeHash ( ) ; } abstract HashCode makeHash ( ) ; private void munchIfFull ( ) { if ( buffer . remaining ( ) < <int> ) { munch ( ) ; } } private void munch ( ) { buffer . flip ( ) ; while ( buffer . remaining ( ) > = chunkSize ) { process ( buffer ) ; } buffer . compact ( ) ; } } } 
