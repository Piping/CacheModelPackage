package org . elasticsearch . indices . memory . breaker ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchRequestBuilder ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . breaker . CircuitBreakingException ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . indices . breaker . BreakerSettings ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . indices . breaker . CircuitBreakerStats ; import org . elasticsearch . indices . breaker . HierarchyCircuitBreakerService ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . junit . After ; import org . junit . Before ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . cardinality ; import static org . elasticsearch . test . ESIntegTestCase . Scope . TEST ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertFailures ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ClusterScope ( scope = TEST , randomDynamicTemplates = false ) public class CircuitBreakerServiceIT extends ESIntegTestCase { private void reset ( ) { logger . info ( <str> ) ; Settings resetSettings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , HierarchyCircuitBreakerService . DEFAULT_FIELDDATA_BREAKER_LIMIT ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , HierarchyCircuitBreakerService . DEFAULT_FIELDDATA_OVERHEAD_CONSTANT ) . put ( HierarchyCircuitBreakerService . REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , HierarchyCircuitBreakerService . DEFAULT_REQUEST_BREAKER_LIMIT ) . put ( HierarchyCircuitBreakerService . REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) . build ( ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( resetSettings ) ) ; } @Before public void setup ( ) { reset ( ) ; } @After public void teardown ( ) { reset ( ) ; } private boolean noopBreakerUsed ( ) { NodesStatsResponse stats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setBreaker ( true ) . get ( ) ; for ( NodeStats nodeStats : stats ) { if ( nodeStats . getBreaker ( ) . getStats ( CircuitBreaker . REQUEST ) . getLimit ( ) = = <int> ) { return true ; } if ( nodeStats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getLimit ( ) = = <int> ) { return true ; } } return false ; } public void testMemoryBreaker ( ) throws Exception { if ( noopBreakerUsed ( ) ) { logger . info ( <str> ) ; return ; } assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_REPLICAS , between ( <int> , <int> ) ) ) ) ; final Client client = client ( ) ; int docCount = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > reqs = new ArrayList < > ( ) ; for ( long id = <int> ; id < docCount ; id + + ) { reqs . add ( client . prepareIndex ( <str> , <str> , Long . toString ( id ) ) . setSource ( <str> , <str> + id ) ) ; } indexRandom ( true , false , true , reqs ) ; clearFieldData ( ) ; Settings settings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) . build ( ) ; assertAcked ( client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settings ) ) ; SearchRequestBuilder searchRequest = client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) ; assertFailures ( searchRequest , RestStatus . INTERNAL_SERVER_ERROR , containsString ( <str> ) ) ; NodesStatsResponse stats = client . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setBreaker ( true ) . get ( ) ; int breaks = <int> ; for ( NodeStats stat : stats . getNodes ( ) ) { CircuitBreakerStats breakerStats = stat . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) ; breaks + = breakerStats . getTrippedCount ( ) ; } assertThat ( breaks , greaterThanOrEqualTo ( <int> ) ) ; } public void testRamAccountingTermsEnum ( ) throws Exception { if ( noopBreakerUsed ( ) ) { logger . info ( <str> ) ; return ; } final Client client = client ( ) ; assertAcked ( prepareCreate ( <str> ) . setSource ( <str> + <str> ) ) ; ensureGreen ( <str> ) ; int docCount = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > reqs = new ArrayList < > ( ) ; for ( long id = <int> ; id < docCount ; id + + ) { reqs . add ( client . prepareIndex ( <str> , <str> , Long . toString ( id ) ) . setSource ( <str> , <str> + id ) ) ; } indexRandom ( true , false , true , reqs ) ; client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) . get ( ) ; clearFieldData ( ) ; Settings settings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) . build ( ) ; assertAcked ( client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settings ) ) ; assertFailures ( client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) , RestStatus . INTERNAL_SERVER_ERROR , containsString ( <str> ) ) ; NodesStatsResponse stats = client . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setBreaker ( true ) . get ( ) ; int breaks = <int> ; for ( NodeStats stat : stats . getNodes ( ) ) { CircuitBreakerStats breakerStats = stat . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) ; breaks + = breakerStats . getTrippedCount ( ) ; } assertThat ( breaks , greaterThanOrEqualTo ( <int> ) ) ; } public void testParentChecking ( ) throws Exception { if ( noopBreakerUsed ( ) ) { logger . info ( <str> ) ; return ; } assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_REPLICAS , between ( <int> , <int> ) ) ) ) ; Client client = client ( ) ; int docCount = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > reqs = new ArrayList < > ( ) ; for ( long id = <int> ; id < docCount ; id + + ) { reqs . add ( client . prepareIndex ( <str> , <str> , Long . toString ( id ) ) . setSource ( <str> , <str> + id ) ) ; } indexRandom ( true , reqs ) ; long beforeReqLimit = client . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setBreaker ( true ) . get ( ) . getNodes ( ) [ <int> ] . getBreaker ( ) . getStats ( CircuitBreaker . REQUEST ) . getLimit ( ) ; Settings resetSettings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) . build ( ) ; assertAcked ( client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( resetSettings ) ) ; try { client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) . get ( ) ; fail ( <str> ) ; } catch ( Exception e ) { String errMsg = <str> ; assertThat ( <str> + e . toString ( ) + <str> , e . toString ( ) . contains ( errMsg ) , equalTo ( true ) ) ; } assertFailures ( client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) , RestStatus . INTERNAL_SERVER_ERROR , containsString ( <str> ) ) ; resetSettings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . put ( HierarchyCircuitBreakerService . FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) . build ( ) ; client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( resetSettings ) . execute ( ) . actionGet ( ) ; try { client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . DESC ) . get ( ) ; fail ( <str> ) ; } catch ( Exception e ) { String errMsg = <str> ; assertThat ( <str> + e . toString ( ) + <str> , e . toString ( ) . contains ( errMsg ) , equalTo ( true ) ) ; } } public void testRequestBreaker ( ) throws Exception { if ( noopBreakerUsed ( ) ) { logger . info ( <str> ) ; return ; } assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_REPLICAS , between ( <int> , <int> ) ) ) ) ; Client client = client ( ) ; Settings resetSettings = settingsBuilder ( ) . put ( HierarchyCircuitBreakerService . REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , <str> ) . build ( ) ; assertAcked ( client . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( resetSettings ) ) ; int docCount = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > reqs = new ArrayList < > ( ) ; for ( long id = <int> ; id < docCount ; id + + ) { reqs . add ( client . prepareIndex ( <str> , <str> , Long . toString ( id ) ) . setSource ( <str> , id ) ) ; } indexRandom ( true , reqs ) ; try { client . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( cardinality ( <str> ) . field ( <str> ) ) . get ( ) ; fail ( <str> ) ; } catch ( Exception e ) { String errMsg = <str> ; assertThat ( <str> + e . toString ( ) + <str> , e . toString ( ) . contains ( errMsg ) , equalTo ( true ) ) ; } } public void clearFieldData ( ) throws Exception { client ( ) . admin ( ) . indices ( ) . prepareClearCache ( ) . setFieldDataCache ( true ) . execute ( ) . actionGet ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { NodesStatsResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . get ( new TimeValue ( <int> , TimeUnit . SECONDS ) ) ; for ( NodeStats nStats : resp . getNodes ( ) ) { assertThat ( <str> , nStats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; } } } , <int> , TimeUnit . SECONDS ) ; } public void testCustomCircuitBreakerRegistration ( ) throws Exception { Iterable < CircuitBreakerService > serviceIter = internalCluster ( ) . getInstances ( CircuitBreakerService . class ) ; final String breakerName = <str> ; BreakerSettings breakerSettings = new BreakerSettings ( breakerName , <int> , <float> ) ; CircuitBreaker breaker = null ; for ( CircuitBreakerService s : serviceIter ) { s . registerBreaker ( breakerSettings ) ; breaker = s . getBreaker ( breakerSettings . getName ( ) ) ; } if ( breaker ! = null ) { try { breaker . addEstimateBytesAndMaybeBreak ( <int> , <str> ) ; } catch ( CircuitBreakingException e ) { } } NodesStatsResponse stats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . get ( ) ; int breaks = <int> ; for ( NodeStats stat : stats . getNodes ( ) ) { CircuitBreakerStats breakerStats = stat . getBreaker ( ) . getStats ( breakerName ) ; breaks + = breakerStats . getTrippedCount ( ) ; } assertThat ( breaks , greaterThanOrEqualTo ( <int> ) ) ; } } 
