package com . badlogic . gdx . graphics ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . math . Frustum ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . Ray ; public abstract class Camera { public final Vector3 position = new Vector3 ( ) ; public final Vector3 direction = new Vector3 ( <int> , <int> , - <int> ) ; public final Vector3 up = new Vector3 ( <int> , <int> , <int> ) ; public final Matrix4 projection = new Matrix4 ( ) ; public final Matrix4 view = new Matrix4 ( ) ; public final Matrix4 combined = new Matrix4 ( ) ; public final Matrix4 invProjectionView = new Matrix4 ( ) ; public float near = <int> ; public float far = <int> ; public float viewportWidth = <int> ; public float viewportHeight = <int> ; public final Frustum frustum = new Frustum ( ) ; private final Vector3 tmpVec = new Vector3 ( ) ; private final Ray ray = new Ray ( new Vector3 ( ) , new Vector3 ( ) ) ; public abstract void update ( ) ; public abstract void update ( boolean updateFrustum ) ; public void lookAt ( float x , float y , float z ) { tmpVec . set ( x , y , z ) . sub ( position ) . nor ( ) ; if ( ! tmpVec . isZero ( ) ) { float dot = tmpVec . dot ( up ) ; if ( Math . abs ( dot - <int> ) < <float> ) { up . set ( direction ) . scl ( - <int> ) ; } else if ( Math . abs ( dot + <int> ) < <float> ) { up . set ( direction ) ; } direction . set ( tmpVec ) ; normalizeUp ( ) ; } } public void lookAt ( Vector3 target ) { lookAt ( target . x , target . y , target . z ) ; } public void normalizeUp ( ) { tmpVec . set ( direction ) . crs ( up ) . nor ( ) ; up . set ( tmpVec ) . crs ( direction ) . nor ( ) ; } public void rotate ( float angle , float axisX , float axisY , float axisZ ) { direction . rotate ( angle , axisX , axisY , axisZ ) ; up . rotate ( angle , axisX , axisY , axisZ ) ; } public void rotate ( Vector3 axis , float angle ) { direction . rotate ( axis , angle ) ; up . rotate ( axis , angle ) ; } public void rotate ( final Matrix4 transform ) { direction . rot ( transform ) ; up . rot ( transform ) ; } public void rotate ( final Quaternion quat ) { quat . transform ( direction ) ; quat . transform ( up ) ; } public void rotateAround ( Vector3 point , Vector3 axis , float angle ) { tmpVec . set ( point ) ; tmpVec . sub ( position ) ; translate ( tmpVec ) ; rotate ( axis , angle ) ; tmpVec . rotate ( axis , angle ) ; translate ( - tmpVec . x , - tmpVec . y , - tmpVec . z ) ; } public void transform ( final Matrix4 transform ) { position . mul ( transform ) ; rotate ( transform ) ; } public void translate ( float x , float y , float z ) { position . add ( x , y , z ) ; } public void translate ( Vector3 vec ) { position . add ( vec ) ; } public Vector3 unproject ( Vector3 screenCoords , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { float x = screenCoords . x , y = screenCoords . y ; x = x - viewportX ; y = Gdx . graphics . getHeight ( ) - y - <int> ; y = y - viewportY ; screenCoords . x = ( <int> * x ) / viewportWidth - <int> ; screenCoords . y = ( <int> * y ) / viewportHeight - <int> ; screenCoords . z = <int> * screenCoords . z - <int> ; screenCoords . prj ( invProjectionView ) ; return screenCoords ; } public Vector3 unproject ( Vector3 screenCoords ) { unproject ( screenCoords , <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; return screenCoords ; } public Vector3 project ( Vector3 worldCoords ) { project ( worldCoords , <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; return worldCoords ; } public Vector3 project ( Vector3 worldCoords , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { worldCoords . prj ( combined ) ; worldCoords . x = viewportWidth * ( worldCoords . x + <int> ) / <int> + viewportX ; worldCoords . y = viewportHeight * ( worldCoords . y + <int> ) / <int> + viewportY ; worldCoords . z = ( worldCoords . z + <int> ) / <int> ; return worldCoords ; } public Ray getPickRay ( float screenX , float screenY , float viewportX , float viewportY , float viewportWidth , float viewportHeight ) { unproject ( ray . origin . set ( screenX , screenY , <int> ) , viewportX , viewportY , viewportWidth , viewportHeight ) ; unproject ( ray . direction . set ( screenX , screenY , <int> ) , viewportX , viewportY , viewportWidth , viewportHeight ) ; ray . direction . sub ( ray . origin ) . nor ( ) ; return ray ; } public Ray getPickRay ( float screenX , float screenY ) { return getPickRay ( screenX , screenY , <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; } } 
