package com . google . common . math ; import static com . google . common . math . MathBenchmarking . ARRAY_MASK ; import static com . google . common . math . MathBenchmarking . ARRAY_SIZE ; import static com . google . common . math . MathBenchmarking . RANDOM_SOURCE ; import static java . math . RoundingMode . CEILING ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . math . BigIntegerMath ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . BigInteger ; public class BigIntegerMathBenchmark { private static final int [ ] factorials = new int [ ARRAY_SIZE ] ; private static final int [ ] slowFactorials = new int [ ARRAY_SIZE ] ; private static final int [ ] binomials = new int [ ARRAY_SIZE ] ; @Param ( { <str> , <str> , <str> } ) int factorialBound ; @BeforeExperiment void setUp ( ) { for ( int i = <int> ; i < ARRAY_SIZE ; i + + ) { factorials [ i ] = RANDOM_SOURCE . nextInt ( factorialBound ) ; slowFactorials [ i ] = RANDOM_SOURCE . nextInt ( factorialBound ) ; binomials [ i ] = RANDOM_SOURCE . nextInt ( factorials [ i ] + <int> ) ; } } private static BigInteger oldSlowFactorial ( int n ) { if ( n < = <int> ) { return BigInteger . valueOf ( LongMath . factorial ( n ) ) ; } else { int k = <int> ; return BigInteger . valueOf ( LongMath . factorial ( k ) ) . multiply ( oldSlowFactorial ( k , n ) ) ; } } private static BigInteger oldSlowFactorial ( int n1 , int n2 ) { assert n1 < = n2 ; if ( IntMath . log2 ( n2 , CEILING ) * ( n2 - n1 ) < Long . SIZE - <int> ) { long result = <int> ; for ( int i = n1 + <int> ; i < = n2 ; i + + ) { result * = i ; } return BigInteger . valueOf ( result ) ; } int mid = ( n1 + n2 ) > > > <int> ; return oldSlowFactorial ( n1 , mid ) . multiply ( oldSlowFactorial ( mid , n2 ) ) ; } @Benchmark int slowFactorial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = oldSlowFactorial ( slowFactorials [ j ] ) . intValue ( ) ; } return tmp ; } @Benchmark int factorial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = BigIntegerMath . factorial ( factorials [ j ] ) . intValue ( ) ; } return tmp ; } @Benchmark int binomial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & <hex> ; tmp + = BigIntegerMath . binomial ( factorials [ j ] , binomials [ j ] ) . intValue ( ) ; } return tmp ; } } 
