package org . gradle . execution . taskgraph ; import groovy . lang . Closure ; import org . gradle . api . Action ; import org . gradle . api . Task ; import org . gradle . api . execution . TaskExecutionGraphListener ; import org . gradle . api . execution . TaskExecutionListener ; import org . gradle . api . execution . internal . InternalTaskExecutionListener ; import org . gradle . api . execution . internal . TaskOperationInternal ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . tasks . TaskExecuter ; import org . gradle . api . internal . tasks . TaskStateInternal ; import org . gradle . api . internal . tasks . execution . DefaultTaskExecutionContext ; import org . gradle . api . specs . Spec ; import org . gradle . execution . TaskFailureHandler ; import org . gradle . execution . TaskGraphExecuter ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . Factory ; import org . gradle . internal . TimeProvider ; import org . gradle . internal . event . ListenerBroadcast ; import org . gradle . internal . event . ListenerManager ; import org . gradle . internal . progress . BuildOperationExecutor ; import org . gradle . internal . progress . OperationIdGenerator ; import org . gradle . internal . progress . OperationResult ; import org . gradle . internal . progress . OperationStartEvent ; import org . gradle . listener . ClosureBackedMethodInvocationDispatch ; import org . gradle . util . Clock ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; public class DefaultTaskGraphExecuter implements TaskGraphExecuter { private static Logger logger = LoggerFactory . getLogger ( DefaultTaskGraphExecuter . class ) ; private enum TaskGraphState { EMPTY , DIRTY , POPULATED } private final TaskPlanExecutor taskPlanExecutor ; private final Factory < ? extends TaskExecuter > taskExecuter ; private final TimeProvider timeProvider ; private final ListenerBroadcast < TaskExecutionGraphListener > graphListeners ; private final ListenerBroadcast < TaskExecutionListener > taskListeners ; private final ListenerBroadcast < InternalTaskExecutionListener > internalTaskListeners ; private final DefaultTaskExecutionPlan taskExecutionPlan ; private final BuildOperationExecutor buildOperationExecutor ; private TaskGraphState taskGraphState = TaskGraphState . EMPTY ; public DefaultTaskGraphExecuter ( ListenerManager listenerManager , TaskPlanExecutor taskPlanExecutor , Factory < ? extends TaskExecuter > taskExecuter , BuildCancellationToken cancellationToken , TimeProvider timeProvider , BuildOperationExecutor buildOperationExecutor ) { this . taskPlanExecutor = taskPlanExecutor ; this . taskExecuter = taskExecuter ; this . timeProvider = timeProvider ; this . buildOperationExecutor = buildOperationExecutor ; graphListeners = listenerManager . createAnonymousBroadcaster ( TaskExecutionGraphListener . class ) ; taskListeners = listenerManager . createAnonymousBroadcaster ( TaskExecutionListener . class ) ; internalTaskListeners = listenerManager . createAnonymousBroadcaster ( InternalTaskExecutionListener . class ) ; taskExecutionPlan = new DefaultTaskExecutionPlan ( cancellationToken ) ; } public void useFailureHandler ( TaskFailureHandler handler ) { taskExecutionPlan . useFailureHandler ( handler ) ; } public void useFilter ( Spec < ? super Task > filter ) { taskExecutionPlan . useFilter ( filter ) ; taskGraphState = TaskGraphState . DIRTY ; } public void addTasks ( Iterable < ? extends Task > tasks ) { assert tasks ! = null ; Clock clock = new Clock ( ) ; Set < Task > taskSet = new LinkedHashSet < Task > ( ) ; for ( Task task : tasks ) { taskSet . add ( task ) ; } taskExecutionPlan . addToTaskGraph ( taskSet ) ; taskGraphState = TaskGraphState . DIRTY ; logger . debug ( <str> + clock . getTime ( ) ) ; } public void execute ( ) { Clock clock = new Clock ( ) ; ensurePopulated ( ) ; graphListeners . getSource ( ) . graphPopulated ( this ) ; try { taskPlanExecutor . process ( taskExecutionPlan , new EventFiringTaskWorker ( taskExecuter . create ( ) , buildOperationExecutor . getCurrentOperationId ( ) ) ) ; logger . debug ( <str> + clock . getTime ( ) ) ; } finally { taskExecutionPlan . clear ( ) ; } } public void addTaskExecutionGraphListener ( TaskExecutionGraphListener listener ) { graphListeners . add ( listener ) ; } public void removeTaskExecutionGraphListener ( TaskExecutionGraphListener listener ) { graphListeners . remove ( listener ) ; } public void whenReady ( final Closure closure ) { graphListeners . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void addTaskExecutionListener ( TaskExecutionListener listener ) { taskListeners . add ( listener ) ; } public void removeTaskExecutionListener ( TaskExecutionListener listener ) { taskListeners . remove ( listener ) ; } public void beforeTask ( final Closure closure ) { taskListeners . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public void afterTask ( final Closure closure ) { taskListeners . add ( new ClosureBackedMethodInvocationDispatch ( <str> , closure ) ) ; } public boolean hasTask ( Task task ) { ensurePopulated ( ) ; return taskExecutionPlan . getTasks ( ) . contains ( task ) ; } public boolean hasTask ( String path ) { ensurePopulated ( ) ; assert path ! = null & & path . length ( ) > <int> ; for ( Task task : taskExecutionPlan . getTasks ( ) ) { if ( task . getPath ( ) . equals ( path ) ) { return true ; } } return false ; } public List < Task > getAllTasks ( ) { ensurePopulated ( ) ; return taskExecutionPlan . getTasks ( ) ; } private void ensurePopulated ( ) { switch ( taskGraphState ) { case EMPTY : throw new IllegalStateException ( <str> ) ; case DIRTY : taskExecutionPlan . determineExecutionPlan ( ) ; taskGraphState = TaskGraphState . POPULATED ; return ; case POPULATED : } } private class EventFiringTaskWorker implements Action < TaskInternal > { private final TaskExecuter taskExecuter ; private final Object parentOperationId ; public EventFiringTaskWorker ( TaskExecuter taskExecuter , Object parentOperationId ) { this . taskExecuter = taskExecuter ; this . parentOperationId = parentOperationId ; } @Override public void execute ( TaskInternal task ) { Object id = OperationIdGenerator . generateId ( task ) ; TaskOperationInternal taskOperation = new TaskOperationInternal ( id , parentOperationId , task ) ; TaskStateInternal state = task . getState ( ) ; long startTime = timeProvider . getCurrentTime ( ) ; internalTaskListeners . getSource ( ) . beforeExecute ( taskOperation , new OperationStartEvent ( startTime ) ) ; try { taskListeners . getSource ( ) . beforeExecute ( task ) ; taskExecuter . execute ( task , task . getState ( ) , new DefaultTaskExecutionContext ( ) ) ; taskListeners . getSource ( ) . afterExecute ( task , state ) ; } finally { long endTime = timeProvider . getCurrentTime ( ) ; internalTaskListeners . getSource ( ) . afterExecute ( taskOperation , new OperationResult ( startTime , endTime , task . getState ( ) . getFailure ( ) ) ) ; } } } } 
