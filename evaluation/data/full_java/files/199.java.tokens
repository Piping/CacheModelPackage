package org . apache . cassandra . cql3 . functions ; import java . lang . invoke . MethodHandle ; import java . lang . invoke . MethodHandles ; import java . lang . reflect . Method ; import java . nio . ByteBuffer ; import java . util . List ; import com . datastax . driver . core . CodecRegistry ; import com . datastax . driver . core . DataType ; import com . datastax . driver . core . ProtocolVersion ; import com . datastax . driver . core . TypeCodec ; import com . datastax . driver . core . exceptions . InvalidTypeException ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . transport . Server ; public final class UDHelper { private static final MethodHandle methodParseOne ; private static final CodecRegistry codecRegistry ; static { try { Class < ? > cls = Class . forName ( <str> ) ; Method m = cls . getDeclaredMethod ( <str> , String . class , ProtocolVersion . class , CodecRegistry . class ) ; m . setAccessible ( true ) ; methodParseOne = MethodHandles . lookup ( ) . unreflect ( m ) ; codecRegistry = new CodecRegistry ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } static TypeCodec < Object > codecFor ( DataType dataType ) { return codecRegistry . codecFor ( dataType ) ; } public static Class < ? > [ ] javaTypes ( DataType [ ] dataTypes , boolean calledOnNullInput ) { Class < ? > [ ] paramTypes = new Class [ dataTypes . length ] ; for ( int i = <int> ; i < paramTypes . length ; i + + ) { Class < ? > clazz = asJavaClass ( dataTypes [ i ] ) ; if ( ! calledOnNullInput ) { if ( clazz = = Integer . class ) clazz = int . class ; else if ( clazz = = Long . class ) clazz = long . class ; else if ( clazz = = Byte . class ) clazz = byte . class ; else if ( clazz = = Short . class ) clazz = short . class ; else if ( clazz = = Float . class ) clazz = float . class ; else if ( clazz = = Double . class ) clazz = double . class ; else if ( clazz = = Boolean . class ) clazz = boolean . class ; } paramTypes [ i ] = clazz ; } return paramTypes ; } public static DataType [ ] driverTypes ( List < AbstractType < ? > > abstractTypes ) { DataType [ ] argDataTypes = new DataType [ abstractTypes . size ( ) ] ; for ( int i = <int> ; i < argDataTypes . length ; i + + ) argDataTypes [ i ] = driverType ( abstractTypes . get ( i ) ) ; return argDataTypes ; } public static DataType driverType ( AbstractType abstractType ) { CQL3Type cqlType = abstractType . asCQL3Type ( ) ; try { return ( DataType ) methodParseOne . invoke ( cqlType . getType ( ) . toString ( ) , ProtocolVersion . fromInt ( Server . CURRENT_VERSION ) , codecRegistry ) ; } catch ( RuntimeException | Error e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( <str> + cqlType . getType ( ) . toString ( ) , e ) ; } } public static Object deserialize ( DataType dataType , int protocolVersion , ByteBuffer value ) { return codecFor ( dataType ) . deserialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; } public static ByteBuffer serialize ( DataType dataType , int protocolVersion , Object value ) { TypeCodec < Object > codec = codecFor ( dataType ) ; if ( ! codec . getJavaType ( ) . getRawType ( ) . isAssignableFrom ( value . getClass ( ) ) ) throw new InvalidTypeException ( <str> + dataType . getName ( ) . toString ( ) ) ; return codec . serialize ( value , ProtocolVersion . fromInt ( protocolVersion ) ) ; } public static Class < ? > asJavaClass ( DataType dataType ) { return codecFor ( dataType ) . getJavaType ( ) . getRawType ( ) ; } public static boolean isNullOrEmpty ( AbstractType < ? > type , ByteBuffer bb ) { return bb = = null | | ( bb . remaining ( ) = = <int> & & type . isEmptyValueMeaningless ( ) ) ; } } 
