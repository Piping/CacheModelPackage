package io . netty . handler . codec . compression ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; final class Bzip2MTFAndRLE2StageEncoder { private final int [ ] bwtBlock ; private final int bwtLength ; private final boolean [ ] bwtValuesPresent ; private final char [ ] mtfBlock ; private int mtfLength ; private final int [ ] mtfSymbolFrequencies = new int [ HUFFMAN_MAX_ALPHABET_SIZE ] ; private int alphabetSize ; Bzip2MTFAndRLE2StageEncoder ( final int [ ] bwtBlock , final int bwtLength , final boolean [ ] bwtValuesPresent ) { this . bwtBlock = bwtBlock ; this . bwtLength = bwtLength ; this . bwtValuesPresent = bwtValuesPresent ; mtfBlock = new char [ bwtLength + <int> ] ; } void encode ( ) { final int bwtLength = this . bwtLength ; final boolean [ ] bwtValuesPresent = this . bwtValuesPresent ; final int [ ] bwtBlock = this . bwtBlock ; final char [ ] mtfBlock = this . mtfBlock ; final int [ ] mtfSymbolFrequencies = this . mtfSymbolFrequencies ; final byte [ ] huffmanSymbolMap = new byte [ <int> ] ; final Bzip2MoveToFrontTable symbolMTF = new Bzip2MoveToFrontTable ( ) ; int totalUniqueValues = <int> ; for ( int i = <int> ; i < huffmanSymbolMap . length ; i + + ) { if ( bwtValuesPresent [ i ] ) { huffmanSymbolMap [ i ] = ( byte ) totalUniqueValues + + ; } } final int endOfBlockSymbol = totalUniqueValues + <int> ; int mtfIndex = <int> ; int repeatCount = <int> ; int totalRunAs = <int> ; int totalRunBs = <int> ; for ( int i = <int> ; i < bwtLength ; i + + ) { final int mtfPosition = symbolMTF . valueToFront ( huffmanSymbolMap [ bwtBlock [ i ] & <hex> ] ) ; if ( mtfPosition = = <int> ) { repeatCount + + ; } else { if ( repeatCount > <int> ) { repeatCount - - ; while ( true ) { if ( ( repeatCount & <int> ) = = <int> ) { mtfBlock [ mtfIndex + + ] = HUFFMAN_SYMBOL_RUNA ; totalRunAs + + ; } else { mtfBlock [ mtfIndex + + ] = HUFFMAN_SYMBOL_RUNB ; totalRunBs + + ; } if ( repeatCount < = <int> ) { break ; } repeatCount = ( repeatCount - <int> ) > > > <int> ; } repeatCount = <int> ; } mtfBlock [ mtfIndex + + ] = ( char ) ( mtfPosition + <int> ) ; mtfSymbolFrequencies [ mtfPosition + <int> ] + + ; } } if ( repeatCount > <int> ) { repeatCount - - ; while ( true ) { if ( ( repeatCount & <int> ) = = <int> ) { mtfBlock [ mtfIndex + + ] = HUFFMAN_SYMBOL_RUNA ; totalRunAs + + ; } else { mtfBlock [ mtfIndex + + ] = HUFFMAN_SYMBOL_RUNB ; totalRunBs + + ; } if ( repeatCount < = <int> ) { break ; } repeatCount = ( repeatCount - <int> ) > > > <int> ; } } mtfBlock [ mtfIndex ] = ( char ) endOfBlockSymbol ; mtfSymbolFrequencies [ endOfBlockSymbol ] + + ; mtfSymbolFrequencies [ HUFFMAN_SYMBOL_RUNA ] + = totalRunAs ; mtfSymbolFrequencies [ HUFFMAN_SYMBOL_RUNB ] + = totalRunBs ; mtfLength = mtfIndex + <int> ; alphabetSize = endOfBlockSymbol + <int> ; } char [ ] mtfBlock ( ) { return mtfBlock ; } int mtfLength ( ) { return mtfLength ; } int mtfAlphabetSize ( ) { return alphabetSize ; } int [ ] mtfSymbolFrequencies ( ) { return mtfSymbolFrequencies ; } } 
