package org . elasticsearch . transport . netty ; import org . elasticsearch . common . util . concurrent . KeyedLock ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . util . Map . Entry ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . not ; public class KeyedLockTests extends ESTestCase { public void testIfMapEmptyAfterLotsOfAcquireAndReleases ( ) throws InterruptedException { ConcurrentHashMap < String , Integer > counter = new ConcurrentHashMap < > ( ) ; ConcurrentHashMap < String , AtomicInteger > safeCounter = new ConcurrentHashMap < > ( ) ; KeyedLock < String > connectionLock = new KeyedLock < String > ( randomBoolean ( ) ) ; String [ ] names = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < names . length ; i + + ) { names [ i ] = randomRealisticUnicodeOfLengthBetween ( <int> , <int> ) ; } CountDownLatch startLatch = new CountDownLatch ( <int> ) ; int numThreads = randomIntBetween ( <int> , <int> ) ; AcquireAndReleaseThread [ ] threads = new AcquireAndReleaseThread [ numThreads ] ; for ( int i = <int> ; i < numThreads ; i + + ) { threads [ i ] = new AcquireAndReleaseThread ( startLatch , connectionLock , names , counter , safeCounter ) ; } for ( int i = <int> ; i < numThreads ; i + + ) { threads [ i ] . start ( ) ; } startLatch . countDown ( ) ; for ( int i = <int> ; i < numThreads ; i + + ) { threads [ i ] . join ( ) ; } assertThat ( connectionLock . hasLockedKeys ( ) , equalTo ( false ) ) ; Set < Entry < String , Integer > > entrySet = counter . entrySet ( ) ; assertThat ( counter . size ( ) , equalTo ( safeCounter . size ( ) ) ) ; for ( Entry < String , Integer > entry : entrySet ) { AtomicInteger atomicInteger = safeCounter . get ( entry . getKey ( ) ) ; assertThat ( atomicInteger , not ( Matchers . nullValue ( ) ) ) ; assertThat ( atomicInteger . get ( ) , equalTo ( entry . getValue ( ) ) ) ; } } public void testCannotAcquireTwoLocks ( ) throws InterruptedException { KeyedLock < String > connectionLock = new KeyedLock < String > ( ) ; String name = randomRealisticUnicodeOfLength ( scaledRandomIntBetween ( <int> , <int> ) ) ; connectionLock . acquire ( name ) ; try { connectionLock . acquire ( name ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testCannotReleaseUnacquiredLock ( ) throws InterruptedException { KeyedLock < String > connectionLock = new KeyedLock < String > ( ) ; String name = randomRealisticUnicodeOfLength ( scaledRandomIntBetween ( <int> , <int> ) ) ; try { connectionLock . release ( name ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public static class AcquireAndReleaseThread extends Thread { private CountDownLatch startLatch ; KeyedLock < String > connectionLock ; String [ ] names ; ConcurrentHashMap < String , Integer > counter ; ConcurrentHashMap < String , AtomicInteger > safeCounter ; public AcquireAndReleaseThread ( CountDownLatch startLatch , KeyedLock < String > connectionLock , String [ ] names , ConcurrentHashMap < String , Integer > counter , ConcurrentHashMap < String , AtomicInteger > safeCounter ) { this . startLatch = startLatch ; this . connectionLock = connectionLock ; this . names = names ; this . counter = counter ; this . safeCounter = safeCounter ; } @Override public void run ( ) { try { startLatch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } int numRuns = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numRuns ; i + + ) { String curName = names [ randomInt ( names . length - <int> ) ] ; connectionLock . acquire ( curName ) ; try { Integer integer = counter . get ( curName ) ; if ( integer = = null ) { counter . put ( curName , <int> ) ; } else { counter . put ( curName , integer . intValue ( ) + <int> ) ; } } finally { connectionLock . release ( curName ) ; } AtomicInteger atomicInteger = new AtomicInteger ( <int> ) ; AtomicInteger value = safeCounter . putIfAbsent ( curName , atomicInteger ) ; if ( value = = null ) { atomicInteger . incrementAndGet ( ) ; } else { value . incrementAndGet ( ) ; } } } } } 
