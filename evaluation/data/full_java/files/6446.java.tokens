package org . elasticsearch . index . fielddata ; import org . apache . lucene . util . Accountable ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . index . AbstractIndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . plain . BytesBinaryDVIndexFieldData ; import org . elasticsearch . index . fielddata . plain . DisabledIndexFieldData ; import org . elasticsearch . index . fielddata . plain . DocValuesIndexFieldData ; import org . elasticsearch . index . fielddata . plain . AbstractGeoPointDVIndexFieldData ; import org . elasticsearch . index . fielddata . plain . GeoPointArrayIndexFieldData ; import org . elasticsearch . index . fielddata . plain . IndexIndexFieldData ; import org . elasticsearch . index . fielddata . plain . PagedBytesIndexFieldData ; import org . elasticsearch . index . fielddata . plain . ParentChildIndexFieldData ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . core . BooleanFieldMapper ; import org . elasticsearch . index . mapper . internal . IndexFieldMapper ; import org . elasticsearch . index . mapper . internal . ParentFieldMapper ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . indices . fielddata . cache . IndicesFieldDataCache ; import java . io . Closeable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class IndexFieldDataService extends AbstractIndexComponent implements Closeable { public static final String FIELDDATA_CACHE_KEY = <str> ; public static final String FIELDDATA_CACHE_VALUE_NODE = <str> ; private static final IndexFieldData . Builder MISSING_DOC_VALUES_BUILDER = ( indexProperties , fieldType , cache , breakerService , mapperService1 ) - > { throw new IllegalStateException ( <str> + fieldType . names ( ) . fullName ( ) + <str> + indexProperties . getIndex ( ) . getName ( ) + <str> + fieldType . fieldDataType ( ) . getType ( ) + <str> ) ; } ; private static final String ARRAY_FORMAT = <str> ; private static final String DISABLED_FORMAT = <str> ; private static final String DOC_VALUES_FORMAT = <str> ; private static final String PAGED_BYTES_FORMAT = <str> ; private final static Map < String , IndexFieldData . Builder > buildersByType ; private final static Map < String , IndexFieldData . Builder > docValuesBuildersByType ; private final static Map < Tuple < String , String > , IndexFieldData . Builder > buildersByTypeAndFormat ; private final CircuitBreakerService circuitBreakerService ; static { Map < String , IndexFieldData . Builder > buildersByTypeBuilder = new HashMap < > ( ) ; buildersByTypeBuilder . put ( <str> , new PagedBytesIndexFieldData . Builder ( ) ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , MISSING_DOC_VALUES_BUILDER ) ; buildersByTypeBuilder . put ( <str> , new GeoPointArrayIndexFieldData . Builder ( ) ) ; buildersByTypeBuilder . put ( ParentFieldMapper . NAME , new ParentChildIndexFieldData . Builder ( ) ) ; buildersByTypeBuilder . put ( IndexFieldMapper . NAME , new IndexIndexFieldData . Builder ( ) ) ; buildersByTypeBuilder . put ( <str> , new DisabledIndexFieldData . Builder ( ) ) ; buildersByTypeBuilder . put ( BooleanFieldMapper . CONTENT_TYPE , MISSING_DOC_VALUES_BUILDER ) ; buildersByType = unmodifiableMap ( buildersByTypeBuilder ) ; docValuesBuildersByType = MapBuilder . < String , IndexFieldData . Builder > newMapBuilder ( ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . FLOAT ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . DOUBLE ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . BYTE ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . SHORT ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . INT ) ) . put ( <str> , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . LONG ) ) . put ( <str> , new AbstractGeoPointDVIndexFieldData . Builder ( ) ) . put ( <str> , new BytesBinaryDVIndexFieldData . Builder ( ) ) . put ( BooleanFieldMapper . CONTENT_TYPE , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . BOOLEAN ) ) . immutableMap ( ) ; buildersByTypeAndFormat = MapBuilder . < Tuple < String , String > , IndexFieldData . Builder > newMapBuilder ( ) . put ( Tuple . tuple ( <str> , PAGED_BYTES_FORMAT ) , new PagedBytesIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . FLOAT ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . DOUBLE ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . BYTE ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . SHORT ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . INT ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . LONG ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , ARRAY_FORMAT ) , new GeoPointArrayIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new AbstractGeoPointDVIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DOC_VALUES_FORMAT ) , new BytesBinaryDVIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( <str> , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . put ( Tuple . tuple ( BooleanFieldMapper . CONTENT_TYPE , DOC_VALUES_FORMAT ) , new DocValuesIndexFieldData . Builder ( ) . numericType ( IndexNumericFieldData . NumericType . BOOLEAN ) ) . put ( Tuple . tuple ( BooleanFieldMapper . CONTENT_TYPE , DISABLED_FORMAT ) , new DisabledIndexFieldData . Builder ( ) ) . immutableMap ( ) ; } private final IndicesFieldDataCache indicesFieldDataCache ; private final Map < String , IndexFieldDataCache > fieldDataCaches = new HashMap < > ( ) ; private final MapperService mapperService ; private static final IndexFieldDataCache . Listener DEFAULT_NOOP_LISTENER = new IndexFieldDataCache . Listener ( ) { @Override public void onCache ( ShardId shardId , Names fieldNames , FieldDataType fieldDataType , Accountable ramUsage ) { } @Override public void onRemoval ( ShardId shardId , Names fieldNames , FieldDataType fieldDataType , boolean wasEvicted , long sizeInBytes ) { } } ; private volatile IndexFieldDataCache . Listener listener = DEFAULT_NOOP_LISTENER ; public IndexFieldDataService ( IndexSettings indexSettings , IndicesFieldDataCache indicesFieldDataCache , CircuitBreakerService circuitBreakerService , MapperService mapperService ) { super ( indexSettings ) ; this . indicesFieldDataCache = indicesFieldDataCache ; this . circuitBreakerService = circuitBreakerService ; this . mapperService = mapperService ; } public synchronized void clear ( ) { List < Throwable > exceptions = new ArrayList < > ( <int> ) ; final Collection < IndexFieldDataCache > fieldDataCacheValues = fieldDataCaches . values ( ) ; for ( IndexFieldDataCache cache : fieldDataCacheValues ) { try { cache . clear ( ) ; } catch ( Throwable t ) { exceptions . add ( t ) ; } } fieldDataCacheValues . clear ( ) ; ExceptionsHelper . maybeThrowRuntimeAndSuppress ( exceptions ) ; } public synchronized void clearField ( final String fieldName ) { List < Throwable > exceptions = new ArrayList < > ( <int> ) ; final IndexFieldDataCache cache = fieldDataCaches . remove ( fieldName ) ; if ( cache ! = null ) { try { cache . clear ( ) ; } catch ( Throwable t ) { exceptions . add ( t ) ; } } ExceptionsHelper . maybeThrowRuntimeAndSuppress ( exceptions ) ; } @SuppressWarnings ( <str> ) public < IFD extends IndexFieldData < ? > > IFD getForField ( MappedFieldType fieldType ) { final Names fieldNames = fieldType . names ( ) ; final FieldDataType type = fieldType . fieldDataType ( ) ; if ( type = = null ) { throw new IllegalArgumentException ( <str> + fieldNames . fullName ( ) + <str> ) ; } final boolean docValues = fieldType . hasDocValues ( ) ; IndexFieldData . Builder builder = null ; String format = type . getFormat ( indexSettings . getSettings ( ) ) ; if ( format ! = null & & FieldDataType . DOC_VALUES_FORMAT_VALUE . equals ( format ) & & ! docValues ) { logger . warn ( <str> + fieldNames . fullName ( ) + <str> ) ; format = null ; } if ( format ! = null ) { builder = buildersByTypeAndFormat . get ( Tuple . tuple ( type . getType ( ) , format ) ) ; if ( builder = = null ) { logger . warn ( <str> + format + <str> + fieldNames . fullName ( ) + <str> ) ; } } if ( builder = = null & & docValues ) { builder = docValuesBuildersByType . get ( type . getType ( ) ) ; } if ( builder = = null ) { builder = buildersByType . get ( type . getType ( ) ) ; } if ( builder = = null ) { throw new IllegalArgumentException ( <str> + fieldNames . fullName ( ) + <str> + type . getType ( ) ) ; } IndexFieldDataCache cache ; synchronized ( this ) { cache = fieldDataCaches . get ( fieldNames . indexName ( ) ) ; if ( cache = = null ) { String cacheType = type . getSettings ( ) . get ( <str> , indexSettings . getSettings ( ) . get ( FIELDDATA_CACHE_KEY , FIELDDATA_CACHE_VALUE_NODE ) ) ; if ( FIELDDATA_CACHE_VALUE_NODE . equals ( cacheType ) ) { cache = indicesFieldDataCache . buildIndexFieldDataCache ( listener , index ( ) , fieldNames , type ) ; } else if ( <str> . equals ( cacheType ) ) { cache = new IndexFieldDataCache . None ( ) ; } else { throw new IllegalArgumentException ( <str> + cacheType + <str> + fieldNames . fullName ( ) + <str> ) ; } fieldDataCaches . put ( fieldNames . indexName ( ) , cache ) ; } } return ( IFD ) builder . build ( indexSettings , fieldType , cache , circuitBreakerService , mapperService ) ; } public void setListener ( IndexFieldDataCache . Listener listener ) { if ( listener = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( this . listener ! = DEFAULT_NOOP_LISTENER ) { throw new IllegalStateException ( <str> ) ; } this . listener = listener ; } @Override public void close ( ) throws IOException { clear ( ) ; } } 
