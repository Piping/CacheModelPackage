package org . apache . cassandra . security ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . security . InvalidAlgorithmParameterException ; import java . security . InvalidKeyException ; import java . security . Key ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Arrays ; import java . util . concurrent . ExecutionException ; import javax . crypto . Cipher ; import javax . crypto . NoSuchPaddingException ; import javax . crypto . spec . IvParameterSpec ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import com . google . common . cache . RemovalListener ; import com . google . common . cache . RemovalNotification ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . TransparentDataEncryptionOptions ; public class CipherFactory { private final Logger logger = LoggerFactory . getLogger ( CipherFactory . class ) ; private static final ThreadLocal < CachedCipher > cipherThreadLocal = new ThreadLocal < > ( ) ; private final SecureRandom secureRandom ; private final LoadingCache < String , Key > cache ; private final int ivLength ; private final KeyProvider keyProvider ; public CipherFactory ( TransparentDataEncryptionOptions options ) { logger . info ( <str> ) ; ivLength = options . iv_length ; try { secureRandom = SecureRandom . getInstance ( <str> ) ; Class < KeyProvider > keyProviderClass = ( Class < KeyProvider > ) Class . forName ( options . key_provider . class_name ) ; Constructor ctor = keyProviderClass . getConstructor ( TransparentDataEncryptionOptions . class ) ; keyProvider = ( KeyProvider ) ctor . newInstance ( options ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } cache = CacheBuilder . newBuilder ( ) . maximumSize ( <int> ) . concurrencyLevel ( Runtime . getRuntime ( ) . availableProcessors ( ) ) . removalListener ( new RemovalListener < String , Key > ( ) { public void onRemoval ( RemovalNotification < String , Key > notice ) { logger . info ( <str> , notice . getKey ( ) ) ; } } ) . build ( new CacheLoader < String , Key > ( ) { @Override public Key load ( String alias ) throws Exception { logger . info ( <str> , alias ) ; return keyProvider . getSecretKey ( alias ) ; } } ) ; } public Cipher getEncryptor ( String transformation , String keyAlias ) throws IOException { byte [ ] iv = new byte [ ivLength ] ; secureRandom . nextBytes ( iv ) ; return buildCipher ( transformation , keyAlias , iv , Cipher . ENCRYPT_MODE ) ; } public Cipher getDecryptor ( String transformation , String keyAlias , byte [ ] iv ) throws IOException { assert iv ! = null & & iv . length > <int> : <str> ; return buildCipher ( transformation , keyAlias , iv , Cipher . DECRYPT_MODE ) ; } @VisibleForTesting Cipher buildCipher ( String transformation , String keyAlias , byte [ ] iv , int cipherMode ) throws IOException { try { CachedCipher cachedCipher = cipherThreadLocal . get ( ) ; if ( cachedCipher ! = null ) { Cipher cipher = cachedCipher . cipher ; if ( cachedCipher . mode = = cipherMode & & cipher . getAlgorithm ( ) . equals ( transformation ) & & cachedCipher . keyAlias . equals ( keyAlias ) & & Arrays . equals ( cipher . getIV ( ) , iv ) ) return cipher ; } Key key = retrieveKey ( keyAlias ) ; Cipher cipher = Cipher . getInstance ( transformation ) ; cipher . init ( cipherMode , key , new IvParameterSpec ( iv ) ) ; cipherThreadLocal . set ( new CachedCipher ( cipherMode , keyAlias , cipher ) ) ; return cipher ; } catch ( NoSuchAlgorithmException | NoSuchPaddingException | InvalidAlgorithmParameterException | InvalidKeyException e ) { logger . error ( <str> , e ) ; throw new IOException ( <str> , e ) ; } } private Key retrieveKey ( String keyAlias ) throws IOException { try { return cache . get ( keyAlias ) ; } catch ( ExecutionException e ) { if ( e . getCause ( ) instanceof IOException ) throw ( IOException ) e . getCause ( ) ; throw new IOException ( <str> + keyAlias , e ) ; } } private static class CachedCipher { public final int mode ; public final String keyAlias ; public final Cipher cipher ; private CachedCipher ( int mode , String keyAlias , Cipher cipher ) { this . mode = mode ; this . keyAlias = keyAlias ; this . cipher = cipher ; } } } 
