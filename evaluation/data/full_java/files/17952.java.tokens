package com . badlogic . gdx . graphics ; import java . io . BufferedInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . util . zip . CRC32 ; import java . util . zip . CheckedOutputStream ; import java . util . zip . Deflater ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . InflaterInputStream ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . utils . ByteArray ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class PixmapIO { static public void writeCIM ( FileHandle file , Pixmap pixmap ) { CIM . write ( file , pixmap ) ; } static public Pixmap readCIM ( FileHandle file ) { return CIM . read ( file ) ; } static public void writePNG ( FileHandle file , Pixmap pixmap ) { try { PNG writer = new PNG ( ( int ) ( pixmap . getWidth ( ) * pixmap . getHeight ( ) * <float> ) ) ; try { writer . setFlipY ( false ) ; writer . write ( file , pixmap ) ; } finally { writer . dispose ( ) ; } } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + file , ex ) ; } } static private class CIM { static private final int BUFFER_SIZE = <int> ; static private final byte [ ] writeBuffer = new byte [ BUFFER_SIZE ] ; static private final byte [ ] readBuffer = new byte [ BUFFER_SIZE ] ; static public void write ( FileHandle file , Pixmap pixmap ) { DataOutputStream out = null ; try { DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream ( file . write ( false ) ) ; out = new DataOutputStream ( deflaterOutputStream ) ; out . writeInt ( pixmap . getWidth ( ) ) ; out . writeInt ( pixmap . getHeight ( ) ) ; out . writeInt ( Format . toGdx2DPixmapFormat ( pixmap . getFormat ( ) ) ) ; ByteBuffer pixelBuf = pixmap . getPixels ( ) ; pixelBuf . position ( <int> ) ; pixelBuf . limit ( pixelBuf . capacity ( ) ) ; int remainingBytes = pixelBuf . capacity ( ) % BUFFER_SIZE ; int iterations = pixelBuf . capacity ( ) / BUFFER_SIZE ; synchronized ( writeBuffer ) { for ( int i = <int> ; i < iterations ; i + + ) { pixelBuf . get ( writeBuffer ) ; out . write ( writeBuffer ) ; } pixelBuf . get ( writeBuffer , <int> , remainingBytes ) ; out . write ( writeBuffer , <int> , remainingBytes ) ; } pixelBuf . position ( <int> ) ; pixelBuf . limit ( pixelBuf . capacity ( ) ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + file + <str> , e ) ; } finally { StreamUtils . closeQuietly ( out ) ; } } static public Pixmap read ( FileHandle file ) { DataInputStream in = null ; try { in = new DataInputStream ( new InflaterInputStream ( new BufferedInputStream ( file . read ( ) ) ) ) ; int width = in . readInt ( ) ; int height = in . readInt ( ) ; Format format = Format . fromGdx2DPixmapFormat ( in . readInt ( ) ) ; Pixmap pixmap = new Pixmap ( width , height , format ) ; ByteBuffer pixelBuf = pixmap . getPixels ( ) ; pixelBuf . position ( <int> ) ; pixelBuf . limit ( pixelBuf . capacity ( ) ) ; synchronized ( readBuffer ) { int readBytes = <int> ; while ( ( readBytes = in . read ( readBuffer ) ) > <int> ) { pixelBuf . put ( readBuffer , <int> , readBytes ) ; } } pixelBuf . position ( <int> ) ; pixelBuf . limit ( pixelBuf . capacity ( ) ) ; return pixmap ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + file + <str> , e ) ; } finally { StreamUtils . closeQuietly ( in ) ; } } } static public class PNG implements Disposable { static private final byte [ ] SIGNATURE = { ( byte ) <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; static private final int IHDR = <hex> , IDAT = <hex> , IEND = <hex> ; static private final byte COLOR_ARGB = <int> ; static private final byte COMPRESSION_DEFLATE = <int> ; static private final byte FILTER_NONE = <int> ; static private final byte INTERLACE_NONE = <int> ; static private final byte PAETH = <int> ; private final ChunkBuffer buffer ; private final Deflater deflater ; private ByteArray lineOutBytes , curLineBytes , prevLineBytes ; private boolean flipY = true ; private int lastLineLen ; public PNG ( ) { this ( <int> * <int> ) ; } public PNG ( int initialBufferSize ) { buffer = new ChunkBuffer ( initialBufferSize ) ; deflater = new Deflater ( ) ; } public void setFlipY ( boolean flipY ) { this . flipY = flipY ; } public void setCompression ( int level ) { deflater . setLevel ( level ) ; } public void write ( FileHandle file , Pixmap pixmap ) throws IOException { OutputStream output = file . write ( false ) ; try { write ( output , pixmap ) ; } finally { StreamUtils . closeQuietly ( output ) ; } } public void write ( OutputStream output , Pixmap pixmap ) throws IOException { DeflaterOutputStream deflaterOutput = new DeflaterOutputStream ( buffer , deflater ) ; DataOutputStream dataOutput = new DataOutputStream ( output ) ; dataOutput . write ( SIGNATURE ) ; buffer . writeInt ( IHDR ) ; buffer . writeInt ( pixmap . getWidth ( ) ) ; buffer . writeInt ( pixmap . getHeight ( ) ) ; buffer . writeByte ( <int> ) ; buffer . writeByte ( COLOR_ARGB ) ; buffer . writeByte ( COMPRESSION_DEFLATE ) ; buffer . writeByte ( FILTER_NONE ) ; buffer . writeByte ( INTERLACE_NONE ) ; buffer . endChunk ( dataOutput ) ; buffer . writeInt ( IDAT ) ; deflater . reset ( ) ; int lineLen = pixmap . getWidth ( ) * <int> ; byte [ ] lineOut , curLine , prevLine ; if ( lineOutBytes = = null ) { lineOut = ( lineOutBytes = new ByteArray ( lineLen ) ) . items ; curLine = ( curLineBytes = new ByteArray ( lineLen ) ) . items ; prevLine = ( prevLineBytes = new ByteArray ( lineLen ) ) . items ; } else { lineOut = lineOutBytes . ensureCapacity ( lineLen ) ; curLine = curLineBytes . ensureCapacity ( lineLen ) ; prevLine = prevLineBytes . ensureCapacity ( lineLen ) ; for ( int i = <int> , n = lastLineLen ; i < n ; i + + ) prevLine [ i ] = <int> ; } lastLineLen = lineLen ; ByteBuffer pixels = pixmap . getPixels ( ) ; int oldPosition = pixels . position ( ) ; boolean rgba8888 = pixmap . getFormat ( ) = = Format . RGBA8888 ; for ( int y = <int> , h = pixmap . getHeight ( ) ; y < h ; y + + ) { int py = flipY ? ( h - y - <int> ) : y ; if ( rgba8888 ) { pixels . position ( py * lineLen ) ; pixels . get ( curLine , <int> , lineLen ) ; } else { for ( int px = <int> , x = <int> ; px < pixmap . getWidth ( ) ; px + + ) { int pixel = pixmap . getPixel ( px , py ) ; curLine [ x + + ] = ( byte ) ( ( pixel > > <int> ) & <hex> ) ; curLine [ x + + ] = ( byte ) ( ( pixel > > <int> ) & <hex> ) ; curLine [ x + + ] = ( byte ) ( ( pixel > > <int> ) & <hex> ) ; curLine [ x + + ] = ( byte ) ( pixel & <hex> ) ; } } lineOut [ <int> ] = ( byte ) ( curLine [ <int> ] - prevLine [ <int> ] ) ; lineOut [ <int> ] = ( byte ) ( curLine [ <int> ] - prevLine [ <int> ] ) ; lineOut [ <int> ] = ( byte ) ( curLine [ <int> ] - prevLine [ <int> ] ) ; lineOut [ <int> ] = ( byte ) ( curLine [ <int> ] - prevLine [ <int> ] ) ; for ( int x = <int> ; x < lineLen ; x + + ) { int a = curLine [ x - <int> ] & <hex> ; int b = prevLine [ x ] & <hex> ; int c = prevLine [ x - <int> ] & <hex> ; int p = a + b - c ; int pa = p - a ; if ( pa < <int> ) pa = - pa ; int pb = p - b ; if ( pb < <int> ) pb = - pb ; int pc = p - c ; if ( pc < <int> ) pc = - pc ; if ( pa < = pb & & pa < = pc ) c = a ; else if ( pb < = pc ) c = b ; lineOut [ x ] = ( byte ) ( curLine [ x ] - c ) ; } deflaterOutput . write ( PAETH ) ; deflaterOutput . write ( lineOut , <int> , lineLen ) ; byte [ ] temp = curLine ; curLine = prevLine ; prevLine = temp ; } pixels . position ( oldPosition ) ; deflaterOutput . finish ( ) ; buffer . endChunk ( dataOutput ) ; buffer . writeInt ( IEND ) ; buffer . endChunk ( dataOutput ) ; output . flush ( ) ; } public void dispose ( ) { deflater . end ( ) ; } static class ChunkBuffer extends DataOutputStream { final ByteArrayOutputStream buffer ; final CRC32 crc ; ChunkBuffer ( int initialSize ) { this ( new ByteArrayOutputStream ( initialSize ) , new CRC32 ( ) ) ; } private ChunkBuffer ( ByteArrayOutputStream buffer , CRC32 crc ) { super ( new CheckedOutputStream ( buffer , crc ) ) ; this . buffer = buffer ; this . crc = crc ; } public void endChunk ( DataOutputStream target ) throws IOException { flush ( ) ; target . writeInt ( buffer . size ( ) - <int> ) ; buffer . writeTo ( target ) ; target . writeInt ( ( int ) crc . getValue ( ) ) ; buffer . reset ( ) ; crc . reset ( ) ; } } } } 
