package org . elasticsearch . search . aggregations . bucket . significant . heuristics ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . script . * ; import org . elasticsearch . script . Script . ScriptField ; import org . elasticsearch . script . ScriptParameterParser . ScriptParameterValue ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; public class ScriptHeuristic extends SignificanceHeuristic { protected static final ParseField NAMES_FIELD = new ParseField ( <str> ) ; private final LongAccessor subsetSizeHolder ; private final LongAccessor supersetSizeHolder ; private final LongAccessor subsetDfHolder ; private final LongAccessor supersetDfHolder ; ExecutableScript searchScript = null ; Script script ; public static final SignificanceHeuristicStreams . Stream STREAM = new SignificanceHeuristicStreams . Stream ( ) { @Override public SignificanceHeuristic readResult ( StreamInput in ) throws IOException { Script script = Script . readScript ( in ) ; return new ScriptHeuristic ( null , script ) ; } @Override public String getName ( ) { return NAMES_FIELD . getPreferredName ( ) ; } } ; public ScriptHeuristic ( ExecutableScript searchScript , Script script ) { subsetSizeHolder = new LongAccessor ( ) ; supersetSizeHolder = new LongAccessor ( ) ; subsetDfHolder = new LongAccessor ( ) ; supersetDfHolder = new LongAccessor ( ) ; this . searchScript = searchScript ; if ( searchScript ! = null ) { searchScript . setNextVar ( <str> , subsetDfHolder ) ; searchScript . setNextVar ( <str> , subsetSizeHolder ) ; searchScript . setNextVar ( <str> , supersetDfHolder ) ; searchScript . setNextVar ( <str> , supersetSizeHolder ) ; } this . script = script ; } @Override public void initialize ( InternalAggregation . ReduceContext context ) { searchScript = context . scriptService ( ) . executable ( script , ScriptContext . Standard . AGGS , context ) ; searchScript . setNextVar ( <str> , subsetDfHolder ) ; searchScript . setNextVar ( <str> , subsetSizeHolder ) ; searchScript . setNextVar ( <str> , supersetDfHolder ) ; searchScript . setNextVar ( <str> , supersetSizeHolder ) ; } @Override public double getScore ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize ) { if ( searchScript = = null ) { ESLoggerFactory . getLogger ( <str> ) . warn ( <str> ) ; return <int> ; } subsetSizeHolder . value = subsetSize ; supersetSizeHolder . value = supersetSize ; subsetDfHolder . value = subsetFreq ; supersetDfHolder . value = supersetFreq ; return ( ( Number ) searchScript . run ( ) ) . doubleValue ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; script . writeTo ( out ) ; } public static class ScriptHeuristicParser implements SignificanceHeuristicParser { private final ScriptService scriptService ; public ScriptHeuristicParser ( ScriptService scriptService ) { this . scriptService = scriptService ; } @Override public SignificanceHeuristic parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher , SearchContext context ) throws IOException , QueryShardException { String heuristicName = parser . currentName ( ) ; Script script = null ; XContentParser . Token token ; Map < String , Object > params = null ; String currentFieldName = null ; ScriptParameterParser scriptParameterParser = new ScriptParameterParser ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token . equals ( XContentParser . Token . FIELD_NAME ) ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( parseFieldMatcher . match ( currentFieldName , ScriptField . SCRIPT ) ) { script = Script . parse ( parser , parseFieldMatcher ) ; } else if ( <str> . equals ( currentFieldName ) ) { params = parser . map ( ) ; } else { throw new ElasticsearchParseException ( <str> , heuristicName , currentFieldName ) ; } } else if ( ! scriptParameterParser . token ( currentFieldName , token , parser , parseFieldMatcher ) ) { throw new ElasticsearchParseException ( <str> , heuristicName , currentFieldName ) ; } } if ( script = = null ) { ScriptParameterValue scriptValue = scriptParameterParser . getDefaultScriptParameterValue ( ) ; if ( scriptValue ! = null ) { if ( params = = null ) { params = new HashMap < > ( ) ; } script = new Script ( scriptValue . script ( ) , scriptValue . scriptType ( ) , scriptParameterParser . lang ( ) , params ) ; } } else if ( params ! = null ) { throw new ElasticsearchParseException ( <str> , heuristicName ) ; } if ( script = = null ) { throw new ElasticsearchParseException ( <str> , heuristicName ) ; } ExecutableScript searchScript ; try { searchScript = scriptService . executable ( script , ScriptContext . Standard . AGGS , context ) ; } catch ( Exception e ) { throw new ElasticsearchParseException ( <str> , e , script , heuristicName ) ; } return new ScriptHeuristic ( searchScript , script ) ; } @Override public String [ ] getNames ( ) { return NAMES_FIELD . getAllNamesIncludedDeprecated ( ) ; } } public static class ScriptHeuristicBuilder implements SignificanceHeuristicBuilder { private Script script = null ; public ScriptHeuristicBuilder setScript ( Script script ) { this . script = script ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params builderParams ) throws IOException { builder . startObject ( STREAM . getName ( ) ) ; builder . field ( ScriptField . SCRIPT . getPreferredName ( ) ) ; script . toXContent ( builder , builderParams ) ; builder . endObject ( ) ; return builder ; } } public final class LongAccessor extends Number { public long value ; @Override public int intValue ( ) { return ( int ) value ; } @Override public long longValue ( ) { return value ; } @Override public float floatValue ( ) { return value ; } @Override public double doubleValue ( ) { return value ; } @Override public String toString ( ) { return Long . toString ( value ) ; } } } 
