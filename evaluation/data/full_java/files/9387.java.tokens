package com . google . common . graph ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . graph . GraphErrorMessageUtils . EDGE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . NODE_NOT_IN_GRAPH ; import com . google . common . annotations . Beta ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import java . util . Collections ; import java . util . Set ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta public final class ImmutableDirectedGraph < N , E > extends AbstractImmutableGraph < N , E > implements DirectedGraph < N , E > { private final ImmutableMap < N , IncidentEdges < E > > nodeToIncidentEdges ; private final ImmutableMap < E , IncidentNodes < N > > edgeToIncidentNodes ; private final GraphConfig config ; private ImmutableDirectedGraph ( Builder < N , E > builder ) { DirectedGraph < N , E > directedGraph = builder . directedGraph ; ImmutableMap . Builder < N , IncidentEdges < E > > nodeToIncidentEdgesBuilder = ImmutableMap . builder ( ) ; for ( N node : directedGraph . nodes ( ) ) { IncidentEdges < E > incidentEdges = IncidentEdges . ofImmutable ( directedGraph . inEdges ( node ) , directedGraph . outEdges ( node ) ) ; nodeToIncidentEdgesBuilder . put ( node , incidentEdges ) ; } nodeToIncidentEdges = nodeToIncidentEdgesBuilder . build ( ) ; ImmutableMap . Builder < E , IncidentNodes < N > > edgeToIncidentNodesBuilder = ImmutableMap . builder ( ) ; for ( E edge : directedGraph . edges ( ) ) { IncidentNodes < N > incidentNodes = IncidentNodes . of ( directedGraph . source ( edge ) , directedGraph . target ( edge ) ) ; edgeToIncidentNodesBuilder . put ( edge , incidentNodes ) ; } edgeToIncidentNodes = edgeToIncidentNodesBuilder . build ( ) ; this . config = directedGraph . config ( ) ; } @Override public Set < N > nodes ( ) { return nodeToIncidentEdges . keySet ( ) ; } @Override public Set < E > edges ( ) { return edgeToIncidentNodes . keySet ( ) ; } @Override public GraphConfig config ( ) { return config ; } @Override public Set < E > incidentEdges ( Object node ) { return Sets . union ( inEdges ( node ) , outEdges ( node ) ) . immutableCopy ( ) ; } @Override public Set < N > incidentNodes ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . asImmutableSet ( ) ; } @Override public Set < N > adjacentNodes ( Object node ) { return Sets . union ( predecessors ( node ) , successors ( node ) ) . immutableCopy ( ) ; } @Override public Set < E > adjacentEdges ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; Set < E > adjacentEdges = Sets . newLinkedHashSet ( ) ; adjacentEdges . addAll ( incidentEdges ( endpoints . target ( ) ) ) ; adjacentEdges . addAll ( incidentEdges ( endpoints . source ( ) ) ) ; adjacentEdges . remove ( edge ) ; return Collections . unmodifiableSet ( adjacentEdges ) ; } @Override public Set < E > edgesConnecting ( Object node1 , Object node2 ) { checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; Set < E > sourceOutEdges = outEdges ( node1 ) ; Set < E > targetInEdges = inEdges ( node2 ) ; return sourceOutEdges . size ( ) < = targetInEdges . size ( ) ? Sets . intersection ( sourceOutEdges , targetInEdges ) . immutableCopy ( ) : Sets . intersection ( targetInEdges , sourceOutEdges ) . immutableCopy ( ) ; } @Override public Set < E > inEdges ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges . inEdges ( ) ; } @Override public Set < E > outEdges ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges . outEdges ( ) ; } @Override public Set < N > predecessors ( Object node ) { ImmutableSet . Builder < N > predecessorsBuilder = ImmutableSet . builder ( ) ; for ( E edge : inEdges ( node ) ) { predecessorsBuilder . add ( source ( edge ) ) ; } return predecessorsBuilder . build ( ) ; } @Override public Set < N > successors ( Object node ) { ImmutableSet . Builder < N > successorsBuilder = ImmutableSet . builder ( ) ; for ( E edge : outEdges ( node ) ) { successorsBuilder . add ( target ( edge ) ) ; } return successorsBuilder . build ( ) ; } @Override public long degree ( Object node ) { return inDegree ( node ) + outDegree ( node ) - edgesConnecting ( node , node ) . size ( ) ; } @Override public long inDegree ( Object node ) { return inEdges ( node ) . size ( ) ; } @Override public long outDegree ( Object node ) { return outEdges ( node ) . size ( ) ; } @Override public N source ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . source ( ) ; } @Override public N target ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . target ( ) ; } @Override public boolean equals ( @Nullable Object object ) { return ( object instanceof DirectedGraph ) & & Graphs . equal ( this , ( DirectedGraph ) object ) ; } @Override public int hashCode ( ) { return nodeToIncidentEdges . hashCode ( ) ; } @CheckReturnValue public static < N , E > Builder < N , E > builder ( ) { return new Builder < N , E > ( ) ; } @CheckReturnValue public static < N , E > Builder < N , E > builder ( GraphConfig config ) { return new Builder < N , E > ( config ) ; } @CheckReturnValue public static < N , E > ImmutableDirectedGraph < N , E > copyOf ( DirectedGraph < N , E > graph ) { return new Builder < N , E > ( graph ) . build ( ) ; } @Override public String toString ( ) { return String . format ( <str> , config , nodeToIncidentEdges . keySet ( ) , edgeToIncidentNodes ) ; } public static final class Builder < N , E > implements AbstractImmutableGraph . Builder < N , E > { private final DirectedGraph < N , E > directedGraph ; public Builder ( ) { this ( Graphs . < N , E > createDirected ( ) ) ; } public Builder ( GraphConfig config ) { this ( Graphs . < N , E > createDirected ( config ) ) ; } private Builder ( DirectedGraph < N , E > graph ) { this . directedGraph = checkNotNull ( graph , <str> ) ; } @Override public Builder < N , E > addNode ( N node ) { directedGraph . addNode ( node ) ; return this ; } @Override public Builder < N , E > addEdge ( E edge , N node1 , N node2 ) { directedGraph . addEdge ( edge , node1 , node2 ) ; return this ; } public Builder < N , E > addGraph ( DirectedGraph < N , E > graph ) { checkArgument ( directedGraph . config ( ) . compatibleWith ( graph . config ( ) ) , <str> + <str> , graph . config ( ) , directedGraph . config ( ) ) ; for ( N node : graph . nodes ( ) ) { directedGraph . addNode ( node ) ; } for ( E edge : graph . edges ( ) ) { directedGraph . addEdge ( edge , graph . source ( edge ) , graph . target ( edge ) ) ; } return this ; } @Override @CheckReturnValue public ImmutableDirectedGraph < N , E > build ( ) { return new ImmutableDirectedGraph < N , E > ( this ) ; } } } 
