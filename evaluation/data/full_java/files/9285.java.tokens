package com . google . common . collect ; import static com . google . common . base . Preconditions . checkPositionIndex ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import static java . util . Collections . unmodifiableList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . j2objc . annotations . WeakOuter ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . AbstractSequentialList ; import java . util . Collection ; import java . util . ConcurrentModificationException ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; import java . util . Set ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) public class LinkedListMultimap < K , V > extends AbstractMultimap < K , V > implements ListMultimap < K , V > , Serializable { private static final class Node < K , V > extends AbstractMapEntry < K , V > { final K key ; V value ; Node < K , V > next ; Node < K , V > previous ; Node < K , V > nextSibling ; Node < K , V > previousSibling ; Node ( @Nullable K key , @Nullable V value ) { this . key = key ; this . value = value ; } @Override public K getKey ( ) { return key ; } @Override public V getValue ( ) { return value ; } @Override public V setValue ( @Nullable V newValue ) { V result = value ; this . value = newValue ; return result ; } } private static class KeyList < K , V > { Node < K , V > head ; Node < K , V > tail ; int count ; KeyList ( Node < K , V > firstNode ) { this . head = firstNode ; this . tail = firstNode ; firstNode . previousSibling = null ; firstNode . nextSibling = null ; this . count = <int> ; } } private transient Node < K , V > head ; private transient Node < K , V > tail ; private transient Map < K , KeyList < K , V > > keyToKeyList ; private transient int size ; private transient int modCount ; public static < K , V > LinkedListMultimap < K , V > create ( ) { return new LinkedListMultimap < K , V > ( ) ; } public static < K , V > LinkedListMultimap < K , V > create ( int expectedKeys ) { return new LinkedListMultimap < K , V > ( expectedKeys ) ; } public static < K , V > LinkedListMultimap < K , V > create ( Multimap < ? extends K , ? extends V > multimap ) { return new LinkedListMultimap < K , V > ( multimap ) ; } LinkedListMultimap ( ) { keyToKeyList = Maps . newHashMap ( ) ; } private LinkedListMultimap ( int expectedKeys ) { keyToKeyList = new HashMap < K , KeyList < K , V > > ( expectedKeys ) ; } private LinkedListMultimap ( Multimap < ? extends K , ? extends V > multimap ) { this ( multimap . keySet ( ) . size ( ) ) ; putAll ( multimap ) ; } private Node < K , V > addNode ( @Nullable K key , @Nullable V value , @Nullable Node < K , V > nextSibling ) { Node < K , V > node = new Node < K , V > ( key , value ) ; if ( head = = null ) { head = tail = node ; keyToKeyList . put ( key , new KeyList < K , V > ( node ) ) ; modCount + + ; } else if ( nextSibling = = null ) { tail . next = node ; node . previous = tail ; tail = node ; KeyList < K , V > keyList = keyToKeyList . get ( key ) ; if ( keyList = = null ) { keyToKeyList . put ( key , keyList = new KeyList < K , V > ( node ) ) ; modCount + + ; } else { keyList . count + + ; Node < K , V > keyTail = keyList . tail ; keyTail . nextSibling = node ; node . previousSibling = keyTail ; keyList . tail = node ; } } else { KeyList < K , V > keyList = keyToKeyList . get ( key ) ; keyList . count + + ; node . previous = nextSibling . previous ; node . previousSibling = nextSibling . previousSibling ; node . next = nextSibling ; node . nextSibling = nextSibling ; if ( nextSibling . previousSibling = = null ) { keyToKeyList . get ( key ) . head = node ; } else { nextSibling . previousSibling . nextSibling = node ; } if ( nextSibling . previous = = null ) { head = node ; } else { nextSibling . previous . next = node ; } nextSibling . previous = node ; nextSibling . previousSibling = node ; } size + + ; return node ; } private void removeNode ( Node < K , V > node ) { if ( node . previous ! = null ) { node . previous . next = node . next ; } else { head = node . next ; } if ( node . next ! = null ) { node . next . previous = node . previous ; } else { tail = node . previous ; } if ( node . previousSibling = = null & & node . nextSibling = = null ) { KeyList < K , V > keyList = keyToKeyList . remove ( node . key ) ; keyList . count = <int> ; modCount + + ; } else { KeyList < K , V > keyList = keyToKeyList . get ( node . key ) ; keyList . count - - ; if ( node . previousSibling = = null ) { keyList . head = node . nextSibling ; } else { node . previousSibling . nextSibling = node . nextSibling ; } if ( node . nextSibling = = null ) { keyList . tail = node . previousSibling ; } else { node . nextSibling . previousSibling = node . previousSibling ; } } size - - ; } private void removeAllNodes ( @Nullable Object key ) { Iterators . clear ( new ValueForKeyIterator ( key ) ) ; } private static void checkElement ( @Nullable Object node ) { if ( node = = null ) { throw new NoSuchElementException ( ) ; } } private class NodeIterator implements ListIterator < Entry < K , V > > { int nextIndex ; Node < K , V > next ; Node < K , V > current ; Node < K , V > previous ; int expectedModCount = modCount ; NodeIterator ( int index ) { int size = size ( ) ; checkPositionIndex ( index , size ) ; if ( index > = ( size / <int> ) ) { previous = tail ; nextIndex = size ; while ( index + + < size ) { previous ( ) ; } } else { next = head ; while ( index - - > <int> ) { next ( ) ; } } current = null ; } private void checkForConcurrentModification ( ) { if ( modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } } @Override public boolean hasNext ( ) { checkForConcurrentModification ( ) ; return next ! = null ; } @Override public Node < K , V > next ( ) { checkForConcurrentModification ( ) ; checkElement ( next ) ; previous = current = next ; next = next . next ; nextIndex + + ; return current ; } @Override public void remove ( ) { checkForConcurrentModification ( ) ; checkRemove ( current ! = null ) ; if ( current ! = next ) { previous = current . previous ; nextIndex - - ; } else { next = current . next ; } removeNode ( current ) ; current = null ; expectedModCount = modCount ; } @Override public boolean hasPrevious ( ) { checkForConcurrentModification ( ) ; return previous ! = null ; } @Override public Node < K , V > previous ( ) { checkForConcurrentModification ( ) ; checkElement ( previous ) ; next = current = previous ; previous = previous . previous ; nextIndex - - ; return current ; } @Override public int nextIndex ( ) { return nextIndex ; } @Override public int previousIndex ( ) { return nextIndex - <int> ; } @Override public void set ( Entry < K , V > e ) { throw new UnsupportedOperationException ( ) ; } @Override public void add ( Entry < K , V > e ) { throw new UnsupportedOperationException ( ) ; } void setValue ( V value ) { checkState ( current ! = null ) ; current . value = value ; } } private class DistinctKeyIterator implements Iterator < K > { final Set < K > seenKeys = Sets . < K > newHashSetWithExpectedSize ( keySet ( ) . size ( ) ) ; Node < K , V > next = head ; Node < K , V > current ; int expectedModCount = modCount ; private void checkForConcurrentModification ( ) { if ( modCount ! = expectedModCount ) { throw new ConcurrentModificationException ( ) ; } } @Override public boolean hasNext ( ) { checkForConcurrentModification ( ) ; return next ! = null ; } @Override public K next ( ) { checkForConcurrentModification ( ) ; checkElement ( next ) ; current = next ; seenKeys . add ( current . key ) ; do { next = next . next ; } while ( ( next ! = null ) & & ! seenKeys . add ( next . key ) ) ; return current . key ; } @Override public void remove ( ) { checkForConcurrentModification ( ) ; checkRemove ( current ! = null ) ; removeAllNodes ( current . key ) ; current = null ; expectedModCount = modCount ; } } private class ValueForKeyIterator implements ListIterator < V > { final Object key ; int nextIndex ; Node < K , V > next ; Node < K , V > current ; Node < K , V > previous ; ValueForKeyIterator ( @Nullable Object key ) { this . key = key ; KeyList < K , V > keyList = keyToKeyList . get ( key ) ; next = ( keyList = = null ) ? null : keyList . head ; } public ValueForKeyIterator ( @Nullable Object key , int index ) { KeyList < K , V > keyList = keyToKeyList . get ( key ) ; int size = ( keyList = = null ) ? <int> : keyList . count ; checkPositionIndex ( index , size ) ; if ( index > = ( size / <int> ) ) { previous = ( keyList = = null ) ? null : keyList . tail ; nextIndex = size ; while ( index + + < size ) { previous ( ) ; } } else { next = ( keyList = = null ) ? null : keyList . head ; while ( index - - > <int> ) { next ( ) ; } } this . key = key ; current = null ; } @Override public boolean hasNext ( ) { return next ! = null ; } @Override public V next ( ) { checkElement ( next ) ; previous = current = next ; next = next . nextSibling ; nextIndex + + ; return current . value ; } @Override public boolean hasPrevious ( ) { return previous ! = null ; } @Override public V previous ( ) { checkElement ( previous ) ; next = current = previous ; previous = previous . previousSibling ; nextIndex - - ; return current . value ; } @Override public int nextIndex ( ) { return nextIndex ; } @Override public int previousIndex ( ) { return nextIndex - <int> ; } @Override public void remove ( ) { checkRemove ( current ! = null ) ; if ( current ! = next ) { previous = current . previousSibling ; nextIndex - - ; } else { next = current . nextSibling ; } removeNode ( current ) ; current = null ; } @Override public void set ( V value ) { checkState ( current ! = null ) ; current . value = value ; } @Override @SuppressWarnings ( <str> ) public void add ( V value ) { previous = addNode ( ( K ) key , value , next ) ; nextIndex + + ; current = null ; } } @Override public int size ( ) { return size ; } @Override public boolean isEmpty ( ) { return head = = null ; } @Override public boolean containsKey ( @Nullable Object key ) { return keyToKeyList . containsKey ( key ) ; } @Override public boolean containsValue ( @Nullable Object value ) { return values ( ) . contains ( value ) ; } @Override public boolean put ( @Nullable K key , @Nullable V value ) { addNode ( key , value , null ) ; return true ; } @Override public List < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { List < V > oldValues = getCopy ( key ) ; ListIterator < V > keyValues = new ValueForKeyIterator ( key ) ; Iterator < ? extends V > newValues = values . iterator ( ) ; while ( keyValues . hasNext ( ) & & newValues . hasNext ( ) ) { keyValues . next ( ) ; keyValues . set ( newValues . next ( ) ) ; } while ( keyValues . hasNext ( ) ) { keyValues . next ( ) ; keyValues . remove ( ) ; } while ( newValues . hasNext ( ) ) { keyValues . add ( newValues . next ( ) ) ; } return oldValues ; } private List < V > getCopy ( @Nullable Object key ) { return unmodifiableList ( Lists . newArrayList ( new ValueForKeyIterator ( key ) ) ) ; } @Override public List < V > removeAll ( @Nullable Object key ) { List < V > oldValues = getCopy ( key ) ; removeAllNodes ( key ) ; return oldValues ; } @Override public void clear ( ) { head = null ; tail = null ; keyToKeyList . clear ( ) ; size = <int> ; modCount + + ; } @Override public List < V > get ( final @Nullable K key ) { return new AbstractSequentialList < V > ( ) { @Override public int size ( ) { KeyList < K , V > keyList = keyToKeyList . get ( key ) ; return ( keyList = = null ) ? <int> : keyList . count ; } @Override public ListIterator < V > listIterator ( int index ) { return new ValueForKeyIterator ( key , index ) ; } } ; } @Override Set < K > createKeySet ( ) { @WeakOuter class KeySetImpl extends Sets . ImprovedAbstractSet < K > { @Override public int size ( ) { return keyToKeyList . size ( ) ; } @Override public Iterator < K > iterator ( ) { return new DistinctKeyIterator ( ) ; } @Override public boolean contains ( Object key ) { return containsKey ( key ) ; } @Override public boolean remove ( Object o ) { return ! LinkedListMultimap . this . removeAll ( o ) . isEmpty ( ) ; } } return new KeySetImpl ( ) ; } @Override public List < V > values ( ) { return ( List < V > ) super . values ( ) ; } @Override List < V > createValues ( ) { @WeakOuter class ValuesImpl extends AbstractSequentialList < V > { @Override public int size ( ) { return size ; } @Override public ListIterator < V > listIterator ( int index ) { final NodeIterator nodeItr = new NodeIterator ( index ) ; return new TransformedListIterator < Entry < K , V > , V > ( nodeItr ) { @Override V transform ( Entry < K , V > entry ) { return entry . getValue ( ) ; } @Override public void set ( V value ) { nodeItr . setValue ( value ) ; } } ; } } return new ValuesImpl ( ) ; } @Override public List < Entry < K , V > > entries ( ) { return ( List < Entry < K , V > > ) super . entries ( ) ; } @Override List < Entry < K , V > > createEntries ( ) { @WeakOuter class EntriesImpl extends AbstractSequentialList < Entry < K , V > > { @Override public int size ( ) { return size ; } @Override public ListIterator < Entry < K , V > > listIterator ( int index ) { return new NodeIterator ( index ) ; } } return new EntriesImpl ( ) ; } @Override Iterator < Entry < K , V > > entryIterator ( ) { throw new AssertionError ( <str> ) ; } @Override Map < K , Collection < V > > createAsMap ( ) { return new Multimaps . AsMap < K , V > ( this ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeInt ( size ( ) ) ; for ( Entry < K , V > entry : entries ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } } @GwtIncompatible ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; keyToKeyList = Maps . newLinkedHashMap ( ) ; int size = stream . readInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { @SuppressWarnings ( <str> ) K key = ( K ) stream . readObject ( ) ; @SuppressWarnings ( <str> ) V value = ( V ) stream . readObject ( ) ; put ( key , value ) ; } } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } 
