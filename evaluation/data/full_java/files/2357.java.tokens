package org . nd4j . bytebuddy . arrays . assign ; import net . bytebuddy . ByteBuddy ; import net . bytebuddy . dynamic . DynamicType ; import net . bytebuddy . dynamic . loading . ClassLoadingStrategy ; import net . bytebuddy . implementation . bytecode . Duplication ; import net . bytebuddy . implementation . bytecode . StackManipulation ; import net . bytebuddy . implementation . bytecode . member . MethodReturn ; import net . bytebuddy . implementation . bytecode . member . MethodVariableAccess ; import net . bytebuddy . matcher . ElementMatchers ; import org . junit . Test ; import org . nd4j . bytebuddy . arithmetic . stackmanipulation . OpStackManipulation ; import org . nd4j . bytebuddy . arrays . stackmanipulation . ArrayStackManipulation ; import org . nd4j . bytebuddy . stackmanipulation . StackManipulationImplementation ; import java . io . File ; import static org . junit . Assert . * ; public class AssignImplementationTest { @Test public void testAssign ( ) throws Exception { new ByteBuddy ( ) . subclass ( AssignValue . class ) . method ( ElementMatchers . isDeclaredBy ( AssignValue . class ) ) . intercept ( new AssignImplmentation ( <int> , <int> ) ) . make ( ) . saveIn ( new File ( <str> ) ) ; Class < ? > dynamicType = new ByteBuddy ( ) . subclass ( AssignValue . class ) . method ( ElementMatchers . isDeclaredBy ( AssignValue . class ) ) . intercept ( new AssignImplmentation ( <int> , <int> ) ) . make ( ) . load ( AssignValue . class . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) ; int [ ] vals = new int [ <int> ] ; AssignValue instance = ( AssignValue ) dynamicType . newInstance ( ) ; instance . assign ( vals , <int> , <int> ) ; assertEquals ( <int> , vals [ <int> ] ) ; } @Test public void inPlaceSet ( ) throws Exception { DynamicType . Unloaded < SetValueInPlace > val = new ByteBuddy ( ) . subclass ( SetValueInPlace . class ) . method ( ElementMatchers . isDeclaredBy ( SetValueInPlace . class ) ) . intercept ( new StackManipulationImplementation ( new StackManipulation . Compound ( MethodVariableAccess . REFERENCE . loadOffset ( <int> ) , MethodVariableAccess . INTEGER . loadOffset ( <int> ) , MethodVariableAccess . INTEGER . loadOffset ( <int> ) , ArrayStackManipulation . store ( ) , MethodReturn . VOID ) ) ) . make ( ) ; val . saveIn ( new File ( <str> ) ) ; SetValueInPlace dv = val . load ( getClass ( ) . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) . newInstance ( ) ; int [ ] ret = { <int> , <int> } ; int [ ] assertion = { <int> , <int> } ; dv . update ( ret , <int> , <int> ) ; assertArrayEquals ( assertion , ret ) ; } @Test public void inPlaceDivide ( ) throws Exception { DynamicType . Unloaded < SetValueInPlace > val = new ByteBuddy ( ) . subclass ( SetValueInPlace . class ) . method ( ElementMatchers . isDeclaredBy ( SetValueInPlace . class ) ) . intercept ( new StackManipulationImplementation ( new StackManipulation . Compound ( MethodVariableAccess . REFERENCE . loadOffset ( <int> ) , MethodVariableAccess . INTEGER . loadOffset ( <int> ) , Duplication . DOUBLE , ArrayStackManipulation . load ( ) , MethodVariableAccess . INTEGER . loadOffset ( <int> ) , OpStackManipulation . div ( ) , ArrayStackManipulation . store ( ) , MethodReturn . VOID ) ) ) . make ( ) ; val . saveIn ( new File ( <str> ) ) ; SetValueInPlace dv = val . load ( getClass ( ) . getClassLoader ( ) , ClassLoadingStrategy . Default . WRAPPER ) . getLoaded ( ) . newInstance ( ) ; int [ ] ret = { <int> , <int> } ; int [ ] assertion = { <int> , <int> } ; dv . update ( ret , <int> , <int> ) ; assertArrayEquals ( assertion , ret ) ; } public interface SetValueInPlace { void update ( int [ ] values , int index , int divideBy ) ; } } 
