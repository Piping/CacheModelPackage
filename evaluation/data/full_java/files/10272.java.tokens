package com . google . common . cache ; import static com . google . common . cache . TestingCacheLoaders . constantLoader ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static com . google . common . cache . TestingRemovalListeners . countingRemovalListener ; import static com . google . common . cache . TestingRemovalListeners . nullRemovalListener ; import static com . google . common . cache . TestingRemovalListeners . queuingRemovalListener ; import static com . google . common . cache . TestingWeighers . constantWeigher ; import static com . google . common . truth . Truth . assertThat ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Ticker ; import com . google . common . cache . TestingRemovalListeners . CountingRemovalListener ; import com . google . common . cache . TestingRemovalListeners . QueuingRemovalListener ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Map ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; @GwtCompatible ( emulated = true ) public class CacheBuilderTest extends TestCase { public void testNewBuilder ( ) { CacheLoader < Object , Integer > loader = constantLoader ( <int> ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . removalListener ( countingRemovalListener ( ) ) . build ( loader ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getUnchecked ( <str> ) ) ; assertEquals ( <int> , cache . size ( ) ) ; } public void testInitialCapacity_negative ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . initialCapacity ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testInitialCapacity_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . initialCapacity ( <int> ) ; try { builder . initialCapacity ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testInitialCapacity_small ( ) { LoadingCache < ? , ? > cache = CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) . build ( identityLoader ( ) ) ; LocalCache < ? , ? > map = CacheTesting . toLocalCache ( cache ) ; assertThat ( map . segments ) . hasLength ( <int> ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; } @GwtIncompatible ( <str> ) public void testInitialCapacity_smallest ( ) { LoadingCache < ? , ? > cache = CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) . build ( identityLoader ( ) ) ; LocalCache < ? , ? > map = CacheTesting . toLocalCache ( cache ) ; assertThat ( map . segments ) . hasLength ( <int> ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; } public void testInitialCapacity_large ( ) { CacheBuilder . newBuilder ( ) . initialCapacity ( Integer . MAX_VALUE ) ; } public void testConcurrencyLevel_zero ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . concurrencyLevel ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testConcurrencyLevel_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . concurrencyLevel ( <int> ) ; try { builder . concurrencyLevel ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testConcurrencyLevel_small ( ) { LoadingCache < ? , ? > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . build ( identityLoader ( ) ) ; LocalCache < ? , ? > map = CacheTesting . toLocalCache ( cache ) ; assertThat ( map . segments ) . hasLength ( <int> ) ; } public void testConcurrencyLevel_large ( ) { CacheBuilder . newBuilder ( ) . concurrencyLevel ( Integer . MAX_VALUE ) ; } public void testMaximumSize_negative ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . maximumSize ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMaximumSize_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . maximumSize ( <int> ) ; try { builder . maximumSize ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testMaximumSize_andWeight ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . maximumSize ( <int> ) ; try { builder . maximumWeight ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testMaximumWeight_negative ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . maximumWeight ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testMaximumWeight_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . maximumWeight ( <int> ) ; try { builder . maximumWeight ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { builder . maximumSize ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testMaximumWeight_withoutWeigher ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . maximumWeight ( <int> ) ; try { builder . build ( identityLoader ( ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testWeigher_withoutMaximumWeight ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . weigher ( constantWeigher ( <int> ) ) ; try { builder . build ( identityLoader ( ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testWeigher_withMaximumSize ( ) { try { new CacheBuilder < Object , Object > ( ) . weigher ( constantWeigher ( <int> ) ) . maximumSize ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { new CacheBuilder < Object , Object > ( ) . maximumSize ( <int> ) . weigher ( constantWeigher ( <int> ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testKeyStrengthSetTwice ( ) { CacheBuilder < Object , Object > builder1 = new CacheBuilder < Object , Object > ( ) . weakKeys ( ) ; try { builder1 . weakKeys ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } @GwtIncompatible ( <str> ) public void testValueStrengthSetTwice ( ) { CacheBuilder < Object , Object > builder1 = new CacheBuilder < Object , Object > ( ) . weakValues ( ) ; try { builder1 . weakValues ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { builder1 . softValues ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } CacheBuilder < Object , Object > builder2 = new CacheBuilder < Object , Object > ( ) . softValues ( ) ; try { builder2 . softValues ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } try { builder2 . weakValues ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testTimeToLive_negative ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . expireAfterWrite ( - <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testTimeToLive_small ( ) { CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , NANOSECONDS ) . build ( identityLoader ( ) ) ; } public void testTimeToLive_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . expireAfterWrite ( <int> , SECONDS ) ; try { builder . expireAfterWrite ( <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testTimeToIdle_negative ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . expireAfterAccess ( - <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testTimeToIdle_small ( ) { CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , NANOSECONDS ) . build ( identityLoader ( ) ) ; } public void testTimeToIdle_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . expireAfterAccess ( <int> , SECONDS ) ; try { builder . expireAfterAccess ( <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testTimeToIdleAndToLive ( ) { CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , NANOSECONDS ) . expireAfterAccess ( <int> , NANOSECONDS ) . build ( identityLoader ( ) ) ; } @GwtIncompatible ( <str> ) public void testRefresh_zero ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; try { builder . refreshAfterWrite ( <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testRefresh_setTwice ( ) { CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . refreshAfterWrite ( <int> , SECONDS ) ; try { builder . refreshAfterWrite ( <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testTicker_setTwice ( ) { Ticker testTicker = Ticker . systemTicker ( ) ; CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . ticker ( testTicker ) ; try { builder . ticker ( testTicker ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testRemovalListener_setTwice ( ) { RemovalListener < Object , Object > testListener = nullRemovalListener ( ) ; CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) . removalListener ( testListener ) ; try { builder = builder . removalListener ( testListener ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testValuesIsNotASet ( ) { assertThat ( new CacheBuilder < Object , Object > ( ) . build ( ) . asMap ( ) . values ( ) ) . isNotInstanceOf ( Set . class ) ; } @GwtIncompatible ( <str> ) public void testNullCache ( ) { CountingRemovalListener < Object , Object > listener = countingRemovalListener ( ) ; LoadingCache < Object , Object > nullCache = new CacheBuilder < Object , Object > ( ) . maximumSize ( <int> ) . removalListener ( listener ) . build ( identityLoader ( ) ) ; assertEquals ( <int> , nullCache . size ( ) ) ; Object key = new Object ( ) ; assertSame ( key , nullCache . getUnchecked ( key ) ) ; assertEquals ( <int> , listener . getCount ( ) ) ; assertEquals ( <int> , nullCache . size ( ) ) ; CacheTesting . checkEmpty ( nullCache . asMap ( ) ) ; } @GwtIncompatible ( <str> ) public void testRemovalNotification_clear ( ) throws InterruptedException { final AtomicBoolean shouldWait = new AtomicBoolean ( false ) ; final CountDownLatch computingLatch = new CountDownLatch ( <int> ) ; CacheLoader < String , String > computingFunction = new CacheLoader < String , String > ( ) { @Override public String load ( String key ) throws InterruptedException { if ( shouldWait . get ( ) ) { computingLatch . await ( ) ; } return key ; } } ; QueuingRemovalListener < String , String > listener = queuingRemovalListener ( ) ; final LoadingCache < String , String > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . removalListener ( listener ) . build ( computingFunction ) ; cache . getUnchecked ( <str> ) ; shouldWait . set ( true ) ; final CountDownLatch computationStarted = new CountDownLatch ( <int> ) ; final CountDownLatch computationComplete = new CountDownLatch ( <int> ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { computationStarted . countDown ( ) ; cache . getUnchecked ( <str> ) ; computationComplete . countDown ( ) ; } } ) . start ( ) ; computationStarted . await ( ) ; cache . invalidateAll ( ) ; computingLatch . countDown ( ) ; computationComplete . await ( ) ; assertEquals ( <int> , listener . size ( ) ) ; RemovalNotification < String , String > notification = listener . remove ( ) ; assertEquals ( <str> , notification . getKey ( ) ) ; assertEquals ( <str> , notification . getValue ( ) ) ; assertEquals ( <int> , cache . size ( ) ) ; assertEquals ( <str> , cache . getUnchecked ( <str> ) ) ; } @GwtIncompatible ( <str> ) public void testRemovalNotification_clear_basher ( ) throws InterruptedException { AtomicBoolean computationShouldWait = new AtomicBoolean ( ) ; CountDownLatch computationLatch = new CountDownLatch ( <int> ) ; QueuingRemovalListener < String , String > listener = queuingRemovalListener ( ) ; final LoadingCache < String , String > cache = CacheBuilder . newBuilder ( ) . removalListener ( listener ) . concurrencyLevel ( <int> ) . build ( new DelayingIdentityLoader < String > ( computationShouldWait , computationLatch ) ) ; int nThreads = <int> ; int nTasks = <int> ; int nSeededEntries = <int> ; Set < String > expectedKeys = Sets . newHashSetWithExpectedSize ( nTasks + nSeededEntries ) ; for ( int i = <int> ; i < nSeededEntries ; i + + ) { String s = <str> + i ; cache . getUnchecked ( s ) ; expectedKeys . add ( s ) ; } computationShouldWait . set ( true ) ; final AtomicInteger computedCount = new AtomicInteger ( ) ; ExecutorService threadPool = Executors . newFixedThreadPool ( nThreads ) ; final CountDownLatch tasksFinished = new CountDownLatch ( nTasks ) ; for ( int i = <int> ; i < nTasks ; i + + ) { final String s = <str> + i ; threadPool . submit ( new Runnable ( ) { @Override public void run ( ) { cache . getUnchecked ( s ) ; computedCount . incrementAndGet ( ) ; tasksFinished . countDown ( ) ; } } ) ; expectedKeys . add ( s ) ; } computationLatch . countDown ( ) ; while ( computedCount . get ( ) < nThreads ) { Thread . yield ( ) ; } cache . invalidateAll ( ) ; tasksFinished . await ( ) ; Map < String , String > removalNotifications = Maps . newHashMap ( ) ; for ( RemovalNotification < String , String > notification : listener ) { removalNotifications . put ( notification . getKey ( ) , notification . getValue ( ) ) ; assertEquals ( <str> , notification . getKey ( ) , notification . getValue ( ) ) ; } for ( int i = <int> ; i < nSeededEntries ; i + + ) { assertEquals ( <str> + i , removalNotifications . get ( <str> + i ) ) ; } assertEquals ( expectedKeys , Sets . union ( cache . asMap ( ) . keySet ( ) , removalNotifications . keySet ( ) ) ) ; assertTrue ( Sets . intersection ( cache . asMap ( ) . keySet ( ) , removalNotifications . keySet ( ) ) . isEmpty ( ) ) ; } @GwtIncompatible ( <str> ) public void testRemovalNotification_get_basher ( ) throws InterruptedException { int nTasks = <int> ; int nThreads = <int> ; final int getsPerTask = <int> ; final int nUniqueKeys = <int> ; final Random random = new Random ( ) ; QueuingRemovalListener < String , String > removalListener = queuingRemovalListener ( ) ; final AtomicInteger computeCount = new AtomicInteger ( ) ; final AtomicInteger exceptionCount = new AtomicInteger ( ) ; final AtomicInteger computeNullCount = new AtomicInteger ( ) ; CacheLoader < String , String > countingIdentityLoader = new CacheLoader < String , String > ( ) { @Override public String load ( String key ) throws InterruptedException { int behavior = random . nextInt ( <int> ) ; if ( behavior = = <int> ) { exceptionCount . incrementAndGet ( ) ; throw new RuntimeException ( <str> ) ; } else if ( behavior = = <int> ) { computeNullCount . incrementAndGet ( ) ; return null ; } else if ( behavior = = <int> ) { Thread . sleep ( <int> ) ; computeCount . incrementAndGet ( ) ; return key ; } else { computeCount . incrementAndGet ( ) ; return key ; } } } ; final LoadingCache < String , String > cache = CacheBuilder . newBuilder ( ) . recordStats ( ) . concurrencyLevel ( <int> ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . removalListener ( removalListener ) . maximumSize ( <int> ) . build ( countingIdentityLoader ) ; ExecutorService threadPool = Executors . newFixedThreadPool ( nThreads ) ; for ( int i = <int> ; i < nTasks ; i + + ) { threadPool . submit ( new Runnable ( ) { @Override public void run ( ) { for ( int j = <int> ; j < getsPerTask ; j + + ) { try { cache . getUnchecked ( <str> + random . nextInt ( nUniqueKeys ) ) ; } catch ( RuntimeException e ) { } } } } ) ; } threadPool . shutdown ( ) ; threadPool . awaitTermination ( <int> , TimeUnit . SECONDS ) ; for ( RemovalNotification < String , String > notification : removalListener ) { assertEquals ( <str> , notification . getKey ( ) , notification . getValue ( ) ) ; } CacheStats stats = cache . stats ( ) ; assertEquals ( removalListener . size ( ) , stats . evictionCount ( ) ) ; assertEquals ( computeCount . get ( ) , stats . loadSuccessCount ( ) ) ; assertEquals ( exceptionCount . get ( ) + computeNullCount . get ( ) , stats . loadExceptionCount ( ) ) ; assertEquals ( computeCount . get ( ) , cache . size ( ) + removalListener . size ( ) ) ; } @GwtIncompatible ( <str> ) public void testNullParameters ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; CacheBuilder < Object , Object > builder = new CacheBuilder < Object , Object > ( ) ; tester . testAllPublicInstanceMethods ( builder ) ; } @GwtIncompatible ( <str> ) public void testSizingDefaults ( ) { LoadingCache < ? , ? > cache = CacheBuilder . newBuilder ( ) . build ( identityLoader ( ) ) ; LocalCache < ? , ? > map = CacheTesting . toLocalCache ( cache ) ; assertThat ( map . segments ) . hasLength ( <int> ) ; assertEquals ( <int> , map . segments [ <int> ] . table . length ( ) ) ; } @GwtIncompatible ( <str> ) static final class DelayingIdentityLoader < T > extends CacheLoader < T , T > { private final AtomicBoolean shouldWait ; private final CountDownLatch delayLatch ; DelayingIdentityLoader ( AtomicBoolean shouldWait , CountDownLatch delayLatch ) { this . shouldWait = shouldWait ; this . delayLatch = delayLatch ; } @Override public T load ( T key ) throws InterruptedException { if ( shouldWait . get ( ) ) { delayLatch . await ( ) ; } return key ; } } } 
