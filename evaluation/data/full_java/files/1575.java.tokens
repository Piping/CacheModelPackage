package org . apache . cassandra . io . util ; import java . io . EOFException ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Random ; import com . google . common . primitives . Ints ; import org . junit . Test ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class FileSegmentInputStreamTest { private ByteBuffer allocateBuffer ( int size ) { ByteBuffer ret = ByteBuffer . allocate ( Ints . checkedCast ( size ) ) ; long seed = System . nanoTime ( ) ; System . out . println ( <str> + seed ) ; new Random ( seed ) . nextBytes ( ret . array ( ) ) ; return ret ; } @Test public void testRead ( ) throws IOException { testRead ( <int> , <int> , <int> ) ; testRead ( <int> , <int> , <int> ) ; testRead ( <int> , <int> , <int> ) ; } private void testRead ( int offset , int size , int checkInterval ) throws IOException { final ByteBuffer buffer = allocateBuffer ( size ) ; final String path = buffer . toString ( ) ; FileSegmentInputStream reader = new FileSegmentInputStream ( buffer . duplicate ( ) , path , offset ) ; assertEquals ( path , reader . getPath ( ) ) ; for ( int i = offset ; i < ( size + offset ) ; i + = checkInterval ) { reader . seek ( i ) ; assertFalse ( reader . isEOF ( ) ) ; assertEquals ( i , reader . getFilePointer ( ) ) ; buffer . position ( i - offset ) ; int remaining = buffer . remaining ( ) ; assertEquals ( remaining , reader . bytesRemaining ( ) ) ; byte [ ] expected = new byte [ buffer . remaining ( ) ] ; buffer . get ( expected ) ; assertTrue ( Arrays . equals ( expected , ByteBufferUtil . read ( reader , remaining ) . array ( ) ) ) ; assertTrue ( reader . isEOF ( ) ) ; assertEquals ( <int> , reader . bytesRemaining ( ) ) ; assertEquals ( buffer . capacity ( ) + offset , reader . getFilePointer ( ) ) ; } reader . close ( ) ; reader . close ( ) ; } @Test ( expected = UnsupportedOperationException . class ) public void testMarkNotSupported ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; assertFalse ( reader . markSupported ( ) ) ; assertEquals ( <int> , reader . bytesPastMark ( null ) ) ; reader . mark ( ) ; } @Test ( expected = UnsupportedOperationException . class ) public void testResetNotSupported ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; reader . reset ( null ) ; } @Test ( expected = IllegalArgumentException . class ) public void testSeekNegative ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; reader . seek ( - <int> ) ; } @Test ( expected = IllegalArgumentException . class ) public void testSeekBeforeOffset ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; reader . seek ( <int> ) ; } @Test ( expected = IllegalArgumentException . class ) public void testSeekPastLength ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; reader . seek ( <int> ) ; } @Test ( expected = EOFException . class ) public void testReadBytesTooMany ( ) throws Exception { FileSegmentInputStream reader = new FileSegmentInputStream ( allocateBuffer ( <int> ) , <str> , <int> ) ; ByteBufferUtil . read ( reader , <int> ) ; } } 
