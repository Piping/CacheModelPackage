package com . google . common . base ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . CharMatcher . NamedFastMatcher ; import java . util . BitSet ; @GwtIncompatible ( <str> ) final class SmallCharMatcher extends NamedFastMatcher { static final int MAX_SIZE = <int> ; private final char [ ] table ; private final boolean containsZero ; private final long filter ; private SmallCharMatcher ( char [ ] table , long filter , boolean containsZero , String description ) { super ( description ) ; this . table = table ; this . filter = filter ; this . containsZero = containsZero ; } private static final int C1 = <hex> ; private static final int C2 = <hex> ; static int smear ( int hashCode ) { return C2 * Integer . rotateLeft ( hashCode * C1 , <int> ) ; } private boolean checkFilter ( int c ) { return <int> = = ( <int> & ( filter > > c ) ) ; } private static final double DESIRED_LOAD_FACTOR = <float> ; @VisibleForTesting static int chooseTableSize ( int setSize ) { if ( setSize = = <int> ) { return <int> ; } int tableSize = Integer . highestOneBit ( setSize - <int> ) < < <int> ; while ( tableSize * DESIRED_LOAD_FACTOR < setSize ) { tableSize < < = <int> ; } return tableSize ; } static CharMatcher from ( BitSet chars , String description ) { long filter = <int> ; int size = chars . cardinality ( ) ; boolean containsZero = chars . get ( <int> ) ; char [ ] table = new char [ chooseTableSize ( size ) ] ; int mask = table . length - <int> ; for ( int c = chars . nextSetBit ( <int> ) ; c ! = - <int> ; c = chars . nextSetBit ( c + <int> ) ) { filter | = <int> < < c ; int index = smear ( c ) & mask ; while ( true ) { if ( table [ index ] = = <int> ) { table [ index ] = ( char ) c ; break ; } index = ( index + <int> ) & mask ; } } return new SmallCharMatcher ( table , filter , containsZero , description ) ; } @Override public boolean matches ( char c ) { if ( c = = <int> ) { return containsZero ; } if ( ! checkFilter ( c ) ) { return false ; } int mask = table . length - <int> ; int startingIndex = smear ( c ) & mask ; int index = startingIndex ; do { if ( table [ index ] = = <int> ) { return false ; } else if ( table [ index ] = = c ) { return true ; } else { index = ( index + <int> ) & mask ; } } while ( index ! = startingIndex ) ; return false ; } @Override void setBits ( BitSet table ) { if ( containsZero ) { table . set ( <int> ) ; } for ( char c : this . table ) { if ( c ! = <int> ) { table . set ( c ) ; } } } } 
