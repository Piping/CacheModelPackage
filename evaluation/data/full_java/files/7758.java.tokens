package org . elasticsearch . action . support ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import org . junit . Before ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . notNullValue ; public class TransportActionFilterChainTests extends ESTestCase { private AtomicInteger counter ; @Before public void init ( ) throws Exception { counter = new AtomicInteger ( ) ; } public void testActionFiltersRequest ( ) throws ExecutionException , InterruptedException { int numFilters = randomInt ( <int> ) ; Set < Integer > orders = new HashSet < > ( numFilters ) ; while ( orders . size ( ) < numFilters ) { orders . add ( randomInt ( <int> ) ) ; } Set < ActionFilter > filters = new HashSet < > ( ) ; for ( Integer order : orders ) { filters . add ( new RequestTestFilter ( order , randomFrom ( RequestOperation . values ( ) ) ) ) ; } String actionName = randomAsciiOfLength ( randomInt ( <int> ) ) ; ActionFilters actionFilters = new ActionFilters ( filters ) ; TransportAction < TestRequest , TestResponse > transportAction = new TransportAction < TestRequest , TestResponse > ( Settings . EMPTY , actionName , null , actionFilters , null ) { @Override protected void doExecute ( TestRequest request , ActionListener < TestResponse > listener ) { listener . onResponse ( new TestResponse ( ) ) ; } } ; ArrayList < ActionFilter > actionFiltersByOrder = new ArrayList < > ( filters ) ; Collections . sort ( actionFiltersByOrder , new Comparator < ActionFilter > ( ) { @Override public int compare ( ActionFilter o1 , ActionFilter o2 ) { return Integer . compare ( o1 . order ( ) , o2 . order ( ) ) ; } } ) ; List < ActionFilter > expectedActionFilters = new ArrayList < > ( ) ; boolean errorExpected = false ; for ( ActionFilter filter : actionFiltersByOrder ) { RequestTestFilter testFilter = ( RequestTestFilter ) filter ; expectedActionFilters . add ( testFilter ) ; if ( testFilter . callback = = RequestOperation . LISTENER_FAILURE ) { errorExpected = true ; } if ( ! ( testFilter . callback = = RequestOperation . CONTINUE_PROCESSING ) ) { break ; } } PlainListenableActionFuture < TestResponse > future = new PlainListenableActionFuture < > ( null ) ; transportAction . execute ( new TestRequest ( ) , future ) ; try { assertThat ( future . get ( ) , notNullValue ( ) ) ; assertThat ( <str> , errorExpected , equalTo ( false ) ) ; } catch ( Throwable t ) { assertThat ( <str> + t . getMessage ( ) , errorExpected , equalTo ( true ) ) ; } List < RequestTestFilter > testFiltersByLastExecution = new ArrayList < > ( ) ; for ( ActionFilter actionFilter : actionFilters . filters ( ) ) { testFiltersByLastExecution . add ( ( RequestTestFilter ) actionFilter ) ; } Collections . sort ( testFiltersByLastExecution , new Comparator < RequestTestFilter > ( ) { @Override public int compare ( RequestTestFilter o1 , RequestTestFilter o2 ) { return Integer . compare ( o1 . executionToken , o2 . executionToken ) ; } } ) ; ArrayList < RequestTestFilter > finalTestFilters = new ArrayList < > ( ) ; for ( ActionFilter filter : testFiltersByLastExecution ) { RequestTestFilter testFilter = ( RequestTestFilter ) filter ; finalTestFilters . add ( testFilter ) ; if ( ! ( testFilter . callback = = RequestOperation . CONTINUE_PROCESSING ) ) { break ; } } assertThat ( finalTestFilters . size ( ) , equalTo ( expectedActionFilters . size ( ) ) ) ; for ( int i = <int> ; i < finalTestFilters . size ( ) ; i + + ) { RequestTestFilter testFilter = finalTestFilters . get ( i ) ; assertThat ( testFilter , equalTo ( expectedActionFilters . get ( i ) ) ) ; assertThat ( testFilter . runs . get ( ) , equalTo ( <int> ) ) ; assertThat ( testFilter . lastActionName , equalTo ( actionName ) ) ; } } public void testActionFiltersResponse ( ) throws ExecutionException , InterruptedException { int numFilters = randomInt ( <int> ) ; Set < Integer > orders = new HashSet < > ( numFilters ) ; while ( orders . size ( ) < numFilters ) { orders . add ( randomInt ( <int> ) ) ; } Set < ActionFilter > filters = new HashSet < > ( ) ; for ( Integer order : orders ) { filters . add ( new ResponseTestFilter ( order , randomFrom ( ResponseOperation . values ( ) ) ) ) ; } String actionName = randomAsciiOfLength ( randomInt ( <int> ) ) ; ActionFilters actionFilters = new ActionFilters ( filters ) ; TransportAction < TestRequest , TestResponse > transportAction = new TransportAction < TestRequest , TestResponse > ( Settings . EMPTY , actionName , null , actionFilters , null ) { @Override protected void doExecute ( TestRequest request , ActionListener < TestResponse > listener ) { listener . onResponse ( new TestResponse ( ) ) ; } } ; ArrayList < ActionFilter > actionFiltersByOrder = new ArrayList < > ( filters ) ; Collections . sort ( actionFiltersByOrder , new Comparator < ActionFilter > ( ) { @Override public int compare ( ActionFilter o1 , ActionFilter o2 ) { return Integer . compare ( o2 . order ( ) , o1 . order ( ) ) ; } } ) ; List < ActionFilter > expectedActionFilters = new ArrayList < > ( ) ; boolean errorExpected = false ; for ( ActionFilter filter : actionFiltersByOrder ) { ResponseTestFilter testFilter = ( ResponseTestFilter ) filter ; expectedActionFilters . add ( testFilter ) ; if ( testFilter . callback = = ResponseOperation . LISTENER_FAILURE ) { errorExpected = true ; } if ( testFilter . callback ! = ResponseOperation . CONTINUE_PROCESSING ) { break ; } } PlainListenableActionFuture < TestResponse > future = new PlainListenableActionFuture < > ( null ) ; transportAction . execute ( new TestRequest ( ) , future ) ; try { assertThat ( future . get ( ) , notNullValue ( ) ) ; assertThat ( <str> , errorExpected , equalTo ( false ) ) ; } catch ( Throwable t ) { assertThat ( <str> + t . getMessage ( ) , errorExpected , equalTo ( true ) ) ; } List < ResponseTestFilter > testFiltersByLastExecution = new ArrayList < > ( ) ; for ( ActionFilter actionFilter : actionFilters . filters ( ) ) { testFiltersByLastExecution . add ( ( ResponseTestFilter ) actionFilter ) ; } Collections . sort ( testFiltersByLastExecution , new Comparator < ResponseTestFilter > ( ) { @Override public int compare ( ResponseTestFilter o1 , ResponseTestFilter o2 ) { return Integer . compare ( o1 . executionToken , o2 . executionToken ) ; } } ) ; ArrayList < ResponseTestFilter > finalTestFilters = new ArrayList < > ( ) ; for ( ActionFilter filter : testFiltersByLastExecution ) { ResponseTestFilter testFilter = ( ResponseTestFilter ) filter ; finalTestFilters . add ( testFilter ) ; if ( testFilter . callback ! = ResponseOperation . CONTINUE_PROCESSING ) { break ; } } assertThat ( finalTestFilters . size ( ) , equalTo ( expectedActionFilters . size ( ) ) ) ; for ( int i = <int> ; i < finalTestFilters . size ( ) ; i + + ) { ResponseTestFilter testFilter = finalTestFilters . get ( i ) ; assertThat ( testFilter , equalTo ( expectedActionFilters . get ( i ) ) ) ; assertThat ( testFilter . runs . get ( ) , equalTo ( <int> ) ) ; assertThat ( testFilter . lastActionName , equalTo ( actionName ) ) ; } } public void testTooManyContinueProcessingRequest ( ) throws ExecutionException , InterruptedException { final int additionalContinueCount = randomInt ( <int> ) ; RequestTestFilter testFilter = new RequestTestFilter ( randomInt ( ) , new RequestCallback ( ) { @Override public void execute ( final String action , final ActionRequest actionRequest , final ActionListener actionListener , final ActionFilterChain actionFilterChain ) { for ( int i = <int> ; i < = additionalContinueCount ; i + + ) { actionFilterChain . proceed ( action , actionRequest , actionListener ) ; } } } ) ; Set < ActionFilter > filters = new HashSet < > ( ) ; filters . add ( testFilter ) ; String actionName = randomAsciiOfLength ( randomInt ( <int> ) ) ; ActionFilters actionFilters = new ActionFilters ( filters ) ; TransportAction < TestRequest , TestResponse > transportAction = new TransportAction < TestRequest , TestResponse > ( Settings . EMPTY , actionName , null , actionFilters , null ) { @Override protected void doExecute ( TestRequest request , ActionListener < TestResponse > listener ) { listener . onResponse ( new TestResponse ( ) ) ; } } ; final CountDownLatch latch = new CountDownLatch ( additionalContinueCount + <int> ) ; final AtomicInteger responses = new AtomicInteger ( ) ; final List < Throwable > failures = new CopyOnWriteArrayList < > ( ) ; transportAction . execute ( new TestRequest ( ) , new ActionListener < TestResponse > ( ) { @Override public void onResponse ( TestResponse testResponse ) { responses . incrementAndGet ( ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable e ) { failures . add ( e ) ; latch . countDown ( ) ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } assertThat ( testFilter . runs . get ( ) , equalTo ( <int> ) ) ; assertThat ( testFilter . lastActionName , equalTo ( actionName ) ) ; assertThat ( responses . get ( ) , equalTo ( <int> ) ) ; assertThat ( failures . size ( ) , equalTo ( additionalContinueCount ) ) ; for ( Throwable failure : failures ) { assertThat ( failure , instanceOf ( IllegalStateException . class ) ) ; } } public void testTooManyContinueProcessingResponse ( ) throws ExecutionException , InterruptedException { final int additionalContinueCount = randomInt ( <int> ) ; ResponseTestFilter testFilter = new ResponseTestFilter ( randomInt ( ) , new ResponseCallback ( ) { @Override public void execute ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { for ( int i = <int> ; i < = additionalContinueCount ; i + + ) { chain . proceed ( action , response , listener ) ; } } } ) ; Set < ActionFilter > filters = new HashSet < > ( ) ; filters . add ( testFilter ) ; String actionName = randomAsciiOfLength ( randomInt ( <int> ) ) ; ActionFilters actionFilters = new ActionFilters ( filters ) ; TransportAction < TestRequest , TestResponse > transportAction = new TransportAction < TestRequest , TestResponse > ( Settings . EMPTY , actionName , null , actionFilters , null ) { @Override protected void doExecute ( TestRequest request , ActionListener < TestResponse > listener ) { listener . onResponse ( new TestResponse ( ) ) ; } } ; final CountDownLatch latch = new CountDownLatch ( additionalContinueCount + <int> ) ; final AtomicInteger responses = new AtomicInteger ( ) ; final List < Throwable > failures = new CopyOnWriteArrayList < > ( ) ; transportAction . execute ( new TestRequest ( ) , new ActionListener < TestResponse > ( ) { @Override public void onResponse ( TestResponse testResponse ) { responses . incrementAndGet ( ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable e ) { failures . add ( e ) ; latch . countDown ( ) ; } } ) ; if ( ! latch . await ( <int> , TimeUnit . SECONDS ) ) { fail ( <str> ) ; } assertThat ( testFilter . runs . get ( ) , equalTo ( <int> ) ) ; assertThat ( testFilter . lastActionName , equalTo ( actionName ) ) ; assertThat ( responses . get ( ) , equalTo ( <int> ) ) ; assertThat ( failures . size ( ) , equalTo ( additionalContinueCount ) ) ; for ( Throwable failure : failures ) { assertThat ( failure , instanceOf ( IllegalStateException . class ) ) ; } } private class RequestTestFilter implements ActionFilter { private final RequestCallback callback ; private final int order ; AtomicInteger runs = new AtomicInteger ( ) ; volatile String lastActionName ; volatile int executionToken = Integer . MAX_VALUE ; RequestTestFilter ( int order , RequestCallback callback ) { this . order = order ; this . callback = callback ; } @Override public int order ( ) { return order ; } @SuppressWarnings ( <str> ) @Override public void apply ( String action , ActionRequest actionRequest , ActionListener actionListener , ActionFilterChain actionFilterChain ) { this . runs . incrementAndGet ( ) ; this . lastActionName = action ; this . executionToken = counter . incrementAndGet ( ) ; this . callback . execute ( action , actionRequest , actionListener , actionFilterChain ) ; } @Override public void apply ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { chain . proceed ( action , response , listener ) ; } } private class ResponseTestFilter implements ActionFilter { private final ResponseCallback callback ; private final int order ; AtomicInteger runs = new AtomicInteger ( ) ; volatile String lastActionName ; volatile int executionToken = Integer . MAX_VALUE ; ResponseTestFilter ( int order , ResponseCallback callback ) { this . order = order ; this . callback = callback ; } @Override public int order ( ) { return order ; } @Override public void apply ( String action , ActionRequest request , ActionListener listener , ActionFilterChain chain ) { chain . proceed ( action , request , listener ) ; } @Override public void apply ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { this . runs . incrementAndGet ( ) ; this . lastActionName = action ; this . executionToken = counter . incrementAndGet ( ) ; this . callback . execute ( action , response , listener , chain ) ; } } private static enum RequestOperation implements RequestCallback { CONTINUE_PROCESSING { @Override public void execute ( String action , ActionRequest actionRequest , ActionListener actionListener , ActionFilterChain actionFilterChain ) { actionFilterChain . proceed ( action , actionRequest , actionListener ) ; } } , LISTENER_RESPONSE { @Override @SuppressWarnings ( <str> ) public void execute ( String action , ActionRequest actionRequest , ActionListener actionListener , ActionFilterChain actionFilterChain ) { actionListener . onResponse ( new TestResponse ( ) ) ; } } , LISTENER_FAILURE { @Override public void execute ( String action , ActionRequest actionRequest , ActionListener actionListener , ActionFilterChain actionFilterChain ) { actionListener . onFailure ( new ElasticsearchTimeoutException ( <str> ) ) ; } } } private static enum ResponseOperation implements ResponseCallback { CONTINUE_PROCESSING { @Override public void execute ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { chain . proceed ( action , response , listener ) ; } } , LISTENER_RESPONSE { @Override @SuppressWarnings ( <str> ) public void execute ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { listener . onResponse ( new TestResponse ( ) ) ; } } , LISTENER_FAILURE { @Override public void execute ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) { listener . onFailure ( new ElasticsearchTimeoutException ( <str> ) ) ; } } } private static interface RequestCallback { void execute ( String action , ActionRequest actionRequest , ActionListener actionListener , ActionFilterChain actionFilterChain ) ; } private static interface ResponseCallback { void execute ( String action , ActionResponse response , ActionListener listener , ActionFilterChain chain ) ; } public static class TestRequest extends ActionRequest { @Override public ActionRequestValidationException validate ( ) { return null ; } } private static class TestResponse extends ActionResponse { } } 
