package org . apache . cassandra . db ; import java . io . IOException ; import com . google . common . collect . ImmutableList ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class RowTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private int nowInSeconds ; private DecoratedKey dk ; private ColumnFamilyStore cfs ; private CFMetaData cfm ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { CFMetaData cfMetadata = CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARD1 ) . addPartitionKey ( <str> , BytesType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , cfMetadata ) ; } @Before public void setup ( ) { nowInSeconds = FBUtilities . nowInSeconds ( ) ; dk = Util . dk ( <str> ) ; cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; cfm = cfs . metadata ; } @Test public void testMergeRangeTombstones ( ) throws InterruptedException { PartitionUpdate update1 = new PartitionUpdate ( cfm , dk , cfm . partitionColumns ( ) , <int> ) ; writeRangeTombstone ( update1 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update1 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update1 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update1 , <str> , <str> , <int> , <int> ) ; PartitionUpdate update2 = new PartitionUpdate ( cfm , dk , cfm . partitionColumns ( ) , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; writeRangeTombstone ( update2 , <str> , <str> , <int> , <int> ) ; try ( UnfilteredRowIterator merged = UnfilteredRowIterators . merge ( ImmutableList . of ( update1 . unfilteredIterator ( ) , update2 . unfilteredIterator ( ) ) , nowInSeconds ) ) { Object [ ] [ ] expected = new Object [ ] [ ] { { <str> , <str> , <int> , <int> } , { <str> , <str> , <int> , <int> } , { <str> , <str> , <int> , <int> } , { <str> , <str> , <int> , <int> } , { <str> , <str> , <int> , <int> } , { <str> , <str> , <int> , <int> } } ; int i = <int> ; while ( merged . hasNext ( ) ) { RangeTombstoneBoundMarker openMarker = ( RangeTombstoneBoundMarker ) merged . next ( ) ; Slice . Bound openBound = openMarker . clustering ( ) ; DeletionTime openDeletion = new DeletionTime ( openMarker . deletionTime ( ) . markedForDeleteAt ( ) , openMarker . deletionTime ( ) . localDeletionTime ( ) ) ; RangeTombstoneBoundMarker closeMarker = ( RangeTombstoneBoundMarker ) merged . next ( ) ; Slice . Bound closeBound = closeMarker . clustering ( ) ; DeletionTime closeDeletion = new DeletionTime ( closeMarker . deletionTime ( ) . markedForDeleteAt ( ) , closeMarker . deletionTime ( ) . localDeletionTime ( ) ) ; assertEquals ( openDeletion , closeDeletion ) ; assertRangeTombstoneMarkers ( openBound , closeBound , openDeletion , expected [ i + + ] ) ; } } } @Test public void testResolve ( ) { ColumnDefinition defA = cfm . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; ColumnDefinition defB = cfm . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSeconds ) ; builder . newRow ( cfm . comparator . make ( <str> ) ) ; writeSimpleCellValue ( builder , cfm , defA , <str> , <int> ) ; writeSimpleCellValue ( builder , cfm , defA , <str> , <int> ) ; writeSimpleCellValue ( builder , cfm , defB , <str> , <int> ) ; Row row = builder . build ( ) ; PartitionUpdate update = PartitionUpdate . singleRowUpdate ( cfm , dk , row ) ; Unfiltered unfiltered = update . unfilteredIterator ( ) . next ( ) ; assertTrue ( unfiltered . kind ( ) = = Unfiltered . Kind . ROW ) ; row = ( Row ) unfiltered ; assertEquals ( <str> , defA . cellValueType ( ) . getString ( row . getCell ( defA ) . value ( ) ) ) ; assertEquals ( <str> , defB . cellValueType ( ) . getString ( row . getCell ( defB ) . value ( ) ) ) ; assertEquals ( <int> , row . columns ( ) . size ( ) ) ; } @Test public void testExpiringColumnExpiration ( ) throws IOException { int ttl = <int> ; ColumnDefinition def = cfm . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; Cell cell = BufferCell . expiring ( def , <int> , ttl , nowInSeconds , ( ( AbstractType ) def . cellValueType ( ) ) . decompose ( <str> ) ) ; PartitionUpdate update = PartitionUpdate . singleRowUpdate ( cfm , dk , BTreeRow . singleCellRow ( cfm . comparator . make ( <str> ) , cell ) ) ; new Mutation ( update ) . applyUnsafe ( ) ; Row row = Util . getOnlyRow ( Util . cmd ( cfs , dk ) . includeRow ( <str> ) . withNowInSeconds ( nowInSeconds ) . build ( ) ) ; assertEquals ( <str> , ByteBufferUtil . string ( row . getCell ( def ) . value ( ) ) ) ; Util . assertEmpty ( Util . cmd ( cfs , dk ) . includeRow ( <str> ) . withNowInSeconds ( nowInSeconds + ttl + <int> ) . build ( ) ) ; } private void assertRangeTombstoneMarkers ( Slice . Bound start , Slice . Bound end , DeletionTime deletionTime , Object [ ] expected ) { AbstractType clusteringType = ( AbstractType ) cfm . comparator . subtype ( <int> ) ; assertEquals ( <int> , start . size ( ) ) ; assertEquals ( start . kind ( ) , Slice . Bound . Kind . INCL_START_BOUND ) ; assertEquals ( expected [ <int> ] , clusteringType . getString ( start . get ( <int> ) ) ) ; assertEquals ( <int> , end . size ( ) ) ; assertEquals ( end . kind ( ) , Slice . Bound . Kind . INCL_END_BOUND ) ; assertEquals ( expected [ <int> ] , clusteringType . getString ( end . get ( <int> ) ) ) ; assertEquals ( expected [ <int> ] , deletionTime . markedForDeleteAt ( ) ) ; assertEquals ( expected [ <int> ] , deletionTime . localDeletionTime ( ) ) ; } public void writeRangeTombstone ( PartitionUpdate update , Object start , Object end , long markedForDeleteAt , int localDeletionTime ) { ClusteringComparator comparator = cfs . getComparator ( ) ; update . add ( new RangeTombstone ( Slice . make ( comparator . make ( start ) , comparator . make ( end ) ) , new DeletionTime ( markedForDeleteAt , localDeletionTime ) ) ) ; } private void writeSimpleCellValue ( Row . Builder builder , CFMetaData cfm , ColumnDefinition columnDefinition , String value , long timestamp ) { builder . addCell ( BufferCell . live ( cfm , columnDefinition , timestamp , ( ( AbstractType ) columnDefinition . cellValueType ( ) ) . decompose ( value ) ) ) ; } } 
