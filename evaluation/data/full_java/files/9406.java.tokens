package com . google . common . hash ; import com . google . common . annotations . Beta ; import com . google . common . base . Preconditions ; import java . io . OutputStream ; import java . io . Serializable ; import java . nio . charset . Charset ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta @CheckReturnValue public final class Funnels { private Funnels ( ) { } public static Funnel < byte [ ] > byteArrayFunnel ( ) { return ByteArrayFunnel . INSTANCE ; } private enum ByteArrayFunnel implements Funnel < byte [ ] > { INSTANCE ; public void funnel ( byte [ ] from , PrimitiveSink into ) { into . putBytes ( from ) ; } @Override public String toString ( ) { return <str> ; } } public static Funnel < CharSequence > unencodedCharsFunnel ( ) { return UnencodedCharsFunnel . INSTANCE ; } private enum UnencodedCharsFunnel implements Funnel < CharSequence > { INSTANCE ; public void funnel ( CharSequence from , PrimitiveSink into ) { into . putUnencodedChars ( from ) ; } @Override public String toString ( ) { return <str> ; } } public static Funnel < CharSequence > stringFunnel ( Charset charset ) { return new StringCharsetFunnel ( charset ) ; } private static class StringCharsetFunnel implements Funnel < CharSequence > , Serializable { private final Charset charset ; StringCharsetFunnel ( Charset charset ) { this . charset = Preconditions . checkNotNull ( charset ) ; } public void funnel ( CharSequence from , PrimitiveSink into ) { into . putString ( from , charset ) ; } @Override public String toString ( ) { return <str> + charset . name ( ) + <str> ; } @Override public boolean equals ( @Nullable Object o ) { if ( o instanceof StringCharsetFunnel ) { StringCharsetFunnel funnel = ( StringCharsetFunnel ) o ; return this . charset . equals ( funnel . charset ) ; } return false ; } @Override public int hashCode ( ) { return StringCharsetFunnel . class . hashCode ( ) ^ charset . hashCode ( ) ; } Object writeReplace ( ) { return new SerializedForm ( charset ) ; } private static class SerializedForm implements Serializable { private final String charsetCanonicalName ; SerializedForm ( Charset charset ) { this . charsetCanonicalName = charset . name ( ) ; } private Object readResolve ( ) { return stringFunnel ( Charset . forName ( charsetCanonicalName ) ) ; } private static final long serialVersionUID = <int> ; } } public static Funnel < Integer > integerFunnel ( ) { return IntegerFunnel . INSTANCE ; } private enum IntegerFunnel implements Funnel < Integer > { INSTANCE ; public void funnel ( Integer from , PrimitiveSink into ) { into . putInt ( from ) ; } @Override public String toString ( ) { return <str> ; } } public static < E > Funnel < Iterable < ? extends E > > sequentialFunnel ( Funnel < E > elementFunnel ) { return new SequentialFunnel < E > ( elementFunnel ) ; } private static class SequentialFunnel < E > implements Funnel < Iterable < ? extends E > > , Serializable { private final Funnel < E > elementFunnel ; SequentialFunnel ( Funnel < E > elementFunnel ) { this . elementFunnel = Preconditions . checkNotNull ( elementFunnel ) ; } public void funnel ( Iterable < ? extends E > from , PrimitiveSink into ) { for ( E e : from ) { elementFunnel . funnel ( e , into ) ; } } @Override public String toString ( ) { return <str> + elementFunnel + <str> ; } @Override public boolean equals ( @Nullable Object o ) { if ( o instanceof SequentialFunnel ) { SequentialFunnel < ? > funnel = ( SequentialFunnel < ? > ) o ; return elementFunnel . equals ( funnel . elementFunnel ) ; } return false ; } @Override public int hashCode ( ) { return SequentialFunnel . class . hashCode ( ) ^ elementFunnel . hashCode ( ) ; } } public static Funnel < Long > longFunnel ( ) { return LongFunnel . INSTANCE ; } private enum LongFunnel implements Funnel < Long > { INSTANCE ; public void funnel ( Long from , PrimitiveSink into ) { into . putLong ( from ) ; } @Override public String toString ( ) { return <str> ; } } public static OutputStream asOutputStream ( PrimitiveSink sink ) { return new SinkAsStream ( sink ) ; } private static class SinkAsStream extends OutputStream { final PrimitiveSink sink ; SinkAsStream ( PrimitiveSink sink ) { this . sink = Preconditions . checkNotNull ( sink ) ; } @Override public void write ( int b ) { sink . putByte ( ( byte ) b ) ; } @Override public void write ( byte [ ] bytes ) { sink . putBytes ( bytes ) ; } @Override public void write ( byte [ ] bytes , int off , int len ) { sink . putBytes ( bytes , off , len ) ; } @Override public String toString ( ) { return <str> + sink + <str> ; } } } 
