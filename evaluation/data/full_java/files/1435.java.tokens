package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . Arrays ; import org . junit . AfterClass ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . BufferCell ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . CellPath ; import org . apache . cassandra . db . rows . Cells ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . * ; import static org . junit . Assert . * ; import static org . apache . cassandra . db . context . CounterContext . ContextState ; public class CounterCellTest { private static final CounterContext cc = new CounterContext ( ) ; private static final int idLength ; private static final int clockLength ; private static final int countLength ; private static final int stepLength ; private static final String KEYSPACE1 = <str> ; private static final String COUNTER1 = <str> ; private static final String STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , STANDARD1 ) , SchemaLoader . counterCFMD ( KEYSPACE1 , COUNTER1 ) ) ; } @AfterClass public static void cleanup ( ) { SchemaLoader . cleanupSavedCaches ( ) ; } static { idLength = CounterId . LENGTH ; clockLength = <int> ; countLength = <int> ; stepLength = idLength + clockLength + countLength ; } @Test public void testCreate ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; long delta = <int> ; Cell cell = createLegacyCounterCell ( cfs , ByteBufferUtil . bytes ( <str> ) , delta , <int> ) ; assertEquals ( delta , CounterContext . instance ( ) . total ( cell . value ( ) ) ) ; assertEquals ( <int> , cell . value ( ) . getShort ( <int> ) ) ; assertEquals ( <int> , cell . value ( ) . getShort ( <int> ) ) ; Assert . assertTrue ( CounterId . wrap ( cell . value ( ) , <int> ) . isLocalId ( ) ) ; assertEquals ( <int> , cell . value ( ) . getLong ( <int> + idLength ) ) ; assertEquals ( delta , cell . value ( ) . getLong ( <int> + idLength + clockLength ) ) ; } private Cell createLegacyCounterCell ( ColumnFamilyStore cfs , ByteBuffer colName , long count , long ts ) { ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( colName ) ; ByteBuffer val = CounterContext . instance ( ) . createLocal ( count ) ; return BufferCell . live ( cfs . metadata , cDef , ts , val ) ; } private Cell createCounterCell ( ColumnFamilyStore cfs , ByteBuffer colName , CounterId id , long count , long ts ) { ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( colName ) ; ByteBuffer val = CounterContext . instance ( ) . createGlobal ( id , ts , count ) ; return BufferCell . live ( cfs . metadata , cDef , ts , val ) ; } private Cell createCounterCellFromContext ( ColumnFamilyStore cfs , ByteBuffer colName , ContextState context , long ts ) { ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( colName ) ; return BufferCell . live ( cfs . metadata , cDef , ts , context . context ) ; } private Cell createDeleted ( ColumnFamilyStore cfs , ByteBuffer colName , long ts , int localDeletionTime ) { ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( colName ) ; return BufferCell . tombstone ( cDef , ts , localDeletionTime ) ; } @Test public void testReconcile ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; Cell left ; Cell right ; left = createDeleted ( cfs , col , <int> , <int> ) ; right = createDeleted ( cfs , col , <int> , <int> ) ; assert Cells . reconcile ( left , right , <int> ) = = right ; right = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assert Cells . reconcile ( left , right , <int> ) = = left ; left = createDeleted ( cfs , col , <int> , <int> ) ; right = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assert Cells . reconcile ( left , right , <int> ) = = left ; left = createDeleted ( cfs , col , <int> , <int> ) ; right = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assert Cells . reconcile ( left , right , <int> ) = = left ; left = createDeleted ( cfs , col , <int> , <int> ) ; right = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assert Cells . reconcile ( left , right , <int> ) = = left ; left = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; right = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; Cell reconciled = Cells . reconcile ( left , right , <int> ) ; assertEquals ( CounterContext . instance ( ) . total ( reconciled . value ( ) ) , <int> ) ; assertEquals ( reconciled . timestamp ( ) , <int> ) ; Cell addTen = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; reconciled = Cells . reconcile ( reconciled , addTen , <int> ) ; assertEquals ( CounterContext . instance ( ) . total ( reconciled . value ( ) ) , <int> ) ; assertEquals ( reconciled . timestamp ( ) , <int> ) ; Cell addThree = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; reconciled = Cells . reconcile ( reconciled , addThree , <int> ) ; assertEquals ( CounterContext . instance ( ) . total ( reconciled . value ( ) ) , <int> ) ; assertEquals ( reconciled . timestamp ( ) , <int> ) ; assert reconciled . localDeletionTime ( ) = = Integer . MAX_VALUE ; Cell deleted = createDeleted ( cfs , col , <int> , <int> ) ; reconciled = Cells . reconcile ( reconciled , deleted , <int> ) ; assert reconciled . localDeletionTime ( ) = = <int> ; } @Test public void testDiff ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; Cell leftCell ; Cell rightCell ; leftCell = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; rightCell = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assertEquals ( CounterContext . Relationship . EQUAL , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; leftCell = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; rightCell = createLegacyCounterCell ( cfs , col , <int> , <int> ) ; assertEquals ( CounterContext . Relationship . DISJOINT , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; CounterId id = CounterId . generate ( ) ; leftCell = createCounterCell ( cfs , col , id , <int> , <int> ) ; rightCell = createCounterCell ( cfs , col , id , <int> , <int> ) ; assertEquals ( CounterContext . Relationship . GREATER_THAN , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; ContextState leftContext ; ContextState rightContext ; leftContext = ContextState . allocate ( <int> , <int> , <int> ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext = ContextState . wrap ( ByteBufferUtil . clone ( leftContext . context ) ) ; leftCell = createCounterCellFromContext ( cfs , col , leftContext , <int> ) ; rightCell = createCounterCellFromContext ( cfs , col , rightContext , <int> ) ; assertEquals ( CounterContext . Relationship . EQUAL , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; leftContext = ContextState . allocate ( <int> , <int> , <int> ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> L , <int> L ) ; rightContext = ContextState . allocate ( <int> , <int> , <int> ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftCell = createCounterCellFromContext ( cfs , col , leftContext , <int> ) ; rightCell = createCounterCellFromContext ( cfs , col , rightContext , <int> ) ; assertEquals ( CounterContext . Relationship . GREATER_THAN , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; assertEquals ( CounterContext . Relationship . LESS_THAN , CounterContext . instance ( ) . diff ( rightCell . value ( ) , leftCell . value ( ) ) ) ; leftContext = ContextState . allocate ( <int> , <int> , <int> ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext = ContextState . allocate ( <int> , <int> , <int> ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; rightContext . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> L ) ; leftCell = createCounterCellFromContext ( cfs , col , leftContext , <int> ) ; rightCell = createCounterCellFromContext ( cfs , col , rightContext , <int> ) ; assertEquals ( CounterContext . Relationship . DISJOINT , CounterContext . instance ( ) . diff ( leftCell . value ( ) , rightCell . value ( ) ) ) ; assertEquals ( CounterContext . Relationship . DISJOINT , CounterContext . instance ( ) . diff ( rightCell . value ( ) , leftCell . value ( ) ) ) ; } @Test public void testUpdateDigest ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; MessageDigest digest1 = MessageDigest . getInstance ( <str> ) ; MessageDigest digest2 = MessageDigest . getInstance ( <str> ) ; CounterContext . ContextState state = CounterContext . ContextState . allocate ( <int> , <int> , <int> ) ; state . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> ) ; state . writeLocal ( CounterId . fromInt ( <int> ) , <int> , <int> ) ; state . writeRemote ( CounterId . fromInt ( <int> ) , <int> , <int> ) ; state . writeLocal ( CounterId . fromInt ( <int> ) , <int> , <int> ) ; Cell original = createCounterCellFromContext ( cfs , col , state , <int> ) ; ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( col ) ; Cell cleared = BufferCell . live ( cfs . metadata , cDef , <int> , CounterContext . instance ( ) . clearAllLocal ( state . context ) ) ; CounterContext . instance ( ) . updateDigest ( digest1 , original . value ( ) ) ; CounterContext . instance ( ) . updateDigest ( digest2 , cleared . value ( ) ) ; assert Arrays . equals ( digest1 . digest ( ) , digest2 . digest ( ) ) ; } } 
