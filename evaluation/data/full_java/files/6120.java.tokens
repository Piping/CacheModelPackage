package org . elasticsearch . common . util . concurrent ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; public class EsThreadPoolExecutor extends ThreadPoolExecutor { private volatile ShutdownListener listener ; private final Object monitor = new Object ( ) ; private final String name ; EsThreadPoolExecutor ( String name , int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , BlockingQueue < Runnable > workQueue , ThreadFactory threadFactory ) { this ( name , corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , new EsAbortPolicy ( ) ) ; } EsThreadPoolExecutor ( String name , int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , BlockingQueue < Runnable > workQueue , ThreadFactory threadFactory , XRejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; this . name = name ; } public void shutdown ( ShutdownListener listener ) { synchronized ( monitor ) { if ( this . listener ! = null ) { throw new IllegalStateException ( <str> ) ; } if ( isTerminated ( ) ) { listener . onTerminated ( ) ; } else { this . listener = listener ; } } shutdown ( ) ; } @Override protected synchronized void terminated ( ) { super . terminated ( ) ; synchronized ( monitor ) { if ( listener ! = null ) { try { listener . onTerminated ( ) ; } finally { listener = null ; } } } } public interface ShutdownListener { void onTerminated ( ) ; } @Override public void execute ( Runnable command ) { try { super . execute ( command ) ; } catch ( EsRejectedExecutionException ex ) { if ( command instanceof AbstractRunnable ) { try { ( ( AbstractRunnable ) command ) . onRejection ( ex ) ; } finally { ( ( AbstractRunnable ) command ) . onAfter ( ) ; } } else { throw ex ; } } } @Override public String toString ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( getClass ( ) . getSimpleName ( ) ) . append ( <str> ) ; b . append ( name ) . append ( <str> ) ; if ( getQueue ( ) instanceof SizeBlockingQueue ) { @SuppressWarnings ( <str> ) SizeBlockingQueue queue = ( SizeBlockingQueue ) getQueue ( ) ; b . append ( <str> ) . append ( queue . capacity ( ) ) . append ( <str> ) ; } b . append ( super . toString ( ) ) . append ( <str> ) ; return b . toString ( ) ; } } 
