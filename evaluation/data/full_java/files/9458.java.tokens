package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . math . DoubleUtils . isFinite ; import static java . lang . Double . NaN ; import com . google . common . annotations . Beta ; @Beta public abstract class LinearTransformation { public static LinearTransformationBuilder mapping ( double x1 , double y1 ) { checkArgument ( isFinite ( x1 ) & & isFinite ( y1 ) ) ; return new LinearTransformationBuilder ( x1 , y1 ) ; } public static final class LinearTransformationBuilder { private final double x1 ; private final double y1 ; private LinearTransformationBuilder ( double x1 , double y1 ) { this . x1 = x1 ; this . y1 = y1 ; } public LinearTransformation and ( double x2 , double y2 ) { checkArgument ( isFinite ( x2 ) & & isFinite ( y2 ) ) ; if ( x2 = = x1 ) { checkArgument ( y2 ! = y1 ) ; return new VerticalLinearTransformation ( x1 ) ; } else { return withSlope ( ( y2 - y1 ) / ( x2 - x1 ) ) ; } } public LinearTransformation withSlope ( double slope ) { checkArgument ( ! Double . isNaN ( slope ) ) ; if ( isFinite ( slope ) ) { double yIntercept = y1 - x1 * slope ; return new RegularLinearTransformation ( slope , yIntercept ) ; } else { return new VerticalLinearTransformation ( x1 ) ; } } } public static LinearTransformation vertical ( double x ) { checkArgument ( isFinite ( x ) ) ; return new VerticalLinearTransformation ( x ) ; } public static LinearTransformation horizontal ( double y ) { checkArgument ( isFinite ( y ) ) ; double slope = <float> ; return new RegularLinearTransformation ( slope , y ) ; } public static LinearTransformation forNaN ( ) { return NaNLinearTransformation . INSTANCE ; } public abstract boolean isVertical ( ) ; public abstract boolean isHorizontal ( ) ; public abstract double slope ( ) ; public abstract double transformX ( double x ) ; public abstract double transformY ( double y ) ; private static final class RegularLinearTransformation extends LinearTransformation { final double slope ; final double yIntercept ; RegularLinearTransformation ( double slope , double yIntercept ) { this . slope = slope ; this . yIntercept = yIntercept ; } @Override public boolean isVertical ( ) { return false ; } @Override public boolean isHorizontal ( ) { return ( slope = = <float> ) ; } @Override public double slope ( ) { return slope ; } @Override public double transformX ( double x ) { return x * slope + yIntercept ; } @Override public double transformY ( double y ) { checkState ( slope ! = <float> ) ; return ( y - yIntercept ) / slope ; } @Override public String toString ( ) { return String . format ( <str> , slope , yIntercept ) ; } } private static final class VerticalLinearTransformation extends LinearTransformation { final double x ; VerticalLinearTransformation ( double x ) { this . x = x ; } @Override public boolean isVertical ( ) { return true ; } @Override public boolean isHorizontal ( ) { return false ; } @Override public double slope ( ) { throw new IllegalStateException ( ) ; } @Override public double transformX ( double x ) { throw new IllegalStateException ( ) ; } @Override public double transformY ( double y ) { return x ; } @Override public String toString ( ) { return String . format ( <str> , x ) ; } } private static final class NaNLinearTransformation extends LinearTransformation { static final NaNLinearTransformation INSTANCE = new NaNLinearTransformation ( ) ; @Override public boolean isVertical ( ) { return false ; } @Override public boolean isHorizontal ( ) { return false ; } @Override public double slope ( ) { return NaN ; } @Override public double transformX ( double x ) { return NaN ; } @Override public double transformY ( double y ) { return NaN ; } @Override public String toString ( ) { return String . format ( <str> ) ; } } } 
