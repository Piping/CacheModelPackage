package org . elasticsearch . action . support . broadcast ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . NoShardAvailableActionException ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . action . support . TransportActions ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReferenceArray ; import java . util . function . Supplier ; public abstract class TransportBroadcastAction < Request extends BroadcastRequest , Response extends BroadcastResponse , ShardRequest extends BroadcastShardRequest , ShardResponse extends BroadcastShardResponse > extends HandledTransportAction < Request , Response > { protected final ClusterService clusterService ; protected final TransportService transportService ; final String transportShardAction ; protected TransportBroadcastAction ( Settings settings , String actionName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , Supplier < Request > request , Supplier < ShardRequest > shardRequest , String shardExecutor ) { super ( settings , actionName , threadPool , transportService , actionFilters , indexNameExpressionResolver , request ) ; this . clusterService = clusterService ; this . transportService = transportService ; this . transportShardAction = actionName + <str> ; transportService . registerRequestHandler ( transportShardAction , shardRequest , shardExecutor , new ShardTransportHandler ( ) ) ; } @Override protected void doExecute ( Request request , ActionListener < Response > listener ) { new AsyncBroadcastAction ( request , listener ) . start ( ) ; } protected abstract Response newResponse ( Request request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) ; protected abstract ShardRequest newShardRequest ( int numShards , ShardRouting shard , Request request ) ; protected abstract ShardResponse newShardResponse ( ) ; protected abstract ShardResponse shardOperation ( ShardRequest request ) ; protected abstract GroupShardsIterator shards ( ClusterState clusterState , Request request , String [ ] concreteIndices ) ; protected abstract ClusterBlockException checkGlobalBlock ( ClusterState state , Request request ) ; protected abstract ClusterBlockException checkRequestBlock ( ClusterState state , Request request , String [ ] concreteIndices ) ; protected class AsyncBroadcastAction { private final Request request ; private final ActionListener < Response > listener ; private final ClusterState clusterState ; private final DiscoveryNodes nodes ; private final GroupShardsIterator shardsIts ; private final int expectedOps ; private final AtomicInteger counterOps = new AtomicInteger ( ) ; private final AtomicReferenceArray shardsResponses ; protected AsyncBroadcastAction ( Request request , ActionListener < Response > listener ) { this . request = request ; this . listener = listener ; clusterState = clusterService . state ( ) ; ClusterBlockException blockException = checkGlobalBlock ( clusterState , request ) ; if ( blockException ! = null ) { throw blockException ; } String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request ) ; blockException = checkRequestBlock ( clusterState , request , concreteIndices ) ; if ( blockException ! = null ) { throw blockException ; } nodes = clusterState . nodes ( ) ; logger . trace ( <str> , clusterState . version ( ) ) ; shardsIts = shards ( clusterState , request , concreteIndices ) ; expectedOps = shardsIts . size ( ) ; shardsResponses = new AtomicReferenceArray < > ( expectedOps ) ; } public void start ( ) { if ( shardsIts . size ( ) = = <int> ) { try { listener . onResponse ( newResponse ( request , new AtomicReferenceArray ( <int> ) , clusterState ) ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; } return ; } int shardIndex = - <int> ; for ( final ShardIterator shardIt : shardsIts ) { shardIndex + + ; final ShardRouting shard = shardIt . nextOrNull ( ) ; if ( shard ! = null ) { performOperation ( shardIt , shard , shardIndex ) ; } else { onOperation ( null , shardIt , shardIndex , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } } } protected void performOperation ( final ShardIterator shardIt , final ShardRouting shard , final int shardIndex ) { if ( shard = = null ) { onOperation ( null , shardIt , shardIndex , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } else { try { final ShardRequest shardRequest = newShardRequest ( shardIt . size ( ) , shard , request ) ; DiscoveryNode node = nodes . get ( shard . currentNodeId ( ) ) ; if ( node = = null ) { onOperation ( shard , shardIt , shardIndex , new NoShardAvailableActionException ( shardIt . shardId ( ) ) ) ; } else { transportService . sendRequest ( node , transportShardAction , shardRequest , new BaseTransportResponseHandler < ShardResponse > ( ) { @Override public ShardResponse newInstance ( ) { return newShardResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } @Override public void handleResponse ( ShardResponse response ) { onOperation ( shard , shardIndex , response ) ; } @Override public void handleException ( TransportException e ) { onOperation ( shard , shardIt , shardIndex , e ) ; } } ) ; } } catch ( Throwable e ) { onOperation ( shard , shardIt , shardIndex , e ) ; } } } @SuppressWarnings ( { <str> } ) protected void onOperation ( ShardRouting shard , int shardIndex , ShardResponse response ) { logger . trace ( <str> , shard ) ; shardsResponses . set ( shardIndex , response ) ; if ( expectedOps = = counterOps . incrementAndGet ( ) ) { finishHim ( ) ; } } @SuppressWarnings ( { <str> } ) void onOperation ( @Nullable ShardRouting shard , final ShardIterator shardIt , int shardIndex , Throwable t ) { setFailure ( shardIt , shardIndex , t ) ; ShardRouting nextShard = shardIt . nextOrNull ( ) ; if ( nextShard ! = null ) { if ( t ! = null ) { if ( logger . isTraceEnabled ( ) ) { if ( ! TransportActions . isShardNotAvailableException ( t ) ) { logger . trace ( <str> , t , shard ! = null ? shard . shortSummary ( ) : shardIt . shardId ( ) , request ) ; } } } performOperation ( shardIt , nextShard , shardIndex ) ; } else { if ( logger . isDebugEnabled ( ) ) { if ( t ! = null ) { if ( ! TransportActions . isShardNotAvailableException ( t ) ) { logger . debug ( <str> , t , shard ! = null ? shard . shortSummary ( ) : shardIt . shardId ( ) , request ) ; } } } if ( expectedOps = = counterOps . incrementAndGet ( ) ) { finishHim ( ) ; } } } protected void finishHim ( ) { try { listener . onResponse ( newResponse ( request , shardsResponses , clusterState ) ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; } } void setFailure ( ShardIterator shardIt , int shardIndex , Throwable t ) { if ( TransportActions . isShardNotAvailableException ( t ) ) { return ; } if ( ! ( t instanceof BroadcastShardOperationFailedException ) ) { t = new BroadcastShardOperationFailedException ( shardIt . shardId ( ) , t ) ; } Object response = shardsResponses . get ( shardIndex ) ; if ( response = = null ) { shardsResponses . set ( shardIndex , t ) ; } if ( ! ( response instanceof Throwable ) ) { return ; } if ( TransportActions . isReadOverrideException ( t ) ) { shardsResponses . set ( shardIndex , t ) ; } } } class ShardTransportHandler implements TransportRequestHandler < ShardRequest > { @Override public void messageReceived ( final ShardRequest request , final TransportChannel channel ) throws Exception { channel . sendResponse ( shardOperation ( request ) ) ; } } } 
