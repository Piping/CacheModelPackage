package io . netty . handler . codec . compression ; final class Bzip2HuffmanAllocator { private static int first ( final int [ ] array , int i , final int nodesToMove ) { final int length = array . length ; final int limit = i ; int k = array . length - <int> ; while ( i > = nodesToMove & & array [ i ] % length > limit ) { k = i ; i - = limit - i + <int> ; } i = Math . max ( nodesToMove - <int> , i ) ; while ( k > i + <int> ) { int temp = i + k > > > <int> ; if ( array [ temp ] % length > limit ) { k = temp ; } else { i = temp ; } } return k ; } private static void setExtendedParentPointers ( final int [ ] array ) { final int length = array . length ; array [ <int> ] + = array [ <int> ] ; for ( int headNode = <int> , tailNode = <int> , topNode = <int> ; tailNode < length - <int> ; tailNode + + ) { int temp ; if ( topNode > = length | | array [ headNode ] < array [ topNode ] ) { temp = array [ headNode ] ; array [ headNode + + ] = tailNode ; } else { temp = array [ topNode + + ] ; } if ( topNode > = length | | ( headNode < tailNode & & array [ headNode ] < array [ topNode ] ) ) { temp + = array [ headNode ] ; array [ headNode + + ] = tailNode + length ; } else { temp + = array [ topNode + + ] ; } array [ tailNode ] = temp ; } } private static int findNodesToRelocate ( final int [ ] array , final int maximumLength ) { int currentNode = array . length - <int> ; for ( int currentDepth = <int> ; currentDepth < maximumLength - <int> & & currentNode > <int> ; currentDepth + + ) { currentNode = first ( array , currentNode - <int> , <int> ) ; } return currentNode ; } private static void allocateNodeLengths ( final int [ ] array ) { int firstNode = array . length - <int> ; int nextNode = array . length - <int> ; for ( int currentDepth = <int> , availableNodes = <int> ; availableNodes > <int> ; currentDepth + + ) { final int lastNode = firstNode ; firstNode = first ( array , lastNode - <int> , <int> ) ; for ( int i = availableNodes - ( lastNode - firstNode ) ; i > <int> ; i - - ) { array [ nextNode - - ] = currentDepth ; } availableNodes = ( lastNode - firstNode ) < < <int> ; } } private static void allocateNodeLengthsWithRelocation ( final int [ ] array , final int nodesToMove , final int insertDepth ) { int firstNode = array . length - <int> ; int nextNode = array . length - <int> ; int currentDepth = insertDepth = = <int> ? <int> : <int> ; int nodesLeftToMove = insertDepth = = <int> ? nodesToMove - <int> : nodesToMove ; for ( int availableNodes = currentDepth < < <int> ; availableNodes > <int> ; currentDepth + + ) { final int lastNode = firstNode ; firstNode = firstNode < = nodesToMove ? firstNode : first ( array , lastNode - <int> , nodesToMove ) ; int offset = <int> ; if ( currentDepth > = insertDepth ) { offset = Math . min ( nodesLeftToMove , <int> < < ( currentDepth - insertDepth ) ) ; } else if ( currentDepth = = insertDepth - <int> ) { offset = <int> ; if ( array [ firstNode ] = = lastNode ) { firstNode + + ; } } for ( int i = availableNodes - ( lastNode - firstNode + offset ) ; i > <int> ; i - - ) { array [ nextNode - - ] = currentDepth ; } nodesLeftToMove - = offset ; availableNodes = ( lastNode - firstNode + offset ) < < <int> ; } } static void allocateHuffmanCodeLengths ( final int [ ] array , final int maximumLength ) { switch ( array . length ) { case <int> : array [ <int> ] = <int> ; case <int> : array [ <int> ] = <int> ; return ; } setExtendedParentPointers ( array ) ; int nodesToRelocate = findNodesToRelocate ( array , maximumLength ) ; if ( array [ <int> ] % array . length > = nodesToRelocate ) { allocateNodeLengths ( array ) ; } else { int insertDepth = maximumLength - ( <int> - Integer . numberOfLeadingZeros ( nodesToRelocate - <int> ) ) ; allocateNodeLengthsWithRelocation ( array , nodesToRelocate , insertDepth ) ; } } private Bzip2HuffmanAllocator ( ) { } } 
