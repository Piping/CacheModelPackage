package org . apache . cassandra . utils ; import org . apache . cassandra . utils . CoalescingStrategies . Clock ; import org . apache . cassandra . utils . CoalescingStrategies . Coalescable ; import org . apache . cassandra . utils . CoalescingStrategies . CoalescingStrategy ; import org . apache . cassandra . utils . CoalescingStrategies . Parker ; import org . junit . Before ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . LockSupport ; import static org . junit . Assert . * ; public class CoalescingStrategiesTest { static final ExecutorService ex = Executors . newSingleThreadExecutor ( ) ; private static final Logger logger = LoggerFactory . getLogger ( CoalescingStrategiesTest . class ) ; static class MockParker implements Parker { Queue < Long > parks = new ArrayDeque < Long > ( ) ; Semaphore permits = new Semaphore ( <int> ) ; Semaphore parked = new Semaphore ( <int> ) ; public void park ( long nanos ) { parks . offer ( nanos ) ; parked . release ( ) ; try { permits . acquire ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } static class SimpleCoalescable implements Coalescable { final long timestampNanos ; SimpleCoalescable ( long timestampNanos ) { this . timestampNanos = timestampNanos ; } public long timestampNanos ( ) { return timestampNanos ; } } static long toNanos ( long micros ) { return TimeUnit . MICROSECONDS . toNanos ( micros ) ; } MockParker parker ; BlockingQueue < SimpleCoalescable > input ; List < SimpleCoalescable > output ; CoalescingStrategy cs ; Semaphore queueParked = new Semaphore ( <int> ) ; Semaphore queueRelease = new Semaphore ( <int> ) ; @SuppressWarnings ( { <str> } ) @Before public void setUp ( ) throws Exception { cs = null ; CoalescingStrategies . CLOCK = new Clock ( ) { @Override public long nanoTime ( ) { return <int> ; } } ; parker = new MockParker ( ) ; input = new LinkedBlockingQueue < SimpleCoalescable > ( ) { @Override public SimpleCoalescable take ( ) throws InterruptedException { queueParked . release ( ) ; queueRelease . acquire ( ) ; return super . take ( ) ; } } ; output = new ArrayList < > ( <int> ) ; clear ( ) ; } CoalescingStrategy newStrategy ( String name , int window ) { return CoalescingStrategies . newCoalescingStrategy ( name , window , parker , logger , <str> ) ; } void add ( long whenMicros ) { input . offer ( new SimpleCoalescable ( toNanos ( whenMicros ) ) ) ; } void clear ( ) { output . clear ( ) ; input . clear ( ) ; parker . parks . clear ( ) ; parker . parked . drainPermits ( ) ; parker . permits . drainPermits ( ) ; queueParked . drainPermits ( ) ; queueRelease . drainPermits ( ) ; } void release ( ) throws Exception { queueRelease . release ( ) ; parker . permits . release ( ) ; fut . get ( ) ; } Future < ? > fut ; void runBlocker ( Semaphore waitFor ) throws Exception { fut = ex . submit ( new Runnable ( ) { @Override public void run ( ) { try { cs . coalesce ( input , output , <int> ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } } ) ; waitFor . acquire ( ) ; } @Test public void testFixedCoalescingStrategy ( ) throws Exception { cs = newStrategy ( <str> , <int> ) ; add ( <int> ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; add ( <int> ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertEquals ( toNanos ( <int> ) , parker . parks . poll ( ) . longValue ( ) ) ; } @Test public void testDisabledCoalescingStrateg ( ) throws Exception { cs = newStrategy ( <str> , <int> ) ; add ( <int> ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; } @Test public void parkLoop ( ) throws Exception { final Thread current = Thread . currentThread ( ) ; final Semaphore helperReady = new Semaphore ( <int> ) ; final Semaphore helperGo = new Semaphore ( <int> ) ; new Thread ( ) { @Override public void run ( ) { try { helperReady . release ( ) ; helperGo . acquire ( ) ; Thread . sleep ( <int> ) ; LockSupport . unpark ( current ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( <str> , e ) ; System . exit ( - <int> ) ; } } } . start ( ) ; long start = System . nanoTime ( ) ; helperGo . release ( ) ; long parkNanos = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; CoalescingStrategies . parkLoop ( parkNanos ) ; long delta = System . nanoTime ( ) - start ; assertTrue ( delta > = ( parkNanos - ( parkNanos / <int> ) ) ) ; } @Test public void testMovingAverageCoalescingStrategy ( ) throws Exception { cs = newStrategy ( <str> , <int> ) ; add ( <int> ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; for ( long ii = <int> ; ii < <int> ; ii + + ) add ( ii * <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( output . size ( ) , <int> ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> * <int> ) ; release ( ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; cs = newStrategy ( <str> , <int> ) ; for ( long ii = <int> ; ii < <int> ; ii + + ) add ( ii * <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( output . size ( ) , <int> ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> * <int> ) ; add ( <int> * <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertEquals ( toNanos ( <int> ) , parker . parks . poll ( ) . longValue ( ) ) ; } @Test public void testTimeHorizonStrategy ( ) throws Exception { cs = newStrategy ( <str> , <int> ) ; add ( <int> ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> ) ; release ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertNull ( parker . parks . poll ( ) ) ; clear ( ) ; for ( long ii = <int> ; ii < <int> ; ii + + ) add ( ii * <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( output . size ( ) , <int> ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> * <int> ) ; release ( ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; cs = newStrategy ( <str> , <int> ) ; primeTimeHorizonAverage ( <int> ) ; clear ( ) ; runBlocker ( queueParked ) ; add ( <int> * <int> ) ; queueRelease . release ( ) ; parker . parked . acquire ( ) ; add ( <int> * <int> ) ; parker . permits . release ( ) ; fut . get ( ) ; assertEquals ( <int> , output . size ( ) ) ; assertEquals ( toNanos ( <int> ) , parker . parks . poll ( ) . longValue ( ) ) ; clear ( ) ; add ( Integer . MAX_VALUE ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; clear ( ) ; add ( <int> ) ; cs . coalesce ( input , output , <int> ) ; assertEquals ( <int> , output . size ( ) ) ; assertTrue ( parker . parks . isEmpty ( ) ) ; } void primeTimeHorizonAverage ( long micros ) throws Exception { for ( long ii = <int> ; ii < <int> ; ii + + ) { add ( ii * micros ) ; if ( ii % <int> = = <int> ) { cs . coalesce ( input , output , <int> ) ; output . clear ( ) ; } } } } 
