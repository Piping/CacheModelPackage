package com . google . common . cache ; import static com . google . common . cache . CacheTesting . checkEmpty ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static java . util . Arrays . asList ; import static java . util . concurrent . TimeUnit . DAYS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . base . Function ; import com . google . common . cache . CacheBuilderFactory . DurationSpec ; import com . google . common . cache . LocalCache . Strength ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . Map . Entry ; import java . util . Set ; import java . util . concurrent . ExecutionException ; public class EmptyCachesTest extends TestCase { public void testEmpty ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { checkEmpty ( cache ) ; } } public void testInvalidate_empty ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <str> ) ; cache . getUnchecked ( <str> ) ; cache . invalidate ( <str> ) ; cache . invalidate ( <str> ) ; cache . invalidate ( <int> ) ; checkEmpty ( cache ) ; } } public void testInvalidateAll_empty ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <str> ) ; cache . getUnchecked ( <str> ) ; cache . getUnchecked ( <str> ) ; cache . invalidateAll ( ) ; checkEmpty ( cache ) ; } } public void testEquals_null ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { assertFalse ( cache . equals ( null ) ) ; } } public void testEqualsAndHashCode_different ( ) { for ( CacheBuilder < Object , Object > builder : cacheFactory ( ) . buildAllPermutations ( ) ) { new EqualsTester ( ) . addEqualityGroup ( builder . build ( identityLoader ( ) ) ) . addEqualityGroup ( builder . build ( identityLoader ( ) ) ) . addEqualityGroup ( builder . build ( identityLoader ( ) ) ) . testEquals ( ) ; } } public void testGet_null ( ) throws ExecutionException { for ( LoadingCache < Object , Object > cache : caches ( ) ) { try { cache . get ( null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } checkEmpty ( cache ) ; } } public void testGetUnchecked_null ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { try { cache . getUnchecked ( null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } checkEmpty ( cache ) ; } } public void testKeySet_nullToArray ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Object > keys = cache . asMap ( ) . keySet ( ) ; try { keys . toArray ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } checkEmpty ( cache ) ; } } public void testKeySet_addNotSupported ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { try { cache . asMap ( ) . keySet ( ) . add ( <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { cache . asMap ( ) . keySet ( ) . addAll ( asList ( <int> , <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } } public void testKeySet_clear ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { warmUp ( cache , <int> , <int> ) ; Set < Object > keys = cache . asMap ( ) . keySet ( ) ; keys . clear ( ) ; checkEmpty ( keys ) ; checkEmpty ( cache ) ; } } public void testKeySet_empty_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Object > keys = cache . asMap ( ) . keySet ( ) ; assertFalse ( keys . remove ( null ) ) ; assertFalse ( keys . remove ( <int> ) ) ; assertFalse ( keys . remove ( - <int> ) ) ; assertFalse ( keys . removeAll ( asList ( null , <int> , <int> , <int> ) ) ) ; assertFalse ( keys . retainAll ( asList ( null , <int> , <int> , <int> ) ) ) ; checkEmpty ( keys ) ; checkEmpty ( cache ) ; } } public void testKeySet_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <int> ) ; cache . getUnchecked ( <int> ) ; Set < Object > keys = cache . asMap ( ) . keySet ( ) ; keys . remove ( <int> ) ; keys . remove ( <int> ) ; assertFalse ( keys . remove ( null ) ) ; assertFalse ( keys . remove ( <int> ) ) ; assertFalse ( keys . remove ( - <int> ) ) ; assertFalse ( keys . removeAll ( asList ( null , <int> , <int> , <int> ) ) ) ; assertFalse ( keys . retainAll ( asList ( null , <int> , <int> , <int> ) ) ) ; checkEmpty ( keys ) ; checkEmpty ( cache ) ; } } public void testValues_nullToArray ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Collection < Object > values = cache . asMap ( ) . values ( ) ; try { values . toArray ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } checkEmpty ( cache ) ; } } public void testValues_addNotSupported ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { try { cache . asMap ( ) . values ( ) . add ( <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { cache . asMap ( ) . values ( ) . addAll ( asList ( <int> , <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } } public void testValues_clear ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { warmUp ( cache , <int> , <int> ) ; Collection < Object > values = cache . asMap ( ) . values ( ) ; values . clear ( ) ; checkEmpty ( values ) ; checkEmpty ( cache ) ; } } public void testValues_empty_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Collection < Object > values = cache . asMap ( ) . values ( ) ; assertFalse ( values . remove ( null ) ) ; assertFalse ( values . remove ( <int> ) ) ; assertFalse ( values . remove ( - <int> ) ) ; assertFalse ( values . removeAll ( asList ( null , <int> , <int> , <int> ) ) ) ; assertFalse ( values . retainAll ( asList ( null , <int> , <int> , <int> ) ) ) ; checkEmpty ( values ) ; checkEmpty ( cache ) ; } } public void testValues_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <int> ) ; cache . getUnchecked ( <int> ) ; Collection < Object > values = cache . asMap ( ) . keySet ( ) ; values . remove ( <int> ) ; values . remove ( <int> ) ; assertFalse ( values . remove ( null ) ) ; assertFalse ( values . remove ( <int> ) ) ; assertFalse ( values . remove ( - <int> ) ) ; assertFalse ( values . removeAll ( asList ( null , <int> , <int> , <int> ) ) ) ; assertFalse ( values . retainAll ( asList ( null , <int> , <int> , <int> ) ) ) ; checkEmpty ( values ) ; checkEmpty ( cache ) ; } } public void testEntrySet_nullToArray ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Entry < Object , Object > > entries = cache . asMap ( ) . entrySet ( ) ; try { entries . toArray ( null ) ; fail ( ) ; } catch ( NullPointerException e ) { } checkEmpty ( cache ) ; } } public void testEntrySet_addNotSupported ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { try { cache . asMap ( ) . entrySet ( ) . add ( entryOf ( <int> , <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { cache . asMap ( ) . values ( ) . addAll ( asList ( entryOf ( <int> , <int> ) , entryOf ( <int> , <int> ) ) ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } } public void testEntrySet_clear ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { warmUp ( cache , <int> , <int> ) ; Set < Entry < Object , Object > > entrySet = cache . asMap ( ) . entrySet ( ) ; entrySet . clear ( ) ; checkEmpty ( entrySet ) ; checkEmpty ( cache ) ; } } public void testEntrySet_empty_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { Set < Entry < Object , Object > > entrySet = cache . asMap ( ) . entrySet ( ) ; assertFalse ( entrySet . remove ( null ) ) ; assertFalse ( entrySet . remove ( entryOf ( <int> , <int> ) ) ) ; assertFalse ( entrySet . remove ( entryOf ( - <int> , - <int> ) ) ) ; assertFalse ( entrySet . removeAll ( asList ( null , entryOf ( <int> , <int> ) , entryOf ( <int> , <int> ) ) ) ) ; assertFalse ( entrySet . retainAll ( asList ( null , entryOf ( <int> , <int> ) , entryOf ( <int> , <int> ) ) ) ) ; checkEmpty ( entrySet ) ; checkEmpty ( cache ) ; } } public void testEntrySet_remove ( ) { for ( LoadingCache < Object , Object > cache : caches ( ) ) { cache . getUnchecked ( <int> ) ; cache . getUnchecked ( <int> ) ; Set < Entry < Object , Object > > entrySet = cache . asMap ( ) . entrySet ( ) ; entrySet . remove ( entryOf ( <int> , <int> ) ) ; entrySet . remove ( entryOf ( <int> , <int> ) ) ; assertFalse ( entrySet . remove ( null ) ) ; assertFalse ( entrySet . remove ( entryOf ( <int> , <int> ) ) ) ; assertFalse ( entrySet . remove ( entryOf ( <int> , <int> ) ) ) ; assertFalse ( entrySet . removeAll ( asList ( null , entryOf ( <int> , <int> ) , entryOf ( <int> , <int> ) ) ) ) ; assertFalse ( entrySet . retainAll ( asList ( null , entryOf ( <int> , <int> ) , entryOf ( <int> , <int> ) ) ) ) ; checkEmpty ( entrySet ) ; checkEmpty ( cache ) ; } } private Iterable < LoadingCache < Object , Object > > caches ( ) { CacheBuilderFactory factory = cacheFactory ( ) ; return Iterables . transform ( factory . buildAllPermutations ( ) , new Function < CacheBuilder < Object , Object > , LoadingCache < Object , Object > > ( ) { @Override public LoadingCache < Object , Object > apply ( CacheBuilder < Object , Object > builder ) { return builder . build ( identityLoader ( ) ) ; } } ) ; } private CacheBuilderFactory cacheFactory ( ) { return new CacheBuilderFactory ( ) . withKeyStrengths ( ImmutableSet . of ( Strength . STRONG , Strength . WEAK ) ) . withValueStrengths ( ImmutableSet . copyOf ( Strength . values ( ) ) ) . withConcurrencyLevels ( ImmutableSet . of ( <int> , <int> , <int> , <int> ) ) . withMaximumSizes ( ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> ) ) . withInitialCapacities ( ImmutableSet . of ( <int> , <int> , <int> , <int> , <int> ) ) . withExpireAfterWrites ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) . withExpireAfterAccesses ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) . withRefreshes ( ImmutableSet . of ( DurationSpec . of ( <int> , SECONDS ) , DurationSpec . of ( <int> , DAYS ) ) ) ; } private static void warmUp ( LoadingCache < Object , Object > cache , int minimum , int maximum ) { for ( int i = minimum ; i < maximum ; i + + ) { cache . getUnchecked ( i ) ; } } private Entry < Object , Object > entryOf ( Object key , Object value ) { return Maps . immutableEntry ( key , value ) ; } } 
