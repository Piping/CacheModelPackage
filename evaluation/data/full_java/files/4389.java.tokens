package org . eclipse . debug . internal . ui . viewers . model ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IHasChildrenUpdate ; import org . eclipse . jface . viewers . TreePath ; class HasChildrenUpdate extends ViewerUpdateMonitor implements IHasChildrenUpdate { private boolean fHasChildren = false ; private List < ViewerUpdateMonitor > fBatchedRequests = null ; public HasChildrenUpdate ( TreeModelContentProvider provider , Object viewerInput , TreePath elementPath , Object element , IElementContentProvider elementContentProvider ) { super ( provider , viewerInput , elementPath , element , elementContentProvider , provider . getPresentationContext ( ) ) ; } @Override protected void performUpdate ( ) { TreeModelContentProvider contentProvider = getContentProvider ( ) ; TreePath elementPath = getElementPath ( ) ; if ( ! fHasChildren ) { contentProvider . clearFilters ( elementPath ) ; } if ( DebugUIPlugin . DEBUG_CONTENT_PROVIDER & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { } contentProvider . getViewer ( ) . setHasChildren ( elementPath , fHasChildren ) ; if ( fHasChildren ) { contentProvider . getViewer ( ) . autoExpand ( elementPath ) ; } if ( elementPath . getSegmentCount ( ) > <int> ) { getContentProvider ( ) . getStateTracker ( ) . restorePendingStateOnUpdate ( getElementPath ( ) , - <int> , true , false , false ) ; } } @Override public void setHasChilren ( boolean hasChildren ) { fHasChildren = hasChildren ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; buf . append ( getElement ( ) ) ; return buf . toString ( ) ; } @Override boolean coalesce ( ViewerUpdateMonitor request ) { if ( request instanceof HasChildrenUpdate ) { if ( getElementPath ( ) . equals ( request . getElementPath ( ) ) ) { return true ; } else if ( getElementContentProvider ( ) . equals ( request . getElementContentProvider ( ) ) ) { if ( fBatchedRequests = = null ) { fBatchedRequests = new ArrayList < ViewerUpdateMonitor > ( ) ; fBatchedRequests . add ( this ) ; } fBatchedRequests . add ( request ) ; return true ; } } return false ; } @Override void startRequest ( ) { if ( fBatchedRequests = = null ) { getElementContentProvider ( ) . update ( new IHasChildrenUpdate [ ] { this } ) ; } else { IHasChildrenUpdate [ ] updates = fBatchedRequests . toArray ( new IHasChildrenUpdate [ fBatchedRequests . size ( ) ] ) ; for ( int i = <int> ; i < updates . length ; i + + ) { getContentProvider ( ) . updateStarted ( ( ViewerUpdateMonitor ) updates [ i ] ) ; } getElementContentProvider ( ) . update ( updates ) ; } } @Override boolean containsUpdate ( TreePath path ) { if ( getElementPath ( ) . equals ( path ) ) { return true ; } else if ( fBatchedRequests ! = null ) { for ( int i = <int> ; i < fBatchedRequests . size ( ) ; i + + ) { if ( fBatchedRequests . get ( i ) . getElementPath ( ) . equals ( path ) ) { return true ; } } } return false ; } @Override int getPriority ( ) { return <int> ; } @Override TreePath getSchedulingPath ( ) { TreePath path = getElementPath ( ) ; if ( path . getSegmentCount ( ) > <int> ) { return path . getParentPath ( ) ; } return path ; } boolean hasChildren ( ) { return fHasChildren ; } @Override protected boolean doEquals ( ViewerUpdateMonitor update ) { return update instanceof HasChildrenUpdate & & getViewerInput ( ) . equals ( update . getViewerInput ( ) ) & & getElementPath ( ) . equals ( update . getElementPath ( ) ) ; } @Override protected int doHashCode ( ) { return getClass ( ) . hashCode ( ) + getViewerInput ( ) . hashCode ( ) + getElementPath ( ) . hashCode ( ) ; } } 
