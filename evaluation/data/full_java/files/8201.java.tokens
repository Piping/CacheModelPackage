package org . elasticsearch . index . mapper . merge ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . mapper . DocumentFieldMappers ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . Mapping ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class TestMergeMapperTests extends ESSingleNodeTestCase { public void test1Merge ( ) throws Exception { String stage1Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper stage1 = parser . parse ( stage1Mapping ) ; String stage2Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper stage2 = parser . parse ( stage2Mapping ) ; MergeResult mergeResult = stage1 . merge ( stage2 . mapping ( ) , true , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) , nullValue ( ) ) ; assertThat ( stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) , nullValue ( ) ) ; mergeResult = stage1 . merge ( stage2 . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) , notNullValue ( ) ) ; assertThat ( stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) , notNullValue ( ) ) ; } public void testMergeObjectDynamic ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String objectMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = parser . parse ( objectMapping ) ; assertNull ( mapper . root ( ) . dynamic ( ) ) ; String withDynamicMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper withDynamicMapper = parser . parse ( withDynamicMapping ) ; assertThat ( withDynamicMapper . root ( ) . dynamic ( ) , equalTo ( ObjectMapper . Dynamic . FALSE ) ) ; MergeResult mergeResult = mapper . merge ( withDynamicMapper . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( mapper . root ( ) . dynamic ( ) , equalTo ( ObjectMapper . Dynamic . FALSE ) ) ; } public void testMergeObjectAndNested ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String objectMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper objectMapper = parser . parse ( objectMapping ) ; String nestedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper nestedMapper = parser . parse ( nestedMapping ) ; MergeResult mergeResult = objectMapper . merge ( nestedMapper . mapping ( ) , true , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( true ) ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( <int> ) ) ; assertThat ( mergeResult . buildConflicts ( ) [ <int> ] , equalTo ( <str> ) ) ; mergeResult = nestedMapper . merge ( objectMapper . mapping ( ) , true , false ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( <int> ) ) ; assertThat ( mergeResult . buildConflicts ( ) [ <int> ] , equalTo ( <str> ) ) ; } public void testMergeSearchAnalyzer ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String mapping2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper existing = parser . parse ( mapping1 ) ; DocumentMapper changed = parser . parse ( mapping2 ) ; assertThat ( ( ( NamedAnalyzer ) existing . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . searchAnalyzer ( ) ) . name ( ) , equalTo ( <str> ) ) ; MergeResult mergeResult = existing . merge ( changed . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( ( ( NamedAnalyzer ) existing . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . searchAnalyzer ( ) ) . name ( ) , equalTo ( <str> ) ) ; } public void testChangeSearchAnalyzerToDefault ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String mapping2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper existing = parser . parse ( mapping1 ) ; DocumentMapper changed = parser . parse ( mapping2 ) ; assertThat ( ( ( NamedAnalyzer ) existing . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . searchAnalyzer ( ) ) . name ( ) , equalTo ( <str> ) ) ; MergeResult mergeResult = existing . merge ( changed . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( ( ( NamedAnalyzer ) existing . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . searchAnalyzer ( ) ) . name ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( StringFieldMapper ) ( existing . mappers ( ) . getMapper ( <str> ) ) ) . getIgnoreAbove ( ) , equalTo ( <int> ) ) ; } public void testConcurrentMergeTest ( ) throws Throwable { final MapperService mapperService = createIndex ( <str> ) . mapperService ( ) ; mapperService . merge ( <str> , new CompressedXContent ( <str> ) , true , false ) ; final DocumentMapper documentMapper = mapperService . documentMapper ( <str> ) ; DocumentFieldMappers dfm = documentMapper . mappers ( ) ; try { assertNotNull ( dfm . indexAnalyzer ( ) . tokenStream ( <str> , <str> ) ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } final AtomicBoolean stopped = new AtomicBoolean ( false ) ; final CyclicBarrier barrier = new CyclicBarrier ( <int> ) ; final AtomicReference < String > lastIntroducedFieldName = new AtomicReference < > ( ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; final Thread updater = new Thread ( ) { @Override public void run ( ) { try { barrier . await ( ) ; for ( int i = <int> ; i < <int> & & stopped . get ( ) = = false ; i + + ) { final String fieldName = Integer . toString ( i ) ; ParsedDocument doc = documentMapper . parse ( <str> , <str> , fieldName , new BytesArray ( <str> + fieldName + <str> ) ) ; Mapping update = doc . dynamicMappingsUpdate ( ) ; assert update ! = null ; lastIntroducedFieldName . set ( fieldName ) ; mapperService . merge ( <str> , new CompressedXContent ( update . toString ( ) ) , false , false ) ; } } catch ( Throwable t ) { error . set ( t ) ; } finally { stopped . set ( true ) ; } } } ; updater . start ( ) ; try { barrier . await ( ) ; while ( stopped . get ( ) = = false ) { final String fieldName = lastIntroducedFieldName . get ( ) ; final BytesReference source = new BytesArray ( <str> + fieldName + <str> ) ; ParsedDocument parsedDoc = documentMapper . parse ( <str> , <str> , <str> , source ) ; if ( parsedDoc . dynamicMappingsUpdate ( ) ! = null ) { continue ; } dfm = documentMapper . mappers ( ) ; assertNotNull ( dfm . indexAnalyzer ( ) . tokenStream ( fieldName , <str> ) ) ; } } finally { stopped . set ( true ) ; updater . join ( ) ; } if ( error . get ( ) ! = null ) { throw error . get ( ) ; } } } 
