package org . elasticsearch . index . mapper . core ; import org . apache . lucene . analysis . * ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import static org . hamcrest . Matchers . equalTo ; public class TokenCountFieldMapperTests extends ESSingleNodeTestCase { public void testMerge ( ) throws IOException { String stage1Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper stage1 = parser . parse ( stage1Mapping ) ; String stage2Mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper stage2 = parser . parse ( stage2Mapping ) ; MergeResult mergeResult = stage1 . merge ( stage2 . mapping ( ) , true , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( ( ( TokenCountFieldMapper ) stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) ) . analyzer ( ) , equalTo ( <str> ) ) ; mergeResult = stage1 . merge ( stage2 . mapping ( ) , false , false ) ; assertThat ( mergeResult . hasConflicts ( ) , equalTo ( false ) ) ; assertThat ( ( ( TokenCountFieldMapper ) stage1 . mappers ( ) . smartNameFieldMapper ( <str> ) ) . analyzer ( ) , equalTo ( <str> ) ) ; } public void testCountPositions ( ) throws IOException { Token t1 = new Token ( ) ; t1 . setPositionIncrement ( <int> ) ; Token t2 = new Token ( ) ; t2 . setPositionIncrement ( <int> ) ; Token t3 = new Token ( ) ; t2 . setPositionIncrement ( <int> ) ; int finalTokenIncrement = <int> ; Token [ ] tokens = new Token [ ] { t1 , t2 , t3 } ; Collections . shuffle ( Arrays . asList ( tokens ) , random ( ) ) ; final TokenStream tokenStream = new CannedTokenStream ( finalTokenIncrement , <int> , tokens ) ; Analyzer analyzer = new Analyzer ( ) { @Override public TokenStreamComponents createComponents ( String fieldName ) { return new TokenStreamComponents ( new MockTokenizer ( ) , tokenStream ) ; } } ; assertThat ( TokenCountFieldMapper . countPositions ( analyzer , <str> , <str> ) , equalTo ( <int> ) ) ; } } 
