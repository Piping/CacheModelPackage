package org . eclipse . debug . internal . ui . viewers . model . provisional ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . TreeMap ; import org . eclipse . core . runtime . Assert ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; public class VirtualItem { public static String LABEL_KEY = <str> ; public static String IMAGE_KEY = <str> ; public static String FONT_KEY = <str> ; public static String FOREGROUND_KEY = <str> ; public static String BACKGROUND_KEY = <str> ; public static String ELEMENT_DATA_KEY = <str> ; public static class Index implements Comparable < Object > { private Integer fIndexValue ; public Index ( int index ) { fIndexValue = Integer . valueOf ( index ) ; } @Override public boolean equals ( Object obj ) { return obj instanceof Index & & ( ( Index ) obj ) . fIndexValue . equals ( fIndexValue ) ; } @Override public int hashCode ( ) { return fIndexValue . hashCode ( ) ; } public void increment ( ) { fIndexValue = Integer . valueOf ( fIndexValue . intValue ( ) + <int> ) ; } public void decrement ( ) { fIndexValue = Integer . valueOf ( fIndexValue . intValue ( ) - <int> ) ; } public int intValue ( ) { return fIndexValue . intValue ( ) ; } @Override public int compareTo ( Object obj ) { return obj instanceof Index ? fIndexValue . compareTo ( ( ( Index ) obj ) . fIndexValue ) : <int> ; } @Override public String toString ( ) { return fIndexValue . toString ( ) ; } } final private VirtualItem fParent ; final private Index fIndex ; private Map < Index , VirtualItem > fItems = new TreeMap < Index , VirtualItem > ( ) ; private boolean fHasItems = false ; private boolean fExpanded = false ; private int fItemCount = - <int> ; private Map < String , Object > fData = new HashMap < String , Object > ( <int> ) ; private boolean fNeedsLabelUpdate = true ; private boolean fNeedsCountUpdate = true ; private boolean fNeedsDataUpdate = true ; private boolean fDisposed = false ; public VirtualItem ( VirtualItem parent , Index index ) { fParent = parent ; fIndex = index ; } public void clear ( Index index ) { VirtualItem item = fItems . remove ( index ) ; if ( item ! = null ) { item . dispose ( ) ; } } public void clearAll ( ) { fData . clear ( ) ; for ( VirtualItem item : fItems . values ( ) ) { item . dispose ( ) ; } fItems . clear ( ) ; } public VirtualItem getParent ( ) { return fParent ; } public Index getIndex ( ) { return fIndex ; } public VirtualItem findItem ( Object element ) { for ( VirtualItem item : fItems . values ( ) ) { Object nextData = item . getData ( ) ; if ( ( element ! = null & & element . equals ( nextData ) ) | | ( element = = null & & nextData = = null ) ) { return item ; } } return null ; } public boolean needsDataUpdate ( ) { return fNeedsDataUpdate ; } public void setNeedsDataUpdate ( ) { fNeedsDataUpdate = true ; } public void clearNeedsDataUpdate ( ) { fNeedsDataUpdate = false ; } public boolean needsCountUpdate ( ) { return fNeedsCountUpdate ; } public void setNeedsCountUpdate ( ) { fNeedsCountUpdate = true ; fItemCount = - <int> ; } public void clearNeedsCountUpdate ( ) { fNeedsCountUpdate = false ; } public boolean needsLabelUpdate ( ) { return fNeedsLabelUpdate ; } public void setNeedsLabelUpdate ( ) { fNeedsLabelUpdate = true ; } public void clearNeedsLabelUpdate ( ) { fNeedsLabelUpdate = false ; } public boolean isDisposed ( ) { return fDisposed ; } public void dispose ( ) { clearAll ( ) ; fDisposed = true ; findTree ( ) . fireItemDisposed ( this ) ; } public Object getData ( String key ) { return fData . get ( key ) ; } public void setData ( String key , Object data ) { fData . put ( key , data ) ; } public void setData ( Object data ) { fData . put ( ELEMENT_DATA_KEY , data ) ; } public Object getData ( ) { return fData . get ( ELEMENT_DATA_KEY ) ; } public void setExpanded ( boolean expanded ) { if ( fExpanded = = expanded ) { return ; } fExpanded = expanded ; if ( fExpanded & & getItemCount ( ) = = - <int> ) { setNeedsCountUpdate ( ) ; } Assert . isTrue ( ! fExpanded | | hasItems ( ) ) ; if ( ! fExpanded ) { for ( VirtualItem item : fItems . values ( ) ) { item . setExpanded ( expanded ) ; } } } public boolean getExpanded ( ) { return fExpanded ; } public void setHasItems ( boolean hasChildren ) { fHasItems = hasChildren ; if ( ! fHasItems ) { if ( getItemCount ( ) ! = <int> ) { setItemCount ( <int> ) ; } } else if ( getItemCount ( ) = = <int> ) { setItemCount ( - <int> ) ; } } public boolean hasItems ( ) { return fHasItems ; } public void setItemCount ( int count ) { fItemCount = count ; for ( Iterator < Entry < Index , VirtualItem > > itr = fItems . entrySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Entry < Index , VirtualItem > entry = itr . next ( ) ; int index = entry . getKey ( ) . intValue ( ) ; if ( index > = count ) { VirtualItem item = entry . getValue ( ) ; item . dispose ( ) ; itr . remove ( ) ; } } if ( fItemCount = = <int> ) { if ( hasItems ( ) ) { setHasItems ( false ) ; } if ( getExpanded ( ) ) { setExpanded ( false ) ; } } else { if ( ! hasItems ( ) ) { setHasItems ( true ) ; } } } public int getItemCount ( ) { return fItemCount ; } public VirtualItem getItem ( Index index ) { ensureItems ( ) ; VirtualItem item = fItems . get ( index ) ; if ( item = = null ) { item = new VirtualItem ( this , index ) ; fItems . put ( index , item ) ; } return item ; } public boolean childrenNeedDataUpdate ( ) { if ( getItemCount ( ) = = <int> ) { return false ; } if ( fItems = = null | | fItems . size ( ) ! = fItemCount ) { return true ; } for ( VirtualItem child : fItems . values ( ) ) { if ( child . needsDataUpdate ( ) ) { return true ; } } return false ; } public VirtualItem [ ] getItems ( ) { return fItems . values ( ) . toArray ( new VirtualItem [ fItems . size ( ) ] ) ; } public VirtualItem addItem ( int position ) { if ( ! fHasItems ) { fHasItems = true ; } if ( fItemCount < <int> ) { fItemCount = <int> ; } fItemCount + + ; ensureItems ( ) ; for ( Index childIndex : fItems . keySet ( ) ) { if ( childIndex . intValue ( ) > = position ) { childIndex . increment ( ) ; } } Index childIndex = new Index ( position ) ; VirtualItem newChild = new VirtualItem ( this , childIndex ) ; fItems . put ( childIndex , newChild ) ; return newChild ; } public void remove ( Index position ) { fItemCount - - ; if ( fItemCount < <int> ) { fHasItems = false ; } ensureItems ( ) ; VirtualItem removedItem = null ; for ( Iterator < Entry < Index , VirtualItem > > itr = fItems . entrySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Entry < Index , VirtualItem > entry = itr . next ( ) ; Index childIndex = entry . getKey ( ) ; if ( childIndex . intValue ( ) > position . intValue ( ) ) { childIndex . decrement ( ) ; } else if ( childIndex . intValue ( ) = = position . intValue ( ) ) { removedItem = entry . getValue ( ) ; removedItem . dispose ( ) ; itr . remove ( ) ; } } } private void ensureItems ( ) { if ( fItems = = null ) { fItems = new HashMap < Index , VirtualItem > ( Math . max ( <int> , Math . min ( fItemCount , <int> ) ) ) ; } } private VirtualTree findTree ( ) { VirtualItem item = this ; while ( ! ( item instanceof VirtualTree ) ) { item = item . fParent ; } return ( VirtualTree ) item ; } @Override public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; toStringItem ( buffer , IInternalDebugCoreConstants . EMPTY_STRING ) ; return buffer . toString ( ) ; } void toStringItem ( StringBuffer buffer , String indent ) { buffer . append ( indent ) ; buffer . append ( toStringElement ( ) ) ; buffer . append ( <str> ) ; indent = indent + <str> ; for ( int i = <int> ; i < fItemCount ; i + + ) { VirtualItem item = fItems . get ( new Index ( i ) ) ; if ( item ! = null ) { item . toStringItem ( buffer , indent ) ; } else { buffer . append ( <str> ) ; } } } private String toStringElement ( ) { String [ ] label = ( String [ ] ) fData . get ( LABEL_KEY ) ; if ( label ! = null & & label . length ! = <int> ) { return label [ <int> ] ; } Object data = fData . get ( ELEMENT_DATA_KEY ) ; if ( data ! = null ) { return data . toString ( ) ; } return <str> ; } } 
