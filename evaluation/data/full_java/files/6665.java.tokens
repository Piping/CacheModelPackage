package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; public class SimpleQueryStringParser implements QueryParser < SimpleQueryStringBuilder > { public static final ParseField MINIMUM_SHOULD_MATCH_FIELD = new ParseField ( <str> ) ; public static final ParseField ANALYZE_WILDCARD_FIELD = new ParseField ( <str> ) ; public static final ParseField LENIENT_FIELD = new ParseField ( <str> ) ; public static final ParseField LOWERCASE_EXPANDED_TERMS_FIELD = new ParseField ( <str> ) ; public static final ParseField LOCALE_FIELD = new ParseField ( <str> ) ; public static final ParseField FLAGS_FIELD = new ParseField ( <str> ) ; public static final ParseField DEFAULT_OPERATOR_FIELD = new ParseField ( <str> ) ; public static final ParseField ANALYZER_FIELD = new ParseField ( <str> ) ; public static final ParseField QUERY_FIELD = new ParseField ( <str> ) ; public static final ParseField FIELDS_FIELD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { SimpleQueryStringBuilder . NAME , Strings . toCamelCase ( SimpleQueryStringBuilder . NAME ) } ; } @Override public SimpleQueryStringBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; String currentFieldName = null ; String queryBody = null ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; String queryName = null ; String minimumShouldMatch = null ; Map < String , Float > fieldsAndWeights = new HashMap < > ( ) ; Operator defaultOperator = null ; String analyzerName = null ; int flags = SimpleQueryStringFlag . ALL . value ( ) ; boolean lenient = SimpleQueryStringBuilder . DEFAULT_LENIENT ; boolean lowercaseExpandedTerms = SimpleQueryStringBuilder . DEFAULT_LOWERCASE_EXPANDED_TERMS ; boolean analyzeWildcard = SimpleQueryStringBuilder . DEFAULT_ANALYZE_WILDCARD ; Locale locale = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , FIELDS_FIELD ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String fField = null ; float fBoost = <int> ; char [ ] text = parser . textCharacters ( ) ; int end = parser . textOffset ( ) + parser . textLength ( ) ; for ( int i = parser . textOffset ( ) ; i < end ; i + + ) { if ( text [ i ] = = <str> ) { int relativeLocation = i - parser . textOffset ( ) ; fField = new String ( text , parser . textOffset ( ) , relativeLocation ) ; fBoost = Float . parseFloat ( new String ( text , i + <int> , parser . textLength ( ) - relativeLocation - <int> ) ) ; break ; } } if ( fField = = null ) { fField = parser . text ( ) ; } fieldsAndWeights . put ( fField , fBoost ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + SimpleQueryStringBuilder . NAME + <str> + currentFieldName + <str> ) ; } } else if ( token . isValue ( ) ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , QUERY_FIELD ) ) { queryBody = parser . text ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . BOOST_FIELD ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , ANALYZER_FIELD ) ) { analyzerName = parser . text ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , DEFAULT_OPERATOR_FIELD ) ) { defaultOperator = Operator . fromString ( parser . text ( ) ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , FLAGS_FIELD ) ) { if ( parser . currentToken ( ) ! = XContentParser . Token . VALUE_NUMBER ) { flags = SimpleQueryStringFlag . resolveFlags ( parser . text ( ) ) ; } else { flags = parser . intValue ( ) ; if ( flags < <int> ) { flags = SimpleQueryStringFlag . ALL . value ( ) ; } } } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , LOCALE_FIELD ) ) { String localeStr = parser . text ( ) ; locale = Locale . forLanguageTag ( localeStr ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , LOWERCASE_EXPANDED_TERMS_FIELD ) ) { lowercaseExpandedTerms = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , LENIENT_FIELD ) ) { lenient = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , ANALYZE_WILDCARD_FIELD ) ) { analyzeWildcard = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . NAME_FIELD ) ) { queryName = parser . text ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , MINIMUM_SHOULD_MATCH_FIELD ) ) { minimumShouldMatch = parser . textOrNull ( ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + SimpleQueryStringBuilder . NAME + <str> + parser . currentName ( ) + <str> ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + SimpleQueryStringBuilder . NAME + <str> + token + <str> + currentFieldName + <str> ) ; } } if ( queryBody = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + SimpleQueryStringBuilder . NAME + <str> ) ; } SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( queryBody ) ; qb . boost ( boost ) . fields ( fieldsAndWeights ) . analyzer ( analyzerName ) . queryName ( queryName ) . minimumShouldMatch ( minimumShouldMatch ) ; qb . flags ( flags ) . defaultOperator ( defaultOperator ) . locale ( locale ) . lowercaseExpandedTerms ( lowercaseExpandedTerms ) ; qb . lenient ( lenient ) . analyzeWildcard ( analyzeWildcard ) . boost ( boost ) ; return qb ; } @Override public SimpleQueryStringBuilder getBuilderPrototype ( ) { return SimpleQueryStringBuilder . PROTOTYPE ; } } 
