package org . elasticsearch . common . util ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . RamUsageEstimator ; import java . util . Arrays ; import static org . elasticsearch . common . util . BigArrays . BYTE_PAGE_SIZE ; final class BigByteArray extends AbstractBigArray implements ByteArray { private byte [ ] [ ] pages ; public BigByteArray ( long size , BigArrays bigArrays , boolean clearOnResize ) { super ( BYTE_PAGE_SIZE , bigArrays , clearOnResize ) ; this . size = size ; pages = new byte [ numPages ( size ) ] [ ] ; for ( int i = <int> ; i < pages . length ; + + i ) { pages [ i ] = newBytePage ( i ) ; } } @Override public byte get ( long index ) { final int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; return pages [ pageIndex ] [ indexInPage ] ; } @Override public byte set ( long index , byte value ) { final int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; final byte [ ] page = pages [ pageIndex ] ; final byte ret = page [ indexInPage ] ; page [ indexInPage ] = value ; return ret ; } @Override public boolean get ( long index , int len , BytesRef ref ) { assert index + len < = size ( ) ; int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; if ( indexInPage + len < = pageSize ( ) ) { ref . bytes = pages [ pageIndex ] ; ref . offset = indexInPage ; ref . length = len ; return false ; } else { ref . bytes = new byte [ len ] ; ref . offset = <int> ; ref . length = pageSize ( ) - indexInPage ; System . arraycopy ( pages [ pageIndex ] , indexInPage , ref . bytes , <int> , ref . length ) ; do { + + pageIndex ; final int copyLength = Math . min ( pageSize ( ) , len - ref . length ) ; System . arraycopy ( pages [ pageIndex ] , <int> , ref . bytes , ref . length , copyLength ) ; ref . length + = copyLength ; } while ( ref . length < len ) ; return true ; } } @Override public void set ( long index , byte [ ] buf , int offset , int len ) { assert index + len < = size ( ) ; int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; if ( indexInPage + len < = pageSize ( ) ) { System . arraycopy ( buf , offset , pages [ pageIndex ] , indexInPage , len ) ; } else { int copyLen = pageSize ( ) - indexInPage ; System . arraycopy ( buf , offset , pages [ pageIndex ] , indexInPage , copyLen ) ; do { + + pageIndex ; offset + = copyLen ; len - = copyLen ; copyLen = Math . min ( len , pageSize ( ) ) ; System . arraycopy ( buf , offset , pages [ pageIndex ] , <int> , copyLen ) ; } while ( len > copyLen ) ; } } @Override public void fill ( long fromIndex , long toIndex , byte value ) { if ( fromIndex > toIndex ) { throw new IllegalArgumentException ( ) ; } final int fromPage = pageIndex ( fromIndex ) ; final int toPage = pageIndex ( toIndex - <int> ) ; if ( fromPage = = toPage ) { Arrays . fill ( pages [ fromPage ] , indexInPage ( fromIndex ) , indexInPage ( toIndex - <int> ) + <int> , value ) ; } else { Arrays . fill ( pages [ fromPage ] , indexInPage ( fromIndex ) , pages [ fromPage ] . length , value ) ; for ( int i = fromPage + <int> ; i < toPage ; + + i ) { Arrays . fill ( pages [ i ] , value ) ; } Arrays . fill ( pages [ toPage ] , <int> , indexInPage ( toIndex - <int> ) + <int> , value ) ; } } @Override protected int numBytesPerElement ( ) { return RamUsageEstimator . NUM_BYTES_BYTE ; } @Override public void resize ( long newSize ) { final int numPages = numPages ( newSize ) ; if ( numPages > pages . length ) { pages = Arrays . copyOf ( pages , ArrayUtil . oversize ( numPages , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) ; } for ( int i = numPages - <int> ; i > = <int> & & pages [ i ] = = null ; - - i ) { pages [ i ] = newBytePage ( i ) ; } for ( int i = numPages ; i < pages . length & & pages [ i ] ! = null ; + + i ) { pages [ i ] = null ; releasePage ( i ) ; } this . size = newSize ; } } 
