package org . elasticsearch . snapshots ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . search . ShardSearchFailure ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . SnapshotsInProgress ; import org . elasticsearch . cluster . SnapshotsInProgress . ShardSnapshotStatus ; import org . elasticsearch . cluster . SnapshotsInProgress . State ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . RepositoriesMetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . snapshots . IndexShardSnapshotStatus ; import org . elasticsearch . repositories . RepositoriesService ; import org . elasticsearch . repositories . Repository ; import org . elasticsearch . repositories . RepositoryMissingException ; import org . elasticsearch . search . SearchShardTarget ; import org . elasticsearch . threadpool . ThreadPool ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . cluster . SnapshotsInProgress . completed ; public class SnapshotsService extends AbstractLifecycleComponent < SnapshotsService > implements ClusterStateListener { private final ClusterService clusterService ; private final IndexNameExpressionResolver indexNameExpressionResolver ; private final RepositoriesService repositoriesService ; private final ThreadPool threadPool ; private final CopyOnWriteArrayList < SnapshotCompletionListener > snapshotCompletionListeners = new CopyOnWriteArrayList < > ( ) ; @Inject public SnapshotsService ( Settings settings , ClusterService clusterService , IndexNameExpressionResolver indexNameExpressionResolver , RepositoriesService repositoriesService , ThreadPool threadPool ) { super ( settings ) ; this . clusterService = clusterService ; this . indexNameExpressionResolver = indexNameExpressionResolver ; this . repositoriesService = repositoriesService ; this . threadPool = threadPool ; if ( DiscoveryNode . masterNode ( settings ) ) { clusterService . addLast ( this ) ; } } public Snapshot snapshot ( SnapshotId snapshotId ) { validate ( snapshotId ) ; List < SnapshotsInProgress . Entry > entries = currentSnapshots ( snapshotId . getRepository ( ) , new String [ ] { snapshotId . getSnapshot ( ) } ) ; if ( ! entries . isEmpty ( ) ) { return inProgressSnapshot ( entries . iterator ( ) . next ( ) ) ; } return repositoriesService . repository ( snapshotId . getRepository ( ) ) . readSnapshot ( snapshotId ) ; } public List < Snapshot > snapshots ( String repositoryName , boolean ignoreUnavailable ) { Set < Snapshot > snapshotSet = new HashSet < > ( ) ; List < SnapshotsInProgress . Entry > entries = currentSnapshots ( repositoryName , null ) ; for ( SnapshotsInProgress . Entry entry : entries ) { snapshotSet . add ( inProgressSnapshot ( entry ) ) ; } Repository repository = repositoriesService . repository ( repositoryName ) ; List < SnapshotId > snapshotIds = repository . snapshots ( ) ; for ( SnapshotId snapshotId : snapshotIds ) { try { snapshotSet . add ( repository . readSnapshot ( snapshotId ) ) ; } catch ( Exception ex ) { if ( ignoreUnavailable ) { logger . warn ( <str> , ex , snapshotId ) ; } else { throw new SnapshotException ( snapshotId , <str> , ex ) ; } } } ArrayList < Snapshot > snapshotList = new ArrayList < > ( snapshotSet ) ; CollectionUtil . timSort ( snapshotList ) ; return Collections . unmodifiableList ( snapshotList ) ; } public List < Snapshot > currentSnapshots ( String repositoryName ) { List < Snapshot > snapshotList = new ArrayList < > ( ) ; List < SnapshotsInProgress . Entry > entries = currentSnapshots ( repositoryName , null ) ; for ( SnapshotsInProgress . Entry entry : entries ) { snapshotList . add ( inProgressSnapshot ( entry ) ) ; } CollectionUtil . timSort ( snapshotList ) ; return Collections . unmodifiableList ( snapshotList ) ; } public void createSnapshot ( final SnapshotRequest request , final CreateSnapshotListener listener ) { final SnapshotId snapshotId = new SnapshotId ( request . repository ( ) , request . name ( ) ) ; validate ( snapshotId ) ; clusterService . submitStateUpdateTask ( request . cause ( ) , new ClusterStateUpdateTask ( ) { private SnapshotsInProgress . Entry newSnapshot = null ; @Override public ClusterState execute ( ClusterState currentState ) { validate ( request , currentState ) ; SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots = = null | | snapshots . entries ( ) . isEmpty ( ) ) { List < String > indices = Arrays . asList ( indexNameExpressionResolver . concreteIndices ( currentState , request . indicesOptions ( ) , request . indices ( ) ) ) ; logger . trace ( <str> , request . repository ( ) , request . name ( ) , indices ) ; newSnapshot = new SnapshotsInProgress . Entry ( snapshotId , request . includeGlobalState ( ) , State . INIT , indices , System . currentTimeMillis ( ) , null ) ; snapshots = new SnapshotsInProgress ( newSnapshot ) ; } else { throw new ConcurrentSnapshotExecutionException ( snapshotId , <str> ) ; } return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , request . repository ( ) , request . name ( ) ) ; newSnapshot = null ; listener . onFailure ( t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , final ClusterState newState ) { if ( newSnapshot ! = null ) { threadPool . executor ( ThreadPool . Names . SNAPSHOT ) . execute ( new Runnable ( ) { @Override public void run ( ) { beginSnapshot ( newState , newSnapshot , request . partial , listener ) ; } } ) ; } } @Override public TimeValue timeout ( ) { return request . masterNodeTimeout ( ) ; } } ) ; } private void validate ( SnapshotRequest request , ClusterState state ) { RepositoriesMetaData repositoriesMetaData = state . getMetaData ( ) . custom ( RepositoriesMetaData . TYPE ) ; if ( repositoriesMetaData = = null | | repositoriesMetaData . repository ( request . repository ( ) ) = = null ) { throw new RepositoryMissingException ( request . repository ( ) ) ; } validate ( new SnapshotId ( request . repository ( ) , request . name ( ) ) ) ; } private static void validate ( SnapshotId snapshotId ) { String name = snapshotId . getSnapshot ( ) ; if ( ! Strings . hasLength ( name ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( name . contains ( <str> ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( name . contains ( <str> ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( name . contains ( <str> ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( name . charAt ( <int> ) = = <str> ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( ! name . toLowerCase ( Locale . ROOT ) . equals ( name ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> ) ; } if ( ! Strings . validFileName ( name ) ) { throw new InvalidSnapshotNameException ( snapshotId , <str> + Strings . INVALID_FILENAME_CHARS ) ; } } private void beginSnapshot ( ClusterState clusterState , final SnapshotsInProgress . Entry snapshot , final boolean partial , final CreateSnapshotListener userCreateSnapshotListener ) { boolean snapshotCreated = false ; try { Repository repository = repositoriesService . repository ( snapshot . snapshotId ( ) . getRepository ( ) ) ; MetaData metaData = clusterState . metaData ( ) ; if ( ! snapshot . includeGlobalState ( ) ) { MetaData . Builder builder = MetaData . builder ( ) ; for ( String index : snapshot . indices ( ) ) { builder . put ( metaData . index ( index ) , false ) ; } metaData = builder . build ( ) ; } repository . initializeSnapshot ( snapshot . snapshotId ( ) , snapshot . indices ( ) , metaData ) ; snapshotCreated = true ; if ( snapshot . indices ( ) . isEmpty ( ) ) { userCreateSnapshotListener . onResponse ( ) ; endSnapshot ( snapshot ) ; return ; } clusterService . submitStateUpdateTask ( <str> + snapshot . snapshotId ( ) . getSnapshot ( ) + <str> , new ClusterStateUpdateTask ( ) { boolean accepted = false ; SnapshotsInProgress . Entry updatedSnapshot ; String failure = null ; @Override public ClusterState execute ( ClusterState currentState ) { SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; List < SnapshotsInProgress . Entry > entries = new ArrayList < > ( ) ; for ( SnapshotsInProgress . Entry entry : snapshots . entries ( ) ) { if ( entry . snapshotId ( ) . equals ( snapshot . snapshotId ( ) ) ) { ImmutableOpenMap < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shards = shards ( currentState , entry . indices ( ) ) ; if ( ! partial ) { Tuple < Set < String > , Set < String > > indicesWithMissingShards = indicesWithMissingShards ( shards , currentState . metaData ( ) ) ; Set < String > missing = indicesWithMissingShards . v1 ( ) ; Set < String > closed = indicesWithMissingShards . v2 ( ) ; if ( missing . isEmpty ( ) = = false | | closed . isEmpty ( ) = = false ) { StringBuilder failureMessage = new StringBuilder ( ) ; updatedSnapshot = new SnapshotsInProgress . Entry ( entry , State . FAILED , shards ) ; entries . add ( updatedSnapshot ) ; if ( missing . isEmpty ( ) = = false ) { failureMessage . append ( <str> ) ; failureMessage . append ( missing ) ; } if ( closed . isEmpty ( ) = = false ) { if ( failureMessage . length ( ) > <int> ) { failureMessage . append ( <str> ) ; } failureMessage . append ( <str> ) ; failureMessage . append ( closed ) ; } failure = failureMessage . toString ( ) ; continue ; } } updatedSnapshot = new SnapshotsInProgress . Entry ( entry , State . STARTED , shards ) ; entries . add ( updatedSnapshot ) ; if ( ! completed ( shards . values ( ) ) ) { accepted = true ; } } else { entries . add ( entry ) ; } } return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , new SnapshotsInProgress ( Collections . unmodifiableList ( entries ) ) ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , snapshot . snapshotId ( ) ) ; removeSnapshotFromClusterState ( snapshot . snapshotId ( ) , null , t ) ; try { repositoriesService . repository ( snapshot . snapshotId ( ) . getRepository ( ) ) . finalizeSnapshot ( snapshot . snapshotId ( ) , snapshot . indices ( ) , snapshot . startTime ( ) , ExceptionsHelper . detailedMessage ( t ) , <int> , Collections . < SnapshotShardFailure > emptyList ( ) ) ; } catch ( Throwable t2 ) { logger . warn ( <str> , snapshot . snapshotId ( ) ) ; } userCreateSnapshotListener . onFailure ( t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { userCreateSnapshotListener . onResponse ( ) ; if ( ! accepted & & updatedSnapshot ! = null ) { endSnapshot ( updatedSnapshot , failure ) ; } } } ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , snapshot . snapshotId ( ) ) ; removeSnapshotFromClusterState ( snapshot . snapshotId ( ) , null , t ) ; if ( snapshotCreated ) { try { repositoriesService . repository ( snapshot . snapshotId ( ) . getRepository ( ) ) . finalizeSnapshot ( snapshot . snapshotId ( ) , snapshot . indices ( ) , snapshot . startTime ( ) , ExceptionsHelper . detailedMessage ( t ) , <int> , Collections . < SnapshotShardFailure > emptyList ( ) ) ; } catch ( Throwable t2 ) { logger . warn ( <str> , snapshot . snapshotId ( ) ) ; } } userCreateSnapshotListener . onFailure ( t ) ; } } private Snapshot inProgressSnapshot ( SnapshotsInProgress . Entry entry ) { return new Snapshot ( entry . snapshotId ( ) . getSnapshot ( ) , entry . indices ( ) , entry . startTime ( ) ) ; } public List < SnapshotsInProgress . Entry > currentSnapshots ( String repository , String [ ] snapshots ) { SnapshotsInProgress snapshotsInProgress = clusterService . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshotsInProgress = = null | | snapshotsInProgress . entries ( ) . isEmpty ( ) ) { return Collections . emptyList ( ) ; } if ( <str> . equals ( repository ) ) { return snapshotsInProgress . entries ( ) ; } if ( snapshotsInProgress . entries ( ) . size ( ) = = <int> ) { SnapshotsInProgress . Entry entry = snapshotsInProgress . entries ( ) . get ( <int> ) ; if ( ! entry . snapshotId ( ) . getRepository ( ) . equals ( repository ) ) { return Collections . emptyList ( ) ; } if ( snapshots ! = null & & snapshots . length > <int> ) { for ( String snapshot : snapshots ) { if ( entry . snapshotId ( ) . getSnapshot ( ) . equals ( snapshot ) ) { return snapshotsInProgress . entries ( ) ; } } return Collections . emptyList ( ) ; } else { return snapshotsInProgress . entries ( ) ; } } List < SnapshotsInProgress . Entry > builder = new ArrayList < > ( ) ; for ( SnapshotsInProgress . Entry entry : snapshotsInProgress . entries ( ) ) { if ( ! entry . snapshotId ( ) . getRepository ( ) . equals ( repository ) ) { continue ; } if ( snapshots ! = null & & snapshots . length > <int> ) { for ( String snapshot : snapshots ) { if ( entry . snapshotId ( ) . getSnapshot ( ) . equals ( snapshot ) ) { builder . add ( entry ) ; break ; } } } else { builder . add ( entry ) ; } } return Collections . unmodifiableList ( builder ) ; } public Map < ShardId , IndexShardSnapshotStatus > snapshotShards ( SnapshotId snapshotId ) throws IOException { validate ( snapshotId ) ; Map < ShardId , IndexShardSnapshotStatus > shardStatus = new HashMap < > ( ) ; Repository repository = repositoriesService . repository ( snapshotId . getRepository ( ) ) ; IndexShardRepository indexShardRepository = repositoriesService . indexShardRepository ( snapshotId . getRepository ( ) ) ; Snapshot snapshot = repository . readSnapshot ( snapshotId ) ; MetaData metaData = repository . readSnapshotMetaData ( snapshotId , snapshot , snapshot . indices ( ) ) ; for ( String index : snapshot . indices ( ) ) { IndexMetaData indexMetaData = metaData . indices ( ) . get ( index ) ; if ( indexMetaData ! = null ) { int numberOfShards = indexMetaData . getNumberOfShards ( ) ; for ( int i = <int> ; i < numberOfShards ; i + + ) { ShardId shardId = new ShardId ( index , i ) ; SnapshotShardFailure shardFailure = findShardFailure ( snapshot . shardFailures ( ) , shardId ) ; if ( shardFailure ! = null ) { IndexShardSnapshotStatus shardSnapshotStatus = new IndexShardSnapshotStatus ( ) ; shardSnapshotStatus . updateStage ( IndexShardSnapshotStatus . Stage . FAILURE ) ; shardSnapshotStatus . failure ( shardFailure . reason ( ) ) ; shardStatus . put ( shardId , shardSnapshotStatus ) ; } else { IndexShardSnapshotStatus shardSnapshotStatus = indexShardRepository . snapshotStatus ( snapshotId , snapshot . version ( ) , shardId ) ; shardStatus . put ( shardId , shardSnapshotStatus ) ; } } } } return unmodifiableMap ( shardStatus ) ; } private SnapshotShardFailure findShardFailure ( List < SnapshotShardFailure > shardFailures , ShardId shardId ) { for ( SnapshotShardFailure shardFailure : shardFailures ) { if ( shardId . getIndex ( ) . equals ( shardFailure . index ( ) ) & & shardId . getId ( ) = = shardFailure . shardId ( ) ) { return shardFailure ; } } return null ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { try { if ( event . localNodeMaster ( ) ) { if ( event . nodesRemoved ( ) ) { processSnapshotsOnRemovedNodes ( event ) ; } if ( event . routingTableChanged ( ) ) { processStartedShards ( event ) ; } } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } private void processSnapshotsOnRemovedNodes ( ClusterChangedEvent event ) { if ( removedNodesCleanupNeeded ( event ) ) { final boolean newMaster = ! event . previousState ( ) . nodes ( ) . localNodeMaster ( ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { DiscoveryNodes nodes = currentState . nodes ( ) ; SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots = = null ) { return currentState ; } boolean changed = false ; ArrayList < SnapshotsInProgress . Entry > entries = new ArrayList < > ( ) ; for ( final SnapshotsInProgress . Entry snapshot : snapshots . entries ( ) ) { SnapshotsInProgress . Entry updatedSnapshot = snapshot ; boolean snapshotChanged = false ; if ( snapshot . state ( ) = = State . STARTED | | snapshot . state ( ) = = State . ABORTED ) { ImmutableOpenMap . Builder < ShardId , ShardSnapshotStatus > shards = ImmutableOpenMap . builder ( ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardEntry : snapshot . shards ( ) ) { ShardSnapshotStatus shardStatus = shardEntry . value ; if ( ! shardStatus . state ( ) . completed ( ) & & shardStatus . nodeId ( ) ! = null ) { if ( nodes . nodeExists ( shardStatus . nodeId ( ) ) ) { shards . put ( shardEntry . key , shardEntry . value ) ; } else { snapshotChanged = true ; logger . warn ( <str> , shardEntry . key , shardStatus . nodeId ( ) ) ; shards . put ( shardEntry . key , new ShardSnapshotStatus ( shardStatus . nodeId ( ) , State . FAILED , <str> ) ) ; } } } if ( snapshotChanged ) { changed = true ; ImmutableOpenMap < ShardId , ShardSnapshotStatus > shardsMap = shards . build ( ) ; if ( ! snapshot . state ( ) . completed ( ) & & completed ( shardsMap . values ( ) ) ) { updatedSnapshot = new SnapshotsInProgress . Entry ( snapshot , State . SUCCESS , shardsMap ) ; endSnapshot ( updatedSnapshot ) ; } else { updatedSnapshot = new SnapshotsInProgress . Entry ( snapshot , snapshot . state ( ) , shardsMap ) ; } } entries . add ( updatedSnapshot ) ; } else if ( snapshot . state ( ) = = State . INIT & & newMaster ) { deleteSnapshot ( snapshot . snapshotId ( ) , new DeleteSnapshotListener ( ) { @Override public void onResponse ( ) { logger . debug ( <str> , snapshot . snapshotId ( ) ) ; } @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , snapshot . snapshotId ( ) ) ; } } ) ; } else if ( snapshot . state ( ) = = State . SUCCESS & & newMaster ) { endSnapshot ( snapshot ) ; } } if ( changed ) { snapshots = new SnapshotsInProgress ( entries . toArray ( new SnapshotsInProgress . Entry [ entries . size ( ) ] ) ) ; return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> ) ; } } ) ; } } private void processStartedShards ( ClusterChangedEvent event ) { if ( waitingShardsStartedOrUnassigned ( event ) ) { clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { RoutingTable routingTable = currentState . routingTable ( ) ; SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots ! = null ) { boolean changed = false ; ArrayList < SnapshotsInProgress . Entry > entries = new ArrayList < > ( ) ; for ( final SnapshotsInProgress . Entry snapshot : snapshots . entries ( ) ) { SnapshotsInProgress . Entry updatedSnapshot = snapshot ; if ( snapshot . state ( ) = = State . STARTED ) { ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards = processWaitingShards ( snapshot . shards ( ) , routingTable ) ; if ( shards ! = null ) { changed = true ; if ( ! snapshot . state ( ) . completed ( ) & & completed ( shards . values ( ) ) ) { updatedSnapshot = new SnapshotsInProgress . Entry ( snapshot , State . SUCCESS , shards ) ; endSnapshot ( updatedSnapshot ) ; } else { updatedSnapshot = new SnapshotsInProgress . Entry ( snapshot , shards ) ; } } entries . add ( updatedSnapshot ) ; } } if ( changed ) { snapshots = new SnapshotsInProgress ( entries . toArray ( new SnapshotsInProgress . Entry [ entries . size ( ) ] ) ) ; return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , source ) ; } } ) ; } } private ImmutableOpenMap < ShardId , ShardSnapshotStatus > processWaitingShards ( ImmutableOpenMap < ShardId , ShardSnapshotStatus > snapshotShards , RoutingTable routingTable ) { boolean snapshotChanged = false ; ImmutableOpenMap . Builder < ShardId , ShardSnapshotStatus > shards = ImmutableOpenMap . builder ( ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardEntry : snapshotShards ) { ShardSnapshotStatus shardStatus = shardEntry . value ; ShardId shardId = shardEntry . key ; if ( shardStatus . state ( ) = = State . WAITING ) { IndexRoutingTable indexShardRoutingTable = routingTable . index ( shardId . getIndex ( ) ) ; if ( indexShardRoutingTable ! = null ) { IndexShardRoutingTable shardRouting = indexShardRoutingTable . shard ( shardId . id ( ) ) ; if ( shardRouting ! = null & & shardRouting . primaryShard ( ) ! = null ) { if ( shardRouting . primaryShard ( ) . started ( ) ) { snapshotChanged = true ; logger . trace ( <str> , shardId , shardStatus . nodeId ( ) ) ; shards . put ( shardId , new ShardSnapshotStatus ( shardRouting . primaryShard ( ) . currentNodeId ( ) ) ) ; continue ; } else if ( shardRouting . primaryShard ( ) . initializing ( ) | | shardRouting . primaryShard ( ) . relocating ( ) ) { shards . put ( shardId , shardStatus ) ; continue ; } } } snapshotChanged = true ; logger . warn ( <str> , shardId , shardStatus . nodeId ( ) ) ; shards . put ( shardId , new ShardSnapshotStatus ( shardStatus . nodeId ( ) , State . FAILED , <str> ) ) ; } else { shards . put ( shardId , shardStatus ) ; } } if ( snapshotChanged ) { return shards . build ( ) ; } else { return null ; } } private boolean waitingShardsStartedOrUnassigned ( ClusterChangedEvent event ) { SnapshotsInProgress curr = event . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( curr ! = null ) { for ( SnapshotsInProgress . Entry entry : curr . entries ( ) ) { if ( entry . state ( ) = = State . STARTED & & ! entry . waitingIndices ( ) . isEmpty ( ) ) { for ( ObjectCursor < String > index : entry . waitingIndices ( ) . keys ( ) ) { if ( event . indexRoutingTableChanged ( index . value ) ) { IndexRoutingTable indexShardRoutingTable = event . state ( ) . getRoutingTable ( ) . index ( index . value ) ; for ( ShardId shardId : entry . waitingIndices ( ) . get ( index . value ) ) { ShardRouting shardRouting = indexShardRoutingTable . shard ( shardId . id ( ) ) . primaryShard ( ) ; if ( shardRouting ! = null & & ( shardRouting . started ( ) | | shardRouting . unassigned ( ) ) ) { return true ; } } } } } } } return false ; } private boolean removedNodesCleanupNeeded ( ClusterChangedEvent event ) { boolean newMaster = ! event . previousState ( ) . nodes ( ) . localNodeMaster ( ) ; SnapshotsInProgress snapshotsInProgress = event . state ( ) . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshotsInProgress = = null ) { return false ; } for ( SnapshotsInProgress . Entry snapshot : snapshotsInProgress . entries ( ) ) { if ( newMaster & & ( snapshot . state ( ) = = State . SUCCESS | | snapshot . state ( ) = = State . INIT ) ) { return true ; } for ( DiscoveryNode node : event . nodesDelta ( ) . removedNodes ( ) ) { for ( ObjectCursor < ShardSnapshotStatus > shardStatus : snapshot . shards ( ) . values ( ) ) { if ( ! shardStatus . value . state ( ) . completed ( ) & & node . getId ( ) . equals ( shardStatus . value . nodeId ( ) ) ) { return true ; } } } } return false ; } private Tuple < Set < String > , Set < String > > indicesWithMissingShards ( ImmutableOpenMap < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shards , MetaData metaData ) { Set < String > missing = new HashSet < > ( ) ; Set < String > closed = new HashSet < > ( ) ; for ( ObjectObjectCursor < ShardId , SnapshotsInProgress . ShardSnapshotStatus > entry : shards ) { if ( entry . value . state ( ) = = State . MISSING ) { if ( metaData . hasIndex ( entry . key . getIndex ( ) ) & & metaData . index ( entry . key . getIndex ( ) ) . getState ( ) = = IndexMetaData . State . CLOSE ) { closed . add ( entry . key . getIndex ( ) ) ; } else { missing . add ( entry . key . getIndex ( ) ) ; } } } return new Tuple < > ( missing , closed ) ; } void endSnapshot ( SnapshotsInProgress . Entry entry ) { endSnapshot ( entry , null ) ; } private void endSnapshot ( final SnapshotsInProgress . Entry entry , final String failure ) { threadPool . executor ( ThreadPool . Names . SNAPSHOT ) . execute ( new Runnable ( ) { @Override public void run ( ) { SnapshotId snapshotId = entry . snapshotId ( ) ; try { final Repository repository = repositoriesService . repository ( snapshotId . getRepository ( ) ) ; logger . trace ( <str> , snapshotId , entry . state ( ) , failure ) ; ArrayList < ShardSearchFailure > failures = new ArrayList < > ( ) ; ArrayList < SnapshotShardFailure > shardFailures = new ArrayList < > ( ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardStatus : entry . shards ( ) ) { ShardId shardId = shardStatus . key ; ShardSnapshotStatus status = shardStatus . value ; if ( status . state ( ) . failed ( ) ) { failures . add ( new ShardSearchFailure ( status . reason ( ) , new SearchShardTarget ( status . nodeId ( ) , shardId . getIndex ( ) , shardId . id ( ) ) ) ) ; shardFailures . add ( new SnapshotShardFailure ( status . nodeId ( ) , shardId . getIndex ( ) , shardId . id ( ) , status . reason ( ) ) ) ; } } Snapshot snapshot = repository . finalizeSnapshot ( snapshotId , entry . indices ( ) , entry . startTime ( ) , failure , entry . shards ( ) . size ( ) , Collections . unmodifiableList ( shardFailures ) ) ; removeSnapshotFromClusterState ( snapshotId , new SnapshotInfo ( snapshot ) , null ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , snapshotId ) ; removeSnapshotFromClusterState ( snapshotId , null , t ) ; } } } ) ; } private void removeSnapshotFromClusterState ( final SnapshotId snapshotId , final SnapshotInfo snapshot , final Throwable t ) { clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) { SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots ! = null ) { boolean changed = false ; ArrayList < SnapshotsInProgress . Entry > entries = new ArrayList < > ( ) ; for ( SnapshotsInProgress . Entry entry : snapshots . entries ( ) ) { if ( entry . snapshotId ( ) . equals ( snapshotId ) ) { changed = true ; } else { entries . add ( entry ) ; } } if ( changed ) { snapshots = new SnapshotsInProgress ( entries . toArray ( new SnapshotsInProgress . Entry [ entries . size ( ) ] ) ) ; return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , snapshotId ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { for ( SnapshotCompletionListener listener : snapshotCompletionListeners ) { try { if ( snapshot ! = null ) { listener . onSnapshotCompletion ( snapshotId , snapshot ) ; } else { listener . onSnapshotFailure ( snapshotId , t ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t , listener ) ; } } } } ) ; } public void deleteSnapshot ( final SnapshotId snapshotId , final DeleteSnapshotListener listener ) { validate ( snapshotId ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { boolean waitForSnapshot = false ; @Override public ClusterState execute ( ClusterState currentState ) throws Exception { SnapshotsInProgress snapshots = currentState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots = = null ) { return currentState ; } SnapshotsInProgress . Entry snapshot = snapshots . snapshot ( snapshotId ) ; if ( snapshot = = null ) { if ( ! snapshots . entries ( ) . isEmpty ( ) ) { throw new ConcurrentSnapshotExecutionException ( snapshotId , <str> ) ; } return currentState ; } else { waitForSnapshot = true ; ImmutableOpenMap < ShardId , ShardSnapshotStatus > shards ; if ( snapshot . state ( ) = = State . STARTED & & snapshot . shards ( ) ! = null ) { ImmutableOpenMap . Builder < ShardId , ShardSnapshotStatus > shardsBuilder = ImmutableOpenMap . builder ( ) ; for ( ObjectObjectCursor < ShardId , ShardSnapshotStatus > shardEntry : snapshot . shards ( ) ) { ShardSnapshotStatus status = shardEntry . value ; if ( ! status . state ( ) . completed ( ) ) { shardsBuilder . put ( shardEntry . key , new ShardSnapshotStatus ( status . nodeId ( ) , State . ABORTED ) ) ; } else { shardsBuilder . put ( shardEntry . key , status ) ; } } shards = shardsBuilder . build ( ) ; } else if ( snapshot . state ( ) = = State . INIT ) { shards = snapshot . shards ( ) ; endSnapshot ( snapshot ) ; } else { boolean hasUncompletedShards = false ; for ( ObjectCursor < ShardSnapshotStatus > shardStatus : snapshot . shards ( ) . values ( ) ) { if ( shardStatus . value . state ( ) . completed ( ) = = false & & shardStatus . value . nodeId ( ) ! = null & & currentState . nodes ( ) . get ( shardStatus . value . nodeId ( ) ) ! = null ) { hasUncompletedShards = true ; break ; } } if ( hasUncompletedShards ) { logger . debug ( <str> ) ; return currentState ; } else { logger . debug ( <str> ) ; shards = snapshot . shards ( ) ; endSnapshot ( snapshot ) ; } } SnapshotsInProgress . Entry newSnapshot = new SnapshotsInProgress . Entry ( snapshot , State . ABORTED , shards ) ; snapshots = new SnapshotsInProgress ( newSnapshot ) ; return ClusterState . builder ( currentState ) . putCustom ( SnapshotsInProgress . TYPE , snapshots ) . build ( ) ; } } @Override public void onFailure ( String source , Throwable t ) { listener . onFailure ( t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { if ( waitForSnapshot ) { logger . trace ( <str> ) ; addListener ( new SnapshotCompletionListener ( ) { @Override public void onSnapshotCompletion ( SnapshotId completedSnapshotId , SnapshotInfo snapshot ) { if ( completedSnapshotId . equals ( snapshotId ) ) { logger . trace ( <str> ) ; removeListener ( this ) ; deleteSnapshotFromRepository ( snapshotId , listener ) ; } } @Override public void onSnapshotFailure ( SnapshotId failedSnapshotId , Throwable t ) { if ( failedSnapshotId . equals ( snapshotId ) ) { logger . trace ( <str> , t ) ; removeListener ( this ) ; deleteSnapshotFromRepository ( snapshotId , listener ) ; } } } ) ; } else { logger . trace ( <str> ) ; deleteSnapshotFromRepository ( snapshotId , listener ) ; } } } ) ; } public static boolean isRepositoryInUse ( ClusterState clusterState , String repository ) { SnapshotsInProgress snapshots = clusterState . custom ( SnapshotsInProgress . TYPE ) ; if ( snapshots ! = null ) { for ( SnapshotsInProgress . Entry snapshot : snapshots . entries ( ) ) { if ( repository . equals ( snapshot . snapshotId ( ) . getRepository ( ) ) ) { return true ; } } } return false ; } private void deleteSnapshotFromRepository ( final SnapshotId snapshotId , final DeleteSnapshotListener listener ) { threadPool . executor ( ThreadPool . Names . SNAPSHOT ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { Repository repository = repositoriesService . repository ( snapshotId . getRepository ( ) ) ; repository . deleteSnapshot ( snapshotId ) ; listener . onResponse ( ) ; } catch ( Throwable t ) { listener . onFailure ( t ) ; } } } ) ; } private ImmutableOpenMap < ShardId , SnapshotsInProgress . ShardSnapshotStatus > shards ( ClusterState clusterState , List < String > indices ) { ImmutableOpenMap . Builder < ShardId , SnapshotsInProgress . ShardSnapshotStatus > builder = ImmutableOpenMap . builder ( ) ; MetaData metaData = clusterState . metaData ( ) ; for ( String index : indices ) { IndexMetaData indexMetaData = metaData . index ( index ) ; if ( indexMetaData = = null ) { builder . put ( new ShardId ( index , <int> ) , new SnapshotsInProgress . ShardSnapshotStatus ( null , State . MISSING , <str> ) ) ; } else if ( indexMetaData . getState ( ) = = IndexMetaData . State . CLOSE ) { for ( int i = <int> ; i < indexMetaData . getNumberOfShards ( ) ; i + + ) { ShardId shardId = new ShardId ( index , i ) ; builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( null , State . MISSING , <str> ) ) ; } } else { IndexRoutingTable indexRoutingTable = clusterState . getRoutingTable ( ) . index ( index ) ; for ( int i = <int> ; i < indexMetaData . getNumberOfShards ( ) ; i + + ) { ShardId shardId = new ShardId ( index , i ) ; if ( indexRoutingTable ! = null ) { ShardRouting primary = indexRoutingTable . shard ( i ) . primaryShard ( ) ; if ( primary = = null | | ! primary . assignedToNode ( ) ) { builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( null , State . MISSING , <str> ) ) ; } else if ( primary . relocating ( ) | | primary . initializing ( ) ) { builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( primary . currentNodeId ( ) , State . WAITING ) ) ; } else if ( ! primary . started ( ) ) { builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( primary . currentNodeId ( ) , State . MISSING , <str> ) ) ; } else { builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( primary . currentNodeId ( ) ) ) ; } } else { builder . put ( shardId , new SnapshotsInProgress . ShardSnapshotStatus ( null , State . MISSING , <str> ) ) ; } } } } return builder . build ( ) ; } public void addListener ( SnapshotCompletionListener listener ) { this . snapshotCompletionListeners . add ( listener ) ; } public void removeListener ( SnapshotCompletionListener listener ) { this . snapshotCompletionListeners . remove ( listener ) ; } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { clusterService . remove ( this ) ; } public RepositoriesService getRepositoriesService ( ) { return repositoriesService ; } public static interface CreateSnapshotListener { void onResponse ( ) ; void onFailure ( Throwable t ) ; } public static interface DeleteSnapshotListener { void onResponse ( ) ; void onFailure ( Throwable t ) ; } public static interface SnapshotCompletionListener { void onSnapshotCompletion ( SnapshotId snapshotId , SnapshotInfo snapshot ) ; void onSnapshotFailure ( SnapshotId snapshotId , Throwable t ) ; } public static class SnapshotRequest { private String cause ; private String name ; private String repository ; private String [ ] indices ; private IndicesOptions indicesOptions = IndicesOptions . strictExpandOpen ( ) ; private boolean partial ; private Settings settings ; private boolean includeGlobalState ; private TimeValue masterNodeTimeout ; public SnapshotRequest ( String cause , String name , String repository ) { this . cause = cause ; this . name = name ; this . repository = repository ; } public SnapshotRequest indices ( String [ ] indices ) { this . indices = indices ; return this ; } public SnapshotRequest settings ( Settings settings ) { this . settings = settings ; return this ; } public SnapshotRequest includeGlobalState ( boolean includeGlobalState ) { this . includeGlobalState = includeGlobalState ; return this ; } public SnapshotRequest masterNodeTimeout ( TimeValue masterNodeTimeout ) { this . masterNodeTimeout = masterNodeTimeout ; return this ; } public SnapshotRequest indicesOptions ( IndicesOptions indicesOptions ) { this . indicesOptions = indicesOptions ; return this ; } public SnapshotRequest partial ( boolean partial ) { this . partial = partial ; return this ; } public String cause ( ) { return cause ; } public String name ( ) { return name ; } public String repository ( ) { return repository ; } public String [ ] indices ( ) { return indices ; } public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public Settings settings ( ) { return settings ; } public boolean includeGlobalState ( ) { return includeGlobalState ; } public TimeValue masterNodeTimeout ( ) { return masterNodeTimeout ; } } } 
