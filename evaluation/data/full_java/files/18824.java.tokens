package io . netty . buffer ; import org . junit . Test ; import java . io . IOException ; import java . util . Random ; import static org . junit . Assert . * ; public class SlicedByteBufTest extends AbstractByteBufTest { private final Random random = new Random ( ) ; @Override protected ByteBuf newBuffer ( int length ) { ByteBuf buffer = Unpooled . wrappedBuffer ( new byte [ length * <int> ] , random . nextInt ( length - <int> ) + <int> , length ) ; assertEquals ( length , buffer . writerIndex ( ) ) ; return buffer ; } @Test ( expected = NullPointerException . class ) public void shouldNotAllowNullInConstructor ( ) { new SlicedByteBuf ( null , <int> , <int> ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testInternalNioBuffer ( ) { super . testInternalNioBuffer ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testDuplicateReadGatheringByteChannelMultipleThreads ( ) throws Exception { super . testDuplicateReadGatheringByteChannelMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testSliceReadGatheringByteChannelMultipleThreads ( ) throws Exception { super . testSliceReadGatheringByteChannelMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testDuplicateReadOutputStreamMultipleThreads ( ) throws Exception { super . testDuplicateReadOutputStreamMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testSliceReadOutputStreamMultipleThreads ( ) throws Exception { super . testSliceReadOutputStreamMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testDuplicateBytesInArrayMultipleThreads ( ) throws Exception { super . testDuplicateBytesInArrayMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testSliceBytesInArrayMultipleThreads ( ) throws Exception { super . testSliceBytesInArrayMultipleThreads ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testNioBufferExposeOnlyRegion ( ) { super . testNioBufferExposeOnlyRegion ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testEnsureWritableAfterRelease ( ) { super . testEnsureWritableAfterRelease ( ) ; } @Test ( expected = IndexOutOfBoundsException . class ) @Override public void testWriteZeroAfterRelease ( ) throws IOException { super . testWriteZeroAfterRelease ( ) ; } @Test @Override public void testLittleEndianWithExpand ( ) { } @Test public void testReaderIndexAndMarks ( ) { ByteBuf wrapped = Unpooled . buffer ( <int> ) ; try { wrapped . writerIndex ( <int> ) ; wrapped . readerIndex ( <int> ) ; wrapped . markWriterIndex ( ) ; wrapped . markReaderIndex ( ) ; ByteBuf slice = new SlicedByteBuf ( wrapped , <int> , <int> ) ; assertEquals ( <int> , slice . readerIndex ( ) ) ; assertEquals ( <int> , slice . writerIndex ( ) ) ; slice . readerIndex ( slice . readerIndex ( ) + <int> ) ; slice . resetReaderIndex ( ) ; assertEquals ( <int> , slice . readerIndex ( ) ) ; slice . writerIndex ( slice . writerIndex ( ) - <int> ) ; slice . resetWriterIndex ( ) ; assertEquals ( <int> , slice . writerIndex ( ) ) ; } finally { wrapped . release ( ) ; } } @Test public void sliceEmptyNotLeak ( ) { ByteBuf buffer = Unpooled . buffer ( <int> ) . retain ( ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; ByteBuf slice1 = buffer . slice ( ) ; assertEquals ( <int> , slice1 . refCnt ( ) ) ; ByteBuf slice2 = slice1 . slice ( ) ; assertEquals ( <int> , slice2 . refCnt ( ) ) ; assertFalse ( slice2 . release ( ) ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; assertEquals ( <int> , slice1 . refCnt ( ) ) ; assertEquals ( <int> , slice2 . refCnt ( ) ) ; assertTrue ( slice2 . release ( ) ) ; assertEquals ( <int> , buffer . refCnt ( ) ) ; assertEquals ( <int> , slice1 . refCnt ( ) ) ; assertEquals ( <int> , slice2 . refCnt ( ) ) ; } } 
