package org . elasticsearch . action . deletebyquery ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . bulk . BulkItemResponse ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . search . ClearScrollResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . common . util . concurrent . CountDown ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . SearchShardTarget ; import org . elasticsearch . search . internal . InternalSearchHit ; import org . elasticsearch . test . ESSingleNodeTestCase ; import static org . elasticsearch . index . query . QueryBuilders . boolQuery ; import static org . elasticsearch . index . query . QueryBuilders . rangeQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; public class TransportDeleteByQueryActionTests extends ESSingleNodeTestCase { public void testExecuteScanFailsOnMissingIndex ( ) { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScan ( ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScan ( ) { createIndex ( <str> ) ; final int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < = numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , i ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . get ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , numDocs ) ; final long limit = randomIntBetween ( <int> , numDocs ) ; DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) . query ( boolQuery ( ) . must ( rangeQuery ( <str> ) . lte ( limit ) ) ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScan ( ) ; waitForCompletion ( <str> , listener ) ; assertNoFailures ( listener ) ; DeleteByQueryResponse response = listener . getResponse ( ) ; assertNotNull ( response ) ; assertThat ( response . getTotalFound ( ) , equalTo ( limit ) ) ; assertThat ( response . getTotalDeleted ( ) , equalTo ( limit ) ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScrollFailsOnMissingScrollId ( ) { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScroll ( null ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScrollFailsOnMalformedScrollId ( ) { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScroll ( <str> ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScrollFailsOnExpiredScrollId ( ) { final long numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < = numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , i ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . get ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , numDocs ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( numDocs ) ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; ClearScrollResponse clearScrollResponse = client ( ) . prepareClearScroll ( ) . addScrollId ( scrollId ) . get ( ) ; assertTrue ( clearScrollResponse . isSucceeded ( ) ) ; DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScroll ( searchResponse . getScrollId ( ) ) ; waitForCompletion ( <str> , listener ) ; assertNotNull ( listener . getError ( ) ) ; assertThrowableContains ( listener . getError ( ) , <str> ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScrollTimedOut ( ) throws InterruptedException { client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . get ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) . timeout ( TimeValue . timeValueSeconds ( <int> ) ) ; TestActionListener listener = new TestActionListener ( ) ; final TransportDeleteByQueryAction . AsyncDeleteByQueryAction async = newAsyncAction ( delete , listener ) ; awaitBusy ( ( ) - > async . hasTimedOut ( ) ) ; async . executeScroll ( searchResponse . getScrollId ( ) ) ; waitForCompletion ( <str> , listener ) ; assertNull ( listener . getError ( ) ) ; assertTrue ( listener . getResponse ( ) . isTimedOut ( ) ) ; assertThat ( listener . getResponse ( ) . getTotalDeleted ( ) , equalTo ( <int> L ) ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScrollNoDocuments ( ) { createIndex ( <str> ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScroll ( searchResponse . getScrollId ( ) ) ; waitForCompletion ( <str> , listener ) ; assertNull ( listener . getError ( ) ) ; assertFalse ( listener . getResponse ( ) . isTimedOut ( ) ) ; assertThat ( listener . getResponse ( ) . getTotalFound ( ) , equalTo ( <int> L ) ) ; assertThat ( listener . getResponse ( ) . getTotalDeleted ( ) , equalTo ( <int> L ) ) ; assertSearchContextsClosed ( ) ; } public void testExecuteScroll ( ) { final int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < = numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , i ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . get ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , numDocs ) ; final long limit = randomIntBetween ( <int> , numDocs ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . setQuery ( boolQuery ( ) . must ( rangeQuery ( <str> ) . lte ( limit ) ) ) . fields ( <str> , <str> ) . setFetchSource ( false ) . setVersion ( true ) . get ( ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( limit ) ) ; DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) . indices ( new String [ ] { <str> } ) . size ( <int> ) . query ( boolQuery ( ) . must ( rangeQuery ( <str> ) . lte ( limit ) ) ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . executeScroll ( searchResponse . getScrollId ( ) ) ; waitForCompletion ( <str> , listener ) ; assertNull ( listener . getError ( ) ) ; assertFalse ( listener . getResponse ( ) . isTimedOut ( ) ) ; final long expectedDeleted = Math . max ( <int> , limit - searchResponse . getHits ( ) . hits ( ) . length ) ; assertThat ( listener . getResponse ( ) . getTotalDeleted ( ) , equalTo ( expectedDeleted ) ) ; assertSearchContextsClosed ( ) ; } public void testOnBulkResponse ( ) { final int nbItems = randomIntBetween ( <int> , <int> ) ; long deleted = <int> ; long missing = <int> ; long failed = <int> ; BulkItemResponse [ ] items = new BulkItemResponse [ nbItems ] ; for ( int i = <int> ; i < nbItems ; i + + ) { if ( randomBoolean ( ) ) { boolean delete = true ; if ( rarely ( ) ) { delete = false ; missing + + ; } else { deleted + + ; } items [ i ] = new BulkItemResponse ( i , <str> , new DeleteResponse ( new ShardId ( <str> , <int> ) , <str> , String . valueOf ( i ) , <int> , delete ) ) ; } else { items [ i ] = new BulkItemResponse ( i , <str> , new BulkItemResponse . Failure ( <str> , <str> , String . valueOf ( i ) , new Throwable ( <str> ) ) ) ; failed + + ; } } createIndex ( <str> ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; try { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . onBulkResponse ( scrollId , new BulkResponse ( items , <int> L ) ) ; waitForCompletion ( <str> , listener ) ; assertNoFailures ( listener ) ; assertThat ( listener . getResponse ( ) . getTotalDeleted ( ) , equalTo ( deleted ) ) ; assertThat ( listener . getResponse ( ) . getTotalFailed ( ) , equalTo ( failed ) ) ; assertThat ( listener . getResponse ( ) . getTotalMissing ( ) , equalTo ( missing ) ) ; } finally { client ( ) . prepareClearScroll ( ) . addScrollId ( scrollId ) . get ( ) ; } } public void testOnBulkResponseMultipleIndices ( ) { final int nbIndices = randomIntBetween ( <int> , <int> ) ; final long [ ] found = new long [ <int> + nbIndices ] ; final long [ ] deleted = new long [ <int> + nbIndices ] ; final long [ ] missing = new long [ <int> + nbIndices ] ; final long [ ] failed = new long [ <int> + nbIndices ] ; final int nbItems = randomIntBetween ( <int> , <int> ) ; found [ <int> ] = nbItems ; BulkItemResponse [ ] items = new BulkItemResponse [ nbItems ] ; for ( int i = <int> ; i < nbItems ; i + + ) { int index = randomIntBetween ( <int> , nbIndices ) ; found [ index ] = found [ index ] + <int> ; if ( randomBoolean ( ) ) { boolean delete = true ; if ( rarely ( ) ) { delete = false ; missing [ <int> ] = missing [ <int> ] + <int> ; missing [ index ] = missing [ index ] + <int> ; } else { deleted [ <int> ] = deleted [ <int> ] + <int> ; deleted [ index ] = deleted [ index ] + <int> ; } items [ i ] = new BulkItemResponse ( i , <str> , new DeleteResponse ( new ShardId ( <str> + index , <int> ) , <str> , String . valueOf ( i ) , <int> , delete ) ) ; } else { items [ i ] = new BulkItemResponse ( i , <str> , new BulkItemResponse . Failure ( <str> + index , <str> , String . valueOf ( i ) , new Throwable ( <str> ) ) ) ; failed [ <int> ] = failed [ <int> ] + <int> ; failed [ index ] = failed [ index ] + <int> ; } } createIndex ( <str> ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; String scrollId = searchResponse . getScrollId ( ) ; assertTrue ( Strings . hasText ( scrollId ) ) ; try { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . onBulkResponse ( scrollId , new BulkResponse ( items , <int> L ) ) ; waitForCompletion ( <str> , listener ) ; assertNoFailures ( listener ) ; assertThat ( listener . getResponse ( ) . getTotalDeleted ( ) , equalTo ( deleted [ <int> ] ) ) ; assertThat ( listener . getResponse ( ) . getTotalFailed ( ) , equalTo ( failed [ <int> ] ) ) ; assertThat ( listener . getResponse ( ) . getTotalMissing ( ) , equalTo ( missing [ <int> ] ) ) ; for ( int i = <int> ; i < = nbIndices ; i + + ) { IndexDeleteByQueryResponse indexResponse = listener . getResponse ( ) . getIndex ( <str> + i ) ; if ( found [ i ] > = <int> ) { assertNotNull ( indexResponse ) ; assertThat ( indexResponse . getFound ( ) , equalTo ( found [ i ] ) ) ; assertThat ( indexResponse . getDeleted ( ) , equalTo ( deleted [ i ] ) ) ; assertThat ( indexResponse . getFailed ( ) , equalTo ( failed [ i ] ) ) ; assertThat ( indexResponse . getMissing ( ) , equalTo ( missing [ i ] ) ) ; } else { assertNull ( indexResponse ) ; } } } finally { client ( ) . prepareClearScroll ( ) . addScrollId ( scrollId ) . get ( ) ; } } public void testOnBulkFailureNoDocuments ( ) { DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( delete , listener ) . onBulkFailure ( null , new SearchHit [ <int> ] , new Throwable ( <str> ) ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; } public void testOnBulkFailure ( ) { final int nbDocs = randomIntBetween ( <int> , <int> ) ; SearchHit [ ] docs = new SearchHit [ nbDocs ] ; for ( int i = <int> ; i < nbDocs ; i + + ) { InternalSearchHit doc = new InternalSearchHit ( randomInt ( ) , String . valueOf ( i ) , new StringText ( <str> ) , null ) ; doc . shard ( new SearchShardTarget ( <str> , <str> , randomInt ( ) ) ) ; docs [ i ] = doc ; } DeleteByQueryRequest delete = new DeleteByQueryRequest ( ) ; TestActionListener listener = new TestActionListener ( ) ; TransportDeleteByQueryAction . AsyncDeleteByQueryAction async = newAsyncAction ( delete , listener ) ; async . onBulkFailure ( null , docs , new Throwable ( <str> ) ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; DeleteByQueryResponse response = async . buildResponse ( ) ; assertThat ( response . getTotalFailed ( ) , equalTo ( ( long ) nbDocs ) ) ; assertThat ( response . getTotalDeleted ( ) , equalTo ( <int> L ) ) ; } public void testFinishHim ( ) { TestActionListener listener = new TestActionListener ( ) ; newAsyncAction ( new DeleteByQueryRequest ( ) , listener ) . finishHim ( null , false , null ) ; waitForCompletion ( <str> , listener ) ; assertNoFailures ( listener ) ; assertNotNull ( listener . getResponse ( ) ) ; assertFalse ( listener . getResponse ( ) . isTimedOut ( ) ) ; listener = new TestActionListener ( ) ; newAsyncAction ( new DeleteByQueryRequest ( ) , listener ) . finishHim ( null , true , null ) ; waitForCompletion ( <str> , listener ) ; assertNoFailures ( listener ) ; assertNotNull ( listener . getResponse ( ) ) ; assertTrue ( listener . getResponse ( ) . isTimedOut ( ) ) ; listener = new TestActionListener ( ) ; newAsyncAction ( new DeleteByQueryRequest ( ) , listener ) . finishHim ( null , false , new Throwable ( <str> ) ) ; waitForCompletion ( <str> , listener ) ; assertFailure ( listener , <str> ) ; assertNull ( listener . getResponse ( ) ) ; } private TransportDeleteByQueryAction . AsyncDeleteByQueryAction newAsyncAction ( DeleteByQueryRequest request , TestActionListener listener ) { TransportDeleteByQueryAction action = getInstanceFromNode ( TransportDeleteByQueryAction . class ) ; assertNotNull ( action ) ; return action . new AsyncDeleteByQueryAction ( request , listener ) ; } private void waitForCompletion ( String testName , final TestActionListener listener ) { logger . info ( <str> , testName ) ; try { awaitBusy ( ( ) - > listener . isTerminated ( ) ) ; } catch ( InterruptedException e ) { fail ( <str> + testName + <str> + e . getMessage ( ) ) ; logger . error ( <str> , e , testName ) ; } } private void assertFailure ( TestActionListener listener , String expectedMessage ) { Throwable t = listener . getError ( ) ; assertNotNull ( t ) ; assertTrue ( Strings . hasText ( expectedMessage ) ) ; assertTrue ( <str> + expectedMessage + <str> + t . getMessage ( ) + <str> , t . getMessage ( ) . contains ( expectedMessage ) ) ; } private void assertNoFailures ( TestActionListener listener ) { assertNull ( listener . getError ( ) ) ; assertTrue ( CollectionUtils . isEmpty ( listener . getResponse ( ) . getShardFailures ( ) ) ) ; } private void assertSearchContextsClosed ( ) { NodesStatsResponse nodesStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setIndices ( true ) . get ( ) ; for ( NodeStats nodeStat : nodesStats . getNodes ( ) ) { assertThat ( nodeStat . getIndices ( ) . getSearch ( ) . getOpenContexts ( ) , equalTo ( <int> L ) ) ; } } private void assertThrowableContains ( Throwable t , String expectedFailure ) { assertThat ( t . toString ( ) , containsString ( expectedFailure ) ) ; } private class TestActionListener implements ActionListener < DeleteByQueryResponse > { private final CountDown count = new CountDown ( <int> ) ; private DeleteByQueryResponse response ; private Throwable error ; @Override public void onResponse ( DeleteByQueryResponse response ) { try { this . response = response ; } finally { count . countDown ( ) ; } } @Override public void onFailure ( Throwable e ) { try { this . error = e ; } finally { count . countDown ( ) ; } } public boolean isTerminated ( ) { return count . isCountedDown ( ) ; } public DeleteByQueryResponse getResponse ( ) { return response ; } public Throwable getError ( ) { return error ; } } } 
