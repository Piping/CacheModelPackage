package org . gradle . internal . xml ; import org . gradle . internal . SystemProperties ; import java . io . IOException ; import java . io . Writer ; import java . util . LinkedList ; public class SimpleMarkupWriter extends Writer { private enum Context { Outside , Text , CData , StartTag , ElementContent } private final Writer output ; private final LinkedList < String > elements = new LinkedList < String > ( ) ; private Context context = Context . Outside ; private int squareBrackets ; private final String indent ; protected SimpleMarkupWriter ( Writer writer , String indent ) throws IOException { this . indent = indent ; this . output = writer ; } @Override public void write ( char [ ] chars , int offset , int length ) throws IOException { characters ( chars , offset , length ) ; } @Override public void flush ( ) throws IOException { output . flush ( ) ; } @Override public void close ( ) throws IOException { } public SimpleMarkupWriter characters ( char [ ] characters ) throws IOException { characters ( characters , <int> , characters . length ) ; return this ; } public SimpleMarkupWriter characters ( char [ ] characters , int start , int count ) throws IOException { if ( context = = Context . CData ) { writeCDATA ( characters , start , count ) ; } else { maybeStartText ( ) ; writeXmlEncoded ( characters , start , count ) ; } return this ; } public SimpleMarkupWriter characters ( CharSequence characters ) throws IOException { if ( context = = Context . CData ) { writeCDATA ( characters ) ; } else { maybeStartText ( ) ; writeXmlEncoded ( characters ) ; } return this ; } private void maybeStartText ( ) throws IOException { if ( context = = Context . Outside ) { throw new IllegalStateException ( <str> ) ; } if ( context = = Context . StartTag ) { writeRaw ( <str> ) ; } context = Context . Text ; } private void maybeFinishStartTag ( ) throws IOException { if ( context = = Context . StartTag ) { writeRaw ( <str> ) ; context = Context . ElementContent ; } } public SimpleMarkupWriter startElement ( String name ) throws IOException { if ( ! XmlValidation . isValidXmlName ( name ) ) { throw new IllegalArgumentException ( String . format ( <str> , name ) ) ; } if ( context = = Context . CData ) { throw new IllegalStateException ( <str> ) ; } maybeFinishStartTag ( ) ; if ( indent ! = null ) { writeRaw ( SystemProperties . getInstance ( ) . getLineSeparator ( ) ) ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { writeRaw ( indent ) ; } } context = Context . StartTag ; elements . add ( name ) ; writeRaw ( <str> ) ; writeRaw ( name ) ; return this ; } public SimpleMarkupWriter endElement ( ) throws IOException { if ( context = = Context . Outside ) { throw new IllegalStateException ( <str> ) ; } if ( context = = Context . CData ) { throw new IllegalStateException ( <str> ) ; } if ( context = = Context . StartTag ) { writeRaw ( <str> ) ; elements . removeLast ( ) ; } else { if ( context ! = Context . Text & & indent ! = null ) { writeRaw ( SystemProperties . getInstance ( ) . getLineSeparator ( ) ) ; for ( int i = <int> ; i < elements . size ( ) ; i + + ) { writeRaw ( indent ) ; } } writeRaw ( <str> ) ; writeRaw ( elements . removeLast ( ) ) ; writeRaw ( <str> ) ; } if ( elements . isEmpty ( ) ) { if ( indent ! = null ) { writeRaw ( SystemProperties . getInstance ( ) . getLineSeparator ( ) ) ; } output . flush ( ) ; context = Context . Outside ; } else { context = Context . ElementContent ; } return this ; } private void writeCDATA ( char [ ] cdata , int offset , int count ) throws IOException { int end = offset + count ; for ( int i = offset ; i < end ; i + + ) { writeCDATA ( cdata [ i ] ) ; } } private void writeCDATA ( CharSequence cdata ) throws IOException { int len = cdata . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { writeCDATA ( cdata . charAt ( i ) ) ; } } private void writeCDATA ( char ch ) throws IOException { if ( needsCDATAEscaping ( ch ) ) { writeRaw ( <str> ) ; } else if ( ! XmlValidation . isLegalCharacter ( ch ) ) { writeRaw ( <str> ) ; } else if ( XmlValidation . isRestrictedCharacter ( ch ) ) { writeRaw ( <str> ) ; writeCharacterReference ( ch ) ; writeRaw ( <str> ) ; } else { writeRaw ( ch ) ; } } private void writeCharacterReference ( char ch ) throws IOException { writeRaw ( <str> ) ; writeRaw ( Integer . toHexString ( ch ) ) ; writeRaw ( <str> ) ; } private boolean needsCDATAEscaping ( char ch ) { switch ( ch ) { case <str> : squareBrackets + + ; return false ; case <str> : if ( squareBrackets > = <int> ) { squareBrackets = <int> ; return true ; } return false ; default : squareBrackets = <int> ; return false ; } } public SimpleMarkupWriter startCDATA ( ) throws IOException { if ( context = = Context . CData ) { throw new IllegalStateException ( <str> ) ; } maybeFinishStartTag ( ) ; writeRaw ( <str> ) ; context = Context . CData ; squareBrackets = <int> ; return this ; } public SimpleMarkupWriter endCDATA ( ) throws IOException { if ( context ! = Context . CData ) { throw new IllegalStateException ( <str> ) ; } writeRaw ( <str> ) ; context = Context . Text ; return this ; } public SimpleMarkupWriter attribute ( String name , String value ) throws IOException { if ( ! XmlValidation . isValidXmlName ( name ) ) { throw new IllegalArgumentException ( String . format ( <str> , name ) ) ; } if ( context ! = Context . StartTag ) { throw new IllegalStateException ( <str> + name + <str> + value + <str> ) ; } writeRaw ( <str> ) ; writeRaw ( name ) ; writeRaw ( <str> ) ; writeXmlAttributeEncoded ( value ) ; writeRaw ( <str> ) ; return this ; } private void writeRaw ( char c ) throws IOException { output . write ( c ) ; } protected void writeRaw ( String message ) throws IOException { output . write ( message ) ; } private void writeXmlEncoded ( char [ ] message , int offset , int count ) throws IOException { int end = offset + count ; for ( int i = offset ; i < end ; i + + ) { writeXmlEncoded ( message [ i ] ) ; } } private void writeXmlAttributeEncoded ( CharSequence message ) throws IOException { assert message ! = null ; int len = message . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { writeXmlAttributeEncoded ( message . charAt ( i ) ) ; } } private void writeXmlAttributeEncoded ( char ch ) throws IOException { if ( ch = = <int> ) { writeRaw ( <str> ) ; } else if ( ch = = <int> ) { writeRaw ( <str> ) ; } else if ( ch = = <int> ) { writeRaw ( <str> ) ; } else { writeXmlEncoded ( ch ) ; } } private void writeXmlEncoded ( CharSequence message ) throws IOException { assert message ! = null ; int len = message . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { writeXmlEncoded ( message . charAt ( i ) ) ; } } private void writeXmlEncoded ( char ch ) throws IOException { if ( ch = = <str> ) { writeRaw ( <str> ) ; } else if ( ch = = <str> ) { writeRaw ( <str> ) ; } else if ( ch = = <str> ) { writeRaw ( <str> ) ; } else if ( ch = = <str> ) { writeRaw ( <str> ) ; } else if ( ! XmlValidation . isLegalCharacter ( ch ) ) { writeRaw ( <str> ) ; } else if ( XmlValidation . isRestrictedCharacter ( ch ) ) { writeCharacterReference ( ch ) ; } else { writeRaw ( ch ) ; } } } 
