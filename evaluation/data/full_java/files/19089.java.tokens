package io . netty . handler . codec . http ; import static io . netty . handler . codec . http . HttpHeaderValues . DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . GZIP ; import static io . netty . handler . codec . http . HttpHeaderValues . X_DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . X_GZIP ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . compression . ZlibCodecFactory ; import io . netty . handler . codec . compression . ZlibWrapper ; public class HttpContentDecompressor extends HttpContentDecoder { private final boolean strict ; public HttpContentDecompressor ( ) { this ( false ) ; } public HttpContentDecompressor ( boolean strict ) { this . strict = strict ; } @Override protected EmbeddedChannel newContentDecoder ( String contentEncoding ) throws Exception { if ( GZIP . contentEqualsIgnoreCase ( contentEncoding ) | | X_GZIP . contentEqualsIgnoreCase ( contentEncoding ) ) { return new EmbeddedChannel ( ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; } if ( DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) | | X_DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) ) { final ZlibWrapper wrapper = strict ? ZlibWrapper . ZLIB : ZlibWrapper . ZLIB_OR_NONE ; return new EmbeddedChannel ( ZlibCodecFactory . newZlibDecoder ( wrapper ) ) ; } return null ; } } 
