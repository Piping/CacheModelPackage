package org . nd4j . linalg . api . parallel . tasks . cpu . accumulation ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . parallel . tasks . Task ; import org . nd4j . linalg . api . parallel . tasks . TaskExecutorProvider ; import org . nd4j . linalg . api . shape . tensor . TensorCalculator ; import java . nio . ByteBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . util . List ; import java . util . concurrent . Future ; import java . util . concurrent . RecursiveAction ; import java . util . concurrent . RecursiveTask ; public class CPUAccumulations1dAction extends RecursiveAction implements Task < Void > { private Future future ; private List < Task < ? > > subTasks = null ; private Accumulation op ; private int threshold ; private TensorCalculator tCalcx ; private TensorCalculator tCalcy ; private int firstTensor ; private int lastTensor ; private INDArray output ; public CPUAccumulations1dAction ( Accumulation op , int threshold , TensorCalculator tCalcx , TensorCalculator tCalcy , int firstTensor , int lastTensor , INDArray output ) { this . op = op ; this . threshold = threshold ; this . tCalcx = tCalcx ; this . tCalcy = tCalcy ; this . firstTensor = firstTensor ; this . lastTensor = lastTensor ; this . output = output ; } @Override protected void compute ( ) { int nTensors = ( lastTensor - firstTensor + <int> ) ; int nElements = nTensors * tCalcx . getTensorLength ( ) ; if ( nTensors > <int> & & nElements > threshold ) { int nFirst = nTensors / <int> ; CPUAccumulations1dAction taskLeft = new CPUAccumulations1dAction ( op , threshold , tCalcx , tCalcy , firstTensor , firstTensor + nFirst - <int> , output ) ; taskLeft . fork ( ) ; CPUAccumulations1dAction taskRight = new CPUAccumulations1dAction ( op , threshold , tCalcx , tCalcy , firstTensor + nFirst , lastTensor , output ) ; taskRight . fork ( ) ; taskLeft . join ( ) ; taskRight . join ( ) ; } else if ( nTensors = = <int> & & nElements > threshold ) { int offsetX = tCalcx . getOffsetForTensor ( firstTensor ) ; int offsetY = ( tCalcy ! = null ? tCalcy . getOffsetForTensor ( firstTensor ) : <int> ) ; int incrX = tCalcx . getElementWiseStrideForTensor ( ) ; int incrY = ( tCalcy ! = null ? tCalcy . getElementWiseStrideForTensor ( ) : <int> ) ; int n = tCalcx . getTensorLength ( ) ; int nFirst = n / <int> ; RecursiveTask < Double > first = new CPUAccumulationTask ( op , threshold , nFirst , offsetX , offsetY , incrX , incrY , false ) ; first . fork ( ) ; int nSecond = n - nFirst ; int offsetX2 = offsetX + nFirst * incrX ; int offsetY2 = offsetY + nFirst * incrY ; RecursiveTask < Double > second = new CPUAccumulationTask ( op , threshold , nSecond , offsetX2 , offsetY2 , incrX , incrY , false ) ; second . fork ( ) ; double accum = op . combineSubResults ( first . join ( ) , second . join ( ) ) ; output . putScalar ( firstTensor , op . calculateFinalResult ( accum , tCalcx . getTensorLength ( ) ) ) ; } else { execute ( ) ; } } @Override public Void call ( ) { throw new UnsupportedOperationException ( <str> ) ; } private void execute ( ) { DataBuffer x = op . x ( ) . data ( ) ; DataBuffer y = ( op . y ( ) ! = null ? op . y ( ) . data ( ) : null ) ; int incrX = tCalcx . getElementWiseStrideForTensor ( ) ; int n = tCalcx . getTensorLength ( ) ; if ( y ! = null ) { int incrY = tCalcy . getElementWiseStrideForTensor ( ) ; for ( int tensorNum = firstTensor ; tensorNum < = lastTensor ; tensorNum + + ) { int offsetX = tCalcx . getOffsetForTensor ( tensorNum ) ; int offsetY = tCalcy . getOffsetForTensor ( tensorNum ) ; if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; float [ ] yf = ( float [ ] ) y . array ( ) ; float accum = op . zeroFloat ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i ] , yf [ offsetY + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i * incrX ] , yf [ offsetY + i * incrY ] ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } else { double [ ] xd = ( double [ ] ) x . array ( ) ; double [ ] yd = ( double [ ] ) y . array ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i ] , yd [ offsetY + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i * incrX ] , yd [ offsetY + i * incrY ] ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } } else { ByteBuffer nbbx = x . asNio ( ) ; ByteBuffer nbby = y . asNio ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = offsetX ; int byteOffsetY = offsetY ; FloatBuffer floatBufferX = nbbx . asFloatBuffer ( ) ; FloatBuffer floatBuffery = nbby . asFloatBuffer ( ) ; float accum = op . zeroFloat ( ) ; int idx = <int> ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + , idx + + ) { float fx = floatBufferX . get ( byteOffsetX + i ) ; float fy = floatBuffery . get ( byteOffsetY + i ) ; accum = op . update ( accum , op . op ( fx , fy ) ) ; } } else { for ( int i = <int> ; i < n ; i + + , idx + + ) { float fx = floatBufferX . get ( byteOffsetX + i * incrX ) ; float fy = floatBuffery . get ( byteOffsetY + i * incrY ) ; accum = op . update ( accum , op . op ( fx , fy ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } else { int byteOffsetX = offsetX ; int byteOffsetY = offsetY ; DoubleBuffer doubleBufferX = nbbx . asDoubleBuffer ( ) ; DoubleBuffer doubleBufferY = nbby . asDoubleBuffer ( ) ; double accum = op . zeroDouble ( ) ; int idx = <int> ; if ( incrX = = <int> & & incrY = = <int> ) { for ( int i = <int> ; i < n ; i + + , idx + + ) { double dx = doubleBufferX . get ( byteOffsetX + i ) ; double dy = doubleBufferY . get ( byteOffsetY + i ) ; accum = op . update ( accum , op . op ( dx , dy ) ) ; } } else { for ( int i = <int> ; i < n ; i + + , idx + + ) { double dx = doubleBufferX . get ( byteOffsetX + i * incrX ) ; double dy = doubleBufferY . get ( byteOffsetY + i * incrY ) ; accum = op . update ( accum , op . op ( dx , dy ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } } } } else { for ( int tensorNum = firstTensor ; tensorNum < = lastTensor ; tensorNum + + ) { int offsetX = tCalcx . getOffsetForTensor ( tensorNum ) ; if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; float accum = op . zeroFloat ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xf [ offsetX + i * incrX ] ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } else { double [ ] xd = ( double [ ] ) x . array ( ) ; double accum = op . zeroDouble ( ) ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i ] ) ) ; } } else { for ( int i = <int> ; i < n ; i + + ) { accum = op . update ( accum , op . op ( xd [ offsetX + i * incrX ] ) ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } } else { ByteBuffer nbbx = x . asNio ( ) ; FloatBuffer floatBuffer = nbbx . asFloatBuffer ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = offsetX ; float accum = op . zeroFloat ( ) ; int idx = <int> ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + , idx + + ) { float fx = op . op ( floatBuffer . get ( byteOffsetX + i ) ) ; accum = op . update ( accum , fx ) ; } } else { for ( int i = <int> ; i < n ; i + + , idx + + ) { float fx = op . op ( floatBuffer . get ( byteOffsetX + i * incrX ) ) ; accum = op . update ( accum , fx ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } else { int byteOffsetX = offsetX ; DoubleBuffer doubleBuffer = nbbx . asDoubleBuffer ( ) ; double accum = op . zeroDouble ( ) ; int idx = <int> ; if ( incrX = = <int> ) { for ( int i = <int> ; i < n ; i + + , idx + + ) { double dx = op . op ( doubleBuffer . get ( byteOffsetX + i ) ) ; accum = op . update ( accum , dx ) ; } } else { for ( int i = <int> ; i < n ; i + + , idx + + ) { double dx = op . op ( doubleBuffer . get ( byteOffsetX + i * incrX ) ) ; accum = op . update ( accum , dx ) ; } } output . putScalar ( tensorNum , op . calculateFinalResult ( accum , n ) ) ; } } } } } @Override public Void invokeBlocking ( ) { invokeAsync ( ) ; return blockUntilComplete ( ) ; } @Override public void invokeAsync ( ) { this . future = TaskExecutorProvider . getTaskExecutor ( ) . executeAsync ( this ) ; } @Override public Void blockUntilComplete ( ) { if ( future = = null ) { invokeAsync ( ) ; } try { future . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( subTasks ! = null ) { for ( Task < ? > t : subTasks ) { t . blockUntilComplete ( ) ; } } return null ; } } 
