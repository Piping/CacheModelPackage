package org . elasticsearch . search . aggregations . bucket . geogrid ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . util . LongArray ; import org . elasticsearch . common . util . LongHash ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . bucket . BucketsAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public class GeoHashGridAggregator extends BucketsAggregator { private final int requiredSize ; private final int shardSize ; private final GeoHashGridParser . GeoGridFactory . CellIdSource valuesSource ; private final LongHash bucketOrds ; public GeoHashGridAggregator ( String name , AggregatorFactories factories , GeoHashGridParser . GeoGridFactory . CellIdSource valuesSource , int requiredSize , int shardSize , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; this . requiredSize = requiredSize ; this . shardSize = shardSize ; bucketOrds = new LongHash ( <int> , aggregationContext . bigArrays ( ) ) ; } @Override public boolean needsScores ( ) { return ( valuesSource ! = null & & valuesSource . needsScores ( ) ) | | super . needsScores ( ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { final SortedNumericDocValues values = valuesSource . longValues ( ctx ) ; return new LeafBucketCollectorBase ( sub , null ) { @Override public void collect ( int doc , long bucket ) throws IOException { assert bucket = = <int> ; values . setDocument ( doc ) ; final int valuesCount = values . count ( ) ; long previous = Long . MAX_VALUE ; for ( int i = <int> ; i < valuesCount ; + + i ) { final long val = values . valueAt ( i ) ; if ( previous ! = val | | i = = <int> ) { long bucketOrdinal = bucketOrds . add ( val ) ; if ( bucketOrdinal < <int> ) { bucketOrdinal = - <int> - bucketOrdinal ; collectExistingBucket ( sub , doc , bucketOrdinal ) ; } else { collectBucket ( sub , doc , bucketOrdinal ) ; } previous = val ; } } } } ; } static class OrdinalBucket extends InternalGeoHashGrid . Bucket { long bucketOrd ; public OrdinalBucket ( ) { super ( <int> , <int> , ( InternalAggregations ) null ) ; } } @Override public InternalGeoHashGrid buildAggregation ( long owningBucketOrdinal ) throws IOException { assert owningBucketOrdinal = = <int> ; final int size = ( int ) Math . min ( bucketOrds . size ( ) , shardSize ) ; InternalGeoHashGrid . BucketPriorityQueue ordered = new InternalGeoHashGrid . BucketPriorityQueue ( size ) ; OrdinalBucket spare = null ; for ( long i = <int> ; i < bucketOrds . size ( ) ; i + + ) { if ( spare = = null ) { spare = new OrdinalBucket ( ) ; } spare . geohashAsLong = bucketOrds . get ( i ) ; spare . docCount = bucketDocCount ( i ) ; spare . bucketOrd = i ; spare = ( OrdinalBucket ) ordered . insertWithOverflow ( spare ) ; } final InternalGeoHashGrid . Bucket [ ] list = new InternalGeoHashGrid . Bucket [ ordered . size ( ) ] ; for ( int i = ordered . size ( ) - <int> ; i > = <int> ; - - i ) { final OrdinalBucket bucket = ( OrdinalBucket ) ordered . pop ( ) ; bucket . aggregations = bucketAggregations ( bucket . bucketOrd ) ; list [ i ] = bucket ; } return new InternalGeoHashGrid ( name , requiredSize , Arrays . asList ( list ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalGeoHashGrid buildEmptyAggregation ( ) { return new InternalGeoHashGrid ( name , requiredSize , Collections . < InternalGeoHashGrid . Bucket > emptyList ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public void doClose ( ) { Releasables . close ( bucketOrds ) ; } } 
