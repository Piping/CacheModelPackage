package com . badlogic . gdx . input ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . utils . TimeUtils ; import com . badlogic . gdx . utils . Timer ; import com . badlogic . gdx . utils . Timer . Task ; public class GestureDetector extends InputAdapter { final GestureListener listener ; private float tapSquareSize ; private long tapCountInterval ; private float longPressSeconds ; private long maxFlingDelay ; private boolean inTapSquare ; private int tapCount ; private long lastTapTime ; private float lastTapX , lastTapY ; private int lastTapButton , lastTapPointer ; boolean longPressFired ; private boolean pinching ; private boolean panning ; private final VelocityTracker tracker = new VelocityTracker ( ) ; private float tapSquareCenterX , tapSquareCenterY ; private long gestureStartTime ; Vector2 pointer1 = new Vector2 ( ) ; private final Vector2 pointer2 = new Vector2 ( ) ; private final Vector2 initialPointer1 = new Vector2 ( ) ; private final Vector2 initialPointer2 = new Vector2 ( ) ; private final Task longPressTask = new Task ( ) { @Override public void run ( ) { if ( ! longPressFired ) longPressFired = listener . longPress ( pointer1 . x , pointer1 . y ) ; } } ; public GestureDetector ( GestureListener listener ) { this ( <int> , <float> , <float> , <float> , listener ) ; } public GestureDetector ( float halfTapSquareSize , float tapCountInterval , float longPressDuration , float maxFlingDelay , GestureListener listener ) { this . tapSquareSize = halfTapSquareSize ; this . tapCountInterval = ( long ) ( tapCountInterval * <int> ) ; this . longPressSeconds = longPressDuration ; this . maxFlingDelay = ( long ) ( maxFlingDelay * <int> ) ; this . listener = listener ; } @Override public boolean touchDown ( int x , int y , int pointer , int button ) { return touchDown ( ( float ) x , ( float ) y , pointer , button ) ; } public boolean touchDown ( float x , float y , int pointer , int button ) { if ( pointer > <int> ) return false ; if ( pointer = = <int> ) { pointer1 . set ( x , y ) ; gestureStartTime = Gdx . input . getCurrentEventTime ( ) ; tracker . start ( x , y , gestureStartTime ) ; if ( Gdx . input . isTouched ( <int> ) ) { inTapSquare = false ; pinching = true ; initialPointer1 . set ( pointer1 ) ; initialPointer2 . set ( pointer2 ) ; longPressTask . cancel ( ) ; } else { inTapSquare = true ; pinching = false ; longPressFired = false ; tapSquareCenterX = x ; tapSquareCenterY = y ; if ( ! longPressTask . isScheduled ( ) ) Timer . schedule ( longPressTask , longPressSeconds ) ; } } else { pointer2 . set ( x , y ) ; inTapSquare = false ; pinching = true ; initialPointer1 . set ( pointer1 ) ; initialPointer2 . set ( pointer2 ) ; longPressTask . cancel ( ) ; } return listener . touchDown ( x , y , pointer , button ) ; } @Override public boolean touchDragged ( int x , int y , int pointer ) { return touchDragged ( ( float ) x , ( float ) y , pointer ) ; } public boolean touchDragged ( float x , float y , int pointer ) { if ( pointer > <int> ) return false ; if ( longPressFired ) return false ; if ( pointer = = <int> ) pointer1 . set ( x , y ) ; else pointer2 . set ( x , y ) ; if ( pinching ) { if ( listener ! = null ) { boolean result = listener . pinch ( initialPointer1 , initialPointer2 , pointer1 , pointer2 ) ; return listener . zoom ( initialPointer1 . dst ( initialPointer2 ) , pointer1 . dst ( pointer2 ) ) | | result ; } return false ; } tracker . update ( x , y , Gdx . input . getCurrentEventTime ( ) ) ; if ( inTapSquare & & ! isWithinTapSquare ( x , y , tapSquareCenterX , tapSquareCenterY ) ) { longPressTask . cancel ( ) ; inTapSquare = false ; } if ( ! inTapSquare ) { panning = true ; return listener . pan ( x , y , tracker . deltaX , tracker . deltaY ) ; } return false ; } @Override public boolean touchUp ( int x , int y , int pointer , int button ) { return touchUp ( ( float ) x , ( float ) y , pointer , button ) ; } public boolean touchUp ( float x , float y , int pointer , int button ) { if ( pointer > <int> ) return false ; if ( inTapSquare & & ! isWithinTapSquare ( x , y , tapSquareCenterX , tapSquareCenterY ) ) inTapSquare = false ; boolean wasPanning = panning ; panning = false ; longPressTask . cancel ( ) ; if ( longPressFired ) return false ; if ( inTapSquare ) { if ( lastTapButton ! = button | | lastTapPointer ! = pointer | | TimeUtils . nanoTime ( ) - lastTapTime > tapCountInterval | | ! isWithinTapSquare ( x , y , lastTapX , lastTapY ) ) tapCount = <int> ; tapCount + + ; lastTapTime = TimeUtils . nanoTime ( ) ; lastTapX = x ; lastTapY = y ; lastTapButton = button ; lastTapPointer = pointer ; gestureStartTime = <int> ; return listener . tap ( x , y , tapCount , button ) ; } if ( pinching ) { pinching = false ; panning = true ; if ( pointer = = <int> ) { tracker . start ( pointer2 . x , pointer2 . y , Gdx . input . getCurrentEventTime ( ) ) ; } else { tracker . start ( pointer1 . x , pointer1 . y , Gdx . input . getCurrentEventTime ( ) ) ; } return false ; } boolean handled = false ; if ( wasPanning & & ! panning ) handled = listener . panStop ( x , y , pointer , button ) ; gestureStartTime = <int> ; long time = Gdx . input . getCurrentEventTime ( ) ; if ( time - tracker . lastTime < maxFlingDelay ) { tracker . update ( x , y , time ) ; handled = listener . fling ( tracker . getVelocityX ( ) , tracker . getVelocityY ( ) , button ) | | handled ; } return handled ; } public void cancel ( ) { longPressTask . cancel ( ) ; longPressFired = true ; } public boolean isLongPressed ( ) { return isLongPressed ( longPressSeconds ) ; } public boolean isLongPressed ( float duration ) { if ( gestureStartTime = = <int> ) return false ; return TimeUtils . nanoTime ( ) - gestureStartTime > ( long ) ( duration * <int> ) ; } public boolean isPanning ( ) { return panning ; } public void reset ( ) { gestureStartTime = <int> ; panning = false ; inTapSquare = false ; } private boolean isWithinTapSquare ( float x , float y , float centerX , float centerY ) { return Math . abs ( x - centerX ) < tapSquareSize & & Math . abs ( y - centerY ) < tapSquareSize ; } public void invalidateTapSquare ( ) { inTapSquare = false ; } public void setTapSquareSize ( float halfTapSquareSize ) { this . tapSquareSize = halfTapSquareSize ; } public void setTapCountInterval ( float tapCountInterval ) { this . tapCountInterval = ( long ) ( tapCountInterval * <int> ) ; } public void setLongPressSeconds ( float longPressSeconds ) { this . longPressSeconds = longPressSeconds ; } public void setMaxFlingDelay ( long maxFlingDelay ) { this . maxFlingDelay = maxFlingDelay ; } public static interface GestureListener { public boolean touchDown ( float x , float y , int pointer , int button ) ; public boolean tap ( float x , float y , int count , int button ) ; public boolean longPress ( float x , float y ) ; public boolean fling ( float velocityX , float velocityY , int button ) ; public boolean pan ( float x , float y , float deltaX , float deltaY ) ; public boolean panStop ( float x , float y , int pointer , int button ) ; public boolean zoom ( float initialDistance , float distance ) ; public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) ; } public static class GestureAdapter implements GestureListener { @Override public boolean touchDown ( float x , float y , int pointer , int button ) { return false ; } @Override public boolean tap ( float x , float y , int count , int button ) { return false ; } @Override public boolean longPress ( float x , float y ) { return false ; } @Override public boolean fling ( float velocityX , float velocityY , int button ) { return false ; } @Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { return false ; } @Override public boolean panStop ( float x , float y , int pointer , int button ) { return false ; } @Override public boolean zoom ( float initialDistance , float distance ) { return false ; } @Override public boolean pinch ( Vector2 initialPointer1 , Vector2 initialPointer2 , Vector2 pointer1 , Vector2 pointer2 ) { return false ; } } static class VelocityTracker { int sampleSize = <int> ; float lastX , lastY ; float deltaX , deltaY ; long lastTime ; int numSamples ; float [ ] meanX = new float [ sampleSize ] ; float [ ] meanY = new float [ sampleSize ] ; long [ ] meanTime = new long [ sampleSize ] ; public void start ( float x , float y , long timeStamp ) { lastX = x ; lastY = y ; deltaX = <int> ; deltaY = <int> ; numSamples = <int> ; for ( int i = <int> ; i < sampleSize ; i + + ) { meanX [ i ] = <int> ; meanY [ i ] = <int> ; meanTime [ i ] = <int> ; } lastTime = timeStamp ; } public void update ( float x , float y , long timeStamp ) { long currTime = timeStamp ; deltaX = x - lastX ; deltaY = y - lastY ; lastX = x ; lastY = y ; long deltaTime = currTime - lastTime ; lastTime = currTime ; int index = numSamples % sampleSize ; meanX [ index ] = deltaX ; meanY [ index ] = deltaY ; meanTime [ index ] = deltaTime ; numSamples + + ; } public float getVelocityX ( ) { float meanX = getAverage ( this . meanX , numSamples ) ; float meanTime = getAverage ( this . meanTime , numSamples ) / <float> ; if ( meanTime = = <int> ) return <int> ; return meanX / meanTime ; } public float getVelocityY ( ) { float meanY = getAverage ( this . meanY , numSamples ) ; float meanTime = getAverage ( this . meanTime , numSamples ) / <float> ; if ( meanTime = = <int> ) return <int> ; return meanY / meanTime ; } private float getAverage ( float [ ] values , int numSamples ) { numSamples = Math . min ( sampleSize , numSamples ) ; float sum = <int> ; for ( int i = <int> ; i < numSamples ; i + + ) { sum + = values [ i ] ; } return sum / numSamples ; } private long getAverage ( long [ ] values , int numSamples ) { numSamples = Math . min ( sampleSize , numSamples ) ; long sum = <int> ; for ( int i = <int> ; i < numSamples ; i + + ) { sum + = values [ i ] ; } if ( numSamples = = <int> ) return <int> ; return sum / numSamples ; } private float getSum ( float [ ] values , int numSamples ) { numSamples = Math . min ( sampleSize , numSamples ) ; float sum = <int> ; for ( int i = <int> ; i < numSamples ; i + + ) { sum + = values [ i ] ; } if ( numSamples = = <int> ) return <int> ; return sum ; } } } 
