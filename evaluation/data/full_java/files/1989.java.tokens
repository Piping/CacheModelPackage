package org . nd4j . linalg . api . iter ; import org . apache . commons . math3 . util . Pair ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . api . shape . Shape ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public class NdIndexIterator implements Iterator < int [ ] > { private int length = - <int> ; private int i = <int> ; private int [ ] shape ; private char order = <str> ; private boolean cache = false ; private static Map < Pair < int [ ] , Character > , LinearIndexLookup > lookupMap = new HashMap < > ( ) ; private LinearIndexLookup lookup ; public NdIndexIterator ( int . . . shape ) { this ( <str> , shape ) ; this . cache = false ; } public NdIndexIterator ( char order , boolean cache , int . . . shape ) { this . shape = ArrayUtil . copy ( shape ) ; this . length = ArrayUtil . prod ( shape ) ; this . order = order ; this . cache = cache ; if ( this . cache ) { LinearIndexLookup lookup = lookupMap . get ( new Pair < > ( shape , order ) ) ; if ( lookup = = null ) { lookup = new LinearIndexLookup ( shape , order ) ; for ( int i = <int> ; i < length ; i + + ) { lookup . lookup ( i ) ; } lookupMap . put ( new Pair < > ( shape , order ) , lookup ) ; this . lookup = lookup ; } else { this . lookup = lookupMap . get ( new Pair < > ( shape , order ) ) ; } } } public NdIndexIterator ( char order , int . . . shape ) { this ( order , false , shape ) ; } @Override public boolean hasNext ( ) { return i < length ; } @Override public int [ ] next ( ) { if ( lookup ! = null ) return lookup . lookup ( i + + ) ; switch ( order ) { case <str> : return Shape . ind2subC ( shape , i + + ) ; case <str> : return Shape . ind2sub ( shape , i + + ) ; default : throw new IllegalArgumentException ( <str> + order ) ; } } @Override public void remove ( ) { } } 
