package org . gradle . wrapper ; import java . io . * ; import java . net . URI ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; import java . security . MessageDigest ; public class Install { public static final String DEFAULT_DISTRIBUTION_PATH = <str> ; private final Logger logger ; private final IDownload download ; private final PathAssembler pathAssembler ; private final ExclusiveFileAccessManager exclusiveFileAccessManager = new ExclusiveFileAccessManager ( <int> , <int> ) ; public Install ( Logger logger , IDownload download , PathAssembler pathAssembler ) { this . logger = logger ; this . download = download ; this . pathAssembler = pathAssembler ; } public File createDist ( final WrapperConfiguration configuration ) throws Exception { final URI distributionUrl = configuration . getDistribution ( ) ; final String distributionSha256Sum = configuration . getDistributionSha256Sum ( ) ; final PathAssembler . LocalDistribution localDistribution = pathAssembler . getDistribution ( configuration ) ; final File distDir = localDistribution . getDistributionDir ( ) ; final File localZipFile = localDistribution . getZipFile ( ) ; return exclusiveFileAccessManager . access ( localZipFile , new Callable < File > ( ) { public File call ( ) throws Exception { final File markerFile = new File ( localZipFile . getParentFile ( ) , localZipFile . getName ( ) + <str> ) ; if ( distDir . isDirectory ( ) & & markerFile . isFile ( ) ) { return getAndVerifyDistributionRoot ( distDir , distDir . getAbsolutePath ( ) ) ; } boolean needsDownload = ! localZipFile . isFile ( ) ; if ( needsDownload ) { File tmpZipFile = new File ( localZipFile . getParentFile ( ) , localZipFile . getName ( ) + <str> ) ; tmpZipFile . delete ( ) ; logger . log ( <str> + distributionUrl ) ; download . download ( distributionUrl , tmpZipFile ) ; tmpZipFile . renameTo ( localZipFile ) ; } List < File > topLevelDirs = listDirs ( distDir ) ; for ( File dir : topLevelDirs ) { logger . log ( <str> + dir . getAbsolutePath ( ) ) ; deleteDir ( dir ) ; } verifyDownloadChecksum ( configuration . getDistribution ( ) . toString ( ) , localZipFile , distributionSha256Sum ) ; logger . log ( <str> + localZipFile . getAbsolutePath ( ) + <str> + distDir . getAbsolutePath ( ) ) ; unzip ( localZipFile , distDir ) ; File root = getAndVerifyDistributionRoot ( distDir , distributionUrl . toString ( ) ) ; setExecutablePermissions ( root ) ; markerFile . createNewFile ( ) ; return root ; } } ) ; } private String calculateSha256Sum ( File file ) throws Exception { MessageDigest md = MessageDigest . getInstance ( <str> ) ; InputStream fis = new FileInputStream ( file ) ; int n = <int> ; byte [ ] buffer = new byte [ <int> ] ; while ( n ! = - <int> ) { n = fis . read ( buffer ) ; if ( n > <int> ) { md . update ( buffer , <int> , n ) ; } } byte byteData [ ] = md . digest ( ) ; StringBuffer hexString = new StringBuffer ( ) ; for ( int i = <int> ; i < byteData . length ; i + + ) { String hex = Integer . toHexString ( <hex> & byteData [ i ] ) ; if ( hex . length ( ) = = <int> ) { hexString . append ( <str> ) ; } hexString . append ( hex ) ; } return hexString . toString ( ) ; } private File getAndVerifyDistributionRoot ( File distDir , String distributionDescription ) throws Exception { List < File > dirs = listDirs ( distDir ) ; if ( dirs . isEmpty ( ) ) { throw new RuntimeException ( String . format ( <str> , distributionDescription ) ) ; } if ( dirs . size ( ) ! = <int> ) { throw new RuntimeException ( String . format ( <str> , distributionDescription ) ) ; } return dirs . get ( <int> ) ; } private void verifyDownloadChecksum ( String sourceUrl , File localZipFile , String expectedSum ) throws Exception { if ( expectedSum ! = null ) { String actualSum = calculateSha256Sum ( localZipFile ) ; if ( ! expectedSum . equals ( actualSum ) ) { localZipFile . delete ( ) ; String message = String . format ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> , sourceUrl , localZipFile . getAbsolutePath ( ) , expectedSum , actualSum ) ; System . err . println ( message ) ; System . exit ( <int> ) ; } } } private List < File > listDirs ( File distDir ) { List < File > dirs = new ArrayList < File > ( ) ; if ( distDir . exists ( ) ) { for ( File file : distDir . listFiles ( ) ) { if ( file . isDirectory ( ) ) { dirs . add ( file ) ; } } } return dirs ; } private void setExecutablePermissions ( File gradleHome ) { if ( isWindows ( ) ) { return ; } File gradleCommand = new File ( gradleHome , <str> ) ; String errorMessage = null ; try { ProcessBuilder pb = new ProcessBuilder ( <str> , <str> , gradleCommand . getCanonicalPath ( ) ) ; Process p = pb . start ( ) ; if ( p . waitFor ( ) = = <int> ) { logger . log ( <str> + gradleCommand . getAbsolutePath ( ) ) ; } else { BufferedReader is = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; Formatter stdout = new Formatter ( ) ; String line ; while ( ( line = is . readLine ( ) ) ! = null ) { stdout . format ( <str> , line ) ; } errorMessage = stdout . toString ( ) ; } } catch ( IOException e ) { errorMessage = e . getMessage ( ) ; } catch ( InterruptedException e ) { errorMessage = e . getMessage ( ) ; } if ( errorMessage ! = null ) { logger . log ( <str> + gradleCommand . getAbsolutePath ( ) ) ; logger . log ( <str> ) ; } } private boolean isWindows ( ) { String osName = System . getProperty ( <str> ) . toLowerCase ( Locale . US ) ; if ( osName . indexOf ( <str> ) > - <int> ) { return true ; } return false ; } private boolean deleteDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = <int> ; i < children . length ; i + + ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return dir . delete ( ) ; } private void unzip ( File zip , File dest ) throws IOException { Enumeration entries ; ZipFile zipFile = new ZipFile ( zip ) ; try { entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) entries . nextElement ( ) ; if ( entry . isDirectory ( ) ) { ( new File ( dest , entry . getName ( ) ) ) . mkdirs ( ) ; continue ; } OutputStream outputStream = new BufferedOutputStream ( new FileOutputStream ( new File ( dest , entry . getName ( ) ) ) ) ; try { copyInputStream ( zipFile . getInputStream ( entry ) , outputStream ) ; } finally { outputStream . close ( ) ; } } } finally { zipFile . close ( ) ; } } private void copyInputStream ( InputStream in , OutputStream out ) throws IOException { byte [ ] buffer = new byte [ <int> ] ; int len ; while ( ( len = in . read ( buffer ) ) > = <int> ) { out . write ( buffer , <int> , len ) ; } in . close ( ) ; out . close ( ) ; } } 
