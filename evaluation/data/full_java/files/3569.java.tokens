package org . eclipse . debug . core ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . MultiStatus ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IDisconnect ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . ISourceLocator ; import org . eclipse . debug . internal . core . DebugCoreMessages ; import org . eclipse . debug . internal . core . LaunchManager ; public class Launch extends PlatformObject implements ILaunch , IDisconnect , ILaunchListener , ILaunchConfigurationListener , IDebugEventSetListener { private List < IDebugTarget > fTargets = new ArrayList < IDebugTarget > ( ) ; private ILaunchConfiguration fConfiguration = null ; private List < IProcess > fProcesses = new ArrayList < IProcess > ( ) ; private ISourceLocator fLocator = null ; private String fMode ; private HashMap < String , String > fAttributes ; private boolean fSuppressChange = true ; public Launch ( ILaunchConfiguration launchConfiguration , String mode , ISourceLocator locator ) { fConfiguration = launchConfiguration ; setSourceLocator ( locator ) ; fMode = mode ; fSuppressChange = false ; getLaunchManager ( ) . addLaunchListener ( this ) ; getLaunchManager ( ) . addLaunchConfigurationListener ( this ) ; } private void addEventListener ( ) { DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; } private void removeEventListener ( ) { DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; } @Override public boolean canTerminate ( ) { for ( IProcess process : getProcesses0 ( ) ) { if ( process . canTerminate ( ) ) { return true ; } } for ( IDebugTarget target : getDebugTargets0 ( ) ) { if ( target . canTerminate ( ) | | target . canDisconnect ( ) ) { return true ; } } return false ; } @Override public Object [ ] getChildren ( ) { ArrayList < Object > children = new ArrayList < Object > ( getDebugTargets0 ( ) ) ; children . addAll ( getProcesses0 ( ) ) ; return children . toArray ( ) ; } @Override public IDebugTarget getDebugTarget ( ) { if ( ! getDebugTargets0 ( ) . isEmpty ( ) ) { return getDebugTargets0 ( ) . get ( <int> ) ; } return null ; } @Override public IProcess [ ] getProcesses ( ) { return getProcesses0 ( ) . toArray ( new IProcess [ getProcesses0 ( ) . size ( ) ] ) ; } protected List < IProcess > getProcesses0 ( ) { return fProcesses ; } @Override public ISourceLocator getSourceLocator ( ) { return fLocator ; } @Override public void setSourceLocator ( ISourceLocator sourceLocator ) { fLocator = sourceLocator ; } @Override public boolean isTerminated ( ) { if ( getProcesses0 ( ) . isEmpty ( ) & & getDebugTargets0 ( ) . isEmpty ( ) ) { return false ; } for ( IProcess process : getProcesses0 ( ) ) { if ( ! process . isTerminated ( ) ) { return false ; } } for ( IDebugTarget target : getDebugTargets0 ( ) ) { if ( ! ( target . isTerminated ( ) | | target . isDisconnected ( ) ) ) { return false ; } } return true ; } @Override public void terminate ( ) throws DebugException { MultiStatus status = new MultiStatus ( DebugPlugin . getUniqueIdentifier ( ) , DebugException . REQUEST_FAILED , DebugCoreMessages . Launch_terminate_failed , null ) ; IDebugTarget [ ] targets = getDebugTargets ( ) ; for ( int i = <int> ; i < targets . length ; i + + ) { IDebugTarget target = targets [ i ] ; if ( target ! = null ) { if ( target . canTerminate ( ) ) { try { target . terminate ( ) ; } catch ( DebugException e ) { status . merge ( e . getStatus ( ) ) ; } } else { if ( target . canDisconnect ( ) ) { try { target . disconnect ( ) ; } catch ( DebugException de ) { status . merge ( de . getStatus ( ) ) ; } } } } } IProcess [ ] processes = getProcesses ( ) ; for ( int i = <int> ; i < processes . length ; i + + ) { IProcess process = processes [ i ] ; if ( process . canTerminate ( ) ) { try { process . terminate ( ) ; } catch ( DebugException e ) { status . merge ( e . getStatus ( ) ) ; } } } if ( status . isOK ( ) ) { return ; } IStatus [ ] children = status . getChildren ( ) ; if ( children . length = = <int> ) { throw new DebugException ( children [ <int> ] ) ; } throw new DebugException ( status ) ; } @Override public String getLaunchMode ( ) { return fMode ; } @Override public ILaunchConfiguration getLaunchConfiguration ( ) { return fConfiguration ; } @Override public void setAttribute ( String key , String value ) { if ( fAttributes = = null ) { fAttributes = new HashMap < String , String > ( <int> ) ; } fAttributes . put ( key , value ) ; } @Override public String getAttribute ( String key ) { if ( fAttributes = = null ) { return null ; } return fAttributes . get ( key ) ; } @Override public IDebugTarget [ ] getDebugTargets ( ) { return fTargets . toArray ( new IDebugTarget [ fTargets . size ( ) ] ) ; } protected List < IDebugTarget > getDebugTargets0 ( ) { return fTargets ; } @Override public void addDebugTarget ( IDebugTarget target ) { if ( target ! = null ) { if ( ! getDebugTargets0 ( ) . contains ( target ) ) { addEventListener ( ) ; getDebugTargets0 ( ) . add ( target ) ; fireChanged ( ) ; } } } @Override public void removeDebugTarget ( IDebugTarget target ) { if ( target ! = null ) { if ( getDebugTargets0 ( ) . remove ( target ) ) { fireChanged ( ) ; } } } @Override public void addProcess ( IProcess process ) { if ( process ! = null ) { if ( ! getProcesses0 ( ) . contains ( process ) ) { addEventListener ( ) ; getProcesses0 ( ) . add ( process ) ; fireChanged ( ) ; } } } @Override public void removeProcess ( IProcess process ) { if ( process ! = null ) { if ( getProcesses0 ( ) . remove ( process ) ) { fireChanged ( ) ; } } } protected void addProcesses ( IProcess [ ] processes ) { if ( processes ! = null ) { for ( int i = <int> ; i < processes . length ; i + + ) { addProcess ( processes [ i ] ) ; fireChanged ( ) ; } } } protected void fireChanged ( ) { if ( ! fSuppressChange ) { ( ( LaunchManager ) getLaunchManager ( ) ) . fireUpdate ( this , LaunchManager . CHANGED ) ; ( ( LaunchManager ) getLaunchManager ( ) ) . fireUpdate ( new ILaunch [ ] { this } , LaunchManager . CHANGED ) ; } } protected void fireTerminate ( ) { if ( ! fSuppressChange ) { ( ( LaunchManager ) getLaunchManager ( ) ) . fireUpdate ( this , LaunchManager . TERMINATE ) ; ( ( LaunchManager ) getLaunchManager ( ) ) . fireUpdate ( new ILaunch [ ] { this } , LaunchManager . TERMINATE ) ; } removeEventListener ( ) ; } @Override public boolean hasChildren ( ) { return getProcesses0 ( ) . size ( ) > <int> | | ( getDebugTargets0 ( ) . size ( ) > <int> ) ; } @Override public boolean canDisconnect ( ) { for ( IProcess process : getProcesses0 ( ) ) { if ( process instanceof IDisconnect ) { if ( ( ( IDisconnect ) process ) . canDisconnect ( ) ) { return true ; } } } for ( IDebugTarget target : getDebugTargets0 ( ) ) { if ( target . canDisconnect ( ) ) { return true ; } } return false ; } @Override public void disconnect ( ) throws DebugException { for ( IProcess process : getProcesses0 ( ) ) { if ( process instanceof IDisconnect ) { IDisconnect dis = ( IDisconnect ) process ; if ( dis . canDisconnect ( ) ) { dis . disconnect ( ) ; } } } for ( IDebugTarget target : getDebugTargets0 ( ) ) { if ( target . canDisconnect ( ) ) { target . disconnect ( ) ; } } } @Override public boolean isDisconnected ( ) { for ( IProcess process : getProcesses0 ( ) ) { if ( process instanceof IDisconnect ) { if ( ! ( ( IDisconnect ) process ) . isDisconnected ( ) ) { return false ; } } } for ( IDebugTarget target : getDebugTargets0 ( ) ) { if ( ! target . isDisconnected ( ) ) { return false ; } } return hasChildren ( ) ; } @Override public void launchRemoved ( ILaunch launch ) { if ( this . equals ( launch ) ) { removeEventListener ( ) ; getLaunchManager ( ) . removeLaunchListener ( this ) ; getLaunchManager ( ) . removeLaunchConfigurationListener ( this ) ; } } protected ILaunchManager getLaunchManager ( ) { return DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; } @Override public void launchAdded ( ILaunch launch ) { } @Override public void launchChanged ( ILaunch launch ) { } @Override public void launchConfigurationAdded ( ILaunchConfiguration configuration ) { ILaunchConfiguration from = getLaunchManager ( ) . getMovedFrom ( configuration ) ; if ( from ! = null & & from . equals ( getLaunchConfiguration ( ) ) ) { fConfiguration = configuration ; fireChanged ( ) ; } } @Override public void launchConfigurationChanged ( ILaunchConfiguration configuration ) { } @Override public void launchConfigurationRemoved ( ILaunchConfiguration configuration ) { if ( configuration . equals ( getLaunchConfiguration ( ) ) ) { if ( getLaunchManager ( ) . getMovedTo ( configuration ) = = null ) { fConfiguration = null ; fireChanged ( ) ; } } } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) { DebugEvent event = events [ i ] ; if ( event . getKind ( ) = = DebugEvent . TERMINATE ) { Object object = event . getSource ( ) ; ILaunch launch = null ; if ( object instanceof IProcess ) { launch = ( ( IProcess ) object ) . getLaunch ( ) ; } else if ( object instanceof IDebugTarget ) { launch = ( ( IDebugTarget ) object ) . getLaunch ( ) ; } if ( this . equals ( launch ) ) { if ( isTerminated ( ) ) { fireTerminate ( ) ; } } } } } @SuppressWarnings ( <str> ) @Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter . equals ( ILaunch . class ) ) { return ( T ) this ; } if ( adapter . equals ( ILaunchConfiguration . class ) ) { return ( T ) getLaunchConfiguration ( ) ; } return super . getAdapter ( adapter ) ; } } 
