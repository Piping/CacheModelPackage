package org . apache . cassandra . utils ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import com . google . common . collect . Maps ; import com . google . common . util . concurrent . Uninterruptibles ; import org . junit . Test ; import com . clearspring . analytics . hash . MurmurHash ; import com . clearspring . analytics . stream . Counter ; import junit . framework . Assert ; import org . apache . cassandra . utils . TopKSampler . SamplerResult ; public class TopKSamplerTest { @Test public void testSamplerSingleInsertionsEqualMulti ( ) throws TimeoutException { TopKSampler < String > sampler = new TopKSampler < String > ( ) ; sampler . beginSampling ( <int> ) ; insert ( sampler ) ; waitForEmpty ( <int> ) ; SamplerResult single = sampler . finishSampling ( <int> ) ; TopKSampler < String > sampler2 = new TopKSampler < String > ( ) ; sampler2 . beginSampling ( <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) { String key = <str> + i ; sampler2 . addSample ( key , MurmurHash . hash64 ( key ) , i ) ; } waitForEmpty ( <int> ) ; Assert . assertEquals ( countMap ( single . topK ) , countMap ( sampler2 . finishSampling ( <int> ) . topK ) ) ; Assert . assertEquals ( sampler2 . hll . cardinality ( ) , <int> ) ; Assert . assertEquals ( sampler . hll . cardinality ( ) , sampler2 . hll . cardinality ( ) ) ; } @Test public void testSamplerOutOfOrder ( ) throws TimeoutException { TopKSampler < String > sampler = new TopKSampler < String > ( ) ; sampler . beginSampling ( <int> ) ; insert ( sampler ) ; waitForEmpty ( <int> ) ; SamplerResult single = sampler . finishSampling ( <int> ) ; single = sampler . finishSampling ( <int> ) ; } @Test public void testMultithreadedAccess ( ) throws Exception { final AtomicBoolean running = new AtomicBoolean ( true ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final TopKSampler < String > sampler = new TopKSampler < String > ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { try { while ( running . get ( ) ) { insert ( sampler ) ; } } finally { latch . countDown ( ) ; } } } , <str> ) . start ( ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { sampler . beginSampling ( i ) ; sampler . finishSampling ( i ) ; } for ( int i = <int> ; i < <int> ; i + + ) { sampler . beginSampling ( i ) ; Thread . sleep ( <int> ) ; sampler . finishSampling ( i ) ; } running . set ( false ) ; latch . await ( <int> , TimeUnit . SECONDS ) ; waitForEmpty ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { sampler . beginSampling ( i ) ; Thread . sleep ( i ) ; sampler . finishSampling ( i ) ; } } finally { running . set ( false ) ; } } private void insert ( TopKSampler < String > sampler ) { for ( int i = <int> ; i < = <int> ; i + + ) { for ( int j = <int> ; j < i ; j + + ) { String key = <str> + i ; sampler . addSample ( key , MurmurHash . hash64 ( key ) , <int> ) ; } } } private void waitForEmpty ( int timeoutMs ) throws TimeoutException { int timeout = <int> ; while ( ! TopKSampler . samplerExecutor . getQueue ( ) . isEmpty ( ) ) { timeout + + ; Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; if ( timeout * <int> > timeoutMs ) { throw new TimeoutException ( <str> ) ; } } } private < T > Map < T , Long > countMap ( List < Counter < T > > target ) { Map < T , Long > counts = Maps . newHashMap ( ) ; for ( Counter < T > counter : target ) { counts . put ( counter . getItem ( ) , counter . getCount ( ) ) ; } return counts ; } } 
