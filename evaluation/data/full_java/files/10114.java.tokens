package com . google . common . testing ; import static com . google . common . base . Predicates . and ; import static com . google . common . base . Predicates . not ; import static com . google . common . testing . AbstractPackageSanityTests . Chopper . suffix ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Optional ; import com . google . common . base . Predicate ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import com . google . common . collect . Sets ; import com . google . common . reflect . ClassPath ; import com . google . common . testing . NullPointerTester . Visibility ; import com . google . j2objc . annotations . J2ObjCIncompatible ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import org . junit . Test ; import java . io . IOException ; import java . io . Serializable ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Locale ; import java . util . TreeMap ; import java . util . logging . Level ; import java . util . logging . Logger ; @Beta @J2ObjCIncompatible public abstract class AbstractPackageSanityTests extends TestCase { public static final Predicate < Class < ? > > UNDERSCORE_IN_NAME = new Predicate < Class < ? > > ( ) { @Override public boolean apply ( Class < ? > c ) { return c . getSimpleName ( ) . contains ( <str> ) ; } } ; private static final ImmutableList < String > NULL_TEST_METHOD_NAMES = ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; private static final ImmutableList < String > SERIALIZABLE_TEST_METHOD_NAMES = ImmutableList . of ( <str> , <str> , <str> , <str> ) ; private static final ImmutableList < String > EQUALS_TEST_METHOD_NAMES = ImmutableList . of ( <str> , <str> , <str> , <str> , <str> ) ; private static final Chopper TEST_SUFFIX = suffix ( <str> ) . or ( suffix ( <str> ) ) . or ( suffix ( <str> ) ) . or ( suffix ( <str> ) ) ; private final Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; private final ClassSanityTester tester = new ClassSanityTester ( ) ; private Visibility visibility = Visibility . PACKAGE ; private Predicate < Class < ? > > classFilter = new Predicate < Class < ? > > ( ) { @Override public boolean apply ( Class < ? > cls ) { return visibility . isVisible ( cls . getModifiers ( ) ) ; } } ; protected final void publicApiOnly ( ) { visibility = Visibility . PUBLIC ; } @Test public void testSerializable ( ) throws Exception { for ( Class < ? > classToTest : findClassesToTest ( loadClassesInPackage ( ) , SERIALIZABLE_TEST_METHOD_NAMES ) ) { if ( Serializable . class . isAssignableFrom ( classToTest ) ) { try { Object instance = tester . instantiate ( classToTest ) ; if ( instance ! = null ) { if ( isEqualsDefined ( classToTest ) ) { SerializableTester . reserializeAndAssert ( instance ) ; } else { SerializableTester . reserialize ( instance ) ; } } } catch ( Throwable e ) { throw sanityError ( classToTest , SERIALIZABLE_TEST_METHOD_NAMES , <str> , e ) ; } } } } @Test public void testNulls ( ) throws Exception { for ( Class < ? > classToTest : findClassesToTest ( loadClassesInPackage ( ) , NULL_TEST_METHOD_NAMES ) ) { try { tester . doTestNulls ( classToTest , visibility ) ; } catch ( Throwable e ) { throw sanityError ( classToTest , NULL_TEST_METHOD_NAMES , <str> , e ) ; } } } @Test public void testEquals ( ) throws Exception { for ( Class < ? > classToTest : findClassesToTest ( loadClassesInPackage ( ) , EQUALS_TEST_METHOD_NAMES ) ) { if ( ! classToTest . isEnum ( ) & & isEqualsDefined ( classToTest ) ) { try { tester . doTestEquals ( classToTest ) ; } catch ( Throwable e ) { throw sanityError ( classToTest , EQUALS_TEST_METHOD_NAMES , <str> , e ) ; } } } } protected final < T > void setDefault ( Class < T > type , T value ) { tester . setDefault ( type , value ) ; } protected final < T > void setDistinctValues ( Class < T > type , T value1 , T value2 ) { tester . setDistinctValues ( type , value1 , value2 ) ; } protected final void ignoreClasses ( Predicate < ? super Class < ? > > condition ) { this . classFilter = and ( this . classFilter , not ( condition ) ) ; } private static AssertionFailedError sanityError ( Class < ? > cls , List < String > explicitTestNames , String description , Throwable e ) { String message = String . format ( Locale . ROOT , <str> + <str> , description , cls , explicitTestNames . get ( <int> ) , cls . getName ( ) ) ; AssertionFailedError error = new AssertionFailedError ( message ) ; error . initCause ( e ) ; return error ; } @VisibleForTesting List < Class < ? > > findClassesToTest ( Iterable < ? extends Class < ? > > classes , Iterable < String > explicitTestNames ) { TreeMap < String , Class < ? > > classMap = Maps . newTreeMap ( ) ; for ( Class < ? > cls : classes ) { classMap . put ( cls . getName ( ) , cls ) ; } Multimap < Class < ? > , Class < ? > > testClasses = HashMultimap . create ( ) ; LinkedHashSet < Class < ? > > candidateClasses = Sets . newLinkedHashSet ( ) ; for ( Class < ? > cls : classes ) { Optional < String > testedClassName = TEST_SUFFIX . chop ( cls . getName ( ) ) ; if ( testedClassName . isPresent ( ) ) { Class < ? > testedClass = classMap . get ( testedClassName . get ( ) ) ; if ( testedClass ! = null ) { testClasses . put ( testedClass , cls ) ; } } else { candidateClasses . add ( cls ) ; } } List < Class < ? > > result = Lists . newArrayList ( ) ; NEXT_CANDIDATE : for ( Class < ? > candidate : Iterables . filter ( candidateClasses , classFilter ) ) { for ( Class < ? > testClass : testClasses . get ( candidate ) ) { if ( hasTest ( testClass , explicitTestNames ) ) { continue NEXT_CANDIDATE ; } } result . add ( candidate ) ; } return result ; } private List < Class < ? > > loadClassesInPackage ( ) throws IOException { List < Class < ? > > classes = Lists . newArrayList ( ) ; String packageName = getClass ( ) . getPackage ( ) . getName ( ) ; for ( ClassPath . ClassInfo classInfo : ClassPath . from ( getClass ( ) . getClassLoader ( ) ) . getTopLevelClasses ( packageName ) ) { Class < ? > cls ; try { cls = classInfo . load ( ) ; } catch ( NoClassDefFoundError e ) { logger . log ( Level . SEVERE , <str> + classInfo + <str> , e ) ; continue ; } if ( ! cls . isInterface ( ) ) { classes . add ( cls ) ; } } return classes ; } private static boolean hasTest ( Class < ? > testClass , Iterable < String > testNames ) { for ( String testName : testNames ) { try { testClass . getMethod ( testName ) ; return true ; } catch ( NoSuchMethodException e ) { continue ; } } return false ; } private static boolean isEqualsDefined ( Class < ? > cls ) { try { return ! cls . getDeclaredMethod ( <str> , Object . class ) . isSynthetic ( ) ; } catch ( NoSuchMethodException e ) { return false ; } } abstract static class Chopper { final Chopper or ( final Chopper you ) { final Chopper i = this ; return new Chopper ( ) { @Override Optional < String > chop ( String str ) { return i . chop ( str ) . or ( you . chop ( str ) ) ; } } ; } abstract Optional < String > chop ( String str ) ; static Chopper suffix ( final String suffix ) { return new Chopper ( ) { @Override Optional < String > chop ( String str ) { if ( str . endsWith ( suffix ) ) { return Optional . of ( str . substring ( <int> , str . length ( ) - suffix . length ( ) ) ) ; } else { return Optional . absent ( ) ; } } } ; } } } 
