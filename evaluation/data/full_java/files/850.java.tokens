package org . apache . cassandra . repair ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . util . concurrent . * ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . JMXConfigurableThreadPoolExecutor ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . repair . messages . RepairOption ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . tracing . TraceKeyspace ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . UUIDGen ; import org . apache . cassandra . utils . WrappedRunnable ; import org . apache . cassandra . utils . progress . ProgressEvent ; import org . apache . cassandra . utils . progress . ProgressEventNotifier ; import org . apache . cassandra . utils . progress . ProgressEventType ; import org . apache . cassandra . utils . progress . ProgressListener ; public class RepairRunnable extends WrappedRunnable implements ProgressEventNotifier { private static final Logger logger = LoggerFactory . getLogger ( RepairRunnable . class ) ; private StorageService storageService ; private final int cmd ; private final RepairOption options ; private final String keyspace ; private final List < ProgressListener > listeners = new ArrayList < > ( ) ; public RepairRunnable ( StorageService storageService , int cmd , RepairOption options , String keyspace ) { this . storageService = storageService ; this . cmd = cmd ; this . options = options ; this . keyspace = keyspace ; } @Override public void addProgressListener ( ProgressListener listener ) { listeners . add ( listener ) ; } @Override public void removeProgressListener ( ProgressListener listener ) { listeners . remove ( listener ) ; } protected void fireProgressEvent ( String tag , ProgressEvent event ) { for ( ProgressListener listener : listeners ) { listener . progress ( tag , event ) ; } } protected void fireErrorAndComplete ( String tag , int progressCount , int totalProgress , String message ) { fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . ERROR , progressCount , totalProgress , message ) ) ; fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . COMPLETE , progressCount , totalProgress ) ) ; } protected void runMayThrow ( ) throws Exception { final TraceState traceState ; final String tag = <str> + cmd ; final AtomicInteger progress = new AtomicInteger ( ) ; final int totalProgress = <int> + options . getRanges ( ) . size ( ) ; String [ ] columnFamilies = options . getColumnFamilies ( ) . toArray ( new String [ options . getColumnFamilies ( ) . size ( ) ] ) ; Iterable < ColumnFamilyStore > validColumnFamilies = storageService . getValidColumnFamilies ( false , false , keyspace , columnFamilies ) ; final long startTime = System . currentTimeMillis ( ) ; String message = String . format ( <str> , cmd , keyspace , options ) ; logger . info ( message ) ; fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . START , <int> , <int> , message ) ) ; if ( options . isTraced ( ) ) { StringBuilder cfsb = new StringBuilder ( ) ; for ( ColumnFamilyStore cfs : validColumnFamilies ) cfsb . append ( <str> ) . append ( cfs . keyspace . getName ( ) ) . append ( <str> ) . append ( cfs . name ) ; UUID sessionId = Tracing . instance . newSession ( Tracing . TraceType . REPAIR ) ; traceState = Tracing . instance . begin ( <str> , ImmutableMap . of ( <str> , keyspace , <str> , cfsb . substring ( <int> ) ) ) ; Tracing . traceRepair ( message ) ; traceState . enableActivityNotification ( tag ) ; for ( ProgressListener listener : listeners ) traceState . addProgressListener ( listener ) ; Thread queryThread = createQueryThread ( cmd , sessionId ) ; queryThread . setName ( <str> ) ; queryThread . start ( ) ; } else { traceState = null ; } final Set < InetAddress > allNeighbors = new HashSet < > ( ) ; List < Pair < Set < InetAddress > , ? extends Collection < Range < Token > > > > commonRanges = new ArrayList < > ( ) ; try { for ( Range < Token > range : options . getRanges ( ) ) { Set < InetAddress > neighbors = ActiveRepairService . getNeighbors ( keyspace , range , options . getDataCenters ( ) , options . getHosts ( ) ) ; addRangeToNeighbors ( commonRanges , range , neighbors ) ; allNeighbors . addAll ( neighbors ) ; } progress . incrementAndGet ( ) ; } catch ( IllegalArgumentException e ) { logger . error ( <str> , e ) ; fireErrorAndComplete ( tag , progress . get ( ) , totalProgress , e . getMessage ( ) ) ; return ; } List < ColumnFamilyStore > columnFamilyStores = new ArrayList < > ( ) ; try { Iterables . addAll ( columnFamilyStores , validColumnFamilies ) ; progress . incrementAndGet ( ) ; } catch ( IllegalArgumentException e ) { fireErrorAndComplete ( tag , progress . get ( ) , totalProgress , e . getMessage ( ) ) ; return ; } String [ ] cfnames = new String [ columnFamilyStores . size ( ) ] ; for ( int i = <int> ; i < columnFamilyStores . size ( ) ; i + + ) { cfnames [ i ] = columnFamilyStores . get ( i ) . name ; } final UUID parentSession = UUIDGen . getTimeUUID ( ) ; SystemDistributedKeyspace . startParentRepair ( parentSession , keyspace , cfnames , options . getRanges ( ) ) ; long repairedAt ; try { ActiveRepairService . instance . prepareForRepair ( parentSession , allNeighbors , options , columnFamilyStores ) ; repairedAt = ActiveRepairService . instance . getParentRepairSession ( parentSession ) . getRepairedAt ( ) ; progress . incrementAndGet ( ) ; } catch ( Throwable t ) { SystemDistributedKeyspace . failParentRepair ( parentSession , t ) ; fireErrorAndComplete ( tag , progress . get ( ) , totalProgress , t . getMessage ( ) ) ; return ; } final ListeningExecutorService executor = MoreExecutors . listeningDecorator ( new JMXConfigurableThreadPoolExecutor ( options . getJobThreads ( ) , Integer . MAX_VALUE , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , new NamedThreadFactory ( <str> + cmd ) , <str> ) ) ; List < ListenableFuture < RepairSessionResult > > futures = new ArrayList < > ( options . getRanges ( ) . size ( ) ) ; for ( Pair < Set < InetAddress > , ? extends Collection < Range < Token > > > p : commonRanges ) { final RepairSession session = ActiveRepairService . instance . submitRepairSession ( parentSession , p . right , keyspace , options . getParallelism ( ) , p . left , repairedAt , executor , cfnames ) ; if ( session = = null ) continue ; Futures . addCallback ( session , new FutureCallback < RepairSessionResult > ( ) { public void onSuccess ( RepairSessionResult result ) { String message = String . format ( <str> , session . getId ( ) , session . getRanges ( ) . toString ( ) ) ; logger . info ( message ) ; fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . PROGRESS , progress . incrementAndGet ( ) , totalProgress , message ) ) ; } public void onFailure ( Throwable t ) { String message = String . format ( <str> , session . getId ( ) , session . getRanges ( ) . toString ( ) , t . getMessage ( ) ) ; logger . error ( message , t ) ; fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . PROGRESS , progress . incrementAndGet ( ) , totalProgress , message ) ) ; } } ) ; futures . add ( session ) ; } final Collection < Range < Token > > successfulRanges = new ArrayList < > ( ) ; final AtomicBoolean hasFailure = new AtomicBoolean ( ) ; final ListenableFuture < List < RepairSessionResult > > allSessions = Futures . successfulAsList ( futures ) ; ListenableFuture anticompactionResult = Futures . transform ( allSessions , new AsyncFunction < List < RepairSessionResult > , Object > ( ) { @SuppressWarnings ( <str> ) public ListenableFuture apply ( List < RepairSessionResult > results ) throws Exception { for ( RepairSessionResult sessionResult : results ) { if ( sessionResult ! = null ) { successfulRanges . addAll ( sessionResult . ranges ) ; } else { hasFailure . compareAndSet ( false , true ) ; } } return ActiveRepairService . instance . finishParentSession ( parentSession , allNeighbors , successfulRanges ) ; } } ) ; Futures . addCallback ( anticompactionResult , new FutureCallback < Object > ( ) { public void onSuccess ( Object result ) { SystemDistributedKeyspace . successfulParentRepair ( parentSession , successfulRanges ) ; if ( hasFailure . get ( ) ) { fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . ERROR , progress . get ( ) , totalProgress , <str> ) ) ; } else { fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . SUCCESS , progress . get ( ) , totalProgress , <str> ) ) ; } repairComplete ( ) ; } public void onFailure ( Throwable t ) { fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . ERROR , progress . get ( ) , totalProgress , t . getMessage ( ) ) ) ; SystemDistributedKeyspace . failParentRepair ( parentSession , t ) ; repairComplete ( ) ; } private void repairComplete ( ) { String duration = DurationFormatUtils . formatDurationWords ( System . currentTimeMillis ( ) - startTime , true , true ) ; String message = String . format ( <str> , cmd , duration ) ; fireProgressEvent ( tag , new ProgressEvent ( ProgressEventType . COMPLETE , progress . get ( ) , totalProgress , message ) ) ; logger . info ( message ) ; if ( options . isTraced ( ) & & traceState ! = null ) { for ( ProgressListener listener : listeners ) traceState . removeProgressListener ( listener ) ; Tracing . instance . set ( traceState ) ; Tracing . traceRepair ( message ) ; Tracing . instance . stopSession ( ) ; } executor . shutdownNow ( ) ; } } ) ; } private void addRangeToNeighbors ( List < Pair < Set < InetAddress > , ? extends Collection < Range < Token > > > > neighborRangeList , Range < Token > range , Set < InetAddress > neighbors ) { for ( int i = <int> ; i < neighborRangeList . size ( ) ; i + + ) { Pair < Set < InetAddress > , ? extends Collection < Range < Token > > > p = neighborRangeList . get ( i ) ; if ( p . left . containsAll ( neighbors ) ) { p . right . add ( range ) ; return ; } } List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( range ) ; neighborRangeList . add ( Pair . create ( neighbors , ranges ) ) ; } private Thread createQueryThread ( final int cmd , final UUID sessionId ) { return new Thread ( new WrappedRunnable ( ) { public void runMayThrow ( ) throws Exception { TraceState state = Tracing . instance . get ( sessionId ) ; if ( state = = null ) throw new Exception ( <str> ) ; String format = <str> ; String query = String . format ( format , TraceKeyspace . NAME , TraceKeyspace . EVENTS ) ; SelectStatement statement = ( SelectStatement ) QueryProcessor . parseStatement ( query ) . prepare ( ) . statement ; ByteBuffer sessionIdBytes = ByteBufferUtil . bytes ( sessionId ) ; InetAddress source = FBUtilities . getBroadcastAddress ( ) ; HashSet < UUID > [ ] seen = new HashSet [ ] { new HashSet < > ( ) , new HashSet < > ( ) } ; int si = <int> ; UUID uuid ; long tlast = System . currentTimeMillis ( ) , tcur ; TraceState . Status status ; long minWaitMillis = <int> ; long maxWaitMillis = <int> * <int> ; long timeout = minWaitMillis ; boolean shouldDouble = false ; while ( ( status = state . waitActivity ( timeout ) ) ! = TraceState . Status . STOPPED ) { if ( status = = TraceState . Status . IDLE ) { timeout = shouldDouble ? Math . min ( timeout * <int> , maxWaitMillis ) : timeout ; shouldDouble = ! shouldDouble ; } else { timeout = minWaitMillis ; shouldDouble = false ; } ByteBuffer tminBytes = ByteBufferUtil . bytes ( UUIDGen . minTimeUUID ( tlast - <int> ) ) ; ByteBuffer tmaxBytes = ByteBufferUtil . bytes ( UUIDGen . maxTimeUUID ( tcur = System . currentTimeMillis ( ) ) ) ; QueryOptions options = QueryOptions . forInternalCalls ( ConsistencyLevel . ONE , Lists . newArrayList ( sessionIdBytes , tminBytes , tmaxBytes ) ) ; ResultMessage . Rows rows = statement . execute ( QueryState . forInternalCalls ( ) , options ) ; UntypedResultSet result = UntypedResultSet . create ( rows . result ) ; for ( UntypedResultSet . Row r : result ) { if ( source . equals ( r . getInetAddress ( <str> ) ) ) continue ; if ( ( uuid = r . getUUID ( <str> ) ) . timestamp ( ) > ( tcur - <int> ) * <int> ) seen [ si ] . add ( uuid ) ; if ( seen [ si = = <int> ? <int> : <int> ] . contains ( uuid ) ) continue ; String message = String . format ( <str> , r . getInetAddress ( <str> ) , r . getString ( <str> ) ) ; fireProgressEvent ( <str> + cmd , new ProgressEvent ( ProgressEventType . NOTIFICATION , <int> , <int> , message ) ) ; } tlast = tcur ; si = si = = <int> ? <int> : <int> ; seen [ si ] . clear ( ) ; } } } ) ; } } 
