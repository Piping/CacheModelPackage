package org . apache . cassandra . service ; import java . io . IOException ; import java . net . InetAddress ; import java . util . * ; import java . util . concurrent . * ; import java . lang . management . ManagementFactory ; import java . lang . management . RuntimeMXBean ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . config . ViewDefinition ; import org . apache . cassandra . cql3 . functions . UDAggregate ; import org . apache . cassandra . cql3 . functions . UDFunction ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . UserType ; import org . apache . cassandra . exceptions . AlreadyExistsException ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . * ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . schema . SchemaKeyspace ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . WrappedRunnable ; public class MigrationManager { private static final Logger logger = LoggerFactory . getLogger ( MigrationManager . class ) ; public static final MigrationManager instance = new MigrationManager ( ) ; private static final RuntimeMXBean runtimeMXBean = ManagementFactory . getRuntimeMXBean ( ) ; public static final int MIGRATION_DELAY_IN_MS = <int> ; private static final int MIGRATION_TASK_WAIT_IN_SECONDS = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; private final List < MigrationListener > listeners = new CopyOnWriteArrayList < > ( ) ; private MigrationManager ( ) { } public void register ( MigrationListener listener ) { listeners . add ( listener ) ; } public void unregister ( MigrationListener listener ) { listeners . remove ( listener ) ; } public static void scheduleSchemaPull ( InetAddress endpoint , EndpointState state ) { VersionedValue value = state . getApplicationState ( ApplicationState . SCHEMA ) ; if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & value ! = null ) maybeScheduleSchemaPull ( UUID . fromString ( value . value ) , endpoint ) ; } private static void maybeScheduleSchemaPull ( final UUID theirVersion , final InetAddress endpoint ) { if ( ( Schema . instance . getVersion ( ) ! = null & & Schema . instance . getVersion ( ) . equals ( theirVersion ) ) | | ! shouldPullSchemaFrom ( endpoint ) ) { logger . debug ( <str> ) ; return ; } if ( Schema . emptyVersion . equals ( Schema . instance . getVersion ( ) ) | | runtimeMXBean . getUptime ( ) < MIGRATION_DELAY_IN_MS ) { logger . debug ( <str> , endpoint ) ; submitMigrationTask ( endpoint ) ; } else { Runnable runnable = ( ) - > { EndpointState epState = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; if ( epState = = null ) { logger . debug ( <str> , endpoint ) ; return ; } VersionedValue value = epState . getApplicationState ( ApplicationState . SCHEMA ) ; UUID currentVersion = UUID . fromString ( value . value ) ; if ( Schema . instance . getVersion ( ) . equals ( currentVersion ) ) { logger . debug ( <str> , endpoint ) ; return ; } logger . debug ( <str> , endpoint ) ; submitMigrationTask ( endpoint ) ; } ; ScheduledExecutors . optionalTasks . schedule ( runnable , MIGRATION_DELAY_IN_MS , TimeUnit . MILLISECONDS ) ; } } private static Future < ? > submitMigrationTask ( InetAddress endpoint ) { return StageManager . getStage ( Stage . MIGRATION ) . submit ( new MigrationTask ( endpoint ) ) ; } public static boolean shouldPullSchemaFrom ( InetAddress endpoint ) { return MessagingService . instance ( ) . knowsVersion ( endpoint ) & & MessagingService . instance ( ) . getRawVersion ( endpoint ) = = MessagingService . current_version & & ! Gossiper . instance . isGossipOnlyMember ( endpoint ) ; } public static boolean isReadyForBootstrap ( ) { return MigrationTask . getInflightTasks ( ) . isEmpty ( ) ; } public static void waitUntilReadyForBootstrap ( ) { CountDownLatch completionLatch ; while ( ( completionLatch = MigrationTask . getInflightTasks ( ) . poll ( ) ) ! = null ) { try { if ( ! completionLatch . await ( MIGRATION_TASK_WAIT_IN_SECONDS , TimeUnit . SECONDS ) ) logger . error ( <str> ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; logger . error ( <str> ) ; } } } public void notifyCreateKeyspace ( KeyspaceMetadata ksm ) { for ( MigrationListener listener : listeners ) listener . onCreateKeyspace ( ksm . name ) ; } public void notifyCreateColumnFamily ( CFMetaData cfm ) { for ( MigrationListener listener : listeners ) listener . onCreateColumnFamily ( cfm . ksName , cfm . cfName ) ; } public void notifyCreateView ( ViewDefinition view ) { for ( MigrationListener listener : listeners ) listener . onCreateView ( view . ksName , view . viewName ) ; } public void notifyCreateUserType ( UserType ut ) { for ( MigrationListener listener : listeners ) listener . onCreateUserType ( ut . keyspace , ut . getNameAsString ( ) ) ; } public void notifyCreateFunction ( UDFunction udf ) { for ( MigrationListener listener : listeners ) listener . onCreateFunction ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public void notifyCreateAggregate ( UDAggregate udf ) { for ( MigrationListener listener : listeners ) listener . onCreateAggregate ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public void notifyUpdateKeyspace ( KeyspaceMetadata ksm ) { for ( MigrationListener listener : listeners ) listener . onUpdateKeyspace ( ksm . name ) ; } public void notifyUpdateColumnFamily ( CFMetaData cfm , boolean columnsDidChange ) { for ( MigrationListener listener : listeners ) listener . onUpdateColumnFamily ( cfm . ksName , cfm . cfName , columnsDidChange ) ; } public void notifyUpdateView ( ViewDefinition view , boolean columnsDidChange ) { for ( MigrationListener listener : listeners ) listener . onUpdateView ( view . ksName , view . viewName , columnsDidChange ) ; } public void notifyUpdateUserType ( UserType ut ) { for ( MigrationListener listener : listeners ) listener . onUpdateUserType ( ut . keyspace , ut . getNameAsString ( ) ) ; Schema . instance . getKSMetaData ( ut . keyspace ) . functions . udfs ( ) . forEach ( f - > f . userTypeUpdated ( ut . keyspace , ut . getNameAsString ( ) ) ) ; } public void notifyUpdateFunction ( UDFunction udf ) { for ( MigrationListener listener : listeners ) listener . onUpdateFunction ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public void notifyUpdateAggregate ( UDAggregate udf ) { for ( MigrationListener listener : listeners ) listener . onUpdateAggregate ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public void notifyDropKeyspace ( KeyspaceMetadata ksm ) { for ( MigrationListener listener : listeners ) listener . onDropKeyspace ( ksm . name ) ; } public void notifyDropColumnFamily ( CFMetaData cfm ) { for ( MigrationListener listener : listeners ) listener . onDropColumnFamily ( cfm . ksName , cfm . cfName ) ; } public void notifyDropView ( ViewDefinition view ) { for ( MigrationListener listener : listeners ) listener . onDropView ( view . ksName , view . viewName ) ; } public void notifyDropUserType ( UserType ut ) { for ( MigrationListener listener : listeners ) listener . onDropUserType ( ut . keyspace , ut . getNameAsString ( ) ) ; } public void notifyDropFunction ( UDFunction udf ) { for ( MigrationListener listener : listeners ) listener . onDropFunction ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public void notifyDropAggregate ( UDAggregate udf ) { for ( MigrationListener listener : listeners ) listener . onDropAggregate ( udf . name ( ) . keyspace , udf . name ( ) . name , udf . argTypes ( ) ) ; } public static void announceNewKeyspace ( KeyspaceMetadata ksm ) throws ConfigurationException { announceNewKeyspace ( ksm , false ) ; } public static void announceNewKeyspace ( KeyspaceMetadata ksm , boolean announceLocally ) throws ConfigurationException { announceNewKeyspace ( ksm , FBUtilities . timestampMicros ( ) , announceLocally ) ; } public static void announceNewKeyspace ( KeyspaceMetadata ksm , long timestamp , boolean announceLocally ) throws ConfigurationException { ksm . validate ( ) ; if ( Schema . instance . getKSMetaData ( ksm . name ) ! = null ) throw new AlreadyExistsException ( ksm . name ) ; logger . info ( String . format ( <str> , ksm ) ) ; announce ( SchemaKeyspace . makeCreateKeyspaceMutation ( ksm , timestamp ) , announceLocally ) ; } public static void announceNewColumnFamily ( CFMetaData cfm ) throws ConfigurationException { announceNewColumnFamily ( cfm , false ) ; } public static void announceNewColumnFamily ( CFMetaData cfm , boolean announceLocally ) throws ConfigurationException { announceNewColumnFamily ( cfm , announceLocally , true ) ; } public static void forceAnnounceNewColumnFamily ( CFMetaData cfm ) throws ConfigurationException { announceNewColumnFamily ( cfm , false , false ) ; } private static void announceNewColumnFamily ( CFMetaData cfm , boolean announceLocally , boolean throwOnDuplicate ) throws ConfigurationException { cfm . validate ( ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( cfm . ksName ) ; if ( ksm = = null ) throw new ConfigurationException ( String . format ( <str> , cfm . cfName , cfm . ksName ) ) ; else if ( throwOnDuplicate & & ksm . getTableOrViewNullable ( cfm . cfName ) ! = null ) throw new AlreadyExistsException ( cfm . ksName , cfm . cfName ) ; logger . info ( String . format ( <str> , cfm ) ) ; announce ( SchemaKeyspace . makeCreateTableMutation ( ksm , cfm , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceNewView ( ViewDefinition view , boolean announceLocally ) throws ConfigurationException { view . metadata . validate ( ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( view . ksName ) ; if ( ksm = = null ) throw new ConfigurationException ( String . format ( <str> , view . viewName , view . ksName ) ) ; else if ( ksm . getTableOrViewNullable ( view . viewName ) ! = null ) throw new AlreadyExistsException ( view . ksName , view . viewName ) ; logger . info ( String . format ( <str> , view ) ) ; announce ( SchemaKeyspace . makeCreateViewMutation ( ksm , view , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceNewType ( UserType newType , boolean announceLocally ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( newType . keyspace ) ; announce ( SchemaKeyspace . makeCreateTypeMutation ( ksm , newType , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceNewFunction ( UDFunction udf , boolean announceLocally ) { logger . info ( String . format ( <str> , udf . name ( ) ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( udf . name ( ) . keyspace ) ; announce ( SchemaKeyspace . makeCreateFunctionMutation ( ksm , udf , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceNewAggregate ( UDAggregate udf , boolean announceLocally ) { logger . info ( String . format ( <str> , udf . name ( ) ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( udf . name ( ) . keyspace ) ; announce ( SchemaKeyspace . makeCreateAggregateMutation ( ksm , udf , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceKeyspaceUpdate ( KeyspaceMetadata ksm ) throws ConfigurationException { announceKeyspaceUpdate ( ksm , false ) ; } public static void announceKeyspaceUpdate ( KeyspaceMetadata ksm , boolean announceLocally ) throws ConfigurationException { ksm . validate ( ) ; KeyspaceMetadata oldKsm = Schema . instance . getKSMetaData ( ksm . name ) ; if ( oldKsm = = null ) throw new ConfigurationException ( String . format ( <str> , ksm . name ) ) ; logger . info ( String . format ( <str> , ksm . name , oldKsm , ksm ) ) ; announce ( SchemaKeyspace . makeCreateKeyspaceMutation ( ksm . name , ksm . params , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceColumnFamilyUpdate ( CFMetaData cfm , boolean fromThrift ) throws ConfigurationException { announceColumnFamilyUpdate ( cfm , fromThrift , false ) ; } public static void announceColumnFamilyUpdate ( CFMetaData cfm , boolean fromThrift , boolean announceLocally ) throws ConfigurationException { cfm . validate ( ) ; CFMetaData oldCfm = Schema . instance . getCFMetaData ( cfm . ksName , cfm . cfName ) ; if ( oldCfm = = null ) throw new ConfigurationException ( String . format ( <str> , cfm . cfName , cfm . ksName ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( cfm . ksName ) ; oldCfm . validateCompatibility ( cfm ) ; logger . info ( String . format ( <str> , cfm . ksName , cfm . cfName , oldCfm , cfm ) ) ; announce ( SchemaKeyspace . makeUpdateTableMutation ( ksm , oldCfm , cfm , FBUtilities . timestampMicros ( ) , fromThrift ) , announceLocally ) ; } public static void announceViewUpdate ( ViewDefinition view , boolean announceLocally ) throws ConfigurationException { view . metadata . validate ( ) ; ViewDefinition oldView = Schema . instance . getView ( view . ksName , view . viewName ) ; if ( oldView = = null ) throw new ConfigurationException ( String . format ( <str> , view . viewName , view . ksName ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( view . ksName ) ; oldView . metadata . validateCompatibility ( view . metadata ) ; logger . info ( String . format ( <str> , view . ksName , view . viewName , oldView , view ) ) ; announce ( SchemaKeyspace . makeUpdateViewMutation ( ksm , oldView , view , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceTypeUpdate ( UserType updatedType , boolean announceLocally ) { announceNewType ( updatedType , announceLocally ) ; } public static void announceKeyspaceDrop ( String ksName ) throws ConfigurationException { announceKeyspaceDrop ( ksName , false ) ; } public static void announceKeyspaceDrop ( String ksName , boolean announceLocally ) throws ConfigurationException { KeyspaceMetadata oldKsm = Schema . instance . getKSMetaData ( ksName ) ; if ( oldKsm = = null ) throw new ConfigurationException ( String . format ( <str> , ksName ) ) ; logger . info ( String . format ( <str> , oldKsm . name ) ) ; announce ( SchemaKeyspace . makeDropKeyspaceMutation ( oldKsm , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceColumnFamilyDrop ( String ksName , String cfName ) throws ConfigurationException { announceColumnFamilyDrop ( ksName , cfName , false ) ; } public static void announceColumnFamilyDrop ( String ksName , String cfName , boolean announceLocally ) throws ConfigurationException { CFMetaData oldCfm = Schema . instance . getCFMetaData ( ksName , cfName ) ; if ( oldCfm = = null ) throw new ConfigurationException ( String . format ( <str> , cfName , ksName ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; logger . info ( String . format ( <str> , oldCfm . ksName , oldCfm . cfName ) ) ; announce ( SchemaKeyspace . makeDropTableMutation ( ksm , oldCfm , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceViewDrop ( String ksName , String viewName , boolean announceLocally ) throws ConfigurationException { ViewDefinition view = Schema . instance . getView ( ksName , viewName ) ; if ( view = = null ) throw new ConfigurationException ( String . format ( <str> , viewName , ksName ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; logger . info ( String . format ( <str> , view . ksName , view . viewName ) ) ; announce ( SchemaKeyspace . makeDropViewMutation ( ksm , view , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceTypeDrop ( UserType droppedType ) { announceTypeDrop ( droppedType , false ) ; } public static void announceTypeDrop ( UserType droppedType , boolean announceLocally ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( droppedType . keyspace ) ; announce ( SchemaKeyspace . dropTypeFromSchemaMutation ( ksm , droppedType , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceFunctionDrop ( UDFunction udf , boolean announceLocally ) { logger . info ( String . format ( <str> , udf . name ( ) , udf . argTypes ( ) ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( udf . name ( ) . keyspace ) ; announce ( SchemaKeyspace . makeDropFunctionMutation ( ksm , udf , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } public static void announceAggregateDrop ( UDAggregate udf , boolean announceLocally ) { logger . info ( String . format ( <str> , udf . name ( ) , udf . argTypes ( ) ) ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( udf . name ( ) . keyspace ) ; announce ( SchemaKeyspace . makeDropAggregateMutation ( ksm , udf , FBUtilities . timestampMicros ( ) ) , announceLocally ) ; } private static void announce ( Mutation schema , boolean announceLocally ) { if ( announceLocally ) SchemaKeyspace . mergeSchema ( Collections . singletonList ( schema ) ) ; else FBUtilities . waitOnFuture ( announce ( Collections . singletonList ( schema ) ) ) ; } private static void pushSchemaMutation ( InetAddress endpoint , Collection < Mutation > schema ) { MessageOut < Collection < Mutation > > msg = new MessageOut < > ( MessagingService . Verb . DEFINITIONS_UPDATE , schema , MigrationsSerializer . instance ) ; MessagingService . instance ( ) . sendOneWay ( msg , endpoint ) ; } private static Future < ? > announce ( final Collection < Mutation > schema ) { Future < ? > f = StageManager . getStage ( Stage . MIGRATION ) . submit ( new WrappedRunnable ( ) { protected void runMayThrow ( ) throws ConfigurationException { SchemaKeyspace . mergeSchemaAndAnnounceVersion ( schema ) ; } } ) ; for ( InetAddress endpoint : Gossiper . instance . getLiveMembers ( ) ) { if ( ! endpoint . equals ( FBUtilities . getBroadcastAddress ( ) ) & & MessagingService . instance ( ) . knowsVersion ( endpoint ) & & MessagingService . instance ( ) . getRawVersion ( endpoint ) = = MessagingService . current_version ) pushSchemaMutation ( endpoint , schema ) ; } return f ; } public static void passiveAnnounce ( UUID version ) { Gossiper . instance . addLocalApplicationState ( ApplicationState . SCHEMA , StorageService . instance . valueFactory . schema ( version ) ) ; logger . debug ( <str> , version ) ; } public static void resetLocalSchema ( ) { logger . info ( <str> ) ; logger . debug ( <str> ) ; SchemaKeyspace . truncate ( ) ; logger . debug ( <str> ) ; Schema . instance . clear ( ) ; Set < InetAddress > liveEndpoints = Gossiper . instance . getLiveMembers ( ) ; liveEndpoints . remove ( FBUtilities . getBroadcastAddress ( ) ) ; for ( InetAddress node : liveEndpoints ) { if ( shouldPullSchemaFrom ( node ) ) { logger . debug ( <str> , node ) ; FBUtilities . waitOnFuture ( submitMigrationTask ( node ) ) ; break ; } } logger . info ( <str> ) ; } public static class MigrationsSerializer implements IVersionedSerializer < Collection < Mutation > > { public static MigrationsSerializer instance = new MigrationsSerializer ( ) ; public void serialize ( Collection < Mutation > schema , DataOutputPlus out , int version ) throws IOException { out . writeInt ( schema . size ( ) ) ; for ( Mutation mutation : schema ) Mutation . serializer . serialize ( mutation , out , version ) ; } public Collection < Mutation > deserialize ( DataInputPlus in , int version ) throws IOException { int count = in . readInt ( ) ; Collection < Mutation > schema = new ArrayList < > ( count ) ; for ( int i = <int> ; i < count ; i + + ) schema . add ( Mutation . serializer . deserialize ( in , version ) ) ; return schema ; } public long serializedSize ( Collection < Mutation > schema , int version ) { int size = TypeSizes . sizeof ( schema . size ( ) ) ; for ( Mutation mutation : schema ) size + = Mutation . serializer . serializedSize ( mutation , version ) ; return size ; } } } 
