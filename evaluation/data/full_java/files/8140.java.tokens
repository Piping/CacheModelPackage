package org . elasticsearch . index . mapper ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . create . CreateIndexResponse ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . junit . Rule ; import org . junit . rules . ExpectedException ; import static org . elasticsearch . test . VersionUtils . getFirstVersion ; import static org . elasticsearch . test . VersionUtils . getPreviousVersion ; import static org . elasticsearch . test . VersionUtils . randomVersionBetween ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . Matchers . hasToString ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . concurrent . ExecutionException ; public class MapperServiceTests extends ESSingleNodeTestCase { @Rule public ExpectedException expectedException = ExpectedException . none ( ) ; public void testTypeNameStartsWithIllegalDot ( ) { expectedException . expect ( MapperParsingException . class ) ; expectedException . expect ( hasToString ( containsString ( <str> ) ) ) ; String index = <str> ; String type = <str> ; String field = <str> ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . addMapping ( type , field , <str> ) . execute ( ) . actionGet ( ) ; } public void testThatLongTypeNameIsNotRejectedOnPreElasticsearchVersionTwo ( ) { String index = <str> ; String field = <str> ; String type = new String ( new char [ <int> ] ) . replace ( <str> , <str> ) ; CreateIndexResponse response = client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . setSettings ( settings ( randomVersionBetween ( random ( ) , getFirstVersion ( ) , getPreviousVersion ( Version . V_2_0_0_beta1 ) ) ) ) . addMapping ( type , field , <str> ) . execute ( ) . actionGet ( ) ; assertNotNull ( response ) ; } public void testTypeNameTooLong ( ) { String index = <str> ; String field = <str> ; String type = new String ( new char [ <int> ] ) . replace ( <str> , <str> ) ; expectedException . expect ( MapperParsingException . class ) ; expectedException . expect ( hasToString ( containsString ( <str> + type + <str> ) ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . addMapping ( type , field , <str> ) . execute ( ) . actionGet ( ) ; } public void testTypes ( ) throws Exception { IndexService indexService1 = createIndex ( <str> ) ; MapperService mapperService = indexService1 . mapperService ( ) ; assertEquals ( Collections . emptySet ( ) , mapperService . types ( ) ) ; mapperService . merge ( <str> , new CompressedXContent ( <str> ) , true , false ) ; assertNull ( mapperService . documentMapper ( MapperService . DEFAULT_MAPPING ) ) ; assertEquals ( Collections . singleton ( <str> ) , mapperService . types ( ) ) ; mapperService . merge ( MapperService . DEFAULT_MAPPING , new CompressedXContent ( <str> ) , true , false ) ; assertNotNull ( mapperService . documentMapper ( MapperService . DEFAULT_MAPPING ) ) ; assertEquals ( Collections . singleton ( <str> ) , mapperService . types ( ) ) ; mapperService . merge ( <str> , new CompressedXContent ( <str> ) , true , false ) ; assertNotNull ( mapperService . documentMapper ( MapperService . DEFAULT_MAPPING ) ) ; assertEquals ( new HashSet < > ( Arrays . asList ( <str> , <str> ) ) , mapperService . types ( ) ) ; } public void testIndexIntoDefaultMapping ( ) throws Throwable { try { client ( ) . prepareIndex ( <str> , MapperService . DEFAULT_MAPPING , <str> ) . setSource ( <str> ) . execute ( ) . get ( ) ; fail ( ) ; } catch ( Throwable t ) { if ( t instanceof ExecutionException ) { t = ( ( ExecutionException ) t ) . getCause ( ) ; } final Throwable throwable = ExceptionsHelper . unwrapCause ( t ) ; if ( throwable instanceof IllegalArgumentException ) { assertEquals ( <str> , throwable . getMessage ( ) ) ; } else { throw t ; } } IndexService indexService = createIndex ( <str> ) ; try { client ( ) . prepareIndex ( <str> , MapperService . DEFAULT_MAPPING , <str> ) . setSource ( ) . execute ( ) . get ( ) ; fail ( ) ; } catch ( Throwable t ) { if ( t instanceof ExecutionException ) { t = ( ( ExecutionException ) t ) . getCause ( ) ; } final Throwable throwable = ExceptionsHelper . unwrapCause ( t ) ; if ( throwable instanceof IllegalArgumentException ) { assertEquals ( <str> , throwable . getMessage ( ) ) ; } else { throw t ; } } assertFalse ( indexService . mapperService ( ) . hasMapping ( MapperService . DEFAULT_MAPPING ) ) ; } } 
