package org . apache . cassandra . utils ; import java . io . IOException ; import java . util . * ; import com . google . common . base . Objects ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public class StreamingHistogram { public static final StreamingHistogramSerializer serializer = new StreamingHistogramSerializer ( ) ; private final TreeMap < Double , Long > bin ; private final int maxBinSize ; public StreamingHistogram ( int maxBinSize ) { this . maxBinSize = maxBinSize ; bin = new TreeMap < > ( ) ; } private StreamingHistogram ( int maxBinSize , Map < Double , Long > bin ) { this . maxBinSize = maxBinSize ; this . bin = new TreeMap < > ( bin ) ; } public void update ( double p ) { update ( p , <int> ) ; } public void update ( double p , long m ) { Long mi = bin . get ( p ) ; if ( mi ! = null ) { bin . put ( p , mi + m ) ; } else { bin . put ( p , m ) ; while ( bin . size ( ) > maxBinSize ) { Iterator < Double > keys = bin . keySet ( ) . iterator ( ) ; double p1 = keys . next ( ) ; double p2 = keys . next ( ) ; double smallestDiff = p2 - p1 ; double q1 = p1 , q2 = p2 ; while ( keys . hasNext ( ) ) { p1 = p2 ; p2 = keys . next ( ) ; double diff = p2 - p1 ; if ( diff < smallestDiff ) { smallestDiff = diff ; q1 = p1 ; q2 = p2 ; } } long k1 = bin . remove ( q1 ) ; long k2 = bin . remove ( q2 ) ; bin . put ( ( q1 * k1 + q2 * k2 ) / ( k1 + k2 ) , k1 + k2 ) ; } } } public void merge ( StreamingHistogram other ) { if ( other = = null ) return ; for ( Map . Entry < Double , Long > entry : other . getAsMap ( ) . entrySet ( ) ) update ( entry . getKey ( ) , entry . getValue ( ) ) ; } public double sum ( double b ) { double sum = <int> ; Map . Entry < Double , Long > pnext = bin . higherEntry ( b ) ; if ( pnext = = null ) { for ( Long value : bin . values ( ) ) sum + = value ; } else { Map . Entry < Double , Long > pi = bin . floorEntry ( b ) ; if ( pi = = null ) return <int> ; double weight = ( b - pi . getKey ( ) ) / ( pnext . getKey ( ) - pi . getKey ( ) ) ; double mb = pi . getValue ( ) + ( pnext . getValue ( ) - pi . getValue ( ) ) * weight ; sum + = ( pi . getValue ( ) + mb ) * weight / <int> ; sum + = pi . getValue ( ) / <float> ; for ( Long value : bin . headMap ( pi . getKey ( ) , false ) . values ( ) ) sum + = value ; } return sum ; } public Map < Double , Long > getAsMap ( ) { return Collections . unmodifiableMap ( bin ) ; } public static class StreamingHistogramSerializer implements ISerializer < StreamingHistogram > { public void serialize ( StreamingHistogram histogram , DataOutputPlus out ) throws IOException { out . writeInt ( histogram . maxBinSize ) ; Map < Double , Long > entries = histogram . getAsMap ( ) ; out . writeInt ( entries . size ( ) ) ; for ( Map . Entry < Double , Long > entry : entries . entrySet ( ) ) { out . writeDouble ( entry . getKey ( ) ) ; out . writeLong ( entry . getValue ( ) ) ; } } public StreamingHistogram deserialize ( DataInputPlus in ) throws IOException { int maxBinSize = in . readInt ( ) ; int size = in . readInt ( ) ; Map < Double , Long > tmp = new HashMap < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { tmp . put ( in . readDouble ( ) , in . readLong ( ) ) ; } return new StreamingHistogram ( maxBinSize , tmp ) ; } public long serializedSize ( StreamingHistogram histogram ) { long size = TypeSizes . sizeof ( histogram . maxBinSize ) ; Map < Double , Long > entries = histogram . getAsMap ( ) ; size + = TypeSizes . sizeof ( entries . size ( ) ) ; size + = entries . size ( ) * ( <int> + <int> ) ; return size ; } } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof StreamingHistogram ) ) return false ; StreamingHistogram that = ( StreamingHistogram ) o ; return maxBinSize = = that . maxBinSize & & bin . equals ( that . bin ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( bin . hashCode ( ) , maxBinSize ) ; } } 
