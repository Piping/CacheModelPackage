package io . netty . testsuite . util ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . rules . TestName ; import org . tukaani . xz . LZMA2Options ; import org . tukaani . xz . XZOutputStream ; import javax . management . MBeanServer ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . FilenameFilter ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . lang . management . ManagementFactory ; import java . lang . management . ThreadInfo ; import java . lang . reflect . Method ; import java . net . DatagramSocket ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . nio . channels . Channel ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; public final class TestUtils { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( TestUtils . class ) ; private static final int START_PORT = <int> ; private static final int END_PORT = <int> ; private static final int NUM_CANDIDATES = END_PORT - START_PORT ; private static final List < Integer > PORTS = new ArrayList < Integer > ( ) ; private static Iterator < Integer > portIterator ; private static final Method hotspotMXBeanDumpHeap ; private static final Object hotspotMXBean ; private static final long DUMP_PROGRESS_LOGGING_INTERVAL = TimeUnit . SECONDS . toNanos ( <int> ) ; static { for ( int i = START_PORT ; i < END_PORT ; i + + ) { PORTS . add ( i ) ; } Collections . shuffle ( PORTS ) ; Object mxBean ; Method mxBeanDumpHeap ; try { Class < ? > clazz = Class . forName ( <str> ) ; MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; mxBean = ManagementFactory . newPlatformMXBeanProxy ( server , <str> , clazz ) ; mxBeanDumpHeap = clazz . getMethod ( <str> , String . class , boolean . class ) ; } catch ( Exception ignored ) { mxBean = null ; mxBeanDumpHeap = null ; } hotspotMXBean = mxBean ; hotspotMXBeanDumpHeap = mxBeanDumpHeap ; } public static int getFreePort ( ) { for ( int i = <int> ; i < NUM_CANDIDATES ; i + + ) { final int port = nextCandidatePort ( ) ; final InetSocketAddress wildcardAddr = new InetSocketAddress ( port ) ; final InetSocketAddress loopbackAddr = new InetSocketAddress ( NetUtil . LOCALHOST4 , port ) ; if ( isTcpPortAvailable ( wildcardAddr ) & & isTcpPortAvailable ( loopbackAddr ) & & isUdpPortAvailable ( wildcardAddr ) & & isUdpPortAvailable ( loopbackAddr ) ) { return port ; } } throw new RuntimeException ( <str> ) ; } private static int nextCandidatePort ( ) { if ( portIterator = = null | | ! portIterator . hasNext ( ) ) { portIterator = PORTS . iterator ( ) ; } return portIterator . next ( ) ; } private static boolean isTcpPortAvailable ( InetSocketAddress localAddress ) { ServerSocket ss = null ; try { ss = new ServerSocket ( ) ; ss . setReuseAddress ( false ) ; ss . bind ( localAddress ) ; ss . close ( ) ; ss = null ; return true ; } catch ( Exception ignore ) { } finally { if ( ss ! = null ) { try { ss . close ( ) ; } catch ( IOException ignore ) { } } } return false ; } private static boolean isUdpPortAvailable ( InetSocketAddress localAddress ) { DatagramSocket ds = null ; try { ds = new DatagramSocket ( null ) ; ds . setReuseAddress ( false ) ; ds . bind ( localAddress ) ; ds . close ( ) ; ds = null ; return true ; } catch ( Exception ignore ) { } finally { if ( ds ! = null ) { ds . close ( ) ; } } return false ; } public static boolean isSctpSupported ( ) { String os = System . getProperty ( <str> ) . toLowerCase ( Locale . UK ) ; if ( <str> . equals ( os ) | | <str> . equals ( os ) | | <str> . equals ( os ) | | <str> . equals ( os ) ) { try { Class < ? > sctpChannelClass = Class . forName ( <str> ) ; Channel channel = ( Channel ) sctpChannelClass . getMethod ( <str> ) . invoke ( null ) ; try { channel . close ( ) ; } catch ( IOException e ) { } } catch ( UnsupportedOperationException e ) { System . out . print ( <str> + e . getMessage ( ) ) ; return false ; } catch ( Throwable t ) { if ( ! ( t instanceof IOException ) ) { return false ; } } return true ; } return false ; } public static String testMethodName ( TestName testName ) { String testMethodName = testName . getMethodName ( ) ; if ( testMethodName . contains ( <str> ) ) { testMethodName = testMethodName . substring ( <int> , testMethodName . indexOf ( <str> ) ) ; } return testMethodName ; } public static void dump ( String filenamePrefix ) throws IOException { if ( filenamePrefix = = null ) { throw new NullPointerException ( <str> ) ; } final String timestamp = timestamp ( ) ; final File heapDumpFile = new File ( filenamePrefix + <str> + timestamp + <str> ) ; if ( heapDumpFile . exists ( ) ) { if ( ! heapDumpFile . delete ( ) ) { throw new IOException ( <str> + heapDumpFile ) ; } } final File threadDumpFile = new File ( filenamePrefix + <str> + timestamp + <str> ) ; if ( threadDumpFile . exists ( ) ) { if ( ! threadDumpFile . delete ( ) ) { throw new IOException ( <str> + threadDumpFile ) ; } } dumpHeap ( heapDumpFile ) ; dumpThreads ( threadDumpFile ) ; } public static void compressHeapDumps ( ) throws IOException { final File [ ] files = new File ( System . getProperty ( <str> ) ) . listFiles ( new FilenameFilter ( ) { @Override public boolean accept ( File dir , String name ) { return name . endsWith ( <str> ) ; } } ) ; final byte [ ] buf = new byte [ <int> ] ; final LZMA2Options options = new LZMA2Options ( LZMA2Options . PRESET_DEFAULT ) ; for ( File file : files ) { final String filename = file . toString ( ) ; final String xzFilename = filename + <str> ; final long fileLength = file . length ( ) ; logger . info ( <str> , xzFilename ) ; long lastLogTime = System . nanoTime ( ) ; long counter = <int> ; InputStream in = null ; OutputStream out = null ; try { in = new FileInputStream ( filename ) ; out = new XZOutputStream ( new FileOutputStream ( xzFilename ) , options ) ; for ( ; ; ) { int readBytes = in . read ( buf ) ; if ( readBytes < <int> ) { break ; } if ( readBytes = = <int> ) { continue ; } out . write ( buf , <int> , readBytes ) ; counter + = readBytes ; long currentTime = System . nanoTime ( ) ; if ( currentTime - lastLogTime > DUMP_PROGRESS_LOGGING_INTERVAL ) { logger . info ( <str> , xzFilename , counter * <int> / fileLength ) ; lastLogTime = currentTime ; } } out . close ( ) ; in . close ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , xzFilename , t ) ; } finally { if ( in ! = null ) { try { in . close ( ) ; } catch ( IOException ignored ) { } } if ( out ! = null ) { try { out . close ( ) ; } catch ( IOException ignored ) { } } } if ( ! file . delete ( ) ) { logger . warn ( <str> , filename ) ; } } } private static String timestamp ( ) { return new SimpleDateFormat ( <str> ) . format ( new Date ( ) ) ; } private static void dumpHeap ( File file ) { if ( hotspotMXBean = = null ) { logger . warn ( <str> ) ; return ; } final String filename = file . toString ( ) ; logger . info ( <str> , filename ) ; try { hotspotMXBeanDumpHeap . invoke ( hotspotMXBean , filename , true ) ; } catch ( Exception e ) { logger . warn ( <str> , filename , e ) ; } } private static void dumpThreads ( File file ) { final String filename = file . toString ( ) ; OutputStream out = null ; try { logger . info ( <str> , filename ) ; final StringBuilder buf = new StringBuilder ( <int> ) ; try { for ( ThreadInfo info : ManagementFactory . getThreadMXBean ( ) . dumpAllThreads ( true , true ) ) { buf . append ( info ) ; } buf . append ( <str> ) ; } catch ( UnsupportedOperationException ignored ) { logger . warn ( <str> ) ; return ; } out = new FileOutputStream ( file ) ; out . write ( buf . toString ( ) . getBytes ( CharsetUtil . UTF_8 ) ) ; } catch ( Exception e ) { logger . warn ( <str> , filename , e ) ; } finally { if ( out ! = null ) { try { out . close ( ) ; } catch ( IOException ignored ) { } } } } private TestUtils ( ) { } } 
