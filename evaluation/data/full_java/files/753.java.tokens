package org . apache . cassandra . io . util ; import java . io . * ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import com . google . common . primitives . Ints ; import com . google . common . util . concurrent . RateLimiter ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . io . compress . BufferType ; import org . apache . cassandra . utils . memory . BufferPool ; public class RandomAccessReader extends RebufferingInputStream implements FileDataInput { public static final int DEFAULT_BUFFER_SIZE = <int> ; public static final int MAX_BUFFER_SIZE = <int> < < <int> ; protected final ChannelProxy channel ; protected final MmappedRegions regions ; protected final RateLimiter limiter ; private final long fileLength ; protected final int bufferSize ; protected final BufferType bufferType ; protected long bufferOffset ; protected long markedPointer ; protected RandomAccessReader ( Builder builder ) { super ( builder . createBuffer ( ) ) ; this . channel = builder . channel ; this . regions = builder . regions ; this . limiter = builder . limiter ; this . fileLength = builder . overrideLength < = <int> ? builder . channel . size ( ) : builder . overrideLength ; this . bufferSize = builder . bufferSize ; this . bufferType = builder . bufferType ; this . buffer = builder . buffer ; } protected static ByteBuffer allocateBuffer ( int size , BufferType bufferType ) { return BufferPool . get ( size , bufferType ) . order ( ByteOrder . BIG_ENDIAN ) ; } protected void releaseBuffer ( ) { if ( buffer ! = null ) { if ( regions = = null ) BufferPool . put ( buffer ) ; buffer = null ; } } public void reBuffer ( ) { if ( isEOF ( ) ) return ; if ( regions = = null ) reBufferStandard ( ) ; else reBufferMmap ( ) ; if ( limiter ! = null ) limiter . acquire ( buffer . remaining ( ) ) ; assert buffer . order ( ) = = ByteOrder . BIG_ENDIAN : <str> ; } protected void reBufferStandard ( ) { bufferOffset + = buffer . position ( ) ; assert bufferOffset < fileLength ; buffer . clear ( ) ; long position = bufferOffset ; long limit = bufferOffset ; long pageAligedPos = position & ~ <int> ; long upperLimit = Math . min ( fileLength , pageAligedPos + buffer . capacity ( ) ) ; buffer . limit ( ( int ) ( upperLimit - position ) ) ; while ( buffer . hasRemaining ( ) & & limit < upperLimit ) { int n = channel . read ( buffer , position ) ; if ( n < <int> ) throw new FSReadError ( new IOException ( <str> ) , channel . filePath ( ) ) ; position + = n ; limit = bufferOffset + buffer . position ( ) ; } buffer . flip ( ) ; } protected void reBufferMmap ( ) { long position = bufferOffset + buffer . position ( ) ; assert position < fileLength ; MmappedRegions . Region region = regions . floor ( position ) ; bufferOffset = region . bottom ( ) ; buffer = region . buffer . duplicate ( ) ; buffer . position ( Ints . checkedCast ( position - bufferOffset ) ) ; if ( limiter ! = null & & bufferSize < buffer . remaining ( ) ) { buffer . limit ( buffer . position ( ) + bufferSize ) ; } } @Override public long getFilePointer ( ) { return current ( ) ; } protected long current ( ) { return bufferOffset + ( buffer = = null ? <int> : buffer . position ( ) ) ; } public String getPath ( ) { return channel . filePath ( ) ; } public ChannelProxy getChannel ( ) { return channel ; } @Override public void reset ( ) throws IOException { seek ( markedPointer ) ; } @Override public boolean markSupported ( ) { return true ; } public long bytesPastMark ( ) { long bytes = current ( ) - markedPointer ; assert bytes > = <int> ; return bytes ; } public FileMark mark ( ) { markedPointer = current ( ) ; return new BufferedRandomAccessFileMark ( markedPointer ) ; } public void reset ( FileMark mark ) { assert mark instanceof BufferedRandomAccessFileMark ; seek ( ( ( BufferedRandomAccessFileMark ) mark ) . pointer ) ; } public long bytesPastMark ( FileMark mark ) { assert mark instanceof BufferedRandomAccessFileMark ; long bytes = current ( ) - ( ( BufferedRandomAccessFileMark ) mark ) . pointer ; assert bytes > = <int> ; return bytes ; } public boolean isEOF ( ) { return current ( ) = = length ( ) ; } public long bytesRemaining ( ) { return length ( ) - getFilePointer ( ) ; } @Override public int available ( ) throws IOException { return Ints . saturatedCast ( bytesRemaining ( ) ) ; } @Override public void close ( ) { if ( buffer = = null ) return ; bufferOffset + = buffer . position ( ) ; releaseBuffer ( ) ; } @Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + <str> + channel + <str> ; } protected static class BufferedRandomAccessFileMark implements FileMark { final long pointer ; public BufferedRandomAccessFileMark ( long pointer ) { this . pointer = pointer ; } } @Override public void seek ( long newPosition ) { if ( newPosition < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( buffer = = null ) throw new IllegalStateException ( <str> ) ; if ( newPosition > = length ( ) ) { if ( newPosition > length ( ) ) throw new IllegalArgumentException ( String . format ( <str> , newPosition , getPath ( ) , length ( ) ) ) ; buffer . limit ( <int> ) ; bufferOffset = newPosition ; return ; } if ( newPosition > = bufferOffset & & newPosition < bufferOffset + buffer . limit ( ) ) { buffer . position ( ( int ) ( newPosition - bufferOffset ) ) ; return ; } bufferOffset = newPosition ; buffer . clear ( ) ; reBuffer ( ) ; assert current ( ) = = newPosition ; } public final String readLine ( ) throws IOException { StringBuilder line = new StringBuilder ( <int> ) ; boolean foundTerminator = false ; long unreadPosition = - <int> ; while ( true ) { int nextByte = read ( ) ; switch ( nextByte ) { case - <int> : return line . length ( ) ! = <int> ? line . toString ( ) : null ; case ( byte ) <str> : if ( foundTerminator ) { seek ( unreadPosition ) ; return line . toString ( ) ; } foundTerminator = true ; unreadPosition = getPosition ( ) ; break ; case ( byte ) <str> : return line . toString ( ) ; default : if ( foundTerminator ) { seek ( unreadPosition ) ; return line . toString ( ) ; } line . append ( ( char ) nextByte ) ; } } } public long length ( ) { return fileLength ; } public long getPosition ( ) { return current ( ) ; } public static class Builder { public final ChannelProxy channel ; public long overrideLength ; public int bufferSize ; public BufferType bufferType ; public ByteBuffer buffer ; public MmappedRegions regions ; public RateLimiter limiter ; public Builder ( ChannelProxy channel ) { this . channel = channel ; this . overrideLength = - <int> ; this . bufferSize = DEFAULT_BUFFER_SIZE ; this . bufferType = BufferType . OFF_HEAP ; this . regions = null ; this . limiter = null ; } private void setBufferSize ( ) { if ( limiter ! = null ) { bufferSize = MAX_BUFFER_SIZE ; return ; } if ( ( bufferSize & ~ <int> ) ! = bufferSize ) { bufferSize = ( bufferSize + <int> ) & ~ <int> ; } bufferSize = Math . min ( MAX_BUFFER_SIZE , bufferSize ) ; } protected ByteBuffer createBuffer ( ) { setBufferSize ( ) ; buffer = regions = = null ? allocateBuffer ( bufferSize , bufferType ) : regions . floor ( <int> ) . buffer . duplicate ( ) ; buffer . limit ( <int> ) ; return buffer ; } public Builder overrideLength ( long overrideLength ) { this . overrideLength = overrideLength ; return this ; } public Builder bufferSize ( int bufferSize ) { if ( bufferSize < = <int> ) throw new IllegalArgumentException ( <str> ) ; this . bufferSize = bufferSize ; return this ; } public Builder bufferType ( BufferType bufferType ) { this . bufferType = bufferType ; return this ; } public Builder regions ( MmappedRegions regions ) { this . regions = regions ; return this ; } public Builder limiter ( RateLimiter limiter ) { this . limiter = limiter ; return this ; } public RandomAccessReader build ( ) { return new RandomAccessReader ( this ) ; } public RandomAccessReader buildWithChannel ( ) { return new RandomAccessReaderWithOwnChannel ( this ) ; } } public static class RandomAccessReaderWithOwnChannel extends RandomAccessReader { protected RandomAccessReaderWithOwnChannel ( Builder builder ) { super ( builder ) ; } @Override public void close ( ) { try { super . close ( ) ; } finally { channel . close ( ) ; } } } @SuppressWarnings ( <str> ) public static RandomAccessReader open ( File file ) { return new Builder ( new ChannelProxy ( file ) ) . buildWithChannel ( ) ; } public static RandomAccessReader open ( ChannelProxy channel ) { return new Builder ( channel ) . build ( ) ; } } 
