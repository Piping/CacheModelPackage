package io . netty . channel . nio ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . ServerChannel ; import java . io . IOException ; import java . net . PortUnreachableException ; import java . nio . channels . SelectableChannel ; import java . nio . channels . SelectionKey ; import java . util . ArrayList ; import java . util . List ; public abstract class AbstractNioMessageChannel extends AbstractNioChannel { protected AbstractNioMessageChannel ( Channel parent , SelectableChannel ch , int readInterestOp ) { super ( parent , ch , readInterestOp ) ; } @Override protected AbstractNioUnsafe newUnsafe ( ) { return new NioMessageUnsafe ( ) ; } private final class NioMessageUnsafe extends AbstractNioUnsafe { private final List < Object > readBuf = new ArrayList < Object > ( ) ; @Override public void read ( ) { assert eventLoop ( ) . inEventLoop ( ) ; final ChannelConfig config = config ( ) ; if ( ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { removeReadOp ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; boolean closed = false ; Throwable exception = null ; try { try { boolean needReadPendingReset = true ; do { int localRead = doReadMessages ( readBuf ) ; if ( localRead = = <int> ) { break ; } if ( localRead < <int> ) { closed = true ; break ; } allocHandle . incMessagesRead ( localRead ) ; if ( needReadPendingReset ) { needReadPendingReset = false ; setReadPending ( false ) ; } } while ( allocHandle . continueReading ( ) ) ; } catch ( Throwable t ) { exception = t ; } int size = readBuf . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { pipeline . fireChannelRead ( readBuf . get ( i ) ) ; } readBuf . clear ( ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( exception ! = null ) { if ( exception instanceof IOException & & ! ( exception instanceof PortUnreachableException ) ) { closed = ! ( AbstractNioMessageChannel . this instanceof ServerChannel ) ; } pipeline . fireExceptionCaught ( exception ) ; } if ( closed ) { setInputShutdown ( ) ; if ( isOpen ( ) ) { close ( voidPromise ( ) ) ; } } } finally { if ( ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { removeReadOp ( ) ; } } } } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { final SelectionKey key = selectionKey ( ) ; final int interestOps = key . interestOps ( ) ; for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { if ( ( interestOps & SelectionKey . OP_WRITE ) ! = <int> ) { key . interestOps ( interestOps & ~ SelectionKey . OP_WRITE ) ; } break ; } try { boolean done = false ; for ( int i = config ( ) . getWriteSpinCount ( ) - <int> ; i > = <int> ; i - - ) { if ( doWriteMessage ( msg , in ) ) { done = true ; break ; } } if ( done ) { in . remove ( ) ; } else { if ( ( interestOps & SelectionKey . OP_WRITE ) = = <int> ) { key . interestOps ( interestOps | SelectionKey . OP_WRITE ) ; } break ; } } catch ( IOException e ) { if ( continueOnWriteError ( ) ) { in . remove ( e ) ; } else { throw e ; } } } } protected boolean continueOnWriteError ( ) { return false ; } protected abstract int doReadMessages ( List < Object > buf ) throws Exception ; protected abstract boolean doWriteMessage ( Object msg , ChannelOutboundBuffer in ) throws Exception ; } 
