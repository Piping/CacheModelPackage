package org . gradle . integtests ; import org . gradle . internal . UncheckedException ; import org . gradle . openapi . external . foundation . RequestObserverVersion1 ; import org . gradle . openapi . external . foundation . RequestVersion1 ; import java . util . Date ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class BlockingRequestObserver implements RequestObserverVersion1 { private final String typeOfInterest ; private RequestVersion1 request ; private Integer result ; private String output ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private Throwable failure ; public BlockingRequestObserver ( ) { this ( RequestVersion1 . EXECUTION_TYPE ) ; } public BlockingRequestObserver ( String typeOfInterest ) { this . typeOfInterest = typeOfInterest ; } public RequestVersion1 getRequest ( ) { lock . lock ( ) ; try { assertComplete ( ) ; return request ; } finally { lock . unlock ( ) ; } } public int getResult ( ) { lock . lock ( ) ; try { assertComplete ( ) ; return result ; } finally { lock . unlock ( ) ; } } public String getOutput ( ) { lock . lock ( ) ; try { assertComplete ( ) ; return output ; } finally { lock . unlock ( ) ; } } private void assertComplete ( ) { if ( request = = null ) { throw new AssertionError ( <str> ) ; } } void reset ( ) { lock . lock ( ) ; try { request = null ; result = null ; output = null ; } finally { lock . unlock ( ) ; } } public void executionRequestAdded ( RequestVersion1 request ) { } public void refreshRequestAdded ( RequestVersion1 request ) { } public void aboutToExecuteRequest ( RequestVersion1 request ) { } public void requestExecutionComplete ( RequestVersion1 request , int result , String output ) { if ( this . typeOfInterest . equals ( request . getType ( ) ) ) { lock . lock ( ) ; try { if ( this . request ! = null ) { failure = new AssertionError ( <str> ) ; } this . request = request ; this . result = result ; this . output = output ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } void waitForRequestExecutionComplete ( int timeOutValue , TimeUnit timeOutUnits ) { lock . lock ( ) ; try { Date expiry = new Date ( System . currentTimeMillis ( ) + timeOutUnits . toMillis ( timeOutValue ) ) ; while ( failure = = null & & request = = null ) { if ( ! condition . awaitUntil ( expiry ) ) { throw new AssertionError ( <str> ) ; } } if ( failure ! = null ) { throw failure ; } } catch ( Throwable t ) { throw UncheckedException . throwAsUncheckedException ( t ) ; } finally { lock . unlock ( ) ; } } } 
