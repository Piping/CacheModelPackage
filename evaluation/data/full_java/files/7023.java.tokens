package org . elasticsearch . rest . action . cat ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestResponseListener ; import org . elasticsearch . rest . action . support . RestTable ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestCountAction extends AbstractCatAction { private final IndicesQueriesRegistry indicesQueriesRegistry ; @Inject public RestCountAction ( Settings settings , RestController restController , RestController controller , Client client , IndicesQueriesRegistry indicesQueriesRegistry ) { super ( settings , controller , client ) ; restController . registerHandler ( GET , <str> , this ) ; restController . registerHandler ( GET , <str> , this ) ; this . indicesQueriesRegistry = indicesQueriesRegistry ; } @Override protected void documentation ( StringBuilder sb ) { sb . append ( <str> ) ; sb . append ( <str> ) ; } @Override public void doRequest ( final RestRequest request , final RestChannel channel , final Client client ) { String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; SearchRequest countRequest = new SearchRequest ( indices ) ; String source = request . param ( <str> ) ; SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder ( ) . size ( <int> ) ; countRequest . source ( searchSourceBuilder ) ; if ( source ! = null ) { searchSourceBuilder . query ( RestActions . getQueryContent ( new BytesArray ( source ) , indicesQueriesRegistry , parseFieldMatcher ) ) ; } else { QueryBuilder < ? > queryBuilder = RestActions . urlParamsToQueryBuilder ( request ) ; if ( queryBuilder ! = null ) { searchSourceBuilder . query ( queryBuilder ) ; } } client . search ( countRequest , new RestResponseListener < SearchResponse > ( channel ) { @Override public RestResponse buildResponse ( SearchResponse countResponse ) throws Exception { return RestTable . buildResponse ( buildTable ( request , countResponse ) , channel ) ; } } ) ; } @Override protected Table getTableWithHeader ( final RestRequest request ) { Table table = new Table ( ) ; table . startHeaders ( ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . endHeaders ( ) ; return table ; } private DateTimeFormatter dateFormat = DateTimeFormat . forPattern ( <str> ) ; private Table buildTable ( RestRequest request , SearchResponse response ) { Table table = getTableWithHeader ( request ) ; long time = System . currentTimeMillis ( ) ; table . startRow ( ) ; table . addCell ( TimeUnit . SECONDS . convert ( time , TimeUnit . MILLISECONDS ) ) ; table . addCell ( dateFormat . print ( time ) ) ; table . addCell ( response . getHits ( ) . totalHits ( ) ) ; table . endRow ( ) ; return table ; } } 
