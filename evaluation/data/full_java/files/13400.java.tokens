package org . gradle . plugins . javascript . rhino . worker ; import org . gradle . api . Action ; import org . gradle . api . UncheckedIOException ; import org . gradle . util . GFileUtils ; import org . mozilla . javascript . Context ; import org . mozilla . javascript . FunctionObject ; import org . mozilla . javascript . Scriptable ; import java . io . * ; import java . util . LinkedHashMap ; import java . util . Map ; public abstract class RhinoWorkerUtils { public static interface ScopeOperation < T > { void initContext ( Context context ) ; T action ( Scriptable scope , Context context ) ; } public static class DefaultScopeOperation < T > implements ScopeOperation < T > { public void initContext ( Context context ) { } public T action ( Scriptable scope , Context context ) { return null ; } } public static String readFile ( File file , String encoding ) { return GFileUtils . readFile ( file , encoding ) ; } public static void writeFile ( String content , File destination , String encoding ) { GFileUtils . writeFile ( content , destination , encoding ) ; } public static Scriptable parse ( File source , String encoding ) { return parse ( source , encoding , null ) ; } public static < T > T parseRhino ( File rhinoScript , ScopeOperation < T > operation ) { Context context = Context . enter ( ) ; try { operation . initContext ( context ) ; Scriptable scope = context . initStandardObjects ( ) ; String printFunction = <str> ; context . evaluateString ( scope , printFunction , <str> , <int> , null ) ; context . evaluateString ( scope , readFile ( rhinoScript , <str> ) , rhinoScript . getName ( ) , <int> , null ) ; return operation . action ( scope , context ) ; } finally { Context . exit ( ) ; } } public static Scriptable parse ( File source , String encoding , Action < Context > contextConfig ) { Context context = Context . enter ( ) ; if ( contextConfig ! = null ) { contextConfig . execute ( context ) ; } Scriptable scope = context . initStandardObjects ( ) ; try { Reader reader = new InputStreamReader ( new FileInputStream ( source ) , encoding ) ; try { context . evaluateReader ( scope , reader , source . getName ( ) , <int> , null ) ; } finally { reader . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } finally { Context . exit ( ) ; } return scope ; } public static < R > R childScope ( Scriptable parentScope , ScopeOperation < R > operation ) { Context context = Context . enter ( ) ; try { operation . initContext ( context ) ; Scriptable childScope = context . newObject ( parentScope ) ; childScope . setParentScope ( parentScope ) ; return operation . action ( childScope , context ) ; } finally { Context . exit ( ) ; } } public static Map < String , Object > toMap ( Scriptable obj ) { Map < String , Object > map = new LinkedHashMap < String , Object > ( ) ; for ( Object id : obj . getIds ( ) ) { String key ; Object value ; if ( id instanceof String ) { key = ( String ) id ; value = obj . get ( key , obj ) ; } else if ( id instanceof Integer ) { key = id . toString ( ) ; value = obj . get ( ( Integer ) id , obj ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , id . getClass ( ) . getName ( ) , id ) ) ; } map . put ( key , toJavaValue ( value ) ) ; } return map ; } public static Object toJavaValue ( Object object ) { if ( object = = null | | object . equals ( Context . getUndefinedValue ( ) ) ) { return null ; } else if ( object . getClass ( ) . getPackage ( ) . getName ( ) . startsWith ( <str> ) ) { return object ; } else if ( object instanceof FunctionObject ) { throw new IllegalArgumentException ( String . format ( <str> , object ) ) ; } else if ( object instanceof Scriptable ) { return toMap ( ( Scriptable ) object ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , object , object . getClass ( ) . getName ( ) ) ) ; } } } 
