package org . elasticsearch . indices . recovery ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . IndexOutput ; import org . apache . lucene . store . RateLimiter ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateObserver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . CancellableThreads ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . engine . RecoveryEngineException ; import org . elasticsearch . index . mapper . MapperException ; import org . elasticsearch . index . shard . * ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Predicate ; import static org . elasticsearch . common . unit . TimeValue . timeValueMillis ; public class RecoveryTarget extends AbstractComponent implements IndexEventListener { public static class Actions { public static final String FILES_INFO = <str> ; public static final String FILE_CHUNK = <str> ; public static final String CLEAN_FILES = <str> ; public static final String TRANSLOG_OPS = <str> ; public static final String PREPARE_TRANSLOG = <str> ; public static final String FINALIZE = <str> ; } private final ThreadPool threadPool ; private final TransportService transportService ; private final RecoverySettings recoverySettings ; private final ClusterService clusterService ; private final RecoveriesCollection onGoingRecoveries ; @Inject public RecoveryTarget ( Settings settings , ThreadPool threadPool , TransportService transportService , RecoverySettings recoverySettings , ClusterService clusterService ) { super ( settings ) ; this . threadPool = threadPool ; this . transportService = transportService ; this . recoverySettings = recoverySettings ; this . clusterService = clusterService ; this . onGoingRecoveries = new RecoveriesCollection ( logger , threadPool ) ; transportService . registerRequestHandler ( Actions . FILES_INFO , RecoveryFilesInfoRequest : : new , ThreadPool . Names . GENERIC , new FilesInfoRequestHandler ( ) ) ; transportService . registerRequestHandler ( Actions . FILE_CHUNK , RecoveryFileChunkRequest : : new , ThreadPool . Names . GENERIC , new FileChunkTransportRequestHandler ( ) ) ; transportService . registerRequestHandler ( Actions . CLEAN_FILES , RecoveryCleanFilesRequest : : new , ThreadPool . Names . GENERIC , new CleanFilesRequestHandler ( ) ) ; transportService . registerRequestHandler ( Actions . PREPARE_TRANSLOG , RecoveryPrepareForTranslogOperationsRequest : : new , ThreadPool . Names . GENERIC , new PrepareForTranslogOperationsRequestHandler ( ) ) ; transportService . registerRequestHandler ( Actions . TRANSLOG_OPS , RecoveryTranslogOperationsRequest : : new , ThreadPool . Names . GENERIC , new TranslogOperationsRequestHandler ( ) ) ; transportService . registerRequestHandler ( Actions . FINALIZE , RecoveryFinalizeRecoveryRequest : : new , ThreadPool . Names . GENERIC , new FinalizeRecoveryRequestHandler ( ) ) ; } @Override public void beforeIndexShardClosed ( ShardId shardId , @Nullable IndexShard indexShard , Settings indexSettings ) { if ( indexShard ! = null ) { onGoingRecoveries . cancelRecoveriesForShard ( shardId , <str> ) ; } } public boolean cancelRecoveriesForShard ( ShardId shardId , String reason , @Nullable Predicate < RecoveryStatus > shouldCancel ) { return onGoingRecoveries . cancelRecoveriesForShard ( shardId , reason , shouldCancel ) ; } public void startRecovery ( final IndexShard indexShard , final RecoveryState . Type recoveryType , final DiscoveryNode sourceNode , final RecoveryListener listener ) { final long recoveryId = onGoingRecoveries . startRecovery ( indexShard , sourceNode , listener , recoverySettings . activityTimeout ( ) ) ; threadPool . generic ( ) . execute ( new RecoveryRunner ( recoveryId ) ) ; } protected void retryRecovery ( final RecoveryStatus recoveryStatus , final Throwable reason , TimeValue retryAfter , final StartRecoveryRequest currentRequest ) { logger . trace ( <str> , reason , recoveryStatus . recoveryId ( ) , retryAfter ) ; retryRecovery ( recoveryStatus , retryAfter , currentRequest ) ; } protected void retryRecovery ( final RecoveryStatus recoveryStatus , final String reason , TimeValue retryAfter , final StartRecoveryRequest currentRequest ) { logger . trace ( <str> , recoveryStatus . recoveryId ( ) , retryAfter , reason ) ; retryRecovery ( recoveryStatus , retryAfter , currentRequest ) ; } private void retryRecovery ( final RecoveryStatus recoveryStatus , TimeValue retryAfter , final StartRecoveryRequest currentRequest ) { try { recoveryStatus . resetRecovery ( ) ; } catch ( Throwable e ) { onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( currentRequest , e ) , true ) ; } threadPool . schedule ( retryAfter , ThreadPool . Names . GENERIC , new RecoveryRunner ( recoveryStatus . recoveryId ( ) ) ) ; } private void doRecovery ( final RecoveryStatus recoveryStatus ) { assert recoveryStatus . sourceNode ( ) ! = null : <str> ; logger . trace ( <str> , recoveryStatus ) ; Store . MetadataSnapshot metadataSnapshot = null ; try { metadataSnapshot = recoveryStatus . store ( ) . getMetadataOrEmpty ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; metadataSnapshot = Store . MetadataSnapshot . EMPTY ; } catch ( Exception e ) { logger . trace ( <str> , e ) ; onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( recoveryStatus . state ( ) , <str> , e ) , true ) ; return ; } final StartRecoveryRequest request = new StartRecoveryRequest ( recoveryStatus . shardId ( ) , recoveryStatus . sourceNode ( ) , clusterService . localNode ( ) , false , metadataSnapshot , recoveryStatus . state ( ) . getType ( ) , recoveryStatus . recoveryId ( ) ) ; final AtomicReference < RecoveryResponse > responseHolder = new AtomicReference < > ( ) ; try { logger . trace ( <str> , request . shardId ( ) . index ( ) . name ( ) , request . shardId ( ) . id ( ) , request . sourceNode ( ) ) ; recoveryStatus . indexShard ( ) . prepareForIndexRecovery ( ) ; recoveryStatus . CancellableThreads ( ) . execute ( new CancellableThreads . Interruptable ( ) { @Override public void run ( ) throws InterruptedException { responseHolder . set ( transportService . submitRequest ( request . sourceNode ( ) , RecoverySource . Actions . START_RECOVERY , request , new FutureTransportResponseHandler < RecoveryResponse > ( ) { @Override public RecoveryResponse newInstance ( ) { return new RecoveryResponse ( ) ; } } ) . txGet ( ) ) ; } } ) ; final RecoveryResponse recoveryResponse = responseHolder . get ( ) ; assert responseHolder ! = null ; final TimeValue recoveryTime = new TimeValue ( recoveryStatus . state ( ) . getTimer ( ) . time ( ) ) ; onGoingRecoveries . markRecoveryAsDone ( recoveryStatus . recoveryId ( ) ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( request . shardId ( ) . index ( ) . name ( ) ) . append ( <str> ) . append ( <str> ) . append ( request . shardId ( ) . id ( ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( request . sourceNode ( ) ) . append ( <str> ) . append ( recoveryTime ) . append ( <str> ) ; sb . append ( <str> ) . append ( recoveryResponse . phase1FileNames . size ( ) ) . append ( <str> ) . append ( <str> ) . append ( new ByteSizeValue ( recoveryResponse . phase1TotalSize ) ) . append ( <str> ) . append ( <str> ) . append ( timeValueMillis ( recoveryResponse . phase1Time ) ) . append ( <str> ) . append ( timeValueMillis ( recoveryResponse . phase1ThrottlingWaitTime ) ) . append ( <str> ) . append ( <str> ) ; sb . append ( <str> ) . append ( recoveryResponse . phase1ExistingFileNames . size ( ) ) . append ( <str> ) . append ( new ByteSizeValue ( recoveryResponse . phase1ExistingTotalSize ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( timeValueMillis ( recoveryResponse . startTime ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( recoveryResponse . phase2Operations ) . append ( <str> ) . append ( <str> ) . append ( <str> ) . append ( timeValueMillis ( recoveryResponse . phase2Time ) ) . append ( <str> ) . append ( <str> ) ; logger . trace ( sb . toString ( ) ) ; } else { logger . debug ( <str> , request . shardId ( ) , recoveryStatus . sourceNode ( ) , recoveryTime ) ; } } catch ( CancellableThreads . ExecutionCancelledException e ) { logger . trace ( <str> , e ) ; } catch ( Throwable e ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , e , request . shardId ( ) . index ( ) . name ( ) , request . shardId ( ) . id ( ) ) ; } Throwable cause = ExceptionsHelper . unwrapCause ( e ) ; if ( cause instanceof CancellableThreads . ExecutionCancelledException ) { onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( request , <str> , cause ) , false ) ; return ; } if ( cause instanceof RecoveryEngineException ) { cause = cause . getCause ( ) ; } cause = ExceptionsHelper . unwrapCause ( cause ) ; if ( cause instanceof RecoveryEngineException ) { cause = cause . getCause ( ) ; } if ( cause instanceof IllegalIndexShardStateException | | cause instanceof IndexNotFoundException | | cause instanceof ShardNotFoundException ) { retryRecovery ( recoveryStatus , <str> , recoverySettings . retryDelayStateSync ( ) , request ) ; return ; } if ( cause instanceof DelayRecoveryException ) { retryRecovery ( recoveryStatus , cause , recoverySettings . retryDelayStateSync ( ) , request ) ; return ; } if ( cause instanceof ConnectTransportException ) { logger . debug ( <str> , recoveryStatus . shardId ( ) , recoverySettings . retryDelayNetwork ( ) , cause . getMessage ( ) ) ; retryRecovery ( recoveryStatus , cause . getMessage ( ) , recoverySettings . retryDelayNetwork ( ) , request ) ; return ; } if ( cause instanceof IndexShardClosedException ) { onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( request , <str> , cause ) , false ) ; return ; } if ( cause instanceof AlreadyClosedException ) { onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( request , <str> , cause ) , false ) ; return ; } onGoingRecoveries . failRecovery ( recoveryStatus . recoveryId ( ) , new RecoveryFailedException ( request , e ) , true ) ; } } public interface RecoveryListener { void onRecoveryDone ( RecoveryState state ) ; void onRecoveryFailure ( RecoveryState state , RecoveryFailedException e , boolean sendShardFailure ) ; } class PrepareForTranslogOperationsRequestHandler implements TransportRequestHandler < RecoveryPrepareForTranslogOperationsRequest > { @Override public void messageReceived ( RecoveryPrepareForTranslogOperationsRequest request , TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final RecoveryStatus recoveryStatus = statusRef . status ( ) ; recoveryStatus . state ( ) . getTranslog ( ) . totalOperations ( request . totalTranslogOps ( ) ) ; recoveryStatus . indexShard ( ) . skipTranslogRecovery ( ) ; } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } class FinalizeRecoveryRequestHandler implements TransportRequestHandler < RecoveryFinalizeRecoveryRequest > { @Override public void messageReceived ( RecoveryFinalizeRecoveryRequest request , TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final RecoveryStatus recoveryStatus = statusRef . status ( ) ; recoveryStatus . indexShard ( ) . finalizeRecovery ( ) ; } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } class TranslogOperationsRequestHandler implements TransportRequestHandler < RecoveryTranslogOperationsRequest > { @Override public void messageReceived ( final RecoveryTranslogOperationsRequest request , final TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final ClusterStateObserver observer = new ClusterStateObserver ( clusterService , null , logger ) ; final RecoveryStatus recoveryStatus = statusRef . status ( ) ; final RecoveryState . Translog translog = recoveryStatus . state ( ) . getTranslog ( ) ; translog . totalOperations ( request . totalTranslogOps ( ) ) ; assert recoveryStatus . indexShard ( ) . recoveryState ( ) = = recoveryStatus . state ( ) ; try { recoveryStatus . indexShard ( ) . performBatchRecovery ( request . operations ( ) ) ; channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } catch ( TranslogRecoveryPerformer . BatchOperationException exception ) { MapperException mapperException = ( MapperException ) ExceptionsHelper . unwrap ( exception , MapperException . class ) ; if ( mapperException = = null ) { throw exception ; } logger . trace ( <str> , exception , exception . completedOperations ( ) ) ; translog . decrementRecoveredOperations ( exception . completedOperations ( ) ) ; observer . waitForNextChange ( new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState state ) { try { messageReceived ( request , channel ) ; } catch ( Exception e ) { onFailure ( e ) ; } } protected void onFailure ( Exception e ) { try { channel . sendResponse ( e ) ; } catch ( IOException e1 ) { logger . warn ( <str> , e1 ) ; } } @Override public void onClusterServiceClose ( ) { onFailure ( new ElasticsearchException ( <str> ) ) ; } @Override public void onTimeout ( TimeValue timeout ) { onFailure ( new ElasticsearchTimeoutException ( <str> + timeout + <str> ) ) ; } } ) ; } } } } class FilesInfoRequestHandler implements TransportRequestHandler < RecoveryFilesInfoRequest > { @Override public void messageReceived ( RecoveryFilesInfoRequest request , TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final RecoveryStatus recoveryStatus = statusRef . status ( ) ; final RecoveryState . Index index = recoveryStatus . state ( ) . getIndex ( ) ; for ( int i = <int> ; i < request . phase1ExistingFileNames . size ( ) ; i + + ) { index . addFileDetail ( request . phase1ExistingFileNames . get ( i ) , request . phase1ExistingFileSizes . get ( i ) , true ) ; } for ( int i = <int> ; i < request . phase1FileNames . size ( ) ; i + + ) { index . addFileDetail ( request . phase1FileNames . get ( i ) , request . phase1FileSizes . get ( i ) , false ) ; } recoveryStatus . state ( ) . getTranslog ( ) . totalOperations ( request . totalTranslogOps ) ; recoveryStatus . state ( ) . getTranslog ( ) . totalOperationsOnStart ( request . totalTranslogOps ) ; channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } } class CleanFilesRequestHandler implements TransportRequestHandler < RecoveryCleanFilesRequest > { @Override public void messageReceived ( RecoveryCleanFilesRequest request , TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final RecoveryStatus recoveryStatus = statusRef . status ( ) ; recoveryStatus . state ( ) . getTranslog ( ) . totalOperations ( request . totalTranslogOps ( ) ) ; recoveryStatus . indexShard ( ) . deleteShardState ( ) ; recoveryStatus . renameAllTempFiles ( ) ; final Store store = recoveryStatus . store ( ) ; recoveryStatus . legacyChecksums ( ) . write ( store ) ; Store . MetadataSnapshot sourceMetaData = request . sourceMetaSnapshot ( ) ; try { store . cleanupAndVerify ( <str> , sourceMetaData ) ; } catch ( CorruptIndexException | IndexFormatTooNewException | IndexFormatTooOldException ex ) { try { try { store . removeCorruptionMarker ( ) ; } finally { Lucene . cleanLuceneIndex ( store . directory ( ) ) ; } } catch ( Throwable e ) { logger . debug ( <str> , e ) ; ex . addSuppressed ( e ) ; } RecoveryFailedException rfe = new RecoveryFailedException ( recoveryStatus . state ( ) , <str> , ex ) ; recoveryStatus . fail ( rfe , true ) ; throw rfe ; } catch ( Exception ex ) { RecoveryFailedException rfe = new RecoveryFailedException ( recoveryStatus . state ( ) , <str> , ex ) ; recoveryStatus . fail ( rfe , true ) ; throw rfe ; } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } } class FileChunkTransportRequestHandler implements TransportRequestHandler < RecoveryFileChunkRequest > { final AtomicLong bytesSinceLastPause = new AtomicLong ( ) ; @Override public void messageReceived ( final RecoveryFileChunkRequest request , TransportChannel channel ) throws Exception { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatusSafe ( request . recoveryId ( ) , request . shardId ( ) ) ) { final RecoveryStatus recoveryStatus = statusRef . status ( ) ; final Store store = recoveryStatus . store ( ) ; recoveryStatus . state ( ) . getTranslog ( ) . totalOperations ( request . totalTranslogOps ( ) ) ; final RecoveryState . Index indexState = recoveryStatus . state ( ) . getIndex ( ) ; if ( request . sourceThrottleTimeInNanos ( ) ! = RecoveryState . Index . UNKNOWN ) { indexState . addSourceThrottling ( request . sourceThrottleTimeInNanos ( ) ) ; } IndexOutput indexOutput ; if ( request . position ( ) = = <int> ) { indexOutput = recoveryStatus . openAndPutIndexOutput ( request . name ( ) , request . metadata ( ) , store ) ; } else { indexOutput = recoveryStatus . getOpenIndexOutput ( request . name ( ) ) ; } BytesReference content = request . content ( ) ; if ( ! content . hasArray ( ) ) { content = content . toBytesArray ( ) ; } RateLimiter rl = recoverySettings . rateLimiter ( ) ; if ( rl ! = null ) { long bytes = bytesSinceLastPause . addAndGet ( content . length ( ) ) ; if ( bytes > rl . getMinPauseCheckBytes ( ) ) { bytesSinceLastPause . addAndGet ( - bytes ) ; long throttleTimeInNanos = rl . pause ( bytes ) ; indexState . addTargetThrottling ( throttleTimeInNanos ) ; recoveryStatus . indexShard ( ) . recoveryStats ( ) . addThrottleTime ( throttleTimeInNanos ) ; } } indexOutput . writeBytes ( content . array ( ) , content . arrayOffset ( ) , content . length ( ) ) ; indexState . addRecoveredBytesToFile ( request . name ( ) , content . length ( ) ) ; if ( indexOutput . getFilePointer ( ) > = request . length ( ) | | request . lastChunk ( ) ) { try { Store . verify ( indexOutput ) ; } finally { indexOutput . close ( ) ; } recoveryStatus . legacyChecksums ( ) . add ( request . metadata ( ) ) ; final String temporaryFileName = recoveryStatus . getTempNameForFile ( request . name ( ) ) ; assert Arrays . asList ( store . directory ( ) . listAll ( ) ) . contains ( temporaryFileName ) ; store . directory ( ) . sync ( Collections . singleton ( temporaryFileName ) ) ; IndexOutput remove = recoveryStatus . removeOpenIndexOutputs ( request . name ( ) ) ; assert remove = = null | | remove = = indexOutput ; } } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } class RecoveryRunner extends AbstractRunnable { final long recoveryId ; RecoveryRunner ( long recoveryId ) { this . recoveryId = recoveryId ; } @Override public void onFailure ( Throwable t ) { try ( RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatus ( recoveryId ) ) { if ( statusRef ! = null ) { logger . error ( <str> , t , recoveryId ) ; onGoingRecoveries . failRecovery ( recoveryId , new RecoveryFailedException ( statusRef . status ( ) . state ( ) , <str> , t ) , true ) ; } else { logger . debug ( <str> , t , recoveryId ) ; } } } @Override public void doRun ( ) { RecoveriesCollection . StatusRef statusRef = onGoingRecoveries . getStatus ( recoveryId ) ; if ( statusRef = = null ) { logger . trace ( <str> , recoveryId ) ; return ; } try { doRecovery ( statusRef . status ( ) ) ; } finally { statusRef . close ( ) ; } } } } 
