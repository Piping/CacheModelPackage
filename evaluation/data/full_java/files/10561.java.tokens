package com . google . common . math ; import static java . math . BigInteger . ONE ; import static java . math . BigInteger . ZERO ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . DOWN ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . HALF_DOWN ; import static java . math . RoundingMode . HALF_EVEN ; import static java . math . RoundingMode . HALF_UP ; import static java . math . RoundingMode . UP ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . base . Predicate ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . primitives . Doubles ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible public class MathTesting { static final ImmutableSet < RoundingMode > ALL_ROUNDING_MODES = ImmutableSet . copyOf ( RoundingMode . values ( ) ) ; static final ImmutableList < RoundingMode > ALL_SAFE_ROUNDING_MODES = ImmutableList . of ( DOWN , UP , FLOOR , CEILING , HALF_EVEN , HALF_UP , HALF_DOWN ) ; static final ImmutableList < Integer > EXPONENTS = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; private static final Function < Integer , Long > TO_LONG = new Function < Integer , Long > ( ) { @Override public Long apply ( Integer n ) { return Long . valueOf ( n ) ; } } ; private static final Function < Long , BigInteger > TO_BIGINTEGER = new Function < Long , BigInteger > ( ) { @Override public BigInteger apply ( Long n ) { return BigInteger . valueOf ( n ) ; } } ; private static final Function < Integer , Integer > NEGATE_INT = new Function < Integer , Integer > ( ) { @Override public Integer apply ( Integer x ) { return - x ; } } ; private static final Function < Long , Long > NEGATE_LONG = new Function < Long , Long > ( ) { @Override public Long apply ( Long x ) { return - x ; } } ; private static final Function < BigInteger , BigInteger > NEGATE_BIGINT = new Function < BigInteger , BigInteger > ( ) { @Override public BigInteger apply ( BigInteger x ) { return x . negate ( ) ; } } ; static final ImmutableSet < Integer > POSITIVE_INTEGER_CANDIDATES ; static final Iterable < Integer > NEGATIVE_INTEGER_CANDIDATES ; static final Iterable < Integer > NONZERO_INTEGER_CANDIDATES ; static final Iterable < Integer > ALL_INTEGER_CANDIDATES ; static { ImmutableSet . Builder < Integer > intValues = ImmutableSet . builder ( ) ; intValues . add ( Integer . MAX_VALUE - <int> , Integer . MAX_VALUE ) ; for ( int i = <int> ; i < = <int> ; i + + ) { intValues . add ( i ) ; } for ( int exponent : asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) { int x = <int> < < exponent ; intValues . add ( x , x + <int> , x - <int> ) ; } intValues . add ( <int> ) . add ( <int> ) . add ( <int> ) . add ( <int> ) ; intValues . add ( <int> ) . add ( <int> ) ; POSITIVE_INTEGER_CANDIDATES = intValues . build ( ) ; NEGATIVE_INTEGER_CANDIDATES = ImmutableList . copyOf ( Iterables . concat ( Iterables . transform ( POSITIVE_INTEGER_CANDIDATES , NEGATE_INT ) , ImmutableList . of ( Integer . MIN_VALUE ) ) ) ; NONZERO_INTEGER_CANDIDATES = ImmutableList . copyOf ( Iterables . concat ( POSITIVE_INTEGER_CANDIDATES , NEGATIVE_INTEGER_CANDIDATES ) ) ; ALL_INTEGER_CANDIDATES = Iterables . concat ( NONZERO_INTEGER_CANDIDATES , ImmutableList . of ( <int> ) ) ; } static final ImmutableSet < Long > POSITIVE_LONG_CANDIDATES ; static final Iterable < Long > NEGATIVE_LONG_CANDIDATES ; static final Iterable < Long > NONZERO_LONG_CANDIDATES ; static final Iterable < Long > ALL_LONG_CANDIDATES ; static { ImmutableSet . Builder < Long > longValues = ImmutableSet . builder ( ) ; longValues . addAll ( Iterables . transform ( POSITIVE_INTEGER_CANDIDATES , TO_LONG ) ) ; longValues . add ( Integer . MAX_VALUE + <int> , Long . MAX_VALUE - <int> , Long . MAX_VALUE ) ; for ( int exponent : asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) { long x = <int> < < exponent ; longValues . add ( x , x + <int> , x - <int> ) ; } longValues . add ( <int> ) . add ( <int> ) ; POSITIVE_LONG_CANDIDATES = longValues . build ( ) ; NEGATIVE_LONG_CANDIDATES = Iterables . concat ( Iterables . transform ( POSITIVE_LONG_CANDIDATES , NEGATE_LONG ) , ImmutableList . of ( Long . MIN_VALUE ) ) ; NONZERO_LONG_CANDIDATES = Iterables . concat ( POSITIVE_LONG_CANDIDATES , NEGATIVE_LONG_CANDIDATES ) ; ALL_LONG_CANDIDATES = Iterables . concat ( NONZERO_LONG_CANDIDATES , ImmutableList . of ( <int> L ) ) ; } static final ImmutableSet < BigInteger > POSITIVE_BIGINTEGER_CANDIDATES ; static final Iterable < BigInteger > NEGATIVE_BIGINTEGER_CANDIDATES ; static final Iterable < BigInteger > NONZERO_BIGINTEGER_CANDIDATES ; static final Iterable < BigInteger > ALL_BIGINTEGER_CANDIDATES ; static { ImmutableSet . Builder < BigInteger > bigValues = ImmutableSet . builder ( ) ; bigValues . addAll ( Iterables . transform ( POSITIVE_LONG_CANDIDATES , TO_BIGINTEGER ) ) ; bigValues . add ( BigInteger . valueOf ( Long . MAX_VALUE ) . add ( ONE ) ) ; for ( int exponent : asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , Double . MAX_EXPONENT - <int> , Double . MAX_EXPONENT , Double . MAX_EXPONENT + <int> ) ) { BigInteger x = ONE . shiftLeft ( exponent ) ; bigValues . add ( x , x . add ( ONE ) , x . subtract ( ONE ) ) ; } bigValues . add ( new BigInteger ( <str> ) ) ; bigValues . add ( new BigInteger ( <str> ) ) ; POSITIVE_BIGINTEGER_CANDIDATES = bigValues . build ( ) ; NEGATIVE_BIGINTEGER_CANDIDATES = Iterables . transform ( POSITIVE_BIGINTEGER_CANDIDATES , NEGATE_BIGINT ) ; NONZERO_BIGINTEGER_CANDIDATES = Iterables . concat ( POSITIVE_BIGINTEGER_CANDIDATES , NEGATIVE_BIGINTEGER_CANDIDATES ) ; ALL_BIGINTEGER_CANDIDATES = Iterables . concat ( NONZERO_BIGINTEGER_CANDIDATES , ImmutableList . of ( ZERO ) ) ; } static final ImmutableSet < Double > INTEGRAL_DOUBLE_CANDIDATES ; static final ImmutableSet < Double > FRACTIONAL_DOUBLE_CANDIDATES ; static final Iterable < Double > INFINITIES = Doubles . asList ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY ) ; static final Iterable < Double > FINITE_DOUBLE_CANDIDATES ; static final Iterable < Double > POSITIVE_FINITE_DOUBLE_CANDIDATES ; static final Iterable < Double > ALL_DOUBLE_CANDIDATES ; static final Iterable < Double > DOUBLE_CANDIDATES_EXCEPT_NAN ; static { ImmutableSet . Builder < Double > integralBuilder = ImmutableSet . builder ( ) ; ImmutableSet . Builder < Double > fractionalBuilder = ImmutableSet . builder ( ) ; integralBuilder . addAll ( Doubles . asList ( <float> , - <float> , Double . MAX_VALUE , - Double . MAX_VALUE ) ) ; for ( int scale = <int> ; scale < = <int> ; scale + + ) { for ( double d : Doubles . asList ( Double . MIN_VALUE , Double . MIN_NORMAL ) ) { fractionalBuilder . add ( d * scale ) . add ( - d * scale ) ; } } for ( double d : Doubles . asList ( <int> , <int> , <int> , <int> , <int> , <int> , Math . scalb ( <float> , <int> ) , Integer . MIN_VALUE , Integer . MAX_VALUE , Long . MIN_VALUE , Long . MAX_VALUE ) ) { for ( double delta : Doubles . asList ( <float> , <float> , <float> ) ) { integralBuilder . addAll ( Doubles . asList ( d + delta , d - delta , - d - delta , - d + delta ) ) ; } for ( double delta : Doubles . asList ( <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> ) ) { double x = d + delta ; if ( x ! = Math . round ( x ) ) { fractionalBuilder . add ( x ) ; } } } INTEGRAL_DOUBLE_CANDIDATES = integralBuilder . build ( ) ; fractionalBuilder . add ( <float> ) . add ( <float> ) . add ( Math . sqrt ( <int> ) ) ; fractionalBuilder . add ( <float> ) . add ( <float> ) . add ( <int> * Math . sqrt ( <int> ) ) ; for ( double d : INTEGRAL_DOUBLE_CANDIDATES ) { double x = <int> / d ; if ( x ! = Math . rint ( x ) ) { fractionalBuilder . add ( x ) ; } } FRACTIONAL_DOUBLE_CANDIDATES = fractionalBuilder . build ( ) ; FINITE_DOUBLE_CANDIDATES = Iterables . concat ( FRACTIONAL_DOUBLE_CANDIDATES , INTEGRAL_DOUBLE_CANDIDATES ) ; POSITIVE_FINITE_DOUBLE_CANDIDATES = Iterables . filter ( FINITE_DOUBLE_CANDIDATES , new Predicate < Double > ( ) { @Override public boolean apply ( Double input ) { return input . doubleValue ( ) > <float> ; } } ) ; DOUBLE_CANDIDATES_EXCEPT_NAN = Iterables . concat ( FINITE_DOUBLE_CANDIDATES , INFINITIES ) ; ALL_DOUBLE_CANDIDATES = Iterables . concat ( DOUBLE_CANDIDATES_EXCEPT_NAN , asList ( Double . NaN ) ) ; } } 
