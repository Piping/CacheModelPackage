package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . ShortArray ; public class ConvexHull { private final IntArray quicksortStack = new IntArray ( ) ; private float [ ] sortedPoints ; private final FloatArray hull = new FloatArray ( ) ; private final IntArray indices = new IntArray ( ) ; private final ShortArray originalIndices = new ShortArray ( false , <int> ) ; public FloatArray computePolygon ( FloatArray points , boolean sorted ) { return computePolygon ( points . items , <int> , points . size , sorted ) ; } public FloatArray computePolygon ( float [ ] polygon , boolean sorted ) { return computePolygon ( polygon , <int> , polygon . length , sorted ) ; } public FloatArray computePolygon ( float [ ] points , int offset , int count , boolean sorted ) { int end = offset + count ; if ( ! sorted ) { if ( sortedPoints = = null | | sortedPoints . length < count ) sortedPoints = new float [ count ] ; System . arraycopy ( points , offset , sortedPoints , <int> , count ) ; points = sortedPoints ; offset = <int> ; sort ( points , count ) ; } FloatArray hull = this . hull ; hull . clear ( ) ; for ( int i = offset ; i < end ; i + = <int> ) { float x = points [ i ] ; float y = points [ i + <int> ] ; while ( hull . size > = <int> & & ccw ( x , y ) < = <int> ) hull . size - = <int> ; hull . add ( x ) ; hull . add ( y ) ; } for ( int i = end - <int> , t = hull . size + <int> ; i > = offset ; i - = <int> ) { float x = points [ i ] ; float y = points [ i + <int> ] ; while ( hull . size > = t & & ccw ( x , y ) < = <int> ) hull . size - = <int> ; hull . add ( x ) ; hull . add ( y ) ; } return hull ; } public IntArray computeIndices ( FloatArray points , boolean sorted , boolean yDown ) { return computeIndices ( points . items , <int> , points . size , sorted , yDown ) ; } public IntArray computeIndices ( float [ ] polygon , boolean sorted , boolean yDown ) { return computeIndices ( polygon , <int> , polygon . length , sorted , yDown ) ; } public IntArray computeIndices ( float [ ] points , int offset , int count , boolean sorted , boolean yDown ) { int end = offset + count ; if ( ! sorted ) { if ( sortedPoints = = null | | sortedPoints . length < count ) sortedPoints = new float [ count ] ; System . arraycopy ( points , offset , sortedPoints , <int> , count ) ; points = sortedPoints ; offset = <int> ; sortWithIndices ( points , count , yDown ) ; } IntArray indices = this . indices ; indices . clear ( ) ; FloatArray hull = this . hull ; hull . clear ( ) ; for ( int i = offset , index = i / <int> ; i < end ; i + = <int> , index + + ) { float x = points [ i ] ; float y = points [ i + <int> ] ; while ( hull . size > = <int> & & ccw ( x , y ) < = <int> ) { hull . size - = <int> ; indices . size - - ; } hull . add ( x ) ; hull . add ( y ) ; indices . add ( index ) ; } for ( int i = end - <int> , index = i / <int> , t = hull . size + <int> ; i > = offset ; i - = <int> , index - - ) { float x = points [ i ] ; float y = points [ i + <int> ] ; while ( hull . size > = t & & ccw ( x , y ) < = <int> ) { hull . size - = <int> ; indices . size - - ; } hull . add ( x ) ; hull . add ( y ) ; indices . add ( index ) ; } if ( ! sorted ) { short [ ] originalIndicesArray = originalIndices . items ; int [ ] indicesArray = indices . items ; for ( int i = <int> , n = indices . size ; i < n ; i + + ) indicesArray [ i ] = originalIndicesArray [ indicesArray [ i ] ] ; } return indices ; } private float ccw ( float p3x , float p3y ) { FloatArray hull = this . hull ; int size = hull . size ; float p1x = hull . get ( size - <int> ) ; float p1y = hull . get ( size - <int> ) ; float p2x = hull . get ( size - <int> ) ; float p2y = hull . peek ( ) ; return ( p2x - p1x ) * ( p3y - p1y ) - ( p2y - p1y ) * ( p3x - p1x ) ; } private void sort ( float [ ] values , int count ) { int lower = <int> ; int upper = count - <int> ; IntArray stack = quicksortStack ; stack . add ( lower ) ; stack . add ( upper - <int> ) ; while ( stack . size > <int> ) { upper = stack . pop ( ) ; lower = stack . pop ( ) ; if ( upper < = lower ) continue ; int i = quicksortPartition ( values , lower , upper ) ; if ( i - lower > upper - i ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } stack . add ( i + <int> ) ; stack . add ( upper ) ; if ( upper - i > = i - lower ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } } } private int quicksortPartition ( final float [ ] values , int lower , int upper ) { float x = values [ lower ] ; float y = values [ lower + <int> ] ; int up = upper ; int down = lower ; float temp ; short tempIndex ; while ( down < up ) { while ( down < up & & values [ down ] < = x ) down = down + <int> ; while ( values [ up ] > x | | ( values [ up ] = = x & & values [ up + <int> ] < y ) ) up = up - <int> ; if ( down < up ) { temp = values [ down ] ; values [ down ] = values [ up ] ; values [ up ] = temp ; temp = values [ down + <int> ] ; values [ down + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = temp ; } } values [ lower ] = values [ up ] ; values [ up ] = x ; values [ lower + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = y ; return up ; } private void sortWithIndices ( float [ ] values , int count , boolean yDown ) { int pointCount = count / <int> ; originalIndices . clear ( ) ; originalIndices . ensureCapacity ( pointCount ) ; short [ ] originalIndicesArray = originalIndices . items ; for ( short i = <int> ; i < pointCount ; i + + ) originalIndicesArray [ i ] = i ; int lower = <int> ; int upper = count - <int> ; IntArray stack = quicksortStack ; stack . add ( lower ) ; stack . add ( upper - <int> ) ; while ( stack . size > <int> ) { upper = stack . pop ( ) ; lower = stack . pop ( ) ; if ( upper < = lower ) continue ; int i = quicksortPartitionWithIndices ( values , lower , upper , yDown , originalIndicesArray ) ; if ( i - lower > upper - i ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } stack . add ( i + <int> ) ; stack . add ( upper ) ; if ( upper - i > = i - lower ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } } } private int quicksortPartitionWithIndices ( final float [ ] values , int lower , int upper , boolean yDown , short [ ] originalIndices ) { float x = values [ lower ] ; float y = values [ lower + <int> ] ; int up = upper ; int down = lower ; float temp ; short tempIndex ; while ( down < up ) { while ( down < up & & values [ down ] < = x ) down = down + <int> ; if ( yDown ) { while ( values [ up ] > x | | ( values [ up ] = = x & & values [ up + <int> ] < y ) ) up = up - <int> ; } else { while ( values [ up ] > x | | ( values [ up ] = = x & & values [ up + <int> ] > y ) ) up = up - <int> ; } if ( down < up ) { temp = values [ down ] ; values [ down ] = values [ up ] ; values [ up ] = temp ; temp = values [ down + <int> ] ; values [ down + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = temp ; tempIndex = originalIndices [ down / <int> ] ; originalIndices [ down / <int> ] = originalIndices [ up / <int> ] ; originalIndices [ up / <int> ] = tempIndex ; } } values [ lower ] = values [ up ] ; values [ up ] = x ; values [ lower + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = y ; tempIndex = originalIndices [ lower / <int> ] ; originalIndices [ lower / <int> ] = originalIndices [ up / <int> ] ; originalIndices [ up / <int> ] = tempIndex ; return up ; } } 
