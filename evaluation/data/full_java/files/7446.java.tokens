package org . elasticsearch . search . aggregations . support ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . AggregationInitializationException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormat ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public abstract class ValuesSourceAggregatorFactory < VS extends ValuesSource > extends AggregatorFactory { public static abstract class LeafOnly < VS extends ValuesSource > extends ValuesSourceAggregatorFactory < VS > { protected LeafOnly ( String name , String type , ValuesSourceConfig < VS > valuesSourceConfig ) { super ( name , type , valuesSourceConfig ) ; } @Override public AggregatorFactory subFactories ( AggregatorFactories subFactories ) { throw new AggregationInitializationException ( <str> + name + <str> + type + <str> ) ; } } protected ValuesSourceConfig < VS > config ; protected ValuesSourceAggregatorFactory ( String name , String type , ValuesSourceConfig < VS > config ) { super ( name , type ) ; this . config = config ; } @Override public Aggregator createInternal ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { VS vs = context . valuesSource ( config , context . searchContext ( ) ) ; if ( vs = = null ) { return createUnmapped ( context , parent , pipelineAggregators , metaData ) ; } return doCreateInternal ( vs , context , parent , collectsFromSingleBucket , pipelineAggregators , metaData ) ; } @Override public void doValidate ( ) { if ( config = = null | | ! config . valid ( ) ) { resolveValuesSourceConfigFromAncestors ( name , parent , config . valueSourceType ( ) ) ; } } protected abstract Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException ; protected abstract Aggregator doCreateInternal ( VS valuesSource , AggregationContext aggregationContext , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException ; private void resolveValuesSourceConfigFromAncestors ( String aggName , AggregatorFactory parent , Class < VS > requiredValuesSourceType ) { ValuesSourceConfig config ; while ( parent ! = null ) { if ( parent instanceof ValuesSourceAggregatorFactory ) { config = ( ( ValuesSourceAggregatorFactory ) parent ) . config ; if ( config ! = null & & config . valid ( ) ) { if ( requiredValuesSourceType = = null | | requiredValuesSourceType . isAssignableFrom ( config . valueSourceType ) ) { ValueFormat format = config . format ; this . config = config ; if ( this . config . formatPattern ! = null & & format ! = null & & format instanceof ValueFormat . Patternable ) { this . config . format = ( ( ValueFormat . Patternable ) format ) . create ( this . config . formatPattern ) ; } return ; } } } parent = parent . parent ( ) ; } throw new AggregationExecutionException ( <str> + aggName + <str> ) ; } } 
