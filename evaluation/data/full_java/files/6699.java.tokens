package org . elasticsearch . index . query . functionscore ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . FunctionScoreQuery ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . * ; import org . elasticsearch . index . query . functionscore . weight . WeightBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class FunctionScoreQueryParser implements QueryParser < FunctionScoreQueryBuilder > { private static final FunctionScoreQueryBuilder PROTOTYPE = new FunctionScoreQueryBuilder ( EmptyQueryBuilder . PROTOTYPE , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ <int> ] ) ; static final String MISPLACED_FUNCTION_MESSAGE_PREFIX = <str> ; public static final ParseField WEIGHT_FIELD = new ParseField ( <str> ) ; private final ScoreFunctionParserMapper functionParserMapper ; @Inject public FunctionScoreQueryParser ( ScoreFunctionParserMapper functionParserMapper ) { this . functionParserMapper = functionParserMapper ; } @Override public String [ ] names ( ) { return new String [ ] { FunctionScoreQueryBuilder . NAME , Strings . toCamelCase ( FunctionScoreQueryBuilder . NAME ) } ; } @Override public FunctionScoreQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; QueryBuilder query = null ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; String queryName = null ; FiltersFunctionScoreQuery . ScoreMode scoreMode = FunctionScoreQueryBuilder . DEFAULT_SCORE_MODE ; float maxBoost = FunctionScoreQuery . DEFAULT_MAX_BOOST ; Float minScore = null ; String currentFieldName = null ; XContentParser . Token token ; CombineFunction combineFunction = null ; boolean functionArrayFound = false ; boolean singleFunctionFound = false ; String singleFunctionName = null ; List < FunctionScoreQueryBuilder . FilterFunctionBuilder > filterFunctionBuilders = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { query = parseContext . parseInnerQueryBuilder ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { scoreMode = FiltersFunctionScoreQuery . ScoreMode . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { combineFunction = CombineFunction . fromString ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { maxBoost = parser . floatValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { boost = parser . floatValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { queryName = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { minScore = parser . floatValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { if ( singleFunctionFound ) { String errorString = <str> + singleFunctionName + <str> ; handleMisplacedFunctionsDeclaration ( parser . getTokenLocation ( ) , errorString ) ; } functionArrayFound = true ; currentFieldName = parseFiltersAndFunctions ( parseContext , parser , filterFunctionBuilders ) ; } else { if ( singleFunctionFound ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> , FunctionScoreQueryBuilder . NAME , singleFunctionName , currentFieldName ) ; } if ( functionArrayFound ) { String errorString = <str> + currentFieldName + <str> ; handleMisplacedFunctionsDeclaration ( parser . getTokenLocation ( ) , errorString ) ; } singleFunctionFound = true ; singleFunctionName = currentFieldName ; ScoreFunctionBuilder < ? > scoreFunction ; if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , WEIGHT_FIELD ) ) { scoreFunction = new WeightBuilder ( ) . setWeight ( parser . floatValue ( ) ) ; } else { scoreFunction = functionParserMapper . get ( parser . getTokenLocation ( ) , currentFieldName ) . fromXContent ( parseContext , parser ) ; } filterFunctionBuilders . add ( new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scoreFunction ) ) ; } } if ( query = = null ) { query = new MatchAllQueryBuilder ( ) ; } FunctionScoreQueryBuilder functionScoreQueryBuilder = new FunctionScoreQueryBuilder ( query , filterFunctionBuilders . toArray ( new FunctionScoreQueryBuilder . FilterFunctionBuilder [ filterFunctionBuilders . size ( ) ] ) ) ; if ( combineFunction ! = null ) { functionScoreQueryBuilder . boostMode ( combineFunction ) ; } functionScoreQueryBuilder . scoreMode ( scoreMode ) ; functionScoreQueryBuilder . maxBoost ( maxBoost ) ; if ( minScore ! = null ) { functionScoreQueryBuilder . setMinScore ( minScore ) ; } functionScoreQueryBuilder . boost ( boost ) ; functionScoreQueryBuilder . queryName ( queryName ) ; return functionScoreQueryBuilder ; } private static void handleMisplacedFunctionsDeclaration ( XContentLocation contentLocation , String errorString ) { throw new ParsingException ( contentLocation , <str> , FunctionScoreQueryBuilder . NAME , MISPLACED_FUNCTION_MESSAGE_PREFIX + errorString ) ; } private String parseFiltersAndFunctions ( QueryParseContext parseContext , XContentParser parser , List < FunctionScoreQueryBuilder . FilterFunctionBuilder > filterFunctionBuilders ) throws IOException { String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { QueryBuilder filter = null ; ScoreFunctionBuilder < ? > scoreFunction = null ; Float functionWeight = null ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> , XContentParser . Token . START_OBJECT , token , FunctionScoreQueryBuilder . NAME ) ; } else { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , WEIGHT_FIELD ) ) { functionWeight = parser . floatValue ( ) ; } else { if ( <str> . equals ( currentFieldName ) ) { filter = parseContext . parseInnerQueryBuilder ( ) ; } else { if ( scoreFunction ! = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> , scoreFunction . getName ( ) , currentFieldName ) ; } ScoreFunctionParser functionParser = functionParserMapper . get ( parser . getTokenLocation ( ) , currentFieldName ) ; scoreFunction = functionParser . fromXContent ( parseContext , parser ) ; } } } if ( functionWeight ! = null ) { if ( scoreFunction = = null ) { scoreFunction = new WeightBuilder ( ) . setWeight ( functionWeight ) ; } else { scoreFunction . setWeight ( functionWeight ) ; } } } if ( filter = = null ) { filter = new MatchAllQueryBuilder ( ) ; } if ( scoreFunction = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> , FunctionScoreQueryBuilder . NAME ) ; } filterFunctionBuilders . add ( new FunctionScoreQueryBuilder . FilterFunctionBuilder ( filter , scoreFunction ) ) ; } return currentFieldName ; } @Override public FunctionScoreQueryBuilder getBuilderPrototype ( ) { return PROTOTYPE ; } } 
