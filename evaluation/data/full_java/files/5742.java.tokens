package org . elasticsearch . common . hash ; import org . elasticsearch . common . util . ByteUtils ; public enum MurmurHash3 { ; public static class Hash128 { public long h1 , h2 ; } private static long C1 = <hex> ; private static long C2 = <hex> ; protected static long getblock ( byte [ ] key , int offset , int index ) { int i_8 = index < < <int> ; int blockOffset = offset + i_8 ; return ByteUtils . readLongLE ( key , blockOffset ) ; } protected static long fmix ( long k ) { k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; return k ; } public static Hash128 hash128 ( byte [ ] key , int offset , int length , long seed , Hash128 hash ) { long h1 = seed ; long h2 = seed ; if ( length > = <int> ) { final int len16 = length & <hex> ; final int end = offset + len16 ; for ( int i = offset ; i < end ; i + = <int> ) { long k1 = ByteUtils . readLongLE ( key , i ) ; long k2 = ByteUtils . readLongLE ( key , i + <int> ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , <int> ) ; k1 * = C2 ; h1 ^ = k1 ; h1 = Long . rotateLeft ( h1 , <int> ) ; h1 + = h2 ; h1 = h1 * <int> + <hex> ; k2 * = C2 ; k2 = Long . rotateLeft ( k2 , <int> ) ; k2 * = C1 ; h2 ^ = k2 ; h2 = Long . rotateLeft ( h2 , <int> ) ; h2 + = h1 ; h2 = h2 * <int> + <hex> ; } offset = end ; } long k1 = <int> ; long k2 = <int> ; switch ( length & <int> ) { case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k2 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; k2 * = C2 ; k2 = Long . rotateLeft ( k2 , <int> ) ; k2 * = C1 ; h2 ^ = k2 ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset + <int> ] & <hex> ) < < <int> ; case <int> : k1 ^ = ( key [ offset ] & <hex> ) ; k1 * = C1 ; k1 = Long . rotateLeft ( k1 , <int> ) ; k1 * = C2 ; h1 ^ = k1 ; } h1 ^ = length ; h2 ^ = length ; h1 + = h2 ; h2 + = h1 ; h1 = fmix ( h1 ) ; h2 = fmix ( h2 ) ; h1 + = h2 ; h2 + = h1 ; hash . h1 = h1 ; hash . h2 = h2 ; return hash ; } } 
