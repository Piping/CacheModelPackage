package io . netty . channel . embedded ; import io . netty . channel . AbstractChannel ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelId ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelConfig ; import io . netty . channel . EventLoop ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . RecyclableArrayList ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . SocketAddress ; import java . nio . channels . ClosedChannelException ; import java . util . ArrayDeque ; import java . util . Queue ; public class EmbeddedChannel extends AbstractChannel { private static final SocketAddress LOCAL_ADDRESS = new EmbeddedSocketAddress ( ) ; private static final SocketAddress REMOTE_ADDRESS = new EmbeddedSocketAddress ( ) ; private static final ChannelHandler [ ] EMPTY_HANDLERS = new ChannelHandler [ <int> ] ; private enum State { OPEN , ACTIVE , CLOSED } private static final InternalLogger logger = InternalLoggerFactory . getInstance ( EmbeddedChannel . class ) ; private static final ChannelMetadata METADATA = new ChannelMetadata ( false ) ; private final EmbeddedEventLoop loop = new EmbeddedEventLoop ( ) ; private final ChannelConfig config = new DefaultChannelConfig ( this ) ; private Queue < Object > inboundMessages ; private Queue < Object > outboundMessages ; private Throwable lastException ; private State state ; public EmbeddedChannel ( ) { this ( EMPTY_HANDLERS ) ; } public EmbeddedChannel ( ChannelId channelId ) { this ( channelId , EMPTY_HANDLERS ) ; } public EmbeddedChannel ( final ChannelHandler . . . handlers ) { this ( EmbeddedChannelId . INSTANCE , handlers ) ; } public EmbeddedChannel ( ChannelId channelId , final ChannelHandler . . . handlers ) { super ( null , channelId ) ; if ( handlers = = null ) { throw new NullPointerException ( <str> ) ; } ChannelPipeline p = pipeline ( ) ; p . addLast ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; for ( ChannelHandler h : handlers ) { if ( h = = null ) { break ; } pipeline . addLast ( h ) ; } } } ) ; ChannelFuture future = loop . register ( this ) ; assert future . isDone ( ) ; p . addLast ( new LastInboundHandler ( ) ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public ChannelConfig config ( ) { return config ; } @Override public boolean isOpen ( ) { return state ! = State . CLOSED ; } @Override public boolean isActive ( ) { return state = = State . ACTIVE ; } public Queue < Object > inboundMessages ( ) { if ( inboundMessages = = null ) { inboundMessages = new ArrayDeque < Object > ( ) ; } return inboundMessages ; } @Deprecated public Queue < Object > lastInboundBuffer ( ) { return inboundMessages ( ) ; } public Queue < Object > outboundMessages ( ) { if ( outboundMessages = = null ) { outboundMessages = new ArrayDeque < Object > ( ) ; } return outboundMessages ; } @Deprecated public Queue < Object > lastOutboundBuffer ( ) { return outboundMessages ( ) ; } @SuppressWarnings ( <str> ) public < T > T readInbound ( ) { return ( T ) poll ( inboundMessages ) ; } @SuppressWarnings ( <str> ) public < T > T readOutbound ( ) { return ( T ) poll ( outboundMessages ) ; } public boolean writeInbound ( Object . . . msgs ) { ensureOpen ( ) ; if ( msgs . length = = <int> ) { return isNotEmpty ( inboundMessages ) ; } ChannelPipeline p = pipeline ( ) ; for ( Object m : msgs ) { p . fireChannelRead ( m ) ; } p . fireChannelReadComplete ( ) ; runPendingTasks ( ) ; checkException ( ) ; return isNotEmpty ( inboundMessages ) ; } public boolean writeOutbound ( Object . . . msgs ) { ensureOpen ( ) ; if ( msgs . length = = <int> ) { return isNotEmpty ( outboundMessages ) ; } RecyclableArrayList futures = RecyclableArrayList . newInstance ( msgs . length ) ; try { for ( Object m : msgs ) { if ( m = = null ) { break ; } futures . add ( write ( m ) ) ; } flush ( ) ; int size = futures . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { ChannelFuture future = ( ChannelFuture ) futures . get ( i ) ; assert future . isDone ( ) ; if ( future . cause ( ) ! = null ) { recordException ( future . cause ( ) ) ; } } runPendingTasks ( ) ; checkException ( ) ; return isNotEmpty ( outboundMessages ) ; } finally { futures . recycle ( ) ; } } public boolean finish ( ) { close ( ) ; checkException ( ) ; return isNotEmpty ( inboundMessages ) | | isNotEmpty ( outboundMessages ) ; } private void finishPendingTasks ( ) { runPendingTasks ( ) ; loop . cancelScheduledTasks ( ) ; } @Override public final ChannelFuture close ( ) { ChannelFuture future = super . close ( ) ; finishPendingTasks ( ) ; return future ; } @Override public final ChannelFuture disconnect ( ) { ChannelFuture future = super . disconnect ( ) ; finishPendingTasks ( ) ; return future ; } @Override public final ChannelFuture close ( ChannelPromise promise ) { ChannelFuture future = super . close ( promise ) ; finishPendingTasks ( ) ; return future ; } @Override public final ChannelFuture disconnect ( ChannelPromise promise ) { ChannelFuture future = super . disconnect ( promise ) ; finishPendingTasks ( ) ; return future ; } private static boolean isNotEmpty ( Queue < Object > queue ) { return queue ! = null & & ! queue . isEmpty ( ) ; } private static Object poll ( Queue < Object > queue ) { return queue ! = null ? queue . poll ( ) : null ; } public void runPendingTasks ( ) { try { loop . runTasks ( ) ; } catch ( Exception e ) { recordException ( e ) ; } try { loop . runScheduledTasks ( ) ; } catch ( Exception e ) { recordException ( e ) ; } } public long runScheduledPendingTasks ( ) { try { return loop . runScheduledTasks ( ) ; } catch ( Exception e ) { recordException ( e ) ; return loop . nextScheduledTask ( ) ; } } private void recordException ( Throwable cause ) { if ( lastException = = null ) { lastException = cause ; } else { logger . warn ( <str> + <str> , cause ) ; } } public void checkException ( ) { Throwable t = lastException ; if ( t = = null ) { return ; } lastException = null ; PlatformDependent . throwException ( t ) ; } protected final void ensureOpen ( ) { if ( ! isOpen ( ) ) { recordException ( new ClosedChannelException ( ) ) ; checkException ( ) ; } } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof EmbeddedEventLoop ; } @Override protected SocketAddress localAddress0 ( ) { return isActive ( ) ? LOCAL_ADDRESS : null ; } @Override protected SocketAddress remoteAddress0 ( ) { return isActive ( ) ? REMOTE_ADDRESS : null ; } @Override protected void doRegister ( ) throws Exception { state = State . ACTIVE ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected void doClose ( ) throws Exception { state = State . CLOSED ; } @Override protected void doBeginRead ( ) throws Exception { } @Override protected AbstractUnsafe newUnsafe ( ) { return new DefaultUnsafe ( ) ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { break ; } ReferenceCountUtil . retain ( msg ) ; outboundMessages ( ) . add ( msg ) ; in . remove ( ) ; } } private class DefaultUnsafe extends AbstractUnsafe { @Override public void connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) { safeSetSuccess ( promise ) ; } } private final class LastInboundHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { inboundMessages ( ) . add ( msg ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { recordException ( cause ) ; } } } 
