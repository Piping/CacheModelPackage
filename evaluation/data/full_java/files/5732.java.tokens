package org . elasticsearch . common . geo . builders ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import org . elasticsearch . common . xcontent . XContentBuilder ; import com . spatial4j . core . shape . Shape ; import com . vividsolutions . jts . geom . Coordinate ; import com . vividsolutions . jts . geom . Geometry ; import com . vividsolutions . jts . geom . GeometryFactory ; import com . vividsolutions . jts . geom . LineString ; public class LineStringBuilder extends PointCollection < LineStringBuilder > { public static final GeoShapeType TYPE = GeoShapeType . LINESTRING ; @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( FIELD_TYPE , TYPE . shapeName ( ) ) ; builder . field ( FIELD_COORDINATES ) ; coordinatesToXcontent ( builder , false ) ; builder . endObject ( ) ; return builder ; } public LineStringBuilder close ( ) { Coordinate start = points . get ( <int> ) ; Coordinate end = points . get ( points . size ( ) - <int> ) ; if ( start . x ! = end . x | | start . y ! = end . y ) { points . add ( start ) ; } return this ; } @Override public GeoShapeType type ( ) { return TYPE ; } @Override public Shape build ( ) { Coordinate [ ] coordinates = points . toArray ( new Coordinate [ points . size ( ) ] ) ; Geometry geometry ; if ( wrapdateline ) { ArrayList < LineString > strings = decompose ( FACTORY , coordinates , new ArrayList < LineString > ( ) ) ; if ( strings . size ( ) = = <int> ) { geometry = strings . get ( <int> ) ; } else { LineString [ ] linestrings = strings . toArray ( new LineString [ strings . size ( ) ] ) ; geometry = FACTORY . createMultiLineString ( linestrings ) ; } } else { geometry = FACTORY . createLineString ( coordinates ) ; } return jtsGeometry ( geometry ) ; } static ArrayList < LineString > decompose ( GeometryFactory factory , Coordinate [ ] coordinates , ArrayList < LineString > strings ) { for ( Coordinate [ ] part : decompose ( + DATELINE , coordinates ) ) { for ( Coordinate [ ] line : decompose ( - DATELINE , part ) ) { strings . add ( factory . createLineString ( line ) ) ; } } return strings ; } private static Coordinate [ ] [ ] decompose ( double dateline , Coordinate [ ] coordinates ) { int offset = <int> ; ArrayList < Coordinate [ ] > parts = new ArrayList < > ( ) ; double shift = coordinates [ <int> ] . x > DATELINE ? DATELINE : ( coordinates [ <int> ] . x < - DATELINE ? - DATELINE : <int> ) ; for ( int i = <int> ; i < coordinates . length ; i + + ) { double t = intersection ( coordinates [ i - <int> ] , coordinates [ i ] , dateline ) ; if ( ! Double . isNaN ( t ) ) { Coordinate [ ] part ; if ( t < <int> ) { part = Arrays . copyOfRange ( coordinates , offset , i + <int> ) ; part [ part . length - <int> ] = Edge . position ( coordinates [ i - <int> ] , coordinates [ i ] , t ) ; coordinates [ offset + i - <int> ] = Edge . position ( coordinates [ i - <int> ] , coordinates [ i ] , t ) ; shift ( shift , part ) ; offset = i - <int> ; shift = coordinates [ i ] . x > DATELINE ? DATELINE : ( coordinates [ i ] . x < - DATELINE ? - DATELINE : <int> ) ; } else { part = shift ( shift , Arrays . copyOfRange ( coordinates , offset , i + <int> ) ) ; offset = i ; } parts . add ( part ) ; } } if ( offset = = <int> ) { parts . add ( shift ( shift , coordinates ) ) ; } else if ( offset < coordinates . length - <int> ) { Coordinate [ ] part = Arrays . copyOfRange ( coordinates , offset , coordinates . length ) ; parts . add ( shift ( shift , part ) ) ; } return parts . toArray ( new Coordinate [ parts . size ( ) ] [ ] ) ; } private static Coordinate [ ] shift ( double shift , Coordinate . . . coordinates ) { if ( shift ! = <int> ) { for ( int j = <int> ; j < coordinates . length ; j + + ) { coordinates [ j ] = new Coordinate ( coordinates [ j ] . x - <int> * shift , coordinates [ j ] . y ) ; } } return coordinates ; } } 
