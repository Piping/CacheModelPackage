package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . StandardOpenOption ; import java . util . zip . CRC32 ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . DataOutputBufferFixed ; import org . apache . cassandra . utils . CLibrary ; import org . apache . cassandra . utils . SyncUtil ; import org . apache . cassandra . utils . Throwables ; import static org . apache . cassandra . utils . FBUtilities . updateChecksum ; import static org . apache . cassandra . utils . FBUtilities . updateChecksumInt ; import static org . apache . cassandra . utils . Throwables . perform ; final class HintsWriter implements AutoCloseable { static final int PAGE_SIZE = <int> ; private final File directory ; private final HintsDescriptor descriptor ; private final File file ; private final FileChannel channel ; private final int fd ; private final CRC32 globalCRC ; private volatile long lastSyncPosition = <int> L ; private HintsWriter ( File directory , HintsDescriptor descriptor , File file , FileChannel channel , int fd , CRC32 globalCRC ) { this . directory = directory ; this . descriptor = descriptor ; this . file = file ; this . channel = channel ; this . fd = fd ; this . globalCRC = globalCRC ; } @SuppressWarnings ( <str> ) static HintsWriter create ( File directory , HintsDescriptor descriptor ) throws IOException { File file = new File ( directory , descriptor . fileName ( ) ) ; FileChannel channel = FileChannel . open ( file . toPath ( ) , StandardOpenOption . WRITE , StandardOpenOption . CREATE_NEW ) ; int fd = CLibrary . getfd ( channel ) ; CRC32 crc = new CRC32 ( ) ; try ( DataOutputBuffer dob = new DataOutputBuffer ( ) ) { descriptor . serialize ( dob ) ; ByteBuffer descriptorBytes = dob . buffer ( ) ; updateChecksum ( crc , descriptorBytes ) ; channel . write ( descriptorBytes ) ; } catch ( Throwable e ) { channel . close ( ) ; throw e ; } return new HintsWriter ( directory , descriptor , file , channel , fd , crc ) ; } HintsDescriptor descriptor ( ) { return descriptor ; } private void writeChecksum ( ) { File checksumFile = new File ( directory , descriptor . checksumFileName ( ) ) ; try ( OutputStream out = Files . newOutputStream ( checksumFile . toPath ( ) ) ) { out . write ( Integer . toHexString ( ( int ) globalCRC . getValue ( ) ) . getBytes ( StandardCharsets . UTF_8 ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , checksumFile ) ; } } public void close ( ) { perform ( file , Throwables . FileOpType . WRITE , this : : doFsync , channel : : close ) ; writeChecksum ( ) ; } public void fsync ( ) { perform ( file , Throwables . FileOpType . WRITE , this : : doFsync ) ; } private void doFsync ( ) throws IOException { SyncUtil . force ( channel , true ) ; lastSyncPosition = channel . position ( ) ; } Session newSession ( ByteBuffer buffer ) { try { return new Session ( buffer , channel . size ( ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , file ) ; } } final class Session implements AutoCloseable { private final ByteBuffer buffer ; private final long initialSize ; private long bytesWritten ; Session ( ByteBuffer buffer , long initialSize ) { buffer . clear ( ) ; bytesWritten = <int> L ; this . buffer = buffer ; this . initialSize = initialSize ; } long position ( ) { return initialSize + bytesWritten ; } void append ( ByteBuffer hint ) throws IOException { bytesWritten + = hint . remaining ( ) ; if ( hint . remaining ( ) < = buffer . remaining ( ) ) { buffer . put ( hint ) ; return ; } buffer . flip ( ) ; updateChecksum ( globalCRC , buffer ) ; updateChecksum ( globalCRC , hint ) ; channel . write ( new ByteBuffer [ ] { buffer , hint } ) ; buffer . clear ( ) ; } void append ( Hint hint ) throws IOException { int hintSize = ( int ) Hint . serializer . serializedSize ( hint , descriptor . messagingVersion ( ) ) ; int totalSize = hintSize + HintsBuffer . ENTRY_OVERHEAD_SIZE ; if ( totalSize > buffer . remaining ( ) ) flushBuffer ( ) ; ByteBuffer hintBuffer = totalSize < = buffer . remaining ( ) ? buffer : ByteBuffer . allocate ( totalSize ) ; CRC32 crc = new CRC32 ( ) ; try ( DataOutputBufferFixed out = new DataOutputBufferFixed ( hintBuffer ) ) { out . writeInt ( hintSize ) ; updateChecksumInt ( crc , hintSize ) ; out . writeInt ( ( int ) crc . getValue ( ) ) ; Hint . serializer . serialize ( hint , out , descriptor . messagingVersion ( ) ) ; updateChecksum ( crc , hintBuffer , hintBuffer . position ( ) - hintSize , hintSize ) ; out . writeInt ( ( int ) crc . getValue ( ) ) ; } if ( hintBuffer = = buffer ) bytesWritten + = totalSize ; else append ( ( ByteBuffer ) hintBuffer . flip ( ) ) ; } public void close ( ) throws IOException { flushBuffer ( ) ; maybeFsync ( ) ; maybeSkipCache ( ) ; } private void flushBuffer ( ) throws IOException { buffer . flip ( ) ; if ( buffer . remaining ( ) > <int> ) { updateChecksum ( globalCRC , buffer ) ; channel . write ( buffer ) ; } buffer . clear ( ) ; } private void maybeFsync ( ) { if ( position ( ) > = lastSyncPosition + DatabaseDescriptor . getTrickleFsyncIntervalInKb ( ) * <int> ) fsync ( ) ; } private void maybeSkipCache ( ) { long position = position ( ) ; if ( position > = DatabaseDescriptor . getTrickleFsyncIntervalInKb ( ) * <int> ) CLibrary . trySkipCache ( fd , <int> , position - ( position % PAGE_SIZE ) , file . getPath ( ) ) ; } } } 
