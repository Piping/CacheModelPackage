package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import java . util . Arrays ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; final class Bzip2HuffmanStageEncoder { private static final int HUFFMAN_HIGH_SYMBOL_COST = <int> ; private final Bzip2BitWriter writer ; private final char [ ] mtfBlock ; private final int mtfLength ; private final int mtfAlphabetSize ; private final int [ ] mtfSymbolFrequencies ; private final int [ ] [ ] huffmanCodeLengths ; private final int [ ] [ ] huffmanMergedCodeSymbols ; private final byte [ ] selectors ; Bzip2HuffmanStageEncoder ( final Bzip2BitWriter writer , final char [ ] mtfBlock , final int mtfLength , final int mtfAlphabetSize , final int [ ] mtfSymbolFrequencies ) { this . writer = writer ; this . mtfBlock = mtfBlock ; this . mtfLength = mtfLength ; this . mtfAlphabetSize = mtfAlphabetSize ; this . mtfSymbolFrequencies = mtfSymbolFrequencies ; final int totalTables = selectTableCount ( mtfLength ) ; huffmanCodeLengths = new int [ totalTables ] [ mtfAlphabetSize ] ; huffmanMergedCodeSymbols = new int [ totalTables ] [ mtfAlphabetSize ] ; selectors = new byte [ ( mtfLength + HUFFMAN_GROUP_RUN_LENGTH - <int> ) / HUFFMAN_GROUP_RUN_LENGTH ] ; } private static int selectTableCount ( final int mtfLength ) { if ( mtfLength > = <int> ) { return <int> ; } if ( mtfLength > = <int> ) { return <int> ; } if ( mtfLength > = <int> ) { return <int> ; } if ( mtfLength > = <int> ) { return <int> ; } return <int> ; } private static void generateHuffmanCodeLengths ( final int alphabetSize , final int [ ] symbolFrequencies , final int [ ] codeLengths ) { final int [ ] mergedFrequenciesAndIndices = new int [ alphabetSize ] ; final int [ ] sortedFrequencies = new int [ alphabetSize ] ; for ( int i = <int> ; i < alphabetSize ; i + + ) { mergedFrequenciesAndIndices [ i ] = ( symbolFrequencies [ i ] < < <int> ) | i ; } Arrays . sort ( mergedFrequenciesAndIndices ) ; for ( int i = <int> ; i < alphabetSize ; i + + ) { sortedFrequencies [ i ] = mergedFrequenciesAndIndices [ i ] > > > <int> ; } Bzip2HuffmanAllocator . allocateHuffmanCodeLengths ( sortedFrequencies , HUFFMAN_ENCODE_MAX_CODE_LENGTH ) ; for ( int i = <int> ; i < alphabetSize ; i + + ) { codeLengths [ mergedFrequenciesAndIndices [ i ] & <hex> ] = sortedFrequencies [ i ] ; } } private void generateHuffmanOptimisationSeeds ( ) { final int [ ] [ ] huffmanCodeLengths = this . huffmanCodeLengths ; final int [ ] mtfSymbolFrequencies = this . mtfSymbolFrequencies ; final int mtfAlphabetSize = this . mtfAlphabetSize ; final int totalTables = huffmanCodeLengths . length ; int remainingLength = mtfLength ; int lowCostEnd = - <int> ; for ( int i = <int> ; i < totalTables ; i + + ) { final int targetCumulativeFrequency = remainingLength / ( totalTables - i ) ; final int lowCostStart = lowCostEnd + <int> ; int actualCumulativeFrequency = <int> ; while ( actualCumulativeFrequency < targetCumulativeFrequency & & lowCostEnd < mtfAlphabetSize - <int> ) { actualCumulativeFrequency + = mtfSymbolFrequencies [ + + lowCostEnd ] ; } if ( lowCostEnd > lowCostStart & & i ! = <int> & & i ! = totalTables - <int> & & ( totalTables - i & <int> ) = = <int> ) { actualCumulativeFrequency - = mtfSymbolFrequencies [ lowCostEnd - - ] ; } final int [ ] tableCodeLengths = huffmanCodeLengths [ i ] ; for ( int j = <int> ; j < mtfAlphabetSize ; j + + ) { if ( j < lowCostStart | | j > lowCostEnd ) { tableCodeLengths [ j ] = HUFFMAN_HIGH_SYMBOL_COST ; } } remainingLength - = actualCumulativeFrequency ; } } private void optimiseSelectorsAndHuffmanTables ( final boolean storeSelectors ) { final char [ ] mtfBlock = this . mtfBlock ; final byte [ ] selectors = this . selectors ; final int [ ] [ ] huffmanCodeLengths = this . huffmanCodeLengths ; final int mtfLength = this . mtfLength ; final int mtfAlphabetSize = this . mtfAlphabetSize ; final int totalTables = huffmanCodeLengths . length ; final int [ ] [ ] tableFrequencies = new int [ totalTables ] [ mtfAlphabetSize ] ; int selectorIndex = <int> ; for ( int groupStart = <int> ; groupStart < mtfLength ; ) { final int groupEnd = Math . min ( groupStart + HUFFMAN_GROUP_RUN_LENGTH , mtfLength ) - <int> ; short [ ] cost = new short [ totalTables ] ; for ( int i = groupStart ; i < = groupEnd ; i + + ) { final int value = mtfBlock [ i ] ; for ( int j = <int> ; j < totalTables ; j + + ) { cost [ j ] + = huffmanCodeLengths [ j ] [ value ] ; } } byte bestTable = <int> ; int bestCost = cost [ <int> ] ; for ( byte i = <int> ; i < totalTables ; i + + ) { final int tableCost = cost [ i ] ; if ( tableCost < bestCost ) { bestCost = tableCost ; bestTable = i ; } } final int [ ] bestGroupFrequencies = tableFrequencies [ bestTable ] ; for ( int i = groupStart ; i < = groupEnd ; i + + ) { bestGroupFrequencies [ mtfBlock [ i ] ] + + ; } if ( storeSelectors ) { selectors [ selectorIndex + + ] = bestTable ; } groupStart = groupEnd + <int> ; } for ( int i = <int> ; i < totalTables ; i + + ) { generateHuffmanCodeLengths ( mtfAlphabetSize , tableFrequencies [ i ] , huffmanCodeLengths [ i ] ) ; } } private void assignHuffmanCodeSymbols ( ) { final int [ ] [ ] huffmanMergedCodeSymbols = this . huffmanMergedCodeSymbols ; final int [ ] [ ] huffmanCodeLengths = this . huffmanCodeLengths ; final int mtfAlphabetSize = this . mtfAlphabetSize ; final int totalTables = huffmanCodeLengths . length ; for ( int i = <int> ; i < totalTables ; i + + ) { final int [ ] tableLengths = huffmanCodeLengths [ i ] ; int minimumLength = <int> ; int maximumLength = <int> ; for ( int j = <int> ; j < mtfAlphabetSize ; j + + ) { final int length = tableLengths [ j ] ; if ( length > maximumLength ) { maximumLength = length ; } if ( length < minimumLength ) { minimumLength = length ; } } int code = <int> ; for ( int j = minimumLength ; j < = maximumLength ; j + + ) { for ( int k = <int> ; k < mtfAlphabetSize ; k + + ) { if ( ( huffmanCodeLengths [ i ] [ k ] & <hex> ) = = j ) { huffmanMergedCodeSymbols [ i ] [ k ] = ( j < < <int> ) | code ; code + + ; } } code < < = <int> ; } } } private void writeSelectorsAndHuffmanTables ( ByteBuf out ) { final Bzip2BitWriter writer = this . writer ; final byte [ ] selectors = this . selectors ; final int totalSelectors = selectors . length ; final int [ ] [ ] huffmanCodeLengths = this . huffmanCodeLengths ; final int totalTables = huffmanCodeLengths . length ; final int mtfAlphabetSize = this . mtfAlphabetSize ; writer . writeBits ( out , <int> , totalTables ) ; writer . writeBits ( out , <int> , totalSelectors ) ; Bzip2MoveToFrontTable selectorMTF = new Bzip2MoveToFrontTable ( ) ; for ( byte selector : selectors ) { writer . writeUnary ( out , selectorMTF . valueToFront ( selector ) ) ; } for ( final int [ ] tableLengths : huffmanCodeLengths ) { int currentLength = tableLengths [ <int> ] ; writer . writeBits ( out , <int> , currentLength ) ; for ( int j = <int> ; j < mtfAlphabetSize ; j + + ) { final int codeLength = tableLengths [ j ] ; final int value = currentLength < codeLength ? <int> : <int> ; int delta = Math . abs ( codeLength - currentLength ) ; while ( delta - - > <int> ) { writer . writeBits ( out , <int> , value ) ; } writer . writeBoolean ( out , false ) ; currentLength = codeLength ; } } } private void writeBlockData ( ByteBuf out ) { final Bzip2BitWriter writer = this . writer ; final int [ ] [ ] huffmanMergedCodeSymbols = this . huffmanMergedCodeSymbols ; final byte [ ] selectors = this . selectors ; final char [ ] mtf = mtfBlock ; final int mtfLength = this . mtfLength ; int selectorIndex = <int> ; for ( int mtfIndex = <int> ; mtfIndex < mtfLength ; ) { final int groupEnd = Math . min ( mtfIndex + HUFFMAN_GROUP_RUN_LENGTH , mtfLength ) - <int> ; final int [ ] tableMergedCodeSymbols = huffmanMergedCodeSymbols [ selectors [ selectorIndex + + ] ] ; while ( mtfIndex < = groupEnd ) { final int mergedCodeSymbol = tableMergedCodeSymbols [ mtf [ mtfIndex + + ] ] ; writer . writeBits ( out , mergedCodeSymbol > > > <int> , mergedCodeSymbol ) ; } } } void encode ( ByteBuf out ) { generateHuffmanOptimisationSeeds ( ) ; for ( int i = <int> ; i > = <int> ; i - - ) { optimiseSelectorsAndHuffmanTables ( i = = <int> ) ; } assignHuffmanCodeSymbols ( ) ; writeSelectorsAndHuffmanTables ( out ) ; writeBlockData ( out ) ; } } 
