package org . elasticsearch . action . admin . indices . get ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . support . master . info . ClusterInfoRequest ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . util . ArrayUtils ; import java . io . IOException ; import java . util . Arrays ; import java . util . List ; public class GetIndexRequest extends ClusterInfoRequest < GetIndexRequest > { public static enum Feature { ALIASES ( ( byte ) <int> , <str> , <str> ) , MAPPINGS ( ( byte ) <int> , <str> , <str> ) , SETTINGS ( ( byte ) <int> , <str> ) , WARMERS ( ( byte ) <int> , <str> , <str> ) ; private static final Feature [ ] FEATURES = new Feature [ Feature . values ( ) . length ] ; static { for ( Feature feature : Feature . values ( ) ) { assert feature . id ( ) < FEATURES . length & & feature . id ( ) > = <int> ; FEATURES [ feature . id ] = feature ; } } private final List < String > validNames ; private final String preferredName ; private final byte id ; private Feature ( byte id , String . . . validNames ) { assert validNames ! = null & & validNames . length > <int> ; this . id = id ; this . validNames = Arrays . asList ( validNames ) ; this . preferredName = validNames [ <int> ] ; } public byte id ( ) { return id ; } public String preferredName ( ) { return preferredName ; } public boolean validName ( String name ) { return this . validNames . contains ( name ) ; } public static Feature fromName ( String name ) { for ( Feature feature : Feature . values ( ) ) { if ( feature . validName ( name ) ) { return feature ; } } throw new IllegalArgumentException ( <str> + name + <str> ) ; } public static Feature fromId ( byte id ) { if ( id < <int> | | id > = FEATURES . length ) { throw new IllegalArgumentException ( <str> + id + <str> ) ; } return FEATURES [ id ] ; } public static Feature [ ] convertToFeatures ( String . . . featureNames ) { Feature [ ] features = new Feature [ featureNames . length ] ; for ( int i = <int> ; i < featureNames . length ; i + + ) { features [ i ] = Feature . fromName ( featureNames [ i ] ) ; } return features ; } } private static final Feature [ ] DEFAULT_FEATURES = new Feature [ ] { Feature . ALIASES , Feature . MAPPINGS , Feature . SETTINGS , Feature . WARMERS } ; private Feature [ ] features = DEFAULT_FEATURES ; private boolean humanReadable = false ; public GetIndexRequest features ( Feature . . . features ) { if ( features = = null ) { throw new IllegalArgumentException ( <str> ) ; } else { this . features = features ; } return this ; } public GetIndexRequest addFeatures ( Feature . . . features ) { if ( this . features = = DEFAULT_FEATURES ) { return features ( features ) ; } else { return features ( ArrayUtils . concat ( features ( ) , features , Feature . class ) ) ; } } public Feature [ ] features ( ) { return features ; } @Deprecated public Feature [ ] featuresAsEnums ( ) { return features ( ) ; } @Override public ActionRequestValidationException validate ( ) { return null ; } public GetIndexRequest humanReadable ( boolean humanReadable ) { this . humanReadable = humanReadable ; return this ; } public boolean humanReadable ( ) { return humanReadable ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; features = new Feature [ size ] ; for ( int i = <int> ; i < size ; i + + ) { features [ i ] = Feature . fromId ( in . readByte ( ) ) ; } humanReadable = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( features . length ) ; for ( Feature feature : features ) { out . writeByte ( feature . id ) ; } out . writeBoolean ( humanReadable ) ; } } 
