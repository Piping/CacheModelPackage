package org . elasticsearch . recovery ; import org . elasticsearch . action . admin . indices . refresh . RefreshResponse ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . admin . indices . stats . ShardStats ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . routing . Murmur3HashFunction ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . math . MathUtils ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . shard . DocsStats ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . index . translog . TranslogConfig ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . BackgroundIndexer ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Arrays ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . * ; public class RecoveryWhileUnderLoadIT extends ESIntegTestCase { private final ESLogger logger = Loggers . getLogger ( RecoveryWhileUnderLoadIT . class ) ; public void testRecoverWhileUnderLoadAllocateReplicasTest ( ) throws Exception { logger . info ( <str> ) ; int numberOfShards = numberOfShards ( ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , numberOfShards ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( TranslogConfig . INDEX_TRANSLOG_DURABILITY , Translog . Durabilty . ASYNC ) ) ) ; final int totalNumDocs = scaledRandomIntBetween ( <int> , <int> ) ; int waitFor = totalNumDocs / <int> ; int extraDocs = waitFor ; try ( BackgroundIndexer indexer = new BackgroundIndexer ( <str> , <str> , client ( ) , extraDocs ) ) { logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs / <int> ; waitFor + = extraDocs ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs - waitFor ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForGreenStatus ( ) ) ; logger . info ( <str> , totalNumDocs ) ; waitForDocs ( totalNumDocs , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , totalNumDocs ) ; logger . info ( <str> ) ; indexer . stop ( ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; refreshAndAssert ( ) ; logger . info ( <str> ) ; iterateAssertCount ( numberOfShards , indexer . totalIndexedDocs ( ) , <int> ) ; } } public void testRecoverWhileUnderLoadAllocateReplicasRelocatePrimariesTest ( ) throws Exception { logger . info ( <str> ) ; int numberOfShards = numberOfShards ( ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , numberOfShards ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( TranslogConfig . INDEX_TRANSLOG_DURABILITY , Translog . Durabilty . ASYNC ) ) ) ; final int totalNumDocs = scaledRandomIntBetween ( <int> , <int> ) ; int waitFor = totalNumDocs / <int> ; int extraDocs = waitFor ; try ( BackgroundIndexer indexer = new BackgroundIndexer ( <str> , <str> , client ( ) , extraDocs ) ) { logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs / <int> ; waitFor + = extraDocs ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs - waitFor ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForGreenStatus ( ) ) ; logger . info ( <str> , totalNumDocs ) ; waitForDocs ( totalNumDocs , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , totalNumDocs ) ; logger . info ( <str> ) ; indexer . stop ( ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; refreshAndAssert ( ) ; logger . info ( <str> ) ; iterateAssertCount ( numberOfShards , indexer . totalIndexedDocs ( ) , <int> ) ; } } public void testRecoverWhileUnderLoadWithReducedAllowedNodes ( ) throws Exception { logger . info ( <str> ) ; int numberOfShards = numberOfShards ( ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , numberOfShards ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( TranslogConfig . INDEX_TRANSLOG_DURABILITY , Translog . Durabilty . ASYNC ) ) ) ; final int totalNumDocs = scaledRandomIntBetween ( <int> , <int> ) ; int waitFor = totalNumDocs / <int> ; int extraDocs = waitFor ; try ( BackgroundIndexer indexer = new BackgroundIndexer ( <str> , <str> , client ( ) , extraDocs ) ) { logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs / <int> ; waitFor + = extraDocs ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; logger . info ( <str> , waitFor ) ; waitForDocs ( waitFor , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , waitFor ) ; extraDocs = totalNumDocs - waitFor ; indexer . continueIndexing ( extraDocs ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) ) ; logger . info ( <str> , totalNumDocs ) ; waitForDocs ( totalNumDocs , indexer ) ; indexer . assertNoFailures ( ) ; logger . info ( <str> , totalNumDocs ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForRelocatingShards ( <int> ) ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForRelocatingShards ( <int> ) ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForRelocatingShards ( <int> ) ) ; logger . info ( <str> ) ; indexer . stop ( ) ; logger . info ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( <str> ) . setWaitForRelocatingShards ( <int> ) ) ; logger . info ( <str> ) ; refreshAndAssert ( ) ; logger . info ( <str> ) ; iterateAssertCount ( numberOfShards , indexer . totalIndexedDocs ( ) , <int> ) ; } } public void testRecoverWhileRelocating ( ) throws Exception { final int numShards = between ( <int> , <int> ) ; final int numReplicas = <int> ; logger . info ( <str> ) ; int allowNodes = <int> ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( SETTING_NUMBER_OF_SHARDS , numShards ) . put ( SETTING_NUMBER_OF_REPLICAS , numReplicas ) . put ( TranslogConfig . INDEX_TRANSLOG_DURABILITY , Translog . Durabilty . ASYNC ) ) ) ; final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; try ( BackgroundIndexer indexer = new BackgroundIndexer ( <str> , <str> , client ( ) , numDocs ) ) { for ( int i = <int> ; i < numDocs ; i + = scaledRandomIntBetween ( <int> , Math . min ( <int> , numDocs ) ) ) { indexer . assertNoFailures ( ) ; logger . info ( <str> , i ) ; waitForDocs ( i , indexer ) ; logger . info ( <str> , i ) ; allowNodes = <int> / allowNodes ; allowNodes ( <str> , allowNodes ) ; logger . info ( <str> ) ; ensureGreen ( TimeValue . timeValueMinutes ( <int> ) ) ; } logger . info ( <str> ) ; indexer . stop ( ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; allowNodes ( <str> , <int> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . get ( ) ) ; ensureGreen ( TimeValue . timeValueMinutes ( <int> ) ) ; logger . info ( <str> ) ; refreshAndAssert ( ) ; logger . info ( <str> ) ; iterateAssertCount ( numShards , indexer . totalIndexedDocs ( ) , <int> ) ; } } private void iterateAssertCount ( final int numberOfShards , final long numberOfDocs , final int iterations ) throws Exception { SearchResponse [ ] iterationResults = new SearchResponse [ iterations ] ; boolean error = false ; SearchResponse lastErroneousResponse = null ; for ( int i = <int> ; i < iterations ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setSize ( ( int ) numberOfDocs ) . setQuery ( matchAllQuery ( ) ) . addSort ( <str> , SortOrder . ASC ) . get ( ) ; logSearchResponse ( numberOfShards , numberOfDocs , i , searchResponse ) ; iterationResults [ i ] = searchResponse ; if ( searchResponse . getHits ( ) . totalHits ( ) ! = numberOfDocs ) { error = true ; lastErroneousResponse = searchResponse ; } } if ( error ) { IndicesStatsResponse indicesStatsResponse = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . get ( ) ; for ( ShardStats shardStats : indicesStatsResponse . getShards ( ) ) { DocsStats docsStats = shardStats . getStats ( ) . docs ; logger . info ( <str> , shardStats . getShardRouting ( ) . id ( ) , docsStats . getCount ( ) , shardStats . getShardRouting ( ) . primary ( ) ) ; } for ( int doc = <int> , hit = <int> ; hit < lastErroneousResponse . getHits ( ) . getHits ( ) . length ; hit + + , doc + + ) { SearchHit searchHit = lastErroneousResponse . getHits ( ) . getAt ( hit ) ; while ( doc < Integer . parseInt ( searchHit . id ( ) ) ) { logger . info ( <str> , doc , MathUtils . mod ( Murmur3HashFunction . hash ( Integer . toString ( doc ) ) , numberOfShards ) ) ; doc + + ; } } logger . info ( <str> ) ; assertTrue ( awaitBusy ( ( ) - > { boolean errorOccurred = false ; for ( int i = <int> ; i < iterations ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; if ( searchResponse . getHits ( ) . totalHits ( ) ! = numberOfDocs ) { errorOccurred = true ; } } return ! errorOccurred ; } , <int> , TimeUnit . MINUTES ) ) ; } for ( int i = <int> ; i < iterations ; i + + ) { assertHitCount ( iterationResults [ i ] , numberOfDocs ) ; } } private void logSearchResponse ( int numberOfShards , long numberOfDocs , int iteration , SearchResponse searchResponse ) { logger . info ( <str> , iteration , searchResponse . getSuccessfulShards ( ) , numberOfShards ) ; logger . info ( <str> , iteration , searchResponse . getFailedShards ( ) ) ; if ( searchResponse . getShardFailures ( ) ! = null & & searchResponse . getShardFailures ( ) . length > <int> ) { logger . info ( <str> , iteration , Arrays . toString ( searchResponse . getShardFailures ( ) ) ) ; } logger . info ( <str> , iteration , searchResponse . getHits ( ) . totalHits ( ) , numberOfDocs ) ; } private void refreshAndAssert ( ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { RefreshResponse actionGet = client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . get ( ) ; assertAllSuccessful ( actionGet ) ; } } , <int> , TimeUnit . MINUTES ) ; } } 
