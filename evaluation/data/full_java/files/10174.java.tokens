package com . google . common . util . concurrent . testing ; import com . google . common . collect . ImmutableList ; import com . google . common . util . concurrent . ListeningScheduledExecutorService ; import junit . framework . TestCase ; import java . lang . InterruptedException ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public class TestingExecutorsTest extends TestCase { private volatile boolean taskDone ; public void testNoOpScheduledExecutor ( ) throws InterruptedException { taskDone = false ; Runnable task = new Runnable ( ) { @Override public void run ( ) { taskDone = true ; } } ; ScheduledFuture < ? > future = TestingExecutors . noOpScheduledExecutor ( ) . schedule ( task , <int> , TimeUnit . MILLISECONDS ) ; Thread . sleep ( <int> ) ; assertFalse ( taskDone ) ; assertFalse ( future . isDone ( ) ) ; } public void testNoOpScheduledExecutorShutdown ( ) { ListeningScheduledExecutorService executor = TestingExecutors . noOpScheduledExecutor ( ) ; assertFalse ( executor . isShutdown ( ) ) ; assertFalse ( executor . isTerminated ( ) ) ; executor . shutdown ( ) ; assertTrue ( executor . isShutdown ( ) ) ; assertTrue ( executor . isTerminated ( ) ) ; } public void testNoOpScheduledExecutorInvokeAll ( ) throws ExecutionException , InterruptedException { ListeningScheduledExecutorService executor = TestingExecutors . noOpScheduledExecutor ( ) ; taskDone = false ; Callable < Boolean > task = new Callable < Boolean > ( ) { @Override public Boolean call ( ) { taskDone = true ; return taskDone ; } } ; List < Future < Boolean > > futureList = executor . invokeAll ( ImmutableList . of ( task ) , <int> , TimeUnit . MILLISECONDS ) ; Future < Boolean > future = futureList . get ( <int> ) ; assertFalse ( taskDone ) ; assertTrue ( future . isDone ( ) ) ; try { future . get ( ) ; fail ( ) ; } catch ( CancellationException e ) { } } public void testSameThreadScheduledExecutor ( ) throws ExecutionException , InterruptedException { taskDone = false ; Callable < Integer > task = new Callable < Integer > ( ) { @Override public Integer call ( ) { taskDone = true ; return <int> ; } } ; Future < Integer > future = TestingExecutors . sameThreadScheduledExecutor ( ) . schedule ( task , <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( <str> , taskDone ) ; assertEquals ( <int> , ( int ) future . get ( ) ) ; } public void testSameThreadScheduledExecutorWithException ( ) throws InterruptedException { Runnable runnable = new Runnable ( ) { @Override public void run ( ) { throw new RuntimeException ( <str> ) ; } } ; Future < ? > future = TestingExecutors . sameThreadScheduledExecutor ( ) . submit ( runnable ) ; try { future . get ( ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { } } } 
