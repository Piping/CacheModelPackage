package org . apache . cassandra . cql3 ; import java . nio . ByteBuffer ; import java . util . Map ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . partitions . Partition ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . FBUtilities ; public class UpdateParameters { public final CFMetaData metadata ; public final PartitionColumns updatedColumns ; public final QueryOptions options ; private final int nowInSec ; private final long timestamp ; private final int ttl ; private final DeletionTime deletionTime ; private final Map < DecoratedKey , Partition > prefetchedRows ; private Row . Builder staticBuilder ; private Row . Builder regularBuilder ; private Row . Builder builder ; public UpdateParameters ( CFMetaData metadata , PartitionColumns updatedColumns , QueryOptions options , long timestamp , int ttl , Map < DecoratedKey , Partition > prefetchedRows ) throws InvalidRequestException { this . metadata = metadata ; this . updatedColumns = updatedColumns ; this . options = options ; this . nowInSec = FBUtilities . nowInSeconds ( ) ; this . timestamp = timestamp ; this . ttl = ttl ; this . deletionTime = new DeletionTime ( timestamp , nowInSec ) ; this . prefetchedRows = prefetchedRows ; if ( timestamp = = Long . MIN_VALUE ) throw new InvalidRequestException ( String . format ( <str> , Long . MIN_VALUE + <int> , Long . MAX_VALUE ) ) ; } public void newRow ( Clustering clustering ) throws InvalidRequestException { if ( metadata . isDense ( ) & & ! metadata . isCompound ( ) ) { assert clustering . size ( ) = = <int> ; ByteBuffer value = clustering . get ( <int> ) ; if ( value = = null | | ! value . hasRemaining ( ) ) throw new InvalidRequestException ( <str> + metadata . clusteringColumns ( ) . get ( <int> ) . name ) ; } if ( clustering = = Clustering . STATIC_CLUSTERING ) { if ( staticBuilder = = null ) staticBuilder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder = staticBuilder ; } else { if ( regularBuilder = = null ) regularBuilder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder = regularBuilder ; } builder . newRow ( clustering ) ; } public Clustering currentClustering ( ) { return builder . clustering ( ) ; } public void addPrimaryKeyLivenessInfo ( ) { builder . addPrimaryKeyLivenessInfo ( LivenessInfo . create ( metadata , timestamp , ttl , nowInSec ) ) ; } public void addRowDeletion ( ) { if ( metadata . isCompactTable ( ) & & builder . clustering ( ) ! = Clustering . STATIC_CLUSTERING ) addTombstone ( metadata . compactValueColumn ( ) ) ; else builder . addRowDeletion ( Row . Deletion . regular ( deletionTime ) ) ; } public void addTombstone ( ColumnDefinition column ) throws InvalidRequestException { addTombstone ( column , null ) ; } public void addTombstone ( ColumnDefinition column , CellPath path ) throws InvalidRequestException { builder . addCell ( BufferCell . tombstone ( column , timestamp , nowInSec , path ) ) ; } public void addCell ( ColumnDefinition column , ByteBuffer value ) throws InvalidRequestException { addCell ( column , null , value ) ; } public void addCell ( ColumnDefinition column , CellPath path , ByteBuffer value ) throws InvalidRequestException { Cell cell = ttl = = LivenessInfo . NO_TTL ? BufferCell . live ( metadata , column , timestamp , value , path ) : BufferCell . expiring ( column , timestamp , ttl , nowInSec , value , path ) ; builder . addCell ( cell ) ; } public void addCounter ( ColumnDefinition column , long increment ) throws InvalidRequestException { assert ttl = = LivenessInfo . NO_TTL ; builder . addCell ( BufferCell . live ( metadata , column , timestamp , CounterContext . instance ( ) . createLocal ( increment ) ) ) ; } public void setComplexDeletionTime ( ColumnDefinition column ) { builder . addComplexDeletion ( column , deletionTime ) ; } public void setComplexDeletionTimeForOverwrite ( ColumnDefinition column ) { builder . addComplexDeletion ( column , new DeletionTime ( deletionTime . markedForDeleteAt ( ) - <int> , deletionTime . localDeletionTime ( ) ) ) ; } public Row buildRow ( ) { Row built = builder . build ( ) ; builder = null ; return built ; } public DeletionTime deletionTime ( ) { return deletionTime ; } public RangeTombstone makeRangeTombstone ( ClusteringComparator comparator , Clustering clustering ) { return makeRangeTombstone ( Slice . make ( comparator , clustering ) ) ; } public RangeTombstone makeRangeTombstone ( Slice slice ) { return new RangeTombstone ( slice , deletionTime ) ; } public Row getPrefetchedRow ( DecoratedKey key , Clustering clustering ) { if ( prefetchedRows = = null ) return null ; Partition partition = prefetchedRows . get ( key ) ; return partition = = null ? null : partition . searchIterator ( ColumnFilter . selection ( partition . columns ( ) ) , false ) . next ( clustering ) ; } } 
