package org . elasticsearch . index . mapper . geo ; import org . apache . lucene . document . FieldType ; import org . apache . lucene . document . GeoPointField ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . DoubleFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import java . io . IOException ; import java . util . Map ; public class GeoPointFieldMapper extends BaseGeoPointFieldMapper { public static final String CONTENT_TYPE = <str> ; public static class Defaults extends BaseGeoPointFieldMapper . Defaults { public static final GeoPointFieldType FIELD_TYPE = new GeoPointFieldType ( ) ; static { FIELD_TYPE . setIndexOptions ( IndexOptions . DOCS ) ; FIELD_TYPE . setTokenized ( false ) ; FIELD_TYPE . setOmitNorms ( true ) ; FIELD_TYPE . setNumericType ( FieldType . NumericType . LONG ) ; FIELD_TYPE . setNumericPrecisionStep ( GeoPointField . PRECISION_STEP ) ; FIELD_TYPE . setDocValuesType ( DocValuesType . SORTED_NUMERIC ) ; FIELD_TYPE . setHasDocValues ( true ) ; FIELD_TYPE . setStored ( true ) ; FIELD_TYPE . freeze ( ) ; } } public static class Builder extends BaseGeoPointFieldMapper . Builder < Builder , GeoPointFieldMapper > { public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE ) ; this . builder = this ; } @Override public GeoPointFieldMapper build ( BuilderContext context , String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , CopyTo copyTo ) { fieldType . setTokenized ( false ) ; setupFieldType ( context ) ; return new GeoPointFieldMapper ( simpleName , fieldType , defaultFieldType , indexSettings , pathType , latMapper , lonMapper , geoHashMapper , multiFields , ignoreMalformed , copyTo ) ; } @Override public GeoPointFieldMapper build ( BuilderContext context ) { return super . build ( context ) ; } } public static class TypeParser extends BaseGeoPointFieldMapper . TypeParser { @Override public Mapper . Builder < ? , ? > parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { return super . parse ( name , node , parserContext ) ; } } public GeoPointFieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , ContentPath . Type pathType , DoubleFieldMapper latMapper , DoubleFieldMapper lonMapper , StringFieldMapper geoHashMapper , MultiFields multiFields , Explicit < Boolean > ignoreMalformed , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , indexSettings , pathType , latMapper , lonMapper , geoHashMapper , multiFields , ignoreMalformed , copyTo ) ; } @Override protected void parse ( ParseContext context , GeoPoint point , String geoHash ) throws IOException { if ( ignoreMalformed . value ( ) = = false ) { if ( point . lat ( ) > <float> | | point . lat ( ) < - <float> ) { throw new IllegalArgumentException ( <str> + point . lat ( ) + <str> + name ( ) ) ; } if ( point . lon ( ) > <float> | | point . lon ( ) < - <int> ) { throw new IllegalArgumentException ( <str> + point . lon ( ) + <str> + name ( ) ) ; } } else { GeoUtils . normalizePoint ( point ) ; } if ( fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE | | fieldType ( ) . stored ( ) ) { context . doc ( ) . add ( new GeoPointField ( fieldType ( ) . names ( ) . indexName ( ) , point . lon ( ) , point . lat ( ) , fieldType ( ) ) ) ; } super . parse ( context , point , geoHash ) ; } } 
