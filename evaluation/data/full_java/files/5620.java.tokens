package org . elasticsearch . cluster . routing . allocation . command ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . cluster . routing . allocation . RerouteExplanation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import static org . elasticsearch . cluster . routing . ShardRoutingState . RELOCATING ; public class CancelAllocationCommand implements AllocationCommand { public static final String NAME = <str> ; public static class Factory implements AllocationCommand . Factory < CancelAllocationCommand > { @Override public CancelAllocationCommand readFrom ( StreamInput in ) throws IOException { return new CancelAllocationCommand ( ShardId . readShardId ( in ) , in . readString ( ) , in . readBoolean ( ) ) ; } @Override public void writeTo ( CancelAllocationCommand command , StreamOutput out ) throws IOException { command . shardId ( ) . writeTo ( out ) ; out . writeString ( command . node ( ) ) ; out . writeBoolean ( command . allowPrimary ( ) ) ; } @Override public CancelAllocationCommand fromXContent ( XContentParser parser ) throws IOException { String index = null ; int shardId = - <int> ; String nodeId = null ; boolean allowPrimary = false ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { index = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { shardId = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { nodeId = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { allowPrimary = parser . booleanValue ( ) ; } else { throw new ElasticsearchParseException ( <str> , NAME , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , NAME , token ) ; } } if ( index = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( shardId = = - <int> ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( nodeId = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } return new CancelAllocationCommand ( new ShardId ( index , shardId ) , nodeId , allowPrimary ) ; } @Override public void toXContent ( CancelAllocationCommand command , XContentBuilder builder , ToXContent . Params params , String objectName ) throws IOException { if ( objectName = = null ) { builder . startObject ( ) ; } else { builder . startObject ( objectName ) ; } builder . field ( <str> , command . shardId ( ) . index ( ) . name ( ) ) ; builder . field ( <str> , command . shardId ( ) . id ( ) ) ; builder . field ( <str> , command . node ( ) ) ; builder . field ( <str> , command . allowPrimary ( ) ) ; builder . endObject ( ) ; } } private final ShardId shardId ; private final String node ; private final boolean allowPrimary ; public CancelAllocationCommand ( ShardId shardId , String node , boolean allowPrimary ) { this . shardId = shardId ; this . node = node ; this . allowPrimary = allowPrimary ; } @Override public String name ( ) { return NAME ; } public ShardId shardId ( ) { return this . shardId ; } public String node ( ) { return this . node ; } public boolean allowPrimary ( ) { return this . allowPrimary ; } @Override public RerouteExplanation execute ( RoutingAllocation allocation , boolean explain ) { DiscoveryNode discoNode = allocation . nodes ( ) . resolveNode ( node ) ; boolean found = false ; for ( RoutingNodes . RoutingNodeIterator it = allocation . routingNodes ( ) . routingNodeIter ( discoNode . id ( ) ) ; it . hasNext ( ) ; ) { ShardRouting shardRouting = it . next ( ) ; if ( ! shardRouting . shardId ( ) . equals ( shardId ) ) { continue ; } found = true ; if ( shardRouting . relocatingNodeId ( ) ! = null ) { if ( shardRouting . initializing ( ) ) { it . remove ( ) ; RoutingNode relocatingFromNode = allocation . routingNodes ( ) . node ( shardRouting . relocatingNodeId ( ) ) ; if ( relocatingFromNode ! = null ) { for ( ShardRouting fromShardRouting : relocatingFromNode ) { if ( fromShardRouting . isSameShard ( shardRouting ) & & fromShardRouting . state ( ) = = RELOCATING ) { allocation . routingNodes ( ) . cancelRelocation ( fromShardRouting ) ; break ; } } } } else if ( shardRouting . relocating ( ) ) { if ( ! allowPrimary & & shardRouting . primary ( ) ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> + discoNode + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + discoNode + <str> ) ; } it . moveToUnassigned ( new UnassignedInfo ( UnassignedInfo . Reason . REROUTE_CANCELLED , null ) ) ; RoutingNodes . RoutingNodeIterator initializingNode = allocation . routingNodes ( ) . routingNodeIter ( shardRouting . relocatingNodeId ( ) ) ; if ( initializingNode ! = null ) { while ( initializingNode . hasNext ( ) ) { ShardRouting initializingShardRouting = initializingNode . next ( ) ; if ( initializingShardRouting . isRelocationTargetOf ( shardRouting ) ) { initializingNode . remove ( ) ; } } } } } else { if ( ! allowPrimary & & shardRouting . primary ( ) ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> + discoNode + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + discoNode + <str> ) ; } it . moveToUnassigned ( new UnassignedInfo ( UnassignedInfo . Reason . REROUTE_CANCELLED , null ) ) ; } } if ( ! found ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> + discoNode ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + discoNode ) ; } return new RerouteExplanation ( this , allocation . decision ( Decision . YES , <str> , <str> + shardId + <str> + discoNode + <str> ) ) ; } } 
