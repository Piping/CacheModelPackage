package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import junit . framework . TestCase ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; public class ListenableFutureTaskTest extends TestCase { private ExecutorService exec ; protected final CountDownLatch runLatch = new CountDownLatch ( <int> ) ; protected final CountDownLatch taskLatch = new CountDownLatch ( <int> ) ; protected final CountDownLatch listenerLatch = new CountDownLatch ( <int> ) ; protected volatile boolean throwException = false ; protected final ListenableFutureTask < Integer > task = ListenableFutureTask . create ( new Callable < Integer > ( ) { @Override public Integer call ( ) throws Exception { runLatch . countDown ( ) ; taskLatch . await ( ) ; if ( throwException ) { throw new IllegalStateException ( <str> ) ; } return <int> ; } } ) ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; exec = Executors . newCachedThreadPool ( ) ; task . addListener ( new Runnable ( ) { @Override public void run ( ) { listenerLatch . countDown ( ) ; } } , directExecutor ( ) ) ; } @Override protected void tearDown ( ) throws Exception { if ( exec ! = null ) { exec . shutdown ( ) ; } super . tearDown ( ) ; } public void testListenerDoesNotRunUntilTaskCompletes ( ) throws Exception { assertEquals ( <int> , listenerLatch . getCount ( ) ) ; assertFalse ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; exec . execute ( task ) ; runLatch . await ( ) ; assertEquals ( <int> , listenerLatch . getCount ( ) ) ; assertFalse ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; taskLatch . countDown ( ) ; assertEquals ( <int> , task . get ( ) . intValue ( ) ) ; assertTrue ( listenerLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; } public void testListenerCalledOnException ( ) throws Exception { throwException = true ; exec . execute ( task ) ; runLatch . await ( ) ; taskLatch . countDown ( ) ; try { task . get ( <int> , TimeUnit . SECONDS ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertEquals ( IllegalStateException . class , e . getCause ( ) . getClass ( ) ) ; } assertTrue ( listenerLatch . await ( <int> , TimeUnit . SECONDS ) ) ; assertTrue ( task . isDone ( ) ) ; assertFalse ( task . isCancelled ( ) ) ; } public void testListenerCalledOnCancelFromNotRunning ( ) throws Exception { task . cancel ( false ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertEquals ( <int> , runLatch . getCount ( ) ) ; listenerLatch . await ( <int> , TimeUnit . SECONDS ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertEquals ( <int> , runLatch . getCount ( ) ) ; } public void testListenerCalledOnCancelFromRunning ( ) throws Exception { exec . execute ( task ) ; runLatch . await ( ) ; task . cancel ( true ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertEquals ( <int> , taskLatch . getCount ( ) ) ; listenerLatch . await ( <int> , TimeUnit . SECONDS ) ; assertTrue ( task . isDone ( ) ) ; assertTrue ( task . isCancelled ( ) ) ; assertEquals ( <int> , taskLatch . getCount ( ) ) ; } } 
