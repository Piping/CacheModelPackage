package org . gradle . plugins . ide . api ; import org . gradle . api . GradleException ; import org . gradle . api . internal . ConventionTask ; import org . gradle . api . specs . Specs ; import org . gradle . api . tasks . OutputFile ; import org . gradle . api . tasks . TaskAction ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . listener . ActionBroadcast ; import org . gradle . plugins . ide . internal . generator . generator . Generator ; import javax . inject . Inject ; import java . io . File ; public class GeneratorTask < T > extends ConventionTask { private File inputFile ; private File outputFile ; protected final ActionBroadcast < T > beforeConfigured = new ActionBroadcast < T > ( ) ; protected final ActionBroadcast < T > afterConfigured = new ActionBroadcast < T > ( ) ; protected Generator < T > generator ; protected T domainObject ; public GeneratorTask ( ) { getOutputs ( ) . upToDateWhen ( Specs . satisfyNone ( ) ) ; } @SuppressWarnings ( <str> ) @TaskAction void generate ( ) { File inputFile = getInputFile ( ) ; if ( inputFile ! = null & & inputFile . exists ( ) ) { try { domainObject = generator . read ( inputFile ) ; } catch ( RuntimeException e ) { throw new GradleException ( String . format ( <str> + <str> , inputFile ) , e ) ; } } else { domainObject = generator . defaultInstance ( ) ; } beforeConfigured . execute ( domainObject ) ; generator . configure ( domainObject ) ; afterConfigured . execute ( domainObject ) ; generator . write ( domainObject , getOutputFile ( ) ) ; } @Inject protected Instantiator getInstantiator ( ) { throw new UnsupportedOperationException ( ) ; } public File getInputFile ( ) { return inputFile ! = null ? inputFile : getOutputFile ( ) ; } public void setInputFile ( File inputFile ) { this . inputFile = inputFile ; } @OutputFile public File getOutputFile ( ) { return outputFile ; } public void setOutputFile ( File outputFile ) { this . outputFile = outputFile ; } } 
