package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . UUID ; import java . util . regex . Pattern ; import com . google . common . primitives . UnsignedLongs ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . Constants ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . serializers . TypeSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . serializers . UUIDSerializer ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; public class UUIDType extends AbstractType < UUID > { public static final UUIDType instance = new UUIDType ( ) ; UUIDType ( ) { super ( ComparisonType . CUSTOM ) ; } public boolean isEmptyValueMeaningless ( ) { return true ; } public int compareCustom ( ByteBuffer b1 , ByteBuffer b2 ) { int s1 = b1 . position ( ) , s2 = b2 . position ( ) ; int l1 = b1 . limit ( ) , l2 = b2 . limit ( ) ; boolean p1 = l1 - s1 = = <int> , p2 = l2 - s2 = = <int> ; if ( ! ( p1 & p2 ) ) { assert p1 | ( l1 = = s1 ) ; assert p2 | ( l2 = = s2 ) ; return p1 ? <int> : p2 ? - <int> : <int> ; } long msb1 = b1 . getLong ( s1 ) ; long msb2 = b2 . getLong ( s2 ) ; int version1 = ( int ) ( ( msb1 > > > <int> ) & <hex> ) ; int version2 = ( int ) ( ( msb2 > > > <int> ) & <hex> ) ; if ( version1 ! = version2 ) return version1 - version2 ; if ( version1 = = <int> ) { long reorder1 = TimeUUIDType . reorderTimestampBytes ( msb1 ) ; long reorder2 = TimeUUIDType . reorderTimestampBytes ( msb2 ) ; int c = Long . compare ( reorder1 , reorder2 ) ; if ( c ! = <int> ) return c ; } else { int c = UnsignedLongs . compare ( msb1 , msb2 ) ; if ( c ! = <int> ) return c ; } return UnsignedLongs . compare ( b1 . getLong ( s1 + <int> ) , b2 . getLong ( s2 + <int> ) ) ; } @Override public boolean isValueCompatibleWithInternal ( AbstractType < ? > otherType ) { return otherType instanceof UUIDType | | otherType instanceof TimeUUIDType ; } @Override public ByteBuffer fromString ( String source ) throws MarshalException { ByteBuffer parsed = parse ( source ) ; if ( parsed ! = null ) return parsed ; throw new MarshalException ( String . format ( <str> , source ) ) ; } @Override public CQL3Type asCQL3Type ( ) { return CQL3Type . Native . UUID ; } public TypeSerializer < UUID > getSerializer ( ) { return UUIDSerializer . instance ; } static final Pattern regexPattern = Pattern . compile ( <str> ) ; static ByteBuffer parse ( String source ) { if ( source . isEmpty ( ) ) return ByteBufferUtil . EMPTY_BYTE_BUFFER ; if ( regexPattern . matcher ( source ) . matches ( ) ) { try { return UUIDGen . toByteBuffer ( UUID . fromString ( source ) ) ; } catch ( IllegalArgumentException e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } } return null ; } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { try { return new Constants . Value ( fromString ( ( String ) parsed ) ) ; } catch ( ClassCastException exc ) { throw new MarshalException ( String . format ( <str> , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; } } static int version ( ByteBuffer uuid ) { return ( uuid . get ( <int> ) & <hex> ) > > <int> ; } @Override protected int valueLengthIfFixed ( ) { return <int> ; } } 
