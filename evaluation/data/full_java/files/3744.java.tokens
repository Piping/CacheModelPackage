package org . eclipse . debug . examples . core . pda . model ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . Socket ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IMarkerDelta ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Path ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . IBreakpointManager ; import org . eclipse . debug . core . IBreakpointManagerListener ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . examples . core . pda . DebugCorePlugin ; import org . eclipse . debug . examples . core . pda . breakpoints . PDALineBreakpoint ; import org . eclipse . debug . examples . core . pda . breakpoints . PDARunToLineBreakpoint ; import org . eclipse . debug . examples . core . pda . protocol . PDACommand ; import org . eclipse . debug . examples . core . pda . protocol . PDACommandResult ; import org . eclipse . debug . examples . core . pda . protocol . PDAEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAEventStopCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAExitedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDARestartCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAStartedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDATerminateCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMResumeCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMResumedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMStartedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMSuspendCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMSuspendedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMTerminatedEvent ; public class PDADebugTarget extends PDADebugElement implements IDebugTarget , IBreakpointManagerListener , IPDAEventListener { private IProcess fProcess ; private ILaunch fLaunch ; private Socket fRequestSocket ; private PrintWriter fRequestWriter ; private BufferedReader fRequestReader ; private Socket fEventSocket ; private BufferedReader fEventReader ; private boolean fVMSuspended = false ; private boolean fTerminated = false ; private Map < Integer , PDAThread > fThreads = Collections . synchronizedMap ( new LinkedHashMap < Integer , PDAThread > ( ) ) ; private EventDispatchJob fEventDispatch ; private List < IPDAEventListener > fEventListeners = Collections . synchronizedList ( new ArrayList < IPDAEventListener > ( ) ) ; class EventDispatchJob extends Job { public EventDispatchJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { String message = <str> ; while ( ! isTerminated ( ) & & message ! = null ) { try { message = fEventReader . readLine ( ) ; if ( message ! = null ) { PDAEvent event = null ; try { event = PDAEvent . parseEvent ( message ) ; } catch ( IllegalArgumentException e ) { DebugCorePlugin . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . ERROR , <str> , <str> , e ) ) ; continue ; } Object [ ] listeners = fEventListeners . toArray ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { ( ( IPDAEventListener ) listeners [ i ] ) . handleEvent ( event ) ; } } } catch ( IOException e ) { vmTerminated ( ) ; } } return Status . OK_STATUS ; } } public void addEventListener ( IPDAEventListener listener ) { synchronized ( fEventListeners ) { if ( ! fEventListeners . contains ( listener ) ) { fEventListeners . add ( listener ) ; } } } public void removeEventListener ( IPDAEventListener listener ) { fEventListeners . remove ( listener ) ; } public PDADebugTarget ( ILaunch launch , IProcess process , int requestPort , int eventPort ) throws CoreException { super ( null ) ; fLaunch = launch ; fProcess = process ; addEventListener ( this ) ; try { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } fRequestSocket = new Socket ( <str> , requestPort ) ; fRequestWriter = new PrintWriter ( fRequestSocket . getOutputStream ( ) ) ; fRequestReader = new BufferedReader ( new InputStreamReader ( fRequestSocket . getInputStream ( ) ) ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } fEventSocket = new Socket ( <str> , eventPort ) ; fEventReader = new BufferedReader ( new InputStreamReader ( fEventSocket . getInputStream ( ) ) ) ; } catch ( UnknownHostException e ) { requestFailed ( <str> , e ) ; } catch ( IOException e ) { requestFailed ( <str> , e ) ; } fEventDispatch = new EventDispatchJob ( ) ; fEventDispatch . schedule ( ) ; IBreakpointManager breakpointManager = getBreakpointManager ( ) ; breakpointManager . addBreakpointListener ( this ) ; breakpointManager . addBreakpointManagerListener ( this ) ; sendCommand ( new PDAEventStopCommand ( PDAEventStopCommand . UNIMPINSTR , true ) ) ; sendCommand ( new PDAEventStopCommand ( PDAEventStopCommand . NOSUCHLABEL , true ) ) ; } @Override public IProcess getProcess ( ) { return fProcess ; } @Override public IThread [ ] getThreads ( ) throws DebugException { synchronized ( fThreads ) { return fThreads . values ( ) . toArray ( new IThread [ fThreads . size ( ) ] ) ; } } @Override public boolean hasThreads ( ) throws DebugException { return fThreads . size ( ) > <int> ; } @Override public String getName ( ) throws DebugException { return <str> ; } @Override public boolean supportsBreakpoint ( IBreakpoint breakpoint ) { if ( ! isTerminated ( ) & & breakpoint . getModelIdentifier ( ) . equals ( getModelIdentifier ( ) ) ) { try { String program = getLaunch ( ) . getLaunchConfiguration ( ) . getAttribute ( DebugCorePlugin . ATTR_PDA_PROGRAM , ( String ) null ) ; if ( program ! = null ) { IResource resource = null ; if ( breakpoint instanceof PDARunToLineBreakpoint ) { PDARunToLineBreakpoint rtl = ( PDARunToLineBreakpoint ) breakpoint ; resource = rtl . getSourceFile ( ) ; } else { IMarker marker = breakpoint . getMarker ( ) ; if ( marker ! = null ) { resource = marker . getResource ( ) ; } } if ( resource ! = null ) { IPath p = new Path ( program ) ; return resource . getFullPath ( ) . equals ( p ) ; } } } catch ( CoreException e ) { } } return false ; } @Override public IDebugTarget getDebugTarget ( ) { return this ; } @Override public ILaunch getLaunch ( ) { return fLaunch ; } @Override public boolean canTerminate ( ) { return getProcess ( ) . canTerminate ( ) ; } @Override public synchronized boolean isTerminated ( ) { return fTerminated | | getProcess ( ) . isTerminated ( ) ; } @Override public void terminate ( ) throws DebugException { sendCommand ( new PDATerminateCommand ( ) ) ; } @Override public boolean canResume ( ) { return ! isTerminated ( ) & & isSuspended ( ) ; } @Override public boolean canSuspend ( ) { return ! isTerminated ( ) & & ! isSuspended ( ) ; } @Override public synchronized boolean isSuspended ( ) { return ! isTerminated ( ) & & fVMSuspended ; } @Override public void resume ( ) throws DebugException { sendCommand ( new PDAVMResumeCommand ( ) ) ; } @Override public void suspend ( ) throws DebugException { sendCommand ( new PDAVMSuspendCommand ( ) ) ; } @Override public void breakpointAdded ( IBreakpoint breakpoint ) { if ( supportsBreakpoint ( breakpoint ) ) { try { if ( ( breakpoint . isEnabled ( ) & & getBreakpointManager ( ) . isEnabled ( ) ) | | ! breakpoint . isRegistered ( ) ) { PDALineBreakpoint pdaBreakpoint = ( PDALineBreakpoint ) breakpoint ; pdaBreakpoint . install ( this ) ; } } catch ( CoreException e ) { } } } @Override public void breakpointRemoved ( IBreakpoint breakpoint , IMarkerDelta delta ) { if ( supportsBreakpoint ( breakpoint ) ) { try { PDALineBreakpoint pdaBreakpoint = ( PDALineBreakpoint ) breakpoint ; pdaBreakpoint . remove ( this ) ; } catch ( CoreException e ) { } } } @Override public void breakpointChanged ( IBreakpoint breakpoint , IMarkerDelta delta ) { if ( supportsBreakpoint ( breakpoint ) ) { try { if ( breakpoint . isEnabled ( ) & & getBreakpointManager ( ) . isEnabled ( ) ) { breakpointAdded ( breakpoint ) ; } else { breakpointRemoved ( breakpoint , null ) ; } } catch ( CoreException e ) { } } } @Override public boolean canDisconnect ( ) { return false ; } @Override public void disconnect ( ) throws DebugException { } @Override public boolean isDisconnected ( ) { return false ; } @Override public boolean supportsStorageRetrieval ( ) { return true ; } @Override public IMemoryBlock getMemoryBlock ( long startAddress , long length ) throws DebugException { return new PDAMemoryBlock ( this , startAddress , length ) ; } private void vmStarted ( PDAVMStartedEvent event ) { fireCreationEvent ( ) ; installDeferredBreakpoints ( ) ; try { resume ( ) ; } catch ( DebugException e ) { } } private void installDeferredBreakpoints ( ) { IBreakpoint [ ] breakpoints = getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { breakpointAdded ( breakpoints [ i ] ) ; } } private void vmTerminated ( ) { setTerminated ( true ) ; fThreads . clear ( ) ; IBreakpointManager breakpointManager = getBreakpointManager ( ) ; breakpointManager . removeBreakpointListener ( this ) ; breakpointManager . removeBreakpointManagerListener ( this ) ; fireTerminateEvent ( ) ; removeEventListener ( this ) ; } private void vmResumed ( PDAVMResumedEvent event ) { setVMSuspended ( false ) ; fireResumeEvent ( calcDetail ( event . fReason ) ) ; } private void vmSuspended ( PDAVMSuspendedEvent event ) { setVMSuspended ( true ) ; fireSuspendEvent ( calcDetail ( event . fReason ) ) ; } private int calcDetail ( String reason ) { if ( reason . equals ( <str> ) | | reason . equals ( <str> ) ) { return DebugEvent . BREAKPOINT ; } else if ( reason . equals ( <str> ) ) { return DebugEvent . STEP_OVER ; } else if ( reason . equals ( <str> ) ) { return DebugEvent . STEP_RETURN ; } else if ( reason . equals ( <str> ) ) { return DebugEvent . CLIENT_REQUEST ; } else if ( reason . equals ( <str> ) ) { return DebugEvent . BREAKPOINT ; } else { return DebugEvent . UNSPECIFIED ; } } private void started ( PDAStartedEvent event ) { PDAThread newThread = new PDAThread ( this , event . fThreadId ) ; fThreads . put ( Integer . valueOf ( event . fThreadId ) , newThread ) ; newThread . start ( ) ; } private void exited ( PDAExitedEvent event ) { PDAThread thread = fThreads . remove ( Integer . valueOf ( event . fThreadId ) ) ; if ( thread ! = null ) { thread . exit ( ) ; } } private synchronized void setVMSuspended ( boolean suspended ) { fVMSuspended = suspended ; } private synchronized void setTerminated ( boolean terminated ) { fTerminated = terminated ; } private String sendRequest ( String request ) throws DebugException { synchronized ( fRequestSocket ) { fRequestWriter . println ( request ) ; fRequestWriter . flush ( ) ; try { String retVal = fRequestReader . readLine ( ) ; if ( retVal = = null ) { requestFailed ( <str> + request + <str> , null ) ; } return retVal ; } catch ( IOException e ) { requestFailed ( <str> + request , e ) ; } } return null ; } @Override public PDACommandResult sendCommand ( PDACommand command ) throws DebugException { String response = sendRequest ( command . getRequest ( ) ) ; return command . createResult ( response ) ; } @Override public void breakpointManagerEnablementChanged ( boolean enabled ) { IBreakpoint [ ] breakpoints = getBreakpointManager ( ) . getBreakpoints ( getModelIdentifier ( ) ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { if ( enabled ) { breakpointAdded ( breakpoints [ i ] ) ; } else { breakpointRemoved ( breakpoints [ i ] , null ) ; } } } @Override public void handleEvent ( PDAEvent event ) { if ( event instanceof PDAStartedEvent ) { started ( ( PDAStartedEvent ) event ) ; } else if ( event instanceof PDAExitedEvent ) { exited ( ( PDAExitedEvent ) event ) ; } else if ( event instanceof PDAVMStartedEvent ) { vmStarted ( ( PDAVMStartedEvent ) event ) ; } else if ( event instanceof PDAVMTerminatedEvent ) { vmTerminated ( ) ; } else if ( event instanceof PDAVMSuspendedEvent ) { vmSuspended ( ( PDAVMSuspendedEvent ) event ) ; } else if ( event instanceof PDAVMResumedEvent ) { vmResumed ( ( PDAVMResumedEvent ) event ) ; } } public PDAThread getThread ( int threadId ) { if ( threadId > <int> ) { return fThreads . get ( Integer . valueOf ( threadId ) ) ; } else { synchronized ( fThreads ) { if ( fThreads . size ( ) > <int> ) { return fThreads . values ( ) . iterator ( ) . next ( ) ; } } } return null ; } public void restart ( ) throws DebugException { sendCommand ( new PDARestartCommand ( ) ) ; } } 
