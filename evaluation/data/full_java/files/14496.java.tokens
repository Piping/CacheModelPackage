package org . gradle . model . dsl . internal . transform ; import com . google . common . collect . Lists ; import org . codehaus . groovy . ast . * ; import org . codehaus . groovy . ast . expr . * ; import org . codehaus . groovy . ast . stmt . BlockStatement ; import org . codehaus . groovy . ast . stmt . EmptyStatement ; import org . codehaus . groovy . ast . stmt . ExpressionStatement ; import org . codehaus . groovy . ast . stmt . Statement ; import org . codehaus . groovy . control . SourceUnit ; import org . gradle . api . Nullable ; import org . gradle . groovy . scripts . internal . AstUtils ; import org . gradle . groovy . scripts . internal . RestrictiveCodeVisitor ; import org . gradle . internal . Pair ; import org . gradle . model . internal . core . ModelPath ; import java . util . List ; public class RulesVisitor extends RestrictiveCodeVisitor { private static final String AST_NODE_METADATA_KEY = RulesVisitor . class . getName ( ) ; private static final ClassNode ANNOTATION_CLASS_NODE = new ClassNode ( RulesBlock . class ) ; public static final String INVALID_STATEMENT = <str> ; public static final String INVALID_RULE_SIGNATURE = <str> ; private final RuleVisitor ruleVisitor ; public RulesVisitor ( SourceUnit sourceUnit , RuleVisitor ruleVisitor ) { super ( sourceUnit , INVALID_STATEMENT ) ; this . ruleVisitor = ruleVisitor ; } public static void visitGeneratedClosure ( ClassNode node ) { MethodNode method = AstUtils . getGeneratedClosureImplMethod ( node ) ; Boolean isRulesBlock = method . getCode ( ) . getNodeMetaData ( AST_NODE_METADATA_KEY ) ; if ( isRulesBlock ! = null ) { AnnotationNode markerAnnotation = new AnnotationNode ( ANNOTATION_CLASS_NODE ) ; node . addAnnotation ( markerAnnotation ) ; } } @Override public void visitBlockStatement ( BlockStatement block ) { block . setNodeMetaData ( AST_NODE_METADATA_KEY , true ) ; for ( Statement statement : block . getStatements ( ) ) { statement . visit ( this ) ; } } @Override public void visitExpressionStatement ( ExpressionStatement statement ) { statement . getExpression ( ) . visit ( this ) ; } @Override public void visitMethodCallExpression ( MethodCallExpression call ) { ClosureExpression closureExpression = AstUtils . getSingleClosureArg ( call ) ; if ( closureExpression ! = null ) { rewriteAction ( call , extractModelPathFromMethodTarget ( call ) , closureExpression , RuleVisitor . displayName ( call ) ) ; return ; } Pair < ClassExpression , ClosureExpression > args = AstUtils . getClassAndClosureArgs ( call ) ; if ( args ! = null ) { rewriteCreator ( call , extractModelPathFromMethodTarget ( call ) , args . getRight ( ) , args . getLeft ( ) , RuleVisitor . displayName ( call ) ) ; return ; } ClassExpression classArg = AstUtils . getClassArg ( call ) ; if ( classArg ! = null ) { String displayName = RuleVisitor . displayName ( call ) ; List < Statement > statements = Lists . newLinkedList ( ) ; statements . add ( new EmptyStatement ( ) ) ; BlockStatement block = new BlockStatement ( statements , new VariableScope ( ) ) ; closureExpression = new ClosureExpression ( Parameter . EMPTY_ARRAY , block ) ; closureExpression . setVariableScope ( block . getVariableScope ( ) ) ; String modelPath = extractModelPathFromMethodTarget ( call ) ; rewriteCreator ( call , modelPath , closureExpression , classArg , displayName ) ; return ; } restrict ( call , INVALID_RULE_SIGNATURE ) ; } public void rewriteCreator ( MethodCallExpression call , String modelPath , ClosureExpression closureExpression , ClassExpression typeExpression , String displayName ) { ConstantExpression modelPathArgument = new ConstantExpression ( modelPath ) ; ArgumentListExpression replacedArgumentList = new ArgumentListExpression ( modelPathArgument , typeExpression , closureExpression ) ; call . setMethod ( new ConstantExpression ( <str> ) ) ; call . setArguments ( replacedArgumentList ) ; call . setImplicitThis ( true ) ; call . setObjectExpression ( new MethodCallExpression ( VariableExpression . THIS_EXPRESSION , <str> , ArgumentListExpression . EMPTY_ARGUMENTS ) ) ; ruleVisitor . visitRuleClosure ( closureExpression , call , displayName ) ; } public void rewriteAction ( MethodCallExpression call , String modelPath , ClosureExpression closureExpression , String displayName ) { ConstantExpression modelPathArgument = new ConstantExpression ( modelPath ) ; ArgumentListExpression replacedArgumentList = new ArgumentListExpression ( modelPathArgument , closureExpression ) ; call . setMethod ( new ConstantExpression ( <str> ) ) ; call . setArguments ( replacedArgumentList ) ; call . setImplicitThis ( true ) ; call . setObjectExpression ( new MethodCallExpression ( VariableExpression . THIS_EXPRESSION , <str> , ArgumentListExpression . EMPTY_ARGUMENTS ) ) ; ruleVisitor . visitRuleClosure ( closureExpression , call , displayName ) ; } @Nullable private String extractModelPathFromMethodTarget ( MethodCallExpression call ) { Expression target = call . getMethod ( ) ; List < String > names = Lists . newLinkedList ( ) ; while ( true ) { if ( target instanceof ConstantExpression ) { if ( target . getType ( ) . equals ( ClassHelper . STRING_TYPE ) ) { String name = target . getText ( ) ; names . add ( <int> , name ) ; if ( call . isImplicitThis ( ) ) { break ; } else { target = call . getObjectExpression ( ) ; continue ; } } } else if ( target instanceof PropertyExpression ) { PropertyExpression propertyExpression = ( PropertyExpression ) target ; Expression property = propertyExpression . getProperty ( ) ; if ( property instanceof ConstantExpression ) { ConstantExpression constantProperty = ( ConstantExpression ) property ; if ( constantProperty . getType ( ) . equals ( ClassHelper . STRING_TYPE ) ) { String name = constantProperty . getText ( ) ; names . add ( <int> , name ) ; target = propertyExpression . getObjectExpression ( ) ; continue ; } } } else if ( target instanceof VariableExpression ) { names . add ( <int> , ( ( VariableExpression ) target ) . getName ( ) ) ; break ; } restrict ( call ) ; return null ; } return ModelPath . pathString ( names ) ; } } 
