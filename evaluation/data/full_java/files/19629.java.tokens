package io . netty . util ; import io . netty . util . ByteProcessor . IndexOfProcessor ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . PlatformDependent ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . charset . Charset ; import java . nio . charset . CharsetEncoder ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . regex . Pattern ; import java . util . regex . PatternSyntaxException ; import static io . netty . util . internal . MathUtil . isOutOfBounds ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public final class AsciiString implements CharSequence , Comparable < CharSequence > { public static final AsciiString EMPTY_STRING = new AsciiString ( <str> ) ; private static final char MAX_CHAR_VALUE = <int> ; public static final int INDEX_NOT_FOUND = - <int> ; private final byte [ ] value ; private final int offset ; private final int length ; private int hash ; private String string ; public AsciiString ( byte [ ] value ) { this ( value , true ) ; } public AsciiString ( byte [ ] value , boolean copy ) { this ( value , <int> , value . length , copy ) ; } public AsciiString ( byte [ ] value , int start , int length , boolean copy ) { if ( copy ) { this . value = Arrays . copyOfRange ( value , start , start + length ) ; this . offset = <int> ; } else { if ( isOutOfBounds ( start , length , value . length ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + <str> + value . length + <str> ) ; } this . value = value ; this . offset = start ; } this . length = length ; } public AsciiString ( ByteBuffer value ) { this ( value , true ) ; } public AsciiString ( ByteBuffer value , boolean copy ) { this ( value , value . position ( ) , value . remaining ( ) , copy ) ; } public AsciiString ( ByteBuffer value , int start , int length , boolean copy ) { if ( isOutOfBounds ( start , length , value . capacity ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + <str> + value . capacity ( ) + <str> ) ; } if ( value . hasArray ( ) ) { if ( copy ) { final int bufferOffset = value . arrayOffset ( ) + start ; this . value = Arrays . copyOfRange ( value . array ( ) , bufferOffset , bufferOffset + length ) ; offset = <int> ; } else { this . value = value . array ( ) ; this . offset = start ; } } else { this . value = new byte [ length ] ; int oldPos = value . position ( ) ; value . get ( this . value , <int> , length ) ; value . position ( oldPos ) ; this . offset = <int> ; } this . length = length ; } public AsciiString ( char [ ] value ) { this ( value , <int> , value . length ) ; } public AsciiString ( char [ ] value , int start , int length ) { if ( isOutOfBounds ( start , length , value . length ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + <str> + value . length + <str> ) ; } this . value = new byte [ length ] ; for ( int i = <int> , j = start ; i < length ; i + + , j + + ) { this . value [ i ] = c2b ( value [ j ] ) ; } this . offset = <int> ; this . length = length ; } public AsciiString ( char [ ] value , Charset charset ) { this ( value , charset , <int> , value . length ) ; } public AsciiString ( char [ ] value , Charset charset , int start , int length ) { CharBuffer cbuf = CharBuffer . wrap ( value , start , length ) ; CharsetEncoder encoder = CharsetUtil . getEncoder ( charset ) ; ByteBuffer nativeBuffer = ByteBuffer . allocate ( ( int ) ( encoder . maxBytesPerChar ( ) * length ) ) ; encoder . encode ( cbuf , nativeBuffer , true ) ; final int bufferOffset = nativeBuffer . arrayOffset ( ) ; this . value = Arrays . copyOfRange ( nativeBuffer . array ( ) , bufferOffset , bufferOffset + nativeBuffer . position ( ) ) ; this . offset = <int> ; this . length = this . value . length ; } public AsciiString ( CharSequence value ) { this ( value , <int> , value . length ( ) ) ; } public AsciiString ( CharSequence value , int start , int length ) { if ( isOutOfBounds ( start , length , value . length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + <str> + value . length ( ) + <str> ) ; } this . value = new byte [ length ] ; for ( int i = <int> , j = start ; i < length ; i + + , j + + ) { this . value [ i ] = c2b ( value . charAt ( j ) ) ; } this . offset = <int> ; this . length = length ; } public AsciiString ( CharSequence value , Charset charset ) { this ( value , charset , <int> , value . length ( ) ) ; } public AsciiString ( CharSequence value , Charset charset , int start , int length ) { CharBuffer cbuf = CharBuffer . wrap ( value , start , start + length ) ; CharsetEncoder encoder = CharsetUtil . getEncoder ( charset ) ; ByteBuffer nativeBuffer = ByteBuffer . allocate ( ( int ) ( encoder . maxBytesPerChar ( ) * length ) ) ; encoder . encode ( cbuf , nativeBuffer , true ) ; final int offset = nativeBuffer . arrayOffset ( ) ; this . value = Arrays . copyOfRange ( nativeBuffer . array ( ) , offset , offset + nativeBuffer . position ( ) ) ; this . offset = <int> ; this . length = this . value . length ; } public int forEachByte ( ByteProcessor visitor ) throws Exception { return forEachByte0 ( <int> , length ( ) , visitor ) ; } public int forEachByte ( int index , int length , ByteProcessor visitor ) throws Exception { if ( isOutOfBounds ( index , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + index + <str> + length + <str> + <str> + length ( ) + <str> ) ; } return forEachByte0 ( index , length , visitor ) ; } private int forEachByte0 ( int index , int length , ByteProcessor visitor ) throws Exception { final int len = offset + index + length ; for ( int i = offset + index ; i < len ; + + i ) { if ( ! visitor . process ( value [ i ] ) ) { return i - offset ; } } return - <int> ; } public int forEachByteDesc ( ByteProcessor visitor ) throws Exception { return forEachByteDesc0 ( <int> , length ( ) , visitor ) ; } public int forEachByteDesc ( int index , int length , ByteProcessor visitor ) throws Exception { if ( isOutOfBounds ( index , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + index + <str> + length + <str> + <str> + length ( ) + <str> ) ; } return forEachByteDesc0 ( index , length , visitor ) ; } private int forEachByteDesc0 ( int index , int length , ByteProcessor visitor ) throws Exception { final int end = offset + index ; for ( int i = offset + index + length - <int> ; i > = end ; - - i ) { if ( ! visitor . process ( value [ i ] ) ) { return i - offset ; } } return - <int> ; } public byte byteAt ( int index ) { if ( index < <int> | | index > = length ) { throw new IndexOutOfBoundsException ( <str> + index + <str> + length + <str> ) ; } if ( PlatformDependent . hasUnsafe ( ) ) { return PlatformDependent . getByte ( value , index + offset ) ; } return value [ index + offset ] ; } public boolean isEmpty ( ) { return length = = <int> ; } @Override public int length ( ) { return length ; } public void arrayChanged ( ) { string = null ; hash = <int> ; } public byte [ ] array ( ) { return value ; } public int arrayOffset ( ) { return offset ; } public boolean isEntireArrayUsed ( ) { return offset = = <int> & & length = = value . length ; } public byte [ ] toByteArray ( ) { return toByteArray ( <int> , length ( ) ) ; } public byte [ ] toByteArray ( int start , int end ) { return Arrays . copyOfRange ( value , start + offset , end + offset ) ; } public void copy ( int srcIdx , byte [ ] dst , int dstIdx , int length ) { if ( isOutOfBounds ( srcIdx , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + srcIdx + <str> + length + <str> + length ( ) + <str> ) ; } System . arraycopy ( value , srcIdx + offset , checkNotNull ( dst , <str> ) , dstIdx , length ) ; } @Override public char charAt ( int index ) { return b2c ( byteAt ( index ) ) ; } public boolean contains ( CharSequence cs ) { return indexOf ( cs ) > = <int> ; } @Override public int compareTo ( CharSequence string ) { if ( this = = string ) { return <int> ; } int result ; int length1 = length ( ) ; int length2 = string . length ( ) ; int minLength = Math . min ( length1 , length2 ) ; for ( int i = <int> , j = arrayOffset ( ) ; i < minLength ; i + + , j + + ) { result = b2c ( value [ j ] ) - string . charAt ( i ) ; if ( result ! = <int> ) { return result ; } } return length1 - length2 ; } public AsciiString concat ( CharSequence string ) { int thisLen = length ( ) ; int thatLen = string . length ( ) ; if ( thatLen = = <int> ) { return this ; } if ( string . getClass ( ) = = AsciiString . class ) { AsciiString that = ( AsciiString ) string ; if ( isEmpty ( ) ) { return that ; } byte [ ] newValue = new byte [ thisLen + thatLen ] ; System . arraycopy ( value , arrayOffset ( ) , newValue , <int> , thisLen ) ; System . arraycopy ( that . value , that . arrayOffset ( ) , newValue , thisLen , thatLen ) ; return new AsciiString ( newValue , false ) ; } if ( isEmpty ( ) ) { return new AsciiString ( string ) ; } byte [ ] newValue = new byte [ thisLen + thatLen ] ; System . arraycopy ( value , arrayOffset ( ) , newValue , <int> , thisLen ) ; for ( int i = thisLen , j = <int> ; i < newValue . length ; i + + , j + + ) { newValue [ i ] = c2b ( string . charAt ( j ) ) ; } return new AsciiString ( newValue , false ) ; } public boolean endsWith ( CharSequence suffix ) { int suffixLen = suffix . length ( ) ; return regionMatches ( length ( ) - suffixLen , suffix , <int> , suffixLen ) ; } public boolean contentEqualsIgnoreCase ( CharSequence string ) { if ( string = = null | | string . length ( ) ! = length ( ) ) { return false ; } if ( string . getClass ( ) = = AsciiString . class ) { AsciiString rhs = ( AsciiString ) string ; for ( int i = arrayOffset ( ) , j = rhs . arrayOffset ( ) ; i < length ( ) ; + + i , + + j ) { if ( ! equalsIgnoreCase ( value [ i ] , value [ j ] ) ) { return false ; } } return true ; } for ( int i = arrayOffset ( ) , j = <int> ; i < length ( ) ; + + i , + + j ) { if ( ! equalsIgnoreCase ( b2c ( value [ i ] ) , string . charAt ( j ) ) ) { return false ; } } return true ; } public char [ ] toCharArray ( ) { return toCharArray ( <int> , length ( ) ) ; } public char [ ] toCharArray ( int start , int end ) { int length = end - start ; if ( length = = <int> ) { return EmptyArrays . EMPTY_CHARS ; } if ( isOutOfBounds ( start , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + length ( ) + <str> ) ; } final char [ ] buffer = new char [ length ] ; for ( int i = <int> , j = start + arrayOffset ( ) ; i < length ; i + + , j + + ) { buffer [ i ] = b2c ( value [ j ] ) ; } return buffer ; } public void copy ( int srcIdx , char [ ] dst , int dstIdx , int length ) { if ( dst = = null ) { throw new NullPointerException ( <str> ) ; } if ( isOutOfBounds ( srcIdx , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + srcIdx + <str> + length + <str> + length ( ) + <str> ) ; } final int dstEnd = dstIdx + length ; for ( int i = dstIdx , j = srcIdx + arrayOffset ( ) ; i < dstEnd ; i + + , j + + ) { dst [ i ] = b2c ( value [ j ] ) ; } } public AsciiString subSequence ( int start ) { return subSequence ( start , length ( ) ) ; } @Override public AsciiString subSequence ( int start , int end ) { return subSequence ( start , end , true ) ; } public AsciiString subSequence ( int start , int end , boolean copy ) { if ( isOutOfBounds ( start , end - start , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + start + <str> + end + <str> + length ( ) + <str> ) ; } if ( start = = <int> & & end = = length ( ) ) { return this ; } if ( end = = start ) { return EMPTY_STRING ; } return new AsciiString ( value , start + offset , end - start , copy ) ; } public int indexOf ( CharSequence string ) { return indexOf ( string , <int> ) ; } public int indexOf ( CharSequence subString , int start ) { if ( start < <int> ) { start = <int> ; } final int thisLen = length ( ) ; int subCount = subString . length ( ) ; if ( subCount < = <int> ) { return start < thisLen ? start : thisLen ; } if ( subCount > thisLen - start ) { return - <int> ; } final char firstChar = subString . charAt ( <int> ) ; if ( firstChar > MAX_CHAR_VALUE ) { return - <int> ; } ByteProcessor IndexOfVisitor = new IndexOfProcessor ( ( byte ) firstChar ) ; try { for ( ; ; ) { int i = forEachByte ( start , thisLen - start , IndexOfVisitor ) ; if ( i = = - <int> | | subCount + i > thisLen ) { return - <int> ; } int o1 = i , o2 = <int> ; while ( + + o2 < subCount & & b2c ( value [ + + o1 + arrayOffset ( ) ] ) = = subString . charAt ( o2 ) ) { } if ( o2 = = subCount ) { return i ; } start = i + <int> ; } } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; return - <int> ; } } public int lastIndexOf ( CharSequence string ) { return lastIndexOf ( string , length ( ) ) ; } public int lastIndexOf ( CharSequence subString , int start ) { final int thisLen = length ( ) ; final int subCount = subString . length ( ) ; if ( subCount > thisLen | | start < <int> ) { return - <int> ; } if ( subCount < = <int> ) { return start < thisLen ? start : thisLen ; } start = Math . min ( start , thisLen - subCount ) ; final char firstChar = subString . charAt ( <int> ) ; if ( firstChar > MAX_CHAR_VALUE ) { return - <int> ; } ByteProcessor IndexOfVisitor = new IndexOfProcessor ( ( byte ) firstChar ) ; try { for ( ; ; ) { int i = forEachByteDesc ( start , thisLen - start , IndexOfVisitor ) ; if ( i = = - <int> ) { return - <int> ; } int o1 = i , o2 = <int> ; while ( + + o2 < subCount & & b2c ( value [ + + o1 + arrayOffset ( ) ] ) = = subString . charAt ( o2 ) ) { } if ( o2 = = subCount ) { return i ; } start = i - <int> ; } } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; return - <int> ; } } public boolean regionMatches ( int thisStart , CharSequence string , int start , int length ) { if ( string = = null ) { throw new NullPointerException ( <str> ) ; } if ( start < <int> | | string . length ( ) - start < length ) { return false ; } final int thisLen = length ( ) ; if ( thisStart < <int> | | thisLen - thisStart < length ) { return false ; } if ( length < = <int> ) { return true ; } final int thatEnd = start + length ; for ( int i = start , j = thisStart + arrayOffset ( ) ; i < thatEnd ; i + + , j + + ) { if ( b2c ( value [ j ] ) ! = string . charAt ( i ) ) { return false ; } } return true ; } public boolean regionMatches ( boolean ignoreCase , int thisStart , CharSequence string , int start , int length ) { if ( ! ignoreCase ) { return regionMatches ( thisStart , string , start , length ) ; } if ( string = = null ) { throw new NullPointerException ( <str> ) ; } final int thisLen = length ( ) ; if ( thisStart < <int> | | length > thisLen - thisStart ) { return false ; } if ( start < <int> | | length > string . length ( ) - start ) { return false ; } thisStart + = arrayOffset ( ) ; final int thisEnd = thisStart + length ; while ( thisStart < thisEnd ) { if ( ! equalsIgnoreCase ( b2c ( value [ thisStart + + ] ) , string . charAt ( start + + ) ) ) { return false ; } } return true ; } public AsciiString replace ( char oldChar , char newChar ) { if ( oldChar > MAX_CHAR_VALUE ) { return this ; } final int index ; final byte oldCharByte = c2b ( oldChar ) ; try { index = forEachByte ( new IndexOfProcessor ( oldCharByte ) ) ; } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; return this ; } if ( index = = - <int> ) { return this ; } final byte newCharByte = c2b ( newChar ) ; byte [ ] buffer = new byte [ length ( ) ] ; for ( int i = <int> , j = arrayOffset ( ) ; i < buffer . length ; i + + , j + + ) { byte b = value [ j ] ; if ( b = = oldCharByte ) { b = newCharByte ; } buffer [ i ] = b ; } return new AsciiString ( buffer , false ) ; } public boolean startsWith ( CharSequence prefix ) { return startsWith ( prefix , <int> ) ; } public boolean startsWith ( CharSequence prefix , int start ) { return regionMatches ( start , prefix , <int> , prefix . length ( ) ) ; } public AsciiString toLowerCase ( ) { boolean lowercased = true ; int i , j ; final int len = length ( ) + arrayOffset ( ) ; for ( i = arrayOffset ( ) ; i < len ; + + i ) { byte b = value [ i ] ; if ( b > = <str> & & b < = <str> ) { lowercased = false ; break ; } } if ( lowercased ) { return this ; } final byte [ ] newValue = new byte [ length ( ) ] ; for ( i = <int> , j = arrayOffset ( ) ; i < newValue . length ; + + i , + + j ) { newValue [ i ] = toLowerCase ( value [ j ] ) ; } return new AsciiString ( newValue , false ) ; } public AsciiString toUpperCase ( ) { boolean uppercased = true ; int i , j ; final int len = length ( ) + arrayOffset ( ) ; for ( i = arrayOffset ( ) ; i < len ; + + i ) { byte b = value [ i ] ; if ( b > = <str> & & b < = <str> ) { uppercased = false ; break ; } } if ( uppercased ) { return this ; } final byte [ ] newValue = new byte [ length ( ) ] ; for ( i = <int> , j = arrayOffset ( ) ; i < newValue . length ; + + i , + + j ) { newValue [ i ] = toUpperCase ( value [ j ] ) ; } return new AsciiString ( newValue , false ) ; } public AsciiString trim ( ) { int start = arrayOffset ( ) , last = arrayOffset ( ) + length ( ) ; int end = last ; while ( start < = end & & value [ start ] < = <str> ) { start + + ; } while ( end > = start & & value [ end ] < = <str> ) { end - - ; } if ( start = = <int> & & end = = last ) { return this ; } return new AsciiString ( value , start , end - start + <int> , false ) ; } public boolean contentEquals ( CharSequence a ) { if ( a = = null | | a . length ( ) ! = length ( ) ) { return false ; } if ( a . getClass ( ) = = AsciiString . class ) { return equals ( a ) ; } for ( int i = arrayOffset ( ) , j = <int> ; j < a . length ( ) ; + + i , + + j ) { if ( b2c ( value [ i ] ) ! = a . charAt ( j ) ) { return false ; } } return true ; } public boolean matches ( String expr ) { return Pattern . matches ( expr , this ) ; } public AsciiString [ ] split ( String expr , int max ) { return toAsciiStringArray ( Pattern . compile ( expr ) . split ( this , max ) ) ; } public AsciiString [ ] split ( char delim ) { final List < AsciiString > res = new ArrayList < AsciiString > ( ) ; int start = <int> ; final int length = length ( ) ; for ( int i = start ; i < length ; i + + ) { if ( charAt ( i ) = = delim ) { if ( start = = i ) { res . add ( EMPTY_STRING ) ; } else { res . add ( new AsciiString ( value , start + arrayOffset ( ) , i - start , false ) ) ; } start = i + <int> ; } } if ( start = = <int> ) { res . add ( this ) ; } else { if ( start ! = length ) { res . add ( new AsciiString ( value , start + arrayOffset ( ) , length - start , false ) ) ; } else { for ( int i = res . size ( ) - <int> ; i > = <int> ; i - - ) { if ( res . get ( i ) . isEmpty ( ) ) { res . remove ( i ) ; } else { break ; } } } } return res . toArray ( new AsciiString [ res . size ( ) ] ) ; } @Override public int hashCode ( ) { if ( hash = = <int> ) { hash = PlatformDependent . hashCodeAscii ( value , offset , length ) ; } return hash ; } @Override public boolean equals ( Object obj ) { if ( obj = = null | | obj . getClass ( ) ! = AsciiString . class ) { return false ; } if ( this = = obj ) { return true ; } AsciiString other = ( AsciiString ) obj ; return length ( ) = = other . length ( ) & & hashCode ( ) = = other . hashCode ( ) & & PlatformDependent . equals ( array ( ) , arrayOffset ( ) , other . array ( ) , other . arrayOffset ( ) , length ( ) ) ; } @Override public String toString ( ) { if ( string ! = null ) { return string ; } string = toString ( <int> ) ; return string ; } public String toString ( int start ) { return toString ( start , length ( ) ) ; } public String toString ( int start , int end ) { int length = end - start ; if ( length = = <int> ) { return <str> ; } if ( isOutOfBounds ( start , length , length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + length ( ) + <str> ) ; } @SuppressWarnings ( <str> ) final String str = new String ( value , <int> , start + offset , length ) ; return str ; } public boolean parseBoolean ( ) { return length > = <int> & & value [ offset ] ! = <int> ; } public char parseChar ( ) { return parseChar ( <int> ) ; } public char parseChar ( int start ) { if ( start + <int> > = length ( ) ) { throw new IndexOutOfBoundsException ( <str> + start + <str> ) ; } final int startWithOffset = start + offset ; return ( char ) ( ( b2c ( value [ startWithOffset ] ) < < <int> ) | b2c ( value [ startWithOffset + <int> ] ) ) ; } public short parseShort ( ) { return parseShort ( <int> , length ( ) , <int> ) ; } public short parseShort ( int radix ) { return parseShort ( <int> , length ( ) , radix ) ; } public short parseShort ( int start , int end ) { return parseShort ( start , end , <int> ) ; } public short parseShort ( int start , int end , int radix ) { int intValue = parseInt ( start , end , radix ) ; short result = ( short ) intValue ; if ( result ! = intValue ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } return result ; } public int parseInt ( ) { return parseInt ( <int> , length ( ) , <int> ) ; } public int parseInt ( int radix ) { return parseInt ( <int> , length ( ) , radix ) ; } public int parseInt ( int start , int end ) { return parseInt ( start , end , <int> ) ; } public int parseInt ( int start , int end , int radix ) { if ( radix < Character . MIN_RADIX | | radix > Character . MAX_RADIX ) { throw new NumberFormatException ( ) ; } if ( start = = end ) { throw new NumberFormatException ( ) ; } int i = start ; boolean negative = byteAt ( i ) = = <str> ; if ( negative & & + + i = = end ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } return parseInt ( i , end , radix , negative ) ; } private int parseInt ( int start , int end , int radix , boolean negative ) { int max = Integer . MIN_VALUE / radix ; int result = <int> ; int currOffset = start ; while ( currOffset < end ) { int digit = Character . digit ( ( char ) ( value [ currOffset + + + offset ] & <hex> ) , radix ) ; if ( digit = = - <int> ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } if ( max > result ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } int next = result * radix - digit ; if ( next > result ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } result = next ; } if ( ! negative ) { result = - result ; if ( result < <int> ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } } return result ; } public long parseLong ( ) { return parseLong ( <int> , length ( ) , <int> ) ; } public long parseLong ( int radix ) { return parseLong ( <int> , length ( ) , radix ) ; } public long parseLong ( int start , int end ) { return parseLong ( start , end , <int> ) ; } public long parseLong ( int start , int end , int radix ) { if ( radix < Character . MIN_RADIX | | radix > Character . MAX_RADIX ) { throw new NumberFormatException ( ) ; } if ( start = = end ) { throw new NumberFormatException ( ) ; } int i = start ; boolean negative = byteAt ( i ) = = <str> ; if ( negative & & + + i = = end ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } return parseLong ( i , end , radix , negative ) ; } private long parseLong ( int start , int end , int radix , boolean negative ) { long max = Long . MIN_VALUE / radix ; long result = <int> ; int currOffset = start ; while ( currOffset < end ) { int digit = Character . digit ( ( char ) ( value [ currOffset + + + offset ] & <hex> ) , radix ) ; if ( digit = = - <int> ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } if ( max > result ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } long next = result * radix - digit ; if ( next > result ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } result = next ; } if ( ! negative ) { result = - result ; if ( result < <int> ) { throw new NumberFormatException ( subSequence ( start , end , false ) . toString ( ) ) ; } } return result ; } public float parseFloat ( ) { return parseFloat ( <int> , length ( ) ) ; } public float parseFloat ( int start , int end ) { return Float . parseFloat ( toString ( start , end ) ) ; } public double parseDouble ( ) { return parseDouble ( <int> , length ( ) ) ; } public double parseDouble ( int start , int end ) { return Double . parseDouble ( toString ( start , end ) ) ; } public static final HashingStrategy < CharSequence > CASE_INSENSITIVE_HASHER = new HashingStrategy < CharSequence > ( ) { @Override public int hashCode ( CharSequence o ) { return AsciiString . hashCode ( o ) ; } @Override public boolean equals ( CharSequence a , CharSequence b ) { return AsciiString . contentEqualsIgnoreCase ( a , b ) ; } } ; public static final HashingStrategy < CharSequence > CASE_SENSITIVE_HASHER = new HashingStrategy < CharSequence > ( ) { @Override public int hashCode ( CharSequence o ) { return AsciiString . hashCode ( o ) ; } @Override public boolean equals ( CharSequence a , CharSequence b ) { return AsciiString . contentEquals ( a , b ) ; } } ; public static AsciiString of ( CharSequence string ) { return string . getClass ( ) = = AsciiString . class ? ( AsciiString ) string : new AsciiString ( string ) ; } public static int hashCode ( CharSequence value ) { if ( value = = null ) { return <int> ; } if ( value . getClass ( ) = = AsciiString . class ) { return ( ( AsciiString ) value ) . hashCode ( ) ; } return PlatformDependent . hashCodeAscii ( value ) ; } public static boolean contains ( CharSequence a , CharSequence b ) { return contains ( a , b , DefaultCharEqualityComparator . INSTANCE ) ; } public static boolean containsIgnoreCase ( CharSequence a , CharSequence b ) { return contains ( a , b , AsciiCaseInsensitiveCharEqualityComparator . INSTANCE ) ; } public static boolean contentEqualsIgnoreCase ( CharSequence a , CharSequence b ) { if ( a = = null | | b = = null ) { return a = = b ; } if ( a . getClass ( ) = = AsciiString . class ) { return ( ( AsciiString ) a ) . contentEqualsIgnoreCase ( b ) ; } if ( b . getClass ( ) = = AsciiString . class ) { return ( ( AsciiString ) b ) . contentEqualsIgnoreCase ( a ) ; } if ( a . length ( ) ! = b . length ( ) ) { return false ; } for ( int i = <int> , j = <int> ; i < a . length ( ) ; + + i , + + j ) { if ( ! equalsIgnoreCase ( a . charAt ( i ) , b . charAt ( j ) ) ) { return false ; } } return true ; } public static boolean containsContentEqualsIgnoreCase ( Collection < CharSequence > collection , CharSequence value ) { for ( CharSequence v : collection ) { if ( contentEqualsIgnoreCase ( value , v ) ) { return true ; } } return false ; } public static boolean containsAllContentEqualsIgnoreCase ( Collection < CharSequence > a , Collection < CharSequence > b ) { for ( CharSequence v : b ) { if ( ! containsContentEqualsIgnoreCase ( a , v ) ) { return false ; } } return true ; } public static boolean contentEquals ( CharSequence a , CharSequence b ) { if ( a = = null | | b = = null ) { return a = = b ; } if ( a . getClass ( ) = = AsciiString . class ) { return ( ( AsciiString ) a ) . contentEquals ( b ) ; } if ( b . getClass ( ) = = AsciiString . class ) { return ( ( AsciiString ) b ) . contentEquals ( a ) ; } if ( a . length ( ) ! = b . length ( ) ) { return false ; } for ( int i = <int> ; i < a . length ( ) ; + + i ) { if ( a . charAt ( i ) ! = b . charAt ( i ) ) { return false ; } } return true ; } private static AsciiString [ ] toAsciiStringArray ( String [ ] jdkResult ) { AsciiString [ ] res = new AsciiString [ jdkResult . length ] ; for ( int i = <int> ; i < jdkResult . length ; i + + ) { res [ i ] = new AsciiString ( jdkResult [ i ] ) ; } return res ; } private interface CharEqualityComparator { boolean equals ( char a , char b ) ; } private static final class DefaultCharEqualityComparator implements CharEqualityComparator { static final DefaultCharEqualityComparator INSTANCE = new DefaultCharEqualityComparator ( ) ; private DefaultCharEqualityComparator ( ) { } @Override public boolean equals ( char a , char b ) { return a = = b ; } } private static final class AsciiCaseInsensitiveCharEqualityComparator implements CharEqualityComparator { static final AsciiCaseInsensitiveCharEqualityComparator INSTANCE = new AsciiCaseInsensitiveCharEqualityComparator ( ) ; private AsciiCaseInsensitiveCharEqualityComparator ( ) { } @Override public boolean equals ( char a , char b ) { return equalsIgnoreCase ( a , b ) ; } } private static final class GeneralCaseInsensitiveCharEqualityComparator implements CharEqualityComparator { static final GeneralCaseInsensitiveCharEqualityComparator INSTANCE = new GeneralCaseInsensitiveCharEqualityComparator ( ) ; private GeneralCaseInsensitiveCharEqualityComparator ( ) { } @Override public boolean equals ( char a , char b ) { return Character . toUpperCase ( a ) = = Character . toUpperCase ( b ) | | Character . toLowerCase ( a ) = = Character . toLowerCase ( b ) ; } } private static boolean contains ( CharSequence a , CharSequence b , CharEqualityComparator cmp ) { if ( a = = null | | b = = null | | a . length ( ) < b . length ( ) ) { return false ; } if ( b . length ( ) = = <int> ) { return true ; } int bStart = <int> ; for ( int i = <int> ; i < a . length ( ) ; + + i ) { if ( cmp . equals ( b . charAt ( bStart ) , a . charAt ( i ) ) ) { if ( + + bStart = = b . length ( ) ) { return true ; } } else if ( a . length ( ) - i < b . length ( ) ) { return false ; } else { bStart = <int> ; } } return false ; } private static boolean regionMatchesCharSequences ( final CharSequence cs , final int csStart , final CharSequence string , final int start , final int length , CharEqualityComparator charEqualityComparator ) { if ( csStart < <int> | | length > cs . length ( ) - csStart ) { return false ; } if ( start < <int> | | length > string . length ( ) - start ) { return false ; } int csIndex = csStart ; int csEnd = csIndex + length ; int stringIndex = start ; while ( csIndex < csEnd ) { char c1 = cs . charAt ( csIndex + + ) ; char c2 = string . charAt ( stringIndex + + ) ; if ( ! charEqualityComparator . equals ( c1 , c2 ) ) { return false ; } } return true ; } public static boolean regionMatches ( final CharSequence cs , final boolean ignoreCase , final int csStart , final CharSequence string , final int start , final int length ) { if ( cs = = null | | string = = null ) { return false ; } if ( cs instanceof String & & string instanceof String ) { return ( ( String ) cs ) . regionMatches ( ignoreCase , csStart , ( String ) string , start , length ) ; } if ( cs instanceof AsciiString ) { return ( ( AsciiString ) cs ) . regionMatches ( ignoreCase , csStart , string , start , length ) ; } return regionMatchesCharSequences ( cs , csStart , string , start , length , ignoreCase ? GeneralCaseInsensitiveCharEqualityComparator . INSTANCE : DefaultCharEqualityComparator . INSTANCE ) ; } public static boolean regionMatchesAscii ( final CharSequence cs , final boolean ignoreCase , final int csStart , final CharSequence string , final int start , final int length ) { if ( cs = = null | | string = = null ) { return false ; } if ( ! ignoreCase & & cs instanceof String & & string instanceof String ) { return ( ( String ) cs ) . regionMatches ( false , csStart , ( String ) string , start , length ) ; } if ( cs instanceof AsciiString ) { return ( ( AsciiString ) cs ) . regionMatches ( ignoreCase , csStart , string , start , length ) ; } return regionMatchesCharSequences ( cs , csStart , string , start , length , ignoreCase ? AsciiCaseInsensitiveCharEqualityComparator . INSTANCE : DefaultCharEqualityComparator . INSTANCE ) ; } public static int indexOfIgnoreCase ( final CharSequence str , final CharSequence searchStr , int startPos ) { if ( str = = null | | searchStr = = null ) { return INDEX_NOT_FOUND ; } if ( startPos < <int> ) { startPos = <int> ; } int searchStrLen = searchStr . length ( ) ; final int endLimit = str . length ( ) - searchStrLen + <int> ; if ( startPos > endLimit ) { return INDEX_NOT_FOUND ; } if ( searchStrLen = = <int> ) { return startPos ; } for ( int i = startPos ; i < endLimit ; i + + ) { if ( regionMatches ( str , true , i , searchStr , <int> , searchStrLen ) ) { return i ; } } return INDEX_NOT_FOUND ; } public static int indexOfIgnoreCaseAscii ( final CharSequence str , final CharSequence searchStr , int startPos ) { if ( str = = null | | searchStr = = null ) { return INDEX_NOT_FOUND ; } if ( startPos < <int> ) { startPos = <int> ; } int searchStrLen = searchStr . length ( ) ; final int endLimit = str . length ( ) - searchStrLen + <int> ; if ( startPos > endLimit ) { return INDEX_NOT_FOUND ; } if ( searchStrLen = = <int> ) { return startPos ; } for ( int i = startPos ; i < endLimit ; i + + ) { if ( regionMatchesAscii ( str , true , i , searchStr , <int> , searchStrLen ) ) { return i ; } } return INDEX_NOT_FOUND ; } private static boolean equalsIgnoreCase ( byte a , byte b ) { return a = = b | | toLowerCase ( a ) = = toLowerCase ( b ) ; } private static boolean equalsIgnoreCase ( char a , char b ) { return a = = b | | toLowerCase ( a ) = = toLowerCase ( b ) ; } private static byte toLowerCase ( byte b ) { return isUpperCase ( b ) ? ( byte ) ( b + <int> ) : b ; } private static char toLowerCase ( char c ) { return isUpperCase ( c ) ? ( char ) ( c + <int> ) : c ; } private static byte toUpperCase ( byte b ) { return isLowerCase ( b ) ? ( byte ) ( b - <int> ) : b ; } private static boolean isLowerCase ( byte value ) { return value > = <str> & & value < = <str> ; } public static boolean isUpperCase ( byte value ) { return value > = <str> & & value < = <str> ; } public static boolean isUpperCase ( char value ) { return value > = <str> & & value < = <str> ; } public static byte c2b ( char c ) { return ( byte ) ( ( c > MAX_CHAR_VALUE ) ? <str> : c ) ; } public static char b2c ( byte b ) { return ( char ) ( b & <hex> ) ; } } 
