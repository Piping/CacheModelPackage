package org . elasticsearch . threadpool ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . EsThreadPoolExecutor ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool . Names ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . stream . Collectors ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . * ; public class UpdateThreadPoolSettingsTests extends ESTestCase { public void testCorrectThreadPoolTypePermittedInSettings ( ) throws InterruptedException { String threadPoolName = randomThreadPoolName ( ) ; ThreadPool . ThreadPoolType correctThreadPoolType = ThreadPool . THREAD_POOL_TYPES . get ( threadPoolName ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> + threadPoolName + <str> , correctThreadPoolType . getType ( ) ) . build ( ) ) ; ThreadPool . Info info = info ( threadPool , threadPoolName ) ; if ( ThreadPool . Names . SAME . equals ( threadPoolName ) ) { assertNull ( info ) ; } else { assertEquals ( info . getThreadPoolType ( ) , correctThreadPoolType ) ; } } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testThreadPoolCanNotOverrideThreadPoolType ( ) throws InterruptedException { String threadPoolName = randomThreadPoolName ( ) ; ThreadPool . ThreadPoolType incorrectThreadPoolType = randomIncorrectThreadPoolType ( threadPoolName ) ; ThreadPool . ThreadPoolType correctThreadPoolType = ThreadPool . THREAD_POOL_TYPES . get ( threadPoolName ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> + threadPoolName + <str> , incorrectThreadPoolType . getType ( ) ) . build ( ) ) ; terminate ( threadPool ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> + threadPoolName + <str> + incorrectThreadPoolType . getType ( ) + <str> + correctThreadPoolType . getType ( ) ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testUpdateSettingsCanNotChangeThreadPoolType ( ) throws InterruptedException { String threadPoolName = randomThreadPoolName ( ) ; ThreadPool . ThreadPoolType invalidThreadPoolType = randomIncorrectThreadPoolType ( threadPoolName ) ; ThreadPool . ThreadPoolType validThreadPoolType = ThreadPool . THREAD_POOL_TYPES . get ( threadPoolName ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , invalidThreadPoolType . getType ( ) ) . build ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> + threadPoolName + <str> + invalidThreadPoolType . getType ( ) + <str> + validThreadPoolType . getType ( ) ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testCachedExecutorType ( ) throws InterruptedException { String threadPoolName = randomThreadPool ( ThreadPool . ThreadPoolType . CACHED ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . CACHED ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . CACHED ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getCorePoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getKeepAliveTime ( TimeUnit . MINUTES ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; Executor oldExecutor = threadPool . executor ( threadPoolName ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getKeepAliveTime ( TimeUnit . MINUTES ) , equalTo ( <int> ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . CACHED ) ; assertThat ( threadPool . executor ( threadPoolName ) , sameInstance ( oldExecutor ) ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getKeepAliveTime ( TimeUnit . MINUTES ) , equalTo ( <int> ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . CACHED ) ; assertThat ( threadPool . executor ( threadPoolName ) , sameInstance ( oldExecutor ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testFixedExecutorType ( ) throws InterruptedException { String threadPoolName = randomThreadPool ( ThreadPool . ThreadPoolType . FIXED ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getCorePoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getMaximumPoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getKeepAliveTime ( TimeUnit . MINUTES ) , equalTo ( <int> L ) ) ; threadPool . updateSettings ( Settings . EMPTY ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) , nullValue ( ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getCorePoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getMaximumPoolSize ( ) , equalTo ( <int> ) ) ; Executor oldExecutor = threadPool . executor ( threadPoolName ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getMaximumPoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getCorePoolSize ( ) , equalTo ( <int> ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; assertThat ( threadPool . executor ( threadPoolName ) , sameInstance ( oldExecutor ) ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testScalingExecutorType ( ) throws InterruptedException { String threadPoolName = randomThreadPool ( ThreadPool . ThreadPoolType . SCALING ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <int> ) . put ( <str> , <str> ) . build ( ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . SCALING ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; Executor oldExecutor = threadPool . executor ( threadPoolName ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <str> ) . put ( <str> + threadPoolName + <str> , <str> ) . put ( <str> + threadPoolName + <str> , <str> ) . build ( ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . SCALING ) ; assertThat ( threadPool . executor ( threadPoolName ) , instanceOf ( EsThreadPoolExecutor . class ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getCorePoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getMaximumPoolSize ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( info ( threadPool , threadPoolName ) . getKeepAlive ( ) . minutes ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( EsThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ) . getKeepAliveTime ( TimeUnit . MINUTES ) , equalTo ( <int> ) ) ; assertThat ( threadPool . executor ( threadPoolName ) , sameInstance ( oldExecutor ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testShutdownNowInterrupts ( ) throws Exception { String threadPoolName = randomThreadPool ( ThreadPool . ThreadPoolType . FIXED ) ; ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( Settings . settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <int> ) . put ( <str> , <str> ) . build ( ) ) ; assertEquals ( info ( threadPool , threadPoolName ) . getQueueSize ( ) . getSingles ( ) , <int> ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; ThreadPoolExecutor oldExecutor = ( ThreadPoolExecutor ) threadPool . executor ( threadPoolName ) ; threadPool . executor ( threadPoolName ) . execute ( ( ) - > { try { new CountDownLatch ( <int> ) . await ( ) ; } catch ( InterruptedException ex ) { latch . countDown ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } ) ; threadPool . updateSettings ( settingsBuilder ( ) . put ( <str> + threadPoolName + <str> , <int> ) . build ( ) ) ; assertThat ( threadPool . executor ( threadPoolName ) , not ( sameInstance ( oldExecutor ) ) ) ; assertThat ( oldExecutor . isShutdown ( ) , equalTo ( true ) ) ; assertThat ( oldExecutor . isTerminating ( ) , equalTo ( true ) ) ; assertThat ( oldExecutor . isTerminated ( ) , equalTo ( false ) ) ; threadPool . shutdownNow ( ) ; latch . await ( <int> , TimeUnit . SECONDS ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } public void testCustomThreadPool ( ) throws Exception { ThreadPool threadPool = null ; try { threadPool = new ThreadPool ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . build ( ) ) ; ThreadPoolInfo groups = threadPool . info ( ) ; boolean foundPool1 = false ; boolean foundPool2 = false ; outer : for ( ThreadPool . Info info : groups ) { if ( <str> . equals ( info . getName ( ) ) ) { foundPool1 = true ; assertEquals ( info . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . SCALING ) ; } else if ( <str> . equals ( info . getName ( ) ) ) { foundPool2 = true ; assertEquals ( info . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; assertThat ( info . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( info . getQueueSize ( ) . singles ( ) , equalTo ( <int> ) ) ; } else { for ( Field field : Names . class . getFields ( ) ) { if ( info . getName ( ) . equalsIgnoreCase ( field . getName ( ) ) ) { continue outer ; } } fail ( <str> + info . getName ( ) ) ; } } assertThat ( foundPool1 , is ( true ) ) ; assertThat ( foundPool2 , is ( true ) ) ; Settings settings = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; threadPool . updateSettings ( settings ) ; groups = threadPool . info ( ) ; foundPool1 = false ; foundPool2 = false ; outer : for ( ThreadPool . Info info : groups ) { if ( <str> . equals ( info . getName ( ) ) ) { foundPool1 = true ; assertEquals ( info . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . SCALING ) ; } else if ( <str> . equals ( info . getName ( ) ) ) { foundPool2 = true ; assertThat ( info . getMax ( ) , equalTo ( <int> ) ) ; assertThat ( info . getMin ( ) , equalTo ( <int> ) ) ; assertThat ( info . getQueueSize ( ) . singles ( ) , equalTo ( <int> ) ) ; assertEquals ( info . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; } else { for ( Field field : Names . class . getFields ( ) ) { if ( info . getName ( ) . equalsIgnoreCase ( field . getName ( ) ) ) { continue outer ; } } fail ( <str> + info . getName ( ) ) ; } } assertThat ( foundPool1 , is ( true ) ) ; assertThat ( foundPool2 , is ( true ) ) ; } finally { terminateThreadPoolIfNeeded ( threadPool ) ; } } private void terminateThreadPoolIfNeeded ( ThreadPool threadPool ) throws InterruptedException { if ( threadPool ! = null ) { terminate ( threadPool ) ; } } private ThreadPool . Info info ( ThreadPool threadPool , String name ) { for ( ThreadPool . Info info : threadPool . info ( ) ) { if ( info . getName ( ) . equals ( name ) ) { return info ; } } return null ; } private String randomThreadPoolName ( ) { Set < String > threadPoolNames = ThreadPool . THREAD_POOL_TYPES . keySet ( ) ; return randomFrom ( threadPoolNames . toArray ( new String [ threadPoolNames . size ( ) ] ) ) ; } private ThreadPool . ThreadPoolType randomIncorrectThreadPoolType ( String threadPoolName ) { Set < ThreadPool . ThreadPoolType > set = new HashSet < > ( ) ; set . addAll ( Arrays . asList ( ThreadPool . ThreadPoolType . values ( ) ) ) ; set . remove ( ThreadPool . THREAD_POOL_TYPES . get ( threadPoolName ) ) ; ThreadPool . ThreadPoolType invalidThreadPoolType = randomFrom ( set . toArray ( new ThreadPool . ThreadPoolType [ set . size ( ) ] ) ) ; return invalidThreadPoolType ; } private String randomThreadPool ( ThreadPool . ThreadPoolType type ) { return randomFrom ( ThreadPool . THREAD_POOL_TYPES . entrySet ( ) . stream ( ) . filter ( t - > t . getValue ( ) . equals ( type ) ) . map ( t - > t . getKey ( ) ) . collect ( Collectors . toList ( ) ) ) ; } } 
