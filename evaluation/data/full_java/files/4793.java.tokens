package org . eclipse . ui . console ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . ui . WorkbenchEncoding ; import org . eclipse . ui . internal . console . IOConsolePage ; import org . eclipse . ui . internal . console . IOConsolePartitioner ; import org . eclipse . ui . part . IPageBookViewPage ; public class IOConsole extends TextConsole { private IOConsolePartitioner partitioner ; private InputStream inputStream ; private List < Closeable > openStreams = Collections . synchronizedList ( new ArrayList < Closeable > ( ) ) ; private String fEncoding = WorkbenchEncoding . getWorkbenchDefaultEncoding ( ) ; public IOConsole ( String name , String consoleType , ImageDescriptor imageDescriptor , boolean autoLifecycle ) { this ( name , consoleType , imageDescriptor , null , autoLifecycle ) ; } public IOConsole ( String name , String consoleType , ImageDescriptor imageDescriptor , String encoding , boolean autoLifecycle ) { super ( name , consoleType , imageDescriptor , autoLifecycle ) ; if ( encoding ! = null ) { fEncoding = encoding ; } synchronized ( openStreams ) { inputStream = new IOConsoleInputStream ( this ) ; openStreams . add ( inputStream ) ; } if ( inputStream instanceof IOConsoleInputStream ) { partitioner = new IOConsolePartitioner ( ( IOConsoleInputStream ) inputStream , this ) ; partitioner . connect ( getDocument ( ) ) ; } } public IOConsole ( String name , String consoleType , ImageDescriptor imageDescriptor ) { this ( name , consoleType , imageDescriptor , true ) ; } public IOConsole ( String name , ImageDescriptor imageDescriptor ) { this ( name , null , imageDescriptor ) ; } @Override public IPageBookViewPage createPage ( IConsoleView view ) { return new IOConsolePage ( this , view ) ; } public IOConsoleOutputStream newOutputStream ( ) { IOConsoleOutputStream outputStream = new IOConsoleOutputStream ( this ) ; outputStream . setEncoding ( fEncoding ) ; synchronized ( openStreams ) { openStreams . add ( outputStream ) ; } return outputStream ; } public IOConsoleInputStream getInputStream ( ) { if ( inputStream instanceof IOConsoleInputStream ) { return ( IOConsoleInputStream ) inputStream ; } return null ; } public void setInputStream ( InputStream inputStream ) { this . inputStream = inputStream ; } @Override protected IConsoleDocumentPartitioner getPartitioner ( ) { return partitioner ; } public int getHighWaterMark ( ) { return partitioner . getHighWaterMark ( ) ; } public int getLowWaterMark ( ) { return partitioner . getLowWaterMark ( ) ; } public void setWaterMarks ( int low , int high ) { if ( low > = <int> ) { if ( low > = high ) { throw new IllegalArgumentException ( <str> ) ; } } partitioner . setWaterMarks ( low , high ) ; } private void checkFinished ( ) { if ( openStreams . isEmpty ( ) ) { partitioner . streamsClosed ( ) ; } } void streamClosed ( IOConsoleOutputStream stream ) { synchronized ( openStreams ) { openStreams . remove ( stream ) ; checkFinished ( ) ; } } void streamClosed ( IOConsoleInputStream stream ) { synchronized ( openStreams ) { openStreams . remove ( stream ) ; checkFinished ( ) ; } } @Override public void clearConsole ( ) { if ( partitioner ! = null ) { partitioner . clearBuffer ( ) ; } } @Override protected void dispose ( ) { super . dispose ( ) ; partitioner . disconnect ( ) ; List < Closeable > list = new ArrayList < Closeable > ( openStreams ) ; for ( Closeable closable : list ) { try { closable . close ( ) ; } catch ( IOException e ) { } } inputStream = null ; } public String getEncoding ( ) { return fEncoding ; } } 
