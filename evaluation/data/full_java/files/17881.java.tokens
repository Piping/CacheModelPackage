package com . badlogic . gdx . tools . texturepacker ; import com . badlogic . gdx . tools . FileProcessor ; import com . badlogic . gdx . tools . texturepacker . TexturePacker . Settings ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonReader ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . ObjectSet ; import java . io . File ; import java . io . FileReader ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TexturePackerFileProcessor extends FileProcessor { private final Settings defaultSettings ; private ObjectMap < File , Settings > dirToSettings = new ObjectMap ( ) ; private Json json = new Json ( ) ; private String packFileName ; private File root ; ArrayList < File > ignoreDirs = new ArrayList ( ) ; public TexturePackerFileProcessor ( ) { this ( new Settings ( ) , <str> ) ; } public TexturePackerFileProcessor ( Settings defaultSettings , String packFileName ) { this . defaultSettings = defaultSettings ; if ( packFileName . toLowerCase ( ) . endsWith ( defaultSettings . atlasExtension . toLowerCase ( ) ) ) packFileName = packFileName . substring ( <int> , packFileName . length ( ) - defaultSettings . atlasExtension . length ( ) ) ; this . packFileName = packFileName ; setFlattenOutput ( true ) ; addInputSuffix ( <str> , <str> , <str> ) ; } public ArrayList < Entry > process ( File inputFile , File outputRoot ) throws Exception { root = inputFile ; final ArrayList < File > settingsFiles = new ArrayList ( ) ; FileProcessor settingsProcessor = new FileProcessor ( ) { protected void processFile ( Entry inputFile ) throws Exception { settingsFiles . add ( inputFile . inputFile ) ; } } ; settingsProcessor . addInputRegex ( <str> ) ; settingsProcessor . process ( inputFile , null ) ; Collections . sort ( settingsFiles , new Comparator < File > ( ) { public int compare ( File file1 , File file2 ) { return file1 . toString ( ) . length ( ) - file2 . toString ( ) . length ( ) ; } } ) ; for ( File settingsFile : settingsFiles ) { Settings settings = null ; File parent = settingsFile . getParentFile ( ) ; while ( true ) { if ( parent . equals ( root ) ) break ; parent = parent . getParentFile ( ) ; settings = dirToSettings . get ( parent ) ; if ( settings ! = null ) { settings = new Settings ( settings ) ; break ; } } if ( settings = = null ) settings = new Settings ( defaultSettings ) ; merge ( settings , settingsFile ) ; dirToSettings . put ( settingsFile . getParentFile ( ) , settings ) ; } return super . process ( inputFile , outputRoot ) ; } private void merge ( Settings settings , File settingsFile ) { try { json . readFields ( settings , new JsonReader ( ) . parse ( new FileReader ( settingsFile ) ) ) ; } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> + settingsFile , ex ) ; } } public ArrayList < Entry > process ( File [ ] files , File outputRoot ) throws Exception { if ( outputRoot . exists ( ) ) { File settingsFile = new File ( root , <str> ) ; Settings rootSettings = defaultSettings ; if ( settingsFile . exists ( ) ) { rootSettings = new Settings ( rootSettings ) ; merge ( rootSettings , settingsFile ) ; } for ( int i = <int> , n = rootSettings . scale . length ; i < n ; i + + ) { FileProcessor deleteProcessor = new FileProcessor ( ) { protected void processFile ( Entry inputFile ) throws Exception { inputFile . inputFile . delete ( ) ; } } ; deleteProcessor . setRecursive ( false ) ; String scaledPackFileName = rootSettings . getScaledPackFileName ( packFileName , i ) ; File packFile = new File ( scaledPackFileName ) ; String prefix = packFile . getName ( ) ; int dotIndex = prefix . lastIndexOf ( <str> ) ; if ( dotIndex ! = - <int> ) prefix = prefix . substring ( <int> , dotIndex ) ; deleteProcessor . addInputRegex ( <str> + prefix + <str> ) ; deleteProcessor . addInputRegex ( <str> + prefix + <str> ) ; String dir = packFile . getParent ( ) ; if ( dir = = null ) deleteProcessor . process ( outputRoot , null ) ; else if ( new File ( outputRoot + <str> + dir ) . exists ( ) ) deleteProcessor . process ( outputRoot + <str> + dir , null ) ; } } return super . process ( files , outputRoot ) ; } protected void processDir ( Entry inputDir , ArrayList < Entry > files ) throws Exception { if ( ignoreDirs . contains ( inputDir . inputFile ) ) return ; Settings settings = null ; File parent = inputDir . inputFile ; while ( true ) { settings = dirToSettings . get ( parent ) ; if ( settings ! = null ) break ; if ( parent . equals ( root ) ) break ; parent = parent . getParentFile ( ) ; } if ( settings = = null ) settings = defaultSettings ; if ( settings . combineSubdirectories ) { files = new FileProcessor ( this ) { protected void processDir ( Entry entryDir , ArrayList < Entry > files ) { ignoreDirs . add ( entryDir . inputFile ) ; } protected void processFile ( Entry entry ) { addProcessedFile ( entry ) ; } } . process ( inputDir . inputFile , null ) ; } if ( files . isEmpty ( ) ) return ; Collections . sort ( files , new Comparator < Entry > ( ) { final Pattern digitSuffix = Pattern . compile ( <str> ) ; public int compare ( Entry entry1 , Entry entry2 ) { String full1 = entry1 . inputFile . getName ( ) ; int dotIndex = full1 . lastIndexOf ( <str> ) ; if ( dotIndex ! = - <int> ) full1 = full1 . substring ( <int> , dotIndex ) ; String full2 = entry2 . inputFile . getName ( ) ; dotIndex = full2 . lastIndexOf ( <str> ) ; if ( dotIndex ! = - <int> ) full2 = full2 . substring ( <int> , dotIndex ) ; String name1 = full1 , name2 = full2 ; int num1 = <int> , num2 = <int> ; Matcher matcher = digitSuffix . matcher ( full1 ) ; if ( matcher . matches ( ) ) { try { num1 = Integer . parseInt ( matcher . group ( <int> ) ) ; name1 = matcher . group ( <int> ) ; } catch ( Exception ignored ) { } } matcher = digitSuffix . matcher ( full2 ) ; if ( matcher . matches ( ) ) { try { num2 = Integer . parseInt ( matcher . group ( <int> ) ) ; name2 = matcher . group ( <int> ) ; } catch ( Exception ignored ) { } } int compare = name1 . compareTo ( name2 ) ; if ( compare ! = <int> | | num1 = = num2 ) return compare ; return num1 - num2 ; } } ) ; if ( ! settings . silent ) System . out . println ( inputDir . inputFile . getName ( ) ) ; TexturePacker packer = new TexturePacker ( root , settings ) ; for ( Entry file : files ) packer . addImage ( file . inputFile ) ; packer . pack ( inputDir . outputDir , packFileName ) ; } } 
