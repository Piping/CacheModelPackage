package org . nd4j . linalg ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . buffer . DataBuffer . Type ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . util . ComplexUtil ; import org . nd4j . linalg . api . shape . Shape ; import static org . junit . Assert . * ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class ComplexNDArrayTestsFortran extends BaseComplexNDArrayTests { public ComplexNDArrayTestsFortran ( ) { } public ComplexNDArrayTestsFortran ( String name ) { super ( name ) ; } public ComplexNDArrayTestsFortran ( Nd4jBackend backend ) { super ( backend ) ; } public ComplexNDArrayTestsFortran ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Before public void before ( ) { super . before ( ) ; } @After public void after ( ) { super . after ( ) ; } @Test public void testLeadingOnes ( ) { IComplexNDArray complexRand = Nd4j . complexRand ( <int> , <int> , <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , complexRand . shape ( ) ) ; IComplexNDArray arr = complexRand . linearView ( ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) { arr . putScalar ( i , arr . getComplex ( i ) ) ; } IComplexNDArray complexRand2 = Nd4j . complexRand ( <int> , <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> } , complexRand2 . shape ( ) ) ; IComplexNDArray arr2 = complexRand . linearView ( ) ; for ( int i = <int> ; i < arr2 . length ( ) ; i + + ) { arr2 . putScalar ( i , arr2 . getComplex ( i ) ) ; } } @Test public void testDimShuffle ( ) { IComplexNDArray n = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray twoOneTwo = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , twoOneTwo . shape ( ) ) ) ; IComplexNDArray reverse = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , reverse . shape ( ) ) ) ; } @Test public void testPutComplex ( ) { INDArray fourTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray test = Nd4j . createComplex ( <int> , <int> , <int> ) ; for ( int i = <int> ; i < test . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vector = fourTwoTwo . vectorAlongDimension ( i , <int> ) ; IComplexNDArray complexVector = test . vectorAlongDimension ( i , <int> ) ; for ( int j = <int> ; j < complexVector . length ( ) ; j + + ) { complexVector . putReal ( j , vector . getFloat ( j ) ) ; } } for ( int i = <int> ; i < test . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vector = fourTwoTwo . vectorAlongDimension ( i , <int> ) ; IComplexNDArray complexVector = test . vectorAlongDimension ( i , <int> ) ; assertEquals ( vector , complexVector . real ( ) ) ; } } @Test public void testColumnWithReshape ( ) { IComplexNDArray ones = Nd4j . complexOnes ( <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray column = Nd4j . createComplex ( new float [ ] { <int> , <int> , <int> , <int> } ) ; ones . putColumn ( <int> , column ) ; assertEquals ( column , ones . getColumn ( <int> ) ) ; } @Test public void testAssignOffset ( ) { IComplexNDArray arr = Nd4j . complexOnes ( <int> , <int> ) ; IComplexNDArray row = arr . slice ( <int> ) ; row . assign ( <int> ) ; assertEquals ( Nd4j . complexOnes ( <int> ) , row ) ; IComplexNDArray row2 = arr . slice ( <int> ) ; row2 . assign ( Nd4j . complexValueOf ( <int> , <int> ) ) ; assertEquals ( Nd4j . complexValueOf ( <int> , <int> ) , row2 ) ; } @Test public void testSum ( ) { IComplexNDArray n = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , n . sumComplex ( ) ) ; } @Test public void testCreateComplexFromReal ( ) { INDArray n = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray nComplex = Nd4j . createComplex ( n ) ; for ( int i = <int> ; i < n . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vec = n . vectorAlongDimension ( i , <int> ) ; IComplexNDArray vecComplex = nComplex . vectorAlongDimension ( i , <int> ) ; assertEquals ( vec . length ( ) , vecComplex . length ( ) ) ; for ( int j = <int> ; j < vec . length ( ) ; j + + ) { IComplexNumber currComplex = vecComplex . getComplex ( j ) ; double curr = vec . getFloat ( j ) ; assertEquals ( curr , currComplex . realComponent ( ) . doubleValue ( ) , <float> ) ; } assertEquals ( vec , vecComplex . getReal ( ) ) ; } } @Test public void testVectorOffsetRavel ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; for ( int i = <int> ; i < arr . slices ( ) ; i + + ) { assertEquals ( arr . slice ( i ) , arr . slice ( i ) . ravel ( ) ) ; } } @Test public void testVectorGet ( ) { IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) { IComplexNumber curr = arr . getComplex ( i ) ; assertEquals ( Nd4j . createDouble ( i + <int> , <int> ) , curr ) ; } IComplexNDArray matrix = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray row = matrix . getRow ( <int> ) ; IComplexNDArray column = matrix . getColumn ( <int> ) ; IComplexNDArray validate = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNumber d = row . getComplex ( <int> ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , d ) ; assertEquals ( row , validate ) ; IComplexNumber d2 = column . getComplex ( <int> ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , d2 ) ; } @Test public void testCreateFromNDArray ( ) { Nd4j . dtype = Type . DOUBLE ; INDArray fortran = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; IComplexNDArray fortranComplex = Nd4j . createComplex ( fortran ) ; for ( int i = <int> ; i < fortran . rows ( ) ; i + + ) { for ( int j = <int> ; j < fortran . columns ( ) ; j + + ) { double d = fortran . getFloat ( i , j ) ; IComplexNumber complexD = fortranComplex . getComplex ( i , j ) ; assertEquals ( Nd4j . createDouble ( d , <int> ) , complexD ) ; } } } @Test public void testSwapAxesFortranOrder ( ) { IComplexNDArray n = Nd4j . createComplex ( Nd4j . linspace ( <int> , <int> , <int> ) ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray slice = n . swapAxes ( <int> , <int> ) ; IComplexNDArray assertion = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; IComplexNDArray test = slice . slice ( <int> ) . slice ( <int> ) ; assertEquals ( assertion , test ) ; } @Test public void testSliceOffset ( ) { Nd4j . EPS_THRESHOLD = <float> ; IComplexNDArray test = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray testSlice0 = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , } ) ; IComplexNDArray testSlice1 = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , } ) ; assertEquals ( getFailureMessage ( ) , testSlice0 , test . slice ( <int> ) ) ; assertEquals ( getFailureMessage ( ) , testSlice1 , test . slice ( <int> ) ) ; IComplexNDArray sliceOfSlice0 = test . slice ( <int> ) . slice ( <int> ) ; assertEquals ( sliceOfSlice0 . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( getFailureMessage ( ) , test . slice ( <int> ) . slice ( <int> ) . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( getFailureMessage ( ) , test . slice ( <int> ) . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; } @Test public void testSliceMatrix ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; assertEquals ( Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } ) , arr . slice ( <int> ) ) ; assertEquals ( Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } ) , arr . slice ( <int> ) ) ; } @Test public void testSliceConstructor ( ) { List < IComplexNDArray > testList = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) testList . add ( Nd4j . complexScalar ( i + <int> ) ) ; IComplexNDArray test = Nd4j . createComplex ( testList , new int [ ] { testList . size ( ) } ) ; IComplexNDArray expected = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; assertEquals ( expected , test ) ; } @Test public void testVectorInit ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; IComplexNDArray arr = Nd4j . createComplex ( data , new int [ ] { <int> } ) ; assertEquals ( true , arr . isRowVector ( ) ) ; IComplexNDArray arr2 = Nd4j . createComplex ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , arr2 . isRowVector ( ) ) ; IComplexNDArray columnVector = Nd4j . createComplex ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , columnVector . isColumnVector ( ) ) ; } @Test public void testRealConversion ( ) { IComplexNDArray arr = Nd4j . createComplex ( <int> , <int> ) ; INDArray arr1 = Nd4j . create ( <int> , <int> ) ; assertEquals ( arr , Nd4j . createComplex ( arr1 ) ) ; IComplexNDArray arr3 = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; assertEquals ( getFailureMessage ( ) , arr3 , Nd4j . createComplex ( linspace ) ) ; } @Test public void testTranspose ( ) { IComplexNDArray ndArray = Nd4j . createComplex ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray transposed2 = ndArray . transpose ( ) ; assertEquals ( getFailureMessage ( ) , <int> , transposed2 . columns ( ) ) ; } @Test public void testConjugate ( ) { IComplexNDArray negative = Nd4j . createComplex ( new double [ ] { <int> , - <int> , <int> , - <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray positive = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , negative , positive . conj ( ) ) ; } @Test public void testMultiDimensionalCreation ( ) { INDArray fourTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray multiRow = Nd4j . createComplex ( fourTwoTwo ) ; assertEquals ( fourTwoTwo , multiRow . getReal ( ) ) ; } @Test public void testMmul ( ) { IComplexNDArray n = Nd4j . createComplex ( Nd4j . linspace ( <int> , <int> , <int> ) ) ; IComplexNDArray transposed = n . transpose ( ) ; assertEquals ( true , n . isRowVector ( ) ) ; assertEquals ( true , transposed . isColumnVector ( ) ) ; INDArray innerProduct = n . mmul ( transposed ) ; INDArray scalar = Nd4j . scalar ( Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( getFailureMessage ( ) , scalar , innerProduct ) ; INDArray outerProduct = transposed . mmul ( n ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , outerProduct . shape ( ) ) ) ; IComplexNDArray d3 = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) ) . reshape ( <int> , <int> ) ; IComplexNDArray d4 = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) ) ; INDArray resultNDArray = d3 . mmul ( d4 ) ; INDArray result = Nd4j . createComplex ( new IComplexNumber [ ] [ ] { { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } , { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } } ) ; assertEquals ( getFailureMessage ( ) , result , resultNDArray ) ; } @Test public void testMmulOffset ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray row1 = arr . getRow ( <int> ) ; IComplexNDArray arrT = row1 . transpose ( ) ; assertEquals ( row1 , arrT ) ; } @Test public void testMmulColumnVector ( ) { IComplexNDArray three = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) , new int [ ] { <int> , <int> } ) ; IComplexNDArray test = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray sliceRow = test . slice ( <int> ) . getRow ( <int> ) ; assertEquals ( three , sliceRow ) ; IComplexNDArray twoSix = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) , new int [ ] { <int> , <int> } ) ; IComplexNDArray threeTwoSix = three . mmul ( twoSix ) ; IComplexNDArray sliceRowTwoSix = sliceRow . mmul ( twoSix ) ; assertEquals ( getFailureMessage ( ) , threeTwoSix , sliceRowTwoSix ) ; } @Test public void testPermute ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray permute = arr . permute ( <int> , <int> , <int> ) ; IComplexNDArray assertion = Nd4j . createComplex ( <int> , <int> , <int> ) ; IComplexNDArray assertionSlice1 = Nd4j . createComplex ( Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ) ; IComplexNDArray assertionSlice2 = Nd4j . createComplex ( Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ) ; assertion . putSlice ( <int> , assertionSlice1 ) ; assertion . putSlice ( <int> , assertionSlice2 ) ; assertEquals ( assertion , permute ) ; } @Test public void testPutAndGet ( ) { IComplexNDArray multiRow = Nd4j . createComplex ( <int> , <int> ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , arr . length ( ) ) ; assertEquals ( <int> , arr . data ( ) . length ( ) ) ; arr . put ( <int> , <int> , Nd4j . scalar ( <float> ) ) ; IComplexNumber n1 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n2 = arr . getComplex ( <int> , <int> ) ; assertEquals ( getFailureMessage ( ) , <float> , n1 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( getFailureMessage ( ) , <float> , n2 . imaginaryComponent ( ) . doubleValue ( ) , <float> ) ; } @Test public void testGetReal ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; int [ ] shape = new int [ ] { <int> , <int> } ; IComplexNDArray arr = Nd4j . createComplex ( shape ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) arr . put ( i , Nd4j . scalar ( data . getFloat ( i ) ) ) ; INDArray arr2 = Nd4j . create ( data , shape ) ; assertEquals ( arr2 , arr . getReal ( ) ) ; INDArray ones = Nd4j . ones ( <int> ) ; IComplexNDArray n2 = Nd4j . complexOnes ( <int> ) ; assertEquals ( getFailureMessage ( ) , ones , n2 . getReal ( ) ) ; } @Test public void testBroadcast ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; IComplexNDArray arrs = arr . broadcast ( new int [ ] { <int> , <int> } ) ; IComplexNDArray arrs3 = Nd4j . createComplex ( <int> , <int> ) ; assertTrue ( Arrays . equals ( arrs . shape ( ) , arrs3 . shape ( ) ) ) ; for ( int i = <int> ; i < arrs . slices ( ) ; i + + ) arrs3 . putSlice ( i , arr ) ; assertEquals ( arrs3 , arrs ) ; } @Test public void testBasicOperations ( ) { IComplexNDArray arr = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNumber scalar = arr . sumComplex ( ) ; double sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; arr . addi ( <int> ) ; scalar = arr . sumComplex ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; arr . subi ( Nd4j . createDouble ( <int> , <int> ) ) ; scalar = arr . sumComplex ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testComplexCalculation ( ) { IComplexNDArray arr = Nd4j . createComplex ( new IComplexNumber [ ] [ ] { { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } , { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } } ) ; IComplexNumber scalar = arr . sumComplex ( ) ; double sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; double sumImag = scalar . imaginaryComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sumImag , <float> ) ; IComplexNDArray res = arr . add ( Nd4j . createComplexNumber ( <int> , <int> ) ) ; scalar = res . sumComplex ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; sumImag = scalar . imaginaryComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sumImag , <float> ) ; sum = arr . sumComplex ( ) . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testElementWiseOps ( ) { IComplexNDArray n1 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray n2 = Nd4j . complexScalar ( <int> ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , n1 . add ( n2 ) ) ; assertFalse ( n1 . add ( n2 ) . equals ( n1 ) ) ; IComplexNDArray n3 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray n4 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray subbed = n4 . sub ( n3 ) ; IComplexNDArray mulled = n4 . mul ( n3 ) ; IComplexNDArray div = n4 . div ( n3 ) ; assertFalse ( subbed . equals ( n4 ) ) ; assertFalse ( mulled . equals ( n4 ) ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , subbed ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , mulled ) ; assertEquals ( Nd4j . complexScalar ( <float> ) , div ) ; IComplexNDArray multiDimensionElementWise = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; IComplexNumber sum2 = multiDimensionElementWise . sumComplex ( ) ; assertEquals ( sum2 , Nd4j . createDouble ( <int> , <int> ) ) ; IComplexNDArray added = multiDimensionElementWise . add ( Nd4j . complexScalar ( <int> ) ) ; IComplexDouble sum3 = ( IComplexDouble ) added . sumComplex ( ) ; assertEquals ( sum3 , Nd4j . createDouble ( <int> , <int> ) ) ; } @Test public void testMatrixGet ( ) { IComplexNDArray arr = Nd4j . createComplex ( ( Nd4j . linspace ( <int> , <int> , <int> ) ) ) . reshape ( <int> , <int> ) ; IComplexNumber n1 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n2 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n3 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n4 = arr . getComplex ( <int> , <int> ) ; assertEquals ( <int> , n1 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n2 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n3 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n4 . realComponent ( ) . doubleValue ( ) , <float> ) ; } @Test public void testTwoByTwoMmul ( ) { IComplexNDArray oneThroughFour = Nd4j . createComplex ( Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ) ; IComplexNDArray fiveThroughEight = Nd4j . createComplex ( Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ) ; IComplexNDArray solution = Nd4j . createComplex ( Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ) ; IComplexNDArray test = oneThroughFour . mmul ( fiveThroughEight ) ; assertEquals ( getFailureMessage ( ) , solution , test ) ; } @Override public char ordering ( ) { return <str> ; } } 
