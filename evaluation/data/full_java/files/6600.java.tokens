package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class DisMaxQueryParser implements QueryParser < DisMaxQueryBuilder > { public static final ParseField TIE_BREAKER_FIELD = new ParseField ( <str> ) ; public static final ParseField QUERIES_FIELD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { DisMaxQueryBuilder . NAME , Strings . toCamelCase ( DisMaxQueryBuilder . NAME ) } ; } @Override public DisMaxQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; float tieBreaker = DisMaxQueryBuilder . DEFAULT_TIE_BREAKER ; final List < QueryBuilder > queries = new ArrayList < > ( ) ; boolean queriesFound = false ; String queryName = null ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , QUERIES_FIELD ) ) { queriesFound = true ; QueryBuilder query = parseContext . parseInnerQueryBuilder ( ) ; queries . add ( query ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , QUERIES_FIELD ) ) { queriesFound = true ; while ( token ! = XContentParser . Token . END_ARRAY ) { QueryBuilder query = parseContext . parseInnerQueryBuilder ( ) ; queries . add ( query ) ; token = parser . nextToken ( ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . BOOST_FIELD ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , TIE_BREAKER_FIELD ) ) { tieBreaker = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . NAME_FIELD ) ) { queryName = parser . text ( ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } } if ( ! queriesFound ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } DisMaxQueryBuilder disMaxQuery = new DisMaxQueryBuilder ( ) ; disMaxQuery . tieBreaker ( tieBreaker ) ; disMaxQuery . queryName ( queryName ) ; disMaxQuery . boost ( boost ) ; for ( QueryBuilder query : queries ) { disMaxQuery . add ( query ) ; } return disMaxQuery ; } @Override public DisMaxQueryBuilder getBuilderPrototype ( ) { return DisMaxQueryBuilder . PROTOTYPE ; } } 
