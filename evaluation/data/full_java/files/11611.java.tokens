package org . gradle . api . internal . plugins ; import com . google . common . base . Predicate ; import com . google . common . collect . Iterables ; import org . gradle . api . Action ; import org . gradle . api . Plugin ; import org . gradle . api . plugins . PluginCollection ; import org . gradle . api . plugins . PluginContainer ; import org . gradle . api . plugins . UnknownPluginException ; import org . gradle . api . specs . Spec ; import org . gradle . plugin . internal . PluginId ; public class DefaultPluginContainer extends DefaultPluginCollection < Plugin > implements PluginContainer { private final PluginRegistry pluginRegistry ; private final PluginManagerInternal pluginManager ; public DefaultPluginContainer ( PluginRegistry pluginRegistry , final PluginManagerInternal pluginManager ) { super ( Plugin . class ) ; this . pluginRegistry = pluginRegistry ; this . pluginManager = pluginManager ; whenObjectAdded ( new Action < Plugin > ( ) { public void execute ( Plugin plugin ) { pluginManager . addImperativePlugin ( plugin . getClass ( ) ) ; } } ) ; } public Plugin apply ( String id ) { PluginImplementation plugin = pluginRegistry . lookup ( PluginId . unvalidated ( id ) ) ; if ( plugin = = null ) { throw new UnknownPluginException ( <str> + id + <str> ) ; } if ( ! Plugin . class . isAssignableFrom ( plugin . asClass ( ) ) ) { throw new IllegalArgumentException ( <str> + plugin . asClass ( ) . getName ( ) + <str> ) ; } else { return pluginManager . addImperativePlugin ( plugin ) ; } } public < P extends Plugin > P apply ( Class < P > type ) { return pluginManager . addImperativePlugin ( type ) ; } public boolean hasPlugin ( String id ) { return findPlugin ( id ) ! = null ; } public boolean hasPlugin ( Class < ? extends Plugin > type ) { return findPlugin ( type ) ! = null ; } private Plugin doFindPlugin ( String id ) { for ( final PluginManagerInternal . PluginWithId pluginWithId : pluginManager . pluginsForId ( id ) ) { Plugin plugin = Iterables . tryFind ( DefaultPluginContainer . this , new Predicate < Plugin > ( ) { public boolean apply ( Plugin plugin ) { return pluginWithId . clazz . equals ( plugin . getClass ( ) ) ; } } ) . orNull ( ) ; if ( plugin ! = null ) { return plugin ; } } return null ; } public Plugin findPlugin ( String id ) { return doFindPlugin ( id ) ; } public < P extends Plugin > P findPlugin ( Class < P > type ) { for ( Plugin plugin : this ) { if ( plugin . getClass ( ) . equals ( type ) ) { return type . cast ( plugin ) ; } } return null ; } public Plugin getPlugin ( String id ) { Plugin plugin = findPlugin ( id ) ; if ( plugin = = null ) { throw new UnknownPluginException ( <str> + id + <str> ) ; } return plugin ; } public Plugin getAt ( String id ) throws UnknownPluginException { return getPlugin ( id ) ; } public < P extends Plugin > P getAt ( Class < P > type ) throws UnknownPluginException { return getPlugin ( type ) ; } public < P extends Plugin > P getPlugin ( Class < P > type ) throws UnknownPluginException { P plugin = findPlugin ( type ) ; if ( plugin = = null ) { throw new UnknownPluginException ( <str> + type + <str> ) ; } return type . cast ( plugin ) ; } public void withId ( final String pluginId , final Action < ? super Plugin > action ) { Action < DefaultPluginManager . PluginWithId > wrappedAction = new Action < DefaultPluginManager . PluginWithId > ( ) { public void execute ( final DefaultPluginManager . PluginWithId pluginWithId ) { matching ( new Spec < Plugin > ( ) { public boolean isSatisfiedBy ( Plugin element ) { return pluginWithId . clazz . equals ( element . getClass ( ) ) ; } } ) . all ( action ) ; } } ; pluginManager . pluginsForId ( pluginId ) . all ( wrappedAction ) ; } @Override public < S extends Plugin > PluginCollection < S > withType ( Class < S > type ) { if ( ! Plugin . class . isAssignableFrom ( type ) ) { throw new IllegalArgumentException ( String . format ( <str> , type . getName ( ) ) ) ; } return super . withType ( type ) ; } } 
