package com . badlogic . gdx . graphics . g2d ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Writer ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . collision . BoundingBox ; public class ParticleEmitter { static private final int UPDATE_SCALE = <int> < < <int> ; static private final int UPDATE_ANGLE = <int> < < <int> ; static private final int UPDATE_ROTATION = <int> < < <int> ; static private final int UPDATE_VELOCITY = <int> < < <int> ; static private final int UPDATE_WIND = <int> < < <int> ; static private final int UPDATE_GRAVITY = <int> < < <int> ; static private final int UPDATE_TINT = <int> < < <int> ; private RangedNumericValue delayValue = new RangedNumericValue ( ) ; private ScaledNumericValue lifeOffsetValue = new ScaledNumericValue ( ) ; private RangedNumericValue durationValue = new RangedNumericValue ( ) ; private ScaledNumericValue lifeValue = new ScaledNumericValue ( ) ; private ScaledNumericValue emissionValue = new ScaledNumericValue ( ) ; private ScaledNumericValue scaleValue = new ScaledNumericValue ( ) ; private ScaledNumericValue rotationValue = new ScaledNumericValue ( ) ; private ScaledNumericValue velocityValue = new ScaledNumericValue ( ) ; private ScaledNumericValue angleValue = new ScaledNumericValue ( ) ; private ScaledNumericValue windValue = new ScaledNumericValue ( ) ; private ScaledNumericValue gravityValue = new ScaledNumericValue ( ) ; private ScaledNumericValue transparencyValue = new ScaledNumericValue ( ) ; private GradientColorValue tintValue = new GradientColorValue ( ) ; private RangedNumericValue xOffsetValue = new ScaledNumericValue ( ) ; private RangedNumericValue yOffsetValue = new ScaledNumericValue ( ) ; private ScaledNumericValue spawnWidthValue = new ScaledNumericValue ( ) ; private ScaledNumericValue spawnHeightValue = new ScaledNumericValue ( ) ; private SpawnShapeValue spawnShapeValue = new SpawnShapeValue ( ) ; private float accumulator ; private Sprite sprite ; private Particle [ ] particles ; private int minParticleCount , maxParticleCount = <int> ; private float x , y ; private String name ; private String imagePath ; private int activeCount ; private boolean [ ] active ; private boolean firstUpdate ; private boolean flipX , flipY ; private int updateFlags ; private boolean allowCompletion ; private BoundingBox bounds ; private int emission , emissionDiff , emissionDelta ; private int lifeOffset , lifeOffsetDiff ; private int life , lifeDiff ; private float spawnWidth , spawnWidthDiff ; private float spawnHeight , spawnHeightDiff ; public float duration = <int> , durationTimer ; private float delay , delayTimer ; private boolean attached ; private boolean continuous ; private boolean aligned ; private boolean behind ; private boolean additive = true ; private boolean premultipliedAlpha = false ; boolean cleansUpBlendFunction = true ; public ParticleEmitter ( ) { initialize ( ) ; } public ParticleEmitter ( BufferedReader reader ) throws IOException { initialize ( ) ; load ( reader ) ; } public ParticleEmitter ( ParticleEmitter emitter ) { sprite = emitter . sprite ; name = emitter . name ; imagePath = emitter . imagePath ; setMaxParticleCount ( emitter . maxParticleCount ) ; minParticleCount = emitter . minParticleCount ; delayValue . load ( emitter . delayValue ) ; durationValue . load ( emitter . durationValue ) ; emissionValue . load ( emitter . emissionValue ) ; lifeValue . load ( emitter . lifeValue ) ; lifeOffsetValue . load ( emitter . lifeOffsetValue ) ; scaleValue . load ( emitter . scaleValue ) ; rotationValue . load ( emitter . rotationValue ) ; velocityValue . load ( emitter . velocityValue ) ; angleValue . load ( emitter . angleValue ) ; windValue . load ( emitter . windValue ) ; gravityValue . load ( emitter . gravityValue ) ; transparencyValue . load ( emitter . transparencyValue ) ; tintValue . load ( emitter . tintValue ) ; xOffsetValue . load ( emitter . xOffsetValue ) ; yOffsetValue . load ( emitter . yOffsetValue ) ; spawnWidthValue . load ( emitter . spawnWidthValue ) ; spawnHeightValue . load ( emitter . spawnHeightValue ) ; spawnShapeValue . load ( emitter . spawnShapeValue ) ; attached = emitter . attached ; continuous = emitter . continuous ; aligned = emitter . aligned ; behind = emitter . behind ; additive = emitter . additive ; premultipliedAlpha = emitter . premultipliedAlpha ; cleansUpBlendFunction = emitter . cleansUpBlendFunction ; } private void initialize ( ) { durationValue . setAlwaysActive ( true ) ; emissionValue . setAlwaysActive ( true ) ; lifeValue . setAlwaysActive ( true ) ; scaleValue . setAlwaysActive ( true ) ; transparencyValue . setAlwaysActive ( true ) ; spawnShapeValue . setAlwaysActive ( true ) ; spawnWidthValue . setAlwaysActive ( true ) ; spawnHeightValue . setAlwaysActive ( true ) ; } public void setMaxParticleCount ( int maxParticleCount ) { this . maxParticleCount = maxParticleCount ; active = new boolean [ maxParticleCount ] ; activeCount = <int> ; particles = new Particle [ maxParticleCount ] ; } public void addParticle ( ) { int activeCount = this . activeCount ; if ( activeCount = = maxParticleCount ) return ; boolean [ ] active = this . active ; for ( int i = <int> , n = active . length ; i < n ; i + + ) { if ( ! active [ i ] ) { activateParticle ( i ) ; active [ i ] = true ; this . activeCount = activeCount + <int> ; break ; } } } public void addParticles ( int count ) { count = Math . min ( count , maxParticleCount - activeCount ) ; if ( count = = <int> ) return ; boolean [ ] active = this . active ; int index = <int> , n = active . length ; outer : for ( int i = <int> ; i < count ; i + + ) { for ( ; index < n ; index + + ) { if ( ! active [ index ] ) { activateParticle ( index ) ; active [ index + + ] = true ; continue outer ; } } break ; } this . activeCount + = count ; } public void update ( float delta ) { accumulator + = delta * <int> ; if ( accumulator < <int> ) return ; int deltaMillis = ( int ) accumulator ; accumulator - = deltaMillis ; if ( delayTimer < delay ) { delayTimer + = deltaMillis ; } else { boolean done = false ; if ( firstUpdate ) { firstUpdate = false ; addParticle ( ) ; } if ( durationTimer < duration ) durationTimer + = deltaMillis ; else { if ( ! continuous | | allowCompletion ) done = true ; else restart ( ) ; } if ( ! done ) { emissionDelta + = deltaMillis ; float emissionTime = emission + emissionDiff * emissionValue . getScale ( durationTimer / ( float ) duration ) ; if ( emissionTime > <int> ) { emissionTime = <int> / emissionTime ; if ( emissionDelta > = emissionTime ) { int emitCount = ( int ) ( emissionDelta / emissionTime ) ; emitCount = Math . min ( emitCount , maxParticleCount - activeCount ) ; emissionDelta - = emitCount * emissionTime ; emissionDelta % = emissionTime ; addParticles ( emitCount ) ; } } if ( activeCount < minParticleCount ) addParticles ( minParticleCount - activeCount ) ; } } boolean [ ] active = this . active ; int activeCount = this . activeCount ; Particle [ ] particles = this . particles ; for ( int i = <int> , n = active . length ; i < n ; i + + ) { if ( active [ i ] & & ! updateParticle ( particles [ i ] , delta , deltaMillis ) ) { active [ i ] = false ; activeCount - - ; } } this . activeCount = activeCount ; } public void draw ( Batch batch ) { if ( premultipliedAlpha ) { batch . setBlendFunction ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; } else if ( additive ) { batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE ) ; } else { batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; } Particle [ ] particles = this . particles ; boolean [ ] active = this . active ; for ( int i = <int> , n = active . length ; i < n ; i + + ) { if ( active [ i ] ) particles [ i ] . draw ( batch ) ; } if ( cleansUpBlendFunction & & ( additive | | premultipliedAlpha ) ) batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; } public void draw ( Batch batch , float delta ) { accumulator + = delta * <int> ; if ( accumulator < <int> ) { draw ( batch ) ; return ; } int deltaMillis = ( int ) accumulator ; accumulator - = deltaMillis ; if ( premultipliedAlpha ) { batch . setBlendFunction ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; } else if ( additive ) { batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE ) ; } else { batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; } Particle [ ] particles = this . particles ; boolean [ ] active = this . active ; int activeCount = this . activeCount ; for ( int i = <int> , n = active . length ; i < n ; i + + ) { if ( active [ i ] ) { Particle particle = particles [ i ] ; if ( updateParticle ( particle , delta , deltaMillis ) ) particle . draw ( batch ) ; else { active [ i ] = false ; activeCount - - ; } } } this . activeCount = activeCount ; if ( cleansUpBlendFunction & & ( additive | | premultipliedAlpha ) ) batch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; if ( delayTimer < delay ) { delayTimer + = deltaMillis ; return ; } if ( firstUpdate ) { firstUpdate = false ; addParticle ( ) ; } if ( durationTimer < duration ) durationTimer + = deltaMillis ; else { if ( ! continuous | | allowCompletion ) return ; restart ( ) ; } emissionDelta + = deltaMillis ; float emissionTime = emission + emissionDiff * emissionValue . getScale ( durationTimer / ( float ) duration ) ; if ( emissionTime > <int> ) { emissionTime = <int> / emissionTime ; if ( emissionDelta > = emissionTime ) { int emitCount = ( int ) ( emissionDelta / emissionTime ) ; emitCount = Math . min ( emitCount , maxParticleCount - activeCount ) ; emissionDelta - = emitCount * emissionTime ; emissionDelta % = emissionTime ; addParticles ( emitCount ) ; } } if ( activeCount < minParticleCount ) addParticles ( minParticleCount - activeCount ) ; } public void start ( ) { firstUpdate = true ; allowCompletion = false ; restart ( ) ; } public void reset ( ) { emissionDelta = <int> ; durationTimer = duration ; boolean [ ] active = this . active ; for ( int i = <int> , n = active . length ; i < n ; i + + ) active [ i ] = false ; activeCount = <int> ; start ( ) ; } private void restart ( ) { delay = delayValue . active ? delayValue . newLowValue ( ) : <int> ; delayTimer = <int> ; durationTimer - = duration ; duration = durationValue . newLowValue ( ) ; emission = ( int ) emissionValue . newLowValue ( ) ; emissionDiff = ( int ) emissionValue . newHighValue ( ) ; if ( ! emissionValue . isRelative ( ) ) emissionDiff - = emission ; life = ( int ) lifeValue . newLowValue ( ) ; lifeDiff = ( int ) lifeValue . newHighValue ( ) ; if ( ! lifeValue . isRelative ( ) ) lifeDiff - = life ; lifeOffset = lifeOffsetValue . active ? ( int ) lifeOffsetValue . newLowValue ( ) : <int> ; lifeOffsetDiff = ( int ) lifeOffsetValue . newHighValue ( ) ; if ( ! lifeOffsetValue . isRelative ( ) ) lifeOffsetDiff - = lifeOffset ; spawnWidth = spawnWidthValue . newLowValue ( ) ; spawnWidthDiff = spawnWidthValue . newHighValue ( ) ; if ( ! spawnWidthValue . isRelative ( ) ) spawnWidthDiff - = spawnWidth ; spawnHeight = spawnHeightValue . newLowValue ( ) ; spawnHeightDiff = spawnHeightValue . newHighValue ( ) ; if ( ! spawnHeightValue . isRelative ( ) ) spawnHeightDiff - = spawnHeight ; updateFlags = <int> ; if ( angleValue . active & & angleValue . timeline . length > <int> ) updateFlags | = UPDATE_ANGLE ; if ( velocityValue . active ) updateFlags | = UPDATE_VELOCITY ; if ( scaleValue . timeline . length > <int> ) updateFlags | = UPDATE_SCALE ; if ( rotationValue . active & & rotationValue . timeline . length > <int> ) updateFlags | = UPDATE_ROTATION ; if ( windValue . active ) updateFlags | = UPDATE_WIND ; if ( gravityValue . active ) updateFlags | = UPDATE_GRAVITY ; if ( tintValue . timeline . length > <int> ) updateFlags | = UPDATE_TINT ; } protected Particle newParticle ( Sprite sprite ) { return new Particle ( sprite ) ; } private void activateParticle ( int index ) { Particle particle = particles [ index ] ; if ( particle = = null ) { particles [ index ] = particle = newParticle ( sprite ) ; particle . flip ( flipX , flipY ) ; } float percent = durationTimer / ( float ) duration ; int updateFlags = this . updateFlags ; particle . currentLife = particle . life = life + ( int ) ( lifeDiff * lifeValue . getScale ( percent ) ) ; if ( velocityValue . active ) { particle . velocity = velocityValue . newLowValue ( ) ; particle . velocityDiff = velocityValue . newHighValue ( ) ; if ( ! velocityValue . isRelative ( ) ) particle . velocityDiff - = particle . velocity ; } particle . angle = angleValue . newLowValue ( ) ; particle . angleDiff = angleValue . newHighValue ( ) ; if ( ! angleValue . isRelative ( ) ) particle . angleDiff - = particle . angle ; float angle = <int> ; if ( ( updateFlags & UPDATE_ANGLE ) = = <int> ) { angle = particle . angle + particle . angleDiff * angleValue . getScale ( <int> ) ; particle . angle = angle ; particle . angleCos = MathUtils . cosDeg ( angle ) ; particle . angleSin = MathUtils . sinDeg ( angle ) ; } float spriteWidth = sprite . getWidth ( ) ; particle . scale = scaleValue . newLowValue ( ) / spriteWidth ; particle . scaleDiff = scaleValue . newHighValue ( ) / spriteWidth ; if ( ! scaleValue . isRelative ( ) ) particle . scaleDiff - = particle . scale ; particle . setScale ( particle . scale + particle . scaleDiff * scaleValue . getScale ( <int> ) ) ; if ( rotationValue . active ) { particle . rotation = rotationValue . newLowValue ( ) ; particle . rotationDiff = rotationValue . newHighValue ( ) ; if ( ! rotationValue . isRelative ( ) ) particle . rotationDiff - = particle . rotation ; float rotation = particle . rotation + particle . rotationDiff * rotationValue . getScale ( <int> ) ; if ( aligned ) rotation + = angle ; particle . setRotation ( rotation ) ; } if ( windValue . active ) { particle . wind = windValue . newLowValue ( ) ; particle . windDiff = windValue . newHighValue ( ) ; if ( ! windValue . isRelative ( ) ) particle . windDiff - = particle . wind ; } if ( gravityValue . active ) { particle . gravity = gravityValue . newLowValue ( ) ; particle . gravityDiff = gravityValue . newHighValue ( ) ; if ( ! gravityValue . isRelative ( ) ) particle . gravityDiff - = particle . gravity ; } float [ ] color = particle . tint ; if ( color = = null ) particle . tint = color = new float [ <int> ] ; float [ ] temp = tintValue . getColor ( <int> ) ; color [ <int> ] = temp [ <int> ] ; color [ <int> ] = temp [ <int> ] ; color [ <int> ] = temp [ <int> ] ; particle . transparency = transparencyValue . newLowValue ( ) ; particle . transparencyDiff = transparencyValue . newHighValue ( ) - particle . transparency ; float x = this . x ; if ( xOffsetValue . active ) x + = xOffsetValue . newLowValue ( ) ; float y = this . y ; if ( yOffsetValue . active ) y + = yOffsetValue . newLowValue ( ) ; switch ( spawnShapeValue . shape ) { case square : { float width = spawnWidth + ( spawnWidthDiff * spawnWidthValue . getScale ( percent ) ) ; float height = spawnHeight + ( spawnHeightDiff * spawnHeightValue . getScale ( percent ) ) ; x + = MathUtils . random ( width ) - width / <int> ; y + = MathUtils . random ( height ) - height / <int> ; break ; } case ellipse : { float width = spawnWidth + ( spawnWidthDiff * spawnWidthValue . getScale ( percent ) ) ; float height = spawnHeight + ( spawnHeightDiff * spawnHeightValue . getScale ( percent ) ) ; float radiusX = width / <int> ; float radiusY = height / <int> ; if ( radiusX = = <int> | | radiusY = = <int> ) break ; float scaleY = radiusX / ( float ) radiusY ; if ( spawnShapeValue . edges ) { float spawnAngle ; switch ( spawnShapeValue . side ) { case top : spawnAngle = - MathUtils . random ( <int> f ) ; break ; case bottom : spawnAngle = MathUtils . random ( <int> f ) ; break ; default : spawnAngle = MathUtils . random ( <int> f ) ; break ; } float cosDeg = MathUtils . cosDeg ( spawnAngle ) ; float sinDeg = MathUtils . sinDeg ( spawnAngle ) ; x + = cosDeg * radiusX ; y + = sinDeg * radiusX / scaleY ; if ( ( updateFlags & UPDATE_ANGLE ) = = <int> ) { particle . angle = spawnAngle ; particle . angleCos = cosDeg ; particle . angleSin = sinDeg ; } } else { float radius2 = radiusX * radiusX ; while ( true ) { float px = MathUtils . random ( width ) - radiusX ; float py = MathUtils . random ( height ) - radiusY ; if ( px * px + py * py < = radius2 ) { x + = px ; y + = py / scaleY ; break ; } } } break ; } case line : { float width = spawnWidth + ( spawnWidthDiff * spawnWidthValue . getScale ( percent ) ) ; float height = spawnHeight + ( spawnHeightDiff * spawnHeightValue . getScale ( percent ) ) ; if ( width ! = <int> ) { float lineX = width * MathUtils . random ( ) ; x + = lineX ; y + = lineX * ( height / ( float ) width ) ; } else y + = height * MathUtils . random ( ) ; break ; } } float spriteHeight = sprite . getHeight ( ) ; particle . setBounds ( x - spriteWidth / <int> , y - spriteHeight / <int> , spriteWidth , spriteHeight ) ; int offsetTime = ( int ) ( lifeOffset + lifeOffsetDiff * lifeOffsetValue . getScale ( percent ) ) ; if ( offsetTime > <int> ) { if ( offsetTime > = particle . currentLife ) offsetTime = particle . currentLife - <int> ; updateParticle ( particle , offsetTime / <int> f , offsetTime ) ; } } private boolean updateParticle ( Particle particle , float delta , int deltaMillis ) { int life = particle . currentLife - deltaMillis ; if ( life < = <int> ) return false ; particle . currentLife = life ; float percent = <int> - particle . currentLife / ( float ) particle . life ; int updateFlags = this . updateFlags ; if ( ( updateFlags & UPDATE_SCALE ) ! = <int> ) particle . setScale ( particle . scale + particle . scaleDiff * scaleValue . getScale ( percent ) ) ; if ( ( updateFlags & UPDATE_VELOCITY ) ! = <int> ) { float velocity = ( particle . velocity + particle . velocityDiff * velocityValue . getScale ( percent ) ) * delta ; float velocityX , velocityY ; if ( ( updateFlags & UPDATE_ANGLE ) ! = <int> ) { float angle = particle . angle + particle . angleDiff * angleValue . getScale ( percent ) ; velocityX = velocity * MathUtils . cosDeg ( angle ) ; velocityY = velocity * MathUtils . sinDeg ( angle ) ; if ( ( updateFlags & UPDATE_ROTATION ) ! = <int> ) { float rotation = particle . rotation + particle . rotationDiff * rotationValue . getScale ( percent ) ; if ( aligned ) rotation + = angle ; particle . setRotation ( rotation ) ; } } else { velocityX = velocity * particle . angleCos ; velocityY = velocity * particle . angleSin ; if ( aligned | | ( updateFlags & UPDATE_ROTATION ) ! = <int> ) { float rotation = particle . rotation + particle . rotationDiff * rotationValue . getScale ( percent ) ; if ( aligned ) rotation + = particle . angle ; particle . setRotation ( rotation ) ; } } if ( ( updateFlags & UPDATE_WIND ) ! = <int> ) velocityX + = ( particle . wind + particle . windDiff * windValue . getScale ( percent ) ) * delta ; if ( ( updateFlags & UPDATE_GRAVITY ) ! = <int> ) velocityY + = ( particle . gravity + particle . gravityDiff * gravityValue . getScale ( percent ) ) * delta ; particle . translate ( velocityX , velocityY ) ; } else { if ( ( updateFlags & UPDATE_ROTATION ) ! = <int> ) particle . setRotation ( particle . rotation + particle . rotationDiff * rotationValue . getScale ( percent ) ) ; } float [ ] color ; if ( ( updateFlags & UPDATE_TINT ) ! = <int> ) color = tintValue . getColor ( percent ) ; else color = particle . tint ; if ( premultipliedAlpha ) { float alphaMultiplier = additive ? <int> : <int> ; float a = particle . transparency + particle . transparencyDiff * transparencyValue . getScale ( percent ) ; particle . setColor ( color [ <int> ] * a , color [ <int> ] * a , color [ <int> ] * a , a * alphaMultiplier ) ; } else { particle . setColor ( color [ <int> ] , color [ <int> ] , color [ <int> ] , particle . transparency + particle . transparencyDiff * transparencyValue . getScale ( percent ) ) ; } return true ; } public void setPosition ( float x , float y ) { if ( attached ) { float xAmount = x - this . x ; float yAmount = y - this . y ; boolean [ ] active = this . active ; for ( int i = <int> , n = active . length ; i < n ; i + + ) if ( active [ i ] ) particles [ i ] . translate ( xAmount , yAmount ) ; } this . x = x ; this . y = y ; } public void setSprite ( Sprite sprite ) { this . sprite = sprite ; if ( sprite = = null ) return ; float originX = sprite . getOriginX ( ) ; float originY = sprite . getOriginY ( ) ; Texture texture = sprite . getTexture ( ) ; for ( int i = <int> , n = particles . length ; i < n ; i + + ) { Particle particle = particles [ i ] ; if ( particle = = null ) break ; particle . setTexture ( texture ) ; particle . setOrigin ( originX , originY ) ; } } public void allowCompletion ( ) { allowCompletion = true ; durationTimer = duration ; } public Sprite getSprite ( ) { return sprite ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public ScaledNumericValue getLife ( ) { return lifeValue ; } public ScaledNumericValue getScale ( ) { return scaleValue ; } public ScaledNumericValue getRotation ( ) { return rotationValue ; } public GradientColorValue getTint ( ) { return tintValue ; } public ScaledNumericValue getVelocity ( ) { return velocityValue ; } public ScaledNumericValue getWind ( ) { return windValue ; } public ScaledNumericValue getGravity ( ) { return gravityValue ; } public ScaledNumericValue getAngle ( ) { return angleValue ; } public ScaledNumericValue getEmission ( ) { return emissionValue ; } public ScaledNumericValue getTransparency ( ) { return transparencyValue ; } public RangedNumericValue getDuration ( ) { return durationValue ; } public RangedNumericValue getDelay ( ) { return delayValue ; } public ScaledNumericValue getLifeOffset ( ) { return lifeOffsetValue ; } public RangedNumericValue getXOffsetValue ( ) { return xOffsetValue ; } public RangedNumericValue getYOffsetValue ( ) { return yOffsetValue ; } public ScaledNumericValue getSpawnWidth ( ) { return spawnWidthValue ; } public ScaledNumericValue getSpawnHeight ( ) { return spawnHeightValue ; } public SpawnShapeValue getSpawnShape ( ) { return spawnShapeValue ; } public boolean isAttached ( ) { return attached ; } public void setAttached ( boolean attached ) { this . attached = attached ; } public boolean isContinuous ( ) { return continuous ; } public void setContinuous ( boolean continuous ) { this . continuous = continuous ; } public boolean isAligned ( ) { return aligned ; } public void setAligned ( boolean aligned ) { this . aligned = aligned ; } public boolean isAdditive ( ) { return additive ; } public void setAdditive ( boolean additive ) { this . additive = additive ; } public boolean cleansUpBlendFunction ( ) { return cleansUpBlendFunction ; } public void setCleansUpBlendFunction ( boolean cleansUpBlendFunction ) { this . cleansUpBlendFunction = cleansUpBlendFunction ; } public boolean isBehind ( ) { return behind ; } public void setBehind ( boolean behind ) { this . behind = behind ; } public boolean isPremultipliedAlpha ( ) { return premultipliedAlpha ; } public void setPremultipliedAlpha ( boolean premultipliedAlpha ) { this . premultipliedAlpha = premultipliedAlpha ; } public int getMinParticleCount ( ) { return minParticleCount ; } public void setMinParticleCount ( int minParticleCount ) { this . minParticleCount = minParticleCount ; } public int getMaxParticleCount ( ) { return maxParticleCount ; } public boolean isComplete ( ) { if ( continuous ) return false ; if ( delayTimer < delay ) return false ; return durationTimer > = duration & & activeCount = = <int> ; } public float getPercentComplete ( ) { if ( delayTimer < delay ) return <int> ; return Math . min ( <int> , durationTimer / ( float ) duration ) ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public int getActiveCount ( ) { return activeCount ; } public String getImagePath ( ) { return imagePath ; } public void setImagePath ( String imagePath ) { this . imagePath = imagePath ; } public void setFlip ( boolean flipX , boolean flipY ) { this . flipX = flipX ; this . flipY = flipY ; if ( particles = = null ) return ; for ( int i = <int> , n = particles . length ; i < n ; i + + ) { Particle particle = particles [ i ] ; if ( particle ! = null ) particle . flip ( flipX , flipY ) ; } } public void flipY ( ) { angleValue . setHigh ( - angleValue . getHighMin ( ) , - angleValue . getHighMax ( ) ) ; angleValue . setLow ( - angleValue . getLowMin ( ) , - angleValue . getLowMax ( ) ) ; gravityValue . setHigh ( - gravityValue . getHighMin ( ) , - gravityValue . getHighMax ( ) ) ; gravityValue . setLow ( - gravityValue . getLowMin ( ) , - gravityValue . getLowMax ( ) ) ; windValue . setHigh ( - windValue . getHighMin ( ) , - windValue . getHighMax ( ) ) ; windValue . setLow ( - windValue . getLowMin ( ) , - windValue . getLowMax ( ) ) ; rotationValue . setHigh ( - rotationValue . getHighMin ( ) , - rotationValue . getHighMax ( ) ) ; rotationValue . setLow ( - rotationValue . getLowMin ( ) , - rotationValue . getLowMax ( ) ) ; yOffsetValue . setLow ( - yOffsetValue . getLowMin ( ) , - yOffsetValue . getLowMax ( ) ) ; } public BoundingBox getBoundingBox ( ) { if ( bounds = = null ) bounds = new BoundingBox ( ) ; Particle [ ] particles = this . particles ; boolean [ ] active = this . active ; BoundingBox bounds = this . bounds ; bounds . inf ( ) ; for ( int i = <int> , n = active . length ; i < n ; i + + ) if ( active [ i ] ) { Rectangle r = particles [ i ] . getBoundingRectangle ( ) ; bounds . ext ( r . x , r . y , <int> ) ; bounds . ext ( r . x + r . width , r . y + r . height , <int> ) ; } return bounds ; } public void save ( Writer output ) throws IOException { output . write ( name + <str> ) ; output . write ( <str> ) ; delayValue . save ( output ) ; output . write ( <str> ) ; durationValue . save ( output ) ; output . write ( <str> ) ; output . write ( <str> + minParticleCount + <str> ) ; output . write ( <str> + maxParticleCount + <str> ) ; output . write ( <str> ) ; emissionValue . save ( output ) ; output . write ( <str> ) ; lifeValue . save ( output ) ; output . write ( <str> ) ; lifeOffsetValue . save ( output ) ; output . write ( <str> ) ; xOffsetValue . save ( output ) ; output . write ( <str> ) ; yOffsetValue . save ( output ) ; output . write ( <str> ) ; spawnShapeValue . save ( output ) ; output . write ( <str> ) ; spawnWidthValue . save ( output ) ; output . write ( <str> ) ; spawnHeightValue . save ( output ) ; output . write ( <str> ) ; scaleValue . save ( output ) ; output . write ( <str> ) ; velocityValue . save ( output ) ; output . write ( <str> ) ; angleValue . save ( output ) ; output . write ( <str> ) ; rotationValue . save ( output ) ; output . write ( <str> ) ; windValue . save ( output ) ; output . write ( <str> ) ; gravityValue . save ( output ) ; output . write ( <str> ) ; tintValue . save ( output ) ; output . write ( <str> ) ; transparencyValue . save ( output ) ; output . write ( <str> ) ; output . write ( <str> + attached + <str> ) ; output . write ( <str> + continuous + <str> ) ; output . write ( <str> + aligned + <str> ) ; output . write ( <str> + additive + <str> ) ; output . write ( <str> + behind + <str> ) ; output . write ( <str> + premultipliedAlpha + <str> ) ; output . write ( <str> ) ; output . write ( imagePath + <str> ) ; } public void load ( BufferedReader reader ) throws IOException { try { name = readString ( reader , <str> ) ; reader . readLine ( ) ; delayValue . load ( reader ) ; reader . readLine ( ) ; durationValue . load ( reader ) ; reader . readLine ( ) ; setMinParticleCount ( readInt ( reader , <str> ) ) ; setMaxParticleCount ( readInt ( reader , <str> ) ) ; reader . readLine ( ) ; emissionValue . load ( reader ) ; reader . readLine ( ) ; lifeValue . load ( reader ) ; reader . readLine ( ) ; lifeOffsetValue . load ( reader ) ; reader . readLine ( ) ; xOffsetValue . load ( reader ) ; reader . readLine ( ) ; yOffsetValue . load ( reader ) ; reader . readLine ( ) ; spawnShapeValue . load ( reader ) ; reader . readLine ( ) ; spawnWidthValue . load ( reader ) ; reader . readLine ( ) ; spawnHeightValue . load ( reader ) ; reader . readLine ( ) ; scaleValue . load ( reader ) ; reader . readLine ( ) ; velocityValue . load ( reader ) ; reader . readLine ( ) ; angleValue . load ( reader ) ; reader . readLine ( ) ; rotationValue . load ( reader ) ; reader . readLine ( ) ; windValue . load ( reader ) ; reader . readLine ( ) ; gravityValue . load ( reader ) ; reader . readLine ( ) ; tintValue . load ( reader ) ; reader . readLine ( ) ; transparencyValue . load ( reader ) ; reader . readLine ( ) ; attached = readBoolean ( reader , <str> ) ; continuous = readBoolean ( reader , <str> ) ; aligned = readBoolean ( reader , <str> ) ; additive = readBoolean ( reader , <str> ) ; behind = readBoolean ( reader , <str> ) ; String line = reader . readLine ( ) ; if ( line . startsWith ( <str> ) ) { premultipliedAlpha = readBoolean ( line ) ; reader . readLine ( ) ; } setImagePath ( reader . readLine ( ) ) ; } catch ( RuntimeException ex ) { if ( name = = null ) throw ex ; throw new RuntimeException ( <str> + name , ex ) ; } } static String readString ( String line ) throws IOException { return line . substring ( line . indexOf ( <str> ) + <int> ) . trim ( ) ; } static String readString ( BufferedReader reader , String name ) throws IOException { String line = reader . readLine ( ) ; if ( line = = null ) throw new IOException ( <str> + name ) ; return readString ( line ) ; } static boolean readBoolean ( String line ) throws IOException { return Boolean . parseBoolean ( readString ( line ) ) ; } static boolean readBoolean ( BufferedReader reader , String name ) throws IOException { return Boolean . parseBoolean ( readString ( reader , name ) ) ; } static int readInt ( BufferedReader reader , String name ) throws IOException { return Integer . parseInt ( readString ( reader , name ) ) ; } static float readFloat ( BufferedReader reader , String name ) throws IOException { return Float . parseFloat ( readString ( reader , name ) ) ; } public static class Particle extends Sprite { protected int life , currentLife ; protected float scale , scaleDiff ; protected float rotation , rotationDiff ; protected float velocity , velocityDiff ; protected float angle , angleDiff ; protected float angleCos , angleSin ; protected float transparency , transparencyDiff ; protected float wind , windDiff ; protected float gravity , gravityDiff ; protected float [ ] tint ; public Particle ( Sprite sprite ) { super ( sprite ) ; } } static public class ParticleValue { boolean active ; boolean alwaysActive ; public void setAlwaysActive ( boolean alwaysActive ) { this . alwaysActive = alwaysActive ; } public boolean isAlwaysActive ( ) { return alwaysActive ; } public boolean isActive ( ) { return alwaysActive | | active ; } public void setActive ( boolean active ) { this . active = active ; } public void save ( Writer output ) throws IOException { if ( ! alwaysActive ) output . write ( <str> + active + <str> ) ; else active = true ; } public void load ( BufferedReader reader ) throws IOException { if ( ! alwaysActive ) active = readBoolean ( reader , <str> ) ; else active = true ; } public void load ( ParticleValue value ) { active = value . active ; alwaysActive = value . alwaysActive ; } } static public class NumericValue extends ParticleValue { private float value ; public float getValue ( ) { return value ; } public void setValue ( float value ) { this . value = value ; } public void save ( Writer output ) throws IOException { super . save ( output ) ; if ( ! active ) return ; output . write ( <str> + value + <str> ) ; } public void load ( BufferedReader reader ) throws IOException { super . load ( reader ) ; if ( ! active ) return ; value = readFloat ( reader , <str> ) ; } public void load ( NumericValue value ) { super . load ( value ) ; this . value = value . value ; } } static public class RangedNumericValue extends ParticleValue { private float lowMin , lowMax ; public float newLowValue ( ) { return lowMin + ( lowMax - lowMin ) * MathUtils . random ( ) ; } public void setLow ( float value ) { lowMin = value ; lowMax = value ; } public void setLow ( float min , float max ) { lowMin = min ; lowMax = max ; } public float getLowMin ( ) { return lowMin ; } public void setLowMin ( float lowMin ) { this . lowMin = lowMin ; } public float getLowMax ( ) { return lowMax ; } public void setLowMax ( float lowMax ) { this . lowMax = lowMax ; } public void save ( Writer output ) throws IOException { super . save ( output ) ; if ( ! active ) return ; output . write ( <str> + lowMin + <str> ) ; output . write ( <str> + lowMax + <str> ) ; } public void load ( BufferedReader reader ) throws IOException { super . load ( reader ) ; if ( ! active ) return ; lowMin = readFloat ( reader , <str> ) ; lowMax = readFloat ( reader , <str> ) ; } public void load ( RangedNumericValue value ) { super . load ( value ) ; lowMax = value . lowMax ; lowMin = value . lowMin ; } } static public class ScaledNumericValue extends RangedNumericValue { private float [ ] scaling = { <int> } ; float [ ] timeline = { <int> } ; private float highMin , highMax ; private boolean relative ; public float newHighValue ( ) { return highMin + ( highMax - highMin ) * MathUtils . random ( ) ; } public void setHigh ( float value ) { highMin = value ; highMax = value ; } public void setHigh ( float min , float max ) { highMin = min ; highMax = max ; } public float getHighMin ( ) { return highMin ; } public void setHighMin ( float highMin ) { this . highMin = highMin ; } public float getHighMax ( ) { return highMax ; } public void setHighMax ( float highMax ) { this . highMax = highMax ; } public float [ ] getScaling ( ) { return scaling ; } public void setScaling ( float [ ] values ) { this . scaling = values ; } public float [ ] getTimeline ( ) { return timeline ; } public void setTimeline ( float [ ] timeline ) { this . timeline = timeline ; } public boolean isRelative ( ) { return relative ; } public void setRelative ( boolean relative ) { this . relative = relative ; } public float getScale ( float percent ) { int endIndex = - <int> ; float [ ] timeline = this . timeline ; int n = timeline . length ; for ( int i = <int> ; i < n ; i + + ) { float t = timeline [ i ] ; if ( t > percent ) { endIndex = i ; break ; } } if ( endIndex = = - <int> ) return scaling [ n - <int> ] ; float [ ] scaling = this . scaling ; int startIndex = endIndex - <int> ; float startValue = scaling [ startIndex ] ; float startTime = timeline [ startIndex ] ; return startValue + ( scaling [ endIndex ] - startValue ) * ( ( percent - startTime ) / ( timeline [ endIndex ] - startTime ) ) ; } public void save ( Writer output ) throws IOException { super . save ( output ) ; if ( ! active ) return ; output . write ( <str> + highMin + <str> ) ; output . write ( <str> + highMax + <str> ) ; output . write ( <str> + relative + <str> ) ; output . write ( <str> + scaling . length + <str> ) ; for ( int i = <int> ; i < scaling . length ; i + + ) output . write ( <str> + i + <str> + scaling [ i ] + <str> ) ; output . write ( <str> + timeline . length + <str> ) ; for ( int i = <int> ; i < timeline . length ; i + + ) output . write ( <str> + i + <str> + timeline [ i ] + <str> ) ; } public void load ( BufferedReader reader ) throws IOException { super . load ( reader ) ; if ( ! active ) return ; highMin = readFloat ( reader , <str> ) ; highMax = readFloat ( reader , <str> ) ; relative = readBoolean ( reader , <str> ) ; scaling = new float [ readInt ( reader , <str> ) ] ; for ( int i = <int> ; i < scaling . length ; i + + ) scaling [ i ] = readFloat ( reader , <str> + i ) ; timeline = new float [ readInt ( reader , <str> ) ] ; for ( int i = <int> ; i < timeline . length ; i + + ) timeline [ i ] = readFloat ( reader , <str> + i ) ; } public void load ( ScaledNumericValue value ) { super . load ( value ) ; highMax = value . highMax ; highMin = value . highMin ; scaling = new float [ value . scaling . length ] ; System . arraycopy ( value . scaling , <int> , scaling , <int> , scaling . length ) ; timeline = new float [ value . timeline . length ] ; System . arraycopy ( value . timeline , <int> , timeline , <int> , timeline . length ) ; relative = value . relative ; } } static public class GradientColorValue extends ParticleValue { static private float [ ] temp = new float [ <int> ] ; private float [ ] colors = { <int> , <int> , <int> } ; float [ ] timeline = { <int> } ; public GradientColorValue ( ) { alwaysActive = true ; } public float [ ] getTimeline ( ) { return timeline ; } public void setTimeline ( float [ ] timeline ) { this . timeline = timeline ; } public float [ ] getColors ( ) { return colors ; } public void setColors ( float [ ] colors ) { this . colors = colors ; } public float [ ] getColor ( float percent ) { int startIndex = <int> , endIndex = - <int> ; float [ ] timeline = this . timeline ; int n = timeline . length ; for ( int i = <int> ; i < n ; i + + ) { float t = timeline [ i ] ; if ( t > percent ) { endIndex = i ; break ; } startIndex = i ; } float startTime = timeline [ startIndex ] ; startIndex * = <int> ; float r1 = colors [ startIndex ] ; float g1 = colors [ startIndex + <int> ] ; float b1 = colors [ startIndex + <int> ] ; if ( endIndex = = - <int> ) { temp [ <int> ] = r1 ; temp [ <int> ] = g1 ; temp [ <int> ] = b1 ; return temp ; } float factor = ( percent - startTime ) / ( timeline [ endIndex ] - startTime ) ; endIndex * = <int> ; temp [ <int> ] = r1 + ( colors [ endIndex ] - r1 ) * factor ; temp [ <int> ] = g1 + ( colors [ endIndex + <int> ] - g1 ) * factor ; temp [ <int> ] = b1 + ( colors [ endIndex + <int> ] - b1 ) * factor ; return temp ; } public void save ( Writer output ) throws IOException { super . save ( output ) ; if ( ! active ) return ; output . write ( <str> + colors . length + <str> ) ; for ( int i = <int> ; i < colors . length ; i + + ) output . write ( <str> + i + <str> + colors [ i ] + <str> ) ; output . write ( <str> + timeline . length + <str> ) ; for ( int i = <int> ; i < timeline . length ; i + + ) output . write ( <str> + i + <str> + timeline [ i ] + <str> ) ; } public void load ( BufferedReader reader ) throws IOException { super . load ( reader ) ; if ( ! active ) return ; colors = new float [ readInt ( reader , <str> ) ] ; for ( int i = <int> ; i < colors . length ; i + + ) colors [ i ] = readFloat ( reader , <str> + i ) ; timeline = new float [ readInt ( reader , <str> ) ] ; for ( int i = <int> ; i < timeline . length ; i + + ) timeline [ i ] = readFloat ( reader , <str> + i ) ; } public void load ( GradientColorValue value ) { super . load ( value ) ; colors = new float [ value . colors . length ] ; System . arraycopy ( value . colors , <int> , colors , <int> , colors . length ) ; timeline = new float [ value . timeline . length ] ; System . arraycopy ( value . timeline , <int> , timeline , <int> , timeline . length ) ; } } static public class SpawnShapeValue extends ParticleValue { SpawnShape shape = SpawnShape . point ; boolean edges ; SpawnEllipseSide side = SpawnEllipseSide . both ; public SpawnShape getShape ( ) { return shape ; } public void setShape ( SpawnShape shape ) { this . shape = shape ; } public boolean isEdges ( ) { return edges ; } public void setEdges ( boolean edges ) { this . edges = edges ; } public SpawnEllipseSide getSide ( ) { return side ; } public void setSide ( SpawnEllipseSide side ) { this . side = side ; } public void save ( Writer output ) throws IOException { super . save ( output ) ; if ( ! active ) return ; output . write ( <str> + shape + <str> ) ; if ( shape = = SpawnShape . ellipse ) { output . write ( <str> + edges + <str> ) ; output . write ( <str> + side + <str> ) ; } } public void load ( BufferedReader reader ) throws IOException { super . load ( reader ) ; if ( ! active ) return ; shape = SpawnShape . valueOf ( readString ( reader , <str> ) ) ; if ( shape = = SpawnShape . ellipse ) { edges = readBoolean ( reader , <str> ) ; side = SpawnEllipseSide . valueOf ( readString ( reader , <str> ) ) ; } } public void load ( SpawnShapeValue value ) { super . load ( value ) ; shape = value . shape ; edges = value . edges ; side = value . side ; } } static public enum SpawnShape { point , line , square , ellipse } static public enum SpawnEllipseSide { both , top , bottom } } 
