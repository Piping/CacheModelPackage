package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import org . apache . cassandra . utils . AbstractIterator ; import com . google . common . collect . Iterators ; import org . apache . cassandra . cache . IMeasurableMemory ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public class RangeTombstoneList implements Iterable < RangeTombstone > , IMeasurableMemory { private static long EMPTY_SIZE = ObjectSizes . measure ( new RangeTombstoneList ( null , <int> ) ) ; private final ClusteringComparator comparator ; private Slice . Bound [ ] starts ; private Slice . Bound [ ] ends ; private long [ ] markedAts ; private int [ ] delTimes ; private long boundaryHeapSize ; private int size ; private RangeTombstoneList ( ClusteringComparator comparator , Slice . Bound [ ] starts , Slice . Bound [ ] ends , long [ ] markedAts , int [ ] delTimes , long boundaryHeapSize , int size ) { assert starts . length = = ends . length & & starts . length = = markedAts . length & & starts . length = = delTimes . length ; this . comparator = comparator ; this . starts = starts ; this . ends = ends ; this . markedAts = markedAts ; this . delTimes = delTimes ; this . size = size ; this . boundaryHeapSize = boundaryHeapSize ; } public RangeTombstoneList ( ClusteringComparator comparator , int capacity ) { this ( comparator , new Slice . Bound [ capacity ] , new Slice . Bound [ capacity ] , new long [ capacity ] , new int [ capacity ] , <int> , <int> ) ; } public boolean isEmpty ( ) { return size = = <int> ; } public int size ( ) { return size ; } public ClusteringComparator comparator ( ) { return comparator ; } public RangeTombstoneList copy ( ) { return new RangeTombstoneList ( comparator , Arrays . copyOf ( starts , size ) , Arrays . copyOf ( ends , size ) , Arrays . copyOf ( markedAts , size ) , Arrays . copyOf ( delTimes , size ) , boundaryHeapSize , size ) ; } public RangeTombstoneList copy ( AbstractAllocator allocator ) { RangeTombstoneList copy = new RangeTombstoneList ( comparator , new Slice . Bound [ size ] , new Slice . Bound [ size ] , Arrays . copyOf ( markedAts , size ) , Arrays . copyOf ( delTimes , size ) , boundaryHeapSize , size ) ; for ( int i = <int> ; i < size ; i + + ) { copy . starts [ i ] = clone ( starts [ i ] , allocator ) ; copy . ends [ i ] = clone ( ends [ i ] , allocator ) ; } return copy ; } private static Slice . Bound clone ( Slice . Bound bound , AbstractAllocator allocator ) { ByteBuffer [ ] values = new ByteBuffer [ bound . size ( ) ] ; for ( int i = <int> ; i < values . length ; i + + ) values [ i ] = allocator . clone ( bound . get ( i ) ) ; return new Slice . Bound ( bound . kind ( ) , values ) ; } public void add ( RangeTombstone tombstone ) { add ( tombstone . deletedSlice ( ) . start ( ) , tombstone . deletedSlice ( ) . end ( ) , tombstone . deletionTime ( ) . markedForDeleteAt ( ) , tombstone . deletionTime ( ) . localDeletionTime ( ) ) ; } public void add ( Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) { if ( isEmpty ( ) ) { addInternal ( <int> , start , end , markedAt , delTime ) ; return ; } int c = comparator . compare ( ends [ size - <int> ] , start ) ; if ( c < = <int> ) { addInternal ( size , start , end , markedAt , delTime ) ; } else { int pos = Arrays . binarySearch ( ends , <int> , size , start , comparator ) ; insertFrom ( ( pos > = <int> ? pos + <int> : - pos - <int> ) , start , end , markedAt , delTime ) ; } boundaryHeapSize + = start . unsharedHeapSize ( ) + end . unsharedHeapSize ( ) ; } public void addAll ( RangeTombstoneList tombstones ) { if ( tombstones . isEmpty ( ) ) return ; if ( isEmpty ( ) ) { copyArrays ( tombstones , this ) ; return ; } if ( size > <int> * tombstones . size ) { for ( int i = <int> ; i < tombstones . size ; i + + ) add ( tombstones . starts [ i ] , tombstones . ends [ i ] , tombstones . markedAts [ i ] , tombstones . delTimes [ i ] ) ; } else { int i = <int> ; int j = <int> ; while ( i < size & & j < tombstones . size ) { if ( comparator . compare ( tombstones . starts [ j ] , ends [ i ] ) < <int> ) { insertFrom ( i , tombstones . starts [ j ] , tombstones . ends [ j ] , tombstones . markedAts [ j ] , tombstones . delTimes [ j ] ) ; j + + ; } else { i + + ; } } for ( ; j < tombstones . size ; j + + ) addInternal ( size , tombstones . starts [ j ] , tombstones . ends [ j ] , tombstones . markedAts [ j ] , tombstones . delTimes [ j ] ) ; } } public boolean isDeleted ( Clustering clustering , Cell cell ) { int idx = searchInternal ( clustering , <int> , size ) ; return idx > = <int> & & ( cell . isCounterCell ( ) | | markedAts [ idx ] > = cell . timestamp ( ) ) ; } public DeletionTime searchDeletionTime ( Clustering name ) { int idx = searchInternal ( name , <int> , size ) ; return idx < <int> ? null : new DeletionTime ( markedAts [ idx ] , delTimes [ idx ] ) ; } public RangeTombstone search ( Clustering name ) { int idx = searchInternal ( name , <int> , size ) ; return idx < <int> ? null : rangeTombstone ( idx ) ; } private int searchInternal ( ClusteringPrefix name , int startIdx , int endIdx ) { if ( isEmpty ( ) ) return - <int> ; int pos = Arrays . binarySearch ( starts , startIdx , endIdx , name , comparator ) ; if ( pos > = <int> ) { return - pos - <int> ; } else { int idx = - pos - <int> ; if ( idx < <int> ) return - <int> ; return comparator . compare ( name , ends [ idx ] ) < <int> ? idx : - idx - <int> ; } } public int dataSize ( ) { int dataSize = TypeSizes . sizeof ( size ) ; for ( int i = <int> ; i < size ; i + + ) { dataSize + = starts [ i ] . dataSize ( ) + ends [ i ] . dataSize ( ) ; dataSize + = TypeSizes . sizeof ( markedAts [ i ] ) ; dataSize + = TypeSizes . sizeof ( delTimes [ i ] ) ; } return dataSize ; } public long maxMarkedAt ( ) { long max = Long . MIN_VALUE ; for ( int i = <int> ; i < size ; i + + ) max = Math . max ( max , markedAts [ i ] ) ; return max ; } public void collectStats ( EncodingStats . Collector collector ) { for ( int i = <int> ; i < size ; i + + ) { collector . updateTimestamp ( markedAts [ i ] ) ; collector . updateLocalDeletionTime ( delTimes [ i ] ) ; } } public void updateAllTimestamp ( long timestamp ) { for ( int i = <int> ; i < size ; i + + ) markedAts [ i ] = timestamp ; } private RangeTombstone rangeTombstone ( int idx ) { return new RangeTombstone ( Slice . make ( starts [ idx ] , ends [ idx ] ) , new DeletionTime ( markedAts [ idx ] , delTimes [ idx ] ) ) ; } private RangeTombstone rangeTombstoneWithNewStart ( int idx , Slice . Bound newStart ) { return new RangeTombstone ( Slice . make ( newStart , ends [ idx ] ) , new DeletionTime ( markedAts [ idx ] , delTimes [ idx ] ) ) ; } private RangeTombstone rangeTombstoneWithNewEnd ( int idx , Slice . Bound newEnd ) { return new RangeTombstone ( Slice . make ( starts [ idx ] , newEnd ) , new DeletionTime ( markedAts [ idx ] , delTimes [ idx ] ) ) ; } private RangeTombstone rangeTombstoneWithNewBounds ( int idx , Slice . Bound newStart , Slice . Bound newEnd ) { return new RangeTombstone ( Slice . make ( newStart , newEnd ) , new DeletionTime ( markedAts [ idx ] , delTimes [ idx ] ) ) ; } public Iterator < RangeTombstone > iterator ( ) { return iterator ( false ) ; } public Iterator < RangeTombstone > iterator ( boolean reversed ) { return reversed ? new AbstractIterator < RangeTombstone > ( ) { private int idx = size - <int> ; protected RangeTombstone computeNext ( ) { if ( idx < <int> ) return endOfData ( ) ; return rangeTombstone ( idx - - ) ; } } : new AbstractIterator < RangeTombstone > ( ) { private int idx ; protected RangeTombstone computeNext ( ) { if ( idx > = size ) return endOfData ( ) ; return rangeTombstone ( idx + + ) ; } } ; } public Iterator < RangeTombstone > iterator ( final Slice slice , boolean reversed ) { return reversed ? reverseIterator ( slice ) : forwardIterator ( slice ) ; } private Iterator < RangeTombstone > forwardIterator ( final Slice slice ) { int startIdx = slice . start ( ) = = Slice . Bound . BOTTOM ? <int> : searchInternal ( slice . start ( ) , <int> , size ) ; final int start = startIdx < <int> ? - startIdx - <int> : startIdx ; if ( start > = size ) return Collections . emptyIterator ( ) ; int finishIdx = slice . end ( ) = = Slice . Bound . TOP ? size - <int> : searchInternal ( slice . end ( ) , start , size ) ; final int finish = finishIdx < <int> ? - finishIdx - <int> : finishIdx ; if ( start > finish ) return Collections . emptyIterator ( ) ; if ( start = = finish ) { Slice . Bound s = comparator . compare ( starts [ start ] , slice . start ( ) ) < <int> ? slice . start ( ) : starts [ start ] ; Slice . Bound e = comparator . compare ( slice . end ( ) , ends [ start ] ) < <int> ? slice . end ( ) : ends [ start ] ; return Iterators . < RangeTombstone > singletonIterator ( rangeTombstoneWithNewBounds ( start , s , e ) ) ; } return new AbstractIterator < RangeTombstone > ( ) { private int idx = start ; protected RangeTombstone computeNext ( ) { if ( idx > = size | | idx > finish ) return endOfData ( ) ; if ( idx = = start & & comparator . compare ( starts [ idx ] , slice . start ( ) ) < <int> ) return rangeTombstoneWithNewStart ( idx + + , slice . start ( ) ) ; if ( idx = = finish & & comparator . compare ( slice . end ( ) , ends [ idx ] ) < <int> ) return rangeTombstoneWithNewEnd ( idx + + , slice . end ( ) ) ; return rangeTombstone ( idx + + ) ; } } ; } private Iterator < RangeTombstone > reverseIterator ( final Slice slice ) { int startIdx = slice . end ( ) = = Slice . Bound . TOP ? size - <int> : searchInternal ( slice . end ( ) , <int> , size ) ; final int start = startIdx < <int> ? - startIdx - <int> : startIdx ; if ( start < <int> ) return Collections . emptyIterator ( ) ; int finishIdx = slice . start ( ) = = Slice . Bound . BOTTOM ? <int> : searchInternal ( slice . start ( ) , <int> , start + <int> ) ; final int finish = finishIdx < <int> ? - finishIdx - <int> : finishIdx ; if ( start < finish ) return Collections . emptyIterator ( ) ; if ( start = = finish ) { Slice . Bound s = comparator . compare ( starts [ start ] , slice . start ( ) ) < <int> ? slice . start ( ) : starts [ start ] ; Slice . Bound e = comparator . compare ( slice . end ( ) , ends [ start ] ) < <int> ? slice . end ( ) : ends [ start ] ; return Iterators . < RangeTombstone > singletonIterator ( rangeTombstoneWithNewBounds ( start , s , e ) ) ; } return new AbstractIterator < RangeTombstone > ( ) { private int idx = start ; protected RangeTombstone computeNext ( ) { if ( idx < <int> | | idx < finish ) return endOfData ( ) ; if ( idx = = start & & comparator . compare ( slice . end ( ) , ends [ idx ] ) < <int> ) return rangeTombstoneWithNewEnd ( idx - - , slice . end ( ) ) ; if ( idx = = finish & & comparator . compare ( starts [ idx ] , slice . start ( ) ) < <int> ) return rangeTombstoneWithNewStart ( idx - - , slice . start ( ) ) ; return rangeTombstone ( idx - - ) ; } } ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof RangeTombstoneList ) ) return false ; RangeTombstoneList that = ( RangeTombstoneList ) o ; if ( size ! = that . size ) return false ; for ( int i = <int> ; i < size ; i + + ) { if ( ! starts [ i ] . equals ( that . starts [ i ] ) ) return false ; if ( ! ends [ i ] . equals ( that . ends [ i ] ) ) return false ; if ( markedAts [ i ] ! = that . markedAts [ i ] ) return false ; if ( delTimes [ i ] ! = that . delTimes [ i ] ) return false ; } return true ; } @Override public final int hashCode ( ) { int result = size ; for ( int i = <int> ; i < size ; i + + ) { result + = starts [ i ] . hashCode ( ) + ends [ i ] . hashCode ( ) ; result + = ( int ) ( markedAts [ i ] ^ ( markedAts [ i ] > > > <int> ) ) ; result + = delTimes [ i ] ; } return result ; } private static void copyArrays ( RangeTombstoneList src , RangeTombstoneList dst ) { dst . grow ( src . size ) ; System . arraycopy ( src . starts , <int> , dst . starts , <int> , src . size ) ; System . arraycopy ( src . ends , <int> , dst . ends , <int> , src . size ) ; System . arraycopy ( src . markedAts , <int> , dst . markedAts , <int> , src . size ) ; System . arraycopy ( src . delTimes , <int> , dst . delTimes , <int> , src . size ) ; dst . size = src . size ; dst . boundaryHeapSize = src . boundaryHeapSize ; } private void insertFrom ( int i , Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) { while ( i < size ) { assert start . isStart ( ) & & end . isEnd ( ) ; assert i = = <int> | | comparator . compare ( ends [ i - <int> ] , start ) < = <int> ; assert comparator . compare ( start , ends [ i ] ) < <int> ; if ( Slice . isEmpty ( comparator , start , end ) ) return ; if ( markedAt > markedAts [ i ] ) { if ( comparator . compare ( starts [ i ] , start ) < <int> ) { Slice . Bound newEnd = start . invert ( ) ; if ( ! Slice . isEmpty ( comparator , starts [ i ] , newEnd ) ) { addInternal ( i , starts [ i ] , start . invert ( ) , markedAts [ i ] , delTimes [ i ] ) ; i + + ; setInternal ( i , start , ends [ i ] , markedAts [ i ] , delTimes [ i ] ) ; } } int endCmp = comparator . compare ( end , starts [ i ] ) ; if ( endCmp < <int> ) { addInternal ( i , start , end , markedAt , delTime ) ; return ; } int cmp = comparator . compare ( ends [ i ] , end ) ; if ( cmp < = <int> ) { if ( i = = size - <int> | | comparator . compare ( end , starts [ i + <int> ] ) < = <int> ) { setInternal ( i , start , end , markedAt , delTime ) ; return ; } setInternal ( i , start , starts [ i + <int> ] . invert ( ) , markedAt , delTime ) ; start = starts [ i + <int> ] ; i + + ; } else { addInternal ( i , start , end , markedAt , delTime ) ; i + + ; Slice . Bound newStart = end . invert ( ) ; if ( ! Slice . isEmpty ( comparator , newStart , ends [ i ] ) ) { setInternal ( i , newStart , ends [ i ] , markedAts [ i ] , delTimes [ i ] ) ; } return ; } } else { if ( comparator . compare ( start , starts [ i ] ) < <int> ) { if ( comparator . compare ( end , starts [ i ] ) < = <int> ) { addInternal ( i , start , end , markedAt , delTime ) ; return ; } Slice . Bound newEnd = starts [ i ] . invert ( ) ; if ( ! Slice . isEmpty ( comparator , start , newEnd ) ) { addInternal ( i , start , newEnd , markedAt , delTime ) ; i + + ; } } if ( comparator . compare ( end , ends [ i ] ) < = <int> ) return ; start = ends [ i ] . invert ( ) ; i + + ; } } addInternal ( i , start , end , markedAt , delTime ) ; } private int capacity ( ) { return starts . length ; } private void addInternal ( int i , Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) { assert i > = <int> ; if ( size = = capacity ( ) ) growToFree ( i ) ; else if ( i < size ) moveElements ( i ) ; setInternal ( i , start , end , markedAt , delTime ) ; size + + ; } private void growToFree ( int i ) { int newLength = ( capacity ( ) * <int> ) / <int> + <int> ; grow ( i , newLength ) ; } private void grow ( int newLength ) { if ( capacity ( ) < newLength ) grow ( - <int> , newLength ) ; } private void grow ( int i , int newLength ) { starts = grow ( starts , size , newLength , i ) ; ends = grow ( ends , size , newLength , i ) ; markedAts = grow ( markedAts , size , newLength , i ) ; delTimes = grow ( delTimes , size , newLength , i ) ; } private static Slice . Bound [ ] grow ( Slice . Bound [ ] a , int size , int newLength , int i ) { if ( i < <int> | | i > = size ) return Arrays . copyOf ( a , newLength ) ; Slice . Bound [ ] newA = new Slice . Bound [ newLength ] ; System . arraycopy ( a , <int> , newA , <int> , i ) ; System . arraycopy ( a , i , newA , i + <int> , size - i ) ; return newA ; } private static long [ ] grow ( long [ ] a , int size , int newLength , int i ) { if ( i < <int> | | i > = size ) return Arrays . copyOf ( a , newLength ) ; long [ ] newA = new long [ newLength ] ; System . arraycopy ( a , <int> , newA , <int> , i ) ; System . arraycopy ( a , i , newA , i + <int> , size - i ) ; return newA ; } private static int [ ] grow ( int [ ] a , int size , int newLength , int i ) { if ( i < <int> | | i > = size ) return Arrays . copyOf ( a , newLength ) ; int [ ] newA = new int [ newLength ] ; System . arraycopy ( a , <int> , newA , <int> , i ) ; System . arraycopy ( a , i , newA , i + <int> , size - i ) ; return newA ; } private void moveElements ( int i ) { if ( i > = size ) return ; System . arraycopy ( starts , i , starts , i + <int> , size - i ) ; System . arraycopy ( ends , i , ends , i + <int> , size - i ) ; System . arraycopy ( markedAts , i , markedAts , i + <int> , size - i ) ; System . arraycopy ( delTimes , i , delTimes , i + <int> , size - i ) ; starts [ i ] = null ; } private void setInternal ( int i , Slice . Bound start , Slice . Bound end , long markedAt , int delTime ) { if ( starts [ i ] ! = null ) boundaryHeapSize - = starts [ i ] . unsharedHeapSize ( ) + ends [ i ] . unsharedHeapSize ( ) ; starts [ i ] = start ; ends [ i ] = end ; markedAts [ i ] = markedAt ; delTimes [ i ] = delTime ; boundaryHeapSize + = start . unsharedHeapSize ( ) + end . unsharedHeapSize ( ) ; } @Override public long unsharedHeapSize ( ) { return EMPTY_SIZE + boundaryHeapSize + ObjectSizes . sizeOfArray ( starts ) + ObjectSizes . sizeOfArray ( ends ) + ObjectSizes . sizeOfArray ( markedAts ) + ObjectSizes . sizeOfArray ( delTimes ) ; } } 
