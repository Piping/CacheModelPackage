package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import java . util . Set ; public class AllocationDeciders extends AllocationDecider { private final AllocationDecider [ ] allocations ; public AllocationDeciders ( Settings settings , AllocationDecider [ ] allocations ) { super ( settings ) ; this . allocations = allocations ; } @Inject public AllocationDeciders ( Settings settings , Set < AllocationDecider > allocations ) { this ( settings , allocations . toArray ( new AllocationDecider [ allocations . size ( ) ] ) ) ; } @Override public Decision canRebalance ( ShardRouting shardRouting , RoutingAllocation allocation ) { Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canRebalance ( shardRouting , allocation ) ; if ( decision = = Decision . NO ) { if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( allocation . shouldIgnoreShardForNode ( shardRouting . shardId ( ) , node . nodeId ( ) ) ) { return Decision . NO ; } Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canAllocate ( shardRouting , node , allocation ) ; if ( decision = = Decision . NO ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shardRouting , node . nodeId ( ) , allocationDecider . getClass ( ) . getSimpleName ( ) ) ; } if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( allocation . shouldIgnoreShardForNode ( shardRouting . shardId ( ) , node . nodeId ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shardRouting , node . nodeId ( ) ) ; } return Decision . NO ; } Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canRemain ( shardRouting , node , allocation ) ; if ( decision = = Decision . NO ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shardRouting , node . nodeId ( ) , allocationDecider . getClass ( ) . getSimpleName ( ) ) ; } if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingAllocation allocation ) { Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canAllocate ( shardRouting , allocation ) ; if ( decision = = Decision . NO ) { if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } @Override public Decision canAllocate ( RoutingNode node , RoutingAllocation allocation ) { Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canAllocate ( node , allocation ) ; if ( decision = = Decision . NO ) { if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } @Override public Decision canRebalance ( RoutingAllocation allocation ) { Decision . Multi ret = new Decision . Multi ( ) ; for ( AllocationDecider allocationDecider : allocations ) { Decision decision = allocationDecider . canRebalance ( allocation ) ; if ( decision = = Decision . NO ) { if ( ! allocation . debugDecision ( ) ) { return decision ; } else { ret . add ( decision ) ; } } else if ( decision ! = Decision . ALWAYS ) { ret . add ( decision ) ; } } return ret ; } } 
