package io . netty . handler . codec . haproxy ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . haproxy . HAProxyProxiedProtocol . AddressFamily ; import io . netty . util . ByteProcessor ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import io . netty . util . internal . StringUtil ; public final class HAProxyMessage { private static final HAProxyMessage V1_UNKNOWN_MSG = new HAProxyMessage ( HAProxyProtocolVersion . V1 , HAProxyCommand . PROXY , HAProxyProxiedProtocol . UNKNOWN , null , null , <int> , <int> ) ; private static final HAProxyMessage V2_UNKNOWN_MSG = new HAProxyMessage ( HAProxyProtocolVersion . V2 , HAProxyCommand . PROXY , HAProxyProxiedProtocol . UNKNOWN , null , null , <int> , <int> ) ; private static final HAProxyMessage V2_LOCAL_MSG = new HAProxyMessage ( HAProxyProtocolVersion . V2 , HAProxyCommand . LOCAL , HAProxyProxiedProtocol . UNKNOWN , null , null , <int> , <int> ) ; private final HAProxyProtocolVersion protocolVersion ; private final HAProxyCommand command ; private final HAProxyProxiedProtocol proxiedProtocol ; private final String sourceAddress ; private final String destinationAddress ; private final int sourcePort ; private final int destinationPort ; private HAProxyMessage ( HAProxyProtocolVersion protocolVersion , HAProxyCommand command , HAProxyProxiedProtocol proxiedProtocol , String sourceAddress , String destinationAddress , String sourcePort , String destinationPort ) { this ( protocolVersion , command , proxiedProtocol , sourceAddress , destinationAddress , portStringToInt ( sourcePort ) , portStringToInt ( destinationPort ) ) ; } private HAProxyMessage ( HAProxyProtocolVersion protocolVersion , HAProxyCommand command , HAProxyProxiedProtocol proxiedProtocol , String sourceAddress , String destinationAddress , int sourcePort , int destinationPort ) { if ( proxiedProtocol = = null ) { throw new NullPointerException ( <str> ) ; } AddressFamily addrFamily = proxiedProtocol . addressFamily ( ) ; checkAddress ( sourceAddress , addrFamily ) ; checkAddress ( destinationAddress , addrFamily ) ; checkPort ( sourcePort ) ; checkPort ( destinationPort ) ; this . protocolVersion = protocolVersion ; this . command = command ; this . proxiedProtocol = proxiedProtocol ; this . sourceAddress = sourceAddress ; this . destinationAddress = destinationAddress ; this . sourcePort = sourcePort ; this . destinationPort = destinationPort ; } static HAProxyMessage decodeHeader ( ByteBuf header ) { if ( header = = null ) { throw new NullPointerException ( <str> ) ; } if ( header . readableBytes ( ) < <int> ) { throw new HAProxyProtocolException ( <str> + header . readableBytes ( ) + <str> ) ; } header . skipBytes ( <int> ) ; final byte verCmdByte = header . readByte ( ) ; HAProxyProtocolVersion ver ; try { ver = HAProxyProtocolVersion . valueOf ( verCmdByte ) ; } catch ( IllegalArgumentException e ) { throw new HAProxyProtocolException ( e ) ; } if ( ver ! = HAProxyProtocolVersion . V2 ) { throw new HAProxyProtocolException ( <str> + Integer . toHexString ( verCmdByte ) ) ; } HAProxyCommand cmd ; try { cmd = HAProxyCommand . valueOf ( verCmdByte ) ; } catch ( IllegalArgumentException e ) { throw new HAProxyProtocolException ( e ) ; } if ( cmd = = HAProxyCommand . LOCAL ) { return V2_LOCAL_MSG ; } HAProxyProxiedProtocol protAndFam ; try { protAndFam = HAProxyProxiedProtocol . valueOf ( header . readByte ( ) ) ; } catch ( IllegalArgumentException e ) { throw new HAProxyProtocolException ( e ) ; } if ( protAndFam = = HAProxyProxiedProtocol . UNKNOWN ) { return V2_UNKNOWN_MSG ; } int addressInfoLen = header . readUnsignedShort ( ) ; String srcAddress ; String dstAddress ; int addressLen ; int srcPort = <int> ; int dstPort = <int> ; AddressFamily addressFamily = protAndFam . addressFamily ( ) ; if ( addressFamily = = AddressFamily . AF_UNIX ) { if ( addressInfoLen < <int> | | header . readableBytes ( ) < <int> ) { throw new HAProxyProtocolException ( <str> + Math . min ( addressInfoLen , header . readableBytes ( ) ) + <str> ) ; } int startIdx = header . readerIndex ( ) ; int addressEnd = header . forEachByte ( startIdx , <int> , ByteProcessor . FIND_NUL ) ; if ( addressEnd = = - <int> ) { addressLen = <int> ; } else { addressLen = addressEnd - startIdx ; } srcAddress = header . toString ( startIdx , addressLen , CharsetUtil . US_ASCII ) ; startIdx + = <int> ; addressEnd = header . forEachByte ( startIdx , <int> , ByteProcessor . FIND_NUL ) ; if ( addressEnd = = - <int> ) { addressLen = <int> ; } else { addressLen = addressEnd - startIdx ; } dstAddress = header . toString ( startIdx , addressLen , CharsetUtil . US_ASCII ) ; } else { if ( addressFamily = = AddressFamily . AF_IPv4 ) { if ( addressInfoLen < <int> | | header . readableBytes ( ) < <int> ) { throw new HAProxyProtocolException ( <str> + Math . min ( addressInfoLen , header . readableBytes ( ) ) + <str> ) ; } addressLen = <int> ; } else if ( addressFamily = = AddressFamily . AF_IPv6 ) { if ( addressInfoLen < <int> | | header . readableBytes ( ) < <int> ) { throw new HAProxyProtocolException ( <str> + Math . min ( addressInfoLen , header . readableBytes ( ) ) + <str> ) ; } addressLen = <int> ; } else { throw new HAProxyProtocolException ( <str> + addressFamily + <str> ) ; } srcAddress = ipBytestoString ( header , addressLen ) ; dstAddress = ipBytestoString ( header , addressLen ) ; srcPort = header . readUnsignedShort ( ) ; dstPort = header . readUnsignedShort ( ) ; } return new HAProxyMessage ( ver , cmd , protAndFam , srcAddress , dstAddress , srcPort , dstPort ) ; } static HAProxyMessage decodeHeader ( String header ) { if ( header = = null ) { throw new HAProxyProtocolException ( <str> ) ; } String [ ] parts = StringUtil . split ( header , <str> ) ; int numParts = parts . length ; if ( numParts < <int> ) { throw new HAProxyProtocolException ( <str> + header + <str> ) ; } if ( ! <str> . equals ( parts [ <int> ] ) ) { throw new HAProxyProtocolException ( <str> + parts [ <int> ] ) ; } HAProxyProxiedProtocol protAndFam ; try { protAndFam = HAProxyProxiedProtocol . valueOf ( parts [ <int> ] ) ; } catch ( IllegalArgumentException e ) { throw new HAProxyProtocolException ( e ) ; } if ( protAndFam ! = HAProxyProxiedProtocol . TCP4 & & protAndFam ! = HAProxyProxiedProtocol . TCP6 & & protAndFam ! = HAProxyProxiedProtocol . UNKNOWN ) { throw new HAProxyProtocolException ( <str> + parts [ <int> ] ) ; } if ( protAndFam = = HAProxyProxiedProtocol . UNKNOWN ) { return V1_UNKNOWN_MSG ; } if ( numParts ! = <int> ) { throw new HAProxyProtocolException ( <str> + header + <str> ) ; } return new HAProxyMessage ( HAProxyProtocolVersion . V1 , HAProxyCommand . PROXY , protAndFam , parts [ <int> ] , parts [ <int> ] , parts [ <int> ] , parts [ <int> ] ) ; } private static String ipBytestoString ( ByteBuf header , int addressLen ) { StringBuilder sb = new StringBuilder ( ) ; if ( addressLen = = <int> ) { sb . append ( header . readByte ( ) & <hex> ) ; sb . append ( <str> ) ; sb . append ( header . readByte ( ) & <hex> ) ; sb . append ( <str> ) ; sb . append ( header . readByte ( ) & <hex> ) ; sb . append ( <str> ) ; sb . append ( header . readByte ( ) & <hex> ) ; } else { sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; sb . append ( <str> ) ; sb . append ( Integer . toHexString ( header . readUnsignedShort ( ) ) ) ; } return sb . toString ( ) ; } private static int portStringToInt ( String value ) { int port ; try { port = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { throw new HAProxyProtocolException ( <str> + value , e ) ; } if ( port < = <int> | | port > <int> ) { throw new HAProxyProtocolException ( <str> + value + <str> ) ; } return port ; } private static void checkAddress ( String address , AddressFamily addrFamily ) { if ( addrFamily = = null ) { throw new NullPointerException ( <str> ) ; } switch ( addrFamily ) { case AF_UNSPEC : if ( address ! = null ) { throw new HAProxyProtocolException ( <str> + address ) ; } return ; case AF_UNIX : return ; } if ( address = = null ) { throw new NullPointerException ( <str> ) ; } switch ( addrFamily ) { case AF_IPv4 : if ( ! NetUtil . isValidIpV4Address ( address ) ) { throw new HAProxyProtocolException ( <str> + address ) ; } break ; case AF_IPv6 : if ( ! NetUtil . isValidIpV6Address ( address ) ) { throw new HAProxyProtocolException ( <str> + address ) ; } break ; default : throw new Error ( ) ; } } private static void checkPort ( int port ) { if ( port < <int> | | port > <int> ) { throw new HAProxyProtocolException ( <str> + port + <str> ) ; } } public HAProxyProtocolVersion protocolVersion ( ) { return protocolVersion ; } public HAProxyCommand command ( ) { return command ; } public HAProxyProxiedProtocol proxiedProtocol ( ) { return proxiedProtocol ; } public String sourceAddress ( ) { return sourceAddress ; } public String destinationAddress ( ) { return destinationAddress ; } public int sourcePort ( ) { return sourcePort ; } public int destinationPort ( ) { return destinationPort ; } } 
