package org . nd4j . linalg . convolution ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . parallel . tasks . Task ; import org . nd4j . linalg . api . parallel . tasks . TaskFactoryProvider ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class Convolution { private static Logger log = LoggerFactory . getLogger ( Convolution . class ) ; public enum Type { FULL , VALID , SAME } private Convolution ( ) { } public static INDArray col2im ( INDArray col , int [ ] stride , int [ ] padding , int height , int width ) { return col2im ( col , stride [ <int> ] , stride [ <int> ] , padding [ <int> ] , padding [ <int> ] , height , width ) ; } public static INDArray col2im ( INDArray col , int sy , int sx , int ph , int pw , int h , int w ) { Task < INDArray > task = Nd4j . getTaskFactory ( ) . getCol2ImTask ( col , sy , sx , ph , pw , h , w ) ; return task . invokeBlocking ( ) ; } public static INDArray im2col ( INDArray img , int [ ] kernel , int [ ] stride , int [ ] padding ) { return im2col ( img , kernel [ <int> ] , kernel [ <int> ] , stride [ <int> ] , stride [ <int> ] , padding [ <int> ] , padding [ <int> ] , <int> , false ) ; } public static INDArray im2col ( INDArray img , int kh , int kw , int sy , int sx , int ph , int pw , boolean coverAll ) { Task < INDArray > task = Nd4j . getTaskFactory ( ) . getIm2ColTask ( img , kh , kw , sy , sx , ph , pw , coverAll ) ; return task . invokeBlocking ( ) ; } public static INDArray im2col ( INDArray img , int kh , int kw , int sy , int sx , int ph , int pw , int pval , boolean coverAll ) { Task < INDArray > task = Nd4j . getTaskFactory ( ) . getIm2ColTask ( img , kh , kw , sy , sx , ph , pw , coverAll ) ; return task . invokeBlocking ( ) ; } public static int outSize ( int size , int k , int s , int p , boolean coverAll ) { if ( coverAll ) return ( size + p * <int> - k + s - <int> ) / s + <int> ; else return ( size + p * <int> - k ) / s + <int> ; } public static INDArray conv2d ( INDArray input , INDArray kernel , Type type ) { return Nd4j . getConvolution ( ) . conv2d ( input , kernel , type ) ; } public static INDArray conv2d ( IComplexNDArray input , IComplexNDArray kernel , Type type ) { return Nd4j . getConvolution ( ) . conv2d ( input , kernel , type ) ; } public static INDArray convn ( INDArray input , INDArray kernel , Type type , int [ ] axes ) { return Nd4j . getConvolution ( ) . convn ( input , kernel , type , axes ) ; } public static IComplexNDArray convn ( IComplexNDArray input , IComplexNDArray kernel , Type type , int [ ] axes ) { return Nd4j . getConvolution ( ) . convn ( input , kernel , type , axes ) ; } public static INDArray convn ( INDArray input , INDArray kernel , Type type ) { return Nd4j . getConvolution ( ) . convn ( input , kernel , type ) ; } public static IComplexNDArray convn ( IComplexNDArray input , IComplexNDArray kernel , Type type ) { return Nd4j . getConvolution ( ) . convn ( input , kernel , type ) ; } } 
