package org . elasticsearch . index . mapper ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsResponse ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicReference ; public class DynamicMappingIntegrationIT extends ESIntegTestCase { public void testConflictingDynamicMappings ( ) { createIndex ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . get ( ) ; try { client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { } } public void testConflictingDynamicMappingsBulk ( ) { createIndex ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . get ( ) ; BulkResponse bulkResponse = client ( ) . prepareBulk ( ) . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) ) . get ( ) ; assertFalse ( bulkResponse . hasFailures ( ) ) ; bulkResponse = client ( ) . prepareBulk ( ) . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) ) . get ( ) ; assertTrue ( bulkResponse . hasFailures ( ) ) ; } private static void assertMappingsHaveField ( GetMappingsResponse mappings , String index , String type , String field ) throws IOException { ImmutableOpenMap < String , MappingMetaData > indexMappings = mappings . getMappings ( ) . get ( <str> ) ; assertNotNull ( indexMappings ) ; MappingMetaData typeMappings = indexMappings . get ( type ) ; assertNotNull ( typeMappings ) ; Map < String , Object > typeMappingsMap = typeMappings . getSourceAsMap ( ) ; Map < String , Object > properties = ( Map < String , Object > ) typeMappingsMap . get ( <str> ) ; assertTrue ( <str> + field + <str> + typeMappingsMap . toString ( ) , properties . containsKey ( field ) ) ; } public void testMappingsPropagatedToMasterNodeImmediately ( ) throws IOException { createIndex ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . get ( ) ; GetMappingsResponse mappings = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . setTypes ( <str> ) . get ( ) ; assertMappingsHaveField ( mappings , <str> , <str> , <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; mappings = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . setTypes ( <str> ) . get ( ) ; assertMappingsHaveField ( mappings , <str> , <str> , <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( ) . get ( ) ; mappings = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . setTypes ( <str> ) . get ( ) ; assertTrue ( mappings . getMappings ( ) . get ( <str> ) . toString ( ) , mappings . getMappings ( ) . get ( <str> ) . containsKey ( <str> ) ) ; } public void testConcurrentDynamicUpdates ( ) throws Throwable { createIndex ( <str> ) ; final Thread [ ] indexThreads = new Thread [ <int> ] ; final CountDownLatch startLatch = new CountDownLatch ( <int> ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; for ( int i = <int> ; i < indexThreads . length ; + + i ) { final String id = Integer . toString ( i ) ; indexThreads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { startLatch . await ( ) ; assertTrue ( client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> + id , <str> ) . get ( ) . isCreated ( ) ) ; } catch ( Throwable t ) { error . compareAndSet ( null , t ) ; } } } ) ; indexThreads [ i ] . start ( ) ; } startLatch . countDown ( ) ; for ( Thread thread : indexThreads ) { thread . join ( ) ; } if ( error . get ( ) ! = null ) { throw error . get ( ) ; } Thread . sleep ( <int> ) ; GetMappingsResponse mappings = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . setTypes ( <str> ) . get ( ) ; for ( int i = <int> ; i < indexThreads . length ; + + i ) { assertMappingsHaveField ( mappings , <str> , <str> , <str> + i ) ; } for ( int i = <int> ; i < indexThreads . length ; + + i ) { assertTrue ( client ( ) . prepareGet ( <str> , <str> , Integer . toString ( i ) ) . get ( ) . isExists ( ) ) ; } } } 
