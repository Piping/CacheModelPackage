package org . elasticsearch . cluster ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . fd . FaultDetection ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . disruption . NetworkDelaysPartition ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Predicate ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . * ; import static org . hamcrest . Matchers . * ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) @ESIntegTestCase.SuppressLocalMode public class MinimumMasterNodesIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { final HashSet < Class < ? extends Plugin > > classes = new HashSet < > ( super . nodePlugins ( ) ) ; classes . add ( MockTransportService . TestPlugin . class ) ; return classes ; } @TestLogging ( <str> ) public void testSimpleMinimumMasterNodes ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settings ) ; logger . info ( <str> ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( true ) ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settings ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . metaData ( ) . indices ( ) . containsKey ( <str> ) , equalTo ( false ) ) ; createIndex ( <str> ) ; NumShards numShards = getNumShards ( <str> ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; } assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForActiveShards ( numShards . totalNumShards ) . execute ( ) . actionGet ( ) . getActiveShards ( ) , equalTo ( numShards . totalNumShards ) ) ; flushAndRefresh ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; } internalCluster ( ) . stopCurrentMasterNode ( ) ; awaitBusy ( ( ) - > { ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; return clusterState . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) ; } ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( true ) ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settings ) ; clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . metaData ( ) . indices ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } internalCluster ( ) . stopRandomNonMasterNode ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( true ) ) ; } } ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settings ) ; ensureGreen ( ) ; clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . metaData ( ) . indices ( ) . containsKey ( <str> ) , equalTo ( true ) ) ; logger . info ( <str> ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } } public void testMultipleNodesShutdownNonMasterNodes ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; ClusterState state ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { for ( Client client : clients ( ) ) { ClusterState state = client . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) , equalTo ( true ) ) ; } } } ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; ensureGreen ( ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; createIndex ( <str> ) ; NumShards numShards = getNumShards ( <str> ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; } ensureGreen ( ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForActiveShards ( numShards . totalNumShards ) . execute ( ) . actionGet ( ) . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; refresh ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } internalCluster ( ) . stopRandomNonMasterNode ( ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; logger . info ( <str> ) ; assertNoMasterBlockOnAllNodes ( ) ; logger . info ( <str> ) ; String [ ] newNodes = internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) . toArray ( Strings . EMPTY_ARRAY ) ; ensureGreen ( ) ; clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . nodes ( ) . masterNodeId ( ) , not ( isOneOf ( newNodes ) ) ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . execute ( ) . actionGet ( ) , <int> ) ; } } public void testDynamicUpdateMinimumMasterNodes ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) . build ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; ClusterHealthResponse clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; setMinimumMasterNodes ( <int> ) ; for ( Client client : internalCluster ( ) ) { assertThat ( client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setLocal ( true ) . get ( ) . isTimedOut ( ) , equalTo ( false ) ) ; } logger . info ( <str> ) ; internalCluster ( ) . stopRandomDataNode ( ) ; logger . info ( <str> ) ; assertNoMasterBlockOnAllNodes ( ) ; logger . info ( <str> ) ; internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( settings ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . build ( ) ) ; clusterHealthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( clusterHealthResponse . isTimedOut ( ) , equalTo ( false ) ) ; } private void assertNoMasterBlockOnAllNodes ( ) throws InterruptedException { Predicate < Client > hasNoMasterBlock = client - > { ClusterState state = client . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; return state . blocks ( ) . hasGlobalBlock ( DiscoverySettings . NO_MASTER_BLOCK_ID ) ; } ; assertTrue ( awaitBusy ( ( ) - > { boolean success = true ; for ( Client client : internalCluster ( ) ) { boolean clientHasNoMasterBlock = hasNoMasterBlock . test ( client ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , client , clientHasNoMasterBlock ) ; } success & = clientHasNoMasterBlock ; } return success ; } , <int> , TimeUnit . SECONDS ) ) ; } public void testCanNotBringClusterDown ( ) throws ExecutionException , InterruptedException { int nodeCount = scaledRandomIntBetween ( <int> , <int> ) ; Settings . Builder settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( <str> , <str> ) ; int initialMinMasterNodes = randomIntBetween ( nodeCount / <int> + <int> , nodeCount ) ; settings . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , initialMinMasterNodes ) ; logger . info ( <str> , nodeCount , initialMinMasterNodes ) ; internalCluster ( ) . startNodesAsync ( nodeCount , settings . build ( ) ) . get ( ) ; logger . info ( <str> ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( Integer . toString ( nodeCount ) ) . get ( ) . isTimedOut ( ) ) ; int updateCount = randomIntBetween ( <int> , nodeCount ) ; logger . info ( <str> , ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , updateCount ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( settingsBuilder ( ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , updateCount ) ) ) ; logger . info ( <str> ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( Integer . toString ( nodeCount ) ) . get ( ) . isTimedOut ( ) ) ; updateCount = nodeCount + randomIntBetween ( <int> , <int> ) ; logger . info ( <str> , ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , updateCount ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( settingsBuilder ( ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , updateCount ) ) . get ( ) . getPersistentSettings ( ) . getAsMap ( ) . keySet ( ) , empty ( ) ) ; logger . info ( <str> ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( Integer . toString ( nodeCount ) ) . get ( ) . isTimedOut ( ) ) ; } public void testCanNotPublishWithoutMinMastNodes ( ) throws Exception { Settings settings = settingsBuilder ( ) . put ( <str> , <str> ) . put ( FaultDetection . SETTING_PING_TIMEOUT , <str> ) . put ( ZenDiscovery . SETTING_PING_TIMEOUT , <str> ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . put ( DiscoverySettings . COMMIT_TIMEOUT , <str> ) . build ( ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; ensureGreen ( ) ; final String master = internalCluster ( ) . getMasterName ( ) ; Set < String > otherNodes = new HashSet < > ( Arrays . asList ( internalCluster ( ) . getNodeNames ( ) ) ) ; otherNodes . remove ( master ) ; NetworkDelaysPartition partition = new NetworkDelaysPartition ( Collections . singleton ( master ) , otherNodes , <int> , random ( ) ) ; internalCluster ( ) . setDisruptionScheme ( partition ) ; partition . startDisrupting ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final AtomicReference < Throwable > failure = new AtomicReference < > ( ) ; logger . debug ( <str> ) ; final ClusterService masterClusterService = internalCluster ( ) . clusterService ( master ) ; masterClusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { latch . countDown ( ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { MetaData . Builder metaData = MetaData . builder ( currentState . metaData ( ) ) . persistentSettings ( Settings . builder ( ) . put ( currentState . metaData ( ) . persistentSettings ( ) ) . put ( <str> , true ) . build ( ) ) ; return ClusterState . builder ( currentState ) . metaData ( metaData ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { failure . set ( t ) ; latch . countDown ( ) ; } } ) ; logger . debug ( <str> ) ; latch . await ( ) ; assertThat ( failure . get ( ) , instanceOf ( Discovery . FailedToCommitClusterStateException . class ) ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( masterClusterService . state ( ) . nodes ( ) . masterNode ( ) , nullValue ( ) ) ; } } ) ; partition . stopDisrupting ( ) ; logger . debug ( <str> ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . setWaitForEvents ( Priority . LANGUID ) ) ; for ( String node : internalCluster ( ) . getNodeNames ( ) ) { Settings nodeSetting = internalCluster ( ) . clusterService ( node ) . state ( ) . metaData ( ) . settings ( ) ; assertThat ( node + <str> , nodeSetting . get ( <str> ) , nullValue ( ) ) ; } } } 
