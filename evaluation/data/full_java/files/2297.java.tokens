package org . nd4j . bytebuddy . arrays . assign . relative . withvalue ; import net . bytebuddy . description . method . MethodDescription ; import net . bytebuddy . implementation . Implementation ; import net . bytebuddy . implementation . bytecode . ByteCodeAppender ; import net . bytebuddy . implementation . bytecode . StackManipulation ; import net . bytebuddy . implementation . bytecode . collection . ArrayAccess ; import net . bytebuddy . implementation . bytecode . constant . IntegerConstant ; import net . bytebuddy . implementation . bytecode . member . MethodReturn ; import net . bytebuddy . implementation . bytecode . member . MethodVariableAccess ; import net . bytebuddy . jar . asm . MethodVisitor ; import net . bytebuddy . pool . TypePool ; public class RelativeArrayAssignWithValueValueAppender implements ByteCodeAppender { private int index ; private int newVal ; private static TypePool typePool = TypePool . Default . ofClassPath ( ) ; public RelativeArrayAssignWithValueValueAppender ( int index , int newVal ) { this . index = index ; this . newVal = newVal ; } @Override public Size apply ( MethodVisitor methodVisitor , Implementation . Context implementationContext , MethodDescription instrumentedMethod ) { StackManipulation compound = assignOperation ( ) ; StackManipulation . Size size = compound . apply ( methodVisitor , implementationContext ) ; StackManipulation store = ArrayAccess . of ( typePool . describe ( <str> ) . resolve ( ) ) . store ( ) ; size = size . aggregate ( store . apply ( methodVisitor , implementationContext ) ) ; return new Size ( size . getMaximalSize ( ) , instrumentedMethod . getStackSize ( ) ) ; } public StackManipulation assignOperation ( ) { StackManipulation val = IntegerConstant . forValue ( newVal ) ; StackManipulation indexToAssign = IntegerConstant . forValue ( index ) ; StackManipulation . Compound compound = new StackManipulation . Compound ( indexToAssign , val ) ; return compound ; } } 
