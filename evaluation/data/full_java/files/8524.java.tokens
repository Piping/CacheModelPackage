package org . elasticsearch . search . query ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . action . admin . indices . create . CreateIndexRequestBuilder ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . query . MatchQueryBuilder ; import org . elasticsearch . index . query . MultiMatchQueryBuilder ; import org . elasticsearch . index . query . Operator ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . search . MatchQuery ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . SearchHits ; import org . elasticsearch . search . sort . SortBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . junit . Before ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . index . query . QueryBuilders . boolQuery ; import static org . elasticsearch . index . query . QueryBuilders . disMaxQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchPhrasePrefixQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchPhraseQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchQuery ; import static org . elasticsearch . index . query . QueryBuilders . multiMatchQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertFirstHit ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchHits ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSecondHit ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . hasId ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . empty ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThan ; public class MultiMatchQueryIT extends ESIntegTestCase { @Before public void init ( ) throws Exception { CreateIndexRequestBuilder builder = prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) . put ( <str> , <str> ) ) ; assertAcked ( builder . addMapping ( <str> , createMapping ( ) ) ) ; ensureGreen ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <int> , <str> , <int> ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <int> ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <int> ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <int> ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <int> ) ) ; List < String > firstNames = new ArrayList < > ( ) ; fill ( firstNames , <str> , between ( <int> , <int> ) ) ; fill ( firstNames , <str> , between ( <int> , <int> ) ) ; fillRandom ( firstNames , between ( <int> , <int> ) ) ; List < String > lastNames = new ArrayList < > ( ) ; fill ( lastNames , <str> , between ( <int> , <int> ) ) ; fillRandom ( lastNames , between ( <int> , <int> ) ) ; for ( int i = <int> ; i < numDocs ; i + + ) { String first = RandomPicks . randomFrom ( getRandom ( ) , firstNames ) ; String last = randomPickExcept ( lastNames , first ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , first + <str> + last , <str> , first , <str> , last , <str> , randomBoolean ( ) ? <str> : <str> , <str> , between ( <int> , <int> ) ) ) ; } indexRandom ( true , false , builders ) ; } private XContentBuilder createMapping ( ) throws IOException { return XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; } public void testDefaults ( ) throws ExecutionException , InterruptedException { MatchQuery . Type type = randomBoolean ( ) ? MatchQueryBuilder . DEFAULT_TYPE : MatchQuery . Type . BOOLEAN ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) ) ) . get ( ) ; Set < String > topNIds = Sets . newHashSet ( <str> , <str> ) ; for ( int i = <int> ; i < searchResponse . getHits ( ) . hits ( ) . length ; i + + ) { topNIds . remove ( searchResponse . getHits ( ) . getAt ( i ) . getId ( ) ) ; } assertThat ( topNIds , empty ( ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , equalTo ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . useDisMax ( false ) . type ( type ) ) ) . get ( ) ; assertFirstHit ( searchResponse , anyOf ( hasId ( <str> ) , hasId ( <str> ) ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThan ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . type ( type ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . AND ) . type ( type ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . AND ) . type ( type ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; } public void testPhraseType ( ) { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . type ( MatchQuery . Type . PHRASE ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; assertHitCount ( searchResponse , <int> ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . type ( MatchQuery . Type . PHRASE ) ) ) . get ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , greaterThan ( <int> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . type ( MatchQuery . Type . PHRASE_PREFIX ) ) ) . get ( ) ; assertSearchHits ( searchResponse , <str> , <str> ) ; assertHitCount ( searchResponse , <int> ) ; } public void testSingleField ( ) throws NoSuchFieldException , IllegalAccessException { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> ) ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; String [ ] fields = { <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; String [ ] query = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; int numIters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { String field = RandomPicks . randomFrom ( getRandom ( ) , fields ) ; int numTerms = randomIntBetween ( <int> , query . length ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int j = <int> ; j < numTerms ; j + + ) { builder . append ( RandomPicks . randomFrom ( getRandom ( ) , query ) ) . append ( <str> ) ; } MultiMatchQueryBuilder multiMatchQueryBuilder = randomizeType ( multiMatchQuery ( builder . toString ( ) , field ) ) ; SearchResponse multiMatchResp = client ( ) . prepareSearch ( <str> ) . addSort ( <str> , SortOrder . DESC ) . addSort ( <str> , SortOrder . ASC ) . setQuery ( multiMatchQueryBuilder ) . get ( ) ; MatchQueryBuilder matchQueryBuilder = QueryBuilders . matchQuery ( field , builder . toString ( ) ) ; if ( getType ( multiMatchQueryBuilder ) ! = null ) { matchQueryBuilder . type ( MatchQuery . Type . valueOf ( getType ( multiMatchQueryBuilder ) . matchQueryType ( ) . toString ( ) ) ) ; } SearchResponse matchResp = client ( ) . prepareSearch ( <str> ) . addSort ( <str> , SortOrder . DESC ) . addSort ( <str> , SortOrder . ASC ) . setQuery ( matchQueryBuilder ) . get ( ) ; assertThat ( <str> + field + <str> + builder . toString ( ) , multiMatchResp . getHits ( ) . getTotalHits ( ) , equalTo ( matchResp . getHits ( ) . getTotalHits ( ) ) ) ; SearchHits hits = multiMatchResp . getHits ( ) ; for ( int j = <int> ; j < hits . hits ( ) . length ; j + + ) { assertThat ( hits . getHits ( ) [ j ] . score ( ) , equalTo ( matchResp . getHits ( ) . getHits ( ) [ j ] . score ( ) ) ) ; assertThat ( hits . getHits ( ) [ j ] . getId ( ) , equalTo ( matchResp . getHits ( ) . getHits ( ) [ j ] . getId ( ) ) ) ; } } } public void testCutoffFreq ( ) throws ExecutionException , InterruptedException { final long numDocs = client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) . getHits ( ) . totalHits ( ) ; MatchQuery . Type type = randomBoolean ( ) ? MatchQueryBuilder . DEFAULT_TYPE : MatchQuery . Type . BOOLEAN ; Float cutoffFrequency = randomBoolean ( ) ? Math . min ( <int> , numDocs * <float> / between ( <int> , <int> ) ) : <float> / between ( <int> , <int> ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . cutoffFrequency ( cutoffFrequency ) ) ) . get ( ) ; Set < String > topNIds = Sets . newHashSet ( <str> , <str> ) ; for ( int i = <int> ; i < searchResponse . getHits ( ) . hits ( ) . length ; i + + ) { topNIds . remove ( searchResponse . getHits ( ) . getAt ( i ) . getId ( ) ) ; } assertThat ( topNIds , empty ( ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThanOrEqualTo ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; cutoffFrequency = randomBoolean ( ) ? Math . min ( <int> , numDocs * <float> / between ( <int> , <int> ) ) : <float> / between ( <int> , <int> ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . useDisMax ( false ) . cutoffFrequency ( cutoffFrequency ) . type ( type ) ) ) . get ( ) ; assertFirstHit ( searchResponse , anyOf ( hasId ( <str> ) , hasId ( <str> ) ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThan ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; long size = searchResponse . getHits ( ) . getTotalHits ( ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . useDisMax ( false ) . type ( type ) ) ) . get ( ) ; assertFirstHit ( searchResponse , anyOf ( hasId ( <str> ) , hasId ( <str> ) ) ) ; assertThat ( <str> , size , lessThan ( searchResponse . getHits ( ) . getTotalHits ( ) ) ) ; cutoffFrequency = randomBoolean ( ) ? Math . min ( <int> , numDocs * <float> / between ( <int> , <int> ) ) : <float> / between ( <int> , <int> ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . OR ) . cutoffFrequency ( cutoffFrequency ) . type ( type ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . AND ) . cutoffFrequency ( cutoffFrequency ) . type ( type ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . operator ( Operator . AND ) . cutoffFrequency ( cutoffFrequency ) . type ( type ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . operator ( Operator . AND ) . cutoffFrequency ( cutoffFrequency ) . analyzer ( <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; } public void testEquivalence ( ) { final int numDocs = ( int ) client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) . getHits ( ) . totalHits ( ) ; int numIters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIters ; i + + ) { { MatchQuery . Type type = randomBoolean ( ) ? MatchQueryBuilder . DEFAULT_TYPE : MatchQuery . Type . BOOLEAN ; MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean ( ) ? multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) : multiMatchQuery ( <str> , <str> , randomBoolean ( ) ? <str> : <str> ) ; SearchResponse left = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( randomizeType ( multiMatchQueryBuilder . operator ( Operator . OR ) . type ( type ) ) ) . get ( ) ; SearchResponse right = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( disMaxQuery ( ) . add ( matchQuery ( <str> , <str> ) ) . add ( matchQuery ( <str> , <str> ) ) . add ( matchQuery ( <str> , <str> ) ) . add ( matchQuery ( <str> , <str> ) ) ) . get ( ) ; assertEquivalent ( <str> , left , right ) ; } { MatchQuery . Type type = randomBoolean ( ) ? MatchQueryBuilder . DEFAULT_TYPE : MatchQuery . Type . BOOLEAN ; String minShouldMatch = randomBoolean ( ) ? null : <str> + between ( <int> , <int> ) ; Operator op = randomBoolean ( ) ? Operator . AND : Operator . OR ; MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean ( ) ? multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) : multiMatchQuery ( <str> , <str> , randomBoolean ( ) ? <str> : <str> ) ; SearchResponse left = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( randomizeType ( multiMatchQueryBuilder . operator ( op ) . useDisMax ( false ) . minimumShouldMatch ( minShouldMatch ) . type ( type ) ) ) . get ( ) ; SearchResponse right = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( boolQuery ( ) . minimumShouldMatch ( minShouldMatch ) . should ( randomBoolean ( ) ? termQuery ( <str> , <str> ) : matchQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchQuery ( <str> , <str> ) . operator ( op ) ) ) . get ( ) ; assertEquivalent ( <str> , left , right ) ; } { String minShouldMatch = randomBoolean ( ) ? null : <str> + between ( <int> , <int> ) ; Operator op = randomBoolean ( ) ? Operator . AND : Operator . OR ; SearchResponse left = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MatchQuery . Type . PHRASE_PREFIX ) . useDisMax ( false ) . minimumShouldMatch ( minShouldMatch ) ) ) . get ( ) ; SearchResponse right = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( boolQuery ( ) . minimumShouldMatch ( minShouldMatch ) . should ( matchPhrasePrefixQuery ( <str> , <str> ) ) . should ( matchPhrasePrefixQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchPhrasePrefixQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchPhrasePrefixQuery ( <str> , <str> ) . operator ( op ) ) ) . get ( ) ; assertEquivalent ( <str> , left , right ) ; } { String minShouldMatch = randomBoolean ( ) ? null : <str> + between ( <int> , <int> ) ; Operator op = randomBoolean ( ) ? Operator . AND : Operator . OR ; SearchResponse left ; if ( randomBoolean ( ) ) { left = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MatchQuery . Type . PHRASE ) . useDisMax ( false ) . minimumShouldMatch ( minShouldMatch ) ) ) . get ( ) ; } else { left = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MatchQuery . Type . PHRASE ) . tieBreaker ( <float> ) . minimumShouldMatch ( minShouldMatch ) ) ) . get ( ) ; } SearchResponse right = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs ) . addSort ( SortBuilders . scoreSort ( ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setQuery ( boolQuery ( ) . minimumShouldMatch ( minShouldMatch ) . should ( matchPhraseQuery ( <str> , <str> ) ) . should ( matchPhraseQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchPhraseQuery ( <str> , <str> ) . operator ( op ) ) . should ( matchPhraseQuery ( <str> , <str> ) . operator ( op ) ) ) . get ( ) ; assertEquivalent ( <str> , left , right ) ; } } } public void testCrossFieldMode ( ) throws ExecutionException , InterruptedException { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . OR ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . OR ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; assertSecondHit ( searchResponse , hasId ( <str> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThan ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . OR ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . AND ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . analyzer ( <str> ) . operator ( Operator . AND ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . analyzer ( <str> ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . analyzer ( <str> ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . cutoffFrequency ( <float> ) . analyzer ( <str> ) . operator ( Operator . OR ) ) ) . get ( ) ; assertFirstHit ( searchResponse , anyOf ( hasId ( <str> ) , hasId ( <str> ) ) ) ; long numResults = searchResponse . getHits ( ) . totalHits ( ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . analyzer ( <str> ) . operator ( Operator . OR ) ) ) . get ( ) ; assertThat ( numResults , lessThan ( searchResponse . getHits ( ) . getTotalHits ( ) ) ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . analyzer ( <str> ) . operator ( Operator . AND ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( randomBoolean ( ) ? MultiMatchQueryBuilder . Type . CROSS_FIELDS : MultiMatchQueryBuilder . DEFAULT_TYPE ) . operator ( Operator . AND ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> l ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> ) . type ( randomBoolean ( ) ? MultiMatchQueryBuilder . Type . CROSS_FIELDS : MultiMatchQueryBuilder . DEFAULT_TYPE ) . operator ( Operator . AND ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> l ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . field ( <str> , <int> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . AND ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; assertSecondHit ( searchResponse , hasId ( <str> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThan ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( randomizeType ( multiMatchQuery ( <str> , <str> , <str> , <str> , <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . operator ( Operator . AND ) ) ) . get ( ) ; assertFirstHit ( searchResponse , hasId ( <str> ) ) ; assertSecondHit ( searchResponse , hasId ( <str> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) , greaterThan ( searchResponse . getHits ( ) . hits ( ) [ <int> ] . getScore ( ) ) ) ; } private static final void assertEquivalent ( String query , SearchResponse left , SearchResponse right ) { assertNoFailures ( left ) ; assertNoFailures ( right ) ; SearchHits leftHits = left . getHits ( ) ; SearchHits rightHits = right . getHits ( ) ; assertThat ( leftHits . getTotalHits ( ) , equalTo ( rightHits . getTotalHits ( ) ) ) ; assertThat ( leftHits . getHits ( ) . length , equalTo ( rightHits . getHits ( ) . length ) ) ; SearchHit [ ] hits = leftHits . getHits ( ) ; SearchHit [ ] rHits = rightHits . getHits ( ) ; for ( int i = <int> ; i < hits . length ; i + + ) { assertThat ( <str> + query + <str> + i , ( double ) hits [ i ] . getScore ( ) , closeTo ( rHits [ i ] . getScore ( ) , <float> ) ) ; } for ( int i = <int> ; i < hits . length ; i + + ) { if ( hits [ i ] . getScore ( ) = = hits [ hits . length - <int> ] . getScore ( ) ) { return ; } assertThat ( <str> + query , hits [ i ] . getId ( ) , equalTo ( rHits [ i ] . getId ( ) ) ) ; } } public static List < String > fill ( List < String > list , String value , int times ) { for ( int i = <int> ; i < times ; i + + ) { list . add ( value ) ; } return list ; } public List < String > fillRandom ( List < String > list , int times ) { for ( int i = <int> ; i < times ; i + + ) { list . add ( randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) ) ; } return list ; } public < T > T randomPickExcept ( List < T > fromList , T butNot ) { while ( true ) { T t = RandomPicks . randomFrom ( getRandom ( ) , fromList ) ; if ( t . equals ( butNot ) ) { continue ; } return t ; } } public MultiMatchQueryBuilder randomizeType ( MultiMatchQueryBuilder builder ) { try { MultiMatchQueryBuilder . Type type = getType ( builder ) ; if ( type = = null & & randomBoolean ( ) ) { return builder ; } if ( type = = null ) { type = MultiMatchQueryBuilder . Type . BEST_FIELDS ; } if ( randomBoolean ( ) ) { builder . type ( type ) ; } else { Object oType = type ; switch ( type ) { case BEST_FIELDS : if ( randomBoolean ( ) ) { oType = MatchQuery . Type . BOOLEAN ; } break ; case MOST_FIELDS : if ( randomBoolean ( ) ) { oType = MatchQuery . Type . BOOLEAN ; } break ; case CROSS_FIELDS : break ; case PHRASE : if ( randomBoolean ( ) ) { oType = MatchQuery . Type . PHRASE ; } break ; case PHRASE_PREFIX : if ( randomBoolean ( ) ) { oType = MatchQuery . Type . PHRASE_PREFIX ; } break ; } builder . type ( oType ) ; } return builder ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } private MultiMatchQueryBuilder . Type getType ( MultiMatchQueryBuilder builder ) throws NoSuchFieldException , IllegalAccessException { return builder . getType ( ) ; } } 
