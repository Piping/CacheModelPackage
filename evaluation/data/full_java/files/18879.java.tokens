package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import java . util . List ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; public class Bzip2Decoder extends ByteToMessageDecoder { private enum State { INIT , INIT_BLOCK , INIT_BLOCK_PARAMS , RECEIVE_HUFFMAN_USED_MAP , RECEIVE_HUFFMAN_USED_BITMAPS , RECEIVE_SELECTORS_NUMBER , RECEIVE_SELECTORS , RECEIVE_HUFFMAN_LENGTH , DECODE_HUFFMAN_DATA , EOF } private State currentState = State . INIT ; private final Bzip2BitReader reader = new Bzip2BitReader ( ) ; private Bzip2BlockDecompressor blockDecompressor ; private Bzip2HuffmanStageDecoder huffmanStageDecoder ; private int blockSize ; private int blockCRC ; private int streamCRC ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( ! in . isReadable ( ) ) { return ; } final Bzip2BitReader reader = this . reader ; reader . setByteBuf ( in ) ; for ( ; ; ) { switch ( currentState ) { case INIT : if ( in . readableBytes ( ) < <int> ) { return ; } int magicNumber = in . readUnsignedMedium ( ) ; if ( magicNumber ! = MAGIC_NUMBER ) { throw new DecompressionException ( <str> + <str> ) ; } int blockSize = in . readByte ( ) - <str> ; if ( blockSize < MIN_BLOCK_SIZE | | blockSize > MAX_BLOCK_SIZE ) { throw new DecompressionException ( <str> ) ; } this . blockSize = blockSize * BASE_BLOCK_SIZE ; streamCRC = <int> ; currentState = State . INIT_BLOCK ; case INIT_BLOCK : if ( ! reader . hasReadableBytes ( <int> ) ) { return ; } final int magic1 = reader . readBits ( <int> ) ; final int magic2 = reader . readBits ( <int> ) ; if ( magic1 = = END_OF_STREAM_MAGIC_1 & & magic2 = = END_OF_STREAM_MAGIC_2 ) { final int storedCombinedCRC = reader . readInt ( ) ; if ( storedCombinedCRC ! = streamCRC ) { throw new DecompressionException ( <str> ) ; } currentState = State . EOF ; break ; } if ( magic1 ! = BLOCK_HEADER_MAGIC_1 | | magic2 ! = BLOCK_HEADER_MAGIC_2 ) { throw new DecompressionException ( <str> ) ; } blockCRC = reader . readInt ( ) ; currentState = State . INIT_BLOCK_PARAMS ; case INIT_BLOCK_PARAMS : if ( ! reader . hasReadableBits ( <int> ) ) { return ; } final boolean blockRandomised = reader . readBoolean ( ) ; final int bwtStartPointer = reader . readBits ( <int> ) ; blockDecompressor = new Bzip2BlockDecompressor ( this . blockSize , blockCRC , blockRandomised , bwtStartPointer , reader ) ; currentState = State . RECEIVE_HUFFMAN_USED_MAP ; case RECEIVE_HUFFMAN_USED_MAP : if ( ! reader . hasReadableBits ( <int> ) ) { return ; } blockDecompressor . huffmanInUse16 = reader . readBits ( <int> ) ; currentState = State . RECEIVE_HUFFMAN_USED_BITMAPS ; case RECEIVE_HUFFMAN_USED_BITMAPS : Bzip2BlockDecompressor blockDecompressor = this . blockDecompressor ; final int inUse16 = blockDecompressor . huffmanInUse16 ; final int bitNumber = Integer . bitCount ( inUse16 ) ; final byte [ ] huffmanSymbolMap = blockDecompressor . huffmanSymbolMap ; if ( ! reader . hasReadableBits ( bitNumber * HUFFMAN_SYMBOL_RANGE_SIZE + <int> ) ) { return ; } int huffmanSymbolCount = <int> ; if ( bitNumber > <int> ) { for ( int i = <int> ; i < <int> ; i + + ) { if ( ( inUse16 & <int> < < <int> > > > i ) ! = <int> ) { for ( int j = <int> , k = i < < <int> ; j < HUFFMAN_SYMBOL_RANGE_SIZE ; j + + , k + + ) { if ( reader . readBoolean ( ) ) { huffmanSymbolMap [ huffmanSymbolCount + + ] = ( byte ) k ; } } } } } blockDecompressor . huffmanEndOfBlockSymbol = huffmanSymbolCount + <int> ; int totalTables = reader . readBits ( <int> ) ; if ( totalTables < HUFFMAN_MINIMUM_TABLES | | totalTables > HUFFMAN_MAXIMUM_TABLES ) { throw new DecompressionException ( <str> ) ; } int alphaSize = huffmanSymbolCount + <int> ; if ( alphaSize > HUFFMAN_MAX_ALPHABET_SIZE ) { throw new DecompressionException ( <str> ) ; } huffmanStageDecoder = new Bzip2HuffmanStageDecoder ( reader , totalTables , alphaSize ) ; currentState = State . RECEIVE_SELECTORS_NUMBER ; case RECEIVE_SELECTORS_NUMBER : if ( ! reader . hasReadableBits ( <int> ) ) { return ; } int totalSelectors = reader . readBits ( <int> ) ; if ( totalSelectors < <int> | | totalSelectors > MAX_SELECTORS ) { throw new DecompressionException ( <str> ) ; } huffmanStageDecoder . selectors = new byte [ totalSelectors ] ; currentState = State . RECEIVE_SELECTORS ; case RECEIVE_SELECTORS : Bzip2HuffmanStageDecoder huffmanStageDecoder = this . huffmanStageDecoder ; byte [ ] selectors = huffmanStageDecoder . selectors ; totalSelectors = selectors . length ; final Bzip2MoveToFrontTable tableMtf = huffmanStageDecoder . tableMTF ; int currSelector ; for ( currSelector = huffmanStageDecoder . currentSelector ; currSelector < totalSelectors ; currSelector + + ) { if ( ! reader . hasReadableBits ( HUFFMAN_SELECTOR_LIST_MAX_LENGTH ) ) { huffmanStageDecoder . currentSelector = currSelector ; return ; } int index = <int> ; while ( reader . readBoolean ( ) ) { index + + ; } selectors [ currSelector ] = tableMtf . indexToFront ( index ) ; } currentState = State . RECEIVE_HUFFMAN_LENGTH ; case RECEIVE_HUFFMAN_LENGTH : huffmanStageDecoder = this . huffmanStageDecoder ; totalTables = huffmanStageDecoder . totalTables ; final byte [ ] [ ] codeLength = huffmanStageDecoder . tableCodeLengths ; alphaSize = huffmanStageDecoder . alphabetSize ; int currGroup ; int currLength = huffmanStageDecoder . currentLength ; int currAlpha = <int> ; boolean modifyLength = huffmanStageDecoder . modifyLength ; boolean saveStateAndReturn = false ; loop : for ( currGroup = huffmanStageDecoder . currentGroup ; currGroup < totalTables ; currGroup + + ) { if ( ! reader . hasReadableBits ( <int> ) ) { saveStateAndReturn = true ; break ; } if ( currLength < <int> ) { currLength = reader . readBits ( <int> ) ; } for ( currAlpha = huffmanStageDecoder . currentAlpha ; currAlpha < alphaSize ; currAlpha + + ) { if ( ! reader . isReadable ( ) ) { saveStateAndReturn = true ; break loop ; } while ( modifyLength | | reader . readBoolean ( ) ) { if ( ! reader . isReadable ( ) ) { modifyLength = true ; saveStateAndReturn = true ; break loop ; } currLength + = reader . readBoolean ( ) ? - <int> : <int> ; modifyLength = false ; if ( ! reader . isReadable ( ) ) { saveStateAndReturn = true ; break loop ; } } codeLength [ currGroup ] [ currAlpha ] = ( byte ) currLength ; } currLength = - <int> ; currAlpha = huffmanStageDecoder . currentAlpha = <int> ; modifyLength = false ; } if ( saveStateAndReturn ) { huffmanStageDecoder . currentGroup = currGroup ; huffmanStageDecoder . currentLength = currLength ; huffmanStageDecoder . currentAlpha = currAlpha ; huffmanStageDecoder . modifyLength = modifyLength ; return ; } huffmanStageDecoder . createHuffmanDecodingTables ( ) ; currentState = State . DECODE_HUFFMAN_DATA ; case DECODE_HUFFMAN_DATA : blockDecompressor = this . blockDecompressor ; final int oldReaderIndex = in . readerIndex ( ) ; final boolean decoded = blockDecompressor . decodeHuffmanData ( this . huffmanStageDecoder ) ; if ( ! decoded ) { return ; } if ( in . readerIndex ( ) = = oldReaderIndex & & in . isReadable ( ) ) { reader . refill ( ) ; } final int blockLength = blockDecompressor . blockLength ( ) ; final ByteBuf uncompressed = ctx . alloc ( ) . buffer ( blockLength ) ; boolean success = false ; try { int uncByte ; while ( ( uncByte = blockDecompressor . read ( ) ) > = <int> ) { uncompressed . writeByte ( uncByte ) ; } int currentBlockCRC = blockDecompressor . checkCRC ( ) ; streamCRC = ( streamCRC < < <int> | streamCRC > > > <int> ) ^ currentBlockCRC ; out . add ( uncompressed ) ; success = true ; } finally { if ( ! success ) { uncompressed . release ( ) ; } } currentState = State . INIT_BLOCK ; break ; case EOF : in . skipBytes ( in . readableBytes ( ) ) ; return ; default : throw new IllegalStateException ( ) ; } } } public boolean isClosed ( ) { return currentState = = State . EOF ; } } 
