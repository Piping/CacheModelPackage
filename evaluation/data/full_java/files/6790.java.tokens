package org . elasticsearch . index . store ; import org . apache . lucene . store . StoreRateLimiting ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . index . AbstractIndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardPath ; public class IndexStore extends AbstractIndexComponent { public static final String INDEX_STORE_THROTTLE_TYPE = <str> ; public static final String INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC = <str> ; protected final IndexStoreConfig indexStoreConfig ; private volatile String rateLimitingType ; private volatile ByteSizeValue rateLimitingThrottle ; private volatile boolean nodeRateLimiting ; private final StoreRateLimiting rateLimiting = new StoreRateLimiting ( ) ; public IndexStore ( IndexSettings indexSettings , IndexStoreConfig indexStoreConfig ) { super ( indexSettings ) ; this . indexStoreConfig = indexStoreConfig ; this . rateLimitingType = indexSettings . getSettings ( ) . get ( INDEX_STORE_THROTTLE_TYPE , <str> ) ; if ( rateLimitingType . equalsIgnoreCase ( <str> ) ) { nodeRateLimiting = true ; } else { nodeRateLimiting = false ; rateLimiting . setType ( rateLimitingType ) ; } this . rateLimitingThrottle = indexSettings . getSettings ( ) . getAsBytesSize ( INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC , new ByteSizeValue ( <int> ) ) ; rateLimiting . setMaxRate ( rateLimitingThrottle ) ; logger . debug ( <str> , rateLimitingType , rateLimitingThrottle ) ; } public StoreRateLimiting rateLimiting ( ) { return nodeRateLimiting ? indexStoreConfig . getNodeRateLimiter ( ) : this . rateLimiting ; } public DirectoryService newDirectoryService ( ShardPath path ) { return new FsDirectoryService ( indexSettings , this , path ) ; } public void onRefreshSettings ( Settings settings ) { String rateLimitingType = settings . get ( INDEX_STORE_THROTTLE_TYPE , IndexStore . this . rateLimitingType ) ; if ( ! rateLimitingType . equals ( IndexStore . this . rateLimitingType ) ) { logger . info ( <str> , IndexStore . this . rateLimitingType , rateLimitingType ) ; if ( rateLimitingType . equalsIgnoreCase ( <str> ) ) { IndexStore . this . rateLimitingType = rateLimitingType ; IndexStore . this . nodeRateLimiting = true ; } else { StoreRateLimiting . Type . fromString ( rateLimitingType ) ; IndexStore . this . rateLimitingType = rateLimitingType ; IndexStore . this . nodeRateLimiting = false ; IndexStore . this . rateLimiting . setType ( rateLimitingType ) ; } } ByteSizeValue rateLimitingThrottle = settings . getAsBytesSize ( INDEX_STORE_THROTTLE_MAX_BYTES_PER_SEC , IndexStore . this . rateLimitingThrottle ) ; if ( ! rateLimitingThrottle . equals ( IndexStore . this . rateLimitingThrottle ) ) { logger . info ( <str> , IndexStore . this . rateLimitingThrottle , rateLimitingThrottle , IndexStore . this . rateLimitingType ) ; IndexStore . this . rateLimitingThrottle = rateLimitingThrottle ; IndexStore . this . rateLimiting . setMaxRate ( rateLimitingThrottle ) ; } } } 
