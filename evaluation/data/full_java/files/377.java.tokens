package org . apache . cassandra . db . compaction ; import java . util . * ; import com . google . common . base . Throwables ; import com . google . common . collect . ImmutableMap ; import com . google . common . base . Predicate ; import com . google . common . collect . Iterables ; import com . google . common . util . concurrent . RateLimiter ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . SSTableMultiWriter ; import org . apache . cassandra . io . sstable . SimpleSSTableMultiWriter ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Memtable ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . utils . JVMStabilityInspector ; public abstract class AbstractCompactionStrategy { private static final Logger logger = LoggerFactory . getLogger ( AbstractCompactionStrategy . class ) ; protected static final float DEFAULT_TOMBSTONE_THRESHOLD = <float> ; protected static final long DEFAULT_TOMBSTONE_COMPACTION_INTERVAL = <int> ; protected static final boolean DEFAULT_UNCHECKED_TOMBSTONE_COMPACTION_OPTION = false ; protected static final String TOMBSTONE_THRESHOLD_OPTION = <str> ; protected static final String TOMBSTONE_COMPACTION_INTERVAL_OPTION = <str> ; protected static final String UNCHECKED_TOMBSTONE_COMPACTION_OPTION = <str> ; protected static final String COMPACTION_ENABLED = <str> ; public static final String ONLY_PURGE_REPAIRED_TOMBSTONES = <str> ; protected Map < String , String > options ; protected final ColumnFamilyStore cfs ; protected float tombstoneThreshold ; protected long tombstoneCompactionInterval ; protected boolean uncheckedTombstoneCompaction ; protected boolean disableTombstoneCompactions = false ; private final Directories directories ; protected boolean isActive = false ; protected AbstractCompactionStrategy ( ColumnFamilyStore cfs , Map < String , String > options ) { assert cfs ! = null ; this . cfs = cfs ; this . options = ImmutableMap . copyOf ( options ) ; try { validateOptions ( options ) ; String optionValue = options . get ( TOMBSTONE_THRESHOLD_OPTION ) ; tombstoneThreshold = optionValue = = null ? DEFAULT_TOMBSTONE_THRESHOLD : Float . parseFloat ( optionValue ) ; optionValue = options . get ( TOMBSTONE_COMPACTION_INTERVAL_OPTION ) ; tombstoneCompactionInterval = optionValue = = null ? DEFAULT_TOMBSTONE_COMPACTION_INTERVAL : Long . parseLong ( optionValue ) ; optionValue = options . get ( UNCHECKED_TOMBSTONE_COMPACTION_OPTION ) ; uncheckedTombstoneCompaction = optionValue = = null ? DEFAULT_UNCHECKED_TOMBSTONE_COMPACTION_OPTION : Boolean . parseBoolean ( optionValue ) ; if ( ! shouldBeEnabled ( ) ) this . disable ( ) ; } catch ( ConfigurationException e ) { logger . warn ( <str> , e . getMessage ( ) ) ; tombstoneThreshold = DEFAULT_TOMBSTONE_THRESHOLD ; tombstoneCompactionInterval = DEFAULT_TOMBSTONE_COMPACTION_INTERVAL ; uncheckedTombstoneCompaction = DEFAULT_UNCHECKED_TOMBSTONE_COMPACTION_OPTION ; } directories = new Directories ( cfs . metadata , Directories . dataDirectories ) ; } public Directories getDirectories ( ) { return directories ; } public synchronized void pause ( ) { isActive = false ; } public synchronized void resume ( ) { isActive = true ; } public void startup ( ) { isActive = true ; } public void shutdown ( ) { isActive = false ; } public abstract AbstractCompactionTask getNextBackgroundTask ( final int gcBefore ) ; public abstract Collection < AbstractCompactionTask > getMaximalTask ( final int gcBefore , boolean splitOutput ) ; public abstract AbstractCompactionTask getUserDefinedTask ( Collection < SSTableReader > sstables , final int gcBefore ) ; public AbstractCompactionTask getCompactionTask ( LifecycleTransaction txn , final int gcBefore , long maxSSTableBytes ) { return new CompactionTask ( cfs , txn , gcBefore ) ; } public abstract int getEstimatedRemainingTasks ( ) ; public abstract long getMaxSSTableBytes ( ) ; public void enable ( ) { } public void disable ( ) { } public boolean isAffectedByMeteredFlusher ( ) { return true ; } public long getMemtableReservedSize ( ) { return <int> ; } public void replaceFlushed ( Memtable memtable , Collection < SSTableReader > sstables ) { cfs . getTracker ( ) . replaceFlushed ( memtable , sstables ) ; if ( sstables ! = null & & ! sstables . isEmpty ( ) ) CompactionManager . instance . submitBackground ( cfs ) ; } public static Iterable < SSTableReader > filterSuspectSSTables ( Iterable < SSTableReader > originalCandidates ) { return Iterables . filter ( originalCandidates , new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader sstable ) { return ! sstable . isMarkedSuspect ( ) ; } } ) ; } @SuppressWarnings ( <str> ) public ScannerList getScanners ( Collection < SSTableReader > sstables , Range < Token > range ) { RateLimiter limiter = CompactionManager . instance . getRateLimiter ( ) ; ArrayList < ISSTableScanner > scanners = new ArrayList < ISSTableScanner > ( ) ; try { for ( SSTableReader sstable : sstables ) scanners . add ( sstable . getScanner ( range , limiter ) ) ; } catch ( Throwable t ) { try { new ScannerList ( scanners ) . close ( ) ; } catch ( Throwable t2 ) { t . addSuppressed ( t2 ) ; } throw t ; } return new ScannerList ( scanners ) ; } public boolean shouldDefragment ( ) { return false ; } public String getName ( ) { return getClass ( ) . getSimpleName ( ) ; } public synchronized void replaceSSTables ( Collection < SSTableReader > removed , Collection < SSTableReader > added ) { for ( SSTableReader remove : removed ) removeSSTable ( remove ) ; for ( SSTableReader add : added ) addSSTable ( add ) ; } public abstract void addSSTable ( SSTableReader added ) ; public abstract void removeSSTable ( SSTableReader sstable ) ; public static class ScannerList implements AutoCloseable { public final List < ISSTableScanner > scanners ; public ScannerList ( List < ISSTableScanner > scanners ) { this . scanners = scanners ; } public void close ( ) { Throwable t = null ; for ( ISSTableScanner scanner : scanners ) { try { scanner . close ( ) ; } catch ( Throwable t2 ) { JVMStabilityInspector . inspectThrowable ( t2 ) ; if ( t = = null ) t = t2 ; else t . addSuppressed ( t2 ) ; } } if ( t ! = null ) throw Throwables . propagate ( t ) ; } } public ScannerList getScanners ( Collection < SSTableReader > toCompact ) { return getScanners ( toCompact , null ) ; } protected boolean worthDroppingTombstones ( SSTableReader sstable , int gcBefore ) { if ( disableTombstoneCompactions ) return false ; if ( System . currentTimeMillis ( ) < sstable . getCreationTimeFor ( Component . DATA ) + tombstoneCompactionInterval * <int> ) return false ; double droppableRatio = sstable . getEstimatedDroppableTombstoneRatio ( gcBefore ) ; if ( droppableRatio < = tombstoneThreshold ) return false ; if ( uncheckedTombstoneCompaction ) return true ; Collection < SSTableReader > overlaps = cfs . getOverlappingSSTables ( SSTableSet . CANONICAL , Collections . singleton ( sstable ) ) ; if ( overlaps . isEmpty ( ) ) { return true ; } else if ( CompactionController . getFullyExpiredSSTables ( cfs , Collections . singleton ( sstable ) , overlaps , gcBefore ) . size ( ) > <int> ) { return true ; } else { if ( sstable . getIndexSummarySize ( ) < <int> ) { return false ; } long keys = sstable . estimatedKeys ( ) ; Set < Range < Token > > ranges = new HashSet < Range < Token > > ( overlaps . size ( ) ) ; for ( SSTableReader overlap : overlaps ) ranges . add ( new Range < > ( overlap . first . getToken ( ) , overlap . last . getToken ( ) ) ) ; long remainingKeys = keys - sstable . estimatedKeysForRanges ( ranges ) ; long columns = sstable . getEstimatedColumnCount ( ) . mean ( ) * remainingKeys ; double remainingColumnsRatio = ( ( double ) columns ) / ( sstable . getEstimatedColumnCount ( ) . count ( ) * sstable . getEstimatedColumnCount ( ) . mean ( ) ) ; return remainingColumnsRatio * droppableRatio > tombstoneThreshold ; } } public static Map < String , String > validateOptions ( Map < String , String > options ) throws ConfigurationException { String threshold = options . get ( TOMBSTONE_THRESHOLD_OPTION ) ; if ( threshold ! = null ) { try { float thresholdValue = Float . parseFloat ( threshold ) ; if ( thresholdValue < <int> ) { throw new ConfigurationException ( String . format ( <str> , TOMBSTONE_THRESHOLD_OPTION , thresholdValue ) ) ; } } catch ( NumberFormatException e ) { throw new ConfigurationException ( String . format ( <str> , threshold , TOMBSTONE_THRESHOLD_OPTION ) , e ) ; } } String interval = options . get ( TOMBSTONE_COMPACTION_INTERVAL_OPTION ) ; if ( interval ! = null ) { try { long tombstoneCompactionInterval = Long . parseLong ( interval ) ; if ( tombstoneCompactionInterval < <int> ) { throw new ConfigurationException ( String . format ( <str> , TOMBSTONE_COMPACTION_INTERVAL_OPTION , tombstoneCompactionInterval ) ) ; } } catch ( NumberFormatException e ) { throw new ConfigurationException ( String . format ( <str> , interval , TOMBSTONE_COMPACTION_INTERVAL_OPTION ) , e ) ; } } String unchecked = options . get ( UNCHECKED_TOMBSTONE_COMPACTION_OPTION ) ; if ( unchecked ! = null ) { if ( ! unchecked . equalsIgnoreCase ( <str> ) & & ! unchecked . equalsIgnoreCase ( <str> ) ) throw new ConfigurationException ( String . format ( <str> , UNCHECKED_TOMBSTONE_COMPACTION_OPTION , unchecked ) ) ; } String compactionEnabled = options . get ( COMPACTION_ENABLED ) ; if ( compactionEnabled ! = null ) { if ( ! compactionEnabled . equalsIgnoreCase ( <str> ) & & ! compactionEnabled . equalsIgnoreCase ( <str> ) ) { throw new ConfigurationException ( String . format ( <str> , compactionEnabled ) ) ; } } Map < String , String > uncheckedOptions = new HashMap < String , String > ( options ) ; uncheckedOptions . remove ( TOMBSTONE_THRESHOLD_OPTION ) ; uncheckedOptions . remove ( TOMBSTONE_COMPACTION_INTERVAL_OPTION ) ; uncheckedOptions . remove ( UNCHECKED_TOMBSTONE_COMPACTION_OPTION ) ; uncheckedOptions . remove ( COMPACTION_ENABLED ) ; uncheckedOptions . remove ( ONLY_PURGE_REPAIRED_TOMBSTONES ) ; return uncheckedOptions ; } public boolean shouldBeEnabled ( ) { String optionValue = options . get ( COMPACTION_ENABLED ) ; return optionValue = = null | | Boolean . parseBoolean ( optionValue ) ; } public Collection < Collection < SSTableReader > > groupSSTablesForAntiCompaction ( Collection < SSTableReader > sstablesToGroup ) { int groupSize = <int> ; List < SSTableReader > sortedSSTablesToGroup = new ArrayList < > ( sstablesToGroup ) ; Collections . sort ( sortedSSTablesToGroup , SSTableReader . sstableComparator ) ; Collection < Collection < SSTableReader > > groupedSSTables = new ArrayList < > ( ) ; Collection < SSTableReader > currGroup = new ArrayList < > ( ) ; for ( SSTableReader sstable : sortedSSTablesToGroup ) { currGroup . add ( sstable ) ; if ( currGroup . size ( ) = = groupSize ) { groupedSSTables . add ( currGroup ) ; currGroup = new ArrayList < > ( ) ; } } if ( currGroup . size ( ) ! = <int> ) groupedSSTables . add ( currGroup ) ; return groupedSSTables ; } public SSTableMultiWriter createSSTableMultiWriter ( Descriptor descriptor , long keyCount , long repairedAt , MetadataCollector meta , SerializationHeader header , Collection < Index > indexes , LifecycleTransaction txn ) { return SimpleSSTableMultiWriter . create ( descriptor , keyCount , repairedAt , cfs . metadata , meta , header , indexes , txn ) ; } } 
