package io . netty . microbench . http2 . hpack ; import io . netty . handler . codec . http2 . hpack . Encoder ; import io . netty . microbench . util . AbstractMicrobenchmark ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . BenchmarkMode ; import org . openjdk . jmh . annotations . Level ; import org . openjdk . jmh . annotations . Mode ; import org . openjdk . jmh . annotations . Param ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . infra . Blackhole ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . util . List ; public class EncoderBenchmark extends AbstractMicrobenchmark { @Param public HeadersSize size ; @Param ( { <str> } ) public int maxTableSize ; @Param ( { <str> , <str> } ) public boolean sensitive ; @Param ( { <str> , <str> } ) public boolean duplicates ; @Param ( { <str> , <str> } ) public boolean limitToAscii ; private List < Header > headers ; private ByteArrayOutputStream outputStream ; @Setup ( Level . Trial ) public void setup ( ) { headers = Util . headers ( size , limitToAscii ) ; outputStream = size . newOutputStream ( ) ; } @Benchmark @BenchmarkMode ( Mode . Throughput ) public void encode ( Blackhole bh ) throws IOException { Encoder encoder = new Encoder ( maxTableSize ) ; outputStream . reset ( ) ; if ( duplicates ) { Header header = headers . get ( <int> ) ; for ( int i = <int> ; i < headers . size ( ) ; + + i ) { encoder . encodeHeader ( outputStream , header . name , header . value , sensitive ) ; } } else { for ( int i = <int> ; i < headers . size ( ) ; + + i ) { Header header = headers . get ( i ) ; encoder . encodeHeader ( outputStream , header . name , header . value , sensitive ) ; } } bh . consume ( outputStream ) ; } } 
