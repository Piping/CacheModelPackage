package org . elasticsearch . common . inject . multibindings ; import org . elasticsearch . common . inject . Binder ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . inject . Provider ; import org . elasticsearch . common . inject . TypeLiteral ; import org . elasticsearch . common . inject . binder . LinkedBindingBuilder ; import org . elasticsearch . common . inject . multibindings . Multibinder . RealMultibinder ; import org . elasticsearch . common . inject . spi . Dependency ; import org . elasticsearch . common . inject . spi . ProviderWithDependencies ; import org . elasticsearch . common . inject . util . Types ; import java . lang . annotation . Annotation ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import static java . util . Collections . singleton ; import static org . elasticsearch . common . inject . util . Types . newParameterizedType ; import static org . elasticsearch . common . inject . util . Types . newParameterizedTypeWithOwner ; public abstract class MapBinder < K , V > { private MapBinder ( ) { } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , TypeLiteral < K > keyType , TypeLiteral < V > valueType ) { binder = binder . skipSources ( MapBinder . class , RealMapBinder . class ) ; return newMapBinder ( binder , valueType , Key . get ( mapOf ( keyType , valueType ) ) , Key . get ( mapOfProviderOf ( keyType , valueType ) ) , Multibinder . newSetBinder ( binder , entryOfProviderOf ( keyType , valueType ) ) ) ; } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , Class < K > keyType , Class < V > valueType ) { return newMapBinder ( binder , TypeLiteral . get ( keyType ) , TypeLiteral . get ( valueType ) ) ; } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , TypeLiteral < K > keyType , TypeLiteral < V > valueType , Annotation annotation ) { binder = binder . skipSources ( MapBinder . class , RealMapBinder . class ) ; return newMapBinder ( binder , valueType , Key . get ( mapOf ( keyType , valueType ) , annotation ) , Key . get ( mapOfProviderOf ( keyType , valueType ) , annotation ) , Multibinder . newSetBinder ( binder , entryOfProviderOf ( keyType , valueType ) , annotation ) ) ; } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , Class < K > keyType , Class < V > valueType , Annotation annotation ) { return newMapBinder ( binder , TypeLiteral . get ( keyType ) , TypeLiteral . get ( valueType ) , annotation ) ; } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , TypeLiteral < K > keyType , TypeLiteral < V > valueType , Class < ? extends Annotation > annotationType ) { binder = binder . skipSources ( MapBinder . class , RealMapBinder . class ) ; return newMapBinder ( binder , valueType , Key . get ( mapOf ( keyType , valueType ) , annotationType ) , Key . get ( mapOfProviderOf ( keyType , valueType ) , annotationType ) , Multibinder . newSetBinder ( binder , entryOfProviderOf ( keyType , valueType ) , annotationType ) ) ; } public static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , Class < K > keyType , Class < V > valueType , Class < ? extends Annotation > annotationType ) { return newMapBinder ( binder , TypeLiteral . get ( keyType ) , TypeLiteral . get ( valueType ) , annotationType ) ; } @SuppressWarnings ( <str> ) private static < K , V > TypeLiteral < Map < K , V > > mapOf ( TypeLiteral < K > keyType , TypeLiteral < V > valueType ) { return ( TypeLiteral < Map < K , V > > ) TypeLiteral . get ( Types . mapOf ( keyType . getType ( ) , valueType . getType ( ) ) ) ; } @SuppressWarnings ( <str> ) private static < K , V > TypeLiteral < Map < K , Provider < V > > > mapOfProviderOf ( TypeLiteral < K > keyType , TypeLiteral < V > valueType ) { return ( TypeLiteral < Map < K , Provider < V > > > ) TypeLiteral . get ( Types . mapOf ( keyType . getType ( ) , newParameterizedType ( Provider . class , valueType . getType ( ) ) ) ) ; } @SuppressWarnings ( <str> ) private static < K , V > TypeLiteral < Map . Entry < K , Provider < V > > > entryOfProviderOf ( TypeLiteral < K > keyType , TypeLiteral < V > valueType ) { return ( TypeLiteral < Entry < K , Provider < V > > > ) TypeLiteral . get ( newParameterizedTypeWithOwner ( Map . class , Entry . class , keyType . getType ( ) , Types . providerOf ( valueType . getType ( ) ) ) ) ; } private static < K , V > MapBinder < K , V > newMapBinder ( Binder binder , TypeLiteral < V > valueType , Key < Map < K , V > > mapKey , Key < Map < K , Provider < V > > > providerMapKey , Multibinder < Entry < K , Provider < V > > > entrySetBinder ) { RealMapBinder < K , V > mapBinder = new RealMapBinder < > ( binder , valueType , mapKey , providerMapKey , entrySetBinder ) ; binder . install ( mapBinder ) ; return mapBinder ; } public abstract LinkedBindingBuilder < V > addBinding ( K key ) ; public static final class RealMapBinder < K , V > extends MapBinder < K , V > implements Module { private final TypeLiteral < V > valueType ; private final Key < Map < K , V > > mapKey ; private final Key < Map < K , Provider < V > > > providerMapKey ; private final RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder ; private Binder binder ; private RealMapBinder ( Binder binder , TypeLiteral < V > valueType , Key < Map < K , V > > mapKey , Key < Map < K , Provider < V > > > providerMapKey , Multibinder < Map . Entry < K , Provider < V > > > entrySetBinder ) { this . valueType = valueType ; this . mapKey = mapKey ; this . providerMapKey = providerMapKey ; this . entrySetBinder = ( RealMultibinder < Entry < K , Provider < V > > > ) entrySetBinder ; this . binder = binder ; } @Override public LinkedBindingBuilder < V > addBinding ( K key ) { Multibinder . checkNotNull ( key , <str> ) ; Multibinder . checkConfiguration ( ! isInitialized ( ) , <str> ) ; Key < V > valueKey = Key . get ( valueType , new RealElement ( entrySetBinder . getSetName ( ) ) ) ; entrySetBinder . addBinding ( ) . toInstance ( new MapEntry < > ( key , binder . getProvider ( valueKey ) ) ) ; return binder . bind ( valueKey ) ; } public static class MapBinderProviderWithDependencies < K , V > implements ProviderWithDependencies < Map < K , Provider < V > > > { private Map < K , Provider < V > > providerMap ; @SuppressWarnings ( <str> ) private final RealMapBinder binder ; private final Set < Dependency < ? > > dependencies ; private final Provider < Set < Entry < K , Provider < V > > > > provider ; @SuppressWarnings ( <str> ) MapBinderProviderWithDependencies ( RealMapBinder binder , Set < Dependency < ? > > dependencies , Provider < Set < Entry < K , Provider < V > > > > provider ) { this . binder = binder ; this . dependencies = dependencies ; this . provider = provider ; } @SuppressWarnings ( { <str> , <str> } ) @Inject public void initialize ( ) { binder . binder = null ; Map < K , Provider < V > > providerMapMutable = new LinkedHashMap < > ( ) ; for ( Entry < K , Provider < V > > entry : provider . get ( ) ) { Multibinder . checkConfiguration ( providerMapMutable . put ( entry . getKey ( ) , entry . getValue ( ) ) = = null , <str> , entry . getKey ( ) ) ; } providerMap = Collections . unmodifiableMap ( providerMapMutable ) ; } @Override public Map < K , Provider < V > > get ( ) { return providerMap ; } @Override public Set < Dependency < ? > > getDependencies ( ) { return dependencies ; } } @Override @SuppressWarnings ( { <str> , <str> } ) public void configure ( Binder binder ) { Multibinder . checkConfiguration ( ! isInitialized ( ) , <str> ) ; final Set < Dependency < ? > > dependencies = singleton ( Dependency . get ( entrySetBinder . getSetKey ( ) ) ) ; final Provider < Set < Entry < K , Provider < V > > > > entrySetProvider = binder . getProvider ( entrySetBinder . getSetKey ( ) ) ; binder . bind ( providerMapKey ) . toProvider ( new MapBinderProviderWithDependencies ( RealMapBinder . this , dependencies , entrySetProvider ) ) ; final Provider < Map < K , Provider < V > > > mapProvider = binder . getProvider ( providerMapKey ) ; binder . bind ( mapKey ) . toProvider ( new ProviderWithDependencies < Map < K , V > > ( ) { @Override public Map < K , V > get ( ) { Map < K , V > map = new LinkedHashMap < > ( ) ; for ( Entry < K , Provider < V > > entry : mapProvider . get ( ) . entrySet ( ) ) { V value = entry . getValue ( ) . get ( ) ; K key = entry . getKey ( ) ; Multibinder . checkConfiguration ( value ! = null , <str> , key ) ; map . put ( key , value ) ; } return Collections . unmodifiableMap ( map ) ; } @Override public Set < Dependency < ? > > getDependencies ( ) { return dependencies ; } } ) ; } private boolean isInitialized ( ) { return binder = = null ; } @Override public boolean equals ( Object o ) { return o instanceof RealMapBinder & & ( ( RealMapBinder < ? , ? > ) o ) . mapKey . equals ( mapKey ) ; } @Override public int hashCode ( ) { return mapKey . hashCode ( ) ; } private static final class MapEntry < K , V > implements Map . Entry < K , V > { private final K key ; private final V value ; private MapEntry ( K key , V value ) { this . key = key ; this . value = value ; } @Override public K getKey ( ) { return key ; } @Override public V getValue ( ) { return value ; } @Override public V setValue ( V value ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean equals ( Object obj ) { return obj instanceof Map . Entry & & key . equals ( ( ( Map . Entry < ? , ? > ) obj ) . getKey ( ) ) & & value . equals ( ( ( Map . Entry < ? , ? > ) obj ) . getValue ( ) ) ; } @Override public int hashCode ( ) { return <int> * ( <str> . hashCode ( ) ^ key . hashCode ( ) ) + <int> * ( <str> . hashCode ( ) ^ value . hashCode ( ) ) ; } @Override public String toString ( ) { return <str> + key + <str> + value + <str> ; } } } } 
