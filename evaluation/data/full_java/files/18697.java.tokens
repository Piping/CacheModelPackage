package com . badlogic . gdx . tests . g3d . voxel ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . math . MathUtils ; public class PerlinNoiseGenerator { public static float [ ] [ ] generateWhiteNoise ( int width , int height ) { float [ ] [ ] noise = new float [ width ] [ height ] ; for ( int y = <int> ; y < height ; y + + ) { for ( int x = <int> ; x < width ; x + + ) { noise [ x ] [ y ] = MathUtils . random ( ) ; } } return noise ; } public static float interpolate ( float x0 , float x1 , float alpha ) { return x0 * ( <int> - alpha ) + alpha * x1 ; } public static float [ ] [ ] generateSmoothNoise ( float [ ] [ ] baseNoise , int octave ) { int width = baseNoise . length ; int height = baseNoise [ <int> ] . length ; float [ ] [ ] smoothNoise = new float [ width ] [ height ] ; int samplePeriod = <int> < < octave ; float sampleFrequency = <float> / samplePeriod ; for ( int i = <int> ; i < width ; i + + ) { int sample_i0 = ( i / samplePeriod ) * samplePeriod ; int sample_i1 = ( sample_i0 + samplePeriod ) % width ; float horizontal_blend = ( i - sample_i0 ) * sampleFrequency ; for ( int j = <int> ; j < height ; j + + ) { int sample_j0 = ( j / samplePeriod ) * samplePeriod ; int sample_j1 = ( sample_j0 + samplePeriod ) % height ; float vertical_blend = ( j - sample_j0 ) * sampleFrequency ; float top = interpolate ( baseNoise [ sample_i0 ] [ sample_j0 ] , baseNoise [ sample_i1 ] [ sample_j0 ] , horizontal_blend ) ; float bottom = interpolate ( baseNoise [ sample_i0 ] [ sample_j1 ] , baseNoise [ sample_i1 ] [ sample_j1 ] , horizontal_blend ) ; smoothNoise [ i ] [ j ] = interpolate ( top , bottom , vertical_blend ) ; } } return smoothNoise ; } public static float [ ] [ ] generatePerlinNoise ( float [ ] [ ] baseNoise , int octaveCount ) { int width = baseNoise . length ; int height = baseNoise [ <int> ] . length ; float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; float persistance = <float> ; for ( int i = <int> ; i < octaveCount ; i + + ) { smoothNoise [ i ] = generateSmoothNoise ( baseNoise , i ) ; } float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = <float> ; float totalAmplitude = <float> ; for ( int octave = octaveCount - <int> ; octave > = <int> ; octave - - ) { amplitude * = persistance ; totalAmplitude + = amplitude ; for ( int i = <int> ; i < width ; i + + ) { for ( int j = <int> ; j < height ; j + + ) { perlinNoise [ i ] [ j ] + = smoothNoise [ octave ] [ i ] [ j ] * amplitude ; } } } for ( int i = <int> ; i < width ; i + + ) { for ( int j = <int> ; j < height ; j + + ) { perlinNoise [ i ] [ j ] / = totalAmplitude ; } } return perlinNoise ; } public static float [ ] [ ] generatePerlinNoise ( int width , int height , int octaveCount ) { float [ ] [ ] baseNoise = generateWhiteNoise ( width , height ) ; return generatePerlinNoise ( baseNoise , octaveCount ) ; } public static byte [ ] generateHeightMap ( int width , int height , int min , int max , int octaveCount ) { float [ ] [ ] baseNoise = generateWhiteNoise ( width , height ) ; float [ ] [ ] noise = generatePerlinNoise ( baseNoise , octaveCount ) ; byte [ ] bytes = new byte [ baseNoise . length * baseNoise [ <int> ] . length ] ; int idx = <int> ; int range = max - min ; for ( int y = <int> ; y < height ; y + + ) { for ( int x = <int> ; x < width ; x + + ) { bytes [ idx + + ] = ( byte ) ( noise [ x ] [ y ] * range + min ) ; } } return bytes ; } public static Pixmap generatePixmap ( int width , int height , int min , int max , int octaveCount ) { byte [ ] bytes = generateHeightMap ( width , height , min , max , octaveCount ) ; Pixmap pixmap = new Pixmap ( width , height , Format . RGBA8888 ) ; for ( int i = <int> , idx = <int> ; i < bytes . length ; i + + ) { byte val = bytes [ i ] ; pixmap . getPixels ( ) . put ( idx + + , val ) ; pixmap . getPixels ( ) . put ( idx + + , val ) ; pixmap . getPixels ( ) . put ( idx + + , val ) ; pixmap . getPixels ( ) . put ( idx + + , ( byte ) <int> ) ; } return pixmap ; } public static void generateVoxels ( VoxelWorld voxelWorld , int min , int max , int octaveCount ) { byte [ ] heightMap = PerlinNoiseGenerator . generateHeightMap ( voxelWorld . voxelsX , voxelWorld . voxelsZ , min , max , octaveCount ) ; int idx = <int> ; for ( int z = <int> ; z < voxelWorld . voxelsZ ; z + + ) { for ( int x = <int> ; x < voxelWorld . voxelsX ; x + + ) { voxelWorld . setColumn ( x , heightMap [ idx + + ] , z , ( byte ) <int> ) ; } } } } 
