package com . google . common . collect ; import static com . google . common . collect . MapMakerInternalMap . Strength . STRONG ; import static com . google . common . collect . MapMakerInternalMap . Strength . WEAK ; import static com . google . common . testing . SerializableTester . reserializeAndAssert ; import static java . util . Arrays . asList ; import static org . easymock . EasyMock . eq ; import static org . easymock . EasyMock . expect ; import static org . easymock . EasyMock . isA ; import com . google . common . base . Equivalence ; import com . google . common . collect . MapMaker . RemovalListener ; import com . google . common . collect . MapMaker . RemovalNotification ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . google . MultisetTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringMultisetGenerator ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . easymock . EasyMock ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; public class ConcurrentHashMultisetTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( concurrentHashMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MultisetTestSuiteBuilder . using ( concurrentSkipListMultisetGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . GENERAL_PURPOSE , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTestSuite ( ConcurrentHashMultisetTest . class ) ; return suite ; } private static TestStringMultisetGenerator concurrentHashMultisetGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { return ConcurrentHashMultiset . create ( asList ( elements ) ) ; } } ; } private static TestStringMultisetGenerator concurrentSkipListMultisetGenerator ( ) { return new TestStringMultisetGenerator ( ) { @Override protected Multiset < String > create ( String [ ] elements ) { Multiset < String > multiset = new ConcurrentHashMultiset < String > ( new ConcurrentSkipListMap < String , AtomicInteger > ( ) ) ; Collections . addAll ( multiset , elements ) ; return multiset ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ; } private static final String KEY = <str> ; ConcurrentMap < String , AtomicInteger > backingMap ; ConcurrentHashMultiset < String > multiset ; @SuppressWarnings ( <str> ) @Override protected void setUp ( ) { backingMap = EasyMock . createMock ( ConcurrentMap . class ) ; expect ( backingMap . isEmpty ( ) ) . andReturn ( true ) ; replay ( ) ; multiset = new ConcurrentHashMultiset < String > ( backingMap ) ; verify ( ) ; reset ( ) ; } public void testCount_elementPresent ( ) { final int COUNT = <int> ; expect ( backingMap . get ( KEY ) ) . andReturn ( new AtomicInteger ( COUNT ) ) ; replay ( ) ; assertEquals ( COUNT , multiset . count ( KEY ) ) ; verify ( ) ; } public void testCount_elementAbsent ( ) { expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; replay ( ) ; assertEquals ( <int> , multiset . count ( KEY ) ) ; verify ( ) ; } public void testAdd_zero ( ) { final int INITIAL_COUNT = <int> ; expect ( backingMap . get ( KEY ) ) . andReturn ( new AtomicInteger ( INITIAL_COUNT ) ) ; replay ( ) ; assertEquals ( INITIAL_COUNT , multiset . add ( KEY , <int> ) ) ; verify ( ) ; } public void testAdd_firstFewWithSuccess ( ) { final int COUNT = <int> ; expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; expect ( backingMap . putIfAbsent ( eq ( KEY ) , isA ( AtomicInteger . class ) ) ) . andReturn ( null ) ; replay ( ) ; assertEquals ( <int> , multiset . add ( KEY , COUNT ) ) ; verify ( ) ; } public void testAdd_laterFewWithSuccess ( ) { int INITIAL_COUNT = <int> ; int COUNT_TO_ADD = <int> ; AtomicInteger initial = new AtomicInteger ( INITIAL_COUNT ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( initial ) ; replay ( ) ; assertEquals ( INITIAL_COUNT , multiset . add ( KEY , COUNT_TO_ADD ) ) ; assertEquals ( INITIAL_COUNT + COUNT_TO_ADD , initial . get ( ) ) ; verify ( ) ; } public void testAdd_laterFewWithOverflow ( ) { final int INITIAL_COUNT = <int> ; final int COUNT_TO_ADD = Integer . MAX_VALUE - INITIAL_COUNT + <int> ; expect ( backingMap . get ( KEY ) ) . andReturn ( new AtomicInteger ( INITIAL_COUNT ) ) ; replay ( ) ; try { multiset . add ( KEY , COUNT_TO_ADD ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } verify ( ) ; } public void testAdd_withFailures ( ) { AtomicInteger existing = new AtomicInteger ( <int> ) ; AtomicInteger existingZero = new AtomicInteger ( <int> ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; expect ( backingMap . putIfAbsent ( eq ( KEY ) , isA ( AtomicInteger . class ) ) ) . andReturn ( existingZero ) ; expect ( backingMap . replace ( eq ( KEY ) , eq ( existingZero ) , isA ( AtomicInteger . class ) ) ) . andReturn ( false ) ; expect ( backingMap . putIfAbsent ( eq ( KEY ) , isA ( AtomicInteger . class ) ) ) . andReturn ( existing ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( existingZero ) ; expect ( backingMap . replace ( eq ( KEY ) , eq ( existingZero ) , isA ( AtomicInteger . class ) ) ) . andReturn ( false ) ; expect ( backingMap . putIfAbsent ( eq ( KEY ) , isA ( AtomicInteger . class ) ) ) . andReturn ( existing ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( existing ) ; replay ( ) ; assertEquals ( multiset . add ( KEY , <int> ) , <int> ) ; assertEquals ( <int> , existing . get ( ) ) ; verify ( ) ; } public void testRemove_zeroFromSome ( ) { final int INITIAL_COUNT = <int> ; expect ( backingMap . get ( KEY ) ) . andReturn ( new AtomicInteger ( INITIAL_COUNT ) ) ; replay ( ) ; assertEquals ( INITIAL_COUNT , multiset . remove ( KEY , <int> ) ) ; verify ( ) ; } public void testRemove_zeroFromNone ( ) { expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; replay ( ) ; assertEquals ( <int> , multiset . remove ( KEY , <int> ) ) ; verify ( ) ; } public void testRemove_nonePresent ( ) { expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; replay ( ) ; assertEquals ( <int> , multiset . remove ( KEY , <int> ) ) ; verify ( ) ; } public void testRemove_someRemaining ( ) { int countToRemove = <int> ; int countRemaining = <int> ; AtomicInteger current = new AtomicInteger ( countToRemove + countRemaining ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( current ) ; replay ( ) ; assertEquals ( countToRemove + countRemaining , multiset . remove ( KEY , countToRemove ) ) ; assertEquals ( countRemaining , current . get ( ) ) ; verify ( ) ; } public void testRemove_noneRemaining ( ) { int countToRemove = <int> ; AtomicInteger current = new AtomicInteger ( countToRemove ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( current ) ; expect ( backingMap . remove ( KEY , current ) ) . andReturn ( false ) ; replay ( ) ; assertEquals ( countToRemove , multiset . remove ( KEY , countToRemove ) ) ; assertEquals ( <int> , current . get ( ) ) ; verify ( ) ; } public void testRemoveExactly ( ) { ConcurrentHashMultiset < String > cms = ConcurrentHashMultiset . create ( ) ; cms . add ( <str> , <int> ) ; cms . add ( <str> , <int> ) ; try { cms . removeExactly ( <str> , - <int> ) ; } catch ( IllegalArgumentException expected ) { } assertTrue ( cms . removeExactly ( <str> , <int> ) ) ; assertEquals ( <int> , cms . count ( <str> ) ) ; assertTrue ( cms . removeExactly ( <str> , <int> ) ) ; assertEquals ( <int> , cms . count ( <str> ) ) ; assertFalse ( cms . removeExactly ( <str> , <int> ) ) ; assertEquals ( <int> , cms . count ( <str> ) ) ; assertTrue ( cms . removeExactly ( <str> , <int> ) ) ; assertEquals ( <int> , cms . count ( <str> ) ) ; assertTrue ( cms . removeExactly ( <str> , <int> ) ) ; assertEquals ( <int> , cms . count ( <str> ) ) ; } public void testIteratorRemove_actualMap ( ) { multiset = ConcurrentHashMultiset . create ( ) ; multiset . add ( KEY ) ; multiset . add ( KEY + <str> ) ; multiset . add ( KEY ) ; int mutations = <int> ; for ( Iterator < String > it = multiset . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) ; it . remove ( ) ; mutations + + ; } assertTrue ( multiset . isEmpty ( ) ) ; assertEquals ( <int> , mutations ) ; } public void testSetCount_basic ( ) { int initialCount = <int> ; int countToSet = <int> ; AtomicInteger current = new AtomicInteger ( initialCount ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( current ) ; replay ( ) ; assertEquals ( initialCount , multiset . setCount ( KEY , countToSet ) ) ; assertEquals ( countToSet , current . get ( ) ) ; verify ( ) ; } public void testSetCount_asRemove ( ) { int countToRemove = <int> ; AtomicInteger current = new AtomicInteger ( countToRemove ) ; expect ( backingMap . get ( KEY ) ) . andReturn ( current ) ; expect ( backingMap . remove ( KEY , current ) ) . andReturn ( true ) ; replay ( ) ; assertEquals ( countToRemove , multiset . setCount ( KEY , <int> ) ) ; assertEquals ( <int> , current . get ( ) ) ; verify ( ) ; } public void testSetCount_0_nonePresent ( ) { expect ( backingMap . get ( KEY ) ) . andReturn ( null ) ; replay ( ) ; assertEquals ( <int> , multiset . setCount ( KEY , <int> ) ) ; verify ( ) ; } public void testCreate ( ) { ConcurrentHashMultiset < Integer > multiset = ConcurrentHashMultiset . create ( ) ; assertTrue ( multiset . isEmpty ( ) ) ; reserializeAndAssert ( multiset ) ; } public void testCreateFromIterable ( ) { Iterable < Integer > iterable = asList ( <int> , <int> , <int> , <int> , <int> ) ; ConcurrentHashMultiset < Integer > multiset = ConcurrentHashMultiset . create ( iterable ) ; assertEquals ( <int> , multiset . count ( <int> ) ) ; reserializeAndAssert ( multiset ) ; } public void testIdentityKeyEquality_strongKeys ( ) { testIdentityKeyEquality ( STRONG ) ; } public void testIdentityKeyEquality_weakKeys ( ) { testIdentityKeyEquality ( WEAK ) ; } private void testIdentityKeyEquality ( MapMakerInternalMap . Strength keyStrength ) { MapMaker mapMaker = new MapMaker ( ) . setKeyStrength ( keyStrength ) . keyEquivalence ( Equivalence . identity ( ) ) ; ConcurrentHashMultiset < String > multiset = ConcurrentHashMultiset . create ( mapMaker ) ; String s1 = new String ( <str> ) ; String s2 = new String ( <str> ) ; assertEquals ( s1 , s2 ) ; assertTrue ( s1 ! = s2 ) ; multiset . add ( s1 ) ; assertTrue ( multiset . contains ( s1 ) ) ; assertFalse ( multiset . contains ( s2 ) ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; multiset . add ( s1 ) ; multiset . add ( s2 , <int> ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; multiset . remove ( s1 ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; } public void testLogicalKeyEquality_strongKeys ( ) { testLogicalKeyEquality ( STRONG ) ; } public void testLogicalKeyEquality_weakKeys ( ) { testLogicalKeyEquality ( WEAK ) ; } private void testLogicalKeyEquality ( MapMakerInternalMap . Strength keyStrength ) { MapMaker mapMaker = new MapMaker ( ) . setKeyStrength ( keyStrength ) . keyEquivalence ( Equivalence . equals ( ) ) ; ConcurrentHashMultiset < String > multiset = ConcurrentHashMultiset . create ( mapMaker ) ; String s1 = new String ( <str> ) ; String s2 = new String ( <str> ) ; assertEquals ( s1 , s2 ) ; multiset . add ( s1 ) ; assertTrue ( multiset . contains ( s1 ) ) ; assertTrue ( multiset . contains ( s2 ) ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; multiset . add ( s2 , <int> ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; multiset . remove ( s1 ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; } public void testSerializationWithMapMaker1 ( ) { MapMaker mapMaker = new MapMaker ( ) ; multiset = ConcurrentHashMultiset . create ( mapMaker ) ; reserializeAndAssert ( multiset ) ; } public void testSerializationWithMapMaker2 ( ) { MapMaker mapMaker = new MapMaker ( ) ; multiset = ConcurrentHashMultiset . create ( mapMaker ) ; multiset . addAll ( ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; reserializeAndAssert ( multiset ) ; } public void testSerializationWithMapMaker3 ( ) { MapMaker mapMaker = new MapMaker ( ) . expireAfterWrite ( <int> , TimeUnit . SECONDS ) ; multiset = ConcurrentHashMultiset . create ( mapMaker ) ; multiset . addAll ( ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; reserializeAndAssert ( multiset ) ; } public void testSerializationWithMapMaker_preservesIdentityKeyEquivalence ( ) { MapMaker mapMaker = new MapMaker ( ) . keyEquivalence ( Equivalence . identity ( ) ) ; ConcurrentHashMultiset < String > multiset = ConcurrentHashMultiset . create ( mapMaker ) ; multiset = reserializeAndAssert ( multiset ) ; String s1 = new String ( <str> ) ; String s2 = new String ( <str> ) ; assertEquals ( s1 , s2 ) ; assertTrue ( s1 ! = s2 ) ; multiset . add ( s1 ) ; assertTrue ( multiset . contains ( s1 ) ) ; assertFalse ( multiset . contains ( s2 ) ) ; assertEquals ( <int> , multiset . count ( s1 ) ) ; assertEquals ( <int> , multiset . count ( s2 ) ) ; } public void testWithMapMakerEvictionListener ( ) { final List < RemovalNotification < String , Number > > notificationQueue = Lists . newArrayList ( ) ; RemovalListener < String , Number > removalListener = new RemovalListener < String , Number > ( ) { @Override public void onRemoval ( RemovalNotification < String , Number > notification ) { notificationQueue . add ( notification ) ; } } ; @SuppressWarnings ( <str> ) MapMaker mapMaker = new MapMaker ( ) . concurrencyLevel ( <int> ) . maximumSize ( <int> ) ; mapMaker . removalListener ( removalListener ) ; ConcurrentHashMultiset < String > multiset = ConcurrentHashMultiset . create ( mapMaker ) ; multiset . add ( <str> , <int> ) ; assertTrue ( multiset . contains ( <str> ) ) ; assertEquals ( <int> , multiset . count ( <str> ) ) ; multiset . add ( <str> , <int> ) ; assertFalse ( multiset . contains ( <str> ) ) ; assertTrue ( multiset . contains ( <str> ) ) ; assertEquals ( <int> , multiset . count ( <str> ) ) ; RemovalNotification < String , Number > notification = Iterables . getOnlyElement ( notificationQueue ) ; assertEquals ( <str> , notification . getKey ( ) ) ; assertEquals ( <int> , notification . getValue ( ) . intValue ( ) ) ; } private void replay ( ) { EasyMock . replay ( backingMap ) ; } private void verify ( ) { EasyMock . verify ( backingMap ) ; } private void reset ( ) { EasyMock . reset ( backingMap ) ; } } 
