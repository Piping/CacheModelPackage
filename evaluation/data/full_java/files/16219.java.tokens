package org . gradle . gradleplugin . foundation ; import org . codehaus . groovy . runtime . StackTraceUtils ; import org . gradle . api . internal . classpath . DefaultGradleDistributionLocator ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . foundation . CommandLineAssistant ; import org . gradle . foundation . ProjectView ; import org . gradle . foundation . TaskView ; import org . gradle . foundation . common . ObserverLord ; import org . gradle . foundation . ipc . basic . ProcessLauncherServer ; import org . gradle . foundation . queue . ExecutionQueue ; import org . gradle . gradleplugin . foundation . favorites . FavoriteTask ; import org . gradle . gradleplugin . foundation . favorites . FavoritesEditor ; import org . gradle . gradleplugin . foundation . request . ExecutionRequest ; import org . gradle . gradleplugin . foundation . request . RefreshTaskListRequest ; import org . gradle . gradleplugin . foundation . request . Request ; import org . gradle . internal . SystemProperties ; import org . gradle . internal . exceptions . LocationAwareException ; import org . gradle . logging . ShowStacktrace ; import org . gradle . util . GUtil ; import java . io . File ; import java . util . * ; public class GradlePluginLord { private final Logger logger = Logging . getLogger ( GradlePluginLord . class ) ; private File gradleHomeDirectory ; private File currentDirectory ; private File customGradleExecutor ; private List < ProjectView > projects = new ArrayList < ProjectView > ( ) ; private FavoritesEditor favoritesEditor ; private QueueManager queueManager = new QueueManager ( ) ; private ShowStacktrace stackTraceLevel = ShowStacktrace . INTERNAL_EXCEPTIONS ; private LogLevel logLevel = LogLevel . LIFECYCLE ; private ObserverLord < GeneralPluginObserver > generalObserverLord = new ObserverLord < GeneralPluginObserver > ( ) ; private ObserverLord < RequestObserver > requestObserverLord = new ObserverLord < RequestObserver > ( ) ; private ObserverLord < SettingsObserver > settingsObserverLord = new ObserverLord < SettingsObserver > ( ) ; private ObserverLord < CommandLineArgumentAlteringListener > commandLineArgumentObserverLord = new ObserverLord < CommandLineArgumentAlteringListener > ( ) ; private long nextRequestID = <int> ; public List < ProjectView > getProjects ( ) { return Collections . unmodifiableList ( projects ) ; } public void setProjects ( final List < ProjectView > newProjects ) { projects . clear ( ) ; if ( newProjects ! = null ) { projects . addAll ( newProjects ) ; } generalObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < GeneralPluginObserver > ( ) { public void notify ( GeneralPluginObserver observer ) { observer . projectsAndTasksReloaded ( newProjects ! = null ) ; } } ) ; } public interface GeneralPluginObserver { public void startingProjectsAndTasksReload ( ) ; public void projectsAndTasksReloaded ( boolean wasSuccessful ) ; } public interface RequestObserver { public void executionRequestAdded ( ExecutionRequest request ) ; public void refreshRequestAdded ( RefreshTaskListRequest request ) ; public void aboutToExecuteRequest ( Request request ) ; public void requestExecutionComplete ( Request request , int result , String output ) ; } public interface SettingsObserver { public void settingsChanged ( ) ; } public GradlePluginLord ( ) { favoritesEditor = new FavoritesEditor ( ) ; currentDirectory = SystemProperties . getInstance ( ) . getCurrentDir ( ) ; String gradleHomeProperty = System . getProperty ( <str> ) ; if ( gradleHomeProperty ! = null ) { gradleHomeDirectory = new File ( gradleHomeProperty ) ; } else { gradleHomeDirectory = new DefaultGradleDistributionLocator ( ) . getGradleHome ( ) ; } } public File getGradleHomeDirectory ( ) { if ( gradleHomeDirectory = = null | | ! gradleHomeDirectory . isDirectory ( ) ) { throw new IllegalArgumentException ( <str> ) ; } return gradleHomeDirectory ; } public void setGradleHomeDirectory ( File gradleHomeDirectory ) { if ( areEqual ( this . gradleHomeDirectory , gradleHomeDirectory ) ) { return ; } this . gradleHomeDirectory = gradleHomeDirectory ; notifySettingsChanged ( ) ; } public File getCurrentDirectory ( ) { return currentDirectory ; } public boolean setCurrentDirectory ( File currentDirectory ) { if ( areEqual ( this . currentDirectory , currentDirectory ) ) { return false ; } this . currentDirectory = currentDirectory ; notifySettingsChanged ( ) ; return true ; } public File getCustomGradleExecutor ( ) { return customGradleExecutor ; } public boolean setCustomGradleExecutor ( File customGradleExecutor ) { if ( areEqual ( this . customGradleExecutor , customGradleExecutor ) ) { return false ; } this . customGradleExecutor = customGradleExecutor ; notifySettingsChanged ( ) ; return true ; } public FavoritesEditor getFavoritesEditor ( ) { return favoritesEditor ; } public void setStackTraceLevel ( ShowStacktrace stackTraceLevel ) { if ( areEqual ( this . stackTraceLevel , stackTraceLevel ) ) { return ; } this . stackTraceLevel = stackTraceLevel ; notifySettingsChanged ( ) ; } public ShowStacktrace getStackTraceLevel ( ) { return stackTraceLevel ; } public LogLevel getLogLevel ( ) { return logLevel ; } public void setLogLevel ( LogLevel logLevel ) { if ( logLevel = = null ) { return ; } if ( areEqual ( this . logLevel , logLevel ) ) { return ; } this . logLevel = logLevel ; notifySettingsChanged ( ) ; } private class ExecutionQueueInteraction implements ExecutionQueue . ExecutionInteraction < Request > { public void execute ( final Request request ) { notifyAboutToExecuteRequest ( request ) ; File currentDirectory = getCurrentDirectory ( ) ; File gradleHomeDirectory = getGradleHomeDirectory ( ) ; File customGradleExecutor = getCustomGradleExecutor ( ) ; ProcessLauncherServer . Protocol serverProtocol = request . createServerProtocol ( logLevel , stackTraceLevel , currentDirectory , gradleHomeDirectory , customGradleExecutor ) ; ProcessLauncherServer server = new ProcessLauncherServer ( serverProtocol ) ; request . setProcessLauncherServer ( server ) ; server . addServerObserver ( new ProcessLauncherServer . ServerObserver ( ) { public void clientExited ( int result , String output ) { queueManager . onComplete ( request ) ; notifyRequestExecutionComplete ( request , result , output ) ; } public void serverExited ( ) { } } , false ) ; server . start ( ) ; } } private void notifyAboutToExecuteRequest ( final Request request ) { requestObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < RequestObserver > ( ) { public void notify ( RequestObserver observer ) { try { observer . aboutToExecuteRequest ( request ) ; } catch ( Exception e ) { logger . error ( <str> + e . getMessage ( ) ) ; } } } ) ; } private void notifyRequestExecutionComplete ( final Request request , final int result , final String output ) { requestObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < RequestObserver > ( ) { public void notify ( RequestObserver observer ) { try { observer . requestExecutionComplete ( request , result , output ) ; } catch ( Exception e ) { logger . error ( <str> + e . getMessage ( ) ) ; } } } ) ; } public void addGeneralPluginObserver ( GeneralPluginObserver observer , boolean inEventQueue ) { generalObserverLord . addObserver ( observer , inEventQueue ) ; } public void removeGeneralPluginObserver ( GeneralPluginObserver observer ) { generalObserverLord . removeObserver ( observer ) ; } public void addRequestObserver ( RequestObserver observer , boolean inEventQueue ) { requestObserverLord . addObserver ( observer , inEventQueue ) ; } public void removeRequestObserver ( RequestObserver observer ) { requestObserverLord . removeObserver ( observer ) ; } public void addSettingsObserver ( SettingsObserver observer , boolean inEventQueue ) { settingsObserverLord . addObserver ( observer , inEventQueue ) ; } public void removeSettingsObserver ( SettingsObserver observer ) { settingsObserverLord . removeObserver ( observer ) ; } private void notifySettingsChanged ( ) { settingsObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < SettingsObserver > ( ) { public void notify ( SettingsObserver observer ) { observer . settingsChanged ( ) ; } } ) ; } private boolean areEqual ( Object object1 , Object object2 ) { if ( object1 = = null | | object2 = = null ) { return object2 = = object1 ; } return object1 . equals ( object2 ) ; } public boolean isSetupComplete ( ) { return getCurrentDirectory ( ) ! = null & & getCurrentDirectory ( ) . exists ( ) ; } public Request addExecutionRequestToQueue ( String fullCommandLine , String displayName ) { return addExecutionRequestToQueue ( fullCommandLine , displayName , false ) ; } public Request addExecutionRequestToQueue ( final TaskView task , boolean forceOutputToBeShown , String . . . additionCommandLineOptions ) { if ( task = = null ) { return null ; } String fullCommandLine = CommandLineAssistant . appendAdditionalCommandLineOptions ( task , additionCommandLineOptions ) ; return addExecutionRequestToQueue ( fullCommandLine , task . getFullTaskName ( ) , forceOutputToBeShown ) ; } public Request addExecutionRequestToQueue ( List < FavoriteTask > favorites ) { if ( favorites . isEmpty ( ) ) { return null ; } FavoriteTask firstFavoriteTask = favorites . get ( <int> ) ; String displayName ; String fullCommandLine ; boolean alwaysShowOutput = firstFavoriteTask . alwaysShowOutput ( ) ; if ( favorites . size ( ) = = <int> ) { displayName = firstFavoriteTask . getDisplayName ( ) ; fullCommandLine = firstFavoriteTask . getFullCommandLine ( ) ; } else { displayName = <str> + firstFavoriteTask . getDisplayName ( ) + <str> ; fullCommandLine = FavoritesEditor . combineFavoriteCommandLines ( favorites ) ; } return addExecutionRequestToQueue ( fullCommandLine , displayName , alwaysShowOutput ) ; } public Request addExecutionRequestToQueue ( String fullCommandLine , String displayName , boolean forceOutputToBeShown ) { if ( fullCommandLine = = null ) { return null ; } fullCommandLine = alterCommandLine ( fullCommandLine ) ; final ExecutionRequest request = new ExecutionRequest ( getNextRequestID ( ) , fullCommandLine , displayName , forceOutputToBeShown , queueManager ) ; requestObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < RequestObserver > ( ) { public void notify ( RequestObserver observer ) { observer . executionRequestAdded ( request ) ; } } ) ; queueManager . addRequestToQueue ( request ) ; return request ; } private synchronized long getNextRequestID ( ) { return nextRequestID + + ; } public Request addRefreshRequestToQueue ( ) { return addRefreshRequestToQueue ( null ) ; } public Request addRefreshRequestToQueue ( String additionalCommandLineArguments ) { String fullCommandLine = ProjectInternal . TASKS_TASK ; if ( additionalCommandLineArguments ! = null ) { fullCommandLine + = <str> + additionalCommandLineArguments ; } fullCommandLine = alterCommandLine ( fullCommandLine ) ; List < Request > currentRequests = queueManager . findRequestsOfType ( RefreshTaskListRequest . TYPE ) ; for ( Request currentRequest : currentRequests ) { if ( currentRequest . getFullCommandLine ( ) . equals ( fullCommandLine ) ) { return currentRequest ; } } final RefreshTaskListRequest request = new RefreshTaskListRequest ( getNextRequestID ( ) , fullCommandLine , queueManager , this ) ; queueManager . addRequestToQueue ( request ) ; requestObserverLord . notifyObservers ( new ObserverLord . ObserverNotification < RequestObserver > ( ) { public void notify ( RequestObserver observer ) { observer . refreshRequestAdded ( request ) ; } } ) ; return request ; } private String alterCommandLine ( String fullCommandLine ) { CommandLineArgumentAlteringNotification notification = new CommandLineArgumentAlteringNotification ( fullCommandLine ) ; commandLineArgumentObserverLord . notifyObservers ( notification ) ; return notification . getFullCommandLine ( ) ; } private class CommandLineArgumentAlteringNotification implements ObserverLord . ObserverNotification < CommandLineArgumentAlteringListener > { private StringBuilder fullCommandLineBuilder ; private CommandLineArgumentAlteringNotification ( String fullCommandLine ) { this . fullCommandLineBuilder = new StringBuilder ( fullCommandLine ) ; } public void notify ( CommandLineArgumentAlteringListener observer ) { String additions = observer . getAdditionalCommandLineArguments ( fullCommandLineBuilder . toString ( ) ) ; if ( additions ! = null ) { fullCommandLineBuilder . append ( <str> ) . append ( additions ) ; } } public String getFullCommandLine ( ) { return fullCommandLineBuilder . toString ( ) ; } } public void addCommandLineArgumentAlteringListener ( CommandLineArgumentAlteringListener listener ) { commandLineArgumentObserverLord . addObserver ( listener , false ) ; } public void removeCommandLineArgumentAlteringListener ( CommandLineArgumentAlteringListener listener ) { commandLineArgumentObserverLord . removeObserver ( listener ) ; } public static String getGradleExceptionMessage ( Throwable failure , ShowStacktrace stackTraceLevel ) { if ( failure = = null ) { return <str> ; } Formatter formatter = new Formatter ( ) ; formatter . format ( <str> ) ; if ( stackTraceLevel = = ShowStacktrace . INTERNAL_EXCEPTIONS ) { formatter . format ( <str> ) ; } if ( failure ! = null ) { formatter . format ( <str> ) ; if ( failure instanceof LocationAwareException ) { LocationAwareException scriptException = ( LocationAwareException ) failure ; formatter . format ( <str> , scriptException . getLocation ( ) ) ; formatter . format ( <str> , scriptException . getCause ( ) . getMessage ( ) ) ; for ( Throwable cause : scriptException . getReportableCauses ( ) ) { formatter . format ( <str> , getMessage ( cause ) ) ; } } else { formatter . format ( <str> , getMessage ( failure ) ) ; } if ( stackTraceLevel ! = ShowStacktrace . INTERNAL_EXCEPTIONS ) { formatter . format ( <str> ) ; if ( stackTraceLevel = = ShowStacktrace . ALWAYS_FULL ) { return formatter . toString ( ) + getStackTraceAsText ( failure ) ; } return formatter . toString ( ) + getStackTraceAsText ( StackTraceUtils . deepSanitize ( failure ) ) ; } } return formatter . toString ( ) ; } private static String getStackTraceAsText ( Throwable t ) { StringBuilder builder = new StringBuilder ( ) ; StackTraceElement [ ] stackTraceElements = t . getStackTrace ( ) ; for ( int index = <int> ; index < stackTraceElements . length ; index + + ) { StackTraceElement stackTraceElement = stackTraceElements [ index ] ; builder . append ( <str> ) . append ( stackTraceElement . toString ( ) ) . append ( <str> ) ; } return builder . toString ( ) ; } private static String getMessage ( Throwable throwable ) { String message = throwable . getMessage ( ) ; if ( ! GUtil . isTrue ( message ) ) { message = String . format ( <str> , throwable . getClass ( ) . getName ( ) ) ; } if ( throwable . getCause ( ) ! = null ) { message + = <str> + getMessage ( throwable . getCause ( ) ) ; } return message ; } public boolean isBusy ( ) { return ! queueManager . findRequestsOfType ( ExecutionRequest . TYPE ) . isEmpty ( ) ; } private class QueueManager implements ExecutionQueue . RequestCancellation { private final Object lock = new Object ( ) ; private final ExecutionQueue < Request > executionQueue = new ExecutionQueue < Request > ( new ExecutionQueueInteraction ( ) ) ; private final Set < Request > currentlyExecutingRequests = new HashSet < Request > ( ) ; private List < Request > findRequestsOfType ( Request . Type type ) { List < Request > requests = new ArrayList < Request > ( ) ; synchronized ( lock ) { for ( Request request : currentlyExecutingRequests ) { if ( request . getType ( ) = = type ) { requests . add ( request ) ; } } } return requests ; } public void onCancel ( ExecutionQueue . Request request ) { executionQueue . removeRequestFromQueue ( request ) ; synchronized ( lock ) { currentlyExecutingRequests . remove ( request ) ; } } public void onComplete ( Request request ) { synchronized ( lock ) { currentlyExecutingRequests . remove ( request ) ; } } public void addRequestToQueue ( Request request ) { synchronized ( lock ) { currentlyExecutingRequests . add ( request ) ; } executionQueue . addRequestToQueue ( request ) ; } } } 
