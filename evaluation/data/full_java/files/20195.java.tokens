package io . netty . channel ; import io . netty . util . internal . StringUtil ; import java . net . SocketAddress ; import static io . netty . channel . DefaultChannelPipeline . * ; public final class ChannelHandlerInvokerUtil { public static void invokeChannelRegisteredNow ( ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelRegistered ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelUnregisteredNow ( ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelUnregistered ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelActiveNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelActive ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelInactiveNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelInactive ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeExceptionCaughtNow ( final ChannelHandlerContext ctx , final Throwable cause ) { try { ctx . handler ( ) . exceptionCaught ( ctx , cause ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , t ) ; logger . warn ( <str> , cause ) ; } } } public static void invokeUserEventTriggeredNow ( final ChannelHandlerContext ctx , final Object event ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . userEventTriggered ( ctx , event ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelReadNow ( final ChannelHandlerContext ctx , final Object msg ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelRead ( ctx , msg ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelReadCompleteNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelReadComplete ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeChannelWritabilityChangedNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelInboundHandler ) ctx . handler ( ) ) . channelWritabilityChanged ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeBindNow ( final ChannelHandlerContext ctx , final SocketAddress localAddress , final ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . bind ( ctx , localAddress , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeConnectNow ( final ChannelHandlerContext ctx , final SocketAddress remoteAddress , final SocketAddress localAddress , final ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . connect ( ctx , remoteAddress , localAddress , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeDisconnectNow ( final ChannelHandlerContext ctx , final ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . disconnect ( ctx , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeCloseNow ( final ChannelHandlerContext ctx , final ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . close ( ctx , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeDeregisterNow ( final ChannelHandlerContext ctx , final ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . deregister ( ctx , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeReadNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . read ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static void invokeWriteNow ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . write ( ctx , msg , promise ) ; } catch ( Throwable t ) { notifyOutboundHandlerException ( t , promise ) ; } } public static void invokeFlushNow ( final ChannelHandlerContext ctx ) { try { ( ( ChannelOutboundHandler ) ctx . handler ( ) ) . flush ( ctx ) ; } catch ( Throwable t ) { notifyHandlerException ( ctx , t ) ; } } public static boolean validatePromise ( ChannelHandlerContext ctx , ChannelPromise promise , boolean allowVoidPromise ) { if ( ctx = = null ) { throw new NullPointerException ( <str> ) ; } if ( promise = = null ) { throw new NullPointerException ( <str> ) ; } if ( promise . isDone ( ) ) { if ( promise . isCancelled ( ) ) { return false ; } throw new IllegalArgumentException ( <str> + promise ) ; } if ( promise . channel ( ) ! = ctx . channel ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , promise . channel ( ) , ctx . channel ( ) ) ) ; } if ( promise . getClass ( ) = = DefaultChannelPromise . class ) { return true ; } if ( ! allowVoidPromise & & promise instanceof VoidChannelPromise ) { throw new IllegalArgumentException ( StringUtil . simpleClassName ( VoidChannelPromise . class ) + <str> ) ; } if ( promise instanceof AbstractChannel . CloseFuture ) { throw new IllegalArgumentException ( StringUtil . simpleClassName ( AbstractChannel . CloseFuture . class ) + <str> ) ; } return true ; } private static void notifyHandlerException ( ChannelHandlerContext ctx , Throwable cause ) { if ( inExceptionCaught ( cause ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> + <str> , cause ) ; } return ; } invokeExceptionCaughtNow ( ctx , cause ) ; } private static void notifyOutboundHandlerException ( Throwable cause , ChannelPromise promise ) { if ( ! promise . tryFailure ( cause ) & & ! ( promise instanceof VoidChannelPromise ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , promise , cause ) ; } } } private static boolean inExceptionCaught ( Throwable cause ) { do { StackTraceElement [ ] trace = cause . getStackTrace ( ) ; if ( trace ! = null ) { for ( StackTraceElement t : trace ) { if ( t = = null ) { break ; } if ( <str> . equals ( t . getMethodName ( ) ) ) { return true ; } } } cause = cause . getCause ( ) ; } while ( cause ! = null ) ; return false ; } private ChannelHandlerInvokerUtil ( ) { } } 
