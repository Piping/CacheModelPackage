package org . elasticsearch . gateway ; import com . carrotsearch . hppc . ObjectFloatHashMap ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . action . FailedNodeException ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . NodeEnvironment ; import java . nio . file . Path ; public class Gateway extends AbstractComponent implements ClusterStateListener { private final ClusterService clusterService ; private final NodeEnvironment nodeEnv ; private final GatewayMetaState metaState ; private final TransportNodesListGatewayMetaState listGatewayMetaState ; private final String initialMeta ; private final ClusterName clusterName ; @Inject public Gateway ( Settings settings , ClusterService clusterService , NodeEnvironment nodeEnv , GatewayMetaState metaState , TransportNodesListGatewayMetaState listGatewayMetaState , ClusterName clusterName ) { super ( settings ) ; this . clusterService = clusterService ; this . nodeEnv = nodeEnv ; this . metaState = metaState ; this . listGatewayMetaState = listGatewayMetaState ; this . clusterName = clusterName ; clusterService . addLast ( this ) ; this . initialMeta = settings . get ( <str> , settings . get ( <str> , settings . get ( <str> , <str> ) ) ) ; } public void performStateRecovery ( final GatewayStateRecoveredListener listener ) throws GatewayException { ObjectHashSet < String > nodesIds = new ObjectHashSet < > ( clusterService . state ( ) . nodes ( ) . masterNodes ( ) . keys ( ) ) ; logger . trace ( <str> , nodesIds ) ; TransportNodesListGatewayMetaState . NodesGatewayMetaState nodesState = listGatewayMetaState . list ( nodesIds . toArray ( String . class ) , null ) . actionGet ( ) ; int requiredAllocation = calcRequiredAllocations ( this . initialMeta , nodesIds . size ( ) ) ; if ( nodesState . failures ( ) . length > <int> ) { for ( FailedNodeException failedNodeException : nodesState . failures ( ) ) { logger . warn ( <str> , failedNodeException ) ; } } ObjectFloatHashMap < String > indices = new ObjectFloatHashMap < > ( ) ; MetaData electedGlobalState = null ; int found = <int> ; for ( TransportNodesListGatewayMetaState . NodeGatewayMetaState nodeState : nodesState ) { if ( nodeState . metaData ( ) = = null ) { continue ; } found + + ; if ( electedGlobalState = = null ) { electedGlobalState = nodeState . metaData ( ) ; } else if ( nodeState . metaData ( ) . version ( ) > electedGlobalState . version ( ) ) { electedGlobalState = nodeState . metaData ( ) ; } for ( ObjectCursor < IndexMetaData > cursor : nodeState . metaData ( ) . indices ( ) . values ( ) ) { indices . addTo ( cursor . value . getIndex ( ) , <int> ) ; } } if ( found < requiredAllocation ) { listener . onFailure ( <str> + found + <str> + requiredAllocation + <str> ) ; return ; } MetaData . Builder metaDataBuilder = MetaData . builder ( electedGlobalState ) . removeAllIndices ( ) ; assert ! indices . containsKey ( null ) ; final Object [ ] keys = indices . keys ; for ( int i = <int> ; i < keys . length ; i + + ) { if ( keys [ i ] ! = null ) { String index = ( String ) keys [ i ] ; IndexMetaData electedIndexMetaData = null ; int indexMetaDataCount = <int> ; for ( TransportNodesListGatewayMetaState . NodeGatewayMetaState nodeState : nodesState ) { if ( nodeState . metaData ( ) = = null ) { continue ; } IndexMetaData indexMetaData = nodeState . metaData ( ) . index ( index ) ; if ( indexMetaData = = null ) { continue ; } if ( electedIndexMetaData = = null ) { electedIndexMetaData = indexMetaData ; } else if ( indexMetaData . getVersion ( ) > electedIndexMetaData . getVersion ( ) ) { electedIndexMetaData = indexMetaData ; } indexMetaDataCount + + ; } if ( electedIndexMetaData ! = null ) { if ( indexMetaDataCount < requiredAllocation ) { logger . debug ( <str> , index , indexMetaDataCount , requiredAllocation ) ; } metaDataBuilder . put ( electedIndexMetaData , false ) ; } } } ClusterState . Builder builder = ClusterState . builder ( clusterName ) ; builder . metaData ( metaDataBuilder ) ; listener . onSuccess ( builder . build ( ) ) ; } protected int calcRequiredAllocations ( final String setting , final int nodeCount ) { int requiredAllocation = <int> ; try { if ( <str> . equals ( setting ) ) { if ( nodeCount > <int> ) { requiredAllocation = ( nodeCount / <int> ) + <int> ; } } else if ( <str> . equals ( setting ) | | <str> . equals ( setting ) ) { if ( nodeCount > <int> ) { requiredAllocation = ( ( <int> + nodeCount ) / <int> ) ; } } else if ( <str> . equals ( setting ) ) { requiredAllocation = <int> ; } else if ( <str> . equals ( setting ) | | <str> . equals ( setting ) ) { requiredAllocation = nodeCount ; } else if ( <str> . equals ( setting ) | | <str> . equals ( setting ) ) { if ( nodeCount > <int> ) { requiredAllocation = nodeCount - <int> ; } } else { requiredAllocation = Integer . parseInt ( setting ) ; } } catch ( Exception e ) { logger . warn ( <str> , setting ) ; } return requiredAllocation ; } public void reset ( ) throws Exception { try { Path [ ] dataPaths = nodeEnv . nodeDataPaths ( ) ; logger . trace ( <str> , ( Object ) dataPaths ) ; IOUtils . rm ( dataPaths ) ; } catch ( Exception ex ) { logger . debug ( <str> , ex ) ; } } @Override public void clusterChanged ( final ClusterChangedEvent event ) { metaState . clusterChanged ( event ) ; } public interface GatewayStateRecoveredListener { void onSuccess ( ClusterState build ) ; void onFailure ( String s ) ; } } 
