package org . elasticsearch . test . rest . section ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . test . rest . RestTestExecutionContext ; import org . elasticsearch . test . rest . client . RestException ; import org . elasticsearch . test . rest . client . RestResponse ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . common . collect . Tuple . tuple ; import static org . elasticsearch . test . hamcrest . RegexMatcher . matches ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . notNullValue ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class DoSection implements ExecutableSection { private static final ESLogger logger = Loggers . getLogger ( DoSection . class ) ; private String catchParam ; private ApiCallSection apiCallSection ; public String getCatch ( ) { return catchParam ; } public void setCatch ( String catchParam ) { this . catchParam = catchParam ; } public ApiCallSection getApiCallSection ( ) { return apiCallSection ; } public void setApiCallSection ( ApiCallSection apiCallSection ) { this . apiCallSection = apiCallSection ; } @Override public void execute ( RestTestExecutionContext executionContext ) throws IOException { if ( <str> . equals ( catchParam ) ) { logger . info ( <str> ) ; return ; } try { RestResponse restResponse = executionContext . callApi ( apiCallSection . getApi ( ) , apiCallSection . getParams ( ) , apiCallSection . getBodies ( ) , apiCallSection . getHeaders ( ) ) ; if ( Strings . hasLength ( catchParam ) ) { String catchStatusCode ; if ( catches . containsKey ( catchParam ) ) { catchStatusCode = catches . get ( catchParam ) . v1 ( ) ; } else if ( catchParam . startsWith ( <str> ) & & catchParam . endsWith ( <str> ) ) { catchStatusCode = <str> ; } else { throw new UnsupportedOperationException ( <str> + catchParam + <str> ) ; } fail ( formatStatusCodeMessage ( restResponse , catchStatusCode ) ) ; } } catch ( RestException e ) { if ( ! Strings . hasLength ( catchParam ) ) { fail ( formatStatusCodeMessage ( e . restResponse ( ) , <str> ) ) ; } else if ( catches . containsKey ( catchParam ) ) { assertStatusCode ( e . restResponse ( ) ) ; } else if ( catchParam . length ( ) > <int> & & catchParam . startsWith ( <str> ) & & catchParam . endsWith ( <str> ) ) { assertThat ( formatStatusCodeMessage ( e . restResponse ( ) , <str> ) , e . statusCode ( ) , greaterThanOrEqualTo ( <int> ) ) ; Object error = executionContext . response ( <str> ) ; assertThat ( <str> , error , notNullValue ( ) ) ; String regex = catchParam . substring ( <int> , catchParam . length ( ) - <int> ) ; assertThat ( <str> , error . toString ( ) , matches ( regex ) ) ; } else { throw new UnsupportedOperationException ( <str> + catchParam + <str> ) ; } } } private void assertStatusCode ( RestResponse restResponse ) { Tuple < String , org . hamcrest . Matcher < Integer > > stringMatcherTuple = catches . get ( catchParam ) ; assertThat ( formatStatusCodeMessage ( restResponse , stringMatcherTuple . v1 ( ) ) , restResponse . getStatusCode ( ) , stringMatcherTuple . v2 ( ) ) ; } private String formatStatusCodeMessage ( RestResponse restResponse , String expected ) { return <str> + expected + <str> + apiCallSection . getApi ( ) + <str> + restResponse . getStatusCode ( ) + <str> + restResponse . getReasonPhrase ( ) + <str> + restResponse . getBodyAsString ( ) + <str> ; } private static Map < String , Tuple < String , org . hamcrest . Matcher < Integer > > > catches = new HashMap < > ( ) ; static { catches . put ( <str> , tuple ( <str> , equalTo ( <int> ) ) ) ; catches . put ( <str> , tuple ( <str> , equalTo ( <int> ) ) ) ; catches . put ( <str> , tuple ( <str> , equalTo ( <int> ) ) ) ; catches . put ( <str> , tuple ( <str> , equalTo ( <int> ) ) ) ; catches . put ( <str> , tuple ( <str> , allOf ( greaterThanOrEqualTo ( <int> ) , not ( equalTo ( <int> ) ) , not ( equalTo ( <int> ) ) , not ( equalTo ( <int> ) ) , not ( equalTo ( <int> ) ) ) ) ) ; } } 
