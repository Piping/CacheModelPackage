package com . google . common . base ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . io . IOException ; import java . util . AbstractList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @GwtCompatible public class Joiner { @CheckReturnValue public static Joiner on ( String separator ) { return new Joiner ( separator ) ; } @CheckReturnValue public static Joiner on ( char separator ) { return new Joiner ( String . valueOf ( separator ) ) ; } private final String separator ; private Joiner ( String separator ) { this . separator = checkNotNull ( separator ) ; } private Joiner ( Joiner prototype ) { this . separator = prototype . separator ; } public < A extends Appendable > A appendTo ( A appendable , Iterable < ? > parts ) throws IOException { return appendTo ( appendable , parts . iterator ( ) ) ; } public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable ) ; if ( parts . hasNext ( ) ) { appendable . append ( toString ( parts . next ( ) ) ) ; while ( parts . hasNext ( ) ) { appendable . append ( separator ) ; appendable . append ( toString ( parts . next ( ) ) ) ; } } return appendable ; } public final < A extends Appendable > A appendTo ( A appendable , Object [ ] parts ) throws IOException { return appendTo ( appendable , Arrays . asList ( parts ) ) ; } public final < A extends Appendable > A appendTo ( A appendable , @Nullable Object first , @Nullable Object second , Object . . . rest ) throws IOException { return appendTo ( appendable , iterable ( first , second , rest ) ) ; } public final StringBuilder appendTo ( StringBuilder builder , Iterable < ? > parts ) { return appendTo ( builder , parts . iterator ( ) ) ; } public final StringBuilder appendTo ( StringBuilder builder , Iterator < ? > parts ) { try { appendTo ( ( Appendable ) builder , parts ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; } public final StringBuilder appendTo ( StringBuilder builder , Object [ ] parts ) { return appendTo ( builder , Arrays . asList ( parts ) ) ; } public final StringBuilder appendTo ( StringBuilder builder , @Nullable Object first , @Nullable Object second , Object . . . rest ) { return appendTo ( builder , iterable ( first , second , rest ) ) ; } @CheckReturnValue public final String join ( Iterable < ? > parts ) { return join ( parts . iterator ( ) ) ; } @CheckReturnValue public final String join ( Iterator < ? > parts ) { return appendTo ( new StringBuilder ( ) , parts ) . toString ( ) ; } @CheckReturnValue public final String join ( Object [ ] parts ) { return join ( Arrays . asList ( parts ) ) ; } @CheckReturnValue public final String join ( @Nullable Object first , @Nullable Object second , Object . . . rest ) { return join ( iterable ( first , second , rest ) ) ; } @CheckReturnValue public Joiner useForNull ( final String nullText ) { checkNotNull ( nullText ) ; return new Joiner ( this ) { @Override CharSequence toString ( @Nullable Object part ) { return ( part = = null ) ? nullText : Joiner . this . toString ( part ) ; } @Override public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public Joiner skipNulls ( ) { throw new UnsupportedOperationException ( <str> ) ; } } ; } @CheckReturnValue public Joiner skipNulls ( ) { return new Joiner ( this ) { @Override public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable , <str> ) ; checkNotNull ( parts , <str> ) ; while ( parts . hasNext ( ) ) { Object part = parts . next ( ) ; if ( part ! = null ) { appendable . append ( Joiner . this . toString ( part ) ) ; break ; } } while ( parts . hasNext ( ) ) { Object part = parts . next ( ) ; if ( part ! = null ) { appendable . append ( separator ) ; appendable . append ( Joiner . this . toString ( part ) ) ; } } return appendable ; } @Override public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public MapJoiner withKeyValueSeparator ( String kvs ) { throw new UnsupportedOperationException ( <str> ) ; } } ; } @CheckReturnValue public MapJoiner withKeyValueSeparator ( String keyValueSeparator ) { return new MapJoiner ( this , keyValueSeparator ) ; } public static final class MapJoiner { private final Joiner joiner ; private final String keyValueSeparator ; private MapJoiner ( Joiner joiner , String keyValueSeparator ) { this . joiner = joiner ; this . keyValueSeparator = checkNotNull ( keyValueSeparator ) ; } public < A extends Appendable > A appendTo ( A appendable , Map < ? , ? > map ) throws IOException { return appendTo ( appendable , map . entrySet ( ) ) ; } public StringBuilder appendTo ( StringBuilder builder , Map < ? , ? > map ) { return appendTo ( builder , map . entrySet ( ) ) ; } @CheckReturnValue public String join ( Map < ? , ? > map ) { return join ( map . entrySet ( ) ) ; } @Beta public < A extends Appendable > A appendTo ( A appendable , Iterable < ? extends Entry < ? , ? > > entries ) throws IOException { return appendTo ( appendable , entries . iterator ( ) ) ; } @Beta public < A extends Appendable > A appendTo ( A appendable , Iterator < ? extends Entry < ? , ? > > parts ) throws IOException { checkNotNull ( appendable ) ; if ( parts . hasNext ( ) ) { Entry < ? , ? > entry = parts . next ( ) ; appendable . append ( joiner . toString ( entry . getKey ( ) ) ) ; appendable . append ( keyValueSeparator ) ; appendable . append ( joiner . toString ( entry . getValue ( ) ) ) ; while ( parts . hasNext ( ) ) { appendable . append ( joiner . separator ) ; Entry < ? , ? > e = parts . next ( ) ; appendable . append ( joiner . toString ( e . getKey ( ) ) ) ; appendable . append ( keyValueSeparator ) ; appendable . append ( joiner . toString ( e . getValue ( ) ) ) ; } } return appendable ; } @Beta public StringBuilder appendTo ( StringBuilder builder , Iterable < ? extends Entry < ? , ? > > entries ) { return appendTo ( builder , entries . iterator ( ) ) ; } @Beta public StringBuilder appendTo ( StringBuilder builder , Iterator < ? extends Entry < ? , ? > > entries ) { try { appendTo ( ( Appendable ) builder , entries ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; } @Beta @CheckReturnValue public String join ( Iterable < ? extends Entry < ? , ? > > entries ) { return join ( entries . iterator ( ) ) ; } @Beta @CheckReturnValue public String join ( Iterator < ? extends Entry < ? , ? > > entries ) { return appendTo ( new StringBuilder ( ) , entries ) . toString ( ) ; } @CheckReturnValue public MapJoiner useForNull ( String nullText ) { return new MapJoiner ( joiner . useForNull ( nullText ) , keyValueSeparator ) ; } } CharSequence toString ( Object part ) { checkNotNull ( part ) ; return ( part instanceof CharSequence ) ? ( CharSequence ) part : part . toString ( ) ; } private static Iterable < Object > iterable ( final Object first , final Object second , final Object [ ] rest ) { checkNotNull ( rest ) ; return new AbstractList < Object > ( ) { @Override public int size ( ) { return rest . length + <int> ; } @Override public Object get ( int index ) { switch ( index ) { case <int> : return first ; case <int> : return second ; default : return rest [ index - <int> ] ; } } } ; } } 
