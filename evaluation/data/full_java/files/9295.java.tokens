package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . base . Supplier ; import com . google . common . collect . Maps . EntryTransformer ; import com . google . j2objc . annotations . Weak ; import com . google . j2objc . annotations . WeakOuter ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . AbstractCollection ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedSet ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public final class Multimaps { private Multimaps ( ) { } public static < K , V > Multimap < K , V > newMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends Collection < V > > factory ) { return new CustomMultimap < K , V > ( map , factory ) ; } private static class CustomMultimap < K , V > extends AbstractMapBasedMultimap < K , V > { transient Supplier < ? extends Collection < V > > factory ; CustomMultimap ( Map < K , Collection < V > > map , Supplier < ? extends Collection < V > > factory ) { super ( map ) ; this . factory = checkNotNull ( factory ) ; } @Override protected Collection < V > createCollection ( ) { return factory . get ( ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( factory ) ; stream . writeObject ( backingMap ( ) ) ; } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; factory = ( Supplier < ? extends Collection < V > > ) stream . readObject ( ) ; Map < K , Collection < V > > map = ( Map < K , Collection < V > > ) stream . readObject ( ) ; setMap ( map ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } public static < K , V > ListMultimap < K , V > newListMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends List < V > > factory ) { return new CustomListMultimap < K , V > ( map , factory ) ; } private static class CustomListMultimap < K , V > extends AbstractListMultimap < K , V > { transient Supplier < ? extends List < V > > factory ; CustomListMultimap ( Map < K , Collection < V > > map , Supplier < ? extends List < V > > factory ) { super ( map ) ; this . factory = checkNotNull ( factory ) ; } @Override protected List < V > createCollection ( ) { return factory . get ( ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( factory ) ; stream . writeObject ( backingMap ( ) ) ; } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; factory = ( Supplier < ? extends List < V > > ) stream . readObject ( ) ; Map < K , Collection < V > > map = ( Map < K , Collection < V > > ) stream . readObject ( ) ; setMap ( map ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } public static < K , V > SetMultimap < K , V > newSetMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends Set < V > > factory ) { return new CustomSetMultimap < K , V > ( map , factory ) ; } private static class CustomSetMultimap < K , V > extends AbstractSetMultimap < K , V > { transient Supplier < ? extends Set < V > > factory ; CustomSetMultimap ( Map < K , Collection < V > > map , Supplier < ? extends Set < V > > factory ) { super ( map ) ; this . factory = checkNotNull ( factory ) ; } @Override protected Set < V > createCollection ( ) { return factory . get ( ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( factory ) ; stream . writeObject ( backingMap ( ) ) ; } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; factory = ( Supplier < ? extends Set < V > > ) stream . readObject ( ) ; Map < K , Collection < V > > map = ( Map < K , Collection < V > > ) stream . readObject ( ) ; setMap ( map ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } public static < K , V > SortedSetMultimap < K , V > newSortedSetMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends SortedSet < V > > factory ) { return new CustomSortedSetMultimap < K , V > ( map , factory ) ; } private static class CustomSortedSetMultimap < K , V > extends AbstractSortedSetMultimap < K , V > { transient Supplier < ? extends SortedSet < V > > factory ; transient Comparator < ? super V > valueComparator ; CustomSortedSetMultimap ( Map < K , Collection < V > > map , Supplier < ? extends SortedSet < V > > factory ) { super ( map ) ; this . factory = checkNotNull ( factory ) ; valueComparator = factory . get ( ) . comparator ( ) ; } @Override protected SortedSet < V > createCollection ( ) { return factory . get ( ) ; } @Override public Comparator < ? super V > valueComparator ( ) { return valueComparator ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( factory ) ; stream . writeObject ( backingMap ( ) ) ; } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; factory = ( Supplier < ? extends SortedSet < V > > ) stream . readObject ( ) ; valueComparator = factory . get ( ) . comparator ( ) ; Map < K , Collection < V > > map = ( Map < K , Collection < V > > ) stream . readObject ( ) ; setMap ( map ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } public static < K , V , M extends Multimap < K , V > > M invertFrom ( Multimap < ? extends V , ? extends K > source , M dest ) { checkNotNull ( dest ) ; for ( Map . Entry < ? extends V , ? extends K > entry : source . entries ( ) ) { dest . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } return dest ; } public static < K , V > Multimap < K , V > synchronizedMultimap ( Multimap < K , V > multimap ) { return Synchronized . multimap ( multimap , null ) ; } public static < K , V > Multimap < K , V > unmodifiableMultimap ( Multimap < K , V > delegate ) { if ( delegate instanceof UnmodifiableMultimap | | delegate instanceof ImmutableMultimap ) { return delegate ; } return new UnmodifiableMultimap < K , V > ( delegate ) ; } @Deprecated public static < K , V > Multimap < K , V > unmodifiableMultimap ( ImmutableMultimap < K , V > delegate ) { return checkNotNull ( delegate ) ; } private static class UnmodifiableMultimap < K , V > extends ForwardingMultimap < K , V > implements Serializable { final Multimap < K , V > delegate ; transient Collection < Entry < K , V > > entries ; transient Multiset < K > keys ; transient Set < K > keySet ; transient Collection < V > values ; transient Map < K , Collection < V > > map ; UnmodifiableMultimap ( final Multimap < K , V > delegate ) { this . delegate = checkNotNull ( delegate ) ; } @Override protected Multimap < K , V > delegate ( ) { return delegate ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Map < K , Collection < V > > asMap ( ) { Map < K , Collection < V > > result = map ; if ( result = = null ) { result = map = Collections . unmodifiableMap ( Maps . transformValues ( delegate . asMap ( ) , new Function < Collection < V > , Collection < V > > ( ) { @Override public Collection < V > apply ( Collection < V > collection ) { return unmodifiableValueCollection ( collection ) ; } } ) ) ; } return result ; } @Override public Collection < Entry < K , V > > entries ( ) { Collection < Entry < K , V > > result = entries ; if ( result = = null ) { entries = result = unmodifiableEntries ( delegate . entries ( ) ) ; } return result ; } @Override public Collection < V > get ( K key ) { return unmodifiableValueCollection ( delegate . get ( key ) ) ; } @Override public Multiset < K > keys ( ) { Multiset < K > result = keys ; if ( result = = null ) { keys = result = Multisets . unmodifiableMultiset ( delegate . keys ( ) ) ; } return result ; } @Override public Set < K > keySet ( ) { Set < K > result = keySet ; if ( result = = null ) { keySet = result = Collections . unmodifiableSet ( delegate . keySet ( ) ) ; } return result ; } @Override public boolean put ( K key , V value ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( Multimap < ? extends K , ? extends V > multimap ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean remove ( Object key , Object value ) { throw new UnsupportedOperationException ( ) ; } @Override public Collection < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public Collection < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } @Override public Collection < V > values ( ) { Collection < V > result = values ; if ( result = = null ) { values = result = Collections . unmodifiableCollection ( delegate . values ( ) ) ; } return result ; } private static final long serialVersionUID = <int> ; } private static class UnmodifiableListMultimap < K , V > extends UnmodifiableMultimap < K , V > implements ListMultimap < K , V > { UnmodifiableListMultimap ( ListMultimap < K , V > delegate ) { super ( delegate ) ; } @Override public ListMultimap < K , V > delegate ( ) { return ( ListMultimap < K , V > ) super . delegate ( ) ; } @Override public List < V > get ( K key ) { return Collections . unmodifiableList ( delegate ( ) . get ( key ) ) ; } @Override public List < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public List < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } private static final long serialVersionUID = <int> ; } private static class UnmodifiableSetMultimap < K , V > extends UnmodifiableMultimap < K , V > implements SetMultimap < K , V > { UnmodifiableSetMultimap ( SetMultimap < K , V > delegate ) { super ( delegate ) ; } @Override public SetMultimap < K , V > delegate ( ) { return ( SetMultimap < K , V > ) super . delegate ( ) ; } @Override public Set < V > get ( K key ) { return Collections . unmodifiableSet ( delegate ( ) . get ( key ) ) ; } @Override public Set < Map . Entry < K , V > > entries ( ) { return Maps . unmodifiableEntrySet ( delegate ( ) . entries ( ) ) ; } @Override public Set < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public Set < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } private static final long serialVersionUID = <int> ; } private static class UnmodifiableSortedSetMultimap < K , V > extends UnmodifiableSetMultimap < K , V > implements SortedSetMultimap < K , V > { UnmodifiableSortedSetMultimap ( SortedSetMultimap < K , V > delegate ) { super ( delegate ) ; } @Override public SortedSetMultimap < K , V > delegate ( ) { return ( SortedSetMultimap < K , V > ) super . delegate ( ) ; } @Override public SortedSet < V > get ( K key ) { return Collections . unmodifiableSortedSet ( delegate ( ) . get ( key ) ) ; } @Override public SortedSet < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public SortedSet < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } @Override public Comparator < ? super V > valueComparator ( ) { return delegate ( ) . valueComparator ( ) ; } private static final long serialVersionUID = <int> ; } public static < K , V > SetMultimap < K , V > synchronizedSetMultimap ( SetMultimap < K , V > multimap ) { return Synchronized . setMultimap ( multimap , null ) ; } public static < K , V > SetMultimap < K , V > unmodifiableSetMultimap ( SetMultimap < K , V > delegate ) { if ( delegate instanceof UnmodifiableSetMultimap | | delegate instanceof ImmutableSetMultimap ) { return delegate ; } return new UnmodifiableSetMultimap < K , V > ( delegate ) ; } @Deprecated public static < K , V > SetMultimap < K , V > unmodifiableSetMultimap ( ImmutableSetMultimap < K , V > delegate ) { return checkNotNull ( delegate ) ; } public static < K , V > SortedSetMultimap < K , V > synchronizedSortedSetMultimap ( SortedSetMultimap < K , V > multimap ) { return Synchronized . sortedSetMultimap ( multimap , null ) ; } public static < K , V > SortedSetMultimap < K , V > unmodifiableSortedSetMultimap ( SortedSetMultimap < K , V > delegate ) { if ( delegate instanceof UnmodifiableSortedSetMultimap ) { return delegate ; } return new UnmodifiableSortedSetMultimap < K , V > ( delegate ) ; } public static < K , V > ListMultimap < K , V > synchronizedListMultimap ( ListMultimap < K , V > multimap ) { return Synchronized . listMultimap ( multimap , null ) ; } public static < K , V > ListMultimap < K , V > unmodifiableListMultimap ( ListMultimap < K , V > delegate ) { if ( delegate instanceof UnmodifiableListMultimap | | delegate instanceof ImmutableListMultimap ) { return delegate ; } return new UnmodifiableListMultimap < K , V > ( delegate ) ; } @Deprecated public static < K , V > ListMultimap < K , V > unmodifiableListMultimap ( ImmutableListMultimap < K , V > delegate ) { return checkNotNull ( delegate ) ; } private static < V > Collection < V > unmodifiableValueCollection ( Collection < V > collection ) { if ( collection instanceof SortedSet ) { return Collections . unmodifiableSortedSet ( ( SortedSet < V > ) collection ) ; } else if ( collection instanceof Set ) { return Collections . unmodifiableSet ( ( Set < V > ) collection ) ; } else if ( collection instanceof List ) { return Collections . unmodifiableList ( ( List < V > ) collection ) ; } return Collections . unmodifiableCollection ( collection ) ; } private static < K , V > Collection < Entry < K , V > > unmodifiableEntries ( Collection < Entry < K , V > > entries ) { if ( entries instanceof Set ) { return Maps . unmodifiableEntrySet ( ( Set < Entry < K , V > > ) entries ) ; } return new Maps . UnmodifiableEntries < K , V > ( Collections . unmodifiableCollection ( entries ) ) ; } @Beta @SuppressWarnings ( <str> ) public static < K , V > Map < K , List < V > > asMap ( ListMultimap < K , V > multimap ) { return ( Map < K , List < V > > ) ( Map < K , ? > ) multimap . asMap ( ) ; } @Beta @SuppressWarnings ( <str> ) public static < K , V > Map < K , Set < V > > asMap ( SetMultimap < K , V > multimap ) { return ( Map < K , Set < V > > ) ( Map < K , ? > ) multimap . asMap ( ) ; } @Beta @SuppressWarnings ( <str> ) public static < K , V > Map < K , SortedSet < V > > asMap ( SortedSetMultimap < K , V > multimap ) { return ( Map < K , SortedSet < V > > ) ( Map < K , ? > ) multimap . asMap ( ) ; } @Beta public static < K , V > Map < K , Collection < V > > asMap ( Multimap < K , V > multimap ) { return multimap . asMap ( ) ; } public static < K , V > SetMultimap < K , V > forMap ( Map < K , V > map ) { return new MapMultimap < K , V > ( map ) ; } private static class MapMultimap < K , V > extends AbstractMultimap < K , V > implements SetMultimap < K , V > , Serializable { final Map < K , V > map ; MapMultimap ( Map < K , V > map ) { this . map = checkNotNull ( map ) ; } @Override public int size ( ) { return map . size ( ) ; } @Override public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; } @Override public boolean containsValue ( Object value ) { return map . containsValue ( value ) ; } @Override public boolean containsEntry ( Object key , Object value ) { return map . entrySet ( ) . contains ( Maps . immutableEntry ( key , value ) ) ; } @Override public Set < V > get ( final K key ) { return new Sets . ImprovedAbstractSet < V > ( ) { @Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { int i ; @Override public boolean hasNext ( ) { return ( i = = <int> ) & & map . containsKey ( key ) ; } @Override public V next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } i + + ; return map . get ( key ) ; } @Override public void remove ( ) { checkRemove ( i = = <int> ) ; i = - <int> ; map . remove ( key ) ; } } ; } @Override public int size ( ) { return map . containsKey ( key ) ? <int> : <int> ; } } ; } @Override public boolean put ( K key , V value ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( Multimap < ? extends K , ? extends V > multimap ) { throw new UnsupportedOperationException ( ) ; } @Override public Set < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean remove ( Object key , Object value ) { return map . entrySet ( ) . remove ( Maps . immutableEntry ( key , value ) ) ; } @Override public Set < V > removeAll ( Object key ) { Set < V > values = new HashSet < V > ( <int> ) ; if ( ! map . containsKey ( key ) ) { return values ; } values . add ( map . remove ( key ) ) ; return values ; } @Override public void clear ( ) { map . clear ( ) ; } @Override public Set < K > keySet ( ) { return map . keySet ( ) ; } @Override public Collection < V > values ( ) { return map . values ( ) ; } @Override public Set < Entry < K , V > > entries ( ) { return map . entrySet ( ) ; } @Override Iterator < Entry < K , V > > entryIterator ( ) { return map . entrySet ( ) . iterator ( ) ; } @Override Map < K , Collection < V > > createAsMap ( ) { return new AsMap < K , V > ( this ) ; } @Override public int hashCode ( ) { return map . hashCode ( ) ; } private static final long serialVersionUID = <int> ; } public static < K , V1 , V2 > Multimap < K , V2 > transformValues ( Multimap < K , V1 > fromMultimap , final Function < ? super V1 , V2 > function ) { checkNotNull ( function ) ; EntryTransformer < K , V1 , V2 > transformer = Maps . asEntryTransformer ( function ) ; return transformEntries ( fromMultimap , transformer ) ; } public static < K , V1 , V2 > Multimap < K , V2 > transformEntries ( Multimap < K , V1 > fromMap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { return new TransformedEntriesMultimap < K , V1 , V2 > ( fromMap , transformer ) ; } private static class TransformedEntriesMultimap < K , V1 , V2 > extends AbstractMultimap < K , V2 > { final Multimap < K , V1 > fromMultimap ; final EntryTransformer < ? super K , ? super V1 , V2 > transformer ; TransformedEntriesMultimap ( Multimap < K , V1 > fromMultimap , final EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { this . fromMultimap = checkNotNull ( fromMultimap ) ; this . transformer = checkNotNull ( transformer ) ; } Collection < V2 > transform ( K key , Collection < V1 > values ) { Function < ? super V1 , V2 > function = Maps . asValueToValueFunction ( transformer , key ) ; if ( values instanceof List ) { return Lists . transform ( ( List < V1 > ) values , function ) ; } else { return Collections2 . transform ( values , function ) ; } } @Override Map < K , Collection < V2 > > createAsMap ( ) { return Maps . transformEntries ( fromMultimap . asMap ( ) , new EntryTransformer < K , Collection < V1 > , Collection < V2 > > ( ) { @Override public Collection < V2 > transformEntry ( K key , Collection < V1 > value ) { return transform ( key , value ) ; } } ) ; } @Override public void clear ( ) { fromMultimap . clear ( ) ; } @Override public boolean containsKey ( Object key ) { return fromMultimap . containsKey ( key ) ; } @Override Iterator < Entry < K , V2 > > entryIterator ( ) { return Iterators . transform ( fromMultimap . entries ( ) . iterator ( ) , Maps . < K , V1 , V2 > asEntryToEntryFunction ( transformer ) ) ; } @Override public Collection < V2 > get ( final K key ) { return transform ( key , fromMultimap . get ( key ) ) ; } @Override public boolean isEmpty ( ) { return fromMultimap . isEmpty ( ) ; } @Override public Set < K > keySet ( ) { return fromMultimap . keySet ( ) ; } @Override public Multiset < K > keys ( ) { return fromMultimap . keys ( ) ; } @Override public boolean put ( K key , V2 value ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( K key , Iterable < ? extends V2 > values ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean putAll ( Multimap < ? extends K , ? extends V2 > multimap ) { throw new UnsupportedOperationException ( ) ; } @SuppressWarnings ( <str> ) @Override public boolean remove ( Object key , Object value ) { return get ( ( K ) key ) . remove ( value ) ; } @SuppressWarnings ( <str> ) @Override public Collection < V2 > removeAll ( Object key ) { return transform ( ( K ) key , fromMultimap . removeAll ( key ) ) ; } @Override public Collection < V2 > replaceValues ( K key , Iterable < ? extends V2 > values ) { throw new UnsupportedOperationException ( ) ; } @Override public int size ( ) { return fromMultimap . size ( ) ; } @Override Collection < V2 > createValues ( ) { return Collections2 . transform ( fromMultimap . entries ( ) , Maps . < K , V1 , V2 > asEntryToValueFunction ( transformer ) ) ; } } public static < K , V1 , V2 > ListMultimap < K , V2 > transformValues ( ListMultimap < K , V1 > fromMultimap , final Function < ? super V1 , V2 > function ) { checkNotNull ( function ) ; EntryTransformer < K , V1 , V2 > transformer = Maps . asEntryTransformer ( function ) ; return transformEntries ( fromMultimap , transformer ) ; } public static < K , V1 , V2 > ListMultimap < K , V2 > transformEntries ( ListMultimap < K , V1 > fromMap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { return new TransformedEntriesListMultimap < K , V1 , V2 > ( fromMap , transformer ) ; } private static final class TransformedEntriesListMultimap < K , V1 , V2 > extends TransformedEntriesMultimap < K , V1 , V2 > implements ListMultimap < K , V2 > { TransformedEntriesListMultimap ( ListMultimap < K , V1 > fromMultimap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { super ( fromMultimap , transformer ) ; } @Override List < V2 > transform ( K key , Collection < V1 > values ) { return Lists . transform ( ( List < V1 > ) values , Maps . asValueToValueFunction ( transformer , key ) ) ; } @Override public List < V2 > get ( K key ) { return transform ( key , fromMultimap . get ( key ) ) ; } @SuppressWarnings ( <str> ) @Override public List < V2 > removeAll ( Object key ) { return transform ( ( K ) key , fromMultimap . removeAll ( key ) ) ; } @Override public List < V2 > replaceValues ( K key , Iterable < ? extends V2 > values ) { throw new UnsupportedOperationException ( ) ; } } public static < K , V > ImmutableListMultimap < K , V > index ( Iterable < V > values , Function < ? super V , K > keyFunction ) { return index ( values . iterator ( ) , keyFunction ) ; } public static < K , V > ImmutableListMultimap < K , V > index ( Iterator < V > values , Function < ? super V , K > keyFunction ) { checkNotNull ( keyFunction ) ; ImmutableListMultimap . Builder < K , V > builder = ImmutableListMultimap . builder ( ) ; while ( values . hasNext ( ) ) { V value = values . next ( ) ; checkNotNull ( value , values ) ; builder . put ( keyFunction . apply ( value ) , value ) ; } return builder . build ( ) ; } static class Keys < K , V > extends AbstractMultiset < K > { @Weak final Multimap < K , V > multimap ; Keys ( Multimap < K , V > multimap ) { this . multimap = multimap ; } @Override Iterator < Multiset . Entry < K > > entryIterator ( ) { return new TransformedIterator < Map . Entry < K , Collection < V > > , Multiset . Entry < K > > ( multimap . asMap ( ) . entrySet ( ) . iterator ( ) ) { @Override Multiset . Entry < K > transform ( final Map . Entry < K , Collection < V > > backingEntry ) { return new Multisets . AbstractEntry < K > ( ) { @Override public K getElement ( ) { return backingEntry . getKey ( ) ; } @Override public int getCount ( ) { return backingEntry . getValue ( ) . size ( ) ; } } ; } } ; } @Override int distinctElements ( ) { return multimap . asMap ( ) . size ( ) ; } @Override Set < Multiset . Entry < K > > createEntrySet ( ) { return new KeysEntrySet ( ) ; } @WeakOuter class KeysEntrySet extends Multisets . EntrySet < K > { @Override Multiset < K > multiset ( ) { return Keys . this ; } @Override public Iterator < Multiset . Entry < K > > iterator ( ) { return entryIterator ( ) ; } @Override public int size ( ) { return distinctElements ( ) ; } @Override public boolean isEmpty ( ) { return multimap . isEmpty ( ) ; } @Override public boolean contains ( @Nullable Object o ) { if ( o instanceof Multiset . Entry ) { Multiset . Entry < ? > entry = ( Multiset . Entry < ? > ) o ; Collection < V > collection = multimap . asMap ( ) . get ( entry . getElement ( ) ) ; return collection ! = null & & collection . size ( ) = = entry . getCount ( ) ; } return false ; } @Override public boolean remove ( @Nullable Object o ) { if ( o instanceof Multiset . Entry ) { Multiset . Entry < ? > entry = ( Multiset . Entry < ? > ) o ; Collection < V > collection = multimap . asMap ( ) . get ( entry . getElement ( ) ) ; if ( collection ! = null & & collection . size ( ) = = entry . getCount ( ) ) { collection . clear ( ) ; return true ; } } return false ; } } @Override public boolean contains ( @Nullable Object element ) { return multimap . containsKey ( element ) ; } @Override public Iterator < K > iterator ( ) { return Maps . keyIterator ( multimap . entries ( ) . iterator ( ) ) ; } @Override public int count ( @Nullable Object element ) { Collection < V > values = Maps . safeGet ( multimap . asMap ( ) , element ) ; return ( values = = null ) ? <int> : values . size ( ) ; } @Override public int remove ( @Nullable Object element , int occurrences ) { checkNonnegative ( occurrences , <str> ) ; if ( occurrences = = <int> ) { return count ( element ) ; } Collection < V > values = Maps . safeGet ( multimap . asMap ( ) , element ) ; if ( values = = null ) { return <int> ; } int oldCount = values . size ( ) ; if ( occurrences > = oldCount ) { values . clear ( ) ; } else { Iterator < V > iterator = values . iterator ( ) ; for ( int i = <int> ; i < occurrences ; i + + ) { iterator . next ( ) ; iterator . remove ( ) ; } } return oldCount ; } @Override public void clear ( ) { multimap . clear ( ) ; } @Override public Set < K > elementSet ( ) { return multimap . keySet ( ) ; } } abstract static class Entries < K , V > extends AbstractCollection < Map . Entry < K , V > > { abstract Multimap < K , V > multimap ( ) ; @Override public int size ( ) { return multimap ( ) . size ( ) ; } @Override public boolean contains ( @Nullable Object o ) { if ( o instanceof Map . Entry ) { Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) o ; return multimap ( ) . containsEntry ( entry . getKey ( ) , entry . getValue ( ) ) ; } return false ; } @Override public boolean remove ( @Nullable Object o ) { if ( o instanceof Map . Entry ) { Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) o ; return multimap ( ) . remove ( entry . getKey ( ) , entry . getValue ( ) ) ; } return false ; } @Override public void clear ( ) { multimap ( ) . clear ( ) ; } } static final class AsMap < K , V > extends Maps . ViewCachingAbstractMap < K , Collection < V > > { @Weak private final Multimap < K , V > multimap ; AsMap ( Multimap < K , V > multimap ) { this . multimap = checkNotNull ( multimap ) ; } @Override public int size ( ) { return multimap . keySet ( ) . size ( ) ; } @Override protected Set < Entry < K , Collection < V > > > createEntrySet ( ) { return new EntrySet ( ) ; } void removeValuesForKey ( Object key ) { multimap . keySet ( ) . remove ( key ) ; } @WeakOuter class EntrySet extends Maps . EntrySet < K , Collection < V > > { @Override Map < K , Collection < V > > map ( ) { return AsMap . this ; } @Override public Iterator < Entry < K , Collection < V > > > iterator ( ) { return Maps . asMapEntryIterator ( multimap . keySet ( ) , new Function < K , Collection < V > > ( ) { @Override public Collection < V > apply ( K key ) { return multimap . get ( key ) ; } } ) ; } @Override public boolean remove ( Object o ) { if ( ! contains ( o ) ) { return false ; } Map . Entry < ? , ? > entry = ( Map . Entry < ? , ? > ) o ; removeValuesForKey ( entry . getKey ( ) ) ; return true ; } } @SuppressWarnings ( <str> ) @Override public Collection < V > get ( Object key ) { return containsKey ( key ) ? multimap . get ( ( K ) key ) : null ; } @Override public Collection < V > remove ( Object key ) { return containsKey ( key ) ? multimap . removeAll ( key ) : null ; } @Override public Set < K > keySet ( ) { return multimap . keySet ( ) ; } @Override public boolean isEmpty ( ) { return multimap . isEmpty ( ) ; } @Override public boolean containsKey ( Object key ) { return multimap . containsKey ( key ) ; } @Override public void clear ( ) { multimap . clear ( ) ; } } @CheckReturnValue public static < K , V > Multimap < K , V > filterKeys ( Multimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof SetMultimap ) { return filterKeys ( ( SetMultimap < K , V > ) unfiltered , keyPredicate ) ; } else if ( unfiltered instanceof ListMultimap ) { return filterKeys ( ( ListMultimap < K , V > ) unfiltered , keyPredicate ) ; } else if ( unfiltered instanceof FilteredKeyMultimap ) { FilteredKeyMultimap < K , V > prev = ( FilteredKeyMultimap < K , V > ) unfiltered ; return new FilteredKeyMultimap < K , V > ( prev . unfiltered , Predicates . and ( prev . keyPredicate , keyPredicate ) ) ; } else if ( unfiltered instanceof FilteredMultimap ) { FilteredMultimap < K , V > prev = ( FilteredMultimap < K , V > ) unfiltered ; return filterFiltered ( prev , Maps . < K > keyPredicateOnEntries ( keyPredicate ) ) ; } else { return new FilteredKeyMultimap < K , V > ( unfiltered , keyPredicate ) ; } } @CheckReturnValue public static < K , V > SetMultimap < K , V > filterKeys ( SetMultimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof FilteredKeySetMultimap ) { FilteredKeySetMultimap < K , V > prev = ( FilteredKeySetMultimap < K , V > ) unfiltered ; return new FilteredKeySetMultimap < K , V > ( prev . unfiltered ( ) , Predicates . and ( prev . keyPredicate , keyPredicate ) ) ; } else if ( unfiltered instanceof FilteredSetMultimap ) { FilteredSetMultimap < K , V > prev = ( FilteredSetMultimap < K , V > ) unfiltered ; return filterFiltered ( prev , Maps . < K > keyPredicateOnEntries ( keyPredicate ) ) ; } else { return new FilteredKeySetMultimap < K , V > ( unfiltered , keyPredicate ) ; } } @CheckReturnValue public static < K , V > ListMultimap < K , V > filterKeys ( ListMultimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof FilteredKeyListMultimap ) { FilteredKeyListMultimap < K , V > prev = ( FilteredKeyListMultimap < K , V > ) unfiltered ; return new FilteredKeyListMultimap < K , V > ( prev . unfiltered ( ) , Predicates . and ( prev . keyPredicate , keyPredicate ) ) ; } else { return new FilteredKeyListMultimap < K , V > ( unfiltered , keyPredicate ) ; } } @CheckReturnValue public static < K , V > Multimap < K , V > filterValues ( Multimap < K , V > unfiltered , final Predicate < ? super V > valuePredicate ) { return filterEntries ( unfiltered , Maps . < V > valuePredicateOnEntries ( valuePredicate ) ) ; } @CheckReturnValue public static < K , V > SetMultimap < K , V > filterValues ( SetMultimap < K , V > unfiltered , final Predicate < ? super V > valuePredicate ) { return filterEntries ( unfiltered , Maps . < V > valuePredicateOnEntries ( valuePredicate ) ) ; } @CheckReturnValue public static < K , V > Multimap < K , V > filterEntries ( Multimap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; if ( unfiltered instanceof SetMultimap ) { return filterEntries ( ( SetMultimap < K , V > ) unfiltered , entryPredicate ) ; } return ( unfiltered instanceof FilteredMultimap ) ? filterFiltered ( ( FilteredMultimap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntryMultimap < K , V > ( checkNotNull ( unfiltered ) , entryPredicate ) ; } @CheckReturnValue public static < K , V > SetMultimap < K , V > filterEntries ( SetMultimap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; return ( unfiltered instanceof FilteredSetMultimap ) ? filterFiltered ( ( FilteredSetMultimap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntrySetMultimap < K , V > ( checkNotNull ( unfiltered ) , entryPredicate ) ; } private static < K , V > Multimap < K , V > filterFiltered ( FilteredMultimap < K , V > multimap , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( multimap . entryPredicate ( ) , entryPredicate ) ; return new FilteredEntryMultimap < K , V > ( multimap . unfiltered ( ) , predicate ) ; } private static < K , V > SetMultimap < K , V > filterFiltered ( FilteredSetMultimap < K , V > multimap , Predicate < ? super Entry < K , V > > entryPredicate ) { Predicate < Entry < K , V > > predicate = Predicates . and ( multimap . entryPredicate ( ) , entryPredicate ) ; return new FilteredEntrySetMultimap < K , V > ( multimap . unfiltered ( ) , predicate ) ; } static boolean equalsImpl ( Multimap < ? , ? > multimap , @Nullable Object object ) { if ( object = = multimap ) { return true ; } if ( object instanceof Multimap ) { Multimap < ? , ? > that = ( Multimap < ? , ? > ) object ; return multimap . asMap ( ) . equals ( that . asMap ( ) ) ; } return false ; } } 
