package org . apache . cassandra . locator ; import java . net . InetAddress ; import java . util . * ; import java . util . Map . Entry ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . locator . TokenMetadata . Topology ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import com . google . common . collect . Multimap ; public class NetworkTopologyStrategy extends AbstractReplicationStrategy { private final Map < String , Integer > datacenters ; private static final Logger logger = LoggerFactory . getLogger ( NetworkTopologyStrategy . class ) ; public NetworkTopologyStrategy ( String keyspaceName , TokenMetadata tokenMetadata , IEndpointSnitch snitch , Map < String , String > configOptions ) throws ConfigurationException { super ( keyspaceName , tokenMetadata , snitch , configOptions ) ; Map < String , Integer > newDatacenters = new HashMap < String , Integer > ( ) ; if ( configOptions ! = null ) { for ( Entry < String , String > entry : configOptions . entrySet ( ) ) { String dc = entry . getKey ( ) ; if ( dc . equalsIgnoreCase ( <str> ) ) throw new ConfigurationException ( <str> ) ; Integer replicas = Integer . valueOf ( entry . getValue ( ) ) ; newDatacenters . put ( dc , replicas ) ; } } datacenters = Collections . unmodifiableMap ( newDatacenters ) ; logger . trace ( <str> , FBUtilities . toString ( datacenters ) ) ; } private static final class DatacenterEndpoints { Set < InetAddress > endpoints ; Set < Pair < String , String > > racks ; int rfLeft ; int acceptableRackRepeats ; DatacenterEndpoints ( int rf , int rackCount , int nodeCount , Set < InetAddress > endpoints , Set < Pair < String , String > > racks ) { this . endpoints = endpoints ; this . racks = racks ; this . rfLeft = Math . min ( rf , nodeCount ) ; acceptableRackRepeats = rf - rackCount ; } boolean addEndpointAndCheckIfDone ( InetAddress ep , Pair < String , String > location ) { if ( done ( ) ) return false ; if ( racks . add ( location ) ) { - - rfLeft ; boolean added = endpoints . add ( ep ) ; assert added ; return done ( ) ; } if ( acceptableRackRepeats < = <int> ) return false ; if ( ! endpoints . add ( ep ) ) return false ; - - acceptableRackRepeats ; - - rfLeft ; return done ( ) ; } boolean done ( ) { assert rfLeft > = <int> ; return rfLeft = = <int> ; } } public List < InetAddress > calculateNaturalEndpoints ( Token searchToken , TokenMetadata tokenMetadata ) { Set < InetAddress > replicas = new LinkedHashSet < > ( ) ; Set < Pair < String , String > > seenRacks = new HashSet < > ( ) ; Topology topology = tokenMetadata . getTopology ( ) ; Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; assert ! allEndpoints . isEmpty ( ) & & ! racks . isEmpty ( ) : <str> ; int dcsToFill = <int> ; Map < String , DatacenterEndpoints > dcs = new HashMap < > ( datacenters . size ( ) * <int> ) ; for ( Map . Entry < String , Integer > en : datacenters . entrySet ( ) ) { String dc = en . getKey ( ) ; int rf = en . getValue ( ) ; int nodeCount = sizeOrZero ( allEndpoints . get ( dc ) ) ; if ( rf < = <int> | | nodeCount < = <int> ) continue ; DatacenterEndpoints dcEndpoints = new DatacenterEndpoints ( rf , sizeOrZero ( racks . get ( dc ) ) , nodeCount , replicas , seenRacks ) ; dcs . put ( dc , dcEndpoints ) ; + + dcsToFill ; } Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tokenMetadata . sortedTokens ( ) , searchToken , false ) ; while ( dcsToFill > <int> & & tokenIter . hasNext ( ) ) { Token next = tokenIter . next ( ) ; InetAddress ep = tokenMetadata . getEndpoint ( next ) ; Pair < String , String > location = topology . getLocation ( ep ) ; DatacenterEndpoints dcEndpoints = dcs . get ( location . left ) ; if ( dcEndpoints ! = null & & dcEndpoints . addEndpointAndCheckIfDone ( ep , location ) ) - - dcsToFill ; } return new ArrayList < > ( replicas ) ; } private int sizeOrZero ( Multimap < ? , ? > collection ) { return collection ! = null ? collection . asMap ( ) . size ( ) : <int> ; } private int sizeOrZero ( Collection < ? > collection ) { return collection ! = null ? collection . size ( ) : <int> ; } public int getReplicationFactor ( ) { int total = <int> ; for ( int repFactor : datacenters . values ( ) ) total + = repFactor ; return total ; } public int getReplicationFactor ( String dc ) { Integer replicas = datacenters . get ( dc ) ; return replicas = = null ? <int> : replicas ; } public Set < String > getDatacenters ( ) { return datacenters . keySet ( ) ; } public void validateOptions ( ) throws ConfigurationException { for ( Entry < String , String > e : this . configOptions . entrySet ( ) ) { if ( e . getKey ( ) . equalsIgnoreCase ( <str> ) ) throw new ConfigurationException ( <str> ) ; validateReplicationFactor ( e . getValue ( ) ) ; } } public Collection < String > recognizedOptions ( ) { return null ; } } 
