package org . elasticsearch . script ; import org . elasticsearch . common . ContextAndHeaderHolder ; import org . elasticsearch . common . HasContextAndHeaders ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . search . lookup . SearchLookup ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . watcher . ResourceWatcherService ; import org . junit . Before ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . sameInstance ; public class ScriptServiceTests extends ESTestCase { private ResourceWatcherService resourceWatcherService ; private Set < ScriptEngineService > scriptEngineServices ; private Map < String , ScriptEngineService > scriptEnginesByLangMap ; private ScriptContextRegistry scriptContextRegistry ; private ScriptContext [ ] scriptContexts ; private ScriptService scriptService ; private Path scriptsFilePath ; private Settings baseSettings ; private static final Map < ScriptType , ScriptMode > DEFAULT_SCRIPT_MODES = new HashMap < > ( ) ; static { DEFAULT_SCRIPT_MODES . put ( ScriptType . FILE , ScriptMode . ON ) ; DEFAULT_SCRIPT_MODES . put ( ScriptType . INDEXED , ScriptMode . SANDBOX ) ; DEFAULT_SCRIPT_MODES . put ( ScriptType . INLINE , ScriptMode . SANDBOX ) ; } @Before public void setup ( ) throws IOException { Path genericConfigFolder = createTempDir ( ) ; baseSettings = settingsBuilder ( ) . put ( <str> , createTempDir ( ) . toString ( ) ) . put ( <str> , genericConfigFolder ) . build ( ) ; resourceWatcherService = new ResourceWatcherService ( baseSettings , null ) ; scriptEngineServices = newHashSet ( new TestEngineService ( ) ) ; scriptEnginesByLangMap = ScriptModesTests . buildScriptEnginesByLangMap ( scriptEngineServices ) ; int randomInt = randomIntBetween ( <int> , <int> ) ; Map < String , ScriptContext . Plugin > contexts = new HashMap < > ( ) ; for ( int i = <int> ; i < randomInt ; i + + ) { String plugin ; do { plugin = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; } while ( ScriptContextRegistry . RESERVED_SCRIPT_CONTEXTS . contains ( plugin ) ) ; String operation ; do { operation = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; } while ( ScriptContextRegistry . RESERVED_SCRIPT_CONTEXTS . contains ( operation ) ) ; String context = plugin + <str> + operation ; contexts . put ( context , new ScriptContext . Plugin ( plugin , operation ) ) ; } scriptContextRegistry = new ScriptContextRegistry ( contexts . values ( ) ) ; scriptContexts = scriptContextRegistry . scriptContexts ( ) . toArray ( new ScriptContext [ scriptContextRegistry . scriptContexts ( ) . size ( ) ] ) ; logger . info ( <str> ) ; scriptsFilePath = genericConfigFolder . resolve ( <str> ) ; Files . createDirectories ( scriptsFilePath ) ; } private void buildScriptService ( Settings additionalSettings ) throws IOException { Settings finalSettings = Settings . builder ( ) . put ( baseSettings ) . put ( additionalSettings ) . build ( ) ; Environment environment = new Environment ( finalSettings ) ; scriptService = new ScriptService ( finalSettings , environment , scriptEngineServices , resourceWatcherService , scriptContextRegistry ) { @Override String getScriptFromIndex ( String scriptLang , String id , HasContextAndHeaders headersContext ) { return <str> ; } } ; } public void testNotSupportedDisableDynamicSetting ( ) throws IOException { try { buildScriptService ( Settings . builder ( ) . put ( ScriptService . DISABLE_DYNAMIC_SCRIPTING_SETTING , randomUnicodeOfLength ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( ScriptService . DISABLE_DYNAMIC_SCRIPTING_SETTING + <str> ) ) ; } } public void testScriptsWithoutExtensions ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; logger . info ( <str> ) ; Path testFileNoExt = scriptsFilePath . resolve ( <str> ) ; Path testFileWithExt = scriptsFilePath . resolve ( <str> ) ; Streams . copy ( <str> . getBytes ( <str> ) , Files . newOutputStream ( testFileNoExt ) ) ; Streams . copy ( <str> . getBytes ( <str> ) , Files . newOutputStream ( testFileWithExt ) ) ; resourceWatcherService . notifyNow ( ) ; logger . info ( <str> ) ; CompiledScript compiledScript = scriptService . compile ( new Script ( <str> , ScriptType . FILE , <str> , null ) , ScriptContext . Standard . SEARCH , contextAndHeaders ) ; assertThat ( compiledScript . compiled ( ) , equalTo ( ( Object ) <str> ) ) ; logger . info ( <str> ) ; Files . delete ( testFileNoExt ) ; Files . delete ( testFileWithExt ) ; resourceWatcherService . notifyNow ( ) ; logger . info ( <str> ) ; try { scriptService . compile ( new Script ( <str> , ScriptType . FILE , <str> , null ) , ScriptContext . Standard . SEARCH , contextAndHeaders ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } } public void testInlineScriptCompiledOnceCache ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; CompiledScript compiledScript1 = scriptService . compile ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; CompiledScript compiledScript2 = scriptService . compile ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertThat ( compiledScript1 . compiled ( ) , sameInstance ( compiledScript2 . compiled ( ) ) ) ; } public void testInlineScriptCompiledOnceMultipleLangAcronyms ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; CompiledScript compiledScript1 = scriptService . compile ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; CompiledScript compiledScript2 = scriptService . compile ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertThat ( compiledScript1 . compiled ( ) , sameInstance ( compiledScript2 . compiled ( ) ) ) ; } public void testFileScriptCompiledOnceMultipleLangAcronyms ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; createFileScripts ( <str> ) ; CompiledScript compiledScript1 = scriptService . compile ( new Script ( <str> , ScriptType . FILE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; CompiledScript compiledScript2 = scriptService . compile ( new Script ( <str> , ScriptType . FILE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertThat ( compiledScript1 . compiled ( ) , sameInstance ( compiledScript2 . compiled ( ) ) ) ; } public void testDefaultBehaviourFineGrainedSettings ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; Settings . Builder builder = Settings . builder ( ) ; if ( rarely ( ) ) { builder . put ( <str> , randomFrom ( ScriptModesTests . ENABLE_VALUES ) ) ; } if ( rarely ( ) ) { builder . put ( <str> , ScriptMode . SANDBOX ) ; } if ( rarely ( ) ) { builder . put ( <str> , ScriptMode . SANDBOX ) ; } buildScriptService ( builder . build ( ) ) ; createFileScripts ( <str> , <str> , <str> ) ; for ( ScriptContext scriptContext : scriptContexts ) { assertCompileAccepted ( <str> , <str> , ScriptType . INLINE , scriptContext , contextAndHeaders ) ; assertCompileAccepted ( <str> , <str> , ScriptType . INDEXED , scriptContext , contextAndHeaders ) ; assertCompileAccepted ( <str> , <str> , ScriptType . FILE , scriptContext , contextAndHeaders ) ; } } public void testFineGrainedSettings ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; int numScriptSettings = randomIntBetween ( <int> , ScriptType . values ( ) . length ) ; Map < ScriptType , ScriptMode > scriptSourceSettings = new HashMap < > ( ) ; for ( int i = <int> ; i < numScriptSettings ; i + + ) { ScriptType scriptType ; do { scriptType = randomFrom ( ScriptType . values ( ) ) ; } while ( scriptSourceSettings . containsKey ( scriptType ) ) ; scriptSourceSettings . put ( scriptType , randomFrom ( ScriptMode . values ( ) ) ) ; } int numScriptContextSettings = randomIntBetween ( <int> , this . scriptContextRegistry . scriptContexts ( ) . size ( ) ) ; Map < String , ScriptMode > scriptContextSettings = new HashMap < > ( ) ; for ( int i = <int> ; i < numScriptContextSettings ; i + + ) { String scriptContext ; do { scriptContext = randomFrom ( this . scriptContexts ) . getKey ( ) ; } while ( scriptContextSettings . containsKey ( scriptContext ) ) ; scriptContextSettings . put ( scriptContext , randomFrom ( ScriptMode . values ( ) ) ) ; } int numEngineSettings = randomIntBetween ( <int> , <int> ) ; Map < String , ScriptMode > engineSettings = new HashMap < > ( ) ; for ( int i = <int> ; i < numEngineSettings ; i + + ) { String settingKey ; do { ScriptEngineService [ ] scriptEngineServices = this . scriptEngineServices . toArray ( new ScriptEngineService [ this . scriptEngineServices . size ( ) ] ) ; ScriptEngineService scriptEngineService = randomFrom ( scriptEngineServices ) ; ScriptType scriptType = randomFrom ( ScriptType . values ( ) ) ; ScriptContext scriptContext = randomFrom ( this . scriptContexts ) ; settingKey = scriptEngineService . types ( ) [ <int> ] + <str> + scriptType + <str> + scriptContext . getKey ( ) ; } while ( engineSettings . containsKey ( settingKey ) ) ; engineSettings . put ( settingKey , randomFrom ( ScriptMode . values ( ) ) ) ; } Settings . Builder builder = Settings . builder ( ) ; for ( Map . Entry < ScriptType , ScriptMode > entry : scriptSourceSettings . entrySet ( ) ) { switch ( entry . getValue ( ) ) { case ON : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , randomFrom ( ScriptModesTests . ENABLE_VALUES ) ) ; break ; case OFF : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , randomFrom ( ScriptModesTests . DISABLE_VALUES ) ) ; break ; case SANDBOX : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , ScriptMode . SANDBOX ) ; break ; } } for ( Map . Entry < String , ScriptMode > entry : scriptContextSettings . entrySet ( ) ) { switch ( entry . getValue ( ) ) { case ON : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , randomFrom ( ScriptModesTests . ENABLE_VALUES ) ) ; break ; case OFF : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , randomFrom ( ScriptModesTests . DISABLE_VALUES ) ) ; break ; case SANDBOX : builder . put ( ScriptModes . SCRIPT_SETTINGS_PREFIX + entry . getKey ( ) , ScriptMode . SANDBOX ) ; break ; } } for ( Map . Entry < String , ScriptMode > entry : engineSettings . entrySet ( ) ) { int delimiter = entry . getKey ( ) . indexOf ( <str> ) ; String part1 = entry . getKey ( ) . substring ( <int> , delimiter ) ; String part2 = entry . getKey ( ) . substring ( delimiter + <int> ) ; String lang = randomFrom ( scriptEnginesByLangMap . get ( part1 ) . types ( ) ) ; switch ( entry . getValue ( ) ) { case ON : builder . put ( ScriptModes . ENGINE_SETTINGS_PREFIX + <str> + lang + <str> + part2 , randomFrom ( ScriptModesTests . ENABLE_VALUES ) ) ; break ; case OFF : builder . put ( ScriptModes . ENGINE_SETTINGS_PREFIX + <str> + lang + <str> + part2 , randomFrom ( ScriptModesTests . DISABLE_VALUES ) ) ; break ; case SANDBOX : builder . put ( ScriptModes . ENGINE_SETTINGS_PREFIX + <str> + lang + <str> + part2 , ScriptMode . SANDBOX ) ; break ; } } buildScriptService ( builder . build ( ) ) ; createFileScripts ( <str> , <str> , <str> , <str> ) ; for ( ScriptEngineService scriptEngineService : scriptEngineServices ) { for ( ScriptType scriptType : ScriptType . values ( ) ) { String script = scriptType = = ScriptType . FILE ? <str> : <str> ; for ( ScriptContext scriptContext : this . scriptContexts ) { ScriptMode scriptMode = engineSettings . get ( scriptEngineService . types ( ) [ <int> ] + <str> + scriptType + <str> + scriptContext . getKey ( ) ) ; if ( scriptMode = = null ) { scriptMode = scriptContextSettings . get ( scriptContext . getKey ( ) ) ; } if ( scriptMode = = null ) { scriptMode = scriptSourceSettings . get ( scriptType ) ; } if ( scriptMode = = null ) { scriptMode = DEFAULT_SCRIPT_MODES . get ( scriptType ) ; } for ( String lang : scriptEngineService . types ( ) ) { switch ( scriptMode ) { case ON : assertCompileAccepted ( lang , script , scriptType , scriptContext , contextAndHeaders ) ; break ; case OFF : assertCompileRejected ( lang , script , scriptType , scriptContext , contextAndHeaders ) ; break ; case SANDBOX : if ( scriptEngineService . sandboxed ( ) ) { assertCompileAccepted ( lang , script , scriptType , scriptContext , contextAndHeaders ) ; } else { assertCompileRejected ( lang , script , scriptType , scriptContext , contextAndHeaders ) ; } break ; } } } } } } public void testCompileNonRegisteredContext ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; String pluginName ; String unknownContext ; do { pluginName = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; unknownContext = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; } while ( scriptContextRegistry . isSupportedContext ( new ScriptContext . Plugin ( pluginName , unknownContext ) ) ) ; for ( ScriptEngineService scriptEngineService : scriptEngineServices ) { for ( String type : scriptEngineService . types ( ) ) { try { scriptService . compile ( new Script ( <str> , randomFrom ( ScriptType . values ( ) ) , type , null ) , new ScriptContext . Plugin ( pluginName , unknownContext ) , contextAndHeaders ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> + pluginName + <str> + unknownContext + <str> ) ) ; } } } } public void testCompileCountedInCompilationStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; scriptService . compile ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testExecutableCountedInCompilationStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; scriptService . executable ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testSearchCountedInCompilationStats ( ) throws IOException { buildScriptService ( Settings . EMPTY ) ; scriptService . search ( null , new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testMultipleCompilationsCountedInCompilationStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; int numberOfCompilations = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numberOfCompilations ; i + + ) { scriptService . compile ( new Script ( i + <str> + i , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; } assertEquals ( numberOfCompilations , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testCompilationStatsOnCacheHit ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; Settings . Builder builder = Settings . builder ( ) ; builder . put ( ScriptService . SCRIPT_CACHE_SIZE_SETTING , <int> ) ; buildScriptService ( builder . build ( ) ) ; scriptService . executable ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; scriptService . executable ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testFileScriptCountedInCompilationStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; createFileScripts ( <str> ) ; scriptService . compile ( new Script ( <str> , ScriptType . FILE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testIndexedScriptCountedInCompilationStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; buildScriptService ( Settings . EMPTY ) ; scriptService . compile ( new Script ( <str> , ScriptType . INDEXED , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; } public void testCacheEvictionCountedInCacheEvictionsStats ( ) throws IOException { ContextAndHeaderHolder contextAndHeaders = new ContextAndHeaderHolder ( ) ; Settings . Builder builder = Settings . builder ( ) ; builder . put ( ScriptService . SCRIPT_CACHE_SIZE_SETTING , <int> ) ; buildScriptService ( builder . build ( ) ) ; scriptService . executable ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; scriptService . executable ( new Script ( <str> , ScriptType . INLINE , <str> , null ) , randomFrom ( scriptContexts ) , contextAndHeaders ) ; assertEquals ( <int> , scriptService . stats ( ) . getCompilations ( ) ) ; assertEquals ( <int> , scriptService . stats ( ) . getCacheEvictions ( ) ) ; } private void createFileScripts ( String . . . langs ) throws IOException { for ( String lang : langs ) { Path scriptPath = scriptsFilePath . resolve ( <str> + lang ) ; Streams . copy ( <str> . getBytes ( <str> ) , Files . newOutputStream ( scriptPath ) ) ; } resourceWatcherService . notifyNow ( ) ; } private void assertCompileRejected ( String lang , String script , ScriptType scriptType , ScriptContext scriptContext , HasContextAndHeaders contextAndHeaders ) { try { scriptService . compile ( new Script ( script , scriptType , lang , null ) , scriptContext , contextAndHeaders ) ; fail ( <str> + lang + <str> + scriptType + <str> + scriptContext + <str> ) ; } catch ( ScriptException e ) { } } private void assertCompileAccepted ( String lang , String script , ScriptType scriptType , ScriptContext scriptContext , HasContextAndHeaders contextAndHeaders ) { assertThat ( scriptService . compile ( new Script ( script , scriptType , lang , null ) , scriptContext , contextAndHeaders ) , notNullValue ( ) ) ; } public static class TestEngineService implements ScriptEngineService { @Override public String [ ] types ( ) { return new String [ ] { <str> , <str> } ; } @Override public String [ ] extensions ( ) { return new String [ ] { <str> , <str> } ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { return <str> + script ; } @Override public ExecutableScript executable ( final CompiledScript compiledScript , @Nullable Map < String , Object > vars ) { return null ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , @Nullable Map < String , Object > vars ) { return null ; } @Override public void close ( ) { } @Override public void scriptRemoved ( CompiledScript script ) { } } } 
