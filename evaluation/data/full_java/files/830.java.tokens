package org . apache . cassandra . net ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . nio . channels . SocketChannel ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . locator . IEndpointSnitch ; import org . apache . cassandra . metrics . ConnectionMetrics ; import org . apache . cassandra . security . SSLFactory ; import org . apache . cassandra . utils . FBUtilities ; public class OutboundTcpConnectionPool { public static final long LARGE_MESSAGE_THRESHOLD = Long . getLong ( Config . PROPERTY_PREFIX + <str> , <int> * <int> ) ; private final InetAddress id ; private final CountDownLatch started ; public final OutboundTcpConnection smallMessages ; public final OutboundTcpConnection largeMessages ; public final OutboundTcpConnection gossipMessages ; private InetAddress resetEndpoint ; private ConnectionMetrics metrics ; OutboundTcpConnectionPool ( InetAddress remoteEp ) { id = remoteEp ; resetEndpoint = SystemKeyspace . getPreferredIP ( remoteEp ) ; started = new CountDownLatch ( <int> ) ; smallMessages = new OutboundTcpConnection ( this ) ; largeMessages = new OutboundTcpConnection ( this ) ; gossipMessages = new OutboundTcpConnection ( this ) ; } OutboundTcpConnection getConnection ( MessageOut msg ) { if ( Stage . GOSSIP = = msg . getStage ( ) ) return gossipMessages ; return msg . payloadSize ( smallMessages . getTargetVersion ( ) ) > LARGE_MESSAGE_THRESHOLD ? largeMessages : smallMessages ; } void reset ( ) { for ( OutboundTcpConnection conn : new OutboundTcpConnection [ ] { smallMessages , largeMessages , gossipMessages } ) conn . closeSocket ( false ) ; } public void resetToNewerVersion ( int version ) { for ( OutboundTcpConnection conn : new OutboundTcpConnection [ ] { smallMessages , largeMessages , gossipMessages } ) { if ( version > conn . getTargetVersion ( ) ) conn . softCloseSocket ( ) ; } } public void reset ( InetAddress remoteEP ) { SystemKeyspace . updatePreferredIP ( id , remoteEP ) ; resetEndpoint = remoteEP ; for ( OutboundTcpConnection conn : new OutboundTcpConnection [ ] { smallMessages , largeMessages , gossipMessages } ) conn . softCloseSocket ( ) ; metrics . release ( ) ; metrics = new ConnectionMetrics ( resetEndpoint , this ) ; } public long getTimeouts ( ) { return metrics . timeouts . getCount ( ) ; } public void incrementTimeout ( ) { metrics . timeouts . mark ( ) ; } public Socket newSocket ( ) throws IOException { return newSocket ( endPoint ( ) ) ; } public static Socket newSocket ( InetAddress endpoint ) throws IOException { if ( isEncryptedChannel ( endpoint ) ) { if ( Config . getOutboundBindAny ( ) ) return SSLFactory . getSocket ( DatabaseDescriptor . getServerEncryptionOptions ( ) , endpoint , DatabaseDescriptor . getSSLStoragePort ( ) ) ; else return SSLFactory . getSocket ( DatabaseDescriptor . getServerEncryptionOptions ( ) , endpoint , DatabaseDescriptor . getSSLStoragePort ( ) , FBUtilities . getLocalAddress ( ) , <int> ) ; } else { Socket socket = SocketChannel . open ( new InetSocketAddress ( endpoint , DatabaseDescriptor . getStoragePort ( ) ) ) . socket ( ) ; if ( Config . getOutboundBindAny ( ) & & ! socket . isBound ( ) ) socket . bind ( new InetSocketAddress ( FBUtilities . getLocalAddress ( ) , <int> ) ) ; return socket ; } } public InetAddress endPoint ( ) { if ( id . equals ( FBUtilities . getBroadcastAddress ( ) ) ) return FBUtilities . getLocalAddress ( ) ; return resetEndpoint ; } public static boolean isEncryptedChannel ( InetAddress address ) { IEndpointSnitch snitch = DatabaseDescriptor . getEndpointSnitch ( ) ; switch ( DatabaseDescriptor . getServerEncryptionOptions ( ) . internode_encryption ) { case none : return false ; case all : break ; case dc : if ( snitch . getDatacenter ( address ) . equals ( snitch . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ) ) return false ; break ; case rack : if ( snitch . getRack ( address ) . equals ( snitch . getRack ( FBUtilities . getBroadcastAddress ( ) ) ) & & snitch . getDatacenter ( address ) . equals ( snitch . getDatacenter ( FBUtilities . getBroadcastAddress ( ) ) ) ) return false ; break ; } return true ; } public void start ( ) { smallMessages . start ( ) ; largeMessages . start ( ) ; gossipMessages . start ( ) ; metrics = new ConnectionMetrics ( id , this ) ; started . countDown ( ) ; } public void waitForStarted ( ) { if ( started . getCount ( ) = = <int> ) return ; boolean error = false ; try { if ( ! started . await ( <int> , TimeUnit . MINUTES ) ) error = true ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; error = true ; } if ( error ) throw new IllegalStateException ( String . format ( <str> , id . getHostAddress ( ) ) ) ; } public void close ( ) { if ( largeMessages ! = null ) largeMessages . closeSocket ( true ) ; if ( smallMessages ! = null ) smallMessages . closeSocket ( true ) ; if ( gossipMessages ! = null ) gossipMessages . closeSocket ( true ) ; metrics . release ( ) ; } } 
