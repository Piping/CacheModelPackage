package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . net . SocketAddress ; import java . nio . ByteBuffer ; import static io . netty . buffer . Unpooled . * ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class ChannelOutboundBufferTest { @Test public void testEmptyNioBuffers ( ) { TestChannel channel = new TestChannel ( ) ; ChannelOutboundBuffer buffer = new ChannelOutboundBuffer ( channel ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; ByteBuffer [ ] buffers = buffer . nioBuffers ( ) ; assertNotNull ( buffers ) ; for ( ByteBuffer b : buffers ) { assertNull ( b ) ; } assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; release ( buffer ) ; } @Test public void testNioBuffersSingleBacked ( ) { TestChannel channel = new TestChannel ( ) ; ChannelOutboundBuffer buffer = new ChannelOutboundBuffer ( channel ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; ByteBuf buf = copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ; ByteBuffer nioBuf = buf . internalNioBuffer ( <int> , buf . readableBytes ( ) ) ; buffer . addMessage ( buf , buf . readableBytes ( ) , channel . voidPromise ( ) ) ; assertEquals ( <str> , <int> , buffer . nioBufferCount ( ) ) ; buffer . addFlush ( ) ; ByteBuffer [ ] buffers = buffer . nioBuffers ( ) ; assertNotNull ( buffers ) ; assertEquals ( <str> , <int> , buffer . nioBufferCount ( ) ) ; for ( int i = <int> ; i < buffer . nioBufferCount ( ) ; i + + ) { if ( i = = <int> ) { assertEquals ( buffers [ i ] , nioBuf ) ; } else { assertNull ( buffers [ i ] ) ; } } release ( buffer ) ; } @Test public void testNioBuffersExpand ( ) { TestChannel channel = new TestChannel ( ) ; ChannelOutboundBuffer buffer = new ChannelOutboundBuffer ( channel ) ; ByteBuf buf = directBuffer ( ) . writeBytes ( <str> . getBytes ( CharsetUtil . US_ASCII ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { buffer . addMessage ( buf . copy ( ) , buf . readableBytes ( ) , channel . voidPromise ( ) ) ; } assertEquals ( <str> , <int> , buffer . nioBufferCount ( ) ) ; buffer . addFlush ( ) ; ByteBuffer [ ] buffers = buffer . nioBuffers ( ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; for ( int i = <int> ; i < buffer . nioBufferCount ( ) ; i + + ) { assertEquals ( buffers [ i ] , buf . internalNioBuffer ( <int> , buf . readableBytes ( ) ) ) ; } release ( buffer ) ; buf . release ( ) ; } @Test public void testNioBuffersExpand2 ( ) { TestChannel channel = new TestChannel ( ) ; ChannelOutboundBuffer buffer = new ChannelOutboundBuffer ( channel ) ; CompositeByteBuf comp = compositeBuffer ( <int> ) ; ByteBuf buf = directBuffer ( ) . writeBytes ( <str> . getBytes ( CharsetUtil . US_ASCII ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { comp . addComponent ( buf . copy ( ) ) . writerIndex ( comp . writerIndex ( ) + buf . readableBytes ( ) ) ; } buffer . addMessage ( comp , comp . readableBytes ( ) , channel . voidPromise ( ) ) ; assertEquals ( <str> , <int> , buffer . nioBufferCount ( ) ) ; buffer . addFlush ( ) ; ByteBuffer [ ] buffers = buffer . nioBuffers ( ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; for ( int i = <int> ; i < buffer . nioBufferCount ( ) ; i + + ) { if ( i < <int> ) { assertEquals ( buffers [ i ] , buf . internalNioBuffer ( <int> , buf . readableBytes ( ) ) ) ; } else { assertNull ( buffers [ i ] ) ; } } release ( buffer ) ; buf . release ( ) ; } private static void release ( ChannelOutboundBuffer buffer ) { for ( ; ; ) { if ( ! buffer . remove ( ) ) { break ; } } } private static final class TestChannel extends AbstractChannel { private static final ChannelMetadata TEST_METADATA = new ChannelMetadata ( false ) ; private final ChannelConfig config = new DefaultChannelConfig ( this ) ; TestChannel ( ) { super ( null ) ; } @Override protected AbstractUnsafe newUnsafe ( ) { return new TestUnsafe ( ) ; } @Override protected boolean isCompatible ( EventLoop loop ) { return false ; } @Override protected SocketAddress localAddress0 ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void doDisconnect ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void doClose ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void doBeginRead ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override public ChannelConfig config ( ) { return config ; } @Override public boolean isOpen ( ) { return true ; } @Override public boolean isActive ( ) { return true ; } @Override public ChannelMetadata metadata ( ) { return TEST_METADATA ; } final class TestUnsafe extends AbstractUnsafe { @Override public void connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) { throw new UnsupportedOperationException ( ) ; } } } @Test public void testWritability ( ) { final StringBuilder buf = new StringBuilder ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { buf . append ( ctx . channel ( ) . isWritable ( ) ) ; buf . append ( <str> ) ; } } ) ; ch . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; ch . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ch . write ( buffer ( ) . writeZero ( <int> ) ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; ch . unsafe ( ) . outboundBuffer ( ) . addFlush ( ) ; ch . write ( buffer ( ) . writeZero ( <int> ) ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; assertThat ( ch . unsafe ( ) . outboundBuffer ( ) . remove ( ) , is ( true ) ) ; assertThat ( ch . unsafe ( ) . outboundBuffer ( ) . totalPendingWriteBytes ( ) , is ( <int> ) ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; safeClose ( ch ) ; } @Test public void testUserDefinedWritability ( ) { final StringBuilder buf = new StringBuilder ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { buf . append ( ctx . channel ( ) . isWritable ( ) ) ; buf . append ( <str> ) ; } } ) ; ch . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; ch . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ChannelOutboundBuffer cob = ch . unsafe ( ) . outboundBuffer ( ) ; for ( int i = <int> ; i < = <int> ; i + + ) { assertThat ( cob . getUserDefinedWritability ( i ) , is ( true ) ) ; } cob . setUserDefinedWritability ( <int> , false ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , true ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; safeClose ( ch ) ; } @Test public void testUserDefinedWritability2 ( ) { final StringBuilder buf = new StringBuilder ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { buf . append ( ctx . channel ( ) . isWritable ( ) ) ; buf . append ( <str> ) ; } } ) ; ch . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; ch . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ChannelOutboundBuffer cob = ch . unsafe ( ) . outboundBuffer ( ) ; cob . setUserDefinedWritability ( <int> , false ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , false ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , true ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , true ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; safeClose ( ch ) ; } @Test public void testMixedWritability ( ) { final StringBuilder buf = new StringBuilder ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { buf . append ( ctx . channel ( ) . isWritable ( ) ) ; buf . append ( <str> ) ; } } ) ; ch . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; ch . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ChannelOutboundBuffer cob = ch . unsafe ( ) . outboundBuffer ( ) ; ch . write ( buffer ( ) . writeZero ( <int> ) ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , false ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; ch . flush ( ) ; assertThat ( cob . totalPendingWriteBytes ( ) , is ( <int> L ) ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; cob . setUserDefinedWritability ( <int> , true ) ; ch . runPendingTasks ( ) ; assertThat ( buf . toString ( ) , is ( <str> ) ) ; safeClose ( ch ) ; } private static void safeClose ( EmbeddedChannel ch ) { ch . finish ( ) ; for ( ; ; ) { ByteBuf m = ch . readOutbound ( ) ; if ( m = = null ) { break ; } m . release ( ) ; } } } 
