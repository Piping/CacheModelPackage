package org . apache . cassandra . utils ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import java . util . function . Consumer ; import com . google . common . base . Function ; import com . google . common . collect . Lists ; import com . google . common . util . concurrent . Futures ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . common . util . concurrent . ListenableFutureTask ; import org . junit . Assert ; import org . junit . Test ; import com . codahale . metrics . MetricRegistry ; import com . codahale . metrics . Snapshot ; import com . codahale . metrics . Timer ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . utils . btree . * ; import static com . google . common . base . Predicates . notNull ; import static com . google . common . collect . Iterables . filter ; import static com . google . common . collect . Iterables . transform ; import static java . util . Comparator . naturalOrder ; import static java . util . Comparator . reverseOrder ; import static org . apache . cassandra . utils . btree . BTree . iterable ; import static org . junit . Assert . assertTrue ; public class LongBTreeTest { private static final boolean DEBUG = false ; private static int perThreadTrees = <int> ; private static int minTreeSize = <int> ; private static int maxTreeSize = <int> ; private static int threads = DEBUG ? <int> : Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ; private static final MetricRegistry metrics = new MetricRegistry ( ) ; private static final Timer BTREE_TIMER = metrics . timer ( MetricRegistry . name ( BTree . class , <str> ) ) ; private static final Timer TREE_TIMER = metrics . timer ( MetricRegistry . name ( BTree . class , <str> ) ) ; private static final ExecutorService MODIFY = Executors . newFixedThreadPool ( threads , new NamedThreadFactory ( <str> ) ) ; private static final ExecutorService COMPARE = DEBUG ? MODIFY : Executors . newFixedThreadPool ( threads , new NamedThreadFactory ( <str> ) ) ; private static final RandomAbort < Integer > SPORADIC_ABORT = new RandomAbort < > ( new Random ( ) , <float> ) ; static { System . setProperty ( <str> , <str> ) ; } @Test public void testSearchIterator ( ) throws InterruptedException { final int perTreeSelections = <int> ; testRandomSelection ( perThreadTrees , perTreeSelections , ( test ) - > { IndexedSearchIterator < Integer , Integer > iter1 = test . testAsSet . iterator ( ) ; IndexedSearchIterator < Integer , Integer > iter2 = test . testAsList . iterator ( ) ; return ( key ) - > { Integer found1 = iter1 . hasNext ( ) ? iter1 . next ( key ) : null ; Integer found2 = iter2 . hasNext ( ) ? iter2 . next ( key ) : null ; Assert . assertSame ( found1 , found2 ) ; if ( found1 ! = null ) Assert . assertEquals ( iter1 . indexOfCurrent ( ) , iter2 . indexOfCurrent ( ) ) ; int index = Collections . binarySearch ( test . canonicalList , key , test . comparator ) ; if ( index < <int> ) { Assert . assertNull ( found1 ) ; } else { Assert . assertEquals ( key , found1 ) ; Assert . assertEquals ( index , iter1 . indexOfCurrent ( ) ) ; } if ( ThreadLocalRandom . current ( ) . nextBoolean ( ) ) Assert . assertNull ( iter1 . next ( key ) ) ; else Assert . assertNull ( iter2 . next ( key ) ) ; } ; } ) ; } @Test public void testInequalityLookups ( ) throws InterruptedException { final int perTreeSelections = <int> ; testRandomSelectionOfSet ( perThreadTrees , perTreeSelections , ( test , canonical ) - > { if ( ! canonical . isEmpty ( ) | | ! test . isEmpty ( ) ) { Assert . assertEquals ( canonical . isEmpty ( ) , test . isEmpty ( ) ) ; Assert . assertEquals ( canonical . first ( ) , test . first ( ) ) ; Assert . assertEquals ( canonical . last ( ) , test . last ( ) ) ; } return ( key ) - > { Assert . assertEquals ( test . ceiling ( key ) , canonical . ceiling ( key ) ) ; Assert . assertEquals ( test . higher ( key ) , canonical . higher ( key ) ) ; Assert . assertEquals ( test . floor ( key ) , canonical . floor ( key ) ) ; Assert . assertEquals ( test . lower ( key ) , canonical . lower ( key ) ) ; } ; } ) ; } @Test public void testListIndexes ( ) throws InterruptedException { testRandomSelectionOfList ( perThreadTrees , <int> , ( test , canonical , cmp ) - > ( key ) - > { int javaIndex = Collections . binarySearch ( canonical , key , cmp ) ; int btreeIndex = test . indexOf ( key ) ; Assert . assertEquals ( javaIndex , btreeIndex ) ; if ( javaIndex > = <int> ) Assert . assertEquals ( canonical . get ( javaIndex ) , test . get ( btreeIndex ) ) ; } ) ; } @Test public void testToArray ( ) throws InterruptedException { testRandomSelection ( perThreadTrees , <int> , ( selection ) - > { Integer [ ] array = new Integer [ selection . canonicalList . size ( ) + <int> ] ; selection . testAsList . toArray ( array , <int> ) ; Assert . assertEquals ( null , array [ <int> ] ) ; for ( int j = <int> ; j < selection . canonicalList . size ( ) ; j + + ) Assert . assertEquals ( selection . canonicalList . get ( j ) , array [ j + <int> ] ) ; } ) ; } private static final class CountingFunction implements Function < Integer , Integer > { final Function < Integer , Integer > wrapped ; int count = <int> ; protected CountingFunction ( Function < Integer , Integer > wrapped ) { this . wrapped = wrapped ; } public Integer apply ( Integer integer ) { count + + ; return wrapped . apply ( integer ) ; } } @Test public void testTransformAndFilter ( ) throws InterruptedException { testRandomSelection ( perThreadTrees , <int> , false , false , false , ( selection ) - > { Map < Integer , Integer > update = new LinkedHashMap < > ( ) ; for ( Integer i : selection . testKeys ) update . put ( i , new Integer ( i ) ) ; CountingFunction function ; Object [ ] original = selection . testAsSet . tree ( ) ; Object [ ] transformed ; function = new CountingFunction ( ( x ) - > x ) ; transformed = BTree . transformAndFilter ( original , function ) ; Assert . assertEquals ( BTree . size ( original ) , function . count ) ; Assert . assertSame ( original , transformed ) ; function = new CountingFunction ( ( x ) - > update . containsKey ( x ) ? update . get ( x ) : x ) ; transformed = BTree . transformAndFilter ( original , function ) ; Assert . assertEquals ( BTree . size ( original ) , function . count ) ; assertSame ( transform ( selection . canonicalList , function . wrapped ) , iterable ( transformed ) ) ; function = new CountingFunction ( update : : get ) ; transformed = BTree . transformAndFilter ( original , function ) ; Assert . assertEquals ( BTree . size ( original ) , function . count ) ; assertSame ( filter ( transform ( selection . canonicalList , function . wrapped ) , notNull ( ) ) , iterable ( transformed ) ) ; function = new CountingFunction ( ( x ) - > update . containsKey ( x ) ? null : x ) ; transformed = BTree . transformAndFilter ( selection . testAsList . tree ( ) , function ) ; Assert . assertEquals ( BTree . size ( original ) , function . count ) ; assertSame ( filter ( transform ( selection . canonicalList , function . wrapped ) , notNull ( ) ) , iterable ( transformed ) ) ; } ) ; } private static void assertSame ( Iterable < Integer > i1 , Iterable < Integer > i2 ) { assertSame ( i1 . iterator ( ) , i2 . iterator ( ) ) ; } private static void assertSame ( Iterator < Integer > i1 , Iterator < Integer > i2 ) { while ( i1 . hasNext ( ) & & i2 . hasNext ( ) ) Assert . assertSame ( i1 . next ( ) , i2 . next ( ) ) ; Assert . assertEquals ( i1 . hasNext ( ) , i2 . hasNext ( ) ) ; } private void testRandomSelectionOfList ( int perThreadTrees , int perTreeSelections , BTreeListTestFactory testRun ) throws InterruptedException { testRandomSelection ( perThreadTrees , perTreeSelections , ( BTreeTestFactory ) ( selection ) - > testRun . get ( selection . testAsList , selection . canonicalList , selection . comparator ) ) ; } private void testRandomSelectionOfSet ( int perThreadTrees , int perTreeSelections , BTreeSetTestFactory testRun ) throws InterruptedException { testRandomSelection ( perThreadTrees , perTreeSelections , ( BTreeTestFactory ) ( selection ) - > testRun . get ( selection . testAsSet , selection . canonicalSet ) ) ; } static interface BTreeSetTestFactory { TestEachKey get ( BTreeSet < Integer > test , NavigableSet < Integer > canonical ) ; } static interface BTreeListTestFactory { TestEachKey get ( BTreeSet < Integer > test , List < Integer > canonical , Comparator < Integer > comparator ) ; } static interface BTreeTestFactory { TestEachKey get ( RandomSelection test ) ; } static interface TestEachKey { void testOne ( Integer value ) ; } private void testRandomSelection ( int perThreadTrees , int perTreeSelections , BTreeTestFactory testRun ) throws InterruptedException { testRandomSelection ( perThreadTrees , perTreeSelections , ( selection ) - > { TestEachKey testEachKey = testRun . get ( selection ) ; for ( Integer key : selection . testKeys ) testEachKey . testOne ( key ) ; } ) ; } private void testRandomSelection ( int perThreadTrees , int perTreeSelections , Consumer < RandomSelection > testRun ) throws InterruptedException { testRandomSelection ( perThreadTrees , perTreeSelections , true , true , true , testRun ) ; } private void testRandomSelection ( int perThreadTrees , int perTreeSelections , boolean narrow , boolean mixInNotPresentItems , boolean permitReversal , Consumer < RandomSelection > testRun ) throws InterruptedException { int threads = Runtime . getRuntime ( ) . availableProcessors ( ) ; final CountDownLatch latch = new CountDownLatch ( threads ) ; final AtomicLong errors = new AtomicLong ( ) ; final AtomicLong count = new AtomicLong ( ) ; final long totalCount = threads * perThreadTrees * perTreeSelections ; for ( int t = <int> ; t < threads ; t + + ) { Runnable runnable = new Runnable ( ) { public void run ( ) { try { for ( int i = <int> ; i < perThreadTrees ; i + + ) { RandomTree tree = randomTree ( minTreeSize , maxTreeSize ) ; for ( int j = <int> ; j < perTreeSelections ; j + + ) { testRun . accept ( tree . select ( narrow , mixInNotPresentItems , permitReversal ) ) ; count . incrementAndGet ( ) ; } } } catch ( Throwable t ) { errors . incrementAndGet ( ) ; t . printStackTrace ( ) ; } latch . countDown ( ) ; } } ; MODIFY . execute ( runnable ) ; } while ( latch . getCount ( ) > <int> ) { for ( int i = <int> ; i < <int> ; i + + ) { latch . await ( <int> , TimeUnit . SECONDS ) ; Assert . assertEquals ( <int> , errors . get ( ) ) ; } log ( <str> , <int> * count . get ( ) / ( double ) totalCount , errors . get ( ) > <int> ? ( <str> + errors . get ( ) ) : <str> ) ; } } private static class RandomSelection { final List < Integer > testKeys ; final NavigableSet < Integer > canonicalSet ; final List < Integer > canonicalList ; final BTreeSet < Integer > testAsSet ; final BTreeSet < Integer > testAsList ; final Comparator < Integer > comparator ; private RandomSelection ( List < Integer > testKeys , NavigableSet < Integer > canonicalSet , BTreeSet < Integer > testAsSet , List < Integer > canonicalList , BTreeSet < Integer > testAsList , Comparator < Integer > comparator ) { this . testKeys = testKeys ; this . canonicalList = canonicalList ; this . canonicalSet = canonicalSet ; this . testAsSet = testAsSet ; this . testAsList = testAsList ; this . comparator = comparator ; } } private static class RandomTree { final NavigableSet < Integer > canonical ; final BTreeSet < Integer > test ; private RandomTree ( NavigableSet < Integer > canonical , BTreeSet < Integer > test ) { this . canonical = canonical ; this . test = test ; } RandomSelection select ( boolean narrow , boolean mixInNotPresentItems , boolean permitReversal ) { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; NavigableSet < Integer > canonicalSet = this . canonical ; BTreeSet < Integer > testAsSet = this . test ; List < Integer > canonicalList = new ArrayList < > ( canonicalSet ) ; BTreeSet < Integer > testAsList = this . test ; Assert . assertEquals ( canonicalSet . size ( ) , testAsSet . size ( ) ) ; Assert . assertEquals ( canonicalList . size ( ) , testAsList . size ( ) ) ; List < Integer > allKeys = randomKeys ( canonical , mixInNotPresentItems ) ; List < Integer > keys = allKeys ; int narrowCount = random . nextInt ( <int> ) ; while ( narrow & & canonicalList . size ( ) > <int> & & keys . size ( ) > <int> & & narrowCount - - > <int> ) { boolean useLb = random . nextBoolean ( ) ; boolean useUb = random . nextBoolean ( ) ; if ( ! ( useLb | useUb ) ) continue ; int indexRange = keys . size ( ) / ( narrowCount + <int> ) ; boolean lbInclusive = true ; Integer lbKey = canonicalList . get ( <int> ) ; int lbKeyIndex = <int> , lbIndex = <int> ; boolean ubInclusive = true ; Integer ubKey = canonicalList . get ( canonicalList . size ( ) - <int> ) ; int ubKeyIndex = keys . size ( ) , ubIndex = canonicalList . size ( ) ; if ( useLb ) { lbKeyIndex = random . nextInt ( <int> , indexRange - <int> ) ; Integer candidate = keys . get ( lbKeyIndex ) ; if ( useLb = ( candidate > lbKey & & candidate < = ubKey ) ) { lbInclusive = random . nextBoolean ( ) ; lbKey = keys . get ( lbKeyIndex ) ; lbIndex = Collections . binarySearch ( canonicalList , lbKey ) ; if ( lbIndex > = <int> & & ! lbInclusive ) lbIndex + + ; else if ( lbIndex < <int> ) lbIndex = - <int> - lbIndex ; } } if ( useUb ) { ubKeyIndex = random . nextInt ( Math . max ( lbKeyIndex , keys . size ( ) - indexRange ) , keys . size ( ) - <int> ) ; Integer candidate = keys . get ( ubKeyIndex ) ; if ( useUb = ( candidate < ubKey & & candidate > = lbKey ) ) { ubInclusive = random . nextBoolean ( ) ; ubKey = keys . get ( ubKeyIndex ) ; ubIndex = Collections . binarySearch ( canonicalList , ubKey ) ; if ( ubIndex > = <int> & & ubInclusive ) { ubIndex + + ; } else if ( ubIndex < <int> ) ubIndex = - <int> - ubIndex ; } } if ( ubIndex < lbIndex ) { ubIndex = lbIndex ; ubKey = lbKey ; ubInclusive = false ; } canonicalSet = ! useLb ? canonicalSet . headSet ( ubKey , ubInclusive ) : ! useUb ? canonicalSet . tailSet ( lbKey , lbInclusive ) : canonicalSet . subSet ( lbKey , lbInclusive , ubKey , ubInclusive ) ; testAsSet = ! useLb ? testAsSet . headSet ( ubKey , ubInclusive ) : ! useUb ? testAsSet . tailSet ( lbKey , lbInclusive ) : testAsSet . subSet ( lbKey , lbInclusive , ubKey , ubInclusive ) ; keys = keys . subList ( lbKeyIndex , ubKeyIndex ) ; canonicalList = canonicalList . subList ( lbIndex , ubIndex ) ; testAsList = testAsList . subList ( lbIndex , ubIndex ) ; Assert . assertEquals ( canonicalSet . size ( ) , testAsSet . size ( ) ) ; Assert . assertEquals ( canonicalList . size ( ) , testAsList . size ( ) ) ; } if ( keys ! = allKeys & & random . nextBoolean ( ) ) keys = allKeys ; Comparator < Integer > comparator = naturalOrder ( ) ; if ( permitReversal & & random . nextBoolean ( ) ) { if ( allKeys ! = keys ) keys = new ArrayList < > ( keys ) ; if ( canonicalSet ! = canonical ) canonicalList = new ArrayList < > ( canonicalList ) ; Collections . reverse ( keys ) ; Collections . reverse ( canonicalList ) ; testAsList = testAsList . descendingSet ( ) ; canonicalSet = canonicalSet . descendingSet ( ) ; testAsSet = testAsSet . descendingSet ( ) ; comparator = reverseOrder ( ) ; } Assert . assertEquals ( canonicalSet . size ( ) , testAsSet . size ( ) ) ; Assert . assertEquals ( canonicalList . size ( ) , testAsList . size ( ) ) ; if ( ! canonicalSet . isEmpty ( ) ) { Assert . assertEquals ( canonicalSet . first ( ) , canonicalList . get ( <int> ) ) ; Assert . assertEquals ( canonicalSet . last ( ) , canonicalList . get ( canonicalList . size ( ) - <int> ) ) ; Assert . assertEquals ( canonicalSet . first ( ) , testAsSet . first ( ) ) ; Assert . assertEquals ( canonicalSet . last ( ) , testAsSet . last ( ) ) ; Assert . assertEquals ( canonicalSet . first ( ) , testAsList . get ( <int> ) ) ; Assert . assertEquals ( canonicalSet . last ( ) , testAsList . get ( testAsList . size ( ) - <int> ) ) ; } return new RandomSelection ( keys , canonicalSet , testAsSet , canonicalList , testAsList , comparator ) ; } } private static RandomTree randomTree ( int minSize , int maxSize ) { return ThreadLocalRandom . current ( ) . nextFloat ( ) < <float> ? randomTreeByUpdate ( minSize , maxSize ) : randomTreeByBuilder ( minSize , maxSize ) ; } private static RandomTree randomTreeByUpdate ( int minSize , int maxSize ) { assert minSize > <int> ; TreeSet < Integer > canonical = new TreeSet < > ( ) ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; int targetSize = random . nextInt ( minSize , maxSize ) ; int maxModificationSize = random . nextInt ( <int> , targetSize ) ; Object [ ] accmumulate = BTree . empty ( ) ; int curSize = <int> ; while ( curSize < targetSize ) { int nextSize = maxModificationSize = = <int> ? <int> : random . nextInt ( <int> , maxModificationSize ) ; TreeSet < Integer > build = new TreeSet < > ( ) ; for ( int i = <int> ; i < nextSize ; i + + ) { Integer next = random . nextInt ( ) ; build . add ( next ) ; canonical . add ( next ) ; } accmumulate = BTree . update ( accmumulate , naturalOrder ( ) , build , UpdateFunction . < Integer > noOp ( ) ) ; curSize + = nextSize ; maxModificationSize = Math . min ( maxModificationSize , targetSize - curSize ) ; } return new RandomTree ( canonical , BTreeSet . < Integer > wrap ( accmumulate , naturalOrder ( ) ) ) ; } private static RandomTree randomTreeByBuilder ( int minSize , int maxSize ) { assert minSize > <int> ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; BTree . Builder < Integer > builder = BTree . builder ( naturalOrder ( ) ) ; int targetSize = random . nextInt ( minSize , maxSize ) ; int maxModificationSize = ( int ) Math . sqrt ( targetSize ) ; TreeSet < Integer > canonical = new TreeSet < > ( ) ; int curSize = <int> ; TreeSet < Integer > ordered = new TreeSet < > ( ) ; List < Integer > shuffled = new ArrayList < > ( ) ; while ( curSize < targetSize ) { int nextSize = maxModificationSize < = <int> ? <int> : random . nextInt ( <int> , maxModificationSize ) ; ( random . nextBoolean ( ) ? ordered . headSet ( random . nextInt ( ) ) : ordered . tailSet ( random . nextInt ( ) ) ) . clear ( ) ; shuffled = new ArrayList < > ( shuffled . subList ( <int> , shuffled . size ( ) < <int> ? <int> : random . nextInt ( shuffled . size ( ) / <int> ) ) ) ; for ( int i = <int> ; i < nextSize ; i + + ) { Integer next = random . nextInt ( ) ; ordered . add ( next ) ; shuffled . add ( next ) ; canonical . add ( next ) ; } switch ( random . nextInt ( <int> ) ) { case <int> : builder . addAll ( ordered ) ; break ; case <int> : builder . addAll ( BTreeSet . of ( ordered ) ) ; break ; case <int> : for ( Integer i : ordered ) builder . add ( i ) ; case <int> : builder . addAll ( shuffled ) ; break ; case <int> : for ( Integer i : shuffled ) builder . add ( i ) ; } curSize + = nextSize ; maxModificationSize = Math . min ( maxModificationSize , targetSize - curSize ) ; } BTreeSet < Integer > btree = BTreeSet . < Integer > wrap ( builder . build ( ) , naturalOrder ( ) ) ; Assert . assertEquals ( canonical . size ( ) , btree . size ( ) ) ; return new RandomTree ( canonical , btree ) ; } private static List < Integer > randomKeys ( Iterable < Integer > canonical , boolean mixInNotPresentItems ) { ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; boolean useFake = mixInNotPresentItems & & rnd . nextBoolean ( ) ; final float fakeRatio = rnd . nextFloat ( ) ; List < Integer > results = new ArrayList < > ( ) ; Long fakeLb = ( long ) Integer . MIN_VALUE , fakeUb = null ; Integer max = null ; for ( Integer v : canonical ) { if ( ! useFake | | ( fakeUb = = null ? v - <int> : fakeUb ) < = fakeLb + <int> | | rnd . nextFloat ( ) < fakeRatio ) { results . add ( v ) ; fakeLb = v . longValue ( ) ; fakeUb = null ; } else { if ( fakeUb = = null ) fakeUb = v . longValue ( ) - <int> ; long mid = ( fakeLb + fakeUb ) / <int> ; assert mid < fakeUb ; results . add ( ( int ) mid ) ; fakeLb = mid ; } max = v ; } if ( useFake & & max ! = null & & max < Integer . MAX_VALUE ) results . add ( max + <int> ) ; final float useChance = rnd . nextFloat ( ) ; return Lists . newArrayList ( filter ( results , ( x ) - > rnd . nextFloat ( ) < useChance ) ) ; } @Test public void testOversizedMiddleInsert ( ) { TreeSet < Integer > canon = new TreeSet < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) canon . add ( i ) ; Object [ ] btree = BTree . build ( Arrays . asList ( Integer . MIN_VALUE , Integer . MAX_VALUE ) , UpdateFunction . noOp ( ) ) ; btree = BTree . update ( btree , naturalOrder ( ) , canon , UpdateFunction . < Integer > noOp ( ) ) ; canon . add ( Integer . MIN_VALUE ) ; canon . add ( Integer . MAX_VALUE ) ; assertTrue ( BTree . isWellFormed ( btree , naturalOrder ( ) ) ) ; testEqual ( <str> , BTree . iterator ( btree ) , canon . iterator ( ) ) ; } @Test public void testIndividualInsertsSmallOverlappingRange ( ) throws ExecutionException , InterruptedException { testInsertions ( <int> , <int> , <int> , true ) ; } @Test public void testBatchesSmallOverlappingRange ( ) throws ExecutionException , InterruptedException { testInsertions ( <int> , <int> , <int> , true ) ; } @Test public void testIndividualInsertsMediumSparseRange ( ) throws ExecutionException , InterruptedException { testInsertions ( perThreadTrees / <int> , <int> , <int> , <int> , true ) ; } @Test public void testBatchesMediumSparseRange ( ) throws ExecutionException , InterruptedException { testInsertions ( <int> , <int> , <int> , true ) ; } @Test public void testLargeBatchesLargeRange ( ) throws ExecutionException , InterruptedException { testInsertions ( perThreadTrees / <int> , Math . max ( maxTreeSize , <int> ) , <int> , <int> , true ) ; } @Test public void testRandomRangeAndBatches ( ) throws ExecutionException , InterruptedException { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; int treeSize = random . nextInt ( maxTreeSize / <int> , maxTreeSize * <int> ) ; for ( int i = <int> ; i < perThreadTrees / <int> ; i + + ) testInsertions ( threads * <int> , treeSize , random . nextInt ( <int> , <int> ) / <int> f , treeSize / <int> , true ) ; } @Test public void testSlicingSmallRandomTrees ( ) throws ExecutionException , InterruptedException { testInsertions ( <int> , <int> , <int> , false ) ; } private static void testInsertions ( int perTestCount , float testKeyRatio , int modificationBatchSize , boolean quickEquality ) throws ExecutionException , InterruptedException { int tests = perThreadTrees * threads ; testInsertions ( tests , perTestCount , testKeyRatio , modificationBatchSize , quickEquality ) ; } private static void testInsertions ( int tests , int perTestCount , float testKeyRatio , int modificationBatchSize , boolean quickEquality ) throws ExecutionException , InterruptedException { int batchesPerTest = perTestCount / modificationBatchSize ; int testKeyRange = ( int ) ( perTestCount * testKeyRatio ) ; long totalCount = ( long ) perTestCount * tests ; log ( <str> , tests , perTestCount , <int> / testKeyRatio , modificationBatchSize ) ; int chunkSize = quickEquality ? tests : ( int ) ( <int> / Math . pow ( perTestCount , <int> ) ) ; for ( int chunk = <int> ; chunk < tests ; chunk + = chunkSize ) { final List < ListenableFutureTask < List < ListenableFuture < ? > > > > outer = new ArrayList < > ( ) ; for ( int i = <int> ; i < chunkSize ; i + + ) { int maxRunLength = modificationBatchSize = = <int> ? <int> : ThreadLocalRandom . current ( ) . nextInt ( <int> , modificationBatchSize ) ; outer . add ( doOneTestInsertions ( testKeyRange , maxRunLength , modificationBatchSize , batchesPerTest , quickEquality ) ) ; } final List < ListenableFuture < ? > > inner = new ArrayList < > ( ) ; long complete = <int> ; int reportInterval = Math . max ( <int> , ( int ) ( totalCount / <int> ) ) ; long lastReportAt = <int> ; for ( ListenableFutureTask < List < ListenableFuture < ? > > > f : outer ) { inner . addAll ( f . get ( ) ) ; complete + = perTestCount ; if ( complete - lastReportAt > = reportInterval ) { long done = ( chunk * perTestCount ) + complete ; float ratio = done / ( float ) totalCount ; log ( <str> , ratio * <int> , done , totalCount ) ; lastReportAt = complete ; } } Futures . allAsList ( inner ) . get ( ) ; } Snapshot snap = BTREE_TIMER . getSnapshot ( ) ; log ( <str> , snap . getMedian ( ) , snap . get95thPercentile ( ) , snap . get999thPercentile ( ) ) ; snap = TREE_TIMER . getSnapshot ( ) ; log ( <str> , snap . getMedian ( ) , snap . get95thPercentile ( ) , snap . get999thPercentile ( ) ) ; log ( <str> ) ; } private static ListenableFutureTask < List < ListenableFuture < ? > > > doOneTestInsertions ( final int upperBound , final int maxRunLength , final int averageModsPerIteration , final int iterations , final boolean quickEquality ) { ListenableFutureTask < List < ListenableFuture < ? > > > f = ListenableFutureTask . create ( new Callable < List < ListenableFuture < ? > > > ( ) { @Override public List < ListenableFuture < ? > > call ( ) { final List < ListenableFuture < ? > > r = new ArrayList < > ( ) ; NavigableMap < Integer , Integer > canon = new TreeMap < > ( ) ; Object [ ] btree = BTree . empty ( ) ; final TreeMap < Integer , Integer > buffer = new TreeMap < > ( ) ; ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { buffer . clear ( ) ; int mods = rnd . nextInt ( <int> , averageModsPerIteration * <int> ) ; while ( mods > <int> ) { int v = rnd . nextInt ( upperBound ) ; int rc = Math . max ( <int> , Math . min ( mods , maxRunLength ) - <int> ) ; int c = <int> + ( rc < = <int> ? <int> : rnd . nextInt ( rc ) ) ; for ( int j = <int> ; j < c ; j + + ) { buffer . put ( v , v ) ; v + + ; } mods - = c ; } Timer . Context ctxt ; ctxt = TREE_TIMER . time ( ) ; canon . putAll ( buffer ) ; ctxt . stop ( ) ; ctxt = BTREE_TIMER . time ( ) ; Object [ ] next = null ; while ( next = = null ) next = BTree . update ( btree , naturalOrder ( ) , buffer . keySet ( ) , SPORADIC_ABORT ) ; btree = next ; ctxt . stop ( ) ; if ( ! BTree . isWellFormed ( btree , naturalOrder ( ) ) ) { log ( <str> ) ; throw new AssertionError ( <str> ) ; } if ( quickEquality ) testEqual ( <str> , BTree . iterator ( btree ) , canon . keySet ( ) . iterator ( ) ) ; else r . addAll ( testAllSlices ( <str> , btree , new TreeSet < > ( canon . keySet ( ) ) ) ) ; } return r ; } } ) ; if ( DEBUG ) f . run ( ) ; else MODIFY . execute ( f ) ; return f ; } @Test public void testSlicingAllSmallTrees ( ) throws ExecutionException , InterruptedException { Object [ ] cur = BTree . empty ( ) ; TreeSet < Integer > canon = new TreeSet < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { String id = String . format ( <str> , canon . size ( ) ) ; log ( <str> + id ) ; Futures . allAsList ( testAllSlices ( id , cur , canon ) ) . get ( ) ; Object [ ] next = null ; while ( next = = null ) next = BTree . update ( cur , naturalOrder ( ) , Arrays . asList ( i ) , SPORADIC_ABORT ) ; cur = next ; canon . add ( i ) ; } } private static List < ListenableFuture < ? > > testAllSlices ( String id , Object [ ] btree , NavigableSet < Integer > canon ) { List < ListenableFuture < ? > > waitFor = new ArrayList < > ( ) ; testAllSlices ( id + <str> , new BTreeSet < > ( btree , naturalOrder ( ) ) , canon , true , waitFor ) ; testAllSlices ( id + <str> , new BTreeSet < Integer > ( btree , naturalOrder ( ) ) . descendingSet ( ) , canon . descendingSet ( ) , false , waitFor ) ; return waitFor ; } private static void testAllSlices ( String id , NavigableSet < Integer > btree , NavigableSet < Integer > canon , boolean ascending , List < ListenableFuture < ? > > results ) { testOneSlice ( id , btree , canon , results ) ; for ( Integer lb : range ( canon . size ( ) , Integer . MIN_VALUE , ascending ) ) { testOneSlice ( String . format ( <str> , id , lb ) , btree . headSet ( lb , true ) , canon . headSet ( lb , true ) , results ) ; testOneSlice ( String . format ( <str> , id , lb ) , btree . headSet ( lb , false ) , canon . headSet ( lb , false ) , results ) ; testOneSlice ( String . format ( <str> , id , lb ) , btree . tailSet ( lb , true ) , canon . tailSet ( lb , true ) , results ) ; testOneSlice ( String . format ( <str> , id , lb ) , btree . tailSet ( lb , false ) , canon . tailSet ( lb , false ) , results ) ; for ( Integer ub : range ( canon . size ( ) , lb , ascending ) ) { testOneSlice ( String . format ( <str> , id , lb , ub ) , btree . subSet ( lb , true , ub , true ) , canon . subSet ( lb , true , ub , true ) , results ) ; testOneSlice ( String . format ( <str> , id , lb , ub ) , btree . subSet ( lb , false , ub , true ) , canon . subSet ( lb , false , ub , true ) , results ) ; testOneSlice ( String . format ( <str> , id , lb , ub ) , btree . subSet ( lb , true , ub , false ) , canon . subSet ( lb , true , ub , false ) , results ) ; testOneSlice ( String . format ( <str> , id , lb , ub ) , btree . subSet ( lb , false , ub , false ) , canon . subSet ( lb , false , ub , false ) , results ) ; } } } private static void testOneSlice ( final String id , final NavigableSet < Integer > test , final NavigableSet < Integer > canon , List < ListenableFuture < ? > > results ) { ListenableFutureTask < ? > f = ListenableFutureTask . create ( new Runnable ( ) { @Override public void run ( ) { test ( id + <str> , test . size ( ) , canon . size ( ) ) ; testEqual ( id , test . iterator ( ) , canon . iterator ( ) ) ; testEqual ( id + <str> , test . descendingIterator ( ) , canon . descendingIterator ( ) ) ; testEqual ( id + <str> , test . descendingSet ( ) . iterator ( ) , canon . descendingSet ( ) . iterator ( ) ) ; testEqual ( id + <str> , test . descendingSet ( ) . descendingIterator ( ) , canon . descendingSet ( ) . descendingIterator ( ) ) ; } } , null ) ; results . add ( f ) ; if ( DEBUG ) f . run ( ) ; else COMPARE . execute ( f ) ; } private static void test ( String id , int test , int expect ) { if ( test ! = expect ) { log ( <str> , id , expect , test ) ; } } private static < V > void testEqual ( String id , Iterator < V > btree , Iterator < V > canon ) { boolean equal = true ; while ( btree . hasNext ( ) & & canon . hasNext ( ) ) { Object i = btree . next ( ) ; Object j = canon . next ( ) ; if ( ! Objects . equals ( i , j ) ) { log ( <str> , id , j , i ) ; equal = false ; } } while ( btree . hasNext ( ) ) { log ( <str> , id , btree . next ( ) ) ; equal = false ; } while ( canon . hasNext ( ) ) { log ( <str> , id , canon . next ( ) ) ; equal = false ; } if ( ! equal ) throw new AssertionError ( <str> ) ; } private static final Iterable < Integer > range ( final int size , final int from , final boolean ascending ) { return new Iterable < Integer > ( ) { int cur ; int delta ; int end ; { if ( ascending ) { end = size + <int> ; cur = from = = Integer . MIN_VALUE ? - <int> : from ; delta = <int> ; } else { end = - <int> ; cur = from = = Integer . MIN_VALUE ? size : from ; delta = - <int> ; } } @Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { @Override public boolean hasNext ( ) { return cur ! = end ; } @Override public Integer next ( ) { Integer r = cur ; cur + = delta ; return r ; } @Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; } private static final class RandomAbort < V > implements UpdateFunction < V , V > { final Random rnd ; final float chance ; private RandomAbort ( Random rnd , float chance ) { this . rnd = rnd ; this . chance = chance ; } public V apply ( V replacing , V update ) { return update ; } public boolean abortEarly ( ) { return rnd . nextFloat ( ) < chance ; } public void allocated ( long heapSize ) { } public V apply ( V v ) { return v ; } } public static void main ( String [ ] args ) throws ExecutionException , InterruptedException , InvocationTargetException , IllegalAccessException { for ( String arg : args ) { if ( arg . startsWith ( <str> ) ) System . setProperty ( <str> , arg . substring ( <int> ) ) ; else if ( arg . startsWith ( <str> ) ) minTreeSize = Integer . parseInt ( arg . substring ( <int> ) ) ; else if ( arg . startsWith ( <str> ) ) maxTreeSize = Integer . parseInt ( arg . substring ( <int> ) ) ; else if ( arg . startsWith ( <str> ) ) perThreadTrees = Integer . parseInt ( arg . substring ( <int> ) ) ; else exit ( ) ; } List < Method > methods = new ArrayList < > ( ) ; for ( Method m : LongBTreeTest . class . getDeclaredMethods ( ) ) { if ( m . getParameters ( ) . length > <int> ) continue ; for ( Annotation annotation : m . getAnnotations ( ) ) if ( annotation . annotationType ( ) = = Test . class ) methods . add ( m ) ; } LongBTreeTest test = new LongBTreeTest ( ) ; Collections . sort ( methods , ( a , b ) - > a . getName ( ) . compareTo ( b . getName ( ) ) ) ; log ( Lists . transform ( methods , ( m ) - > m . getName ( ) ) . toString ( ) ) ; for ( Method m : methods ) { log ( m . getName ( ) ) ; m . invoke ( test ) ; } log ( <str> ) ; } private static void exit ( ) { log ( <str> ) ; log ( <str> ) ; log ( <str> ) ; log ( <str> ) ; log ( <str> ) ; } private static void log ( String formatstr , Object . . . args ) { args = Arrays . copyOf ( args , args . length + <int> ) ; System . arraycopy ( args , <int> , args , <int> , args . length - <int> ) ; args [ <int> ] = System . currentTimeMillis ( ) ; System . out . printf ( <str> + formatstr + <str> , args ) ; } } 
