package com . badlogic . gdx . tools . flame ; import java . awt . BorderLayout ; import java . awt . Component ; import java . awt . EventQueue ; import java . awt . FileDialog ; import java . awt . Graphics ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . io . File ; import java . io . Writer ; import javax . swing . BorderFactory ; import javax . swing . DefaultComboBoxModel ; import javax . swing . JButton ; import javax . swing . JComboBox ; import javax . swing . JComponent ; import javax . swing . JFrame ; import javax . swing . JOptionPane ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JSplitPane ; import javax . swing . UIManager ; import javax . swing . UIManager . LookAndFeelInfo ; import javax . swing . border . CompoundBorder ; import javax . swing . plaf . basic . BasicSplitPaneUI ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . assets . AssetDescriptor ; import com . badlogic . gdx . assets . AssetErrorListener ; import com . badlogic . gdx . assets . AssetLoaderParameters ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . assets . loaders . AssetLoader ; import com . badlogic . gdx . assets . loaders . resolvers . AbsoluteFileHandleResolver ; import com . badlogic . gdx . assets . loaders . resolvers . InternalFileHandleResolver ; import com . badlogic . gdx . backends . lwjgl . LwjglCanvas ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . BlendingAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . particles . ParticleController ; import com . badlogic . gdx . graphics . g3d . particles . ParticleEffect ; import com . badlogic . gdx . graphics . g3d . particles . ParticleEffectLoader ; import com . badlogic . gdx . graphics . g3d . particles . ParticleEffectLoader . ParticleEffectSaveParameter ; import com . badlogic . gdx . graphics . g3d . particles . ParticleSystem ; import com . badlogic . gdx . graphics . g3d . particles . batches . BillboardParticleBatch ; import com . badlogic . gdx . graphics . g3d . particles . batches . ModelInstanceParticleBatch ; import com . badlogic . gdx . graphics . g3d . particles . batches . ParticleBatch ; import com . badlogic . gdx . graphics . g3d . particles . batches . PointSpriteParticleBatch ; import com . badlogic . gdx . graphics . g3d . particles . emitters . Emitter ; import com . badlogic . gdx . graphics . g3d . particles . emitters . RegularEmitter ; import com . badlogic . gdx . graphics . g3d . particles . influencers . ColorInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . DynamicsInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . Influencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . ModelInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . ParticleControllerFinalizerInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . ParticleControllerInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . RegionInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . ScaleInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . influencers . SpawnInfluencer ; import com . badlogic . gdx . graphics . g3d . particles . renderers . BillboardRenderer ; import com . badlogic . gdx . graphics . g3d . particles . renderers . ModelInstanceRenderer ; import com . badlogic . gdx . graphics . g3d . particles . renderers . ParticleControllerControllerRenderer ; import com . badlogic . gdx . graphics . g3d . particles . renderers . PointSpriteRenderer ; import com . badlogic . gdx . graphics . g3d . particles . values . GradientColorValue ; import com . badlogic . gdx . graphics . g3d . particles . values . NumericValue ; import com . badlogic . gdx . graphics . g3d . utils . CameraInputController ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . RandomXS128 ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . ui . Label ; import com . badlogic . gdx . scenes . scene2d . ui . Skin ; import com . badlogic . gdx . scenes . scene2d . ui . Table ; import com . badlogic . gdx . scenes . scene2d . ui . TextButton ; import com . badlogic . gdx . scenes . scene2d . utils . ClickListener ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . StreamUtils ; import com . badlogic . gdx . utils . StringBuilder ; public class FlameMain extends JFrame implements AssetErrorListener { public static final String DEFAULT_FONT = <str> , DEFAULT_BILLBOARD_PARTICLE = <str> , DEFAULT_MODEL_PARTICLE = <str> , DEFAULT_TEMPLATE_PFX = <str> , DEFAULT_SKIN = <str> ; public static final int EVT_ASSET_RELOADED = <int> ; static class ControllerData { public boolean enabled = true ; public ParticleController controller ; public ControllerData ( ParticleController emitter ) { controller = emitter ; } } private static class InfluencerWrapper < T > { String string ; Class < Influencer > type ; public InfluencerWrapper ( String string , Class < Influencer > type ) { this . string = string ; this . type = type ; } @Override public String toString ( ) { return string ; } } public enum ControllerType { Billboard ( <str> , new InfluencerWrapper [ ] { new InfluencerWrapper ( <str> , ColorInfluencer . Single . class ) , new InfluencerWrapper ( <str> , ColorInfluencer . Random . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Single . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Random . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Animated . class ) , new InfluencerWrapper ( <str> , ScaleInfluencer . class ) , new InfluencerWrapper ( <str> , SpawnInfluencer . class ) , new InfluencerWrapper ( <str> , DynamicsInfluencer . class ) } ) , PointSprite ( <str> , new InfluencerWrapper [ ] { new InfluencerWrapper ( <str> , ColorInfluencer . Single . class ) , new InfluencerWrapper ( <str> , ColorInfluencer . Random . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Single . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Random . class ) , new InfluencerWrapper ( <str> , RegionInfluencer . Animated . class ) , new InfluencerWrapper ( <str> , ScaleInfluencer . class ) , new InfluencerWrapper ( <str> , SpawnInfluencer . class ) , new InfluencerWrapper ( <str> , DynamicsInfluencer . class ) } ) , ModelInstance ( <str> , new InfluencerWrapper [ ] { new InfluencerWrapper ( <str> , ColorInfluencer . Single . class ) , new InfluencerWrapper ( <str> , ColorInfluencer . Random . class ) , new InfluencerWrapper ( <str> , ModelInfluencer . Single . class ) , new InfluencerWrapper ( <str> , ModelInfluencer . Random . class ) , new InfluencerWrapper ( <str> , ScaleInfluencer . class ) , new InfluencerWrapper ( <str> , SpawnInfluencer . class ) , new InfluencerWrapper ( <str> , DynamicsInfluencer . class ) } ) , ParticleController ( <str> , new InfluencerWrapper [ ] { new InfluencerWrapper ( <str> , ParticleControllerInfluencer . Single . class ) , new InfluencerWrapper ( <str> , ParticleControllerInfluencer . Random . class ) , new InfluencerWrapper ( <str> , ScaleInfluencer . class ) , new InfluencerWrapper ( <str> , SpawnInfluencer . class ) , new InfluencerWrapper ( <str> , DynamicsInfluencer . class ) } ) ; public String desc ; public InfluencerWrapper [ ] wrappers ; private ControllerType ( String desc , InfluencerWrapper [ ] wrappers ) { this . desc = desc ; this . wrappers = wrappers ; } } LwjglCanvas lwjglCanvas ; JPanel controllerPropertiesPanel ; JPanel editorPropertiesPanel ; EffectPanel effectPanel ; JSplitPane splitPane ; NumericValue fovValue ; NumericValue deltaMultiplier ; GradientColorValue backgroundColor ; AppRenderer renderer ; AssetManager assetManager ; JComboBox influencerBox ; private ParticleEffect effect ; public Array < ControllerData > controllersData ; ParticleSystem particleSystem ; public FlameMain ( ) { super ( <str> ) ; MathUtils . random = new RandomXS128 ( ) ; particleSystem = ParticleSystem . get ( ) ; effect = new ParticleEffect ( ) ; particleSystem . add ( effect ) ; assetManager = new AssetManager ( ) ; assetManager . setErrorListener ( this ) ; assetManager . setLoader ( ParticleEffect . class , new ParticleEffectLoader ( new InternalFileHandleResolver ( ) ) ) ; controllersData = new Array < ControllerData > ( ) ; lwjglCanvas = new LwjglCanvas ( renderer = new AppRenderer ( ) ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosed ( WindowEvent event ) { Gdx . app . exit ( ) ; } } ) ; initializeComponents ( ) ; setSize ( <int> , <int> ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setVisible ( true ) ; } public ControllerType getControllerType ( ) { ParticleController controller = getEmitter ( ) ; ControllerType type = null ; if ( controller . renderer instanceof BillboardRenderer ) type = ControllerType . Billboard ; else if ( controller . renderer instanceof PointSpriteRenderer ) type = ControllerType . PointSprite ; else if ( controller . renderer instanceof ModelInstanceRenderer ) type = ControllerType . ModelInstance ; else if ( controller . renderer instanceof ParticleControllerControllerRenderer ) type = ControllerType . ParticleController ; return type ; } void reloadRows ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { EventManager . get ( ) . clear ( ) ; editorPropertiesPanel . removeAll ( ) ; influencerBox . removeAllItems ( ) ; controllerPropertiesPanel . removeAll ( ) ; addRow ( editorPropertiesPanel , new NumericPanel ( FlameMain . this , fovValue , <str> , <str> ) ) ; addRow ( editorPropertiesPanel , new NumericPanel ( FlameMain . this , deltaMultiplier , <str> , <str> ) ) ; addRow ( editorPropertiesPanel , new GradientPanel ( FlameMain . this , backgroundColor , <str> , <str> , true ) ) ; addRow ( editorPropertiesPanel , new DrawPanel ( FlameMain . this , <str> , <str> ) ) ; addRow ( editorPropertiesPanel , new TextureLoaderPanel ( FlameMain . this , <str> , <str> ) ) ; addRow ( editorPropertiesPanel , new BillboardBatchPanel ( FlameMain . this , renderer . billboardBatch ) , <int> , <int> ) ; editorPropertiesPanel . repaint ( ) ; ParticleController controller = getEmitter ( ) ; if ( controller ! = null ) { DefaultComboBoxModel model = ( DefaultComboBoxModel ) influencerBox . getModel ( ) ; ControllerType type = getControllerType ( ) ; if ( type ! = null ) { for ( Object value : type . wrappers ) model . addElement ( value ) ; } JPanel panel = null ; addRow ( controllerPropertiesPanel , getPanel ( controller . emitter ) ) ; for ( int i = <int> , c = controller . influencers . size ; i < c ; + + i ) { Influencer influencer = ( Influencer ) controller . influencers . get ( i ) ; panel = getPanel ( influencer ) ; if ( panel ! = null ) addRow ( controllerPropertiesPanel , panel , <int> , i = = c - <int> ? <int> : <int> ) ; } for ( Component component : controllerPropertiesPanel . getComponents ( ) ) if ( component instanceof EditorPanel ) ( ( EditorPanel ) component ) . update ( FlameMain . this ) ; } controllerPropertiesPanel . repaint ( ) ; } } ) ; } protected JPanel getPanel ( Emitter emitter ) { if ( emitter instanceof RegularEmitter ) { return new RegularEmitterPanel ( this , ( RegularEmitter ) emitter ) ; } return null ; } protected JPanel getPanel ( Influencer influencer ) { if ( influencer instanceof ColorInfluencer . Single ) { return new ColorInfluencerPanel ( this , ( ColorInfluencer . Single ) influencer ) ; } if ( influencer instanceof ColorInfluencer . Random ) { return new InfluencerPanel < ColorInfluencer . Random > ( this , ( ColorInfluencer . Random ) influencer , <str> , <str> ) { } ; } else if ( influencer instanceof ScaleInfluencer ) { return new ScaleInfluencerPanel ( this , ( ScaleInfluencer ) influencer ) ; } else if ( influencer instanceof SpawnInfluencer ) { return new SpawnInfluencerPanel ( this , ( SpawnInfluencer ) influencer ) ; } else if ( influencer instanceof DynamicsInfluencer ) { return new DynamicsInfluencerPanel ( this , ( DynamicsInfluencer ) influencer ) ; } else if ( influencer instanceof ModelInfluencer ) { boolean single = influencer instanceof ModelInfluencer . Single ; String name = single ? <str> : <str> ; return new ModelInfluencerPanel ( this , ( ModelInfluencer ) influencer , single , name , <str> ) ; } else if ( influencer instanceof ParticleControllerInfluencer ) { boolean single = influencer instanceof ParticleControllerInfluencer . Single ; String name = single ? <str> : <str> ; return new ParticleControllerInfluencerPanel ( this , ( ParticleControllerInfluencer ) influencer , single , name , <str> ) ; } else if ( influencer instanceof RegionInfluencer . Single ) { return new RegionInfluencerPanel ( this , <str> , <str> , ( RegionInfluencer . Single ) influencer ) ; } else if ( influencer instanceof RegionInfluencer . Animated ) { return new RegionInfluencerPanel ( this , <str> , <str> , ( RegionInfluencer . Animated ) influencer ) ; } else if ( influencer instanceof RegionInfluencer . Random ) { return new RegionInfluencerPanel ( this , <str> , <str> , ( RegionInfluencer . Random ) influencer ) ; } else if ( influencer instanceof ParticleControllerFinalizerInfluencer ) { return new InfluencerPanel < ParticleControllerFinalizerInfluencer > ( this , ( ParticleControllerFinalizerInfluencer ) influencer , <str> , <str> , true , false ) { } ; } return null ; } protected JPanel getPanel ( ParticleBatch renderer ) { if ( renderer instanceof PointSpriteParticleBatch ) { return new EmptyPanel ( this , <str> , <str> ) ; } if ( renderer instanceof BillboardParticleBatch ) { return new BillboardBatchPanel ( this , ( BillboardParticleBatch ) renderer ) ; } else if ( renderer instanceof ModelInstanceParticleBatch ) { return new EmptyPanel ( this , <str> , <str> ) ; } return null ; } void addRow ( JPanel panel , JPanel row ) { addRow ( panel , row , <int> , <int> ) ; } void addRow ( JPanel panel , JPanel row , float wx , float wy ) { row . setBorder ( BorderFactory . createMatteBorder ( <int> , <int> , <int> , <int> , java . awt . Color . black ) ) ; panel . add ( row , new GridBagConstraints ( <int> , - <int> , <int> , <int> , wx , wy , GridBagConstraints . NORTH , GridBagConstraints . HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; } public void setVisible ( String name , boolean visible ) { for ( Component component : controllerPropertiesPanel . getComponents ( ) ) if ( component instanceof EditorPanel & & ( ( EditorPanel ) component ) . getName ( ) . equals ( name ) ) component . setVisible ( visible ) ; } private void rebuildActiveControllers ( ) { Array < ParticleController > effectControllers = effect . getControllers ( ) ; effectControllers . clear ( ) ; for ( ControllerData controllerData : controllersData ) { if ( controllerData . enabled ) effectControllers . add ( controllerData . controller ) ; } effect . init ( ) ; effect . start ( ) ; } public ParticleController getEmitter ( ) { return effectPanel . editIndex > = <int> ? controllersData . get ( effectPanel . editIndex ) . controller : null ; } public void addEmitter ( ParticleController emitter ) { controllersData . add ( new ControllerData ( emitter ) ) ; rebuildActiveControllers ( ) ; } public void removeEmitter ( int row ) { controllersData . removeIndex ( row ) . controller . dispose ( ) ; rebuildActiveControllers ( ) ; } public void setEnabled ( int emitterIndex , boolean enabled ) { ControllerData data = controllersData . get ( emitterIndex ) ; data . enabled = enabled ; rebuildActiveControllers ( ) ; } public boolean isEnabled ( int emitterIndex ) { return controllersData . get ( emitterIndex ) . enabled ; } private void initializeComponents ( ) { splitPane = new JSplitPane ( ) ; splitPane . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; splitPane . setDividerSize ( <int> ) ; getContentPane ( ) . add ( splitPane , BorderLayout . CENTER ) ; { JSplitPane rightSplit = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; rightSplit . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; rightSplit . setDividerSize ( <int> ) ; splitPane . add ( rightSplit , JSplitPane . RIGHT ) ; { JPanel propertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; rightSplit . add ( propertiesPanel , JSplitPane . TOP ) ; propertiesPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { JScrollPane scroll = new JScrollPane ( ) ; propertiesPanel . add ( scroll , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTH , GridBagConstraints . BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; { editorPropertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; scroll . setViewportView ( editorPropertiesPanel ) ; scroll . getVerticalScrollBar ( ) . setUnitIncrement ( <int> ) ; } } } { JSplitPane rightSplitPane = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; rightSplitPane . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; rightSplitPane . setDividerSize ( <int> ) ; rightSplitPane . setDividerLocation ( <int> ) ; rightSplit . add ( rightSplitPane , JSplitPane . BOTTOM ) ; JPanel propertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; rightSplitPane . add ( propertiesPanel , JSplitPane . TOP ) ; propertiesPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { JScrollPane scroll = new JScrollPane ( ) ; propertiesPanel . add ( scroll , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTH , GridBagConstraints . BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; { JPanel influencersPanel = new JPanel ( new GridBagLayout ( ) ) ; influencerBox = new JComboBox ( new DefaultComboBoxModel ( ) ) ; JButton addInfluencerButton = new JButton ( <str> ) ; addInfluencerButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent e ) { InfluencerWrapper wrapper = ( InfluencerWrapper ) influencerBox . getSelectedItem ( ) ; ParticleController controller = getEmitter ( ) ; if ( controller ! = null ) addInfluencer ( wrapper . type , controller ) ; } } ) ; influencersPanel . add ( influencerBox , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTHWEST , GridBagConstraints . NONE , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; influencersPanel . add ( addInfluencerButton , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTHWEST , GridBagConstraints . NONE , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setViewportView ( influencersPanel ) ; scroll . getVerticalScrollBar ( ) . setUnitIncrement ( <int> ) ; } } propertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; rightSplitPane . add ( propertiesPanel , JSplitPane . BOTTOM ) ; propertiesPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { JScrollPane scroll = new JScrollPane ( ) ; propertiesPanel . add ( scroll , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTH , GridBagConstraints . BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; { controllerPropertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; scroll . setViewportView ( controllerPropertiesPanel ) ; scroll . getVerticalScrollBar ( ) . setUnitIncrement ( <int> ) ; } } } rightSplit . setDividerLocation ( <int> ) ; } { JSplitPane leftSplit = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; leftSplit . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; leftSplit . setDividerSize ( <int> ) ; splitPane . add ( leftSplit , JSplitPane . LEFT ) ; { JPanel spacer = new JPanel ( new BorderLayout ( ) ) ; leftSplit . add ( spacer , JSplitPane . TOP ) ; spacer . add ( lwjglCanvas . getCanvas ( ) ) ; spacer . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; } { JPanel emittersPanel = new JPanel ( new BorderLayout ( ) ) ; leftSplit . add ( emittersPanel , JSplitPane . BOTTOM ) ; emittersPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { effectPanel = new EffectPanel ( this ) ; emittersPanel . add ( effectPanel ) ; } } leftSplit . setDividerLocation ( <int> ) ; } splitPane . setDividerLocation ( <int> ) ; } protected void addInfluencer ( Class < Influencer > type , ParticleController controller ) { if ( controller . findInfluencer ( type ) ! = null ) return ; try { controller . end ( ) ; Influencer newInfluencer = type . newInstance ( ) ; boolean replaced = false ; if ( ColorInfluencer . class . isAssignableFrom ( type ) ) { replaced = controller . replaceInfluencer ( ColorInfluencer . class , ( ColorInfluencer ) newInfluencer ) ; } else if ( RegionInfluencer . class . isAssignableFrom ( type ) ) { replaced = controller . replaceInfluencer ( RegionInfluencer . class , ( RegionInfluencer ) newInfluencer ) ; } else if ( ModelInfluencer . class . isAssignableFrom ( type ) ) { ModelInfluencer newModelInfluencer = ( ModelInfluencer ) newInfluencer ; ModelInfluencer currentInfluencer = ( ModelInfluencer ) controller . findInfluencer ( ModelInfluencer . class ) ; if ( currentInfluencer ! = null ) { newModelInfluencer . models . add ( currentInfluencer . models . first ( ) ) ; } replaced = controller . replaceInfluencer ( ModelInfluencer . class , ( ModelInfluencer ) newInfluencer ) ; } else if ( ParticleControllerInfluencer . class . isAssignableFrom ( type ) ) { ParticleControllerInfluencer newModelInfluencer = ( ParticleControllerInfluencer ) newInfluencer ; ParticleControllerInfluencer currentInfluencer = ( ParticleControllerInfluencer ) controller . findInfluencer ( ParticleControllerInfluencer . class ) ; if ( currentInfluencer ! = null ) { newModelInfluencer . templates . add ( currentInfluencer . templates . first ( ) ) ; } replaced = controller . replaceInfluencer ( ParticleControllerInfluencer . class , ( ParticleControllerInfluencer ) newInfluencer ) ; } if ( ! replaced ) { if ( getControllerType ( ) ! = ControllerType . ParticleController ) controller . influencers . add ( newInfluencer ) ; else { Influencer finalizer = controller . influencers . pop ( ) ; controller . influencers . add ( newInfluencer ) ; controller . influencers . add ( finalizer ) ; } } controller . init ( ) ; effect . start ( ) ; reloadRows ( ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } } protected boolean canAddInfluencer ( Class influencerType , ParticleController controller ) { boolean hasSameInfluencer = controller . findInfluencer ( influencerType ) ! = null ; if ( ! hasSameInfluencer ) { if ( ( ColorInfluencer . Single . class . isAssignableFrom ( influencerType ) & & controller . findInfluencer ( ColorInfluencer . Random . class ) ! = null ) | | ( ColorInfluencer . Random . class . isAssignableFrom ( influencerType ) & & controller . findInfluencer ( ColorInfluencer . Single . class ) ! = null ) ) { return false ; } if ( RegionInfluencer . class . isAssignableFrom ( influencerType ) ) { return controller . findInfluencer ( RegionInfluencer . class ) = = null ; } else if ( ModelInfluencer . class . isAssignableFrom ( influencerType ) ) { return controller . findInfluencer ( ModelInfluencer . class ) = = null ; } else if ( ParticleControllerInfluencer . class . isAssignableFrom ( influencerType ) ) { return controller . findInfluencer ( ParticleControllerInfluencer . class ) = = null ; } } return ! hasSameInfluencer ; } class AppRenderer implements ApplicationListener { private float maxActiveTimer ; private int maxActive , lastMaxActive ; boolean isUpdate = true ; private CameraInputController cameraInputController ; private Stage ui ; TextButton playPauseButton ; private Label fpsLabel , pointCountLabel , billboardCountLabel , modelInstanceCountLabel , maxLabel ; StringBuilder stringBuilder ; public PerspectiveCamera worldCamera ; private boolean isDrawXYZ , isDrawXZPlane , isDrawXYPlane ; private Array < Model > models ; private ModelInstance xyzInstance , xzPlaneInstance , xyPlaneInstance ; private Environment environment ; private ModelBatch modelBatch ; PointSpriteParticleBatch pointSpriteBatch ; BillboardParticleBatch billboardBatch ; ModelInstanceParticleBatch modelInstanceParticleBatch ; public void create ( ) { if ( ui ! = null ) return ; int w = Gdx . graphics . getWidth ( ) , h = Gdx . graphics . getHeight ( ) ; modelBatch = new ModelBatch ( ) ; environment = new Environment ( ) ; environment . add ( new DirectionalLight ( ) . set ( Color . WHITE , <int> , <int> , - <int> ) ) ; worldCamera = new PerspectiveCamera ( <int> , w , h ) ; worldCamera . position . set ( <int> , <int> , <int> ) ; worldCamera . lookAt ( <int> , <int> , <int> ) ; worldCamera . near = <float> ; worldCamera . far = <int> f ; worldCamera . update ( ) ; cameraInputController = new CameraInputController ( worldCamera ) ; pointSpriteBatch = new PointSpriteParticleBatch ( ) ; pointSpriteBatch . setCamera ( worldCamera ) ; billboardBatch = new BillboardParticleBatch ( ) ; billboardBatch . setCamera ( worldCamera ) ; modelInstanceParticleBatch = new ModelInstanceParticleBatch ( ) ; particleSystem . add ( billboardBatch ) ; particleSystem . add ( pointSpriteBatch ) ; particleSystem . add ( modelInstanceParticleBatch ) ; fovValue = new NumericValue ( ) ; fovValue . setValue ( <int> ) ; fovValue . setActive ( true ) ; deltaMultiplier = new NumericValue ( ) ; deltaMultiplier . setValue ( <float> ) ; deltaMultiplier . setActive ( true ) ; backgroundColor = new GradientColorValue ( ) ; Color color = Color . valueOf ( <str> ) ; backgroundColor . setColors ( new float [ ] { color . r , color . g , color . b } ) ; models = new Array < Model > ( ) ; ModelBuilder builder = new ModelBuilder ( ) ; Model xyzModel = builder . createXYZCoordinates ( <int> , new Material ( ) , Usage . Position | Usage . ColorPacked ) , planeModel = builder . createLineGrid ( <int> , <int> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . WHITE ) ) , Usage . Position ) ; models . add ( xyzModel ) ; models . add ( planeModel ) ; xyzInstance = new ModelInstance ( xyzModel ) ; xzPlaneInstance = new ModelInstance ( planeModel ) ; xyPlaneInstance = new ModelInstance ( planeModel ) ; xyPlaneInstance . transform . rotate ( <float> , <float> , <float> , <int> f ) ; setDrawXYZ ( true ) ; setDrawXZPlane ( true ) ; ParticleEffectLoader . ParticleEffectLoadParameter params = new ParticleEffectLoader . ParticleEffectLoadParameter ( particleSystem . getBatches ( ) ) ; assetManager . load ( DEFAULT_BILLBOARD_PARTICLE , Texture . class ) ; assetManager . load ( DEFAULT_MODEL_PARTICLE , Model . class ) ; assetManager . load ( DEFAULT_SKIN , Skin . class ) ; assetManager . load ( DEFAULT_TEMPLATE_PFX , ParticleEffect . class , params ) ; assetManager . finishLoading ( ) ; assetManager . setLoader ( ParticleEffect . class , new ParticleEffectLoader ( new AbsoluteFileHandleResolver ( ) ) ) ; assetManager . get ( DEFAULT_MODEL_PARTICLE , Model . class ) . materials . get ( <int> ) . set ( new BlendingAttribute ( GL20 . GL_ONE , GL20 . GL_ONE_MINUS_SRC_ALPHA , <int> ) ) ; stringBuilder = new StringBuilder ( ) ; Skin skin = assetManager . get ( DEFAULT_SKIN , Skin . class ) ; ui = new Stage ( ) ; fpsLabel = new Label ( <str> , skin ) ; pointCountLabel = new Label ( <str> , skin ) ; billboardCountLabel = new Label ( <str> , skin ) ; modelInstanceCountLabel = new Label ( <str> , skin ) ; maxLabel = new Label ( <str> , skin ) ; playPauseButton = new TextButton ( <str> , skin ) ; playPauseButton . addListener ( new ClickListener ( ) { @Override public void clicked ( InputEvent event , float x , float y ) { isUpdate = ! isUpdate ; playPauseButton . setText ( isUpdate ? <str> : <str> ) ; } } ) ; Table table = new Table ( skin ) ; table . setFillParent ( true ) ; table . pad ( <int> ) ; table . add ( fpsLabel ) . expandX ( ) . left ( ) . row ( ) ; table . add ( pointCountLabel ) . expandX ( ) . left ( ) . row ( ) ; table . add ( billboardCountLabel ) . expandX ( ) . left ( ) . row ( ) ; table . add ( modelInstanceCountLabel ) . expandX ( ) . left ( ) . row ( ) ; table . add ( maxLabel ) . expandX ( ) . left ( ) . row ( ) ; table . add ( playPauseButton ) . expand ( ) . bottom ( ) . left ( ) . row ( ) ; ui . addActor ( table ) ; setTexture ( ( Texture ) assetManager . get ( DEFAULT_BILLBOARD_PARTICLE ) ) ; effectPanel . createDefaultEmitter ( ControllerType . Billboard , true , true ) ; } @Override public void resize ( int width , int height ) { Gdx . input . setInputProcessor ( new InputMultiplexer ( ui , cameraInputController ) ) ; Gdx . gl . glViewport ( <int> , <int> , width , height ) ; worldCamera . viewportWidth = width ; worldCamera . viewportHeight = height ; worldCamera . update ( ) ; ui . getViewport ( ) . setWorldSize ( width , height ) ; ui . getViewport ( ) . update ( width , height , true ) ; } public void render ( ) { update ( ) ; renderWorld ( ) ; } private void update ( ) { worldCamera . fieldOfView = fovValue . getValue ( ) ; worldCamera . update ( ) ; cameraInputController . update ( ) ; if ( isUpdate ) { particleSystem . update ( ) ; stringBuilder . delete ( <int> , stringBuilder . length ) ; stringBuilder . append ( <str> ) . append ( pointSpriteBatch . getBufferedCount ( ) ) ; pointCountLabel . setText ( stringBuilder ) ; stringBuilder . delete ( <int> , stringBuilder . length ) ; stringBuilder . append ( <str> ) . append ( billboardBatch . getBufferedCount ( ) ) ; billboardCountLabel . setText ( stringBuilder ) ; stringBuilder . delete ( <int> , stringBuilder . length ) ; stringBuilder . append ( <str> ) . append ( modelInstanceParticleBatch . getBufferedCount ( ) ) ; modelInstanceCountLabel . setText ( stringBuilder ) ; } stringBuilder . delete ( <int> , stringBuilder . length ) ; stringBuilder . append ( <str> ) . append ( Gdx . graphics . getFramesPerSecond ( ) ) ; fpsLabel . setText ( stringBuilder ) ; ui . act ( Gdx . graphics . getDeltaTime ( ) ) ; } private void renderWorld ( ) { float [ ] colors = backgroundColor . getColors ( ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; Gdx . gl . glClearColor ( colors [ <int> ] , colors [ <int> ] , colors [ <int> ] , <int> ) ; modelBatch . begin ( worldCamera ) ; if ( isDrawXYZ ) modelBatch . render ( xyzInstance ) ; if ( isDrawXZPlane ) modelBatch . render ( xzPlaneInstance ) ; if ( isDrawXYPlane ) modelBatch . render ( xyPlaneInstance ) ; particleSystem . begin ( ) ; particleSystem . draw ( ) ; particleSystem . end ( ) ; modelBatch . render ( particleSystem , environment ) ; modelBatch . end ( ) ; ui . draw ( ) ; } @Override public void dispose ( ) { } @Override public void pause ( ) { } @Override public void resume ( ) { } public void setDrawXYZ ( boolean isDraw ) { isDrawXYZ = isDraw ; } public boolean IsDrawXYZ ( ) { return isDrawXYZ ; } public void setDrawXZPlane ( boolean isDraw ) { isDrawXZPlane = isDraw ; } public boolean IsDrawXZPlane ( ) { return isDrawXZPlane ; } public void setDrawXYPlane ( boolean isDraw ) { isDrawXYPlane = isDraw ; } public boolean IsDrawXYPlane ( ) { return isDrawXYPlane ; } } public static void main ( String [ ] args ) { for ( LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { if ( <str> . equals ( info . getName ( ) ) ) { try { UIManager . setLookAndFeel ( info . getClassName ( ) ) ; } catch ( Throwable ignored ) { } break ; } } EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new FlameMain ( ) ; } } ) ; } public AppRenderer getRenderer ( ) { return renderer ; } String lastDir ; public File showFileLoadDialog ( ) { return showFileDialog ( <str> , FileDialog . LOAD ) ; } public File showFileSaveDialog ( ) { return showFileDialog ( <str> , FileDialog . SAVE ) ; } private File showFileDialog ( String title , int mode ) { FileDialog dialog = new FileDialog ( this , title , mode ) ; if ( lastDir ! = null ) dialog . setDirectory ( lastDir ) ; dialog . setVisible ( true ) ; final String file = dialog . getFile ( ) ; final String dir = dialog . getDirectory ( ) ; if ( dir = = null | | file = = null | | file . trim ( ) . length ( ) = = <int> ) return null ; lastDir = dir ; return new File ( dir , file ) ; } @Override public void error ( AssetDescriptor asset , Throwable throwable ) { throwable . printStackTrace ( ) ; } public PointSpriteParticleBatch getPointSpriteBatch ( ) { return renderer . pointSpriteBatch ; } public BillboardParticleBatch getBillboardBatch ( ) { return renderer . billboardBatch ; } public ModelInstanceParticleBatch getModelInstanceParticleBatch ( ) { return renderer . modelInstanceParticleBatch ; } public void setAtlas ( TextureAtlas atlas ) { setTexture ( atlas . getTextures ( ) . first ( ) ) ; } public void setTexture ( Texture texture ) { renderer . billboardBatch . setTexture ( texture ) ; renderer . pointSpriteBatch . setTexture ( texture ) ; } public Texture getTexture ( ) { return renderer . billboardBatch . getTexture ( ) ; } public TextureAtlas getAtlas ( Texture texture ) { Array < TextureAtlas > atlases = assetManager . getAll ( TextureAtlas . class , new Array < TextureAtlas > ( ) ) ; for ( TextureAtlas atlas : atlases ) { if ( atlas . getTextures ( ) . contains ( texture ) ) return atlas ; } return null ; } public TextureAtlas getAtlas ( ) { return getAtlas ( renderer . billboardBatch . getTexture ( ) ) ; } public boolean isUsingDefaultTexture ( ) { return renderer . billboardBatch . getTexture ( ) = = assetManager . get ( DEFAULT_BILLBOARD_PARTICLE , Texture . class ) ; } public Array < ParticleEffect > getParticleEffects ( Array < ParticleController > controllers , Array < ParticleEffect > out ) { out . clear ( ) ; assetManager . getAll ( ParticleEffect . class , out ) ; for ( int i = <int> ; i < out . size ; ) { ParticleEffect effect = out . get ( i ) ; Array < ParticleController > effectControllers = effect . getControllers ( ) ; boolean remove = true ; for ( ParticleController controller : controllers ) { if ( effectControllers . contains ( controller , true ) ) { remove = false ; break ; } } if ( remove ) { out . removeIndex ( i ) ; continue ; } + + i ; } return out ; } public void saveEffect ( File file ) { Writer fileWriter = null ; try { ParticleEffectLoader loader = ( ParticleEffectLoader ) assetManager . getLoader ( ParticleEffect . class ) ; loader . save ( effect , new ParticleEffectSaveParameter ( new FileHandle ( file . getAbsolutePath ( ) ) , assetManager , particleSystem . getBatches ( ) ) ) ; } catch ( Exception ex ) { System . out . println ( <str> + file . getAbsolutePath ( ) ) ; ex . printStackTrace ( ) ; JOptionPane . showMessageDialog ( this , <str> ) ; } finally { StreamUtils . closeQuietly ( fileWriter ) ; } } public ParticleEffect openEffect ( File file , boolean replaceCurrentWorkspace ) { try { ParticleEffect loadedEffect = load ( file . getAbsolutePath ( ) , ParticleEffect . class , null , new ParticleEffectLoader . ParticleEffectLoadParameter ( particleSystem . getBatches ( ) ) ) ; loadedEffect = loadedEffect . copy ( ) ; loadedEffect . init ( ) ; if ( replaceCurrentWorkspace ) { effect = loadedEffect ; controllersData . clear ( ) ; particleSystem . removeAll ( ) ; particleSystem . add ( effect ) ; for ( ParticleController controller : effect . getControllers ( ) ) controllersData . add ( new ControllerData ( controller ) ) ; rebuildActiveControllers ( ) ; } reloadRows ( ) ; return loadedEffect ; } catch ( Exception ex ) { System . out . println ( <str> + file . getAbsolutePath ( ) ) ; ex . printStackTrace ( ) ; JOptionPane . showMessageDialog ( this , <str> ) ; } return null ; } public < T > T load ( String resource , Class < T > type , AssetLoader loader , AssetLoaderParameters < T > params ) { String resolvedPath = new String ( resource ) . replaceAll ( <str> , <str> ) ; boolean exist = assetManager . isLoaded ( resolvedPath , type ) ; T oldAsset = null ; if ( exist ) { oldAsset = assetManager . get ( resolvedPath , type ) ; for ( int i = assetManager . getReferenceCount ( resolvedPath ) ; i > <int> ; - - i ) assetManager . unload ( resolvedPath ) ; } AssetLoader < T , AssetLoaderParameters < T > > currentLoader = assetManager . getLoader ( type ) ; if ( loader ! = null ) assetManager . setLoader ( type , loader ) ; assetManager . load ( resource , type , params ) ; assetManager . finishLoading ( ) ; T res = assetManager . get ( resolvedPath ) ; if ( currentLoader ! = null ) assetManager . setLoader ( type , currentLoader ) ; if ( exist ) EventManager . get ( ) . fire ( EVT_ASSET_RELOADED , new Object [ ] { oldAsset , res } ) ; return res ; } public void restart ( ) { effect . init ( ) ; effect . start ( ) ; } } 
