package com . google . common . primitives ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import java . util . Random ; public class UnsignedLongsBenchmark { private static final int ARRAY_SIZE = <hex> ; private static final int ARRAY_MASK = <hex> ; private static final Random RANDOM_SOURCE = new Random ( <int> ) ; private static final long [ ] longs = new long [ ARRAY_SIZE ] ; private static final long [ ] divisors = new long [ ARRAY_SIZE ] ; private static final String [ ] decimalStrings = new String [ ARRAY_SIZE ] ; private static final String [ ] binaryStrings = new String [ ARRAY_SIZE ] ; private static final String [ ] hexStrings = new String [ ARRAY_SIZE ] ; private static final String [ ] prefixedHexStrings = new String [ ARRAY_SIZE ] ; @BeforeExperiment void setUp ( ) { for ( int i = <int> ; i < ARRAY_SIZE ; i + + ) { longs [ i ] = random ( ) ; divisors [ i ] = randomDivisor ( longs [ i ] ) ; decimalStrings [ i ] = UnsignedLongs . toString ( longs [ i ] ) ; binaryStrings [ i ] = UnsignedLongs . toString ( longs [ i ] , <int> ) ; hexStrings [ i ] = UnsignedLongs . toString ( longs [ i ] , <int> ) ; prefixedHexStrings [ i ] = <str> + hexStrings [ i ] ; } } @Benchmark long divide ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = UnsignedLongs . divide ( longs [ j ] , divisors [ j ] ) ; } return tmp ; } @Benchmark long remainder ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = UnsignedLongs . remainder ( longs [ j ] , divisors [ j ] ) ; } return tmp ; } @Benchmark long parseUnsignedLong ( int reps ) { long tmp = <int> ; int scaledReps = reps / <int> + <int> ; for ( int i = <int> ; i < scaledReps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = UnsignedLongs . parseUnsignedLong ( decimalStrings [ j ] ) ; tmp + = UnsignedLongs . parseUnsignedLong ( hexStrings [ j ] , <int> ) ; tmp + = UnsignedLongs . parseUnsignedLong ( binaryStrings [ j ] , <int> ) ; } return tmp ; } @Benchmark long parseDecode10 ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = UnsignedLongs . decode ( decimalStrings [ j ] ) ; } return tmp ; } @Benchmark long parseDecode16 ( int reps ) { long tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = UnsignedLongs . decode ( prefixedHexStrings [ j ] ) ; } return tmp ; } @Benchmark int toString ( int reps ) { int tmp = <int> ; int scaledReps = reps / <int> + <int> ; for ( int i = <int> ; i < scaledReps ; i + + ) { int j = i & ARRAY_MASK ; long x = longs [ j ] ; tmp + = UnsignedLongs . toString ( x ) . length ( ) ; tmp + = UnsignedLongs . toString ( x , <int> ) . length ( ) ; tmp + = UnsignedLongs . toString ( x , <int> ) . length ( ) ; } return tmp ; } private static long random ( ) { return RANDOM_SOURCE . nextLong ( ) ; } private static long randomDivisor ( long dividend ) { long r = RANDOM_SOURCE . nextLong ( ) ; if ( dividend = = - <int> ) { return r ; } else { return UnsignedLongs . remainder ( r , dividend + <int> ) ; } } } 
