package org . eclipse . debug . internal . ui . viewers . update ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IWatchExpression ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . debug . ui . contexts . IDebugContextService ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . widgets . Control ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . progress . UIJob ; public class DefaultWatchExpressionModelProxy extends DefaultExpressionModelProxy implements IDebugContextListener { private IWorkbenchWindow fWindow ; public DefaultWatchExpressionModelProxy ( IWatchExpression expression ) { super ( expression ) ; } @Override public void installed ( final Viewer viewer ) { super . installed ( viewer ) ; UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( ! isDisposed ( ) ) { IWorkbenchWindow [ ] workbenchWindows = PlatformUI . getWorkbench ( ) . getWorkbenchWindows ( ) ; for ( int i = <int> ; i < workbenchWindows . length ; i + + ) { IWorkbenchWindow window = workbenchWindows [ i ] ; Control control = viewer . getControl ( ) ; if ( control ! = null & & control . getShell ( ) . equals ( window . getShell ( ) ) ) { fWindow = window ; break ; } } if ( fWindow = = null ) { fWindow = DebugUIPlugin . getActiveWorkbenchWindow ( ) ; } IDebugContextService contextService = DebugUITools . getDebugContextManager ( ) . getContextService ( fWindow ) ; contextService . addDebugContextListener ( DefaultWatchExpressionModelProxy . this ) ; ISelection activeContext = contextService . getActiveContext ( ) ; if ( activeContext ! = null ) { contextActivated ( activeContext ) ; } } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } @Override public synchronized void dispose ( ) { super . dispose ( ) ; if ( fWindow ! = null ) { DebugUITools . getDebugContextManager ( ) . getContextService ( fWindow ) . removeDebugContextListener ( this ) ; fWindow = null ; } } @Override protected DebugEventHandler [ ] createEventHandlers ( ) { return new DebugEventHandler [ ] { new ExpressionEventHandler ( this ) } ; } protected void contextActivated ( ISelection selection ) { if ( fWindow ! = null ) { if ( selection instanceof IStructuredSelection ) { IDebugElement context = null ; IStructuredSelection ss = ( IStructuredSelection ) selection ; if ( ss . size ( ) < <int> ) { Object object = ss . getFirstElement ( ) ; if ( object instanceof IDebugElement ) { context = ( IDebugElement ) object ; } else if ( object instanceof ILaunch ) { context = ( ( ILaunch ) object ) . getDebugTarget ( ) ; } } IWatchExpression expression = ( IWatchExpression ) getExpression ( ) ; if ( expression ! = null ) { expression . setExpressionContext ( context ) ; } } } } @Override public void debugContextChanged ( DebugContextEvent event ) { if ( ( event . getFlags ( ) & DebugContextEvent . ACTIVATED ) > <int> ) { contextActivated ( event . getContext ( ) ) ; } } } 
