package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufInputStream ; import io . netty . buffer . ByteBufOutputStream ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToByteEncoder ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import lzma . sdk . lzma . Base ; import lzma . sdk . lzma . Encoder ; import java . io . InputStream ; import static lzma . sdk . lzma . Encoder . * ; public class LzmaFrameEncoder extends MessageToByteEncoder < ByteBuf > { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( LzmaFrameEncoder . class ) ; private static final int MEDIUM_DICTIONARY_SIZE = <int> < < <int> ; private static final int MIN_FAST_BYTES = <int> ; private static final int MEDIUM_FAST_BYTES = <hex> ; private static final int MAX_FAST_BYTES = Base . kMatchMaxLen ; private static final int DEFAULT_MATCH_FINDER = EMatchFinderTypeBT4 ; private static final int DEFAULT_LC = <int> ; private static final int DEFAULT_LP = <int> ; private static final int DEFAULT_PB = <int> ; private final Encoder encoder ; private final byte properties ; private final int littleEndianDictionarySize ; private static boolean warningLogged ; public LzmaFrameEncoder ( ) { this ( MEDIUM_DICTIONARY_SIZE ) ; } public LzmaFrameEncoder ( int lc , int lp , int pb ) { this ( lc , lp , pb , MEDIUM_DICTIONARY_SIZE ) ; } public LzmaFrameEncoder ( int dictionarySize ) { this ( DEFAULT_LC , DEFAULT_LP , DEFAULT_PB , dictionarySize ) ; } public LzmaFrameEncoder ( int lc , int lp , int pb , int dictionarySize ) { this ( lc , lp , pb , dictionarySize , false , MEDIUM_FAST_BYTES ) ; } public LzmaFrameEncoder ( int lc , int lp , int pb , int dictionarySize , boolean endMarkerMode , int numFastBytes ) { if ( lc < <int> | | lc > <int> ) { throw new IllegalArgumentException ( <str> + lc + <str> ) ; } if ( lp < <int> | | lp > <int> ) { throw new IllegalArgumentException ( <str> + lp + <str> ) ; } if ( pb < <int> | | pb > <int> ) { throw new IllegalArgumentException ( <str> + pb + <str> ) ; } if ( lc + lp > <int> ) { if ( ! warningLogged ) { logger . warn ( <str> + <str> + <str> ) ; warningLogged = true ; } } if ( dictionarySize < <int> ) { throw new IllegalArgumentException ( <str> + dictionarySize + <str> ) ; } if ( numFastBytes < MIN_FAST_BYTES | | numFastBytes > MAX_FAST_BYTES ) { throw new IllegalArgumentException ( String . format ( <str> , numFastBytes , MIN_FAST_BYTES , MAX_FAST_BYTES ) ) ; } encoder = new Encoder ( ) ; encoder . setDictionarySize ( dictionarySize ) ; encoder . setEndMarkerMode ( endMarkerMode ) ; encoder . setMatchFinder ( DEFAULT_MATCH_FINDER ) ; encoder . setNumFastBytes ( numFastBytes ) ; encoder . setLcLpPb ( lc , lp , pb ) ; properties = ( byte ) ( ( pb * <int> + lp ) * <int> + lc ) ; littleEndianDictionarySize = Integer . reverseBytes ( dictionarySize ) ; } @Override protected void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { final int length = in . readableBytes ( ) ; final InputStream bbIn = new ByteBufInputStream ( in ) ; final ByteBufOutputStream bbOut = new ByteBufOutputStream ( out ) ; bbOut . writeByte ( properties ) ; bbOut . writeInt ( littleEndianDictionarySize ) ; bbOut . writeLong ( Long . reverseBytes ( length ) ) ; encoder . code ( bbIn , bbOut , - <int> , - <int> , null ) ; bbIn . close ( ) ; bbOut . close ( ) ; } @Override protected ByteBuf allocateBuffer ( ChannelHandlerContext ctx , ByteBuf in , boolean preferDirect ) throws Exception { final int length = in . readableBytes ( ) ; final int maxOutputLength = maxOutputBufferLength ( length ) ; return ctx . alloc ( ) . ioBuffer ( maxOutputLength ) ; } private static int maxOutputBufferLength ( int inputLength ) { double factor ; if ( inputLength < <int> ) { factor = <float> ; } else if ( inputLength < <int> ) { factor = <float> ; } else if ( inputLength < <int> ) { factor = <float> ; } else if ( inputLength < <int> ) { factor = <float> ; } else { factor = <float> ; } return <int> + ( int ) ( inputLength * factor ) ; } } 
