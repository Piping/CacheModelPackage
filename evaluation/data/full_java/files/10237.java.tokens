package com . google . common . base ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . GcFinalization ; import junit . framework . TestCase ; import java . lang . ref . WeakReference ; import java . util . Iterator ; import java . util . NoSuchElementException ; @GwtCompatible ( emulated = true ) public class AbstractIteratorTest extends TestCase { public void testDefaultBehaviorOfNextAndHasNext ( ) { Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { private int rep ; @Override public Integer computeNext ( ) { switch ( rep + + ) { case <int> : return <int> ; case <int> : return <int> ; case <int> : return endOfData ( ) ; default : fail ( <str> ) ; return null ; } } } ; assertTrue ( iter . hasNext ( ) ) ; assertEquals ( <int> , ( int ) iter . next ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; assertTrue ( iter . hasNext ( ) ) ; assertEquals ( <int> , ( int ) iter . next ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; assertFalse ( iter . hasNext ( ) ) ; try { iter . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException expected ) { } } public void testSneakyThrow ( ) throws Exception { Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { boolean haveBeenCalled ; @Override public Integer computeNext ( ) { if ( haveBeenCalled ) { fail ( <str> ) ; } else { haveBeenCalled = true ; sneakyThrow ( new SomeCheckedException ( ) ) ; } return null ; } } ; try { iter . hasNext ( ) ; fail ( <str> ) ; } catch ( Exception e ) { if ( ! ( e instanceof SomeCheckedException ) ) { throw e ; } } try { iter . hasNext ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testException ( ) { final SomeUncheckedException exception = new SomeUncheckedException ( ) ; Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { @Override public Integer computeNext ( ) { throw exception ; } } ; try { iter . hasNext ( ) ; fail ( <str> ) ; } catch ( SomeUncheckedException e ) { assertSame ( exception , e ) ; } } public void testExceptionAfterEndOfData ( ) { Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { @Override public Integer computeNext ( ) { endOfData ( ) ; throw new SomeUncheckedException ( ) ; } } ; try { iter . hasNext ( ) ; fail ( <str> ) ; } catch ( SomeUncheckedException expected ) { } } public void testCantRemove ( ) { Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { boolean haveBeenCalled ; @Override public Integer computeNext ( ) { if ( haveBeenCalled ) { endOfData ( ) ; } haveBeenCalled = true ; return <int> ; } } ; assertEquals ( <int> , ( int ) iter . next ( ) ) ; try { iter . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testFreesNextReference ( ) { Iterator < Object > itr = new AbstractIterator < Object > ( ) { @Override public Object computeNext ( ) { return new Object ( ) ; } } ; WeakReference < Object > ref = new WeakReference < Object > ( itr . next ( ) ) ; GcFinalization . awaitClear ( ref ) ; } public void testReentrantHasNext ( ) { Iterator < Integer > iter = new AbstractIterator < Integer > ( ) { @Override protected Integer computeNext ( ) { hasNext ( ) ; return null ; } } ; try { iter . hasNext ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } private static void sneakyThrow ( Throwable t ) { class SneakyThrower < T extends Throwable > { @SuppressWarnings ( <str> ) void throwIt ( Throwable t ) throws T { throw ( T ) t ; } } new SneakyThrower < Error > ( ) . throwIt ( t ) ; } private static class SomeCheckedException extends Exception { } private static class SomeUncheckedException extends RuntimeException { } } 
