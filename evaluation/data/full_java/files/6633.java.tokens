package org . elasticsearch . index . query ; import org . apache . lucene . queries . ExtendedCommonTermsQuery ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . FuzzyQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . support . QueryParsers ; import org . elasticsearch . index . search . MatchQuery ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public class MatchQueryBuilder extends AbstractQueryBuilder < MatchQueryBuilder > { public static final String NAME = <str> ; public static final Operator DEFAULT_OPERATOR = Operator . OR ; public static final MatchQuery . Type DEFAULT_TYPE = MatchQuery . Type . BOOLEAN ; private final String fieldName ; private final Object value ; private MatchQuery . Type type = DEFAULT_TYPE ; private Operator operator = DEFAULT_OPERATOR ; private String analyzer ; private int slop = MatchQuery . DEFAULT_PHRASE_SLOP ; private Fuzziness fuzziness = null ; private int prefixLength = FuzzyQuery . defaultPrefixLength ; private int maxExpansions = FuzzyQuery . defaultMaxExpansions ; private boolean fuzzyTranspositions = FuzzyQuery . defaultTranspositions ; private String minimumShouldMatch ; private String fuzzyRewrite = null ; private boolean lenient = MatchQuery . DEFAULT_LENIENCY ; private MatchQuery . ZeroTermsQuery zeroTermsQuery = MatchQuery . DEFAULT_ZERO_TERMS_QUERY ; private Float cutoffFrequency = null ; static final MatchQueryBuilder PROTOTYPE = new MatchQueryBuilder ( <str> , <str> ) ; public MatchQueryBuilder ( String fieldName , Object value ) { if ( fieldName = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } if ( value = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . fieldName = fieldName ; this . value = value ; } public String fieldName ( ) { return this . fieldName ; } public Object value ( ) { return this . value ; } public MatchQueryBuilder type ( MatchQuery . Type type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . type = type ; return this ; } public MatchQuery . Type type ( ) { return this . type ; } public MatchQueryBuilder operator ( Operator operator ) { if ( operator = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . operator = operator ; return this ; } public Operator operator ( ) { return this . operator ; } public MatchQueryBuilder analyzer ( String analyzer ) { this . analyzer = analyzer ; return this ; } public String analyzer ( ) { return this . analyzer ; } public MatchQueryBuilder slop ( int slop ) { if ( slop < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . slop = slop ; return this ; } public int slop ( ) { return this . slop ; } public MatchQueryBuilder fuzziness ( Object fuzziness ) { this . fuzziness = Fuzziness . build ( fuzziness ) ; return this ; } public Fuzziness fuzziness ( ) { return this . fuzziness ; } public MatchQueryBuilder prefixLength ( int prefixLength ) { if ( prefixLength < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . prefixLength = prefixLength ; return this ; } public int prefixLength ( ) { return this . prefixLength ; } public MatchQueryBuilder maxExpansions ( int maxExpansions ) { if ( maxExpansions < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxExpansions = maxExpansions ; return this ; } public int maxExpansions ( ) { return this . maxExpansions ; } public MatchQueryBuilder cutoffFrequency ( float cutoff ) { this . cutoffFrequency = cutoff ; return this ; } public Float cutoffFrequency ( ) { return this . cutoffFrequency ; } public MatchQueryBuilder minimumShouldMatch ( String minimumShouldMatch ) { this . minimumShouldMatch = minimumShouldMatch ; return this ; } public String minimumShouldMatch ( ) { return this . minimumShouldMatch ; } public MatchQueryBuilder fuzzyRewrite ( String fuzzyRewrite ) { this . fuzzyRewrite = fuzzyRewrite ; return this ; } public String fuzzyRewrite ( ) { return this . fuzzyRewrite ; } public MatchQueryBuilder fuzzyTranspositions ( boolean fuzzyTranspositions ) { this . fuzzyTranspositions = fuzzyTranspositions ; return this ; } public boolean fuzzyTranspositions ( ) { return this . fuzzyTranspositions ; } @Deprecated public MatchQueryBuilder setLenient ( boolean lenient ) { return lenient ( lenient ) ; } public MatchQueryBuilder lenient ( boolean lenient ) { this . lenient = lenient ; return this ; } public boolean lenient ( ) { return this . lenient ; } public MatchQueryBuilder zeroTermsQuery ( MatchQuery . ZeroTermsQuery zeroTermsQuery ) { if ( zeroTermsQuery = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . zeroTermsQuery = zeroTermsQuery ; return this ; } public MatchQuery . ZeroTermsQuery zeroTermsQuery ( ) { return this . zeroTermsQuery ; } @Override public void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; builder . field ( MatchQueryParser . QUERY_FIELD . getPreferredName ( ) , value ) ; builder . field ( MatchQueryParser . TYPE_FIELD . getPreferredName ( ) , type . toString ( ) . toLowerCase ( Locale . ENGLISH ) ) ; builder . field ( MatchQueryParser . OPERATOR_FIELD . getPreferredName ( ) , operator . toString ( ) ) ; if ( analyzer ! = null ) { builder . field ( MatchQueryParser . ANALYZER_FIELD . getPreferredName ( ) , analyzer ) ; } builder . field ( MatchQueryParser . SLOP_FIELD . getPreferredName ( ) , slop ) ; if ( fuzziness ! = null ) { fuzziness . toXContent ( builder , params ) ; } builder . field ( MatchQueryParser . PREFIX_LENGTH_FIELD . getPreferredName ( ) , prefixLength ) ; builder . field ( MatchQueryParser . MAX_EXPANSIONS_FIELD . getPreferredName ( ) , maxExpansions ) ; if ( minimumShouldMatch ! = null ) { builder . field ( MatchQueryParser . MINIMUM_SHOULD_MATCH_FIELD . getPreferredName ( ) , minimumShouldMatch ) ; } if ( fuzzyRewrite ! = null ) { builder . field ( MatchQueryParser . FUZZY_REWRITE_FIELD . getPreferredName ( ) , fuzzyRewrite ) ; } builder . field ( MatchQueryParser . FUZZY_TRANSPOSITIONS_FIELD . getPreferredName ( ) , fuzzyTranspositions ) ; builder . field ( MatchQueryParser . LENIENT_FIELD . getPreferredName ( ) , lenient ) ; builder . field ( MatchQueryParser . ZERO_TERMS_QUERY_FIELD . getPreferredName ( ) , zeroTermsQuery . toString ( ) ) ; if ( cutoffFrequency ! = null ) { builder . field ( MatchQueryParser . CUTOFF_FREQUENCY_FIELD . getPreferredName ( ) , cutoffFrequency ) ; } printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; builder . endObject ( ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { if ( analyzer ! = null & & context . getAnalysisService ( ) . analyzer ( analyzer ) = = null ) { throw new QueryShardException ( context , <str> + analyzer + <str> ) ; } MatchQuery matchQuery = new MatchQuery ( context ) ; matchQuery . setOccur ( operator . toBooleanClauseOccur ( ) ) ; matchQuery . setAnalyzer ( analyzer ) ; matchQuery . setPhraseSlop ( slop ) ; matchQuery . setFuzziness ( fuzziness ) ; matchQuery . setFuzzyPrefixLength ( prefixLength ) ; matchQuery . setMaxExpansions ( maxExpansions ) ; matchQuery . setTranspositions ( fuzzyTranspositions ) ; matchQuery . setFuzzyRewriteMethod ( QueryParsers . parseRewriteMethod ( context . parseFieldMatcher ( ) , fuzzyRewrite , null ) ) ; matchQuery . setLenient ( lenient ) ; matchQuery . setCommonTermsCutoff ( cutoffFrequency ) ; matchQuery . setZeroTermsQuery ( zeroTermsQuery ) ; Query query = matchQuery . parse ( type , fieldName , value ) ; if ( query = = null ) { return null ; } if ( query instanceof BooleanQuery ) { query = Queries . applyMinimumShouldMatch ( ( BooleanQuery ) query , minimumShouldMatch ) ; } else if ( query instanceof ExtendedCommonTermsQuery ) { ( ( ExtendedCommonTermsQuery ) query ) . setLowFreqMinimumNumberShouldMatch ( minimumShouldMatch ) ; } return query ; } @Override protected boolean doEquals ( MatchQueryBuilder other ) { return Objects . equals ( fieldName , other . fieldName ) & & Objects . equals ( value , other . value ) & & Objects . equals ( type , other . type ) & & Objects . equals ( operator , other . operator ) & & Objects . equals ( analyzer , other . analyzer ) & & Objects . equals ( slop , other . slop ) & & Objects . equals ( fuzziness , other . fuzziness ) & & Objects . equals ( prefixLength , other . prefixLength ) & & Objects . equals ( maxExpansions , other . maxExpansions ) & & Objects . equals ( minimumShouldMatch , other . minimumShouldMatch ) & & Objects . equals ( fuzzyRewrite , other . fuzzyRewrite ) & & Objects . equals ( lenient , other . lenient ) & & Objects . equals ( fuzzyTranspositions , other . fuzzyTranspositions ) & & Objects . equals ( zeroTermsQuery , other . zeroTermsQuery ) & & Objects . equals ( cutoffFrequency , other . cutoffFrequency ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( fieldName , value , type , operator , analyzer , slop , fuzziness , prefixLength , maxExpansions , minimumShouldMatch , fuzzyRewrite , lenient , fuzzyTranspositions , zeroTermsQuery , cutoffFrequency ) ; } @Override protected MatchQueryBuilder doReadFrom ( StreamInput in ) throws IOException { MatchQueryBuilder matchQuery = new MatchQueryBuilder ( in . readString ( ) , in . readGenericValue ( ) ) ; matchQuery . type = MatchQuery . Type . readTypeFrom ( in ) ; matchQuery . operator = Operator . readOperatorFrom ( in ) ; matchQuery . slop = in . readVInt ( ) ; matchQuery . prefixLength = in . readVInt ( ) ; matchQuery . maxExpansions = in . readVInt ( ) ; matchQuery . fuzzyTranspositions = in . readBoolean ( ) ; matchQuery . lenient = in . readBoolean ( ) ; matchQuery . zeroTermsQuery = MatchQuery . ZeroTermsQuery . readZeroTermsQueryFrom ( in ) ; matchQuery . analyzer = in . readOptionalString ( ) ; matchQuery . minimumShouldMatch = in . readOptionalString ( ) ; matchQuery . fuzzyRewrite = in . readOptionalString ( ) ; if ( in . readBoolean ( ) ) { matchQuery . fuzziness = Fuzziness . readFuzzinessFrom ( in ) ; } if ( in . readBoolean ( ) ) { matchQuery . cutoffFrequency = in . readFloat ( ) ; } return matchQuery ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; out . writeGenericValue ( value ) ; type . writeTo ( out ) ; operator . writeTo ( out ) ; out . writeVInt ( slop ) ; out . writeVInt ( prefixLength ) ; out . writeVInt ( maxExpansions ) ; out . writeBoolean ( fuzzyTranspositions ) ; out . writeBoolean ( lenient ) ; zeroTermsQuery . writeTo ( out ) ; out . writeOptionalString ( analyzer ) ; out . writeOptionalString ( minimumShouldMatch ) ; out . writeOptionalString ( fuzzyRewrite ) ; if ( fuzziness = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; fuzziness . writeTo ( out ) ; } if ( cutoffFrequency = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeFloat ( cutoffFrequency ) ; } } @Override public String getWriteableName ( ) { return NAME ; } } 
