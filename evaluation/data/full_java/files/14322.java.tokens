package org . gradle . model . internal . core . rule . describe ; import com . google . common . base . Objects ; import net . jcip . annotations . ThreadSafe ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . specs . Spec ; import org . gradle . model . internal . method . WeaklyTypeReferencingMethod ; import org . gradle . model . internal . type . ModelType ; import org . gradle . util . CollectionUtils ; import java . io . IOException ; import java . lang . reflect . Method ; import java . util . List ; @ThreadSafe public class MethodModelRuleDescriptor extends AbstractModelRuleDescriptor { private final WeaklyTypeReferencingMethod < ? , ? > method ; private String description ; public MethodModelRuleDescriptor ( ModelType < ? > target , ModelType < ? > returnType , Method method ) { this ( WeaklyTypeReferencingMethod . of ( target , returnType , method ) ) ; } public MethodModelRuleDescriptor ( WeaklyTypeReferencingMethod < ? , ? > method ) { this . method = method ; } public void describeTo ( Appendable appendable ) { try { appendable . append ( getDescription ( ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } private String getDescription ( ) { if ( description = = null ) { description = getClassName ( ) + <str> + method . getName ( ) ; } return description ; } private String getClassName ( ) { return method . getDeclaringType ( ) . getDisplayName ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } MethodModelRuleDescriptor that = ( MethodModelRuleDescriptor ) o ; return Objects . equal ( method , that . method ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( method ) ; } public static ModelRuleDescriptor of ( Class < ? > clazz , final String methodName ) { List < Method > methodsOfName = CollectionUtils . filter ( clazz . getDeclaredMethods ( ) , new Spec < Method > ( ) { public boolean isSatisfiedBy ( Method element ) { return element . getName ( ) . equals ( methodName ) ; } } ) ; if ( methodsOfName . isEmpty ( ) ) { throw new IllegalStateException ( <str> + clazz . getName ( ) + <str> + methodName + <str> ) ; } if ( methodsOfName . size ( ) > <int> ) { throw new IllegalStateException ( <str> + clazz . getName ( ) + <str> + methodName + <str> ) ; } Method method = methodsOfName . get ( <int> ) ; return of ( clazz , method ) ; } public static ModelRuleDescriptor of ( Class < ? > clazz , Method method ) { return new MethodModelRuleDescriptor ( ModelType . of ( clazz ) , ModelType . returnType ( method ) , method ) ; } } 
