package org . eclipse . debug . internal . ui . views . breakpoints ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IBreakpointManager ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointContainer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . ui . IBreakpointOrganizerDelegateExtension ; import org . eclipse . jface . viewers . CheckboxTreeViewer ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . swt . widgets . Widget ; public class BreakpointsViewer extends CheckboxTreeViewer { public BreakpointsViewer ( Tree tree ) { super ( tree ) ; } public Item [ ] getSelectedItems ( ) { return getSelection ( getControl ( ) ) ; } public Widget searchItem ( Object element ) { return findItem ( element ) ; } public void refreshItem ( TreeItem item ) { updateItem ( item , item . getData ( ) ) ; } public IBreakpoint [ ] getVisibleBreakpoints ( ) { IBreakpointManager manager = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) ; Object [ ] elements = ( ( ITreeContentProvider ) getContentProvider ( ) ) . getElements ( manager ) ; List < IBreakpoint > list = new ArrayList < IBreakpoint > ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { TreeItem item = ( TreeItem ) searchItem ( elements [ i ] ) ; if ( item ! = null ) { collectExpandedBreakpoints ( item , list ) ; } } return list . toArray ( new IBreakpoint [ list . size ( ) ] ) ; } private void collectExpandedBreakpoints ( TreeItem item , List < IBreakpoint > list ) { Object data = item . getData ( ) ; if ( data instanceof IBreakpoint ) { list . add ( ( IBreakpoint ) data ) ; return ; } if ( item . getExpanded ( ) ) { TreeItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { collectExpandedBreakpoints ( items [ i ] , list ) ; } } } protected void setSelection ( TreeItem item ) { getTree ( ) . setSelection ( new TreeItem [ ] { item } ) ; updateSelection ( getSelection ( ) ) ; } public IBreakpointContainer getRemovableContainer ( Item item ) { if ( item = = null ) { return null ; } if ( item . getData ( ) instanceof IBreakpoint ) { TreePath path = getTreePathFromItem ( item ) ; if ( path ! = null ) { IBreakpoint breakpoint = ( IBreakpoint ) path . getLastSegment ( ) ; IBreakpointContainer container = null ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { container = ( IBreakpointContainer ) path . getSegment ( i ) ; if ( container . contains ( breakpoint ) & & container . getOrganizer ( ) . canRemove ( breakpoint , container . getCategory ( ) ) ) { return container ; } } } } return null ; } public IBreakpointContainer getAddableContainer ( Item item ) { TreePath path = getTreePathFromItem ( item ) ; if ( path ! = null ) { Object element = path . getLastSegment ( ) ; if ( element instanceof IBreakpoint ) { IBreakpointContainer container = null ; IBreakpoint breakpoint = ( IBreakpoint ) element ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { container = ( IBreakpointContainer ) path . getSegment ( i ) ; if ( container . contains ( breakpoint ) & & container . getOrganizer ( ) . canAdd ( breakpoint , container . getCategory ( ) ) ) { return container ; } } } } return null ; } public boolean canDrag ( Item [ ] items ) { if ( items = = null ) { return false ; } if ( items . length = = <int> ) { return false ; } for ( int i = <int> ; i < items . length ; i + + ) { if ( getRemovableContainer ( items [ i ] ) = = null ) { return false ; } } return true ; } public void performDrag ( Item [ ] items ) { if ( items = = null ) { return ; } Map < IBreakpointContainer , List < IBreakpoint > > containersToBreakpoints = new HashMap < IBreakpointContainer , List < IBreakpoint > > ( ) ; IBreakpointContainer container = null ; IBreakpoint breakpoint = null ; for ( int i = <int> ; i < items . length ; i + + ) { if ( ! items [ i ] . isDisposed ( ) ) { breakpoint = ( IBreakpoint ) items [ i ] . getData ( ) ; container = getRemovableContainer ( items [ i ] ) ; if ( container ! = null ) { List < IBreakpoint > list = containersToBreakpoints . get ( container ) ; if ( list = = null ) { list = new ArrayList < IBreakpoint > ( ) ; containersToBreakpoints . put ( container , list ) ; } list . add ( breakpoint ) ; } } } for ( Entry < IBreakpointContainer , List < IBreakpoint > > entry : containersToBreakpoints . entrySet ( ) ) { container = entry . getKey ( ) ; List < IBreakpoint > list = entry . getValue ( ) ; IBreakpointOrganizer organizer = container . getOrganizer ( ) ; IBreakpoint [ ] breakpoints = list . toArray ( new IBreakpoint [ list . size ( ) ] ) ; if ( organizer instanceof IBreakpointOrganizerDelegateExtension ) { IBreakpointOrganizerDelegateExtension extension = ( IBreakpointOrganizerDelegateExtension ) organizer ; extension . removeBreakpoints ( breakpoints , container . getCategory ( ) ) ; } else { for ( int i = <int> ; i < breakpoints . length ; i + + ) { organizer . removeBreakpoint ( breakpoints [ i ] , container . getCategory ( ) ) ; } } } } public boolean canDrop ( Item target , IStructuredSelection selection ) { if ( selection = = null | | target = = null ) { return false ; } for ( Iterator < ? > iter = selection . iterator ( ) ; iter . hasNext ( ) ; ) { Object currentObject = iter . next ( ) ; if ( ! ( currentObject instanceof IBreakpoint ) | | ! checkAddableParentContainers ( target , ( IBreakpoint ) currentObject ) ) { return false ; } } return true ; } private boolean checkAddableParentContainers ( Item target , IBreakpoint breakpoint ) { IBreakpointContainer container = null ; TreePath path = getTreePathFromItem ( target ) ; if ( path ! = null ) { Object element = null ; for ( int i = path . getSegmentCount ( ) - <int> ; i > - <int> ; i - - ) { element = path . getSegment ( i ) ; if ( element instanceof IBreakpointContainer ) { container = ( IBreakpointContainer ) element ; if ( container . contains ( breakpoint ) | | ! container . getOrganizer ( ) . canAdd ( breakpoint , container . getCategory ( ) ) ) { return false ; } } } } return true ; } public boolean performDrop ( Item target , IStructuredSelection selection ) { if ( target = = null | | selection = = null ) { return false ; } IBreakpoint breakpoint = null ; Object element = target . getData ( ) ; IBreakpointContainer container = ( element instanceof IBreakpointContainer ? ( IBreakpointContainer ) element : getAddableContainer ( target ) ) ; if ( container = = null ) { return false ; } IBreakpointOrganizer organizer = container . getOrganizer ( ) ; if ( organizer instanceof IBreakpointOrganizerDelegateExtension ) { IBreakpointOrganizerDelegateExtension extension = ( IBreakpointOrganizerDelegateExtension ) organizer ; Object [ ] array = selection . toArray ( ) ; IBreakpoint [ ] breakpoints = new IBreakpoint [ array . length ] ; System . arraycopy ( array , <int> , breakpoints , <int> , array . length ) ; extension . addBreakpoints ( breakpoints , container . getCategory ( ) ) ; } else { for ( Iterator < ? > iter = selection . iterator ( ) ; iter . hasNext ( ) ; ) { breakpoint = ( IBreakpoint ) iter . next ( ) ; organizer . addBreakpoint ( breakpoint , container . getCategory ( ) ) ; } } expandToLevel ( target . getData ( ) , ALL_LEVELS ) ; return true ; } @Override public void refresh ( ) { super . refresh ( ) ; initializeCheckedState ( ) ; } private void initializeCheckedState ( ) { TreeItem [ ] items = getTree ( ) . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { updateCheckedState ( items [ i ] ) ; } } public void updateCheckedState ( Object element ) { Widget [ ] widgets = searchItems ( element ) ; for ( int i = <int> ; i < widgets . length ; i + + ) { Widget widget = widgets [ i ] ; if ( widget ! = null ) { updateCheckedState ( ( TreeItem ) widget ) ; } } } private Widget [ ] searchItems ( Object element ) { ArrayList < TreeItem > list = new ArrayList < TreeItem > ( ) ; TreeItem [ ] items = getTree ( ) . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { findAllOccurrences ( items [ i ] , element , list ) ; } return list . toArray ( new Widget [ <int> ] ) ; } private void findAllOccurrences ( TreeItem item , Object element , ArrayList < TreeItem > list ) { if ( element . equals ( item . getData ( ) ) ) { list . add ( item ) ; } TreeItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { findAllOccurrences ( items [ i ] , element , list ) ; } } public void updateCheckedState ( TreeItem item ) { Object element = item . getData ( ) ; if ( element instanceof IBreakpoint ) { try { item . setChecked ( ( ( IBreakpoint ) element ) . isEnabled ( ) ) ; refreshItem ( item ) ; } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } } else if ( element instanceof IBreakpointContainer ) { IBreakpoint [ ] breakpoints = ( ( IBreakpointContainer ) element ) . getBreakpoints ( ) ; int enabledChildren = <int> ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { IBreakpoint breakpoint = breakpoints [ i ] ; try { if ( breakpoint . isEnabled ( ) ) { enabledChildren + + ; } } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } } if ( enabledChildren = = <int> ) { item . setGrayed ( false ) ; item . setChecked ( false ) ; } else if ( enabledChildren = = breakpoints . length ) { item . setGrayed ( false ) ; item . setChecked ( true ) ; } else { item . setGrayed ( true ) ; item . setChecked ( true ) ; } TreeItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { updateCheckedState ( items [ i ] ) ; } } } } 
