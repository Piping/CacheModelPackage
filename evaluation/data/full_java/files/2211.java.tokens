package org . nd4j . linalg . indexing ; import com . google . common . primitives . Ints ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . impl . transforms . LinearIndex ; import org . nd4j . linalg . factory . NDArrayFactory ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . api . shape . Shape ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class Indices { public static int rowNumber ( int index , INDArray arr ) { double otherTest = ( ( double ) index ) / arr . size ( - <int> ) ; int test = ( int ) Math . floor ( otherTest ) ; int vectors = arr . vectorsAlongDimension ( - <int> ) ; if ( test > = vectors ) return vectors - <int> ; return test ; } public static int linearOffset ( int index , INDArray arr ) { if ( arr . ordering ( ) = = NDArrayFactory . C ) { double otherTest = ( ( double ) index ) % arr . size ( - <int> ) ; int test = ( int ) Math . floor ( otherTest ) ; INDArray vec = arr . vectorAlongDimension ( test , - <int> ) ; int otherDim = arr . vectorAlongDimension ( test , - <int> ) . offset ( ) + index ; return otherDim ; } else { int majorStride = arr . stride ( - <int> ) ; int vectorsAlongDimension = arr . vectorsAlongDimension ( - <int> ) ; double rowCalc = ( double ) ( index * majorStride ) / ( double ) arr . length ( ) ; int floor = ( int ) Math . floor ( rowCalc ) ; INDArray arrVector = arr . vectorAlongDimension ( floor , - <int> ) ; int columnIndex = index % arr . size ( - <int> ) ; int retOffset = arrVector . linearIndex ( columnIndex ) ; return retOffset ; } } public static int [ ] linearIndices ( INDArray arr ) { LinearIndex index = new LinearIndex ( arr , arr . dup ( ) , true ) ; Nd4j . getExecutioner ( ) . iterateOverAllRows ( index ) ; return index . getIndices ( ) ; } public static int [ ] offsets ( int [ ] shape , INDArrayIndex . . . indices ) { int [ ] ret = new int [ shape . length ] ; if ( indices . length = = shape . length ) { for ( int i = <int> ; i < indices . length ; i + + ) { if ( indices [ i ] instanceof NDArrayIndexEmpty ) ret [ i ] = <int> ; else { ret [ i ] = indices [ i ] . offset ( ) ; } } if ( ret . length = = <int> ) { ret = new int [ ] { ret [ <int> ] , <int> } ; } } else { int numPoints = NDArrayIndex . numPoints ( indices ) ; if ( numPoints > <int> ) { List < Integer > nonZeros = new ArrayList < > ( ) ; for ( int i = <int> ; i < indices . length ; i + + ) if ( indices [ i ] . offset ( ) > <int> ) nonZeros . add ( indices [ i ] . offset ( ) ) ; if ( nonZeros . size ( ) > shape . length ) throw new IllegalStateException ( <str> ) ; else { for ( int i = <int> ; i < nonZeros . size ( ) ; i + + ) ret [ i ] = nonZeros . get ( i ) ; } } else { int shapeIndex = <int> ; for ( int i = <int> ; i < indices . length ; i + + ) { if ( indices [ i ] instanceof NDArrayIndexEmpty ) ret [ i ] = <int> ; else { ret [ i ] = indices [ shapeIndex + + ] . offset ( ) ; } } } if ( ret . length = = <int> ) { ret = new int [ ] { ret [ <int> ] , <int> } ; } } return ret ; } public static INDArrayIndex [ ] fillIn ( int [ ] shape , INDArrayIndex . . . indexes ) { if ( shape . length = = indexes . length ) return indexes ; INDArrayIndex [ ] newIndexes = new INDArrayIndex [ shape . length ] ; System . arraycopy ( indexes , <int> , newIndexes , <int> , indexes . length ) ; for ( int i = indexes . length ; i < shape . length ; i + + ) { newIndexes [ i ] = NDArrayIndex . interval ( <int> , shape [ i ] ) ; } return newIndexes ; } public static INDArrayIndex [ ] adjustIndices ( int [ ] originalShape , INDArrayIndex . . . indexes ) { if ( Shape . isVector ( originalShape ) & & indexes . length = = <int> ) return indexes ; if ( indexes . length < originalShape . length ) indexes = fillIn ( originalShape , indexes ) ; if ( indexes . length > originalShape . length ) { INDArrayIndex [ ] ret = new INDArrayIndex [ originalShape . length ] ; System . arraycopy ( indexes , <int> , ret , <int> , originalShape . length ) ; return ret ; } if ( indexes . length = = originalShape . length ) return indexes ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] . end ( ) > = originalShape [ i ] | | indexes [ i ] instanceof NDArrayIndexAll ) indexes [ i ] = NDArrayIndex . interval ( <int> , originalShape [ i ] - <int> ) ; } return indexes ; } public static int [ ] strides ( char ordering , NDArrayIndex . . . indexes ) { return Nd4j . getStrides ( shape ( indexes ) , ordering ) ; } public static int [ ] shape ( INDArrayIndex . . . indices ) { int [ ] ret = new int [ indices . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) { ret [ i ] = indices [ i ] . length ( ) ; } List < Integer > nonZeros = new ArrayList < > ( ) ; for ( int i = <int> ; i < ret . length ; i + + ) { if ( ret [ i ] > <int> ) nonZeros . add ( ret [ i ] ) ; } return ArrayUtil . toArray ( nonZeros ) ; } public static boolean isContiguous ( int [ ] indices , int diff ) { if ( indices . length < <int> ) return true ; for ( int i = <int> ; i < indices . length ; i + + ) { if ( Math . abs ( indices [ i ] - indices [ i - <int> ] ) > diff ) return false ; } return true ; } public static INDArrayIndex [ ] createFromStartAndEnd ( INDArray start , INDArray end ) { if ( start . length ( ) ! = end . length ( ) ) throw new IllegalArgumentException ( <str> ) ; else { INDArrayIndex [ ] indexes = new INDArrayIndex [ start . length ( ) ] ; for ( int i = <int> ; i < indexes . length ; i + + ) { indexes [ i ] = NDArrayIndex . interval ( start . getInt ( i ) , end . getInt ( i ) ) ; } return indexes ; } } public static INDArrayIndex [ ] createFromStartAndEnd ( INDArray start , INDArray end , boolean inclusive ) { if ( start . length ( ) ! = end . length ( ) ) throw new IllegalArgumentException ( <str> ) ; else { INDArrayIndex [ ] indexes = new INDArrayIndex [ start . length ( ) ] ; for ( int i = <int> ; i < indexes . length ; i + + ) { indexes [ i ] = NDArrayIndex . interval ( start . getInt ( i ) , end . getInt ( i ) , inclusive ) ; } return indexes ; } } public static int [ ] shape ( int [ ] shape , INDArrayIndex . . . indices ) { int newAxesPrepend = <int> ; boolean encounteredAll = false ; List < Integer > accumShape = new ArrayList < > ( ) ; int shapeIndex = <int> ; List < Integer > prependNewAxes = new ArrayList < > ( ) ; for ( int i = <int> ; i < indices . length ; i + + ) { INDArrayIndex idx = indices [ i ] ; if ( idx instanceof NDArrayIndexAll ) encounteredAll = true ; if ( idx instanceof PointIndex ) { shapeIndex + + ; continue ; } else if ( idx instanceof NewAxis ) { if ( encounteredAll ) { prependNewAxes . add ( i ) ; } else newAxesPrepend + + ; continue ; } else if ( idx instanceof IntervalIndex & & ! ( idx instanceof NDArrayIndexAll ) | | idx instanceof SpecifiedIndex ) { accumShape . add ( idx . length ( ) ) ; shapeIndex + + ; continue ; } accumShape . add ( shape [ shapeIndex ] ) ; shapeIndex + + ; } while ( shapeIndex < shape . length ) { accumShape . add ( shape [ shapeIndex + + ] ) ; } while ( accumShape . size ( ) < <int> ) { accumShape . add ( <int> ) ; } if ( indices . length = = <int> & & indices [ <int> ] instanceof PointIndex & & shape . length = = <int> ) { Collections . reverse ( accumShape ) ; } if ( newAxesPrepend > <int> ) { for ( int i = <int> ; i < newAxesPrepend ; i + + ) accumShape . add ( <int> , <int> ) ; } for ( int i = <int> ; i < prependNewAxes . size ( ) ; i + + ) { accumShape . add ( prependNewAxes . get ( i ) - i , <int> ) ; } return Ints . toArray ( accumShape ) ; } public static int [ ] stride ( INDArray arr , INDArrayIndex [ ] indexes , int . . . shape ) { List < Integer > strides = new ArrayList < > ( ) ; int strideIndex = <int> ; List < Integer > prependNewAxes = new ArrayList < > ( ) ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] instanceof PointIndex ) { strideIndex + + ; continue ; } else if ( indexes [ i ] instanceof NewAxis ) { } } for ( int i = <int> ; i < prependNewAxes . size ( ) ; i + + ) { strides . add ( prependNewAxes . get ( i ) - i , <int> ) ; } return Ints . toArray ( strides ) ; } public static boolean isScalar ( INDArray indexOver , INDArrayIndex . . . indexes ) { boolean allOneLength = true ; for ( int i = <int> ; i < indexes . length ; i + + ) { allOneLength = allOneLength & & indexes [ i ] . length ( ) = = <int> ; } int numNewAxes = NDArrayIndex . numNewAxis ( indexes ) ; if ( allOneLength & & numNewAxes = = <int> & & indexes . length = = indexOver . rank ( ) ) return true ; else if ( allOneLength & & indexes . length = = indexOver . rank ( ) - numNewAxes ) { return allOneLength ; } return allOneLength ; } } 
