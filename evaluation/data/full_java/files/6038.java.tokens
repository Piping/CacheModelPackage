package org . elasticsearch . common . rounding ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import java . io . IOException ; public abstract class Rounding implements Streamable { public abstract byte id ( ) ; public abstract long roundKey ( long value ) ; public abstract long valueForKey ( long key ) ; public final long round ( long value ) { return valueForKey ( roundKey ( value ) ) ; } public abstract long nextRoundingValue ( long value ) ; public static class Interval extends Rounding { final static byte ID = <int> ; private long interval ; public Interval ( ) { } public Interval ( long interval ) { this . interval = interval ; } @Override public byte id ( ) { return ID ; } public static long roundKey ( long value , long interval ) { if ( value < <int> ) { return ( value - interval + <int> ) / interval ; } else { return value / interval ; } } public static long roundValue ( long key , long interval ) { return key * interval ; } @Override public long roundKey ( long value ) { return roundKey ( value , interval ) ; } @Override public long valueForKey ( long key ) { return key * interval ; } @Override public long nextRoundingValue ( long value ) { assert value = = round ( value ) ; return value + interval ; } @Override public void readFrom ( StreamInput in ) throws IOException { interval = in . readVLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( interval ) ; } } public static class FactorRounding extends Rounding { final static byte ID = <int> ; private Rounding rounding ; private float factor ; FactorRounding ( ) { } FactorRounding ( Rounding rounding , float factor ) { this . rounding = rounding ; this . factor = factor ; } @Override public byte id ( ) { return ID ; } @Override public long roundKey ( long utcMillis ) { return rounding . roundKey ( ( long ) ( factor * utcMillis ) ) ; } @Override public long valueForKey ( long key ) { return rounding . valueForKey ( key ) ; } @Override public long nextRoundingValue ( long value ) { return rounding . nextRoundingValue ( value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { rounding = ( TimeZoneRounding ) Rounding . Streams . read ( in ) ; factor = in . readFloat ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { Rounding . Streams . write ( rounding , out ) ; out . writeFloat ( factor ) ; } } public static class OffsetRounding extends Rounding { final static byte ID = <int> ; private Rounding rounding ; private long offset ; OffsetRounding ( ) { } public OffsetRounding ( Rounding intervalRounding , long offset ) { this . rounding = intervalRounding ; this . offset = offset ; } @Override public byte id ( ) { return ID ; } @Override public long roundKey ( long value ) { return rounding . roundKey ( value - offset ) ; } @Override public long valueForKey ( long key ) { return offset + rounding . valueForKey ( key ) ; } @Override public long nextRoundingValue ( long value ) { return rounding . nextRoundingValue ( value - offset ) + offset ; } @Override public void readFrom ( StreamInput in ) throws IOException { rounding = Rounding . Streams . read ( in ) ; offset = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { Rounding . Streams . write ( rounding , out ) ; out . writeLong ( offset ) ; } } public static class Streams { public static void write ( Rounding rounding , StreamOutput out ) throws IOException { out . writeByte ( rounding . id ( ) ) ; rounding . writeTo ( out ) ; } public static Rounding read ( StreamInput in ) throws IOException { Rounding rounding = null ; byte id = in . readByte ( ) ; switch ( id ) { case Interval . ID : rounding = new Interval ( ) ; break ; case TimeZoneRounding . TimeUnitRounding . ID : rounding = new TimeZoneRounding . TimeUnitRounding ( ) ; break ; case TimeZoneRounding . TimeIntervalRounding . ID : rounding = new TimeZoneRounding . TimeIntervalRounding ( ) ; break ; case TimeZoneRounding . FactorRounding . ID : rounding = new FactorRounding ( ) ; break ; case OffsetRounding . ID : rounding = new OffsetRounding ( ) ; break ; default : throw new ElasticsearchException ( <str> + id + <str> ) ; } rounding . readFrom ( in ) ; return rounding ; } } } 
