package org . apache . lucene . queries ; import org . apache . lucene . analysis . MockAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . FieldType ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . * ; import org . apache . lucene . search . * ; import org . apache . lucene . search . similarities . BM25Similarity ; import org . apache . lucene . search . similarities . DefaultSimilarity ; import org . apache . lucene . search . similarities . Similarity ; import org . apache . lucene . store . Directory ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . * ; import static org . hamcrest . Matchers . containsInAnyOrder ; import static org . hamcrest . Matchers . equalTo ; public class BlendedTermQueryTests extends ESTestCase { public void testBooleanQuery ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ) ; String [ ] firstNames = new String [ ] { <str> , <str> } ; String [ ] surNames = new String [ ] { <str> , <str> } ; for ( int i = <int> ; i < surNames . length ; i + + ) { Document d = new Document ( ) ; d . add ( new TextField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; d . add ( new TextField ( <str> , firstNames [ i ] , Field . Store . NO ) ) ; d . add ( new TextField ( <str> , surNames [ i ] , Field . Store . NO ) ) ; w . addDocument ( d ) ; } int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < iters ; j + + ) { Document d = new Document ( ) ; d . add ( new TextField ( <str> , Integer . toString ( firstNames . length + j ) , Field . Store . YES ) ) ; d . add ( new TextField ( <str> , rarely ( ) ? <str> : <str> , Field . Store . NO ) ) ; d . add ( new TextField ( <str> , <str> , Field . Store . NO ) ) ; w . addDocument ( d ) ; } w . commit ( ) ; DirectoryReader reader = DirectoryReader . open ( w , true ) ; IndexSearcher searcher = setSimilarity ( newSearcher ( reader ) ) ; { Term [ ] terms = new Term [ ] { new Term ( <str> , <str> ) , new Term ( <str> , <str> ) } ; BlendedTermQuery query = BlendedTermQuery . booleanBlendedQuery ( terms , true ) ; TopDocs search = searcher . search ( query , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; assertEquals ( <int> , scoreDocs . length ) ; assertEquals ( Integer . toString ( <int> ) , reader . document ( scoreDocs [ <int> ] . doc ) . getField ( <str> ) . stringValue ( ) ) ; } { BooleanQuery . Builder query = new BooleanQuery . Builder ( ) ; query . setDisableCoord ( true ) ; query . add ( new TermQuery ( new Term ( <str> , <str> ) ) , BooleanClause . Occur . SHOULD ) ; query . add ( new TermQuery ( new Term ( <str> , <str> ) ) , BooleanClause . Occur . SHOULD ) ; TopDocs search = searcher . search ( query . build ( ) , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; assertEquals ( Integer . toString ( <int> ) , reader . document ( scoreDocs [ <int> ] . doc ) . getField ( <str> ) . stringValue ( ) ) ; } reader . close ( ) ; w . close ( ) ; dir . close ( ) ; } public void testDismaxQuery ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ) ; String [ ] username = new String [ ] { <str> , <str> , <str> } ; String [ ] song = new String [ ] { <str> , <str> , <str> } ; final boolean omitNorms = random ( ) . nextBoolean ( ) ; FieldType ft = new FieldType ( TextField . TYPE_NOT_STORED ) ; ft . setIndexOptions ( random ( ) . nextBoolean ( ) ? IndexOptions . DOCS : IndexOptions . DOCS_AND_FREQS ) ; ft . setOmitNorms ( omitNorms ) ; ft . freeze ( ) ; FieldType ft1 = new FieldType ( TextField . TYPE_NOT_STORED ) ; ft1 . setIndexOptions ( random ( ) . nextBoolean ( ) ? IndexOptions . DOCS : IndexOptions . DOCS_AND_FREQS ) ; ft1 . setOmitNorms ( omitNorms ) ; ft1 . freeze ( ) ; for ( int i = <int> ; i < username . length ; i + + ) { Document d = new Document ( ) ; d . add ( new TextField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; d . add ( new Field ( <str> , username [ i ] , ft ) ) ; d . add ( new Field ( <str> , song [ i ] , ft ) ) ; w . addDocument ( d ) ; } int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < iters ; j + + ) { Document d = new Document ( ) ; d . add ( new TextField ( <str> , Integer . toString ( username . length + j ) , Field . Store . YES ) ) ; d . add ( new Field ( <str> , <str> , ft1 ) ) ; d . add ( new Field ( <str> , <str> , ft1 ) ) ; w . addDocument ( d ) ; } w . commit ( ) ; DirectoryReader reader = DirectoryReader . open ( w , true ) ; IndexSearcher searcher = setSimilarity ( newSearcher ( reader ) ) ; { String [ ] fields = new String [ ] { <str> , <str> } ; BooleanQuery . Builder query = new BooleanQuery . Builder ( ) ; query . setDisableCoord ( true ) ; query . add ( BlendedTermQuery . dismaxBlendedQuery ( toTerms ( fields , <str> ) , <float> ) , BooleanClause . Occur . SHOULD ) ; query . add ( BlendedTermQuery . dismaxBlendedQuery ( toTerms ( fields , <str> ) , <float> ) , BooleanClause . Occur . SHOULD ) ; query . add ( BlendedTermQuery . dismaxBlendedQuery ( toTerms ( fields , <str> ) , <float> ) , BooleanClause . Occur . SHOULD ) ; TopDocs search = searcher . search ( query . build ( ) , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; assertEquals ( Integer . toString ( <int> ) , reader . document ( scoreDocs [ <int> ] . doc ) . getField ( <str> ) . stringValue ( ) ) ; } { BooleanQuery . Builder query = new BooleanQuery . Builder ( ) ; query . setDisableCoord ( true ) ; DisjunctionMaxQuery uname = new DisjunctionMaxQuery ( <float> ) ; uname . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; uname . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; DisjunctionMaxQuery s = new DisjunctionMaxQuery ( <float> ) ; s . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; s . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; DisjunctionMaxQuery gen = new DisjunctionMaxQuery ( <float> ) ; gen . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; gen . add ( new TermQuery ( new Term ( <str> , <str> ) ) ) ; query . add ( uname , BooleanClause . Occur . SHOULD ) ; query . add ( s , BooleanClause . Occur . SHOULD ) ; query . add ( gen , BooleanClause . Occur . SHOULD ) ; TopDocs search = searcher . search ( query . build ( ) , <int> ) ; ScoreDoc [ ] scoreDocs = search . scoreDocs ; assertEquals ( Integer . toString ( <int> ) , reader . document ( scoreDocs [ <int> ] . doc ) . getField ( <str> ) . stringValue ( ) ) ; } reader . close ( ) ; w . close ( ) ; dir . close ( ) ; } public void testBasics ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < iters ; j + + ) { String [ ] fields = new String [ <int> + random ( ) . nextInt ( <int> ) ] ; for ( int i = <int> ; i < fields . length ; i + + ) { fields [ i ] = TestUtil . randomRealisticUnicodeString ( random ( ) , <int> , <int> ) ; } String term = TestUtil . randomRealisticUnicodeString ( random ( ) , <int> , <int> ) ; Term [ ] terms = toTerms ( fields , term ) ; boolean disableCoord = random ( ) . nextBoolean ( ) ; boolean useBoolean = random ( ) . nextBoolean ( ) ; float tieBreaker = random ( ) . nextFloat ( ) ; BlendedTermQuery query = useBoolean ? BlendedTermQuery . booleanBlendedQuery ( terms , disableCoord ) : BlendedTermQuery . dismaxBlendedQuery ( terms , tieBreaker ) ; QueryUtils . check ( query ) ; terms = toTerms ( fields , term ) ; BlendedTermQuery query2 = useBoolean ? BlendedTermQuery . booleanBlendedQuery ( terms , disableCoord ) : BlendedTermQuery . dismaxBlendedQuery ( terms , tieBreaker ) ; assertEquals ( query , query2 ) ; } } public Term [ ] toTerms ( String [ ] fields , String term ) { Term [ ] terms = new Term [ fields . length ] ; List < String > fieldsList = Arrays . asList ( fields ) ; Collections . shuffle ( fieldsList , random ( ) ) ; fields = fieldsList . toArray ( new String [ <int> ] ) ; for ( int i = <int> ; i < fields . length ; i + + ) { terms [ i ] = new Term ( fields [ i ] , term ) ; } return terms ; } public IndexSearcher setSimilarity ( IndexSearcher searcher ) { Similarity similarity = random ( ) . nextBoolean ( ) ? new BM25Similarity ( ) : new DefaultSimilarity ( ) ; searcher . setSimilarity ( similarity ) ; return searcher ; } public void testExtractTerms ( ) throws IOException { Set < Term > terms = new HashSet < > ( ) ; int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < num ; i + + ) { terms . add ( new Term ( TestUtil . randomRealisticUnicodeString ( random ( ) , <int> , <int> ) , TestUtil . randomRealisticUnicodeString ( random ( ) , <int> , <int> ) ) ) ; } BlendedTermQuery blendedTermQuery = random ( ) . nextBoolean ( ) ? BlendedTermQuery . dismaxBlendedQuery ( terms . toArray ( new Term [ <int> ] ) , random ( ) . nextFloat ( ) ) : BlendedTermQuery . booleanBlendedQuery ( terms . toArray ( new Term [ <int> ] ) , random ( ) . nextBoolean ( ) ) ; Set < Term > extracted = new HashSet < > ( ) ; IndexSearcher searcher = new IndexSearcher ( new MultiReader ( ) ) ; searcher . createNormalizedWeight ( blendedTermQuery , false ) . extractTerms ( extracted ) ; assertThat ( extracted . size ( ) , equalTo ( terms . size ( ) ) ) ; assertThat ( extracted , containsInAnyOrder ( terms . toArray ( new Term [ <int> ] ) ) ) ; } } 
