package org . gradle . messaging . remote . internal . protocol ; import org . gradle . internal . UncheckedException ; import org . gradle . messaging . remote . internal . Message ; import java . io . Serializable ; import java . lang . reflect . Method ; import java . util . Arrays ; public class MethodMetaInfo extends Message { private final Type type ; private final String methodName ; private final Type [ ] paramTypes ; private final Object key ; public MethodMetaInfo ( Object key , Method method ) { this . key = key ; type = new Type ( method . getDeclaringClass ( ) ) ; methodName = method . getName ( ) ; paramTypes = new Type [ method . getParameterTypes ( ) . length ] ; for ( int i = <int> ; i < method . getParameterTypes ( ) . length ; i + + ) { Class < ? > paramType = method . getParameterTypes ( ) [ i ] ; paramTypes [ i ] = new Type ( paramType ) ; } } @Override public String toString ( ) { return <str> + <str> + type + <str> + methodName + <str> + <str> + ( paramTypes = = null ? null : Arrays . asList ( paramTypes ) ) + <str> ; } public Object getKey ( ) { return key ; } public Method findMethod ( ClassLoader classLoader ) { try { Class < ? > declaringClass = this . type . load ( classLoader ) ; Class < ? > [ ] paramTypes = new Class [ this . paramTypes . length ] ; for ( int i = <int> ; i < this . paramTypes . length ; i + + ) { Type paramType = this . paramTypes [ i ] ; paramTypes [ i ] = paramType . load ( classLoader ) ; } return declaringClass . getMethod ( methodName , paramTypes ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null | | obj . getClass ( ) ! = getClass ( ) ) { return false ; } MethodMetaInfo other = ( MethodMetaInfo ) obj ; if ( ! key . equals ( other . key ) ) { return false ; } if ( ! type . equals ( other . type ) ) { return false ; } if ( ! methodName . equals ( other . methodName ) ) { return false ; } return Arrays . equals ( paramTypes , other . paramTypes ) ; } @Override public int hashCode ( ) { return key . hashCode ( ) ; } private static class Type implements Serializable { private String typeName ; private Class < ? > type ; public Type ( Class < ? > type ) { this . typeName = type . getName ( ) ; if ( type . isPrimitive ( ) ) { this . type = type ; } } Class < ? > load ( ClassLoader classLoader ) throws ClassNotFoundException { if ( type ! = null ) { return type ; } return classLoader . loadClass ( typeName ) ; } @Override public boolean equals ( Object obj ) { return ( ( Type ) obj ) . typeName . equals ( typeName ) ; } @Override public int hashCode ( ) { return typeName . hashCode ( ) ; } @Override public String toString ( ) { return <str> + <str> + typeName + <str> + <str> ; } } } 
