package org . eclipse . ui . console ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; public class IOConsoleInputStream extends InputStream { private byte [ ] input = new byte [ <int> ] ; private int inPointer = <int> ; private int outPointer = <int> ; private int size = <int> ; private boolean eofSent = false ; private boolean closed = false ; private IOConsole console ; private Color color ; private int fontStyle = SWT . NORMAL ; IOConsoleInputStream ( IOConsole console ) { this . console = console ; } @Override public synchronized int read ( byte [ ] b , int off , int len ) throws IOException { waitForData ( ) ; if ( available ( ) = = - <int> ) { return - <int> ; } int toCopy = Math . min ( len , size ) ; if ( input . length - outPointer > toCopy ) { System . arraycopy ( input , outPointer , b , off , toCopy ) ; outPointer + = toCopy ; size - = toCopy ; } else { int bytesToEnd = input . length - outPointer ; System . arraycopy ( input , outPointer , b , off , bytesToEnd ) ; System . arraycopy ( input , <int> , b , off + bytesToEnd , toCopy - bytesToEnd ) ; outPointer = toCopy - bytesToEnd ; size - = toCopy ; } return toCopy ; } @Override public int read ( byte [ ] b ) throws IOException { return read ( b , <int> , b . length ) ; } @Override public synchronized int read ( ) throws IOException { waitForData ( ) ; if ( available ( ) = = - <int> ) { return - <int> ; } byte b = input [ outPointer ] ; outPointer + + ; if ( outPointer = = input . length ) { outPointer = <int> ; } size - = <int> ; return b ; } private void waitForData ( ) { while ( size = = <int> & & ! closed ) { try { wait ( ) ; } catch ( InterruptedException e ) { } } } public synchronized void appendData ( String text ) { String encoding = console . getEncoding ( ) ; byte [ ] newData ; if ( encoding ! = null ) { try { newData = text . getBytes ( encoding ) ; } catch ( UnsupportedEncodingException e ) { newData = text . getBytes ( ) ; } } else { newData = text . getBytes ( ) ; } while ( input . length - size < newData . length ) { growArray ( ) ; } if ( size = = <int> ) { System . arraycopy ( newData , <int> , input , <int> , newData . length ) ; inPointer = newData . length ; size = newData . length ; outPointer = <int> ; } else if ( inPointer < outPointer | | input . length - inPointer > newData . length ) { System . arraycopy ( newData , <int> , input , inPointer , newData . length ) ; inPointer + = newData . length ; size + = newData . length ; } else { System . arraycopy ( newData , <int> , input , inPointer , input . length - inPointer ) ; System . arraycopy ( newData , input . length - inPointer , input , <int> , newData . length - ( input . length - inPointer ) ) ; inPointer = newData . length - ( input . length - inPointer ) ; size + = newData . length ; } if ( inPointer = = input . length ) { inPointer = <int> ; } notifyAll ( ) ; } private void growArray ( ) { byte [ ] newInput = new byte [ input . length + <int> ] ; if ( outPointer < inPointer ) { System . arraycopy ( input , outPointer , newInput , <int> , size ) ; } else { System . arraycopy ( input , outPointer , newInput , <int> , input . length - outPointer ) ; System . arraycopy ( input , <int> , newInput , input . length - outPointer , inPointer ) ; } outPointer = <int> ; inPointer = size ; input = newInput ; newInput = null ; } public int getFontStyle ( ) { return fontStyle ; } public void setFontStyle ( int newFontStyle ) { if ( newFontStyle ! = fontStyle ) { int old = fontStyle ; fontStyle = newFontStyle ; console . firePropertyChange ( this , IConsoleConstants . P_FONT_STYLE , Integer . valueOf ( old ) , Integer . valueOf ( fontStyle ) ) ; } } public void setColor ( Color newColor ) { Color old = color ; if ( old = = null | | ! old . equals ( newColor ) ) { color = newColor ; console . firePropertyChange ( this , IConsoleConstants . P_STREAM_COLOR , old , newColor ) ; } } public Color getColor ( ) { return color ; } @Override public int available ( ) throws IOException { if ( closed & & eofSent ) { throw new IOException ( <str> ) ; } else if ( size = = <int> ) { if ( ! eofSent ) { eofSent = true ; return - <int> ; } throw new IOException ( <str> ) ; } return size ; } @Override public synchronized void close ( ) throws IOException { if ( closed ) { throw new IOException ( <str> ) ; } closed = true ; notifyAll ( ) ; console . streamClosed ( this ) ; } } 
