package org . elasticsearch . search . suggest . phrase ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . MultiFields ; import org . apache . lucene . index . Terms ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . spell . DirectSpellChecker ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . query . ParsedQuery ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . suggest . Suggest . Suggestion ; import org . elasticsearch . search . suggest . Suggest . Suggestion . Entry ; import org . elasticsearch . search . suggest . Suggest . Suggestion . Entry . Option ; import org . elasticsearch . search . suggest . SuggestContextParser ; import org . elasticsearch . search . suggest . SuggestUtils ; import org . elasticsearch . search . suggest . Suggester ; import org . elasticsearch . search . suggest . phrase . NoisyChannelSpellChecker . Result ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public final class PhraseSuggester extends Suggester < PhraseSuggestionContext > { private final BytesRef SEPARATOR = new BytesRef ( <str> ) ; private static final String SUGGESTION_TEMPLATE_VAR_NAME = <str> ; private final ScriptService scriptService ; private final IndicesService indicesService ; public PhraseSuggester ( ScriptService scriptService , IndicesService indicesService ) { this . scriptService = scriptService ; this . indicesService = indicesService ; } @Override public Suggestion < ? extends Entry < ? extends Option > > innerExecute ( String name , PhraseSuggestionContext suggestion , IndexSearcher searcher , CharsRefBuilder spare ) throws IOException { double realWordErrorLikelihood = suggestion . realworldErrorLikelyhood ( ) ; final PhraseSuggestion response = new PhraseSuggestion ( name , suggestion . getSize ( ) ) ; final IndexReader indexReader = searcher . getIndexReader ( ) ; List < PhraseSuggestionContext . DirectCandidateGenerator > generators = suggestion . generators ( ) ; final int numGenerators = generators . size ( ) ; final List < CandidateGenerator > gens = new ArrayList < > ( generators . size ( ) ) ; for ( int i = <int> ; i < numGenerators ; i + + ) { PhraseSuggestionContext . DirectCandidateGenerator generator = generators . get ( i ) ; DirectSpellChecker directSpellChecker = SuggestUtils . getDirectSpellChecker ( generator ) ; Terms terms = MultiFields . getTerms ( indexReader , generator . field ( ) ) ; if ( terms ! = null ) { gens . add ( new DirectCandidateGenerator ( directSpellChecker , generator . field ( ) , generator . suggestMode ( ) , indexReader , realWordErrorLikelihood , generator . size ( ) , generator . preFilter ( ) , generator . postFilter ( ) , terms ) ) ; } } final String suggestField = suggestion . getField ( ) ; final Terms suggestTerms = MultiFields . getTerms ( indexReader , suggestField ) ; if ( gens . size ( ) > <int> & & suggestTerms ! = null ) { final NoisyChannelSpellChecker checker = new NoisyChannelSpellChecker ( realWordErrorLikelihood , suggestion . getRequireUnigram ( ) , suggestion . getTokenLimit ( ) ) ; final BytesRef separator = suggestion . separator ( ) ; WordScorer wordScorer = suggestion . model ( ) . newScorer ( indexReader , suggestTerms , suggestField , realWordErrorLikelihood , separator ) ; Result checkerResult ; try ( TokenStream stream = checker . tokenStream ( suggestion . getAnalyzer ( ) , suggestion . getText ( ) , spare , suggestion . getField ( ) ) ) { checkerResult = checker . getCorrections ( stream , new MultiCandidateGeneratorWrapper ( suggestion . getShardSize ( ) , gens . toArray ( new CandidateGenerator [ gens . size ( ) ] ) ) , suggestion . maxErrors ( ) , suggestion . getShardSize ( ) , wordScorer , suggestion . confidence ( ) , suggestion . gramSize ( ) ) ; } PhraseSuggestion . Entry resultEntry = buildResultEntry ( suggestion , spare , checkerResult . cutoffScore ) ; response . addTerm ( resultEntry ) ; final BytesRefBuilder byteSpare = new BytesRefBuilder ( ) ; final CompiledScript collateScript = suggestion . getCollateQueryScript ( ) ; final boolean collatePrune = ( collateScript ! = null ) & & suggestion . collatePrune ( ) ; for ( int i = <int> ; i < checkerResult . corrections . length ; i + + ) { Correction correction = checkerResult . corrections [ i ] ; spare . copyUTF8Bytes ( correction . join ( SEPARATOR , byteSpare , null , null ) ) ; boolean collateMatch = true ; if ( collateScript ! = null ) { final Map < String , Object > vars = suggestion . getCollateScriptParams ( ) ; vars . put ( SUGGESTION_TEMPLATE_VAR_NAME , spare . toString ( ) ) ; final ExecutableScript executable = scriptService . executable ( collateScript , vars ) ; final BytesReference querySource = ( BytesReference ) executable . run ( ) ; IndexService indexService = indicesService . indexService ( suggestion . getIndex ( ) ) ; IndexShard shard = indexService . getShard ( suggestion . getShard ( ) ) ; final ParsedQuery parsedQuery = shard . getQueryShardContext ( ) . parse ( querySource ) ; collateMatch = Lucene . exists ( searcher , parsedQuery . query ( ) ) ; } if ( ! collateMatch & & ! collatePrune ) { continue ; } Text phrase = new StringText ( spare . toString ( ) ) ; Text highlighted = null ; if ( suggestion . getPreTag ( ) ! = null ) { spare . copyUTF8Bytes ( correction . join ( SEPARATOR , byteSpare , suggestion . getPreTag ( ) , suggestion . getPostTag ( ) ) ) ; highlighted = new StringText ( spare . toString ( ) ) ; } if ( collatePrune ) { resultEntry . addOption ( new Suggestion . Entry . Option ( phrase , highlighted , ( float ) ( correction . score ) , collateMatch ) ) ; } else { resultEntry . addOption ( new Suggestion . Entry . Option ( phrase , highlighted , ( float ) ( correction . score ) ) ) ; } } } else { response . addTerm ( buildResultEntry ( suggestion , spare , Double . MIN_VALUE ) ) ; } return response ; } private PhraseSuggestion . Entry buildResultEntry ( PhraseSuggestionContext suggestion , CharsRefBuilder spare , double cutoffScore ) { spare . copyUTF8Bytes ( suggestion . getText ( ) ) ; return new PhraseSuggestion . Entry ( new StringText ( spare . toString ( ) ) , <int> , spare . length ( ) , cutoffScore ) ; } ScriptService scriptService ( ) { return scriptService ; } @Override public SuggestContextParser getContextParser ( ) { return new PhraseSuggestParser ( this ) ; } } 
