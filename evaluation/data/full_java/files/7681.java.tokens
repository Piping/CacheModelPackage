package org . elasticsearch . transport . netty ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . Version ; import org . elasticsearch . common . component . Lifecycle ; import org . elasticsearch . common . compress . Compressor ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . compress . NotCompressedException ; import org . elasticsearch . common . io . stream . NamedWriteableAwareStreamInput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import org . elasticsearch . transport . support . TransportStatus ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . channel . * ; import java . io . IOException ; import java . net . InetSocketAddress ; public class MessageChannelHandler extends SimpleChannelUpstreamHandler { protected final ESLogger logger ; protected final ThreadPool threadPool ; protected final TransportServiceAdapter transportServiceAdapter ; protected final NettyTransport transport ; protected final String profileName ; public MessageChannelHandler ( NettyTransport transport , ESLogger logger , String profileName ) { this . threadPool = transport . threadPool ( ) ; this . transportServiceAdapter = transport . transportServiceAdapter ( ) ; this . transport = transport ; this . logger = logger ; this . profileName = profileName ; } @Override public void writeComplete ( ChannelHandlerContext ctx , WriteCompletionEvent e ) throws Exception { transportServiceAdapter . sent ( e . getWrittenAmount ( ) ) ; super . writeComplete ( ctx , e ) ; } @Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { Transports . assertTransportThread ( ) ; Object m = e . getMessage ( ) ; if ( ! ( m instanceof ChannelBuffer ) ) { ctx . sendUpstream ( e ) ; return ; } ChannelBuffer buffer = ( ChannelBuffer ) m ; int size = buffer . getInt ( buffer . readerIndex ( ) - <int> ) ; transportServiceAdapter . received ( size + <int> ) ; boolean hasMessageBytesToRead = ( size - ( NettyHeader . HEADER_SIZE - <int> ) ) ! = <int> ; int markedReaderIndex = buffer . readerIndex ( ) ; int expectedIndexReader = markedReaderIndex + size ; StreamInput streamIn = ChannelBufferStreamInputFactory . create ( buffer , size ) ; boolean success = false ; try { long requestId = streamIn . readLong ( ) ; byte status = streamIn . readByte ( ) ; Version version = Version . fromId ( streamIn . readInt ( ) ) ; if ( TransportStatus . isCompress ( status ) & & hasMessageBytesToRead & & buffer . readable ( ) ) { Compressor compressor ; try { compressor = CompressorFactory . compressor ( buffer ) ; } catch ( NotCompressedException ex ) { int maxToRead = Math . min ( buffer . readableBytes ( ) , <int> ) ; int offset = buffer . readerIndex ( ) ; StringBuilder sb = new StringBuilder ( <str> ) . append ( maxToRead ) . append ( <str> ) . append ( buffer . readableBytes ( ) ) . append ( <str> ) . append ( size ) . append ( <str> ) . append ( <str> ) ; for ( int i = <int> ; i < maxToRead ; i + + ) { sb . append ( buffer . getByte ( offset + i ) ) . append ( <str> ) ; } sb . append ( <str> ) ; throw new IllegalStateException ( sb . toString ( ) ) ; } streamIn = compressor . streamInput ( streamIn ) ; } streamIn . setVersion ( version ) ; if ( TransportStatus . isRequest ( status ) ) { String action = handleRequest ( ctx . getChannel ( ) , streamIn , requestId , version ) ; final int nextByte = streamIn . read ( ) ; if ( nextByte ! = - <int> ) { throw new IllegalStateException ( <str> + requestId + <str> + action + <str> + buffer . readerIndex ( ) + <str> + expectedIndexReader + <str> ) ; } if ( buffer . readerIndex ( ) < expectedIndexReader ) { throw new IllegalStateException ( <str> + ( expectedIndexReader - buffer . readerIndex ( ) ) + <str> ) ; } if ( buffer . readerIndex ( ) > expectedIndexReader ) { throw new IllegalStateException ( <str> + requestId + <str> + action + <str> + buffer . readerIndex ( ) + <str> + expectedIndexReader + <str> ) ; } } else { TransportResponseHandler < ? > handler = transportServiceAdapter . onResponseReceived ( requestId ) ; if ( handler ! = null ) { if ( TransportStatus . isError ( status ) ) { handlerResponseError ( streamIn , handler ) ; } else { handleResponse ( ctx . getChannel ( ) , streamIn , handler ) ; } final int nextByte = streamIn . read ( ) ; if ( nextByte ! = - <int> ) { throw new IllegalStateException ( <str> + requestId + <str> + handler + <str> + TransportStatus . isError ( status ) + <str> ) ; } if ( buffer . readerIndex ( ) < expectedIndexReader ) { throw new IllegalStateException ( <str> + ( expectedIndexReader - buffer . readerIndex ( ) ) + <str> ) ; } if ( buffer . readerIndex ( ) > expectedIndexReader ) { throw new IllegalStateException ( <str> + requestId + <str> + handler + <str> + TransportStatus . isError ( status ) + <str> ) ; } } } } finally { try { if ( success ) { IOUtils . close ( streamIn ) ; } else { IOUtils . closeWhileHandlingException ( streamIn ) ; } } finally { buffer . readerIndex ( expectedIndexReader ) ; } } } protected void handleResponse ( Channel channel , StreamInput buffer , final TransportResponseHandler handler ) { final TransportResponse response = handler . newInstance ( ) ; response . remoteAddress ( new InetSocketTransportAddress ( ( InetSocketAddress ) channel . getRemoteAddress ( ) ) ) ; response . remoteAddress ( ) ; try { response . readFrom ( buffer ) ; } catch ( Throwable e ) { handleException ( handler , new TransportSerializationException ( <str> + response . getClass ( ) . getName ( ) + <str> , e ) ) ; return ; } try { if ( ThreadPool . Names . SAME . equals ( handler . executor ( ) ) ) { handler . handleResponse ( response ) ; } else { threadPool . executor ( handler . executor ( ) ) . execute ( new ResponseHandler ( handler , response ) ) ; } } catch ( Throwable e ) { handleException ( handler , new ResponseHandlerFailureTransportException ( e ) ) ; } } private void handlerResponseError ( StreamInput buffer , final TransportResponseHandler handler ) { Throwable error ; try { error = buffer . readThrowable ( ) ; } catch ( Throwable e ) { error = new TransportSerializationException ( <str> , e ) ; } handleException ( handler , error ) ; } private void handleException ( final TransportResponseHandler handler , Throwable error ) { if ( ! ( error instanceof RemoteTransportException ) ) { error = new RemoteTransportException ( error . getMessage ( ) , error ) ; } final RemoteTransportException rtx = ( RemoteTransportException ) error ; if ( ThreadPool . Names . SAME . equals ( handler . executor ( ) ) ) { try { handler . handleException ( rtx ) ; } catch ( Throwable e ) { logger . error ( <str> , e , handler ) ; } } else { threadPool . executor ( handler . executor ( ) ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { handler . handleException ( rtx ) ; } catch ( Throwable e ) { logger . error ( <str> , e , handler ) ; } } } ) ; } } protected String handleRequest ( Channel channel , StreamInput buffer , long requestId , Version version ) throws IOException { buffer = new NamedWriteableAwareStreamInput ( buffer , transport . namedWriteableRegistry ) ; final String action = buffer . readString ( ) ; transportServiceAdapter . onRequestReceived ( requestId , action ) ; final NettyTransportChannel transportChannel = new NettyTransportChannel ( transport , transportServiceAdapter , action , channel , requestId , version , profileName ) ; try { final RequestHandlerRegistry reg = transportServiceAdapter . getRequestHandler ( action ) ; if ( reg = = null ) { throw new ActionNotFoundTransportException ( action ) ; } final TransportRequest request = reg . newRequest ( ) ; request . remoteAddress ( new InetSocketTransportAddress ( ( InetSocketAddress ) channel . getRemoteAddress ( ) ) ) ; request . readFrom ( buffer ) ; if ( ThreadPool . Names . SAME . equals ( reg . getExecutor ( ) ) ) { reg . getHandler ( ) . messageReceived ( request , transportChannel ) ; } else { threadPool . executor ( reg . getExecutor ( ) ) . execute ( new RequestHandler ( reg , request , transportChannel ) ) ; } } catch ( Throwable e ) { try { transportChannel . sendResponse ( e ) ; } catch ( IOException e1 ) { logger . warn ( <str> + action + <str> , e ) ; logger . warn ( <str> , e1 ) ; } } return action ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , ExceptionEvent e ) throws Exception { transport . exceptionCaught ( ctx , e ) ; } class ResponseHandler implements Runnable { private final TransportResponseHandler handler ; private final TransportResponse response ; public ResponseHandler ( TransportResponseHandler handler , TransportResponse response ) { this . handler = handler ; this . response = response ; } @SuppressWarnings ( { <str> } ) @Override public void run ( ) { try { handler . handleResponse ( response ) ; } catch ( Throwable e ) { handleException ( handler , new ResponseHandlerFailureTransportException ( e ) ) ; } } } class RequestHandler extends AbstractRunnable { private final RequestHandlerRegistry reg ; private final TransportRequest request ; private final NettyTransportChannel transportChannel ; public RequestHandler ( RequestHandlerRegistry reg , TransportRequest request , NettyTransportChannel transportChannel ) { this . reg = reg ; this . request = request ; this . transportChannel = transportChannel ; } @SuppressWarnings ( { <str> } ) @Override protected void doRun ( ) throws Exception { reg . getHandler ( ) . messageReceived ( request , transportChannel ) ; } @Override public boolean isForceExecution ( ) { return reg . isForceExecution ( ) ; } @Override public void onFailure ( Throwable e ) { if ( transport . lifecycleState ( ) = = Lifecycle . State . STARTED ) { try { transportChannel . sendResponse ( e ) ; } catch ( Throwable e1 ) { logger . warn ( <str> + reg . getAction ( ) + <str> , e1 ) ; logger . warn ( <str> , e ) ; } } } } } 
