package org . elasticsearch ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . VersionUtils ; import org . hamcrest . Matchers ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import static org . elasticsearch . Version . V_0_20_0 ; import static org . elasticsearch . Version . V_0_90_0 ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . sameInstance ; public class VersionTests extends ESTestCase { public void testMavenVersion ( ) { String property = System . getProperty ( <str> , null ) ; assumeTrue ( <str> , property ! = null ) ; assertEquals ( property , Version . CURRENT . toString ( ) ) ; } public void testVersionComparison ( ) throws Exception { assertThat ( V_0_20_0 . before ( V_0_90_0 ) , is ( true ) ) ; assertThat ( V_0_20_0 . before ( V_0_20_0 ) , is ( false ) ) ; assertThat ( V_0_90_0 . before ( V_0_20_0 ) , is ( false ) ) ; assertThat ( V_0_20_0 . onOrBefore ( V_0_90_0 ) , is ( true ) ) ; assertThat ( V_0_20_0 . onOrBefore ( V_0_20_0 ) , is ( true ) ) ; assertThat ( V_0_90_0 . onOrBefore ( V_0_20_0 ) , is ( false ) ) ; assertThat ( V_0_20_0 . after ( V_0_90_0 ) , is ( false ) ) ; assertThat ( V_0_20_0 . after ( V_0_20_0 ) , is ( false ) ) ; assertThat ( V_0_90_0 . after ( V_0_20_0 ) , is ( true ) ) ; assertThat ( V_0_20_0 . onOrAfter ( V_0_90_0 ) , is ( false ) ) ; assertThat ( V_0_20_0 . onOrAfter ( V_0_20_0 ) , is ( true ) ) ; assertThat ( V_0_90_0 . onOrAfter ( V_0_20_0 ) , is ( true ) ) ; } public void testVersionConstantPresent ( ) { assertThat ( Version . CURRENT , sameInstance ( Version . fromId ( Version . CURRENT . id ) ) ) ; assertThat ( Version . CURRENT . luceneVersion , equalTo ( org . apache . lucene . util . Version . LATEST ) ) ; final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Version version = randomVersion ( random ( ) ) ; assertThat ( version , sameInstance ( Version . fromId ( version . id ) ) ) ; assertThat ( version . luceneVersion , sameInstance ( Version . fromId ( version . id ) . luceneVersion ) ) ; } } public void testCURRENTIsLatest ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Version version = randomVersion ( random ( ) ) ; if ( version ! = Version . CURRENT ) { assertThat ( <str> + version + <str> + Version . CURRENT + <str> , version . before ( Version . CURRENT ) , is ( true ) ) ; } } } public void testVersionFromString ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Version version = randomVersion ( random ( ) ) ; if ( version . snapshot ( ) ) { assertEquals ( Version . fromString ( version . number ( ) ) , version ) ; } else { assertThat ( Version . fromString ( version . number ( ) ) , sameInstance ( version ) ) ; } assertFalse ( Version . fromString ( version . number ( ) ) . snapshot ( ) ) ; } } public void testTooLongVersionFromString ( ) { try { Version . fromString ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testTooShortVersionFromString ( ) { try { Version . fromString ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testWrongVersionFromString ( ) { try { Version . fromString ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testVersionNoPresentInSettings ( ) { try { Version . indexCreated ( Settings . builder ( ) . build ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testIndexCreatedVersion ( ) { final Version version = randomFrom ( Version . V_0_18_0 , Version . V_0_90_13 , Version . V_1_3_0 ) ; assertEquals ( version , Version . indexCreated ( Settings . builder ( ) . put ( IndexMetaData . SETTING_INDEX_UUID , <str> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ) ) ; } public void testMinCompatVersion ( ) { assertThat ( Version . V_2_0_0_beta1 . minimumCompatibilityVersion ( ) , equalTo ( Version . V_2_0_0_beta1 ) ) ; assertThat ( Version . V_1_3_0 . minimumCompatibilityVersion ( ) , equalTo ( Version . V_1_0_0 ) ) ; assertThat ( Version . V_1_2_0 . minimumCompatibilityVersion ( ) , equalTo ( Version . V_1_0_0 ) ) ; assertThat ( Version . V_1_2_3 . minimumCompatibilityVersion ( ) , equalTo ( Version . V_1_0_0 ) ) ; assertThat ( Version . V_1_0_0_RC2 . minimumCompatibilityVersion ( ) , equalTo ( Version . V_1_0_0_RC2 ) ) ; } public void testToString ( ) { assertEquals ( <str> , Version . V_2_0_0_beta1 . number ( ) ) ; assertEquals ( <str> , Version . V_1_4_0_Beta1 . number ( ) ) ; assertEquals ( <str> , Version . V_1_4_0 . number ( ) ) ; } public void testIsBeta ( ) { assertTrue ( Version . V_2_0_0_beta1 . isBeta ( ) ) ; assertTrue ( Version . V_1_4_0_Beta1 . isBeta ( ) ) ; assertFalse ( Version . V_1_4_0 . isBeta ( ) ) ; } public void testParseVersion ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Version version = randomVersion ( random ( ) ) ; if ( version . snapshot ( ) = = false & & random ( ) . nextBoolean ( ) ) { version = new Version ( version . id , true , version . luceneVersion ) ; } Version parsedVersion = Version . fromString ( version . toString ( ) ) ; assertEquals ( version , parsedVersion ) ; assertEquals ( version . snapshot ( ) , parsedVersion . snapshot ( ) ) ; } } public void testParseLenient ( ) { for ( Version version : VersionUtils . allVersions ( ) ) { org . apache . lucene . util . Version luceneVersion = version . luceneVersion ; String string = luceneVersion . toString ( ) . toUpperCase ( Locale . ROOT ) . replaceFirst ( <str> , <str> ) ; assertThat ( luceneVersion , Matchers . equalTo ( Lucene . parseVersionLenient ( string , null ) ) ) ; } } public void testAllVersionsMatchId ( ) throws Exception { Map < String , Version > maxBranchVersions = new HashMap < > ( ) ; for ( java . lang . reflect . Field field : Version . class . getFields ( ) ) { if ( field . getName ( ) . endsWith ( <str> ) ) { assertTrue ( field . getName ( ) + <str> , Modifier . isStatic ( field . getModifiers ( ) ) ) ; assertTrue ( field . getName ( ) + <str> , Modifier . isFinal ( field . getModifiers ( ) ) ) ; int versionId = ( Integer ) field . get ( Version . class ) ; String constantName = field . getName ( ) . substring ( <int> , field . getName ( ) . length ( ) - <int> ) ; java . lang . reflect . Field versionConstant = Version . class . getField ( constantName ) ; assertTrue ( constantName + <str> , Modifier . isStatic ( versionConstant . getModifiers ( ) ) ) ; assertTrue ( constantName + <str> , Modifier . isFinal ( versionConstant . getModifiers ( ) ) ) ; Version v = ( Version ) versionConstant . get ( Version . class ) ; logger . info ( <str> + v ) ; assertEquals ( <str> + field . getName ( ) + <str> + constantName , v , Version . fromId ( versionId ) ) ; assertEquals ( <str> + constantName + <str> , versionId , v . id ) ; if ( v . major > = <int> ) { String number = v . number ( ) ; if ( v . isBeta ( ) ) { number = number . replace ( <str> , <str> ) ; } else if ( v . isRC ( ) ) { number = number . replace ( <str> , <str> ) ; } assertEquals ( <str> + number . replace ( <str> , <str> ) , constantName ) ; } else { assertEquals ( <str> + v . number ( ) . replace ( <str> , <str> ) , constantName ) ; } String branchName = <str> + v . major + <str> + v . minor ; Version maxBranchVersion = maxBranchVersions . get ( branchName ) ; if ( maxBranchVersion = = null ) { maxBranchVersions . put ( branchName , v ) ; } else if ( v . after ( maxBranchVersion ) ) { assertFalse ( <str> + maxBranchVersion + <str> + v + <str> , maxBranchVersion . snapshot ( ) ) ; maxBranchVersions . put ( branchName , v ) ; } } } } } 
