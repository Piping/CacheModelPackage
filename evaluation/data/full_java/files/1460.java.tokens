package org . apache . cassandra . db ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . LongType ; import org . apache . cassandra . db . rows . EncodingStats ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . io . sstable . IndexHelper ; import org . apache . cassandra . io . sstable . format . big . BigFormat ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . SequentialWriter ; import org . apache . cassandra . utils . FBUtilities ; import org . junit . Assert ; import org . junit . Test ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertTrue ; public class RowIndexEntryTest extends CQLTester { private static final List < AbstractType < ? > > clusterTypes = Collections . < AbstractType < ? > > singletonList ( LongType . instance ) ; private static final ClusteringComparator comp = new ClusteringComparator ( clusterTypes ) ; private static ClusteringPrefix cn ( long l ) { return Util . clustering ( comp , l ) ; } @Test public void testArtificialIndexOf ( ) throws IOException { CFMetaData cfMeta = CFMetaData . compile ( <str> , <str> ) ; DeletionTime deletionInfo = new DeletionTime ( FBUtilities . timestampMicros ( ) , FBUtilities . nowInSeconds ( ) ) ; SerializationHeader header = new SerializationHeader ( true , cfMeta , cfMeta . partitionColumns ( ) , EncodingStats . NO_STATS ) ; IndexHelper . IndexInfo . Serializer indexSerializer = new IndexHelper . IndexInfo . Serializer ( cfMeta , BigFormat . latestVersion , header ) ; DataOutputBuffer dob = new DataOutputBuffer ( ) ; dob . writeUnsignedVInt ( <int> ) ; DeletionTime . serializer . serialize ( DeletionTime . LIVE , dob ) ; dob . writeUnsignedVInt ( <int> ) ; int off0 = dob . getLength ( ) ; indexSerializer . serialize ( new IndexHelper . IndexInfo ( cn ( <int> L ) , cn ( <int> ) , <int> , <int> , deletionInfo ) , dob ) ; int off1 = dob . getLength ( ) ; indexSerializer . serialize ( new IndexHelper . IndexInfo ( cn ( <int> ) , cn ( <int> ) , <int> , <int> , deletionInfo ) , dob ) ; int off2 = dob . getLength ( ) ; indexSerializer . serialize ( new IndexHelper . IndexInfo ( cn ( <int> ) , cn ( <int> ) , <int> , <int> , deletionInfo ) , dob ) ; dob . writeInt ( off0 ) ; dob . writeInt ( off1 ) ; dob . writeInt ( off2 ) ; @SuppressWarnings ( <str> ) DataOutputBuffer dobRie = new DataOutputBuffer ( ) ; dobRie . writeUnsignedVInt ( <int> ) ; dobRie . writeUnsignedVInt ( dob . getLength ( ) ) ; dobRie . write ( dob . buffer ( ) ) ; ByteBuffer buf = dobRie . buffer ( ) ; RowIndexEntry < IndexHelper . IndexInfo > rie = new RowIndexEntry . Serializer ( cfMeta , BigFormat . latestVersion , header ) . deserialize ( new DataInputBuffer ( buf , false ) ) ; Assert . assertEquals ( <int> , rie . position ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( - <int> ) , rie . columnsIndex ( ) , comp , false , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , false , <int> ) ) ; Assert . assertEquals ( - <int> , IndexHelper . indexFor ( cn ( - <int> ) , rie . columnsIndex ( ) , comp , true , - <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; Assert . assertEquals ( <int> , IndexHelper . indexFor ( cn ( <int> ) , rie . columnsIndex ( ) , comp , true , <int> ) ) ; } @Test public void testSerializedSize ( ) throws Throwable { String tableName = createTable ( <str> ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( tableName ) ; final RowIndexEntry simple = new RowIndexEntry ( <int> ) ; DataOutputBuffer buffer = new DataOutputBuffer ( ) ; SerializationHeader header = new SerializationHeader ( true , cfs . metadata , cfs . metadata . partitionColumns ( ) , EncodingStats . NO_STATS ) ; RowIndexEntry . Serializer serializer = new RowIndexEntry . Serializer ( cfs . metadata , BigFormat . latestVersion , header ) ; serializer . serialize ( simple , buffer ) ; assertEquals ( buffer . getLength ( ) , serializer . serializedSize ( simple ) ) ; for ( int i = <int> ; i < = DatabaseDescriptor . getColumnIndexSize ( ) / <int> ; i + + ) execute ( <str> , <int> , <str> + i , i ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs ) . build ( ) ) ; File tempFile = File . createTempFile ( <str> , null ) ; tempFile . deleteOnExit ( ) ; SequentialWriter writer = SequentialWriter . open ( tempFile ) ; ColumnIndex columnIndex = ColumnIndex . writeAndBuildIndex ( partition . unfilteredIterator ( ) , writer , header , Collections . emptySet ( ) , BigFormat . latestVersion ) ; RowIndexEntry < IndexHelper . IndexInfo > withIndex = RowIndexEntry . create ( <hex> , DeletionTime . LIVE , columnIndex ) ; IndexHelper . IndexInfo . Serializer indexSerializer = new IndexHelper . IndexInfo . Serializer ( cfs . metadata , BigFormat . latestVersion , header ) ; assertTrue ( columnIndex . columnsIndex . size ( ) > = <int> ) ; buffer = new DataOutputBuffer ( ) ; serializer . serialize ( withIndex , buffer ) ; assertEquals ( buffer . getLength ( ) , serializer . serializedSize ( withIndex ) ) ; ByteBuffer bb = buffer . buffer ( ) ; DataInputBuffer input = new DataInputBuffer ( bb , false ) ; serializationCheck ( withIndex , indexSerializer , bb , input ) ; buffer = new DataOutputBuffer ( ) { public boolean hasPosition ( ) { return false ; } public long position ( ) { throw new UnsupportedOperationException ( ) ; } } ; serializer . serialize ( withIndex , buffer ) ; bb = buffer . buffer ( ) ; input = new DataInputBuffer ( bb , false ) ; serializationCheck ( withIndex , indexSerializer , bb , input ) ; bb = buffer . buffer ( ) ; input = new DataInputBuffer ( bb , false ) ; RowIndexEntry . Serializer . skip ( input , BigFormat . latestVersion ) ; Assert . assertEquals ( <int> , bb . remaining ( ) ) ; } private void serializationCheck ( RowIndexEntry < IndexHelper . IndexInfo > withIndex , IndexHelper . IndexInfo . Serializer indexSerializer , ByteBuffer bb , DataInputBuffer input ) throws IOException { Assert . assertEquals ( <hex> , input . readUnsignedVInt ( ) ) ; Assert . assertEquals ( withIndex . promotedSize ( indexSerializer ) , input . readUnsignedVInt ( ) ) ; Assert . assertEquals ( withIndex . headerLength ( ) , input . readUnsignedVInt ( ) ) ; Assert . assertEquals ( withIndex . deletionTime ( ) , DeletionTime . serializer . deserialize ( input ) ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . size ( ) , input . readUnsignedVInt ( ) ) ; int offset = bb . position ( ) ; int [ ] offsets = new int [ withIndex . columnsIndex ( ) . size ( ) ] ; for ( int i = <int> ; i < withIndex . columnsIndex ( ) . size ( ) ; i + + ) { int pos = bb . position ( ) ; offsets [ i ] = pos - offset ; IndexHelper . IndexInfo info = indexSerializer . deserialize ( input ) ; int end = bb . position ( ) ; Assert . assertEquals ( indexSerializer . serializedSize ( info ) , end - pos ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . get ( i ) . offset , info . offset ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . get ( i ) . width , info . width ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . get ( i ) . endOpenMarker , info . endOpenMarker ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . get ( i ) . firstName , info . firstName ) ; Assert . assertEquals ( withIndex . columnsIndex ( ) . get ( i ) . lastName , info . lastName ) ; } for ( int i = <int> ; i < withIndex . columnsIndex ( ) . size ( ) ; i + + ) Assert . assertEquals ( offsets [ i ] , input . readInt ( ) ) ; Assert . assertEquals ( <int> , bb . remaining ( ) ) ; } } 
