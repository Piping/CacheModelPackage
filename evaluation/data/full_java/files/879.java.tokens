package org . apache . cassandra . schema ; import java . util . * ; import java . util . stream . Collectors ; import java . util . stream . Stream ; import com . google . common . collect . ImmutableMultimap ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . db . marshal . AbstractType ; import static com . google . common . collect . Iterables . filter ; public final class Functions implements Iterable < Function > { private final ImmutableMultimap < FunctionName , Function > functions ; private Functions ( Builder builder ) { functions = builder . functions . build ( ) ; } public static Builder builder ( ) { return new Builder ( ) ; } public static Functions none ( ) { return builder ( ) . build ( ) ; } public static Functions of ( Function . . . funs ) { return builder ( ) . add ( funs ) . build ( ) ; } public Iterator < Function > iterator ( ) { return functions . values ( ) . iterator ( ) ; } public Stream < Function > stream ( ) { return functions . values ( ) . stream ( ) ; } public Stream < UDFunction > udfs ( ) { return stream ( ) . filter ( f - > f instanceof UDFunction ) . map ( f - > ( UDFunction ) f ) ; } public Stream < UDAggregate > udas ( ) { return stream ( ) . filter ( f - > f instanceof UDAggregate ) . map ( f - > ( UDAggregate ) f ) ; } public Collection < UDAggregate > aggregatesUsingFunction ( Function function ) { return udas ( ) . filter ( uda - > uda . hasReferenceTo ( function ) ) . collect ( Collectors . toList ( ) ) ; } public Collection < Function > get ( FunctionName name ) { return functions . get ( name ) ; } public Optional < Function > find ( FunctionName name , List < AbstractType < ? > > argTypes ) { return get ( name ) . stream ( ) . filter ( fun - > typesMatch ( fun . argTypes ( ) , argTypes ) ) . findAny ( ) ; } public static boolean typesMatch ( AbstractType < ? > t1 , AbstractType < ? > t2 ) { return t1 . asCQL3Type ( ) . toString ( ) . equals ( t2 . asCQL3Type ( ) . toString ( ) ) ; } public static boolean typesMatch ( List < AbstractType < ? > > t1 , List < AbstractType < ? > > t2 ) { if ( t1 . size ( ) ! = t2 . size ( ) ) return false ; for ( int i = <int> ; i < t1 . size ( ) ; i + + ) if ( ! typesMatch ( t1 . get ( i ) , t2 . get ( i ) ) ) return false ; return true ; } public static int typeHashCode ( AbstractType < ? > t ) { return t . asCQL3Type ( ) . toString ( ) . hashCode ( ) ; } public static int typeHashCode ( List < AbstractType < ? > > types ) { int h = <int> ; for ( AbstractType < ? > type : types ) h = h * <int> + typeHashCode ( type ) ; return h ; } public Functions with ( Function fun ) { if ( find ( fun . name ( ) , fun . argTypes ( ) ) . isPresent ( ) ) throw new IllegalStateException ( String . format ( <str> , fun . name ( ) ) ) ; return builder ( ) . add ( this ) . add ( fun ) . build ( ) ; } public Functions without ( FunctionName name , List < AbstractType < ? > > argTypes ) { Function fun = find ( name , argTypes ) . orElseThrow ( ( ) - > new IllegalStateException ( String . format ( <str> , name ) ) ) ; return builder ( ) . add ( filter ( this , f - > f ! = fun ) ) . build ( ) ; } @Override public boolean equals ( Object o ) { return this = = o | | ( o instanceof Functions & & functions . equals ( ( ( Functions ) o ) . functions ) ) ; } @Override public int hashCode ( ) { return functions . hashCode ( ) ; } @Override public String toString ( ) { return functions . values ( ) . toString ( ) ; } public static final class Builder { final ImmutableMultimap . Builder < FunctionName , Function > functions = new ImmutableMultimap . Builder < > ( ) ; private Builder ( ) { functions . orderValuesBy ( ( f1 , f2 ) - > Integer . compare ( f1 . hashCode ( ) , f2 . hashCode ( ) ) ) ; } public Functions build ( ) { return new Functions ( this ) ; } public Builder add ( Function fun ) { functions . put ( fun . name ( ) , fun ) ; return this ; } public Builder add ( Function . . . funs ) { for ( Function fun : funs ) add ( fun ) ; return this ; } public Builder add ( Iterable < ? extends Function > funs ) { funs . forEach ( this : : add ) ; return this ; } } } 
