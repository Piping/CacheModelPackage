package org . elasticsearch . env ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . CoreMatchers . equalTo ; @LuceneTestCase.SuppressFileSystems ( <str> ) public class NodeEnvironmentTests extends ESTestCase { private final IndexSettings idxSettings = IndexSettingsModule . newIndexSettings ( <str> , Settings . EMPTY ) ; public void testNodeLockSingleEnvironment ( ) throws IOException { NodeEnvironment env = newNodeEnvironment ( Settings . builder ( ) . put ( <str> , <int> ) . build ( ) ) ; Settings settings = env . getSettings ( ) ; String [ ] dataPaths = env . getSettings ( ) . getAsArray ( <str> ) ; try { new NodeEnvironment ( settings , new Environment ( settings ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } env . close ( ) ; env = new NodeEnvironment ( settings , new Environment ( settings ) ) ; assertEquals ( env . nodeDataPaths ( ) . length , dataPaths . length ) ; for ( int i = <int> ; i < dataPaths . length ; i + + ) { assertTrue ( env . nodeDataPaths ( ) [ i ] . startsWith ( PathUtils . get ( dataPaths [ i ] ) ) ) ; } env . close ( ) ; assertTrue ( <str> + env . lockedShards ( ) , env . lockedShards ( ) . isEmpty ( ) ) ; } public void testNodeLockMultipleEnvironment ( ) throws IOException { final NodeEnvironment first = newNodeEnvironment ( ) ; String [ ] dataPaths = first . getSettings ( ) . getAsArray ( <str> ) ; NodeEnvironment second = new NodeEnvironment ( first . getSettings ( ) , new Environment ( first . getSettings ( ) ) ) ; assertEquals ( first . nodeDataPaths ( ) . length , dataPaths . length ) ; assertEquals ( second . nodeDataPaths ( ) . length , dataPaths . length ) ; for ( int i = <int> ; i < dataPaths . length ; i + + ) { assertEquals ( first . nodeDataPaths ( ) [ i ] . getParent ( ) , second . nodeDataPaths ( ) [ i ] . getParent ( ) ) ; } IOUtils . close ( first , second ) ; } public void testShardLock ( ) throws IOException { final NodeEnvironment env = newNodeEnvironment ( ) ; ShardLock fooLock = env . shardLock ( new ShardId ( <str> , <int> ) ) ; assertEquals ( new ShardId ( <str> , <int> ) , fooLock . getShardId ( ) ) ; try { env . shardLock ( new ShardId ( <str> , <int> ) ) ; fail ( <str> ) ; } catch ( LockObtainFailedException ex ) { } for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { Files . createDirectories ( path . resolve ( <str> ) ) ; Files . createDirectories ( path . resolve ( <str> ) ) ; } try { env . lockAllForIndex ( new Index ( <str> ) , idxSettings , randomIntBetween ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( LockObtainFailedException ex ) { } fooLock . close ( ) ; env . shardLock ( new ShardId ( <str> , <int> ) ) . close ( ) ; List < ShardLock > locks = env . lockAllForIndex ( new Index ( <str> ) , idxSettings , randomIntBetween ( <int> , <int> ) ) ; try { env . shardLock ( new ShardId ( <str> , <int> ) ) ; fail ( <str> ) ; } catch ( LockObtainFailedException ex ) { } IOUtils . close ( locks ) ; assertTrue ( <str> + env . lockedShards ( ) , env . lockedShards ( ) . isEmpty ( ) ) ; env . close ( ) ; } public void testGetAllIndices ( ) throws Exception { final NodeEnvironment env = newNodeEnvironment ( ) ; final int numIndices = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numIndices ; i + + ) { for ( Path path : env . indexPaths ( new Index ( <str> + i ) ) ) { Files . createDirectories ( path ) ; } } Set < String > indices = env . findAllIndices ( ) ; assertEquals ( indices . size ( ) , numIndices ) ; for ( int i = <int> ; i < numIndices ; i + + ) { assertTrue ( indices . contains ( <str> + i ) ) ; } assertTrue ( <str> + env . lockedShards ( ) , env . lockedShards ( ) . isEmpty ( ) ) ; env . close ( ) ; } public void testDeleteSafe ( ) throws IOException , InterruptedException { final NodeEnvironment env = newNodeEnvironment ( ) ; ShardLock fooLock = env . shardLock ( new ShardId ( <str> , <int> ) ) ; assertEquals ( new ShardId ( <str> , <int> ) , fooLock . getShardId ( ) ) ; for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { Files . createDirectories ( path . resolve ( <str> ) ) ; Files . createDirectories ( path . resolve ( <str> ) ) ; } try { env . deleteShardDirectorySafe ( new ShardId ( <str> , <int> ) , idxSettings ) ; fail ( <str> ) ; } catch ( LockObtainFailedException ex ) { } for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { assertTrue ( Files . exists ( path . resolve ( <str> ) ) ) ; assertTrue ( Files . exists ( path . resolve ( <str> ) ) ) ; } env . deleteShardDirectorySafe ( new ShardId ( <str> , <int> ) , idxSettings ) ; for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { assertTrue ( Files . exists ( path . resolve ( <str> ) ) ) ; assertFalse ( Files . exists ( path . resolve ( <str> ) ) ) ; } try { env . deleteIndexDirectorySafe ( new Index ( <str> ) , randomIntBetween ( <int> , <int> ) , idxSettings ) ; fail ( <str> ) ; } catch ( LockObtainFailedException ex ) { } fooLock . close ( ) ; for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { assertTrue ( Files . exists ( path ) ) ; } final AtomicReference < Throwable > threadException = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final CountDownLatch blockLatch = new CountDownLatch ( <int> ) ; final CountDownLatch start = new CountDownLatch ( <int> ) ; if ( randomBoolean ( ) ) { Thread t = new Thread ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; threadException . set ( t ) ; latch . countDown ( ) ; blockLatch . countDown ( ) ; } @Override protected void doRun ( ) throws Exception { start . await ( ) ; try ( ShardLock autoCloses = env . shardLock ( new ShardId ( <str> , <int> ) ) ) { blockLatch . countDown ( ) ; Thread . sleep ( randomIntBetween ( <int> , <int> ) ) ; } latch . countDown ( ) ; } } ) ; t . start ( ) ; } else { latch . countDown ( ) ; blockLatch . countDown ( ) ; } start . countDown ( ) ; blockLatch . await ( ) ; env . deleteIndexDirectorySafe ( new Index ( <str> ) , <int> , idxSettings ) ; assertNull ( threadException . get ( ) ) ; for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { assertFalse ( Files . exists ( path ) ) ; } latch . await ( ) ; assertTrue ( <str> + env . lockedShards ( ) , env . lockedShards ( ) . isEmpty ( ) ) ; env . close ( ) ; } public void testStressShardLock ( ) throws IOException , InterruptedException { class Int { int value = <int> ; } final NodeEnvironment env = newNodeEnvironment ( ) ; final int shards = randomIntBetween ( <int> , <int> ) ; final Int [ ] counts = new Int [ shards ] ; final AtomicInteger [ ] countsAtomic = new AtomicInteger [ shards ] ; final AtomicInteger [ ] flipFlop = new AtomicInteger [ shards ] ; for ( int i = <int> ; i < counts . length ; i + + ) { counts [ i ] = new Int ( ) ; countsAtomic [ i ] = new AtomicInteger ( ) ; flipFlop [ i ] = new AtomicInteger ( ) ; } Thread [ ] threads = new Thread [ randomIntBetween ( <int> , <int> ) ] ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( ) { @Override public void run ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { fail ( e . getMessage ( ) ) ; } for ( int i = <int> ; i < iters ; i + + ) { int shard = randomIntBetween ( <int> , counts . length - <int> ) ; try { try ( ShardLock autoCloses = env . shardLock ( new ShardId ( <str> , shard ) , scaledRandomIntBetween ( <int> , <int> ) ) ) { counts [ shard ] . value + + ; countsAtomic [ shard ] . incrementAndGet ( ) ; assertEquals ( flipFlop [ shard ] . incrementAndGet ( ) , <int> ) ; assertEquals ( flipFlop [ shard ] . decrementAndGet ( ) , <int> ) ; } } catch ( LockObtainFailedException ex ) { } catch ( IOException ex ) { fail ( ex . toString ( ) ) ; } } } } ; threads [ i ] . start ( ) ; } latch . countDown ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] . join ( ) ; } assertTrue ( <str> + env . lockedShards ( ) , env . lockedShards ( ) . isEmpty ( ) ) ; for ( int i = <int> ; i < counts . length ; i + + ) { assertTrue ( counts [ i ] . value > <int> ) ; assertEquals ( flipFlop [ i ] . get ( ) , <int> ) ; assertEquals ( counts [ i ] . value , countsAtomic [ i ] . get ( ) ) ; } env . close ( ) ; } public void testCustomDataPaths ( ) throws Exception { String [ ] dataPaths = tmpPaths ( ) ; NodeEnvironment env = newNodeEnvironment ( dataPaths , <str> , Settings . EMPTY ) ; IndexSettings s1 = IndexSettingsModule . newIndexSettings ( <str> , Settings . EMPTY ) ; IndexSettings s2 = IndexSettingsModule . newIndexSettings ( <str> , Settings . builder ( ) . put ( IndexMetaData . SETTING_DATA_PATH , <str> ) . build ( ) ) ; ShardId sid = new ShardId ( <str> , <int> ) ; Index i = new Index ( <str> ) ; assertFalse ( <str> , s1 . hasCustomDataPath ( ) ) ; assertTrue ( <str> , s2 . hasCustomDataPath ( ) ) ; assertThat ( env . availableShardPaths ( sid ) , equalTo ( env . availableShardPaths ( sid ) ) ) ; assertThat ( env . resolveCustomLocation ( s2 , sid ) , equalTo ( PathUtils . get ( <str> ) ) ) ; assertThat ( <str> , env . availableShardPaths ( sid ) , equalTo ( stringsToPaths ( dataPaths , <str> ) ) ) ; assertThat ( <str> , env . indexPaths ( i ) , equalTo ( stringsToPaths ( dataPaths , <str> ) ) ) ; env . close ( ) ; NodeEnvironment env2 = newNodeEnvironment ( dataPaths , <str> , Settings . builder ( ) . put ( NodeEnvironment . ADD_NODE_ID_TO_CUSTOM_PATH , false ) . build ( ) ) ; assertThat ( env2 . availableShardPaths ( sid ) , equalTo ( env2 . availableShardPaths ( sid ) ) ) ; assertThat ( env2 . resolveCustomLocation ( s2 , sid ) , equalTo ( PathUtils . get ( <str> ) ) ) ; assertThat ( <str> , env2 . availableShardPaths ( sid ) , equalTo ( stringsToPaths ( dataPaths , <str> ) ) ) ; assertThat ( <str> , env2 . indexPaths ( i ) , equalTo ( stringsToPaths ( dataPaths , <str> ) ) ) ; env2 . close ( ) ; } private Path [ ] stringsToPaths ( String [ ] strings , String additional ) { Path [ ] locations = new Path [ strings . length ] ; for ( int i = <int> ; i < strings . length ; i + + ) { locations [ i ] = PathUtils . get ( strings [ i ] , additional ) ; } return locations ; } @Override public String [ ] tmpPaths ( ) { final int numPaths = randomIntBetween ( <int> , <int> ) ; final String [ ] absPaths = new String [ numPaths ] ; for ( int i = <int> ; i < numPaths ; i + + ) { absPaths [ i ] = createTempDir ( ) . toAbsolutePath ( ) . toString ( ) ; } return absPaths ; } @Override public NodeEnvironment newNodeEnvironment ( ) throws IOException { return newNodeEnvironment ( Settings . EMPTY ) ; } @Override public NodeEnvironment newNodeEnvironment ( Settings settings ) throws IOException { Settings build = Settings . builder ( ) . put ( settings ) . put ( <str> , createTempDir ( ) . toAbsolutePath ( ) . toString ( ) ) . putArray ( <str> , tmpPaths ( ) ) . build ( ) ; return new NodeEnvironment ( build , new Environment ( build ) ) ; } public NodeEnvironment newNodeEnvironment ( String [ ] dataPaths , Settings settings ) throws IOException { Settings build = Settings . builder ( ) . put ( settings ) . put ( <str> , createTempDir ( ) . toAbsolutePath ( ) . toString ( ) ) . putArray ( <str> , dataPaths ) . build ( ) ; return new NodeEnvironment ( build , new Environment ( build ) ) ; } public NodeEnvironment newNodeEnvironment ( String [ ] dataPaths , String sharedDataPath , Settings settings ) throws IOException { Settings build = Settings . builder ( ) . put ( settings ) . put ( <str> , createTempDir ( ) . toAbsolutePath ( ) . toString ( ) ) . put ( <str> , sharedDataPath ) . putArray ( <str> , dataPaths ) . build ( ) ; return new NodeEnvironment ( build , new Environment ( build ) ) ; } } 
