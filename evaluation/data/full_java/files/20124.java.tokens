package io . netty . testsuite . transport ; import io . netty . bootstrap . AbstractBootstrap ; import io . netty . buffer . ByteBufAllocator ; import io . netty . testsuite . util . TestUtils ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . Rule ; import org . junit . rules . TestName ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . List ; public abstract class AbstractTestsuiteTest < T extends AbstractBootstrap < ? , ? > > { private final Class < T > clazz ; protected final InternalLogger logger = InternalLoggerFactory . getInstance ( getClass ( ) ) ; protected volatile T cb ; protected AbstractTestsuiteTest ( Class < T > clazz ) { this . clazz = clazz ; } protected abstract List < TestsuitePermutation . BootstrapFactory < T > > newFactories ( ) ; protected List < ByteBufAllocator > newAllocators ( ) { return TestsuitePermutation . allocator ( ) ; } @Rule public final TestName testName = new TestName ( ) ; protected void run ( ) throws Throwable { List < TestsuitePermutation . BootstrapFactory < T > > combos = newFactories ( ) ; for ( ByteBufAllocator allocator : newAllocators ( ) ) { int i = <int> ; for ( TestsuitePermutation . BootstrapFactory < T > e : combos ) { cb = e . newInstance ( ) ; configure ( cb , allocator ) ; logger . info ( String . format ( <str> , testName . getMethodName ( ) , + + i , combos . size ( ) , StringUtil . simpleClassName ( allocator ) ) ) ; try { Method m = getClass ( ) . getMethod ( TestUtils . testMethodName ( testName ) , clazz ) ; m . invoke ( this , cb ) ; } catch ( InvocationTargetException ex ) { throw ex . getCause ( ) ; } } } } protected abstract void configure ( T bootstrap , ByteBufAllocator allocator ) ; } 
