package org . apache . cassandra . tools ; import java . io . IOException ; import java . io . PrintStream ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . Multimap ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; public class SSTableExpiredBlockers { public static void main ( String [ ] args ) throws IOException { PrintStream out = System . out ; if ( args . length < <int> ) { out . println ( <str> ) ; System . exit ( <int> ) ; } Util . initDatabaseDescriptor ( ) ; String keyspace = args [ args . length - <int> ] ; String columnfamily = args [ args . length - <int> ] ; Schema . instance . loadFromDisk ( false ) ; CFMetaData metadata = Schema . instance . getCFMetaData ( keyspace , columnfamily ) ; if ( metadata = = null ) throw new IllegalArgumentException ( String . format ( <str> , keyspace , columnfamily ) ) ; Keyspace ks = Keyspace . openWithoutSSTables ( keyspace ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( columnfamily ) ; Directories . SSTableLister lister = cfs . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) ; Set < SSTableReader > sstables = new HashSet < > ( ) ; for ( Map . Entry < Descriptor , Set < Component > > sstable : lister . list ( ) . entrySet ( ) ) { if ( sstable . getKey ( ) ! = null ) { try { SSTableReader reader = SSTableReader . open ( sstable . getKey ( ) ) ; sstables . add ( reader ) ; } catch ( Throwable t ) { out . println ( <str> + sstable . getKey ( ) . filenameFor ( Component . DATA ) + <str> + t . getMessage ( ) + <str> ) ; } } } if ( sstables . isEmpty ( ) ) { out . println ( <str> + keyspace + <str> + columnfamily ) ; System . exit ( <int> ) ; } int gcBefore = ( int ) ( System . currentTimeMillis ( ) / <int> ) - metadata . params . gcGraceSeconds ; Multimap < SSTableReader , SSTableReader > blockers = checkForExpiredSSTableBlockers ( sstables , gcBefore ) ; for ( SSTableReader blocker : blockers . keySet ( ) ) { out . println ( String . format ( <str> , formatForExpiryTracing ( Collections . singleton ( blocker ) ) , blockers . get ( blocker ) . size ( ) , formatForExpiryTracing ( blockers . get ( blocker ) ) ) ) ; } System . exit ( <int> ) ; } public static Multimap < SSTableReader , SSTableReader > checkForExpiredSSTableBlockers ( Iterable < SSTableReader > sstables , int gcBefore ) { Multimap < SSTableReader , SSTableReader > blockers = ArrayListMultimap . create ( ) ; for ( SSTableReader sstable : sstables ) { if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime < gcBefore ) { for ( SSTableReader potentialBlocker : sstables ) { if ( ! potentialBlocker . equals ( sstable ) & & potentialBlocker . getMinTimestamp ( ) < = sstable . getMaxTimestamp ( ) & & potentialBlocker . getSSTableMetadata ( ) . maxLocalDeletionTime > gcBefore ) blockers . put ( potentialBlocker , sstable ) ; } } } return blockers ; } private static String formatForExpiryTracing ( Iterable < SSTableReader > sstables ) { StringBuilder sb = new StringBuilder ( ) ; for ( SSTableReader sstable : sstables ) sb . append ( String . format ( <str> , sstable , sstable . getMinTimestamp ( ) , sstable . getMaxTimestamp ( ) , sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ) ) . append ( <str> ) ; return sb . toString ( ) ; } } 
