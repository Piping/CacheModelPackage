package org . elasticsearch . cluster . routing . allocation . decider ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . Allocation ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . Rebalance ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESAllocationTestCase ; import java . util . EnumSet ; import java . util . List ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . RELOCATING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . STARTED ; import static org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE ; import static org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE ; import static org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . INDEX_ROUTING_ALLOCATION_ENABLE ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; public class EnableAllocationTests extends ESAllocationTestCase { private final ESLogger logger = Loggers . getLogger ( EnableAllocationTests . class ) ; public void testClusterEnableNone ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . NONE . name ( ) ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; } public void testClusterEnableOnlyPrimaries ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . PRIMARIES . name ( ) ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; } public void testIndexEnableNone ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . build ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( INDEX_ROUTING_ALLOCATION_ENABLE , Allocation . NONE . name ( ) ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( <str> , STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( <str> , STARTED ) . size ( ) , equalTo ( <int> ) ) ; } public void testEnableClusterBalance ( ) { final boolean useClusterSetting = randomBoolean ( ) ; final Rebalance allowedOnes = RandomPicks . randomFrom ( getRandom ( ) , EnumSet . of ( Rebalance . PRIMARIES , Rebalance . REPLICAS , Rebalance . ALL ) ) ; Settings build = settingsBuilder ( ) . put ( CLUSTER_ROUTING_REBALANCE_ENABLE , useClusterSetting ? Rebalance . NONE : RandomPicks . randomFrom ( getRandom ( ) , Rebalance . values ( ) ) ) . put ( ConcurrentRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE , <int> ) . build ( ) ; NodeSettingsService nodeSettingsService = new NodeSettingsService ( build ) ; AllocationService strategy = createAllocationService ( build , nodeSettingsService , getRandom ( ) ) ; Settings indexSettings = useClusterSetting ? Settings . EMPTY : settingsBuilder ( ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , Rebalance . NONE ) . build ( ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( indexSettings ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , Rebalance . NONE ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; ClusterState prevState = clusterState ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; if ( useClusterSetting ) { prevState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . metaData ( MetaData . builder ( metaData ) . transientSettings ( settingsBuilder ( ) . put ( CLUSTER_ROUTING_REBALANCE_ENABLE , allowedOnes ) . build ( ) ) ) . build ( ) ; } else { prevState = clusterState ; IndexMetaData meta = clusterState . getMetaData ( ) . index ( <str> ) ; IndexMetaData meta1 = clusterState . getMetaData ( ) . index ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . metaData ( MetaData . builder ( metaData ) . removeAllIndices ( ) . put ( IndexMetaData . builder ( meta1 ) ) . put ( IndexMetaData . builder ( meta ) . settings ( settingsBuilder ( ) . put ( meta . getSettings ( ) ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , allowedOnes ) . build ( ) ) ) ) . build ( ) ; } nodeSettingsService . clusterChanged ( new ClusterChangedEvent ( <str> , clusterState , prevState ) ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( <str> + useClusterSetting , clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> + useClusterSetting , clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; List < ShardRouting > mutableShardRoutings = clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) ; switch ( allowedOnes ) { case PRIMARIES : for ( ShardRouting routing : mutableShardRoutings ) { assertTrue ( <str> , routing . primary ( ) ) ; assertThat ( <str> , routing . getIndex ( ) , equalTo ( <str> ) ) ; } break ; case REPLICAS : for ( ShardRouting routing : mutableShardRoutings ) { assertFalse ( <str> , routing . primary ( ) ) ; assertThat ( <str> , routing . getIndex ( ) , equalTo ( <str> ) ) ; } break ; case ALL : for ( ShardRouting routing : mutableShardRoutings ) { assertThat ( <str> , routing . getIndex ( ) , equalTo ( <str> ) ) ; } break ; default : fail ( <str> ) ; } routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; } public void testEnableClusterBalanceNoReplicas ( ) { final boolean useClusterSetting = randomBoolean ( ) ; Settings build = settingsBuilder ( ) . put ( CLUSTER_ROUTING_REBALANCE_ENABLE , useClusterSetting ? Rebalance . NONE : RandomPicks . randomFrom ( getRandom ( ) , Rebalance . values ( ) ) ) . put ( ConcurrentRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE , <int> ) . build ( ) ; NodeSettingsService nodeSettingsService = new NodeSettingsService ( build ) ; AllocationService strategy = createAllocationService ( build , nodeSettingsService , getRandom ( ) ) ; Settings indexSettings = useClusterSetting ? Settings . EMPTY : settingsBuilder ( ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , Rebalance . NONE ) . build ( ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( indexSettings ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; ClusterState prevState = clusterState ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; if ( useClusterSetting ) { prevState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . metaData ( MetaData . builder ( metaData ) . transientSettings ( settingsBuilder ( ) . put ( CLUSTER_ROUTING_REBALANCE_ENABLE , randomBoolean ( ) ? Rebalance . PRIMARIES : Rebalance . ALL ) . build ( ) ) ) . build ( ) ; } else { prevState = clusterState ; IndexMetaData meta = clusterState . getMetaData ( ) . index ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . metaData ( MetaData . builder ( metaData ) . removeAllIndices ( ) . put ( IndexMetaData . builder ( meta ) . settings ( settingsBuilder ( ) . put ( meta . getSettings ( ) ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , randomBoolean ( ) ? Rebalance . PRIMARIES : Rebalance . ALL ) . build ( ) ) ) ) . build ( ) ; } nodeSettingsService . clusterChanged ( new ClusterChangedEvent ( <str> , clusterState , prevState ) ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( <str> + useClusterSetting , clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> + useClusterSetting , clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) , equalTo ( <int> ) ) ; } } 
