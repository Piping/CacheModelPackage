package com . google . common . base ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . VisibleForTesting ; import java . io . Serializable ; import java . util . concurrent . TimeUnit ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @CheckReturnValue @GwtCompatible public final class Suppliers { private Suppliers ( ) { } public static < F , T > Supplier < T > compose ( Function < ? super F , T > function , Supplier < F > supplier ) { Preconditions . checkNotNull ( function ) ; Preconditions . checkNotNull ( supplier ) ; return new SupplierComposition < F , T > ( function , supplier ) ; } private static class SupplierComposition < F , T > implements Supplier < T > , Serializable { final Function < ? super F , T > function ; final Supplier < F > supplier ; SupplierComposition ( Function < ? super F , T > function , Supplier < F > supplier ) { this . function = function ; this . supplier = supplier ; } @Override public T get ( ) { return function . apply ( supplier . get ( ) ) ; } @Override public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SupplierComposition ) { SupplierComposition < ? , ? > that = ( SupplierComposition < ? , ? > ) obj ; return function . equals ( that . function ) & & supplier . equals ( that . supplier ) ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( function , supplier ) ; } @Override public String toString ( ) { return <str> + function + <str> + supplier + <str> ; } private static final long serialVersionUID = <int> ; } public static < T > Supplier < T > memoize ( Supplier < T > delegate ) { return ( delegate instanceof MemoizingSupplier ) ? delegate : new MemoizingSupplier < T > ( Preconditions . checkNotNull ( delegate ) ) ; } @VisibleForTesting static class MemoizingSupplier < T > implements Supplier < T > , Serializable { final Supplier < T > delegate ; transient volatile boolean initialized ; transient T value ; MemoizingSupplier ( Supplier < T > delegate ) { this . delegate = delegate ; } @Override public T get ( ) { if ( ! initialized ) { synchronized ( this ) { if ( ! initialized ) { T t = delegate . get ( ) ; value = t ; initialized = true ; return t ; } } } return value ; } @Override public String toString ( ) { return <str> + delegate + <str> ; } private static final long serialVersionUID = <int> ; } public static < T > Supplier < T > memoizeWithExpiration ( Supplier < T > delegate , long duration , TimeUnit unit ) { return new ExpiringMemoizingSupplier < T > ( delegate , duration , unit ) ; } @VisibleForTesting static class ExpiringMemoizingSupplier < T > implements Supplier < T > , Serializable { final Supplier < T > delegate ; final long durationNanos ; transient volatile T value ; transient volatile long expirationNanos ; ExpiringMemoizingSupplier ( Supplier < T > delegate , long duration , TimeUnit unit ) { this . delegate = Preconditions . checkNotNull ( delegate ) ; this . durationNanos = unit . toNanos ( duration ) ; Preconditions . checkArgument ( duration > <int> ) ; } @Override public T get ( ) { long nanos = expirationNanos ; long now = Platform . systemNanoTime ( ) ; if ( nanos = = <int> | | now - nanos > = <int> ) { synchronized ( this ) { if ( nanos = = expirationNanos ) { T t = delegate . get ( ) ; value = t ; nanos = now + durationNanos ; expirationNanos = ( nanos = = <int> ) ? <int> : nanos ; return t ; } } } return value ; } @Override public String toString ( ) { return <str> + delegate + <str> + durationNanos + <str> ; } private static final long serialVersionUID = <int> ; } public static < T > Supplier < T > ofInstance ( @Nullable T instance ) { return new SupplierOfInstance < T > ( instance ) ; } private static class SupplierOfInstance < T > implements Supplier < T > , Serializable { final T instance ; SupplierOfInstance ( @Nullable T instance ) { this . instance = instance ; } @Override public T get ( ) { return instance ; } @Override public boolean equals ( @Nullable Object obj ) { if ( obj instanceof SupplierOfInstance ) { SupplierOfInstance < ? > that = ( SupplierOfInstance < ? > ) obj ; return Objects . equal ( instance , that . instance ) ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( instance ) ; } @Override public String toString ( ) { return <str> + instance + <str> ; } private static final long serialVersionUID = <int> ; } public static < T > Supplier < T > synchronizedSupplier ( Supplier < T > delegate ) { return new ThreadSafeSupplier < T > ( Preconditions . checkNotNull ( delegate ) ) ; } private static class ThreadSafeSupplier < T > implements Supplier < T > , Serializable { final Supplier < T > delegate ; ThreadSafeSupplier ( Supplier < T > delegate ) { this . delegate = delegate ; } @Override public T get ( ) { synchronized ( delegate ) { return delegate . get ( ) ; } } @Override public String toString ( ) { return <str> + delegate + <str> ; } private static final long serialVersionUID = <int> ; } @Beta public static < T > Function < Supplier < T > , T > supplierFunction ( ) { @SuppressWarnings ( <str> ) SupplierFunction < T > sf = ( SupplierFunction < T > ) SupplierFunctionImpl . INSTANCE ; return sf ; } private interface SupplierFunction < T > extends Function < Supplier < T > , T > { } private enum SupplierFunctionImpl implements SupplierFunction < Object > { INSTANCE ; @Override public Object apply ( Supplier < Object > input ) { return input . get ( ) ; } @Override public String toString ( ) { return <str> ; } } } 
