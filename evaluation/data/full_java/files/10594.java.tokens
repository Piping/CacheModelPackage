package com . google . common . primitives ; import static java . lang . Long . MAX_VALUE ; import static java . lang . Long . MIN_VALUE ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Converter ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Random ; @GwtCompatible ( emulated = true ) @SuppressWarnings ( <str> ) public class LongsTest extends TestCase { private static final long [ ] EMPTY = { } ; private static final long [ ] ARRAY1 = { ( long ) <int> } ; private static final long [ ] ARRAY234 = { ( long ) <int> , ( long ) <int> , ( long ) <int> } ; private static final long [ ] VALUES = { MIN_VALUE , ( long ) - <int> , ( long ) <int> , ( long ) <int> , MAX_VALUE } ; @GwtIncompatible ( <str> ) public void testHashCode ( ) { for ( long value : VALUES ) { assertEquals ( <str> + value , ( ( Long ) value ) . hashCode ( ) , Longs . hashCode ( value ) ) ; } } public void testCompare ( ) { for ( long x : VALUES ) { for ( long y : VALUES ) { assertEquals ( x + <str> + y , Long . valueOf ( x ) . compareTo ( y ) , Longs . compare ( x , y ) ) ; } } } public void testContains ( ) { assertFalse ( Longs . contains ( EMPTY , ( long ) <int> ) ) ; assertFalse ( Longs . contains ( ARRAY1 , ( long ) <int> ) ) ; assertFalse ( Longs . contains ( ARRAY234 , ( long ) <int> ) ) ; assertTrue ( Longs . contains ( new long [ ] { ( long ) - <int> } , ( long ) - <int> ) ) ; assertTrue ( Longs . contains ( ARRAY234 , ( long ) <int> ) ) ; assertTrue ( Longs . contains ( ARRAY234 , ( long ) <int> ) ) ; assertTrue ( Longs . contains ( ARRAY234 , ( long ) <int> ) ) ; } public void testIndexOf ( ) { assertEquals ( - <int> , Longs . indexOf ( EMPTY , ( long ) <int> ) ) ; assertEquals ( - <int> , Longs . indexOf ( ARRAY1 , ( long ) <int> ) ) ; assertEquals ( - <int> , Longs . indexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . indexOf ( new long [ ] { ( long ) - <int> } , ( long ) - <int> ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . indexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , ( long ) <int> ) ) ; } public void testIndexOf_arrayTarget ( ) { assertEquals ( <int> , Longs . indexOf ( EMPTY , EMPTY ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , EMPTY ) ) ; assertEquals ( - <int> , Longs . indexOf ( EMPTY , ARRAY234 ) ) ; assertEquals ( - <int> , Longs . indexOf ( ARRAY234 , ARRAY1 ) ) ; assertEquals ( - <int> , Longs . indexOf ( ARRAY1 , ARRAY234 ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY1 , ARRAY1 ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , ARRAY234 ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , new long [ ] { ( long ) <int> , ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , new long [ ] { ( long ) <int> , ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , new long [ ] { ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( ARRAY234 , new long [ ] { ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , new long [ ] { ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } ) ) ; assertEquals ( <int> , Longs . indexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } ) ) ; assertEquals ( - <int> , Longs . indexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } , new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } ) ) ; } public void testLastIndexOf ( ) { assertEquals ( - <int> , Longs . lastIndexOf ( EMPTY , ( long ) <int> ) ) ; assertEquals ( - <int> , Longs . lastIndexOf ( ARRAY1 , ( long ) <int> ) ) ; assertEquals ( - <int> , Longs . lastIndexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . lastIndexOf ( new long [ ] { ( long ) - <int> } , ( long ) - <int> ) ) ; assertEquals ( <int> , Longs . lastIndexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . lastIndexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . lastIndexOf ( ARRAY234 , ( long ) <int> ) ) ; assertEquals ( <int> , Longs . lastIndexOf ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , ( long ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { Longs . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( MIN_VALUE , Longs . max ( MIN_VALUE ) ) ; assertEquals ( MAX_VALUE , Longs . max ( MAX_VALUE ) ) ; assertEquals ( ( long ) <int> , Longs . max ( ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { Longs . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( MIN_VALUE , Longs . min ( MIN_VALUE ) ) ; assertEquals ( MAX_VALUE , Longs . min ( MAX_VALUE ) ) ; assertEquals ( ( long ) <int> , Longs . min ( ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> ) ) ; } public void testConcat ( ) { assertTrue ( Arrays . equals ( EMPTY , Longs . concat ( ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Longs . concat ( EMPTY ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Longs . concat ( EMPTY , EMPTY , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Longs . concat ( ARRAY1 ) ) ) ; assertNotSame ( ARRAY1 , Longs . concat ( ARRAY1 ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Longs . concat ( EMPTY , ARRAY1 , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } , Longs . concat ( ARRAY1 , ARRAY1 , ARRAY1 ) ) ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } , Longs . concat ( ARRAY1 , ARRAY234 ) ) ) ; } private static void assertByteArrayEquals ( byte [ ] expected , byte [ ] actual ) { assertTrue ( <str> + Arrays . toString ( expected ) + <str> + Arrays . toString ( actual ) , Arrays . equals ( expected , actual ) ) ; } public void testToByteArray ( ) { assertByteArrayEquals ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } , Longs . toByteArray ( <hex> ) ) ; assertByteArrayEquals ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } , Longs . toByteArray ( <hex> ) ) ; } public void testFromByteArray ( ) { assertEquals ( <hex> , Longs . fromByteArray ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ) ; assertEquals ( <hex> , Longs . fromByteArray ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ) ) ; } @SuppressWarnings ( <str> ) public void testFromByteArrayFails ( ) { try { Longs . fromByteArray ( new byte [ Longs . BYTES - <int> ] ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testFromBytes ( ) { assertEquals ( <hex> , Longs . fromBytes ( ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> ) ) ; assertEquals ( <hex> , Longs . fromBytes ( ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> ) ) ; } public void testByteArrayRoundTrips ( ) { Random r = new Random ( <int> ) ; byte [ ] b = new byte [ Longs . BYTES ] ; for ( int i = <int> ; i < <int> ; i + + ) { long num = r . nextLong ( ) ; assertEquals ( num , Longs . fromByteArray ( Longs . toByteArray ( num ) ) ) ; r . nextBytes ( b ) ; long value = Longs . fromByteArray ( b ) ; assertTrue ( <str> + value , Arrays . equals ( b , Longs . toByteArray ( value ) ) ) ; } } public void testEnsureCapacity ( ) { assertSame ( EMPTY , Longs . ensureCapacity ( EMPTY , <int> , <int> ) ) ; assertSame ( ARRAY1 , Longs . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertSame ( ARRAY1 , Longs . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } , Longs . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testEnsureCapacity_fail ( ) { try { Longs . ensureCapacity ( ARRAY1 , - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { Longs . ensureCapacity ( ARRAY1 , <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testJoin ( ) { assertEquals ( <str> , Longs . join ( <str> , EMPTY ) ) ; assertEquals ( <str> , Longs . join ( <str> , ARRAY1 ) ) ; assertEquals ( <str> , Longs . join ( <str> , ( long ) <int> , ( long ) <int> ) ) ; assertEquals ( <str> , Longs . join ( <str> , ( long ) <int> , ( long ) <int> , ( long ) <int> ) ) ; } public void testLexicographicalComparator ( ) { List < long [ ] > ordered = Arrays . asList ( new long [ ] { } , new long [ ] { MIN_VALUE } , new long [ ] { MIN_VALUE , MIN_VALUE } , new long [ ] { MIN_VALUE , ( long ) <int> } , new long [ ] { ( long ) <int> } , new long [ ] { ( long ) <int> , MIN_VALUE } , new long [ ] { MAX_VALUE , MAX_VALUE - ( long ) <int> } , new long [ ] { MAX_VALUE , MAX_VALUE } , new long [ ] { MAX_VALUE , MAX_VALUE , MAX_VALUE } ) ; Comparator < long [ ] > comparator = Longs . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; } @GwtIncompatible ( <str> ) public void testLexicographicalComparatorSerializable ( ) { Comparator < long [ ] > comparator = Longs . lexicographicalComparator ( ) ; assertSame ( comparator , SerializableTester . reserialize ( comparator ) ) ; } @GwtIncompatible ( <str> ) public void testStringConverterSerialization ( ) { SerializableTester . reserializeAndAssert ( Longs . stringConverter ( ) ) ; } public void testToArray ( ) { List < Long > none = Arrays . < Long > asList ( ) ; assertTrue ( Arrays . equals ( EMPTY , Longs . toArray ( none ) ) ) ; List < Long > one = Arrays . asList ( ( long ) <int> ) ; assertTrue ( Arrays . equals ( ARRAY1 , Longs . toArray ( one ) ) ) ; long [ ] array = { ( long ) <int> , ( long ) <int> , <hex> } ; List < Long > three = Arrays . asList ( ( long ) <int> , ( long ) <int> , <hex> ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( three ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( Longs . asList ( array ) ) ) ) ; } public void testToArray_threadSafe ( ) { for ( int delta : new int [ ] { + <int> , <int> , - <int> } ) { for ( int i = <int> ; i < VALUES . length ; i + + ) { List < Long > list = Longs . asList ( VALUES ) . subList ( <int> , i ) ; Collection < Long > misleadingSize = Helpers . misleadingSizeCollection ( delta ) ; misleadingSize . addAll ( list ) ; long [ ] arr = Longs . toArray ( misleadingSize ) ; assertEquals ( i , arr . length ) ; for ( int j = <int> ; j < i ; j + + ) { assertEquals ( VALUES [ j ] , arr [ j ] ) ; } } } } @SuppressWarnings ( <str> ) public void testToArray_withNull ( ) { List < Long > list = Arrays . asList ( ( long ) <int> , ( long ) <int> , null ) ; try { Longs . toArray ( list ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testToArray_withConversion ( ) { long [ ] array = { ( long ) <int> , ( long ) <int> , ( long ) <int> } ; List < Byte > bytes = Arrays . asList ( ( byte ) <int> , ( byte ) <int> , ( byte ) <int> ) ; List < Short > shorts = Arrays . asList ( ( short ) <int> , ( short ) <int> , ( short ) <int> ) ; List < Integer > ints = Arrays . asList ( <int> , <int> , <int> ) ; List < Float > floats = Arrays . asList ( ( float ) <int> , ( float ) <int> , ( float ) <int> ) ; List < Long > longs = Arrays . asList ( ( long ) <int> , ( long ) <int> , ( long ) <int> ) ; List < Double > doubles = Arrays . asList ( ( double ) <int> , ( double ) <int> , ( double ) <int> ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( bytes ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( shorts ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( ints ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( floats ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( longs ) ) ) ; assertTrue ( Arrays . equals ( array , Longs . toArray ( doubles ) ) ) ; } public void testAsList_isAView ( ) { long [ ] array = { ( long ) <int> , ( long ) <int> } ; List < Long > list = Longs . asList ( array ) ; list . set ( <int> , ( long ) <int> ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> } , array ) ) ; array [ <int> ] = ( long ) <int> ; assertEquals ( Arrays . asList ( ( long ) <int> , ( long ) <int> ) , list ) ; } public void testAsList_toArray_roundTrip ( ) { long [ ] array = { ( long ) <int> , ( long ) <int> , ( long ) <int> } ; List < Long > list = Longs . asList ( array ) ; long [ ] newArray = Longs . toArray ( list ) ; list . set ( <int> , ( long ) <int> ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> , ( long ) <int> } , newArray ) ) ; newArray [ <int> ] = ( long ) <int> ; assertEquals ( ( long ) <int> , ( long ) list . get ( <int> ) ) ; } public void testAsList_subList_toArray_roundTrip ( ) { long [ ] array = { ( long ) <int> , ( long ) <int> , ( long ) <int> , ( long ) <int> } ; List < Long > list = Longs . asList ( array ) ; assertTrue ( Arrays . equals ( new long [ ] { ( long ) <int> , ( long ) <int> } , Longs . toArray ( list . subList ( <int> , <int> ) ) ) ) ; assertTrue ( Arrays . equals ( new long [ ] { } , Longs . toArray ( list . subList ( <int> , <int> ) ) ) ) ; } public void testAsListEmpty ( ) { assertSame ( Collections . emptyList ( ) , Longs . asList ( EMPTY ) ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Longs . class ) ; } public void testStringConverter_convert ( ) { Converter < String , Long > converter = Longs . stringConverter ( ) ; assertEquals ( ( Long ) <int> , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) <int> L , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) ( - <int> ) , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) <int> , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) <int> , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) ( - <int> ) , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) <int> , converter . convert ( <str> ) ) ; assertEquals ( ( Long ) <int> , converter . convert ( <str> ) ) ; } public void testStringConverter_convertError ( ) { try { Longs . stringConverter ( ) . convert ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testStringConverter_nullConversions ( ) { assertNull ( Longs . stringConverter ( ) . convert ( null ) ) ; assertNull ( Longs . stringConverter ( ) . reverse ( ) . convert ( null ) ) ; } public void testStringConverter_reverse ( ) { Converter < String , Long > converter = Longs . stringConverter ( ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <int> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <int> L ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( - <int> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <hex> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <hex> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( - <hex> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <oct> ) ) ; } @GwtIncompatible ( <str> ) public void testStringConverter_nullPointerTester ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( Longs . stringConverter ( ) ) ; } public void testTryParse ( ) { tryParseAndAssertEquals ( <int> L , <str> ) ; tryParseAndAssertEquals ( <int> L , <str> ) ; tryParseAndAssertEquals ( <int> , <str> ) ; tryParseAndAssertEquals ( - <int> , <str> ) ; tryParseAndAssertEquals ( <int> , <str> ) ; tryParseAndAssertEquals ( - <int> , <str> ) ; tryParseAndAssertEquals ( MAX_VALUE , Long . toString ( MAX_VALUE ) ) ; tryParseAndAssertEquals ( MIN_VALUE , Long . toString ( MIN_VALUE ) ) ; assertNull ( Longs . tryParse ( <str> ) ) ; assertNull ( Longs . tryParse ( <str> ) ) ; assertNull ( Longs . tryParse ( <str> ) ) ; assertNull ( Longs . tryParse ( <str> ) ) ; assertNull ( <str> , Longs . tryParse ( BigInteger . valueOf ( MAX_VALUE ) . add ( BigInteger . ONE ) . toString ( ) ) ) ; assertNull ( <str> , Longs . tryParse ( BigInteger . valueOf ( MAX_VALUE ) . multiply ( BigInteger . TEN ) . toString ( ) ) ) ; assertNull ( <str> , Longs . tryParse ( BigInteger . valueOf ( MIN_VALUE ) . subtract ( BigInteger . ONE ) . toString ( ) ) ) ; assertNull ( <str> , Longs . tryParse ( BigInteger . valueOf ( MIN_VALUE ) . multiply ( BigInteger . TEN ) . toString ( ) ) ) ; assertNull ( Longs . tryParse ( <str> ) ) ; } private static void tryParseAndAssertEquals ( Long expected , String value ) { assertEquals ( expected , Longs . tryParse ( value ) ) ; } public void testTryParse_radix ( ) { for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { radixEncodeParseAndAssertEquals ( ( long ) <int> , radix ) ; radixEncodeParseAndAssertEquals ( ( long ) <int> , radix ) ; radixEncodeParseAndAssertEquals ( ( long ) - <int> , radix ) ; radixEncodeParseAndAssertEquals ( MAX_VALUE , radix ) ; radixEncodeParseAndAssertEquals ( MIN_VALUE , radix ) ; assertNull ( <str> + radix , Longs . tryParse ( <str> , radix ) ) ; assertNull ( <str> + radix , Longs . tryParse ( BigInteger . valueOf ( MAX_VALUE ) . add ( BigInteger . ONE ) . toString ( ) , radix ) ) ; assertNull ( <str> + radix , Longs . tryParse ( BigInteger . valueOf ( MIN_VALUE ) . subtract ( BigInteger . ONE ) . toString ( ) , radix ) ) ; } assertNull ( <str> , Longs . tryParse ( <str> , <int> ) ) ; assertEquals ( <str> , <int> , Longs . tryParse ( <str> , <int> ) . longValue ( ) ) ; } private static void radixEncodeParseAndAssertEquals ( Long value , int radix ) { assertEquals ( <str> + radix , value , Longs . tryParse ( Long . toString ( value , radix ) , radix ) ) ; } @SuppressWarnings ( <str> ) public void testTryParse_radixTooBig ( ) { try { Longs . tryParse ( <str> , Character . MAX_RADIX + <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testTryParse_radixTooSmall ( ) { try { Longs . tryParse ( <str> , Character . MIN_RADIX - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } } 
