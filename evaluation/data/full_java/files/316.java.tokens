package org . apache . cassandra . db ; import java . io . File ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . locks . Lock ; import com . google . common . base . Function ; import com . google . common . collect . Iterables ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . config . * ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . db . commitlog . ReplayPosition ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . view . ViewManager ; import org . apache . cassandra . exceptions . WriteTimeoutException ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . index . transactions . UpdateTransaction ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . metrics . KeyspaceMetrics ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . concurrent . OpOrder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class Keyspace { private static final Logger logger = LoggerFactory . getLogger ( Keyspace . class ) ; private static final String TEST_FAIL_WRITES_KS = System . getProperty ( <str> , <str> ) ; private static final boolean TEST_FAIL_WRITES = ! TEST_FAIL_WRITES_KS . isEmpty ( ) ; public final KeyspaceMetrics metric ; static { if ( ! Config . isClientMode ( ) ) DatabaseDescriptor . createAllDirectories ( ) ; } private volatile KeyspaceMetadata metadata ; public static final OpOrder writeOrder = new OpOrder ( ) ; private final ConcurrentMap < UUID , ColumnFamilyStore > columnFamilyStores = new ConcurrentHashMap < > ( ) ; private volatile AbstractReplicationStrategy replicationStrategy ; public final ViewManager viewManager ; public static final Function < String , Keyspace > keyspaceTransformer = new Function < String , Keyspace > ( ) { public Keyspace apply ( String keyspaceName ) { return Keyspace . open ( keyspaceName ) ; } } ; private static volatile boolean initialized = false ; public static void setInitialized ( ) { initialized = true ; } public static Keyspace open ( String keyspaceName ) { assert initialized | | Schema . isSystemKeyspace ( keyspaceName ) ; return open ( keyspaceName , Schema . instance , true ) ; } public static Keyspace openWithoutSSTables ( String keyspaceName ) { return open ( keyspaceName , Schema . instance , false ) ; } private static Keyspace open ( String keyspaceName , Schema schema , boolean loadSSTables ) { Keyspace keyspaceInstance = schema . getKeyspaceInstance ( keyspaceName ) ; if ( keyspaceInstance = = null ) { synchronized ( Keyspace . class ) { keyspaceInstance = schema . getKeyspaceInstance ( keyspaceName ) ; if ( keyspaceInstance = = null ) { keyspaceInstance = new Keyspace ( keyspaceName , loadSSTables ) ; schema . storeKeyspaceInstance ( keyspaceInstance ) ; } } } return keyspaceInstance ; } public static Keyspace clear ( String keyspaceName ) { return clear ( keyspaceName , Schema . instance ) ; } public static Keyspace clear ( String keyspaceName , Schema schema ) { synchronized ( Keyspace . class ) { Keyspace t = schema . removeKeyspaceInstance ( keyspaceName ) ; if ( t ! = null ) { for ( ColumnFamilyStore cfs : t . getColumnFamilyStores ( ) ) t . unloadCf ( cfs ) ; t . metric . release ( ) ; } return t ; } } public static ColumnFamilyStore openAndGetStore ( CFMetaData cfm ) { return open ( cfm . ksName ) . getColumnFamilyStore ( cfm . cfId ) ; } public static void removeUnreadableSSTables ( File directory ) { for ( Keyspace keyspace : Keyspace . all ( ) ) { for ( ColumnFamilyStore baseCfs : keyspace . getColumnFamilyStores ( ) ) { for ( ColumnFamilyStore cfs : baseCfs . concatWithIndexes ( ) ) cfs . maybeRemoveUnreadableSSTables ( directory ) ; } } } public void setMetadata ( KeyspaceMetadata metadata ) { this . metadata = metadata ; createReplicationStrategy ( metadata ) ; } public KeyspaceMetadata getMetadata ( ) { return metadata ; } public Collection < ColumnFamilyStore > getColumnFamilyStores ( ) { return Collections . unmodifiableCollection ( columnFamilyStores . values ( ) ) ; } public ColumnFamilyStore getColumnFamilyStore ( String cfName ) { UUID id = Schema . instance . getId ( getName ( ) , cfName ) ; if ( id = = null ) throw new IllegalArgumentException ( String . format ( <str> , getName ( ) , cfName ) ) ; return getColumnFamilyStore ( id ) ; } public ColumnFamilyStore getColumnFamilyStore ( UUID id ) { ColumnFamilyStore cfs = columnFamilyStores . get ( id ) ; if ( cfs = = null ) throw new IllegalArgumentException ( <str> + id ) ; return cfs ; } public boolean hasColumnFamilyStore ( UUID id ) { return columnFamilyStores . containsKey ( id ) ; } public void snapshot ( String snapshotName , String columnFamilyName ) throws IOException { assert snapshotName ! = null ; boolean tookSnapShot = false ; for ( ColumnFamilyStore cfStore : columnFamilyStores . values ( ) ) { if ( columnFamilyName = = null | | cfStore . name . equals ( columnFamilyName ) ) { tookSnapShot = true ; cfStore . snapshot ( snapshotName ) ; } } if ( ( columnFamilyName ! = null ) & & ! tookSnapShot ) throw new IOException ( <str> + columnFamilyName + <str> ) ; } public static String getTimestampedSnapshotName ( String clientSuppliedName ) { String snapshotName = Long . toString ( System . currentTimeMillis ( ) ) ; if ( clientSuppliedName ! = null & & ! clientSuppliedName . equals ( <str> ) ) { snapshotName = snapshotName + <str> + clientSuppliedName ; } return snapshotName ; } public boolean snapshotExists ( String snapshotName ) { assert snapshotName ! = null ; for ( ColumnFamilyStore cfStore : columnFamilyStores . values ( ) ) { if ( cfStore . snapshotExists ( snapshotName ) ) return true ; } return false ; } public static void clearSnapshot ( String snapshotName , String keyspace ) { List < File > snapshotDirs = Directories . getKSChildDirectories ( keyspace ) ; Directories . clearSnapshot ( snapshotName , snapshotDirs ) ; } public List < SSTableReader > getAllSSTables ( SSTableSet sstableSet ) { List < SSTableReader > list = new ArrayList < > ( columnFamilyStores . size ( ) ) ; for ( ColumnFamilyStore cfStore : columnFamilyStores . values ( ) ) Iterables . addAll ( list , cfStore . getSSTables ( sstableSet ) ) ; return list ; } private Keyspace ( String keyspaceName , boolean loadSSTables ) { metadata = Schema . instance . getKSMetaData ( keyspaceName ) ; assert metadata ! = null : <str> + keyspaceName ; createReplicationStrategy ( metadata ) ; this . metric = new KeyspaceMetrics ( this ) ; this . viewManager = new ViewManager ( this ) ; for ( CFMetaData cfm : metadata . tablesAndViews ( ) ) { logger . trace ( <str> , getName ( ) , cfm . cfName ) ; initCf ( cfm , loadSSTables ) ; } this . viewManager . reload ( ) ; } private Keyspace ( KeyspaceMetadata metadata ) { this . metadata = metadata ; createReplicationStrategy ( metadata ) ; this . metric = new KeyspaceMetrics ( this ) ; this . viewManager = new ViewManager ( this ) ; } public static Keyspace mockKS ( KeyspaceMetadata metadata ) { return new Keyspace ( metadata ) ; } private void createReplicationStrategy ( KeyspaceMetadata ksm ) { replicationStrategy = AbstractReplicationStrategy . createReplicationStrategy ( ksm . name , ksm . params . replication . klass , StorageService . instance . getTokenMetadata ( ) , DatabaseDescriptor . getEndpointSnitch ( ) , ksm . params . replication . options ) ; } public void dropCf ( UUID cfId ) { assert columnFamilyStores . containsKey ( cfId ) ; ColumnFamilyStore cfs = columnFamilyStores . remove ( cfId ) ; if ( cfs = = null ) return ; cfs . getCompactionStrategyManager ( ) . shutdown ( ) ; CompactionManager . instance . interruptCompactionForCFs ( cfs . concatWithIndexes ( ) , true ) ; cfs . keyspace . writeOrder . awaitNewBarrier ( ) ; cfs . readOrdering . awaitNewBarrier ( ) ; unloadCf ( cfs ) ; } private void unloadCf ( ColumnFamilyStore cfs ) { cfs . forceBlockingFlush ( ) ; cfs . invalidate ( ) ; } public void initCf ( CFMetaData metadata , boolean loadSSTables ) { ColumnFamilyStore cfs = columnFamilyStores . get ( metadata . cfId ) ; if ( cfs = = null ) { ColumnFamilyStore oldCfs = columnFamilyStores . putIfAbsent ( metadata . cfId , ColumnFamilyStore . createColumnFamilyStore ( this , metadata , loadSSTables ) ) ; if ( oldCfs ! = null ) throw new IllegalStateException ( <str> + metadata . cfId ) ; } else { assert cfs . name . equals ( metadata . cfName ) ; cfs . reload ( ) ; } } public void apply ( Mutation mutation , boolean writeCommitLog ) { apply ( mutation , writeCommitLog , true , false ) ; } public void apply ( Mutation mutation , boolean writeCommitLog , boolean updateIndexes ) { apply ( mutation , writeCommitLog , updateIndexes , false ) ; } public void applyFromCommitLog ( Mutation mutation ) { apply ( mutation , false , true , true ) ; } public void apply ( final Mutation mutation , final boolean writeCommitLog , boolean updateIndexes , boolean isClReplay ) { if ( TEST_FAIL_WRITES & & metadata . name . equals ( TEST_FAIL_WRITES_KS ) ) throw new RuntimeException ( <str> ) ; Lock lock = null ; boolean requiresViewUpdate = updateIndexes & & viewManager . updatesAffectView ( Collections . singleton ( mutation ) , false ) ; if ( requiresViewUpdate ) { mutation . viewLockAcquireStart . compareAndSet ( <int> L , System . currentTimeMillis ( ) ) ; lock = ViewManager . acquireLockFor ( mutation . key ( ) . getKey ( ) ) ; if ( lock = = null ) { if ( ( System . currentTimeMillis ( ) - mutation . createdAt ) > DatabaseDescriptor . getWriteRpcTimeout ( ) ) { logger . trace ( <str> , ByteBufferUtil . bytesToHex ( mutation . key ( ) . getKey ( ) ) ) ; Tracing . trace ( <str> ) ; throw new WriteTimeoutException ( WriteType . VIEW , ConsistencyLevel . LOCAL_ONE , <int> , <int> ) ; } else { StageManager . getStage ( Stage . MUTATION ) . execute ( ( ) - > { if ( writeCommitLog ) mutation . apply ( ) ; else mutation . applyUnsafe ( ) ; } ) ; return ; } } else { long acquireTime = System . currentTimeMillis ( ) - mutation . viewLockAcquireStart . get ( ) ; if ( ! isClReplay ) { for ( UUID cfid : mutation . getColumnFamilyIds ( ) ) { columnFamilyStores . get ( cfid ) . metric . viewLockAcquireTime . update ( acquireTime , TimeUnit . MILLISECONDS ) ; } } } } int nowInSec = FBUtilities . nowInSeconds ( ) ; try ( OpOrder . Group opGroup = writeOrder . start ( ) ) { ReplayPosition replayPosition = null ; if ( writeCommitLog ) { Tracing . trace ( <str> ) ; replayPosition = CommitLog . instance . add ( mutation ) ; } for ( PartitionUpdate upd : mutation . getPartitionUpdates ( ) ) { ColumnFamilyStore cfs = columnFamilyStores . get ( upd . metadata ( ) . cfId ) ; if ( cfs = = null ) { logger . error ( <str> , upd . metadata ( ) . cfId , upd . metadata ( ) . ksName , upd . metadata ( ) . cfName ) ; continue ; } AtomicLong baseComplete = new AtomicLong ( Long . MAX_VALUE ) ; if ( requiresViewUpdate ) { try { Tracing . trace ( <str> ) ; viewManager . pushViewReplicaUpdates ( upd , ! isClReplay , baseComplete ) ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; logger . error ( String . format ( <str> , upd . metadata ( ) . ksName , upd . metadata ( ) . cfName ) , t ) ; throw t ; } } Tracing . trace ( <str> , upd . metadata ( ) . cfName ) ; UpdateTransaction indexTransaction = updateIndexes ? cfs . indexManager . newUpdateTransaction ( upd , opGroup , nowInSec ) : UpdateTransaction . NO_OP ; cfs . apply ( upd , indexTransaction , opGroup , replayPosition ) ; if ( requiresViewUpdate ) baseComplete . set ( System . currentTimeMillis ( ) ) ; } } finally { if ( lock ! = null ) lock . unlock ( ) ; } } public AbstractReplicationStrategy getReplicationStrategy ( ) { return replicationStrategy ; } public static void indexPartition ( DecoratedKey key , ColumnFamilyStore cfs , Set < Index > indexes ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , cfs . metadata . getKeyValidator ( ) . getString ( key . getKey ( ) ) ) ; SinglePartitionReadCommand cmd = SinglePartitionReadCommand . fullPartitionRead ( cfs . metadata , FBUtilities . nowInSeconds ( ) , key ) ; try ( OpOrder . Group opGroup = cfs . keyspace . writeOrder . start ( ) ; UnfilteredRowIterator partition = cmd . queryMemtableAndDisk ( cfs , opGroup ) ) { cfs . indexManager . indexPartition ( partition , opGroup , indexes , cmd . nowInSec ( ) ) ; } } public List < Future < ? > > flush ( ) { List < Future < ? > > futures = new ArrayList < > ( columnFamilyStores . size ( ) ) ; for ( ColumnFamilyStore cfs : columnFamilyStores . values ( ) ) futures . add ( cfs . forceFlush ( ) ) ; return futures ; } public Iterable < ColumnFamilyStore > getValidColumnFamilies ( boolean allowIndexes , boolean autoAddIndexes , String . . . cfNames ) throws IOException { Set < ColumnFamilyStore > valid = new HashSet < > ( ) ; if ( cfNames . length = = <int> ) { for ( ColumnFamilyStore cfStore : getColumnFamilyStores ( ) ) { valid . add ( cfStore ) ; if ( autoAddIndexes ) valid . addAll ( getIndexColumnFamilyStores ( cfStore ) ) ; } return valid ; } for ( String cfName : cfNames ) { if ( SecondaryIndexManager . isIndexColumnFamily ( cfName ) ) { if ( ! allowIndexes ) { logger . warn ( <str> , cfName ) ; continue ; } String baseName = SecondaryIndexManager . getParentCfsName ( cfName ) ; String indexName = SecondaryIndexManager . getIndexName ( cfName ) ; ColumnFamilyStore baseCfs = getColumnFamilyStore ( baseName ) ; Index index = baseCfs . indexManager . getIndexByName ( indexName ) ; if ( index = = null ) throw new IllegalArgumentException ( String . format ( <str> , baseCfs . metadata . cfName , indexName ) ) ; if ( index . getBackingTable ( ) . isPresent ( ) ) valid . add ( index . getBackingTable ( ) . get ( ) ) ; } else { ColumnFamilyStore cfStore = getColumnFamilyStore ( cfName ) ; valid . add ( cfStore ) ; if ( autoAddIndexes ) valid . addAll ( getIndexColumnFamilyStores ( cfStore ) ) ; } } return valid ; } private Set < ColumnFamilyStore > getIndexColumnFamilyStores ( ColumnFamilyStore baseCfs ) { Set < ColumnFamilyStore > stores = new HashSet < > ( ) ; for ( ColumnFamilyStore indexCfs : baseCfs . indexManager . getAllIndexColumnFamilyStores ( ) ) { logger . info ( <str> , indexCfs . metadata . cfName ) ; stores . add ( indexCfs ) ; } return stores ; } public static Iterable < Keyspace > all ( ) { return Iterables . transform ( Schema . instance . getKeyspaces ( ) , keyspaceTransformer ) ; } public static Iterable < Keyspace > nonSystem ( ) { return Iterables . transform ( Schema . instance . getNonSystemKeyspaces ( ) , keyspaceTransformer ) ; } public static Iterable < Keyspace > system ( ) { return Iterables . transform ( Schema . SYSTEM_KEYSPACE_NAMES , keyspaceTransformer ) ; } @Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + <str> + getName ( ) + <str> ; } public String getName ( ) { return metadata . name ; } } 
