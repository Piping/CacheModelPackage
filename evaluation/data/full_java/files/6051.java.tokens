package org . elasticsearch . common . settings . loader ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class XContentSettingsLoader implements SettingsLoader { public abstract XContentType contentType ( ) ; @Override public Map < String , String > load ( String source ) throws IOException { try ( XContentParser parser = XContentFactory . xContent ( contentType ( ) ) . createParser ( source ) ) { return load ( parser ) ; } } @Override public Map < String , String > load ( byte [ ] source ) throws IOException { try ( XContentParser parser = XContentFactory . xContent ( contentType ( ) ) . createParser ( source ) ) { return load ( parser ) ; } } public Map < String , String > load ( XContentParser jp ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; Map < String , String > settings = new HashMap < > ( ) ; List < String > path = new ArrayList < > ( ) ; XContentParser . Token token = jp . nextToken ( ) ; if ( token = = null ) { return settings ; } if ( token ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> , token ) ; } serializeObject ( settings , sb , path , jp , null ) ; XContentParser . Token lastToken = null ; try { while ( ! jp . isClosed ( ) & & ( lastToken = jp . nextToken ( ) ) = = null ) ; } catch ( Exception e ) { throw new ElasticsearchParseException ( <str> , e , jp . getTokenLocation ( ) . lineNumber , jp . getTokenLocation ( ) . columnNumber ) ; } if ( lastToken ! = null ) { throw new ElasticsearchParseException ( <str> , jp . getTokenLocation ( ) . lineNumber , jp . getTokenLocation ( ) . columnNumber ) ; } return settings ; } private void serializeObject ( Map < String , String > settings , StringBuilder sb , List < String > path , XContentParser parser , String objFieldName ) throws IOException { if ( objFieldName ! = null ) { path . add ( objFieldName ) ; } String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . START_OBJECT ) { serializeObject ( settings , sb , path , parser , currentFieldName ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { serializeArray ( settings , sb , path , parser , currentFieldName ) ; } else if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NULL ) { } else { serializeValue ( settings , sb , path , parser , currentFieldName ) ; } } if ( objFieldName ! = null ) { path . remove ( path . size ( ) - <int> ) ; } } private void serializeArray ( Map < String , String > settings , StringBuilder sb , List < String > path , XContentParser parser , String fieldName ) throws IOException { XContentParser . Token token ; int counter = <int> ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . START_OBJECT ) { serializeObject ( settings , sb , path , parser , fieldName + <str> + ( counter + + ) ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { serializeArray ( settings , sb , path , parser , fieldName + <str> + ( counter + + ) ) ; } else if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NULL ) { } else { serializeValue ( settings , sb , path , parser , fieldName + <str> + ( counter + + ) ) ; } } } private void serializeValue ( Map < String , String > settings , StringBuilder sb , List < String > path , XContentParser parser , String fieldName ) throws IOException { sb . setLength ( <int> ) ; for ( String pathEle : path ) { sb . append ( pathEle ) . append ( <str> ) ; } sb . append ( fieldName ) ; String key = sb . toString ( ) ; String currentValue = parser . text ( ) ; String previousValue = settings . put ( key , currentValue ) ; if ( previousValue ! = null ) { throw new ElasticsearchParseException ( <str> , key , parser . getTokenLocation ( ) . lineNumber , parser . getTokenLocation ( ) . columnNumber , previousValue , currentValue ) ; } } } 
