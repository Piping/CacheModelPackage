package com . google . common . io ; import com . google . common . collect . Lists ; import java . io . ByteArrayInputStream ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Collections ; import java . util . List ; public class MultiInputStreamTest extends IoTestCase { public void testJoin ( ) throws Exception { joinHelper ( <int> ) ; joinHelper ( <int> ) ; joinHelper ( <int> , <int> , <int> ) ; joinHelper ( <int> , <int> ) ; joinHelper ( <int> , <int> , <int> ) ; joinHelper ( <int> , <int> , <int> ) ; joinHelper ( <int> , <int> , <int> ) ; joinHelper ( <int> , <int> , <int> ) ; joinHelper ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; joinHelper ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testOnlyOneOpen ( ) throws Exception { final ByteSource source = newByteSource ( <int> , <int> ) ; final int [ ] counter = new int [ <int> ] ; ByteSource checker = new ByteSource ( ) { @Override public InputStream openStream ( ) throws IOException { if ( counter [ <int> ] + + ! = <int> ) { throw new IllegalStateException ( <str> ) ; } return new FilterInputStream ( source . openStream ( ) ) { @Override public void close ( ) throws IOException { super . close ( ) ; counter [ <int> ] - - ; } } ; } } ; byte [ ] result = ByteSource . concat ( checker , checker , checker ) . read ( ) ; assertEquals ( <int> , result . length ) ; } private void joinHelper ( Integer . . . spans ) throws Exception { List < ByteSource > sources = Lists . newArrayList ( ) ; int start = <int> ; for ( Integer span : spans ) { sources . add ( newByteSource ( start , span ) ) ; start + = span ; } ByteSource joined = ByteSource . concat ( sources ) ; assertTrue ( newByteSource ( <int> , start ) . contentEquals ( joined ) ) ; } public void testReadSingleByte ( ) throws Exception { ByteSource source = newByteSource ( <int> , <int> ) ; ByteSource joined = ByteSource . concat ( source , source ) ; assertEquals ( <int> , joined . size ( ) ) ; InputStream in = joined . openStream ( ) ; assertFalse ( in . markSupported ( ) ) ; assertEquals ( <int> , in . available ( ) ) ; int total = <int> ; while ( in . read ( ) ! = - <int> ) { total + + ; } assertEquals ( <int> , in . available ( ) ) ; assertEquals ( <int> , total ) ; } public void testSkip ( ) throws Exception { MultiInputStream multi = new MultiInputStream ( Collections . singleton ( new ByteSource ( ) { @Override public InputStream openStream ( ) { return new ByteArrayInputStream ( newPreFilledByteArray ( <int> , <int> ) ) { @Override public long skip ( long n ) { return <int> ; } } ; } } ) . iterator ( ) ) ; multi . skip ( - <int> ) ; multi . skip ( - <int> ) ; multi . skip ( <int> ) ; ByteStreams . skipFully ( multi , <int> ) ; assertEquals ( <int> , multi . read ( ) ) ; } private static ByteSource newByteSource ( final int start , final int size ) { return new ByteSource ( ) { @Override public InputStream openStream ( ) { return new ByteArrayInputStream ( newPreFilledByteArray ( start , size ) ) ; } } ; } } 
