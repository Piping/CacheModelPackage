package org . gradle . platform . base . binary ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . DomainObjectSet ; import org . gradle . api . Incubating ; import org . gradle . api . Nullable ; import org . gradle . api . artifacts . component . LibraryBinaryIdentifier ; import org . gradle . api . internal . AbstractBuildableModelElement ; import org . gradle . api . internal . DefaultDomainObjectSet ; import org . gradle . api . internal . project . taskfactory . ITaskFactory ; import org . gradle . internal . component . local . model . DefaultLibraryBinaryIdentifier ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . reflect . ObjectInstantiationException ; import org . gradle . language . base . LanguageSourceSet ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . core . ModelMaps ; import org . gradle . model . internal . core . MutableModelNode ; import org . gradle . model . internal . type . ModelType ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . BinaryTasksCollection ; import org . gradle . platform . base . ComponentSpec ; import org . gradle . platform . base . ModelInstantiationException ; import org . gradle . platform . base . internal . * ; import org . gradle . util . DeprecationLogger ; import java . io . File ; import java . util . Set ; @Incubating @SuppressWarnings ( <str> ) public class BaseBinarySpec extends AbstractBuildableModelElement implements BinarySpecInternal { private final DomainObjectSet < LanguageSourceSet > inputSourceSets = new DefaultDomainObjectSet < LanguageSourceSet > ( LanguageSourceSet . class ) ; private static ThreadLocal < BinaryInfo > nextBinaryInfo = new ThreadLocal < BinaryInfo > ( ) ; private final BinaryTasksCollection tasks ; private final String name ; private final MutableModelNode modelNode ; private final MutableModelNode componentNode ; private final MutableModelNode sources ; private final Class < ? extends BinarySpec > publicType ; private BinaryNamingScheme namingScheme ; private boolean disabled ; public static < T extends BaseBinarySpec > T create ( Class < ? extends BinarySpec > publicType , Class < T > implementationType , String name , MutableModelNode modelNode , @Nullable MutableModelNode componentNode , Instantiator instantiator , ITaskFactory taskFactory ) { nextBinaryInfo . set ( new BinaryInfo ( name , publicType , implementationType , modelNode , componentNode , taskFactory , instantiator ) ) ; try { try { return DirectInstantiator . INSTANCE . newInstance ( implementationType ) ; } catch ( ObjectInstantiationException e ) { throw new ModelInstantiationException ( String . format ( <str> , publicType . getSimpleName ( ) ) , e . getCause ( ) ) ; } } finally { nextBinaryInfo . set ( null ) ; } } public BaseBinarySpec ( ) { this ( nextBinaryInfo . get ( ) ) ; } private BaseBinarySpec ( BinaryInfo info ) { if ( info = = null ) { throw new ModelInstantiationException ( <str> ) ; } this . name = info . name ; this . publicType = info . publicType ; this . modelNode = info . modelNode ; this . componentNode = info . componentNode ; this . tasks = info . instantiator . newInstance ( DefaultBinaryTasksCollection . class , this , info . taskFactory ) ; sources = ModelMaps . addModelMapNode ( modelNode , LanguageSourceSet . class , <str> ) ; ComponentSpec component = getComponent ( ) ; namingScheme = DefaultBinaryNamingScheme . component ( component = = null ? null : component . getName ( ) ) . withBinaryName ( name ) . withBinaryType ( getTypeName ( ) ) ; } @Override public LibraryBinaryIdentifier getId ( ) { ComponentSpec component = getComponent ( ) ; return new DefaultLibraryBinaryIdentifier ( component . getProjectPath ( ) , component . getName ( ) , getName ( ) ) ; } @Override public Class < ? extends BinarySpec > getPublicType ( ) { return publicType ; } @Nullable public ComponentSpec getComponent ( ) { return getComponentAs ( ComponentSpec . class ) ; } @Nullable protected < T extends ComponentSpec > T getComponentAs ( Class < T > componentType ) { if ( componentNode ! = null & & componentNode . canBeViewedAs ( ModelType . of ( componentType ) ) ) { return componentNode . asImmutable ( ModelType . of ( componentType ) , componentNode . getDescriptor ( ) ) . getInstance ( ) ; } return null ; } protected String getTypeName ( ) { return publicType . getSimpleName ( ) ; } @Override public String getProjectScopedName ( ) { ComponentSpec owner = getComponent ( ) ; return owner = = null ? name : owner . getName ( ) + StringUtils . capitalize ( name ) ; } public String getDisplayName ( ) { ComponentSpec owner = getComponent ( ) ; if ( owner = = null ) { return String . format ( <str> , getTypeName ( ) , name ) ; } else { return String . format ( <str> , getTypeName ( ) , owner . getName ( ) , name ) ; } } public String getName ( ) { return name ; } @Override public void setBuildable ( boolean buildable ) { this . disabled = ! buildable ; } public final boolean isBuildable ( ) { return getBuildAbility ( ) . isBuildable ( ) ; } @Override public DomainObjectSet < LanguageSourceSet > getSource ( ) { DeprecationLogger . nagUserOfReplacedProperty ( <str> , <str> ) ; return getInputs ( ) ; } @Override public DomainObjectSet < LanguageSourceSet > getInputs ( ) { return inputSourceSets ; } @Override public ModelMap < LanguageSourceSet > getSources ( ) { return ModelMaps . asMutableView ( sources , LanguageSourceSet . class , modelNode . toString ( ) + <str> ) ; } public BinaryTasksCollection getTasks ( ) { return tasks ; } public boolean isLegacyBinary ( ) { return false ; } public BinaryNamingScheme getNamingScheme ( ) { return namingScheme ; } public void setNamingScheme ( BinaryNamingScheme namingScheme ) { this . namingScheme = namingScheme ; } @Override public boolean hasCodependentSources ( ) { return false ; } private static class BinaryInfo { private final String name ; private final Class < ? extends BinarySpec > publicType ; private final MutableModelNode modelNode ; private final MutableModelNode componentNode ; private final ITaskFactory taskFactory ; private final Instantiator instantiator ; private BinaryInfo ( String name , Class < ? extends BinarySpec > publicType , Class < ? extends BaseBinarySpec > implementationType , MutableModelNode modelNode , MutableModelNode componentNode , ITaskFactory taskFactory , Instantiator instantiator ) { this . name = name ; this . publicType = publicType ; this . modelNode = modelNode ; this . componentNode = componentNode ; this . taskFactory = taskFactory ; this . instantiator = instantiator ; } } @Override public String toString ( ) { return getDisplayName ( ) ; } @Override public final BinaryBuildAbility getBuildAbility ( ) { if ( disabled ) { return new FixedBuildAbility ( false ) ; } return getBinaryBuildAbility ( ) ; } protected BinaryBuildAbility getBinaryBuildAbility ( ) { return new FixedBuildAbility ( true ) ; } public static void replaceSingleDirectory ( Set < File > dirs , File dir ) { switch ( dirs . size ( ) ) { case <int> : dirs . add ( dir ) ; break ; case <int> : dirs . clear ( ) ; dirs . add ( dir ) ; break ; default : throw new IllegalStateException ( <str> ) ; } } } 
