package org . gradle . model . internal . inspect ; import net . jcip . annotations . ThreadSafe ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . Model ; import org . gradle . model . internal . core . * ; @ThreadSafe public abstract class AbstractModelCreationRuleExtractor extends AbstractAnnotationDrivenModelRuleExtractor < Model > { protected ModelPath determineModelName ( MethodRuleDefinition < ? , ? > ruleDefinition ) { String annotationValue = ruleDefinition . getAnnotation ( Model . class ) . value ( ) ; String modelName = ( annotationValue = = null | | annotationValue . isEmpty ( ) ) ? ruleDefinition . getMethodName ( ) : annotationValue ; try { return ModelPath . validatedPath ( modelName ) ; } catch ( Exception e ) { throw new InvalidModelRuleDeclarationException ( String . format ( <str> , ruleDefinition . getDescriptor ( ) ) , e ) ; } } @Override public < R , S > ExtractedModelRule registration ( MethodRuleDefinition < R , S > ruleDefinition , ValidationProblemCollector problems ) { ModelPath modelPath = determineModelName ( ruleDefinition ) ; ModelRegistrations . Builder registration = ModelRegistrations . of ( modelPath ) . descriptor ( ruleDefinition . getDescriptor ( ) ) ; buildRegistration ( ruleDefinition , modelPath , registration ) ; registration . hidden ( ruleDefinition . isAnnotationPresent ( Hidden . class ) ) ; return new ExtractedModelRegistration ( registration . build ( ) ) ; } protected abstract < R , S > void buildRegistration ( MethodRuleDefinition < R , S > ruleDefinition , ModelPath modelPath , ModelRegistrations . Builder registration ) ; } 
