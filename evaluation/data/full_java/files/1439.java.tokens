package org . apache . cassandra . db ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import com . google . common . collect . ImmutableList ; import com . google . common . util . concurrent . Uninterruptibles ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . cache . KeyCacheKey ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . utils . concurrent . Refs ; import static org . junit . Assert . assertEquals ; public class KeyCacheTest { private static final String KEYSPACE1 = <str> ; private static final String COLUMN_FAMILY1 = <str> ; private static final String COLUMN_FAMILY2 = <str> ; private static final String COLUMN_FAMILY3 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , COLUMN_FAMILY1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , COLUMN_FAMILY2 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , COLUMN_FAMILY3 ) ) ; } @AfterClass public static void cleanup ( ) { SchemaLoader . cleanupSavedCaches ( ) ; } @Test public void testKeyCacheLoad ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; ColumnFamilyStore store = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COLUMN_FAMILY2 ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY2 ) ; SchemaLoader . insertData ( KEYSPACE1 , COLUMN_FAMILY2 , <int> , <int> ) ; store . forceBlockingFlush ( ) ; readData ( KEYSPACE1 , COLUMN_FAMILY2 , <int> , <int> ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY2 ) ; Map < KeyCacheKey , RowIndexEntry > savedMap = new HashMap < KeyCacheKey , RowIndexEntry > ( ) ; for ( Iterator < KeyCacheKey > iter = CacheService . instance . keyCache . keyIterator ( ) ; iter . hasNext ( ) ; ) { KeyCacheKey k = iter . next ( ) ; if ( k . desc . ksname . equals ( KEYSPACE1 ) & & k . desc . cfname . equals ( COLUMN_FAMILY2 ) ) savedMap . put ( k , CacheService . instance . keyCache . get ( k ) ) ; } CacheService . instance . keyCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY2 ) ; CacheService . instance . keyCache . loadSaved ( ) ; assertKeyCacheSize ( savedMap . size ( ) , KEYSPACE1 , COLUMN_FAMILY2 ) ; for ( Map . Entry < KeyCacheKey , RowIndexEntry > entry : savedMap . entrySet ( ) ) { RowIndexEntry expected = entry . getValue ( ) ; RowIndexEntry actual = CacheService . instance . keyCache . get ( entry . getKey ( ) ) ; assertEquals ( expected . position , actual . position ) ; assertEquals ( expected . columnsIndex ( ) , actual . columnsIndex ( ) ) ; if ( expected . isIndexed ( ) ) { assertEquals ( expected . deletionTime ( ) , actual . deletionTime ( ) ) ; } } } @Test public void testKeyCacheLoadWithLostTable ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; ColumnFamilyStore store = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COLUMN_FAMILY3 ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; SchemaLoader . insertData ( KEYSPACE1 , COLUMN_FAMILY3 , <int> , <int> ) ; store . forceBlockingFlush ( ) ; Collection < SSTableReader > firstFlushTables = ImmutableList . copyOf ( store . getLiveSSTables ( ) ) ; readData ( KEYSPACE1 , COLUMN_FAMILY3 , <int> , <int> ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; SchemaLoader . insertData ( KEYSPACE1 , COLUMN_FAMILY3 , <int> , <int> ) ; store . forceBlockingFlush ( ) ; readData ( KEYSPACE1 , COLUMN_FAMILY3 , <int> , <int> ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; CacheService . instance . keyCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; CacheService . instance . keyCache . loadSaved ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; store . markObsolete ( firstFlushTables , OperationType . UNKNOWN ) ; CacheService . instance . keyCache . loadSaved ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY3 ) ; } @Test public void testKeyCache ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COLUMN_FAMILY1 ) ; CacheService . instance . invalidateKeyCache ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY1 ) ; Mutation rm ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Util . getAll ( Util . cmd ( cfs , <str> ) . build ( ) ) ; Util . getAll ( Util . cmd ( cfs , <str> ) . build ( ) ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY1 ) ; Set < SSTableReader > readers = cfs . getLiveSSTables ( ) ; Refs < SSTableReader > refs = Refs . tryRef ( readers ) ; if ( refs = = null ) throw new IllegalStateException ( ) ; Util . compactAll ( cfs , Integer . MAX_VALUE ) . get ( ) ; boolean noEarlyOpen = DatabaseDescriptor . getSSTablePreempiveOpenIntervalInMB ( ) < <int> ; assertKeyCacheSize ( noEarlyOpen ? <int> : <int> , KEYSPACE1 , COLUMN_FAMILY1 ) ; refs . release ( ) ; LifecycleTransaction . waitForDeletions ( ) ; assertKeyCacheSize ( <int> , KEYSPACE1 , COLUMN_FAMILY1 ) ; Util . getAll ( Util . cmd ( cfs , <str> ) . build ( ) ) ; Util . getAll ( Util . cmd ( cfs , <str> ) . build ( ) ) ; assertKeyCacheSize ( noEarlyOpen ? <int> : <int> , KEYSPACE1 , COLUMN_FAMILY1 ) ; } private static void readData ( String keyspace , String columnFamily , int startRow , int numberOfRows ) { ColumnFamilyStore store = Keyspace . open ( keyspace ) . getColumnFamilyStore ( columnFamily ) ; for ( int i = <int> ; i < numberOfRows ; i + + ) Util . getAll ( Util . cmd ( store , <str> + ( i + startRow ) ) . includeRow ( <str> + ( i + startRow ) ) . build ( ) ) ; } private void assertKeyCacheSize ( int expected , String keyspace , String columnFamily ) { int size = <int> ; for ( Iterator < KeyCacheKey > iter = CacheService . instance . keyCache . keyIterator ( ) ; iter . hasNext ( ) ; ) { KeyCacheKey k = iter . next ( ) ; if ( k . desc . ksname . equals ( keyspace ) & & k . desc . cfname . equals ( columnFamily ) ) size + + ; } assertEquals ( expected , size ) ; } } 
