package org . apache . cassandra . transport ; import java . io . IOException ; import io . netty . buffer . ByteBuf ; import org . xerial . snappy . Snappy ; import org . xerial . snappy . SnappyError ; import net . jpountz . lz4 . LZ4Factory ; import org . apache . cassandra . utils . JVMStabilityInspector ; public interface FrameCompressor { public Frame compress ( Frame frame ) throws IOException ; public Frame decompress ( Frame frame ) throws IOException ; public static class SnappyCompressor implements FrameCompressor { public static final SnappyCompressor instance ; static { SnappyCompressor i ; try { i = new SnappyCompressor ( ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; i = null ; } catch ( NoClassDefFoundError | SnappyError | UnsatisfiedLinkError e ) { i = null ; } instance = i ; } private SnappyCompressor ( ) { Snappy . getNativeLibraryVersion ( ) ; } public Frame compress ( Frame frame ) throws IOException { byte [ ] input = CBUtil . readRawBytes ( frame . body ) ; ByteBuf output = CBUtil . allocator . heapBuffer ( Snappy . maxCompressedLength ( input . length ) ) ; try { int written = Snappy . compress ( input , <int> , input . length , output . array ( ) , output . arrayOffset ( ) ) ; output . writerIndex ( written ) ; } catch ( final Throwable e ) { output . release ( ) ; throw e ; } finally { frame . release ( ) ; } return frame . with ( output ) ; } public Frame decompress ( Frame frame ) throws IOException { byte [ ] input = CBUtil . readRawBytes ( frame . body ) ; if ( ! Snappy . isValidCompressedBuffer ( input , <int> , input . length ) ) throw new ProtocolException ( <str> ) ; ByteBuf output = CBUtil . allocator . heapBuffer ( Snappy . uncompressedLength ( input ) ) ; try { int size = Snappy . uncompress ( input , <int> , input . length , output . array ( ) , output . arrayOffset ( ) ) ; output . writerIndex ( size ) ; } catch ( final Throwable e ) { output . release ( ) ; throw e ; } finally { frame . release ( ) ; } return frame . with ( output ) ; } } public static class LZ4Compressor implements FrameCompressor { public static final LZ4Compressor instance = new LZ4Compressor ( ) ; private static final int INTEGER_BYTES = <int> ; private final net . jpountz . lz4 . LZ4Compressor compressor ; private final net . jpountz . lz4 . LZ4Decompressor decompressor ; private LZ4Compressor ( ) { final LZ4Factory lz4Factory = LZ4Factory . fastestInstance ( ) ; compressor = lz4Factory . fastCompressor ( ) ; decompressor = lz4Factory . decompressor ( ) ; } public Frame compress ( Frame frame ) throws IOException { byte [ ] input = CBUtil . readRawBytes ( frame . body ) ; int maxCompressedLength = compressor . maxCompressedLength ( input . length ) ; ByteBuf outputBuf = CBUtil . allocator . heapBuffer ( INTEGER_BYTES + maxCompressedLength ) ; byte [ ] output = outputBuf . array ( ) ; int outputOffset = outputBuf . arrayOffset ( ) ; output [ outputOffset + <int> ] = ( byte ) ( input . length > > > <int> ) ; output [ outputOffset + <int> ] = ( byte ) ( input . length > > > <int> ) ; output [ outputOffset + <int> ] = ( byte ) ( input . length > > > <int> ) ; output [ outputOffset + <int> ] = ( byte ) ( input . length ) ; try { int written = compressor . compress ( input , <int> , input . length , output , outputOffset + INTEGER_BYTES , maxCompressedLength ) ; outputBuf . writerIndex ( INTEGER_BYTES + written ) ; return frame . with ( outputBuf ) ; } catch ( final Throwable e ) { outputBuf . release ( ) ; throw e ; } finally { frame . release ( ) ; } } public Frame decompress ( Frame frame ) throws IOException { byte [ ] input = CBUtil . readRawBytes ( frame . body ) ; int uncompressedLength = ( ( input [ <int> ] & <hex> ) < < <int> ) | ( ( input [ <int> ] & <hex> ) < < <int> ) | ( ( input [ <int> ] & <hex> ) < < <int> ) | ( ( input [ <int> ] & <hex> ) ) ; ByteBuf output = CBUtil . allocator . heapBuffer ( uncompressedLength ) ; try { int read = decompressor . decompress ( input , INTEGER_BYTES , output . array ( ) , output . arrayOffset ( ) , uncompressedLength ) ; if ( read ! = input . length - INTEGER_BYTES ) throw new IOException ( <str> ) ; output . writerIndex ( uncompressedLength ) ; return frame . with ( output ) ; } catch ( final Throwable e ) { output . release ( ) ; throw e ; } finally { frame . release ( ) ; } } } } 
