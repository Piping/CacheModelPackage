package org . gradle . model . internal . manage . schema . extract ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import org . gradle . internal . Cast ; import org . gradle . model . internal . asm . AsmClassGeneratorUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . Proxy ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public class PropertyAccessorExtractionContext { private final Collection < Method > declaringMethods ; private final Method mostSpecificDeclaration ; private final String mostSpecificSignature ; private final boolean declaredInManagedType ; private final boolean declaredAsAbstract ; private final Map < Class < ? extends Annotation > , Annotation > annotations ; public PropertyAccessorExtractionContext ( Iterable < Method > declaringMethods ) { Method mostSpecificDeclaration = ModelSchemaUtils . findMostSpecificMethod ( declaringMethods ) ; this . declaringMethods = ImmutableList . copyOf ( declaringMethods ) ; this . mostSpecificDeclaration = mostSpecificDeclaration ; this . mostSpecificSignature = AsmClassGeneratorUtils . signature ( mostSpecificDeclaration ) ; this . declaredInManagedType = ModelSchemaUtils . isMethodDeclaredInManagedType ( declaringMethods ) ; this . declaredAsAbstract = Modifier . isAbstract ( this . mostSpecificDeclaration . getModifiers ( ) ) ; this . annotations = collectAnnotations ( declaringMethods ) ; } private Map < Class < ? extends Annotation > , Annotation > collectAnnotations ( Iterable < Method > methods ) { Map < Class < ? extends Annotation > , Annotation > annotations = Maps . newLinkedHashMap ( ) ; for ( Method method : methods ) { for ( Annotation annotation : method . getDeclaredAnnotations ( ) ) { if ( ! annotations . containsKey ( annotation . annotationType ( ) ) ) { annotations . put ( annotation . annotationType ( ) , annotation ) ; } } } return Collections . unmodifiableMap ( annotations ) ; } public Collection < Method > getDeclaringMethods ( ) { return declaringMethods ; } public Method getMostSpecificDeclaration ( ) { return mostSpecificDeclaration ; } public String getMostSpecificSignature ( ) { return mostSpecificSignature ; } public boolean isDeclaredInManagedType ( ) { return declaredInManagedType ; } public boolean isDeclaredAsAbstract ( ) { return declaredAsAbstract ; } public boolean isAnnotationPresent ( Class < ? extends Annotation > annotationType ) { return annotations . containsKey ( annotationType ) ; } public < A extends Annotation > A getAnnotation ( Class < A > annotationType ) { return Cast . uncheckedCast ( annotations . get ( annotationType ) ) ; } public Collection < Annotation > getAnnotations ( ) { return annotations . values ( ) ; } public List < Method > getGetters ( ) { List < Method > getters ; if ( mostSpecificDeclaration . getReturnType ( ) = = Boolean . TYPE ) { getters = Lists . newArrayList ( ) ; for ( Method getter : declaringMethods ) { if ( Proxy . isProxyClass ( getter . getDeclaringClass ( ) ) ) { continue ; } getters . add ( getter ) ; } } else { getters = Collections . singletonList ( mostSpecificDeclaration ) ; } return getters ; } } 
