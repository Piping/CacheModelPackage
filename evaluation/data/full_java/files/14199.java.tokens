package org . gradle . messaging . remote . internal . inet ; import com . google . common . base . Objects ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . serialize . ObjectReader ; import org . gradle . internal . serialize . ObjectWriter ; import org . gradle . messaging . remote . internal . MessageIOException ; import org . gradle . messaging . remote . internal . MessageSerializer ; import org . gradle . messaging . remote . internal . RemoteConnection ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . ClosedSelectorException ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . nio . channels . SocketChannel ; public class SocketConnection < T > implements RemoteConnection < T > { private static final Logger LOGGER = LoggerFactory . getLogger ( SocketConnection . class ) ; private final SocketChannel socket ; private final SocketInetAddress localAddress ; private final SocketInetAddress remoteAddress ; private final ObjectWriter < T > objectWriter ; private final ObjectReader < T > objectReader ; private final InputStream instr ; private final OutputStream outstr ; public SocketConnection ( SocketChannel socket , MessageSerializer < T > serializer ) { this . socket = socket ; try { socket . configureBlocking ( false ) ; outstr = new SocketOutputStream ( socket ) ; instr = new SocketInputStream ( socket ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } InetSocketAddress localSocketAddress = ( InetSocketAddress ) socket . socket ( ) . getLocalSocketAddress ( ) ; localAddress = new SocketInetAddress ( localSocketAddress . getAddress ( ) , localSocketAddress . getPort ( ) ) ; InetSocketAddress remoteSocketAddress = ( InetSocketAddress ) socket . socket ( ) . getRemoteSocketAddress ( ) ; remoteAddress = new SocketInetAddress ( remoteSocketAddress . getAddress ( ) , remoteSocketAddress . getPort ( ) ) ; objectReader = serializer . newReader ( instr , localAddress , remoteAddress ) ; objectWriter = serializer . newWriter ( outstr ) ; } @Override public String toString ( ) { return String . format ( <str> , localAddress , remoteAddress ) ; } public T receive ( ) throws MessageIOException { try { return objectReader . read ( ) ; } catch ( EOFException e ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( <str> , e . toString ( ) ) ; } return null ; } catch ( Exception e ) { throw new MessageIOException ( String . format ( <str> , remoteAddress ) , e ) ; } } private static boolean isEndOfStream ( Exception e ) { if ( e instanceof EOFException ) { return true ; } if ( e instanceof IOException ) { if ( Objects . equal ( e . getMessage ( ) , <str> ) ) { return true ; } if ( Objects . equal ( e . getMessage ( ) , <str> ) ) { return true ; } if ( Objects . equal ( e . getMessage ( ) , <str> ) ) { return true ; } } return false ; } public void dispatch ( T message ) throws MessageIOException { try { objectWriter . write ( message ) ; outstr . flush ( ) ; } catch ( Exception e ) { throw new MessageIOException ( String . format ( <str> , message , remoteAddress ) , e ) ; } } public void requestStop ( ) { CompositeStoppable . stoppable ( instr ) . stop ( ) ; } public void stop ( ) { CompositeStoppable . stoppable ( instr , outstr , socket ) . stop ( ) ; } private static class SocketInputStream extends InputStream { private final Selector selector ; private final ByteBuffer buffer ; private final SocketChannel socket ; private final byte [ ] readBuffer = new byte [ <int> ] ; public SocketInputStream ( SocketChannel socket ) throws IOException { this . socket = socket ; selector = Selector . open ( ) ; socket . register ( selector , SelectionKey . OP_READ ) ; buffer = ByteBuffer . allocateDirect ( <int> ) ; buffer . limit ( <int> ) ; } @Override public int read ( ) throws IOException { int nread = read ( readBuffer , <int> , <int> ) ; if ( nread < = <int> ) { return nread ; } return readBuffer [ <int> ] ; } @Override public int read ( byte [ ] dest , int offset , int max ) throws IOException { if ( max = = <int> ) { return <int> ; } if ( buffer . remaining ( ) = = <int> ) { try { selector . select ( ) ; } catch ( ClosedSelectorException e ) { return - <int> ; } if ( ! selector . isOpen ( ) ) { return - <int> ; } buffer . clear ( ) ; int nread ; try { nread = socket . read ( buffer ) ; } catch ( IOException e ) { if ( isEndOfStream ( e ) ) { buffer . position ( <int> ) ; buffer . limit ( <int> ) ; return - <int> ; } throw e ; } buffer . flip ( ) ; if ( nread < <int> ) { return - <int> ; } } int count = Math . min ( buffer . remaining ( ) , max ) ; buffer . get ( dest , offset , count ) ; return count ; } @Override public void close ( ) throws IOException { selector . close ( ) ; } } private static class SocketOutputStream extends OutputStream { private static final int RETRIES_WHEN_BUFFER_FULL = <int> ; private Selector selector ; private final SocketChannel socket ; private final ByteBuffer buffer ; private final byte [ ] writeBuffer = new byte [ <int> ] ; public SocketOutputStream ( SocketChannel socket ) throws IOException { this . socket = socket ; buffer = ByteBuffer . allocateDirect ( <int> * <int> ) ; } @Override public void write ( int b ) throws IOException { writeBuffer [ <int> ] = ( byte ) b ; write ( writeBuffer ) ; } @Override public void write ( byte [ ] src , int offset , int max ) throws IOException { int remaining = max ; int currentPos = offset ; while ( remaining > <int> ) { int count = Math . min ( remaining , buffer . remaining ( ) ) ; if ( count > <int> ) { buffer . put ( src , currentPos , count ) ; remaining - = count ; currentPos + = count ; } while ( buffer . remaining ( ) = = <int> ) { writeBufferToChannel ( ) ; } } } @Override public void flush ( ) throws IOException { while ( buffer . position ( ) > <int> ) { writeBufferToChannel ( ) ; } } private void writeBufferToChannel ( ) throws IOException { buffer . flip ( ) ; int count = writeWithNonBlockingRetry ( ) ; if ( count = = <int> ) { waitForWriteBufferToDrain ( ) ; } buffer . compact ( ) ; } private int writeWithNonBlockingRetry ( ) throws IOException { int count = <int> ; int retryCount = <int> ; while ( count = = <int> & & retryCount + + < RETRIES_WHEN_BUFFER_FULL ) { count = socket . write ( buffer ) ; if ( count < <int> ) { throw new EOFException ( ) ; } else if ( count = = <int> ) { Thread . yield ( ) ; } } return count ; } private void waitForWriteBufferToDrain ( ) throws IOException { if ( selector = = null ) { selector = Selector . open ( ) ; } SelectionKey key = socket . register ( selector , SelectionKey . OP_WRITE ) ; selector . select ( ) ; key . cancel ( ) ; selector . selectNow ( ) ; } @Override public void close ( ) throws IOException { if ( selector ! = null ) { selector . close ( ) ; selector = null ; } } } } 
