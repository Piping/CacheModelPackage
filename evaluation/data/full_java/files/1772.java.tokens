package org . apache . cassandra . stress . settings ; import java . io . Serializable ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . * ; import com . datastax . driver . core . exceptions . AlreadyExistsException ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . thrift . * ; import org . apache . cassandra . thrift . ConsistencyLevel ; import org . apache . cassandra . utils . ByteBufferUtil ; public class SettingsSchema implements Serializable { public static final String DEFAULT_VALIDATOR = <str> ; private final String replicationStrategy ; private final Map < String , String > replicationStrategyOptions ; private final String compression ; private final String compactionStrategy ; private final Map < String , String > compactionStrategyOptions ; public final String keyspace ; public SettingsSchema ( Options options , SettingsCommand command ) { if ( command instanceof SettingsCommandUser ) keyspace = ( ( SettingsCommandUser ) command ) . profile . keyspaceName ; else keyspace = options . keyspace . value ( ) ; replicationStrategy = options . replication . getStrategy ( ) ; replicationStrategyOptions = options . replication . getOptions ( ) ; compression = options . compression . value ( ) ; compactionStrategy = options . compaction . getStrategy ( ) ; compactionStrategyOptions = options . compaction . getOptions ( ) ; } public void createKeySpaces ( StressSettings settings ) { if ( settings . mode . api ! = ConnectionAPI . JAVA_DRIVER_NATIVE ) { createKeySpacesThrift ( settings ) ; } else { createKeySpacesNative ( settings ) ; } } public void createKeySpacesNative ( StressSettings settings ) { JavaDriverClient client = settings . getJavaDriverClient ( false ) ; try { client . execute ( createKeyspaceStatementCQL3 ( ) , org . apache . cassandra . db . ConsistencyLevel . LOCAL_ONE ) ; client . execute ( <str> + keyspace + <str> , org . apache . cassandra . db . ConsistencyLevel . LOCAL_ONE ) ; client . execute ( createStandard1StatementCQL3 ( settings ) , org . apache . cassandra . db . ConsistencyLevel . LOCAL_ONE ) ; client . execute ( createCounter1StatementCQL3 ( settings ) , org . apache . cassandra . db . ConsistencyLevel . LOCAL_ONE ) ; System . out . println ( String . format ( <str> , settings . node . nodes . size ( ) ) ) ; Thread . sleep ( settings . node . nodes . size ( ) * <int> ) ; } catch ( AlreadyExistsException e ) { } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } String createKeyspaceStatementCQL3 ( ) { StringBuilder b = new StringBuilder ( ) ; b . append ( <str> ) . append ( keyspace ) . append ( <str> ) . append ( replicationStrategy ) . append ( <str> ) ; if ( replicationStrategyOptions . isEmpty ( ) ) { b . append ( <str> ) ; } else { for ( Map . Entry < String , String > entry : replicationStrategyOptions . entrySet ( ) ) { b . append ( <str> ) . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) . append ( <str> ) ; } b . append ( <str> ) ; } b . append ( <str> ) ; return b . toString ( ) ; } String createStandard1StatementCQL3 ( StressSettings settings ) { StringBuilder b = new StringBuilder ( ) ; b . append ( <str> ) . append ( <str> ) ; try { for ( ByteBuffer name : settings . columns . names ) b . append ( <str> ) . append ( ByteBufferUtil . string ( name ) ) . append ( <str> ) ; } catch ( CharacterCodingException e ) { throw new RuntimeException ( e ) ; } b . append ( <str> ) ; if ( compression ! = null ) b . append ( <str> ) . append ( compression ) . append ( <str> ) ; b . append ( <str> ) ; if ( compactionStrategy ! = null ) { b . append ( <str> ) . append ( compactionStrategy ) . append ( <str> ) ; for ( Map . Entry < String , String > entry : compactionStrategyOptions . entrySet ( ) ) b . append ( <str> ) . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) . append ( <str> ) ; b . append ( <str> ) ; } b . append ( <str> ) ; return b . toString ( ) ; } String createCounter1StatementCQL3 ( StressSettings settings ) { StringBuilder b = new StringBuilder ( ) ; b . append ( <str> ) . append ( <str> ) ; try { for ( ByteBuffer name : settings . columns . names ) b . append ( <str> ) . append ( ByteBufferUtil . string ( name ) ) . append ( <str> ) ; } catch ( CharacterCodingException e ) { throw new RuntimeException ( e ) ; } b . append ( <str> ) ; if ( compression ! = null ) b . append ( <str> ) . append ( compression ) . append ( <str> ) ; b . append ( <str> ) ; if ( compactionStrategy ! = null ) { b . append ( <str> ) . append ( compactionStrategy ) . append ( <str> ) ; for ( Map . Entry < String , String > entry : compactionStrategyOptions . entrySet ( ) ) b . append ( <str> ) . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) . append ( <str> ) ; b . append ( <str> ) ; } b . append ( <str> ) ; return b . toString ( ) ; } public void createKeySpacesThrift ( StressSettings settings ) { KsDef ksdef = new KsDef ( ) ; CfDef standardCfDef = new CfDef ( keyspace , <str> ) ; Map < String , String > compressionOptions = new HashMap < > ( ) ; if ( compression ! = null ) compressionOptions . put ( <str> , compression ) ; String comparator = settings . columns . comparator ; standardCfDef . setComparator_type ( comparator ) . setDefault_validation_class ( DEFAULT_VALIDATOR ) . setCompression_options ( compressionOptions ) ; for ( int i = <int> ; i < settings . columns . names . size ( ) ; i + + ) standardCfDef . addToColumn_metadata ( new ColumnDef ( settings . columns . names . get ( i ) , <str> ) ) ; CfDef counterCfDef = new CfDef ( keyspace , <str> ) . setComparator_type ( comparator ) . setDefault_validation_class ( <str> ) . setCompression_options ( compressionOptions ) ; ksdef . setName ( keyspace ) ; ksdef . setStrategy_class ( replicationStrategy ) ; if ( ! replicationStrategyOptions . isEmpty ( ) ) { ksdef . setStrategy_options ( replicationStrategyOptions ) ; } if ( compactionStrategy ! = null ) { standardCfDef . setCompaction_strategy ( compactionStrategy ) ; counterCfDef . setCompaction_strategy ( compactionStrategy ) ; if ( ! compactionStrategyOptions . isEmpty ( ) ) { standardCfDef . setCompaction_strategy_options ( compactionStrategyOptions ) ; counterCfDef . setCompaction_strategy_options ( compactionStrategyOptions ) ; } } ksdef . setCf_defs ( new ArrayList < > ( Arrays . asList ( standardCfDef , counterCfDef ) ) ) ; Cassandra . Client client = settings . getRawThriftClient ( false ) ; try { client . system_add_keyspace ( ksdef ) ; client . set_keyspace ( keyspace ) ; System . out . println ( String . format ( <str> , settings . node . nodes . size ( ) ) ) ; Thread . sleep ( settings . node . nodes . size ( ) * <int> ) ; } catch ( InvalidRequestException e ) { System . err . println ( <str> + e . getWhy ( ) ) ; } catch ( Exception e ) { System . err . println ( <str> + e . getMessage ( ) ) ; } } private static final class Options extends GroupedOptions { final OptionReplication replication = new OptionReplication ( ) ; final OptionCompaction compaction = new OptionCompaction ( ) ; final OptionSimple keyspace = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple compression = new OptionSimple ( <str> , <str> , null , <str> , false ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( replication , keyspace , compaction , compression ) ; } } public static SettingsSchema get ( Map < String , String [ ] > clArgs , SettingsCommand command ) { String [ ] params = clArgs . remove ( <str> ) ; if ( params = = null ) return new SettingsSchema ( new Options ( ) , command ) ; if ( command instanceof SettingsCommandUser ) throw new IllegalArgumentException ( <str> ) ; GroupedOptions options = GroupedOptions . select ( params , new Options ( ) ) ; if ( options = = null ) { printHelp ( ) ; System . out . println ( <str> ) ; System . exit ( <int> ) ; } return new SettingsSchema ( ( Options ) options , command ) ; } public static void printHelp ( ) { GroupedOptions . printOptions ( System . out , <str> , new Options ( ) ) ; } public static Runnable helpPrinter ( ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( ) ; } } ; } } 
