package org . gradle . model . internal . core ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . base . Optional ; import com . google . common . base . Strings ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import org . gradle . api . GradleException ; import org . gradle . api . Incubating ; import org . gradle . model . ModelMap ; import org . gradle . model . ModelSet ; import org . gradle . model . internal . manage . schema . CollectionSchema ; import org . gradle . model . internal . manage . schema . ModelProperty ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . type . ModelType ; import java . util . List ; import java . util . Set ; @Incubating public class ModelTypeInitializationException extends GradleException { private static final String MANAGED_TYPE_DESCRIPTION = <str> ; private static final String UNMANAGED_PROPERTY_DESCRIPTION = <str> ; public ModelTypeInitializationException ( NodeInitializerContext < ? > context , ModelSchemaStore schemaStore , Iterable < ? extends ModelType < ? > > scalarTypes , Iterable < ? extends ModelType < ? > > constructibleTypes ) { super ( toMessage ( context , schemaStore , scalarTypes , constructibleTypes ) ) ; } private static < T > String toMessage ( NodeInitializerContext < T > context , ModelSchemaStore schemaStore , Iterable < ? extends ModelType < ? > > scalarTypes , Iterable < ? extends ModelType < ? > > constructibleTypes ) { Optional < ? extends NodeInitializerContext . PropertyContext > propertyContextOptional = context . getPropertyContextOptional ( ) ; StringBuilder s = new StringBuilder ( ) ; if ( propertyContextOptional . isPresent ( ) ) { NodeInitializerContext . PropertyContext propertyContext = propertyContextOptional . get ( ) ; s . append ( String . format ( <str> , propertyContext . getDeclaringType ( ) . getName ( ) ) ) ; ModelProperty < ? > modelProperty = propertyContext . getModelProperty ( ) ; if ( isManagedCollection ( modelProperty . getType ( ) ) ) { s . append ( String . format ( <str> , modelProperty . getType ( ) . getName ( ) , modelProperty . getName ( ) ) ) ; CollectionSchema < ? , ? > schema = ( CollectionSchema ) schemaStore . getSchema ( modelProperty . getType ( ) ) ; s . append ( String . format ( <str> , schema . getElementType ( ) ) ) ; appendManagedCollections ( s , <int> , constructibleTypes ) ; } else if ( isAScalarCollection ( modelProperty ) ) { ModelType < ? > innerType = modelProperty . getType ( ) . getTypeVariables ( ) . get ( <int> ) ; s . append ( String . format ( <str> , modelProperty . getType ( ) . getName ( ) , modelProperty . getName ( ) ) ) ; s . append ( String . format ( <str> , innerType ) ) ; s . append ( explainScalarCollections ( scalarTypes ) ) ; } else { s . append ( String . format ( <str> , modelProperty . getType ( ) . getName ( ) , modelProperty . getName ( ) ) ) ; s . append ( String . format ( <str> ) ) ; s . append ( String . format ( <str> , MANAGED_TYPE_DESCRIPTION ) ) ; s . append ( <str> ) ; appendManagedCollections ( s , <int> , constructibleTypes ) ; s . append ( String . format ( <str> , explainScalarCollections ( scalarTypes ) , UNMANAGED_PROPERTY_DESCRIPTION ) ) ; maybeAppendConstructibles ( s , constructibleTypes , <int> ) ; } } else { s . append ( String . format ( <str> , context . getModelType ( ) . getName ( ) ) ) ; s . append ( String . format ( <str> ) ) ; s . append ( String . format ( <str> , MANAGED_TYPE_DESCRIPTION ) ) ; maybeAppendConstructibles ( s , constructibleTypes , <int> ) ; } return s . toString ( ) ; } private static String explainScalarCollections ( Iterable < ? extends ModelType < ? > > scalarTypes ) { return String . format ( <str> , describe ( scalarTypes ) ) ; } private static String appendManagedCollections ( StringBuilder s , int pad , Iterable < ? extends ModelType < ? > > constructibleTypes ) { s . append ( String . format ( <str> , MANAGED_TYPE_DESCRIPTION ) ) ; maybeAppendConstructibles ( s , constructibleTypes , pad + <int> ) ; return s . toString ( ) ; } private static void maybeAppendConstructibles ( StringBuilder s , Iterable < ? extends ModelType < ? > > constructibleTypes , int pad ) { if ( ! Iterables . isEmpty ( constructibleTypes ) ) { String padding = pad ( pad ) ; s . append ( String . format ( <str> , padding ) ) ; for ( ModelType < ? > modelType : constructibleTypes ) { s . append ( String . format ( <str> , padding , modelType . getName ( ) ) ) ; } } } private static String pad ( int padding ) { return Strings . padStart ( <str> , padding * <int> , <str> ) ; } private static boolean isAScalarCollection ( ModelProperty < ? > modelProperty ) { Class < ? > concreteClass = modelProperty . getType ( ) . getConcreteClass ( ) ; return ( concreteClass . equals ( List . class ) | | concreteClass . equals ( Set . class ) ) & & ! modelProperty . isDeclaredAsHavingUnmanagedType ( ) ; } private static String describe ( Iterable < ? extends ModelType < ? > > types ) { return Joiner . on ( <str> ) . join ( ImmutableSet . copyOf ( Iterables . transform ( types , new Function < ModelType < ? > , String > ( ) { @Override public String apply ( ModelType < ? > input ) { return input . getDisplayName ( ) ; } } ) ) ) ; } private static boolean isManagedCollection ( ModelType < ? > type ) { Class < ? > concreteClass = type . getConcreteClass ( ) ; return concreteClass . equals ( ModelMap . class ) | | concreteClass . equals ( ModelSet . class ) ; } } 
