package org . elasticsearch . discovery . zen . ping . unicast ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . ping . PingContextProvider ; import org . elasticsearch . discovery . zen . ping . ZenPing ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BaseTransportResponseHandler ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . RemoteTransportException ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . io . Closeable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . unit . TimeValue . readTimeValue ; import static org . elasticsearch . common . util . concurrent . ConcurrentCollections . newConcurrentMap ; import static org . elasticsearch . discovery . zen . ping . ZenPing . PingResponse . readPingResponse ; public class UnicastZenPing extends AbstractLifecycleComponent < ZenPing > implements ZenPing { public static final String ACTION_NAME = <str> ; public static final String DISCOVERY_ZEN_PING_UNICAST_HOSTS = <str> ; public static final int LIMIT_FOREIGN_PORTS_COUNT = <int> ; public static final int LIMIT_LOCAL_PORTS_COUNT = <int> ; private final ThreadPool threadPool ; private final TransportService transportService ; private final ClusterName clusterName ; private final ElectMasterService electMasterService ; private final int concurrentConnects ; private final DiscoveryNode [ ] configuredTargetNodes ; private volatile PingContextProvider contextProvider ; private final AtomicInteger pingHandlerIdGenerator = new AtomicInteger ( ) ; private final AtomicInteger unicastNodeIdGenerator = new AtomicInteger ( ) ; private static final String UNICAST_NODE_PREFIX = <str> ; private final Map < Integer , SendPingsHandler > receivedResponses = newConcurrentMap ( ) ; private final Queue < PingResponse > temporalResponses = ConcurrentCollections . newQueue ( ) ; private final CopyOnWriteArrayList < UnicastHostsProvider > hostsProviders = new CopyOnWriteArrayList < > ( ) ; private final ExecutorService unicastConnectExecutor ; private volatile boolean closed = false ; @Inject public UnicastZenPing ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterName clusterName , Version version , ElectMasterService electMasterService , @Nullable Set < UnicastHostsProvider > unicastHostsProviders ) { super ( settings ) ; this . threadPool = threadPool ; this . transportService = transportService ; this . clusterName = clusterName ; this . electMasterService = electMasterService ; if ( unicastHostsProviders ! = null ) { for ( UnicastHostsProvider unicastHostsProvider : unicastHostsProviders ) { addHostsProvider ( unicastHostsProvider ) ; } } this . concurrentConnects = this . settings . getAsInt ( <str> , <int> ) ; String [ ] hostArr = this . settings . getAsArray ( DISCOVERY_ZEN_PING_UNICAST_HOSTS ) ; for ( int i = <int> ; i < hostArr . length ; i + + ) { hostArr [ i ] = hostArr [ i ] . trim ( ) ; } List < String > hosts = CollectionUtils . arrayAsArrayList ( hostArr ) ; final int limitPortCounts ; if ( hosts . isEmpty ( ) ) { limitPortCounts = LIMIT_LOCAL_PORTS_COUNT ; hosts . addAll ( transportService . getLocalAddresses ( ) ) ; } else { limitPortCounts = LIMIT_FOREIGN_PORTS_COUNT ; } logger . debug ( <str> , hosts , concurrentConnects ) ; List < DiscoveryNode > configuredTargetNodes = new ArrayList < > ( ) ; for ( String host : hosts ) { try { TransportAddress [ ] addresses = transportService . addressesFromString ( host , limitPortCounts ) ; for ( TransportAddress address : addresses ) { configuredTargetNodes . add ( new DiscoveryNode ( UNICAST_NODE_PREFIX + unicastNodeIdGenerator . incrementAndGet ( ) + <str> , address , version . minimumCompatibilityVersion ( ) ) ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + host + <str> , e ) ; } } this . configuredTargetNodes = configuredTargetNodes . toArray ( new DiscoveryNode [ configuredTargetNodes . size ( ) ] ) ; transportService . registerRequestHandler ( ACTION_NAME , UnicastPingRequest : : new , ThreadPool . Names . SAME , new UnicastPingRequestHandler ( ) ) ; ThreadFactory threadFactory = EsExecutors . daemonThreadFactory ( settings , <str> ) ; unicastConnectExecutor = EsExecutors . newScaling ( <str> , <int> , concurrentConnects , <int> , TimeUnit . SECONDS , threadFactory ) ; } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { transportService . removeHandler ( ACTION_NAME ) ; ThreadPool . terminate ( unicastConnectExecutor , <int> , TimeUnit . SECONDS ) ; try { IOUtils . close ( receivedResponses . values ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } closed = true ; } public void addHostsProvider ( UnicastHostsProvider provider ) { hostsProviders . add ( provider ) ; } public void removeHostsProvider ( UnicastHostsProvider provider ) { hostsProviders . remove ( provider ) ; } @Override public void setPingContextProvider ( PingContextProvider contextProvider ) { this . contextProvider = contextProvider ; } public void clearTemporalResponses ( ) { temporalResponses . clear ( ) ; } public PingResponse [ ] pingAndWait ( TimeValue timeout ) { final AtomicReference < PingResponse [ ] > response = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; ping ( new PingListener ( ) { @Override public void onPing ( PingResponse [ ] pings ) { response . set ( pings ) ; latch . countDown ( ) ; } } , timeout ) ; try { latch . await ( ) ; return response . get ( ) ; } catch ( InterruptedException e ) { return null ; } } @Override public void ping ( final PingListener listener , final TimeValue timeout ) { final SendPingsHandler sendPingsHandler = new SendPingsHandler ( pingHandlerIdGenerator . incrementAndGet ( ) ) ; try { receivedResponses . put ( sendPingsHandler . id ( ) , sendPingsHandler ) ; try { sendPings ( timeout , null , sendPingsHandler ) ; } catch ( RejectedExecutionException e ) { logger . debug ( <str> , e ) ; } threadPool . schedule ( TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override protected void doRun ( ) { sendPings ( timeout , null , sendPingsHandler ) ; threadPool . schedule ( TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override protected void doRun ( ) throws Exception { sendPings ( timeout , TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , sendPingsHandler ) ; sendPingsHandler . close ( ) ; listener . onPing ( sendPingsHandler . pingCollection ( ) . toArray ( ) ) ; for ( DiscoveryNode node : sendPingsHandler . nodeToDisconnect ) { logger . trace ( <str> , sendPingsHandler . id ( ) , node ) ; transportService . disconnectFromNode ( node ) ; } } @Override public void onFailure ( Throwable t ) { logger . debug ( <str> , t ) ; sendPingsHandler . close ( ) ; } } ) ; } @Override public void onFailure ( Throwable t ) { logger . debug ( <str> , t ) ; sendPingsHandler . close ( ) ; } } ) ; } catch ( EsRejectedExecutionException ex ) { sendPingsHandler . close ( ) ; } catch ( Exception e ) { sendPingsHandler . close ( ) ; throw new ElasticsearchException ( <str> , e ) ; } } class SendPingsHandler implements Closeable { private final int id ; private final Set < DiscoveryNode > nodeToDisconnect = ConcurrentCollections . newConcurrentSet ( ) ; private final PingCollection pingCollection ; private AtomicBoolean closed = new AtomicBoolean ( false ) ; SendPingsHandler ( int id ) { this . id = id ; this . pingCollection = new PingCollection ( ) ; } public int id ( ) { return this . id ; } public boolean isClosed ( ) { return this . closed . get ( ) ; } public PingCollection pingCollection ( ) { return pingCollection ; } @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { receivedResponses . remove ( id ) ; } } } void sendPings ( final TimeValue timeout , @Nullable TimeValue waitTime , final SendPingsHandler sendPingsHandler ) { final UnicastPingRequest pingRequest = new UnicastPingRequest ( ) ; pingRequest . id = sendPingsHandler . id ( ) ; pingRequest . timeout = timeout ; DiscoveryNodes discoNodes = contextProvider . nodes ( ) ; pingRequest . pingResponse = createPingResponse ( discoNodes ) ; HashSet < DiscoveryNode > nodesToPingSet = new HashSet < > ( ) ; for ( PingResponse temporalResponse : temporalResponses ) { if ( clusterName . equals ( temporalResponse . clusterName ( ) ) ) { nodesToPingSet . add ( temporalResponse . node ( ) ) ; } } for ( UnicastHostsProvider provider : hostsProviders ) { nodesToPingSet . addAll ( provider . buildDynamicNodes ( ) ) ; } for ( ObjectCursor < DiscoveryNode > masterNode : discoNodes . getMasterNodes ( ) . values ( ) ) { nodesToPingSet . add ( masterNode . value ) ; } List < DiscoveryNode > sortedNodesToPing = electMasterService . sortByMasterLikelihood ( nodesToPingSet ) ; List < DiscoveryNode > nodesToPing = CollectionUtils . arrayAsArrayList ( configuredTargetNodes ) ; nodesToPing . addAll ( sortedNodesToPing ) ; final CountDownLatch latch = new CountDownLatch ( nodesToPing . size ( ) ) ; for ( final DiscoveryNode node : nodesToPing ) { final boolean nodeFoundByAddress ; DiscoveryNode nodeToSend = discoNodes . findByAddress ( node . address ( ) ) ; if ( nodeToSend ! = null ) { nodeFoundByAddress = true ; } else { nodeToSend = node ; nodeFoundByAddress = false ; } if ( ! transportService . nodeConnected ( nodeToSend ) ) { if ( sendPingsHandler . isClosed ( ) ) { return ; } if ( ! nodeFoundByAddress ) { if ( ! nodeToSend . id ( ) . startsWith ( UNICAST_NODE_PREFIX ) ) { DiscoveryNode tempNode = new DiscoveryNode ( <str> , UNICAST_NODE_PREFIX + unicastNodeIdGenerator . incrementAndGet ( ) + <str> + nodeToSend . id ( ) + <str> , nodeToSend . getHostName ( ) , nodeToSend . getHostAddress ( ) , nodeToSend . address ( ) , nodeToSend . attributes ( ) , nodeToSend . version ( ) ) ; logger . trace ( <str> , nodeToSend , tempNode ) ; nodeToSend = tempNode ; } sendPingsHandler . nodeToDisconnect . add ( nodeToSend ) ; } final DiscoveryNode finalNodeToSend = nodeToSend ; unicastConnectExecutor . execute ( new Runnable ( ) { @Override public void run ( ) { if ( sendPingsHandler . isClosed ( ) ) { return ; } boolean success = false ; try { if ( ! nodeFoundByAddress ) { logger . trace ( <str> , sendPingsHandler . id ( ) , finalNodeToSend ) ; transportService . connectToNodeLight ( finalNodeToSend ) ; } else { logger . trace ( <str> , sendPingsHandler . id ( ) , finalNodeToSend ) ; transportService . connectToNode ( finalNodeToSend ) ; } logger . trace ( <str> , sendPingsHandler . id ( ) , node ) ; if ( receivedResponses . containsKey ( sendPingsHandler . id ( ) ) ) { sendPingRequestToNode ( sendPingsHandler . id ( ) , timeout , pingRequest , latch , node , finalNodeToSend ) ; } else { latch . countDown ( ) ; logger . trace ( <str> , sendPingsHandler . id ( ) , node ) ; } success = true ; } catch ( ConnectTransportException e ) { logger . trace ( <str> , e , sendPingsHandler . id ( ) , finalNodeToSend ) ; } catch ( RemoteTransportException e ) { logger . debug ( <str> , e , sendPingsHandler . id ( ) , finalNodeToSend ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , sendPingsHandler . id ( ) , finalNodeToSend ) ; } finally { if ( ! success ) { latch . countDown ( ) ; } } } } ) ; } else { sendPingRequestToNode ( sendPingsHandler . id ( ) , timeout , pingRequest , latch , node , nodeToSend ) ; } } if ( waitTime ! = null ) { try { latch . await ( waitTime . millis ( ) , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { } } } private void sendPingRequestToNode ( final int id , final TimeValue timeout , final UnicastPingRequest pingRequest , final CountDownLatch latch , final DiscoveryNode node , final DiscoveryNode nodeToSend ) { logger . trace ( <str> , id , nodeToSend ) ; transportService . sendRequest ( nodeToSend , ACTION_NAME , pingRequest , TransportRequestOptions . builder ( ) . withTimeout ( ( long ) ( timeout . millis ( ) * <float> ) ) . build ( ) , new BaseTransportResponseHandler < UnicastPingResponse > ( ) { @Override public UnicastPingResponse newInstance ( ) { return new UnicastPingResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } @Override public void handleResponse ( UnicastPingResponse response ) { logger . trace ( <str> , id , nodeToSend , Arrays . toString ( response . pingResponses ) ) ; try { DiscoveryNodes discoveryNodes = contextProvider . nodes ( ) ; for ( PingResponse pingResponse : response . pingResponses ) { if ( pingResponse . node ( ) . id ( ) . equals ( discoveryNodes . localNodeId ( ) ) ) { continue ; } if ( ! pingResponse . clusterName ( ) . equals ( clusterName ) ) { logger . debug ( <str> , id , pingResponse . node ( ) , pingResponse . clusterName ( ) . value ( ) ) ; continue ; } SendPingsHandler sendPingsHandler = receivedResponses . get ( response . id ) ; if ( sendPingsHandler = = null ) { if ( ! closed ) { logger . warn ( <str> , pingResponse , response . id ) ; } } else { sendPingsHandler . pingCollection ( ) . addPing ( pingResponse ) ; } } } finally { latch . countDown ( ) ; } } @Override public void handleException ( TransportException exp ) { latch . countDown ( ) ; if ( exp instanceof ConnectTransportException ) { logger . trace ( <str> , exp , nodeToSend ) ; } else { logger . warn ( <str> , exp , node ) ; } } } ) ; } private UnicastPingResponse handlePingRequest ( final UnicastPingRequest request ) { if ( ! lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } temporalResponses . add ( request . pingResponse ) ; threadPool . schedule ( TimeValue . timeValueMillis ( request . timeout . millis ( ) * <int> ) , ThreadPool . Names . SAME , new Runnable ( ) { @Override public void run ( ) { temporalResponses . remove ( request . pingResponse ) ; } } ) ; List < PingResponse > pingResponses = CollectionUtils . iterableAsArrayList ( temporalResponses ) ; pingResponses . add ( createPingResponse ( contextProvider . nodes ( ) ) ) ; UnicastPingResponse unicastPingResponse = new UnicastPingResponse ( ) ; unicastPingResponse . id = request . id ; unicastPingResponse . pingResponses = pingResponses . toArray ( new PingResponse [ pingResponses . size ( ) ] ) ; return unicastPingResponse ; } class UnicastPingRequestHandler implements TransportRequestHandler < UnicastPingRequest > { @Override public void messageReceived ( UnicastPingRequest request , TransportChannel channel ) throws Exception { channel . sendResponse ( handlePingRequest ( request ) ) ; } } public static class UnicastPingRequest extends TransportRequest { int id ; TimeValue timeout ; PingResponse pingResponse ; public UnicastPingRequest ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; id = in . readInt ( ) ; timeout = readTimeValue ( in ) ; pingResponse = readPingResponse ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( id ) ; timeout . writeTo ( out ) ; pingResponse . writeTo ( out ) ; } } private PingResponse createPingResponse ( DiscoveryNodes discoNodes ) { return new PingResponse ( discoNodes . localNode ( ) , discoNodes . masterNode ( ) , clusterName , contextProvider . nodeHasJoinedClusterOnce ( ) ) ; } static class UnicastPingResponse extends TransportResponse { int id ; PingResponse [ ] pingResponses ; UnicastPingResponse ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; id = in . readInt ( ) ; pingResponses = new PingResponse [ in . readVInt ( ) ] ; for ( int i = <int> ; i < pingResponses . length ; i + + ) { pingResponses [ i ] = readPingResponse ( in ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( id ) ; out . writeVInt ( pingResponses . length ) ; for ( PingResponse pingResponse : pingResponses ) { pingResponse . writeTo ( out ) ; } } } } 
