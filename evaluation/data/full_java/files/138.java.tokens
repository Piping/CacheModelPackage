package org . apache . cassandra . cql3 ; import org . antlr . runtime . ANTLRStringStream ; import org . antlr . runtime . CharStream ; import org . antlr . runtime . CommonTokenStream ; import org . antlr . runtime . RecognitionException ; import org . antlr . runtime . TokenStream ; import org . apache . cassandra . exceptions . SyntaxException ; public final class CQLFragmentParser { @FunctionalInterface public interface CQLParserFunction < R > { R parse ( CqlParser parser ) throws RecognitionException ; } public static < R > R parseAny ( CQLParserFunction < R > parserFunction , String input , String meaning ) { try { return parseAnyUnhandled ( parserFunction , input ) ; } catch ( RuntimeException re ) { throw new SyntaxException ( String . format ( <str> , meaning , input , re . getClass ( ) . getSimpleName ( ) , re . getMessage ( ) ) ) ; } catch ( RecognitionException e ) { throw new SyntaxException ( <str> + meaning + <str> + e . getMessage ( ) ) ; } } public static < R > R parseAnyUnhandled ( CQLParserFunction < R > parserFunction , String input ) throws RecognitionException { ErrorCollector errorCollector = new ErrorCollector ( input ) ; CharStream stream = new ANTLRStringStream ( input ) ; CqlLexer lexer = new CqlLexer ( stream ) ; lexer . addErrorListener ( errorCollector ) ; TokenStream tokenStream = new CommonTokenStream ( lexer ) ; CqlParser parser = new CqlParser ( tokenStream ) ; parser . addErrorListener ( errorCollector ) ; R r = parserFunction . parse ( parser ) ; errorCollector . throwFirstSyntaxError ( ) ; return r ; } } 
