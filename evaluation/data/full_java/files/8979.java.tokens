package org . elasticsearch . test . discovery ; import com . carrotsearch . randomizedtesting . RandomizedTest ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . CollectionUtils ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . NodeConfigurationSource ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . util . HashSet ; import java . util . Set ; public class ClusterDiscoveryConfiguration extends NodeConfigurationSource { static Settings DEFAULT_NODE_SETTINGS = Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ; private static final String IP_ADDR = <str> ; final int numOfNodes ; final Settings nodeSettings ; final Settings transportClientSettings ; public ClusterDiscoveryConfiguration ( int numOfNodes , Settings extraSettings ) { this . numOfNodes = numOfNodes ; this . nodeSettings = Settings . builder ( ) . put ( DEFAULT_NODE_SETTINGS ) . put ( extraSettings ) . build ( ) ; this . transportClientSettings = Settings . builder ( ) . put ( extraSettings ) . build ( ) ; } @Override public Settings nodeSettings ( int nodeOrdinal ) { return nodeSettings ; } @Override public Settings transportClientSettings ( ) { return transportClientSettings ; } public static class UnicastZen extends ClusterDiscoveryConfiguration { private static int nextPort = calcBasePort ( ) ; private final int [ ] unicastHostOrdinals ; private final int [ ] unicastHostPorts ; public UnicastZen ( int numOfNodes , Settings extraSettings ) { this ( numOfNodes , numOfNodes , extraSettings ) ; } public UnicastZen ( int numOfNodes , int numOfUnicastHosts , Settings extraSettings ) { super ( numOfNodes , extraSettings ) ; if ( numOfUnicastHosts = = numOfNodes ) { unicastHostOrdinals = new int [ numOfNodes ] ; for ( int i = <int> ; i < numOfNodes ; i + + ) { unicastHostOrdinals [ i ] = i ; } } else { Set < Integer > ordinals = new HashSet < > ( numOfUnicastHosts ) ; while ( ordinals . size ( ) ! = numOfUnicastHosts ) { ordinals . add ( RandomizedTest . randomInt ( numOfNodes - <int> ) ) ; } unicastHostOrdinals = CollectionUtils . toArray ( ordinals ) ; } this . unicastHostPorts = unicastHostPorts ( numOfNodes ) ; assert unicastHostOrdinals . length < = unicastHostPorts . length ; } public UnicastZen ( int numOfNodes , int [ ] unicastHostOrdinals ) { this ( numOfNodes , Settings . EMPTY , unicastHostOrdinals ) ; } public UnicastZen ( int numOfNodes , Settings extraSettings , int [ ] unicastHostOrdinals ) { super ( numOfNodes , extraSettings ) ; this . unicastHostOrdinals = unicastHostOrdinals ; this . unicastHostPorts = unicastHostPorts ( numOfNodes ) ; assert unicastHostOrdinals . length < = unicastHostPorts . length ; } private static int calcBasePort ( ) { return <int> + InternalTestCluster . JVM_BASE_PORT_OFFEST ; } @Override public Settings nodeSettings ( int nodeOrdinal ) { Settings . Builder builder = Settings . builder ( ) ; String [ ] unicastHosts = new String [ unicastHostOrdinals . length ] ; if ( nodeOrdinal > = unicastHostPorts . length ) { throw new ElasticsearchException ( <str> + nodeOrdinal + <str> + unicastHostPorts . length + <str> ) ; } else { builder . put ( <str> , unicastHostPorts [ nodeOrdinal ] ) ; builder . put ( <str> , IP_ADDR ) ; builder . put ( <str> , IP_ADDR ) ; builder . put ( <str> , IP_ADDR ) ; builder . put ( <str> , false ) ; for ( int i = <int> ; i < unicastHostOrdinals . length ; i + + ) { unicastHosts [ i ] = IP_ADDR + <str> + ( unicastHostPorts [ unicastHostOrdinals [ i ] ] ) ; } } builder . putArray ( <str> , unicastHosts ) ; return builder . put ( super . nodeSettings ( nodeOrdinal ) ) . build ( ) ; } @SuppressForbidden ( reason = <str> ) protected synchronized static int [ ] unicastHostPorts ( int numHosts ) { int [ ] unicastHostPorts = new int [ numHosts ] ; final int basePort = calcBasePort ( ) ; final int maxPort = basePort + InternalTestCluster . PORTS_PER_JVM ; int tries = <int> ; for ( int i = <int> ; i < unicastHostPorts . length ; i + + ) { boolean foundPortInRange = false ; while ( tries < InternalTestCluster . PORTS_PER_JVM & & ! foundPortInRange ) { try ( ServerSocket serverSocket = new ServerSocket ( ) ) { serverSocket . setReuseAddress ( NetworkUtils . defaultReuseAddress ( ) ) ; serverSocket . bind ( new InetSocketAddress ( IP_ADDR , nextPort ) ) ; foundPortInRange = true ; unicastHostPorts [ i ] = nextPort ; } catch ( IOException e ) { } nextPort + + ; if ( nextPort > = maxPort ) { nextPort = basePort ; } tries + + ; } if ( ! foundPortInRange ) { throw new ElasticsearchException ( <str> + basePort + <str> + maxPort + <str> + unicastHostPorts . length + <str> ) ; } } return unicastHostPorts ; } } } 
