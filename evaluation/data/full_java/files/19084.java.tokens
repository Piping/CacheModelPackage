package io . netty . handler . codec . http ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOutboundHandler ; import io . netty . channel . ChannelPromise ; import io . netty . util . AsciiString ; import java . net . SocketAddress ; import java . util . Collection ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import static io . netty . handler . codec . http . HttpResponseStatus . SWITCHING_PROTOCOLS ; import static io . netty . util . ReferenceCountUtil . release ; public class HttpClientUpgradeHandler extends HttpObjectAggregator implements ChannelOutboundHandler { public enum UpgradeEvent { UPGRADE_ISSUED , UPGRADE_SUCCESSFUL , UPGRADE_REJECTED } public interface SourceCodec { void upgradeFrom ( ChannelHandlerContext ctx ) ; } public interface UpgradeCodec { CharSequence protocol ( ) ; Collection < CharSequence > setUpgradeHeaders ( ChannelHandlerContext ctx , HttpRequest upgradeRequest ) ; void upgradeTo ( ChannelHandlerContext ctx , FullHttpResponse upgradeResponse ) throws Exception ; } private final SourceCodec sourceCodec ; private final UpgradeCodec upgradeCodec ; private boolean upgradeRequested ; public HttpClientUpgradeHandler ( SourceCodec sourceCodec , UpgradeCodec upgradeCodec , int maxContentLength ) { super ( maxContentLength ) ; if ( sourceCodec = = null ) { throw new NullPointerException ( <str> ) ; } if ( upgradeCodec = = null ) { throw new NullPointerException ( <str> ) ; } this . sourceCodec = sourceCodec ; this . upgradeCodec = upgradeCodec ; } @Override public void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . bind ( localAddress , promise ) ; } @Override public void connect ( ChannelHandlerContext ctx , SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . connect ( remoteAddress , localAddress , promise ) ; } @Override public void disconnect ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . disconnect ( promise ) ; } @Override public void close ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . close ( promise ) ; } @Override public void deregister ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . deregister ( promise ) ; } @Override public void read ( ChannelHandlerContext ctx ) throws Exception { ctx . read ( ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( ! ( msg instanceof HttpRequest ) ) { ctx . write ( msg , promise ) ; return ; } if ( upgradeRequested ) { promise . setFailure ( new IllegalStateException ( <str> ) ) ; return ; } upgradeRequested = true ; setUpgradeRequestHeaders ( ctx , ( HttpRequest ) msg ) ; ctx . write ( msg , promise ) ; ctx . fireUserEventTriggered ( UpgradeEvent . UPGRADE_ISSUED ) ; } @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { ctx . flush ( ) ; } @Override protected void decode ( ChannelHandlerContext ctx , HttpObject msg , List < Object > out ) throws Exception { FullHttpResponse response = null ; try { if ( ! upgradeRequested ) { throw new IllegalStateException ( <str> ) ; } if ( msg instanceof FullHttpResponse ) { response = ( FullHttpResponse ) msg ; response . retain ( ) ; out . add ( response ) ; } else { super . decode ( ctx , msg , out ) ; if ( out . isEmpty ( ) ) { return ; } assert out . size ( ) = = <int> ; response = ( FullHttpResponse ) out . get ( <int> ) ; } if ( ! SWITCHING_PROTOCOLS . equals ( response . status ( ) ) ) { ctx . fireUserEventTriggered ( UpgradeEvent . UPGRADE_REJECTED ) ; removeThisHandler ( ctx ) ; return ; } CharSequence upgradeHeader = response . headers ( ) . get ( HttpHeaderNames . UPGRADE ) ; if ( upgradeHeader ! = null & & ! AsciiString . contentEqualsIgnoreCase ( upgradeCodec . protocol ( ) , upgradeHeader ) ) { throw new IllegalStateException ( <str> + upgradeHeader ) ; } sourceCodec . upgradeFrom ( ctx ) ; upgradeCodec . upgradeTo ( ctx , response ) ; ctx . fireUserEventTriggered ( UpgradeEvent . UPGRADE_SUCCESSFUL ) ; response . release ( ) ; out . clear ( ) ; removeThisHandler ( ctx ) ; } catch ( Throwable t ) { release ( response ) ; ctx . fireExceptionCaught ( t ) ; removeThisHandler ( ctx ) ; } } private static void removeThisHandler ( ChannelHandlerContext ctx ) { ctx . pipeline ( ) . remove ( ctx . name ( ) ) ; } private void setUpgradeRequestHeaders ( ChannelHandlerContext ctx , HttpRequest request ) { request . headers ( ) . set ( HttpHeaderNames . UPGRADE , upgradeCodec . protocol ( ) ) ; Set < CharSequence > connectionParts = new LinkedHashSet < CharSequence > ( <int> ) ; connectionParts . addAll ( upgradeCodec . setUpgradeHeaders ( ctx , request ) ) ; StringBuilder builder = new StringBuilder ( ) ; for ( CharSequence part : connectionParts ) { builder . append ( part ) ; builder . append ( <str> ) ; } builder . append ( HttpHeaderValues . UPGRADE ) ; request . headers ( ) . set ( HttpHeaderNames . CONNECTION , builder . toString ( ) ) ; } } 
