package org . junit . tests . experimental . theories . runner ; import static org . hamcrest . CoreMatchers . containsString ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . tests . experimental . theories . TheoryTestUtils . potentialAssignments ; import java . util . List ; import org . junit . Test ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . FromDataPoints ; import org . junit . experimental . theories . PotentialAssignment ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; public class WithNamedDataPoints { @RunWith ( Theories . class ) public static class HasSpecificDatapointsParameters { @DataPoints public static String [ ] badStrings = new String [ ] { <str> } ; @DataPoint public static String badString = <str> ; @DataPoints ( <str> ) public static String [ ] goodStrings = new String [ ] { <str> , <str> } ; @DataPoint ( <str> ) public static String goodString = <str> ; @DataPoints ( <str> ) public static String [ ] methodStrings ( ) { return new String [ ] { <str> } ; } @DataPoint ( <str> ) public static String methodString ( ) { return <str> ; } @DataPoints public static String [ ] otherMethod ( ) { return new String [ ] { <str> } ; } @DataPoint public static String otherSingleValueMethod ( ) { return <str> ; } @Theory public void theory ( @FromDataPoints ( <str> ) String param ) { } } @Test public void onlyUseSpecificDataPointsIfSpecified ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasSpecificDatapointsParameters . class . getMethod ( <str> , String . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertThat ( ( String ) assignment . getValue ( ) , containsString ( <str> ) ) ; } } } 
