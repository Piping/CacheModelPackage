package org . elasticsearch . discovery ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class DiscoveryService extends AbstractLifecycleComponent < DiscoveryService > { public static final String SETTING_INITIAL_STATE_TIMEOUT = <str> ; public static final String SETTING_DISCOVERY_SEED = <str> ; private static class InitialStateListener implements InitialStateDiscoveryListener { private final CountDownLatch latch = new CountDownLatch ( <int> ) ; private volatile boolean initialStateReceived ; @Override public void initialStateProcessed ( ) { initialStateReceived = true ; latch . countDown ( ) ; } public boolean waitForInitialState ( TimeValue timeValue ) throws InterruptedException { if ( timeValue . millis ( ) > <int> ) { latch . await ( timeValue . millis ( ) , TimeUnit . MILLISECONDS ) ; } return initialStateReceived ; } } private final TimeValue initialStateTimeout ; private final Discovery discovery ; private InitialStateListener initialStateListener ; private final DiscoverySettings discoverySettings ; @Inject public DiscoveryService ( Settings settings , DiscoverySettings discoverySettings , Discovery discovery ) { super ( settings ) ; this . discoverySettings = discoverySettings ; this . discovery = discovery ; this . initialStateTimeout = settings . getAsTime ( SETTING_INITIAL_STATE_TIMEOUT , TimeValue . timeValueSeconds ( <int> ) ) ; } public ClusterBlock getNoMasterBlock ( ) { return discoverySettings . getNoMasterBlock ( ) ; } @Override protected void doStart ( ) { initialStateListener = new InitialStateListener ( ) ; discovery . addListener ( initialStateListener ) ; discovery . start ( ) ; logger . info ( discovery . nodeDescription ( ) ) ; } public void waitForInitialState ( ) { try { if ( ! initialStateListener . waitForInitialState ( initialStateTimeout ) ) { logger . warn ( <str> , initialStateTimeout ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new ElasticsearchTimeoutException ( <str> ) ; } } @Override protected void doStop ( ) { if ( initialStateListener ! = null ) { discovery . removeListener ( initialStateListener ) ; } discovery . stop ( ) ; } @Override protected void doClose ( ) { discovery . close ( ) ; } public DiscoveryNode localNode ( ) { return discovery . localNode ( ) ; } public String nodeDescription ( ) { return discovery . nodeDescription ( ) ; } public void publish ( ClusterChangedEvent clusterChangedEvent , Discovery . AckListener ackListener ) { if ( lifecycle . started ( ) ) { discovery . publish ( clusterChangedEvent , ackListener ) ; } } public static String generateNodeId ( Settings settings ) { Random random = Randomness . get ( settings , DiscoveryService . SETTING_DISCOVERY_SEED ) ; return Strings . randomBase64UUID ( random ) ; } } 
