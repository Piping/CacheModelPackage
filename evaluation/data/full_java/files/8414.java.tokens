package org . elasticsearch . routing ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . common . Priority ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . cluster . metadata . AliasAction . newAddAliasAction ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . nullValue ; public class AliasResolveRoutingIT extends ESIntegTestCase { public void testResolveIndexRouting ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . searchRouting ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , nullValue ( ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , nullValue ( ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , nullValue ( ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , equalTo ( <str> ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , equalTo ( <str> ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) , equalTo ( <str> ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( <str> , <str> ) , equalTo ( <str> ) ) ; assertThat ( clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( <str> , <str> ) , equalTo ( <str> ) ) ; try { clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( <str> , <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { clusterService ( ) . state ( ) . metaData ( ) . resolveIndexRouting ( null , <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } public void testResolveSearchRouting ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareAliases ( ) . addAliasAction ( newAddAliasAction ( <str> , <str> ) . routing ( <str> ) ) . execute ( ) . actionGet ( ) ; ClusterState state = clusterService ( ) . state ( ) ; IndexNameExpressionResolver indexNameExpressionResolver = internalCluster ( ) . getInstance ( IndexNameExpressionResolver . class ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , <str> ) , nullValue ( ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , <str> ) , equalTo ( newMap ( <str> , newSet ( <str> , <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , <str> ) , equalTo ( newMap ( <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , <str> ) , equalTo ( newMap ( <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , <str> ) , equalTo ( newMap ( <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , <str> ) , nullValue ( ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , <str> ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> , <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , new String [ ] { <str> , <str> } ) , nullValue ( ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , null , new String [ ] { <str> , <str> } ) , nullValue ( ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , nullValue ( ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> ) , <str> , newSet ( <str> ) ) ) ) ; assertThat ( indexNameExpressionResolver . resolveSearchRouting ( state , <str> , new String [ ] { <str> , <str> , <str> } ) , equalTo ( newMap ( <str> , newSet ( <str> , <str> , <str> ) , <str> , newSet ( <str> ) ) ) ) ; } private < T > Set < T > newSet ( T . . . elements ) { return newHashSet ( elements ) ; } private < K , V > Map < K , V > newMap ( K key , V value ) { Map < K , V > r = new HashMap < > ( ) ; r . put ( key , value ) ; return r ; } private < K , V > Map < K , V > newMap ( K key1 , V value1 , K key2 , V value2 ) { Map < K , V > r = new HashMap < > ( ) ; r . put ( key1 , value1 ) ; r . put ( key2 , value2 ) ; return r ; } } 
