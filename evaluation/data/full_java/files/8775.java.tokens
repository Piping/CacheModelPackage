package org . elasticsearch . script . javascript . support ; import org . mozilla . javascript . Scriptable ; import org . mozilla . javascript . Wrapper ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; public class ScriptableWrappedMap implements ScriptableMap , Wrapper { private Map map ; private Scriptable parentScope ; private Scriptable prototype ; public static ScriptableWrappedMap wrap ( Scriptable scope , Map < Object , Object > map ) { return new ScriptableWrappedMap ( scope , map ) ; } public ScriptableWrappedMap ( Map map ) { this . map = map ; } public ScriptableWrappedMap ( Scriptable scope , Map map ) { this . parentScope = scope ; this . map = map ; } public Object unwrap ( ) { return map ; } public String getClassName ( ) { return <str> ; } public Object get ( String name , Scriptable start ) { if ( <str> . equals ( name ) ) { return map . size ( ) ; } else { return ScriptValueConverter . wrapValue ( this . parentScope ! = null ? this . parentScope : start , map . get ( name ) ) ; } } public Object get ( int index , Scriptable start ) { Object value = null ; int i = <int> ; Iterator itrValues = map . values ( ) . iterator ( ) ; while ( i + + < = index & & itrValues . hasNext ( ) ) { value = itrValues . next ( ) ; } return ScriptValueConverter . wrapValue ( this . parentScope ! = null ? this . parentScope : start , value ) ; } public boolean has ( String name , Scriptable start ) { return map . containsKey ( name ) ; } public boolean has ( int index , Scriptable start ) { return ( index > = <int> & & map . values ( ) . size ( ) > index ) ; } @SuppressWarnings ( <str> ) public void put ( String name , Scriptable start , Object value ) { map . put ( name , ScriptValueConverter . unwrapValue ( value ) ) ; } public void put ( int index , Scriptable start , Object value ) { } public void delete ( String name ) { map . remove ( name ) ; } public void delete ( int index ) { int i = <int> ; Iterator itrKeys = map . keySet ( ) . iterator ( ) ; while ( i < = index & & itrKeys . hasNext ( ) ) { Object key = itrKeys . next ( ) ; if ( i = = index ) { map . remove ( key ) ; break ; } } } public Scriptable getPrototype ( ) { return this . prototype ; } public void setPrototype ( Scriptable prototype ) { this . prototype = prototype ; } public Scriptable getParentScope ( ) { return this . parentScope ; } public void setParentScope ( Scriptable parent ) { this . parentScope = parent ; } public Object [ ] getIds ( ) { return map . keySet ( ) . toArray ( ) ; } public Object getDefaultValue ( Class hint ) { return null ; } public boolean hasInstance ( Scriptable value ) { if ( ! ( value instanceof Wrapper ) ) return false ; Object instance = ( ( Wrapper ) value ) . unwrap ( ) ; return Map . class . isInstance ( instance ) ; } public void clear ( ) { this . map . clear ( ) ; } public boolean containsKey ( Object key ) { return this . map . containsKey ( key ) ; } public boolean containsValue ( Object value ) { return this . map . containsValue ( value ) ; } public Set entrySet ( ) { return this . map . entrySet ( ) ; } public Object get ( Object key ) { return this . map . get ( key ) ; } public boolean isEmpty ( ) { return ( this . map . size ( ) = = <int> ) ; } public Set keySet ( ) { return this . map . keySet ( ) ; } public Object put ( Object key , Object value ) { return this . map . put ( key , value ) ; } public void putAll ( Map t ) { this . map . putAll ( t ) ; } public Object remove ( Object key ) { return this . map . remove ( key ) ; } public int size ( ) { return this . map . size ( ) ; } public Collection values ( ) { return this . map . values ( ) ; } @Override public String toString ( ) { return ( this . map ! = null ? this . map . toString ( ) : super . toString ( ) ) ; } } 
