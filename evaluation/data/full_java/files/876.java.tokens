package org . apache . cassandra . schema ; import java . lang . reflect . InvocationTargetException ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import com . google . common . base . MoreObjects ; import com . google . common . collect . ImmutableMap ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; import org . apache . cassandra . db . compaction . LeveledCompactionStrategy ; import org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . utils . FBUtilities ; import static java . lang . String . format ; public final class CompactionParams { private static final Logger logger = LoggerFactory . getLogger ( CompactionParams . class ) ; public enum Option { CLASS , ENABLED , MIN_THRESHOLD , MAX_THRESHOLD ; @Override public String toString ( ) { return name ( ) . toLowerCase ( ) ; } } public static final int DEFAULT_MIN_THRESHOLD = <int> ; public static final int DEFAULT_MAX_THRESHOLD = <int> ; public static final boolean DEFAULT_ENABLED = true ; public static final Map < String , String > DEFAULT_THRESHOLDS = ImmutableMap . of ( Option . MIN_THRESHOLD . toString ( ) , Integer . toString ( DEFAULT_MIN_THRESHOLD ) , Option . MAX_THRESHOLD . toString ( ) , Integer . toString ( DEFAULT_MAX_THRESHOLD ) ) ; public static final CompactionParams DEFAULT = new CompactionParams ( SizeTieredCompactionStrategy . class , DEFAULT_THRESHOLDS , DEFAULT_ENABLED ) ; private final Class < ? extends AbstractCompactionStrategy > klass ; private final ImmutableMap < String , String > options ; private final boolean isEnabled ; private CompactionParams ( Class < ? extends AbstractCompactionStrategy > klass , Map < String , String > options , boolean isEnabled ) { this . klass = klass ; this . options = ImmutableMap . copyOf ( options ) ; this . isEnabled = isEnabled ; } public static CompactionParams create ( Class < ? extends AbstractCompactionStrategy > klass , Map < String , String > options ) { boolean isEnabled = options . containsKey ( Option . ENABLED . toString ( ) ) ? Boolean . parseBoolean ( options . get ( Option . ENABLED . toString ( ) ) ) : DEFAULT_ENABLED ; Map < String , String > allOptions = new HashMap < > ( options ) ; if ( supportsThresholdParams ( klass ) ) { allOptions . putIfAbsent ( Option . MIN_THRESHOLD . toString ( ) , Integer . toString ( DEFAULT_MIN_THRESHOLD ) ) ; allOptions . putIfAbsent ( Option . MAX_THRESHOLD . toString ( ) , Integer . toString ( DEFAULT_MAX_THRESHOLD ) ) ; } return new CompactionParams ( klass , allOptions , isEnabled ) ; } public static CompactionParams scts ( Map < String , String > options ) { return create ( SizeTieredCompactionStrategy . class , options ) ; } public static CompactionParams lcs ( Map < String , String > options ) { return create ( LeveledCompactionStrategy . class , options ) ; } public int minCompactionThreshold ( ) { String threshold = options . get ( Option . MIN_THRESHOLD . toString ( ) ) ; return threshold = = null ? DEFAULT_MIN_THRESHOLD : Integer . parseInt ( threshold ) ; } public int maxCompactionThreshold ( ) { String threshold = options . get ( Option . MAX_THRESHOLD . toString ( ) ) ; return threshold = = null ? DEFAULT_MAX_THRESHOLD : Integer . parseInt ( threshold ) ; } public void validate ( ) { try { Map < ? , ? > unknownOptions = ( Map ) klass . getMethod ( <str> , Map . class ) . invoke ( null , options ) ; if ( ! unknownOptions . isEmpty ( ) ) { throw new ConfigurationException ( format ( <str> , unknownOptions . keySet ( ) , klass . getSimpleName ( ) ) ) ; } } catch ( NoSuchMethodException e ) { logger . warn ( <str> , klass . getName ( ) ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof ConfigurationException ) throw ( ConfigurationException ) e . getTargetException ( ) ; Throwable cause = e . getCause ( ) = = null ? e : e . getCause ( ) ; throw new ConfigurationException ( format ( <str> , klass . getName ( ) , cause . getClass ( ) . getName ( ) , cause . getMessage ( ) ) , e ) ; } catch ( IllegalAccessException e ) { throw new ConfigurationException ( <str> + klass . getName ( ) , e ) ; } String minThreshold = options . get ( Option . MIN_THRESHOLD . toString ( ) ) ; if ( minThreshold ! = null & & ! StringUtils . isNumeric ( minThreshold ) ) { throw new ConfigurationException ( format ( <str> , minThreshold , Option . MIN_THRESHOLD ) ) ; } String maxThreshold = options . get ( Option . MAX_THRESHOLD . toString ( ) ) ; if ( maxThreshold ! = null & & ! StringUtils . isNumeric ( maxThreshold ) ) { throw new ConfigurationException ( format ( <str> , maxThreshold , Option . MAX_THRESHOLD ) ) ; } if ( minCompactionThreshold ( ) < = <int> | | maxCompactionThreshold ( ) < = <int> ) { throw new ConfigurationException ( <str> + <str> ) ; } if ( minCompactionThreshold ( ) < = <int> ) { throw new ConfigurationException ( format ( <str> , minCompactionThreshold ( ) ) ) ; } if ( minCompactionThreshold ( ) > maxCompactionThreshold ( ) ) { throw new ConfigurationException ( format ( <str> , minCompactionThreshold ( ) , maxCompactionThreshold ( ) ) ) ; } } double defaultBloomFilterFbChance ( ) { return klass . equals ( LeveledCompactionStrategy . class ) ? <float> : <float> ; } public Class < ? extends AbstractCompactionStrategy > klass ( ) { return klass ; } public Map < String , String > options ( ) { return options ; } public boolean isEnabled ( ) { return isEnabled ; } public static CompactionParams fromMap ( Map < String , String > map ) { Map < String , String > options = new HashMap < > ( map ) ; String className = options . remove ( Option . CLASS . toString ( ) ) ; if ( className = = null ) { throw new ConfigurationException ( format ( <str> , Option . CLASS , TableParams . Option . COMPACTION ) ) ; } return create ( classFromName ( className ) , options ) ; } private static Class < ? extends AbstractCompactionStrategy > classFromName ( String name ) { String className = name . contains ( <str> ) ? name : <str> + name ; Class < AbstractCompactionStrategy > strategyClass = FBUtilities . classForName ( className , <str> ) ; if ( ! AbstractCompactionStrategy . class . isAssignableFrom ( strategyClass ) ) { throw new ConfigurationException ( format ( <str> , className ) ) ; } return strategyClass ; } @SuppressWarnings ( <str> ) public static boolean supportsThresholdParams ( Class < ? extends AbstractCompactionStrategy > klass ) { try { Map < String , String > unrecognizedOptions = ( Map < String , String > ) klass . getMethod ( <str> , Map . class ) . invoke ( null , DEFAULT_THRESHOLDS ) ; return unrecognizedOptions . isEmpty ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public Map < String , String > asMap ( ) { Map < String , String > map = new HashMap < > ( options ( ) ) ; map . put ( Option . CLASS . toString ( ) , klass . getName ( ) ) ; return map ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( <str> , klass . getName ( ) ) . add ( <str> , options ) . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CompactionParams ) ) return false ; CompactionParams cp = ( CompactionParams ) o ; return klass . equals ( cp . klass ) & & options . equals ( cp . options ) ; } @Override public int hashCode ( ) { return Objects . hash ( klass , options ) ; } } 
