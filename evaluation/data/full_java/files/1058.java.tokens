package org . apache . cassandra . tools ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . utils . OutputHandler ; import org . apache . commons . cli . * ; import java . io . File ; import java . io . IOException ; import java . util . function . BiFunction ; import static org . apache . cassandra . tools . BulkLoader . CmdLineOptions ; public class StandaloneSSTableUtil { private static final String TOOL_NAME = <str> ; private static final String TYPE_OPTION = <str> ; private static final String OP_LOG_OPTION = <str> ; private static final String VERBOSE_OPTION = <str> ; private static final String DEBUG_OPTION = <str> ; private static final String HELP_OPTION = <str> ; private static final String CLEANUP_OPTION = <str> ; public static void main ( String args [ ] ) { Options options = Options . parseArgs ( args ) ; try { Schema . instance . loadFromDisk ( false ) ; CFMetaData metadata = Schema . instance . getCFMetaData ( options . keyspaceName , options . cfName ) ; if ( metadata = = null ) throw new IllegalArgumentException ( String . format ( <str> , options . keyspaceName , options . cfName ) ) ; OutputHandler handler = new OutputHandler . SystemOutput ( options . verbose , options . debug ) ; if ( options . cleanup ) { handler . output ( <str> ) ; LifecycleTransaction . removeUnfinishedLeftovers ( metadata ) ; } else { handler . output ( <str> ) ; listFiles ( options , metadata , handler ) ; } System . exit ( <int> ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; if ( options . debug ) e . printStackTrace ( System . err ) ; System . exit ( <int> ) ; } } private static void listFiles ( Options options , CFMetaData metadata , OutputHandler handler ) throws IOException { Directories directories = new Directories ( metadata ) ; for ( File dir : directories . getCFDirectories ( ) ) { for ( File file : LifecycleTransaction . getFiles ( dir . toPath ( ) , getFilter ( options ) , Directories . OnTxnErr . THROW ) ) handler . output ( file . getCanonicalPath ( ) ) ; } } private static BiFunction < File , Directories . FileType , Boolean > getFilter ( Options options ) { return ( file , type ) - > { switch ( type ) { case FINAL : return options . type ! = Options . FileType . TMP ; case TEMPORARY : return options . type ! = Options . FileType . FINAL ; case TXN_LOG : return options . oplogs ; default : throw new AssertionError ( ) ; } } ; } private static class Options { public enum FileType { ALL ( <str> , <str> ) , TMP ( <str> , <str> ) , FINAL ( <str> , <str> ) ; public String option ; public String descr ; FileType ( String option , String descr ) { this . option = option ; this . descr = descr ; } static FileType fromOption ( String option ) { for ( FileType fileType : FileType . values ( ) ) { if ( fileType . option . equals ( option ) ) return fileType ; } return FileType . ALL ; } static String descr ( ) { StringBuilder str = new StringBuilder ( ) ; for ( FileType fileType : FileType . values ( ) ) { str . append ( fileType . option ) ; str . append ( <str> ) ; str . append ( fileType . descr ) ; str . append ( <str> ) ; } return str . toString ( ) ; } } public final String keyspaceName ; public final String cfName ; public boolean debug ; public boolean verbose ; public boolean oplogs ; public boolean cleanup ; public FileType type ; private Options ( String keyspaceName , String cfName ) { this . keyspaceName = keyspaceName ; this . cfName = cfName ; } public static Options parseArgs ( String cmdArgs [ ] ) { CommandLineParser parser = new GnuParser ( ) ; CmdLineOptions options = getCmdLineOptions ( ) ; try { CommandLine cmd = parser . parse ( options , cmdArgs , false ) ; if ( cmd . hasOption ( HELP_OPTION ) ) { printUsage ( options ) ; System . exit ( <int> ) ; } String [ ] args = cmd . getArgs ( ) ; if ( args . length ! = <int> ) { String msg = args . length < <int> ? <str> : <str> ; System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } String keyspaceName = args [ <int> ] ; String cfName = args [ <int> ] ; Options opts = new Options ( keyspaceName , cfName ) ; opts . debug = cmd . hasOption ( DEBUG_OPTION ) ; opts . verbose = cmd . hasOption ( VERBOSE_OPTION ) ; opts . type = FileType . fromOption ( cmd . getOptionValue ( TYPE_OPTION ) ) ; opts . oplogs = cmd . hasOption ( OP_LOG_OPTION ) ; opts . cleanup = cmd . hasOption ( CLEANUP_OPTION ) ; return opts ; } catch ( ParseException e ) { errorMsg ( e . getMessage ( ) , options ) ; return null ; } } private static void errorMsg ( String msg , CmdLineOptions options ) { System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } private static CmdLineOptions getCmdLineOptions ( ) { CmdLineOptions options = new CmdLineOptions ( ) ; options . addOption ( <str> , CLEANUP_OPTION , <str> ) ; options . addOption ( <str> , DEBUG_OPTION , <str> ) ; options . addOption ( <str> , HELP_OPTION , <str> ) ; options . addOption ( <str> , OP_LOG_OPTION , <str> ) ; options . addOption ( <str> , TYPE_OPTION , true , FileType . descr ( ) ) ; options . addOption ( <str> , VERBOSE_OPTION , <str> ) ; return options ; } public static void printUsage ( CmdLineOptions options ) { String usage = String . format ( <str> , TOOL_NAME ) ; StringBuilder header = new StringBuilder ( ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; header . append ( <str> ) ; new HelpFormatter ( ) . printHelp ( usage , header . toString ( ) , options , <str> ) ; } } } 
