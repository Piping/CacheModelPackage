package io . netty . handler . codec . http . multipart ; import io . netty . handler . codec . http . HttpConstants ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . util . internal . PlatformDependent ; import java . io . IOException ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; public class DefaultHttpDataFactory implements HttpDataFactory { public static final long MINSIZE = <hex> ; public static final long MAXSIZE = - <int> ; private final boolean useDisk ; private final boolean checkSize ; private long minSize ; private long maxSize = MAXSIZE ; private Charset charset = HttpConstants . DEFAULT_CHARSET ; private final Map < HttpRequest , List < HttpData > > requestFileDeleteMap = PlatformDependent . newConcurrentHashMap ( ) ; public DefaultHttpDataFactory ( ) { useDisk = false ; checkSize = true ; minSize = MINSIZE ; } public DefaultHttpDataFactory ( Charset charset ) { this ( ) ; this . charset = charset ; } public DefaultHttpDataFactory ( boolean useDisk ) { this . useDisk = useDisk ; checkSize = false ; } public DefaultHttpDataFactory ( boolean useDisk , Charset charset ) { this ( useDisk ) ; this . charset = charset ; } public DefaultHttpDataFactory ( long minSize ) { useDisk = false ; checkSize = true ; this . minSize = minSize ; } public DefaultHttpDataFactory ( long minSize , Charset charset ) { this ( minSize ) ; this . charset = charset ; } @Override public void setMaxLimit ( long maxSize ) { this . maxSize = maxSize ; } private List < HttpData > getList ( HttpRequest request ) { List < HttpData > list = requestFileDeleteMap . get ( request ) ; if ( list = = null ) { list = new ArrayList < HttpData > ( ) ; requestFileDeleteMap . put ( request , list ) ; } return list ; } @Override public Attribute createAttribute ( HttpRequest request , String name ) { if ( useDisk ) { Attribute attribute = new DiskAttribute ( name , charset ) ; attribute . setMaxSize ( maxSize ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } if ( checkSize ) { Attribute attribute = new MixedAttribute ( name , minSize , charset ) ; attribute . setMaxSize ( maxSize ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } MemoryAttribute attribute = new MemoryAttribute ( name ) ; attribute . setMaxSize ( maxSize ) ; return attribute ; } @Override public Attribute createAttribute ( HttpRequest request , String name , long definedSize ) { if ( useDisk ) { Attribute attribute = new DiskAttribute ( name , definedSize , charset ) ; attribute . setMaxSize ( maxSize ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } if ( checkSize ) { Attribute attribute = new MixedAttribute ( name , definedSize , minSize , charset ) ; attribute . setMaxSize ( maxSize ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } MemoryAttribute attribute = new MemoryAttribute ( name , definedSize ) ; attribute . setMaxSize ( maxSize ) ; return attribute ; } private static void checkHttpDataSize ( HttpData data ) { try { data . checkSize ( data . length ( ) ) ; } catch ( IOException ignored ) { throw new IllegalArgumentException ( <str> ) ; } } @Override public Attribute createAttribute ( HttpRequest request , String name , String value ) { if ( useDisk ) { Attribute attribute ; try { attribute = new DiskAttribute ( name , value , charset ) ; attribute . setMaxSize ( maxSize ) ; } catch ( IOException e ) { attribute = new MixedAttribute ( name , value , minSize , charset ) ; attribute . setMaxSize ( maxSize ) ; } checkHttpDataSize ( attribute ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } if ( checkSize ) { Attribute attribute = new MixedAttribute ( name , value , minSize , charset ) ; attribute . setMaxSize ( maxSize ) ; checkHttpDataSize ( attribute ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( attribute ) ; return attribute ; } try { MemoryAttribute attribute = new MemoryAttribute ( name , value , charset ) ; attribute . setMaxSize ( maxSize ) ; checkHttpDataSize ( attribute ) ; return attribute ; } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } } @Override public FileUpload createFileUpload ( HttpRequest request , String name , String filename , String contentType , String contentTransferEncoding , Charset charset , long size ) { if ( useDisk ) { FileUpload fileUpload = new DiskFileUpload ( name , filename , contentType , contentTransferEncoding , charset , size ) ; fileUpload . setMaxSize ( maxSize ) ; checkHttpDataSize ( fileUpload ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( fileUpload ) ; return fileUpload ; } if ( checkSize ) { FileUpload fileUpload = new MixedFileUpload ( name , filename , contentType , contentTransferEncoding , charset , size , minSize ) ; fileUpload . setMaxSize ( maxSize ) ; checkHttpDataSize ( fileUpload ) ; List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . add ( fileUpload ) ; return fileUpload ; } MemoryFileUpload fileUpload = new MemoryFileUpload ( name , filename , contentType , contentTransferEncoding , charset , size ) ; fileUpload . setMaxSize ( maxSize ) ; checkHttpDataSize ( fileUpload ) ; return fileUpload ; } @Override public void removeHttpDataFromClean ( HttpRequest request , InterfaceHttpData data ) { if ( data instanceof HttpData ) { List < HttpData > fileToDelete = getList ( request ) ; fileToDelete . remove ( data ) ; } } @Override public void cleanRequestHttpData ( HttpRequest request ) { List < HttpData > fileToDelete = requestFileDeleteMap . remove ( request ) ; if ( fileToDelete ! = null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } } @Override public void cleanAllHttpData ( ) { Iterator < Entry < HttpRequest , List < HttpData > > > i = requestFileDeleteMap . entrySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Entry < HttpRequest , List < HttpData > > e = i . next ( ) ; i . remove ( ) ; List < HttpData > fileToDelete = e . getValue ( ) ; if ( fileToDelete ! = null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } } } @Override public void cleanRequestHttpDatas ( HttpRequest request ) { cleanRequestHttpData ( request ) ; } @Override public void cleanAllHttpDatas ( ) { cleanAllHttpData ( ) ; } } 
