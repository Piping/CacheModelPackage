package io . netty . handler . codec . spdy ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; public class SpdyHeaderBlockRawDecoder extends SpdyHeaderBlockDecoder { private static final int LENGTH_FIELD_SIZE = <int> ; private final int maxHeaderSize ; private State state ; private ByteBuf cumulation ; private int headerSize ; private int numHeaders ; private int length ; private String name ; private enum State { READ_NUM_HEADERS , READ_NAME_LENGTH , READ_NAME , SKIP_NAME , READ_VALUE_LENGTH , READ_VALUE , SKIP_VALUE , END_HEADER_BLOCK , ERROR } public SpdyHeaderBlockRawDecoder ( SpdyVersion spdyVersion , int maxHeaderSize ) { if ( spdyVersion = = null ) { throw new NullPointerException ( <str> ) ; } this . maxHeaderSize = maxHeaderSize ; state = State . READ_NUM_HEADERS ; } private static int readLengthField ( ByteBuf buffer ) { int length = getSignedInt ( buffer , buffer . readerIndex ( ) ) ; buffer . skipBytes ( LENGTH_FIELD_SIZE ) ; return length ; } @Override void decode ( ByteBufAllocator alloc , ByteBuf headerBlock , SpdyHeadersFrame frame ) throws Exception { if ( headerBlock = = null ) { throw new NullPointerException ( <str> ) ; } if ( frame = = null ) { throw new NullPointerException ( <str> ) ; } if ( cumulation = = null ) { decodeHeaderBlock ( headerBlock , frame ) ; if ( headerBlock . isReadable ( ) ) { cumulation = alloc . buffer ( headerBlock . readableBytes ( ) ) ; cumulation . writeBytes ( headerBlock ) ; } } else { cumulation . writeBytes ( headerBlock ) ; decodeHeaderBlock ( cumulation , frame ) ; if ( cumulation . isReadable ( ) ) { cumulation . discardReadBytes ( ) ; } else { releaseBuffer ( ) ; } } } protected void decodeHeaderBlock ( ByteBuf headerBlock , SpdyHeadersFrame frame ) throws Exception { int skipLength ; while ( headerBlock . isReadable ( ) ) { switch ( state ) { case READ_NUM_HEADERS : if ( headerBlock . readableBytes ( ) < LENGTH_FIELD_SIZE ) { return ; } numHeaders = readLengthField ( headerBlock ) ; if ( numHeaders < <int> ) { state = State . ERROR ; frame . setInvalid ( ) ; } else if ( numHeaders = = <int> ) { state = State . END_HEADER_BLOCK ; } else { state = State . READ_NAME_LENGTH ; } break ; case READ_NAME_LENGTH : if ( headerBlock . readableBytes ( ) < LENGTH_FIELD_SIZE ) { return ; } length = readLengthField ( headerBlock ) ; if ( length < = <int> ) { state = State . ERROR ; frame . setInvalid ( ) ; } else if ( length > maxHeaderSize | | headerSize > maxHeaderSize - length ) { headerSize = maxHeaderSize + <int> ; state = State . SKIP_NAME ; frame . setTruncated ( ) ; } else { headerSize + = length ; state = State . READ_NAME ; } break ; case READ_NAME : if ( headerBlock . readableBytes ( ) < length ) { return ; } byte [ ] nameBytes = new byte [ length ] ; headerBlock . readBytes ( nameBytes ) ; name = new String ( nameBytes , <str> ) ; if ( frame . headers ( ) . contains ( name ) ) { state = State . ERROR ; frame . setInvalid ( ) ; } else { state = State . READ_VALUE_LENGTH ; } break ; case SKIP_NAME : skipLength = Math . min ( headerBlock . readableBytes ( ) , length ) ; headerBlock . skipBytes ( skipLength ) ; length - = skipLength ; if ( length = = <int> ) { state = State . READ_VALUE_LENGTH ; } break ; case READ_VALUE_LENGTH : if ( headerBlock . readableBytes ( ) < LENGTH_FIELD_SIZE ) { return ; } length = readLengthField ( headerBlock ) ; if ( length < <int> ) { state = State . ERROR ; frame . setInvalid ( ) ; } else if ( length = = <int> ) { if ( ! frame . isTruncated ( ) ) { frame . headers ( ) . add ( name , <str> ) ; } name = null ; if ( - - numHeaders = = <int> ) { state = State . END_HEADER_BLOCK ; } else { state = State . READ_NAME_LENGTH ; } } else if ( length > maxHeaderSize | | headerSize > maxHeaderSize - length ) { headerSize = maxHeaderSize + <int> ; name = null ; state = State . SKIP_VALUE ; frame . setTruncated ( ) ; } else { headerSize + = length ; state = State . READ_VALUE ; } break ; case READ_VALUE : if ( headerBlock . readableBytes ( ) < length ) { return ; } byte [ ] valueBytes = new byte [ length ] ; headerBlock . readBytes ( valueBytes ) ; int index = <int> ; int offset = <int> ; if ( valueBytes [ <int> ] = = ( byte ) <int> ) { state = State . ERROR ; frame . setInvalid ( ) ; break ; } while ( index < length ) { while ( index < valueBytes . length & & valueBytes [ index ] ! = ( byte ) <int> ) { index + + ; } if ( index < valueBytes . length ) { if ( index + <int> = = valueBytes . length | | valueBytes [ index + <int> ] = = ( byte ) <int> ) { state = State . ERROR ; frame . setInvalid ( ) ; break ; } } String value = new String ( valueBytes , offset , index - offset , <str> ) ; try { frame . headers ( ) . add ( name , value ) ; } catch ( IllegalArgumentException e ) { state = State . ERROR ; frame . setInvalid ( ) ; break ; } index + + ; offset = index ; } name = null ; if ( state = = State . ERROR ) { break ; } if ( - - numHeaders = = <int> ) { state = State . END_HEADER_BLOCK ; } else { state = State . READ_NAME_LENGTH ; } break ; case SKIP_VALUE : skipLength = Math . min ( headerBlock . readableBytes ( ) , length ) ; headerBlock . skipBytes ( skipLength ) ; length - = skipLength ; if ( length = = <int> ) { if ( - - numHeaders = = <int> ) { state = State . END_HEADER_BLOCK ; } else { state = State . READ_NAME_LENGTH ; } } break ; case END_HEADER_BLOCK : state = State . ERROR ; frame . setInvalid ( ) ; break ; case ERROR : headerBlock . skipBytes ( headerBlock . readableBytes ( ) ) ; return ; default: throw new Error ( <str> ) ; } } } @Override void endHeaderBlock ( SpdyHeadersFrame frame ) throws Exception { if ( state ! = State . END_HEADER_BLOCK ) { frame . setInvalid ( ) ; } releaseBuffer ( ) ; headerSize = <int> ; name = null ; state = State . READ_NUM_HEADERS ; } @Override void end ( ) { releaseBuffer ( ) ; } private void releaseBuffer ( ) { if ( cumulation ! = null ) { cumulation . release ( ) ; cumulation = null ; } } } 
