package org . elasticsearch . index . mapper . core ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . MapperTestUtils ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . VersionUtils ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . core . IsEqual . equalTo ; public class MultiFieldCopyToMapperTests extends ESTestCase { public void testExceptionForCopyToInMultiFields ( ) throws IOException { XContentBuilder mapping = createMappinmgWithCopyToInMultiField ( ) ; Tuple < List < Version > , List < Version > > versionsWithAndWithoutExpectedExceptions = versionsWithAndWithoutExpectedExceptions ( ) ; Version indexVersion = randomFrom ( versionsWithAndWithoutExpectedExceptions . v1 ( ) ) ; MapperService mapperService = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , indexVersion ) . build ( ) ) ; try { mapperService . parse ( <str> , new CompressedXContent ( mapping . string ( ) ) , true ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } indexVersion = randomFrom ( versionsWithAndWithoutExpectedExceptions . v2 ( ) ) ; mapperService = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , indexVersion ) . build ( ) ) ; DocumentMapper documentMapper = mapperService . parse ( <str> , new CompressedXContent ( mapping . string ( ) ) , true ) ; assertFalse ( documentMapper . mapping ( ) . toString ( ) . contains ( <str> ) ) ; } private static XContentBuilder createMappinmgWithCopyToInMultiField ( ) throws IOException { XContentBuilder mapping = jsonBuilder ( ) ; mapping . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; return mapping ; } private static Tuple < List < Version > , List < Version > > versionsWithAndWithoutExpectedExceptions ( ) { List < Version > versionsWithException = new ArrayList < > ( ) ; List < Version > versionsWithoutException = new ArrayList < > ( ) ; for ( Version version : VersionUtils . allVersions ( ) ) { if ( version . after ( Version . V_2_1_0 ) | | ( version . after ( Version . V_2_0_1 ) & & version . before ( Version . V_2_1_0 ) ) ) { versionsWithException . add ( version ) ; } else { versionsWithoutException . add ( version ) ; } } return new Tuple < > ( versionsWithException , versionsWithoutException ) ; } } 
