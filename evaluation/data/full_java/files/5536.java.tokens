package org . elasticsearch . cluster ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . cluster . ClusterState . Custom ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class RestoreInProgress extends AbstractDiffable < Custom > implements Custom { public static final String TYPE = <str> ; public static final RestoreInProgress PROTO = new RestoreInProgress ( ) ; private final List < Entry > entries ; public RestoreInProgress ( List < Entry > entries ) { this . entries = entries ; } public RestoreInProgress ( Entry . . . entries ) { this . entries = Arrays . asList ( entries ) ; } public List < Entry > entries ( ) { return this . entries ; } public Entry snapshot ( SnapshotId snapshotId ) { for ( Entry entry : entries ) { if ( snapshotId . equals ( entry . snapshotId ( ) ) ) { return entry ; } } return null ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; RestoreInProgress that = ( RestoreInProgress ) o ; if ( ! entries . equals ( that . entries ) ) return false ; return true ; } @Override public int hashCode ( ) { return entries . hashCode ( ) ; } public static class Entry { private final State state ; private final SnapshotId snapshotId ; private final ImmutableOpenMap < ShardId , ShardRestoreStatus > shards ; private final List < String > indices ; public Entry ( SnapshotId snapshotId , State state , List < String > indices , ImmutableOpenMap < ShardId , ShardRestoreStatus > shards ) { this . snapshotId = snapshotId ; this . state = state ; this . indices = indices ; if ( shards = = null ) { this . shards = ImmutableOpenMap . of ( ) ; } else { this . shards = shards ; } } public SnapshotId snapshotId ( ) { return this . snapshotId ; } public ImmutableOpenMap < ShardId , ShardRestoreStatus > shards ( ) { return this . shards ; } public State state ( ) { return state ; } public List < String > indices ( ) { return indices ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Entry entry = ( Entry ) o ; if ( ! indices . equals ( entry . indices ) ) return false ; if ( ! snapshotId . equals ( entry . snapshotId ) ) return false ; if ( ! shards . equals ( entry . shards ) ) return false ; if ( state ! = entry . state ) return false ; return true ; } @Override public int hashCode ( ) { int result = state . hashCode ( ) ; result = <int> * result + snapshotId . hashCode ( ) ; result = <int> * result + shards . hashCode ( ) ; result = <int> * result + indices . hashCode ( ) ; return result ; } } public static class ShardRestoreStatus { private State state ; private String nodeId ; private String reason ; private ShardRestoreStatus ( ) { } public ShardRestoreStatus ( String nodeId ) { this ( nodeId , State . INIT ) ; } public ShardRestoreStatus ( String nodeId , State state ) { this ( nodeId , state , null ) ; } public ShardRestoreStatus ( String nodeId , State state , String reason ) { this . nodeId = nodeId ; this . state = state ; this . reason = reason ; } public State state ( ) { return state ; } public String nodeId ( ) { return nodeId ; } public String reason ( ) { return reason ; } public static ShardRestoreStatus readShardRestoreStatus ( StreamInput in ) throws IOException { ShardRestoreStatus shardSnapshotStatus = new ShardRestoreStatus ( ) ; shardSnapshotStatus . readFrom ( in ) ; return shardSnapshotStatus ; } public void readFrom ( StreamInput in ) throws IOException { nodeId = in . readOptionalString ( ) ; state = State . fromValue ( in . readByte ( ) ) ; reason = in . readOptionalString ( ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeOptionalString ( nodeId ) ; out . writeByte ( state . value ) ; out . writeOptionalString ( reason ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; ShardRestoreStatus status = ( ShardRestoreStatus ) o ; if ( nodeId ! = null ? ! nodeId . equals ( status . nodeId ) : status . nodeId ! = null ) return false ; if ( reason ! = null ? ! reason . equals ( status . reason ) : status . reason ! = null ) return false ; if ( state ! = status . state ) return false ; return true ; } @Override public int hashCode ( ) { int result = state ! = null ? state . hashCode ( ) : <int> ; result = <int> * result + ( nodeId ! = null ? nodeId . hashCode ( ) : <int> ) ; result = <int> * result + ( reason ! = null ? reason . hashCode ( ) : <int> ) ; return result ; } } public static enum State { INIT ( ( byte ) <int> ) , STARTED ( ( byte ) <int> ) , SUCCESS ( ( byte ) <int> ) , FAILURE ( ( byte ) <int> ) ; private byte value ; State ( byte value ) { this . value = value ; } public byte value ( ) { return value ; } public boolean completed ( ) { return this = = SUCCESS | | this = = FAILURE ; } public static State fromValue ( byte value ) { switch ( value ) { case <int> : return INIT ; case <int> : return STARTED ; case <int> : return SUCCESS ; case <int> : return FAILURE ; default : throw new IllegalArgumentException ( <str> + value + <str> ) ; } } } @Override public String type ( ) { return TYPE ; } @Override public RestoreInProgress readFrom ( StreamInput in ) throws IOException { Entry [ ] entries = new Entry [ in . readVInt ( ) ] ; for ( int i = <int> ; i < entries . length ; i + + ) { SnapshotId snapshotId = SnapshotId . readSnapshotId ( in ) ; State state = State . fromValue ( in . readByte ( ) ) ; int indices = in . readVInt ( ) ; List < String > indexBuilder = new ArrayList < > ( ) ; for ( int j = <int> ; j < indices ; j + + ) { indexBuilder . add ( in . readString ( ) ) ; } ImmutableOpenMap . Builder < ShardId , ShardRestoreStatus > builder = ImmutableOpenMap . builder ( ) ; int shards = in . readVInt ( ) ; for ( int j = <int> ; j < shards ; j + + ) { ShardId shardId = ShardId . readShardId ( in ) ; ShardRestoreStatus shardState = ShardRestoreStatus . readShardRestoreStatus ( in ) ; builder . put ( shardId , shardState ) ; } entries [ i ] = new Entry ( snapshotId , state , Collections . unmodifiableList ( indexBuilder ) , builder . build ( ) ) ; } return new RestoreInProgress ( entries ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( entries . size ( ) ) ; for ( Entry entry : entries ) { entry . snapshotId ( ) . writeTo ( out ) ; out . writeByte ( entry . state ( ) . value ( ) ) ; out . writeVInt ( entry . indices ( ) . size ( ) ) ; for ( String index : entry . indices ( ) ) { out . writeString ( index ) ; } out . writeVInt ( entry . shards ( ) . size ( ) ) ; for ( ObjectObjectCursor < ShardId , ShardRestoreStatus > shardEntry : entry . shards ( ) ) { shardEntry . key . writeTo ( out ) ; shardEntry . value . writeTo ( out ) ; } } } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startArray ( <str> ) ; for ( Entry entry : entries ) { toXContent ( entry , builder , params ) ; } builder . endArray ( ) ; return builder ; } public void toXContent ( Entry entry , XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( ) ; builder . field ( <str> , entry . snapshotId ( ) . getSnapshot ( ) ) ; builder . field ( <str> , entry . snapshotId ( ) . getRepository ( ) ) ; builder . field ( <str> , entry . state ( ) ) ; builder . startArray ( <str> ) ; { for ( String index : entry . indices ( ) ) { builder . value ( index ) ; } } builder . endArray ( ) ; builder . startArray ( <str> ) ; { for ( ObjectObjectCursor < ShardId , ShardRestoreStatus > shardEntry : entry . shards ) { ShardId shardId = shardEntry . key ; ShardRestoreStatus status = shardEntry . value ; builder . startObject ( ) ; { builder . field ( <str> , shardId . getIndex ( ) ) ; builder . field ( <str> , shardId . getId ( ) ) ; builder . field ( <str> , status . state ( ) ) ; } builder . endObject ( ) ; } } builder . endArray ( ) ; builder . endObject ( ) ; } } 
