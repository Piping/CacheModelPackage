package org . apache . cassandra . db . commitlog ; import java . io . * ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import com . google . common . util . concurrent . RateLimiter ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . db . commitlog . CommitLogUpgradeTest . * ; public class CommitLogUpgradeTestMaker { public static ByteBuffer dataSource ; private static int NUM_THREADS = <int> * Runtime . getRuntime ( ) . availableProcessors ( ) - <int> ; public static int numCells = <int> ; public static int cellSize = <int> ; public static int rateLimit = <int> ; public static int runTimeMs = <int> ; public static void main ( String [ ] args ) throws Exception { try { initialize ( ) ; CommitLogUpgradeTestMaker tester = new CommitLogUpgradeTestMaker ( ) ; tester . makeLog ( ) ; } catch ( Throwable e ) { e . printStackTrace ( System . err ) ; } finally { System . exit ( <int> ) ; } } volatile boolean stop = false ; boolean randomSize = true ; static public void initialize ( ) throws IOException , ConfigurationException { try ( FileInputStream fis = new FileInputStream ( <str> ) ) { dataSource = ByteBuffer . allocateDirect ( ( int ) fis . getChannel ( ) . size ( ) ) ; while ( dataSource . hasRemaining ( ) ) { fis . getChannel ( ) . read ( dataSource ) ; } dataSource . flip ( ) ; } SchemaLoader . loadSchema ( ) ; SchemaLoader . schemaDefinition ( <str> ) ; } public void makeLog ( ) throws IOException , InterruptedException { CommitLog commitLog = CommitLog . instance ; System . out . format ( <str> , mb ( DatabaseDescriptor . getCommitLogSegmentSize ( ) ) , commitLog . compressor ! = null ? commitLog . compressor . getClass ( ) . getSimpleName ( ) : <str> , commitLog . executor . getClass ( ) . getSimpleName ( ) , randomSize ? <str> : <str> ) ; final List < CommitlogExecutor > threads = new ArrayList < > ( ) ; ScheduledExecutorService scheduled = startThreads ( commitLog , threads ) ; Thread . sleep ( runTimeMs ) ; stop = true ; scheduled . shutdown ( ) ; scheduled . awaitTermination ( <int> , TimeUnit . SECONDS ) ; int hash = <int> ; int cells = <int> ; for ( CommitlogExecutor t : threads ) { t . join ( ) ; hash + = t . hash ; cells + = t . cells ; } commitLog . shutdownBlocking ( ) ; File dataDir = new File ( CommitLogUpgradeTest . DATA_DIR + FBUtilities . getReleaseVersionString ( ) ) ; System . out . format ( <str> , dataDir ) ; if ( dataDir . exists ( ) ) FileUtils . deleteRecursive ( dataDir ) ; dataDir . mkdirs ( ) ; for ( File f : new File ( DatabaseDescriptor . getCommitLogLocation ( ) ) . listFiles ( ) ) FileUtils . createHardLink ( f , new File ( dataDir , f . getName ( ) ) ) ; Properties prop = new Properties ( ) ; prop . setProperty ( CFID_PROPERTY , Schema . instance . getId ( KEYSPACE , TABLE ) . toString ( ) ) ; prop . setProperty ( CELLS_PROPERTY , Integer . toString ( cells ) ) ; prop . setProperty ( HASH_PROPERTY , Integer . toString ( hash ) ) ; prop . store ( new FileOutputStream ( new File ( dataDir , PROPERTIES_FILE ) ) , <str> + FBUtilities . getReleaseVersionString ( ) ) ; System . out . println ( <str> ) ; } public ScheduledExecutorService startThreads ( CommitLog commitLog , final List < CommitlogExecutor > threads ) { stop = false ; for ( int ii = <int> ; ii < NUM_THREADS ; ii + + ) { final CommitlogExecutor t = new CommitlogExecutor ( commitLog ) ; threads . add ( t ) ; t . start ( ) ; } final long start = System . currentTimeMillis ( ) ; Runnable printRunnable = new Runnable ( ) { long lastUpdate = <int> ; public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; long maxMemory = mb ( runtime . maxMemory ( ) ) ; long allocatedMemory = mb ( runtime . totalMemory ( ) ) ; long freeMemory = mb ( runtime . freeMemory ( ) ) ; long temp = <int> ; long sz = <int> ; for ( CommitlogExecutor cle : threads ) { temp + = cle . counter . get ( ) ; sz + = cle . dataSize ; } double time = ( System . currentTimeMillis ( ) - start ) / <float> ; double avg = ( temp / time ) ; System . out . println ( String . format ( <str> , ( ( System . currentTimeMillis ( ) - start ) / <int> ) , maxMemory , allocatedMemory , freeMemory , ( temp - lastUpdate ) , lastUpdate , avg , mb ( sz / time ) ) ) ; lastUpdate = temp ; } } ; ScheduledExecutorService scheduled = Executors . newScheduledThreadPool ( <int> ) ; scheduled . scheduleAtFixedRate ( printRunnable , <int> , <int> , TimeUnit . SECONDS ) ; return scheduled ; } private static long mb ( long maxMemory ) { return maxMemory / ( <int> * <int> ) ; } private static double mb ( double maxMemory ) { return maxMemory / ( <int> * <int> ) ; } public static ByteBuffer randomBytes ( int quantity , ThreadLocalRandom tlr ) { ByteBuffer slice = ByteBuffer . allocate ( quantity ) ; ByteBuffer source = dataSource . duplicate ( ) ; source . position ( tlr . nextInt ( source . capacity ( ) - quantity ) ) ; source . limit ( source . position ( ) + quantity ) ; slice . put ( source ) ; slice . flip ( ) ; return slice ; } public class CommitlogExecutor extends Thread { final AtomicLong counter = new AtomicLong ( ) ; int hash = <int> ; int cells = <int> ; int dataSize = <int> ; final CommitLog commitLog ; volatile ReplayPosition rp ; public CommitlogExecutor ( CommitLog commitLog ) { this . commitLog = commitLog ; } public void run ( ) { RateLimiter rl = rateLimit ! = <int> ? RateLimiter . create ( rateLimit ) : null ; final ThreadLocalRandom tlr = ThreadLocalRandom . current ( ) ; while ( ! stop ) { if ( rl ! = null ) rl . acquire ( ) ; String ks = KEYSPACE ; ByteBuffer key = randomBytes ( <int> , tlr ) ; UpdateBuilder builder = UpdateBuilder . create ( Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) , Util . dk ( key ) ) ; for ( int ii = <int> ; ii < numCells ; ii + + ) { int sz = randomSize ? tlr . nextInt ( cellSize ) : cellSize ; ByteBuffer bytes = randomBytes ( sz , tlr ) ; builder . newRow ( CommitLogUpgradeTest . CELLNAME + ii ) . add ( <str> , bytes ) ; hash = hash ( hash , bytes ) ; + + cells ; dataSize + = sz ; } rp = commitLog . add ( ( Mutation ) builder . makeMutation ( ) ) ; counter . incrementAndGet ( ) ; } } } } 
