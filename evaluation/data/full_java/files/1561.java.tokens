package org . apache . cassandra . io . sstable ; import java . io . File ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import com . google . common . io . Files ; import org . junit . After ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . streaming . StreamEvent ; import org . apache . cassandra . streaming . StreamEventHandler ; import org . apache . cassandra . streaming . StreamState ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . OutputHandler ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class SSTableLoaderTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD1 = <str> ; public static final String CF_STANDARD2 = <str> ; private File tmpdir ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 ) ) ; StorageService . instance . initServer ( ) ; } @Before public void setup ( ) throws Exception { tmpdir = Files . createTempDir ( ) ; } @After public void cleanup ( ) { try { FileUtils . deleteRecursive ( tmpdir ) ; } catch ( FSWriteError e ) { System . gc ( ) ; FileUtils . deleteRecursive ( tmpdir ) ; } } private static final class TestClient extends SSTableLoader . Client { private String keyspace ; public void init ( String keyspace ) { this . keyspace = keyspace ; for ( Range < Token > range : StorageService . instance . getLocalRanges ( KEYSPACE1 ) ) addRangeForEndpoint ( range , FBUtilities . getBroadcastAddress ( ) ) ; } public CFMetaData getTableMetadata ( String tableName ) { return Schema . instance . getCFMetaData ( keyspace , tableName ) ; } } @Test public void testLoadingSSTable ( ) throws Exception { File dataDir = new File ( tmpdir . getAbsolutePath ( ) + File . separator + KEYSPACE1 + File . separator + CF_STANDARD1 ) ; assert dataDir . mkdirs ( ) ; CFMetaData cfmeta = Schema . instance . getCFMetaData ( KEYSPACE1 , CF_STANDARD1 ) ; String schema = <str> ; String query = <str> ; try ( CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( String . format ( schema , KEYSPACE1 , CF_STANDARD1 ) ) . using ( String . format ( query , KEYSPACE1 , CF_STANDARD1 ) ) . build ( ) ) { writer . addRow ( <str> , <str> , <str> ) ; } ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; cfs . forceBlockingFlush ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; SSTableLoader loader = new SSTableLoader ( dataDir , new TestClient ( ) , new OutputHandler . SystemOutput ( false , false ) ) ; loader . stream ( Collections . emptySet ( ) , completionStreamListener ( latch ) ) . get ( ) ; List < FilteredPartition > partitions = Util . getAll ( Util . cmd ( cfs ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertEquals ( <str> , AsciiType . instance . getString ( partitions . get ( <int> ) . partitionKey ( ) . getKey ( ) ) ) ; assertEquals ( ByteBufferUtil . bytes ( <str> ) , partitions . get ( <int> ) . getRow ( new Clustering ( ByteBufferUtil . bytes ( <str> ) ) ) . getCell ( cfmeta . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ) . value ( ) ) ; latch . await ( ) ; } @Test public void testLoadingIncompleteSSTable ( ) throws Exception { File dataDir = new File ( tmpdir . getAbsolutePath ( ) + File . separator + KEYSPACE1 + File . separator + CF_STANDARD2 ) ; assert dataDir . mkdirs ( ) ; assertTrue ( dataDir . listFiles ( ) . length = = <int> ) ; String schema = <str> ; String query = <str> ; CQLSSTableWriter writer = CQLSSTableWriter . builder ( ) . inDirectory ( dataDir ) . forTable ( String . format ( schema , KEYSPACE1 , CF_STANDARD2 ) ) . using ( String . format ( query , KEYSPACE1 , CF_STANDARD2 ) ) . withBufferSizeInMB ( <int> ) . build ( ) ; int NB_PARTITIONS = <int> ; for ( int i = <int> ; i < NB_PARTITIONS ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) writer . addRow ( String . format ( <str> , i ) , String . format ( <str> , j ) , <str> ) ; } ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD2 ) ; cfs . forceBlockingFlush ( ) ; assertTrue ( dataDir . listFiles ( ) . length > <int> ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; SSTableLoader loader = new SSTableLoader ( dataDir , new TestClient ( ) , new OutputHandler . SystemOutput ( false , false ) ) ; loader . stream ( Collections . emptySet ( ) , completionStreamListener ( latch ) ) . get ( ) ; List < FilteredPartition > partitions = Util . getAll ( Util . cmd ( cfs ) . build ( ) ) ; assertTrue ( partitions . size ( ) > <int> & & partitions . size ( ) < NB_PARTITIONS ) ; writer . close ( ) ; loader = new SSTableLoader ( dataDir , new TestClient ( ) , new OutputHandler . SystemOutput ( false , false ) ) ; loader . stream ( Collections . emptySet ( ) , completionStreamListener ( latch ) ) . get ( ) ; partitions = Util . getAll ( Util . cmd ( Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD2 ) ) . build ( ) ) ; assertEquals ( NB_PARTITIONS , partitions . size ( ) ) ; latch . await ( ) ; } StreamEventHandler completionStreamListener ( final CountDownLatch latch ) { return new StreamEventHandler ( ) { public void onFailure ( Throwable arg0 ) { latch . countDown ( ) ; } public void onSuccess ( StreamState arg0 ) { latch . countDown ( ) ; } public void handleStreamEvent ( StreamEvent event ) { } } ; } } 
