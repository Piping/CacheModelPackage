package org . gradle . launcher . daemon . client ; import org . gradle . api . GradleException ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . classpath . DefaultGradleDistributionLocator ; import org . gradle . api . internal . classpath . DefaultModuleRegistry ; import org . gradle . api . internal . classpath . Module ; import org . gradle . api . internal . classpath . ModuleRegistry ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . internal . serialize . FlushableEncoder ; import org . gradle . internal . serialize . kryo . KryoBackedEncoder ; import org . gradle . launcher . daemon . DaemonExecHandleBuilder ; import org . gradle . launcher . daemon . bootstrap . DaemonGreeter ; import org . gradle . launcher . daemon . bootstrap . DaemonOutputConsumer ; import org . gradle . launcher . daemon . bootstrap . GradleDaemon ; import org . gradle . launcher . daemon . configuration . DaemonParameters ; import org . gradle . launcher . daemon . diagnostics . DaemonStartupInfo ; import org . gradle . launcher . daemon . registry . DaemonDir ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . ExecHandle ; import org . gradle . process . internal . child . EncodedStream ; import org . gradle . util . Clock ; import org . gradle . util . CollectionUtils ; import org . gradle . util . GFileUtils ; import org . gradle . util . GradleVersion ; import java . io . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class DefaultDaemonStarter implements DaemonStarter { private static final Logger LOGGER = Logging . getLogger ( DefaultDaemonStarter . class ) ; private final DaemonDir daemonDir ; private final DaemonParameters daemonParameters ; private final DaemonGreeter daemonGreeter ; private final DaemonStartListener listener ; private final JvmVersionValidator versionValidator ; public DefaultDaemonStarter ( DaemonDir daemonDir , DaemonParameters daemonParameters , DaemonGreeter daemonGreeter , DaemonStartListener listener , JvmVersionValidator versionValidator ) { this . daemonDir = daemonDir ; this . daemonParameters = daemonParameters ; this . daemonGreeter = daemonGreeter ; this . listener = listener ; this . versionValidator = versionValidator ; } public DaemonStartupInfo startDaemon ( ) { ModuleRegistry registry = new DefaultModuleRegistry ( ) ; ClassPath classpath ; List < File > searchClassPath ; if ( new DefaultGradleDistributionLocator ( ) . getGradleHome ( ) ! = null ) { classpath = registry . getModule ( <str> ) . getImplementationClasspath ( ) ; searchClassPath = Collections . emptyList ( ) ; } else { classpath = new DefaultClassPath ( ) ; for ( Module module : registry . getModule ( <str> ) . getAllRequiredModules ( ) ) { classpath = classpath . plus ( module . getClasspath ( ) ) ; } searchClassPath = registry . getAdditionalClassPath ( ) . getAsFiles ( ) ; } if ( classpath . isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } versionValidator . validate ( daemonParameters ) ; List < String > daemonArgs = new ArrayList < String > ( ) ; daemonArgs . add ( daemonParameters . getEffectiveJvm ( ) . getJavaExecutable ( ) . getAbsolutePath ( ) ) ; List < String > daemonOpts = daemonParameters . getEffectiveJvmArgs ( ) ; daemonArgs . addAll ( daemonOpts ) ; daemonArgs . add ( <str> ) ; daemonArgs . add ( CollectionUtils . join ( File . pathSeparator , classpath . getAsFiles ( ) ) ) ; if ( Boolean . getBoolean ( <str> ) ) { daemonArgs . add ( <str> ) ; daemonArgs . add ( <str> ) ; } LOGGER . debug ( <str> , daemonArgs ) ; daemonArgs . add ( GradleDaemon . class . getName ( ) ) ; daemonArgs . add ( GradleVersion . current ( ) . getVersion ( ) ) ; ByteArrayOutputStream serializedConfig = new ByteArrayOutputStream ( ) ; FlushableEncoder encoder = new KryoBackedEncoder ( new EncodedStream . EncodedOutput ( serializedConfig ) ) ; try { encoder . writeString ( daemonParameters . getGradleUserHomeDir ( ) . getAbsolutePath ( ) ) ; encoder . writeString ( daemonDir . getBaseDir ( ) . getAbsolutePath ( ) ) ; encoder . writeSmallInt ( daemonParameters . getIdleTimeout ( ) ) ; encoder . writeString ( daemonParameters . getUid ( ) ) ; encoder . writeSmallInt ( daemonOpts . size ( ) ) ; for ( String daemonOpt : daemonOpts ) { encoder . writeString ( daemonOpt ) ; } encoder . writeSmallInt ( searchClassPath . size ( ) ) ; for ( File file : searchClassPath ) { encoder . writeString ( file . getAbsolutePath ( ) ) ; } encoder . flush ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } ByteArrayInputStream stdInput = new ByteArrayInputStream ( serializedConfig . toByteArray ( ) ) ; DaemonStartupInfo daemonInfo = startProcess ( daemonArgs , daemonDir . getVersionedDir ( ) , stdInput ) ; listener . daemonStarted ( daemonInfo ) ; return daemonInfo ; } private DaemonStartupInfo startProcess ( List < String > args , File workingDir , InputStream stdInput ) { LOGGER . info ( <str> , workingDir , args ) ; Clock clock = new Clock ( ) ; try { GFileUtils . mkdirs ( workingDir ) ; DaemonOutputConsumer outputConsumer = new DaemonOutputConsumer ( stdInput ) ; ExecHandle handle = new DaemonExecHandleBuilder ( ) . build ( args , workingDir , outputConsumer ) ; handle . start ( ) ; LOGGER . debug ( <str> ) ; ExecResult result = handle . waitForFinish ( ) ; LOGGER . debug ( <str> ) ; return daemonGreeter . parseDaemonOutput ( outputConsumer . getProcessOutput ( ) , result ) ; } catch ( GradleException e ) { throw e ; } catch ( Exception e ) { throw new GradleException ( <str> , e ) ; } finally { LOGGER . info ( <str> , clock . getTime ( ) ) ; } } } 
