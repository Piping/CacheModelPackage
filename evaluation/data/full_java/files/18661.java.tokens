package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Buttons ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . DirectionalLightsAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . PointLightsAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . environment . PointLight ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . shaders . DefaultShader ; import com . badlogic . gdx . graphics . g3d . shaders . DefaultShader . Config ; import com . badlogic . gdx . graphics . g3d . utils . AnimationController ; import com . badlogic . gdx . graphics . g3d . utils . DefaultShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . ShaderProvider ; import com . badlogic . gdx . graphics . profiling . GLProfiler ; import com . badlogic . gdx . graphics . profiling . GL20Profiler ; import com . badlogic . gdx . graphics . profiling . GL30Profiler ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . ui . CheckBox ; import com . badlogic . gdx . scenes . scene2d . ui . Label ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener . ChangeEvent ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . StringBuilder ; public class Benchmark3DTest extends BaseG3dHudTest { protected Environment environment ; protected Label vertexCountLabel , textureBindsLabel , shaderSwitchesLabel , drawCallsLabel , glCallsLabel , lightsLabel ; protected CheckBox lightingCheckBox , lightsCheckBox ; protected boolean lighting ; @Override public void create ( ) { super . create ( ) ; GLProfiler . enable ( ) ; randomizeLights ( ) ; cam . position . set ( <int> , <int> , <int> ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . update ( ) ; showAxes = true ; lighting = true ; vertexCountLabel = new Label ( <str> , skin ) ; vertexCountLabel . setPosition ( <int> , fpsLabel . getTop ( ) ) ; hud . addActor ( vertexCountLabel ) ; textureBindsLabel = new Label ( <str> , skin ) ; textureBindsLabel . setPosition ( <int> , vertexCountLabel . getTop ( ) ) ; hud . addActor ( textureBindsLabel ) ; shaderSwitchesLabel = new Label ( <str> , skin ) ; shaderSwitchesLabel . setPosition ( <int> , textureBindsLabel . getTop ( ) ) ; hud . addActor ( shaderSwitchesLabel ) ; drawCallsLabel = new Label ( <str> , skin ) ; drawCallsLabel . setPosition ( <int> , shaderSwitchesLabel . getTop ( ) ) ; hud . addActor ( drawCallsLabel ) ; glCallsLabel = new Label ( <str> , skin ) ; glCallsLabel . setPosition ( <int> , drawCallsLabel . getTop ( ) ) ; hud . addActor ( glCallsLabel ) ; lightsLabel = new Label ( <str> , skin ) ; lightsLabel . setPosition ( <int> , glCallsLabel . getTop ( ) ) ; hud . addActor ( lightsLabel ) ; lightingCheckBox = new CheckBox ( <str> , skin ) ; lightingCheckBox . setChecked ( lighting ) ; lightingCheckBox . addListener ( new ChangeListener ( ) { @Override public void changed ( ChangeEvent event , Actor actor ) { lighting = lightingCheckBox . isChecked ( ) ; } } ) ; lightingCheckBox . setPosition ( hudWidth - lightingCheckBox . getWidth ( ) , gridCheckBox . getTop ( ) ) ; hud . addActor ( lightingCheckBox ) ; lightsCheckBox = new CheckBox ( <str> , skin ) ; lightsCheckBox . setChecked ( false ) ; lightsCheckBox . addListener ( new ChangeListener ( ) { @Override public void changed ( ChangeEvent event , Actor actor ) { lightsCheckBox . setChecked ( false ) ; randomizeLights ( ) ; } } ) ; lightsCheckBox . setPosition ( hudWidth - lightsCheckBox . getWidth ( ) , lightingCheckBox . getTop ( ) ) ; hud . addActor ( lightsCheckBox ) ; moveCheckBox . remove ( ) ; rotateCheckBox . remove ( ) ; } protected void randomizeLights ( ) { int pointLights = MathUtils . random ( <int> ) ; int directionalLights = MathUtils . random ( <int> ) ; DefaultShader . Config config = new Config ( ) ; config . numDirectionalLights = directionalLights ; config . numPointLights = pointLights ; config . numSpotLights = <int> ; modelBatch . dispose ( ) ; modelBatch = new ModelBatch ( new DefaultShaderProvider ( config ) ) ; environment = new Environment ( ) ; environment . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; for ( int i = <int> ; i < pointLights ; i + + ) { environment . add ( new PointLight ( ) . set ( randomColor ( ) , randomPosition ( ) , MathUtils . random ( <int> f ) ) ) ; } for ( int i = <int> ; i < directionalLights ; i + + ) { environment . add ( new DirectionalLight ( ) . set ( randomColor ( ) , randomPosition ( ) ) ) ; } } protected Color randomColor ( ) { return new Color ( MathUtils . random ( <float> ) , MathUtils . random ( <float> ) , MathUtils . random ( <float> ) , MathUtils . random ( <float> ) ) ; } protected Vector3 randomPosition ( ) { return new Vector3 ( MathUtils . random ( - <int> f , <int> f ) , MathUtils . random ( - <int> f , <int> f ) , MathUtils . random ( - <int> f , <int> f ) ) ; } private final Vector3 tmpV = new Vector3 ( ) ; private final Quaternion tmpQ = new Quaternion ( ) ; private final BoundingBox bounds = new BoundingBox ( ) ; protected void getStatus ( final StringBuilder stringBuilder ) { stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( GLProfiler . calls ) ; glCallsLabel . setText ( stringBuilder ) ; stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( GLProfiler . drawCalls ) ; drawCallsLabel . setText ( stringBuilder ) ; stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( GLProfiler . shaderSwitches ) ; shaderSwitchesLabel . setText ( stringBuilder ) ; stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( GLProfiler . textureBindings ) ; textureBindsLabel . setText ( stringBuilder ) ; stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( GLProfiler . vertexCount . total ) ; vertexCountLabel . setText ( stringBuilder ) ; DirectionalLightsAttribute dirLights = ( DirectionalLightsAttribute ) environment . get ( DirectionalLightsAttribute . Type ) ; PointLightsAttribute pointLights = ( PointLightsAttribute ) environment . get ( PointLightsAttribute . Type ) ; stringBuilder . setLength ( <int> ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( ( dirLights = = null ? <int> : dirLights . lights . size ) + ( pointLights = = null ? <int> : pointLights . lights . size ) ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( dirLights = = null ? <int> : dirLights . lights . size ) ; stringBuilder . append ( <str> ) ; stringBuilder . append ( pointLights = = null ? <int> : pointLights . lights . size ) ; lightsLabel . setText ( stringBuilder ) ; GLProfiler . reset ( ) ; stringBuilder . setLength ( <int> ) ; super . getStatus ( stringBuilder ) ; } @Override protected void render ( ModelBatch batch , Array < ModelInstance > instances ) { if ( lighting ) { batch . render ( instances , environment ) ; } else { batch . render ( instances ) ; } } protected String currentlyLoading ; @Override protected void onModelClicked ( final String name ) { if ( name = = null ) return ; currentlyLoading = <str> + name ; assets . load ( currentlyLoading , Model . class ) ; loading = true ; } @Override protected void onLoaded ( ) { if ( currentlyLoading = = null | | currentlyLoading . length ( ) = = <int> ) return ; final ModelInstance instance = new ModelInstance ( assets . get ( currentlyLoading , Model . class ) ) ; instance . transform = new Matrix4 ( ) . idt ( ) ; instance . transform . setToTranslation ( MathUtils . random ( - <int> , <int> ) , MathUtils . random ( - <int> , <int> ) , MathUtils . random ( - <int> , <int> ) ) ; instance . transform . rotate ( Vector3 . X , MathUtils . random ( - <int> , <int> ) ) ; instance . transform . rotate ( Vector3 . Y , MathUtils . random ( - <int> , <int> ) ) ; instance . transform . rotate ( Vector3 . Z , MathUtils . random ( - <int> , <int> ) ) ; instances . add ( instance ) ; } @Override public boolean keyUp ( int keycode ) { if ( keycode = = Keys . SPACE | | keycode = = Keys . MENU ) { onLoaded ( ) ; } return super . keyUp ( keycode ) ; } @Override public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { onModelClicked ( models [ MathUtils . random ( models . length - <int> ) ] ) ; return false ; } @Override public void dispose ( ) { super . dispose ( ) ; GLProfiler . disable ( ) ; } } 
