package org . gradle . build . docs . dsl . docbook ; import groovy . lang . Closure ; import org . gradle . build . docs . dsl . docbook . model . * ; import org . gradle . build . docs . dsl . source . model . MethodMetaData ; import org . gradle . build . docs . dsl . source . model . PropertyMetaData ; import org . gradle . build . docs . dsl . source . model . TypeMetaData ; import org . gradle . internal . UncheckedException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class ClassDocExtensionsBuilder { private final DslDocModel model ; private final GenerationListener listener ; public ClassDocExtensionsBuilder ( DslDocModel model , GenerationListener listener ) { this . model = model ; this . listener = listener ; } public void build ( ClassDoc classDoc ) { Map < String , ClassExtensionDoc > plugins = new HashMap < String , ClassExtensionDoc > ( ) ; for ( MixinMetaData mixin : classDoc . getExtensionMetaData ( ) . getMixinClasses ( ) ) { String pluginId = mixin . getPluginId ( ) ; ClassExtensionDoc classExtensionDoc = plugins . get ( pluginId ) ; if ( classExtensionDoc = = null ) { classExtensionDoc = new ClassExtensionDoc ( pluginId , classDoc ) ; plugins . put ( pluginId , classExtensionDoc ) ; } classExtensionDoc . getMixinClasses ( ) . add ( model . getClassDoc ( mixin . getMixinClass ( ) ) ) ; } for ( ExtensionMetaData extension : classDoc . getExtensionMetaData ( ) . getExtensionClasses ( ) ) { String pluginId = extension . getPluginId ( ) ; ClassExtensionDoc classExtensionDoc = plugins . get ( pluginId ) ; if ( classExtensionDoc = = null ) { classExtensionDoc = new ClassExtensionDoc ( pluginId , classDoc ) ; plugins . put ( pluginId , classExtensionDoc ) ; } classExtensionDoc . getExtensionClasses ( ) . put ( extension . getExtensionId ( ) , model . getClassDoc ( extension . getExtensionClass ( ) ) ) ; } for ( ClassExtensionDoc extensionDoc : plugins . values ( ) ) { build ( extensionDoc ) ; classDoc . addClassExtension ( extensionDoc ) ; } } private void build ( ClassExtensionDoc extensionDoc ) { Document doc ; try { doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } catch ( ParserConfigurationException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } LinkRenderer linkRenderer = new LinkRenderer ( doc , model ) ; for ( Map . Entry < String , ClassDoc > entry : extensionDoc . getExtensionClasses ( ) . entrySet ( ) ) { String id = entry . getKey ( ) ; ClassDoc type = entry . getValue ( ) ; PropertyMetaData propertyMetaData = new PropertyMetaData ( id , extensionDoc . getTargetClass ( ) . getClassMetaData ( ) ) ; propertyMetaData . setType ( new TypeMetaData ( type . getName ( ) ) ) ; Element para = doc . createElement ( <str> ) ; para . appendChild ( doc . createTextNode ( <str> ) ) ; para . appendChild ( linkRenderer . link ( propertyMetaData . getType ( ) , listener ) ) ; para . appendChild ( doc . createTextNode ( String . format ( <str> , extensionDoc . getPluginId ( ) ) ) ) ; PropertyDoc propertyDoc = new PropertyDoc ( propertyMetaData , Collections . singletonList ( para ) , Collections . < ExtraAttributeDoc > emptyList ( ) ) ; extensionDoc . getExtraProperties ( ) . add ( propertyDoc ) ; para = doc . createElement ( <str> ) ; para . appendChild ( doc . createTextNode ( <str> ) ) ; para . appendChild ( linkRenderer . link ( propertyMetaData . getType ( ) , listener ) ) ; para . appendChild ( doc . createTextNode ( String . format ( <str> , extensionDoc . getPluginId ( ) ) ) ) ; MethodMetaData methodMetaData = new MethodMetaData ( id , extensionDoc . getTargetClass ( ) . getClassMetaData ( ) ) ; methodMetaData . addParameter ( <str> , new TypeMetaData ( Closure . class . getName ( ) ) ) ; MethodDoc methodDoc = new MethodDoc ( methodMetaData , Collections . singletonList ( para ) ) ; extensionDoc . getExtraBlocks ( ) . add ( new BlockDoc ( methodDoc , propertyDoc , propertyMetaData . getType ( ) , false ) ) ; } } } 
