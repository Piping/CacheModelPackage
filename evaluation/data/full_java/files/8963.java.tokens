package org . elasticsearch . test ; import com . carrotsearch . randomizedtesting . RandomizedContext ; import com . carrotsearch . randomizedtesting . RandomizedTest ; import com . carrotsearch . randomizedtesting . annotations . Listeners ; import com . carrotsearch . randomizedtesting . annotations . ThreadLeakLingering ; import com . carrotsearch . randomizedtesting . annotations . ThreadLeakScope ; import com . carrotsearch . randomizedtesting . annotations . ThreadLeakScope . Scope ; import com . carrotsearch . randomizedtesting . annotations . TimeoutSuite ; import com . carrotsearch . randomizedtesting . generators . RandomInts ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import com . carrotsearch . randomizedtesting . rules . TestRuleAdapter ; import org . apache . lucene . uninverting . UninvertingReader ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . LuceneTestCase . SuppressCodecs ; import org . apache . lucene . util . TestRuleMarkFailure ; import org . apache . lucene . util . TestUtil ; import org . apache . lucene . util . TimeUnits ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . bootstrap . BootstrapForTesting ; import org . elasticsearch . cache . recycler . MockPageCacheRecycler ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . io . PathUtilsForTesting ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . MockBigArrays ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . search . MockSearchService ; import org . elasticsearch . test . junit . listeners . LoggingListener ; import org . elasticsearch . test . junit . listeners . ReproduceInfoPrinter ; import org . elasticsearch . threadpool . ThreadPool ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Rule ; import org . junit . rules . RuleChain ; import java . io . IOException ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . function . BooleanSupplier ; import static org . elasticsearch . common . util . CollectionUtils . arrayAsArrayList ; import static org . hamcrest . Matchers . equalTo ; @Listeners ( { ReproduceInfoPrinter . class , LoggingListener . class } ) @ThreadLeakScope ( Scope . SUITE ) @ThreadLeakLingering ( linger = <int> ) @TimeoutSuite ( millis = <int> * TimeUnits . MINUTE ) @LuceneTestCase.SuppressSysoutChecks ( bugUrl = <str> ) @SuppressCodecs ( { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) @LuceneTestCase.SuppressReproduceLine public abstract class ESTestCase extends LuceneTestCase { static { BootstrapForTesting . ensureInitialized ( ) ; } protected final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; @Rule public RuleChain failureAndSuccessEvents = RuleChain . outerRule ( new TestRuleAdapter ( ) { @Override protected void afterIfSuccessful ( ) throws Throwable { ESTestCase . this . afterIfSuccessful ( ) ; } @Override protected void afterAlways ( List < Throwable > errors ) throws Throwable { if ( errors ! = null & & errors . isEmpty ( ) = = false ) { ESTestCase . this . afterIfFailed ( errors ) ; } super . afterAlways ( errors ) ; } } ) ; protected void afterIfFailed ( List < Throwable > errors ) { } protected void afterIfSuccessful ( ) throws Exception { } @BeforeClass public static void setFileSystem ( ) throws Exception { PathUtilsForTesting . setup ( ) ; } @AfterClass public static void restoreFileSystem ( ) throws Exception { PathUtilsForTesting . teardown ( ) ; } @BeforeClass public static void setContentType ( ) throws Exception { Requests . CONTENT_TYPE = randomFrom ( XContentType . values ( ) ) ; Requests . INDEX_CONTENT_TYPE = randomFrom ( XContentType . values ( ) ) ; } @AfterClass public static void restoreContentType ( ) { Requests . CONTENT_TYPE = XContentType . SMILE ; Requests . INDEX_CONTENT_TYPE = XContentType . JSON ; } @BeforeClass @SuppressForbidden ( reason = <str> ) public static void setProcessors ( ) { int numCpu = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; System . setProperty ( EsExecutors . DEFAULT_SYSPROP , Integer . toString ( numCpu ) ) ; assertEquals ( numCpu , EsExecutors . boundedNumberOfProcessors ( Settings . EMPTY ) ) ; } @AfterClass @SuppressForbidden ( reason = <str> ) public static void restoreProcessors ( ) { System . clearProperty ( EsExecutors . DEFAULT_SYSPROP ) ; } @After public final void ensureCleanedUp ( ) throws Exception { MockPageCacheRecycler . ensureAllPagesAreReleased ( ) ; MockBigArrays . ensureAllArraysAreReleased ( ) ; String [ ] entries = UninvertingReader . getUninvertedStats ( ) ; assertEquals ( <str> + Arrays . toString ( entries ) , <int> , entries . length ) ; } @After public final void ensureAllSearchContextsReleased ( ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { MockSearchService . assertNoInFLightContext ( ) ; } } ) ; } public static boolean checkIndexFailed ; @Before public final void resetCheckIndexStatus ( ) throws Exception { checkIndexFailed = false ; } @After public final void ensureCheckIndexPassed ( ) throws Exception { assertFalse ( <str> , checkIndexFailed ) ; } public static Random getRandom ( ) { return random ( ) ; } public static int scaledRandomIntBetween ( int min , int max ) { return RandomizedTest . scaledRandomIntBetween ( min , max ) ; } public static int randomIntBetween ( int min , int max ) { return RandomInts . randomIntBetween ( random ( ) , min , max ) ; } public static int iterations ( int min , int max ) { return scaledRandomIntBetween ( min , max ) ; } public static int between ( int min , int max ) { return randomIntBetween ( min , max ) ; } public static boolean frequently ( ) { return ! rarely ( ) ; } public static boolean randomBoolean ( ) { return random ( ) . nextBoolean ( ) ; } public static byte randomByte ( ) { return ( byte ) random ( ) . nextInt ( ) ; } public static short randomShort ( ) { return ( short ) random ( ) . nextInt ( ) ; } public static int randomInt ( ) { return random ( ) . nextInt ( ) ; } public static float randomFloat ( ) { return random ( ) . nextFloat ( ) ; } public static double randomDouble ( ) { return random ( ) . nextDouble ( ) ; } public static double randomDoubleBetween ( double start , double end , boolean lowerInclusive ) { double result = <float> ; if ( start = = - Double . MAX_VALUE | | end = = Double . MAX_VALUE ) { result = Double . longBitsToDouble ( randomLong ( ) ) ; while ( result < start | | result > end | | Double . isNaN ( result ) ) { result = Double . longBitsToDouble ( randomLong ( ) ) ; } } else { result = randomDouble ( ) ; if ( lowerInclusive = = false ) { while ( result < = <float> ) { result = randomDouble ( ) ; } } result = result * end + ( <float> - result ) * start ; } return result ; } public static long randomLong ( ) { return random ( ) . nextLong ( ) ; } public static int randomInt ( int max ) { return RandomizedTest . randomInt ( max ) ; } public static < T > T randomFrom ( T . . . array ) { return RandomPicks . randomFrom ( random ( ) , array ) ; } public static < T > T randomFrom ( List < T > list ) { return RandomPicks . randomFrom ( random ( ) , list ) ; } public static String randomAsciiOfLengthBetween ( int minCodeUnits , int maxCodeUnits ) { return RandomizedTest . randomAsciiOfLengthBetween ( minCodeUnits , maxCodeUnits ) ; } public static String randomAsciiOfLength ( int codeUnits ) { return RandomizedTest . randomAsciiOfLength ( codeUnits ) ; } public static String randomUnicodeOfLengthBetween ( int minCodeUnits , int maxCodeUnits ) { return RandomizedTest . randomUnicodeOfLengthBetween ( minCodeUnits , maxCodeUnits ) ; } public static String randomUnicodeOfLength ( int codeUnits ) { return RandomizedTest . randomUnicodeOfLength ( codeUnits ) ; } public static String randomUnicodeOfCodepointLengthBetween ( int minCodePoints , int maxCodePoints ) { return RandomizedTest . randomUnicodeOfCodepointLengthBetween ( minCodePoints , maxCodePoints ) ; } public static String randomUnicodeOfCodepointLength ( int codePoints ) { return RandomizedTest . randomUnicodeOfCodepointLength ( codePoints ) ; } public static String randomRealisticUnicodeOfLengthBetween ( int minCodeUnits , int maxCodeUnits ) { return RandomizedTest . randomRealisticUnicodeOfLengthBetween ( minCodeUnits , maxCodeUnits ) ; } public static String randomRealisticUnicodeOfLength ( int codeUnits ) { return RandomizedTest . randomRealisticUnicodeOfLength ( codeUnits ) ; } public static String randomRealisticUnicodeOfCodepointLengthBetween ( int minCodePoints , int maxCodePoints ) { return RandomizedTest . randomRealisticUnicodeOfCodepointLengthBetween ( minCodePoints , maxCodePoints ) ; } public static String randomRealisticUnicodeOfCodepointLength ( int codePoints ) { return RandomizedTest . randomRealisticUnicodeOfCodepointLength ( codePoints ) ; } public static String [ ] generateRandomStringArray ( int maxArraySize , int maxStringSize , boolean allowNull , boolean allowEmpty ) { if ( allowNull & & random ( ) . nextBoolean ( ) ) { return null ; } int arraySize = randomIntBetween ( allowEmpty ? <int> : <int> , maxArraySize ) ; String [ ] array = new String [ arraySize ] ; for ( int i = <int> ; i < arraySize ; i + + ) { array [ i ] = RandomStrings . randomAsciiOfLength ( random ( ) , maxStringSize ) ; } return array ; } public static String [ ] generateRandomStringArray ( int maxArraySize , int maxStringSize , boolean allowNull ) { return generateRandomStringArray ( maxArraySize , maxStringSize , allowNull , true ) ; } public static String randomTimeValue ( ) { final String [ ] values = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ; return randomIntBetween ( <int> , <int> ) + randomFrom ( values ) ; } public static void assertBusy ( Runnable codeBlock ) throws Exception { assertBusy ( Executors . callable ( codeBlock ) , <int> , TimeUnit . SECONDS ) ; } public static void assertBusy ( Runnable codeBlock , long maxWaitTime , TimeUnit unit ) throws Exception { assertBusy ( Executors . callable ( codeBlock ) , maxWaitTime , unit ) ; } public static < V > V assertBusy ( Callable < V > codeBlock ) throws Exception { return assertBusy ( codeBlock , <int> , TimeUnit . SECONDS ) ; } public static < V > V assertBusy ( Callable < V > codeBlock , long maxWaitTime , TimeUnit unit ) throws Exception { long maxTimeInMillis = TimeUnit . MILLISECONDS . convert ( maxWaitTime , unit ) ; long iterations = Math . max ( Math . round ( Math . log10 ( maxTimeInMillis ) / Math . log10 ( <int> ) ) , <int> ) ; long timeInMillis = <int> ; long sum = <int> ; List < AssertionError > failures = new ArrayList < > ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { try { return codeBlock . call ( ) ; } catch ( AssertionError e ) { failures . add ( e ) ; } sum + = timeInMillis ; Thread . sleep ( timeInMillis ) ; timeInMillis * = <int> ; } timeInMillis = maxTimeInMillis - sum ; Thread . sleep ( Math . max ( timeInMillis , <int> ) ) ; try { return codeBlock . call ( ) ; } catch ( AssertionError e ) { for ( AssertionError failure : failures ) { e . addSuppressed ( failure ) ; } throw e ; } } public static boolean awaitBusy ( BooleanSupplier breakSupplier ) throws InterruptedException { return awaitBusy ( breakSupplier , <int> , TimeUnit . SECONDS ) ; } private static final long AWAIT_BUSY_THRESHOLD = <int> ; public static boolean awaitBusy ( BooleanSupplier breakSupplier , long maxWaitTime , TimeUnit unit ) throws InterruptedException { long maxTimeInMillis = TimeUnit . MILLISECONDS . convert ( maxWaitTime , unit ) ; long timeInMillis = <int> ; long sum = <int> ; while ( sum + timeInMillis < maxTimeInMillis ) { if ( breakSupplier . getAsBoolean ( ) ) { return true ; } Thread . sleep ( timeInMillis ) ; sum + = timeInMillis ; timeInMillis = Math . min ( AWAIT_BUSY_THRESHOLD , timeInMillis * <int> ) ; } timeInMillis = maxTimeInMillis - sum ; Thread . sleep ( Math . max ( timeInMillis , <int> ) ) ; return breakSupplier . getAsBoolean ( ) ; } public static boolean terminate ( ExecutorService . . . services ) throws InterruptedException { boolean terminated = true ; for ( ExecutorService service : services ) { if ( service ! = null ) { terminated & = ThreadPool . terminate ( service , <int> , TimeUnit . SECONDS ) ; } } return terminated ; } public static boolean terminate ( ThreadPool service ) throws InterruptedException { return ThreadPool . terminate ( service , <int> , TimeUnit . SECONDS ) ; } @Override public Path getDataPath ( String relativePath ) { try { return PathUtils . get ( getClass ( ) . getResource ( relativePath ) . toURI ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> + relativePath , e ) ; } } public Path getBwcIndicesPath ( ) { return getDataPath ( <str> ) ; } public String [ ] tmpPaths ( ) { final int numPaths = TestUtil . nextInt ( random ( ) , <int> , <int> ) ; final String [ ] absPaths = new String [ numPaths ] ; for ( int i = <int> ; i < numPaths ; i + + ) { absPaths [ i ] = createTempDir ( ) . toAbsolutePath ( ) . toString ( ) ; } return absPaths ; } public NodeEnvironment newNodeEnvironment ( ) throws IOException { return newNodeEnvironment ( Settings . EMPTY ) ; } public NodeEnvironment newNodeEnvironment ( Settings settings ) throws IOException { Settings build = Settings . builder ( ) . put ( settings ) . put ( <str> , createTempDir ( ) . toAbsolutePath ( ) ) . putArray ( <str> , tmpPaths ( ) ) . build ( ) ; return new NodeEnvironment ( build , new Environment ( build ) ) ; } public static Settings . Builder settings ( Version version ) { Settings . Builder builder = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) ; return builder ; } private static String threadName ( Thread t ) { return <str> + <str> + t . getId ( ) + <str> + t . getName ( ) + <str> + t . getState ( ) + <str> + groupName ( t . getThreadGroup ( ) ) + <str> ; } private static String groupName ( ThreadGroup threadGroup ) { if ( threadGroup = = null ) { return <str> ; } else { return threadGroup . getName ( ) ; } } public static < T > List < T > randomSubsetOf ( int size , T . . . values ) { if ( size > values . length ) { throw new IllegalArgumentException ( <str> + size + <str> + values . length + <str> ) ; } List < T > list = arrayAsArrayList ( values ) ; Collections . shuffle ( list , random ( ) ) ; return list . subList ( <int> , size ) ; } public static boolean assertionsEnabled ( ) { boolean enabled = false ; assert ( enabled = true ) ; return enabled ; } public void assertPathHasBeenCleared ( String path ) throws Exception { assertPathHasBeenCleared ( PathUtils . get ( path ) ) ; } public void assertPathHasBeenCleared ( Path path ) throws Exception { logger . info ( <str> , path ) ; int count = <int> ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; if ( Files . exists ( path ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( path ) ) { for ( Path file : stream ) { if ( file . getFileName ( ) . toString ( ) . startsWith ( <str> ) ) { continue ; } logger . info ( <str> , file . toAbsolutePath ( ) . toString ( ) ) ; if ( Files . isDirectory ( file ) ) { assertPathHasBeenCleared ( file ) ; } else if ( Files . isRegularFile ( file ) ) { count + + ; sb . append ( file . toAbsolutePath ( ) . toString ( ) ) ; sb . append ( <str> ) ; } } } } sb . append ( <str> ) ; assertThat ( count + <str> + sb . toString ( ) , count , equalTo ( <int> ) ) ; } public static TestRuleMarkFailure getSuiteFailureMarker ( ) { return suiteFailureMarker ; } public static void assertArrayEquals ( StackTraceElement expected [ ] , StackTraceElement actual [ ] ) { assertEquals ( expected . length , actual . length ) ; for ( int i = <int> ; i < expected . length ; i + + ) { assertEquals ( expected [ i ] , actual [ i ] ) ; } } public static void assertEquals ( StackTraceElement expected , StackTraceElement actual ) { assertEquals ( expected . getClassName ( ) , actual . getClassName ( ) ) ; assertEquals ( expected . getMethodName ( ) , actual . getMethodName ( ) ) ; assertEquals ( expected . getFileName ( ) , actual . getFileName ( ) ) ; assertEquals ( expected . getLineNumber ( ) , actual . getLineNumber ( ) ) ; assertEquals ( expected . isNativeMethod ( ) , actual . isNativeMethod ( ) ) ; } } 
