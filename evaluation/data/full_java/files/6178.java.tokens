package org . elasticsearch . discovery . zen . elect ; import com . carrotsearch . hppc . ObjectContainer ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . settings . Validator ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . CollectionUtils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; public class ElectMasterService extends AbstractComponent { public static final String DISCOVERY_ZEN_MINIMUM_MASTER_NODES = <str> ; public static final Validator DISCOVERY_ZEN_MINIMUM_MASTER_NODES_VALIDATOR = new Validator ( ) { @Override public String validate ( String setting , String value , ClusterState clusterState ) { int intValue ; try { intValue = Integer . parseInt ( value ) ; } catch ( NumberFormatException ex ) { return <str> + value + <str> ; } int masterNodes = clusterState . nodes ( ) . masterNodes ( ) . size ( ) ; if ( intValue > masterNodes ) { return <str> + ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES + <str> + masterNodes + <str> ; } return null ; } } ; private final Version minMasterVersion ; private final NodeComparator nodeComparator = new NodeComparator ( ) ; private volatile int minimumMasterNodes ; @Inject public ElectMasterService ( Settings settings , Version version ) { super ( settings ) ; this . minMasterVersion = version . minimumCompatibilityVersion ( ) ; this . minimumMasterNodes = settings . getAsInt ( DISCOVERY_ZEN_MINIMUM_MASTER_NODES , - <int> ) ; logger . debug ( <str> , minimumMasterNodes ) ; } public void minimumMasterNodes ( int minimumMasterNodes ) { this . minimumMasterNodes = minimumMasterNodes ; } public int minimumMasterNodes ( ) { return minimumMasterNodes ; } public boolean hasEnoughMasterNodes ( Iterable < DiscoveryNode > nodes ) { if ( minimumMasterNodes < <int> ) { return true ; } int count = <int> ; for ( DiscoveryNode node : nodes ) { if ( node . masterNode ( ) ) { count + + ; } } return count > = minimumMasterNodes ; } public List < DiscoveryNode > sortByMasterLikelihood ( Iterable < DiscoveryNode > nodes ) { ArrayList < DiscoveryNode > sortedNodes = CollectionUtils . iterableAsArrayList ( nodes ) ; CollectionUtil . introSort ( sortedNodes , nodeComparator ) ; return sortedNodes ; } public DiscoveryNode [ ] nextPossibleMasters ( ObjectContainer < DiscoveryNode > nodes , int numberOfPossibleMasters ) { List < DiscoveryNode > sortedNodes = sortedMasterNodes ( Arrays . asList ( nodes . toArray ( DiscoveryNode . class ) ) ) ; if ( sortedNodes = = null ) { return new DiscoveryNode [ <int> ] ; } List < DiscoveryNode > nextPossibleMasters = new ArrayList < > ( numberOfPossibleMasters ) ; int counter = <int> ; for ( DiscoveryNode nextPossibleMaster : sortedNodes ) { if ( + + counter > = numberOfPossibleMasters ) { break ; } nextPossibleMasters . add ( nextPossibleMaster ) ; } return nextPossibleMasters . toArray ( new DiscoveryNode [ nextPossibleMasters . size ( ) ] ) ; } public DiscoveryNode electMaster ( Iterable < DiscoveryNode > nodes ) { List < DiscoveryNode > sortedNodes = sortedMasterNodes ( nodes ) ; if ( sortedNodes = = null | | sortedNodes . isEmpty ( ) ) { return null ; } DiscoveryNode masterNode = sortedNodes . get ( <int> ) ; if ( masterNode . getVersion ( ) . before ( minMasterVersion ) ) { logger . warn ( <str> , masterNode , masterNode . getVersion ( ) , minMasterVersion ) ; return null ; } else { return masterNode ; } } private List < DiscoveryNode > sortedMasterNodes ( Iterable < DiscoveryNode > nodes ) { List < DiscoveryNode > possibleNodes = CollectionUtils . iterableAsArrayList ( nodes ) ; if ( possibleNodes . isEmpty ( ) ) { return null ; } for ( Iterator < DiscoveryNode > it = possibleNodes . iterator ( ) ; it . hasNext ( ) ; ) { DiscoveryNode node = it . next ( ) ; if ( ! node . masterNode ( ) ) { it . remove ( ) ; } } CollectionUtil . introSort ( possibleNodes , nodeComparator ) ; return possibleNodes ; } private static class NodeComparator implements Comparator < DiscoveryNode > { @Override public int compare ( DiscoveryNode o1 , DiscoveryNode o2 ) { if ( o1 . masterNode ( ) & & ! o2 . masterNode ( ) ) { return - <int> ; } if ( ! o1 . masterNode ( ) & & o2 . masterNode ( ) ) { return <int> ; } return o1 . id ( ) . compareTo ( o2 . id ( ) ) ; } } } 
