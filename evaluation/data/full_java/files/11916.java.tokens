package org . gradle . execution ; import org . gradle . api . Action ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . UncheckedException ; import org . gradle . util . DisconnectableInputStream ; import java . io . IOException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Future ; public class DefaultCancellableOperationManager implements CancellableOperationManager { private static final int EOF = - <int> ; private static final int KEY_CODE_CTRL_D = <int> ; private final ExecutorService executorService ; private final DisconnectableInputStream input ; private final BuildCancellationToken cancellationToken ; public DefaultCancellableOperationManager ( ExecutorService executorService , DisconnectableInputStream input , BuildCancellationToken cancellationToken ) { this . executorService = executorService ; this . input = input ; this . cancellationToken = cancellationToken ; } @Override public void monitorInput ( final Action < ? super BuildCancellationToken > operation ) { Future < ? > handle = null ; try { handle = executorService . submit ( new Runnable ( ) { @Override public void run ( ) { try { while ( ! Thread . currentThread ( ) . isInterrupted ( ) ) { int c = input . read ( ) ; if ( c = = KEY_CODE_CTRL_D | | c = = EOF ) { cancellationToken . cancel ( ) ; break ; } } } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } ) ; operation . execute ( cancellationToken ) ; } finally { if ( handle ! = null ) { handle . cancel ( true ) ; } } } } 
