package org . elasticsearch . index . mapper . binary ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . core . BinaryFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . Arrays ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; public class BinaryMappingTests extends ESSingleNodeTestCase { public void testDefaultMapping ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper fieldMapper = mapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( BinaryFieldMapper . class ) ) ; assertThat ( fieldMapper . fieldType ( ) . stored ( ) , equalTo ( false ) ) ; } public void testStoredValue ( ) throws IOException { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; final byte [ ] binaryValue1 = new byte [ <int> ] ; binaryValue1 [ <int> ] = <int> ; BytesStreamOutput out = new BytesStreamOutput ( ) ; try ( StreamOutput compressed = CompressorFactory . defaultCompressor ( ) . streamOutput ( out ) ) { new BytesArray ( binaryValue1 ) . writeTo ( compressed ) ; } final byte [ ] binaryValue2 = out . bytes ( ) . toBytes ( ) ; assertTrue ( CompressorFactory . isCompressed ( new BytesArray ( binaryValue2 ) ) ) ; for ( byte [ ] value : Arrays . asList ( binaryValue1 , binaryValue2 ) ) { ParsedDocument doc = mapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . endObject ( ) . bytes ( ) ) ; BytesRef indexedValue = doc . rootDoc ( ) . getBinaryValue ( <str> ) ; assertEquals ( new BytesRef ( value ) , indexedValue ) ; FieldMapper fieldMapper = mapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; Object originalValue = fieldMapper . fieldType ( ) . valueForSearch ( indexedValue ) ; assertEquals ( new BytesArray ( value ) , originalValue ) ; } } } 
