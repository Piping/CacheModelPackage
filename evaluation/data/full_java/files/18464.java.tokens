package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . g2d . CpuSpriteBatch ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Group ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . utils . TextureRegionDrawable ; import com . badlogic . gdx . scenes . scene2d . utils . TransformDrawable ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . TimeUtils ; import com . badlogic . gdx . utils . viewport . ExtendViewport ; import com . badlogic . gdx . utils . viewport . Viewport ; public class CpuSpriteBatchTest extends GdxTest { private static class DrawableActor extends Actor { private final TransformDrawable drawable ; public DrawableActor ( TransformDrawable drawable ) { this . drawable = drawable ; setSize ( drawable . getMinWidth ( ) , drawable . getMinHeight ( ) ) ; } public void draw ( Batch batch , float parentAlpha ) { Color color = getColor ( ) ; batch . setColor ( color . r , color . g , color . b , parentAlpha ) ; drawable . draw ( batch , getX ( ) , getY ( ) , getOriginX ( ) , getOriginY ( ) , getWidth ( ) , getHeight ( ) , getScaleX ( ) , getScaleY ( ) , getRotation ( ) ) ; } } private static final int NUM_GROUPS = <int> ; private Stage stage ; private Texture texture ; private long sampleStartTime ; private long sampleFrames ; public void create ( ) { Batch batch = new CpuSpriteBatch ( ) ; stage = new Stage ( new ExtendViewport ( <int> , <int> ) , batch ) ; Gdx . input . setInputProcessor ( stage ) ; texture = new Texture ( <str> ) ; texture . setFilter ( TextureFilter . Linear , TextureFilter . Linear ) ; TextureRegionDrawable drawable = new TextureRegionDrawable ( new TextureRegion ( texture ) ) ; for ( int i = <int> ; i < NUM_GROUPS ; i + + ) { Group group = createActorGroup ( drawable ) ; stage . addActor ( group ) ; } } private Group createActorGroup ( TextureRegionDrawable bob ) { Actor main = new DrawableActor ( bob ) ; main . setPosition ( <int> , <int> , Align . center ) ; Actor hat = new DrawableActor ( bob ) { @Override public void act ( float delta ) { rotateBy ( delta * - <int> ) ; } } ; hat . setOrigin ( Align . center ) ; hat . setScale ( <float> ) ; hat . setPosition ( <int> , <int> , Align . center ) ; Group group = new Group ( ) { @Override public void act ( float delta ) { rotateBy ( delta * <int> ) ; setScale ( <float> + <float> * MathUtils . cos ( MathUtils . degreesToRadians * getRotation ( ) ) ) ; super . act ( delta ) ; } } ; group . addActor ( main ) ; group . addActor ( hat ) ; float margin = <int> ; float x = MathUtils . random ( margin , stage . getWidth ( ) - margin ) ; float y = MathUtils . random ( margin , stage . getHeight ( ) - margin ) ; group . setPosition ( x , y ) ; group . setRotation ( MathUtils . random ( <int> , <int> ) ) ; return group ; } public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; stage . act ( Gdx . graphics . getDeltaTime ( ) ) ; stage . draw ( ) ; long now = TimeUtils . nanoTime ( ) ; sampleFrames + + ; if ( now - sampleStartTime > <int> ) { if ( sampleStartTime ! = <int> ) { int renderCalls = ( ( SpriteBatch ) stage . getBatch ( ) ) . renderCalls ; Gdx . app . log ( <str> , <str> + sampleFrames + <str> + renderCalls ) ; } sampleStartTime = now ; sampleFrames = <int> ; } } public void resize ( int width , int height ) { stage . getViewport ( ) . update ( width , height , true ) ; } public void dispose ( ) { stage . dispose ( ) ; texture . dispose ( ) ; } } 
