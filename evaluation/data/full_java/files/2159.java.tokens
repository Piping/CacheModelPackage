package org . nd4j . linalg . api . shape ; import com . google . common . primitives . Ints ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . buffer . DataBuffer . AllocationMode ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . api . ops . impl . transforms . arithmetic . CopyOp ; import org . nd4j . linalg . api . shape . loop . coordinatefunction . CoordinateFunction ; import org . nd4j . linalg . api . shape . loop . four . LoopFunction4 ; import org . nd4j . linalg . api . shape . loop . four . RawArrayIterationInformation4 ; import org . nd4j . linalg . api . shape . loop . one . RawArrayIterationInformation1 ; import org . nd4j . linalg . api . shape . loop . three . LoopFunction3 ; import org . nd4j . linalg . api . shape . loop . three . RawArrayIterationInformation3 ; import org . nd4j . linalg . api . shape . loop . two . CopyLoopFunction ; import org . nd4j . linalg . api . shape . loop . two . LoopFunction2 ; import org . nd4j . linalg . api . shape . loop . two . RawArrayIterationInformation2 ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . indexing . ShapeOffsetResolution ; import org . nd4j . linalg . util . ArrayUtil ; import java . util . * ; public class Shape { public static INDArray toOffsetZero ( INDArray arr ) { if ( arr . offset ( ) < <int> & & arr . data ( ) . length ( ) = = arr . length ( ) | | arr instanceof IComplexNDArray & & arr . length ( ) * <int> = = arr . data ( ) . length ( ) ) if ( arr . ordering ( ) = = <str> & & arr . stride ( - <int> ) ! = arr . elementStride ( ) | | arr . ordering ( ) = = <str> & & arr . stride ( <int> ) ! = arr . elementStride ( ) ) return arr ; if ( arr . isRowVector ( ) ) { if ( arr instanceof IComplexNDArray ) { IComplexNDArray ret = Nd4j . createComplex ( arr . shape ( ) ) ; for ( int i = <int> ; i < ret . length ( ) ; i + + ) ret . putScalar ( i , ( ( IComplexNDArray ) arr ) . getComplex ( i ) ) ; return ret ; } else { INDArray ret = Nd4j . create ( arr . shape ( ) ) ; for ( int i = <int> ; i < ret . length ( ) ; i + + ) ret . putScalar ( i , arr . getDouble ( i ) ) ; return ret ; } } if ( arr instanceof IComplexNDArray ) { IComplexNDArray ret = Nd4j . createComplex ( arr . shape ( ) ) ; for ( int i = <int> ; i < ret . slices ( ) ; i + + ) ret . putSlice ( i , arr . slice ( i ) ) ; return ret ; } else { INDArray ret = Nd4j . create ( arr . shape ( ) , arr . ordering ( ) ) ; ret . assign ( arr ) ; return ret ; } } public static INDArray copyArrayWithWholeBuffer ( INDArray arr ) { return Nd4j . create ( arr . data ( ) . dup ( ) , arr . shape ( ) , arr . stride ( ) , arr . offset ( ) , arr . ordering ( ) ) ; } public static INDArray toOffsetZeroCopy ( INDArray arr ) { return toOffsetZeroCopyHelper ( arr , Nd4j . order ( ) , false ) ; } public static INDArray toOffsetZeroCopy ( INDArray arr , char order ) { return toOffsetZeroCopyHelper ( arr , order , false ) ; } public static INDArray toOffsetZeroCopyAnyOrder ( INDArray arr ) { return toOffsetZeroCopyHelper ( arr , Nd4j . order ( ) , true ) ; } private static INDArray toOffsetZeroCopyHelper ( final INDArray arr , char order , boolean anyOrder ) { if ( arr instanceof IComplexNDArray ) { if ( arr . isRowVector ( ) ) { IComplexNDArray ret = Nd4j . createComplex ( arr . shape ( ) , order ) ; for ( int i = <int> ; i < ret . length ( ) ; i + + ) ret . putScalar ( i , ( ( IComplexNDArray ) arr ) . getComplex ( i ) ) ; return ret ; } IComplexNDArray ret = Nd4j . createComplex ( arr . shape ( ) , order ) ; for ( int i = <int> ; i < ret . slices ( ) ; i + + ) ret . putSlice ( i , arr . slice ( i ) ) ; return ret ; } else { char outOrder = ( anyOrder ? arr . ordering ( ) : order ) ; if ( outOrder = = <str> ) outOrder = Nd4j . order ( ) ; INDArray z = Nd4j . create ( arr . shape ( ) , outOrder ) ; CopyOp op = new CopyOp ( arr , z ) ; Nd4j . getExecutioner ( ) . exec ( op ) ; return z ; } } public static INDArray toMmulCompatible ( INDArray input ) { if ( input . rank ( ) ! = <int> ) throw new IllegalArgumentException ( <str> ) ; boolean doCopy = false ; if ( input . ordering ( ) = = <str> & & ( input . stride ( <int> ) ! = input . size ( <int> ) | | input . stride ( <int> ) ! = <int> ) ) doCopy = true ; else if ( input . ordering ( ) = = <str> & & ( input . stride ( <int> ) ! = <int> | | input . stride ( <int> ) ! = input . size ( <int> ) ) ) doCopy = true ; if ( doCopy ) return Shape . toOffsetZeroCopyAnyOrder ( input ) ; else return input ; } public static double getDouble ( INDArray arr , int . . . indices ) { int offset = getOffset ( arr . offset ( ) , arr . shape ( ) , arr . stride ( ) , indices ) ; return arr . data ( ) . getDouble ( offset ) ; } public static void iterate ( INDArray arr , CoordinateFunction coordinateFunction ) { Shape . iterate ( <int> , arr . rank ( ) , arr . shape ( ) , new int [ arr . rank ( ) ] , coordinateFunction ) ; } public static void iterate ( INDArray arr , INDArray arr2 , CoordinateFunction coordinateFunction ) { Shape . iterate ( <int> , arr . rank ( ) , arr . shape ( ) , new int [ arr . rank ( ) ] , <int> , arr2 . rank ( ) , arr2 . shape ( ) , new int [ arr2 . rank ( ) ] , coordinateFunction ) ; } public static void iterate ( int dimension , int n , int [ ] size , int [ ] res , int dimension2 , int n2 , int [ ] size2 , int [ ] res2 , CoordinateFunction func ) { if ( dimension > = n | | dimension2 > = n2 ) { func . process ( res , res2 ) ; return ; } if ( size2 . length ! = size . length ) { if ( dimension > = size . length ) return ; for ( int i = <int> ; i < size [ dimension ] ; i + + ) { if ( dimension2 > = size2 . length ) break ; for ( int j = <int> ; j < size2 [ dimension2 ] ; j + + ) { res [ dimension ] = i ; res2 [ dimension2 ] = j ; iterate ( dimension + <int> , n , size , res , dimension2 + <int> , n2 , size2 , res2 , func ) ; } } } else { if ( dimension > = size . length ) return ; for ( int i = <int> ; i < size [ dimension ] ; i + + ) { for ( int j = <int> ; j < size2 [ dimension2 ] ; j + + ) { if ( dimension2 > = size2 . length ) break ; res [ dimension ] = i ; res2 [ dimension2 ] = j ; iterate ( dimension + <int> , n , size , res , dimension2 + <int> , n2 , size2 , res2 , func ) ; } } } } public static void forEachOffset ( INDArray [ ] arr , CoordinateFunction coordinateFunction ) { int [ ] offset = new int [ arr . length ] ; int length = arr [ <int> ] . length ( ) ; for ( int i = <int> ; i < length ; i + + ) { for ( int j = <int> ; j < offset . length ; j + + ) { offset [ j ] = arr [ j ] . offset ( ) + i * arr [ j ] . elementWiseStride ( ) ; } coordinateFunction . process ( offset ) ; } } public static void forEachOffset ( INDArray arr , CoordinateFunction coordinateFunction ) { int [ ] offset = new int [ <int> ] ; INDArray reshape = arr . reshape ( <int> , arr . length ( ) ) ; for ( int i = <int> ; i < reshape . length ( ) ; i + + ) { offset [ <int> ] = reshape . offset ( ) + i * reshape . stride ( - <int> ) ; coordinateFunction . process ( offset ) ; } } public static void iterate ( int dimension , int n , int [ ] size , int [ ] res , CoordinateFunction func ) { if ( dimension > = n ) { func . process ( res ) ; return ; } for ( int i = <int> ; i < size [ dimension ] ; i + + ) { res [ dimension ] = i ; iterate ( dimension + <int> , n , size , res , func ) ; } } public static int [ ] raw2dLoop ( int idim , int ndim , int [ ] coord , int [ ] shape , int dataA , int [ ] stridesA , int dataB , int [ ] stridesB , RawArrayIterationInformation2 info , LoopFunction2 loopFunction2 ) { idim = <int> ; do { loopFunction2 . perform ( idim , info , info . getA ( ) , dataA , info . getB ( ) , dataB ) ; for ( ; idim < ndim ; idim - - ) { if ( + + coord [ idim ] = = shape [ idim ] ) { coord [ idim ] = <int> ; dataA - = ( shape [ idim ] - <int> ) * stridesA [ idim ] ; dataB - = ( shape [ idim ] - <int> ) * stridesB [ idim ] ; } else { dataA + = stridesA [ idim ] ; dataB + = stridesB [ idim ] ; break ; } } } while ( idim < ndim ) ; return new int [ ] { dataA , dataB } ; } public static int [ ] raw3dLoop ( int idim , int ndim , int [ ] coord , int [ ] shape , int dataA , int [ ] stridesA , int dataB , int [ ] stridesB , int dataC , int [ ] stridesC , RawArrayIterationInformation3 info , LoopFunction3 loopFunction3 ) { do { loopFunction3 . perform ( idim , info , info . getA ( ) , info . getAOffset ( ) , info . getB ( ) , info . getBOffset ( ) , info . getC ( ) , info . getCOffset ( ) ) ; for ( idim = <int> ; ( idim ) < ndim ; idim + + ) { if ( + + ( coord ) [ idim ] = = ( shape ) [ idim ] ) { coord [ idim ] = <int> ; dataA - = ( shape [ idim ] - <int> ) * stridesA [ idim ] ; dataB - = ( shape [ idim ] - <int> ) * stridesB [ idim ] ; dataC - = ( shape [ idim ] - <int> ) * stridesC [ idim ] ; } else { dataA + = stridesA [ idim ] ; dataB + = stridesB [ idim ] ; dataC + = stridesC [ idim ] ; break ; } } } while ( idim < ( ndim ) ) ; return new int [ ] { dataA , dataB , dataC } ; } public static int [ ] raw4DLoop ( int idim , int ndim , int [ ] coord , int [ ] shape , int dataA , int [ ] stridesA , int dataB , int [ ] stridesB , int dataC , int [ ] stridesC , int dataD , int [ ] stridesD , RawArrayIterationInformation4 info , LoopFunction4 loopFunction4 ) { do { loopFunction4 . perform ( idim , info , info . getA ( ) , info . getAOffset ( ) , info . getB ( ) , info . getBOffset ( ) , info . getC ( ) , info . getCOffset ( ) , info . getD ( ) , info . getDOffset ( ) ) ; for ( ( idim ) = <int> ; idim < ndim ; idim + + ) { if ( coord [ idim ] + + = = shape [ idim ] ) { coord [ idim ] = <int> ; dataA - = ( shape [ idim ] - <int> ) * stridesA [ idim ] ; dataB - = ( shape [ idim ] - <int> ) * stridesB [ idim ] ; dataC - = ( shape [ idim ] - <int> ) * stridesC [ idim ] ; dataD - = ( shape [ idim ] - <int> ) * stridesD [ idim ] ; } else { dataA + = stridesA [ idim ] ; dataB + = stridesB [ idim ] ; dataC + = stridesC [ idim ] ; dataD + = stridesD [ idim ] ; break ; } } } while ( idim < ndim ) ; return new int [ ] { dataA , dataB , dataC , dataD } ; } public static int getOffset ( int baseOffset , int [ ] shape , int [ ] stride , int . . . indices ) { if ( shape . length ! = stride . length | | indices . length ! = shape . length ) throw new IllegalArgumentException ( <str> ) ; int offset = baseOffset ; for ( int i = <int> ; i < shape . length ; i + + ) { if ( indices [ i ] > = shape [ i ] ) throw new IllegalArgumentException ( String . format ( <str> , i ) ) ; if ( shape [ i ] ! = <int> ) { offset + = indices [ i ] * stride [ i ] ; } } return offset ; } public static int [ ] sizeForAxes ( int [ ] axes , int [ ] shape ) { int [ ] ret = new int [ shape . length ] ; for ( int i = <int> ; i < axes . length ; i + + ) { ret [ i ] = shape [ axes [ i ] ] ; } return ret ; } public static boolean isVector ( int [ ] shape ) { if ( shape . length > <int> | | shape . length < <int> ) return false ; else { int len = ArrayUtil . prod ( shape ) ; return shape [ <int> ] = = len | | shape [ <int> ] = = len ; } } public static boolean isMatrix ( int [ ] shape ) { if ( shape . length ! = <int> ) return false ; return ! isVector ( shape ) ; } public static int [ ] squeeze ( int [ ] shape ) { if ( isColumnVectorShape ( shape ) ) return shape ; List < Integer > ret = new ArrayList < > ( ) ; for ( int i = <int> ; i < shape . length ; i + + ) if ( shape [ i ] ! = <int> ) ret . add ( shape [ i ] ) ; return ArrayUtil . toArray ( ret ) ; } public static int [ ] nonOneDimensions ( int [ ] dimensions , int [ ] shape ) { if ( dimensions . length ! = shape . length ) throw new IllegalArgumentException ( <str> ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int i = <int> ; i < dimensions . length ; i + + ) { if ( shape [ i ] ! = <int> ) { list . add ( i ) ; } } return Ints . toArray ( list ) ; } public static int [ ] leadingAndTrailingOnes ( int [ ] original ) { List < Integer > ints = new ArrayList < > ( ) ; if ( ! Shape . isVector ( original ) ) { for ( int i = <int> ; i < original . length ; i + + ) { if ( original [ i ] ! = <int> ) ints . add ( original [ i ] ) ; } return Ints . toArray ( ints ) ; } return original ; } public static boolean shapeEquals ( int [ ] shape1 , int [ ] shape2 ) { if ( isColumnVectorShape ( shape1 ) ) { if ( isColumnVectorShape ( shape2 ) ) { return Arrays . equals ( shape1 , shape2 ) ; } } if ( isRowVectorShape ( shape1 ) ) { if ( isRowVectorShape ( shape2 ) ) { int [ ] shape1Comp = squeeze ( shape1 ) ; int [ ] shape2Comp = squeeze ( shape2 ) ; return Arrays . equals ( shape1Comp , shape2Comp ) ; } } shape1 = squeeze ( shape1 ) ; shape2 = squeeze ( shape2 ) ; return scalarEquals ( shape1 , shape2 ) | | Arrays . equals ( shape1 , shape2 ) ; } public static boolean scalarEquals ( int [ ] shape1 , int [ ] shape2 ) { if ( shape1 . length = = <int> ) { if ( shape2 . length = = <int> & & shape2 [ <int> ] = = <int> ) return true ; } else if ( shape2 . length = = <int> ) { if ( shape1 . length = = <int> & & shape1 [ <int> ] = = <int> ) return true ; } return false ; } public static boolean isRowVectorShape ( int [ ] shape ) { return ( shape . length = = <int> & & shape [ <int> ] = = <int> ) | | shape . length = = <int> ; } public static boolean isColumnVectorShape ( int [ ] shape ) { return ( shape . length = = <int> & & shape [ <int> ] = = <int> ) ; } public static int [ ] createConcatStrides ( INDArray . . . arrays ) { int rank = arrays [ <int> ] . rank ( ) ; for ( INDArray arr : arrays ) { if ( arr . rank ( ) ! = rank ) throw new IllegalArgumentException ( <str> ) ; } int [ ] ret = new int [ rank ] ; int i0 , i1 , ipos , ax_j0 , ax_j1 , iarrays ; for ( i0 = <int> ; i0 < rank ; i0 + + ) { ret [ i0 ] = i0 ; } for ( i0 = <int> ; i0 < rank ; i0 + + ) { ipos = i0 ; ax_j0 = ret [ i0 ] ; for ( i1 = i0 - <int> ; i1 > = <int> ; i1 - - ) { boolean ambig = true , shouldSwap = false ; ax_j1 = ret [ i1 ] ; for ( iarrays = <int> ; iarrays < arrays . length ; + + iarrays ) { if ( arrays [ iarrays ] . size ( ax_j0 ) ! = <int> & & arrays [ iarrays ] . size ( ax_j1 ) ! = <int> ) { if ( Math . abs ( arrays [ iarrays ] . stride ( ax_j0 ) ) < = Math . abs ( arrays [ iarrays ] . size ( ax_j1 ) ) ) { shouldSwap = false ; } else { if ( ambig ) { shouldSwap = true ; } } ambig = false ; } } if ( ! ambig ) { if ( shouldSwap ) { ipos = i1 ; } else { break ; } } } if ( ipos ! = i0 ) { for ( i1 = i0 ; i1 > ipos ; i1 - - ) { ret [ i1 ] = ret [ i1 - <int> ] ; } ret [ ipos ] = ax_j0 ; } } return ret ; } public static void assignArray ( INDArray destination , INDArray source ) { int [ ] newStrides ; if ( source . rank ( ) > destination . rank ( ) ) { int nDimTmp = source . rank ( ) ; int [ ] srcShape = Arrays . copyOf ( source . shape ( ) , source . rank ( ) ) ; int [ ] srcStrides = Arrays . copyOf ( source . stride ( ) , source . rank ( ) ) ; while ( nDimTmp > destination . rank ( ) & & srcShape [ <int> ] = = <int> ) { nDimTmp - - ; srcShape = Arrays . copyOfRange ( srcShape , <int> , srcShape . length ) ; srcStrides = Arrays . copyOfRange ( srcStrides , <int> , srcStrides . length ) ; } newStrides = broadcastStrides ( destination . rank ( ) , destination . shape ( ) , source . rank ( ) , source . shape ( ) , source . stride ( ) ) ; } else newStrides = broadcastStrides ( destination . rank ( ) , destination . shape ( ) , source . rank ( ) , source . shape ( ) , source . stride ( ) ) ; RawArrayIterationInformation2 rawIter = RawArrayIterationInformation2 . builder ( ) . nDim ( destination . rank ( ) ) . shape ( destination . shape ( ) ) . a ( destination . data ( ) ) . aStrides ( destination . stride ( ) ) . b ( source . data ( ) ) . bStrides ( newStrides ) . aOffset ( destination . offset ( ) ) . bOffset ( source . offset ( ) ) . build ( ) . computeOut ( ) ; int [ ] offsets = new int [ <int> ] ; int [ ] coords = new int [ rawIter . getNDim ( ) ] ; Shape . raw2dLoop ( <int> , rawIter . getNDim ( ) , coords , rawIter . getShape ( ) , offsets [ <int> ] , rawIter . getAStrides ( ) , offsets [ <int> ] , rawIter . getBStrides ( ) , rawIter , new CopyLoopFunction ( ) ) ; } public static int [ ] broadcastStrides ( int nDim , int [ ] shape , int numStrideDimensions , int [ ] strideShape , int [ ] strides ) { int iDimStart = nDim - numStrideDimensions ; if ( iDimStart < <int> ) throw new IllegalStateException ( <str> ) ; int [ ] newStrides = new int [ numStrideDimensions ] ; for ( int iDim = nDim - <int> ; iDim > = iDimStart ; iDim - - ) { int currShape = strideShape [ iDim - iDimStart ] ; if ( currShape = = <int> ) newStrides [ iDim ] = <int> ; else if ( currShape ! = shape [ iDim ] & & ! Shape . isVector ( strideShape ) & & ! Shape . isVector ( shape ) ) { throw new IllegalStateException ( <str> ) ; } else newStrides [ iDim ] = strides [ iDim - iDimStart ] ; } return newStrides ; } public static RawArrayIterationInformation1 prepareRawArrayIter ( INDArray dst ) { return RawArrayIterationInformation1 . builder ( ) . aOffset ( dst . offset ( ) ) . a ( dst . data ( ) ) . aStrides ( dst . stride ( ) ) . nDim ( dst . rank ( ) ) . shape ( dst . shape ( ) ) . build ( ) . computeOut ( ) ; } public static RawArrayIterationInformation2 prepareTwoRawArrayIter ( INDArray dst , INDArray src ) { return RawArrayIterationInformation2 . builder ( ) . aOffset ( dst . offset ( ) ) . a ( dst . data ( ) ) . b ( src . data ( ) ) . bOffset ( src . offset ( ) ) . aStrides ( dst . stride ( ) ) . bStrides ( src . stride ( ) ) . nDim ( dst . rank ( ) ) . shape ( dst . shape ( ) ) . build ( ) . computeOut ( ) ; } public static StridePermutation [ ] createSortedStrides ( int [ ] strides ) { StridePermutation [ ] perm = StridePermutation . create ( strides ) ; Arrays . sort ( perm ) ; return perm ; } public static INDArray newShapeNoCopy ( INDArray arr , int [ ] newShape , boolean isFOrder ) { int oldnd ; int [ ] olddims = ArrayUtil . copy ( arr . shape ( ) ) ; int [ ] oldstrides = ArrayUtil . copy ( arr . stride ( ) ) ; int np , op , last_stride ; int oi , oj , ok , ni , nj , nk ; int [ ] newStrides = new int [ newShape . length ] ; oldnd = <int> ; for ( oi = <int> ; oi < arr . rank ( ) ; oi + + ) { if ( arr . size ( oi ) ! = <int> ) { olddims [ oldnd ] = arr . size ( oi ) ; oldstrides [ oldnd ] = arr . stride ( oi ) ; oldnd + + ; } } np = <int> ; for ( ni = <int> ; ni < newShape . length ; ni + + ) { np * = newShape [ ni ] ; } op = <int> ; for ( oi = <int> ; oi < oldnd ; oi + + ) { op * = olddims [ oi ] ; } if ( np ! = op ) { return null ; } if ( np = = <int> ) { return null ; } oi = <int> ; oj = <int> ; ni = <int> ; nj = <int> ; while ( ni < newShape . length & & oi < oldnd ) { np = newShape [ ni ] ; op = olddims [ oi ] ; while ( np ! = op ) { if ( np < op ) { np * = newShape [ nj + + ] ; } else { op * = olddims [ oj + + ] ; } } for ( ok = oi ; ok < oj - <int> ; ok + + ) { if ( isFOrder ) { if ( oldstrides [ ok + <int> ] ! = olddims [ ok ] * oldstrides [ ok ] ) { return null ; } } else { if ( oldstrides [ ok ] ! = olddims [ ok + <int> ] * oldstrides [ ok + <int> ] ) { return null ; } } } if ( isFOrder ) { newStrides [ ni ] = oldstrides [ oi ] ; for ( nk = ni + <int> ; nk < nj ; nk + + ) { newStrides [ nk ] = newStrides [ nk - <int> ] * newShape [ nk - <int> ] ; } } else { newStrides [ nj - <int> ] = oldstrides [ oj - <int> ] ; for ( nk = nj - <int> ; nk > ni ; nk - - ) { newStrides [ nk - <int> ] = newStrides [ nk ] * newShape [ nk ] ; } } ni = nj + + ; oi = oj + + ; } if ( ni > = <int> ) { last_stride = newStrides [ ni - <int> ] ; } else { last_stride = arr . elementStride ( ) ; } if ( isFOrder ) { if ( ni > = <int> ) last_stride * = newShape [ ni - <int> ] ; } for ( nk = ni ; nk < newShape . length ; nk + + ) { newStrides [ nk ] = last_stride ; } if ( arr instanceof IComplexNDArray ) return Nd4j . createComplex ( arr . data ( ) , newShape , newStrides , arr . offset ( ) ) ; INDArray ret = Nd4j . create ( arr . data ( ) , newShape , newStrides , arr . offset ( ) ) ; return ret ; } public static boolean cOrFortranOrder ( int [ ] shape , int [ ] stride , int elementStride ) { int sd ; int dim ; int i ; boolean cContiguous = true ; boolean isFortran = true ; sd = <int> ; for ( i = shape . length - <int> ; i > = <int> ; - - i ) { dim = shape [ i ] ; if ( stride [ i ] ! = sd ) { cContiguous = false ; break ; } if ( dim = = <int> ) { break ; } sd * = dim ; } sd = elementStride ; for ( i = <int> ; i < shape . length ; + + i ) { dim = shape [ i ] ; if ( stride [ i ] ! = sd ) { isFortran = false ; } if ( dim = = <int> ) { break ; } sd * = dim ; } return cContiguous | | isFortran ; } public static char getOrder ( int [ ] shape , int [ ] stride , int elementStride ) { int sd ; int dim ; int i ; boolean cContiguous = true ; boolean isFortran = true ; sd = <int> ; for ( i = shape . length - <int> ; i > = <int> ; - - i ) { dim = shape [ i ] ; if ( stride [ i ] ! = sd ) { cContiguous = false ; break ; } if ( dim = = <int> ) { break ; } sd * = dim ; } sd = elementStride ; for ( i = <int> ; i < shape . length ; + + i ) { dim = shape [ i ] ; if ( stride [ i ] ! = sd ) { isFortran = false ; } if ( dim = = <int> ) { break ; } sd * = dim ; } if ( isFortran & & cContiguous ) return <str> ; else if ( isFortran & & ! cContiguous ) return <str> ; else if ( ! isFortran & & ! cContiguous ) return <str> ; else return <str> ; } public static char getOrder ( INDArray arr ) { return getOrder ( arr . shape ( ) , arr . stride ( ) , arr . elementStride ( ) ) ; } public static int sub2Ind ( int [ ] shape , int [ ] indices ) { int index = <int> ; int shift = <int> ; for ( int i = <int> ; i < shape . length ; i + + ) { index + = shift * indices [ i ] ; shift * = shape [ i ] ; } return index ; } public static int [ ] ind2sub ( int [ ] shape , int index , int numIndices ) { int denom = numIndices ; int [ ] ret = new int [ shape . length ] ; for ( int i = ret . length - <int> ; i > = <int> ; i - - ) { denom / = shape [ i ] ; ret [ i ] = index / denom ; index % = denom ; } return ret ; } public static int [ ] ind2sub ( int [ ] shape , int index ) { return ind2sub ( shape , index , ArrayUtil . prod ( shape ) ) ; } public static int [ ] ind2sub ( INDArray arr , int index ) { return ind2sub ( arr . shape ( ) , index , ArrayUtil . prod ( arr . shape ( ) ) ) ; } public static int [ ] ind2subC ( int [ ] shape , int index , int numIndices ) { int denom = numIndices ; int [ ] ret = new int [ shape . length ] ; for ( int i = <int> ; i < shape . length ; i + + ) { denom / = shape [ i ] ; ret [ i ] = index / denom ; index % = denom ; } return ret ; } public static boolean opIsWholeBufferWithMatchingStrides ( Op op ) { if ( op . y ( ) ! = null ) { return op . x ( ) . offset ( ) = = <int> & & op . n ( ) = = op . x ( ) . data ( ) . length ( ) & & op . y ( ) . offset ( ) = = <int> & & op . y ( ) . data ( ) . length ( ) = = op . n ( ) & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . data ( ) . length ( ) = = op . n ( ) & & Arrays . equals ( op . x ( ) . stride ( ) , op . y ( ) . stride ( ) ) & & Arrays . equals ( op . x ( ) . stride ( ) , op . z ( ) . stride ( ) ) & & ! ( op . x ( ) instanceof IComplexNDArray | | op . y ( ) instanceof IComplexNDArray ) ; } else { return op . x ( ) . offset ( ) = = <int> & & op . n ( ) = = op . x ( ) . data ( ) . length ( ) & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . data ( ) . length ( ) = = op . n ( ) & & Arrays . equals ( op . x ( ) . stride ( ) , op . z ( ) . stride ( ) ) & & ! ( op . x ( ) instanceof IComplexNDArray | | op . y ( ) instanceof IComplexNDArray ) ; } } public static boolean opIsWithMatchingStrides ( Op op ) { if ( op . y ( ) ! = null ) { return op . x ( ) . offset ( ) = = <int> & & op . n ( ) = = op . x ( ) . data ( ) . length ( ) & & op . y ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & Arrays . equals ( op . x ( ) . stride ( ) , op . y ( ) . stride ( ) ) & & Arrays . equals ( op . x ( ) . stride ( ) , op . z ( ) . stride ( ) ) & & ! ( op . x ( ) instanceof IComplexNDArray | | op . y ( ) instanceof IComplexNDArray ) ; } else { return op . x ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & op . z ( ) . offset ( ) = = <int> & & Arrays . equals ( op . x ( ) . stride ( ) , op . z ( ) . stride ( ) ) & & ! ( op . x ( ) instanceof IComplexNDArray | | op . y ( ) instanceof IComplexNDArray ) ; } } public static int [ ] ind2subC ( int [ ] shape , int index ) { return ind2subC ( shape , index , ArrayUtil . prod ( shape ) ) ; } public static int [ ] ind2subC ( INDArray arr , int index ) { return ind2subC ( arr . shape ( ) , index , ArrayUtil . prod ( arr . shape ( ) ) ) ; } public static int offsetFor ( INDArray arr , int [ ] indexes ) { ShapeOffsetResolution resolution = new ShapeOffsetResolution ( arr ) ; resolution . exec ( Shape . toIndexes ( indexes ) ) ; return resolution . getOffset ( ) ; } public static int offsetFor ( INDArray arr , int index ) { int [ ] indexes = arr . ordering ( ) = = <str> ? Shape . ind2subC ( arr , index ) : Shape . ind2sub ( arr , index ) ; return offsetFor ( arr , indexes ) ; } public static void assertShapeLessThan ( int [ ] shape , int [ ] lessThan ) { if ( shape . length ! = lessThan . length ) { throw new IllegalArgumentException ( <str> ) ; } for ( int i = <int> ; i < shape . length ; i + + ) { if ( shape [ i ] > = lessThan [ i ] ) throw new IllegalStateException ( <str> + i + <str> + i + <str> ) ; } } public static int [ ] moveOnesToEnd ( int [ ] shape ) { List < Integer > nonOnes = new ArrayList < > ( ) ; List < Integer > ones = new ArrayList < > ( ) ; for ( int i = <int> ; i < shape . length ; i + + ) { if ( shape [ i ] = = <int> ) ones . add ( i ) ; else nonOnes . add ( i ) ; } return Ints . concat ( Ints . toArray ( nonOnes ) , Ints . toArray ( ones ) ) ; } public static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { INDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = new NDArrayIndex ( indices [ i ] ) ; return ret ; } public static int [ ] newStrides ( int [ ] strides , int newLength , INDArrayIndex [ ] indexes ) { if ( strides . length > newLength ) { int [ ] newStrides = new int [ strides . length - <int> ] ; for ( int i = <int> ; i < newStrides . length ; i + + ) { newStrides [ i ] = strides [ i + <int> ] ; } strides = newStrides ; } return strides ; } public static int [ ] newOffsets ( int [ ] offsets , int newLength , INDArrayIndex [ ] indexes ) { if ( offsets . length > newLength ) { int [ ] newOffsets = new int [ offsets . length - <int> ] ; for ( int i = <int> ; i < newOffsets . length ; i + + ) { newOffsets [ i ] = offsets [ i + <int> ] ; } offsets = newOffsets ; } return offsets ; } public static int [ ] squeezeOffsets ( int [ ] shape , int [ ] offsets ) { List < Integer > squeezeIndices = new ArrayList < > ( ) ; for ( int i = <int> ; i < shape . length ; i + + ) if ( offsets [ i ] = = <int> ) squeezeIndices . add ( i ) ; int [ ] ret = ArrayUtil . removeIndex ( offsets , Ints . toArray ( squeezeIndices ) ) ; int delta = Math . abs ( ret . length - shape . length ) ; if ( delta = = <int> ) return ret ; else { if ( ret . length > shape . length ) throw new IllegalStateException ( <str> ) ; int [ ] retOffsets = new int [ shape . length ] ; System . arraycopy ( ret , <int> , retOffsets , <int> , ret . length ) ; return retOffsets ; } } public static boolean squeezeEquals ( int [ ] test1 , int [ ] test2 ) { int [ ] s1 = squeeze ( test1 ) ; int [ ] s2 = squeeze ( test2 ) ; return scalarEquals ( s1 , s2 ) | | Arrays . equals ( s1 , s2 ) ; } public static boolean strideDescendingCAscendingF ( INDArray array ) { int [ ] strides = array . stride ( ) ; if ( array . isVector ( ) & & strides [ <int> ] = = <int> & & strides [ <int> ] = = <int> ) return true ; char order = array . ordering ( ) ; if ( order = = <str> ) { for ( int i = <int> ; i < strides . length ; i + + ) if ( strides [ i - <int> ] < = strides [ i ] ) return false ; return true ; } else if ( order = = <str> ) { for ( int i = <int> ; i < strides . length ; i + + ) if ( strides [ i - <int> ] > = strides [ i ] ) return false ; return true ; } else if ( order = = <str> ) { return true ; } else { throw new RuntimeException ( <str> + order + <str> ) ; } } public static boolean isContiguousInBuffer ( INDArray in ) { int length = in . length ( ) ; int dLength = in . data ( ) . length ( ) ; if ( length = = dLength ) return true ; char order = in . ordering ( ) ; int [ ] shape = in . shape ( ) ; int [ ] stridesIfContiguous ; if ( order = = <str> ) { stridesIfContiguous = ArrayUtil . calcStridesFortran ( shape ) ; } else if ( order = = <str> ) { stridesIfContiguous = ArrayUtil . calcStrides ( shape ) ; } else if ( order = = <str> ) { stridesIfContiguous = new int [ ] { <int> , <int> } ; } else { throw new RuntimeException ( <str> + order + <str> ) ; } return Arrays . equals ( in . stride ( ) , stridesIfContiguous ) ; } } 
