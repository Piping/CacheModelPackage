package org . elasticsearch . bootstrap ; import org . elasticsearch . common . SuppressForbidden ; import java . net . SocketPermission ; import java . net . URL ; import java . security . CodeSource ; import java . security . Permission ; import java . security . PermissionCollection ; import java . security . Permissions ; import java . security . Policy ; import java . security . ProtectionDomain ; import java . util . Map ; final class ESPolicy extends Policy { static final String POLICY_RESOURCE = <str> ; static final String UNTRUSTED_RESOURCE = <str> ; final Policy template ; final Policy untrusted ; final Policy system ; final PermissionCollection dynamic ; final Map < String , Policy > plugins ; public ESPolicy ( PermissionCollection dynamic , Map < String , Policy > plugins , boolean filterBadDefaults ) { this . template = Security . readPolicy ( getClass ( ) . getResource ( POLICY_RESOURCE ) , JarHell . parseClassPath ( ) ) ; this . untrusted = Security . readPolicy ( getClass ( ) . getResource ( UNTRUSTED_RESOURCE ) , new URL [ <int> ] ) ; if ( filterBadDefaults ) { this . system = new SystemPolicy ( Policy . getPolicy ( ) ) ; } else { this . system = Policy . getPolicy ( ) ; } this . dynamic = dynamic ; this . plugins = plugins ; } @Override @SuppressForbidden ( reason = <str> ) public boolean implies ( ProtectionDomain domain , Permission permission ) { CodeSource codeSource = domain . getCodeSource ( ) ; if ( codeSource = = null ) { return false ; } URL location = codeSource . getLocation ( ) ; if ( location ! = null ) { if ( BootstrapInfo . UNTRUSTED_CODEBASE . equals ( location . getFile ( ) ) ) { return untrusted . implies ( domain , permission ) ; } Policy plugin = plugins . get ( location . getFile ( ) ) ; if ( plugin ! = null & & plugin . implies ( domain , permission ) ) { return true ; } } return template . implies ( domain , permission ) | | dynamic . implies ( permission ) | | system . implies ( domain , permission ) ; } @Override public PermissionCollection getPermissions ( CodeSource codesource ) { for ( StackTraceElement element : Thread . currentThread ( ) . getStackTrace ( ) ) { if ( <str> . equals ( element . getClassName ( ) ) & & <str> . equals ( element . getMethodName ( ) ) ) { return new Permissions ( ) ; } } return super . getPermissions ( codesource ) ; } static final Permission BAD_DEFAULT_NUMBER_ONE = new RuntimePermission ( <str> ) ; static final Permission BAD_DEFAULT_NUMBER_TWO = new SocketPermission ( <str> , <str> ) ; static class SystemPolicy extends Policy { final Policy delegate ; SystemPolicy ( Policy delegate ) { this . delegate = delegate ; } @Override public boolean implies ( ProtectionDomain domain , Permission permission ) { if ( BAD_DEFAULT_NUMBER_ONE . equals ( permission ) | | BAD_DEFAULT_NUMBER_TWO . equals ( permission ) ) { return false ; } return delegate . implies ( domain , permission ) ; } } } 
