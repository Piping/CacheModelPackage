package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . MoreObjects ; import com . google . j2objc . annotations . Weak ; import java . io . IOException ; import java . io . InvalidObjectException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) public class ImmutableSetMultimap < K , V > extends ImmutableMultimap < K , V > implements SetMultimap < K , V > { @SuppressWarnings ( <str> ) public static < K , V > ImmutableSetMultimap < K , V > of ( ) { return ( ImmutableSetMultimap < K , V > ) EmptyImmutableSetMultimap . INSTANCE ; } public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 ) { ImmutableSetMultimap . Builder < K , V > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; return builder . build ( ) ; } public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { ImmutableSetMultimap . Builder < K , V > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; return builder . build ( ) ; } public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { ImmutableSetMultimap . Builder < K , V > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; builder . put ( k3 , v3 ) ; return builder . build ( ) ; } public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { ImmutableSetMultimap . Builder < K , V > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; builder . put ( k3 , v3 ) ; builder . put ( k4 , v4 ) ; return builder . build ( ) ; } public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { ImmutableSetMultimap . Builder < K , V > builder = ImmutableSetMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; builder . put ( k2 , v2 ) ; builder . put ( k3 , v3 ) ; builder . put ( k4 , v4 ) ; builder . put ( k5 , v5 ) ; return builder . build ( ) ; } public static < K , V > Builder < K , V > builder ( ) { return new Builder < K , V > ( ) ; } public static final class Builder < K , V > extends ImmutableMultimap . Builder < K , V > { public Builder ( ) { super ( MultimapBuilder . linkedHashKeys ( ) . linkedHashSetValues ( ) . < K , V > build ( ) ) ; } @Override public Builder < K , V > put ( K key , V value ) { builderMultimap . put ( checkNotNull ( key ) , checkNotNull ( value ) ) ; return this ; } @Override public Builder < K , V > put ( Entry < ? extends K , ? extends V > entry ) { builderMultimap . put ( checkNotNull ( entry . getKey ( ) ) , checkNotNull ( entry . getValue ( ) ) ) ; return this ; } @Beta @Override public Builder < K , V > putAll ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { super . putAll ( entries ) ; return this ; } @Override public Builder < K , V > putAll ( K key , Iterable < ? extends V > values ) { Collection < V > collection = builderMultimap . get ( checkNotNull ( key ) ) ; for ( V value : values ) { collection . add ( checkNotNull ( value ) ) ; } return this ; } @Override public Builder < K , V > putAll ( K key , V . . . values ) { return putAll ( key , Arrays . asList ( values ) ) ; } @Override public Builder < K , V > putAll ( Multimap < ? extends K , ? extends V > multimap ) { for ( Entry < ? extends K , ? extends Collection < ? extends V > > entry : multimap . asMap ( ) . entrySet ( ) ) { putAll ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; } @Override public Builder < K , V > orderKeysBy ( Comparator < ? super K > keyComparator ) { this . keyComparator = checkNotNull ( keyComparator ) ; return this ; } @Override public Builder < K , V > orderValuesBy ( Comparator < ? super V > valueComparator ) { super . orderValuesBy ( valueComparator ) ; return this ; } @Override public ImmutableSetMultimap < K , V > build ( ) { if ( keyComparator ! = null ) { Multimap < K , V > sortedCopy = MultimapBuilder . linkedHashKeys ( ) . linkedHashSetValues ( ) . < K , V > build ( ) ; List < Map . Entry < K , Collection < V > > > entries = Ordering . from ( keyComparator ) . < K > onKeys ( ) . immutableSortedCopy ( builderMultimap . asMap ( ) . entrySet ( ) ) ; for ( Map . Entry < K , Collection < V > > entry : entries ) { sortedCopy . putAll ( entry . getKey ( ) , entry . getValue ( ) ) ; } builderMultimap = sortedCopy ; } return copyOf ( builderMultimap , valueComparator ) ; } } public static < K , V > ImmutableSetMultimap < K , V > copyOf ( Multimap < ? extends K , ? extends V > multimap ) { return copyOf ( multimap , null ) ; } private static < K , V > ImmutableSetMultimap < K , V > copyOf ( Multimap < ? extends K , ? extends V > multimap , Comparator < ? super V > valueComparator ) { checkNotNull ( multimap ) ; if ( multimap . isEmpty ( ) & & valueComparator = = null ) { return of ( ) ; } if ( multimap instanceof ImmutableSetMultimap ) { @SuppressWarnings ( <str> ) ImmutableSetMultimap < K , V > kvMultimap = ( ImmutableSetMultimap < K , V > ) multimap ; if ( ! kvMultimap . isPartialView ( ) ) { return kvMultimap ; } } ImmutableMap . Builder < K , ImmutableSet < V > > builder = new ImmutableMap . Builder < K , ImmutableSet < V > > ( multimap . asMap ( ) . size ( ) ) ; int size = <int> ; for ( Entry < ? extends K , ? extends Collection < ? extends V > > entry : multimap . asMap ( ) . entrySet ( ) ) { K key = entry . getKey ( ) ; Collection < ? extends V > values = entry . getValue ( ) ; ImmutableSet < V > set = valueSet ( valueComparator , values ) ; if ( ! set . isEmpty ( ) ) { builder . put ( key , set ) ; size + = set . size ( ) ; } } return new ImmutableSetMultimap < K , V > ( builder . build ( ) , size , valueComparator ) ; } @Beta public static < K , V > ImmutableSetMultimap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { return new Builder < K , V > ( ) . putAll ( entries ) . build ( ) ; } private final transient ImmutableSet < V > emptySet ; ImmutableSetMultimap ( ImmutableMap < K , ImmutableSet < V > > map , int size , @Nullable Comparator < ? super V > valueComparator ) { super ( map , size ) ; this . emptySet = emptySet ( valueComparator ) ; } @Override public ImmutableSet < V > get ( @Nullable K key ) { ImmutableSet < V > set = ( ImmutableSet < V > ) map . get ( key ) ; return MoreObjects . firstNonNull ( set , emptySet ) ; } private transient ImmutableSetMultimap < V , K > inverse ; public ImmutableSetMultimap < V , K > inverse ( ) { ImmutableSetMultimap < V , K > result = inverse ; return ( result = = null ) ? ( inverse = invert ( ) ) : result ; } private ImmutableSetMultimap < V , K > invert ( ) { Builder < V , K > builder = builder ( ) ; for ( Entry < K , V > entry : entries ( ) ) { builder . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } ImmutableSetMultimap < V , K > invertedMultimap = builder . build ( ) ; invertedMultimap . inverse = this ; return invertedMultimap ; } @Deprecated @Override public ImmutableSet < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public ImmutableSet < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } private transient ImmutableSet < Entry < K , V > > entries ; @Override public ImmutableSet < Entry < K , V > > entries ( ) { ImmutableSet < Entry < K , V > > result = entries ; return result = = null ? ( entries = new EntrySet < K , V > ( this ) ) : result ; } private static final class EntrySet < K , V > extends ImmutableSet < Entry < K , V > > { @Weak private final transient ImmutableSetMultimap < K , V > multimap ; EntrySet ( ImmutableSetMultimap < K , V > multimap ) { this . multimap = multimap ; } @Override public boolean contains ( @Nullable Object object ) { if ( object instanceof Entry ) { Entry < ? , ? > entry = ( Entry < ? , ? > ) object ; return multimap . containsEntry ( entry . getKey ( ) , entry . getValue ( ) ) ; } return false ; } @Override public int size ( ) { return multimap . size ( ) ; } @Override public UnmodifiableIterator < Entry < K , V > > iterator ( ) { return multimap . entryIterator ( ) ; } @Override boolean isPartialView ( ) { return false ; } } private static < V > ImmutableSet < V > valueSet ( @Nullable Comparator < ? super V > valueComparator , Collection < ? extends V > values ) { return ( valueComparator = = null ) ? ImmutableSet . copyOf ( values ) : ImmutableSortedSet . copyOf ( valueComparator , values ) ; } private static < V > ImmutableSet < V > emptySet ( @Nullable Comparator < ? super V > valueComparator ) { return ( valueComparator = = null ) ? ImmutableSet . < V > of ( ) : ImmutableSortedSet . < V > emptySet ( valueComparator ) ; } private static < V > ImmutableSet . Builder < V > valuesBuilder ( @Nullable Comparator < ? super V > valueComparator ) { return ( valueComparator = = null ) ? new ImmutableSet . Builder < V > ( ) : new ImmutableSortedSet . Builder < V > ( valueComparator ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( valueComparator ( ) ) ; Serialization . writeMultimap ( this , stream ) ; } @Nullable Comparator < ? super V > valueComparator ( ) { return emptySet instanceof ImmutableSortedSet ? ( ( ImmutableSortedSet < V > ) emptySet ) . comparator ( ) : null ; } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; Comparator < Object > valueComparator = ( Comparator < Object > ) stream . readObject ( ) ; int keyCount = stream . readInt ( ) ; if ( keyCount < <int> ) { throw new InvalidObjectException ( <str> + keyCount ) ; } ImmutableMap . Builder < Object , ImmutableSet < Object > > builder = ImmutableMap . builder ( ) ; int tmpSize = <int> ; for ( int i = <int> ; i < keyCount ; i + + ) { Object key = stream . readObject ( ) ; int valueCount = stream . readInt ( ) ; if ( valueCount < = <int> ) { throw new InvalidObjectException ( <str> + valueCount ) ; } ImmutableSet . Builder < Object > valuesBuilder = valuesBuilder ( valueComparator ) ; for ( int j = <int> ; j < valueCount ; j + + ) { valuesBuilder . add ( stream . readObject ( ) ) ; } ImmutableSet < Object > valueSet = valuesBuilder . build ( ) ; if ( valueSet . size ( ) ! = valueCount ) { throw new InvalidObjectException ( <str> + key ) ; } builder . put ( key , valueSet ) ; tmpSize + = valueCount ; } ImmutableMap < Object , ImmutableSet < Object > > tmpMap ; try { tmpMap = builder . build ( ) ; } catch ( IllegalArgumentException e ) { throw ( InvalidObjectException ) new InvalidObjectException ( e . getMessage ( ) ) . initCause ( e ) ; } FieldSettersHolder . MAP_FIELD_SETTER . set ( this , tmpMap ) ; FieldSettersHolder . SIZE_FIELD_SETTER . set ( this , tmpSize ) ; FieldSettersHolder . EMPTY_SET_FIELD_SETTER . set ( this , emptySet ( valueComparator ) ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } 
