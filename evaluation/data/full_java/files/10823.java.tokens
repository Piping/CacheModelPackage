package org . gradle . internal . classloader ; import com . google . common . collect . ImmutableList ; import org . gradle . internal . reflect . JavaMethod ; import org . gradle . internal . reflect . JavaReflectionUtil ; import java . io . IOException ; import java . net . URL ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; public class MultiParentClassLoader extends ClassLoader implements ClassLoaderHierarchy { private static final JavaMethod < ClassLoader , Package [ ] > GET_PACKAGES_METHOD = JavaReflectionUtil . method ( ClassLoader . class , Package [ ] . class , <str> ) ; private static final JavaMethod < ClassLoader , Package > GET_PACKAGE_METHOD = JavaReflectionUtil . method ( ClassLoader . class , Package . class , <str> , String . class ) ; private final List < ClassLoader > parents ; public MultiParentClassLoader ( ClassLoader . . . parents ) { this ( Arrays . asList ( parents ) ) ; } public MultiParentClassLoader ( Collection < ? extends ClassLoader > parents ) { super ( null ) ; this . parents = new CopyOnWriteArrayList < ClassLoader > ( parents ) ; } public void addParent ( ClassLoader parent ) { parents . add ( parent ) ; } public List < ClassLoader > getParents ( ) { return ImmutableList . copyOf ( parents ) ; } public void visit ( ClassLoaderVisitor visitor ) { visitor . visitSpec ( new Spec ( ) ) ; for ( ClassLoader parent : parents ) { visitor . visitParent ( parent ) ; } } @Override protected Class < ? > loadClass ( String name , boolean resolve ) throws ClassNotFoundException { for ( ClassLoader parent : parents ) { try { return parent . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { } } throw new ClassNotFoundException ( String . format ( <str> , name ) ) ; } @Override protected Package getPackage ( String name ) { for ( ClassLoader parent : parents ) { Package p = GET_PACKAGE_METHOD . invoke ( parent , name ) ; if ( p ! = null ) { return p ; } } return null ; } @Override protected Package [ ] getPackages ( ) { Set < Package > packages = new LinkedHashSet < Package > ( ) ; for ( ClassLoader parent : parents ) { Package [ ] parentPackages = GET_PACKAGES_METHOD . invoke ( parent ) ; packages . addAll ( Arrays . asList ( parentPackages ) ) ; } return packages . toArray ( new Package [ packages . size ( ) ] ) ; } @Override public URL getResource ( String name ) { for ( ClassLoader parent : parents ) { URL resource = parent . getResource ( name ) ; if ( resource ! = null ) { return resource ; } } return null ; } @Override public Enumeration < URL > getResources ( String name ) throws IOException { Set < URL > resources = new LinkedHashSet < URL > ( ) ; for ( ClassLoader parent : parents ) { Enumeration < URL > parentResources = parent . getResources ( name ) ; while ( parentResources . hasMoreElements ( ) ) { resources . add ( parentResources . nextElement ( ) ) ; } } return Collections . enumeration ( resources ) ; } public static class Spec extends ClassLoaderSpec { @Override public boolean equals ( Object obj ) { return obj ! = null & & obj . getClass ( ) . equals ( Spec . class ) ; } @Override public int hashCode ( ) { return getClass ( ) . getName ( ) . hashCode ( ) ; } } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( ! ( o instanceof MultiParentClassLoader ) ) { return false ; } MultiParentClassLoader that = ( MultiParentClassLoader ) o ; return parents . equals ( that . parents ) ; } @Override public int hashCode ( ) { return parents . hashCode ( ) ; } } 
