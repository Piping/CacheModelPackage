package com . badlogic . gdx . backends . gwt . preloader ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . net . URLConnection ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map . Entry ; import com . badlogic . gdx . backends . gwt . preloader . AssetFilter . AssetType ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . google . gwt . core . ext . BadPropertyValueException ; import com . google . gwt . core . ext . ConfigurationProperty ; import com . google . gwt . core . ext . Generator ; import com . google . gwt . core . ext . GeneratorContext ; import com . google . gwt . core . ext . TreeLogger ; import com . google . gwt . core . ext . UnableToCompleteException ; import com . google . gwt . user . rebind . ClassSourceFileComposerFactory ; import com . google . gwt . user . rebind . SourceWriter ; public class PreloaderBundleGenerator extends Generator { private class Asset { FileWrapper file ; AssetType type ; public Asset ( FileWrapper file , AssetType type ) { this . file = file ; this . type = type ; } } @Override public String generate ( TreeLogger logger , GeneratorContext context , String typeName ) throws UnableToCompleteException { System . out . println ( new File ( <str> ) . getAbsolutePath ( ) ) ; String assetPath = getAssetPath ( context ) ; String assetOutputPath = getAssetOutputPath ( context ) ; if ( assetOutputPath = = null ) { assetOutputPath = <str> ; } AssetFilter assetFilter = getAssetFilter ( context ) ; FileWrapper source = new FileWrapper ( assetPath ) ; if ( ! source . exists ( ) ) { source = new FileWrapper ( <str> + assetPath ) ; if ( ! source . exists ( ) ) throw new RuntimeException ( <str> + assetPath + <str> ) ; } if ( ! source . isDirectory ( ) ) throw new RuntimeException ( <str> + assetPath + <str> ) ; System . out . println ( <str> + assetPath + <str> + assetOutputPath ) ; System . out . println ( source . file . getAbsolutePath ( ) ) ; FileWrapper target = new FileWrapper ( <str> ) ; System . out . println ( target . file . getAbsolutePath ( ) ) ; if ( ! target . file . getAbsolutePath ( ) . replace ( <str> , <str> ) . endsWith ( assetOutputPath + <str> ) ) { target = new FileWrapper ( assetOutputPath + <str> ) ; } if ( target . exists ( ) ) { if ( ! target . deleteDirectory ( ) ) throw new RuntimeException ( <str> + target + <str> ) ; } ArrayList < Asset > assets = new ArrayList < Asset > ( ) ; copyDirectory ( source , target , assetFilter , assets ) ; List < String > classpathFiles = getClasspathFiles ( context ) ; for ( String classpathFile : classpathFiles ) { if ( assetFilter . accept ( classpathFile , false ) ) { try { InputStream is = context . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( classpathFile ) ; FileWrapper dest = target . child ( classpathFile ) ; dest . write ( is , false ) ; assets . add ( new Asset ( dest , assetFilter . getType ( dest . path ( ) ) ) ) ; is . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } HashMap < String , ArrayList < Asset > > bundles = new HashMap < String , ArrayList < Asset > > ( ) ; for ( Asset asset : assets ) { String bundleName = assetFilter . getBundleName ( asset . file . path ( ) ) ; if ( bundleName = = null ) { bundleName = <str> ; } ArrayList < Asset > bundleAssets = bundles . get ( bundleName ) ; if ( bundleAssets = = null ) { bundleAssets = new ArrayList < Asset > ( ) ; bundles . put ( bundleName , bundleAssets ) ; } bundleAssets . add ( asset ) ; } for ( Entry < String , ArrayList < Asset > > bundle : bundles . entrySet ( ) ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Asset asset : bundle . getValue ( ) ) { String path = asset . file . path ( ) . replace ( <str> , <str> ) . replace ( assetOutputPath , <str> ) . replaceFirst ( <str> , <str> ) ; if ( path . startsWith ( <str> ) ) path = path . substring ( <int> ) ; buffer . append ( asset . type . code ) ; buffer . append ( <str> ) ; buffer . append ( path ) ; buffer . append ( <str> ) ; buffer . append ( asset . file . isDirectory ( ) ? <int> : asset . file . length ( ) ) ; buffer . append ( <str> ) ; String mimetype = URLConnection . guessContentTypeFromName ( asset . file . name ( ) ) ; buffer . append ( mimetype = = null ? <str> : mimetype ) ; buffer . append ( <str> ) ; } target . child ( bundle . getKey ( ) + <str> ) . writeString ( buffer . toString ( ) , false ) ; } return createDummyClass ( logger , context ) ; } private void copyFile ( FileWrapper source , FileWrapper dest , AssetFilter filter , ArrayList < Asset > assets ) { if ( ! filter . accept ( dest . path ( ) , false ) ) return ; try { assets . add ( new Asset ( dest , filter . getType ( dest . path ( ) ) ) ) ; dest . write ( source . read ( ) , false ) ; } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> + source + <str> + <str> + dest , ex ) ; } } private void copyDirectory ( FileWrapper sourceDir , FileWrapper destDir , AssetFilter filter , ArrayList < Asset > assets ) { if ( ! filter . accept ( destDir . path ( ) , true ) ) return ; assets . add ( new Asset ( destDir , AssetType . Directory ) ) ; destDir . mkdirs ( ) ; FileWrapper [ ] files = sourceDir . list ( ) ; for ( int i = <int> , n = files . length ; i < n ; i + + ) { FileWrapper srcFile = files [ i ] ; FileWrapper destFile = destDir . child ( srcFile . name ( ) ) ; if ( srcFile . isDirectory ( ) ) copyDirectory ( srcFile , destFile , filter , assets ) ; else copyFile ( srcFile , destFile , filter , assets ) ; } } private AssetFilter getAssetFilter ( GeneratorContext context ) { ConfigurationProperty assetFilterClassProperty = null ; try { assetFilterClassProperty = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; } catch ( BadPropertyValueException e ) { return new DefaultAssetFilter ( ) ; } if ( assetFilterClassProperty . getValues ( ) . size ( ) = = <int> ) { return new DefaultAssetFilter ( ) ; } String assetFilterClass = assetFilterClassProperty . getValues ( ) . get ( <int> ) ; if ( assetFilterClass = = null ) return new DefaultAssetFilter ( ) ; try { return ( AssetFilter ) Class . forName ( assetFilterClass ) . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> + assetFilterClass + <str> , e ) ; } } private String getAssetPath ( GeneratorContext context ) { ConfigurationProperty assetPathProperty = null ; try { assetPathProperty = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; } catch ( BadPropertyValueException e ) { throw new RuntimeException ( <str> ) ; } if ( assetPathProperty . getValues ( ) . size ( ) = = <int> ) { throw new RuntimeException ( <str> ) ; } String paths = assetPathProperty . getValues ( ) . get ( <int> ) ; if ( paths = = null ) { throw new RuntimeException ( <str> ) ; } else { ArrayList < String > existingPaths = new ArrayList < String > ( ) ; String [ ] tokens = paths . split ( <str> ) ; for ( String token : tokens ) { System . out . println ( token ) ; if ( new FileWrapper ( token ) . exists ( ) | | new FileWrapper ( <str> + token ) . exists ( ) ) { return token ; } } throw new RuntimeException ( <str> ) ; } } private String getAssetOutputPath ( GeneratorContext context ) { ConfigurationProperty assetPathProperty = null ; try { assetPathProperty = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; } catch ( BadPropertyValueException e ) { return null ; } if ( assetPathProperty . getValues ( ) . size ( ) = = <int> ) { return null ; } String paths = assetPathProperty . getValues ( ) . get ( <int> ) ; if ( paths = = null ) { return null ; } else { ArrayList < String > existingPaths = new ArrayList < String > ( ) ; String [ ] tokens = paths . split ( <str> ) ; String path = null ; for ( String token : tokens ) { if ( new FileWrapper ( token ) . exists ( ) | | new FileWrapper ( token ) . mkdirs ( ) ) { path = token ; } } if ( path ! = null & & ! path . endsWith ( <str> ) ) { path + = <str> ; } return path ; } } private List < String > getClasspathFiles ( GeneratorContext context ) { List < String > classpathFiles = new ArrayList < String > ( ) ; try { ConfigurationProperty prop = context . getPropertyOracle ( ) . getConfigurationProperty ( <str> ) ; for ( String value : prop . getValues ( ) ) { classpathFiles . add ( value ) ; } } catch ( BadPropertyValueException e ) { } return classpathFiles ; } private String createDummyClass ( TreeLogger logger , GeneratorContext context ) { String packageName = <str> ; String className = <str> ; ClassSourceFileComposerFactory composer = new ClassSourceFileComposerFactory ( packageName , className ) ; composer . addImplementedInterface ( packageName + <str> ) ; PrintWriter printWriter = context . tryCreate ( logger , packageName , className ) ; if ( printWriter = = null ) { return packageName + <str> + className ; } SourceWriter sourceWriter = composer . createSourceWriter ( context , printWriter ) ; sourceWriter . commit ( logger ) ; return packageName + <str> + className ; } } 
