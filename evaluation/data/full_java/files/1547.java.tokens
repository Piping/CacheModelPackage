package org . apache . cassandra . index . internal ; import java . util . stream . Collectors ; import java . util . stream . Stream ; import java . util . stream . StreamSupport ; import com . google . common . base . Joiner ; import com . google . common . collect . * ; import org . junit . Before ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ClusteringIndexFilter ; import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . rows . Unfiltered ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . Util . throwAssert ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . fail ; public class CassandraIndexTest extends CQLTester { @Test public void indexOnRegularColumn ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> , <int> ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnFirstClusteringColumn ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> , <int> ) ) . missingIndexMessage ( SelectStatement . REQUIRES_ALLOW_FILTERING_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnSecondClusteringColumn ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> , <int> , <int> ) ) . missingIndexMessage ( String . format ( <str> + <str> , <str> , <str> ) ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnFirstPartitionKeyColumn ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , <int> , <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> , <int> , <int> , <int> ) ) . missingIndexMessage ( <str> ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnSecondPartitionKeyColumn ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , <int> , <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> , <int> , <int> , <int> ) ) . missingIndexMessage ( <str> ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenListWithReplaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenListWithInPlaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenSetWithReplaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenSetWithInPlaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapValuesWithReplaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapValuesWithInPlaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapKeysWithReplaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapKeysWithInPlaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapEntriesWithReplaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnNonFrozenMapEntriesWithInPlaceOperation ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnFrozenList ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Lists . newArrayList ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnFrozenSet ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , Sets . newHashSet ( <int> , <int> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnFrozenMap ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . withSecondRow ( row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void indexOnRegularColumnWithCompactStorage ( ) throws Throwable { new TestScript ( ) . tableDefinition ( <str> ) . target ( <str> ) . indexName ( <str> ) . withFirstRow ( row ( <int> , <int> ) ) . withSecondRow ( row ( <int> , <int> ) ) . missingIndexMessage ( StatementRestrictions . NO_INDEX_FOUND_MESSAGE ) . firstQueryExpression ( <str> ) . secondQueryExpression ( <str> ) . updateExpression ( <str> ) . postUpdateQueryExpression ( <str> ) . run ( ) ; } @Test public void createIndexesOnMultipleMapDimensions ( ) throws Throwable { Object [ ] row1 = row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Object [ ] row2 = row ( <int> , <int> , ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; createTable ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; execute ( <str> , row1 ) ; execute ( <str> , row2 ) ; assertRows ( execute ( <str> ) , row1 ) ; assertRows ( execute ( <str> ) , row1 ) ; assertRows ( execute ( <str> ) , row2 ) ; assertRows ( execute ( <str> ) , row2 ) ; } @Test public void insertWithTombstoneRemovesEntryFromIndex ( ) throws Throwable { int key = <int> ; int indexedValue = <int> ; createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> , key , indexedValue ) ; assertRows ( execute ( <str> , indexedValue ) , row ( key , indexedValue ) ) ; execute ( <str> , key ) ; assertEmpty ( execute ( <str> , indexedValue ) ) ; } @Test public void updateTTLOnIndexedClusteringValue ( ) throws Throwable { int basePk = <int> ; int indexedVal = <int> ; int initialTtl = <int> ; createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> , basePk , indexedVal , initialTtl ) ; ColumnFamilyStore baseCfs = getCurrentColumnFamilyStore ( ) ; ColumnFamilyStore indexCfs = baseCfs . indexManager . listIndexes ( ) . iterator ( ) . next ( ) . getBackingTable ( ) . orElseThrow ( throwAssert ( <str> ) ) ; assertIndexRowTtl ( indexCfs , indexedVal , initialTtl ) ; int updatedTtl = <int> ; execute ( <str> , basePk , indexedVal , updatedTtl ) ; assertIndexRowTtl ( indexCfs , indexedVal , updatedTtl ) ; } @Test public void indexBatchStatements ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> + <str> + <str> + <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> + <str> + <str> + <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; } @Test public void indexStatementsWithConditions ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> ) ; assertEmpty ( execute ( <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; assertEmpty ( execute ( <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> ) ; assertEmpty ( execute ( <str> ) ) ; execute ( <str> + <str> + <str> + <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; } @Test public void indexCorrectlyMarkedAsBuildAndRemoved ( ) throws Throwable { String indexName = <str> ; String tableName = createTable ( <str> ) ; createIndex ( String . format ( <str> , indexName ) ) ; waitForIndex ( KEYSPACE , tableName , indexName ) ; assertRows ( execute ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BUILT_INDEXES ) ) , row ( KEYSPACE , indexName ) ) ; getCurrentColumnFamilyStore ( ) . rebuildSecondaryIndex ( indexName ) ; waitForIndex ( KEYSPACE , tableName , indexName ) ; assertRows ( execute ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BUILT_INDEXES ) ) , row ( KEYSPACE , indexName ) ) ; } private void assertIndexRowTtl ( ColumnFamilyStore indexCfs , int indexedValue , int ttl ) throws Throwable { DecoratedKey indexKey = indexCfs . decorateKey ( ByteBufferUtil . bytes ( indexedValue ) ) ; ClusteringIndexFilter filter = new ClusteringIndexSliceFilter ( Slices . with ( indexCfs . metadata . comparator , Slice . ALL ) , false ) ; SinglePartitionReadCommand command = SinglePartitionReadCommand . create ( indexCfs . metadata , FBUtilities . nowInSeconds ( ) , indexKey , ColumnFilter . all ( indexCfs . metadata ) , filter ) ; try ( ReadExecutionController executionController = ReadExecutionController . forCommand ( command ) ; UnfilteredRowIterator iter = command . queryMemtableAndDisk ( indexCfs , executionController . indexReadOpOrderGroup ( ) ) ) { while ( iter . hasNext ( ) ) { Unfiltered unfiltered = iter . next ( ) ; assert ( unfiltered . isRow ( ) ) ; Row indexRow = ( Row ) unfiltered ; assertEquals ( ttl , indexRow . primaryKeyLivenessInfo ( ) . ttl ( ) ) ; } } } private class TestScript { String tableDefinition ; String indexName ; String indexTarget ; String queryExpression1 ; String queryExpression2 ; String updateExpression ; String postUpdateQueryExpression ; String missingIndexMessage ; Object [ ] firstRow ; Object [ ] secondRow ; TestScript indexName ( String indexName ) { this . indexName = indexName ; return this ; } TestScript target ( String indexTarget ) { this . indexTarget = indexTarget ; return this ; } TestScript tableDefinition ( String tableDefinition ) { this . tableDefinition = tableDefinition ; return this ; } TestScript withFirstRow ( Object [ ] row ) { this . firstRow = row ; return this ; } TestScript withSecondRow ( Object [ ] row ) { this . secondRow = row ; return this ; } TestScript firstQueryExpression ( String queryExpression ) { queryExpression1 = queryExpression ; return this ; } TestScript secondQueryExpression ( String queryExpression ) { queryExpression2 = queryExpression ; return this ; } TestScript updateExpression ( String updateExpression ) { this . updateExpression = updateExpression ; return this ; } TestScript postUpdateQueryExpression ( String queryExpression ) { this . postUpdateQueryExpression = queryExpression ; return this ; } TestScript missingIndexMessage ( String missingIndexMessage ) { this . missingIndexMessage = missingIndexMessage ; return this ; } void run ( ) throws Throwable { assertNotNull ( indexName ) ; assertNotNull ( indexTarget ) ; assertNotNull ( queryExpression1 ) ; assertNotNull ( queryExpression2 ) ; assertNotNull ( firstRow ) ; assertNotNull ( secondRow ) ; assertNotNull ( tableDefinition ) ; if ( updateExpression ! = null ) assertNotNull ( postUpdateQueryExpression ) ; createTable ( tableDefinition ) ; String createIndexCql = String . format ( <str> , indexName , indexTarget ) ; String dropIndexCql = String . format ( <str> , KEYSPACE , indexName ) ; String selectFirstRowCql = String . format ( <str> , queryExpression1 ) ; String selectSecondRowCql = String . format ( <str> , queryExpression2 ) ; String insertCql = getInsertCql ( ) ; String deleteRowCql = getDeleteRowCql ( ) ; String deletePartitionCql = getDeletePartitionCql ( ) ; execute ( insertCql , firstRow ) ; assertInvalidThrowMessage ( missingIndexMessage , InvalidRequestException . class , selectFirstRowCql ) ; createIndex ( createIndexCql ) ; waitForIndexBuild ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; flush ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; compact ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; getCurrentColumnFamilyStore ( ) . reload ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; execute ( dropIndexCql ) ; assertInvalidThrowMessage ( missingIndexMessage , InvalidRequestException . class , selectFirstRowCql ) ; getCurrentColumnFamilyStore ( ) . reload ( ) ; assertInvalidThrowMessage ( missingIndexMessage , InvalidRequestException . class , selectFirstRowCql ) ; flush ( ) ; compact ( ) ; execute ( insertCql , secondRow ) ; createIndex ( createIndexCql ) ; waitForIndexBuild ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertRows ( execute ( selectSecondRowCql ) , secondRow ) ; if ( includesUpdate ( ) ) { execute ( getUpdateCql ( ) , getPrimaryKeyValues ( firstRow ) ) ; assertEmpty ( execute ( selectFirstRowCql ) ) ; selectFirstRowCql = String . format ( <str> , postUpdateQueryExpression ) ; assertPrimaryKeyColumnsOnly ( execute ( selectFirstRowCql ) , firstRow ) ; } execute ( deleteRowCql , getPrimaryKeyValues ( firstRow ) ) ; assertEmpty ( execute ( selectFirstRowCql ) ) ; execute ( deletePartitionCql , getPartitionKeyValues ( secondRow ) ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; flush ( ) ; compact ( ) ; assertEmpty ( execute ( selectFirstRowCql ) ) ; assertEmpty ( execute ( selectSecondRowCql ) ) ; execute ( insertCql , firstRow ) ; selectFirstRowCql = String . format ( <str> , queryExpression1 ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; execute ( insertCql , secondRow ) ; assertRows ( execute ( selectSecondRowCql ) , secondRow ) ; flush ( ) ; compact ( ) ; assertRows ( execute ( selectFirstRowCql ) , firstRow ) ; assertRows ( execute ( selectSecondRowCql ) , secondRow ) ; } private void assertPrimaryKeyColumnsOnly ( UntypedResultSet resultSet , Object [ ] row ) { assertFalse ( resultSet . isEmpty ( ) ) ; CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; int columnCount = cfm . partitionKeyColumns ( ) . size ( ) ; if ( cfm . isCompound ( ) ) columnCount + = cfm . clusteringColumns ( ) . size ( ) ; Object [ ] expected = copyValuesFromRow ( row , columnCount ) ; assertArrayEquals ( expected , copyValuesFromRow ( getRows ( resultSet ) [ <int> ] , columnCount ) ) ; } private String getInsertCql ( ) { CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; String columns = Joiner . on ( <str> ) . join ( Iterators . transform ( cfm . allColumnsInSelectOrder ( ) , ( column ) - > column . name . toString ( ) ) ) ; String markers = Joiner . on ( <str> ) . join ( Iterators . transform ( cfm . allColumnsInSelectOrder ( ) , ( column ) - > { return <str> ; } ) ) ; return String . format ( <str> , columns , markers ) ; } private String getUpdateCql ( ) { String whereClause = getPrimaryKeyColumns ( ) . map ( column - > column . name . toString ( ) + <str> ) . collect ( Collectors . joining ( <str> ) ) ; return String . format ( <str> , updateExpression , whereClause ) ; } private String getDeleteRowCql ( ) { return getPrimaryKeyColumns ( ) . map ( column - > column . name . toString ( ) + <str> ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } private String getDeletePartitionCql ( ) { CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; return StreamSupport . stream ( cfm . partitionKeyColumns ( ) . spliterator ( ) , false ) . map ( column - > column . name . toString ( ) + <str> ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } private Stream < ColumnDefinition > getPrimaryKeyColumns ( ) { CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; if ( cfm . isCompactTable ( ) ) return cfm . partitionKeyColumns ( ) . stream ( ) ; else return Stream . concat ( cfm . partitionKeyColumns ( ) . stream ( ) , cfm . clusteringColumns ( ) . stream ( ) ) ; } private Object [ ] getPrimaryKeyValues ( Object [ ] row ) { CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; if ( cfm . isCompactTable ( ) ) return getPartitionKeyValues ( row ) ; return copyValuesFromRow ( row , cfm . partitionKeyColumns ( ) . size ( ) + cfm . clusteringColumns ( ) . size ( ) ) ; } private Object [ ] getPartitionKeyValues ( Object [ ] row ) { CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; return copyValuesFromRow ( row , cfm . partitionKeyColumns ( ) . size ( ) ) ; } private Object [ ] copyValuesFromRow ( Object [ ] row , int length ) { Object [ ] values = new Object [ length ] ; System . arraycopy ( row , <int> , values , <int> , length ) ; return values ; } private boolean includesUpdate ( ) { return updateExpression ! = null ; } private void waitForIndexBuild ( ) throws Throwable { ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; long maxWaitMillis = <int> ; long startTime = System . currentTimeMillis ( ) ; while ( ! cfs . indexManager . getBuiltIndexNames ( ) . contains ( indexName ) ) { Thread . sleep ( <int> ) ; long wait = System . currentTimeMillis ( ) - startTime ; if ( wait > maxWaitMillis ) fail ( String . format ( <str> , indexName , wait ) ) ; } } } } 
