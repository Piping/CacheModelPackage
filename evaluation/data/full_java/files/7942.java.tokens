package org . elasticsearch . common . lucene . store ; import org . apache . lucene . store . IndexInput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import static org . hamcrest . Matchers . containsString ; public class ByteArrayIndexInputTests extends ESTestCase { public void testRandomReads ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] input = randomUnicodeOfLength ( randomIntBetween ( <int> , <int> ) ) . getBytes ( StandardCharsets . UTF_8 ) ; ByteArrayIndexInput indexInput = new ByteArrayIndexInput ( <str> , input ) ; assertEquals ( input . length , indexInput . length ( ) ) ; assertEquals ( <int> , indexInput . getFilePointer ( ) ) ; byte [ ] output = randomReadAndSlice ( indexInput , input . length ) ; assertArrayEquals ( input , output ) ; } } public void testRandomOverflow ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] input = randomUnicodeOfLength ( randomIntBetween ( <int> , <int> ) ) . getBytes ( StandardCharsets . UTF_8 ) ; ByteArrayIndexInput indexInput = new ByteArrayIndexInput ( <str> , input ) ; int firstReadLen = randomIntBetween ( <int> , input . length - <int> ) ; randomReadAndSlice ( indexInput , firstReadLen ) ; int bytesLeft = input . length - firstReadLen ; try { int secondReadLen = bytesLeft + randomIntBetween ( <int> , <int> ) ; indexInput . readBytes ( new byte [ secondReadLen ] , <int> , secondReadLen ) ; fail ( ) ; } catch ( IOException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } } } public void testSeekOverflow ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] input = randomUnicodeOfLength ( randomIntBetween ( <int> , <int> ) ) . getBytes ( StandardCharsets . UTF_8 ) ; ByteArrayIndexInput indexInput = new ByteArrayIndexInput ( <str> , input ) ; int firstReadLen = randomIntBetween ( <int> , input . length - <int> ) ; randomReadAndSlice ( indexInput , firstReadLen ) ; try { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : indexInput . seek ( Integer . MAX_VALUE + <int> ) ; break ; case <int> : indexInput . seek ( - randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : int seek = input . length + randomIntBetween ( <int> , <int> ) ; indexInput . seek ( seek ) ; break ; default : fail ( ) ; } fail ( ) ; } catch ( IOException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } catch ( IllegalArgumentException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } } } private byte [ ] randomReadAndSlice ( IndexInput indexInput , int length ) throws IOException { int readPos = ( int ) indexInput . getFilePointer ( ) ; byte [ ] output = new byte [ length ] ; while ( readPos < length ) { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : output [ readPos + + ] = indexInput . readByte ( ) ; break ; case <int> : int len = randomIntBetween ( <int> , length - readPos ) ; indexInput . readBytes ( output , readPos , len ) ; readPos + = len ; break ; case <int> : len = randomIntBetween ( <int> , length - readPos ) ; byte [ ] temp = new byte [ len ] ; indexInput . readBytes ( temp , <int> , len ) ; System . arraycopy ( temp , <int> , output , readPos , len ) ; readPos + = len ; break ; case <int> : len = randomIntBetween ( <int> , length - readPos ) ; IndexInput slice = indexInput . slice ( <str> + readPos + <str> + len + <str> + indexInput . toString ( ) , readPos , len ) ; temp = randomReadAndSlice ( slice , len ) ; assertEquals ( readPos , indexInput . getFilePointer ( ) ) ; System . arraycopy ( temp , <int> , output , readPos , len ) ; readPos + = len ; indexInput . seek ( readPos ) ; assertEquals ( readPos , indexInput . getFilePointer ( ) ) ; break ; default : fail ( ) ; } assertEquals ( readPos , indexInput . getFilePointer ( ) ) ; } return output ; } } 
