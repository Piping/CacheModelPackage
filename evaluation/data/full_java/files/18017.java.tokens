package com . badlogic . gdx . graphics . g3d . loader ; import com . badlogic . gdx . assets . loaders . FileHandleResolver ; import com . badlogic . gdx . assets . loaders . ModelLoader ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . g3d . model . data . ModelAnimation ; import com . badlogic . gdx . graphics . g3d . model . data . ModelData ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMaterial ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMesh ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMeshPart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNode ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodeAnimation ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodeKeyframe ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodePart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelTexture ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . ArrayMap ; import com . badlogic . gdx . utils . BaseJsonReader ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . JsonValue ; public class G3dModelLoader extends ModelLoader < ModelLoader . ModelParameters > { public static final short VERSION_HI = <int> ; public static final short VERSION_LO = <int> ; protected final BaseJsonReader reader ; public G3dModelLoader ( final BaseJsonReader reader ) { this ( reader , null ) ; } public G3dModelLoader ( BaseJsonReader reader , FileHandleResolver resolver ) { super ( resolver ) ; this . reader = reader ; } @Override public ModelData loadModelData ( FileHandle fileHandle , ModelLoader . ModelParameters parameters ) { return parseModel ( fileHandle ) ; } public ModelData parseModel ( FileHandle handle ) { JsonValue json = reader . parse ( handle ) ; ModelData model = new ModelData ( ) ; JsonValue version = json . require ( <str> ) ; model . version [ <int> ] = version . getShort ( <int> ) ; model . version [ <int> ] = version . getShort ( <int> ) ; if ( model . version [ <int> ] ! = VERSION_HI | | model . version [ <int> ] ! = VERSION_LO ) throw new GdxRuntimeException ( <str> ) ; model . id = json . getString ( <str> , <str> ) ; parseMeshes ( model , json ) ; parseMaterials ( model , json , handle . parent ( ) . path ( ) ) ; parseNodes ( model , json ) ; parseAnimations ( model , json ) ; return model ; } private void parseMeshes ( ModelData model , JsonValue json ) { JsonValue meshes = json . get ( <str> ) ; if ( meshes ! = null ) { model . meshes . ensureCapacity ( meshes . size ) ; for ( JsonValue mesh = meshes . child ; mesh ! = null ; mesh = mesh . next ) { ModelMesh jsonMesh = new ModelMesh ( ) ; String id = mesh . getString ( <str> , <str> ) ; jsonMesh . id = id ; JsonValue attributes = mesh . require ( <str> ) ; jsonMesh . attributes = parseAttributes ( attributes ) ; jsonMesh . vertices = mesh . require ( <str> ) . asFloatArray ( ) ; JsonValue meshParts = mesh . require ( <str> ) ; Array < ModelMeshPart > parts = new Array < ModelMeshPart > ( ) ; for ( JsonValue meshPart = meshParts . child ; meshPart ! = null ; meshPart = meshPart . next ) { ModelMeshPart jsonPart = new ModelMeshPart ( ) ; String partId = meshPart . getString ( <str> , null ) ; if ( partId = = null ) { throw new GdxRuntimeException ( <str> ) ; } for ( ModelMeshPart other : parts ) { if ( other . id . equals ( partId ) ) { throw new GdxRuntimeException ( <str> + partId + <str> ) ; } } jsonPart . id = partId ; String type = meshPart . getString ( <str> , null ) ; if ( type = = null ) { throw new GdxRuntimeException ( <str> + partId + <str> ) ; } jsonPart . primitiveType = parseType ( type ) ; jsonPart . indices = meshPart . require ( <str> ) . asShortArray ( ) ; parts . add ( jsonPart ) ; } jsonMesh . parts = parts . toArray ( ModelMeshPart . class ) ; model . meshes . add ( jsonMesh ) ; } } } private int parseType ( String type ) { if ( type . equals ( <str> ) ) { return GL20 . GL_TRIANGLES ; } else if ( type . equals ( <str> ) ) { return GL20 . GL_LINES ; } else if ( type . equals ( <str> ) ) { return GL20 . GL_POINTS ; } else if ( type . equals ( <str> ) ) { return GL20 . GL_TRIANGLE_STRIP ; } else if ( type . equals ( <str> ) ) { return GL20 . GL_LINE_STRIP ; } else { throw new GdxRuntimeException ( <str> + type + <str> ) ; } } private VertexAttribute [ ] parseAttributes ( JsonValue attributes ) { Array < VertexAttribute > vertexAttributes = new Array < VertexAttribute > ( ) ; int unit = <int> ; int blendWeightCount = <int> ; for ( JsonValue value = attributes . child ; value ! = null ; value = value . next ) { String attribute = value . asString ( ) ; String attr = ( String ) attribute ; if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . Position ( ) ) ; } else if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . Normal ( ) ) ; } else if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . ColorUnpacked ( ) ) ; } else if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . ColorPacked ( ) ) ; } else if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . Tangent ( ) ) ; } else if ( attr . equals ( <str> ) ) { vertexAttributes . add ( VertexAttribute . Binormal ( ) ) ; } else if ( attr . startsWith ( <str> ) ) { vertexAttributes . add ( VertexAttribute . TexCoords ( unit + + ) ) ; } else if ( attr . startsWith ( <str> ) ) { vertexAttributes . add ( VertexAttribute . BoneWeight ( blendWeightCount + + ) ) ; } else { throw new GdxRuntimeException ( <str> + attr + <str> ) ; } } return vertexAttributes . toArray ( VertexAttribute . class ) ; } private void parseMaterials ( ModelData model , JsonValue json , String materialDir ) { JsonValue materials = json . get ( <str> ) ; if ( materials = = null ) { } else { model . materials . ensureCapacity ( materials . size ) ; for ( JsonValue material = materials . child ; material ! = null ; material = material . next ) { ModelMaterial jsonMaterial = new ModelMaterial ( ) ; String id = material . getString ( <str> , null ) ; if ( id = = null ) throw new GdxRuntimeException ( <str> ) ; jsonMaterial . id = id ; final JsonValue diffuse = material . get ( <str> ) ; if ( diffuse ! = null ) jsonMaterial . diffuse = parseColor ( diffuse ) ; final JsonValue ambient = material . get ( <str> ) ; if ( ambient ! = null ) jsonMaterial . ambient = parseColor ( ambient ) ; final JsonValue emissive = material . get ( <str> ) ; if ( emissive ! = null ) jsonMaterial . emissive = parseColor ( emissive ) ; final JsonValue specular = material . get ( <str> ) ; if ( specular ! = null ) jsonMaterial . specular = parseColor ( specular ) ; final JsonValue reflection = material . get ( <str> ) ; if ( reflection ! = null ) jsonMaterial . reflection = parseColor ( reflection ) ; jsonMaterial . shininess = material . getFloat ( <str> , <float> ) ; jsonMaterial . opacity = material . getFloat ( <str> , <float> ) ; JsonValue textures = material . get ( <str> ) ; if ( textures ! = null ) { for ( JsonValue texture = textures . child ; texture ! = null ; texture = texture . next ) { ModelTexture jsonTexture = new ModelTexture ( ) ; String textureId = texture . getString ( <str> , null ) ; if ( textureId = = null ) throw new GdxRuntimeException ( <str> ) ; jsonTexture . id = textureId ; String fileName = texture . getString ( <str> , null ) ; if ( fileName = = null ) throw new GdxRuntimeException ( <str> ) ; jsonTexture . fileName = materialDir + ( materialDir . length ( ) = = <int> | | materialDir . endsWith ( <str> ) ? <str> : <str> ) + fileName ; jsonTexture . uvTranslation = readVector2 ( texture . get ( <str> ) , <float> , <float> ) ; jsonTexture . uvScaling = readVector2 ( texture . get ( <str> ) , <float> , <float> ) ; String textureType = texture . getString ( <str> , null ) ; if ( textureType = = null ) throw new GdxRuntimeException ( <str> ) ; jsonTexture . usage = parseTextureUsage ( textureType ) ; if ( jsonMaterial . textures = = null ) jsonMaterial . textures = new Array < ModelTexture > ( ) ; jsonMaterial . textures . add ( jsonTexture ) ; } } model . materials . add ( jsonMaterial ) ; } } } private int parseTextureUsage ( final String value ) { if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_AMBIENT ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_BUMP ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_DIFFUSE ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_EMISSIVE ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_NONE ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_NORMAL ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_REFLECTION ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_SHININESS ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_SPECULAR ; else if ( value . equalsIgnoreCase ( <str> ) ) return ModelTexture . USAGE_TRANSPARENCY ; return ModelTexture . USAGE_UNKNOWN ; } private Color parseColor ( JsonValue colorArray ) { if ( colorArray . size > = <int> ) return new Color ( colorArray . getFloat ( <int> ) , colorArray . getFloat ( <int> ) , colorArray . getFloat ( <int> ) , <float> ) ; else throw new GdxRuntimeException ( <str> ) ; } private Vector2 readVector2 ( JsonValue vectorArray , float x , float y ) { if ( vectorArray = = null ) return new Vector2 ( x , y ) ; else if ( vectorArray . size = = <int> ) return new Vector2 ( vectorArray . getFloat ( <int> ) , vectorArray . getFloat ( <int> ) ) ; else throw new GdxRuntimeException ( <str> ) ; } private Array < ModelNode > parseNodes ( ModelData model , JsonValue json ) { JsonValue nodes = json . get ( <str> ) ; if ( nodes ! = null ) { model . nodes . ensureCapacity ( nodes . size ) ; for ( JsonValue node = nodes . child ; node ! = null ; node = node . next ) { model . nodes . add ( parseNodesRecursively ( node ) ) ; } } return model . nodes ; } private final Quaternion tempQ = new Quaternion ( ) ; private ModelNode parseNodesRecursively ( JsonValue json ) { ModelNode jsonNode = new ModelNode ( ) ; String id = json . getString ( <str> , null ) ; if ( id = = null ) throw new GdxRuntimeException ( <str> ) ; jsonNode . id = id ; JsonValue translation = json . get ( <str> ) ; if ( translation ! = null & & translation . size ! = <int> ) throw new GdxRuntimeException ( <str> ) ; jsonNode . translation = translation = = null ? null : new Vector3 ( translation . getFloat ( <int> ) , translation . getFloat ( <int> ) , translation . getFloat ( <int> ) ) ; JsonValue rotation = json . get ( <str> ) ; if ( rotation ! = null & & rotation . size ! = <int> ) throw new GdxRuntimeException ( <str> ) ; jsonNode . rotation = rotation = = null ? null : new Quaternion ( rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) ) ; JsonValue scale = json . get ( <str> ) ; if ( scale ! = null & & scale . size ! = <int> ) throw new GdxRuntimeException ( <str> ) ; jsonNode . scale = scale = = null ? null : new Vector3 ( scale . getFloat ( <int> ) , scale . getFloat ( <int> ) , scale . getFloat ( <int> ) ) ; String meshId = json . getString ( <str> , null ) ; if ( meshId ! = null ) jsonNode . meshId = meshId ; JsonValue materials = json . get ( <str> ) ; if ( materials ! = null ) { jsonNode . parts = new ModelNodePart [ materials . size ] ; int i = <int> ; for ( JsonValue material = materials . child ; material ! = null ; material = material . next , i + + ) { ModelNodePart nodePart = new ModelNodePart ( ) ; String meshPartId = material . getString ( <str> , null ) ; String materialId = material . getString ( <str> , null ) ; if ( meshPartId = = null | | materialId = = null ) { throw new GdxRuntimeException ( <str> + id + <str> ) ; } nodePart . materialId = materialId ; nodePart . meshPartId = meshPartId ; JsonValue bones = material . get ( <str> ) ; if ( bones ! = null ) { nodePart . bones = new ArrayMap < String , Matrix4 > ( true , bones . size , String . class , Matrix4 . class ) ; int j = <int> ; for ( JsonValue bone = bones . child ; bone ! = null ; bone = bone . next , j + + ) { String nodeId = bone . getString ( <str> , null ) ; if ( nodeId = = null ) throw new GdxRuntimeException ( <str> ) ; Matrix4 transform = new Matrix4 ( ) ; JsonValue val = bone . get ( <str> ) ; if ( val ! = null & & val . size > = <int> ) transform . translate ( val . getFloat ( <int> ) , val . getFloat ( <int> ) , val . getFloat ( <int> ) ) ; val = bone . get ( <str> ) ; if ( val ! = null & & val . size > = <int> ) transform . rotate ( tempQ . set ( val . getFloat ( <int> ) , val . getFloat ( <int> ) , val . getFloat ( <int> ) , val . getFloat ( <int> ) ) ) ; val = bone . get ( <str> ) ; if ( val ! = null & & val . size > = <int> ) transform . scale ( val . getFloat ( <int> ) , val . getFloat ( <int> ) , val . getFloat ( <int> ) ) ; nodePart . bones . put ( nodeId , transform ) ; } } jsonNode . parts [ i ] = nodePart ; } } JsonValue children = json . get ( <str> ) ; if ( children ! = null ) { jsonNode . children = new ModelNode [ children . size ] ; int i = <int> ; for ( JsonValue child = children . child ; child ! = null ; child = child . next , i + + ) { jsonNode . children [ i ] = parseNodesRecursively ( child ) ; } } return jsonNode ; } private void parseAnimations ( ModelData model , JsonValue json ) { JsonValue animations = json . get ( <str> ) ; if ( animations = = null ) return ; model . animations . ensureCapacity ( animations . size ) ; for ( JsonValue anim = animations . child ; anim ! = null ; anim = anim . next ) { JsonValue nodes = anim . get ( <str> ) ; if ( nodes = = null ) continue ; ModelAnimation animation = new ModelAnimation ( ) ; model . animations . add ( animation ) ; animation . nodeAnimations . ensureCapacity ( nodes . size ) ; animation . id = anim . getString ( <str> ) ; for ( JsonValue node = nodes . child ; node ! = null ; node = node . next ) { ModelNodeAnimation nodeAnim = new ModelNodeAnimation ( ) ; animation . nodeAnimations . add ( nodeAnim ) ; nodeAnim . nodeId = node . getString ( <str> ) ; JsonValue keyframes = node . get ( <str> ) ; if ( keyframes ! = null & & keyframes . isArray ( ) ) { for ( JsonValue keyframe = keyframes . child ; keyframe ! = null ; keyframe = keyframe . next ) { final float keytime = keyframe . getFloat ( <str> , <float> ) / <float> ; JsonValue translation = keyframe . get ( <str> ) ; if ( translation ! = null & & translation . size = = <int> ) { if ( nodeAnim . translation = = null ) nodeAnim . translation = new Array < ModelNodeKeyframe < Vector3 > > ( ) ; ModelNodeKeyframe < Vector3 > tkf = new ModelNodeKeyframe < Vector3 > ( ) ; tkf . keytime = keytime ; tkf . value = new Vector3 ( translation . getFloat ( <int> ) , translation . getFloat ( <int> ) , translation . getFloat ( <int> ) ) ; nodeAnim . translation . add ( tkf ) ; } JsonValue rotation = keyframe . get ( <str> ) ; if ( rotation ! = null & & rotation . size = = <int> ) { if ( nodeAnim . rotation = = null ) nodeAnim . rotation = new Array < ModelNodeKeyframe < Quaternion > > ( ) ; ModelNodeKeyframe < Quaternion > rkf = new ModelNodeKeyframe < Quaternion > ( ) ; rkf . keytime = keytime ; rkf . value = new Quaternion ( rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) ) ; nodeAnim . rotation . add ( rkf ) ; } JsonValue scale = keyframe . get ( <str> ) ; if ( scale ! = null & & scale . size = = <int> ) { if ( nodeAnim . scaling = = null ) nodeAnim . scaling = new Array < ModelNodeKeyframe < Vector3 > > ( ) ; ModelNodeKeyframe < Vector3 > skf = new ModelNodeKeyframe ( ) ; skf . keytime = keytime ; skf . value = new Vector3 ( scale . getFloat ( <int> ) , scale . getFloat ( <int> ) , scale . getFloat ( <int> ) ) ; nodeAnim . scaling . add ( skf ) ; } } } else { JsonValue translationKF = node . get ( <str> ) ; if ( translationKF ! = null & & translationKF . isArray ( ) ) { nodeAnim . translation = new Array < ModelNodeKeyframe < Vector3 > > ( ) ; nodeAnim . translation . ensureCapacity ( translationKF . size ) ; for ( JsonValue keyframe = translationKF . child ; keyframe ! = null ; keyframe = keyframe . next ) { ModelNodeKeyframe < Vector3 > kf = new ModelNodeKeyframe < Vector3 > ( ) ; nodeAnim . translation . add ( kf ) ; kf . keytime = keyframe . getFloat ( <str> , <float> ) / <float> ; JsonValue translation = keyframe . get ( <str> ) ; if ( translation ! = null & & translation . size > = <int> ) kf . value = new Vector3 ( translation . getFloat ( <int> ) , translation . getFloat ( <int> ) , translation . getFloat ( <int> ) ) ; } } JsonValue rotationKF = node . get ( <str> ) ; if ( rotationKF ! = null & & rotationKF . isArray ( ) ) { nodeAnim . rotation = new Array < ModelNodeKeyframe < Quaternion > > ( ) ; nodeAnim . rotation . ensureCapacity ( rotationKF . size ) ; for ( JsonValue keyframe = rotationKF . child ; keyframe ! = null ; keyframe = keyframe . next ) { ModelNodeKeyframe < Quaternion > kf = new ModelNodeKeyframe < Quaternion > ( ) ; nodeAnim . rotation . add ( kf ) ; kf . keytime = keyframe . getFloat ( <str> , <float> ) / <float> ; JsonValue rotation = keyframe . get ( <str> ) ; if ( rotation ! = null & & rotation . size > = <int> ) kf . value = new Quaternion ( rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) , rotation . getFloat ( <int> ) ) ; } } JsonValue scalingKF = node . get ( <str> ) ; if ( scalingKF ! = null & & scalingKF . isArray ( ) ) { nodeAnim . scaling = new Array < ModelNodeKeyframe < Vector3 > > ( ) ; nodeAnim . scaling . ensureCapacity ( scalingKF . size ) ; for ( JsonValue keyframe = scalingKF . child ; keyframe ! = null ; keyframe = keyframe . next ) { ModelNodeKeyframe < Vector3 > kf = new ModelNodeKeyframe < Vector3 > ( ) ; nodeAnim . scaling . add ( kf ) ; kf . keytime = keyframe . getFloat ( <str> , <float> ) / <float> ; JsonValue scaling = keyframe . get ( <str> ) ; if ( scaling ! = null & & scaling . size > = <int> ) kf . value = new Vector3 ( scaling . getFloat ( <int> ) , scaling . getFloat ( <int> ) , scaling . getFloat ( <int> ) ) ; } } } } } } } 
