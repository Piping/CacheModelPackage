package com . badlogic . gdx . jnigen ; import java . io . InputStream ; import java . nio . Buffer ; import java . util . ArrayList ; import com . badlogic . gdx . jnigen . parsing . CMethodParser ; import com . badlogic . gdx . jnigen . parsing . CMethodParser . CMethod ; import com . badlogic . gdx . jnigen . parsing . CMethodParser . CMethodParserResult ; import com . badlogic . gdx . jnigen . parsing . JavaMethodParser ; import com . badlogic . gdx . jnigen . parsing . JavaMethodParser . Argument ; import com . badlogic . gdx . jnigen . parsing . JavaMethodParser . JavaMethod ; import com . badlogic . gdx . jnigen . parsing . JavaMethodParser . JavaSegment ; import com . badlogic . gdx . jnigen . parsing . JavaMethodParser . JniSection ; import com . badlogic . gdx . jnigen . parsing . JniHeaderCMethodParser ; import com . badlogic . gdx . jnigen . parsing . RobustJavaMethodParser ; public class NativeCodeGenerator { private static final String JNI_METHOD_MARKER = <str> ; private static final String JNI_ARG_PREFIX = <str> ; private static final String JNI_RETURN_VALUE = <str> ; private static final String JNI_WRAPPER_PREFIX = <str> ; FileDescriptor sourceDir ; String classpath ; FileDescriptor jniDir ; String [ ] includes ; String [ ] excludes ; AntPathMatcher matcher = new AntPathMatcher ( ) ; JavaMethodParser javaMethodParser = new RobustJavaMethodParser ( ) ; CMethodParser cMethodParser = new JniHeaderCMethodParser ( ) ; CMethodParserResult cResult ; public void generate ( ) throws Exception { generate ( <str> , <str> , <str> , null , null ) ; } public void generate ( String sourceDir , String classpath , String jniDir ) throws Exception { generate ( sourceDir , classpath , jniDir , null , null ) ; } public void generate ( String sourceDir , String classpath , String jniDir , String [ ] includes , String [ ] excludes ) throws Exception { this . sourceDir = new FileDescriptor ( sourceDir ) ; this . jniDir = new FileDescriptor ( jniDir ) ; this . classpath = classpath ; this . includes = includes ; this . excludes = excludes ; if ( ! this . sourceDir . exists ( ) ) { throw new Exception ( <str> + sourceDir + <str> ) ; } if ( ! this . jniDir . exists ( ) ) { if ( ! this . jniDir . mkdirs ( ) ) { throw new Exception ( <str> + jniDir + <str> ) ; } } processDirectory ( this . sourceDir ) ; } private void processDirectory ( FileDescriptor dir ) throws Exception { FileDescriptor [ ] files = dir . list ( ) ; for ( FileDescriptor file : files ) { if ( file . isDirectory ( ) ) { if ( file . path ( ) . contains ( <str> ) ) continue ; if ( excludes ! = null & & matcher . match ( file . path ( ) , excludes ) ) continue ; processDirectory ( file ) ; } else { if ( file . extension ( ) . equals ( <str> ) ) { if ( file . name ( ) . contains ( <str> ) ) continue ; if ( includes ! = null & & ! matcher . match ( file . path ( ) , includes ) ) continue ; if ( excludes ! = null & & matcher . match ( file . path ( ) , excludes ) ) continue ; String className = getFullyQualifiedClassName ( file ) ; FileDescriptor hFile = new FileDescriptor ( jniDir . path ( ) + <str> + className + <str> ) ; FileDescriptor cppFile = new FileDescriptor ( jniDir + <str> + className + <str> ) ; if ( file . lastModified ( ) < cppFile . lastModified ( ) ) { System . out . println ( <str> + file . path ( ) + <str> ) ; continue ; } String javaContent = file . readString ( ) ; if ( javaContent . contains ( JNI_METHOD_MARKER ) ) { ArrayList < JavaSegment > javaSegments = javaMethodParser . parse ( javaContent ) ; if ( javaSegments . size ( ) = = <int> ) { System . out . println ( <str> + file + <str> ) ; continue ; } System . out . print ( <str> + file + <str> ) ; generateHFile ( file ) ; generateCppFile ( javaSegments , hFile , cppFile ) ; System . out . println ( <str> ) ; } } } } } private String getFullyQualifiedClassName ( FileDescriptor file ) { String className = file . path ( ) . replace ( sourceDir . path ( ) , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) ; if ( className . startsWith ( <str> ) ) className = className . substring ( <int> ) ; return className ; } private void generateHFile ( FileDescriptor file ) throws Exception { String className = getFullyQualifiedClassName ( file ) ; String command = <str> + classpath + <str> + jniDir . path ( ) + <str> + className + <str> + className ; Process process = Runtime . getRuntime ( ) . exec ( command ) ; process . waitFor ( ) ; if ( process . exitValue ( ) ! = <int> ) { System . out . println ( ) ; System . out . println ( <str> + command ) ; InputStream errorStream = process . getErrorStream ( ) ; int c = <int> ; while ( ( c = errorStream . read ( ) ) ! = - <int> ) { System . out . print ( ( char ) c ) ; } } } protected void emitHeaderInclude ( StringBuffer buffer , String fileName ) { buffer . append ( <str> + fileName + <str> ) ; } private void generateCppFile ( ArrayList < JavaSegment > javaSegments , FileDescriptor hFile , FileDescriptor cppFile ) throws Exception { String headerFileContent = hFile . readString ( ) ; ArrayList < CMethod > cMethods = cMethodParser . parse ( headerFileContent ) . getMethods ( ) ; StringBuffer buffer = new StringBuffer ( ) ; emitHeaderInclude ( buffer , hFile . name ( ) ) ; for ( JavaSegment segment : javaSegments ) { if ( segment instanceof JniSection ) { emitJniSection ( buffer , ( JniSection ) segment ) ; } if ( segment instanceof JavaMethod ) { JavaMethod javaMethod = ( JavaMethod ) segment ; if ( javaMethod . getNativeCode ( ) = = null ) { throw new RuntimeException ( <str> + javaMethod . getName ( ) + <str> ) ; } CMethod cMethod = findCMethod ( javaMethod , cMethods ) ; if ( cMethod = = null ) throw new RuntimeException ( <str> + javaMethod . getClassName ( ) + <str> + javaMethod . getName ( ) + <str> ) ; emitJavaMethod ( buffer , javaMethod , cMethod ) ; } } cppFile . writeString ( buffer . toString ( ) , false , <str> ) ; } private CMethod findCMethod ( JavaMethod javaMethod , ArrayList < CMethod > cMethods ) { for ( CMethod cMethod : cMethods ) { if ( cMethod . getHead ( ) . endsWith ( javaMethod . getClassName ( ) + <str> + javaMethod . getName ( ) ) | | cMethod . getHead ( ) . contains ( javaMethod . getClassName ( ) + <str> + javaMethod . getName ( ) + <str> ) ) { if ( cMethod . getArgumentTypes ( ) . length - <int> = = javaMethod . getArguments ( ) . size ( ) ) { boolean match = true ; for ( int i = <int> ; i < cMethod . getArgumentTypes ( ) . length ; i + + ) { String cType = cMethod . getArgumentTypes ( ) [ i ] ; String javaType = javaMethod . getArguments ( ) . get ( i - <int> ) . getType ( ) . getJniType ( ) ; if ( ! cType . equals ( javaType ) ) { match = false ; break ; } } if ( match ) { return cMethod ; } } } } return null ; } private void emitLineMarker ( StringBuffer buffer , int line ) { buffer . append ( <str> ) ; buffer . append ( line ) ; buffer . append ( <str> ) ; } private void emitJniSection ( StringBuffer buffer , JniSection section ) { emitLineMarker ( buffer , section . getStartIndex ( ) ) ; buffer . append ( section . getNativeCode ( ) . replace ( <str> , <str> ) ) ; } private void emitJavaMethod ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod ) { StringBuffer jniSetupCode = new StringBuffer ( ) ; StringBuffer jniCleanupCode = new StringBuffer ( ) ; StringBuffer additionalArgs = new StringBuffer ( ) ; StringBuffer wrapperArgs = new StringBuffer ( ) ; emitJniSetupCode ( jniSetupCode , javaMethod , additionalArgs , wrapperArgs ) ; emitJniCleanupCode ( jniCleanupCode , javaMethod , cMethod ) ; boolean isManual = javaMethod . isManual ( ) ; if ( javaMethod . hasDisposableArgument ( ) & & javaMethod . getNativeCode ( ) . contains ( <str> ) ) { if ( isManual ) { emitMethodSignature ( buffer , javaMethod , cMethod , null , false ) ; emitMethodBody ( buffer , javaMethod ) ; buffer . append ( <str> ) ; } else { String wrappedMethodName = emitMethodSignature ( buffer , javaMethod , cMethod , additionalArgs . toString ( ) ) ; emitMethodBody ( buffer , javaMethod ) ; buffer . append ( <str> ) ; emitMethodSignature ( buffer , javaMethod , cMethod , null ) ; if ( ! isManual ) { buffer . append ( jniSetupCode ) ; } if ( cMethod . getReturnType ( ) . equals ( <str> ) ) { buffer . append ( <str> + wrappedMethodName + <str> + wrapperArgs . toString ( ) + <str> ) ; if ( ! isManual ) { buffer . append ( jniCleanupCode ) ; } buffer . append ( <str> ) ; } else { buffer . append ( <str> + cMethod . getReturnType ( ) + <str> + JNI_RETURN_VALUE + <str> + wrappedMethodName + <str> + wrapperArgs . toString ( ) + <str> ) ; if ( ! isManual ) { buffer . append ( jniCleanupCode ) ; } buffer . append ( <str> + JNI_RETURN_VALUE + <str> ) ; } buffer . append ( <str> ) ; } } else { emitMethodSignature ( buffer , javaMethod , cMethod , null ) ; if ( ! isManual ) { buffer . append ( jniSetupCode ) ; } emitMethodBody ( buffer , javaMethod ) ; if ( ! isManual ) { buffer . append ( jniCleanupCode ) ; } buffer . append ( <str> ) ; } } protected void emitMethodBody ( StringBuffer buffer , JavaMethod javaMethod ) { emitLineMarker ( buffer , javaMethod . getEndIndex ( ) ) ; buffer . append ( javaMethod . getNativeCode ( ) ) ; buffer . append ( <str> ) ; } private String emitMethodSignature ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod , String additionalArguments ) { return emitMethodSignature ( buffer , javaMethod , cMethod , additionalArguments , true ) ; } private String emitMethodSignature ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod , String additionalArguments , boolean appendPrefix ) { String wrappedMethodName = null ; if ( additionalArguments ! = null ) { String [ ] tokens = cMethod . getHead ( ) . replace ( <str> , <str> ) . replace ( <str> , <str> ) . split ( <str> ) ; wrappedMethodName = JNI_WRAPPER_PREFIX + tokens [ <int> ] ; buffer . append ( <str> ) ; buffer . append ( tokens [ <int> ] ) ; buffer . append ( <str> ) ; buffer . append ( wrappedMethodName ) ; buffer . append ( <str> ) ; } else { buffer . append ( cMethod . getHead ( ) ) ; } if ( javaMethod . isStatic ( ) ) { buffer . append ( <str> ) ; } else { buffer . append ( <str> ) ; } if ( javaMethod . getArguments ( ) . size ( ) > <int> ) buffer . append ( <str> ) ; for ( int i = <int> ; i < javaMethod . getArguments ( ) . size ( ) ; i + + ) { buffer . append ( cMethod . getArgumentTypes ( ) [ i + <int> ] ) ; buffer . append ( <str> ) ; Argument javaArg = javaMethod . getArguments ( ) . get ( i ) ; if ( ! javaArg . getType ( ) . isPlainOldDataType ( ) & & ! javaArg . getType ( ) . isObject ( ) & & appendPrefix ) { buffer . append ( JNI_ARG_PREFIX ) ; } buffer . append ( javaArg . getName ( ) ) ; if ( i < javaMethod . getArguments ( ) . size ( ) - <int> ) buffer . append ( <str> ) ; } if ( additionalArguments ! = null ) { buffer . append ( additionalArguments ) ; } buffer . append ( <str> ) ; return wrappedMethodName ; } private void emitJniSetupCode ( StringBuffer buffer , JavaMethod javaMethod , StringBuffer additionalArgs , StringBuffer wrapperArgs ) { if ( javaMethod . isStatic ( ) ) { wrapperArgs . append ( <str> ) ; } else { wrapperArgs . append ( <str> ) ; } for ( int i = <int> ; i < javaMethod . getArguments ( ) . size ( ) ; i + + ) { Argument arg = javaMethod . getArguments ( ) . get ( i ) ; if ( ! arg . getType ( ) . isPlainOldDataType ( ) & & ! arg . getType ( ) . isObject ( ) ) { wrapperArgs . append ( JNI_ARG_PREFIX ) ; } wrapperArgs . append ( arg . getName ( ) ) ; if ( i < javaMethod . getArguments ( ) . size ( ) - <int> ) wrapperArgs . append ( <str> ) ; } for ( Argument arg : javaMethod . getArguments ( ) ) { if ( arg . getType ( ) . isBuffer ( ) ) { String type = arg . getType ( ) . getBufferCType ( ) ; buffer . append ( <str> + type + <str> + arg . getName ( ) + <str> + type + <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( type ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( arg . getName ( ) ) ; wrapperArgs . append ( <str> ) ; wrapperArgs . append ( arg . getName ( ) ) ; } } for ( Argument arg : javaMethod . getArguments ( ) ) { if ( arg . getType ( ) . isString ( ) ) { String type = <str> ; buffer . append ( <str> + type + <str> + arg . getName ( ) + <str> + type + <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( type ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( arg . getName ( ) ) ; wrapperArgs . append ( <str> ) ; wrapperArgs . append ( arg . getName ( ) ) ; } } for ( Argument arg : javaMethod . getArguments ( ) ) { if ( arg . getType ( ) . isPrimitiveArray ( ) ) { String type = arg . getType ( ) . getArrayCType ( ) ; buffer . append ( <str> + type + <str> + arg . getName ( ) + <str> + type + <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( type ) ; additionalArgs . append ( <str> ) ; additionalArgs . append ( arg . getName ( ) ) ; wrapperArgs . append ( <str> ) ; wrapperArgs . append ( arg . getName ( ) ) ; } } buffer . append ( <str> ) ; } private void emitJniCleanupCode ( StringBuffer buffer , JavaMethod javaMethod , CMethod cMethod ) { for ( Argument arg : javaMethod . getArguments ( ) ) { if ( arg . getType ( ) . isPrimitiveArray ( ) ) { buffer . append ( <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> + arg . getName ( ) + <str> ) ; } } for ( Argument arg : javaMethod . getArguments ( ) ) { if ( arg . getType ( ) . isString ( ) ) { buffer . append ( <str> + JNI_ARG_PREFIX + arg . getName ( ) + <str> + arg . getName ( ) + <str> ) ; } } buffer . append ( <str> ) ; } } 
