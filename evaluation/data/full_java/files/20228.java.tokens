package io . netty . channel ; import java . util . AbstractMap ; import java . util . Map . Entry ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; public class DefaultMaxBytesRecvByteBufAllocator implements MaxBytesRecvByteBufAllocator { private volatile int maxBytesPerRead ; private volatile int maxBytesPerIndividualRead ; private final class HandleImpl implements Handle { private int individualReadMax ; private int bytesToRead ; private int lastBytesRead ; private int attemptBytesRead ; @Override public ByteBuf allocate ( ByteBufAllocator alloc ) { return alloc . ioBuffer ( guess ( ) ) ; } @Override public int guess ( ) { return Math . min ( individualReadMax , bytesToRead ) ; } @Override public void reset ( ChannelConfig config ) { bytesToRead = maxBytesPerRead ( ) ; individualReadMax = maxBytesPerIndividualRead ( ) ; } @Override public void incMessagesRead ( int amt ) { } @Override public void lastBytesRead ( int bytes ) { lastBytesRead = bytes ; bytesToRead - = bytes ; } @Override public int lastBytesRead ( ) { return lastBytesRead ; } @Override public boolean continueReading ( ) { return bytesToRead > <int> & & attemptBytesRead = = lastBytesRead ; } @Override public void readComplete ( ) { } @Override public void attemptedBytesRead ( int bytes ) { attemptBytesRead = bytes ; } @Override public int attemptedBytesRead ( ) { return attemptBytesRead ; } } public DefaultMaxBytesRecvByteBufAllocator ( ) { this ( <int> * <int> , <int> * <int> ) ; } public DefaultMaxBytesRecvByteBufAllocator ( int maxBytesPerRead , int maxBytesPerIndividualRead ) { checkMaxBytesPerReadPair ( maxBytesPerRead , maxBytesPerIndividualRead ) ; this . maxBytesPerRead = maxBytesPerRead ; this . maxBytesPerIndividualRead = maxBytesPerIndividualRead ; } @Override public Handle newHandle ( ) { return new HandleImpl ( ) ; } @Override public int maxBytesPerRead ( ) { return maxBytesPerRead ; } @Override public DefaultMaxBytesRecvByteBufAllocator maxBytesPerRead ( int maxBytesPerRead ) { if ( maxBytesPerRead < = <int> ) { throw new IllegalArgumentException ( <str> + maxBytesPerRead + <str> ) ; } synchronized ( this ) { final int maxBytesPerIndividualRead = maxBytesPerIndividualRead ( ) ; if ( maxBytesPerRead < maxBytesPerIndividualRead ) { throw new IllegalArgumentException ( <str> + <str> + maxBytesPerIndividualRead + <str> + maxBytesPerRead ) ; } this . maxBytesPerRead = maxBytesPerRead ; } return this ; } @Override public int maxBytesPerIndividualRead ( ) { return maxBytesPerIndividualRead ; } @Override public DefaultMaxBytesRecvByteBufAllocator maxBytesPerIndividualRead ( int maxBytesPerIndividualRead ) { if ( maxBytesPerIndividualRead < = <int> ) { throw new IllegalArgumentException ( <str> + maxBytesPerIndividualRead + <str> ) ; } synchronized ( this ) { final int maxBytesPerRead = maxBytesPerRead ( ) ; if ( maxBytesPerIndividualRead > maxBytesPerRead ) { throw new IllegalArgumentException ( <str> + <str> + maxBytesPerRead + <str> + maxBytesPerIndividualRead ) ; } this . maxBytesPerIndividualRead = maxBytesPerIndividualRead ; } return this ; } @Override public synchronized Entry < Integer , Integer > maxBytesPerReadPair ( ) { return new AbstractMap . SimpleEntry < Integer , Integer > ( maxBytesPerRead , maxBytesPerIndividualRead ) ; } private void checkMaxBytesPerReadPair ( int maxBytesPerRead , int maxBytesPerIndividualRead ) { if ( maxBytesPerRead < = <int> ) { throw new IllegalArgumentException ( <str> + maxBytesPerRead + <str> ) ; } if ( maxBytesPerIndividualRead < = <int> ) { throw new IllegalArgumentException ( <str> + maxBytesPerIndividualRead + <str> ) ; } if ( maxBytesPerRead < maxBytesPerIndividualRead ) { throw new IllegalArgumentException ( <str> + <str> + maxBytesPerIndividualRead + <str> + maxBytesPerRead ) ; } } @Override public DefaultMaxBytesRecvByteBufAllocator maxBytesPerReadPair ( int maxBytesPerRead , int maxBytesPerIndividualRead ) { checkMaxBytesPerReadPair ( maxBytesPerRead , maxBytesPerIndividualRead ) ; synchronized ( this ) { this . maxBytesPerRead = maxBytesPerRead ; this . maxBytesPerIndividualRead = maxBytesPerIndividualRead ; } return this ; } } 
