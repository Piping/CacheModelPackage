package org . apache . cassandra . utils ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class Hex { private static final Constructor < String > stringConstructor = getProtectedConstructor ( String . class , int . class , int . class , char [ ] . class ) ; private final static byte [ ] charToByte = new byte [ <int> ] ; private static final Logger logger = LoggerFactory . getLogger ( Hex . class ) ; static final char [ ] byteToChar = new char [ <int> ] ; static { for ( char c = <int> ; c < charToByte . length ; + + c ) { if ( c > = <str> & & c < = <str> ) charToByte [ c ] = ( byte ) ( c - <str> ) ; else if ( c > = <str> & & c < = <str> ) charToByte [ c ] = ( byte ) ( c - <str> + <int> ) ; else if ( c > = <str> & & c < = <str> ) charToByte [ c ] = ( byte ) ( c - <str> + <int> ) ; else charToByte [ c ] = ( byte ) - <int> ; } for ( int i = <int> ; i < <int> ; + + i ) { byteToChar [ i ] = Integer . toHexString ( i ) . charAt ( <int> ) ; } } public static byte [ ] hexToBytes ( String str ) { if ( str . length ( ) % <int> = = <int> ) throw new NumberFormatException ( <str> ) ; byte [ ] bytes = new byte [ str . length ( ) / <int> ] ; for ( int i = <int> ; i < bytes . length ; i + + ) { byte halfByte1 = charToByte [ str . charAt ( i * <int> ) ] ; byte halfByte2 = charToByte [ str . charAt ( i * <int> + <int> ) ] ; if ( halfByte1 = = - <int> | | halfByte2 = = - <int> ) throw new NumberFormatException ( <str> + str ) ; bytes [ i ] = ( byte ) ( ( halfByte1 < < <int> ) | halfByte2 ) ; } return bytes ; } public static String bytesToHex ( byte . . . bytes ) { return bytesToHex ( bytes , <int> , bytes . length ) ; } public static String bytesToHex ( byte bytes [ ] , int offset , int length ) { char [ ] c = new char [ length * <int> ] ; for ( int i = <int> ; i < length ; i + + ) { int bint = bytes [ i + offset ] ; c [ i * <int> ] = byteToChar [ ( bint & <hex> ) > > <int> ] ; c [ <int> + i * <int> ] = byteToChar [ bint & <hex> ] ; } return wrapCharArray ( c ) ; } public static String wrapCharArray ( char [ ] c ) { if ( c = = null ) return null ; String s = null ; if ( stringConstructor ! = null ) { try { s = stringConstructor . newInstance ( <int> , c . length , c ) ; } catch ( InvocationTargetException ite ) { Throwable cause = ite . getCause ( ) ; logger . error ( <str> , cause = = null ? ite . getMessage ( ) : cause . getMessage ( ) ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; } } return s = = null ? new String ( c ) : s ; } public static < T > Constructor < T > getProtectedConstructor ( Class < T > klass , Class < ? > . . . paramTypes ) { Constructor < T > c ; try { c = klass . getDeclaredConstructor ( paramTypes ) ; c . setAccessible ( true ) ; return c ; } catch ( Exception e ) { return null ; } } } 
