package org . gradle . messaging . remote . internal ; import org . gradle . internal . io . ClassLoaderObjectInputStream ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . * ; import java . lang . reflect . Constructor ; public abstract class Message implements Serializable { private static final Logger LOGGER = LoggerFactory . getLogger ( Message . class ) ; public static void send ( Object message , OutputStream outputSteam ) throws IOException { ObjectOutputStream oos = new ExceptionReplacingObjectOutputStream ( outputSteam ) ; try { oos . writeObject ( message ) ; } finally { oos . flush ( ) ; } } public static Object receive ( InputStream inputSteam , ClassLoader classLoader ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ExceptionReplacingObjectInputStream ( inputSteam , classLoader ) ; return ois . readObject ( ) ; } private static class ExceptionPlaceholder implements Serializable { private final String type ; private byte [ ] serializedException ; private String message ; private String toString ; private ExceptionPlaceholder cause ; private StackTraceElement [ ] stackTrace ; private Throwable toStringRuntimeExec ; private Throwable getMessageExec ; public ExceptionPlaceholder ( final Throwable throwable ) throws IOException { type = throwable . getClass ( ) . getName ( ) ; try { stackTrace = throwable . getStackTrace ( ) ; } catch ( Throwable ignored ) { stackTrace = new StackTraceElement [ <int> ] ; } try { message = throwable . getMessage ( ) ; } catch ( Throwable failure ) { getMessageExec = failure ; } try { toString = throwable . toString ( ) ; } catch ( Throwable failure ) { toStringRuntimeExec = failure ; } Throwable causeTmp ; try { causeTmp = throwable . getCause ( ) ; } catch ( Throwable ignored ) { causeTmp = null ; } final Throwable causeFinal = causeTmp ; ByteArrayOutputStream outstr = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ExceptionReplacingObjectOutputStream ( outstr ) { boolean seenFirst ; @Override protected Object replaceObject ( Object obj ) throws IOException { if ( ! seenFirst ) { seenFirst = true ; return obj ; } if ( obj = = causeFinal ) { return new CausePlaceholder ( ) ; } return super . replaceObject ( obj ) ; } } ; try { oos . writeObject ( throwable ) ; oos . close ( ) ; serializedException = outstr . toByteArray ( ) ; } catch ( Throwable ignored ) { } if ( causeFinal ! = null ) { cause = new ExceptionPlaceholder ( causeFinal ) ; } } public Throwable read ( ClassLoader classLoader ) throws IOException { final Throwable causeThrowable = getCause ( classLoader ) ; if ( serializedException ! = null ) { final ExceptionReplacingObjectInputStream ois = new ExceptionReplacingObjectInputStream ( new ByteArrayInputStream ( serializedException ) , classLoader ) { @Override protected Object resolveObject ( Object obj ) throws IOException { if ( obj instanceof CausePlaceholder ) { return causeThrowable ; } return super . resolveObject ( obj ) ; } } ; try { return ( Throwable ) ois . readObject ( ) ; } catch ( ClassNotFoundException ignored ) { } catch ( Throwable failure ) { LOGGER . debug ( <str> , failure ) ; } } try { Constructor < ? > constructor = classLoader . loadClass ( type ) . getConstructor ( String . class ) ; Throwable reconstructed = ( Throwable ) constructor . newInstance ( message ) ; reconstructed . initCause ( causeThrowable ) ; reconstructed . setStackTrace ( stackTrace ) ; return reconstructed ; } catch ( ClassNotFoundException ignored ) { } catch ( NoSuchMethodException ignored ) { } catch ( Throwable ignored ) { LOGGER . debug ( <str> , ignored ) ; } Throwable placeholder = new PlaceholderException ( type , message , getMessageExec , toString , toStringRuntimeExec , causeThrowable ) ; placeholder . setStackTrace ( stackTrace ) ; return placeholder ; } private Throwable getCause ( ClassLoader classLoader ) throws IOException { return cause ! = null ? cause . read ( classLoader ) : null ; } } private static class CausePlaceholder implements Serializable { } private static class TopLevelExceptionPlaceholder extends ExceptionPlaceholder { private TopLevelExceptionPlaceholder ( Throwable throwable ) throws IOException { super ( throwable ) ; } } private static class ExceptionReplacingObjectOutputStream extends ObjectOutputStream { public ExceptionReplacingObjectOutputStream ( OutputStream outputSteam ) throws IOException { super ( outputSteam ) ; enableReplaceObject ( true ) ; } @Override protected Object replaceObject ( Object obj ) throws IOException { if ( obj instanceof Throwable ) { return new TopLevelExceptionPlaceholder ( ( Throwable ) obj ) ; } return obj ; } } private static class ExceptionReplacingObjectInputStream extends ClassLoaderObjectInputStream { public ExceptionReplacingObjectInputStream ( InputStream inputSteam , ClassLoader classLoader ) throws IOException { super ( inputSteam , classLoader ) ; enableResolveObject ( true ) ; } @Override protected Object resolveObject ( Object obj ) throws IOException { if ( obj instanceof TopLevelExceptionPlaceholder ) { return ( ( ExceptionPlaceholder ) obj ) . read ( getClassLoader ( ) ) ; } return obj ; } } } 
