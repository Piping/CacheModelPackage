package com . badlogic . gdx . utils ; import com . badlogic . gdx . math . MathUtils ; import java . util . Arrays ; public class FloatArray { public float [ ] items ; public int size ; public boolean ordered ; public FloatArray ( ) { this ( true , <int> ) ; } public FloatArray ( int capacity ) { this ( true , capacity ) ; } public FloatArray ( boolean ordered , int capacity ) { this . ordered = ordered ; items = new float [ capacity ] ; } public FloatArray ( FloatArray array ) { this . ordered = array . ordered ; size = array . size ; items = new float [ size ] ; System . arraycopy ( array . items , <int> , items , <int> , size ) ; } public FloatArray ( float [ ] array ) { this ( true , array , <int> , array . length ) ; } public FloatArray ( boolean ordered , float [ ] array , int startIndex , int count ) { this ( ordered , count ) ; size = count ; System . arraycopy ( array , startIndex , items , <int> , count ) ; } public void add ( float value ) { float [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; items [ size + + ] = value ; } public void addAll ( FloatArray array ) { addAll ( array , <int> , array . size ) ; } public void addAll ( FloatArray array , int offset , int length ) { if ( offset + length > array . size ) throw new IllegalArgumentException ( <str> + offset + <str> + length + <str> + array . size ) ; addAll ( array . items , offset , length ) ; } public void addAll ( float . . . array ) { addAll ( array , <int> , array . length ) ; } public void addAll ( float [ ] array , int offset , int length ) { float [ ] items = this . items ; int sizeNeeded = size + length ; if ( sizeNeeded > items . length ) items = resize ( Math . max ( <int> , ( int ) ( sizeNeeded * <float> ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size + = length ; } public float get ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; return items [ index ] ; } public void set ( int index , float value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] = value ; } public void incr ( int index , float value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] + = value ; } public void mul ( int index , float value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] * = value ; } public void insert ( int index , float value ) { if ( index > size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; float [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; if ( ordered ) System . arraycopy ( items , index , items , index + <int> , size - index ) ; else items [ size ] = items [ index ] ; size + + ; items [ index ] = value ; } public void swap ( int first , int second ) { if ( first > = size ) throw new IndexOutOfBoundsException ( <str> + first + <str> + size ) ; if ( second > = size ) throw new IndexOutOfBoundsException ( <str> + second + <str> + size ) ; float [ ] items = this . items ; float firstValue = items [ first ] ; items [ first ] = items [ second ] ; items [ second ] = firstValue ; } public boolean contains ( float value ) { int i = size - <int> ; float [ ] items = this . items ; while ( i > = <int> ) if ( items [ i - - ] = = value ) return true ; return false ; } public int indexOf ( float value ) { float [ ] items = this . items ; for ( int i = <int> , n = size ; i < n ; i + + ) if ( items [ i ] = = value ) return i ; return - <int> ; } public int lastIndexOf ( char value ) { float [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) if ( items [ i ] = = value ) return i ; return - <int> ; } public boolean removeValue ( float value ) { float [ ] items = this . items ; for ( int i = <int> , n = size ; i < n ; i + + ) { if ( items [ i ] = = value ) { removeIndex ( i ) ; return true ; } } return false ; } public float removeIndex ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; float [ ] items = this . items ; float value = items [ index ] ; size - - ; if ( ordered ) System . arraycopy ( items , index + <int> , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; } public void removeRange ( int start , int end ) { if ( end > = size ) throw new IndexOutOfBoundsException ( <str> + end + <str> + size ) ; if ( start > end ) throw new IndexOutOfBoundsException ( <str> + start + <str> + end ) ; float [ ] items = this . items ; int count = end - start + <int> ; if ( ordered ) System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; else { int lastIndex = this . size - <int> ; for ( int i = <int> ; i < count ; i + + ) items [ start + i ] = items [ lastIndex - i ] ; } size - = count ; } public boolean removeAll ( FloatArray array ) { int size = this . size ; int startSize = size ; float [ ] items = this . items ; for ( int i = <int> , n = array . size ; i < n ; i + + ) { float item = array . get ( i ) ; for ( int ii = <int> ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } return size ! = startSize ; } public float pop ( ) { return items [ - - size ] ; } public float peek ( ) { return items [ size - <int> ] ; } public float first ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; return items [ <int> ] ; } public void clear ( ) { size = <int> ; } public float [ ] shrink ( ) { if ( items . length ! = size ) resize ( size ) ; return items ; } public float [ ] ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > items . length ) resize ( Math . max ( <int> , sizeNeeded ) ) ; return items ; } protected float [ ] resize ( int newSize ) { float [ ] newItems = new float [ newSize ] ; float [ ] items = this . items ; System . arraycopy ( items , <int> , newItems , <int> , Math . min ( size , newItems . length ) ) ; this . items = newItems ; return newItems ; } public void sort ( ) { Arrays . sort ( items , <int> , size ) ; } public void reverse ( ) { float [ ] items = this . items ; for ( int i = <int> , lastIndex = size - <int> , n = size / <int> ; i < n ; i + + ) { int ii = lastIndex - i ; float temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void shuffle ( ) { float [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) { int ii = MathUtils . random ( i ) ; float temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void truncate ( int newSize ) { if ( size > newSize ) size = newSize ; } public float random ( ) { if ( size = = <int> ) return <int> ; return items [ MathUtils . random ( <int> , size - <int> ) ] ; } public float [ ] toArray ( ) { float [ ] array = new float [ size ] ; System . arraycopy ( items , <int> , array , <int> , size ) ; return array ; } public int hashCode ( ) { if ( ! ordered ) return super . hashCode ( ) ; float [ ] items = this . items ; int h = <int> ; for ( int i = <int> , n = size ; i < n ; i + + ) h = h * <int> + Float . floatToIntBits ( items [ i ] ) ; return h ; } public boolean equals ( Object object ) { if ( object = = this ) return true ; if ( ! ordered ) return false ; if ( ! ( object instanceof FloatArray ) ) return false ; FloatArray array = ( FloatArray ) object ; if ( ! array . ordered ) return false ; int n = size ; if ( n ! = array . size ) return false ; float [ ] items1 = this . items ; float [ ] items2 = array . items ; for ( int i = <int> ; i < n ; i + + ) if ( items1 [ i ] ! = items2 [ i ] ) return false ; return true ; } public boolean equals ( Object object , float epsilon ) { if ( object = = this ) return true ; if ( ! ( object instanceof FloatArray ) ) return false ; FloatArray array = ( FloatArray ) object ; int n = size ; if ( n ! = array . size ) return false ; if ( ! ordered ) return false ; if ( ! array . ordered ) return false ; float [ ] items1 = this . items ; float [ ] items2 = array . items ; for ( int i = <int> ; i < n ; i + + ) if ( Math . abs ( items1 [ i ] - items2 [ i ] ) > epsilon ) return false ; return true ; } public String toString ( ) { if ( size = = <int> ) return <str> ; float [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( <str> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( <str> ) ; buffer . append ( items [ i ] ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } public String toString ( String separator ) { if ( size = = <int> ) return <str> ; float [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( separator ) ; buffer . append ( items [ i ] ) ; } return buffer . toString ( ) ; } static public FloatArray with ( float . . . array ) { return new FloatArray ( array ) ; } } 
