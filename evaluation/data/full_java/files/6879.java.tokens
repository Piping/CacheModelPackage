package org . elasticsearch . indices . recovery ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; public class SharedFSRecoverySourceHandler extends RecoverySourceHandler { private final IndexShard shard ; private final StartRecoveryRequest request ; public SharedFSRecoverySourceHandler ( IndexShard shard , StartRecoveryRequest request , RecoverySettings recoverySettings , TransportService transportService , ESLogger logger ) { super ( shard , request , recoverySettings , transportService , logger ) ; this . shard = shard ; this . request = request ; } @Override public RecoveryResponse recoverToTarget ( ) { boolean engineClosed = false ; try { logger . trace ( <str> , request . shardId ( ) , request . targetNode ( ) ) ; if ( isPrimaryRelocation ( ) ) { logger . debug ( <str> ) ; try { engineClosed = true ; shard . flushAndCloseEngine ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; shard . failShard ( <str> , e ) ; } } prepareTargetForTranslog ( Translog . View . EMPTY_VIEW ) ; finalizeRecovery ( ) ; return response ; } catch ( Throwable t ) { if ( engineClosed ) { logger . info ( <str> ) ; shard . failShard ( <str> , t ) ; } else { logger . info ( <str> , t ) ; } throw t ; } } @Override protected int sendSnapshot ( Translog . Snapshot snapshot ) { logger . trace ( <str> , shard . shardId ( ) , request . targetNode ( ) ) ; return <int> ; } private boolean isPrimaryRelocation ( ) { return request . recoveryType ( ) = = RecoveryState . Type . RELOCATION & & shard . routingEntry ( ) . primary ( ) ; } } 
