package org . elasticsearch . common . cache ; import org . elasticsearch . test . ESTestCase ; import org . junit . Before ; import java . lang . management . ManagementFactory ; import java . lang . management . ThreadMXBean ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReferenceArray ; import java . util . stream . Collectors ; import static org . hamcrest . CoreMatchers . instanceOf ; public class CacheTests extends ESTestCase { private int numberOfEntries ; @Before public void setUp ( ) throws Exception { super . setUp ( ) ; numberOfEntries = randomIntBetween ( <int> , <int> ) ; logger . debug ( <str> + numberOfEntries ) ; } public void testCacheStats ( ) { AtomicLong evictions = new AtomicLong ( ) ; Set < Integer > keys = new HashSet < > ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . setMaximumWeight ( numberOfEntries / <int> ) . removalListener ( notification - > { keys . remove ( notification . getKey ( ) ) ; evictions . incrementAndGet ( ) ; } ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { keys . add ( i ) ; cache . put ( i , Integer . toString ( i ) ) ; } long hits = <int> ; long misses = <int> ; Integer missingKey = <int> ; for ( Integer key : keys ) { - - missingKey ; if ( rarely ( ) ) { misses + + ; cache . get ( missingKey ) ; } else { hits + + ; cache . get ( key ) ; } } assertEquals ( hits , cache . stats ( ) . getHits ( ) ) ; assertEquals ( misses , cache . stats ( ) . getMisses ( ) ) ; assertEquals ( ( long ) Math . ceil ( numberOfEntries / <float> ) , evictions . get ( ) ) ; assertEquals ( evictions . get ( ) , cache . stats ( ) . getEvictions ( ) ) ; } public void testCacheEvictions ( ) { int maximumWeight = randomIntBetween ( <int> , numberOfEntries ) ; AtomicLong evictions = new AtomicLong ( ) ; List < Integer > evictedKeys = new ArrayList < > ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . setMaximumWeight ( maximumWeight ) . removalListener ( notification - > { evictions . incrementAndGet ( ) ; evictedKeys . add ( notification . getKey ( ) ) ; } ) . build ( ) ; List < Integer > expectedEvictions = new ArrayList < > ( ) ; int iterations = ( int ) Math . ceil ( ( numberOfEntries - maximumWeight ) / ( <float> * maximumWeight ) ) ; for ( int i = <int> ; i < iterations ; i + + ) { for ( int j = i * maximumWeight ; j < ( i + <int> ) * maximumWeight & & j < numberOfEntries - maximumWeight ; j + + ) { cache . put ( j , Integer . toString ( j ) ) ; if ( j % <int> = = <int> ) { expectedEvictions . add ( j ) ; } } for ( int j = i * maximumWeight ; j < ( i + <int> ) * maximumWeight & & j < numberOfEntries - maximumWeight ; j + + ) { if ( j % <int> = = <int> ) { cache . get ( j ) ; expectedEvictions . add ( j ) ; } } } for ( int i = numberOfEntries - maximumWeight ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } assertEquals ( numberOfEntries - maximumWeight , evictions . get ( ) ) ; assertEquals ( evictions . get ( ) , cache . stats ( ) . getEvictions ( ) ) ; Set < Integer > keys = new HashSet < > ( ) ; List < Integer > remainingKeys = new ArrayList < > ( ) ; for ( Integer key : cache . keys ( ) ) { keys . add ( key ) ; remainingKeys . add ( key ) ; } assertEquals ( expectedEvictions . size ( ) , evictedKeys . size ( ) ) ; for ( int i = <int> ; i < expectedEvictions . size ( ) ; i + + ) { assertFalse ( keys . contains ( expectedEvictions . get ( i ) ) ) ; assertEquals ( expectedEvictions . get ( i ) , evictedKeys . get ( i ) ) ; } for ( int i = numberOfEntries - maximumWeight ; i < numberOfEntries ; i + + ) { assertTrue ( keys . contains ( i ) ) ; assertEquals ( numberOfEntries - i + ( numberOfEntries - maximumWeight ) - <int> , ( int ) remainingKeys . get ( i - ( numberOfEntries - maximumWeight ) ) ) ; } } public void testWeigher ( ) { int maximumWeight = <int> * numberOfEntries ; int weight = randomIntBetween ( <int> , <int> ) ; AtomicLong evictions = new AtomicLong ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . setMaximumWeight ( maximumWeight ) . weigher ( ( k , v ) - > weight ) . removalListener ( notification - > evictions . incrementAndGet ( ) ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } assertEquals ( weight * ( maximumWeight / weight ) , cache . weight ( ) ) ; assertEquals ( ( int ) Math . ceil ( ( weight - <int> ) * numberOfEntries / ( <float> * weight ) ) , evictions . get ( ) ) ; assertEquals ( evictions . get ( ) , cache . stats ( ) . getEvictions ( ) ) ; } public void testWeight ( ) { Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . weigher ( ( k , v ) - > k ) . build ( ) ; int weight = <int> ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { weight + = i ; cache . put ( i , Integer . toString ( i ) ) ; } for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { weight - = i ; cache . invalidate ( i ) ; } } assertEquals ( weight , cache . weight ( ) ) ; } public void testCount ( ) { Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; int count = <int> ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { count + + ; cache . put ( i , Integer . toString ( i ) ) ; } for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { count - - ; cache . invalidate ( i ) ; } } assertEquals ( count , cache . count ( ) ) ; } public void testExpirationAfterAccess ( ) { AtomicLong now = new AtomicLong ( ) ; Cache < Integer , String > cache = new Cache < Integer , String > ( ) { @Override protected long now ( ) { return now . get ( ) ; } } ; cache . setExpireAfterAccess ( <int> ) ; List < Integer > evictedKeys = new ArrayList < > ( ) ; cache . setRemovalListener ( notification - > { assertEquals ( RemovalNotification . RemovalReason . EVICTED , notification . getRemovalReason ( ) ) ; evictedKeys . add ( notification . getKey ( ) ) ; } ) ; now . set ( <int> ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } now . set ( <int> ) ; for ( int i = numberOfEntries ; i < <int> * numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } now . set ( <int> ) ; cache . refresh ( ) ; assertEquals ( numberOfEntries , cache . count ( ) ) ; for ( int i = <int> ; i < evictedKeys . size ( ) ; i + + ) { assertEquals ( i , ( int ) evictedKeys . get ( i ) ) ; } Set < Integer > remainingKeys = new HashSet < > ( ) ; for ( Integer key : cache . keys ( ) ) { remainingKeys . add ( key ) ; } for ( int i = numberOfEntries ; i < <int> * numberOfEntries ; i + + ) { assertTrue ( remainingKeys . contains ( i ) ) ; } } public void testExpirationAfterWrite ( ) { AtomicLong now = new AtomicLong ( ) ; Cache < Integer , String > cache = new Cache < Integer , String > ( ) { @Override protected long now ( ) { return now . get ( ) ; } } ; cache . setExpireAfterWrite ( <int> ) ; List < Integer > evictedKeys = new ArrayList < > ( ) ; cache . setRemovalListener ( notification - > { assertEquals ( RemovalNotification . RemovalReason . EVICTED , notification . getRemovalReason ( ) ) ; evictedKeys . add ( notification . getKey ( ) ) ; } ) ; now . set ( <int> ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } now . set ( <int> ) ; for ( int i = numberOfEntries ; i < <int> * numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } now . set ( <int> ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . get ( i ) ; } cache . refresh ( ) ; assertEquals ( numberOfEntries , cache . count ( ) ) ; for ( int i = <int> ; i < evictedKeys . size ( ) ; i + + ) { assertEquals ( i , ( int ) evictedKeys . get ( i ) ) ; } Set < Integer > remainingKeys = new HashSet < > ( ) ; for ( Integer key : cache . keys ( ) ) { remainingKeys . add ( key ) ; } for ( int i = numberOfEntries ; i < <int> * numberOfEntries ; i + + ) { assertTrue ( remainingKeys . contains ( i ) ) ; } } public void testPromotion ( ) { AtomicLong now = new AtomicLong ( ) ; Cache < Integer , String > cache = new Cache < Integer , String > ( ) { @Override protected long now ( ) { return now . get ( ) ; } } ; cache . setExpireAfterAccess ( <int> ) ; now . set ( <int> ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } now . set ( <int> ) ; Set < Integer > promotedKeys = new HashSet < > ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { cache . get ( i ) ; promotedKeys . add ( i ) ; } } now . set ( <int> ) ; cache . refresh ( ) ; assertEquals ( promotedKeys . size ( ) , cache . count ( ) ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( promotedKeys . contains ( i ) ) { assertNotNull ( cache . get ( i ) ) ; } else { assertNull ( cache . get ( i ) ) ; } } } public void testInvalidate ( ) { Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } Set < Integer > keys = new HashSet < > ( ) ; for ( Integer key : cache . keys ( ) ) { if ( rarely ( ) ) { cache . invalidate ( key ) ; keys . add ( key ) ; } } for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( keys . contains ( i ) ) { assertNull ( cache . get ( i ) ) ; } else { assertNotNull ( cache . get ( i ) ) ; } } } public void testNotificationOnInvalidate ( ) { Set < Integer > notifications = new HashSet < > ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . removalListener ( notification - > { assertEquals ( RemovalNotification . RemovalReason . INVALIDATED , notification . getRemovalReason ( ) ) ; notifications . add ( notification . getKey ( ) ) ; } ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } Set < Integer > invalidated = new HashSet < > ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { cache . invalidate ( i ) ; invalidated . add ( i ) ; } } assertEquals ( notifications , invalidated ) ; } public void testInvalidateAll ( ) { Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } cache . invalidateAll ( ) ; assertEquals ( <int> , cache . count ( ) ) ; assertEquals ( <int> , cache . weight ( ) ) ; } public void testNotificationOnInvalidateAll ( ) { Set < Integer > notifications = new HashSet < > ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . removalListener ( notification - > { assertEquals ( RemovalNotification . RemovalReason . INVALIDATED , notification . getRemovalReason ( ) ) ; notifications . add ( notification . getKey ( ) ) ; } ) . build ( ) ; Set < Integer > invalidated = new HashSet < > ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; invalidated . add ( i ) ; } cache . invalidateAll ( ) ; assertEquals ( invalidated , notifications ) ; } public void testReplaceRecomputesSize ( ) { class Value { private String value ; private long weight ; public Value ( String value , long weight ) { this . value = value ; this . weight = weight ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Value that = ( Value ) o ; return value . equals ( that . value ) ; } @Override public int hashCode ( ) { return value . hashCode ( ) ; } } Cache < Integer , Value > cache = CacheBuilder . < Integer , Value > builder ( ) . weigher ( ( k , s ) - > s . weight ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , new Value ( Integer . toString ( i ) , <int> ) ) ; } assertEquals ( numberOfEntries , cache . count ( ) ) ; assertEquals ( numberOfEntries , cache . weight ( ) ) ; int replaced = <int> ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { replaced + + ; cache . put ( i , new Value ( Integer . toString ( i ) , <int> ) ) ; } } assertEquals ( numberOfEntries , cache . count ( ) ) ; assertEquals ( numberOfEntries + replaced , cache . weight ( ) ) ; } public void testNotificationOnReplace ( ) { Set < Integer > notifications = new HashSet < > ( ) ; Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . removalListener ( notification - > { assertEquals ( RemovalNotification . RemovalReason . REPLACED , notification . getRemovalReason ( ) ) ; notifications . add ( notification . getKey ( ) ) ; } ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { cache . put ( i , Integer . toString ( i ) ) ; } Set < Integer > replacements = new HashSet < > ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { if ( rarely ( ) ) { cache . put ( i , Integer . toString ( i ) + Integer . toString ( i ) ) ; replacements . add ( i ) ; } } assertEquals ( replacements , notifications ) ; } public void testComputeIfAbsentLoadsSuccessfully ( ) { Map < Integer , Integer > map = new HashMap < > ( ) ; Cache < Integer , Integer > cache = CacheBuilder . < Integer , Integer > builder ( ) . build ( ) ; for ( int i = <int> ; i < numberOfEntries ; i + + ) { try { cache . computeIfAbsent ( i , k - > { int value = randomInt ( ) ; map . put ( k , value ) ; return value ; } ) ; } catch ( ExecutionException e ) { fail ( e . getMessage ( ) ) ; } } for ( int i = <int> ; i < numberOfEntries ; i + + ) { assertEquals ( map . get ( i ) , cache . get ( i ) ) ; } } public void testComputeIfAbsentCallsOnce ( ) throws InterruptedException { int numberOfThreads = randomIntBetween ( <int> , <int> ) ; final Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; List < Thread > threads = new ArrayList < > ( ) ; AtomicReferenceArray flags = new AtomicReferenceArray ( numberOfEntries ) ; for ( int j = <int> ; j < numberOfEntries ; j + + ) { flags . set ( j , false ) ; } CountDownLatch latch = new CountDownLatch ( <int> + numberOfThreads ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { Thread thread = new Thread ( ( ) - > { latch . countDown ( ) ; for ( int j = <int> ; j < numberOfEntries ; j + + ) { try { cache . computeIfAbsent ( j , key - > { assertTrue ( flags . compareAndSet ( key , false , true ) ) ; return Integer . toString ( key ) ; } ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } } } ) ; threads . add ( thread ) ; thread . start ( ) ; } latch . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } } public void testComputeIfAbsentThrowsExceptionIfLoaderReturnsANullValue ( ) { final Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; try { cache . computeIfAbsent ( <int> , k - > null ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NullPointerException . class ) ) ; } } public void testDependentKeyDeadlock ( ) throws InterruptedException { class Key { private final int key ; public Key ( int key ) { this . key = key ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Key key1 = ( Key ) o ; return key = = key1 . key ; } @Override public int hashCode ( ) { return key % <int> ; } } int numberOfThreads = randomIntBetween ( <int> , <int> ) ; final Cache < Key , Integer > cache = CacheBuilder . < Key , Integer > builder ( ) . build ( ) ; CountDownLatch latch = new CountDownLatch ( <int> + numberOfThreads ) ; CountDownLatch deadlockLatch = new CountDownLatch ( numberOfThreads ) ; List < Thread > threads = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { Thread thread = new Thread ( ( ) - > { Random random = new Random ( random ( ) . nextLong ( ) ) ; latch . countDown ( ) ; for ( int j = <int> ; j < numberOfEntries ; j + + ) { Key key = new Key ( random . nextInt ( numberOfEntries ) ) ; try { cache . computeIfAbsent ( key , k - > { if ( k . key = = <int> ) { return <int> ; } else { Integer value = cache . get ( new Key ( k . key / <int> ) ) ; return value ! = null ? value : <int> ; } } ) ; } catch ( ExecutionException e ) { fail ( e . getMessage ( ) ) ; } } deadlockLatch . countDown ( ) ; } ) ; threads . add ( thread ) ; thread . start ( ) ; } AtomicBoolean deadlock = new AtomicBoolean ( ) ; assert ! deadlock . get ( ) ; ScheduledExecutorService scheduler = Executors . newScheduledThreadPool ( <int> ) ; scheduler . scheduleAtFixedRate ( ( ) - > { Set < Long > ids = threads . stream ( ) . map ( t - > t . getId ( ) ) . collect ( Collectors . toSet ( ) ) ; ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; long [ ] deadlockedThreads = mxBean . findDeadlockedThreads ( ) ; if ( ! deadlock . get ( ) & & deadlockedThreads ! = null ) { for ( long deadlockedThread : deadlockedThreads ) { if ( ids . contains ( deadlockedThread ) ) { deadlock . set ( true ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { deadlockLatch . countDown ( ) ; } break ; } } } } , <int> , <int> , TimeUnit . SECONDS ) ; latch . countDown ( ) ; deadlockLatch . await ( ) ; scheduler . shutdown ( ) ; assertFalse ( <str> , deadlock . get ( ) ) ; } public void testCachePollution ( ) throws InterruptedException { int numberOfThreads = randomIntBetween ( <int> , <int> ) ; final Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . build ( ) ; CountDownLatch latch = new CountDownLatch ( <int> + numberOfThreads ) ; List < Thread > threads = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { Thread thread = new Thread ( ( ) - > { latch . countDown ( ) ; Random random = new Random ( random ( ) . nextLong ( ) ) ; for ( int j = <int> ; j < numberOfEntries ; j + + ) { Integer key = random . nextInt ( numberOfEntries ) ; boolean first ; boolean second ; do { first = random . nextBoolean ( ) ; second = random . nextBoolean ( ) ; } while ( first & & second ) ; if ( first ) { try { cache . computeIfAbsent ( key , k - > { if ( random . nextBoolean ( ) ) { return Integer . toString ( k ) ; } else { throw new Exception ( <str> ) ; } } ) ; } catch ( ExecutionException e ) { assertNotNull ( e . getCause ( ) ) ; assertThat ( e . getCause ( ) , instanceOf ( Exception . class ) ) ; assertEquals ( e . getCause ( ) . getMessage ( ) , <str> ) ; } } else if ( second ) { cache . invalidate ( key ) ; } else { cache . get ( key ) ; } } } ) ; threads . add ( thread ) ; thread . start ( ) ; } latch . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } } public void testTorture ( ) throws InterruptedException { int numberOfThreads = randomIntBetween ( <int> , <int> ) ; final Cache < Integer , String > cache = CacheBuilder . < Integer , String > builder ( ) . setMaximumWeight ( <int> ) . weigher ( ( k , v ) - > <int> ) . build ( ) ; CountDownLatch latch = new CountDownLatch ( <int> + numberOfThreads ) ; List < Thread > threads = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { Thread thread = new Thread ( ( ) - > { Random random = new Random ( random ( ) . nextLong ( ) ) ; latch . countDown ( ) ; for ( int j = <int> ; j < numberOfEntries ; j + + ) { Integer key = random . nextInt ( numberOfEntries ) ; cache . put ( key , Integer . toString ( j ) ) ; } } ) ; threads . add ( thread ) ; thread . start ( ) ; } latch . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } cache . refresh ( ) ; assertEquals ( <int> , cache . count ( ) ) ; } } 
