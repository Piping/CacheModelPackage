package org . elasticsearch . cluster . metadata ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . admin . indices . create . CreateIndexClusterStateUpdateRequest ; import org . elasticsearch . cluster . AckedClusterStateUpdateTask ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ack . ClusterStateUpdateResponse ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData . Custom ; import org . elasticsearch . cluster . metadata . IndexMetaData . State ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . ValidationException ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . NodeServicesProvider ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . indices . IndexCreationException ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . InvalidIndexNameException ; import org . elasticsearch . script . ScriptService ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . nio . file . Path ; import java . util . * ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_AUTO_EXPAND_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_CREATION_DATE ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_INDEX_UUID ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_VERSION_CREATED ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class MetaDataCreateIndexService extends AbstractComponent { public final static int MAX_INDEX_NAME_BYTES = <int> ; private static final DefaultIndexTemplateFilter DEFAULT_INDEX_TEMPLATE_FILTER = new DefaultIndexTemplateFilter ( ) ; private final ClusterService clusterService ; private final IndicesService indicesService ; private final AllocationService allocationService ; private final Version version ; private final AliasValidator aliasValidator ; private final IndexTemplateFilter indexTemplateFilter ; private final Environment env ; private final NodeServicesProvider nodeServicesProvider ; @Inject public MetaDataCreateIndexService ( Settings settings , ClusterService clusterService , IndicesService indicesService , AllocationService allocationService , Version version , AliasValidator aliasValidator , Set < IndexTemplateFilter > indexTemplateFilters , Environment env , NodeServicesProvider nodeServicesProvider ) { super ( settings ) ; this . clusterService = clusterService ; this . indicesService = indicesService ; this . allocationService = allocationService ; this . version = version ; this . aliasValidator = aliasValidator ; this . env = env ; this . nodeServicesProvider = nodeServicesProvider ; if ( indexTemplateFilters . isEmpty ( ) ) { this . indexTemplateFilter = DEFAULT_INDEX_TEMPLATE_FILTER ; } else { IndexTemplateFilter [ ] templateFilters = new IndexTemplateFilter [ indexTemplateFilters . size ( ) + <int> ] ; templateFilters [ <int> ] = DEFAULT_INDEX_TEMPLATE_FILTER ; int i = <int> ; for ( IndexTemplateFilter indexTemplateFilter : indexTemplateFilters ) { templateFilters [ i + + ] = indexTemplateFilter ; } this . indexTemplateFilter = new IndexTemplateFilter . Compound ( templateFilters ) ; } } public void validateIndexName ( String index , ClusterState state ) { if ( state . routingTable ( ) . hasIndex ( index ) ) { throw new IndexAlreadyExistsException ( new Index ( index ) ) ; } if ( state . metaData ( ) . hasIndex ( index ) ) { throw new IndexAlreadyExistsException ( new Index ( index ) ) ; } if ( ! Strings . validFileName ( index ) ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> + Strings . INVALID_FILENAME_CHARS ) ; } if ( index . contains ( <str> ) ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> ) ; } if ( index . charAt ( <int> ) = = <str> ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> ) ; } if ( ! index . toLowerCase ( Locale . ROOT ) . equals ( index ) ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> ) ; } int byteCount = <int> ; try { byteCount = index . getBytes ( <str> ) . length ; } catch ( UnsupportedEncodingException e ) { throw new ElasticsearchException ( <str> , e ) ; } if ( byteCount > MAX_INDEX_NAME_BYTES ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> + byteCount + <str> + MAX_INDEX_NAME_BYTES + <str> ) ; } if ( state . metaData ( ) . hasAlias ( index ) ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> ) ; } if ( index . equals ( <str> ) | | index . equals ( <str> ) ) { throw new InvalidIndexNameException ( new Index ( index ) , index , <str> ) ; } } public void createIndex ( final CreateIndexClusterStateUpdateRequest request , final ActionListener < ClusterStateUpdateResponse > listener ) { Settings . Builder updatedSettingsBuilder = Settings . settingsBuilder ( ) ; updatedSettingsBuilder . put ( request . settings ( ) ) . normalizePrefix ( IndexMetaData . INDEX_SETTING_PREFIX ) ; request . settings ( updatedSettingsBuilder . build ( ) ) ; clusterService . submitStateUpdateTask ( <str> + request . index ( ) + <str> + request . cause ( ) + <str> , new AckedClusterStateUpdateTask < ClusterStateUpdateResponse > ( Priority . URGENT , request , listener ) { @Override protected ClusterStateUpdateResponse newResponse ( boolean acknowledged ) { return new ClusterStateUpdateResponse ( acknowledged ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { boolean indexCreated = false ; String removalReason = null ; try { validate ( request , currentState ) ; for ( Alias alias : request . aliases ( ) ) { aliasValidator . validateAlias ( alias , request . index ( ) , currentState . metaData ( ) ) ; } List < IndexTemplateMetaData > templates = findTemplates ( request , currentState , indexTemplateFilter ) ; Map < String , Custom > customs = new HashMap < > ( ) ; Map < String , Map < String , Object > > mappings = new HashMap < > ( ) ; Map < String , AliasMetaData > templatesAliases = new HashMap < > ( ) ; List < String > templateNames = new ArrayList < > ( ) ; for ( Map . Entry < String , String > entry : request . mappings ( ) . entrySet ( ) ) { mappings . put ( entry . getKey ( ) , parseMapping ( entry . getValue ( ) ) ) ; } for ( Map . Entry < String , Custom > entry : request . customs ( ) . entrySet ( ) ) { customs . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( IndexTemplateMetaData template : templates ) { templateNames . add ( template . getName ( ) ) ; for ( ObjectObjectCursor < String , CompressedXContent > cursor : template . mappings ( ) ) { if ( mappings . containsKey ( cursor . key ) ) { XContentHelper . mergeDefaults ( mappings . get ( cursor . key ) , parseMapping ( cursor . value . string ( ) ) ) ; } else { mappings . put ( cursor . key , parseMapping ( cursor . value . string ( ) ) ) ; } } for ( ObjectObjectCursor < String , Custom > cursor : template . customs ( ) ) { String type = cursor . key ; IndexMetaData . Custom custom = cursor . value ; IndexMetaData . Custom existing = customs . get ( type ) ; if ( existing = = null ) { customs . put ( type , custom ) ; } else { IndexMetaData . Custom merged = existing . mergeWith ( custom ) ; customs . put ( type , merged ) ; } } for ( ObjectObjectCursor < String , AliasMetaData > cursor : template . aliases ( ) ) { AliasMetaData aliasMetaData = cursor . value ; if ( request . aliases ( ) . contains ( new Alias ( aliasMetaData . alias ( ) ) ) ) { continue ; } if ( templatesAliases . containsKey ( cursor . key ) ) { continue ; } if ( aliasMetaData . alias ( ) . contains ( <str> ) ) { String templatedAlias = aliasMetaData . alias ( ) . replace ( <str> , request . index ( ) ) ; aliasMetaData = AliasMetaData . newAliasMetaData ( aliasMetaData , templatedAlias ) ; } aliasValidator . validateAliasMetaData ( aliasMetaData , request . index ( ) , currentState . metaData ( ) ) ; templatesAliases . put ( aliasMetaData . alias ( ) , aliasMetaData ) ; } } Settings . Builder indexSettingsBuilder = settingsBuilder ( ) ; for ( int i = templates . size ( ) - <int> ; i > = <int> ; i - - ) { indexSettingsBuilder . put ( templates . get ( i ) . settings ( ) ) ; } indexSettingsBuilder . put ( request . settings ( ) ) ; if ( request . index ( ) . equals ( ScriptService . SCRIPT_INDEX ) ) { indexSettingsBuilder . put ( SETTING_NUMBER_OF_SHARDS , settings . getAsInt ( SETTING_NUMBER_OF_SHARDS , <int> ) ) ; } else { if ( indexSettingsBuilder . get ( SETTING_NUMBER_OF_SHARDS ) = = null ) { indexSettingsBuilder . put ( SETTING_NUMBER_OF_SHARDS , settings . getAsInt ( SETTING_NUMBER_OF_SHARDS , <int> ) ) ; } } if ( request . index ( ) . equals ( ScriptService . SCRIPT_INDEX ) ) { indexSettingsBuilder . put ( SETTING_NUMBER_OF_REPLICAS , settings . getAsInt ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) ; indexSettingsBuilder . put ( SETTING_AUTO_EXPAND_REPLICAS , <str> ) ; } else { if ( indexSettingsBuilder . get ( SETTING_NUMBER_OF_REPLICAS ) = = null ) { indexSettingsBuilder . put ( SETTING_NUMBER_OF_REPLICAS , settings . getAsInt ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) ; } } if ( settings . get ( SETTING_AUTO_EXPAND_REPLICAS ) ! = null & & indexSettingsBuilder . get ( SETTING_AUTO_EXPAND_REPLICAS ) = = null ) { indexSettingsBuilder . put ( SETTING_AUTO_EXPAND_REPLICAS , settings . get ( SETTING_AUTO_EXPAND_REPLICAS ) ) ; } if ( indexSettingsBuilder . get ( SETTING_VERSION_CREATED ) = = null ) { DiscoveryNodes nodes = currentState . nodes ( ) ; final Version createdVersion = Version . smallest ( version , nodes . smallestNonClientNodeVersion ( ) ) ; indexSettingsBuilder . put ( SETTING_VERSION_CREATED , createdVersion ) ; } if ( indexSettingsBuilder . get ( SETTING_CREATION_DATE ) = = null ) { indexSettingsBuilder . put ( SETTING_CREATION_DATE , new DateTime ( DateTimeZone . UTC ) . getMillis ( ) ) ; } indexSettingsBuilder . put ( SETTING_INDEX_UUID , Strings . randomBase64UUID ( ) ) ; Settings actualIndexSettings = indexSettingsBuilder . build ( ) ; final IndexMetaData tmpImd = IndexMetaData . builder ( request . index ( ) ) . settings ( actualIndexSettings ) . build ( ) ; indicesService . createIndex ( nodeServicesProvider , tmpImd , Collections . emptyList ( ) ) ; indexCreated = true ; IndexService indexService = indicesService . indexServiceSafe ( request . index ( ) ) ; MapperService mapperService = indexService . mapperService ( ) ; if ( mappings . containsKey ( MapperService . DEFAULT_MAPPING ) ) { try { mapperService . merge ( MapperService . DEFAULT_MAPPING , new CompressedXContent ( XContentFactory . jsonBuilder ( ) . map ( mappings . get ( MapperService . DEFAULT_MAPPING ) ) . string ( ) ) , false , request . updateAllTypes ( ) ) ; } catch ( Exception e ) { removalReason = <str> ; throw new MapperParsingException ( <str> , e , MapperService . DEFAULT_MAPPING , e . getMessage ( ) ) ; } } for ( Map . Entry < String , Map < String , Object > > entry : mappings . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( MapperService . DEFAULT_MAPPING ) ) { continue ; } try { mapperService . merge ( entry . getKey ( ) , new CompressedXContent ( XContentFactory . jsonBuilder ( ) . map ( entry . getValue ( ) ) . string ( ) ) , true , request . updateAllTypes ( ) ) ; } catch ( Exception e ) { removalReason = <str> ; throw new MapperParsingException ( <str> , e , entry . getKey ( ) , e . getMessage ( ) ) ; } } QueryShardContext queryShardContext = indexService . getQueryShardContext ( ) ; for ( Alias alias : request . aliases ( ) ) { if ( Strings . hasLength ( alias . filter ( ) ) ) { aliasValidator . validateAliasFilter ( alias . name ( ) , alias . filter ( ) , queryShardContext ) ; } } for ( AliasMetaData aliasMetaData : templatesAliases . values ( ) ) { if ( aliasMetaData . filter ( ) ! = null ) { aliasValidator . validateAliasFilter ( aliasMetaData . alias ( ) , aliasMetaData . filter ( ) . uncompressed ( ) , queryShardContext ) ; } } Map < String , MappingMetaData > mappingsMetaData = new HashMap < > ( ) ; for ( DocumentMapper mapper : mapperService . docMappers ( true ) ) { MappingMetaData mappingMd = new MappingMetaData ( mapper ) ; mappingsMetaData . put ( mapper . type ( ) , mappingMd ) ; } final IndexMetaData . Builder indexMetaDataBuilder = IndexMetaData . builder ( request . index ( ) ) . settings ( actualIndexSettings ) ; for ( MappingMetaData mappingMd : mappingsMetaData . values ( ) ) { indexMetaDataBuilder . putMapping ( mappingMd ) ; } for ( AliasMetaData aliasMetaData : templatesAliases . values ( ) ) { indexMetaDataBuilder . putAlias ( aliasMetaData ) ; } for ( Alias alias : request . aliases ( ) ) { AliasMetaData aliasMetaData = AliasMetaData . builder ( alias . name ( ) ) . filter ( alias . filter ( ) ) . indexRouting ( alias . indexRouting ( ) ) . searchRouting ( alias . searchRouting ( ) ) . build ( ) ; indexMetaDataBuilder . putAlias ( aliasMetaData ) ; } for ( Map . Entry < String , Custom > customEntry : customs . entrySet ( ) ) { indexMetaDataBuilder . putCustom ( customEntry . getKey ( ) , customEntry . getValue ( ) ) ; } indexMetaDataBuilder . state ( request . state ( ) ) ; final IndexMetaData indexMetaData ; try { indexMetaData = indexMetaDataBuilder . build ( ) ; } catch ( Exception e ) { removalReason = <str> ; throw e ; } indexService . getIndexEventListener ( ) . beforeIndexAddedToCluster ( new Index ( request . index ( ) ) , indexMetaData . getSettings ( ) ) ; MetaData newMetaData = MetaData . builder ( currentState . metaData ( ) ) . put ( indexMetaData , false ) . build ( ) ; String maybeShadowIndicator = IndexMetaData . isIndexUsingShadowReplicas ( indexMetaData . getSettings ( ) ) ? <str> : <str> ; logger . info ( <str> , request . index ( ) , request . cause ( ) , templateNames , indexMetaData . getNumberOfShards ( ) , indexMetaData . getNumberOfReplicas ( ) , maybeShadowIndicator , mappings . keySet ( ) ) ; ClusterBlocks . Builder blocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) ; if ( ! request . blocks ( ) . isEmpty ( ) ) { for ( ClusterBlock block : request . blocks ( ) ) { blocks . addIndexBlock ( request . index ( ) , block ) ; } } blocks . updateBlocks ( indexMetaData ) ; ClusterState updatedState = ClusterState . builder ( currentState ) . blocks ( blocks ) . metaData ( newMetaData ) . build ( ) ; if ( request . state ( ) = = State . OPEN ) { RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( updatedState . routingTable ( ) ) . addAsNew ( updatedState . metaData ( ) . index ( request . index ( ) ) ) ; RoutingAllocation . Result routingResult = allocationService . reroute ( ClusterState . builder ( updatedState ) . routingTable ( routingTableBuilder . build ( ) ) . build ( ) , <str> + request . index ( ) + <str> ) ; updatedState = ClusterState . builder ( updatedState ) . routingResult ( routingResult ) . build ( ) ; } removalReason = <str> ; return updatedState ; } finally { if ( indexCreated ) { indicesService . removeIndex ( request . index ( ) , removalReason ! = null ? removalReason : <str> ) ; } } } } ) ; } private Map < String , Object > parseMapping ( String mappingSource ) throws Exception { try ( XContentParser parser = XContentFactory . xContent ( mappingSource ) . createParser ( mappingSource ) ) { return parser . map ( ) ; } } private List < IndexTemplateMetaData > findTemplates ( CreateIndexClusterStateUpdateRequest request , ClusterState state , IndexTemplateFilter indexTemplateFilter ) throws IOException { List < IndexTemplateMetaData > templates = new ArrayList < > ( ) ; for ( ObjectCursor < IndexTemplateMetaData > cursor : state . metaData ( ) . templates ( ) . values ( ) ) { IndexTemplateMetaData template = cursor . value ; if ( indexTemplateFilter . apply ( request , template ) ) { templates . add ( template ) ; } } CollectionUtil . timSort ( templates , new Comparator < IndexTemplateMetaData > ( ) { @Override public int compare ( IndexTemplateMetaData o1 , IndexTemplateMetaData o2 ) { return o2 . order ( ) - o1 . order ( ) ; } } ) ; return templates ; } private void validate ( CreateIndexClusterStateUpdateRequest request , ClusterState state ) { validateIndexName ( request . index ( ) , state ) ; validateIndexSettings ( request . index ( ) , request . settings ( ) ) ; } public void validateIndexSettings ( String indexName , Settings settings ) throws IndexCreationException { List < String > validationErrors = getIndexSettingsValidationErrors ( settings ) ; if ( validationErrors . isEmpty ( ) = = false ) { ValidationException validationException = new ValidationException ( ) ; validationException . addValidationErrors ( validationErrors ) ; throw new IndexCreationException ( new Index ( indexName ) , validationException ) ; } } List < String > getIndexSettingsValidationErrors ( Settings settings ) { String customPath = settings . get ( IndexMetaData . SETTING_DATA_PATH , null ) ; List < String > validationErrors = new ArrayList < > ( ) ; if ( customPath ! = null & & env . sharedDataFile ( ) = = null ) { validationErrors . add ( <str> ) ; } else if ( customPath ! = null ) { Path resolvedPath = PathUtils . get ( new Path [ ] { env . sharedDataFile ( ) } , customPath ) ; if ( resolvedPath = = null ) { validationErrors . add ( <str> + customPath + <str> + env . sharedDataFile ( ) + <str> ) ; } } Integer number_of_primaries = settings . getAsInt ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , null ) ; Integer number_of_replicas = settings . getAsInt ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , null ) ; if ( number_of_primaries ! = null & & number_of_primaries < = <int> ) { validationErrors . add ( <str> ) ; } if ( number_of_replicas ! = null & & number_of_replicas < <int> ) { validationErrors . add ( <str> ) ; } return validationErrors ; } private static class DefaultIndexTemplateFilter implements IndexTemplateFilter { @Override public boolean apply ( CreateIndexClusterStateUpdateRequest request , IndexTemplateMetaData template ) { return Regex . simpleMatch ( template . template ( ) , request . index ( ) ) ; } } } 
