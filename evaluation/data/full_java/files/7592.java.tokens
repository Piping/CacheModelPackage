package org . elasticsearch . search . suggest . completion . context ; import org . apache . lucene . index . IndexableField ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . ParseContext . Document ; import java . io . IOException ; import java . util . * ; public class CategoryContextMapping extends ContextMapping { private static final String FIELD_FIELDNAME = <str> ; static final String CONTEXT_VALUE = <str> ; static final String CONTEXT_BOOST = <str> ; static final String CONTEXT_PREFIX = <str> ; private final String fieldName ; private CategoryContextMapping ( String name , String fieldName ) { super ( Type . CATEGORY , name ) ; this . fieldName = fieldName ; } public String getFieldName ( ) { return fieldName ; } protected static CategoryContextMapping load ( String name , Map < String , Object > config ) throws ElasticsearchParseException { CategoryContextMapping . Builder mapping = new CategoryContextMapping . Builder ( name ) ; Object fieldName = config . get ( FIELD_FIELDNAME ) ; if ( fieldName ! = null ) { mapping . field ( fieldName . toString ( ) ) ; config . remove ( FIELD_FIELDNAME ) ; } return mapping . build ( ) ; } @Override protected XContentBuilder toInnerXContent ( XContentBuilder builder , Params params ) throws IOException { if ( fieldName ! = null ) { builder . field ( FIELD_FIELDNAME , fieldName ) ; } return builder ; } @Override public Set < CharSequence > parseContext ( ParseContext parseContext , XContentParser parser ) throws IOException , ElasticsearchParseException { final Set < CharSequence > contexts = new HashSet < > ( ) ; Token token = parser . currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { contexts . add ( parser . text ( ) ) ; } else if ( token = = Token . START_ARRAY ) { while ( ( token = parser . nextToken ( ) ) ! = Token . END_ARRAY ) { if ( token = = Token . VALUE_STRING ) { contexts . add ( parser . text ( ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } } else { throw new ElasticsearchParseException ( <str> ) ; } return contexts ; } @Override public Set < CharSequence > parseContext ( Document document ) { Set < CharSequence > values = null ; if ( fieldName ! = null ) { IndexableField [ ] fields = document . getFields ( fieldName ) ; values = new HashSet < > ( fields . length ) ; for ( IndexableField field : fields ) { values . add ( field . stringValue ( ) ) ; } } return ( values = = null ) ? Collections . < CharSequence > emptySet ( ) : values ; } @Override public List < QueryContext > parseQueryContext ( XContentParser parser ) throws IOException , ElasticsearchParseException { List < QueryContext > queryContexts = new ArrayList < > ( ) ; Token token = parser . nextToken ( ) ; if ( token = = Token . START_OBJECT | | token = = Token . VALUE_STRING ) { CategoryQueryContext parse = CategoryQueryContext . parse ( parser ) ; queryContexts . add ( new QueryContext ( parse . getCategory ( ) . toString ( ) , parse . getBoost ( ) , parse . isPrefix ( ) ) ) ; } else if ( token = = Token . START_ARRAY ) { while ( parser . nextToken ( ) ! = Token . END_ARRAY ) { CategoryQueryContext parse = CategoryQueryContext . parse ( parser ) ; queryContexts . add ( new QueryContext ( parse . getCategory ( ) . toString ( ) , parse . getBoost ( ) , parse . isPrefix ( ) ) ) ; } } return queryContexts ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; if ( ! super . equals ( o ) ) return false ; CategoryContextMapping mapping = ( CategoryContextMapping ) o ; return ! ( fieldName ! = null ? ! fieldName . equals ( mapping . fieldName ) : mapping . fieldName ! = null ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , fieldName ) ; } public static class Builder extends ContextBuilder < CategoryContextMapping > { private String fieldName ; public Builder ( String name ) { super ( name ) ; } public Builder field ( String fieldName ) { this . fieldName = fieldName ; return this ; } @Override public CategoryContextMapping build ( ) { return new CategoryContextMapping ( name , fieldName ) ; } } } 
