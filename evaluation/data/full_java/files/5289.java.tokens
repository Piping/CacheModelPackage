package org . elasticsearch . action . fieldstats ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import java . io . IOException ; public abstract class FieldStats < T extends Comparable < T > > implements Streamable , ToXContent { private byte type ; private long maxDoc ; private long docCount ; private long sumDocFreq ; private long sumTotalTermFreq ; protected T minValue ; protected T maxValue ; protected FieldStats ( ) { } protected FieldStats ( int type , long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq ) { this . type = ( byte ) type ; this . maxDoc = maxDoc ; this . docCount = docCount ; this . sumDocFreq = sumDocFreq ; this . sumTotalTermFreq = sumTotalTermFreq ; } byte getType ( ) { return type ; } public long getMaxDoc ( ) { return maxDoc ; } public long getDocCount ( ) { return docCount ; } public int getDensity ( ) { if ( docCount < <int> | | maxDoc < = <int> ) { return - <int> ; } return ( int ) ( docCount * <int> / maxDoc ) ; } public long getSumDocFreq ( ) { return sumDocFreq ; } public long getSumTotalTermFreq ( ) { return sumTotalTermFreq ; } public T getMinValue ( ) { return minValue ; } public T getMaxValue ( ) { return maxValue ; } public abstract String getMinValueAsString ( ) ; public abstract String getMaxValueAsString ( ) ; protected abstract T valueOf ( String value , String optionalFormat ) ; public void append ( FieldStats stats ) { this . maxDoc + = stats . maxDoc ; if ( stats . docCount = = - <int> ) { this . docCount = - <int> ; } else if ( this . docCount ! = - <int> ) { this . docCount + = stats . docCount ; } if ( stats . sumDocFreq = = - <int> ) { this . sumDocFreq = - <int> ; } else if ( this . sumDocFreq ! = - <int> ) { this . sumDocFreq + = stats . sumDocFreq ; } if ( stats . sumTotalTermFreq = = - <int> ) { this . sumTotalTermFreq = - <int> ; } else if ( this . sumTotalTermFreq ! = - <int> ) { this . sumTotalTermFreq + = stats . sumTotalTermFreq ; } } public boolean match ( IndexConstraint constraint ) { int cmp ; T value = valueOf ( constraint . getValue ( ) , constraint . getOptionalFormat ( ) ) ; if ( constraint . getProperty ( ) = = IndexConstraint . Property . MIN ) { cmp = minValue . compareTo ( value ) ; } else if ( constraint . getProperty ( ) = = IndexConstraint . Property . MAX ) { cmp = maxValue . compareTo ( value ) ; } else { throw new IllegalArgumentException ( <str> + constraint . getProperty ( ) + <str> ) ; } switch ( constraint . getComparison ( ) ) { case GT : return cmp > <int> ; case GTE : return cmp > = <int> ; case LT : return cmp < <int> ; case LTE : return cmp < = <int> ; default : throw new IllegalArgumentException ( <str> + constraint . getComparison ( ) + <str> ) ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( Fields . MAX_DOC , maxDoc ) ; builder . field ( Fields . DOC_COUNT , docCount ) ; builder . field ( Fields . DENSITY , getDensity ( ) ) ; builder . field ( Fields . SUM_DOC_FREQ , sumDocFreq ) ; builder . field ( Fields . SUM_TOTAL_TERM_FREQ , sumTotalTermFreq ) ; toInnerXContent ( builder ) ; builder . endObject ( ) ; return builder ; } protected void toInnerXContent ( XContentBuilder builder ) throws IOException { builder . field ( Fields . MIN_VALUE , getMinValue ( ) ) ; builder . field ( Fields . MIN_VALUE_AS_STRING , getMinValueAsString ( ) ) ; builder . field ( Fields . MAX_VALUE , getMaxValue ( ) ) ; builder . field ( Fields . MAX_VALUE_AS_STRING , getMaxValueAsString ( ) ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { maxDoc = in . readVLong ( ) ; docCount = in . readLong ( ) ; sumDocFreq = in . readLong ( ) ; sumTotalTermFreq = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeByte ( type ) ; out . writeVLong ( maxDoc ) ; out . writeLong ( docCount ) ; out . writeLong ( sumDocFreq ) ; out . writeLong ( sumTotalTermFreq ) ; } public static class Long extends FieldStats < java . lang . Long > { public Long ( ) { } public Long ( long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , long minValue , long maxValue ) { this ( <int> , maxDoc , docCount , sumDocFreq , sumTotalTermFreq , minValue , maxValue ) ; } protected Long ( int type , long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , long minValue , long maxValue ) { super ( type , maxDoc , docCount , sumDocFreq , sumTotalTermFreq ) ; this . minValue = minValue ; this . maxValue = maxValue ; } @Override public String getMinValueAsString ( ) { return String . valueOf ( minValue . longValue ( ) ) ; } @Override public String getMaxValueAsString ( ) { return String . valueOf ( maxValue . longValue ( ) ) ; } @Override public void append ( FieldStats stats ) { super . append ( stats ) ; Long other = ( Long ) stats ; this . minValue = Math . min ( other . minValue , minValue ) ; this . maxValue = Math . max ( other . maxValue , maxValue ) ; } @Override protected java . lang . Long valueOf ( String value , String optionalFormat ) { if ( optionalFormat ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } return java . lang . Long . valueOf ( value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; minValue = in . readLong ( ) ; maxValue = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeLong ( minValue ) ; out . writeLong ( maxValue ) ; } } public static final class Float extends FieldStats < java . lang . Float > { public Float ( ) { } public Float ( long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , float minValue , float maxValue ) { super ( <int> , maxDoc , docCount , sumDocFreq , sumTotalTermFreq ) ; this . minValue = minValue ; this . maxValue = maxValue ; } @Override public String getMinValueAsString ( ) { return String . valueOf ( minValue . floatValue ( ) ) ; } @Override public String getMaxValueAsString ( ) { return String . valueOf ( maxValue . floatValue ( ) ) ; } @Override public void append ( FieldStats stats ) { super . append ( stats ) ; Float other = ( Float ) stats ; this . minValue = Math . min ( other . minValue , minValue ) ; this . maxValue = Math . max ( other . maxValue , maxValue ) ; } @Override protected java . lang . Float valueOf ( String value , String optionalFormat ) { if ( optionalFormat ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } return java . lang . Float . valueOf ( value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; minValue = in . readFloat ( ) ; maxValue = in . readFloat ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeFloat ( minValue ) ; out . writeFloat ( maxValue ) ; } } public static final class Double extends FieldStats < java . lang . Double > { public Double ( ) { } public Double ( long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , double minValue , double maxValue ) { super ( <int> , maxDoc , docCount , sumDocFreq , sumTotalTermFreq ) ; this . minValue = minValue ; this . maxValue = maxValue ; } @Override public String getMinValueAsString ( ) { return String . valueOf ( minValue . doubleValue ( ) ) ; } @Override public String getMaxValueAsString ( ) { return String . valueOf ( maxValue . doubleValue ( ) ) ; } @Override public void append ( FieldStats stats ) { super . append ( stats ) ; Double other = ( Double ) stats ; this . minValue = Math . min ( other . minValue , minValue ) ; this . maxValue = Math . max ( other . maxValue , maxValue ) ; } @Override protected java . lang . Double valueOf ( String value , String optionalFormat ) { if ( optionalFormat ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } return java . lang . Double . valueOf ( value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; minValue = in . readDouble ( ) ; maxValue = in . readDouble ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeDouble ( minValue ) ; out . writeDouble ( maxValue ) ; } } public static final class Text extends FieldStats < BytesRef > { public Text ( ) { } public Text ( long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , BytesRef minValue , BytesRef maxValue ) { super ( <int> , maxDoc , docCount , sumDocFreq , sumTotalTermFreq ) ; this . minValue = minValue ; this . maxValue = maxValue ; } @Override public String getMinValueAsString ( ) { return minValue . utf8ToString ( ) ; } @Override public String getMaxValueAsString ( ) { return maxValue . utf8ToString ( ) ; } @Override public void append ( FieldStats stats ) { super . append ( stats ) ; Text other = ( Text ) stats ; if ( other . minValue . compareTo ( minValue ) < <int> ) { minValue = other . minValue ; } if ( other . maxValue . compareTo ( maxValue ) > <int> ) { maxValue = other . maxValue ; } } @Override protected BytesRef valueOf ( String value , String optionalFormat ) { if ( optionalFormat ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } return new BytesRef ( value ) ; } @Override protected void toInnerXContent ( XContentBuilder builder ) throws IOException { builder . field ( Fields . MIN_VALUE , getMinValueAsString ( ) ) ; builder . field ( Fields . MAX_VALUE , getMaxValueAsString ( ) ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; minValue = in . readBytesRef ( ) ; maxValue = in . readBytesRef ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeBytesRef ( minValue ) ; out . writeBytesRef ( maxValue ) ; } } public static final class Date extends Long { private FormatDateTimeFormatter dateFormatter ; public Date ( ) { } public Date ( long maxDoc , long docCount , long sumDocFreq , long sumTotalTermFreq , long minValue , long maxValue , FormatDateTimeFormatter dateFormatter ) { super ( <int> , maxDoc , docCount , sumDocFreq , sumTotalTermFreq , minValue , maxValue ) ; this . dateFormatter = dateFormatter ; } @Override public String getMinValueAsString ( ) { return dateFormatter . printer ( ) . print ( minValue ) ; } @Override public String getMaxValueAsString ( ) { return dateFormatter . printer ( ) . print ( maxValue ) ; } @Override protected java . lang . Long valueOf ( String value , String optionalFormat ) { FormatDateTimeFormatter dateFormatter = this . dateFormatter ; if ( optionalFormat ! = null ) { dateFormatter = Joda . forPattern ( optionalFormat ) ; } return dateFormatter . parser ( ) . parseMillis ( value ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; dateFormatter = Joda . forPattern ( in . readString ( ) ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( dateFormatter . format ( ) ) ; } } public static FieldStats read ( StreamInput in ) throws IOException { FieldStats stats ; byte type = in . readByte ( ) ; switch ( type ) { case <int> : stats = new Long ( ) ; break ; case <int> : stats = new Float ( ) ; break ; case <int> : stats = new Double ( ) ; break ; case <int> : stats = new Text ( ) ; break ; case <int> : stats = new Date ( ) ; break ; default : throw new IllegalArgumentException ( <str> + type + <str> ) ; } stats . type = type ; stats . readFrom ( in ) ; return stats ; } private final static class Fields { final static XContentBuilderString MAX_DOC = new XContentBuilderString ( <str> ) ; final static XContentBuilderString DOC_COUNT = new XContentBuilderString ( <str> ) ; final static XContentBuilderString DENSITY = new XContentBuilderString ( <str> ) ; final static XContentBuilderString SUM_DOC_FREQ = new XContentBuilderString ( <str> ) ; final static XContentBuilderString SUM_TOTAL_TERM_FREQ = new XContentBuilderString ( <str> ) ; final static XContentBuilderString MIN_VALUE = new XContentBuilderString ( <str> ) ; final static XContentBuilderString MIN_VALUE_AS_STRING = new XContentBuilderString ( <str> ) ; final static XContentBuilderString MAX_VALUE = new XContentBuilderString ( <str> ) ; final static XContentBuilderString MAX_VALUE_AS_STRING = new XContentBuilderString ( <str> ) ; } } 
