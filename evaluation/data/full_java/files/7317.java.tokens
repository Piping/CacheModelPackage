package org . elasticsearch . search . aggregations . metrics . percentiles ; import com . carrotsearch . hppc . DoubleArrayList ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . metrics . percentiles . tdigest . InternalTDigestPercentiles ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSource . Numeric ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Arrays ; public abstract class AbstractPercentilesParser implements Aggregator . Parser { public static final ParseField KEYED_FIELD = new ParseField ( <str> ) ; public static final ParseField METHOD_FIELD = new ParseField ( <str> ) ; public static final ParseField COMPRESSION_FIELD = new ParseField ( <str> ) ; public static final ParseField NUMBER_SIGNIFICANT_DIGITS_FIELD = new ParseField ( <str> ) ; private boolean formattable ; public AbstractPercentilesParser ( boolean formattable ) { this . formattable = formattable ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { ValuesSourceParser < ValuesSource . Numeric > vsParser = ValuesSourceParser . numeric ( aggregationName , InternalTDigestPercentiles . TYPE , context ) . formattable ( formattable ) . build ( ) ; double [ ] keys = null ; boolean keyed = true ; Double compression = null ; Integer numberOfSignificantValueDigits = null ; PercentilesMethod method = null ; XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( vsParser . token ( currentFieldName , token , parser ) ) { continue ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , keysField ( ) ) ) { DoubleArrayList values = new DoubleArrayList ( <int> ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { double value = parser . doubleValue ( ) ; values . add ( value ) ; } keys = values . toArray ( ) ; Arrays . sort ( keys ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , KEYED_FIELD ) ) { keyed = parser . booleanValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( method ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> + currentFieldName + <str> + PercentilesMethod . TDIGEST . getName ( ) + <str> + PercentilesMethod . HDR . getName ( ) + <str> , parser . getTokenLocation ( ) ) ; } method = PercentilesMethod . resolveFromName ( currentFieldName ) ; if ( method = = null ) { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } else { switch ( method ) { case TDIGEST : while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , COMPRESSION_FIELD ) ) { compression = parser . doubleValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } break ; case HDR : while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , NUMBER_SIGNIFICANT_DIGITS_FIELD ) ) { numberOfSignificantValueDigits = parser . intValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } break ; } } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( method = = null ) { method = PercentilesMethod . TDIGEST ; } switch ( method ) { case TDIGEST : if ( numberOfSignificantValueDigits ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } if ( compression = = null ) { compression = <float> ; } break ; case HDR : if ( compression ! = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } if ( numberOfSignificantValueDigits = = null ) { numberOfSignificantValueDigits = <int> ; } break ; default: throw new SearchParseException ( context , <str> + currentFieldName + <str> + aggregationName + <str> + method + <str> , parser . getTokenLocation ( ) ) ; } return buildFactory ( context , aggregationName , vsParser . config ( ) , keys , method , compression , numberOfSignificantValueDigits , keyed ) ; } protected abstract AggregatorFactory buildFactory ( SearchContext context , String aggregationName , ValuesSourceConfig < Numeric > config , double [ ] cdfValues , PercentilesMethod method , Double compression , Integer numberOfSignificantValueDigits , boolean keyed ) ; protected abstract ParseField keysField ( ) ; } 
