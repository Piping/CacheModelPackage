package org . elasticsearch . cloud . aws ; import com . amazonaws . AmazonClientException ; import com . amazonaws . AmazonServiceException ; import com . amazonaws . services . s3 . AmazonS3 ; import com . amazonaws . services . s3 . model . * ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import java . io . IOException ; import java . io . InputStream ; import java . io . UnsupportedEncodingException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicLong ; import static com . carrotsearch . randomizedtesting . RandomizedTest . randomDouble ; public class TestAmazonS3 extends AmazonS3Wrapper { protected final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private double writeFailureRate = <float> ; private double readFailureRate = <float> ; private String randomPrefix ; ConcurrentMap < String , AtomicLong > accessCounts = new ConcurrentHashMap < String , AtomicLong > ( ) ; private long incrementAndGet ( String path ) { AtomicLong value = accessCounts . get ( path ) ; if ( value = = null ) { value = accessCounts . putIfAbsent ( path , new AtomicLong ( <int> ) ) ; } if ( value ! = null ) { return value . incrementAndGet ( ) ; } return <int> ; } public TestAmazonS3 ( AmazonS3 delegate , Settings settings ) { super ( delegate ) ; randomPrefix = settings . get ( <str> ) ; writeFailureRate = settings . getAsDouble ( <str> , <float> ) ; readFailureRate = settings . getAsDouble ( <str> , <float> ) ; } @Override public PutObjectResult putObject ( String bucketName , String key , InputStream input , ObjectMetadata metadata ) throws AmazonClientException , AmazonServiceException { if ( shouldFail ( bucketName , key , writeFailureRate ) ) { long length = metadata . getContentLength ( ) ; long partToRead = ( long ) ( length * randomDouble ( ) ) ; byte [ ] buffer = new byte [ <int> ] ; for ( long cur = <int> ; cur < partToRead ; cur + = buffer . length ) { try { input . read ( buffer , <int> , ( int ) ( partToRead - cur > buffer . length ? buffer . length : partToRead - cur ) ) ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } logger . info ( <str> , bucketName , key ) ; AmazonS3Exception ex = new AmazonS3Exception ( <str> ) ; ex . setStatusCode ( <int> ) ; ex . setErrorCode ( <str> ) ; throw ex ; } else { return super . putObject ( bucketName , key , input , metadata ) ; } } @Override public UploadPartResult uploadPart ( UploadPartRequest request ) throws AmazonClientException , AmazonServiceException { if ( shouldFail ( request . getBucketName ( ) , request . getKey ( ) , writeFailureRate ) ) { long length = request . getPartSize ( ) ; long partToRead = ( long ) ( length * randomDouble ( ) ) ; byte [ ] buffer = new byte [ <int> ] ; for ( long cur = <int> ; cur < partToRead ; cur + = buffer . length ) { try ( InputStream input = request . getInputStream ( ) ) { input . read ( buffer , <int> , ( int ) ( partToRead - cur > buffer . length ? buffer . length : partToRead - cur ) ) ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } logger . info ( <str> , request . getBucketName ( ) , request . getKey ( ) ) ; AmazonS3Exception ex = new AmazonS3Exception ( <str> ) ; ex . setStatusCode ( <int> ) ; ex . setErrorCode ( <str> ) ; throw ex ; } else { return super . uploadPart ( request ) ; } } @Override public S3Object getObject ( String bucketName , String key ) throws AmazonClientException , AmazonServiceException { if ( shouldFail ( bucketName , key , readFailureRate ) ) { logger . info ( <str> , bucketName , key ) ; AmazonS3Exception ex = new AmazonS3Exception ( <str> ) ; ex . setStatusCode ( <int> ) ; throw ex ; } else { return super . getObject ( bucketName , key ) ; } } private boolean shouldFail ( String bucketName , String key , double probability ) { if ( probability > <float> ) { String path = randomPrefix + <str> + bucketName + <str> + key ; path + = <str> + incrementAndGet ( path ) ; return Math . abs ( hashCode ( path ) ) < Integer . MAX_VALUE * probability ; } else { return false ; } } private int hashCode ( String path ) { try { MessageDigest digest = MessageDigest . getInstance ( <str> ) ; byte [ ] bytes = digest . digest ( path . getBytes ( <str> ) ) ; int i = <int> ; return ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( ( bytes [ i + + ] & <hex> ) < < <int> ) | ( bytes [ i + + ] & <hex> ) ; } catch ( UnsupportedEncodingException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } catch ( NoSuchAlgorithmException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } } 
