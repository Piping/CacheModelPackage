package org . elasticsearch . search . aggregations . bucket . significant ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . io . stream . InputStreamStreamInput ; import org . elasticsearch . common . io . stream . OutputStreamStreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . search . SearchShardTarget ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . ChiSquare ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . GND ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . JLHScore ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . MutualInformation ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . PercentageScore ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristic ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristicBuilder ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristicParser ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristicParserMapper ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . TestSearchContext ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . util . * ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . Matchers . * ; public class SignificanceHeuristicTests extends ESTestCase { static class SignificantTermsTestSearchContext extends TestSearchContext { @Override public int numberOfShards ( ) { return <int> ; } @Override public SearchShardTarget shardTarget ( ) { return new SearchShardTarget ( <str> , <str> , <int> ) ; } } public void testStreamResponse ( ) throws Exception { Version version = randomVersion ( random ( ) ) ; InternalSignificantTerms [ ] sigTerms = getRandomSignificantTerms ( getRandomSignificanceheuristic ( ) ) ; ByteArrayOutputStream outBuffer = new ByteArrayOutputStream ( ) ; OutputStreamStreamOutput out = new OutputStreamStreamOutput ( outBuffer ) ; out . setVersion ( version ) ; sigTerms [ <int> ] . writeTo ( out ) ; ByteArrayInputStream inBuffer = new ByteArrayInputStream ( outBuffer . toByteArray ( ) ) ; InputStreamStreamInput in = new InputStreamStreamInput ( inBuffer ) ; in . setVersion ( version ) ; sigTerms [ <int> ] . readFrom ( in ) ; assertTrue ( sigTerms [ <int> ] . significanceHeuristic . equals ( sigTerms [ <int> ] . significanceHeuristic ) ) ; InternalSignificantTerms . Bucket originalBucket = ( InternalSignificantTerms . Bucket ) sigTerms [ <int> ] . buckets . get ( <int> ) ; InternalSignificantTerms . Bucket streamedBucket = ( InternalSignificantTerms . Bucket ) sigTerms [ <int> ] . buckets . get ( <int> ) ; assertThat ( originalBucket . getKeyAsString ( ) , equalTo ( streamedBucket . getKeyAsString ( ) ) ) ; assertThat ( originalBucket . getSupersetDf ( ) , equalTo ( streamedBucket . getSupersetDf ( ) ) ) ; assertThat ( originalBucket . getSubsetDf ( ) , equalTo ( streamedBucket . getSubsetDf ( ) ) ) ; assertThat ( streamedBucket . getSubsetSize ( ) , equalTo ( <int> ) ) ; assertThat ( streamedBucket . getSupersetSize ( ) , equalTo ( <int> ) ) ; } InternalSignificantTerms [ ] getRandomSignificantTerms ( SignificanceHeuristic heuristic ) { InternalSignificantTerms [ ] sTerms = new InternalSignificantTerms [ <int> ] ; ArrayList < InternalSignificantTerms . Bucket > buckets = new ArrayList < > ( ) ; if ( randomBoolean ( ) ) { buckets . add ( new SignificantLongTerms . Bucket ( <int> , <int> , <int> , <int> , <int> , InternalAggregations . EMPTY , null ) ) ; sTerms [ <int> ] = new SignificantLongTerms ( <int> , <int> , <str> , null , <int> , <int> , heuristic , buckets , Collections . emptyList ( ) , null ) ; sTerms [ <int> ] = new SignificantLongTerms ( ) ; } else { BytesRef term = new BytesRef ( <str> ) ; buckets . add ( new SignificantStringTerms . Bucket ( term , <int> , <int> , <int> , <int> , InternalAggregations . EMPTY ) ) ; sTerms [ <int> ] = new SignificantStringTerms ( <int> , <int> , <str> , <int> , <int> , heuristic , buckets , Collections . emptyList ( ) , null ) ; sTerms [ <int> ] = new SignificantStringTerms ( ) ; } return sTerms ; } SignificanceHeuristic getRandomSignificanceheuristic ( ) { List < SignificanceHeuristic > heuristics = new ArrayList < > ( ) ; heuristics . add ( JLHScore . INSTANCE ) ; heuristics . add ( new MutualInformation ( randomBoolean ( ) , randomBoolean ( ) ) ) ; heuristics . add ( new GND ( randomBoolean ( ) ) ) ; heuristics . add ( new ChiSquare ( randomBoolean ( ) , randomBoolean ( ) ) ) ; return heuristics . get ( randomInt ( <int> ) ) ; } public void testReduce ( ) { List < InternalAggregation > aggs = createInternalAggregations ( ) ; SignificantTerms reducedAgg = ( SignificantTerms ) aggs . get ( <int> ) . doReduce ( aggs , null ) ; assertThat ( reducedAgg . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSubsetDf ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSubsetSize ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSupersetDf ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSupersetSize ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSubsetDf ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSubsetSize ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSupersetDf ( ) , equalTo ( <int> ) ) ; assertThat ( reducedAgg . getBuckets ( ) . get ( <int> ) . getSupersetSize ( ) , equalTo ( <int> ) ) ; } private List < InternalAggregation > createInternalAggregations ( ) { String type = randomBoolean ( ) ? <str> : <str> ; SignificanceHeuristic significanceHeuristic = getRandomSignificanceheuristic ( ) ; List < InternalAggregation > aggs = new ArrayList < > ( ) ; List < InternalSignificantTerms . Bucket > terms0Buckets = new ArrayList < > ( ) ; terms0Buckets . add ( createBucket ( type , <int> , <int> , <int> , <int> , <int> ) ) ; aggs . add ( createAggregation ( type , significanceHeuristic , terms0Buckets , <int> , <int> ) ) ; List < InternalSignificantTerms . Bucket > terms1Buckets = new ArrayList < > ( ) ; terms0Buckets . add ( createBucket ( type , <int> , <int> , <int> , <int> , <int> ) ) ; aggs . add ( createAggregation ( type , significanceHeuristic , terms1Buckets , <int> , <int> ) ) ; List < InternalSignificantTerms . Bucket > terms01Buckets = new ArrayList < > ( ) ; terms0Buckets . add ( createBucket ( type , <int> , <int> , <int> , <int> , <int> ) ) ; terms0Buckets . add ( createBucket ( type , <int> , <int> , <int> , <int> , <int> ) ) ; aggs . add ( createAggregation ( type , significanceHeuristic , terms01Buckets , <int> , <int> ) ) ; return aggs ; } private InternalSignificantTerms createAggregation ( String type , SignificanceHeuristic significanceHeuristic , List < InternalSignificantTerms . Bucket > buckets , long subsetSize , long supersetSize ) { if ( type . equals ( <str> ) ) { return new SignificantStringTerms ( subsetSize , supersetSize , <str> , <int> , - <int> , significanceHeuristic , buckets , new ArrayList < PipelineAggregator > ( ) , new HashMap < String , Object > ( ) ) ; } else { return new SignificantLongTerms ( subsetSize , supersetSize , <str> , ValueFormatter . RAW , <int> , - <int> , significanceHeuristic , buckets , new ArrayList < PipelineAggregator > ( ) , new HashMap < String , Object > ( ) ) ; } } private InternalSignificantTerms . Bucket createBucket ( String type , long subsetDF , long subsetSize , long supersetDF , long supersetSize , long label ) { if ( type . equals ( <str> ) ) { return new SignificantStringTerms . Bucket ( new BytesRef ( Long . toString ( label ) . getBytes ( StandardCharsets . UTF_8 ) ) , subsetDF , subsetSize , supersetDF , supersetSize , InternalAggregations . EMPTY ) ; } else { return new SignificantLongTerms . Bucket ( subsetDF , subsetSize , supersetDF , supersetSize , label , InternalAggregations . EMPTY , ValueFormatter . RAW ) ; } } public void testBuilderAndParser ( ) throws Exception { Set < SignificanceHeuristicParser > parsers = new HashSet < > ( ) ; SignificanceHeuristicParserMapper heuristicParserMapper = new SignificanceHeuristicParserMapper ( parsers , null ) ; SearchContext searchContext = new SignificantTermsTestSearchContext ( ) ; assertTrue ( parseFromString ( heuristicParserMapper , searchContext , <str> ) instanceof JLHScore ) ; assertTrue ( parseFromString ( heuristicParserMapper , searchContext , <str> ) instanceof GND ) ; boolean includeNegatives = randomBoolean ( ) ; boolean backgroundIsSuperset = randomBoolean ( ) ; assertThat ( parseFromString ( heuristicParserMapper , searchContext , <str> + includeNegatives + <str> + backgroundIsSuperset + <str> ) , equalTo ( ( SignificanceHeuristic ) ( new MutualInformation ( includeNegatives , backgroundIsSuperset ) ) ) ) ; assertThat ( parseFromString ( heuristicParserMapper , searchContext , <str> + includeNegatives + <str> + backgroundIsSuperset + <str> ) , equalTo ( ( SignificanceHeuristic ) ( new ChiSquare ( includeNegatives , backgroundIsSuperset ) ) ) ) ; assertTrue ( parseFromBuilder ( heuristicParserMapper , searchContext , new JLHScore . JLHScoreBuilder ( ) ) instanceof JLHScore ) ; assertTrue ( parseFromBuilder ( heuristicParserMapper , searchContext , new GND . GNDBuilder ( backgroundIsSuperset ) ) instanceof GND ) ; assertThat ( parseFromBuilder ( heuristicParserMapper , searchContext , new MutualInformation . MutualInformationBuilder ( includeNegatives , backgroundIsSuperset ) ) , equalTo ( ( SignificanceHeuristic ) new MutualInformation ( includeNegatives , backgroundIsSuperset ) ) ) ; assertThat ( parseFromBuilder ( heuristicParserMapper , searchContext , new ChiSquare . ChiSquareBuilder ( includeNegatives , backgroundIsSuperset ) ) , equalTo ( ( SignificanceHeuristic ) new ChiSquare ( includeNegatives , backgroundIsSuperset ) ) ) ; String faultyHeuristicdefinition = <str> ; String expectedError = <str> ; checkParseException ( heuristicParserMapper , searchContext , faultyHeuristicdefinition , expectedError ) ; faultyHeuristicdefinition = <str> ; expectedError = <str> ; checkParseException ( heuristicParserMapper , searchContext , faultyHeuristicdefinition , expectedError ) ; faultyHeuristicdefinition = <str> ; expectedError = <str> ; checkParseException ( heuristicParserMapper , searchContext , faultyHeuristicdefinition , expectedError ) ; faultyHeuristicdefinition = <str> ; expectedError = <str> ; checkParseException ( heuristicParserMapper , searchContext , faultyHeuristicdefinition , expectedError ) ; } protected void checkParseException ( SignificanceHeuristicParserMapper heuristicParserMapper , SearchContext searchContext , String faultyHeuristicDefinition , String expectedError ) throws IOException { try { XContentParser stParser = JsonXContent . jsonXContent . createParser ( <str> + faultyHeuristicDefinition + <str> ) ; stParser . nextToken ( ) ; new SignificantTermsParser ( heuristicParserMapper ) . parse ( <str> , stParser , searchContext ) ; fail ( ) ; } catch ( ElasticsearchParseException e ) { assertTrue ( e . getMessage ( ) . contains ( expectedError ) ) ; } } protected SignificanceHeuristic parseFromBuilder ( SignificanceHeuristicParserMapper heuristicParserMapper , SearchContext searchContext , SignificanceHeuristicBuilder significanceHeuristicBuilder ) throws IOException { SignificantTermsBuilder stBuilder = new SignificantTermsBuilder ( <str> ) ; stBuilder . significanceHeuristic ( significanceHeuristicBuilder ) . field ( <str> ) . minDocCount ( <int> ) ; XContentBuilder stXContentBuilder = XContentFactory . jsonBuilder ( ) ; stBuilder . internalXContent ( stXContentBuilder , null ) ; XContentParser stParser = JsonXContent . jsonXContent . createParser ( stXContentBuilder . string ( ) ) ; return parseSignificanceHeuristic ( heuristicParserMapper , searchContext , stParser ) ; } private SignificanceHeuristic parseSignificanceHeuristic ( SignificanceHeuristicParserMapper heuristicParserMapper , SearchContext searchContext , XContentParser stParser ) throws IOException { stParser . nextToken ( ) ; SignificantTermsAggregatorFactory aggregatorFactory = ( SignificantTermsAggregatorFactory ) new SignificantTermsParser ( heuristicParserMapper ) . parse ( <str> , stParser , searchContext ) ; stParser . nextToken ( ) ; assertThat ( aggregatorFactory . getBucketCountThresholds ( ) . getMinDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( stParser . currentToken ( ) , equalTo ( null ) ) ; stParser . close ( ) ; return aggregatorFactory . getSignificanceHeuristic ( ) ; } protected SignificanceHeuristic parseFromString ( SignificanceHeuristicParserMapper heuristicParserMapper , SearchContext searchContext , String heuristicString ) throws IOException { XContentParser stParser = JsonXContent . jsonXContent . createParser ( <str> + heuristicString + <str> ) ; return parseSignificanceHeuristic ( heuristicParserMapper , searchContext , stParser ) ; } void testBackgroundAssertions ( SignificanceHeuristic heuristicIsSuperset , SignificanceHeuristic heuristicNotSuperset ) { try { heuristicIsSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicIsSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicIsSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicIsSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicIsSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException assertionError ) { assertNotNull ( assertionError . getMessage ( ) ) ; assertTrue ( assertionError . getMessage ( ) . contains ( <str> ) ) ; } try { int idx = randomInt ( <int> ) ; long [ ] values = { <int> , <int> , <int> , <int> } ; values [ idx ] * = - <int> ; heuristicIsSuperset . getScore ( values [ <int> ] , values [ <int> ] , values [ <int> ] , values [ <int> ] ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicNotSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristicNotSuperset . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { int idx = randomInt ( <int> ) ; long [ ] values = { <int> , <int> , <int> , <int> } ; values [ idx ] * = - <int> ; heuristicNotSuperset . getScore ( values [ <int> ] , values [ <int> ] , values [ <int> ] , values [ <int> ] ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } } void testAssertions ( SignificanceHeuristic heuristic ) { try { int idx = randomInt ( <int> ) ; long [ ] values = { <int> , <int> , <int> , <int> } ; values [ idx ] * = - <int> ; heuristic . getScore ( values [ <int> ] , values [ <int> ] , values [ <int> ] , values [ <int> ] ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristic . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } try { heuristic . getScore ( <int> , <int> , <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException illegalArgumentException ) { assertNotNull ( illegalArgumentException . getMessage ( ) ) ; assertTrue ( illegalArgumentException . getMessage ( ) . contains ( <str> ) ) ; } } public void testAssertions ( ) throws Exception { testBackgroundAssertions ( new MutualInformation ( true , true ) , new MutualInformation ( true , false ) ) ; testBackgroundAssertions ( new ChiSquare ( true , true ) , new ChiSquare ( true , false ) ) ; testBackgroundAssertions ( new GND ( true ) , new GND ( false ) ) ; testAssertions ( PercentageScore . INSTANCE ) ; testAssertions ( JLHScore . INSTANCE ) ; } public void testBasicScoreProperties ( ) { basicScoreProperties ( JLHScore . INSTANCE , true ) ; basicScoreProperties ( new GND ( true ) , true ) ; basicScoreProperties ( PercentageScore . INSTANCE , true ) ; basicScoreProperties ( new MutualInformation ( true , true ) , false ) ; basicScoreProperties ( new ChiSquare ( true , true ) , false ) ; } public void basicScoreProperties ( SignificanceHeuristic heuristic , boolean test0 ) { assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , greaterThan ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , lessThan ( heuristic . getScore ( <int> , <int> , <int> , <int> ) ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , lessThan ( heuristic . getScore ( <int> , <int> , <int> , <int> ) ) ) ; if ( test0 ) { assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; } double score = <float> ; try { long a = randomLong ( ) ; long b = randomLong ( ) ; long c = randomLong ( ) ; long d = randomLong ( ) ; score = heuristic . getScore ( a , b , c , d ) ; } catch ( IllegalArgumentException e ) { } assertThat ( score , greaterThanOrEqualTo ( <float> ) ) ; } public void testScoreMutual ( ) throws Exception { SignificanceHeuristic heuristic = new MutualInformation ( true , true ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , greaterThan ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , lessThan ( heuristic . getScore ( <int> , <int> , <int> , <int> ) ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; double score = <float> ; try { long a = randomLong ( ) ; long b = randomLong ( ) ; long c = randomLong ( ) ; long d = randomLong ( ) ; score = heuristic . getScore ( a , b , c , d ) ; } catch ( IllegalArgumentException e ) { } assertThat ( score , lessThanOrEqualTo ( <float> ) ) ; assertThat ( score , greaterThanOrEqualTo ( <float> ) ) ; heuristic = new MutualInformation ( false , true ) ; assertThat ( heuristic . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( Double . NEGATIVE_INFINITY ) ) ; heuristic = new MutualInformation ( true , false ) ; score = heuristic . getScore ( <int> , <int> , <int> , <int> ) ; assertThat ( score , greaterThanOrEqualTo ( <float> ) ) ; assertThat ( score , lessThanOrEqualTo ( <float> ) ) ; score = heuristic . getScore ( <int> , <int> , <int> , <int> ) ; assertThat ( score , greaterThanOrEqualTo ( <float> ) ) ; assertThat ( score , lessThanOrEqualTo ( <float> ) ) ; score = heuristic . getScore ( <int> , <int> , <int> , <int> ) ; assertThat ( score , greaterThanOrEqualTo ( <float> ) ) ; assertThat ( score , lessThanOrEqualTo ( <float> ) ) ; } public void testGNDCornerCases ( ) throws Exception { GND gnd = new GND ( true ) ; assertThat ( gnd . getScore ( <int> , randomIntBetween ( <int> , <int> ) , <int> , randomIntBetween ( <int> , <int> ) ) , equalTo ( <float> ) ) ; assertThat ( gnd . getScore ( <int> , randomIntBetween ( <int> , <int> ) , randomIntBetween ( <int> , <int> ) , randomIntBetween ( <int> , <int> ) ) , equalTo ( <float> ) ) ; assertThat ( gnd . getScore ( <int> , <int> , <int> , randomIntBetween ( <int> , <int> ) ) , equalTo ( <float> ) ) ; assertThat ( gnd . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; gnd = new GND ( false ) ; assertThat ( gnd . getScore ( <int> , <int> , <int> , <int> ) , equalTo ( <float> ) ) ; } } 
