package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . UniformStreamByteDistributor . DEFAULT_MIN_ALLOCATION_CHUNK ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . eq ; import static org . mockito . Matchers . same ; import static org . mockito . Mockito . atMost ; import static org . mockito . Mockito . doNothing ; import static org . mockito . Mockito . doThrow ; import static org . mockito . Mockito . reset ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyNoMoreInteractions ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . verification . VerificationMode ; public class UniformStreamByteDistributorTest { private static int CHUNK_SIZE = DEFAULT_MIN_ALLOCATION_CHUNK ; private static final int STREAM_A = <int> ; private static final int STREAM_B = <int> ; private static final int STREAM_C = <int> ; private static final int STREAM_D = <int> ; private Http2Connection connection ; private UniformStreamByteDistributor distributor ; @Mock private StreamByteDistributor . Writer writer ; @Before public void setup ( ) throws Http2Exception { MockitoAnnotations . initMocks ( this ) ; connection = new DefaultHttp2Connection ( false ) ; distributor = new UniformStreamByteDistributor ( connection ) ; connection . local ( ) . createStream ( STREAM_A , false ) ; connection . local ( ) . createStream ( STREAM_B , false ) ; Http2Stream streamC = connection . local ( ) . createStream ( STREAM_C , false ) ; Http2Stream streamD = connection . local ( ) . createStream ( STREAM_D , false ) ; streamC . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; streamD . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; } @Test public void bytesUnassignedAfterProcessing ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertFalse ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; verifyNoMoreInteractions ( writer ) ; assertFalse ( write ( <int> ) ) ; verifyNoMoreInteractions ( writer ) ; } @Test public void connectionErrorForWriterException ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; Exception fakeException = new RuntimeException ( <str> ) ; doThrow ( fakeException ) . when ( writer ) . write ( same ( stream ( STREAM_C ) ) , eq ( <int> ) ) ; try { write ( <int> ) ; fail ( <str> ) ; } catch ( Http2Exception e ) { assertFalse ( Http2Exception . isStreamError ( e ) ) ; assertEquals ( Http2Error . INTERNAL_ERROR , e . error ( ) ) ; assertSame ( fakeException , e . getCause ( ) ) ; } verifyWrite ( atMost ( <int> ) , STREAM_A , <int> ) ; verifyWrite ( atMost ( <int> ) , STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( atMost ( <int> ) , STREAM_D , <int> ) ; doNothing ( ) . when ( writer ) . write ( same ( stream ( STREAM_C ) ) , eq ( <int> ) ) ; write ( <int> ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void minChunkShouldBeAllocatedPerStream ( ) throws Http2Exception { setPriority ( STREAM_A , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_B , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_C , STREAM_A , ( short ) <int> , false ) ; setPriority ( STREAM_D , STREAM_A , ( short ) <int> , false ) ; updateStream ( STREAM_A , CHUNK_SIZE , true ) ; updateStream ( STREAM_B , CHUNK_SIZE , true ) ; updateStream ( STREAM_C , CHUNK_SIZE , true ) ; updateStream ( STREAM_D , CHUNK_SIZE , true ) ; int written = <int> * CHUNK_SIZE ; assertTrue ( write ( written ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_A ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_B ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_C ) ) ; verifyNoMoreInteractions ( writer ) ; reset ( writer ) ; assertFalse ( write ( CHUNK_SIZE ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_D ) ) ; verifyNoMoreInteractions ( writer ) ; } @Test public void streamWithMoreDataShouldBeEnqueuedAfterWrite ( ) throws Http2Exception { updateStream ( STREAM_A , <int> * CHUNK_SIZE , true ) ; assertTrue ( write ( CHUNK_SIZE ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_A ) ) ; verifyNoMoreInteractions ( writer ) ; reset ( writer ) ; assertFalse ( write ( CHUNK_SIZE ) ) ; assertEquals ( CHUNK_SIZE , captureWrite ( STREAM_A ) ) ; verifyNoMoreInteractions ( writer ) ; } @Test public void emptyFrameAtHeadIsWritten ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyNoMoreInteractions ( writer ) ; } private Http2Stream stream ( int streamId ) { return connection . stream ( streamId ) ; } private void updateStream ( final int streamId , final int streamableBytes , final boolean hasFrame ) { final Http2Stream stream = stream ( streamId ) ; distributor . updateStreamableBytes ( new StreamByteDistributor . StreamState ( ) { @Override public Http2Stream stream ( ) { return stream ; } @Override public int streamableBytes ( ) { return streamableBytes ; } @Override public boolean hasFrame ( ) { return hasFrame ; } } ) ; } private void setPriority ( int streamId , int parent , int weight , boolean exclusive ) throws Http2Exception { stream ( streamId ) . setPriority ( parent , ( short ) weight , exclusive ) ; } private boolean write ( int numBytes ) throws Http2Exception { return distributor . distribute ( numBytes , writer ) ; } private void verifyWrite ( int streamId , int numBytes ) { verify ( writer ) . write ( same ( stream ( streamId ) ) , eq ( numBytes ) ) ; } private void verifyWrite ( VerificationMode mode , int streamId , int numBytes ) { verify ( writer , mode ) . write ( same ( stream ( streamId ) ) , eq ( numBytes ) ) ; } private int captureWrite ( int streamId ) { ArgumentCaptor < Integer > captor = ArgumentCaptor . forClass ( Integer . class ) ; verify ( writer ) . write ( same ( stream ( streamId ) ) , captor . capture ( ) ) ; return captor . getValue ( ) ; } } 
