package org . apache . cassandra . triggers ; import java . io . File ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . collect . ListMultimap ; import com . google . common . collect . Maps ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . schema . TriggerMetadata ; import org . apache . cassandra . schema . Triggers ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; public class TriggerExecutor { public static final TriggerExecutor instance = new TriggerExecutor ( ) ; private final Map < String , ITrigger > cachedTriggers = Maps . newConcurrentMap ( ) ; private final ClassLoader parent = Thread . currentThread ( ) . getContextClassLoader ( ) ; private volatile ClassLoader customClassLoader ; private TriggerExecutor ( ) { reloadClasses ( ) ; } public void reloadClasses ( ) { File triggerDirectory = FBUtilities . cassandraTriggerDir ( ) ; if ( triggerDirectory = = null ) return ; customClassLoader = new CustomClassLoader ( parent , triggerDirectory ) ; cachedTriggers . clear ( ) ; } public PartitionUpdate execute ( PartitionUpdate updates ) throws InvalidRequestException { List < Mutation > intermediate = executeInternal ( updates ) ; if ( intermediate = = null | | intermediate . isEmpty ( ) ) return updates ; return PartitionUpdate . merge ( validateForSinglePartition ( updates . metadata ( ) . cfId , updates . partitionKey ( ) , intermediate ) ) ; } public Collection < Mutation > execute ( Collection < ? extends IMutation > mutations ) throws InvalidRequestException { boolean hasCounters = false ; List < Mutation > augmentedMutations = null ; for ( IMutation mutation : mutations ) { if ( mutation instanceof CounterMutation ) hasCounters = true ; for ( PartitionUpdate upd : mutation . getPartitionUpdates ( ) ) { List < Mutation > augmentations = executeInternal ( upd ) ; if ( augmentations = = null | | augmentations . isEmpty ( ) ) continue ; validate ( augmentations ) ; if ( augmentedMutations = = null ) augmentedMutations = new LinkedList < > ( ) ; augmentedMutations . addAll ( augmentations ) ; } } if ( augmentedMutations = = null ) return null ; if ( hasCounters ) throw new InvalidRequestException ( <str> ) ; @SuppressWarnings ( <str> ) Collection < Mutation > originalMutations = ( Collection < Mutation > ) mutations ; return mergeMutations ( Iterables . concat ( originalMutations , augmentedMutations ) ) ; } private Collection < Mutation > mergeMutations ( Iterable < Mutation > mutations ) { ListMultimap < Pair < String , ByteBuffer > , Mutation > groupedMutations = ArrayListMultimap . create ( ) ; for ( Mutation mutation : mutations ) { Pair < String , ByteBuffer > key = Pair . create ( mutation . getKeyspaceName ( ) , mutation . key ( ) . getKey ( ) ) ; groupedMutations . put ( key , mutation ) ; } List < Mutation > merged = new ArrayList < > ( groupedMutations . size ( ) ) ; for ( Pair < String , ByteBuffer > key : groupedMutations . keySet ( ) ) merged . add ( Mutation . merge ( groupedMutations . get ( key ) ) ) ; return merged ; } private List < PartitionUpdate > validateForSinglePartition ( UUID cfId , DecoratedKey key , Collection < Mutation > tmutations ) throws InvalidRequestException { validate ( tmutations ) ; if ( tmutations . size ( ) = = <int> ) { List < PartitionUpdate > updates = Lists . newArrayList ( Iterables . getOnlyElement ( tmutations ) . getPartitionUpdates ( ) ) ; if ( updates . size ( ) > <int> ) throw new InvalidRequestException ( <str> ) ; validateSamePartition ( cfId , key , Iterables . getOnlyElement ( updates ) ) ; return updates ; } ArrayList < PartitionUpdate > updates = new ArrayList < > ( tmutations . size ( ) ) ; for ( Mutation mutation : tmutations ) { for ( PartitionUpdate update : mutation . getPartitionUpdates ( ) ) { validateSamePartition ( cfId , key , update ) ; updates . add ( update ) ; } } return updates ; } private void validateSamePartition ( UUID cfId , DecoratedKey key , PartitionUpdate update ) throws InvalidRequestException { if ( ! key . equals ( update . partitionKey ( ) ) ) throw new InvalidRequestException ( <str> ) ; if ( ! cfId . equals ( update . metadata ( ) . cfId ) ) throw new InvalidRequestException ( <str> ) ; } private void validate ( Collection < Mutation > tmutations ) throws InvalidRequestException { for ( Mutation mutation : tmutations ) { QueryProcessor . validateKey ( mutation . key ( ) . getKey ( ) ) ; for ( PartitionUpdate update : mutation . getPartitionUpdates ( ) ) update . validate ( ) ; } } private List < Mutation > executeInternal ( PartitionUpdate update ) { Triggers triggers = update . metadata ( ) . getTriggers ( ) ; if ( triggers . isEmpty ( ) ) return null ; List < Mutation > tmutations = Lists . newLinkedList ( ) ; Thread . currentThread ( ) . setContextClassLoader ( customClassLoader ) ; try { for ( TriggerMetadata td : triggers ) { ITrigger trigger = cachedTriggers . get ( td . classOption ) ; if ( trigger = = null ) { trigger = loadTriggerInstance ( td . classOption ) ; cachedTriggers . put ( td . classOption , trigger ) ; } Collection < Mutation > temp = trigger . augment ( update ) ; if ( temp ! = null ) tmutations . addAll ( temp ) ; } return tmutations ; } catch ( Exception ex ) { throw new RuntimeException ( String . format ( <str> , update . metadata ( ) . cfId ) , ex ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( parent ) ; } } public synchronized ITrigger loadTriggerInstance ( String triggerName ) throws Exception { if ( cachedTriggers . get ( triggerName ) ! = null ) return cachedTriggers . get ( triggerName ) ; return ( ITrigger ) customClassLoader . loadClass ( triggerName ) . getConstructor ( ) . newInstance ( ) ; } } 
