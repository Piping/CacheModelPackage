package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . TestShardRouting ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESAllocationTestCase ; import java . io . BufferedReader ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public abstract class CatAllocationTestCase extends ESAllocationTestCase { protected abstract Path getCatPath ( ) throws IOException ; public void testRun ( ) throws IOException { Set < String > nodes = new HashSet < > ( ) ; Map < String , Idx > indices = new HashMap < > ( ) ; try ( BufferedReader reader = Files . newBufferedReader ( getCatPath ( ) , StandardCharsets . UTF_8 ) ) { String line = null ; Pattern pattern = Pattern . compile ( <str> ) ; while ( ( line = reader . readLine ( ) ) ! = null ) { final Matcher matcher ; if ( ( matcher = pattern . matcher ( line ) ) . matches ( ) ) { final String index = matcher . group ( <int> ) ; Idx idx = indices . get ( index ) ; if ( idx = = null ) { idx = new Idx ( index ) ; indices . put ( index , idx ) ; } final int shard = Integer . parseInt ( matcher . group ( <int> ) ) ; final boolean primary = matcher . group ( <int> ) . equals ( <str> ) ; ShardRoutingState state = ShardRoutingState . valueOf ( matcher . group ( <int> ) ) ; String ip = matcher . group ( <int> ) ; nodes . add ( ip ) ; ShardRouting routing = TestShardRouting . newShardRouting ( index , shard , ip , null , null , primary , state , <int> ) ; idx . add ( routing ) ; logger . debug ( <str> , routing ) ; } else { fail ( <str> + line ) ; } } } logger . info ( <str> ) ; MetaData . Builder builder = MetaData . builder ( ) ; RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( ) ; for ( Idx idx : indices . values ( ) ) { IndexMetaData idxMeta = IndexMetaData . builder ( idx . name ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( idx . numShards ( ) ) . numberOfReplicas ( idx . numReplicas ( ) ) . build ( ) ; builder . put ( idxMeta , false ) ; IndexRoutingTable . Builder tableBuilder = new IndexRoutingTable . Builder ( idx . name ) . initializeAsRecovery ( idxMeta ) ; Map < Integer , IndexShardRoutingTable > shardIdToRouting = new HashMap < > ( ) ; for ( ShardRouting r : idx . routing ) { IndexShardRoutingTable refData = new IndexShardRoutingTable . Builder ( new ShardId ( idx . name , r . id ( ) ) ) . addShard ( r ) . build ( ) ; if ( shardIdToRouting . containsKey ( r . getId ( ) ) ) { refData = new IndexShardRoutingTable . Builder ( shardIdToRouting . get ( r . getId ( ) ) ) . addShard ( r ) . build ( ) ; } shardIdToRouting . put ( r . getId ( ) , refData ) ; } for ( IndexShardRoutingTable t : shardIdToRouting . values ( ) ) { tableBuilder . addIndexShard ( t ) ; } IndexRoutingTable table = tableBuilder . build ( ) ; routingTableBuilder . add ( table ) ; } MetaData metaData = builder . build ( ) ; RoutingTable routingTable = routingTableBuilder . build ( ) ; DiscoveryNodes . Builder builderDiscoNodes = DiscoveryNodes . builder ( ) ; for ( String node : nodes ) { builderDiscoNodes . put ( newNode ( node ) ) ; } ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( builderDiscoNodes . build ( ) ) . build ( ) ; if ( balanceFirst ( ) ) { clusterState = rebalance ( clusterState ) ; } clusterState = allocateNew ( clusterState ) ; } protected abstract ClusterState allocateNew ( ClusterState clusterState ) ; protected boolean balanceFirst ( ) { return true ; } private ClusterState rebalance ( ClusterState clusterState ) { RoutingTable routingTable ; AllocationService strategy = createAllocationService ( settingsBuilder ( ) . build ( ) ) ; RoutingAllocation . Result reroute = strategy . reroute ( clusterState , <str> ) ; routingTable = reroute . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingTable = clusterState . routingTable ( ) ; int numRelocations = <int> ; while ( true ) { List < ShardRouting > initializing = routingTable . shardsWithState ( INITIALIZING ) ; if ( initializing . isEmpty ( ) ) { break ; } logger . debug ( initializing . toString ( ) ) ; numRelocations + = initializing . size ( ) ; routingTable = strategy . applyStartedShards ( clusterState , initializing ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; } logger . debug ( <str> + numRelocations ) ; return clusterState ; } public class Idx { final String name ; final List < ShardRouting > routing = new ArrayList < > ( ) ; public Idx ( String name ) { this . name = name ; } public void add ( ShardRouting r ) { routing . add ( r ) ; } public int numReplicas ( ) { int count = <int> ; for ( ShardRouting msr : routing ) { if ( msr . primary ( ) = = false & & msr . id ( ) = = <int> ) { count + + ; } } return count ; } public int numShards ( ) { int max = <int> ; for ( ShardRouting msr : routing ) { if ( msr . primary ( ) ) { max = Math . max ( msr . getId ( ) + <int> , max ) ; } } return max ; } } } 
