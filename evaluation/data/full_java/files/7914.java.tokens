package org . elasticsearch . common . geo ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; public class ShapeRelationTests extends ESTestCase { public void testValidOrdinals ( ) { assertThat ( ShapeRelation . INTERSECTS . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( ShapeRelation . DISJOINT . ordinal ( ) , equalTo ( <int> ) ) ; assertThat ( ShapeRelation . WITHIN . ordinal ( ) , equalTo ( <int> ) ) ; } public void testwriteTo ( ) throws Exception { try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { ShapeRelation . INTERSECTS . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { ShapeRelation . DISJOINT . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { ShapeRelation . WITHIN . writeTo ( out ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( in . readVInt ( ) , equalTo ( <int> ) ) ; } } } public void testReadFrom ( ) throws Exception { try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( ShapeRelation . DISJOINT . readFrom ( in ) , equalTo ( ShapeRelation . INTERSECTS ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( ShapeRelation . DISJOINT . readFrom ( in ) , equalTo ( ShapeRelation . DISJOINT ) ) ; } } try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( <int> ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { assertThat ( ShapeRelation . DISJOINT . readFrom ( in ) , equalTo ( ShapeRelation . WITHIN ) ) ; } } } public void testInvalidReadFrom ( ) throws Exception { try ( BytesStreamOutput out = new BytesStreamOutput ( ) ) { out . writeVInt ( randomIntBetween ( <int> , Integer . MAX_VALUE ) ) ; try ( StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ) { ShapeRelation . DISJOINT . readFrom ( in ) ; fail ( <str> ) ; } catch ( IOException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } } } 
