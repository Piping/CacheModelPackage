package com . badlogic . gdx . maps . tiled . tiles ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . maps . MapProperties ; import com . badlogic . gdx . maps . tiled . TiledMapTile ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . TimeUtils ; public class AnimatedTiledMapTile implements TiledMapTile { private static long lastTiledMapRenderTime = <int> ; private int id ; private BlendMode blendMode = BlendMode . ALPHA ; private MapProperties properties ; private StaticTiledMapTile [ ] frameTiles ; private int [ ] animationIntervals ; private int frameCount = <int> ; private int loopDuration ; private static final long initialTimeOffset = TimeUtils . millis ( ) ; @Override public int getId ( ) { return id ; } @Override public void setId ( int id ) { this . id = id ; } @Override public BlendMode getBlendMode ( ) { return blendMode ; } @Override public void setBlendMode ( BlendMode blendMode ) { this . blendMode = blendMode ; } public int getCurrentFrameIndex ( ) { int currentTime = ( int ) ( lastTiledMapRenderTime % loopDuration ) ; for ( int i = <int> ; i < animationIntervals . length ; + + i ) { int animationInterval = animationIntervals [ i ] ; if ( currentTime < = animationInterval ) return i ; currentTime - = animationInterval ; } throw new GdxRuntimeException ( <str> ) ; } public TiledMapTile getCurrentFrame ( ) { return frameTiles [ getCurrentFrameIndex ( ) ] ; } @Override public TextureRegion getTextureRegion ( ) { return getCurrentFrame ( ) . getTextureRegion ( ) ; } @Override public void setTextureRegion ( TextureRegion textureRegion ) { throw new GdxRuntimeException ( <str> ) ; } @Override public float getOffsetX ( ) { return getCurrentFrame ( ) . getOffsetX ( ) ; } @Override public void setOffsetX ( float offsetX ) { throw new GdxRuntimeException ( <str> ) ; } @Override public float getOffsetY ( ) { return getCurrentFrame ( ) . getOffsetY ( ) ; } @Override public void setOffsetY ( float offsetY ) { throw new GdxRuntimeException ( <str> ) ; } public int [ ] getAnimationIntervals ( ) { return animationIntervals ; } public void setAnimationIntervals ( int [ ] intervals ) { if ( intervals . length = = animationIntervals . length ) { this . animationIntervals = intervals ; loopDuration = <int> ; for ( int i = <int> ; i < intervals . length ; i + + ) { loopDuration + = intervals [ i ] ; } } else { throw new GdxRuntimeException ( <str> + intervals . length + <str> + animationIntervals . length + <str> ) ; } } @Override public MapProperties getProperties ( ) { if ( properties = = null ) { properties = new MapProperties ( ) ; } return properties ; } public static void updateAnimationBaseTime ( ) { lastTiledMapRenderTime = TimeUtils . millis ( ) - initialTimeOffset ; } public AnimatedTiledMapTile ( float interval , Array < StaticTiledMapTile > frameTiles ) { this . frameTiles = new StaticTiledMapTile [ frameTiles . size ] ; this . frameCount = frameTiles . size ; this . loopDuration = frameTiles . size * ( int ) ( interval * <int> f ) ; this . animationIntervals = new int [ frameTiles . size ] ; for ( int i = <int> ; i < frameTiles . size ; + + i ) { this . frameTiles [ i ] = frameTiles . get ( i ) ; this . animationIntervals [ i ] = ( int ) ( interval * <int> f ) ; } } public AnimatedTiledMapTile ( IntArray intervals , Array < StaticTiledMapTile > frameTiles ) { this . frameTiles = new StaticTiledMapTile [ frameTiles . size ] ; this . frameCount = frameTiles . size ; this . animationIntervals = intervals . toArray ( ) ; this . loopDuration = <int> ; for ( int i = <int> ; i < intervals . size ; + + i ) { this . frameTiles [ i ] = frameTiles . get ( i ) ; this . loopDuration + = intervals . get ( i ) ; } } public StaticTiledMapTile [ ] getFrameTiles ( ) { return frameTiles ; } } 
