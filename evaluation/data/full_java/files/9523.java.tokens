package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . collect . Maps ; import java . util . Collections ; import java . util . Iterator ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicLong ; @GwtCompatible public final class AtomicLongMap < K > { private final ConcurrentHashMap < K , AtomicLong > map ; private AtomicLongMap ( ConcurrentHashMap < K , AtomicLong > map ) { this . map = checkNotNull ( map ) ; } public static < K > AtomicLongMap < K > create ( ) { return new AtomicLongMap < K > ( new ConcurrentHashMap < K , AtomicLong > ( ) ) ; } public static < K > AtomicLongMap < K > create ( Map < ? extends K , ? extends Long > m ) { AtomicLongMap < K > result = create ( ) ; result . putAll ( m ) ; return result ; } public long get ( K key ) { AtomicLong atomic = map . get ( key ) ; return atomic = = null ? <int> L : atomic . get ( ) ; } public long incrementAndGet ( K key ) { return addAndGet ( key , <int> ) ; } public long decrementAndGet ( K key ) { return addAndGet ( key , - <int> ) ; } public long addAndGet ( K key , long delta ) { outer : while ( true ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { atomic = map . putIfAbsent ( key , new AtomicLong ( delta ) ) ; if ( atomic = = null ) { return delta ; } } while ( true ) { long oldValue = atomic . get ( ) ; if ( oldValue = = <int> L ) { if ( map . replace ( key , atomic , new AtomicLong ( delta ) ) ) { return delta ; } continue outer ; } long newValue = oldValue + delta ; if ( atomic . compareAndSet ( oldValue , newValue ) ) { return newValue ; } } } } public long getAndIncrement ( K key ) { return getAndAdd ( key , <int> ) ; } public long getAndDecrement ( K key ) { return getAndAdd ( key , - <int> ) ; } public long getAndAdd ( K key , long delta ) { outer : while ( true ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { atomic = map . putIfAbsent ( key , new AtomicLong ( delta ) ) ; if ( atomic = = null ) { return <int> L ; } } while ( true ) { long oldValue = atomic . get ( ) ; if ( oldValue = = <int> L ) { if ( map . replace ( key , atomic , new AtomicLong ( delta ) ) ) { return <int> L ; } continue outer ; } long newValue = oldValue + delta ; if ( atomic . compareAndSet ( oldValue , newValue ) ) { return oldValue ; } } } } public long put ( K key , long newValue ) { outer : while ( true ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { atomic = map . putIfAbsent ( key , new AtomicLong ( newValue ) ) ; if ( atomic = = null ) { return <int> L ; } } while ( true ) { long oldValue = atomic . get ( ) ; if ( oldValue = = <int> L ) { if ( map . replace ( key , atomic , new AtomicLong ( newValue ) ) ) { return <int> L ; } continue outer ; } if ( atomic . compareAndSet ( oldValue , newValue ) ) { return oldValue ; } } } } public void putAll ( Map < ? extends K , ? extends Long > m ) { for ( Map . Entry < ? extends K , ? extends Long > entry : m . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } public long remove ( K key ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { return <int> L ; } while ( true ) { long oldValue = atomic . get ( ) ; if ( oldValue = = <int> L | | atomic . compareAndSet ( oldValue , <int> L ) ) { map . remove ( key , atomic ) ; return oldValue ; } } } public void removeAllZeros ( ) { Iterator < Map . Entry < K , AtomicLong > > entryIterator = map . entrySet ( ) . iterator ( ) ; while ( entryIterator . hasNext ( ) ) { Map . Entry < K , AtomicLong > entry = entryIterator . next ( ) ; AtomicLong atomic = entry . getValue ( ) ; if ( atomic ! = null & & atomic . get ( ) = = <int> L ) { entryIterator . remove ( ) ; } } } public long sum ( ) { long sum = <int> L ; for ( AtomicLong value : map . values ( ) ) { sum = sum + value . get ( ) ; } return sum ; } private transient Map < K , Long > asMap ; public Map < K , Long > asMap ( ) { Map < K , Long > result = asMap ; return ( result = = null ) ? asMap = createAsMap ( ) : result ; } private Map < K , Long > createAsMap ( ) { return Collections . unmodifiableMap ( Maps . transformValues ( map , new Function < AtomicLong , Long > ( ) { @Override public Long apply ( AtomicLong atomic ) { return atomic . get ( ) ; } } ) ) ; } public boolean containsKey ( Object key ) { return map . containsKey ( key ) ; } public int size ( ) { return map . size ( ) ; } public boolean isEmpty ( ) { return map . isEmpty ( ) ; } public void clear ( ) { map . clear ( ) ; } @Override public String toString ( ) { return map . toString ( ) ; } long putIfAbsent ( K key , long newValue ) { while ( true ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { atomic = map . putIfAbsent ( key , new AtomicLong ( newValue ) ) ; if ( atomic = = null ) { return <int> L ; } } long oldValue = atomic . get ( ) ; if ( oldValue = = <int> L ) { if ( map . replace ( key , atomic , new AtomicLong ( newValue ) ) ) { return <int> L ; } continue ; } return oldValue ; } } boolean replace ( K key , long expectedOldValue , long newValue ) { if ( expectedOldValue = = <int> L ) { return putIfAbsent ( key , newValue ) = = <int> L ; } else { AtomicLong atomic = map . get ( key ) ; return ( atomic = = null ) ? false : atomic . compareAndSet ( expectedOldValue , newValue ) ; } } boolean remove ( K key , long value ) { AtomicLong atomic = map . get ( key ) ; if ( atomic = = null ) { return false ; } long oldValue = atomic . get ( ) ; if ( oldValue ! = value ) { return false ; } if ( oldValue = = <int> L | | atomic . compareAndSet ( oldValue , <int> L ) ) { map . remove ( key , atomic ) ; return true ; } return false ; } } 
