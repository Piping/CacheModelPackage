package org . elasticsearch . search . query ; import org . elasticsearch . action . explain . ExplainResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . mapper . internal . FieldNamesFieldMapper ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import static java . util . Collections . emptyMap ; import static java . util . Collections . singletonMap ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchHits ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; public class ExistsIT extends ESIntegTestCase { public void testEmptyIndex ( ) throws Exception { createIndex ( <str> ) ; ensureYellow ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . existsQuery ( <str> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( resp ) ; resp = client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . boolQuery ( ) . mustNot ( QueryBuilders . existsQuery ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( resp ) ; } public void testExists ( ) throws Exception { XContentBuilder mapping = XContentBuilder . builder ( JsonXContent . jsonXContent ) . startObject ( ) . startObject ( <str> ) . startObject ( FieldNamesFieldMapper . NAME ) . field ( <str> , randomBoolean ( ) ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , mapping ) ) ; @SuppressWarnings ( <str> ) Map < String , Object > barObject = new HashMap < > ( ) ; barObject . put ( <str> , <str> ) ; barObject . put ( <str> , singletonMap ( <str> , <str> ) ) ; final Map < String , Object > [ ] sources = new Map [ ] { singletonMap ( <str> , <str> ) , singletonMap ( <str> , barObject ) , singletonMap ( <str> , singletonMap ( <str> , <int> ) ) , emptyMap ( ) } ; List < IndexRequestBuilder > reqs = new ArrayList < IndexRequestBuilder > ( ) ; for ( Map < String , Object > source : sources ) { reqs . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( source ) ) ; } indexRandom ( true , false , reqs ) ; final Map < String , Integer > expected = new LinkedHashMap < String , Integer > ( ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; ensureYellow ( <str> ) ; final long numDocs = sources . length ; SearchResponse allDocs = client ( ) . prepareSearch ( <str> ) . setSize ( sources . length ) . get ( ) ; assertSearchResponse ( allDocs ) ; assertHitCount ( allDocs , numDocs ) ; for ( Map . Entry < String , Integer > entry : expected . entrySet ( ) ) { final String fieldName = entry . getKey ( ) ; final int count = entry . getValue ( ) ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . existsQuery ( fieldName ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( resp ) ; try { assertEquals ( String . format ( Locale . ROOT , <str> , fieldName , count , mapping . string ( ) , resp ) , count , resp . getHits ( ) . totalHits ( ) ) ; } catch ( AssertionError e ) { for ( SearchHit searchHit : allDocs . getHits ( ) ) { final String index = searchHit . getIndex ( ) ; final String type = searchHit . getType ( ) ; final String id = searchHit . getId ( ) ; final ExplainResponse explanation = client ( ) . prepareExplain ( index , type , id ) . setQuery ( QueryBuilders . existsQuery ( fieldName ) ) . get ( ) ; logger . info ( <str> , fieldName , id , searchHit . getSourceAsString ( ) , explanation . getExplanation ( ) ) ; } throw e ; } } } } 
