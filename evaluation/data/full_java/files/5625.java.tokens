package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . settings . Validator ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . Locale ; public class ClusterRebalanceAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE = <str> ; public static final Validator ALLOCATION_ALLOW_REBALANCE_VALIDATOR = ( setting , value , clusterState ) - > { try { ClusterRebalanceType . parseString ( value ) ; return null ; } catch ( IllegalArgumentException e ) { return <str> + setting + <str> ; } } ; public static enum ClusterRebalanceType { ALWAYS , INDICES_PRIMARIES_ACTIVE , INDICES_ALL_ACTIVE ; public static ClusterRebalanceType parseString ( String typeString ) { if ( <str> . equalsIgnoreCase ( typeString ) ) { return ClusterRebalanceType . ALWAYS ; } else if ( <str> . equalsIgnoreCase ( typeString ) | | <str> . equalsIgnoreCase ( typeString ) ) { return ClusterRebalanceType . INDICES_PRIMARIES_ACTIVE ; } else if ( <str> . equalsIgnoreCase ( typeString ) | | <str> . equalsIgnoreCase ( typeString ) ) { return ClusterRebalanceType . INDICES_ALL_ACTIVE ; } throw new IllegalArgumentException ( <str> + CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE + <str> + typeString ) ; } } private ClusterRebalanceType type ; @Inject public ClusterRebalanceAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; String allowRebalance = settings . get ( CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) ; try { type = ClusterRebalanceType . parseString ( allowRebalance ) ; } catch ( IllegalStateException e ) { logger . warn ( <str> , CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , allowRebalance ) ; type = ClusterRebalanceType . INDICES_ALL_ACTIVE ; } logger . debug ( <str> , CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , type . toString ( ) . toLowerCase ( Locale . ROOT ) ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { String newAllowRebalance = settings . get ( CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , null ) ; if ( newAllowRebalance ! = null ) { ClusterRebalanceType newType = null ; try { newType = ClusterRebalanceType . parseString ( newAllowRebalance ) ; } catch ( IllegalArgumentException e ) { } if ( newType ! = null & & newType ! = ClusterRebalanceAllocationDecider . this . type ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , ClusterRebalanceAllocationDecider . this . type . toString ( ) . toLowerCase ( Locale . ROOT ) , newType . toString ( ) . toLowerCase ( Locale . ROOT ) ) ; ClusterRebalanceAllocationDecider . this . type = newType ; } } } } @Override public Decision canRebalance ( ShardRouting shardRouting , RoutingAllocation allocation ) { return canRebalance ( allocation ) ; } @Override public Decision canRebalance ( RoutingAllocation allocation ) { if ( type = = ClusterRebalanceType . INDICES_PRIMARIES_ACTIVE ) { if ( allocation . routingNodes ( ) . hasUnassignedPrimaries ( ) ) { return allocation . decision ( Decision . NO , NAME , <str> ) ; } if ( allocation . routingNodes ( ) . hasInactivePrimaries ( ) ) { return allocation . decision ( Decision . NO , NAME , <str> ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } if ( type = = ClusterRebalanceType . INDICES_ALL_ACTIVE ) { if ( allocation . routingNodes ( ) . hasUnassignedShards ( ) ) { return allocation . decision ( Decision . NO , NAME , <str> ) ; } if ( allocation . routingNodes ( ) . hasInactiveShards ( ) ) { return allocation . decision ( Decision . NO , NAME , <str> ) ; } } return allocation . decision ( Decision . YES , NAME , <str> ) ; } } 
