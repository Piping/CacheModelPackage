package org . eclipse . core . externaltools . internal . model ; import java . util . HashMap ; import java . util . Map ; import java . util . StringTokenizer ; import org . eclipse . core . externaltools . internal . IExternalToolConstants ; import org . eclipse . core . externaltools . internal . registry . ExternalToolMigration ; import org . eclipse . core . resources . ICommand ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IncrementalProjectBuilder ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Path ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchManager ; public class BuilderCoreUtils { public static final String LAUNCH_CONFIG_HANDLE = <str> ; public static final String INC_CLEAN = <str> ; public static final String BUILDER_FOLDER_NAME = <str> ; public static final String PROJECT_TAG = <str> ; public static final String VERSION_1_0 = <str> ; public static final String VERSION_2_1 = <str> ; public static final String VERSION_3_0_interim = <str> ; public static final String VERSION_3_0_final = <str> ; private static final String BUILD_TYPE_SEPARATOR = <str> ; private static final int [ ] DEFAULT_BUILD_TYPES = new int [ ] { IncrementalProjectBuilder . INCREMENTAL_BUILD , IncrementalProjectBuilder . FULL_BUILD } ; public static ILaunchConfiguration configFromBuildCommandArgs ( IProject project , Map < String , String > commandArgs , String [ ] version ) { String configHandle = commandArgs . get ( LAUNCH_CONFIG_HANDLE ) ; if ( configHandle = = null ) { version [ <int> ] = VERSION_1_0 ; return ExternalToolMigration . configFromArgumentMap ( commandArgs ) ; } ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfiguration configuration = null ; if ( configHandle . startsWith ( PROJECT_TAG ) ) { version [ <int> ] = VERSION_3_0_final ; IPath path = new Path ( configHandle ) ; IFile file = project . getFile ( path . removeFirstSegments ( <int> ) ) ; if ( file . exists ( ) ) { configuration = manager . getLaunchConfiguration ( file ) ; } } else { IPath path = new Path ( BUILDER_FOLDER_NAME ) . append ( configHandle ) ; IFile file = project . getFile ( path ) ; if ( file . exists ( ) ) { version [ <int> ] = VERSION_3_0_interim ; configuration = manager . getLaunchConfiguration ( file ) ; } else { try { configuration = manager . getLaunchConfiguration ( configHandle ) ; } catch ( CoreException e ) { } if ( configuration ! = null ) { version [ <int> ] = VERSION_2_1 ; } } } return configuration ; } public static void configureTriggers ( ILaunchConfiguration config , ICommand newCommand ) throws CoreException { newCommand . setBuilding ( IncrementalProjectBuilder . FULL_BUILD , false ) ; newCommand . setBuilding ( IncrementalProjectBuilder . INCREMENTAL_BUILD , false ) ; newCommand . setBuilding ( IncrementalProjectBuilder . AUTO_BUILD , false ) ; newCommand . setBuilding ( IncrementalProjectBuilder . CLEAN_BUILD , false ) ; String buildKinds = config . getAttribute ( IExternalToolConstants . ATTR_RUN_BUILD_KINDS , ( String ) null ) ; int [ ] triggers = buildTypesToArray ( buildKinds ) ; boolean isfull = false , isinc = false ; for ( int i = <int> ; i < triggers . length ; i + + ) { switch ( triggers [ i ] ) { case IncrementalProjectBuilder . FULL_BUILD : newCommand . setBuilding ( IncrementalProjectBuilder . FULL_BUILD , true ) ; isfull = true ; break ; case IncrementalProjectBuilder . INCREMENTAL_BUILD : newCommand . setBuilding ( IncrementalProjectBuilder . INCREMENTAL_BUILD , true ) ; isinc = true ; break ; case IncrementalProjectBuilder . AUTO_BUILD : newCommand . setBuilding ( IncrementalProjectBuilder . AUTO_BUILD , true ) ; break ; case IncrementalProjectBuilder . CLEAN_BUILD : newCommand . setBuilding ( IncrementalProjectBuilder . CLEAN_BUILD , true ) ; break ; default : break ; } } if ( ! isfull & & isinc ) { Map < String , String > args = newCommand . getArguments ( ) ; if ( args = = null ) { args = new HashMap < String , String > ( ) ; } newCommand . setBuilding ( IncrementalProjectBuilder . FULL_BUILD , true ) ; args . put ( INC_CLEAN , Boolean . TRUE . toString ( ) ) ; newCommand . setArguments ( args ) ; } if ( ! config . getAttribute ( IExternalToolConstants . ATTR_TRIGGERS_CONFIGURED , false ) ) { ILaunchConfigurationWorkingCopy copy = config . getWorkingCopy ( ) ; copy . setAttribute ( IExternalToolConstants . ATTR_TRIGGERS_CONFIGURED , true ) ; copy . doSave ( ) ; } } public static boolean isUnmigratedConfig ( ILaunchConfiguration config ) { return config . isWorkingCopy ( ) & & ( ( ILaunchConfigurationWorkingCopy ) config ) . getOriginal ( ) = = null ; } public static ICommand toBuildCommand ( IProject project , ILaunchConfiguration config , ICommand command ) throws CoreException { Map < String , String > args = null ; if ( isUnmigratedConfig ( config ) ) { ICommand [ ] commands = project . getDescription ( ) . getBuildSpec ( ) ; for ( int i = <int> ; i < commands . length ; i + + ) { ICommand projectCommand = commands [ i ] ; String name = ExternalToolMigration . getNameFromCommandArgs ( projectCommand . getArguments ( ) ) ; if ( name ! = null & & name . equals ( config . getName ( ) ) ) { args = projectCommand . getArguments ( ) ; break ; } } } else { ILaunchConfiguration temp = config ; if ( config instanceof ILaunchConfigurationWorkingCopy ) { ILaunchConfigurationWorkingCopy workingCopy = ( ILaunchConfigurationWorkingCopy ) config ; if ( workingCopy . getOriginal ( ) ! = null ) { temp = workingCopy . getOriginal ( ) ; } } args = new HashMap < String , String > ( ) ; StringBuffer buffer = new StringBuffer ( PROJECT_TAG ) ; buffer . append ( <str> ) . append ( temp . getFile ( ) . getFullPath ( ) . removeFirstSegments ( <int> ) ) ; args . put ( LAUNCH_CONFIG_HANDLE , buffer . toString ( ) ) ; } command . setBuilderName ( ExternalToolBuilder . ID ) ; command . setArguments ( args ) ; return command ; } public static IFolder getBuilderFolder ( IProject project , boolean create ) { if ( project = = null ) { return null ; } IFolder folder = project . getFolder ( BUILDER_FOLDER_NAME ) ; if ( ! folder . exists ( ) & & create ) { try { folder . create ( true , true , new NullProgressMonitor ( ) ) ; } catch ( CoreException e ) { return null ; } } return folder ; } public static ILaunchConfiguration migrateBuilderConfiguration ( IProject project , ILaunchConfigurationWorkingCopy workingCopy ) throws CoreException { workingCopy . setContainer ( getBuilderFolder ( project , true ) ) ; String name = workingCopy . getName ( ) ; name = name . replace ( <str> , <str> ) ; if ( name . charAt ( <int> ) = = ( <str> ) ) { name = name . substring ( <int> ) ; } IStatus status = ResourcesPlugin . getWorkspace ( ) . validateName ( name , IResource . FILE ) ; if ( ! status . isOK ( ) ) { name = <str> ; } name = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateLaunchConfigurationName ( name ) ; workingCopy . rename ( name ) ; return workingCopy . doSave ( ) ; } public static int [ ] buildTypesToArray ( String buildTypes ) { if ( buildTypes = = null | | buildTypes . length ( ) = = <int> ) { return DEFAULT_BUILD_TYPES ; } int count = <int> ; boolean incremental = false ; boolean full = false ; boolean auto = false ; boolean clean = false ; StringTokenizer tokenizer = new StringTokenizer ( buildTypes , BUILD_TYPE_SEPARATOR ) ; while ( tokenizer . hasMoreTokens ( ) ) { String token = tokenizer . nextToken ( ) ; if ( IExternalToolConstants . BUILD_TYPE_INCREMENTAL . equals ( token ) ) { if ( ! incremental ) { incremental = true ; count + + ; } } else if ( IExternalToolConstants . BUILD_TYPE_FULL . equals ( token ) ) { if ( ! full ) { full = true ; count + + ; } } else if ( IExternalToolConstants . BUILD_TYPE_AUTO . equals ( token ) ) { if ( ! auto ) { auto = true ; count + + ; } } else if ( IExternalToolConstants . BUILD_TYPE_CLEAN . equals ( token ) ) { if ( ! clean ) { clean = true ; count + + ; } } } int [ ] results = new int [ count ] ; count = <int> ; if ( incremental ) { results [ count ] = IncrementalProjectBuilder . INCREMENTAL_BUILD ; count + + ; } if ( full ) { results [ count ] = IncrementalProjectBuilder . FULL_BUILD ; count + + ; } if ( auto ) { results [ count ] = IncrementalProjectBuilder . AUTO_BUILD ; count + + ; } if ( clean ) { results [ count ] = IncrementalProjectBuilder . CLEAN_BUILD ; count + + ; } return results ; } } 
