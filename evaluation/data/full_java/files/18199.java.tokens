package com . badlogic . gdx . math ; public class Polyline implements Shape2D { private float [ ] localVertices ; private float [ ] worldVertices ; private float x , y ; private float originX , originY ; private float rotation ; private float scaleX = <int> , scaleY = <int> ; private float length ; private float scaledLength ; private boolean calculateScaledLength = true ; private boolean calculateLength = true ; private boolean dirty = true ; public Polyline ( ) { this . localVertices = new float [ <int> ] ; } public Polyline ( float [ ] vertices ) { if ( vertices . length < <int> ) throw new IllegalArgumentException ( <str> ) ; this . localVertices = vertices ; } public float [ ] getVertices ( ) { return localVertices ; } public float [ ] getTransformedVertices ( ) { if ( ! dirty ) return worldVertices ; dirty = false ; final float [ ] localVertices = this . localVertices ; if ( worldVertices = = null | | worldVertices . length < localVertices . length ) worldVertices = new float [ localVertices . length ] ; final float [ ] worldVertices = this . worldVertices ; final float positionX = x ; final float positionY = y ; final float originX = this . originX ; final float originY = this . originY ; final float scaleX = this . scaleX ; final float scaleY = this . scaleY ; final boolean scale = scaleX ! = <int> | | scaleY ! = <int> ; final float rotation = this . rotation ; final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; for ( int i = <int> , n = localVertices . length ; i < n ; i + = <int> ) { float x = localVertices [ i ] - originX ; float y = localVertices [ i + <int> ] - originY ; if ( scale ) { x * = scaleX ; y * = scaleY ; } if ( rotation ! = <int> ) { float oldX = x ; x = cos * x - sin * y ; y = sin * oldX + cos * y ; } worldVertices [ i ] = positionX + x + originX ; worldVertices [ i + <int> ] = positionY + y + originY ; } return worldVertices ; } public float getLength ( ) { if ( ! calculateLength ) return length ; calculateLength = false ; length = <int> ; for ( int i = <int> , n = localVertices . length - <int> ; i < n ; i + = <int> ) { float x = localVertices [ i + <int> ] - localVertices [ i ] ; float y = localVertices [ i + <int> ] - localVertices [ i + <int> ] ; length + = ( float ) Math . sqrt ( x * x + y * y ) ; } return length ; } public float getScaledLength ( ) { if ( ! calculateScaledLength ) return scaledLength ; calculateScaledLength = false ; scaledLength = <int> ; for ( int i = <int> , n = localVertices . length - <int> ; i < n ; i + = <int> ) { float x = localVertices [ i + <int> ] * scaleX - localVertices [ i ] * scaleX ; float y = localVertices [ i + <int> ] * scaleY - localVertices [ i + <int> ] * scaleY ; scaledLength + = ( float ) Math . sqrt ( x * x + y * y ) ; } return scaledLength ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public float getOriginX ( ) { return originX ; } public float getOriginY ( ) { return originY ; } public float getRotation ( ) { return rotation ; } public float getScaleX ( ) { return scaleX ; } public float getScaleY ( ) { return scaleY ; } public void setOrigin ( float originX , float originY ) { this . originX = originX ; this . originY = originY ; dirty = true ; } public void setPosition ( float x , float y ) { this . x = x ; this . y = y ; dirty = true ; } public void setVertices ( float [ ] vertices ) { if ( vertices . length < <int> ) throw new IllegalArgumentException ( <str> ) ; this . localVertices = vertices ; dirty = true ; } public void setRotation ( float degrees ) { this . rotation = degrees ; dirty = true ; } public void rotate ( float degrees ) { rotation + = degrees ; dirty = true ; } public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ; dirty = true ; calculateScaledLength = true ; } public void scale ( float amount ) { this . scaleX + = amount ; this . scaleY + = amount ; dirty = true ; calculateScaledLength = true ; } public void calculateLength ( ) { calculateLength = true ; } public void calculateScaledLength ( ) { calculateScaledLength = true ; } public void dirty ( ) { dirty = true ; } public void translate ( float x , float y ) { this . x + = x ; this . y + = y ; dirty = true ; } @Override public boolean contains ( Vector2 point ) { return false ; } @Override public boolean contains ( float x , float y ) { return false ; } } 
