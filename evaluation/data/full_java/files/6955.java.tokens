package org . elasticsearch . rest ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . ContextAndHeaderHolder ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . rest . support . RestUtils ; import java . net . SocketAddress ; import java . util . Map ; import static org . elasticsearch . common . unit . ByteSizeValue . parseBytesSizeValue ; import static org . elasticsearch . common . unit . TimeValue . parseTimeValue ; public abstract class RestRequest extends ContextAndHeaderHolder implements ToXContent . Params { public enum Method { GET , POST , PUT , DELETE , OPTIONS , HEAD } public abstract Method method ( ) ; public abstract String uri ( ) ; public abstract String rawPath ( ) ; public final String path ( ) { return RestUtils . decodeComponent ( rawPath ( ) ) ; } public abstract boolean hasContent ( ) ; public abstract BytesReference content ( ) ; public abstract String header ( String name ) ; public abstract Iterable < Map . Entry < String , String > > headers ( ) ; @Nullable public SocketAddress getRemoteAddress ( ) { return null ; } @Nullable public SocketAddress getLocalAddress ( ) { return null ; } public abstract boolean hasParam ( String key ) ; @Override public abstract String param ( String key ) ; public abstract Map < String , String > params ( ) ; public float paramAsFloat ( String key , float defaultValue ) { String sValue = param ( key ) ; if ( sValue = = null ) { return defaultValue ; } try { return Float . parseFloat ( sValue ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + key + <str> + sValue + <str> , e ) ; } } public int paramAsInt ( String key , int defaultValue ) { String sValue = param ( key ) ; if ( sValue = = null ) { return defaultValue ; } try { return Integer . parseInt ( sValue ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + key + <str> + sValue + <str> , e ) ; } } public long paramAsLong ( String key , long defaultValue ) { String sValue = param ( key ) ; if ( sValue = = null ) { return defaultValue ; } try { return Long . parseLong ( sValue ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + key + <str> + sValue + <str> , e ) ; } } @Override public boolean paramAsBoolean ( String key , boolean defaultValue ) { return Booleans . parseBoolean ( param ( key ) , defaultValue ) ; } @Override public Boolean paramAsBoolean ( String key , Boolean defaultValue ) { return Booleans . parseBoolean ( param ( key ) , defaultValue ) ; } public TimeValue paramAsTime ( String key , TimeValue defaultValue ) { return parseTimeValue ( param ( key ) , defaultValue , key ) ; } public ByteSizeValue paramAsSize ( String key , ByteSizeValue defaultValue ) { return parseBytesSizeValue ( param ( key ) , defaultValue , key ) ; } public String [ ] paramAsStringArray ( String key , String [ ] defaultValue ) { String value = param ( key ) ; if ( value = = null ) { return defaultValue ; } return Strings . splitStringByCommaToArray ( value ) ; } public String [ ] paramAsStringArrayOrEmptyIfAll ( String key ) { String [ ] params = paramAsStringArray ( key , Strings . EMPTY_ARRAY ) ; if ( Strings . isAllOrWildcard ( params ) ) { return Strings . EMPTY_ARRAY ; } return params ; } } 
