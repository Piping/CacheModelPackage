package io . netty . util . concurrent ; import java . util . Collections ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . Set ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup { private final EventExecutor [ ] children ; private final Set < EventExecutor > readonlyChildren ; private final AtomicInteger childIndex = new AtomicInteger ( ) ; private final AtomicInteger terminatedChildren = new AtomicInteger ( ) ; private final Promise < ? > terminationFuture = new DefaultPromise ( GlobalEventExecutor . INSTANCE ) ; private final EventExecutorChooser chooser ; protected MultithreadEventExecutorGroup ( int nThreads , ThreadFactory threadFactory , Object . . . args ) { this ( nThreads , threadFactory = = null ? null : new ThreadPerTaskExecutor ( threadFactory ) , args ) ; } protected MultithreadEventExecutorGroup ( int nThreads , Executor executor , Object . . . args ) { if ( nThreads < = <int> ) { throw new IllegalArgumentException ( String . format ( <str> , nThreads ) ) ; } if ( executor = = null ) { executor = new ThreadPerTaskExecutor ( newDefaultThreadFactory ( ) ) ; } children = new EventExecutor [ nThreads ] ; if ( isPowerOfTwo ( children . length ) ) { chooser = new PowerOfTwoEventExecutorChooser ( ) ; } else { chooser = new GenericEventExecutorChooser ( ) ; } for ( int i = <int> ; i < nThreads ; i + + ) { boolean success = false ; try { children [ i ] = newChild ( executor , args ) ; success = true ; } catch ( Exception e ) { throw new IllegalStateException ( <str> , e ) ; } finally { if ( ! success ) { for ( int j = <int> ; j < i ; j + + ) { children [ j ] . shutdownGracefully ( ) ; } for ( int j = <int> ; j < i ; j + + ) { EventExecutor e = children [ j ] ; try { while ( ! e . isTerminated ( ) ) { e . awaitTermination ( Integer . MAX_VALUE , TimeUnit . SECONDS ) ; } } catch ( InterruptedException interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; break ; } } } } } final FutureListener < Object > terminationListener = new FutureListener < Object > ( ) { @Override public void operationComplete ( Future < Object > future ) throws Exception { if ( terminatedChildren . incrementAndGet ( ) = = children . length ) { terminationFuture . setSuccess ( null ) ; } } } ; for ( EventExecutor e : children ) { e . terminationFuture ( ) . addListener ( terminationListener ) ; } Set < EventExecutor > childrenSet = new LinkedHashSet < EventExecutor > ( children . length ) ; Collections . addAll ( childrenSet , children ) ; readonlyChildren = Collections . unmodifiableSet ( childrenSet ) ; } protected ThreadFactory newDefaultThreadFactory ( ) { return new DefaultThreadFactory ( getClass ( ) ) ; } @Override public EventExecutor next ( ) { return chooser . next ( ) ; } @Override public Iterator < EventExecutor > iterator ( ) { return children ( ) . iterator ( ) ; } public final int executorCount ( ) { return children . length ; } @Override @SuppressWarnings ( <str> ) public final < E extends EventExecutor > Set < E > children ( ) { return ( Set < E > ) readonlyChildren ; } protected abstract EventExecutor newChild ( Executor executor , Object . . . args ) throws Exception ; @Override public Future < ? > shutdownGracefully ( long quietPeriod , long timeout , TimeUnit unit ) { for ( EventExecutor l : children ) { l . shutdownGracefully ( quietPeriod , timeout , unit ) ; } return terminationFuture ( ) ; } @Override public Future < ? > terminationFuture ( ) { return terminationFuture ; } @Override @Deprecated public void shutdown ( ) { for ( EventExecutor l : children ) { l . shutdown ( ) ; } } @Override public boolean isShuttingDown ( ) { for ( EventExecutor l : children ) { if ( ! l . isShuttingDown ( ) ) { return false ; } } return true ; } @Override public boolean isShutdown ( ) { for ( EventExecutor l : children ) { if ( ! l . isShutdown ( ) ) { return false ; } } return true ; } @Override public boolean isTerminated ( ) { for ( EventExecutor l : children ) { if ( ! l . isTerminated ( ) ) { return false ; } } return true ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { long deadline = System . nanoTime ( ) + unit . toNanos ( timeout ) ; loop : for ( EventExecutor l : children ) { for ( ; ; ) { long timeLeft = deadline - System . nanoTime ( ) ; if ( timeLeft < = <int> ) { break loop ; } if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { break ; } } } return isTerminated ( ) ; } private static boolean isPowerOfTwo ( int val ) { return ( val & - val ) = = val ; } private interface EventExecutorChooser { EventExecutor next ( ) ; } private final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser { @Override public EventExecutor next ( ) { return children [ childIndex . getAndIncrement ( ) & children . length - <int> ] ; } } private final class GenericEventExecutorChooser implements EventExecutorChooser { @Override public EventExecutor next ( ) { return children [ Math . abs ( childIndex . getAndIncrement ( ) % children . length ) ] ; } } } 
