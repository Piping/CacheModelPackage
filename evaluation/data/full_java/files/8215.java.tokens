package org . elasticsearch . index . mapper . string ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . index . IndexableFieldType ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . Mapper . BuilderContext ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParseContext . Document ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper . Builder ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . test . VersionUtils ; import org . junit . Before ; import java . util . Arrays ; import java . util . Map ; import static java . util . Collections . emptyMap ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class SimpleStringMappingTests extends ESSingleNodeTestCase { private static Settings DOC_VALUES_SETTINGS = Settings . builder ( ) . put ( FieldDataType . FORMAT_KEY , FieldDataType . DOC_VALUES_FORMAT_VALUE ) . build ( ) ; IndexService indexService ; DocumentMapperParser parser ; @Before public void before ( ) { indexService = createIndex ( <str> ) ; parser = indexService . mapperService ( ) . documentMapperParser ( ) ; } public void testLimit ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; } private void assertDefaultAnalyzedFieldType ( IndexableFieldType fieldType ) { assertThat ( fieldType . omitNorms ( ) , equalTo ( false ) ) ; assertThat ( fieldType . indexOptions ( ) , equalTo ( IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ) ) ; assertThat ( fieldType . storeTermVectors ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; } private void assertEquals ( IndexableFieldType ft1 , IndexableFieldType ft2 ) { assertEquals ( ft1 . tokenized ( ) , ft2 . tokenized ( ) ) ; assertEquals ( ft1 . omitNorms ( ) , ft2 . omitNorms ( ) ) ; assertEquals ( ft1 . indexOptions ( ) , ft2 . indexOptions ( ) ) ; assertEquals ( ft1 . storeTermVectors ( ) , ft2 . storeTermVectors ( ) ) ; assertEquals ( ft1 . docValuesType ( ) , ft2 . docValuesType ( ) ) ; } private void assertParseIdemPotent ( IndexableFieldType expected , DocumentMapper mapper ) throws Exception { String mapping = mapper . toXContent ( XContentFactory . jsonBuilder ( ) . startObject ( ) , new ToXContent . MapParams ( emptyMap ( ) ) ) . endObject ( ) . string ( ) ; mapper = parser . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertEquals ( expected , doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ) ; } public void testDefaultsForAnalyzed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; IndexableFieldType fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertDefaultAnalyzedFieldType ( fieldType ) ; assertParseIdemPotent ( fieldType , defaultMapper ) ; } public void testDefaultsForNotAnalyzed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; IndexableFieldType fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertThat ( fieldType . omitNorms ( ) , equalTo ( true ) ) ; assertThat ( fieldType . indexOptions ( ) , equalTo ( IndexOptions . DOCS ) ) ; assertThat ( fieldType . storeTermVectors ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertParseIdemPotent ( fieldType , defaultMapper ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; defaultMapper = parser . parse ( mapping ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertThat ( fieldType . omitNorms ( ) , equalTo ( false ) ) ; assertThat ( fieldType . indexOptions ( ) , equalTo ( IndexOptions . DOCS_AND_FREQS ) ) ; assertThat ( fieldType . storeTermVectors ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( fieldType . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertParseIdemPotent ( fieldType , defaultMapper ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; defaultMapper = parser . parse ( mapping ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertThat ( fieldType . omitNorms ( ) , equalTo ( false ) ) ; assertParseIdemPotent ( fieldType , defaultMapper ) ; } public void testSearchQuoteAnalyzerSerialization ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = parser . parse ( mapping ) ; for ( String fieldName : Arrays . asList ( <str> , <str> , <str> , <str> ) ) { Map < String , Object > serializedMap = getSerializedMap ( fieldName , mapper ) ; assertFalse ( fieldName , serializedMap . containsKey ( <str> ) ) ; } mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; mapper = parser . parse ( mapping ) ; for ( String fieldName : Arrays . asList ( <str> , <str> ) ) { Map < String , Object > serializedMap = getSerializedMap ( fieldName , mapper ) ; assertEquals ( serializedMap . get ( <str> ) , <str> ) ; } } private Map < String , Object > getSerializedMap ( String fieldName , DocumentMapper mapper ) throws Exception { FieldMapper fieldMapper = mapper . mappers ( ) . smartNameFieldMapper ( fieldName ) ; XContentBuilder builder = JsonXContent . contentBuilder ( ) . startObject ( ) ; fieldMapper . toXContent ( builder , ToXContent . EMPTY_PARAMS ) . endObject ( ) ; builder . close ( ) ; Map < String , Object > fieldMap ; try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( builder . bytes ( ) ) ) { fieldMap = parser . map ( ) ; } @SuppressWarnings ( <str> ) Map < String , Object > result = ( Map < String , Object > ) fieldMap . get ( fieldName ) ; return result ; } public void testTermVectors ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( false ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectors ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( true ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( true ) ) ; } public void testDocValuesFielddata ( ) throws Exception { IndexService indexService = createIndex ( <str> ) ; DocumentMapperParser parser = indexService . mapperService ( ) . documentMapperParser ( ) ; final BuilderContext ctx = new BuilderContext ( indexService . getIndexSettings ( ) . getSettings ( ) , new ContentPath ( <int> ) ) ; assertFalse ( new Builder ( <str> ) . index ( false ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertTrue ( new Builder ( <str> ) . index ( false ) . fieldDataSettings ( DOC_VALUES_SETTINGS ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertTrue ( new Builder ( <str> ) . index ( false ) . docValues ( true ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument parsedDoc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; final Document doc = parsedDoc . rootDoc ( ) ; assertEquals ( DocValuesType . NONE , docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . SORTED_SET , docValuesType ( doc , <str> ) ) ; } public void testDocValues ( ) throws Exception { final BuilderContext ctx = new BuilderContext ( indexService . getIndexSettings ( ) . getSettings ( ) , new ContentPath ( <int> ) ) ; try { new StringFieldMapper . Builder ( <str> ) . docValues ( true ) . build ( ctx ) ; fail ( ) ; } catch ( Exception e ) { } assertFalse ( new Builder ( <str> ) . index ( false ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertTrue ( new Builder ( <str> ) . index ( true ) . tokenized ( false ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertFalse ( new Builder ( <str> ) . index ( true ) . tokenized ( true ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertFalse ( new Builder ( <str> ) . index ( false ) . tokenized ( false ) . docValues ( false ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; assertTrue ( new Builder ( <str> ) . index ( false ) . docValues ( true ) . build ( ctx ) . fieldType ( ) . hasDocValues ( ) ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; ParsedDocument parsedDoc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; final Document doc = parsedDoc . rootDoc ( ) ; assertEquals ( DocValuesType . NONE , docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . SORTED_SET , docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . NONE , docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . NONE , docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . SORTED_SET , docValuesType ( doc , <str> ) ) ; } public static DocValuesType docValuesType ( Document document , String fieldName ) { for ( IndexableField field : document . getFields ( fieldName ) ) { if ( field . fieldType ( ) . docValuesType ( ) ! = DocValuesType . NONE ) { return field . fieldType ( ) . docValuesType ( ) ; } } return DocValuesType . NONE ; } public void testDisableNorms ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = indexService . mapperService ( ) . merge ( <str> , new CompressedXContent ( mapping ) , true , false ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; IndexableFieldType fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertEquals ( false , fieldType . omitNorms ( ) ) ; String updatedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; MergeResult mergeResult = defaultMapper . merge ( parser . parse ( updatedMapping ) . mapping ( ) , false , false ) ; assertFalse ( Arrays . toString ( mergeResult . buildConflicts ( ) ) , mergeResult . hasConflicts ( ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fieldType = doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) ; assertEquals ( true , fieldType . omitNorms ( ) ) ; updatedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { defaultMapper . merge ( parser . parse ( updatedMapping ) . mapping ( ) , true , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testPositionOffsetGapDeprecation ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { parser . parse ( mapping ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertEquals ( e . getMessage ( ) , <str> ) ; } } public void testBackwardCompatible ( ) throws Exception { Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . V_1_7_1 ) ) . build ( ) ; DocumentMapperParser parser = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; parser . parse ( mapping ) ; assertThat ( parser . parse ( mapping ) . mapping ( ) . toString ( ) , containsString ( <str> ) ) ; } } 
