package org . elasticsearch . transport . netty ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . transport . TransportModule ; import java . net . Inet4Address ; import java . net . Inet6Address ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . not ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) public class NettyTransportPublishAddressIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( TransportModule . TRANSPORT_TYPE_KEY , <str> ) . put ( <str> , <str> ) . build ( ) ; } public void testDifferentPorts ( ) throws Exception { if ( ! NetworkUtils . SUPPORTS_V6 ) { return ; } logger . info ( <str> ) ; Settings ipv4Settings = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; String ipv4OnlyNode = internalCluster ( ) . startNode ( ipv4Settings ) ; logger . info ( <str> ) ; Settings bothSettings = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; internalCluster ( ) . startNode ( bothSettings ) ; logger . info ( <str> ) ; ensureStableCluster ( <int> ) ; logger . info ( <str> ) ; NodesInfoResponse nodesInfoResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . get ( ) ; for ( NodeInfo nodeInfo : nodesInfoResponse ) { BoundTransportAddress boundTransportAddress = nodeInfo . getTransport ( ) . getAddress ( ) ; if ( nodeInfo . getNode ( ) . getName ( ) . equals ( ipv4OnlyNode ) ) { assertThat ( boundTransportAddress . boundAddresses ( ) . length , equalTo ( <int> ) ) ; assertThat ( boundTransportAddress . boundAddresses ( ) [ <int> ] . getPort ( ) , equalTo ( boundTransportAddress . publishAddress ( ) . getPort ( ) ) ) ; } else { assertThat ( boundTransportAddress . boundAddresses ( ) . length , greaterThan ( <int> ) ) ; for ( TransportAddress boundAddress : boundTransportAddress . boundAddresses ( ) ) { assertThat ( boundAddress , instanceOf ( InetSocketTransportAddress . class ) ) ; InetSocketTransportAddress inetBoundAddress = ( InetSocketTransportAddress ) boundAddress ; if ( inetBoundAddress . address ( ) . getAddress ( ) instanceof Inet4Address ) { assertThat ( inetBoundAddress . getPort ( ) , equalTo ( boundTransportAddress . publishAddress ( ) . getPort ( ) ) ) ; } } } } } } 
