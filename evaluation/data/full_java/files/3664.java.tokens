package org . eclipse . debug . internal . core ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Vector ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IExpressionListener ; import org . eclipse . debug . core . IExpressionManager ; import org . eclipse . debug . core . IExpressionsListener ; import org . eclipse . debug . core . model . IExpression ; import org . eclipse . debug . core . model . IWatchExpression ; import org . eclipse . debug . core . model . IWatchExpressionDelegate ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import com . ibm . icu . text . MessageFormat ; public class ExpressionManager extends PlatformObject implements IExpressionManager { private Vector < IExpression > fExpressions = null ; private ListenerList fListeners = null ; private ListenerList fExpressionsListeners = null ; private Map < String , IConfigurationElement > fWatchExpressionDelegates = new HashMap < String , IConfigurationElement > ( ) ; private static final int ADDED = <int> ; private static final int CHANGED = <int> ; private static final int REMOVED = <int> ; private static final int INSERTED = <int> ; private static final int MOVED = <int> ; private static final String PREF_WATCH_EXPRESSIONS = <str> ; private static final String WATCH_EXPRESSIONS_TAG = <str> ; private static final String EXPRESSION_TAG = <str> ; private static final String TEXT_TAG = <str> ; private static final String ENABLED_TAG = <str> ; private static final String TRUE_VALUE = <str> ; private static final String FALSE_VALUE = <str> ; public ExpressionManager ( ) { loadPersistedExpressions ( ) ; loadWatchExpressionDelegates ( ) ; } private void loadWatchExpressionDelegates ( ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugPlugin . getUniqueIdentifier ( ) , <str> ) ; IConfigurationElement [ ] configurationElements = extensionPoint . getConfigurationElements ( ) ; for ( int i = <int> ; i < configurationElements . length ; i + + ) { IConfigurationElement element = configurationElements [ i ] ; if ( element . getName ( ) . equals ( <str> ) ) { String debugModel = element . getAttribute ( <str> ) ; if ( debugModel = = null | | debugModel . length ( ) = = <int> ) { continue ; } fWatchExpressionDelegates . put ( debugModel , element ) ; } } } @Override public IWatchExpressionDelegate newWatchExpressionDelegate ( String debugModel ) { try { IConfigurationElement element = fWatchExpressionDelegates . get ( debugModel ) ; if ( element ! = null ) { return ( IWatchExpressionDelegate ) element . createExecutableExtension ( IConfigurationElementConstants . DELEGATE_CLASS ) ; } return null ; } catch ( CoreException e ) { DebugPlugin . log ( e ) ; return null ; } } @Override public boolean hasWatchExpressionDelegate ( String id ) { IConfigurationElement element = fWatchExpressionDelegates . get ( id ) ; return element ! = null ; } private void loadPersistedExpressions ( ) { String expressionsString = Platform . getPreferencesService ( ) . getString ( DebugPlugin . getUniqueIdentifier ( ) , PREF_WATCH_EXPRESSIONS , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; if ( expressionsString . length ( ) = = <int> ) { return ; } Element root ; try { root = DebugPlugin . parseDocument ( expressionsString ) ; } catch ( CoreException e ) { DebugPlugin . logMessage ( <str> , e ) ; return ; } if ( ! root . getNodeName ( ) . equals ( WATCH_EXPRESSIONS_TAG ) ) { DebugPlugin . logMessage ( <str> , null ) ; return ; } NodeList list = root . getChildNodes ( ) ; for ( int i = <int> , numItems = list . getLength ( ) ; i < numItems ; i + + ) { Node node = list . item ( i ) ; if ( node . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element element = ( Element ) node ; if ( ! element . getNodeName ( ) . equals ( EXPRESSION_TAG ) ) { DebugPlugin . logMessage ( MessageFormat . format ( <str> , new Object [ ] { node . getNodeName ( ) } ) , null ) ; continue ; } String expressionText = element . getAttribute ( TEXT_TAG ) ; if ( expressionText . length ( ) > <int> ) { boolean enabled = TRUE_VALUE . equals ( element . getAttribute ( ENABLED_TAG ) ) ; IWatchExpression expression = newWatchExpression ( expressionText , enabled ) ; if ( fExpressions = = null ) { fExpressions = new Vector < IExpression > ( list . getLength ( ) ) ; } fExpressions . add ( expression ) ; } else { DebugPlugin . logMessage ( <str> , null ) ; } } } } private IWatchExpression newWatchExpression ( String expressionText , boolean enabled ) { return new WatchExpression ( expressionText , enabled ) ; } @Override public IWatchExpression newWatchExpression ( String expressionText ) { return new WatchExpression ( expressionText ) ; } public void storeWatchExpressions ( ) { String expressionString = IInternalDebugCoreConstants . EMPTY_STRING ; try { expressionString = getWatchExpressionsAsXML ( ) ; } catch ( IOException e ) { DebugPlugin . log ( e ) ; } catch ( ParserConfigurationException e ) { DebugPlugin . log ( e ) ; } catch ( TransformerException e ) { DebugPlugin . log ( e ) ; } Preferences . setString ( DebugPlugin . getUniqueIdentifier ( ) , PREF_WATCH_EXPRESSIONS , expressionString , null ) ; } private String getWatchExpressionsAsXML ( ) throws IOException , ParserConfigurationException , TransformerException { IExpression [ ] expressions = getExpressions ( ) ; Document document = LaunchManager . getDocument ( ) ; Element rootElement = document . createElement ( WATCH_EXPRESSIONS_TAG ) ; document . appendChild ( rootElement ) ; for ( int i = <int> ; i < expressions . length ; i + + ) { IExpression expression = expressions [ i ] ; if ( expression instanceof IWatchExpression ) { Element element = document . createElement ( EXPRESSION_TAG ) ; element . setAttribute ( TEXT_TAG , expression . getExpressionText ( ) ) ; element . setAttribute ( ENABLED_TAG , ( ( IWatchExpression ) expression ) . isEnabled ( ) ? TRUE_VALUE : FALSE_VALUE ) ; rootElement . appendChild ( element ) ; } } return LaunchManager . serializeDocument ( document ) ; } @Override public void addExpression ( IExpression expression ) { addExpressions ( new IExpression [ ] { expression } ) ; } @Override public void addExpressions ( IExpression [ ] expressions ) { List < IExpression > added = doAdd ( expressions ) ; if ( ! added . isEmpty ( ) ) { fireUpdate ( added . toArray ( new IExpression [ added . size ( ) ] ) , ADDED ) ; } } private List < IExpression > doAdd ( IExpression [ ] expressions ) { List < IExpression > added = new ArrayList < IExpression > ( expressions . length ) ; synchronized ( this ) { if ( fExpressions = = null ) { fExpressions = new Vector < IExpression > ( expressions . length ) ; } for ( int i = <int> ; i < expressions . length ; i + + ) { IExpression expression = expressions [ i ] ; if ( fExpressions . indexOf ( expression ) = = - <int> ) { added . add ( expression ) ; fExpressions . add ( expression ) ; } } } return added ; } @Override public synchronized IExpression [ ] getExpressions ( ) { if ( fExpressions = = null ) { return new IExpression [ <int> ] ; } IExpression [ ] temp = new IExpression [ fExpressions . size ( ) ] ; fExpressions . copyInto ( temp ) ; return temp ; } @Override public synchronized IExpression [ ] getExpressions ( String modelIdentifier ) { if ( fExpressions = = null ) { return new IExpression [ <int> ] ; } ArrayList < IExpression > temp = new ArrayList < IExpression > ( fExpressions . size ( ) ) ; for ( IExpression expression : fExpressions ) { String id = expression . getModelIdentifier ( ) ; if ( id ! = null & & id . equals ( modelIdentifier ) ) { temp . add ( expression ) ; } } return temp . toArray ( new IExpression [ temp . size ( ) ] ) ; } public void insertExpressions ( IExpression [ ] expressions , IExpression insertionLocation , boolean insertBefore ) { List < IExpression > added = null ; List < IExpression > inserted = null ; int insertionIndex = - <int> ; synchronized ( this ) { if ( fExpressions = = null | | ( ( insertionIndex = fExpressions . indexOf ( insertionLocation ) ) < <int> ) ) { added = doAdd ( expressions ) ; } else { if ( ! insertBefore ) { insertionIndex + + ; } inserted = new ArrayList < IExpression > ( expressions . length ) ; for ( int i = <int> ; i < expressions . length ; i + + ) { IExpression expression = expressions [ i ] ; if ( fExpressions . indexOf ( expression ) = = - <int> ) { fExpressions . add ( insertionIndex + inserted . size ( ) , expression ) ; inserted . add ( expression ) ; } } } } if ( added ! = null ) { if ( ! added . isEmpty ( ) ) { fireUpdate ( added . toArray ( new IExpression [ added . size ( ) ] ) , ADDED ) ; } return ; } if ( inserted ! = null ) { if ( ! inserted . isEmpty ( ) ) { fireUpdate ( inserted . toArray ( new IExpression [ inserted . size ( ) ] ) , INSERTED , insertionIndex ) ; } } } public void moveExpressions ( IExpression [ ] expressions , IExpression insertionLocation , boolean insertBefore ) { List < IExpression > movedExpressions = new ArrayList < IExpression > ( expressions . length ) ; int insertionIndex = - <int> ; IExpression [ ] movedExpressionsArray = null ; synchronized ( this ) { if ( fExpressions = = null ) { return ; } insertionIndex = fExpressions . indexOf ( insertionLocation ) ; if ( insertionIndex < <int> ) { return ; } if ( ! insertBefore ) { insertionIndex + + ; } for ( int i = <int> ; i < expressions . length ; i + + ) { int removeIndex = fExpressions . indexOf ( expressions [ i ] ) ; if ( removeIndex > = <int> ) { movedExpressions . add ( expressions [ i ] ) ; if ( removeIndex < insertionIndex ) { insertionIndex - - ; } fExpressions . remove ( removeIndex ) ; } } movedExpressionsArray = movedExpressions . toArray ( new IExpression [ movedExpressions . size ( ) ] ) ; for ( int i = <int> ; i < movedExpressionsArray . length ; i + + ) { fExpressions . add ( insertionIndex + i , movedExpressionsArray [ i ] ) ; } } if ( ! movedExpressions . isEmpty ( ) ) { fireUpdate ( movedExpressionsArray , MOVED , insertionIndex ) ; } } @Override public void removeExpression ( IExpression expression ) { removeExpressions ( new IExpression [ ] { expression } ) ; } @Override public void removeExpressions ( IExpression [ ] expressions ) { List < IExpression > removed = new ArrayList < IExpression > ( expressions . length ) ; synchronized ( this ) { if ( fExpressions = = null ) { return ; } for ( int i = <int> ; i < expressions . length ; i + + ) { IExpression expression = expressions [ i ] ; if ( fExpressions . remove ( expression ) ) { removed . add ( expression ) ; } } } if ( ! removed . isEmpty ( ) ) { for ( IExpression expression : removed ) { expression . dispose ( ) ; } fireUpdate ( removed . toArray ( new IExpression [ removed . size ( ) ] ) , REMOVED ) ; } } @Override public void addExpressionListener ( IExpressionListener listener ) { if ( fListeners = = null ) { fListeners = new ListenerList ( ) ; } fListeners . add ( listener ) ; } @Override public void removeExpressionListener ( IExpressionListener listener ) { if ( fListeners = = null ) { return ; } fListeners . remove ( listener ) ; } protected void watchExpressionChanged ( IWatchExpression expression ) { boolean notify = false ; synchronized ( this ) { if ( fExpressions ! = null & & fExpressions . contains ( expression ) ) { notify = true ; } } if ( notify ) { fireUpdate ( new IExpression [ ] { expression } , CHANGED ) ; } } private void fireUpdate ( IExpression [ ] expressions , int update ) { fireUpdate ( expressions , update , - <int> ) ; } private void fireUpdate ( IExpression [ ] expressions , int update , int index ) { getExpressionNotifier ( ) . notify ( expressions , update ) ; getExpressionsNotifier ( ) . notify ( expressions , update , index ) ; } @Override public synchronized boolean hasExpressions ( ) { return fExpressions ! = null & & ! fExpressions . isEmpty ( ) ; } @Override public void addExpressionListener ( IExpressionsListener listener ) { if ( fExpressionsListeners = = null ) { fExpressionsListeners = new ListenerList ( ) ; } fExpressionsListeners . add ( listener ) ; } @Override public void removeExpressionListener ( IExpressionsListener listener ) { if ( fExpressionsListeners = = null ) { return ; } fExpressionsListeners . remove ( listener ) ; } private ExpressionNotifier getExpressionNotifier ( ) { return new ExpressionNotifier ( ) ; } class ExpressionNotifier implements ISafeRunnable { private IExpressionListener fListener ; private int fType ; private IExpression fExpression ; @Override public void handleException ( Throwable exception ) { IStatus status = new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugPlugin . INTERNAL_ERROR , <str> , exception ) ; DebugPlugin . log ( status ) ; } @Override public void run ( ) throws Exception { switch ( fType ) { case ADDED : case INSERTED : fListener . expressionAdded ( fExpression ) ; break ; case REMOVED : fListener . expressionRemoved ( fExpression ) ; break ; case CHANGED : fListener . expressionChanged ( fExpression ) ; break ; default : break ; } } public void notify ( IExpression [ ] expressions , int update ) { if ( fListeners ! = null ) { fType = update ; Object [ ] copiedListeners = fListeners . getListeners ( ) ; for ( int i = <int> ; i < copiedListeners . length ; i + + ) { fListener = ( IExpressionListener ) copiedListeners [ i ] ; for ( int j = <int> ; j < expressions . length ; j + + ) { fExpression = expressions [ j ] ; SafeRunner . run ( this ) ; } } } fListener = null ; fExpression = null ; } } private ExpressionsNotifier getExpressionsNotifier ( ) { return new ExpressionsNotifier ( ) ; } class ExpressionsNotifier implements ISafeRunnable { private IExpressionsListener fListener ; private int fType ; private int fIndex ; private IExpression [ ] fNotifierExpressions ; @Override public void handleException ( Throwable exception ) { IStatus status = new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugPlugin . INTERNAL_ERROR , <str> , exception ) ; DebugPlugin . log ( status ) ; } @Override public void run ( ) throws Exception { switch ( fType ) { case MOVED : if ( fIndex > = <int> & & fListener instanceof IExpressionsListener2 ) { ( ( IExpressionsListener2 ) fListener ) . expressionsMoved ( fNotifierExpressions , fIndex ) ; } break ; case INSERTED : if ( fIndex > = <int> & & fListener instanceof IExpressionsListener2 ) { ( ( IExpressionsListener2 ) fListener ) . expressionsInserted ( fNotifierExpressions , fIndex ) ; } else { fListener . expressionsAdded ( fNotifierExpressions ) ; } break ; case ADDED : fListener . expressionsAdded ( fNotifierExpressions ) ; break ; case REMOVED : fListener . expressionsRemoved ( fNotifierExpressions ) ; break ; case CHANGED : fListener . expressionsChanged ( fNotifierExpressions ) ; break ; default : break ; } } public void notify ( IExpression [ ] expressions , int update , int index ) { if ( fExpressionsListeners ! = null ) { fNotifierExpressions = expressions ; fType = update ; fIndex = index ; Object [ ] copiedListeners = fExpressionsListeners . getListeners ( ) ; for ( int i = <int> ; i < copiedListeners . length ; i + + ) { fListener = ( IExpressionsListener ) copiedListeners [ i ] ; SafeRunner . run ( this ) ; } } fNotifierExpressions = null ; fListener = null ; } } } 
