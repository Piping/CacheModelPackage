package org . elasticsearch . common . lucene . uid ; import java . io . IOException ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . NumericDocValues ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Numbers ; import org . elasticsearch . common . lucene . uid . Versions . DocIdAndVersion ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . mapper . internal . VersionFieldMapper ; final class PerThreadIDAndVersionLookup { private final TermsEnum termsEnum ; private final NumericDocValues versions ; private final boolean hasPayloads ; private PostingsEnum docsEnum ; private PostingsEnum posEnum ; public PerThreadIDAndVersionLookup ( LeafReader reader ) throws IOException { TermsEnum termsEnum = null ; NumericDocValues versions = null ; boolean hasPayloads = false ; Fields fields = reader . fields ( ) ; if ( fields ! = null ) { Terms terms = fields . terms ( UidFieldMapper . NAME ) ; if ( terms ! = null ) { hasPayloads = terms . hasPayloads ( ) ; termsEnum = terms . iterator ( ) ; assert termsEnum ! = null ; versions = reader . getNumericDocValues ( VersionFieldMapper . NAME ) ; } } this . versions = versions ; this . termsEnum = termsEnum ; this . hasPayloads = hasPayloads ; } public DocIdAndVersion lookup ( BytesRef id , Bits liveDocs , LeafReaderContext context ) throws IOException { if ( termsEnum . seekExact ( id ) ) { if ( versions ! = null | | hasPayloads = = false ) { docsEnum = termsEnum . postings ( docsEnum , <int> ) ; int docID = DocIdSetIterator . NO_MORE_DOCS ; for ( int d = docsEnum . nextDoc ( ) ; d ! = DocIdSetIterator . NO_MORE_DOCS ; d = docsEnum . nextDoc ( ) ) { if ( liveDocs ! = null & & liveDocs . get ( d ) = = false ) { continue ; } docID = d ; } if ( docID ! = DocIdSetIterator . NO_MORE_DOCS ) { if ( versions ! = null ) { return new DocIdAndVersion ( docID , versions . get ( docID ) , context ) ; } else { return new DocIdAndVersion ( docID , Versions . NOT_SET , context ) ; } } } posEnum = termsEnum . postings ( posEnum , PostingsEnum . PAYLOADS ) ; assert posEnum ! = null ; for ( int d = posEnum . nextDoc ( ) ; d ! = DocIdSetIterator . NO_MORE_DOCS ; d = posEnum . nextDoc ( ) ) { if ( liveDocs ! = null & & liveDocs . get ( d ) = = false ) { continue ; } posEnum . nextPosition ( ) ; final BytesRef payload = posEnum . getPayload ( ) ; if ( payload ! = null & & payload . length = = <int> ) { return new DocIdAndVersion ( d , Numbers . bytesToLong ( payload ) , context ) ; } } } return null ; } } 
