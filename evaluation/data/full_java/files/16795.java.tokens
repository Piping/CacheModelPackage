package com . badlogic . gdx . backends . lwjgl . audio ; import java . nio . FloatBuffer ; import org . lwjgl . BufferUtils ; import org . lwjgl . LWJGLException ; import org . lwjgl . openal . AL ; import org . lwjgl . openal . AL10 ; import com . badlogic . gdx . Audio ; import com . badlogic . gdx . audio . AudioDevice ; import com . badlogic . gdx . audio . AudioRecorder ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . IntMap ; import com . badlogic . gdx . utils . LongMap ; import com . badlogic . gdx . utils . ObjectMap ; import static org . lwjgl . openal . AL10 . * ; public class OpenALAudio implements Audio { private final int deviceBufferSize ; private final int deviceBufferCount ; private IntArray idleSources , allSources ; private LongMap < Integer > soundIdToSource ; private IntMap < Long > sourceToSoundId ; private long nextSoundId = <int> ; private ObjectMap < String , Class < ? extends OpenALSound > > extensionToSoundClass = new ObjectMap ( ) ; private ObjectMap < String , Class < ? extends OpenALMusic > > extensionToMusicClass = new ObjectMap ( ) ; private OpenALSound [ ] recentSounds ; private int mostRecetSound = - <int> ; Array < OpenALMusic > music = new Array ( false , <int> , OpenALMusic . class ) ; boolean noDevice = false ; public OpenALAudio ( ) { this ( <int> , <int> , <int> ) ; } public OpenALAudio ( int simultaneousSources , int deviceBufferCount , int deviceBufferSize ) { this . deviceBufferSize = deviceBufferSize ; this . deviceBufferCount = deviceBufferCount ; registerSound ( <str> , Ogg . Sound . class ) ; registerMusic ( <str> , Ogg . Music . class ) ; registerSound ( <str> , Wav . Sound . class ) ; registerMusic ( <str> , Wav . Music . class ) ; registerSound ( <str> , Mp3 . Sound . class ) ; registerMusic ( <str> , Mp3 . Music . class ) ; try { AL . create ( ) ; } catch ( LWJGLException ex ) { noDevice = true ; ex . printStackTrace ( ) ; return ; } allSources = new IntArray ( false , simultaneousSources ) ; for ( int i = <int> ; i < simultaneousSources ; i + + ) { int sourceID = alGenSources ( ) ; if ( alGetError ( ) ! = AL_NO_ERROR ) break ; allSources . add ( sourceID ) ; } idleSources = new IntArray ( allSources ) ; soundIdToSource = new LongMap < Integer > ( ) ; sourceToSoundId = new IntMap < Long > ( ) ; FloatBuffer orientation = ( FloatBuffer ) BufferUtils . createFloatBuffer ( <int> ) . put ( new float [ ] { <float> , <float> , - <float> , <float> , <float> , <float> } ) . flip ( ) ; alListener ( AL_ORIENTATION , orientation ) ; FloatBuffer velocity = ( FloatBuffer ) BufferUtils . createFloatBuffer ( <int> ) . put ( new float [ ] { <float> , <float> , <float> } ) . flip ( ) ; alListener ( AL_VELOCITY , velocity ) ; FloatBuffer position = ( FloatBuffer ) BufferUtils . createFloatBuffer ( <int> ) . put ( new float [ ] { <float> , <float> , <float> } ) . flip ( ) ; alListener ( AL_POSITION , position ) ; recentSounds = new OpenALSound [ simultaneousSources ] ; } public void registerSound ( String extension , Class < ? extends OpenALSound > soundClass ) { if ( extension = = null ) throw new IllegalArgumentException ( <str> ) ; if ( soundClass = = null ) throw new IllegalArgumentException ( <str> ) ; extensionToSoundClass . put ( extension , soundClass ) ; } public void registerMusic ( String extension , Class < ? extends OpenALMusic > musicClass ) { if ( extension = = null ) throw new IllegalArgumentException ( <str> ) ; if ( musicClass = = null ) throw new IllegalArgumentException ( <str> ) ; extensionToMusicClass . put ( extension , musicClass ) ; } public OpenALSound newSound ( FileHandle file ) { if ( file = = null ) throw new IllegalArgumentException ( <str> ) ; Class < ? extends OpenALSound > soundClass = extensionToSoundClass . get ( file . extension ( ) . toLowerCase ( ) ) ; if ( soundClass = = null ) throw new GdxRuntimeException ( <str> + file ) ; try { return soundClass . getConstructor ( new Class [ ] { OpenALAudio . class , FileHandle . class } ) . newInstance ( this , file ) ; } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> + soundClass . getName ( ) + <str> + file , ex ) ; } } public OpenALMusic newMusic ( FileHandle file ) { if ( file = = null ) throw new IllegalArgumentException ( <str> ) ; Class < ? extends OpenALMusic > musicClass = extensionToMusicClass . get ( file . extension ( ) . toLowerCase ( ) ) ; if ( musicClass = = null ) throw new GdxRuntimeException ( <str> + file ) ; try { return musicClass . getConstructor ( new Class [ ] { OpenALAudio . class , FileHandle . class } ) . newInstance ( this , file ) ; } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> + musicClass . getName ( ) + <str> + file , ex ) ; } } int obtainSource ( boolean isMusic ) { if ( noDevice ) return <int> ; for ( int i = <int> , n = idleSources . size ; i < n ; i + + ) { int sourceId = idleSources . get ( i ) ; int state = alGetSourcei ( sourceId , AL_SOURCE_STATE ) ; if ( state ! = AL_PLAYING & & state ! = AL_PAUSED ) { if ( isMusic ) { idleSources . removeIndex ( i ) ; } else { if ( sourceToSoundId . containsKey ( sourceId ) ) { long soundId = sourceToSoundId . get ( sourceId ) ; sourceToSoundId . remove ( sourceId ) ; soundIdToSource . remove ( soundId ) ; } long soundId = nextSoundId + + ; sourceToSoundId . put ( sourceId , soundId ) ; soundIdToSource . put ( soundId , sourceId ) ; } alSourceStop ( sourceId ) ; alSourcei ( sourceId , AL_BUFFER , <int> ) ; AL10 . alSourcef ( sourceId , AL10 . AL_GAIN , <int> ) ; AL10 . alSourcef ( sourceId , AL10 . AL_PITCH , <int> ) ; AL10 . alSource3f ( sourceId , AL10 . AL_POSITION , <int> , <int> , <float> ) ; return sourceId ; } } return - <int> ; } void freeSource ( int sourceID ) { if ( noDevice ) return ; alSourceStop ( sourceID ) ; alSourcei ( sourceID , AL_BUFFER , <int> ) ; if ( sourceToSoundId . containsKey ( sourceID ) ) { long soundId = sourceToSoundId . remove ( sourceID ) ; soundIdToSource . remove ( soundId ) ; } idleSources . add ( sourceID ) ; } void freeBuffer ( int bufferID ) { if ( noDevice ) return ; for ( int i = <int> , n = idleSources . size ; i < n ; i + + ) { int sourceID = idleSources . get ( i ) ; if ( alGetSourcei ( sourceID , AL_BUFFER ) = = bufferID ) { if ( sourceToSoundId . containsKey ( sourceID ) ) { long soundId = sourceToSoundId . remove ( sourceID ) ; soundIdToSource . remove ( soundId ) ; } alSourceStop ( sourceID ) ; alSourcei ( sourceID , AL_BUFFER , <int> ) ; } } } void stopSourcesWithBuffer ( int bufferID ) { if ( noDevice ) return ; for ( int i = <int> , n = idleSources . size ; i < n ; i + + ) { int sourceID = idleSources . get ( i ) ; if ( alGetSourcei ( sourceID , AL_BUFFER ) = = bufferID ) { if ( sourceToSoundId . containsKey ( sourceID ) ) { long soundId = sourceToSoundId . remove ( sourceID ) ; soundIdToSource . remove ( soundId ) ; } alSourceStop ( sourceID ) ; } } } void pauseSourcesWithBuffer ( int bufferID ) { if ( noDevice ) return ; for ( int i = <int> , n = idleSources . size ; i < n ; i + + ) { int sourceID = idleSources . get ( i ) ; if ( alGetSourcei ( sourceID , AL_BUFFER ) = = bufferID ) alSourcePause ( sourceID ) ; } } void resumeSourcesWithBuffer ( int bufferID ) { if ( noDevice ) return ; for ( int i = <int> , n = idleSources . size ; i < n ; i + + ) { int sourceID = idleSources . get ( i ) ; if ( alGetSourcei ( sourceID , AL_BUFFER ) = = bufferID ) { if ( alGetSourcei ( sourceID , AL_SOURCE_STATE ) = = AL_PAUSED ) alSourcePlay ( sourceID ) ; } } } public void update ( ) { if ( noDevice ) return ; for ( int i = <int> ; i < music . size ; i + + ) music . items [ i ] . update ( ) ; } public long getSoundId ( int sourceId ) { if ( ! sourceToSoundId . containsKey ( sourceId ) ) return - <int> ; return sourceToSoundId . get ( sourceId ) ; } public void stopSound ( long soundId ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; alSourceStop ( sourceId ) ; } public void pauseSound ( long soundId ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; alSourcePause ( sourceId ) ; } public void resumeSound ( long soundId ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; if ( alGetSourcei ( sourceId , AL_SOURCE_STATE ) = = AL_PAUSED ) alSourcePlay ( sourceId ) ; } public void setSoundGain ( long soundId , float volume ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; AL10 . alSourcef ( sourceId , AL10 . AL_GAIN , volume ) ; } public void setSoundLooping ( long soundId , boolean looping ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; alSourcei ( sourceId , AL10 . AL_LOOPING , looping ? AL10 . AL_TRUE : AL10 . AL_FALSE ) ; } public void setSoundPitch ( long soundId , float pitch ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; AL10 . alSourcef ( sourceId , AL10 . AL_PITCH , pitch ) ; } public void setSoundPan ( long soundId , float pan , float volume ) { if ( ! soundIdToSource . containsKey ( soundId ) ) return ; int sourceId = soundIdToSource . get ( soundId ) ; AL10 . alSource3f ( sourceId , AL10 . AL_POSITION , MathUtils . cos ( ( pan - <int> ) * MathUtils . PI / <int> ) , <int> , MathUtils . sin ( ( pan + <int> ) * MathUtils . PI / <int> ) ) ; AL10 . alSourcef ( sourceId , AL10 . AL_GAIN , volume ) ; } public void dispose ( ) { if ( noDevice ) return ; for ( int i = <int> , n = allSources . size ; i < n ; i + + ) { int sourceID = allSources . get ( i ) ; int state = alGetSourcei ( sourceID , AL_SOURCE_STATE ) ; if ( state ! = AL_STOPPED ) alSourceStop ( sourceID ) ; alDeleteSources ( sourceID ) ; } sourceToSoundId . clear ( ) ; soundIdToSource . clear ( ) ; AL . destroy ( ) ; while ( AL . isCreated ( ) ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } public AudioDevice newAudioDevice ( int sampleRate , final boolean isMono ) { if ( noDevice ) return new AudioDevice ( ) { @Override public void writeSamples ( float [ ] samples , int offset , int numSamples ) { } @Override public void writeSamples ( short [ ] samples , int offset , int numSamples ) { } @Override public void setVolume ( float volume ) { } @Override public boolean isMono ( ) { return isMono ; } @Override public int getLatency ( ) { return <int> ; } @Override public void dispose ( ) { } } ; return new OpenALAudioDevice ( this , sampleRate , isMono , deviceBufferSize , deviceBufferCount ) ; } public AudioRecorder newAudioRecorder ( int samplingRate , boolean isMono ) { if ( noDevice ) return new AudioRecorder ( ) { @Override public void read ( short [ ] samples , int offset , int numSamples ) { } @Override public void dispose ( ) { } } ; return new JavaSoundAudioRecorder ( samplingRate , isMono ) ; } protected void retain ( OpenALSound sound , boolean stop ) { mostRecetSound + + ; mostRecetSound % = recentSounds . length ; if ( stop ) { if ( recentSounds [ mostRecetSound ] ! = null ) recentSounds [ mostRecetSound ] . stop ( ) ; } recentSounds [ mostRecetSound ] = sound ; } public void forget ( OpenALSound sound ) { for ( int i = <int> ; i < recentSounds . length ; i + + ) { if ( recentSounds [ i ] = = sound ) recentSounds [ i ] = null ; } } } 
