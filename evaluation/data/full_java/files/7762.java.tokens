package org . elasticsearch . action . support . replication ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ReplicationResponse ; import org . elasticsearch . action . NoShardAvailableActionException ; import org . elasticsearch . action . UnavailableShardsException ; import org . elasticsearch . action . admin . indices . flush . FlushRequest ; import org . elasticsearch . action . admin . indices . flush . FlushResponse ; import org . elasticsearch . action . admin . indices . flush . TransportFlushAction ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . action . support . broadcast . BroadcastResponse ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import org . elasticsearch . transport . local . LocalTransport ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . io . IOException ; import java . util . Date ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . action . support . replication . ClusterStateCreationUtils . state ; import static org . elasticsearch . action . support . replication . ClusterStateCreationUtils . stateWithAssignedPrimariesAndOneReplica ; import static org . elasticsearch . action . support . replication . ClusterStateCreationUtils . stateWithNoShard ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class BroadcastReplicationTests extends ESTestCase { private static ThreadPool threadPool ; private TestClusterService clusterService ; private TransportService transportService ; private LocalTransport transport ; private TestBroadcastReplicationAction broadcastReplicationAction ; @BeforeClass public static void beforeClass ( ) { threadPool = new ThreadPool ( <str> ) ; } @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; transport = new LocalTransport ( Settings . EMPTY , threadPool , Version . CURRENT , new NamedWriteableRegistry ( ) ) ; clusterService = new TestClusterService ( threadPool ) ; transportService = new TransportService ( transport , threadPool ) ; transportService . start ( ) ; broadcastReplicationAction = new TestBroadcastReplicationAction ( Settings . EMPTY , threadPool , clusterService , transportService , new ActionFilters ( new HashSet < ActionFilter > ( ) ) , new IndexNameExpressionResolver ( Settings . EMPTY ) , null ) ; } @AfterClass public static void afterClass ( ) { ThreadPool . terminate ( threadPool , <int> , TimeUnit . SECONDS ) ; threadPool = null ; } public void testNotStartedPrimary ( ) throws InterruptedException , ExecutionException , IOException { final String index = <str> ; clusterService . setState ( state ( index , randomBoolean ( ) , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . UNASSIGNED , ShardRoutingState . UNASSIGNED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Future < BroadcastResponse > response = ( broadcastReplicationAction . execute ( new BroadcastRequest ( ) . indices ( index ) ) ) ; for ( Tuple < ShardId , ActionListener < ReplicationResponse > > shardRequests : broadcastReplicationAction . capturedShardRequests ) { if ( randomBoolean ( ) ) { shardRequests . v2 ( ) . onFailure ( new NoShardAvailableActionException ( shardRequests . v1 ( ) ) ) ; } else { shardRequests . v2 ( ) . onFailure ( new UnavailableShardsException ( shardRequests . v1 ( ) , <str> ) ) ; } } response . get ( ) ; logger . info ( <str> , response . get ( ) . getTotalShards ( ) ) ; assertBroadcastResponse ( <int> , <int> , <int> , response . get ( ) , null ) ; } public void testStartedPrimary ( ) throws InterruptedException , ExecutionException , IOException { final String index = <str> ; clusterService . setState ( state ( index , randomBoolean ( ) , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Future < BroadcastResponse > response = ( broadcastReplicationAction . execute ( new BroadcastRequest ( ) . indices ( index ) ) ) ; for ( Tuple < ShardId , ActionListener < ReplicationResponse > > shardRequests : broadcastReplicationAction . capturedShardRequests ) { ReplicationResponse replicationResponse = new ReplicationResponse ( ) ; replicationResponse . setShardInfo ( new ReplicationResponse . ShardInfo ( <int> , <int> , new ReplicationResponse . ShardInfo . Failure [ <int> ] ) ) ; shardRequests . v2 ( ) . onResponse ( replicationResponse ) ; } logger . info ( <str> , response . get ( ) . getTotalShards ( ) ) ; assertBroadcastResponse ( <int> , <int> , <int> , response . get ( ) , null ) ; } public void testResultCombine ( ) throws InterruptedException , ExecutionException , IOException { final String index = <str> ; int numShards = randomInt ( <int> ) ; clusterService . setState ( stateWithAssignedPrimariesAndOneReplica ( index , numShards ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Future < BroadcastResponse > response = ( broadcastReplicationAction . execute ( new BroadcastRequest ( ) . indices ( index ) ) ) ; int succeeded = <int> ; int failed = <int> ; for ( Tuple < ShardId , ActionListener < ReplicationResponse > > shardRequests : broadcastReplicationAction . capturedShardRequests ) { if ( randomBoolean ( ) ) { ReplicationResponse . ShardInfo . Failure [ ] failures = new ReplicationResponse . ShardInfo . Failure [ <int> ] ; int shardsSucceeded = randomInt ( <int> ) + <int> ; succeeded + = shardsSucceeded ; ReplicationResponse replicationResponse = new ReplicationResponse ( ) ; if ( shardsSucceeded = = <int> & & randomBoolean ( ) ) { failures = new ReplicationResponse . ShardInfo . Failure [ <int> ] ; failures [ <int> ] = new ReplicationResponse . ShardInfo . Failure ( index , shardRequests . v1 ( ) . id ( ) , null , new Exception ( <str> ) , RestStatus . GATEWAY_TIMEOUT , false ) ; failed + + ; } replicationResponse . setShardInfo ( new ReplicationResponse . ShardInfo ( <int> , shardsSucceeded , failures ) ) ; shardRequests . v2 ( ) . onResponse ( replicationResponse ) ; } else { failed + = <int> ; shardRequests . v2 ( ) . onFailure ( new Exception ( <str> ) ) ; } } assertBroadcastResponse ( <int> * numShards , succeeded , failed , response . get ( ) , Exception . class ) ; } public void testNoShards ( ) throws InterruptedException , ExecutionException , IOException { clusterService . setState ( stateWithNoShard ( ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; BroadcastResponse response = executeAndAssertImmediateResponse ( broadcastReplicationAction , new BroadcastRequest ( ) ) ; assertBroadcastResponse ( <int> , <int> , <int> , response , null ) ; } public void testShardsList ( ) throws InterruptedException , ExecutionException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; ClusterState clusterState = state ( index , randomBoolean ( ) , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . UNASSIGNED , ShardRoutingState . UNASSIGNED ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; List < ShardId > shards = broadcastReplicationAction . shards ( new BroadcastRequest ( ) . indices ( shardId . index ( ) . name ( ) ) , clusterState ) ; assertThat ( shards . size ( ) , equalTo ( <int> ) ) ; assertThat ( shards . get ( <int> ) , equalTo ( shardId ) ) ; } private class TestBroadcastReplicationAction extends TransportBroadcastReplicationAction < BroadcastRequest , BroadcastResponse , ReplicationRequest , ReplicationResponse > { protected final Set < Tuple < ShardId , ActionListener < ReplicationResponse > > > capturedShardRequests = ConcurrentCollections . newConcurrentSet ( ) ; public TestBroadcastReplicationAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , TransportReplicationAction replicatedBroadcastShardAction ) { super ( <str> , BroadcastRequest : : new , settings , threadPool , clusterService , transportService , actionFilters , indexNameExpressionResolver , replicatedBroadcastShardAction ) ; } @Override protected ReplicationResponse newShardResponse ( ) { return new ReplicationResponse ( ) ; } @Override protected ReplicationRequest newShardRequest ( BroadcastRequest request , ShardId shardId ) { return new ReplicationRequest ( ) . setShardId ( shardId ) ; } @Override protected BroadcastResponse newResponse ( int successfulShards , int failedShards , int totalNumCopies , List shardFailures ) { return new BroadcastResponse ( totalNumCopies , successfulShards , failedShards , shardFailures ) ; } @Override protected void shardExecute ( BroadcastRequest request , ShardId shardId , ActionListener < ReplicationResponse > shardActionListener ) { capturedShardRequests . add ( new Tuple < > ( shardId , shardActionListener ) ) ; } } public FlushResponse assertImmediateResponse ( String index , TransportFlushAction flushAction ) throws InterruptedException , ExecutionException { Date beginDate = new Date ( ) ; FlushResponse flushResponse = flushAction . execute ( new FlushRequest ( index ) ) . get ( ) ; Date endDate = new Date ( ) ; long maxTime = <int> ; assertThat ( <str> + maxTime + <str> , endDate . getTime ( ) - beginDate . getTime ( ) , lessThanOrEqualTo ( maxTime ) ) ; return flushResponse ; } public BroadcastResponse executeAndAssertImmediateResponse ( TransportBroadcastReplicationAction broadcastAction , BroadcastRequest request ) throws InterruptedException , ExecutionException { return ( BroadcastResponse ) broadcastAction . execute ( request ) . actionGet ( <str> ) ; } private void assertBroadcastResponse ( int total , int successful , int failed , BroadcastResponse response , Class exceptionClass ) { assertThat ( response . getSuccessfulShards ( ) , equalTo ( successful ) ) ; assertThat ( response . getTotalShards ( ) , equalTo ( total ) ) ; assertThat ( response . getFailedShards ( ) , equalTo ( failed ) ) ; for ( int i = <int> ; i < failed ; i + + ) { assertThat ( response . getShardFailures ( ) [ <int> ] . getCause ( ) . getCause ( ) , instanceOf ( exceptionClass ) ) ; } } } 
