package org . gradle . cache . internal . btree ; import org . apache . commons . collections . map . LRUMap ; import java . util . * ; public class CachingBlockStore implements BlockStore { private final BlockStore store ; private final Map < BlockPointer , BlockPayload > dirty = new LinkedHashMap < BlockPointer , BlockPayload > ( ) ; private final Map < BlockPointer , BlockPayload > indexBlockCache = new LRUMap ( <int> ) ; private final Set < Class < ? > > cachableTypes = new HashSet < Class < ? > > ( ) ; public CachingBlockStore ( BlockStore store , Class < ? extends BlockPayload > . . . cacheableBlockTypes ) { this . store = store ; cachableTypes . addAll ( Arrays . asList ( cacheableBlockTypes ) ) ; } public void open ( Runnable initAction , Factory factory ) { store . open ( initAction , factory ) ; } public void close ( ) { flush ( ) ; indexBlockCache . clear ( ) ; store . close ( ) ; } public void clear ( ) { dirty . clear ( ) ; indexBlockCache . clear ( ) ; store . clear ( ) ; } public void flush ( ) { Iterator < BlockPayload > iterator = dirty . values ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { BlockPayload block = iterator . next ( ) ; iterator . remove ( ) ; store . write ( block ) ; } store . flush ( ) ; } public void attach ( BlockPayload block ) { store . attach ( block ) ; } public void remove ( BlockPayload block ) { dirty . remove ( block . getPos ( ) ) ; indexBlockCache . remove ( block . getPos ( ) ) ; store . remove ( block ) ; } public < T extends BlockPayload > T readFirst ( Class < T > payloadType ) { T block = store . readFirst ( payloadType ) ; maybeCache ( block ) ; return block ; } public < T extends BlockPayload > T read ( BlockPointer pos , Class < T > payloadType ) { T block = payloadType . cast ( dirty . get ( pos ) ) ; if ( block ! = null ) { return block ; } block = payloadType . cast ( indexBlockCache . get ( pos ) ) ; if ( block ! = null ) { return block ; } block = store . read ( pos , payloadType ) ; maybeCache ( block ) ; return block ; } public void write ( BlockPayload block ) { store . attach ( block ) ; maybeCache ( block ) ; dirty . put ( block . getPos ( ) , block ) ; } private < T extends BlockPayload > void maybeCache ( T block ) { if ( cachableTypes . contains ( block . getClass ( ) ) ) { indexBlockCache . put ( block . getPos ( ) , block ) ; } } } 
