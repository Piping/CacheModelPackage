package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . util . ArrayList ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . debug . core . model . MemoryByte ; public class TableRenderingLine extends PlatformObject { private String fAddress ; private String fStrRep ; private MemoryByte [ ] fBytes ; private byte [ ] fByteArray ; private int fTableIndex = - <int> ; private String fPaddedString ; public boolean isMonitored ; public static final String P_ADDRESS = <str> ; private static final int numCharPerByteForHex = <int> ; public TableRenderingLine ( String address , MemoryByte [ ] bytes , int tableIndex , String paddedString ) { fAddress = address ; fBytes = bytes ; fTableIndex = tableIndex ; fPaddedString = paddedString ; } public String getAddress ( ) { return fAddress ; } public void setAddress ( String address ) { fAddress = address ; } public MemoryByte [ ] getBytes ( ) { return fBytes ; } public MemoryByte getByte ( int offset ) { if ( fBytes = = null ) return null ; if ( offset < fBytes . length ) { return fBytes [ offset ] ; } return null ; } public MemoryByte [ ] getBytes ( int start , int end ) { ArrayList < MemoryByte > ret = new ArrayList < MemoryByte > ( ) ; for ( int i = start ; i < end ; i + + ) { ret . add ( fBytes [ i ] ) ; } return ret . toArray ( new MemoryByte [ ret . size ( ) ] ) ; } public String getRawMemoryString ( ) { if ( fStrRep = = null ) { StringBuffer buffer = new StringBuffer ( ) ; fStrRep = RenderingsUtil . convertByteArrayToHexString ( getByteArray ( ) ) ; fStrRep = fStrRep . toUpperCase ( ) ; buffer = buffer . append ( fStrRep ) ; String paddedString = null ; int bufferCounter = <int> ; for ( int i = <int> ; i < fBytes . length ; i + + ) { if ( ! fBytes [ i ] . isReadable ( ) ) { if ( paddedString = = null ) { paddedString = fPaddedString ; if ( paddedString . length ( ) > TableRenderingLine . numCharPerByteForHex ) paddedString = paddedString . substring ( <int> , TableRenderingLine . numCharPerByteForHex ) ; } buffer . replace ( bufferCounter , bufferCounter + TableRenderingLine . numCharPerByteForHex , paddedString ) ; } bufferCounter + = TableRenderingLine . numCharPerByteForHex ; } fStrRep = buffer . toString ( ) ; } return fStrRep ; } public boolean isAvailable ( int start , int end ) { boolean available = true ; for ( int i = start ; i < end ; i + + ) { if ( ! fBytes [ i ] . isReadable ( ) ) { available = false ; break ; } } return available ; } public byte [ ] getByteArray ( ) { if ( fByteArray = = null ) { fByteArray = new byte [ fBytes . length ] ; for ( int i = <int> ; i < fBytes . length ; i + + ) { fByteArray [ i ] = fBytes [ i ] . getValue ( ) ; } } return fByteArray ; } public byte [ ] getByteArray ( int start , int end ) { byte [ ] ret = new byte [ end - start ] ; int j = <int> ; for ( int i = start ; i < end ; i + + ) { ret [ j ] = fBytes [ i ] . getValue ( ) ; j + + ; } return ret ; } public void markDeltas ( TableRenderingLine oldData ) { if ( oldData = = null ) return ; if ( ! oldData . getAddress ( ) . equals ( this . getAddress ( ) ) ) return ; if ( oldData . getRawMemoryString ( ) . equals ( getRawMemoryString ( ) ) ) { for ( int i = <int> ; i < fBytes . length ; i + + ) { fBytes [ i ] . setHistoryKnown ( true ) ; } return ; } MemoryByte [ ] oldMemory = oldData . getBytes ( ) ; if ( oldMemory . length ! = fBytes . length ) return ; for ( int i = <int> ; i < fBytes . length ; i + + ) { fBytes [ i ] . setHistoryKnown ( true ) ; if ( ( fBytes [ i ] . getFlags ( ) & MemoryByte . READABLE ) ! = ( oldMemory [ i ] . getFlags ( ) & MemoryByte . READABLE ) ) { fBytes [ i ] . setChanged ( true ) ; continue ; } if ( fBytes [ i ] . isReadable ( ) & & oldMemory [ i ] . isReadable ( ) ) { if ( fBytes [ i ] . getValue ( ) ! = oldMemory [ i ] . getValue ( ) ) { fBytes [ i ] . setChanged ( true ) ; } } } } public void copyDeltas ( TableRenderingLine oldData ) { if ( oldData = = null ) return ; if ( ! oldData . getAddress ( ) . equals ( this . getAddress ( ) ) ) return ; MemoryByte [ ] oldMemory = oldData . getBytes ( ) ; if ( oldMemory . length ! = fBytes . length ) return ; for ( int i = <int> ; i < fBytes . length ; i + + ) { fBytes [ i ] . setFlags ( oldMemory [ i ] . getFlags ( ) ) ; } } public boolean isLineChanged ( TableRenderingLine oldData ) { if ( oldData = = null ) return false ; if ( ! oldData . getAddress ( ) . equals ( this . getAddress ( ) ) ) return false ; if ( oldData . getRawMemoryString ( ) . equals ( getRawMemoryString ( ) ) ) { return false ; } return true ; } public boolean isRangeChange ( int offset , int endOffset ) { boolean allBytesKnown = true ; boolean allBytesUnchanged = true ; for ( int i = offset ; i < = endOffset ; i + + ) { if ( ! fBytes [ i ] . isHistoryKnown ( ) ) allBytesKnown = false ; if ( fBytes [ i ] . isChanged ( ) ) allBytesUnchanged = false ; } if ( allBytesKnown & & ! allBytesUnchanged ) { return true ; } return false ; } public void unmarkDeltas ( ) { for ( int i = <int> ; i < fBytes . length ; i + + ) { if ( fBytes [ i ] . isChanged ( ) ) fBytes [ i ] . setChanged ( false ) ; } } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( getAddress ( ) ) ; buf . append ( <str> ) ; buf . append ( getRawMemoryString ( ) ) ; return buf . toString ( ) ; } public int getTableIndex ( ) { return fTableIndex ; } public int getLength ( ) { return fBytes . length ; } } 
