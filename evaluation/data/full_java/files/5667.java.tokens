package org . elasticsearch . common ; import java . io . IOException ; import java . util . concurrent . atomic . AtomicInteger ; class TimeBasedUUIDGenerator implements UUIDGenerator { private final AtomicInteger sequenceNumber = new AtomicInteger ( SecureRandomHolder . INSTANCE . nextInt ( ) ) ; private long lastTimestamp ; private static final byte [ ] secureMungedAddress = MacAddressProvider . getSecureMungedAddress ( ) ; static { assert secureMungedAddress . length = = <int> ; } private static void putLong ( byte [ ] array , long l , int pos , int numberOfLongBytes ) { for ( int i = <int> ; i < numberOfLongBytes ; + + i ) { array [ pos + numberOfLongBytes - i - <int> ] = ( byte ) ( l > > > ( i * <int> ) ) ; } } @Override public String getBase64UUID ( ) { final int sequenceId = sequenceNumber . incrementAndGet ( ) & <hex> ; long timestamp = System . currentTimeMillis ( ) ; synchronized ( this ) { timestamp = Math . max ( lastTimestamp , timestamp ) ; if ( sequenceId = = <int> ) { timestamp + + ; } lastTimestamp = timestamp ; } final byte [ ] uuidBytes = new byte [ <int> ] ; putLong ( uuidBytes , timestamp , <int> , <int> ) ; System . arraycopy ( secureMungedAddress , <int> , uuidBytes , <int> , secureMungedAddress . length ) ; putLong ( uuidBytes , sequenceId , <int> , <int> ) ; assert <int> + secureMungedAddress . length = = uuidBytes . length ; byte [ ] encoded ; try { encoded = Base64 . encodeBytesToBytes ( uuidBytes , <int> , uuidBytes . length , Base64 . URL_SAFE ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } assert encoded [ encoded . length - <int> ] ! = <str> ; return new String ( encoded , <int> , encoded . length , Base64 . PREFERRED_ENCODING ) ; } } 
