package org . elasticsearch . index . mapper . object ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . CopyOnWriteHashMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeBooleanValue ; import static org . elasticsearch . index . mapper . MapperBuilders . object ; import static org . elasticsearch . index . mapper . core . TypeParsers . parsePathType ; public class ObjectMapper extends Mapper implements AllFieldMapper . IncludeInAll , Cloneable { public static final String CONTENT_TYPE = <str> ; public static final String NESTED_CONTENT_TYPE = <str> ; public static class Defaults { public static final boolean ENABLED = true ; public static final Nested NESTED = Nested . NO ; public static final Dynamic DYNAMIC = null ; public static final ContentPath . Type PATH_TYPE = ContentPath . Type . FULL ; } public static enum Dynamic { TRUE , FALSE , STRICT } public static class Nested { public static final Nested NO = new Nested ( false , false , false ) ; public static Nested newNested ( boolean includeInParent , boolean includeInRoot ) { return new Nested ( true , includeInParent , includeInRoot ) ; } private final boolean nested ; private final boolean includeInParent ; private final boolean includeInRoot ; private Nested ( boolean nested , boolean includeInParent , boolean includeInRoot ) { this . nested = nested ; this . includeInParent = includeInParent ; this . includeInRoot = includeInRoot ; } public boolean isNested ( ) { return nested ; } public boolean isIncludeInParent ( ) { return includeInParent ; } public boolean isIncludeInRoot ( ) { return includeInRoot ; } } public static class Builder < T extends Builder , Y extends ObjectMapper > extends Mapper . Builder < T , Y > { protected boolean enabled = Defaults . ENABLED ; protected Nested nested = Defaults . NESTED ; protected Dynamic dynamic = Defaults . DYNAMIC ; protected ContentPath . Type pathType = Defaults . PATH_TYPE ; protected Boolean includeInAll ; protected final List < Mapper . Builder > mappersBuilders = new ArrayList < > ( ) ; public Builder ( String name ) { super ( name ) ; this . builder = ( T ) this ; } public T enabled ( boolean enabled ) { this . enabled = enabled ; return builder ; } public T dynamic ( Dynamic dynamic ) { this . dynamic = dynamic ; return builder ; } public T nested ( Nested nested ) { this . nested = nested ; return builder ; } public T pathType ( ContentPath . Type pathType ) { this . pathType = pathType ; return builder ; } public T includeInAll ( boolean includeInAll ) { this . includeInAll = includeInAll ; return builder ; } public T add ( Mapper . Builder builder ) { mappersBuilders . add ( builder ) ; return this . builder ; } @Override public Y build ( BuilderContext context ) { ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( pathType ) ; context . path ( ) . add ( name ) ; Map < String , Mapper > mappers = new HashMap < > ( ) ; for ( Mapper . Builder builder : mappersBuilders ) { Mapper mapper = builder . build ( context ) ; mappers . put ( mapper . simpleName ( ) , mapper ) ; } context . path ( ) . pathType ( origPathType ) ; context . path ( ) . remove ( ) ; ObjectMapper objectMapper = createMapper ( name , context . path ( ) . fullPathAsText ( name ) , enabled , nested , dynamic , pathType , mappers , context . indexSettings ( ) ) ; objectMapper . includeInAllIfNotSet ( includeInAll ) ; return ( Y ) objectMapper ; } protected ObjectMapper createMapper ( String name , String fullPath , boolean enabled , Nested nested , Dynamic dynamic , ContentPath . Type pathType , Map < String , Mapper > mappers , @Nullable Settings settings ) { return new ObjectMapper ( name , fullPath , enabled , nested , dynamic , pathType , mappers ) ; } } public static class TypeParser implements Mapper . TypeParser { @Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { ObjectMapper . Builder builder = createBuilder ( name ) ; parseNested ( name , node , builder ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object fieldNode = entry . getValue ( ) ; if ( parseObjectOrDocumentTypeProperties ( fieldName , fieldNode , parserContext , builder ) | | parseObjectProperties ( name , fieldName , fieldNode , parserContext , builder ) ) { iterator . remove ( ) ; } } return builder ; } protected static boolean parseObjectOrDocumentTypeProperties ( String fieldName , Object fieldNode , ParserContext parserContext , ObjectMapper . Builder builder ) { if ( fieldName . equals ( <str> ) ) { String value = fieldNode . toString ( ) ; if ( value . equalsIgnoreCase ( <str> ) ) { builder . dynamic ( Dynamic . STRICT ) ; } else { builder . dynamic ( nodeBooleanValue ( fieldNode ) ? Dynamic . TRUE : Dynamic . FALSE ) ; } return true ; } else if ( fieldName . equals ( <str> ) ) { builder . enabled ( nodeBooleanValue ( fieldNode ) ) ; return true ; } else if ( fieldName . equals ( <str> ) ) { if ( fieldNode instanceof Collection & & ( ( Collection ) fieldNode ) . isEmpty ( ) ) { } else if ( ! ( fieldNode instanceof Map ) ) { throw new ElasticsearchParseException ( <str> ) ; } else { parseProperties ( builder , ( Map < String , Object > ) fieldNode , parserContext ) ; } return true ; } else if ( fieldName . equals ( <str> ) ) { builder . includeInAll ( nodeBooleanValue ( fieldNode ) ) ; return true ; } return false ; } protected static boolean parseObjectProperties ( String name , String fieldName , Object fieldNode , ParserContext parserContext , ObjectMapper . Builder builder ) { if ( fieldName . equals ( <str> ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { builder . pathType ( parsePathType ( name , fieldNode . toString ( ) ) ) ; return true ; } return false ; } protected static void parseNested ( String name , Map < String , Object > node , ObjectMapper . Builder builder ) { boolean nested = false ; boolean nestedIncludeInParent = false ; boolean nestedIncludeInRoot = false ; Object fieldNode = node . get ( <str> ) ; if ( fieldNode ! = null ) { String type = fieldNode . toString ( ) ; if ( type . equals ( CONTENT_TYPE ) ) { builder . nested = Nested . NO ; } else if ( type . equals ( NESTED_CONTENT_TYPE ) ) { nested = true ; } else { throw new MapperParsingException ( <str> + type + <str> + name + <str> ) ; } } fieldNode = node . get ( <str> ) ; if ( fieldNode ! = null ) { nestedIncludeInParent = nodeBooleanValue ( fieldNode ) ; node . remove ( <str> ) ; } fieldNode = node . get ( <str> ) ; if ( fieldNode ! = null ) { nestedIncludeInRoot = nodeBooleanValue ( fieldNode ) ; node . remove ( <str> ) ; } if ( nested ) { builder . nested = Nested . newNested ( nestedIncludeInParent , nestedIncludeInRoot ) ; } } protected static void parseProperties ( ObjectMapper . Builder objBuilder , Map < String , Object > propsNode , ParserContext parserContext ) { Iterator < Map . Entry < String , Object > > iterator = propsNode . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = entry . getKey ( ) ; if ( fieldName . contains ( <str> ) ) { throw new MapperParsingException ( <str> + fieldName + <str> ) ; } boolean isEmptyList = entry . getValue ( ) instanceof List & & ( ( List < ? > ) entry . getValue ( ) ) . isEmpty ( ) ; if ( entry . getValue ( ) instanceof Map ) { @SuppressWarnings ( <str> ) Map < String , Object > propNode = ( Map < String , Object > ) entry . getValue ( ) ; String type ; Object typeNode = propNode . get ( <str> ) ; if ( typeNode ! = null ) { type = typeNode . toString ( ) ; } else { if ( propNode . get ( <str> ) ! = null ) { type = ObjectMapper . CONTENT_TYPE ; } else if ( propNode . size ( ) = = <int> & & propNode . get ( <str> ) ! = null ) { type = ObjectMapper . CONTENT_TYPE ; } else { throw new MapperParsingException ( <str> + fieldName + <str> ) ; } } Mapper . TypeParser typeParser = parserContext . typeParser ( type ) ; if ( typeParser = = null ) { throw new MapperParsingException ( <str> + type + <str> + fieldName + <str> ) ; } objBuilder . add ( typeParser . parse ( fieldName , propNode , parserContext ) ) ; propNode . remove ( <str> ) ; DocumentMapperParser . checkNoRemainingFields ( fieldName , propNode , parserContext . indexVersionCreated ( ) ) ; iterator . remove ( ) ; } else if ( isEmptyList ) { iterator . remove ( ) ; } else { throw new MapperParsingException ( <str> + fieldName + <str> + fieldName . getClass ( ) ) ; } } DocumentMapperParser . checkNoRemainingFields ( propsNode , parserContext . indexVersionCreated ( ) , <str> ) ; } protected Builder createBuilder ( String name ) { return object ( name ) ; } } private final String fullPath ; private final boolean enabled ; private final Nested nested ; private final String nestedTypePathAsString ; private final BytesRef nestedTypePathAsBytes ; private final Query nestedTypeFilter ; private volatile Dynamic dynamic ; private final ContentPath . Type pathType ; private Boolean includeInAll ; private volatile CopyOnWriteHashMap < String , Mapper > mappers ; ObjectMapper ( String name , String fullPath , boolean enabled , Nested nested , Dynamic dynamic , ContentPath . Type pathType , Map < String , Mapper > mappers ) { super ( name ) ; this . fullPath = fullPath ; this . enabled = enabled ; this . nested = nested ; this . dynamic = dynamic ; this . pathType = pathType ; if ( mappers = = null ) { this . mappers = new CopyOnWriteHashMap < > ( ) ; } else { this . mappers = CopyOnWriteHashMap . copyOf ( mappers ) ; } this . nestedTypePathAsString = <str> + fullPath ; this . nestedTypePathAsBytes = new BytesRef ( nestedTypePathAsString ) ; this . nestedTypeFilter = new TermQuery ( new Term ( TypeFieldMapper . NAME , nestedTypePathAsBytes ) ) ; } @Override protected ObjectMapper clone ( ) { ObjectMapper clone ; try { clone = ( ObjectMapper ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } return clone ; } public ObjectMapper mappingUpdate ( Mapper mapper ) { ObjectMapper mappingUpdate = clone ( ) ; mappingUpdate . mappers = new CopyOnWriteHashMap < > ( ) ; mappingUpdate . putMapper ( mapper ) ; return mappingUpdate ; } @Override public String name ( ) { return this . fullPath ; } public boolean isEnabled ( ) { return this . enabled ; } public ContentPath . Type pathType ( ) { return pathType ; } public Mapper getMapper ( String field ) { return mappers . get ( field ) ; } @Override public void includeInAll ( Boolean includeInAll ) { if ( includeInAll = = null ) { return ; } this . includeInAll = includeInAll ; for ( Mapper mapper : mappers . values ( ) ) { if ( mapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mapper ) . includeInAll ( includeInAll ) ; } } } @Override public void includeInAllIfNotSet ( Boolean includeInAll ) { if ( this . includeInAll = = null ) { this . includeInAll = includeInAll ; } for ( Mapper mapper : mappers . values ( ) ) { if ( mapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mapper ) . includeInAllIfNotSet ( includeInAll ) ; } } } @Override public void unsetIncludeInAll ( ) { includeInAll = null ; for ( Mapper mapper : mappers . values ( ) ) { if ( mapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mapper ) . unsetIncludeInAll ( ) ; } } } public Nested nested ( ) { return this . nested ; } public Query nestedTypeFilter ( ) { return this . nestedTypeFilter ; } public void putMapper ( Mapper mapper ) { if ( mapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mapper ) . includeInAllIfNotSet ( includeInAll ) ; } mappers = mappers . copyAndPut ( mapper . simpleName ( ) , mapper ) ; } @Override public Iterator < Mapper > iterator ( ) { return mappers . values ( ) . iterator ( ) ; } public String fullPath ( ) { return this . fullPath ; } public String nestedTypePathAsString ( ) { return nestedTypePathAsString ; } public final Dynamic dynamic ( ) { return dynamic ; } @Override public void merge ( final Mapper mergeWith , final MergeResult mergeResult ) { if ( ! ( mergeWith instanceof ObjectMapper ) ) { mergeResult . addConflict ( <str> + mergeWith . name ( ) + <str> + name ( ) + <str> ) ; return ; } ObjectMapper mergeWithObject = ( ObjectMapper ) mergeWith ; if ( nested ( ) . isNested ( ) ) { if ( ! mergeWithObject . nested ( ) . isNested ( ) ) { mergeResult . addConflict ( <str> + name ( ) + <str> ) ; return ; } } else { if ( mergeWithObject . nested ( ) . isNested ( ) ) { mergeResult . addConflict ( <str> + name ( ) + <str> ) ; return ; } } if ( ! mergeResult . simulate ( ) ) { if ( mergeWithObject . dynamic ! = null ) { this . dynamic = mergeWithObject . dynamic ; } } doMerge ( mergeWithObject , mergeResult ) ; List < Mapper > mappersToPut = new ArrayList < > ( ) ; List < ObjectMapper > newObjectMappers = new ArrayList < > ( ) ; List < FieldMapper > newFieldMappers = new ArrayList < > ( ) ; for ( Mapper mapper : mergeWithObject ) { Mapper mergeWithMapper = mapper ; Mapper mergeIntoMapper = mappers . get ( mergeWithMapper . simpleName ( ) ) ; if ( mergeIntoMapper = = null ) { if ( ! mergeResult . simulate ( ) ) { mappersToPut . add ( mergeWithMapper ) ; MapperUtils . collect ( mergeWithMapper , newObjectMappers , newFieldMappers ) ; } } else if ( mergeIntoMapper instanceof MetadataFieldMapper = = false ) { mergeIntoMapper . merge ( mergeWithMapper , mergeResult ) ; } } if ( ! newFieldMappers . isEmpty ( ) ) { mergeResult . addFieldMappers ( newFieldMappers ) ; } if ( ! newObjectMappers . isEmpty ( ) ) { mergeResult . addObjectMappers ( newObjectMappers ) ; } for ( Mapper mapper : mappersToPut ) { putMapper ( mapper ) ; } } protected void doMerge ( ObjectMapper mergeWith , MergeResult mergeResult ) { } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { toXContent ( builder , params , null ) ; return builder ; } public void toXContent ( XContentBuilder builder , Params params , ToXContent custom ) throws IOException { builder . startObject ( simpleName ( ) ) ; if ( nested . isNested ( ) ) { builder . field ( <str> , NESTED_CONTENT_TYPE ) ; if ( nested . isIncludeInParent ( ) ) { builder . field ( <str> , true ) ; } if ( nested . isIncludeInRoot ( ) ) { builder . field ( <str> , true ) ; } } else if ( mappers . isEmpty ( ) & & custom = = null ) { builder . field ( <str> , CONTENT_TYPE ) ; } if ( dynamic ! = null ) { builder . field ( <str> , dynamic . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( enabled ! = Defaults . ENABLED ) { builder . field ( <str> , enabled ) ; } if ( pathType ! = Defaults . PATH_TYPE ) { builder . field ( <str> , pathType . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( includeInAll ! = null ) { builder . field ( <str> , includeInAll ) ; } if ( custom ! = null ) { custom . toXContent ( builder , params ) ; } doXContent ( builder , params ) ; Mapper [ ] sortedMappers = mappers . values ( ) . stream ( ) . toArray ( size - > new Mapper [ size ] ) ; Arrays . sort ( sortedMappers , new Comparator < Mapper > ( ) { @Override public int compare ( Mapper o1 , Mapper o2 ) { return o1 . name ( ) . compareTo ( o2 . name ( ) ) ; } } ) ; int count = <int> ; for ( Mapper mapper : sortedMappers ) { if ( ! ( mapper instanceof MetadataFieldMapper ) ) { if ( count + + = = <int> ) { builder . startObject ( <str> ) ; } mapper . toXContent ( builder , params ) ; } } if ( count > <int> ) { builder . endObject ( ) ; } builder . endObject ( ) ; } protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { } } 
