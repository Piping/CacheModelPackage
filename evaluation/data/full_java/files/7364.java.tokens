package org . elasticsearch . search . aggregations . metrics . tophits ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . fetch . FetchPhase ; import org . elasticsearch . search . fetch . FieldsParseElement ; import org . elasticsearch . search . fetch . fielddata . FieldDataFieldsParseElement ; import org . elasticsearch . search . fetch . script . ScriptFieldsParseElement ; import org . elasticsearch . search . fetch . source . FetchSourceParseElement ; import org . elasticsearch . search . highlight . HighlighterParseElement ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . internal . SubSearchContext ; import org . elasticsearch . search . sort . SortParseElement ; import java . io . IOException ; public class TopHitsParser implements Aggregator . Parser { private final FetchPhase fetchPhase ; private final SortParseElement sortParseElement ; private final FetchSourceParseElement sourceParseElement ; private final HighlighterParseElement highlighterParseElement ; private final FieldDataFieldsParseElement fieldDataFieldsParseElement ; private final ScriptFieldsParseElement scriptFieldsParseElement ; private final FieldsParseElement fieldsParseElement ; @Inject public TopHitsParser ( FetchPhase fetchPhase , SortParseElement sortParseElement , FetchSourceParseElement sourceParseElement , HighlighterParseElement highlighterParseElement , FieldDataFieldsParseElement fieldDataFieldsParseElement , ScriptFieldsParseElement scriptFieldsParseElement , FieldsParseElement fieldsParseElement ) { this . fetchPhase = fetchPhase ; this . sortParseElement = sortParseElement ; this . sourceParseElement = sourceParseElement ; this . highlighterParseElement = highlighterParseElement ; this . fieldDataFieldsParseElement = fieldDataFieldsParseElement ; this . scriptFieldsParseElement = scriptFieldsParseElement ; this . fieldsParseElement = fieldsParseElement ; } @Override public String type ( ) { return InternalTopHits . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { SubSearchContext subSearchContext = new SubSearchContext ( context ) ; XContentParser . Token token ; String currentFieldName = null ; try { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { sortParseElement . parse ( parser , subSearchContext ) ; } else if ( <str> . equals ( currentFieldName ) ) { sourceParseElement . parse ( parser , subSearchContext ) ; } else if ( <str> . equals ( currentFieldName ) ) { fieldsParseElement . parse ( parser , subSearchContext ) ; } else if ( token . isValue ( ) ) { switch ( currentFieldName ) { case <str> : subSearchContext . from ( parser . intValue ( ) ) ; break ; case <str> : subSearchContext . size ( parser . intValue ( ) ) ; break ; case <str> : case <str> : subSearchContext . trackScores ( parser . booleanValue ( ) ) ; break ; case <str> : subSearchContext . version ( parser . booleanValue ( ) ) ; break ; case <str> : subSearchContext . explain ( parser . booleanValue ( ) ) ; break ; default : throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { switch ( currentFieldName ) { case <str> : highlighterParseElement . parse ( parser , subSearchContext ) ; break ; case <str> : case <str> : scriptFieldsParseElement . parse ( parser , subSearchContext ) ; break ; default : throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { switch ( currentFieldName ) { case <str> : case <str> : fieldDataFieldsParseElement . parse ( parser , subSearchContext ) ; break ; default : throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } } catch ( Exception e ) { throw ExceptionsHelper . convertToElastic ( e ) ; } return new TopHitsAggregator . Factory ( aggregationName , fetchPhase , subSearchContext ) ; } } 
