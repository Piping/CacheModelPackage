package io . netty . resolver . dns ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . handler . codec . dns . DefaultDnsQuestion ; import io . netty . handler . codec . dns . DefaultDnsRecordDecoder ; import io . netty . handler . codec . dns . DnsResponseCode ; import io . netty . handler . codec . dns . DnsSection ; import io . netty . handler . codec . dns . DnsQuestion ; import io . netty . handler . codec . dns . DnsRawRecord ; import io . netty . handler . codec . dns . DnsRecord ; import io . netty . handler . codec . dns . DnsRecordType ; import io . netty . handler . codec . dns . DnsResponse ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . StringUtil ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . IdentityHashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; abstract class DnsNameResolverContext < T > { private static final int INADDRSZ4 = <int> ; private static final int INADDRSZ6 = <int> ; private static final FutureListener < AddressedEnvelope < DnsResponse , InetSocketAddress > > RELEASE_RESPONSE = new FutureListener < AddressedEnvelope < DnsResponse , InetSocketAddress > > ( ) { @Override public void operationComplete ( Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > future ) { if ( future . isSuccess ( ) ) { future . getNow ( ) . release ( ) ; } } } ; private final DnsNameResolver parent ; private final DnsServerAddressStream nameServerAddrs ; private final Promise < T > promise ; private final String hostname ; private final boolean traceEnabled ; private final int maxAllowedQueries ; private final InternetProtocolFamily [ ] resolveAddressTypes ; private final Set < Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > queriesInProgress = Collections . newSetFromMap ( new IdentityHashMap < Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > , Boolean > ( ) ) ; private List < DnsCacheEntry > resolvedEntries ; private StringBuilder trace ; private int allowedQueries ; private boolean triedCNAME ; protected DnsNameResolverContext ( DnsNameResolver parent , String hostname , Promise < T > promise ) { this . parent = parent ; this . promise = promise ; this . hostname = hostname ; nameServerAddrs = parent . nameServerAddresses . stream ( ) ; maxAllowedQueries = parent . maxQueriesPerResolve ( ) ; resolveAddressTypes = parent . resolveAddressTypesUnsafe ( ) ; traceEnabled = parent . isTraceEnabled ( ) ; allowedQueries = maxAllowedQueries ; } protected Promise < T > promise ( ) { return promise ; } void resolve ( ) { InetSocketAddress nameServerAddrToTry = nameServerAddrs . next ( ) ; for ( InternetProtocolFamily f : resolveAddressTypes ) { final DnsRecordType type ; switch ( f ) { case IPv4 : type = DnsRecordType . A ; break ; case IPv6 : type = DnsRecordType . AAAA ; break ; default : throw new Error ( ) ; } query ( nameServerAddrToTry , new DefaultDnsQuestion ( hostname , type ) ) ; } } private void query ( InetSocketAddress nameServerAddr , final DnsQuestion question ) { if ( allowedQueries = = <int> | | promise . isCancelled ( ) ) { tryToFinishResolve ( ) ; return ; } allowedQueries - - ; final Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > f = parent . query ( nameServerAddr , question ) ; queriesInProgress . add ( f ) ; f . addListener ( new FutureListener < AddressedEnvelope < DnsResponse , InetSocketAddress > > ( ) { @Override public void operationComplete ( Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > future ) { queriesInProgress . remove ( future ) ; if ( promise . isDone ( ) | | future . isCancelled ( ) ) { return ; } try { if ( future . isSuccess ( ) ) { onResponse ( question , future . getNow ( ) ) ; } else { if ( traceEnabled ) { addTrace ( future . cause ( ) ) ; } query ( nameServerAddrs . next ( ) , question ) ; } } finally { tryToFinishResolve ( ) ; } } } ) ; } void onResponse ( final DnsQuestion question , AddressedEnvelope < DnsResponse , InetSocketAddress > envelope ) { try { final DnsResponse res = envelope . content ( ) ; final DnsResponseCode code = res . code ( ) ; if ( code = = DnsResponseCode . NOERROR ) { final DnsRecordType type = question . type ( ) ; if ( type = = DnsRecordType . A | | type = = DnsRecordType . AAAA ) { onResponseAorAAAA ( type , question , envelope ) ; } else if ( type = = DnsRecordType . CNAME ) { onResponseCNAME ( question , envelope ) ; } return ; } if ( traceEnabled ) { addTrace ( envelope . sender ( ) , <str> + code + <str> + res . count ( DnsSection . ANSWER ) + <str> + res . count ( DnsSection . AUTHORITY ) + <str> ) ; } if ( code ! = DnsResponseCode . NXDOMAIN ) { query ( nameServerAddrs . next ( ) , question ) ; } } finally { ReferenceCountUtil . safeRelease ( envelope ) ; } } private void onResponseAorAAAA ( DnsRecordType qType , DnsQuestion question , AddressedEnvelope < DnsResponse , InetSocketAddress > envelope ) { final DnsResponse response = envelope . content ( ) ; final Map < String , String > cnames = buildAliasMap ( response ) ; final int answerCount = response . count ( DnsSection . ANSWER ) ; boolean found = false ; for ( int i = <int> ; i < answerCount ; i + + ) { final DnsRecord r = response . recordAt ( DnsSection . ANSWER , i ) ; final DnsRecordType type = r . type ( ) ; if ( type ! = DnsRecordType . A & & type ! = DnsRecordType . AAAA ) { continue ; } final String qName = question . name ( ) . toLowerCase ( Locale . US ) ; final String rName = r . name ( ) . toLowerCase ( Locale . US ) ; if ( ! rName . equals ( qName ) ) { String resolved = qName ; do { resolved = cnames . get ( resolved ) ; if ( rName . equals ( resolved ) ) { break ; } } while ( resolved ! = null ) ; if ( resolved = = null ) { continue ; } } if ( ! ( r instanceof DnsRawRecord ) ) { continue ; } final ByteBuf content = ( ( ByteBufHolder ) r ) . content ( ) ; final int contentLen = content . readableBytes ( ) ; if ( contentLen ! = INADDRSZ4 & & contentLen ! = INADDRSZ6 ) { continue ; } final byte [ ] addrBytes = new byte [ contentLen ] ; content . getBytes ( content . readerIndex ( ) , addrBytes ) ; final InetAddress resolved ; try { resolved = InetAddress . getByAddress ( hostname , addrBytes ) ; } catch ( UnknownHostException e ) { throw new Error ( e ) ; } if ( resolvedEntries = = null ) { resolvedEntries = new ArrayList < DnsCacheEntry > ( <int> ) ; } final DnsCacheEntry e = new DnsCacheEntry ( hostname , resolved ) ; parent . cache ( hostname , resolved , r . timeToLive ( ) ) ; resolvedEntries . add ( e ) ; found = true ; } if ( found ) { return ; } if ( traceEnabled ) { addTrace ( envelope . sender ( ) , <str> + qType + <str> ) ; } if ( ! cnames . isEmpty ( ) ) { onResponseCNAME ( question , envelope , cnames , false ) ; } } private void onResponseCNAME ( DnsQuestion question , AddressedEnvelope < DnsResponse , InetSocketAddress > envelope ) { onResponseCNAME ( question , envelope , buildAliasMap ( envelope . content ( ) ) , true ) ; } private void onResponseCNAME ( DnsQuestion question , AddressedEnvelope < DnsResponse , InetSocketAddress > response , Map < String , String > cnames , boolean trace ) { final String name = question . name ( ) . toLowerCase ( Locale . US ) ; String resolved = name ; boolean found = false ; for ( ; ; ) { String next = cnames . get ( resolved ) ; if ( next ! = null ) { found = true ; resolved = next ; } else { break ; } } if ( found ) { followCname ( response . sender ( ) , name , resolved ) ; } else if ( trace & & traceEnabled ) { addTrace ( response . sender ( ) , <str> ) ; } } private static Map < String , String > buildAliasMap ( DnsResponse response ) { final int answerCount = response . count ( DnsSection . ANSWER ) ; Map < String , String > cnames = null ; for ( int i = <int> ; i < answerCount ; i + + ) { final DnsRecord r = response . recordAt ( DnsSection . ANSWER , i ) ; final DnsRecordType type = r . type ( ) ; if ( type ! = DnsRecordType . CNAME ) { continue ; } if ( ! ( r instanceof DnsRawRecord ) ) { continue ; } final ByteBuf recordContent = ( ( ByteBufHolder ) r ) . content ( ) ; final String domainName = decodeDomainName ( recordContent ) ; if ( domainName = = null ) { continue ; } if ( cnames = = null ) { cnames = new HashMap < String , String > ( ) ; } cnames . put ( r . name ( ) . toLowerCase ( Locale . US ) , domainName . toLowerCase ( Locale . US ) ) ; } return cnames ! = null ? cnames : Collections . < String , String > emptyMap ( ) ; } void tryToFinishResolve ( ) { if ( ! queriesInProgress . isEmpty ( ) ) { if ( gotPreferredAddress ( ) ) { finishResolve ( ) ; } return ; } if ( resolvedEntries = = null ) { if ( ! triedCNAME ) { triedCNAME = true ; query ( nameServerAddrs . next ( ) , new DefaultDnsQuestion ( hostname , DnsRecordType . CNAME ) ) ; return ; } } finishResolve ( ) ; } private boolean gotPreferredAddress ( ) { if ( resolvedEntries = = null ) { return false ; } final int size = resolvedEntries . size ( ) ; switch ( resolveAddressTypes [ <int> ] ) { case IPv4 : for ( int i = <int> ; i < size ; i + + ) { if ( resolvedEntries . get ( i ) . address ( ) instanceof Inet4Address ) { return true ; } } break ; case IPv6 : for ( int i = <int> ; i < size ; i + + ) { if ( resolvedEntries . get ( i ) . address ( ) instanceof Inet6Address ) { return true ; } } break ; } return false ; } private void finishResolve ( ) { if ( ! queriesInProgress . isEmpty ( ) ) { for ( Iterator < Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > i = queriesInProgress . iterator ( ) ; i . hasNext ( ) ; ) { Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > f = i . next ( ) ; i . remove ( ) ; if ( ! f . cancel ( false ) ) { f . addListener ( RELEASE_RESPONSE ) ; } } } if ( resolvedEntries ! = null ) { for ( InternetProtocolFamily f : resolveAddressTypes ) { if ( finishResolve ( f . addressType ( ) , resolvedEntries ) ) { return ; } } } final int tries = maxAllowedQueries - allowedQueries ; final StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( <str> ) ; buf . append ( hostname ) ; if ( tries > <int> ) { buf . append ( <str> ) ; buf . append ( tries ) ; if ( trace ! = null ) { buf . append ( <str> ) ; buf . append ( trace ) ; } else { buf . append ( <str> ) ; } } else { if ( trace ! = null ) { buf . append ( <str> ) ; buf . append ( trace ) ; } } final UnknownHostException cause = new UnknownHostException ( buf . toString ( ) ) ; parent . cache ( hostname , cause ) ; promise . tryFailure ( cause ) ; } protected abstract boolean finishResolve ( Class < ? extends InetAddress > addressType , List < DnsCacheEntry > resolvedEntries ) ; static String decodeDomainName ( ByteBuf buf ) { buf . markReaderIndex ( ) ; try { int position = - <int> ; int checked = <int> ; final int end = buf . writerIndex ( ) ; final StringBuilder name = new StringBuilder ( buf . readableBytes ( ) < < <int> ) ; for ( int len = buf . readUnsignedByte ( ) ; buf . isReadable ( ) & & len ! = <int> ; len = buf . readUnsignedByte ( ) ) { boolean pointer = ( len & <hex> ) = = <hex> ; if ( pointer ) { if ( position = = - <int> ) { position = buf . readerIndex ( ) + <int> ; } final int next = ( len & <hex> ) < < <int> | buf . readUnsignedByte ( ) ; if ( next > = end ) { return null ; } buf . readerIndex ( next ) ; checked + = <int> ; if ( checked > = end ) { return null ; } } else { name . append ( buf . toString ( buf . readerIndex ( ) , len , CharsetUtil . UTF_8 ) ) . append ( <str> ) ; buf . skipBytes ( len ) ; } } if ( position ! = - <int> ) { buf . readerIndex ( position ) ; } if ( name . length ( ) = = <int> ) { return null ; } return name . substring ( <int> , name . length ( ) - <int> ) ; } finally { buf . resetReaderIndex ( ) ; } } private void followCname ( InetSocketAddress nameServerAddr , String name , String cname ) { if ( traceEnabled ) { if ( trace = = null ) { trace = new StringBuilder ( <int> ) ; } trace . append ( StringUtil . NEWLINE ) ; trace . append ( <str> ) ; trace . append ( nameServerAddr ) ; trace . append ( <str> ) ; trace . append ( name ) ; trace . append ( <str> ) ; trace . append ( cname ) ; } final InetSocketAddress nextAddr = nameServerAddrs . next ( ) ; query ( nextAddr , new DefaultDnsQuestion ( cname , DnsRecordType . A ) ) ; query ( nextAddr , new DefaultDnsQuestion ( cname , DnsRecordType . AAAA ) ) ; } private void addTrace ( InetSocketAddress nameServerAddr , String msg ) { assert traceEnabled ; if ( trace = = null ) { trace = new StringBuilder ( <int> ) ; } trace . append ( StringUtil . NEWLINE ) ; trace . append ( <str> ) ; trace . append ( nameServerAddr ) ; trace . append ( <str> ) ; trace . append ( msg ) ; } private void addTrace ( Throwable cause ) { assert traceEnabled ; if ( trace = = null ) { trace = new StringBuilder ( <int> ) ; } trace . append ( StringUtil . NEWLINE ) ; trace . append ( <str> ) ; trace . append ( cause ) ; } } 
