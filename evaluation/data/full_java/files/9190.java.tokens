package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import java . util . Collections ; import java . util . NoSuchElementException ; import java . util . Set ; @Beta @GwtCompatible ( emulated = true ) @SuppressWarnings ( <str> ) public abstract class ContiguousSet < C extends Comparable > extends ImmutableSortedSet < C > { public static < C extends Comparable > ContiguousSet < C > create ( Range < C > range , DiscreteDomain < C > domain ) { checkNotNull ( range ) ; checkNotNull ( domain ) ; Range < C > effectiveRange = range ; try { if ( ! range . hasLowerBound ( ) ) { effectiveRange = effectiveRange . intersection ( Range . atLeast ( domain . minValue ( ) ) ) ; } if ( ! range . hasUpperBound ( ) ) { effectiveRange = effectiveRange . intersection ( Range . atMost ( domain . maxValue ( ) ) ) ; } } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( e ) ; } boolean empty = effectiveRange . isEmpty ( ) | | Range . compareOrThrow ( range . lowerBound . leastValueAbove ( domain ) , range . upperBound . greatestValueBelow ( domain ) ) > <int> ; return empty ? new EmptyContiguousSet < C > ( domain ) : new RegularContiguousSet < C > ( effectiveRange , domain ) ; } final DiscreteDomain < C > domain ; ContiguousSet ( DiscreteDomain < C > domain ) { super ( Ordering . natural ( ) ) ; this . domain = domain ; } @Override public ContiguousSet < C > headSet ( C toElement ) { return headSetImpl ( checkNotNull ( toElement ) , false ) ; } @GwtIncompatible ( <str> ) @Override public ContiguousSet < C > headSet ( C toElement , boolean inclusive ) { return headSetImpl ( checkNotNull ( toElement ) , inclusive ) ; } @Override public ContiguousSet < C > subSet ( C fromElement , C toElement ) { checkNotNull ( fromElement ) ; checkNotNull ( toElement ) ; checkArgument ( comparator ( ) . compare ( fromElement , toElement ) < = <int> ) ; return subSetImpl ( fromElement , true , toElement , false ) ; } @GwtIncompatible ( <str> ) @Override public ContiguousSet < C > subSet ( C fromElement , boolean fromInclusive , C toElement , boolean toInclusive ) { checkNotNull ( fromElement ) ; checkNotNull ( toElement ) ; checkArgument ( comparator ( ) . compare ( fromElement , toElement ) < = <int> ) ; return subSetImpl ( fromElement , fromInclusive , toElement , toInclusive ) ; } @Override public ContiguousSet < C > tailSet ( C fromElement ) { return tailSetImpl ( checkNotNull ( fromElement ) , true ) ; } @GwtIncompatible ( <str> ) @Override public ContiguousSet < C > tailSet ( C fromElement , boolean inclusive ) { return tailSetImpl ( checkNotNull ( fromElement ) , inclusive ) ; } abstract ContiguousSet < C > headSetImpl ( C toElement , boolean inclusive ) ; abstract ContiguousSet < C > subSetImpl ( C fromElement , boolean fromInclusive , C toElement , boolean toInclusive ) ; abstract ContiguousSet < C > tailSetImpl ( C fromElement , boolean inclusive ) ; public abstract ContiguousSet < C > intersection ( ContiguousSet < C > other ) ; public abstract Range < C > range ( ) ; public abstract Range < C > range ( BoundType lowerBoundType , BoundType upperBoundType ) ; @Override public String toString ( ) { return range ( ) . toString ( ) ; } @Deprecated public static < E > ImmutableSortedSet . Builder < E > builder ( ) { throw new UnsupportedOperationException ( ) ; } } 
