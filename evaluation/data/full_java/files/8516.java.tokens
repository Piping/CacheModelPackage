package org . elasticsearch . search . highlight ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . NamedWriteableAwareStreamInput ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperBuilders ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . query . IdsQueryBuilder ; import org . elasticsearch . index . query . IdsQueryParser ; import org . elasticsearch . index . query . MatchAllQueryBuilder ; import org . elasticsearch . index . query . MatchAllQueryParser ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . index . query . QueryParseContext ; import org . elasticsearch . index . query . QueryParser ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . query . TermQueryBuilder ; import org . elasticsearch . index . query . TermQueryParser ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . search . highlight . HighlightBuilder ; import org . elasticsearch . search . highlight . HighlightBuilder . Field ; import org . elasticsearch . search . highlight . SearchContextHighlight . FieldOptions ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . not ; public class HighlightBuilderTests extends ESTestCase { private static final int NUMBER_OF_TESTBUILDERS = <int> ; private static NamedWriteableRegistry namedWriteableRegistry ; private static IndicesQueriesRegistry indicesQueriesRegistry ; @BeforeClass public static void init ( ) { namedWriteableRegistry = new NamedWriteableRegistry ( ) ; @SuppressWarnings ( <str> ) Set < QueryParser > injectedQueryParsers = new HashSet < > ( ) ; injectedQueryParsers . add ( new MatchAllQueryParser ( ) ) ; injectedQueryParsers . add ( new IdsQueryParser ( ) ) ; injectedQueryParsers . add ( new TermQueryParser ( ) ) ; indicesQueriesRegistry = new IndicesQueriesRegistry ( Settings . settingsBuilder ( ) . build ( ) , injectedQueryParsers , namedWriteableRegistry ) ; } @AfterClass public static void afterClass ( ) throws Exception { namedWriteableRegistry = null ; indicesQueriesRegistry = null ; } public void testSerialization ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { HighlightBuilder original = randomHighlighterBuilder ( ) ; HighlightBuilder deserialized = serializedCopy ( original ) ; assertEquals ( deserialized , original ) ; assertEquals ( deserialized . hashCode ( ) , original . hashCode ( ) ) ; assertNotSame ( deserialized , original ) ; } } public void testEqualsAndHashcode ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { HighlightBuilder firstBuilder = randomHighlighterBuilder ( ) ; assertFalse ( <str> , firstBuilder . equals ( null ) ) ; assertFalse ( <str> , firstBuilder . equals ( <str> ) ) ; assertTrue ( <str> , firstBuilder . equals ( firstBuilder ) ) ; assertThat ( <str> , firstBuilder . hashCode ( ) , equalTo ( firstBuilder . hashCode ( ) ) ) ; assertThat ( <str> , mutate ( firstBuilder ) , not ( equalTo ( firstBuilder ) ) ) ; HighlightBuilder secondBuilder = serializedCopy ( firstBuilder ) ; assertTrue ( <str> , secondBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , firstBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , secondBuilder . equals ( firstBuilder ) ) ; assertThat ( <str> , secondBuilder . hashCode ( ) , equalTo ( firstBuilder . hashCode ( ) ) ) ; HighlightBuilder thirdBuilder = serializedCopy ( secondBuilder ) ; assertTrue ( <str> , thirdBuilder . equals ( thirdBuilder ) ) ; assertTrue ( <str> , secondBuilder . equals ( thirdBuilder ) ) ; assertThat ( <str> , secondBuilder . hashCode ( ) , equalTo ( thirdBuilder . hashCode ( ) ) ) ; assertTrue ( <str> , firstBuilder . equals ( thirdBuilder ) ) ; assertThat ( <str> , firstBuilder . hashCode ( ) , equalTo ( thirdBuilder . hashCode ( ) ) ) ; assertTrue ( <str> , thirdBuilder . equals ( secondBuilder ) ) ; assertTrue ( <str> , thirdBuilder . equals ( firstBuilder ) ) ; } } public void testFromXContent ( ) throws IOException { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . parseFieldMatcher ( new ParseFieldMatcher ( Settings . EMPTY ) ) ; for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { HighlightBuilder highlightBuilder = randomHighlighterBuilder ( ) ; XContentBuilder builder = XContentFactory . contentBuilder ( randomFrom ( XContentType . values ( ) ) ) ; if ( randomBoolean ( ) ) { builder . prettyPrint ( ) ; } builder . startObject ( ) ; highlightBuilder . innerXContent ( builder ) ; builder . endObject ( ) ; XContentParser parser = XContentHelper . createParser ( builder . bytes ( ) ) ; context . reset ( parser ) ; HighlightBuilder secondHighlightBuilder = HighlightBuilder . fromXContent ( context ) ; assertNotSame ( highlightBuilder , secondHighlightBuilder ) ; assertEquals ( highlightBuilder , secondHighlightBuilder ) ; assertEquals ( highlightBuilder . hashCode ( ) , secondHighlightBuilder . hashCode ( ) ) ; } } public void testUnknownArrayNameExpection ( ) throws IOException { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . parseFieldMatcher ( new ParseFieldMatcher ( Settings . EMPTY ) ) ; String highlightElement = <str> + <str> + <str> ; XContentParser parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } highlightElement = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } } public void testUnknownFieldnameExpection ( ) throws IOException { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . parseFieldMatcher ( new ParseFieldMatcher ( Settings . EMPTY ) ) ; String highlightElement = <str> + <str> + <str> ; XContentParser parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } highlightElement = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } } public void testUnknownObjectFieldnameExpection ( ) throws IOException { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . parseFieldMatcher ( new ParseFieldMatcher ( Settings . EMPTY ) ) ; String highlightElement = <str> + <str> + <str> ; XContentParser parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } highlightElement = <str> + <str> + <str> + <str> + <str> + <str> + <str> ; parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } } public void testBuildSearchContextHighlight ( ) throws IOException { Settings indexSettings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; Index index = new Index ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; IndexSettings idxSettings = IndexSettingsModule . newIndexSettings ( index , indexSettings ) ; QueryShardContext mockShardContext = new QueryShardContext ( idxSettings , null , null , null , null , null , null , indicesQueriesRegistry ) { @Override public MappedFieldType fieldMapper ( String name ) { StringFieldMapper . Builder builder = MapperBuilders . stringField ( name ) ; return builder . build ( new Mapper . BuilderContext ( idxSettings . getSettings ( ) , new ContentPath ( <int> ) ) ) . fieldType ( ) ; } } ; mockShardContext . setMapUnmappedFieldAsString ( true ) ; for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { HighlightBuilder highlightBuilder = randomHighlighterBuilder ( ) ; SearchContextHighlight highlight = highlightBuilder . build ( mockShardContext ) ; XContentBuilder builder = XContentFactory . contentBuilder ( randomFrom ( XContentType . values ( ) ) ) ; if ( randomBoolean ( ) ) { builder . prettyPrint ( ) ; } builder . startObject ( ) ; highlightBuilder . innerXContent ( builder ) ; builder . endObject ( ) ; XContentParser parser = XContentHelper . createParser ( builder . bytes ( ) ) ; SearchContextHighlight parsedHighlight = new HighlighterParseElement ( ) . parse ( parser , mockShardContext ) ; assertNotSame ( highlight , parsedHighlight ) ; assertEquals ( highlight . globalForceSource ( ) , parsedHighlight . globalForceSource ( ) ) ; assertEquals ( highlight . fields ( ) . size ( ) , parsedHighlight . fields ( ) . size ( ) ) ; Iterator < org . elasticsearch . search . highlight . SearchContextHighlight . Field > iterator = parsedHighlight . fields ( ) . iterator ( ) ; for ( org . elasticsearch . search . highlight . SearchContextHighlight . Field field : highlight . fields ( ) ) { org . elasticsearch . search . highlight . SearchContextHighlight . Field otherField = iterator . next ( ) ; assertEquals ( field . field ( ) , otherField . field ( ) ) ; FieldOptions options = field . fieldOptions ( ) ; FieldOptions otherOptions = otherField . fieldOptions ( ) ; assertArrayEquals ( options . boundaryChars ( ) , options . boundaryChars ( ) ) ; assertEquals ( options . boundaryMaxScan ( ) , otherOptions . boundaryMaxScan ( ) ) ; assertEquals ( options . encoder ( ) , otherOptions . encoder ( ) ) ; assertEquals ( options . fragmentCharSize ( ) , otherOptions . fragmentCharSize ( ) ) ; assertEquals ( options . fragmenter ( ) , otherOptions . fragmenter ( ) ) ; assertEquals ( options . fragmentOffset ( ) , otherOptions . fragmentOffset ( ) ) ; assertEquals ( options . highlighterType ( ) , otherOptions . highlighterType ( ) ) ; assertEquals ( options . highlightFilter ( ) , otherOptions . highlightFilter ( ) ) ; assertEquals ( options . highlightQuery ( ) , otherOptions . highlightQuery ( ) ) ; assertEquals ( options . matchedFields ( ) , otherOptions . matchedFields ( ) ) ; assertEquals ( options . noMatchSize ( ) , otherOptions . noMatchSize ( ) ) ; assertEquals ( options . numberOfFragments ( ) , otherOptions . numberOfFragments ( ) ) ; assertEquals ( options . options ( ) , otherOptions . options ( ) ) ; assertEquals ( options . phraseLimit ( ) , otherOptions . phraseLimit ( ) ) ; assertArrayEquals ( options . preTags ( ) , otherOptions . preTags ( ) ) ; assertArrayEquals ( options . postTags ( ) , otherOptions . postTags ( ) ) ; assertEquals ( options . requireFieldMatch ( ) , otherOptions . requireFieldMatch ( ) ) ; assertEquals ( options . scoreOrdered ( ) , otherOptions . scoreOrdered ( ) ) ; } } } public void testParsingTagsSchema ( ) throws IOException { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; context . parseFieldMatcher ( new ParseFieldMatcher ( Settings . EMPTY ) ) ; String highlightElement = <str> + <str> + <str> ; XContentParser parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; HighlightBuilder highlightBuilder = HighlightBuilder . fromXContent ( context ) ; assertArrayEquals ( <str> , HighlightBuilder . DEFAULT_STYLED_PRE_TAG , highlightBuilder . preTags ( ) ) ; assertArrayEquals ( <str> , HighlightBuilder . DEFAULT_STYLED_POST_TAGS , highlightBuilder . postTags ( ) ) ; highlightElement = <str> + <str> + <str> ; parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; highlightBuilder = HighlightBuilder . fromXContent ( context ) ; assertArrayEquals ( <str> , HighlightBuilder . DEFAULT_PRE_TAGS , highlightBuilder . preTags ( ) ) ; assertArrayEquals ( <str> , HighlightBuilder . DEFAULT_POST_TAGS , highlightBuilder . postTags ( ) ) ; highlightElement = <str> + <str> + <str> ; parser = XContentFactory . xContent ( highlightElement ) . createParser ( highlightElement ) ; context . reset ( parser ) ; try { highlightBuilder = HighlightBuilder . fromXContent ( context ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertEquals ( <str> , e . getMessage ( ) ) ; } } protected static XContentBuilder toXContent ( HighlightBuilder highlight , XContentType contentType ) throws IOException { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; if ( randomBoolean ( ) ) { builder . prettyPrint ( ) ; } highlight . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; return builder ; } private static HighlightBuilder randomHighlighterBuilder ( ) { HighlightBuilder testHighlighter = new HighlightBuilder ( ) ; setRandomCommonOptions ( testHighlighter ) ; testHighlighter . useExplicitFieldOrder ( randomBoolean ( ) ) ; if ( randomBoolean ( ) ) { testHighlighter . encoder ( randomFrom ( Arrays . asList ( new String [ ] { <str> , <str> } ) ) ) ; } int numberOfFields = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numberOfFields ; i + + ) { Field field = new Field ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; setRandomCommonOptions ( field ) ; if ( randomBoolean ( ) ) { field . fragmentOffset ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { field . matchedFields ( randomStringArray ( <int> , <int> ) ) ; } testHighlighter . field ( field ) ; } return testHighlighter ; } @SuppressWarnings ( { <str> , <str> } ) private static void setRandomCommonOptions ( AbstractHighlighterBuilder highlightBuilder ) { if ( randomBoolean ( ) ) { highlightBuilder . preTags ( randomStringArray ( <int> , <int> ) ) ; highlightBuilder . postTags ( randomStringArray ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . fragmentSize ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . numOfFragments ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . highlighterType ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . fragmenter ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { QueryBuilder highlightQuery ; switch ( randomInt ( <int> ) ) { case <int> : highlightQuery = new MatchAllQueryBuilder ( ) ; break ; case <int> : highlightQuery = new IdsQueryBuilder ( ) ; break ; default : case <int> : highlightQuery = new TermQueryBuilder ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; } highlightQuery . boost ( ( float ) randomDoubleBetween ( <int> , <int> , false ) ) ; highlightBuilder . highlightQuery ( highlightQuery ) ; } if ( randomBoolean ( ) ) { highlightBuilder . order ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . highlightFilter ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . forceSource ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . boundaryMaxScan ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . boundaryChars ( randomAsciiOfLengthBetween ( <int> , <int> ) . toCharArray ( ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . noMatchSize ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { highlightBuilder . phraseLimit ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { int items = randomIntBetween ( <int> , <int> ) ; Map < String , Object > options = new HashMap < String , Object > ( items ) ; for ( int i = <int> ; i < items ; i + + ) { Object value = null ; switch ( randomInt ( <int> ) ) { case <int> : value = randomAsciiOfLengthBetween ( <int> , <int> ) ; break ; case <int> : value = new Integer ( randomInt ( <int> ) ) ; break ; case <int> : value = new Boolean ( randomBoolean ( ) ) ; break ; } options . put ( randomAsciiOfLengthBetween ( <int> , <int> ) , value ) ; } } if ( randomBoolean ( ) ) { highlightBuilder . requireFieldMatch ( randomBoolean ( ) ) ; } } @SuppressWarnings ( { <str> , <str> } ) private static void mutateCommonOptions ( AbstractHighlighterBuilder highlightBuilder ) { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : highlightBuilder . preTags ( randomStringArray ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . postTags ( randomStringArray ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . fragmentSize ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . numOfFragments ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . highlighterType ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . fragmenter ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . highlightQuery ( new TermQueryBuilder ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ) ; break ; case <int> : highlightBuilder . order ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . highlightFilter ( toggleOrSet ( highlightBuilder . highlightFilter ( ) ) ) ; break ; case <int> : highlightBuilder . forceSource ( toggleOrSet ( highlightBuilder . forceSource ( ) ) ) ; break ; case <int> : highlightBuilder . boundaryMaxScan ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . boundaryChars ( randomAsciiOfLengthBetween ( <int> , <int> ) . toCharArray ( ) ) ; break ; case <int> : highlightBuilder . noMatchSize ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : highlightBuilder . phraseLimit ( randomIntBetween ( <int> , <int> ) ) ; break ; case <int> : int items = <int> ; Map < String , Object > options = new HashMap < String , Object > ( items ) ; for ( int i = <int> ; i < items ; i + + ) { options . put ( randomAsciiOfLengthBetween ( <int> , <int> ) , randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } highlightBuilder . options ( options ) ; break ; case <int> : highlightBuilder . requireFieldMatch ( toggleOrSet ( highlightBuilder . requireFieldMatch ( ) ) ) ; break ; } } private static Boolean toggleOrSet ( Boolean flag ) { if ( flag = = null ) { return randomBoolean ( ) ; } else { return ! flag . booleanValue ( ) ; } } private static String [ ] randomStringArray ( int minSize , int maxSize ) { int size = randomIntBetween ( minSize , maxSize ) ; String [ ] randomStrings = new String [ size ] ; for ( int f = <int> ; f < size ; f + + ) { randomStrings [ f ] = randomAsciiOfLengthBetween ( <int> , <int> ) ; } return randomStrings ; } private static HighlightBuilder mutate ( HighlightBuilder original ) throws IOException { HighlightBuilder mutation = serializedCopy ( original ) ; if ( randomBoolean ( ) ) { mutateCommonOptions ( mutation ) ; } else { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : mutation . useExplicitFieldOrder ( ! original . useExplicitFieldOrder ( ) ) ; break ; case <int> : mutation . encoder ( original . encoder ( ) + randomAsciiOfLength ( <int> ) ) ; break ; case <int> : if ( randomBoolean ( ) ) { mutation . field ( new Field ( randomAsciiOfLength ( <int> ) ) ) ; } else { List < Field > originalFields = original . fields ( ) ; Field fieldToChange = originalFields . get ( randomInt ( originalFields . size ( ) - <int> ) ) ; if ( randomBoolean ( ) ) { fieldToChange . fragmentOffset ( randomIntBetween ( <int> , <int> ) ) ; } else { fieldToChange . matchedFields ( randomStringArray ( <int> , <int> ) ) ; } } break ; } } return mutation ; } private static HighlightBuilder serializedCopy ( HighlightBuilder original ) throws IOException { try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { original . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { return HighlightBuilder . PROTOTYPE . readFrom ( in ) ; } } } } 
