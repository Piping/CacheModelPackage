package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . nio . file . Path ; import java . util . * ; import java . util . function . BiFunction ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Predicate ; import com . google . common . collect . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . io . sstable . SSTable ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableReader . UniqueIdentifier ; import org . apache . cassandra . utils . concurrent . Transactional ; import static com . google . common . base . Functions . compose ; import static com . google . common . base . Predicates . * ; import static com . google . common . collect . ImmutableSet . copyOf ; import static com . google . common . collect . Iterables . * ; import static java . util . Collections . singleton ; import static org . apache . cassandra . db . lifecycle . Helpers . * ; import static org . apache . cassandra . db . lifecycle . View . updateCompacting ; import static org . apache . cassandra . db . lifecycle . View . updateLiveSet ; import static org . apache . cassandra . utils . Throwables . maybeFail ; import static org . apache . cassandra . utils . concurrent . Refs . release ; import static org . apache . cassandra . utils . concurrent . Refs . selfRefs ; public class LifecycleTransaction extends Transactional . AbstractTransactional { private static final Logger logger = LoggerFactory . getLogger ( LifecycleTransaction . class ) ; private static class State { final Set < SSTableReader > update = new HashSet < > ( ) ; final Set < SSTableReader > obsolete = new HashSet < > ( ) ; void log ( State staged ) { update . removeAll ( staged . obsolete ) ; update . removeAll ( staged . update ) ; update . addAll ( staged . update ) ; obsolete . addAll ( staged . obsolete ) ; } boolean contains ( SSTableReader reader ) { return update . contains ( reader ) | | obsolete . contains ( reader ) ; } boolean isEmpty ( ) { return update . isEmpty ( ) & & obsolete . isEmpty ( ) ; } void clear ( ) { update . clear ( ) ; obsolete . clear ( ) ; } } public final Tracker tracker ; private final LogTransaction log ; private final Set < SSTableReader > originals = new HashSet < > ( ) ; private final Set < SSTableReader > marked = new HashSet < > ( ) ; private final Set < UniqueIdentifier > identities = Collections . newSetFromMap ( new IdentityHashMap < > ( ) ) ; private final State logged = new State ( ) ; private final State staged = new State ( ) ; private List < LogTransaction . Obsoletion > obsoletions ; public static LifecycleTransaction offline ( OperationType operationType , SSTableReader reader ) { return offline ( operationType , singleton ( reader ) ) ; } public static LifecycleTransaction offline ( OperationType operationType , Iterable < SSTableReader > readers ) { Tracker dummy = new Tracker ( null , false ) ; dummy . addInitialSSTables ( readers ) ; dummy . apply ( updateCompacting ( emptySet ( ) , readers ) ) ; return new LifecycleTransaction ( dummy , operationType , readers ) ; } @SuppressWarnings ( <str> ) public static LifecycleTransaction offline ( OperationType operationType ) { Tracker dummy = new Tracker ( null , false ) ; return new LifecycleTransaction ( dummy , new LogTransaction ( operationType , dummy ) , Collections . emptyList ( ) ) ; } @SuppressWarnings ( <str> ) LifecycleTransaction ( Tracker tracker , OperationType operationType , Iterable < SSTableReader > readers ) { this ( tracker , new LogTransaction ( operationType , tracker ) , readers ) ; } LifecycleTransaction ( Tracker tracker , LogTransaction log , Iterable < SSTableReader > readers ) { this . tracker = tracker ; this . log = log ; for ( SSTableReader reader : readers ) { originals . add ( reader ) ; marked . add ( reader ) ; identities . add ( reader . instanceId ) ; } } public LogTransaction log ( ) { return log ; } public OperationType opType ( ) { return log . type ( ) ; } public UUID opId ( ) { return log . id ( ) ; } public void doPrepare ( ) { checkpoint ( ) ; maybeFail ( prepareForObsoletion ( filterIn ( logged . obsolete , originals ) , log , obsoletions = new ArrayList < > ( ) , null ) ) ; log . prepareToCommit ( ) ; } public Throwable doCommit ( Throwable accumulate ) { assert staged . isEmpty ( ) : <str> ; logger . trace ( <str> , staged . update , staged . obsolete ) ; maybeFail ( accumulate ) ; maybeFail ( log . commit ( null ) ) ; accumulate = markObsolete ( obsoletions , accumulate ) ; accumulate = tracker . updateSizeTracking ( logged . obsolete , logged . update , accumulate ) ; accumulate = release ( selfRefs ( logged . obsolete ) , accumulate ) ; accumulate = tracker . notifySSTablesChanged ( originals , logged . update , log . type ( ) , accumulate ) ; return accumulate ; } public Throwable doAbort ( Throwable accumulate ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , originals , logged . update , logged . obsolete , staged . update , staged . obsolete ) ; accumulate = abortObsoletion ( obsoletions , accumulate ) ; if ( logged . isEmpty ( ) & & staged . isEmpty ( ) ) return log . abort ( accumulate ) ; Iterable < SSTableReader > obsolete = filterOut ( concatUniq ( staged . update , logged . update ) , originals ) ; logger . trace ( <str> , obsolete ) ; accumulate = prepareForObsoletion ( obsolete , log , obsoletions = new ArrayList < > ( ) , accumulate ) ; accumulate = log . abort ( accumulate ) ; accumulate = markObsolete ( obsoletions , accumulate ) ; accumulate = tracker . apply ( updateLiveSet ( logged . update , restoreUpdatedOriginals ( ) ) , accumulate ) ; accumulate = setReplaced ( logged . update , accumulate ) ; accumulate = release ( selfRefs ( concat ( staged . update , logged . update , logged . obsolete ) ) , accumulate ) ; logged . clear ( ) ; staged . clear ( ) ; return accumulate ; } @Override protected Throwable doPostCleanup ( Throwable accumulate ) { log . close ( ) ; return unmarkCompacting ( marked , accumulate ) ; } public boolean isOffline ( ) { return tracker . isDummy ( ) ; } public void permitRedundantTransitions ( ) { super . permitRedundantTransitions ( ) ; } public void checkpoint ( ) { maybeFail ( checkpoint ( null ) ) ; } private Throwable checkpoint ( Throwable accumulate ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , staged . update , staged . obsolete ) ; if ( staged . isEmpty ( ) ) return accumulate ; Set < SSTableReader > toUpdate = toUpdate ( ) ; Set < SSTableReader > fresh = copyOf ( fresh ( ) ) ; checkNotReplaced ( filterIn ( toUpdate , staged . update ) ) ; tracker . apply ( compose ( updateCompacting ( emptySet ( ) , fresh ) , updateLiveSet ( toUpdate , staged . update ) ) ) ; marked . addAll ( fresh ) ; logged . log ( staged ) ; accumulate = setReplaced ( filterOut ( toUpdate , staged . obsolete ) , accumulate ) ; accumulate = release ( selfRefs ( filterOut ( toUpdate , staged . obsolete ) ) , accumulate ) ; staged . clear ( ) ; return accumulate ; } public void update ( SSTableReader reader , boolean original ) { assert ! staged . update . contains ( reader ) : <str> + reader ; assert ! identities . contains ( reader . instanceId ) : <str> + reader ; assert ! ( logged . obsolete . contains ( reader ) | | staged . obsolete . contains ( reader ) ) : <str> ; assert original = = originals . contains ( reader ) : String . format ( <str> , original , reader ) ; staged . update . add ( reader ) ; identities . add ( reader . instanceId ) ; if ( ! isOffline ( ) ) reader . setupOnline ( ) ; } public void update ( Collection < SSTableReader > readers , boolean original ) { for ( SSTableReader reader : readers ) { update ( reader , original ) ; } } public void obsolete ( SSTableReader reader ) { logger . trace ( <str> , reader ) ; assert identities . contains ( reader . instanceId ) : <str> + reader ; assert originals . contains ( reader ) : <str> + reader + <str> + originals ; assert ! ( logged . obsolete . contains ( reader ) | | staged . obsolete . contains ( reader ) ) : <str> + reader ; assert ! staged . update . contains ( reader ) : <str> + reader ; assert current ( reader ) = = reader : <str> + reader ; staged . obsolete . add ( reader ) ; } public void obsoleteOriginals ( ) { logger . trace ( <str> , originals ) ; assert Iterables . isEmpty ( filterIn ( staged . update , originals ) ) : staged . update ; Iterables . addAll ( staged . obsolete , filterIn ( current ( ) , originals ) ) ; } private Set < SSTableReader > toUpdate ( ) { return copyOf ( filterIn ( current ( ) , staged . obsolete , staged . update ) ) ; } private Iterable < SSTableReader > fresh ( ) { return filterOut ( staged . update , originals , logged . update ) ; } public Iterable < SSTableReader > current ( ) { return concat ( logged . update , filterOut ( originals , logged . update , logged . obsolete ) ) ; } private List < SSTableReader > restoreUpdatedOriginals ( ) { Iterable < SSTableReader > torestore = filterIn ( originals , logged . update , logged . obsolete ) ; return ImmutableList . copyOf ( transform ( torestore , ( reader ) - > current ( reader ) . cloneWithRestoredStart ( reader . first ) ) ) ; } public Set < SSTableReader > originals ( ) { return Collections . unmodifiableSet ( originals ) ; } public boolean isObsolete ( SSTableReader reader ) { return logged . obsolete . contains ( reader ) | | staged . obsolete . contains ( reader ) ; } public SSTableReader current ( SSTableReader reader ) { Set < SSTableReader > container ; if ( staged . contains ( reader ) ) container = staged . update . contains ( reader ) ? staged . update : staged . obsolete ; else if ( logged . contains ( reader ) ) container = logged . update . contains ( reader ) ? logged . update : logged . obsolete ; else if ( originals . contains ( reader ) ) container = originals ; else throw new AssertionError ( ) ; return select ( reader , container ) ; } public void cancel ( SSTableReader cancel ) { logger . trace ( <str> , cancel ) ; assert originals . contains ( cancel ) : <str> + cancel + <str> + originals ; assert ! ( staged . contains ( cancel ) | | logged . contains ( cancel ) ) : <str> + cancel ; originals . remove ( cancel ) ; marked . remove ( cancel ) ; identities . remove ( cancel . instanceId ) ; maybeFail ( unmarkCompacting ( singleton ( cancel ) , null ) ) ; } public void cancel ( Iterable < SSTableReader > cancels ) { for ( SSTableReader cancel : cancels ) cancel ( cancel ) ; } public LifecycleTransaction split ( Collection < SSTableReader > readers ) { logger . trace ( <str> , readers ) ; checkUnused ( ) ; for ( SSTableReader reader : readers ) assert identities . contains ( reader . instanceId ) : <str> + reader ; for ( SSTableReader reader : readers ) { identities . remove ( reader . instanceId ) ; originals . remove ( reader ) ; marked . remove ( reader ) ; } return new LifecycleTransaction ( tracker , log . type ( ) , readers ) ; } private void checkUnused ( ) { assert logged . isEmpty ( ) ; assert staged . isEmpty ( ) ; assert identities . size ( ) = = originals . size ( ) ; assert originals . size ( ) = = marked . size ( ) ; } private Throwable unmarkCompacting ( Set < SSTableReader > unmark , Throwable accumulate ) { accumulate = tracker . apply ( updateCompacting ( unmark , emptySet ( ) ) , accumulate ) ; accumulate = tracker . dropSSTablesIfInvalid ( accumulate ) ; return accumulate ; } public SSTableReader onlyOne ( ) { assert originals . size ( ) = = <int> ; return getFirst ( originals , null ) ; } public void trackNew ( SSTable table ) { log . trackNew ( table ) ; } public void untrackNew ( SSTable table ) { log . untrackNew ( table ) ; } public static void removeUnfinishedLeftovers ( CFMetaData metadata ) { LogTransaction . removeUnfinishedLeftovers ( metadata ) ; } public static List < File > getFiles ( Path folder , BiFunction < File , Directories . FileType , Boolean > filter , Directories . OnTxnErr onTxnErr ) { return new LogAwareFileLister ( folder , filter , onTxnErr ) . list ( ) ; } public static void rescheduleFailedDeletions ( ) { LogTransaction . rescheduleFailedDeletions ( ) ; } public static void waitForDeletions ( ) { LogTransaction . waitForDeletions ( ) ; } @VisibleForTesting public static class ReaderState { public enum Action { UPDATED , OBSOLETED , NONE ; public static Action get ( boolean updated , boolean obsoleted ) { assert ! ( updated & & obsoleted ) ; return updated ? UPDATED : obsoleted ? OBSOLETED : NONE ; } } final Action staged ; final Action logged ; final SSTableReader nextVisible ; final SSTableReader currentlyVisible ; final boolean original ; public ReaderState ( Action logged , Action staged , SSTableReader currentlyVisible , SSTableReader nextVisible , boolean original ) { this . staged = staged ; this . logged = logged ; this . currentlyVisible = currentlyVisible ; this . nextVisible = nextVisible ; this . original = original ; } public boolean equals ( Object that ) { return that instanceof ReaderState & & equals ( ( ReaderState ) that ) ; } public boolean equals ( ReaderState that ) { return this . staged = = that . staged & & this . logged = = that . logged & & this . original = = that . original & & this . currentlyVisible = = that . currentlyVisible & & this . nextVisible = = that . nextVisible ; } public String toString ( ) { return String . format ( <str> , logged , staged , original ) ; } public static SSTableReader visible ( SSTableReader reader , Predicate < SSTableReader > obsolete , Collection < SSTableReader > . . . selectFrom ) { return obsolete . apply ( reader ) ? null : selectFirst ( reader , selectFrom ) ; } } @VisibleForTesting public ReaderState state ( SSTableReader reader ) { SSTableReader currentlyVisible = ReaderState . visible ( reader , in ( logged . obsolete ) , logged . update , originals ) ; SSTableReader nextVisible = ReaderState . visible ( reader , orIn ( staged . obsolete , logged . obsolete ) , staged . update , logged . update , originals ) ; return new ReaderState ( ReaderState . Action . get ( logged . update . contains ( reader ) , logged . obsolete . contains ( reader ) ) , ReaderState . Action . get ( staged . update . contains ( reader ) , staged . obsolete . contains ( reader ) ) , currentlyVisible , nextVisible , originals . contains ( reader ) ) ; } public String toString ( ) { return originals . toString ( ) ; } } 
