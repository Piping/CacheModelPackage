package org . gradle . api . internal . plugins ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import net . jcip . annotations . NotThreadSafe ; import org . gradle . api . Action ; import org . gradle . api . DomainObjectSet ; import org . gradle . api . Nullable ; import org . gradle . api . Plugin ; import org . gradle . api . internal . DefaultDomainObjectSet ; import org . gradle . api . plugins . * ; import org . gradle . internal . Cast ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . internal . reflect . ObjectInstantiationException ; import org . gradle . plugin . internal . PluginId ; import java . util . Map ; @NotThreadSafe public class DefaultPluginManager implements PluginManagerInternal { public static final String CORE_PLUGIN_NAMESPACE = <str> + PluginId . SEPARATOR + <str> ; public static final String CORE_PLUGIN_PREFIX = CORE_PLUGIN_NAMESPACE + PluginId . SEPARATOR ; private final Instantiator instantiator ; private final PluginApplicator applicator ; private final PluginRegistry pluginRegistry ; private final DefaultPluginContainer pluginContainer ; private final Map < Class < ? > , PluginImplementation < ? > > plugins = Maps . newHashMap ( ) ; private final Map < Class < ? > , Plugin < ? > > instances = Maps . newHashMap ( ) ; private final Map < PluginId , DomainObjectSet < PluginWithId > > idMappings = Maps . newHashMap ( ) ; public DefaultPluginManager ( final PluginRegistry pluginRegistry , Instantiator instantiator , final PluginApplicator applicator ) { this . instantiator = instantiator ; this . applicator = applicator ; this . pluginRegistry = pluginRegistry ; this . pluginContainer = new DefaultPluginContainer ( pluginRegistry , this ) ; } private < T > T instantiatePlugin ( Class < T > type ) { try { return instantiator . newInstance ( type ) ; } catch ( ObjectInstantiationException e ) { throw new PluginInstantiationException ( String . format ( <str> , type . getSimpleName ( ) ) , e . getCause ( ) ) ; } } @Override public < P extends Plugin > P addImperativePlugin ( PluginImplementation < P > plugin ) { doApply ( plugin ) ; Class < ? extends P > pluginClass = plugin . asClass ( ) ; return pluginClass . cast ( instances . get ( pluginClass ) ) ; } public < P extends Plugin > P addImperativePlugin ( Class < P > type ) { return addImperativePlugin ( pluginRegistry . inspect ( type ) ) ; } @Nullable private Runnable addPluginInternal ( final PluginImplementation < ? > plugin ) { final Class < ? > pluginClass = plugin . asClass ( ) ; if ( plugins . containsKey ( pluginClass ) ) { return null ; } plugins . put ( pluginClass , plugin ) ; return new Runnable ( ) { @Override public void run ( ) { Iterable < PluginId > pluginIds = Lists . newArrayList ( idMappings . keySet ( ) ) ; for ( PluginId id : pluginIds ) { if ( plugin . isAlsoKnownAs ( id ) ) { idMappings . get ( id ) . add ( new PluginWithId ( id , pluginClass ) ) ; } } } } ; } public PluginContainer getPluginContainer ( ) { return pluginContainer ; } @Override public void apply ( PluginImplementation < ? > plugin ) { doApply ( plugin ) ; } public void apply ( String pluginId ) { PluginImplementation < ? > plugin = pluginRegistry . lookup ( PluginId . unvalidated ( pluginId ) ) ; if ( plugin = = null ) { throw new UnknownPluginException ( <str> + pluginId + <str> ) ; } doApply ( plugin ) ; } public void apply ( Class < ? > type ) { doApply ( pluginRegistry . inspect ( type ) ) ; } private void doApply ( PluginImplementation < ? > plugin ) { PluginId pluginId = plugin . getPluginId ( ) ; String pluginIdStr = pluginId = = null ? null : pluginId . toString ( ) ; Class < ? > pluginClass = plugin . asClass ( ) ; try { if ( plugin . getType ( ) . equals ( PotentialPlugin . Type . UNKNOWN ) ) { throw new InvalidPluginException ( <str> + pluginClass . getName ( ) + <str> ) ; } else { boolean imperative = plugin . isImperative ( ) ; Runnable adder = addPluginInternal ( plugin ) ; if ( adder ! = null ) { if ( imperative ) { Object instance = findInstance ( pluginClass , pluginContainer ) ; if ( instance = = null ) { instance = instantiatePlugin ( pluginClass ) ; } Plugin < ? > pluginInstance = Cast . uncheckedCast ( instance ) ; instances . put ( pluginClass , pluginInstance ) ; if ( plugin . isHasRules ( ) ) { applicator . applyImperativeRulesHybrid ( pluginIdStr , pluginInstance ) ; } else { applicator . applyImperative ( pluginIdStr , pluginInstance ) ; } pluginContainer . add ( pluginInstance ) ; } else { applicator . applyRules ( pluginIdStr , pluginClass ) ; } adder . run ( ) ; } } } catch ( PluginApplicationException e ) { throw e ; } catch ( Exception e ) { throw new PluginApplicationException ( plugin . getDisplayName ( ) , e ) ; } } private < T > T findInstance ( Class < T > clazz , Iterable < ? > instances ) { for ( Object instance : instances ) { if ( instance . getClass ( ) . equals ( clazz ) ) { return clazz . cast ( instance ) ; } } return null ; } public DomainObjectSet < PluginWithId > pluginsForId ( String id ) { PluginId pluginId = PluginId . unvalidated ( id ) ; DomainObjectSet < PluginWithId > pluginsForId = idMappings . get ( pluginId ) ; if ( pluginsForId = = null ) { pluginsForId = new DefaultDomainObjectSet < PluginWithId > ( PluginWithId . class , Sets . < PluginWithId > newLinkedHashSet ( ) ) ; idMappings . put ( pluginId , pluginsForId ) ; for ( PluginImplementation < ? > plugin : plugins . values ( ) ) { if ( plugin . isAlsoKnownAs ( pluginId ) ) { pluginsForId . add ( new PluginWithId ( pluginId , plugin . asClass ( ) ) ) ; } } } return pluginsForId ; } public AppliedPlugin findPlugin ( final String id ) { DomainObjectSet < PluginWithId > pluginWithIds = pluginsForId ( id ) ; if ( ! pluginWithIds . isEmpty ( ) ) { return pluginWithIds . iterator ( ) . next ( ) . asAppliedPlugin ( ) ; } return null ; } public boolean hasPlugin ( String id ) { return findPlugin ( id ) ! = null ; } public void withPlugin ( final String id , final Action < ? super AppliedPlugin > action ) { Action < PluginWithId > wrappedAction = new Action < PluginWithId > ( ) { public void execute ( PluginWithId pluginWithId ) { action . execute ( pluginWithId . asAppliedPlugin ( ) ) ; } } ; pluginsForId ( id ) . all ( wrappedAction ) ; } } 
