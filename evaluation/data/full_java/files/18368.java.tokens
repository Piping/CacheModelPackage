package com . badlogic . gdx . utils ; abstract public class Pool < T > { public final int max ; public int peak ; private final Array < T > freeObjects ; public Pool ( ) { this ( <int> , Integer . MAX_VALUE ) ; } public Pool ( int initialCapacity ) { this ( initialCapacity , Integer . MAX_VALUE ) ; } public Pool ( int initialCapacity , int max ) { freeObjects = new Array ( false , initialCapacity ) ; this . max = max ; } abstract protected T newObject ( ) ; public T obtain ( ) { return freeObjects . size = = <int> ? newObject ( ) : freeObjects . pop ( ) ; } public void free ( T object ) { if ( object = = null ) throw new IllegalArgumentException ( <str> ) ; if ( freeObjects . size < max ) { freeObjects . add ( object ) ; peak = Math . max ( peak , freeObjects . size ) ; } reset ( object ) ; } protected void reset ( T object ) { if ( object instanceof Poolable ) ( ( Poolable ) object ) . reset ( ) ; } public void freeAll ( Array < T > objects ) { if ( objects = = null ) throw new IllegalArgumentException ( <str> ) ; Array < T > freeObjects = this . freeObjects ; int max = this . max ; for ( int i = <int> ; i < objects . size ; i + + ) { T object = objects . get ( i ) ; if ( object = = null ) continue ; if ( freeObjects . size < max ) freeObjects . add ( object ) ; reset ( object ) ; } peak = Math . max ( peak , freeObjects . size ) ; } public void clear ( ) { freeObjects . clear ( ) ; } public int getFree ( ) { return freeObjects . size ; } static public interface Poolable { public void reset ( ) ; } } 
