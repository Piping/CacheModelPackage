package org . elasticsearch . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . IntIntMap ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . missing . Missing ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . Collection ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . missing ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . core . IsNull . notNullValue ; public class CombiIT extends ESIntegTestCase { public void testMultipleAggsOnSameField_WithDifferentRequiredValueSourceType ( ) throws Exception { createIndex ( <str> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ randomInt ( <int> ) ] ; IntIntMap values = new IntIntHashMap ( ) ; long missingValues = <int> ; for ( int i = <int> ; i < builders . length ; i + + ) { String name = <str> + randomIntBetween ( <int> , <int> ) ; if ( rarely ( ) ) { missingValues + + ; builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , name ) . endObject ( ) ) ; } else { int value = randomIntBetween ( <int> , <int> ) ; values . put ( value , values . getOrDefault ( value , <int> ) + <int> ) ; builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , name ) . field ( <str> , value ) . endObject ( ) ) ; } } indexRandom ( true , builders ) ; ensureSearchable ( ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( missing ( <str> ) . field ( <str> ) ) . addAggregation ( terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Aggregations aggs = response . getAggregations ( ) ; Missing missing = aggs . get ( <str> ) ; assertNotNull ( missing ) ; assertThat ( missing . getDocCount ( ) , equalTo ( missingValues ) ) ; Terms terms = aggs . get ( <str> ) ; assertNotNull ( terms ) ; Collection < Terms . Bucket > buckets = terms . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( values . size ( ) ) ) ; for ( Terms . Bucket bucket : buckets ) { values . remove ( ( ( Number ) bucket . getKey ( ) ) . intValue ( ) ) ; } assertTrue ( values . isEmpty ( ) ) ; } public void testSubAggregationForTopAggregationOnUnmappedField ( ) throws Exception { prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; ensureSearchable ( <str> ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( <int> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , Matchers . equalTo ( <int> l ) ) ; Histogram values = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( values , notNullValue ( ) ) ; assertThat ( values . getBuckets ( ) . isEmpty ( ) , is ( true ) ) ; } } 
