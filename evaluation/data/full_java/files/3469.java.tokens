package org . nd4j . linalg . shape ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . util . NDArrayMath ; public class NDArrayMathTests extends BaseNd4jTest { public NDArrayMathTests ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Test public void testVectorPerSlice ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . vectorsPerSlice ( arr ) ) ; INDArray matrix = Nd4j . create ( <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . vectorsPerSlice ( matrix ) ) ; INDArray arrSliceZero = arr . slice ( <int> ) ; assertEquals ( <int> , NDArrayMath . vectorsPerSlice ( arrSliceZero ) ) ; } @Test public void testMatricesPerSlice ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . matricesPerSlice ( arr ) ) ; } @Test public void testLengthPerSlice ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> , <int> ) ; int lengthPerSlice = NDArrayMath . lengthPerSlice ( arr ) ; assertEquals ( <int> , lengthPerSlice ) ; } @Test public void toffsetForSlice ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> ) ; int slice = <int> ; assertEquals ( <int> , NDArrayMath . offsetForSlice ( arr , slice ) ) ; } @Test public void testMapOntoVector ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> ) ; assertEquals ( NDArrayMath . mapIndexOntoVector ( <int> , arr ) , <int> ) ; } @Test public void testNumVectors ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . vectorsPerSlice ( arr ) ) ; INDArray matrix = Nd4j . create ( <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . vectorsPerSlice ( matrix ) ) ; } @Test public void testOffsetForSlice ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; int [ ] dimensions = { <int> , <int> } ; INDArray permuted = arr . permute ( <int> , <int> , <int> , <int> ) ; int [ ] test = { <int> , <int> , <int> , <int> } ; for ( int i = <int> ; i < permuted . tensorssAlongDimension ( dimensions ) ; i + + ) { assertEquals ( test [ i ] , NDArrayMath . sliceOffsetForTensor ( i , permuted , new int [ ] { <int> , <int> } ) ) ; } int arrTensorsPerSlice = NDArrayMath . tensorsPerSlice ( arr , new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , arrTensorsPerSlice ) ; INDArray arr2 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; int [ ] assertions = { <int> , <int> , <int> } ; for ( int i = <int> ; i < assertions . length ; i + + ) { assertEquals ( assertions [ i ] , NDArrayMath . sliceOffsetForTensor ( i , arr2 , new int [ ] { <int> , <int> } ) ) ; } int tensorsPerSlice = NDArrayMath . tensorsPerSlice ( arr2 , new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , tensorsPerSlice ) ; INDArray otherTest = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> , <int> ) ; System . out . println ( otherTest ) ; INDArray baseArr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; for ( int i = <int> ; i < baseArr . tensorssAlongDimension ( <int> , <int> ) ; i + + ) { System . out . println ( NDArrayMath . sliceOffsetForTensor ( i , baseArr , new int [ ] { <int> , <int> } ) ) ; } } @Test public void testOddDimensions ( ) { INDArray arr = Nd4j . create ( <int> , <int> , <int> ) ; int numMatrices = NDArrayMath . matricesPerSlice ( arr ) ; assertEquals ( <int> , numMatrices ) ; } @Test public void testTotalVectors ( ) { INDArray arr2 = Nd4j . create ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , NDArrayMath . numVectors ( arr2 ) ) ; } @Override public char ordering ( ) { return <str> ; } } 
