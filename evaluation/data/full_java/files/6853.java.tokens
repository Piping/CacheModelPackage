package org . elasticsearch . indices . cluster ; import com . carrotsearch . hppc . IntHashSet ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . action . index . NodeIndexDeletedAction ; import org . elasticsearch . cluster . action . index . NodeMappingRefreshAction ; import org . elasticsearch . cluster . action . shard . NoOpShardStateActionListener ; import org . elasticsearch . cluster . action . shard . ShardStateAction ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . Callback ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . IndexShardAlreadyExistsException ; import org . elasticsearch . index . NodeServicesProvider ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . shard . * ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . flush . SyncedFlushService ; import org . elasticsearch . indices . memory . IndexingMemoryController ; import org . elasticsearch . indices . recovery . RecoveryFailedException ; import org . elasticsearch . indices . recovery . RecoverySource ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . indices . recovery . RecoveryTarget ; import org . elasticsearch . repositories . RepositoriesService ; import org . elasticsearch . search . SearchService ; import org . elasticsearch . snapshots . RestoreService ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . * ; import java . util . concurrent . ConcurrentMap ; public class IndicesClusterStateService extends AbstractLifecycleComponent < IndicesClusterStateService > implements ClusterStateListener { private final IndicesService indicesService ; private final ClusterService clusterService ; private final ThreadPool threadPool ; private final RecoveryTarget recoveryTarget ; private final ShardStateAction shardStateAction ; private final NodeIndexDeletedAction nodeIndexDeletedAction ; private final NodeMappingRefreshAction nodeMappingRefreshAction ; private final NodeServicesProvider nodeServicesProvider ; private static final ShardStateAction . Listener SHARD_STATE_ACTION_LISTENER = new NoOpShardStateActionListener ( ) ; private final ConcurrentMap < Tuple < String , String > , Boolean > seenMappings = ConcurrentCollections . newConcurrentMap ( ) ; private final ConcurrentMap < ShardId , FailedShard > failedShards = ConcurrentCollections . newConcurrentMap ( ) ; private final RestoreService restoreService ; private final RepositoriesService repositoriesService ; static class FailedShard { public final long version ; public final long timestamp ; FailedShard ( long version ) { this . version = version ; this . timestamp = System . currentTimeMillis ( ) ; } } private final Object mutex = new Object ( ) ; private final FailedShardHandler failedShardHandler = new FailedShardHandler ( ) ; private final boolean sendRefreshMapping ; private final List < IndexEventListener > buildInIndexListener ; @Inject public IndicesClusterStateService ( Settings settings , IndicesService indicesService , ClusterService clusterService , ThreadPool threadPool , RecoveryTarget recoveryTarget , ShardStateAction shardStateAction , NodeIndexDeletedAction nodeIndexDeletedAction , NodeMappingRefreshAction nodeMappingRefreshAction , RepositoriesService repositoriesService , RestoreService restoreService , SearchService searchService , SyncedFlushService syncedFlushService , RecoverySource recoverySource , NodeServicesProvider nodeServicesProvider , IndexingMemoryController indexingMemoryController ) { super ( settings ) ; this . buildInIndexListener = Arrays . asList ( recoverySource , recoveryTarget , searchService , syncedFlushService , indexingMemoryController ) ; this . indicesService = indicesService ; this . clusterService = clusterService ; this . threadPool = threadPool ; this . recoveryTarget = recoveryTarget ; this . shardStateAction = shardStateAction ; this . nodeIndexDeletedAction = nodeIndexDeletedAction ; this . nodeMappingRefreshAction = nodeMappingRefreshAction ; this . restoreService = restoreService ; this . repositoriesService = repositoriesService ; this . sendRefreshMapping = this . settings . getAsBoolean ( <str> , true ) ; this . nodeServicesProvider = nodeServicesProvider ; } @Override protected void doStart ( ) { clusterService . addFirst ( this ) ; } @Override protected void doStop ( ) { clusterService . remove ( this ) ; } @Override protected void doClose ( ) { } @Override public void clusterChanged ( final ClusterChangedEvent event ) { if ( ! indicesService . changesAllowed ( ) ) { return ; } if ( ! lifecycle . started ( ) ) { return ; } synchronized ( mutex ) { if ( event . state ( ) . blocks ( ) . disableStatePersistence ( ) ) { for ( IndexService indexService : indicesService ) { String index = indexService . index ( ) . getName ( ) ; for ( Integer shardId : indexService . shardIds ( ) ) { logger . debug ( <str> , index , shardId ) ; try { indexService . removeShard ( shardId , <str> ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , index ) ; } } removeIndex ( index , <str> ) ; } return ; } cleanFailedShards ( event ) ; applyDeletedIndices ( event ) ; applyNewIndices ( event ) ; applyMappings ( event ) ; applyNewOrUpdatedShards ( event ) ; applyDeletedShards ( event ) ; applyCleanedIndices ( event ) ; applySettings ( event ) ; } } private void applyCleanedIndices ( final ClusterChangedEvent event ) { for ( IndexService indexService : indicesService ) { String index = indexService . index ( ) . getName ( ) ; IndexMetaData indexMetaData = event . state ( ) . metaData ( ) . index ( index ) ; if ( indexMetaData ! = null & & indexMetaData . getState ( ) = = IndexMetaData . State . CLOSE ) { for ( Integer shardId : indexService . shardIds ( ) ) { logger . debug ( <str> , index , shardId ) ; try { indexService . removeShard ( shardId , <str> ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , index ) ; } } } } for ( IndexService indexService : indicesService ) { String index = indexService . index ( ) . getName ( ) ; if ( indexService . shardIds ( ) . isEmpty ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , index ) ; } removeIndex ( index , <str> ) ; } } } private void applyDeletedIndices ( final ClusterChangedEvent event ) { final ClusterState previousState = event . previousState ( ) ; final String localNodeId = event . state ( ) . nodes ( ) . localNodeId ( ) ; assert localNodeId ! = null ; for ( IndexService indexService : indicesService ) { IndexMetaData indexMetaData = event . state ( ) . metaData ( ) . index ( indexService . index ( ) . name ( ) ) ; if ( indexMetaData ! = null ) { if ( ! indexMetaData . isSameUUID ( indexService . indexUUID ( ) ) ) { logger . debug ( <str> , indexMetaData . getIndex ( ) ) ; deleteIndex ( indexMetaData . getIndex ( ) , <str> ) ; } } } for ( String index : event . indicesDeleted ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , index ) ; } final IndexService idxService = indicesService . indexService ( index ) ; final IndexSettings indexSettings ; if ( idxService ! = null ) { indexSettings = idxService . getIndexSettings ( ) ; deleteIndex ( index , <str> ) ; } else { final IndexMetaData metaData = previousState . metaData ( ) . index ( index ) ; assert metaData ! = null ; indexSettings = new IndexSettings ( metaData , settings , Collections . emptyList ( ) ) ; indicesService . deleteClosedIndex ( <str> , metaData , event . state ( ) ) ; } try { nodeIndexDeletedAction . nodeIndexDeleted ( event . state ( ) , index , indexSettings , localNodeId ) ; } catch ( Throwable e ) { logger . debug ( <str> , e , index ) ; } } } private void applyDeletedShards ( final ClusterChangedEvent event ) { RoutingNodes . RoutingNodeIterator routingNode = event . state ( ) . getRoutingNodes ( ) . routingNodeIter ( event . state ( ) . nodes ( ) . localNodeId ( ) ) ; if ( routingNode = = null ) { return ; } IntHashSet newShardIds = new IntHashSet ( ) ; for ( IndexService indexService : indicesService ) { String index = indexService . index ( ) . name ( ) ; IndexMetaData indexMetaData = event . state ( ) . metaData ( ) . index ( index ) ; if ( indexMetaData = = null ) { continue ; } newShardIds . clear ( ) ; for ( ShardRouting shard : routingNode ) { if ( shard . index ( ) . equals ( index ) ) { newShardIds . add ( shard . id ( ) ) ; } } for ( Integer existingShardId : indexService . shardIds ( ) ) { if ( ! newShardIds . contains ( existingShardId ) ) { if ( indexMetaData . getState ( ) = = IndexMetaData . State . CLOSE ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , index , existingShardId ) ; } indexService . removeShard ( existingShardId , <str> ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , index , existingShardId ) ; } indexService . removeShard ( existingShardId , <str> ) ; } } } } } private void applyNewIndices ( final ClusterChangedEvent event ) { RoutingNodes . RoutingNodeIterator routingNode = event . state ( ) . getRoutingNodes ( ) . routingNodeIter ( event . state ( ) . nodes ( ) . localNodeId ( ) ) ; if ( routingNode = = null ) { return ; } for ( ShardRouting shard : routingNode ) { if ( ! indicesService . hasIndex ( shard . index ( ) ) ) { final IndexMetaData indexMetaData = event . state ( ) . metaData ( ) . index ( shard . index ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , indexMetaData . getIndex ( ) ) ; } try { indicesService . createIndex ( nodeServicesProvider , indexMetaData , buildInIndexListener ) ; } catch ( Throwable e ) { sendFailShard ( shard , indexMetaData . getIndexUUID ( ) , <str> , e ) ; } } } } private void applySettings ( ClusterChangedEvent event ) { if ( ! event . metaDataChanged ( ) ) { return ; } for ( IndexMetaData indexMetaData : event . state ( ) . metaData ( ) ) { if ( ! indicesService . hasIndex ( indexMetaData . getIndex ( ) ) ) { continue ; } if ( ! event . indexMetaDataChanged ( indexMetaData ) ) { continue ; } String index = indexMetaData . getIndex ( ) ; IndexService indexService = indicesService . indexService ( index ) ; if ( indexService = = null ) { continue ; } indexService . updateMetaData ( indexMetaData ) ; } } private void applyMappings ( ClusterChangedEvent event ) { for ( IndexMetaData indexMetaData : event . state ( ) . metaData ( ) ) { if ( ! indicesService . hasIndex ( indexMetaData . getIndex ( ) ) ) { continue ; } boolean requireRefresh = false ; String index = indexMetaData . getIndex ( ) ; IndexService indexService = indicesService . indexService ( index ) ; if ( indexService = = null ) { return ; } try { MapperService mapperService = indexService . mapperService ( ) ; for ( ObjectCursor < MappingMetaData > cursor : indexMetaData . getMappings ( ) . values ( ) ) { MappingMetaData mappingMd = cursor . value ; String mappingType = mappingMd . type ( ) ; CompressedXContent mappingSource = mappingMd . source ( ) ; requireRefresh | = processMapping ( index , mapperService , mappingType , mappingSource ) ; } if ( requireRefresh & & sendRefreshMapping ) { nodeMappingRefreshAction . nodeMappingRefresh ( event . state ( ) , new NodeMappingRefreshAction . NodeMappingRefreshRequest ( index , indexMetaData . getIndexUUID ( ) , event . state ( ) . nodes ( ) . localNodeId ( ) ) ) ; } } catch ( Throwable t ) { for ( IndexShard indexShard : indexService ) { ShardRouting shardRouting = indexShard . routingEntry ( ) ; failAndRemoveShard ( shardRouting , indexService . indexUUID ( ) , indexService , true , <str> , t ) ; } } } } private boolean processMapping ( String index , MapperService mapperService , String mappingType , CompressedXContent mappingSource ) throws Throwable { boolean requiresRefresh = false ; try { DocumentMapper existingMapper = mapperService . documentMapper ( mappingType ) ; if ( existingMapper = = null | | mappingSource . equals ( existingMapper . mappingSource ( ) ) = = false ) { String op = existingMapper = = null ? <str> : <str> ; if ( logger . isDebugEnabled ( ) & & mappingSource . compressed ( ) . length < <int> ) { logger . debug ( <str> , index , op , mappingType , mappingSource . string ( ) ) ; } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , index , op , mappingType , mappingSource . string ( ) ) ; } else { logger . debug ( <str> , index , op , mappingType ) ; } mapperService . merge ( mappingType , mappingSource , false , true ) ; if ( ! mapperService . documentMapper ( mappingType ) . mappingSource ( ) . equals ( mappingSource ) ) { logger . debug ( <str> , index , mappingType , mappingSource , mapperService . documentMapper ( mappingType ) . mappingSource ( ) ) ; requiresRefresh = true ; } } } catch ( Throwable e ) { logger . warn ( <str> , e , index , mappingType , mappingSource ) ; throw e ; } return requiresRefresh ; } private void applyNewOrUpdatedShards ( final ClusterChangedEvent event ) { if ( ! indicesService . changesAllowed ( ) ) { return ; } RoutingTable routingTable = event . state ( ) . routingTable ( ) ; RoutingNodes . RoutingNodeIterator routingNode = event . state ( ) . getRoutingNodes ( ) . routingNodeIter ( event . state ( ) . nodes ( ) . localNodeId ( ) ) ; if ( routingNode = = null ) { failedShards . clear ( ) ; return ; } DiscoveryNodes nodes = event . state ( ) . nodes ( ) ; for ( final ShardRouting shardRouting : routingNode ) { final IndexService indexService = indicesService . indexService ( shardRouting . index ( ) ) ; if ( indexService = = null ) { continue ; } final IndexMetaData indexMetaData = event . state ( ) . metaData ( ) . index ( shardRouting . index ( ) ) ; if ( indexMetaData = = null ) { continue ; } final int shardId = shardRouting . id ( ) ; if ( ! indexService . hasShard ( shardId ) & & shardRouting . started ( ) ) { if ( failedShards . containsKey ( shardRouting . shardId ( ) ) ) { if ( nodes . masterNode ( ) ! = null ) { shardStateAction . resendShardFailed ( shardRouting , indexMetaData . getIndexUUID ( ) , nodes . masterNode ( ) , <str> + nodes . masterNode ( ) + <str> , null , SHARD_STATE_ACTION_LISTENER ) ; } } else { sendFailShard ( shardRouting , indexMetaData . getIndexUUID ( ) , <str> + nodes . masterNode ( ) + <str> , null ) ; } continue ; } IndexShard indexShard = indexService . getShardOrNull ( shardId ) ; if ( indexShard ! = null ) { ShardRouting currentRoutingEntry = indexShard . routingEntry ( ) ; boolean shardHasBeenRemoved = false ; if ( currentRoutingEntry . isSameAllocation ( shardRouting ) = = false ) { logger . debug ( <str> , shardRouting . index ( ) , shardRouting . id ( ) , currentRoutingEntry , shardRouting ) ; indexService . removeShard ( shardRouting . id ( ) , <str> ) ; shardHasBeenRemoved = true ; } else if ( isPeerRecovery ( shardRouting ) ) { final DiscoveryNode sourceNode = findSourceNodeForPeerRecovery ( routingTable , nodes , shardRouting ) ; if ( recoveryTarget . cancelRecoveriesForShard ( indexShard . shardId ( ) , <str> , status - > ! status . sourceNode ( ) . equals ( sourceNode ) ) ) { logger . debug ( <str> , shardRouting . index ( ) , shardRouting . id ( ) , currentRoutingEntry , shardRouting ) ; indexService . removeShard ( shardRouting . id ( ) , <str> ) ; shardHasBeenRemoved = true ; } } if ( shardHasBeenRemoved = = false ) { assert ( shardRouting . primary ( ) & & currentRoutingEntry . primary ( ) = = false ) = = false | | indexShard . allowsPrimaryPromotion ( ) : <str> + shardRouting + <str> + currentRoutingEntry ; indexShard . updateRoutingEntry ( shardRouting , event . state ( ) . blocks ( ) . disableStatePersistence ( ) = = false ) ; } } if ( shardRouting . initializing ( ) ) { applyInitializingShard ( event . state ( ) , indexMetaData , shardRouting ) ; } } } private void cleanFailedShards ( final ClusterChangedEvent event ) { RoutingTable routingTable = event . state ( ) . routingTable ( ) ; RoutingNodes . RoutingNodeIterator routingNode = event . state ( ) . getRoutingNodes ( ) . routingNodeIter ( event . state ( ) . nodes ( ) . localNodeId ( ) ) ; if ( routingNode = = null ) { failedShards . clear ( ) ; return ; } DiscoveryNodes nodes = event . state ( ) . nodes ( ) ; long now = System . currentTimeMillis ( ) ; String localNodeId = nodes . localNodeId ( ) ; Iterator < Map . Entry < ShardId , FailedShard > > iterator = failedShards . entrySet ( ) . iterator ( ) ; shards : while ( iterator . hasNext ( ) ) { Map . Entry < ShardId , FailedShard > entry = iterator . next ( ) ; FailedShard failedShard = entry . getValue ( ) ; IndexRoutingTable indexRoutingTable = routingTable . index ( entry . getKey ( ) . getIndex ( ) ) ; if ( indexRoutingTable ! = null ) { IndexShardRoutingTable shardRoutingTable = indexRoutingTable . shard ( entry . getKey ( ) . id ( ) ) ; if ( shardRoutingTable ! = null ) { for ( ShardRouting shardRouting : shardRoutingTable . assignedShards ( ) ) { if ( localNodeId . equals ( shardRouting . currentNodeId ( ) ) ) { if ( shardRouting . version ( ) = = failedShard . version & & ( ( now - failedShard . timestamp ) < TimeValue . timeValueMinutes ( <int> ) . millis ( ) ) ) { continue shards ; } else { break ; } } } } } iterator . remove ( ) ; } } private void applyInitializingShard ( final ClusterState state , final IndexMetaData indexMetaData , final ShardRouting shardRouting ) { final IndexService indexService = indicesService . indexService ( shardRouting . index ( ) ) ; if ( indexService = = null ) { return ; } final RoutingTable routingTable = state . routingTable ( ) ; final DiscoveryNodes nodes = state . getNodes ( ) ; final int shardId = shardRouting . id ( ) ; if ( indexService . hasShard ( shardId ) ) { IndexShard indexShard = indexService . getShard ( shardId ) ; if ( indexShard . state ( ) = = IndexShardState . STARTED | | indexShard . state ( ) = = IndexShardState . POST_RECOVERY ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , indexShard . shardId ( ) , indexShard . state ( ) , nodes . masterNode ( ) ) ; } if ( nodes . masterNode ( ) ! = null ) { shardStateAction . shardStarted ( shardRouting , indexMetaData . getIndexUUID ( ) , <str> + nodes . masterNode ( ) + <str> + indexShard . state ( ) + <str> , nodes . masterNode ( ) ) ; } return ; } else { if ( indexShard . ignoreRecoveryAttempt ( ) ) { logger . trace ( <str> , indexShard . shardId ( ) , indexShard . state ( ) ) ; return ; } } } DiscoveryNode sourceNode = null ; if ( isPeerRecovery ( shardRouting ) ) { sourceNode = findSourceNodeForPeerRecovery ( routingTable , nodes , shardRouting ) ; if ( sourceNode = = null ) { logger . trace ( <str> , shardRouting . shardId ( ) ) ; return ; } } if ( ! indexService . hasShard ( shardId ) ) { if ( failedShards . containsKey ( shardRouting . shardId ( ) ) ) { if ( nodes . masterNode ( ) ! = null ) { shardStateAction . resendShardFailed ( shardRouting , indexMetaData . getIndexUUID ( ) , nodes . masterNode ( ) , <str> + nodes . masterNode ( ) + <str> , null , SHARD_STATE_ACTION_LISTENER ) ; } return ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , shardRouting . index ( ) , shardId ) ; } IndexShard indexShard = indexService . createShard ( shardRouting ) ; indexShard . addShardFailureCallback ( failedShardHandler ) ; } catch ( IndexShardAlreadyExistsException e ) { } catch ( Throwable e ) { failAndRemoveShard ( shardRouting , indexService . indexUUID ( ) , indexService , true , <str> , e ) ; return ; } } final IndexShard indexShard = indexService . getShard ( shardId ) ; if ( indexShard . ignoreRecoveryAttempt ( ) ) { logger . trace ( <str> , indexShard . shardId ( ) , indexShard . state ( ) ) ; return ; } final RestoreSource restoreSource = shardRouting . restoreSource ( ) ; if ( isPeerRecovery ( shardRouting ) ) { try { assert sourceNode ! = null : <str> ; RecoveryState . Type type = shardRouting . primary ( ) ? RecoveryState . Type . RELOCATION : RecoveryState . Type . REPLICA ; RecoveryState recoveryState = new RecoveryState ( indexShard . shardId ( ) , shardRouting . primary ( ) , type , sourceNode , nodes . localNode ( ) ) ; indexShard . markAsRecovering ( <str> + sourceNode , recoveryState ) ; recoveryTarget . startRecovery ( indexShard , type , sourceNode , new PeerRecoveryListener ( shardRouting , indexService , indexMetaData ) ) ; } catch ( Throwable e ) { indexShard . failShard ( <str> , e ) ; handleRecoveryFailure ( indexService , shardRouting , true , e ) ; } } else if ( restoreSource = = null ) { assert indexShard . routingEntry ( ) . equals ( shardRouting ) ; final RecoveryState recoveryState = new RecoveryState ( indexShard . shardId ( ) , shardRouting . primary ( ) , RecoveryState . Type . STORE , nodes . localNode ( ) , nodes . localNode ( ) ) ; indexShard . markAsRecovering ( <str> , recoveryState ) ; threadPool . generic ( ) . execute ( ( ) - > { try { if ( indexShard . recoverFromStore ( nodes . localNode ( ) ) ) { shardStateAction . shardStarted ( shardRouting , indexMetaData . getIndexUUID ( ) , <str> ) ; } } catch ( Throwable t ) { handleRecoveryFailure ( indexService , shardRouting , true , t ) ; } } ) ; } else { final RecoveryState recoveryState = new RecoveryState ( indexShard . shardId ( ) , shardRouting . primary ( ) , RecoveryState . Type . SNAPSHOT , shardRouting . restoreSource ( ) , nodes . localNode ( ) ) ; indexShard . markAsRecovering ( <str> , recoveryState ) ; threadPool . generic ( ) . execute ( ( ) - > { final ShardId sId = indexShard . shardId ( ) ; try { final IndexShardRepository indexShardRepository = repositoriesService . indexShardRepository ( restoreSource . snapshotId ( ) . getRepository ( ) ) ; if ( indexShard . restoreFromRepository ( indexShardRepository , nodes . localNode ( ) ) ) { restoreService . indexShardRestoreCompleted ( restoreSource . snapshotId ( ) , sId ) ; shardStateAction . shardStarted ( shardRouting , indexMetaData . getIndexUUID ( ) , <str> ) ; } } catch ( Throwable first ) { try { if ( Lucene . isCorruptionException ( first ) ) { restoreService . failRestore ( restoreSource . snapshotId ( ) , sId ) ; } } catch ( Throwable second ) { first . addSuppressed ( second ) ; } finally { handleRecoveryFailure ( indexService , shardRouting , true , first ) ; } } } ) ; } } private DiscoveryNode findSourceNodeForPeerRecovery ( RoutingTable routingTable , DiscoveryNodes nodes , ShardRouting shardRouting ) { DiscoveryNode sourceNode = null ; if ( ! shardRouting . primary ( ) ) { IndexShardRoutingTable shardRoutingTable = routingTable . index ( shardRouting . index ( ) ) . shard ( shardRouting . id ( ) ) ; for ( ShardRouting entry : shardRoutingTable ) { if ( entry . primary ( ) & & entry . active ( ) ) { sourceNode = nodes . get ( entry . currentNodeId ( ) ) ; if ( sourceNode = = null ) { logger . trace ( <str> , entry ) ; return null ; } break ; } } if ( sourceNode = = null ) { logger . trace ( <str> , shardRouting . shardId ( ) ) ; } } else if ( shardRouting . relocatingNodeId ( ) ! = null ) { sourceNode = nodes . get ( shardRouting . relocatingNodeId ( ) ) ; if ( sourceNode = = null ) { logger . trace ( <str> , shardRouting . shardId ( ) , shardRouting . relocatingNodeId ( ) ) ; } } else { throw new IllegalStateException ( <str> + shardRouting ) ; } return sourceNode ; } private boolean isPeerRecovery ( ShardRouting shardRouting ) { return ! shardRouting . primary ( ) | | shardRouting . relocatingNodeId ( ) ! = null ; } private class PeerRecoveryListener implements RecoveryTarget . RecoveryListener { private final ShardRouting shardRouting ; private final IndexService indexService ; private final IndexMetaData indexMetaData ; private PeerRecoveryListener ( ShardRouting shardRouting , IndexService indexService , IndexMetaData indexMetaData ) { this . shardRouting = shardRouting ; this . indexService = indexService ; this . indexMetaData = indexMetaData ; } @Override public void onRecoveryDone ( RecoveryState state ) { shardStateAction . shardStarted ( shardRouting , indexMetaData . getIndexUUID ( ) , <str> + state . getSourceNode ( ) + <str> ) ; } @Override public void onRecoveryFailure ( RecoveryState state , RecoveryFailedException e , boolean sendShardFailure ) { handleRecoveryFailure ( indexService , shardRouting , sendShardFailure , e ) ; } } private void handleRecoveryFailure ( IndexService indexService , ShardRouting shardRouting , boolean sendShardFailure , Throwable failure ) { synchronized ( mutex ) { failAndRemoveShard ( shardRouting , indexService . indexUUID ( ) , indexService , sendShardFailure , <str> , failure ) ; } } private void removeIndex ( String index , String reason ) { try { indicesService . removeIndex ( index , reason ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , reason ) ; } } private void deleteIndex ( String index , String reason ) { try { indicesService . deleteIndex ( index , reason ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , reason ) ; } } private void failAndRemoveShard ( ShardRouting shardRouting , String indexUUID , @Nullable IndexService indexService , boolean sendShardFailure , String message , @Nullable Throwable failure ) { if ( indexService ! = null & & indexService . hasShard ( shardRouting . getId ( ) ) ) { try { indexService . removeShard ( shardRouting . getId ( ) , message ) ; } catch ( ShardNotFoundException e ) { } catch ( Throwable e1 ) { logger . warn ( <str> , e1 , shardRouting . getIndex ( ) , shardRouting . getId ( ) , message ) ; } } if ( sendShardFailure ) { sendFailShard ( shardRouting , indexUUID , message , failure ) ; } } private void sendFailShard ( ShardRouting shardRouting , String indexUUID , String message , @Nullable Throwable failure ) { try { logger . warn ( <str> , failure , shardRouting . shardId ( ) , message ) ; failedShards . put ( shardRouting . shardId ( ) , new FailedShard ( shardRouting . version ( ) ) ) ; shardStateAction . shardFailed ( shardRouting , indexUUID , message , failure , SHARD_STATE_ACTION_LISTENER ) ; } catch ( Throwable e1 ) { logger . warn ( <str> , e1 , shardRouting . getIndex ( ) , shardRouting . getId ( ) , message ) ; } } private class FailedShardHandler implements Callback < IndexShard . ShardFailure > { @Override public void handle ( final IndexShard . ShardFailure shardFailure ) { final IndexService indexService = indicesService . indexService ( shardFailure . routing . shardId ( ) . index ( ) . name ( ) ) ; final ShardRouting shardRouting = shardFailure . routing ; threadPool . generic ( ) . execute ( ( ) - > { synchronized ( mutex ) { failAndRemoveShard ( shardRouting , shardFailure . indexUUID , indexService , true , <str> + shardFailure . reason + <str> , shardFailure . cause ) ; } } ) ; } } } 
