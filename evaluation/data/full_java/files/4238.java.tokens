package org . eclipse . debug . internal . ui . launchConfigurations ; import java . io . IOException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . TransformerException ; import org . eclipse . core . commands . contexts . Context ; import org . eclipse . core . resources . ISaveContext ; import org . eclipse . core . resources . ISaveParticipant ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchDelegate ; import org . eclipse . debug . core . ILaunchListener ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . internal . core . IConfigurationElementConstants ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . core . LaunchManager ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . viewers . AsynchronousSchedulingRuleFactory ; import org . eclipse . debug . internal . ui . views . ViewContextManager ; import org . eclipse . debug . internal . ui . views . ViewContextService ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . contexts . ISuspendTrigger ; import org . eclipse . debug . ui . contexts . ISuspendTriggerListener ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialogWithToggle ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . IPerspectiveDescriptor ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . WorkbenchException ; import org . eclipse . ui . contexts . IContextActivation ; import org . eclipse . ui . contexts . IContextService ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import com . ibm . icu . text . MessageFormat ; public class PerspectiveManager implements ILaunchListener , ISuspendTriggerListener , ISaveParticipant { class PerspectiveContext { private ILaunchConfigurationType fType = null ; private ILaunchDelegate fDelegate = null ; private Map < Set < String > , String > fPerspectives = null ; public PerspectiveContext ( ILaunchConfigurationType type , ILaunchDelegate delegate , Set < String > modes ) { fType = type ; fDelegate = delegate ; fPerspectives = new HashMap < Set < String > , String > ( ) ; fPerspectives . put ( modes , null ) ; } @Override public boolean equals ( Object object ) { ILaunchDelegate delegate = null ; ILaunchConfigurationType type = null ; if ( object instanceof ILaunch ) { try { ILaunch launch = ( ILaunch ) object ; type = launch . getLaunchConfiguration ( ) . getType ( ) ; delegate = resolveLaunchDelegate ( launch ) ; } catch ( CoreException e ) { return false ; } } else if ( object instanceof PerspectiveContext ) { PerspectiveContext context = ( PerspectiveContext ) object ; type = context . getLaunchConfigurationType ( ) ; delegate = context . getLaunchDelegate ( ) ; } if ( fType ! = null & & type ! = null & & fType . getIdentifier ( ) . equals ( type . getIdentifier ( ) ) ) { if ( fDelegate = = null ) { return delegate = = null ; } else { return fDelegate . equals ( delegate ) ; } } return super . equals ( object ) ; } @Override public int hashCode ( ) { if ( fType ! = null ) { int hash = fType . getIdentifier ( ) . hashCode ( ) ; if ( fDelegate ! = null ) { hash + = fDelegate . hashCode ( ) ; } return hash ; } return super . hashCode ( ) ; } public ILaunchConfigurationType getLaunchConfigurationType ( ) { return fType ; } public ILaunchDelegate getLaunchDelegate ( ) { return fDelegate ; } public Map < Set < String > , String > getPersepctiveMap ( ) { return fPerspectives ; } public void setPerspective ( Set < String > modes , String pid ) { if ( fPerspectives = = null ) { fPerspectives = new HashMap < Set < String > , String > ( ) ; } fPerspectives . put ( modes , pid ) ; } public String getPerspective ( Set < String > modes ) { if ( fPerspectives ! = null ) { return fPerspectives . get ( modes ) ; } return null ; } } private abstract class MyUIJob extends Job { public MyUIJob ( String name ) { super ( name ) ; setSystem ( true ) ; setPriority ( Job . INTERACTIVE ) ; setRule ( AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( this ) ) ; } @Override protected IStatus run ( final IProgressMonitor monitor ) { if ( monitor . isCanceled ( ) ) { return Status . CANCEL_STATUS ; } Display asyncDisplay = DebugUIPlugin . getStandardDisplay ( ) ; if ( asyncDisplay = = null | | asyncDisplay . isDisposed ( ) ) { return Status . CANCEL_STATUS ; } asyncDisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { IStatus result = null ; Throwable throwable = null ; try { if ( monitor . isCanceled ( ) ) { result = Status . CANCEL_STATUS ; } else { result = runInUIThread ( monitor ) ; } } catch ( Throwable t ) { throwable = t ; } finally { if ( result = = null ) { result = new Status ( IStatus . ERROR , PlatformUI . PLUGIN_ID , IStatus . ERROR , LaunchConfigurationsMessages . PerspectiveManager_Error_1 , throwable ) ; } done ( result ) ; } } } ) ; return Job . ASYNC_FINISH ; } public abstract IStatus runInUIThread ( IProgressMonitor monitor ) ; } private Set < PerspectiveContext > fPerspectiveContexts = null ; public static final String ATTR_DELEGATE_ID = <str> ; private boolean fPrompting ; private Map < ILaunch , IContextActivation [ ] > fLaunchToContextActivations = new HashMap < ILaunch , IContextActivation [ ] > ( ) ; public void startup ( ) { DebugUIPlugin . getDefault ( ) . addSaveParticipant ( this ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunchListener ( this ) ; initPerspectives ( ) ; } public void shutdown ( ) { DebugUIPlugin . getDefault ( ) . removeSaveParticipant ( this ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunchListener ( this ) ; } @Override public synchronized void launchRemoved ( final ILaunch launch ) { ISuspendTrigger trigger = launch . getAdapter ( ISuspendTrigger . class ) ; if ( trigger ! = null ) { trigger . removeSuspendTriggerListener ( this ) ; } Runnable r = new Runnable ( ) { @Override public void run ( ) { IContextActivation [ ] activations = fLaunchToContextActivations . remove ( launch ) ; if ( activations ! = null ) { for ( int i = <int> ; i < activations . length ; i + + ) { IContextActivation activation = activations [ i ] ; activation . getContextService ( ) . deactivateContext ( activation ) ; } } } } ; async ( r ) ; } @Override public void launchChanged ( ILaunch launch ) { } @Override public synchronized void launchAdded ( ILaunch launch ) { ISuspendTrigger trigger = launch . getAdapter ( ISuspendTrigger . class ) ; if ( trigger ! = null ) { trigger . addSuspendTriggerListener ( this ) ; } String perspectiveId = null ; try { perspectiveId = getPerspectiveId ( launch ) ; } catch ( CoreException e ) { String name = DebugUIPlugin . getModelPresentation ( ) . getText ( launch ) ; switchFailed ( e , name ) ; } ILaunchConfiguration configuration = launch . getLaunchConfiguration ( ) ; if ( configuration ! = null ) { if ( ! LaunchConfigurationManager . isVisible ( configuration ) ) { perspectiveId = null ; } } final String id = perspectiveId ; Job switchJob = new MyUIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { IWorkbenchWindow window = getWindowForPerspective ( id ) ; if ( id ! = null & & window ! = null & & shouldSwitchPerspective ( window , id , IInternalDebugUIConstants . PREF_SWITCH_TO_PERSPECTIVE ) ) { switchToPerspective ( window , id ) ; } return Status . OK_STATUS ; } } ; switchJob . setSystem ( true ) ; switchJob . setPriority ( Job . INTERACTIVE ) ; switchJob . schedule ( ) ; } protected void switchToPerspective ( IWorkbenchWindow window , String id ) { try { Shell dialog = getModalDialogOpen ( window . getShell ( ) ) ; window . getWorkbench ( ) . showPerspective ( id , window ) ; if ( dialog ! = null ) { dialog . setFocus ( ) ; } } catch ( WorkbenchException e ) { DebugUIPlugin . errorDialog ( DebugUIPlugin . getShell ( ) , LaunchConfigurationsMessages . PerspectiveManager_Error_1 , MessageFormat . format ( LaunchConfigurationsMessages . PerspectiveManager_Unable_to_switch_to_perspective___0__2 , new Object [ ] { id } ) , e ) ; } } protected void async ( Runnable r ) { Display d = DebugUIPlugin . getStandardDisplay ( ) ; if ( d ! = null & & ! d . isDisposed ( ) ) { d . asyncExec ( r ) ; } } protected void sync ( Runnable r ) { Display d = DebugUIPlugin . getStandardDisplay ( ) ; if ( d ! = null & & ! d . isDisposed ( ) ) { d . syncExec ( r ) ; } } protected void switchFailed ( final Throwable t , final String launchName ) { sync ( new Runnable ( ) { @Override public void run ( ) { DebugUIPlugin . errorDialog ( DebugUIPlugin . getShell ( ) , LaunchConfigurationsMessages . PerspectiveManager_Error_1 , MessageFormat . format ( LaunchConfigurationsMessages . PerspectiveManager_Unable_to_switch_perpsectives_as_specified_by_launch___0__4 , new Object [ ] { launchName } ) , t ) ; } } ) ; } private void handleBreakpointHit ( final ILaunch launch ) { String perspectiveId = null ; try { perspectiveId = getPerspectiveId ( launch ) ; } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } final String targetId = perspectiveId ; Job switchJob = new MyUIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { IWorkbenchWindow window = null ; if ( targetId ! = null ) { window = getWindowForPerspective ( targetId ) ; if ( window = = null ) { return Status . OK_STATUS ; } if ( shouldSwitchPerspective ( window , targetId , IInternalDebugUIConstants . PREF_SWITCH_PERSPECTIVE_ON_SUSPEND ) ) { switchToPerspective ( window , targetId ) ; window = getWindowForPerspective ( targetId ) ; if ( window = = null ) { return Status . OK_STATUS ; } } Shell shell = window . getShell ( ) ; if ( shell ! = null ) { if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_ACTIVATE_WORKBENCH ) ) { Shell dialog = getModalDialogOpen ( shell ) ; if ( shell . getMinimized ( ) ) { shell . setMinimized ( false ) ; if ( dialog ! = null ) { dialog . setFocus ( ) ; } } if ( dialog = = null ) { shell . forceActive ( ) ; } } } Object ca = fLaunchToContextActivations . get ( launch ) ; if ( ca = = null ) { ILaunchConfiguration launchConfiguration = launch . getLaunchConfiguration ( ) ; if ( launchConfiguration ! = null ) { try { String type = launchConfiguration . getType ( ) . getIdentifier ( ) ; ViewContextService service = ViewContextManager . getDefault ( ) . getService ( window ) ; if ( service ! = null ) { IContextService contextServce = PlatformUI . getWorkbench ( ) . getAdapter ( IContextService . class ) ; String [ ] ids = service . getEnabledPerspectives ( ) ; IContextActivation [ ] activations = new IContextActivation [ ids . length ] ; for ( int i = <int> ; i < ids . length ; i + + ) { Context context = contextServce . getContext ( type + <str> + ids [ i ] ) ; if ( ! context . isDefined ( ) ) { context . define ( context . getId ( ) , null , null ) ; } IContextActivation activation = contextServce . activateContext ( context . getId ( ) ) ; activations [ i ] = activation ; } fLaunchToContextActivations . put ( launch , activations ) ; } } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } } } } if ( window ! = null & & DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_ACTIVATE_DEBUG_VIEW ) ) { ViewContextService service = ViewContextManager . getDefault ( ) . getService ( window ) ; service . showViewQuiet ( IDebugUIConstants . ID_DEBUG_VIEW ) ; } return Status . OK_STATUS ; } } ; switchJob . setSystem ( true ) ; switchJob . setPriority ( Job . INTERACTIVE ) ; switchJob . setRule ( AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( this ) ) ; switchJob . schedule ( ) ; } private Shell getModalDialogOpen ( Shell shell ) { Shell [ ] shells = shell . getShells ( ) ; for ( int i = <int> ; i < shells . length ; i + + ) { Shell dialog = shells [ i ] ; if ( ( dialog . getStyle ( ) & ( SWT . APPLICATION_MODAL | SWT . PRIMARY_MODAL | SWT . SYSTEM_MODAL ) ) > <int> ) { return dialog ; } } return null ; } private IWorkbenchWindow getWindowForPerspective ( String perspectiveId ) { IWorkbenchWindow window = DebugUIPlugin . getActiveWorkbenchWindow ( ) ; if ( isWindowShowingPerspective ( window , perspectiveId ) ) { return window ; } IWorkbenchWindow [ ] windows = PlatformUI . getWorkbench ( ) . getWorkbenchWindows ( ) ; for ( int i = <int> ; i < windows . length ; i + + ) { window = windows [ i ] ; if ( isWindowShowingPerspective ( window , perspectiveId ) ) { return window ; } } window = DebugUIPlugin . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { return window ; } if ( windows . length > <int> ) { return windows [ <int> ] ; } return null ; } private boolean isWindowShowingPerspective ( IWorkbenchWindow window , String perspectiveId ) { if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; if ( page ! = null ) { IPerspectiveDescriptor perspectiveDescriptor = page . getPerspective ( ) ; if ( perspectiveDescriptor ! = null & & perspectiveDescriptor . getId ( ) . equals ( perspectiveId ) ) { return true ; } } } return false ; } private boolean shouldSwitchPerspective ( IWorkbenchWindow window , String perspectiveId , String preferenceKey ) { if ( isCurrentPerspective ( window , perspectiveId ) ) { return false ; } String perspectiveName = getPerspectiveLabel ( perspectiveId ) ; if ( perspectiveName = = null ) { return false ; } String perspectiveDesc = getPerspectiveDescription ( perspectiveId ) ; Object [ ] args ; if ( perspectiveDesc ! = null ) { args = new String [ ] { perspectiveName , perspectiveDesc } ; } else { args = new String [ ] { perspectiveName } ; } String switchPerspective = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( preferenceKey ) ; if ( MessageDialogWithToggle . ALWAYS . equals ( switchPerspective ) ) { return true ; } else if ( MessageDialogWithToggle . NEVER . equals ( switchPerspective ) ) { return false ; } Shell shell = window . getShell ( ) ; if ( shell = = null | | fPrompting ) { return false ; } fPrompting = true ; Shell modal = getModalDialogOpen ( shell ) ; if ( shell . getMinimized ( ) ) { shell . setMinimized ( false ) ; if ( modal ! = null ) { modal . setFocus ( ) ; } } if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_ACTIVATE_WORKBENCH ) ) { if ( modal = = null ) { shell . forceActive ( ) ; } } String message = IInternalDebugCoreConstants . EMPTY_STRING ; if ( IInternalDebugUIConstants . PREF_SWITCH_PERSPECTIVE_ON_SUSPEND . equals ( preferenceKey ) ) { if ( getPerspectiveDescription ( perspectiveId ) ! = null ) { message = LaunchConfigurationsMessages . PerspectiveManager_suspend_description ; } else { message = LaunchConfigurationsMessages . PerspectiveManager_13 ; } } else if ( IInternalDebugUIConstants . PREF_SWITCH_TO_PERSPECTIVE . equals ( preferenceKey ) ) { if ( getPerspectiveDescription ( perspectiveId ) ! = null ) { message = LaunchConfigurationsMessages . PerspectiveManager_launch_description ; } else { message = LaunchConfigurationsMessages . PerspectiveManager_15 ; } } MessageDialogWithToggle dialog = MessageDialogWithToggle . openYesNoQuestion ( shell , LaunchConfigurationsMessages . PerspectiveManager_12 , MessageFormat . format ( message , args ) , null , false , DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) , preferenceKey ) ; boolean answer = ( dialog . getReturnCode ( ) = = IDialogConstants . YES_ID ) ; synchronized ( this ) { fPrompting = false ; notifyAll ( ) ; } if ( isCurrentPerspective ( window , perspectiveId ) ) { answer = false ; } return answer ; } protected boolean isCurrentPerspective ( IWorkbenchWindow window , String perspectiveId ) { boolean isCurrent = false ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; if ( page ! = null ) { IPerspectiveDescriptor perspectiveDescriptor = page . getPerspective ( ) ; if ( perspectiveDescriptor ! = null ) { isCurrent = perspectiveId . equals ( perspectiveDescriptor . getId ( ) ) ; } } } return isCurrent ; } protected String getPerspectiveLabel ( String perspectiveId ) { IPerspectiveDescriptor newPerspective = PlatformUI . getWorkbench ( ) . getPerspectiveRegistry ( ) . findPerspectiveWithId ( perspectiveId ) ; if ( newPerspective = = null ) { return null ; } return newPerspective . getLabel ( ) ; } protected String getPerspectiveDescription ( String perspectiveId ) { IPerspectiveDescriptor newPerspective = PlatformUI . getWorkbench ( ) . getPerspectiveRegistry ( ) . findPerspectiveWithId ( perspectiveId ) ; if ( newPerspective = = null ) { return null ; } return newPerspective . getDescription ( ) ; } protected String getPerspectiveId ( ILaunch launch ) throws CoreException { if ( launch = = null ) { return null ; } ILaunchConfiguration config = launch . getLaunchConfiguration ( ) ; if ( config = = null ) { return null ; } Set < String > modes = launch . getLaunchConfiguration ( ) . getModes ( ) ; modes . add ( launch . getLaunchMode ( ) ) ; String perspectiveId = getLaunchPerspective ( config . getType ( ) , modes , resolveLaunchDelegate ( launch ) ) ; if ( perspectiveId ! = null & & perspectiveId . equals ( IDebugUIConstants . PERSPECTIVE_NONE ) ) { perspectiveId = null ; } return perspectiveId ; } public String getLaunchPerspective ( ILaunchConfigurationType type , Set < String > modes , ILaunchDelegate delegate ) { String id = null ; PerspectiveContext context = findContext ( new PerspectiveContext ( type , delegate , modes ) ) ; if ( context = = null | | ( context ! = null & & ! context . getPersepctiveMap ( ) . containsKey ( modes ) ) ) { context = findContext ( new PerspectiveContext ( type , null , modes ) ) ; if ( context = = null | | ( context ! = null & & ! context . getPersepctiveMap ( ) . containsKey ( modes ) ) ) { return getDefaultLaunchPerspective ( type , delegate , modes ) ; } } if ( context ! = null ) { id = context . getPerspective ( modes ) ; } return id ; } public String getLaunchPerspective ( ILaunchConfigurationType type , String mode ) { HashSet < String > modes = new HashSet < String > ( ) ; modes . add ( mode ) ; return getLaunchPerspective ( type , modes , null ) ; } public void setLaunchPerspective ( ILaunchConfigurationType type , String mode , String perspective ) { HashSet < String > modes = new HashSet < String > ( ) ; modes . add ( mode ) ; setLaunchPerspective ( type , modes , null , perspective ) ; } public void setLaunchPerspective ( ILaunchConfigurationType type , Set < String > modes , ILaunchDelegate delegate , String perspectiveid ) { PerspectiveContext context = new PerspectiveContext ( type , delegate , modes ) ; String id = null ; if ( ! IDebugUIConstants . PERSPECTIVE_NONE . equals ( perspectiveid ) ) { if ( IDebugUIConstants . PERSPECTIVE_DEFAULT . equals ( perspectiveid ) ) { id = getDefaultLaunchPerspective ( type , delegate , modes ) ; } else { id = perspectiveid ; } } PerspectiveContext item = findContext ( context ) ; if ( item ! = null ) { item . setPerspective ( modes , id ) ; } else { context . setPerspective ( modes , id ) ; item = context ; } fPerspectiveContexts . add ( item ) ; } private PerspectiveContext findContext ( PerspectiveContext context ) { for ( PerspectiveContext c : fPerspectiveContexts ) { if ( context . equals ( c ) ) { return c ; } } return null ; } private String generatePerspectiveXML ( ) throws ParserConfigurationException , CoreException { Document doc = DebugUIPlugin . getDocument ( ) ; Element root = doc . createElement ( IConfigurationElementConstants . LAUNCH_PERSPECTIVES ) ; doc . appendChild ( root ) ; Map < Set < String > , String > modesets = null ; Element element = null ; String id = null ; ILaunchConfigurationType type = null ; ILaunchDelegate delegate = null ; for ( PerspectiveContext context : fPerspectiveContexts ) { modesets = context . getPersepctiveMap ( ) ; type = context . getLaunchConfigurationType ( ) ; delegate = context . getLaunchDelegate ( ) ; for ( Set < String > modes : modesets . keySet ( ) ) { id = context . getPerspective ( modes ) ; String defaultId = getDefaultLaunchPerspective ( type , delegate , modes ) ; if ( id = = null & & defaultId ! = null ) { id = IDebugUIConstants . PERSPECTIVE_NONE ; } if ( id ! = null & & ! id . equals ( defaultId ) ) { element = doc . createElement ( IConfigurationElementConstants . LAUNCH_PERSPECTIVE ) ; element . setAttribute ( IConfigurationElementConstants . MODE , createModesetString ( modes ) ) ; if ( delegate ! = null ) { element . setAttribute ( ATTR_DELEGATE_ID , delegate . getId ( ) ) ; } element . setAttribute ( IConfigurationElementConstants . CONFIGURATION_TYPES , type . getIdentifier ( ) ) ; element . setAttribute ( IConfigurationElementConstants . PERSPECTIVE , id ) ; root . appendChild ( element ) ; } } } return DebugPlugin . serializeDocument ( doc ) ; } public String getDefaultLaunchPerspective ( ILaunchConfigurationType type , ILaunchDelegate delegate , Set < String > modes ) { String id = null ; if ( delegate ! = null ) { id = delegate . getPerspectiveId ( modes ) ; } if ( id = = null ) { LaunchConfigurationTabGroupExtension extension = LaunchConfigurationPresentationManager . getDefault ( ) . getExtension ( type . getIdentifier ( ) , modes ) ; if ( extension ! = null ) { id = extension . getPerspective ( modes ) ; if ( id = = null ) { if ( modes . contains ( ILaunchManager . DEBUG_MODE ) ) { id = IDebugUIConstants . ID_DEBUG_PERSPECTIVE ; } } } } return id ; } private ILaunchDelegate resolveLaunchDelegate ( ILaunch launch ) throws CoreException { Set < String > modes = launch . getLaunchConfiguration ( ) . getModes ( ) ; modes . add ( launch . getLaunchMode ( ) ) ; ILaunchConfigurationType type = launch . getLaunchConfiguration ( ) . getType ( ) ; ILaunchDelegate [ ] delegates = LaunchConfigurationManager . filterLaunchDelegates ( type , modes ) ; ILaunchDelegate delegate = null ; if ( delegates . length = = <int> ) { delegate = delegates [ <int> ] ; } else if ( delegates . length > <int> ) { delegate = launch . getLaunchConfiguration ( ) . getPreferredDelegate ( modes ) ; if ( delegate = = null ) { delegate = type . getPreferredDelegate ( modes ) ; } } return delegate ; } private void initPerspectives ( ) { if ( fPerspectiveContexts = = null ) { fPerspectiveContexts = new HashSet < PerspectiveContext > ( ) ; String xml = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IInternalDebugUIConstants . PREF_LAUNCH_PERSPECTIVES ) ; if ( xml ! = null & & xml . length ( ) > <int> ) { try { Element root = DebugPlugin . parseDocument ( xml ) ; NodeList list = root . getChildNodes ( ) ; LaunchManager lm = ( LaunchManager ) DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType lctype = null ; ILaunchDelegate ldelegate = null ; Set < String > modes = null ; Node node = null ; Element element = null ; for ( int i = <int> ; i < list . getLength ( ) ; + + i ) { node = list . item ( i ) ; if ( node . getNodeType ( ) = = Node . ELEMENT_NODE ) { element = ( Element ) node ; String nodeName = element . getNodeName ( ) ; if ( nodeName . equalsIgnoreCase ( IConfigurationElementConstants . LAUNCH_PERSPECTIVE ) ) { String type = element . getAttribute ( IConfigurationElementConstants . CONFIGURATION_TYPES ) ; String mode = element . getAttribute ( IConfigurationElementConstants . MODE ) ; String perspective = element . getAttribute ( IConfigurationElementConstants . PERSPECTIVE ) ; String delegate = element . getAttribute ( ATTR_DELEGATE_ID ) ; lctype = lm . getLaunchConfigurationType ( type ) ; ldelegate = lm . getLaunchDelegate ( delegate ) ; modes = parseModes ( mode ) ; if ( lctype ! = null & & ! modes . isEmpty ( ) & & ! IInternalDebugCoreConstants . EMPTY_STRING . equals ( perspective ) ) { setLaunchPerspective ( lctype , modes , ldelegate , perspective ) ; } } } } } catch ( CoreException e ) { DebugUIPlugin . log ( e ) ; } } } } private Set < String > parseModes ( String modes ) { HashSet < String > modeset = new HashSet < String > ( ) ; String [ ] ms = modes . split ( <str> ) ; for ( int i = <int> ; i < ms . length ; i + + ) { modeset . add ( ms [ i ] . trim ( ) ) ; } return modeset ; } private String createModesetString ( Set < String > modes ) { String str = IInternalDebugCoreConstants . EMPTY_STRING ; if ( modes ! = null ) { for ( Iterator < String > iter = modes . iterator ( ) ; iter . hasNext ( ) ; ) { str + = iter . next ( ) ; if ( iter . hasNext ( ) ) { str + = <str> ; } } } return str ; } public void schedulePostSwitch ( Job job ) { job . setRule ( AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( this ) ) ; job . schedule ( ) ; } @Override public void suspended ( ILaunch launch , Object context ) { handleBreakpointHit ( launch ) ; } @Override public void doneSaving ( ISaveContext context ) { } @Override public void prepareToSave ( ISaveContext context ) throws CoreException { } @Override public void rollback ( ISaveContext context ) { } @Override public void saving ( ISaveContext context ) throws CoreException { try { DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . putValue ( IInternalDebugUIConstants . PREF_LAUNCH_PERSPECTIVES , generatePerspectiveXML ( ) ) ; } catch ( ParserConfigurationException e ) { throw new CoreException ( DebugUIPlugin . newErrorStatus ( <str> , e ) ) ; } } } 
