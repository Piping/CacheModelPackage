package com . badlogic . gdx . utils ; import com . badlogic . gdx . math . MathUtils ; import java . util . BitSet ; public class BooleanArray { public boolean [ ] items ; public int size ; public boolean ordered ; public BooleanArray ( ) { this ( true , <int> ) ; } public BooleanArray ( int capacity ) { this ( true , capacity ) ; } public BooleanArray ( boolean ordered , int capacity ) { this . ordered = ordered ; items = new boolean [ capacity ] ; } public BooleanArray ( BooleanArray array ) { this . ordered = array . ordered ; size = array . size ; items = new boolean [ size ] ; System . arraycopy ( array . items , <int> , items , <int> , size ) ; } public BooleanArray ( boolean [ ] array ) { this ( true , array , <int> , array . length ) ; } public BooleanArray ( boolean ordered , boolean [ ] array , int startIndex , int count ) { this ( ordered , count ) ; size = count ; System . arraycopy ( array , startIndex , items , <int> , count ) ; } public void add ( boolean value ) { boolean [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; items [ size + + ] = value ; } public void addAll ( BooleanArray array ) { addAll ( array , <int> , array . size ) ; } public void addAll ( BooleanArray array , int offset , int length ) { if ( offset + length > array . size ) throw new IllegalArgumentException ( <str> + offset + <str> + length + <str> + array . size ) ; addAll ( array . items , offset , length ) ; } public void addAll ( boolean . . . array ) { addAll ( array , <int> , array . length ) ; } public void addAll ( boolean [ ] array , int offset , int length ) { boolean [ ] items = this . items ; int sizeNeeded = size + length ; if ( sizeNeeded > items . length ) items = resize ( Math . max ( <int> , ( int ) ( sizeNeeded * <float> ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size + = length ; } public boolean get ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; return items [ index ] ; } public void set ( int index , boolean value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] = value ; } public void insert ( int index , boolean value ) { if ( index > size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; boolean [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; if ( ordered ) System . arraycopy ( items , index , items , index + <int> , size - index ) ; else items [ size ] = items [ index ] ; size + + ; items [ index ] = value ; } public void swap ( int first , int second ) { if ( first > = size ) throw new IndexOutOfBoundsException ( <str> + first + <str> + size ) ; if ( second > = size ) throw new IndexOutOfBoundsException ( <str> + second + <str> + size ) ; boolean [ ] items = this . items ; boolean firstValue = items [ first ] ; items [ first ] = items [ second ] ; items [ second ] = firstValue ; } public boolean removeIndex ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; boolean [ ] items = this . items ; boolean value = items [ index ] ; size - - ; if ( ordered ) System . arraycopy ( items , index + <int> , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; } public void removeRange ( int start , int end ) { if ( end > = size ) throw new IndexOutOfBoundsException ( <str> + end + <str> + size ) ; if ( start > end ) throw new IndexOutOfBoundsException ( <str> + start + <str> + end ) ; boolean [ ] items = this . items ; int count = end - start + <int> ; if ( ordered ) System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; else { int lastIndex = this . size - <int> ; for ( int i = <int> ; i < count ; i + + ) items [ start + i ] = items [ lastIndex - i ] ; } size - = count ; } public boolean removeAll ( BooleanArray array ) { int size = this . size ; int startSize = size ; boolean [ ] items = this . items ; for ( int i = <int> , n = array . size ; i < n ; i + + ) { boolean item = array . get ( i ) ; for ( int ii = <int> ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } return size ! = startSize ; } public boolean pop ( ) { return items [ - - size ] ; } public boolean peek ( ) { return items [ size - <int> ] ; } public boolean first ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; return items [ <int> ] ; } public void clear ( ) { size = <int> ; } public boolean [ ] shrink ( ) { if ( items . length ! = size ) resize ( size ) ; return items ; } public boolean [ ] ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > items . length ) resize ( Math . max ( <int> , sizeNeeded ) ) ; return items ; } protected boolean [ ] resize ( int newSize ) { boolean [ ] newItems = new boolean [ newSize ] ; boolean [ ] items = this . items ; System . arraycopy ( items , <int> , newItems , <int> , Math . min ( size , newItems . length ) ) ; this . items = newItems ; return newItems ; } public void reverse ( ) { boolean [ ] items = this . items ; for ( int i = <int> , lastIndex = size - <int> , n = size / <int> ; i < n ; i + + ) { int ii = lastIndex - i ; boolean temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void shuffle ( ) { boolean [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) { int ii = MathUtils . random ( i ) ; boolean temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void truncate ( int newSize ) { if ( size > newSize ) size = newSize ; } public boolean random ( ) { if ( size = = <int> ) return false ; return items [ MathUtils . random ( <int> , size - <int> ) ] ; } public boolean [ ] toArray ( ) { boolean [ ] array = new boolean [ size ] ; System . arraycopy ( items , <int> , array , <int> , size ) ; return array ; } public int hashCode ( ) { if ( ! ordered ) return super . hashCode ( ) ; boolean [ ] items = this . items ; int h = <int> ; for ( int i = <int> , n = size ; i < n ; i + + ) h = h * <int> + ( items [ i ] ? <int> : <int> ) ; return h ; } public boolean equals ( Object object ) { if ( object = = this ) return true ; if ( ! ordered ) return false ; if ( ! ( object instanceof BooleanArray ) ) return false ; BooleanArray array = ( BooleanArray ) object ; if ( ! array . ordered ) return false ; int n = size ; if ( n ! = array . size ) return false ; boolean [ ] items1 = this . items ; boolean [ ] items2 = array . items ; for ( int i = <int> ; i < n ; i + + ) if ( items1 [ i ] ! = items2 [ i ] ) return false ; return true ; } public String toString ( ) { if ( size = = <int> ) return <str> ; boolean [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( <str> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( <str> ) ; buffer . append ( items [ i ] ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } public String toString ( String separator ) { if ( size = = <int> ) return <str> ; boolean [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( separator ) ; buffer . append ( items [ i ] ) ; } return buffer . toString ( ) ; } static public BooleanArray with ( boolean . . . array ) { return new BooleanArray ( array ) ; } } 
