package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . tokenattributes . TermToBytesRefAttribute ; @Deprecated public final class IndexableBinaryStringTools { private static final CodingCase [ ] CODING_CASES = { new CodingCase ( <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> , <int> ) , new CodingCase ( <int> , <int> ) } ; private IndexableBinaryStringTools ( ) { } public static int getEncodedLength ( byte [ ] inputArray , int inputOffset , int inputLength ) { return ( int ) ( ( <int> * inputLength + <int> ) / <int> ) + <int> ; } public static int getDecodedLength ( char [ ] encoded , int offset , int length ) { final int numChars = length - <int> ; if ( numChars < = <int> ) { return <int> ; } else { final long numFullBytesInFinalChar = encoded [ offset + length - <int> ] ; final long numEncodedChars = numChars - <int> ; return ( int ) ( ( numEncodedChars * <int> + <int> ) / <int> + numFullBytesInFinalChar ) ; } } public static void encode ( byte [ ] inputArray , int inputOffset , int inputLength , char [ ] outputArray , int outputOffset , int outputLength ) { assert ( outputLength = = getEncodedLength ( inputArray , inputOffset , inputLength ) ) ; if ( inputLength > <int> ) { int inputByteNum = inputOffset ; int caseNum = <int> ; int outputCharNum = outputOffset ; CodingCase codingCase ; for ( ; inputByteNum + CODING_CASES [ caseNum ] . numBytes < = inputLength ; + + outputCharNum ) { codingCase = CODING_CASES [ caseNum ] ; if ( <int> = = codingCase . numBytes ) { outputArray [ outputCharNum ] = ( char ) ( ( ( inputArray [ inputByteNum ] & <hex> ) < < codingCase . initialShift ) + ( ( ( inputArray [ inputByteNum + <int> ] & <hex> ) > > > codingCase . finalShift ) & codingCase . finalMask ) & ( short ) <hex> ) ; } else { outputArray [ outputCharNum ] = ( char ) ( ( ( inputArray [ inputByteNum ] & <hex> ) < < codingCase . initialShift ) + ( ( inputArray [ inputByteNum + <int> ] & <hex> ) < < codingCase . middleShift ) + ( ( ( inputArray [ inputByteNum + <int> ] & <hex> ) > > > codingCase . finalShift ) & codingCase . finalMask ) & ( short ) <hex> ) ; } inputByteNum + = codingCase . advanceBytes ; if ( + + caseNum = = CODING_CASES . length ) { caseNum = <int> ; } } codingCase = CODING_CASES [ caseNum ] ; if ( inputByteNum + <int> < inputLength ) { outputArray [ outputCharNum + + ] = ( char ) ( ( ( ( inputArray [ inputByteNum ] & <hex> ) < < codingCase . initialShift ) + ( ( inputArray [ inputByteNum + <int> ] & <hex> ) < < codingCase . middleShift ) ) & ( short ) <hex> ) ; outputArray [ outputCharNum + + ] = ( char ) <int> ; } else if ( inputByteNum < inputLength ) { outputArray [ outputCharNum + + ] = ( char ) ( ( ( inputArray [ inputByteNum ] & <hex> ) < < codingCase . initialShift ) & ( short ) <hex> ) ; outputArray [ outputCharNum + + ] = caseNum = = <int> ? ( char ) <int> : ( char ) <int> ; } else { outputArray [ outputCharNum + + ] = ( char ) <int> ; } } } public static void decode ( char [ ] inputArray , int inputOffset , int inputLength , byte [ ] outputArray , int outputOffset , int outputLength ) { assert ( outputLength = = getDecodedLength ( inputArray , inputOffset , inputLength ) ) ; final int numInputChars = inputLength - <int> ; final int numOutputBytes = outputLength ; if ( numOutputBytes > <int> ) { int caseNum = <int> ; int outputByteNum = outputOffset ; int inputCharNum = inputOffset ; short inputChar ; CodingCase codingCase ; for ( ; inputCharNum < numInputChars - <int> ; + + inputCharNum ) { codingCase = CODING_CASES [ caseNum ] ; inputChar = ( short ) inputArray [ inputCharNum ] ; if ( <int> = = codingCase . numBytes ) { if ( <int> = = caseNum ) { outputArray [ outputByteNum ] = ( byte ) ( inputChar > > > codingCase . initialShift ) ; } else { outputArray [ outputByteNum ] + = ( byte ) ( inputChar > > > codingCase . initialShift ) ; } outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . finalMask ) < < codingCase . finalShift ) ; } else { outputArray [ outputByteNum ] + = ( byte ) ( inputChar > > > codingCase . initialShift ) ; outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . middleMask ) > > > codingCase . middleShift ) ; outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . finalMask ) < < codingCase . finalShift ) ; } outputByteNum + = codingCase . advanceBytes ; if ( + + caseNum = = CODING_CASES . length ) { caseNum = <int> ; } } inputChar = ( short ) inputArray [ inputCharNum ] ; codingCase = CODING_CASES [ caseNum ] ; if ( <int> = = caseNum ) { outputArray [ outputByteNum ] = <int> ; } outputArray [ outputByteNum ] + = ( byte ) ( inputChar > > > codingCase . initialShift ) ; final int bytesLeft = numOutputBytes - outputByteNum ; if ( bytesLeft > <int> ) { if ( <int> = = codingCase . numBytes ) { outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . finalMask ) > > > codingCase . finalShift ) ; } else { outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . middleMask ) > > > codingCase . middleShift ) ; if ( bytesLeft > <int> ) { outputArray [ outputByteNum + <int> ] = ( byte ) ( ( inputChar & codingCase . finalMask ) < < codingCase . finalShift ) ; } } } } } static class CodingCase { int numBytes , initialShift , middleShift , finalShift , advanceBytes = <int> ; short middleMask , finalMask ; CodingCase ( int initialShift , int middleShift , int finalShift ) { this . numBytes = <int> ; this . initialShift = initialShift ; this . middleShift = middleShift ; this . finalShift = finalShift ; this . finalMask = ( short ) ( ( short ) <hex> > > > finalShift ) ; this . middleMask = ( short ) ( ( short ) <hex> < < middleShift ) ; } CodingCase ( int initialShift , int finalShift ) { this . numBytes = <int> ; this . initialShift = initialShift ; this . finalShift = finalShift ; this . finalMask = ( short ) ( ( short ) <hex> > > > finalShift ) ; if ( finalShift ! = <int> ) { advanceBytes = <int> ; } } } } 
