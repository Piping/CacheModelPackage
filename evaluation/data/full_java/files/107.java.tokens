package org . apache . cassandra . concurrent ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . locks . LockSupport ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . utils . JVMStabilityInspector ; final class SEPWorker extends AtomicReference < SEPWorker . Work > implements Runnable { private static final Logger logger = LoggerFactory . getLogger ( SEPWorker . class ) ; final Long workerId ; final Thread thread ; final SharedExecutorPool pool ; long prevStopCheck = <int> ; long soleSpinnerSpinTime = <int> ; SEPWorker ( Long workerId , Work initialState , SharedExecutorPool pool ) { this . pool = pool ; this . workerId = workerId ; thread = new Thread ( this , pool . poolName + <str> + workerId ) ; thread . setDaemon ( true ) ; set ( initialState ) ; thread . start ( ) ; } public void run ( ) { SEPExecutor assigned = null ; Runnable task = null ; try { while ( true ) { if ( isSpinning ( ) & & ! selfAssign ( ) ) { doWaitSpin ( ) ; continue ; } if ( stop ( ) ) while ( isStopped ( ) ) LockSupport . park ( ) ; assigned = get ( ) . assigned ; if ( assigned = = null ) continue ; task = assigned . tasks . poll ( ) ; set ( Work . WORKING ) ; boolean shutdown ; while ( true ) { assigned . maybeSchedule ( ) ; task . run ( ) ; task = null ; if ( ( shutdown = assigned . shuttingDown ) | | ! assigned . takeTaskPermit ( ) ) break ; task = assigned . tasks . poll ( ) ; } assigned . returnWorkPermit ( ) ; if ( shutdown & & assigned . getActiveCount ( ) = = <int> ) assigned . shutdown . signalAll ( ) ; assigned = null ; if ( ! selfAssign ( ) ) startSpinning ( ) ; } } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; while ( true ) { if ( get ( ) . assigned ! = null ) { assigned = get ( ) . assigned ; set ( Work . WORKING ) ; } if ( assign ( Work . STOPPED , true ) ) break ; } if ( assigned ! = null ) assigned . returnWorkPermit ( ) ; if ( task ! = null ) logger . error ( <str> , t ) ; else logger . error ( <str> , t ) ; } } boolean assign ( Work work , boolean self ) { Work state = get ( ) ; while ( state . canAssign ( self ) ) { if ( ! compareAndSet ( state , work ) ) { state = get ( ) ; continue ; } if ( state . isSpinning ( ) ) stopSpinning ( ) ; if ( work . isStop ( ) ) pool . descheduled . put ( workerId , this ) ; if ( state . isStopped ( ) & & ( ! work . isStop ( ) | | ! stop ( ) ) ) LockSupport . unpark ( thread ) ; return true ; } return false ; } private boolean selfAssign ( ) { if ( ! get ( ) . canAssign ( true ) ) return false ; for ( SEPExecutor exec : pool . executors ) { if ( exec . takeWorkPermit ( true ) ) { Work work = new Work ( exec ) ; if ( assign ( work , true ) ) return true ; pool . schedule ( work ) ; assert get ( ) . assigned ! = null ; return true ; } } return false ; } private void startSpinning ( ) { assert get ( ) = = Work . WORKING ; pool . spinningCount . incrementAndGet ( ) ; set ( Work . SPINNING ) ; } private void stopSpinning ( ) { if ( pool . spinningCount . decrementAndGet ( ) = = <int> ) for ( SEPExecutor executor : pool . executors ) executor . maybeSchedule ( ) ; prevStopCheck = soleSpinnerSpinTime = <int> ; } private void doWaitSpin ( ) { long sleep = <int> * pool . spinningCount . get ( ) ; sleep = Math . min ( <int> , sleep ) ; sleep * = Math . random ( ) ; sleep = Math . max ( <int> , sleep ) ; long start = System . nanoTime ( ) ; Long target = start + sleep ; if ( pool . spinning . putIfAbsent ( target , this ) ! = null ) return ; LockSupport . parkNanos ( sleep ) ; pool . spinning . remove ( target , this ) ; long end = System . nanoTime ( ) ; long spin = end - start ; long stopCheck = pool . stopCheck . addAndGet ( spin ) ; maybeStop ( stopCheck , end ) ; if ( prevStopCheck + spin = = stopCheck ) soleSpinnerSpinTime + = spin ; else soleSpinnerSpinTime = <int> ; prevStopCheck = stopCheck ; } private static final long stopCheckInterval = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; private void maybeStop ( long stopCheck , long now ) { long delta = now - stopCheck ; if ( delta < = <int> ) { if ( pool . stopCheck . compareAndSet ( stopCheck , now - stopCheckInterval ) ) { if ( ! assign ( Work . STOP_SIGNALLED , true ) ) pool . schedule ( Work . STOP_SIGNALLED ) ; } } else if ( soleSpinnerSpinTime > stopCheckInterval & & pool . spinningCount . get ( ) = = <int> ) { assign ( Work . STOP_SIGNALLED , true ) ; } else { while ( delta > stopCheckInterval * <int> & & ! pool . stopCheck . compareAndSet ( stopCheck , now - stopCheckInterval ) ) { stopCheck = pool . stopCheck . get ( ) ; delta = now - stopCheck ; } } } private boolean isSpinning ( ) { return get ( ) . isSpinning ( ) ; } private boolean stop ( ) { return get ( ) . isStop ( ) & & compareAndSet ( Work . STOP_SIGNALLED , Work . STOPPED ) ; } private boolean isStopped ( ) { return get ( ) . isStopped ( ) ; } static final class Work { static final Work STOP_SIGNALLED = new Work ( ) ; static final Work STOPPED = new Work ( ) ; static final Work SPINNING = new Work ( ) ; static final Work WORKING = new Work ( ) ; final SEPExecutor assigned ; Work ( SEPExecutor executor ) { this . assigned = executor ; } private Work ( ) { this . assigned = null ; } boolean canAssign ( boolean self ) { return assigned = = null & & ( self | | ! isWorking ( ) ) ; } boolean isSpinning ( ) { return this = = Work . SPINNING ; } boolean isWorking ( ) { return this = = Work . WORKING ; } boolean isStop ( ) { return this = = Work . STOP_SIGNALLED ; } boolean isStopped ( ) { return this = = Work . STOPPED ; } boolean isAssigned ( ) { return assigned ! = null ; } } } 
