package org . elasticsearch . search . aggregations . metrics . geocentroid ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . GeoUtils ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . LongArray ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . metrics . MetricsAggregator ; import org . elasticsearch . search . aggregations . metrics . geobounds . InternalGeoBounds ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public final class GeoCentroidAggregator extends MetricsAggregator { private final ValuesSource . GeoPoint valuesSource ; LongArray centroids ; LongArray counts ; protected GeoCentroidAggregator ( String name , AggregationContext aggregationContext , Aggregator parent , ValuesSource . GeoPoint valuesSource , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , aggregationContext , parent , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; if ( valuesSource ! = null ) { final BigArrays bigArrays = context . bigArrays ( ) ; centroids = bigArrays . newLongArray ( <int> , true ) ; counts = bigArrays . newLongArray ( <int> , true ) ; } } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , LeafBucketCollector sub ) throws IOException { if ( valuesSource = = null ) { return LeafBucketCollector . NO_OP_COLLECTOR ; } final BigArrays bigArrays = context . bigArrays ( ) ; final MultiGeoPointValues values = valuesSource . geoPointValues ( ctx ) ; return new LeafBucketCollectorBase ( sub , values ) { @Override public void collect ( int doc , long bucket ) throws IOException { centroids = bigArrays . grow ( centroids , bucket + <int> ) ; counts = bigArrays . grow ( counts , bucket + <int> ) ; values . setDocument ( doc ) ; final int valueCount = values . count ( ) ; if ( valueCount > <int> ) { double [ ] pt = new double [ <int> ] ; long prevCounts = counts . get ( bucket ) ; counts . increment ( bucket , valueCount ) ; if ( prevCounts > <int> ) { final GeoPoint centroid = GeoPoint . fromIndexLong ( centroids . get ( bucket ) ) ; pt [ <int> ] = centroid . lon ( ) ; pt [ <int> ] = centroid . lat ( ) ; } for ( int i = <int> ; i < valueCount ; + + i ) { GeoPoint value = values . valueAt ( i ) ; pt [ <int> ] = pt [ <int> ] + ( value . getLon ( ) - pt [ <int> ] ) / + + prevCounts ; pt [ <int> ] = pt [ <int> ] + ( value . getLat ( ) - pt [ <int> ] ) / prevCounts ; } centroids . set ( bucket , GeoUtils . mortonHash ( pt [ <int> ] , pt [ <int> ] ) ) ; } } } ; } @Override public InternalAggregation buildAggregation ( long bucket ) { if ( valuesSource = = null | | bucket > = centroids . size ( ) ) { return buildEmptyAggregation ( ) ; } final long bucketCount = counts . get ( bucket ) ; final GeoPoint bucketCentroid = ( bucketCount > <int> ) ? GeoPoint . fromIndexLong ( centroids . get ( bucket ) ) : new GeoPoint ( Double . NaN , Double . NaN ) ; return new InternalGeoCentroid ( name , bucketCentroid , bucketCount , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalGeoCentroid ( name , null , <int> l , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public void doClose ( ) { Releasables . close ( centroids , counts ) ; } public static class Factory extends ValuesSourceAggregatorFactory . LeafOnly < ValuesSource . GeoPoint > { protected Factory ( String name , ValuesSourceConfig < ValuesSource . GeoPoint > config ) { super ( name , InternalGeoBounds . TYPE . name ( ) , config ) ; } @Override protected Aggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new GeoCentroidAggregator ( name , aggregationContext , parent , null , pipelineAggregators , metaData ) ; } @Override protected Aggregator doCreateInternal ( ValuesSource . GeoPoint valuesSource , AggregationContext aggregationContext , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new GeoCentroidAggregator ( name , aggregationContext , parent , valuesSource , pipelineAggregators , metaData ) ; } } } 
