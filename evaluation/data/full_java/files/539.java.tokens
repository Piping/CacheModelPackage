package org . apache . cassandra . dht ; import java . io . IOException ; import java . net . InetAddress ; import java . util . * ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . util . concurrent . ListenableFuture ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . dht . tokenallocator . TokenAllocation ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . FailureDetector ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . streaming . * ; import org . apache . cassandra . utils . progress . ProgressEvent ; import org . apache . cassandra . utils . progress . ProgressEventNotifierSupport ; import org . apache . cassandra . utils . progress . ProgressEventType ; public class BootStrapper extends ProgressEventNotifierSupport { private static final Logger logger = LoggerFactory . getLogger ( BootStrapper . class ) ; protected final InetAddress address ; protected final Collection < Token > tokens ; protected final TokenMetadata tokenMetadata ; public BootStrapper ( InetAddress address , Collection < Token > tokens , TokenMetadata tmd ) { assert address ! = null ; assert tokens ! = null & & ! tokens . isEmpty ( ) ; this . address = address ; this . tokens = tokens ; this . tokenMetadata = tmd ; } public ListenableFuture < StreamState > bootstrap ( StreamStateStore stateStore , boolean useStrictConsistency ) { logger . trace ( <str> ) ; RangeStreamer streamer = new RangeStreamer ( tokenMetadata , tokens , address , <str> , useStrictConsistency , DatabaseDescriptor . getEndpointSnitch ( ) , stateStore ) ; streamer . addSourceFilter ( new RangeStreamer . FailureDetectorSourceFilter ( FailureDetector . instance ) ) ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { AbstractReplicationStrategy strategy = Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) ; streamer . addRanges ( keyspaceName , strategy . getPendingAddressRanges ( tokenMetadata , tokens , address ) ) ; } StreamResultFuture bootstrapStreamResult = streamer . fetchAsync ( ) ; bootstrapStreamResult . addEventListener ( new StreamEventHandler ( ) { private final AtomicInteger receivedFiles = new AtomicInteger ( ) ; private final AtomicInteger totalFilesToReceive = new AtomicInteger ( ) ; @Override public void handleStreamEvent ( StreamEvent event ) { switch ( event . eventType ) { case STREAM_PREPARED : StreamEvent . SessionPreparedEvent prepared = ( StreamEvent . SessionPreparedEvent ) event ; int currentTotal = totalFilesToReceive . addAndGet ( ( int ) prepared . session . getTotalFilesToReceive ( ) ) ; ProgressEvent prepareProgress = new ProgressEvent ( ProgressEventType . PROGRESS , receivedFiles . get ( ) , currentTotal , <str> + prepared . session . peer + <str> ) ; fireProgressEvent ( <str> , prepareProgress ) ; break ; case FILE_PROGRESS : StreamEvent . ProgressEvent progress = ( StreamEvent . ProgressEvent ) event ; if ( progress . progress . isCompleted ( ) ) { int received = receivedFiles . incrementAndGet ( ) ; ProgressEvent currentProgress = new ProgressEvent ( ProgressEventType . PROGRESS , received , totalFilesToReceive . get ( ) , <str> + progress . progress . fileName ) ; fireProgressEvent ( <str> , currentProgress ) ; } break ; case STREAM_COMPLETE : StreamEvent . SessionCompleteEvent completeEvent = ( StreamEvent . SessionCompleteEvent ) event ; ProgressEvent completeProgress = new ProgressEvent ( ProgressEventType . PROGRESS , receivedFiles . get ( ) , totalFilesToReceive . get ( ) , <str> + completeEvent . peer + <str> ) ; fireProgressEvent ( <str> , completeProgress ) ; break ; } } @Override public void onSuccess ( StreamState streamState ) { ProgressEventType type ; String message ; if ( streamState . hasFailedSession ( ) ) { type = ProgressEventType . ERROR ; message = <str> ; } else { type = ProgressEventType . SUCCESS ; message = <str> ; } ProgressEvent currentProgress = new ProgressEvent ( type , receivedFiles . get ( ) , totalFilesToReceive . get ( ) , message ) ; fireProgressEvent ( <str> , currentProgress ) ; } @Override public void onFailure ( Throwable throwable ) { ProgressEvent currentProgress = new ProgressEvent ( ProgressEventType . ERROR , receivedFiles . get ( ) , totalFilesToReceive . get ( ) , throwable . getMessage ( ) ) ; fireProgressEvent ( <str> , currentProgress ) ; } } ) ; return bootstrapStreamResult ; } public static Collection < Token > getBootstrapTokens ( final TokenMetadata metadata , InetAddress address ) throws ConfigurationException { String allocationKeyspace = DatabaseDescriptor . getAllocateTokensForKeyspace ( ) ; Collection < String > initialTokens = DatabaseDescriptor . getInitialTokens ( ) ; if ( initialTokens . size ( ) > <int> & & allocationKeyspace ! = null ) logger . warn ( <str> ) ; if ( initialTokens . size ( ) > <int> ) return getSpecifiedTokens ( metadata , initialTokens ) ; int numTokens = DatabaseDescriptor . getNumTokens ( ) ; if ( numTokens < <int> ) throw new ConfigurationException ( <str> ) ; if ( allocationKeyspace ! = null ) return allocateTokens ( metadata , address , allocationKeyspace , numTokens ) ; if ( numTokens = = <int> ) logger . warn ( <str> ) ; return getRandomTokens ( metadata , numTokens ) ; } private static Collection < Token > getSpecifiedTokens ( final TokenMetadata metadata , Collection < String > initialTokens ) { logger . trace ( <str> , initialTokens ) ; List < Token > tokens = new ArrayList < > ( initialTokens . size ( ) ) ; for ( String tokenString : initialTokens ) { Token token = metadata . partitioner . getTokenFactory ( ) . fromString ( tokenString ) ; if ( metadata . getEndpoint ( token ) ! = null ) throw new ConfigurationException ( <str> + tokenString + <str> ) ; tokens . add ( token ) ; } return tokens ; } static Collection < Token > allocateTokens ( final TokenMetadata metadata , InetAddress address , String allocationKeyspace , int numTokens ) { Keyspace ks = Keyspace . open ( allocationKeyspace ) ; if ( ks = = null ) throw new ConfigurationException ( <str> + allocationKeyspace ) ; AbstractReplicationStrategy rs = ks . getReplicationStrategy ( ) ; return TokenAllocation . allocateTokens ( metadata , rs , address , numTokens ) ; } public static Collection < Token > getRandomTokens ( TokenMetadata metadata , int numTokens ) { Set < Token > tokens = new HashSet < > ( numTokens ) ; while ( tokens . size ( ) < numTokens ) { Token token = metadata . partitioner . getRandomToken ( ) ; if ( metadata . getEndpoint ( token ) = = null ) tokens . add ( token ) ; } return tokens ; } public static class StringSerializer implements IVersionedSerializer < String > { public static final StringSerializer instance = new StringSerializer ( ) ; public void serialize ( String s , DataOutputPlus out , int version ) throws IOException { out . writeUTF ( s ) ; } public String deserialize ( DataInputPlus in , int version ) throws IOException { return in . readUTF ( ) ; } public long serializedSize ( String s , int version ) { return TypeSizes . sizeof ( s ) ; } } } 
