package io . netty . channel . epoll ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . ServerChannel ; import io . netty . util . ReferenceCountUtil ; import org . junit . Assert ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class EpollSocketChannelTest { @Test public void testTcpInfo ( ) throws Exception { EventLoopGroup group = new EpollEventLoopGroup ( <int> ) ; try { Bootstrap bootstrap = new Bootstrap ( ) ; EpollSocketChannel ch = ( EpollSocketChannel ) bootstrap . group ( group ) . channel ( EpollSocketChannel . class ) . handler ( new ChannelInboundHandlerAdapter ( ) ) . bind ( new InetSocketAddress ( <int> ) ) . syncUninterruptibly ( ) . channel ( ) ; EpollTcpInfo info = ch . tcpInfo ( ) ; assertTcpInfo0 ( info ) ; ch . close ( ) . syncUninterruptibly ( ) ; } finally { group . shutdownGracefully ( ) ; } } @Test public void testTcpInfoReuse ( ) throws Exception { EventLoopGroup group = new EpollEventLoopGroup ( <int> ) ; try { Bootstrap bootstrap = new Bootstrap ( ) ; EpollSocketChannel ch = ( EpollSocketChannel ) bootstrap . group ( group ) . channel ( EpollSocketChannel . class ) . handler ( new ChannelInboundHandlerAdapter ( ) ) . bind ( new InetSocketAddress ( <int> ) ) . syncUninterruptibly ( ) . channel ( ) ; EpollTcpInfo info = new EpollTcpInfo ( ) ; ch . tcpInfo ( info ) ; assertTcpInfo0 ( info ) ; ch . close ( ) . syncUninterruptibly ( ) ; } finally { group . shutdownGracefully ( ) ; } } private static void assertTcpInfo0 ( EpollTcpInfo info ) throws Exception { Assert . assertNotNull ( info ) ; Assert . assertTrue ( info . state ( ) > = <int> ) ; Assert . assertTrue ( info . caState ( ) > = <int> ) ; Assert . assertTrue ( info . retransmits ( ) > = <int> ) ; Assert . assertTrue ( info . probes ( ) > = <int> ) ; Assert . assertTrue ( info . backoff ( ) > = <int> ) ; Assert . assertTrue ( info . options ( ) > = <int> ) ; Assert . assertTrue ( info . sndWscale ( ) > = <int> ) ; Assert . assertTrue ( info . rcvWscale ( ) > = <int> ) ; Assert . assertTrue ( info . rto ( ) > = <int> ) ; Assert . assertTrue ( info . ato ( ) > = <int> ) ; Assert . assertTrue ( info . sndMss ( ) > = <int> ) ; Assert . assertTrue ( info . rcvMss ( ) > = <int> ) ; Assert . assertTrue ( info . unacked ( ) > = <int> ) ; Assert . assertTrue ( info . sacked ( ) > = <int> ) ; Assert . assertTrue ( info . lost ( ) > = <int> ) ; Assert . assertTrue ( info . retrans ( ) > = <int> ) ; Assert . assertTrue ( info . fackets ( ) > = <int> ) ; Assert . assertTrue ( info . lastDataSent ( ) > = <int> ) ; Assert . assertTrue ( info . lastAckSent ( ) > = <int> ) ; Assert . assertTrue ( info . lastDataRecv ( ) > = <int> ) ; Assert . assertTrue ( info . lastAckRecv ( ) > = <int> ) ; Assert . assertTrue ( info . pmtu ( ) > = <int> ) ; Assert . assertTrue ( info . rcvSsthresh ( ) > = <int> ) ; Assert . assertTrue ( info . rtt ( ) > = <int> ) ; Assert . assertTrue ( info . rttvar ( ) > = <int> ) ; Assert . assertTrue ( info . sndSsthresh ( ) > = <int> ) ; Assert . assertTrue ( info . sndCwnd ( ) > = <int> ) ; Assert . assertTrue ( info . advmss ( ) > = <int> ) ; Assert . assertTrue ( info . reordering ( ) > = <int> ) ; Assert . assertTrue ( info . rcvRtt ( ) > = <int> ) ; Assert . assertTrue ( info . rcvSpace ( ) > = <int> ) ; Assert . assertTrue ( info . totalRetrans ( ) > = <int> ) ; } @Test public void testExceptionHandlingDoesNotInfiniteLoop ( ) throws InterruptedException { EventLoopGroup group = new EpollEventLoopGroup ( ) ; try { runExceptionHandleFeedbackLoop ( group , EpollServerSocketChannel . class , EpollSocketChannel . class , new InetSocketAddress ( <int> ) ) ; runExceptionHandleFeedbackLoop ( group , EpollServerDomainSocketChannel . class , EpollDomainSocketChannel . class , EpollSocketTestPermutation . newSocketAddress ( ) ) ; } finally { group . shutdownGracefully ( ) ; } } private void runExceptionHandleFeedbackLoop ( EventLoopGroup group , Class < ? extends ServerChannel > serverChannelClass , Class < ? extends Channel > channelClass , SocketAddress bindAddr ) throws InterruptedException { Channel serverChannel = null ; Channel clientChannel = null ; try { MyInitializer serverInitializer = new MyInitializer ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . option ( ChannelOption . SO_BACKLOG , <int> ) ; sb . group ( group ) . channel ( serverChannelClass ) . childHandler ( serverInitializer ) ; serverChannel = sb . bind ( bindAddr ) . syncUninterruptibly ( ) . channel ( ) ; Bootstrap b = new Bootstrap ( ) ; b . group ( group ) ; b . channel ( channelClass ) ; b . remoteAddress ( serverChannel . localAddress ( ) ) ; b . handler ( new MyInitializer ( ) ) ; clientChannel = b . connect ( ) . syncUninterruptibly ( ) . channel ( ) ; clientChannel . writeAndFlush ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ; assertTrue ( serverInitializer . exceptionHandler . latch1 . await ( <int> , TimeUnit . SECONDS ) ) ; assertFalse ( <str> + serverInitializer . exceptionHandler . count . get ( ) + <str> , serverInitializer . exceptionHandler . latch2 . await ( <int> , TimeUnit . SECONDS ) ) ; } finally { if ( serverChannel ! = null ) { serverChannel . close ( ) . syncUninterruptibly ( ) ; } if ( clientChannel ! = null ) { clientChannel . close ( ) . syncUninterruptibly ( ) ; } } } private static class MyInitializer extends ChannelInitializer < Channel > { final ExceptionHandler exceptionHandler = new ExceptionHandler ( ) ; @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; pipeline . addLast ( new BuggyChannelHandler ( ) ) ; pipeline . addLast ( exceptionHandler ) ; } } private static class BuggyChannelHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ReferenceCountUtil . release ( msg ) ; throw new NullPointerException ( <str> ) ; } } private static class ExceptionHandler extends ChannelInboundHandlerAdapter { final AtomicLong count = new AtomicLong ( ) ; final CountDownLatch latch1 = new CountDownLatch ( <int> ) ; final CountDownLatch latch2 = new CountDownLatch ( <int> ) ; @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( count . incrementAndGet ( ) < = <int> ) { latch1 . countDown ( ) ; } else { latch2 . countDown ( ) ; } ctx . close ( ) ; } } } 
