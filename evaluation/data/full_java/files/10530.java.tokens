package com . google . common . io ; import com . google . common . base . Function ; import com . google . common . collect . Lists ; import java . io . BufferedReader ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import java . nio . CharBuffer ; import java . util . Arrays ; import java . util . List ; @AndroidIncompatible public class LineBufferTest extends IoTestCase { public void testProcess ( ) throws IOException { bufferHelper ( <str> ) ; bufferHelper ( <str> , <str> ) ; bufferHelper ( <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> , <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> , <str> ) ; bufferHelper ( <str> , <str> , <str> , <str> ) ; } private static final int [ ] CHUNK_SIZES = { <int> , <int> , <int> , Integer . MAX_VALUE } ; private static void bufferHelper ( String input , String . . . expect ) throws IOException { List < String > expectProcess = Arrays . asList ( expect ) ; List < String > expectRead = Lists . transform ( expectProcess , new Function < String , String > ( ) { @Override public String apply ( String value ) { return value . replaceAll ( <str> , <str> ) ; } } ) ; for ( int chunk : CHUNK_SIZES ) { chunk = Math . max ( <int> , Math . min ( chunk , input . length ( ) ) ) ; assertEquals ( expectProcess , bufferHelper ( input , chunk ) ) ; assertEquals ( expectRead , readUsingJava ( input , chunk ) ) ; assertEquals ( expectRead , readUsingReader ( input , chunk , true ) ) ; assertEquals ( expectRead , readUsingReader ( input , chunk , false ) ) ; } } private static List < String > bufferHelper ( String input , int chunk ) throws IOException { final List < String > lines = Lists . newArrayList ( ) ; LineBuffer lineBuf = new LineBuffer ( ) { @Override protected void handleLine ( String line , String end ) { lines . add ( line + end ) ; } } ; char [ ] chars = input . toCharArray ( ) ; int off = <int> ; while ( off < chars . length ) { int len = Math . min ( chars . length , off + chunk ) - off ; lineBuf . add ( chars , off , len ) ; off + = len ; } lineBuf . finish ( ) ; return lines ; } private static List < String > readUsingJava ( String input , int chunk ) throws IOException { BufferedReader r = new BufferedReader ( getChunkedReader ( input , chunk ) ) ; List < String > lines = Lists . newArrayList ( ) ; String line ; while ( ( line = r . readLine ( ) ) ! = null ) { lines . add ( line ) ; } r . close ( ) ; return lines ; } private static List < String > readUsingReader ( String input , int chunk , boolean asReader ) throws IOException { Readable readable = asReader ? getChunkedReader ( input , chunk ) : getChunkedReadable ( input , chunk ) ; LineReader r = new LineReader ( readable ) ; List < String > lines = Lists . newArrayList ( ) ; String line ; while ( ( line = r . readLine ( ) ) ! = null ) { lines . add ( line ) ; } return lines ; } private static Readable getChunkedReadable ( String input , int chunk ) { final Reader reader = getChunkedReader ( input , chunk ) ; return new Readable ( ) { @Override public int read ( CharBuffer cbuf ) throws IOException { return reader . read ( cbuf ) ; } } ; } private static Reader getChunkedReader ( String input , final int chunk ) { return new FilterReader ( new StringReader ( input ) ) { @Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { return super . read ( cbuf , off , Math . min ( chunk , len ) ) ; } } ; } } 
