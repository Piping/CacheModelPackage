package org . apache . cassandra . db . compaction ; import java . util . * ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Before ; import org . junit . Test ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . Util ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . SSTableUtils ; import org . apache . cassandra . schema . CompactionParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; public class LongCompactionsTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { Map < String , String > compactionOptions = Collections . singletonMap ( <str> , <str> ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) . compaction ( CompactionParams . scts ( compactionOptions ) ) ) ; } @Before public void cleanupFiles ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; cfs . truncateBlocking ( ) ; } @Test public void testCompactionWide ( ) throws Exception { testCompaction ( <int> , <int> , <int> ) ; } @Test public void testCompactionSlim ( ) throws Exception { testCompaction ( <int> , <int> , <int> ) ; } @Test public void testCompactionMany ( ) throws Exception { testCompaction ( <int> , <int> , <int> ) ; } protected void testCompaction ( int sstableCount , int partitionsPerSSTable , int rowsPerPartition ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; ArrayList < SSTableReader > sstables = new ArrayList < > ( ) ; for ( int k = <int> ; k < sstableCount ; k + + ) { SortedMap < String , PartitionUpdate > rows = new TreeMap < > ( ) ; for ( int j = <int> ; j < partitionsPerSSTable ; j + + ) { String key = String . valueOf ( j ) ; UpdateBuilder builder = UpdateBuilder . create ( store . metadata , String . valueOf ( j ) ) . withTimestamp ( k ) ; for ( int i = <int> ; i < rowsPerPartition ; i + + ) builder . newRow ( String . valueOf ( i ) ) . add ( <str> , String . valueOf ( i ) ) ; rows . put ( key , builder . build ( ) ) ; } Collection < SSTableReader > readers = SSTableUtils . prepare ( ) . write ( rows ) ; sstables . addAll ( readers ) ; store . addSSTables ( readers ) ; } Thread . sleep ( <int> ) ; long start = System . nanoTime ( ) ; final int gcBefore = ( int ) ( System . currentTimeMillis ( ) / <int> ) - Schema . instance . getCFMetaData ( KEYSPACE1 , <str> ) . params . gcGraceSeconds ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( sstables , OperationType . COMPACTION ) ) { assert txn ! = null : <str> ; new CompactionTask ( store , txn , gcBefore ) . execute ( null ) ; } System . out . println ( String . format ( <str> , this . getClass ( ) . getName ( ) , sstableCount , partitionsPerSSTable , rowsPerPartition , TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - start ) ) ) ; } @Test public void testStandardColumnCompactions ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; cfs . clearUnsafe ( ) ; final int ROWS_PER_SSTABLE = <int> ; final int SSTABLES = cfs . metadata . params . minIndexInterval * <int> / ROWS_PER_SSTABLE ; cfs . disableAutoCompaction ( ) ; long maxTimestampExpected = Long . MIN_VALUE ; Set < DecoratedKey > inserted = new HashSet < DecoratedKey > ( ) ; for ( int j = <int> ; j < SSTABLES ; j + + ) { for ( int i = <int> ; i < ROWS_PER_SSTABLE ; i + + ) { DecoratedKey key = Util . dk ( String . valueOf ( i % <int> ) ) ; long timestamp = j * ROWS_PER_SSTABLE + i ; maxTimestampExpected = Math . max ( timestamp , maxTimestampExpected ) ; UpdateBuilder . create ( cfs . metadata , key ) . withTimestamp ( timestamp ) . newRow ( String . valueOf ( i / <int> ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . apply ( ) ; inserted . add ( key ) ; } cfs . forceBlockingFlush ( ) ; CompactionsTest . assertMaxTimestamp ( cfs , maxTimestampExpected ) ; assertEquals ( inserted . toString ( ) , inserted . size ( ) , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; } forceCompactions ( cfs ) ; assertEquals ( inserted . toString ( ) , inserted . size ( ) , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; CompactionsTest . assertMaxTimestamp ( cfs , maxTimestampExpected ) ; cfs . truncateBlocking ( ) ; } private void forceCompactions ( ColumnFamilyStore cfs ) { cfs . setCompactionThresholds ( <int> , <int> ) ; do { ArrayList < Future < ? > > compactions = new ArrayList < Future < ? > > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) compactions . addAll ( CompactionManager . instance . submitBackground ( cfs ) ) ; FBUtilities . waitOnFutures ( compactions ) ; } while ( CompactionManager . instance . getPendingTasks ( ) > <int> | | CompactionManager . instance . getActiveCompactions ( ) > <int> ) ; if ( cfs . getLiveSSTables ( ) . size ( ) > <int> ) { CompactionManager . instance . performMaximal ( cfs , false ) ; } } } 
