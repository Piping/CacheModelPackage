package org . apache . cassandra . streaming . messages ; import java . io . IOException ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import org . apache . cassandra . io . sstable . SSTableMultiWriter ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataInputPlus . DataInputStreamPlus ; import org . apache . cassandra . io . util . DataOutputStreamPlus ; import org . apache . cassandra . streaming . StreamReader ; import org . apache . cassandra . streaming . StreamSession ; import org . apache . cassandra . streaming . compress . CompressedStreamReader ; import org . apache . cassandra . utils . JVMStabilityInspector ; public class IncomingFileMessage extends StreamMessage { public static Serializer < IncomingFileMessage > serializer = new Serializer < IncomingFileMessage > ( ) { @SuppressWarnings ( <str> ) public IncomingFileMessage deserialize ( ReadableByteChannel in , int version , StreamSession session ) throws IOException { DataInputPlus input = new DataInputStreamPlus ( Channels . newInputStream ( in ) ) ; FileMessageHeader header = FileMessageHeader . serializer . deserialize ( input , version ) ; StreamReader reader = ! header . isCompressed ( ) ? new StreamReader ( header , session ) : new CompressedStreamReader ( header , session ) ; try { return new IncomingFileMessage ( reader . read ( in ) , header ) ; } catch ( IOException eof ) { throw eof ; } catch ( Throwable t ) { Throwable cause = t ; while ( ( cause = cause . getCause ( ) ) ! = null ) { if ( cause instanceof IOException ) throw ( IOException ) cause ; } JVMStabilityInspector . inspectThrowable ( t ) ; session . doRetry ( header , t ) ; return null ; } } public void serialize ( IncomingFileMessage message , DataOutputStreamPlus out , int version , StreamSession session ) throws IOException { throw new UnsupportedOperationException ( <str> ) ; } } ; public FileMessageHeader header ; public SSTableMultiWriter sstable ; public IncomingFileMessage ( SSTableMultiWriter sstable , FileMessageHeader header ) { super ( Type . FILE ) ; this . header = header ; this . sstable = sstable ; } @Override public String toString ( ) { return <str> + header + <str> + sstable . getFilename ( ) + <str> ; } } 
