package org . eclipse . debug . internal . ui . viewers . model ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementLabelProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDeltaVisitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . ColumnLabelProvider ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . ViewerCell ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Display ; public class TreeModelLabelProvider extends ColumnLabelProvider implements ITreeModelLabelProvider , IModelChangedListener { private IInternalTreeModelViewer fViewer ; private List < ILabelUpdate > fComplete ; private Map < ImageDescriptor , Image > fImageCache = new HashMap < ImageDescriptor , Image > ( ) ; private Map < FontData , Font > fFontCache = new HashMap < FontData , Font > ( ) ; private Map < RGB , Color > fColorCache = new HashMap < RGB , Color > ( ) ; private ListenerList fLabelListeners = new ListenerList ( ) ; private Map < IElementLabelProvider , List < ILabelUpdate > > fPendingUpdates = new HashMap < IElementLabelProvider , List < ILabelUpdate > > ( ) ; private Runnable fPendingUpdatesRunnable ; private List < ILabelUpdate > fUpdatesInProgress = new ArrayList < ILabelUpdate > ( ) ; class CancelPendingUpdatesVisitor implements IModelDeltaVisitor { @Override public boolean visit ( IModelDelta delta , int depth ) { if ( ( delta . getFlags ( ) & IModelDelta . CONTENT ) > <int> ) { cancelElementUpdates ( delta . getElement ( ) , true ) ; return false ; } else if ( ( delta . getFlags ( ) & IModelDelta . STATE ) > <int> ) { cancelElementUpdates ( delta . getElement ( ) , false ) ; return true ; } return true ; } } private CancelPendingUpdatesVisitor fCancelPendingUpdatesVisitor = new CancelPendingUpdatesVisitor ( ) ; public TreeModelLabelProvider ( IInternalTreeModelViewer viewer ) { fViewer = viewer ; fViewer . addModelChangedListener ( this ) ; } @Override public Image getImage ( ImageDescriptor descriptor ) { if ( descriptor = = null ) { return null ; } Image image = fImageCache . get ( descriptor ) ; if ( image = = null ) { image = new Image ( getDisplay ( ) , descriptor . getImageData ( ) ) ; fImageCache . put ( descriptor , image ) ; } return image ; } private Display getDisplay ( ) { return fViewer . getDisplay ( ) ; } @Override public Font getFont ( FontData fontData ) { if ( fontData = = null ) { return null ; } Font font = fFontCache . get ( fontData ) ; if ( font = = null ) { font = new Font ( getDisplay ( ) , fontData ) ; fFontCache . put ( fontData , font ) ; } return font ; } @Override public Color getColor ( RGB rgb ) { if ( rgb = = null ) { return null ; } Color color = fColorCache . get ( rgb ) ; if ( color = = null ) { color = new Color ( getDisplay ( ) , rgb ) ; fColorCache . put ( rgb , color ) ; } return color ; } @Override public void dispose ( ) { Assert . isTrue ( fViewer . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fViewer . removeModelChangedListener ( this ) ; fViewer = null ; List < ILabelUpdate > complete = null ; synchronized ( this ) { complete = fComplete ; fComplete = null ; } if ( complete ! = null ) { for ( ILabelUpdate update : complete ) { update . cancel ( ) ; } } for ( ILabelUpdate currentUpdate : fUpdatesInProgress ) { currentUpdate . cancel ( ) ; } if ( fPendingUpdatesRunnable ! = null ) { fPendingUpdatesRunnable = null ; } for ( List < ILabelUpdate > updateList : fPendingUpdates . values ( ) ) { for ( ILabelUpdate update : updateList ) { update . cancel ( ) ; } } fPendingUpdates . clear ( ) ; for ( Image image : fImageCache . values ( ) ) { image . dispose ( ) ; } fImageCache . clear ( ) ; for ( Font font : fFontCache . values ( ) ) { font . dispose ( ) ; } fFontCache . clear ( ) ; for ( Color color : fColorCache . values ( ) ) { color . dispose ( ) ; } fColorCache . clear ( ) ; super . dispose ( ) ; } private boolean isDisposed ( ) { return fViewer = = null ; } @Override public void update ( ViewerCell cell ) { } @Override public boolean update ( TreePath elementPath ) { Assert . isTrue ( fViewer . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; cancelPathUpdates ( elementPath ) ; String [ ] visibleColumns = fViewer . getVisibleColumns ( ) ; Object element = elementPath . getLastSegment ( ) ; IElementLabelProvider presentation = ViewerAdapterService . getLabelProvider ( element ) ; if ( presentation ! = null ) { List < ILabelUpdate > updates = fPendingUpdates . get ( presentation ) ; if ( updates = = null ) { updates = new LinkedList < ILabelUpdate > ( ) ; fPendingUpdates . put ( presentation , updates ) ; } updates . add ( new LabelUpdate ( fViewer . getInput ( ) , elementPath , this , visibleColumns , fViewer . getPresentationContext ( ) ) ) ; fPendingUpdatesRunnable = new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } startRequests ( this ) ; } } ; fViewer . getDisplay ( ) . asyncExec ( fPendingUpdatesRunnable ) ; return true ; } else { return false ; } } private void cancelPathUpdates ( TreePath elementPath ) { Assert . isTrue ( fViewer . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; for ( ILabelUpdate currentUpdate : fUpdatesInProgress ) { if ( elementPath . equals ( currentUpdate . getElementPath ( ) ) ) { currentUpdate . cancel ( ) ; } } } void setElementData ( TreePath path , int numColumns , String [ ] labels , ImageDescriptor [ ] images , FontData [ ] fontDatas , RGB [ ] foregrounds , RGB [ ] backgrounds , boolean checked , boolean grayed ) { fViewer . setElementData ( path , numColumns , labels , images , fontDatas , foregrounds , backgrounds ) ; fViewer . setElementChecked ( path , checked , grayed ) ; } private void startRequests ( Runnable runnable ) { if ( runnable ! = fPendingUpdatesRunnable ) { return ; } if ( ! fPendingUpdates . isEmpty ( ) ) { List < ILabelUpdate > list = null ; for ( Entry < IElementLabelProvider , List < ILabelUpdate > > entry : fPendingUpdates . entrySet ( ) ) { list = entry . getValue ( ) ; for ( ILabelUpdate update : list ) { updateStarted ( update ) ; } entry . getKey ( ) . update ( list . toArray ( new ILabelUpdate [ list . size ( ) ] ) ) ; } } fPendingUpdates . clear ( ) ; fPendingUpdatesRunnable = null ; } private void cancelElementUpdates ( Object element , boolean searchFullPath ) { for ( ILabelUpdate currentUpdate : fUpdatesInProgress ) { if ( searchFullPath ) { if ( element . equals ( fViewer . getInput ( ) ) ) { currentUpdate . cancel ( ) ; } else { TreePath updatePath = currentUpdate . getElementPath ( ) ; for ( int i = <int> ; i < updatePath . getSegmentCount ( ) ; i + + ) { if ( element . equals ( updatePath . getSegment ( i ) ) ) { currentUpdate . cancel ( ) ; break ; } } } } else { if ( element . equals ( currentUpdate . getElement ( ) ) ) { currentUpdate . cancel ( ) ; } } } } private IPresentationContext getPresentationContext ( ) { return fViewer . getPresentationContext ( ) ; } synchronized void complete ( ILabelUpdate update ) { if ( fViewer = = null ) { return ; } if ( fComplete = = null ) { fComplete = new LinkedList < ILabelUpdate > ( ) ; fViewer . getDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( isDisposed ( ) ) { return ; } List < ILabelUpdate > updates = null ; synchronized ( TreeModelLabelProvider . this ) { updates = fComplete ; fComplete = null ; } for ( ILabelUpdate itrUpdate : updates ) { if ( itrUpdate . isCanceled ( ) ) { updateComplete ( itrUpdate ) ; } else { ( ( LabelUpdate ) itrUpdate ) . performUpdate ( ) ; } } } } ) ; } fComplete . add ( update ) ; } @Override public void addLabelUpdateListener ( ILabelUpdateListener listener ) { fLabelListeners . add ( listener ) ; } @Override public void removeLabelUpdateListener ( ILabelUpdateListener listener ) { fLabelListeners . remove ( listener ) ; } void updateStarted ( ILabelUpdate update ) { Assert . isTrue ( fViewer . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; boolean begin = fUpdatesInProgress . isEmpty ( ) ; fUpdatesInProgress . add ( update ) ; if ( begin ) { if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } notifyUpdate ( TreeModelContentProvider . UPDATE_SEQUENCE_BEGINS , null ) ; } if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + update ) ; } notifyUpdate ( TreeModelContentProvider . UPDATE_BEGINS , update ) ; } void updateComplete ( ILabelUpdate update ) { fUpdatesInProgress . remove ( update ) ; if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + update ) ; } notifyUpdate ( TreeModelContentProvider . UPDATE_COMPLETE , update ) ; if ( fUpdatesInProgress . isEmpty ( ) ) { if ( DebugUIPlugin . DEBUG_UPDATE_SEQUENCE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } notifyUpdate ( TreeModelContentProvider . UPDATE_SEQUENCE_COMPLETE , null ) ; } } private void notifyUpdate ( final int type , final ILabelUpdate update ) { if ( ! fLabelListeners . isEmpty ( ) ) { Object [ ] listeners = fLabelListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { final ILabelUpdateListener listener = ( ILabelUpdateListener ) listeners [ i ] ; SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { switch ( type ) { case TreeModelContentProvider . UPDATE_SEQUENCE_BEGINS : listener . labelUpdatesBegin ( ) ; break ; case TreeModelContentProvider . UPDATE_SEQUENCE_COMPLETE : listener . labelUpdatesComplete ( ) ; break ; case TreeModelContentProvider . UPDATE_BEGINS : listener . labelUpdateStarted ( update ) ; break ; case TreeModelContentProvider . UPDATE_COMPLETE : listener . labelUpdateComplete ( update ) ; break ; default : break ; } } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } @Override public void modelChanged ( IModelDelta delta , IModelProxy proxy ) { delta . accept ( fCancelPendingUpdatesVisitor ) ; } } 
