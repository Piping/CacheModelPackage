package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . STREAM_CLOSED ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . handler . codec . http2 . Http2Exception . streamError ; import static io . netty . handler . codec . http2 . Http2PromisedRequestVerifier . ALWAYS_VERIFY ; import static io . netty . handler . codec . http2 . Http2Stream . State . CLOSED ; import static io . netty . handler . codec . http2 . Http2Stream . State . HALF_CLOSED_REMOTE ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . http2 . Http2Exception . ClosedStreamCreationException ; import java . util . List ; public class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder { private Http2FrameListener internalFrameListener = new PrefaceFrameListener ( ) ; private final Http2Connection connection ; private Http2LifecycleManager lifecycleManager ; private final Http2ConnectionEncoder encoder ; private final Http2FrameReader frameReader ; private Http2FrameListener listener ; private final Http2PromisedRequestVerifier requestVerifier ; public DefaultHttp2ConnectionDecoder ( Http2Connection connection , Http2ConnectionEncoder encoder , Http2FrameReader frameReader ) { this ( connection , encoder , frameReader , ALWAYS_VERIFY ) ; } public DefaultHttp2ConnectionDecoder ( Http2Connection connection , Http2ConnectionEncoder encoder , Http2FrameReader frameReader , Http2PromisedRequestVerifier requestVerifier ) { this . connection = checkNotNull ( connection , <str> ) ; this . frameReader = checkNotNull ( frameReader , <str> ) ; this . encoder = checkNotNull ( encoder , <str> ) ; this . requestVerifier = checkNotNull ( requestVerifier , <str> ) ; if ( connection . local ( ) . flowController ( ) = = null ) { connection . local ( ) . flowController ( new DefaultHttp2LocalFlowController ( connection ) ) ; } connection . local ( ) . flowController ( ) . frameWriter ( encoder . frameWriter ( ) ) ; } @Override public void lifecycleManager ( Http2LifecycleManager lifecycleManager ) { this . lifecycleManager = checkNotNull ( lifecycleManager , <str> ) ; } @Override public Http2Connection connection ( ) { return connection ; } @Override public final Http2LocalFlowController flowController ( ) { return connection . local ( ) . flowController ( ) ; } @Override public void frameListener ( Http2FrameListener listener ) { this . listener = checkNotNull ( listener , <str> ) ; } @Override public Http2FrameListener frameListener ( ) { return listener ; } @Override public boolean prefaceReceived ( ) { return FrameReadListener . class = = internalFrameListener . getClass ( ) ; } @Override public void decodeFrame ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Http2Exception { frameReader . readFrame ( ctx , in , internalFrameListener ) ; } @Override public Http2Settings localSettings ( ) { Http2Settings settings = new Http2Settings ( ) ; Http2FrameReader . Configuration config = frameReader . configuration ( ) ; Http2HeaderTable headerTable = config . headerTable ( ) ; Http2FrameSizePolicy frameSizePolicy = config . frameSizePolicy ( ) ; settings . initialWindowSize ( flowController ( ) . initialWindowSize ( ) ) ; settings . maxConcurrentStreams ( connection . remote ( ) . maxActiveStreams ( ) ) ; settings . headerTableSize ( headerTable . maxHeaderTableSize ( ) ) ; settings . maxFrameSize ( frameSizePolicy . maxFrameSize ( ) ) ; settings . maxHeaderListSize ( headerTable . maxHeaderListSize ( ) ) ; if ( ! connection . isServer ( ) ) { settings . pushEnabled ( connection . local ( ) . allowPushTo ( ) ) ; } return settings ; } @Override public void localSettings ( Http2Settings settings ) throws Http2Exception { Boolean pushEnabled = settings . pushEnabled ( ) ; Http2FrameReader . Configuration config = frameReader . configuration ( ) ; Http2HeaderTable inboundHeaderTable = config . headerTable ( ) ; Http2FrameSizePolicy inboundFrameSizePolicy = config . frameSizePolicy ( ) ; if ( pushEnabled ! = null ) { if ( connection . isServer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } connection . local ( ) . allowPushTo ( pushEnabled ) ; } Long maxConcurrentStreams = settings . maxConcurrentStreams ( ) ; if ( maxConcurrentStreams ! = null ) { int value = ( int ) Math . min ( maxConcurrentStreams , Integer . MAX_VALUE ) ; connection . remote ( ) . maxActiveStreams ( value ) ; } Long headerTableSize = settings . headerTableSize ( ) ; if ( headerTableSize ! = null ) { inboundHeaderTable . maxHeaderTableSize ( ( int ) Math . min ( headerTableSize , Integer . MAX_VALUE ) ) ; } Integer maxHeaderListSize = settings . maxHeaderListSize ( ) ; if ( maxHeaderListSize ! = null ) { inboundHeaderTable . maxHeaderListSize ( maxHeaderListSize ) ; } Integer maxFrameSize = settings . maxFrameSize ( ) ; if ( maxFrameSize ! = null ) { inboundFrameSizePolicy . maxFrameSize ( maxFrameSize ) ; } Integer initialWindowSize = settings . initialWindowSize ( ) ; if ( initialWindowSize ! = null ) { flowController ( ) . initialWindowSize ( initialWindowSize ) ; } } @Override public void close ( ) { frameReader . close ( ) ; } private int unconsumedBytes ( Http2Stream stream ) { return flowController ( ) . unconsumedBytes ( stream ) ; } void onGoAwayRead0 ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { listener . onGoAwayRead ( ctx , lastStreamId , errorCode , debugData ) ; connection . goAwayReceived ( lastStreamId , errorCode , debugData ) ; } void onUnknownFrame0 ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { listener . onUnknownFrame ( ctx , frameType , streamId , flags , payload ) ; } private final class FrameReadListener implements Http2FrameListener { @Override public int onDataRead ( final ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { Http2Stream stream = connection . stream ( streamId ) ; Http2LocalFlowController flowController = flowController ( ) ; int bytesToReturn = data . readableBytes ( ) + padding ; if ( stream = = null | | stream . isResetSent ( ) | | streamCreatedAfterGoAwaySent ( streamId ) ) { flowController . receiveFlowControlledFrame ( stream , data , padding , endOfStream ) ; flowController . consumeBytes ( stream , bytesToReturn ) ; verifyStreamMayHaveExisted ( streamId ) ; return bytesToReturn ; } Http2Exception error = null ; switch ( stream . state ( ) ) { case OPEN : case HALF_CLOSED_LOCAL : break ; case HALF_CLOSED_REMOTE : case CLOSED : error = streamError ( stream . id ( ) , STREAM_CLOSED , <str> , stream . id ( ) , stream . state ( ) ) ; break ; default : error = streamError ( stream . id ( ) , PROTOCOL_ERROR , <str> , stream . id ( ) , stream . state ( ) ) ; break ; } int unconsumedBytes = unconsumedBytes ( stream ) ; try { flowController . receiveFlowControlledFrame ( stream , data , padding , endOfStream ) ; unconsumedBytes = unconsumedBytes ( stream ) ; if ( error ! = null ) { throw error ; } bytesToReturn = listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; return bytesToReturn ; } catch ( Http2Exception e ) { int delta = unconsumedBytes - unconsumedBytes ( stream ) ; bytesToReturn - = delta ; throw e ; } catch ( RuntimeException e ) { int delta = unconsumedBytes - unconsumedBytes ( stream ) ; bytesToReturn - = delta ; throw e ; } finally { flowController . consumeBytes ( stream , bytesToReturn ) ; if ( endOfStream ) { lifecycleManager . closeStreamRemote ( stream , ctx . newSucceededFuture ( ) ) ; } } } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endOfStream ) throws Http2Exception { onHeadersRead ( ctx , streamId , headers , <int> , DEFAULT_PRIORITY_WEIGHT , false , padding , endOfStream ) ; } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream ) throws Http2Exception { Http2Stream stream = connection . stream ( streamId ) ; boolean allowHalfClosedRemote = false ; if ( stream = = null & & ! connection . streamMayHaveExisted ( streamId ) ) { stream = connection . remote ( ) . createStream ( streamId , endOfStream ) ; allowHalfClosedRemote = stream . state ( ) = = HALF_CLOSED_REMOTE ; } if ( stream = = null | | stream . isResetSent ( ) | | streamCreatedAfterGoAwaySent ( streamId ) ) { return ; } switch ( stream . state ( ) ) { case RESERVED_REMOTE : stream . open ( endOfStream ) ; break ; case OPEN : case HALF_CLOSED_LOCAL : break ; case HALF_CLOSED_REMOTE : if ( ! allowHalfClosedRemote ) { throw streamError ( stream . id ( ) , STREAM_CLOSED , <str> , stream . id ( ) , stream . state ( ) ) ; } break ; case CLOSED : throw streamError ( stream . id ( ) , STREAM_CLOSED , <str> , stream . id ( ) , stream . state ( ) ) ; default : throw connectionError ( PROTOCOL_ERROR , <str> , stream . id ( ) , stream . state ( ) ) ; } try { stream . setPriority ( streamDependency , weight , exclusive ) ; } catch ( ClosedStreamCreationException ignored ) { } listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream ) ; if ( endOfStream ) { lifecycleManager . closeStreamRemote ( stream , ctx . newSucceededFuture ( ) ) ; } } @Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { Http2Stream stream = connection . stream ( streamId ) ; try { if ( stream = = null ) { if ( connection . streamMayHaveExisted ( streamId ) ) { return ; } stream = connection . remote ( ) . createIdleStream ( streamId ) ; } else if ( streamCreatedAfterGoAwaySent ( streamId ) ) { return ; } stream . setPriority ( streamDependency , weight , exclusive ) ; } catch ( ClosedStreamCreationException ignored ) { } listener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; } @Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null ) { verifyStreamMayHaveExisted ( streamId ) ; return ; } switch ( stream . state ( ) ) { case IDLE : throw connectionError ( PROTOCOL_ERROR , <str> , streamId ) ; case CLOSED : return ; default : break ; } listener . onRstStreamRead ( ctx , streamId , errorCode ) ; lifecycleManager . closeStream ( stream , ctx . newSucceededFuture ( ) ) ; } @Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { Http2Settings settings = encoder . pollSentSettings ( ) ; if ( settings ! = null ) { applyLocalSettings ( settings ) ; } listener . onSettingsAckRead ( ctx ) ; } private void applyLocalSettings ( Http2Settings settings ) throws Http2Exception { Boolean pushEnabled = settings . pushEnabled ( ) ; final Http2FrameReader . Configuration config = frameReader . configuration ( ) ; final Http2HeaderTable headerTable = config . headerTable ( ) ; final Http2FrameSizePolicy frameSizePolicy = config . frameSizePolicy ( ) ; if ( pushEnabled ! = null ) { if ( connection . isServer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } connection . local ( ) . allowPushTo ( pushEnabled ) ; } Long maxConcurrentStreams = settings . maxConcurrentStreams ( ) ; if ( maxConcurrentStreams ! = null ) { int value = ( int ) Math . min ( maxConcurrentStreams , Integer . MAX_VALUE ) ; connection . remote ( ) . maxActiveStreams ( value ) ; } Long headerTableSize = settings . headerTableSize ( ) ; if ( headerTableSize ! = null ) { headerTable . maxHeaderTableSize ( ( int ) Math . min ( headerTableSize , Integer . MAX_VALUE ) ) ; } Integer maxHeaderListSize = settings . maxHeaderListSize ( ) ; if ( maxHeaderListSize ! = null ) { headerTable . maxHeaderListSize ( maxHeaderListSize ) ; } Integer maxFrameSize = settings . maxFrameSize ( ) ; if ( maxFrameSize ! = null ) { frameSizePolicy . maxFrameSize ( maxFrameSize ) ; } Integer initialWindowSize = settings . initialWindowSize ( ) ; if ( initialWindowSize ! = null ) { flowController ( ) . initialWindowSize ( initialWindowSize ) ; } } @Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { encoder . remoteSettings ( settings ) ; encoder . writeSettingsAck ( ctx , ctx . newPromise ( ) ) ; listener . onSettingsRead ( ctx , settings ) ; } @Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { encoder . writePing ( ctx , true , data . slice ( ) . retain ( ) , ctx . newPromise ( ) ) ; listener . onPingRead ( ctx , data ) ; } @Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingAckRead ( ctx , data ) ; } @Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { Http2Stream parentStream = connection . stream ( streamId ) ; if ( streamCreatedAfterGoAwaySent ( streamId ) ) { return ; } if ( parentStream = = null ) { throw connectionError ( PROTOCOL_ERROR , <str> , streamId ) ; } switch ( parentStream . state ( ) ) { case OPEN : case HALF_CLOSED_LOCAL : break ; default : throw connectionError ( PROTOCOL_ERROR , <str> , parentStream . id ( ) , parentStream . state ( ) ) ; } if ( ! requestVerifier . isAuthoritative ( ctx , headers ) ) { throw streamError ( promisedStreamId , PROTOCOL_ERROR , <str> , streamId , promisedStreamId ) ; } if ( ! requestVerifier . isCacheable ( headers ) ) { throw streamError ( promisedStreamId , PROTOCOL_ERROR , <str> , streamId , promisedStreamId ) ; } if ( ! requestVerifier . isSafe ( headers ) ) { throw streamError ( promisedStreamId , PROTOCOL_ERROR , <str> , streamId , promisedStreamId ) ; } connection . remote ( ) . reservePushStream ( promisedStreamId , parentStream ) ; listener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; } @Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { onGoAwayRead0 ( ctx , lastStreamId , errorCode , debugData ) ; } @Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null | | stream . state ( ) = = CLOSED | | streamCreatedAfterGoAwaySent ( streamId ) ) { verifyStreamMayHaveExisted ( streamId ) ; return ; } encoder . flowController ( ) . incrementWindowSize ( stream , windowSizeIncrement ) ; listener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; } @Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { onUnknownFrame0 ( ctx , frameType , streamId , flags , payload ) ; } private boolean streamCreatedAfterGoAwaySent ( int streamId ) { Http2Connection . Endpoint < ? > remote = connection . remote ( ) ; return connection . goAwaySent ( ) & & remote . isValidStreamId ( streamId ) & & streamId > remote . lastStreamKnownByPeer ( ) ; } private void verifyStreamMayHaveExisted ( int streamId ) throws Http2Exception { if ( ! connection . streamMayHaveExisted ( streamId ) ) { throw connectionError ( PROTOCOL_ERROR , <str> , streamId ) ; } } } private final class PrefaceFrameListener implements Http2FrameListener { private void verifyPrefaceReceived ( ) throws Http2Exception { if ( ! prefaceReceived ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } } @Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { verifyPrefaceReceived ( ) ; return internalFrameListener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endOfStream ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onHeadersRead ( ctx , streamId , headers , padding , endOfStream ) ; } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endOfStream ) ; } @Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; } @Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onRstStreamRead ( ctx , streamId , errorCode ) ; } @Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onSettingsAckRead ( ctx ) ; } @Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { if ( ! prefaceReceived ( ) ) { internalFrameListener = new FrameReadListener ( ) ; } internalFrameListener . onSettingsRead ( ctx , settings ) ; } @Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onPingRead ( ctx , data ) ; } @Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onPingAckRead ( ctx , data ) ; } @Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; } @Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { onGoAwayRead0 ( ctx , lastStreamId , errorCode , debugData ) ; } @Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { verifyPrefaceReceived ( ) ; internalFrameListener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; } @Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { onUnknownFrame0 ( ctx , frameType , streamId , flags , payload ) ; } } } 
