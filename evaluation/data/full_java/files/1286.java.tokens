package org . apache . cassandra . utils . memory ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . Semaphore ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . NativeDecoratedKey ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . utils . concurrent . OpOrder ; public class NativeAllocator extends MemtableAllocator { private final static int MAX_REGION_SIZE = <int> * <int> * <int> ; private final static int MAX_CLONED_SIZE = <int> * <int> ; private final static int MIN_REGION_SIZE = <int> * <int> ; private static final Map < Integer , RaceAllocated > RACE_ALLOCATED = new HashMap < > ( ) ; static { for ( int i = MIN_REGION_SIZE ; i < = MAX_REGION_SIZE ; i * = <int> ) RACE_ALLOCATED . put ( i , new RaceAllocated ( ) ) ; } private final AtomicReference < Region > currentRegion = new AtomicReference < > ( ) ; private final ConcurrentLinkedQueue < Region > regions = new ConcurrentLinkedQueue < > ( ) ; protected NativeAllocator ( NativePool pool ) { super ( pool . onHeap . newAllocator ( ) , pool . offHeap . newAllocator ( ) ) ; } public Row . Builder rowBuilder ( OpOrder . Group opGroup ) { throw new UnsupportedOperationException ( ) ; } public DecoratedKey clone ( DecoratedKey key , OpOrder . Group writeOp ) { return new NativeDecoratedKey ( key . getToken ( ) , this , writeOp , key . getKey ( ) ) ; } @Override public MemtableAllocator . DataReclaimer reclaimer ( ) { return NO_OP ; } public long allocate ( int size , OpOrder . Group opGroup ) { assert size > = <int> ; offHeap ( ) . allocate ( size , opGroup ) ; if ( size > MAX_CLONED_SIZE ) return allocateOversize ( size ) ; while ( true ) { Region region = currentRegion . get ( ) ; long peer ; if ( region ! = null & & ( peer = region . allocate ( size ) ) > <int> ) return peer ; trySwapRegion ( region , size ) ; } } private void trySwapRegion ( Region current , int minSize ) { int size ; if ( current = = null ) size = MIN_REGION_SIZE ; else size = current . capacity * <int> ; if ( minSize > size ) size = Integer . highestOneBit ( minSize ) < < <int> ; size = Math . min ( MAX_REGION_SIZE , size ) ; RaceAllocated raceAllocated = RACE_ALLOCATED . get ( size ) ; Region next = raceAllocated . poll ( ) ; if ( next = = null ) next = new Region ( MemoryUtil . allocate ( size ) , size ) ; if ( currentRegion . compareAndSet ( current , next ) ) regions . add ( next ) ; else if ( ! raceAllocated . stash ( next ) ) MemoryUtil . free ( next . peer ) ; } private long allocateOversize ( int size ) { Region region = new Region ( MemoryUtil . allocate ( size ) , size ) ; regions . add ( region ) ; long peer ; if ( ( peer = region . allocate ( size ) ) = = - <int> ) throw new AssertionError ( ) ; return peer ; } public void setDiscarded ( ) { for ( Region region : regions ) MemoryUtil . free ( region . peer ) ; super . setDiscarded ( ) ; } private static class RaceAllocated { final ConcurrentLinkedQueue < Region > stash = new ConcurrentLinkedQueue < > ( ) ; final Semaphore permits = new Semaphore ( <int> ) ; boolean stash ( Region region ) { if ( ! permits . tryAcquire ( ) ) return false ; stash . add ( region ) ; return true ; } Region poll ( ) { Region next = stash . poll ( ) ; if ( next ! = null ) permits . release ( ) ; return next ; } } private static class Region { private final long peer ; private final int capacity ; private AtomicInteger nextFreeOffset = new AtomicInteger ( <int> ) ; private AtomicInteger allocCount = new AtomicInteger ( ) ; private Region ( long peer , int capacity ) { this . peer = peer ; this . capacity = capacity ; } long allocate ( int size ) { while ( true ) { int oldOffset = nextFreeOffset . get ( ) ; if ( oldOffset + size > capacity ) return - <int> ; if ( nextFreeOffset . compareAndSet ( oldOffset , oldOffset + size ) ) { allocCount . incrementAndGet ( ) ; return peer + oldOffset ; } } } @Override public String toString ( ) { return <str> + System . identityHashCode ( this ) + <str> + allocCount . get ( ) + <str> + ( capacity - nextFreeOffset . get ( ) ) ; } } } 
