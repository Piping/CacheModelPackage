package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Equivalence ; import com . google . common . base . Function ; import com . google . common . base . Predicate ; import java . io . Serializable ; import java . util . Comparator ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . SortedSet ; import javax . annotation . Nullable ; @GwtCompatible @SuppressWarnings ( <str> ) public final class Range < C extends Comparable > implements Predicate < C > , Serializable { private static final Function < Range , Cut > LOWER_BOUND_FN = new Function < Range , Cut > ( ) { @Override public Cut apply ( Range range ) { return range . lowerBound ; } } ; @SuppressWarnings ( <str> ) static < C extends Comparable < ? > > Function < Range < C > , Cut < C > > lowerBoundFn ( ) { return ( Function ) LOWER_BOUND_FN ; } private static final Function < Range , Cut > UPPER_BOUND_FN = new Function < Range , Cut > ( ) { @Override public Cut apply ( Range range ) { return range . upperBound ; } } ; @SuppressWarnings ( <str> ) static < C extends Comparable < ? > > Function < Range < C > , Cut < C > > upperBoundFn ( ) { return ( Function ) UPPER_BOUND_FN ; } static final Ordering < Range < ? > > RANGE_LEX_ORDERING = new RangeLexOrdering ( ) ; static < C extends Comparable < ? > > Range < C > create ( Cut < C > lowerBound , Cut < C > upperBound ) { return new Range < C > ( lowerBound , upperBound ) ; } public static < C extends Comparable < ? > > Range < C > open ( C lower , C upper ) { return create ( Cut . aboveValue ( lower ) , Cut . belowValue ( upper ) ) ; } public static < C extends Comparable < ? > > Range < C > closed ( C lower , C upper ) { return create ( Cut . belowValue ( lower ) , Cut . aboveValue ( upper ) ) ; } public static < C extends Comparable < ? > > Range < C > closedOpen ( C lower , C upper ) { return create ( Cut . belowValue ( lower ) , Cut . belowValue ( upper ) ) ; } public static < C extends Comparable < ? > > Range < C > openClosed ( C lower , C upper ) { return create ( Cut . aboveValue ( lower ) , Cut . aboveValue ( upper ) ) ; } public static < C extends Comparable < ? > > Range < C > range ( C lower , BoundType lowerType , C upper , BoundType upperType ) { checkNotNull ( lowerType ) ; checkNotNull ( upperType ) ; Cut < C > lowerBound = ( lowerType = = BoundType . OPEN ) ? Cut . aboveValue ( lower ) : Cut . belowValue ( lower ) ; Cut < C > upperBound = ( upperType = = BoundType . OPEN ) ? Cut . belowValue ( upper ) : Cut . aboveValue ( upper ) ; return create ( lowerBound , upperBound ) ; } public static < C extends Comparable < ? > > Range < C > lessThan ( C endpoint ) { return create ( Cut . < C > belowAll ( ) , Cut . belowValue ( endpoint ) ) ; } public static < C extends Comparable < ? > > Range < C > atMost ( C endpoint ) { return create ( Cut . < C > belowAll ( ) , Cut . aboveValue ( endpoint ) ) ; } public static < C extends Comparable < ? > > Range < C > upTo ( C endpoint , BoundType boundType ) { switch ( boundType ) { case OPEN : return lessThan ( endpoint ) ; case CLOSED : return atMost ( endpoint ) ; default : throw new AssertionError ( ) ; } } public static < C extends Comparable < ? > > Range < C > greaterThan ( C endpoint ) { return create ( Cut . aboveValue ( endpoint ) , Cut . < C > aboveAll ( ) ) ; } public static < C extends Comparable < ? > > Range < C > atLeast ( C endpoint ) { return create ( Cut . belowValue ( endpoint ) , Cut . < C > aboveAll ( ) ) ; } public static < C extends Comparable < ? > > Range < C > downTo ( C endpoint , BoundType boundType ) { switch ( boundType ) { case OPEN : return greaterThan ( endpoint ) ; case CLOSED : return atLeast ( endpoint ) ; default : throw new AssertionError ( ) ; } } private static final Range < Comparable > ALL = new Range < Comparable > ( Cut . belowAll ( ) , Cut . aboveAll ( ) ) ; @SuppressWarnings ( <str> ) public static < C extends Comparable < ? > > Range < C > all ( ) { return ( Range ) ALL ; } public static < C extends Comparable < ? > > Range < C > singleton ( C value ) { return closed ( value , value ) ; } public static < C extends Comparable < ? > > Range < C > encloseAll ( Iterable < C > values ) { checkNotNull ( values ) ; if ( values instanceof ContiguousSet ) { return ( ( ContiguousSet < C > ) values ) . range ( ) ; } Iterator < C > valueIterator = values . iterator ( ) ; C min = checkNotNull ( valueIterator . next ( ) ) ; C max = min ; while ( valueIterator . hasNext ( ) ) { C value = checkNotNull ( valueIterator . next ( ) ) ; min = Ordering . natural ( ) . min ( min , value ) ; max = Ordering . natural ( ) . max ( max , value ) ; } return closed ( min , max ) ; } final Cut < C > lowerBound ; final Cut < C > upperBound ; private Range ( Cut < C > lowerBound , Cut < C > upperBound ) { this . lowerBound = checkNotNull ( lowerBound ) ; this . upperBound = checkNotNull ( upperBound ) ; if ( lowerBound . compareTo ( upperBound ) > <int> | | lowerBound = = Cut . < C > aboveAll ( ) | | upperBound = = Cut . < C > belowAll ( ) ) { throw new IllegalArgumentException ( <str> + toString ( lowerBound , upperBound ) ) ; } } public boolean hasLowerBound ( ) { return lowerBound ! = Cut . belowAll ( ) ; } public C lowerEndpoint ( ) { return lowerBound . endpoint ( ) ; } public BoundType lowerBoundType ( ) { return lowerBound . typeAsLowerBound ( ) ; } public boolean hasUpperBound ( ) { return upperBound ! = Cut . aboveAll ( ) ; } public C upperEndpoint ( ) { return upperBound . endpoint ( ) ; } public BoundType upperBoundType ( ) { return upperBound . typeAsUpperBound ( ) ; } public boolean isEmpty ( ) { return lowerBound . equals ( upperBound ) ; } public boolean contains ( C value ) { checkNotNull ( value ) ; return lowerBound . isLessThan ( value ) & & ! upperBound . isLessThan ( value ) ; } @Deprecated @Override public boolean apply ( C input ) { return contains ( input ) ; } public boolean containsAll ( Iterable < ? extends C > values ) { if ( Iterables . isEmpty ( values ) ) { return true ; } if ( values instanceof SortedSet ) { SortedSet < ? extends C > set = cast ( values ) ; Comparator < ? > comparator = set . comparator ( ) ; if ( Ordering . natural ( ) . equals ( comparator ) | | comparator = = null ) { return contains ( set . first ( ) ) & & contains ( set . last ( ) ) ; } } for ( C value : values ) { if ( ! contains ( value ) ) { return false ; } } return true ; } public boolean encloses ( Range < C > other ) { return lowerBound . compareTo ( other . lowerBound ) < = <int> & & upperBound . compareTo ( other . upperBound ) > = <int> ; } public boolean isConnected ( Range < C > other ) { return lowerBound . compareTo ( other . upperBound ) < = <int> & & other . lowerBound . compareTo ( upperBound ) < = <int> ; } public Range < C > intersection ( Range < C > connectedRange ) { int lowerCmp = lowerBound . compareTo ( connectedRange . lowerBound ) ; int upperCmp = upperBound . compareTo ( connectedRange . upperBound ) ; if ( lowerCmp > = <int> & & upperCmp < = <int> ) { return this ; } else if ( lowerCmp < = <int> & & upperCmp > = <int> ) { return connectedRange ; } else { Cut < C > newLower = ( lowerCmp > = <int> ) ? lowerBound : connectedRange . lowerBound ; Cut < C > newUpper = ( upperCmp < = <int> ) ? upperBound : connectedRange . upperBound ; return create ( newLower , newUpper ) ; } } public Range < C > span ( Range < C > other ) { int lowerCmp = lowerBound . compareTo ( other . lowerBound ) ; int upperCmp = upperBound . compareTo ( other . upperBound ) ; if ( lowerCmp < = <int> & & upperCmp > = <int> ) { return this ; } else if ( lowerCmp > = <int> & & upperCmp < = <int> ) { return other ; } else { Cut < C > newLower = ( lowerCmp < = <int> ) ? lowerBound : other . lowerBound ; Cut < C > newUpper = ( upperCmp > = <int> ) ? upperBound : other . upperBound ; return create ( newLower , newUpper ) ; } } public Range < C > canonical ( DiscreteDomain < C > domain ) { checkNotNull ( domain ) ; Cut < C > lower = lowerBound . canonical ( domain ) ; Cut < C > upper = upperBound . canonical ( domain ) ; return ( lower = = lowerBound & & upper = = upperBound ) ? this : create ( lower , upper ) ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof Range ) { Range < ? > other = ( Range < ? > ) object ; return lowerBound . equals ( other . lowerBound ) & & upperBound . equals ( other . upperBound ) ; } return false ; } @Override public int hashCode ( ) { return lowerBound . hashCode ( ) * <int> + upperBound . hashCode ( ) ; } @Override public String toString ( ) { return toString ( lowerBound , upperBound ) ; } private static String toString ( Cut < ? > lowerBound , Cut < ? > upperBound ) { StringBuilder sb = new StringBuilder ( <int> ) ; lowerBound . describeAsLowerBound ( sb ) ; sb . append ( <str> ) ; upperBound . describeAsUpperBound ( sb ) ; return sb . toString ( ) ; } private static < T > SortedSet < T > cast ( Iterable < T > iterable ) { return ( SortedSet < T > ) iterable ; } Object readResolve ( ) { if ( this . equals ( ALL ) ) { return all ( ) ; } else { return this ; } } @SuppressWarnings ( <str> ) static int compareOrThrow ( Comparable left , Comparable right ) { return left . compareTo ( right ) ; } private static class RangeLexOrdering extends Ordering < Range < ? > > implements Serializable { @Override public int compare ( Range < ? > left , Range < ? > right ) { return ComparisonChain . start ( ) . compare ( left . lowerBound , right . lowerBound ) . compare ( left . upperBound , right . upperBound ) . result ( ) ; } private static final long serialVersionUID = <int> ; } private static final long serialVersionUID = <int> ; } 
