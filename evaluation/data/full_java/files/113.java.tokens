package org . apache . cassandra . config ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Function ; import com . google . common . base . Objects ; import com . google . common . collect . Collections2 ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . serializers . MarshalException ; public class ColumnDefinition extends ColumnSpecification implements Comparable < ColumnDefinition > { public static final Comparator < Object > asymmetricColumnDataComparator = ( a , b ) - > ( ( ColumnData ) a ) . column ( ) . compareTo ( ( ColumnDefinition ) b ) ; public static final int NO_POSITION = - <int> ; public enum ClusteringOrder { ASC , DESC , NONE } public enum Kind { PARTITION_KEY , CLUSTERING , REGULAR , STATIC ; public boolean isPrimaryKeyKind ( ) { return this = = PARTITION_KEY | | this = = CLUSTERING ; } } public final Kind kind ; private final int position ; private final Comparator < CellPath > cellPathComparator ; private final Comparator < Object > asymmetricCellPathComparator ; private final Comparator < ? super Cell > cellComparator ; private final long comparisonOrder ; private static long comparisonOrder ( Kind kind , boolean isComplex , long position , ColumnIdentifier name ) { assert position > = <int> & & position < <int> < < <int> ; return ( ( ( long ) kind . ordinal ( ) ) < < <int> ) | ( isComplex ? <int> < < <int> : <int> ) | ( position < < <int> ) | ( name . prefixComparison > > > <int> ) ; } public static ColumnDefinition partitionKeyDef ( CFMetaData cfm , ByteBuffer name , AbstractType < ? > type , int position ) { return new ColumnDefinition ( cfm , name , type , position , Kind . PARTITION_KEY ) ; } public static ColumnDefinition partitionKeyDef ( String ksName , String cfName , String name , AbstractType < ? > type , int position ) { return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( name , true ) , type , position , Kind . PARTITION_KEY ) ; } public static ColumnDefinition clusteringDef ( CFMetaData cfm , ByteBuffer name , AbstractType < ? > type , int position ) { return new ColumnDefinition ( cfm , name , type , position , Kind . CLUSTERING ) ; } public static ColumnDefinition clusteringDef ( String ksName , String cfName , String name , AbstractType < ? > type , int position ) { return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( name , true ) , type , position , Kind . CLUSTERING ) ; } public static ColumnDefinition regularDef ( CFMetaData cfm , ByteBuffer name , AbstractType < ? > type ) { return new ColumnDefinition ( cfm , name , type , NO_POSITION , Kind . REGULAR ) ; } public static ColumnDefinition regularDef ( String ksName , String cfName , String name , AbstractType < ? > type ) { return new ColumnDefinition ( ksName , cfName , ColumnIdentifier . getInterned ( name , true ) , type , NO_POSITION , Kind . REGULAR ) ; } public static ColumnDefinition staticDef ( CFMetaData cfm , ByteBuffer name , AbstractType < ? > type ) { return new ColumnDefinition ( cfm , name , type , NO_POSITION , Kind . STATIC ) ; } public ColumnDefinition ( CFMetaData cfm , ByteBuffer name , AbstractType < ? > type , int position , Kind kind ) { this ( cfm . ksName , cfm . cfName , ColumnIdentifier . getInterned ( name , cfm . getColumnDefinitionNameComparator ( kind ) ) , type , position , kind ) ; } @VisibleForTesting public ColumnDefinition ( String ksName , String cfName , ColumnIdentifier name , AbstractType < ? > type , int position , Kind kind ) { super ( ksName , cfName , name , type ) ; assert name ! = null & & type ! = null & & kind ! = null ; assert name . isInterned ( ) ; assert ( position = = NO_POSITION ) = = ! kind . isPrimaryKeyKind ( ) ; this . kind = kind ; this . position = position ; this . cellPathComparator = makeCellPathComparator ( kind , type ) ; this . cellComparator = cellPathComparator = = null ? ColumnData . comparator : ( a , b ) - > cellPathComparator . compare ( a . path ( ) , b . path ( ) ) ; this . asymmetricCellPathComparator = cellPathComparator = = null ? null : ( a , b ) - > cellPathComparator . compare ( ( ( Cell ) a ) . path ( ) , ( CellPath ) b ) ; this . comparisonOrder = comparisonOrder ( kind , isComplex ( ) , Math . max ( <int> , position ) , name ) ; } private static Comparator < CellPath > makeCellPathComparator ( Kind kind , AbstractType < ? > type ) { if ( kind . isPrimaryKeyKind ( ) | | ! type . isCollection ( ) | | ! type . isMultiCell ( ) ) return null ; CollectionType collection = ( CollectionType ) type ; return new Comparator < CellPath > ( ) { public int compare ( CellPath path1 , CellPath path2 ) { if ( path1 . size ( ) = = <int> | | path2 . size ( ) = = <int> ) { if ( path1 = = CellPath . BOTTOM ) return path2 = = CellPath . BOTTOM ? <int> : - <int> ; if ( path1 = = CellPath . TOP ) return path2 = = CellPath . TOP ? <int> : <int> ; return path2 = = CellPath . BOTTOM ? <int> : - <int> ; } assert path1 . size ( ) = = <int> & & path2 . size ( ) = = <int> ; return collection . nameComparator ( ) . compare ( path1 . get ( <int> ) , path2 . get ( <int> ) ) ; } } ; } public ColumnDefinition copy ( ) { return new ColumnDefinition ( ksName , cfName , name , type , position , kind ) ; } public ColumnDefinition withNewName ( ColumnIdentifier newName ) { return new ColumnDefinition ( ksName , cfName , newName , type , position , kind ) ; } public ColumnDefinition withNewType ( AbstractType < ? > newType ) { return new ColumnDefinition ( ksName , cfName , name , newType , position , kind ) ; } public boolean isPartitionKey ( ) { return kind = = Kind . PARTITION_KEY ; } public boolean isClusteringColumn ( ) { return kind = = Kind . CLUSTERING ; } public boolean isStatic ( ) { return kind = = Kind . STATIC ; } public boolean isRegular ( ) { return kind = = Kind . REGULAR ; } public ClusteringOrder clusteringOrder ( ) { if ( ! isClusteringColumn ( ) ) return ClusteringOrder . NONE ; return type . isReversed ( ) ? ClusteringOrder . DESC : ClusteringOrder . ASC ; } public int position ( ) { return position ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof ColumnDefinition ) ) return false ; ColumnDefinition cd = ( ColumnDefinition ) o ; return Objects . equal ( ksName , cd . ksName ) & & Objects . equal ( cfName , cd . cfName ) & & Objects . equal ( name , cd . name ) & & Objects . equal ( type , cd . type ) & & Objects . equal ( kind , cd . kind ) & & Objects . equal ( position , cd . position ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( ksName , cfName , name , type , kind , position ) ; } @Override public String toString ( ) { return Objects . toStringHelper ( this ) . add ( <str> , name ) . add ( <str> , type ) . add ( <str> , kind ) . add ( <str> , position ) . toString ( ) ; } public boolean isPrimaryKeyColumn ( ) { return kind . isPrimaryKeyKind ( ) ; } public boolean isPartOfCellName ( boolean isCQL3Table , boolean isSuper ) { if ( isCQL3Table ) return kind = = Kind . REGULAR | | kind = = Kind . STATIC ; else if ( isSuper ) return kind = = Kind . REGULAR ; else return kind = = Kind . STATIC ; } public static Collection < ColumnIdentifier > toIdentifiers ( Collection < ColumnDefinition > definitions ) { return Collections2 . transform ( definitions , new Function < ColumnDefinition , ColumnIdentifier > ( ) { @Override public ColumnIdentifier apply ( ColumnDefinition columnDef ) { return columnDef . name ; } } ) ; } public int compareTo ( ColumnDefinition other ) { if ( this = = other ) return <int> ; if ( comparisonOrder ! = other . comparisonOrder ) return Long . compare ( comparisonOrder , other . comparisonOrder ) ; return this . name . compareTo ( other . name ) ; } public Comparator < CellPath > cellPathComparator ( ) { return cellPathComparator ; } public Comparator < Object > asymmetricCellPathComparator ( ) { return asymmetricCellPathComparator ; } public Comparator < ? super Cell > cellComparator ( ) { return cellComparator ; } public boolean isComplex ( ) { return cellPathComparator ! = null ; } public boolean isSimple ( ) { return ! isComplex ( ) ; } public CellPath . Serializer cellPathSerializer ( ) { return CollectionType . cellPathSerializer ; } public void validateCellValue ( ByteBuffer value ) { type . validateCellValue ( value ) ; } public void validateCellPath ( CellPath path ) { if ( ! isComplex ( ) ) throw new MarshalException ( <str> ) ; assert type instanceof CollectionType ; ( ( CollectionType ) type ) . nameComparator ( ) . validate ( path . get ( <int> ) ) ; } public static String toCQLString ( Iterable < ColumnDefinition > defs ) { return toCQLString ( defs . iterator ( ) ) ; } public static String toCQLString ( Iterator < ColumnDefinition > defs ) { if ( ! defs . hasNext ( ) ) return <str> ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( defs . next ( ) . name ) ; while ( defs . hasNext ( ) ) sb . append ( <str> ) . append ( defs . next ( ) . name ) ; return sb . toString ( ) ; } public AbstractType < ? > cellValueType ( ) { return type instanceof CollectionType ? ( ( CollectionType ) type ) . valueComparator ( ) : type ; } } 
