package org . gradle . gradleplugin . userinterface . swing . generic . filter ; import javax . swing . * ; import javax . swing . event . ListSelectionEvent ; import javax . swing . event . ListSelectionListener ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; public abstract class AbstractFilterEditorPanel { private JPanel mainPanel ; private DefaultListModel model ; private JList list ; private JButton hideButton ; private JButton showButton ; public AbstractFilterEditorPanel ( ) { setupUI ( ) ; } public JComponent getComponent ( ) { return mainPanel ; } private void setupUI ( ) { mainPanel = new JPanel ( new BorderLayout ( ) ) ; mainPanel . add ( createOptionsPanel ( ) , BorderLayout . NORTH ) ; mainPanel . add ( createListPanel ( ) , BorderLayout . CENTER ) ; } private Component createOptionsPanel ( ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; hideButton = new JButton ( new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { hideSelected ( ) ; } } ) ; showButton = new JButton ( new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { showSelected ( ) ; } } ) ; panel . add ( showButton ) ; panel . add ( Box . createHorizontalStrut ( <int> ) ) ; panel . add ( hideButton ) ; panel . add ( Box . createHorizontalGlue ( ) ) ; panel . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; return panel ; } private Component createListPanel ( ) { model = new DefaultListModel ( ) ; list = new JList ( model ) ; list . setCellRenderer ( new FilterRenderer ( ) ) ; list . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) ) { enableAppropriately ( ) ; } } } ) ; return new JScrollPane ( list ) ; } private class FilterRenderer extends DefaultListCellRenderer { private Color defaultForegroundColor ; private FilterRenderer ( ) { defaultForegroundColor = getForeground ( ) ; } public Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { Component component = super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; setIcon ( null ) ; boolean isAllowed = isAllowed ( ( String ) value ) ; if ( isAllowed ) { setForeground ( defaultForegroundColor ) ; } else { setForeground ( Color . red ) ; } return component ; } } protected abstract boolean isAllowed ( String item ) ; public void enableAppropriately ( ) { boolean isShowEnabled = false ; boolean isHideEnabled = false ; List < String > selectedObjects = getSelectedValues ( ) ; if ( selectedObjects . isEmpty ( ) ) { isShowEnabled = false ; isHideEnabled = false ; } else { StateHolder stateHolder = new StateHolder ( ) ; determineShowHideEnabledState ( stateHolder , selectedObjects ) ; isShowEnabled = stateHolder . containsHiddenObjects ; isHideEnabled = stateHolder . containsShownObjects ; } showButton . setEnabled ( isShowEnabled ) ; hideButton . setEnabled ( isHideEnabled ) ; } protected void determineShowHideEnabledState ( StateHolder stateHolder , List < String > selectedObjects ) { Iterator < String > iterator = selectedObjects . iterator ( ) ; while ( iterator . hasNext ( ) & & ( ! stateHolder . containsHiddenObjects | | ! stateHolder . containsShownObjects ) ) { String object = iterator . next ( ) ; if ( isAllowed ( object ) ) { stateHolder . containsShownObjects = true ; } else { stateHolder . containsHiddenObjects = true ; } } } protected class StateHolder { boolean containsHiddenObjects ; boolean containsShownObjects ; } protected List < String > getSelectedValues ( ) { Object [ ] objects = list . getSelectedValues ( ) ; if ( objects = = null | | objects . length = = <int> ) { return Collections . emptyList ( ) ; } List < String > nodes = new ArrayList < String > ( ) ; for ( int index = <int> ; index < objects . length ; index + + ) { Object object = objects [ index ] ; nodes . add ( ( String ) object ) ; } return nodes ; } private void hideSelected ( ) { List < String > selection = getSelectedValues ( ) ; hideSelected ( selection ) ; enableAppropriately ( ) ; list . repaint ( ) ; } protected abstract void hideSelected ( List < String > selection ) ; private void showSelected ( ) { List < String > selection = getSelectedValues ( ) ; showSelected ( selection ) ; enableAppropriately ( ) ; list . repaint ( ) ; } protected abstract void showSelected ( List < String > selection ) ; public void populate ( List < String > items ) { model . clear ( ) ; Iterator < String > iterator = items . iterator ( ) ; while ( iterator . hasNext ( ) ) { String item = iterator . next ( ) ; model . addElement ( item ) ; } } } 
