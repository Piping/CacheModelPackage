package org . elasticsearch . cluster . metadata ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . analysis . Analyzer ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . indices . mapper . MapperRegistry ; import java . util . Collections ; import java . util . Set ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; public class MetaDataIndexUpgradeService extends AbstractComponent { private final MapperRegistry mapperRegistry ; @Inject public MetaDataIndexUpgradeService ( Settings settings , MapperRegistry mapperRegistry ) { super ( settings ) ; this . mapperRegistry = mapperRegistry ; } public IndexMetaData upgradeIndexMetaData ( IndexMetaData indexMetaData ) { if ( isUpgraded ( indexMetaData ) ) { return indexMetaData ; } checkSupportedVersion ( indexMetaData ) ; IndexMetaData newMetaData = indexMetaData ; newMetaData = addDefaultUnitsIfNeeded ( newMetaData ) ; checkMappingsCompatibility ( newMetaData ) ; newMetaData = markAsUpgraded ( newMetaData ) ; return newMetaData ; } private boolean isUpgraded ( IndexMetaData indexMetaData ) { return indexMetaData . getUpgradedVersion ( ) . onOrAfter ( Version . V_3_0_0 ) ; } private void checkSupportedVersion ( IndexMetaData indexMetaData ) { if ( indexMetaData . getState ( ) = = IndexMetaData . State . OPEN & & isSupportedVersion ( indexMetaData ) = = false ) { throw new IllegalStateException ( <str> + indexMetaData . getIndex ( ) + <str> + <str> + Version . CURRENT . minimumCompatibilityVersion ( ) + <str> ) ; } } private static boolean isSupportedVersion ( IndexMetaData indexMetaData ) { if ( indexMetaData . getCreationVersion ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { return true ; } if ( indexMetaData . getMinimumCompatibleVersion ( ) ! = null & & indexMetaData . getMinimumCompatibleVersion ( ) . onOrAfter ( org . apache . lucene . util . Version . LUCENE_5_0_0 ) ) { return true ; } return false ; } public static final Set < String > INDEX_BYTES_SIZE_SETTINGS = unmodifiableSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; public static final Set < String > INDEX_TIME_SETTINGS = unmodifiableSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING ) ) ; private IndexMetaData addDefaultUnitsIfNeeded ( IndexMetaData indexMetaData ) { if ( indexMetaData . getCreationVersion ( ) . before ( Version . V_2_0_0_beta1 ) ) { Settings settings = indexMetaData . getSettings ( ) ; Settings . Builder newSettings = null ; for ( String byteSizeSetting : INDEX_BYTES_SIZE_SETTINGS ) { String value = settings . get ( byteSizeSetting ) ; if ( value ! = null ) { try { Long . parseLong ( value ) ; } catch ( NumberFormatException nfe ) { continue ; } logger . warn ( <str> , byteSizeSetting , value ) ; if ( newSettings = = null ) { newSettings = Settings . builder ( ) ; newSettings . put ( settings ) ; } newSettings . put ( byteSizeSetting , value + <str> ) ; } } for ( String timeSetting : INDEX_TIME_SETTINGS ) { String value = settings . get ( timeSetting ) ; if ( value ! = null ) { try { Long . parseLong ( value ) ; } catch ( NumberFormatException nfe ) { continue ; } logger . warn ( <str> , timeSetting , value ) ; if ( newSettings = = null ) { newSettings = Settings . builder ( ) ; newSettings . put ( settings ) ; } newSettings . put ( timeSetting , value + <str> ) ; } } if ( newSettings ! = null ) { return IndexMetaData . builder ( indexMetaData ) . version ( indexMetaData . getVersion ( ) ) . settings ( newSettings . build ( ) ) . build ( ) ; } } return indexMetaData ; } private void checkMappingsCompatibility ( IndexMetaData indexMetaData ) { try { IndexSettings indexSettings = new IndexSettings ( indexMetaData , this . settings , Collections . emptyList ( ) ) ; SimilarityService similarityService = new SimilarityService ( indexSettings , Collections . emptyMap ( ) ) ; try ( AnalysisService analysisService = new FakeAnalysisService ( indexSettings ) ) { try ( MapperService mapperService = new MapperService ( indexSettings , analysisService , similarityService , mapperRegistry ) ) { for ( ObjectCursor < MappingMetaData > cursor : indexMetaData . getMappings ( ) . values ( ) ) { MappingMetaData mappingMetaData = cursor . value ; mapperService . merge ( mappingMetaData . type ( ) , mappingMetaData . source ( ) , false , false ) ; } } } } catch ( Exception ex ) { throw new IllegalStateException ( <str> + indexMetaData . getIndex ( ) + <str> , ex ) ; } } private IndexMetaData markAsUpgraded ( IndexMetaData indexMetaData ) { Settings settings = Settings . builder ( ) . put ( indexMetaData . getSettings ( ) ) . put ( IndexMetaData . SETTING_VERSION_UPGRADED , Version . CURRENT ) . build ( ) ; return IndexMetaData . builder ( indexMetaData ) . settings ( settings ) . build ( ) ; } private static class FakeAnalysisService extends AnalysisService { private Analyzer fakeAnalyzer = new Analyzer ( ) { @Override protected TokenStreamComponents createComponents ( String fieldName ) { throw new UnsupportedOperationException ( <str> ) ; } } ; public FakeAnalysisService ( IndexSettings indexSettings ) { super ( indexSettings , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) ) ; } @Override public NamedAnalyzer analyzer ( String name ) { return new NamedAnalyzer ( name , fakeAnalyzer ) ; } @Override public void close ( ) { fakeAnalyzer . close ( ) ; super . close ( ) ; } } } 
