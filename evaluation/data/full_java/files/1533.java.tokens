package org . apache . cassandra . gms ; import java . util . Collections ; import java . util . EnumMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import java . util . concurrent . atomic . AtomicInteger ; import org . junit . Test ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . Token ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class EndpointStateTest { public volatile VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( DatabaseDescriptor . getPartitioner ( ) ) ; @Test public void testMultiThreadedReadConsistency ( ) throws InterruptedException { for ( int i = <int> ; i < <int> ; i + + ) innerTestMultiThreadedReadConsistency ( ) ; } private void innerTestMultiThreadedReadConsistency ( ) throws InterruptedException { final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; final List < Token > tokens = Collections . singletonList ( token ) ; final HeartBeatState hb = new HeartBeatState ( <int> ) ; final EndpointState state = new EndpointState ( hb ) ; final AtomicInteger numFailures = new AtomicInteger ( ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { state . addApplicationState ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; state . addApplicationState ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; } } ) ; Thread t2 = new Thread ( new Runnable ( ) { public void run ( ) { for ( int i = <int> ; i < <int> ; i + + ) { Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; for ( Map . Entry < ApplicationState , VersionedValue > entry : state . states ( ) ) values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; if ( values . containsKey ( ApplicationState . STATUS ) & & ! values . containsKey ( ApplicationState . TOKENS ) ) { numFailures . incrementAndGet ( ) ; System . out . println ( String . format ( <str> , values ) ) ; } } } } ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertTrue ( numFailures . get ( ) = = <int> ) ; } @Test public void testMultiThreadWriteConsistency ( ) throws InterruptedException { for ( int i = <int> ; i < <int> ; i + + ) innerTestMultiThreadWriteConsistency ( ) ; } private void innerTestMultiThreadWriteConsistency ( ) throws InterruptedException { final Token token = DatabaseDescriptor . getPartitioner ( ) . getRandomToken ( ) ; final List < Token > tokens = Collections . singletonList ( token ) ; final String ip = <str> ; final UUID hostId = UUID . randomUUID ( ) ; final HeartBeatState hb = new HeartBeatState ( <int> ) ; final EndpointState state = new EndpointState ( hb ) ; Thread t1 = new Thread ( new Runnable ( ) { public void run ( ) { Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; states . put ( ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; states . put ( ApplicationState . STATUS , valueFactory . normal ( tokens ) ) ; state . addApplicationStates ( states ) ; } } ) ; Thread t2 = new Thread ( new Runnable ( ) { public void run ( ) { Map < ApplicationState , VersionedValue > states = new EnumMap < > ( ApplicationState . class ) ; states . put ( ApplicationState . INTERNAL_IP , valueFactory . internalIP ( ip ) ) ; states . put ( ApplicationState . HOST_ID , valueFactory . hostId ( hostId ) ) ; state . addApplicationStates ( states ) ; } } ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; Set < Map . Entry < ApplicationState , VersionedValue > > states = state . states ( ) ; assertEquals ( <int> , states . size ( ) ) ; Map < ApplicationState , VersionedValue > values = new EnumMap < > ( ApplicationState . class ) ; for ( Map . Entry < ApplicationState , VersionedValue > entry : states ) values . put ( entry . getKey ( ) , entry . getValue ( ) ) ; assertTrue ( values . containsKey ( ApplicationState . STATUS ) ) ; assertTrue ( values . containsKey ( ApplicationState . TOKENS ) ) ; assertTrue ( values . containsKey ( ApplicationState . INTERNAL_IP ) ) ; assertTrue ( values . containsKey ( ApplicationState . HOST_ID ) ) ; } } 
