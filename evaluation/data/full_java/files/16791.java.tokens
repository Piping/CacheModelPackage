package com . badlogic . gdx . backends . lwjgl . audio ; import javax . sound . sampled . AudioFormat ; import javax . sound . sampled . AudioFormat . Encoding ; import javax . sound . sampled . AudioSystem ; import javax . sound . sampled . TargetDataLine ; import com . badlogic . gdx . audio . AudioRecorder ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class JavaSoundAudioRecorder implements AudioRecorder { private TargetDataLine line ; private byte [ ] buffer = new byte [ <int> * <int> ] ; public JavaSoundAudioRecorder ( int samplingRate , boolean isMono ) { try { AudioFormat format = new AudioFormat ( Encoding . PCM_SIGNED , samplingRate , <int> , isMono ? <int> : <int> , isMono ? <int> : <int> , samplingRate , false ) ; line = AudioSystem . getTargetDataLine ( format ) ; line . open ( format , buffer . length ) ; line . start ( ) ; } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> , ex ) ; } } public void read ( short [ ] samples , int offset , int numSamples ) { if ( buffer . length < numSamples * <int> ) buffer = new byte [ numSamples * <int> ] ; int toRead = numSamples * <int> ; int read = <int> ; while ( read ! = toRead ) read + = line . read ( buffer , read , toRead - read ) ; for ( int i = <int> , j = <int> ; i < numSamples * <int> ; i + = <int> , j + + ) samples [ offset + j ] = ( short ) ( ( buffer [ i + <int> ] < < <int> ) | ( buffer [ i ] & <hex> ) ) ; } public void dispose ( ) { line . close ( ) ; } } 
