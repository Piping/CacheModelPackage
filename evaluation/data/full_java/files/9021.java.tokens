package org . elasticsearch . test . rest . client . http ; import org . apache . http . client . methods . * ; import org . apache . http . entity . StringEntity ; import org . apache . http . impl . client . CloseableHttpClient ; import org . elasticsearch . client . support . Headers ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . http . HttpServerTransport ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URLEncoder ; import java . nio . charset . Charset ; import java . util . HashMap ; import java . util . Map ; import java . util . stream . Collectors ; public class HttpRequestBuilder { private static final ESLogger logger = Loggers . getLogger ( HttpRequestBuilder . class ) ; static final Charset DEFAULT_CHARSET = Charset . forName ( <str> ) ; private final CloseableHttpClient httpClient ; private String protocol = <str> ; private String host ; private int port ; private String path = <str> ; private final Map < String , String > params = new HashMap < > ( ) ; private final Map < String , String > headers = new HashMap < > ( ) ; private String method = HttpGetWithEntity . METHOD_NAME ; private String body ; public HttpRequestBuilder ( CloseableHttpClient httpClient ) { this . httpClient = httpClient ; } public HttpRequestBuilder host ( String host ) { this . host = host ; return this ; } public HttpRequestBuilder httpTransport ( HttpServerTransport httpServerTransport ) { InetSocketTransportAddress transportAddress = ( InetSocketTransportAddress ) httpServerTransport . boundAddress ( ) . publishAddress ( ) ; return host ( NetworkAddress . formatAddress ( transportAddress . address ( ) . getAddress ( ) ) ) . port ( transportAddress . address ( ) . getPort ( ) ) ; } public HttpRequestBuilder port ( int port ) { this . port = port ; return this ; } public HttpRequestBuilder path ( String path ) { this . path = path ; return this ; } public HttpRequestBuilder pathParts ( String . . . path ) { if ( path . length = = <int> ) { this . path = <str> ; return this ; } StringBuilder finalPath = new StringBuilder ( ) ; for ( String pathPart : path ) { try { finalPath . append ( <str> ) ; URI uri = new URI ( null , null , null , - <int> , pathPart , null , null ) ; finalPath . append ( uri . getRawPath ( ) . replaceAll ( <str> , <str> ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( <str> , e ) ; } } this . path = finalPath . toString ( ) ; return this ; } public HttpRequestBuilder addParam ( String name , String value ) { try { this . params . put ( name , URLEncoder . encode ( value , <str> ) ) ; return this ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } public HttpRequestBuilder addHeaders ( Headers headers ) { for ( String header : headers . headers ( ) . names ( ) ) { this . headers . put ( header , headers . headers ( ) . get ( header ) ) ; } return this ; } public HttpRequestBuilder addHeader ( String name , String value ) { this . headers . put ( name , value ) ; return this ; } public HttpRequestBuilder protocol ( String protocol ) { this . protocol = protocol ; return this ; } public HttpRequestBuilder method ( String method ) { this . method = method ; return this ; } public HttpRequestBuilder body ( String body ) { if ( Strings . hasLength ( body ) ) { this . body = body ; } return this ; } public HttpResponse execute ( ) throws IOException { HttpUriRequest httpUriRequest = buildRequest ( ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder stringBuilder = new StringBuilder ( httpUriRequest . getMethod ( ) ) . append ( <str> ) . append ( httpUriRequest . getURI ( ) ) ; if ( Strings . hasLength ( body ) ) { stringBuilder . append ( <str> ) . append ( body ) ; } logger . trace ( <str> , stringBuilder . toString ( ) ) ; } for ( Map . Entry < String , String > entry : this . headers . entrySet ( ) ) { httpUriRequest . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } try ( CloseableHttpResponse closeableHttpResponse = httpClient . execute ( httpUriRequest ) ) { HttpResponse httpResponse = new HttpResponse ( httpUriRequest , closeableHttpResponse ) ; logger . trace ( <str> , closeableHttpResponse , httpResponse . hasBody ( ) ? httpResponse . getBody ( ) : <str> ) ; return httpResponse ; } } private HttpUriRequest buildRequest ( ) { if ( HttpGetWithEntity . METHOD_NAME . equalsIgnoreCase ( method ) ) { return addOptionalBody ( new HttpGetWithEntity ( buildUri ( ) ) ) ; } if ( HttpHead . METHOD_NAME . equalsIgnoreCase ( method ) ) { checkBodyNotSupported ( ) ; return new HttpHead ( buildUri ( ) ) ; } if ( HttpOptions . METHOD_NAME . equalsIgnoreCase ( method ) ) { checkBodyNotSupported ( ) ; return new HttpOptions ( buildUri ( ) ) ; } if ( HttpDeleteWithEntity . METHOD_NAME . equalsIgnoreCase ( method ) ) { return addOptionalBody ( new HttpDeleteWithEntity ( buildUri ( ) ) ) ; } if ( HttpPut . METHOD_NAME . equalsIgnoreCase ( method ) ) { return addOptionalBody ( new HttpPut ( buildUri ( ) ) ) ; } if ( HttpPost . METHOD_NAME . equalsIgnoreCase ( method ) ) { return addOptionalBody ( new HttpPost ( buildUri ( ) ) ) ; } throw new UnsupportedOperationException ( <str> + method + <str> ) ; } private URI buildUri ( ) { StringBuilder uriBuilder = new StringBuilder ( protocol ) . append ( <str> ) . append ( host ) . append ( <str> ) . append ( port ) . append ( path ) ; if ( params . size ( ) > <int> ) { uriBuilder . append ( <str> ) . append ( params . entrySet ( ) . stream ( ) . map ( e - > e . getKey ( ) + <str> + e . getValue ( ) ) . collect ( Collectors . joining ( <str> ) ) ) ; } return URI . create ( uriBuilder . toString ( ) ) ; } private HttpEntityEnclosingRequestBase addOptionalBody ( HttpEntityEnclosingRequestBase requestBase ) { if ( Strings . hasText ( body ) ) { requestBase . setEntity ( new StringEntity ( body , DEFAULT_CHARSET ) ) ; } return requestBase ; } private void checkBodyNotSupported ( ) { if ( Strings . hasText ( body ) ) { throw new IllegalArgumentException ( <str> ) ; } } @Override public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( method ) . append ( <str> ) . append ( host ) . append ( <str> ) . append ( port ) . append ( path ) . append ( <str> ) ; if ( ! params . isEmpty ( ) ) { stringBuilder . append ( <str> ) . append ( params ) ; } if ( Strings . hasLength ( body ) ) { stringBuilder . append ( <str> ) . append ( body ) ; } return stringBuilder . toString ( ) ; } } 
