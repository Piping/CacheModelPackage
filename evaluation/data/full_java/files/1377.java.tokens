package org . apache . cassandra . cql3 . validation . entities ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . commons . lang3 . StringUtils ; import org . junit . BeforeClass ; import org . junit . Test ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class SecondaryIndexOnMapEntriesTest extends CQLTester { @BeforeClass public static void setUp ( ) { DatabaseDescriptor . setPartitionerUnsafe ( ByteOrderedPartitioner . instance ) ; } @Test public void testShouldNotCreateIndexOnFrozenMaps ( ) throws Throwable { createTable ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; } @Test public void testShouldNotCreateIndexOnNonMapTypes ( ) throws Throwable { createTable ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; assertIndexInvalidForColumn ( <str> ) ; } @Test public void testShouldValidateMapKeyAndValueTypes ( ) throws Throwable { createSimpleTableAndIndex ( ) ; String query = <str> ; Object validKey = <str> ; Object invalidKey = <int> ; Object validValue = <int> ; Object invalidValue = <str> ; assertInvalid ( query , invalidKey , invalidValue ) ; assertInvalid ( query , invalidKey , validValue ) ; assertInvalid ( query , validKey , invalidValue ) ; assertReturnsNoRows ( query , validKey , validValue ) ; } @Test public void testShouldFindRowsMatchingSingleEqualityRestriction ( ) throws Throwable { createSimpleTableAndIndex ( ) ; Object [ ] foo = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] bar = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] baz = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Object [ ] qux = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , baz , qux ) ; assertRowsForConditions ( entry ( <str> , <int> ) , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) , baz ) ; assertRowsForConditions ( entry ( <str> , <int> ) , baz , qux ) ; } @Test public void testRequireFilteringDirectiveIfMultipleRestrictionsSpecified ( ) throws Throwable { createSimpleTableAndIndex ( ) ; String baseQuery = <str> ; assertInvalid ( baseQuery ) ; assertReturnsNoRows ( baseQuery + <str> ) ; } @Test public void testShouldFindRowsMatchingMultipleEqualityRestrictions ( ) throws Throwable { createSimpleTableAndIndex ( ) ; Object [ ] foo = insertIntoSimpleTable ( <str> , map ( <str> , <int> ) ) ; Object [ ] bar = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] baz = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] qux = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) , bar ) ; assertNoRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) . entry ( <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) , baz , qux ) ; assertRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) . entry ( <str> , <int> ) , qux ) ; assertRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) , qux ) ; assertNoRowsForConditions ( entry ( <str> , <int> ) . entry ( <str> , <int> ) . entry ( <str> , <int> ) ) ; } @Test public void testShouldFindRowsMatchingEqualityAndContainsRestrictions ( ) throws Throwable { createSimpleTableAndIndex ( ) ; Object [ ] foo = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Object [ ] bar = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ) ; Object [ ] baz = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , baz , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) , bar , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , bar , foo ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , bar ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . key ( <str> ) , bar ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) , bar , baz ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , bar ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , bar , baz ) ; assertRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) , baz ) ; assertNoRowsForConditions ( entry ( <str> , <int> ) . key ( <str> ) . value ( <int> ) ) ; } @Test public void testShouldNotAcceptUnsupportedRelationsOnEntries ( ) throws Throwable { createSimpleTableAndIndex ( ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; assertInvalidRelation ( <str> ) ; } @Test public void testShouldRecognizeAlteredOrDeletedMapEntries ( ) throws Throwable { createSimpleTableAndIndex ( ) ; Object [ ] foo = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] bar = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; Object [ ] baz = insertIntoSimpleTable ( <str> , map ( <str> , <int> , <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , baz , foo ) ; baz = updateMapInSimpleTable ( baz , <str> , <int> ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , foo ) ; bar = updateMapInSimpleTable ( bar , <str> , null ) ; assertRowsForConditions ( entry ( <str> , <int> ) , foo ) ; execute ( <str> ) ; assertNoRowsForConditions ( entry ( <str> , <int> ) ) ; assertRowsForConditions ( entry ( <str> , <int> ) , bar , baz ) ; assertRowsForConditions ( entry ( <str> , <int> ) , baz ) ; } @Test public void testShouldRejectQueriesForNullEntries ( ) throws Throwable { createSimpleTableAndIndex ( ) ; assertInvalid ( <str> ) ; } @Test public void testShouldTreatQueriesAgainstFrozenMapIndexesAsInvalid ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; try { execute ( <str> ) ; fail ( <str> ) ; } catch ( InvalidRequestException e ) { String expectedMessage = <str> ; assertTrue ( <str> + expectedMessage + <str> + e . getMessage ( ) + <str> , e . getMessage ( ) . contains ( expectedMessage ) ) ; } } private void assertIndexInvalidForColumn ( String colname ) throws Throwable { String query = String . format ( <str> , colname ) ; assertInvalid ( query ) ; } private void assertReturnsNoRows ( String query , Object . . . params ) throws Throwable { assertRows ( execute ( query , params ) ) ; } private void createSimpleTableAndIndex ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; } private Object [ ] insertIntoSimpleTable ( String key , Object value ) throws Throwable { String query = <str> ; execute ( query , key , value ) ; return row ( key , value ) ; } private void assertRowsForConditions ( IndexWhereClause whereClause , Object [ ] . . . rows ) throws Throwable { assertRows ( execute ( <str> + whereClause . text ( ) , whereClause . params ( ) ) , rows ) ; } private void assertNoRowsForConditions ( IndexWhereClause whereClause ) throws Throwable { assertRowsForConditions ( whereClause ) ; } private void assertInvalidRelation ( String rel ) throws Throwable { String query = <str> + rel ; assertInvalid ( query ) ; } private Object [ ] updateMapInSimpleTable ( Object [ ] row , String mapKey , Integer mapValue ) throws Throwable { execute ( <str> , mapKey , mapValue , row [ <int> ] ) ; UntypedResultSet rawResults = execute ( <str> , row [ <int> ] ) ; Map < Object , Object > value = ( Map < Object , Object > ) row [ <int> ] ; if ( mapValue = = null ) { value . remove ( mapKey ) ; } else { value . put ( mapKey , mapValue ) ; } return row ; } private IndexWhereClause entry ( Object key , Object value ) { return ( new IndexWhereClause ( ) ) . entry ( key , value ) ; } private static final class IndexWhereClause { private final List < String > preds = new ArrayList < > ( ) ; private final List < Object > params = new ArrayList < > ( ) ; public IndexWhereClause entry ( Object key , Object value ) { preds . add ( <str> ) ; params . add ( key ) ; params . add ( value ) ; return this ; } public IndexWhereClause key ( Object key ) { preds . add ( <str> ) ; params . add ( key ) ; return this ; } public IndexWhereClause value ( Object value ) { preds . add ( <str> ) ; params . add ( value ) ; return this ; } public String text ( ) { if ( preds . size ( ) = = <int> ) return preds . get ( <int> ) ; return StringUtils . join ( preds , <str> ) + <str> ; } public Object [ ] params ( ) { return params . toArray ( ) ; } } } 
