package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . base . Joiner ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . cql3 . statements . StatementType ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . btree . BTreeSet ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkNotNull ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; public final class StatementRestrictions { public static final String NO_INDEX_FOUND_MESSAGE = <str> ; private final StatementType type ; public final CFMetaData cfm ; private PrimaryKeyRestrictions partitionKeyRestrictions ; private PrimaryKeyRestrictions clusteringColumnsRestrictions ; private RestrictionSet nonPrimaryKeyRestrictions ; private Set < ColumnDefinition > notNullColumns ; private final IndexRestrictions indexRestrictions = new IndexRestrictions ( ) ; private boolean usesSecondaryIndexing ; private boolean isKeyRange ; public static StatementRestrictions empty ( StatementType type , CFMetaData cfm ) { return new StatementRestrictions ( type , cfm ) ; } private StatementRestrictions ( StatementType type , CFMetaData cfm ) { this . type = type ; this . cfm = cfm ; this . partitionKeyRestrictions = new PrimaryKeyRestrictionSet ( cfm . getKeyValidatorAsClusteringComparator ( ) , true ) ; this . clusteringColumnsRestrictions = new PrimaryKeyRestrictionSet ( cfm . comparator , false ) ; this . nonPrimaryKeyRestrictions = new RestrictionSet ( ) ; this . notNullColumns = new HashSet < > ( ) ; } public StatementRestrictions ( StatementType type , CFMetaData cfm , WhereClause whereClause , VariableSpecifications boundNames , boolean selectsOnlyStaticColumns , boolean selectACollection , boolean useFiltering , boolean forView ) throws InvalidRequestException { this ( type , cfm ) ; for ( Relation relation : whereClause . relations ) { if ( relation . operator ( ) = = Operator . IS_NOT ) { if ( ! forView ) throw new InvalidRequestException ( <str> + relation ) ; for ( ColumnDefinition def : relation . toRestriction ( cfm , boundNames ) . getColumnDefs ( ) ) this . notNullColumns . add ( def ) ; } else { addRestriction ( relation . toRestriction ( cfm , boundNames ) ) ; } } boolean hasQueriableClusteringColumnIndex = false ; boolean hasQueriableIndex = false ; if ( type . allowUseOfSecondaryIndices ( ) ) { ColumnFamilyStore cfs = Keyspace . open ( cfm . ksName ) . getColumnFamilyStore ( cfm . cfName ) ; SecondaryIndexManager secondaryIndexManager = cfs . indexManager ; if ( whereClause . containsCustomExpressions ( ) ) processCustomIndexExpressions ( whereClause . expressions , boundNames , secondaryIndexManager ) ; hasQueriableClusteringColumnIndex = clusteringColumnsRestrictions . hasSupportingIndex ( secondaryIndexManager ) ; hasQueriableIndex = ! indexRestrictions . getCustomIndexExpressions ( ) . isEmpty ( ) | | hasQueriableClusteringColumnIndex | | partitionKeyRestrictions . hasSupportingIndex ( secondaryIndexManager ) | | nonPrimaryKeyRestrictions . hasSupportingIndex ( secondaryIndexManager ) ; } processPartitionKeyRestrictions ( hasQueriableIndex ) ; if ( usesSecondaryIndexing ) indexRestrictions . add ( partitionKeyRestrictions ) ; if ( selectsOnlyStaticColumns & & hasClusteringColumnsRestriction ( ) ) { if ( type . isDelete ( ) | | type . isUpdate ( ) ) throw invalidRequest ( <str> , type ) ; if ( type . isSelect ( ) ) throw invalidRequest ( <str> ) ; } processClusteringColumnsRestrictions ( hasQueriableIndex , selectsOnlyStaticColumns , selectACollection , forView ) ; if ( isKeyRange & & hasQueriableClusteringColumnIndex ) usesSecondaryIndexing = true ; usesSecondaryIndexing = usesSecondaryIndexing | | clusteringColumnsRestrictions . isContains ( ) ; if ( usesSecondaryIndexing ) indexRestrictions . add ( clusteringColumnsRestrictions ) ; if ( ! nonPrimaryKeyRestrictions . isEmpty ( ) ) { if ( ! type . allowNonPrimaryKeyInWhereClause ( ) ) { Collection < ColumnIdentifier > nonPrimaryKeyColumns = ColumnDefinition . toIdentifiers ( nonPrimaryKeyRestrictions . getColumnDefs ( ) ) ; throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( nonPrimaryKeyColumns ) ) ; } if ( hasQueriableIndex ) usesSecondaryIndexing = true ; else if ( ! useFiltering ) throw invalidRequest ( NO_INDEX_FOUND_MESSAGE ) ; indexRestrictions . add ( nonPrimaryKeyRestrictions ) ; } if ( usesSecondaryIndexing ) validateSecondaryIndexSelections ( selectsOnlyStaticColumns ) ; } private void addRestriction ( Restriction restriction ) { if ( restriction . isMultiColumn ( ) ) clusteringColumnsRestrictions = clusteringColumnsRestrictions . mergeWith ( restriction ) ; else if ( restriction . isOnToken ( ) ) partitionKeyRestrictions = partitionKeyRestrictions . mergeWith ( restriction ) ; else addSingleColumnRestriction ( ( SingleColumnRestriction ) restriction ) ; } public Iterable < Function > getFunctions ( ) { return Iterables . concat ( partitionKeyRestrictions . getFunctions ( ) , clusteringColumnsRestrictions . getFunctions ( ) , nonPrimaryKeyRestrictions . getFunctions ( ) ) ; } private void addSingleColumnRestriction ( SingleColumnRestriction restriction ) { ColumnDefinition def = restriction . columnDef ; if ( def . isPartitionKey ( ) ) partitionKeyRestrictions = partitionKeyRestrictions . mergeWith ( restriction ) ; else if ( def . isClusteringColumn ( ) ) clusteringColumnsRestrictions = clusteringColumnsRestrictions . mergeWith ( restriction ) ; else nonPrimaryKeyRestrictions = nonPrimaryKeyRestrictions . addRestriction ( restriction ) ; } public Set < ColumnDefinition > nonPKRestrictedColumns ( boolean includeNotNullRestrictions ) { Set < ColumnDefinition > columns = new HashSet < > ( ) ; for ( Restrictions r : indexRestrictions . getRestrictions ( ) ) { for ( ColumnDefinition def : r . getColumnDefs ( ) ) if ( ! def . isPrimaryKeyColumn ( ) ) columns . add ( def ) ; } if ( includeNotNullRestrictions ) { for ( ColumnDefinition def : notNullColumns ) { if ( ! def . isPrimaryKeyColumn ( ) ) columns . add ( def ) ; } } return columns ; } public Set < ColumnDefinition > notNullColumns ( ) { return notNullColumns ; } public boolean isRestricted ( ColumnDefinition column ) { if ( notNullColumns . contains ( column ) ) return true ; else if ( column . isPartitionKey ( ) ) return partitionKeyRestrictions . getColumnDefs ( ) . contains ( column ) ; else if ( column . isClusteringColumn ( ) ) return clusteringColumnsRestrictions . getColumnDefs ( ) . contains ( column ) ; else return nonPrimaryKeyRestrictions . getColumnDefs ( ) . contains ( column ) ; } public boolean keyIsInRelation ( ) { return partitionKeyRestrictions . isIN ( ) ; } public boolean isKeyRange ( ) { return this . isKeyRange ; } public boolean usesSecondaryIndexing ( ) { return this . usesSecondaryIndexing ; } private void processPartitionKeyRestrictions ( boolean hasQueriableIndex ) { if ( ! type . allowPartitionKeyRanges ( ) ) { checkFalse ( partitionKeyRestrictions . isOnToken ( ) , <str> , type ) ; if ( hasUnrestrictedPartitionKeyComponents ( ) ) throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( getPartitionKeyUnrestrictedComponents ( ) ) ) ; } else { if ( partitionKeyRestrictions . isOnToken ( ) ) isKeyRange = true ; if ( hasUnrestrictedPartitionKeyComponents ( ) ) { if ( ! partitionKeyRestrictions . isEmpty ( ) ) { if ( ! hasQueriableIndex ) throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( getPartitionKeyUnrestrictedComponents ( ) ) ) ; } isKeyRange = true ; usesSecondaryIndexing = hasQueriableIndex ; } } } private boolean hasUnrestrictedPartitionKeyComponents ( ) { return partitionKeyRestrictions . size ( ) < cfm . partitionKeyColumns ( ) . size ( ) ; } public boolean hasPartitionKeyRestrictions ( ) { return ! partitionKeyRestrictions . isEmpty ( ) ; } private Collection < ColumnIdentifier > getPartitionKeyUnrestrictedComponents ( ) { List < ColumnDefinition > list = new ArrayList < > ( cfm . partitionKeyColumns ( ) ) ; list . removeAll ( partitionKeyRestrictions . getColumnDefs ( ) ) ; return ColumnDefinition . toIdentifiers ( list ) ; } public boolean isPartitionKeyRestrictionsOnToken ( ) { return partitionKeyRestrictions . isOnToken ( ) ; } private void processClusteringColumnsRestrictions ( boolean hasQueriableIndex , boolean selectsOnlyStaticColumns , boolean selectACollection , boolean forView ) throws InvalidRequestException { checkFalse ( ! type . allowClusteringColumnSlices ( ) & & clusteringColumnsRestrictions . isSlice ( ) , <str> , type ) ; if ( ! type . allowClusteringColumnSlices ( ) & & ( ! cfm . isCompactTable ( ) | | ( cfm . isCompactTable ( ) & & ! hasClusteringColumnsRestriction ( ) ) ) ) { if ( ! selectsOnlyStaticColumns & & hasUnrestrictedClusteringColumns ( ) ) throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( getUnrestrictedClusteringColumns ( ) ) ) ; } else { checkFalse ( clusteringColumnsRestrictions . isIN ( ) & & selectACollection , <str> ) ; checkFalse ( clusteringColumnsRestrictions . isContains ( ) & & ! hasQueriableIndex , <str> ) ; if ( hasClusteringColumnsRestriction ( ) ) { List < ColumnDefinition > clusteringColumns = cfm . clusteringColumns ( ) ; List < ColumnDefinition > restrictedColumns = new LinkedList < > ( clusteringColumnsRestrictions . getColumnDefs ( ) ) ; for ( int i = <int> , m = restrictedColumns . size ( ) ; i < m ; i + + ) { ColumnDefinition clusteringColumn = clusteringColumns . get ( i ) ; ColumnDefinition restrictedColumn = restrictedColumns . get ( i ) ; if ( ! clusteringColumn . equals ( restrictedColumn ) ) { checkTrue ( hasQueriableIndex | | forView , <str> , restrictedColumn . name , clusteringColumn . name ) ; usesSecondaryIndexing = true ; break ; } } } } if ( clusteringColumnsRestrictions . isContains ( ) ) usesSecondaryIndexing = true ; } private Collection < ColumnIdentifier > getUnrestrictedClusteringColumns ( ) { List < ColumnDefinition > missingClusteringColumns = new ArrayList < > ( cfm . clusteringColumns ( ) ) ; missingClusteringColumns . removeAll ( new LinkedList < > ( clusteringColumnsRestrictions . getColumnDefs ( ) ) ) ; return ColumnDefinition . toIdentifiers ( missingClusteringColumns ) ; } private boolean hasUnrestrictedClusteringColumns ( ) { return cfm . clusteringColumns ( ) . size ( ) ! = clusteringColumnsRestrictions . size ( ) ; } private void processCustomIndexExpressions ( List < CustomIndexExpression > expressions , VariableSpecifications boundNames , SecondaryIndexManager indexManager ) { if ( ! MessagingService . instance ( ) . areAllNodesAtLeast30 ( ) ) throw new InvalidRequestException ( <str> ) ; if ( expressions . size ( ) > <int> ) throw new InvalidRequestException ( IndexRestrictions . MULTIPLE_EXPRESSIONS ) ; CustomIndexExpression expression = expressions . get ( <int> ) ; CFName cfName = expression . targetIndex . getCfName ( ) ; if ( cfName . hasKeyspace ( ) & & ! expression . targetIndex . getKeyspace ( ) . equals ( cfm . ksName ) ) throw IndexRestrictions . invalidIndex ( expression . targetIndex , cfm ) ; if ( cfName . getColumnFamily ( ) ! = null & & ! cfName . getColumnFamily ( ) . equals ( cfm . cfName ) ) throw IndexRestrictions . invalidIndex ( expression . targetIndex , cfm ) ; if ( ! cfm . getIndexes ( ) . has ( expression . targetIndex . getIdx ( ) ) ) throw IndexRestrictions . indexNotFound ( expression . targetIndex , cfm ) ; Index index = indexManager . getIndex ( cfm . getIndexes ( ) . get ( expression . targetIndex . getIdx ( ) ) . get ( ) ) ; if ( ! index . getIndexMetadata ( ) . isCustom ( ) ) throw IndexRestrictions . nonCustomIndexInExpression ( expression . targetIndex ) ; AbstractType < ? > expressionType = index . customExpressionValueType ( ) ; if ( expressionType = = null ) throw IndexRestrictions . customExpressionNotSupported ( expression . targetIndex ) ; expression . prepareValue ( cfm , expressionType , boundNames ) ; indexRestrictions . add ( expression ) ; } public RowFilter getRowFilter ( SecondaryIndexManager indexManager , QueryOptions options ) { if ( indexRestrictions . isEmpty ( ) ) return RowFilter . NONE ; RowFilter filter = RowFilter . create ( ) ; for ( Restrictions restrictions : indexRestrictions . getRestrictions ( ) ) restrictions . addRowFilterTo ( filter , indexManager , options ) ; for ( CustomIndexExpression expression : indexRestrictions . getCustomIndexExpressions ( ) ) expression . addToRowFilter ( filter , cfm , options ) ; return filter ; } public List < ByteBuffer > getPartitionKeys ( final QueryOptions options ) { return partitionKeyRestrictions . values ( options ) ; } private ByteBuffer getPartitionKeyBound ( Bound b , QueryOptions options ) { if ( hasUnrestrictedPartitionKeyComponents ( ) ) return ByteBufferUtil . EMPTY_BYTE_BUFFER ; return partitionKeyRestrictions . bounds ( b , options ) . get ( <int> ) ; } public AbstractBounds < PartitionPosition > getPartitionKeyBounds ( QueryOptions options ) { IPartitioner p = cfm . partitioner ; if ( partitionKeyRestrictions . isOnToken ( ) ) { return getPartitionKeyBoundsForTokenRestrictions ( p , options ) ; } return getPartitionKeyBounds ( p , options ) ; } private AbstractBounds < PartitionPosition > getPartitionKeyBounds ( IPartitioner p , QueryOptions options ) { ByteBuffer startKeyBytes = getPartitionKeyBound ( Bound . START , options ) ; ByteBuffer finishKeyBytes = getPartitionKeyBound ( Bound . END , options ) ; PartitionPosition startKey = PartitionPosition . ForKey . get ( startKeyBytes , p ) ; PartitionPosition finishKey = PartitionPosition . ForKey . get ( finishKeyBytes , p ) ; if ( startKey . compareTo ( finishKey ) > <int> & & ! finishKey . isMinimum ( ) ) return null ; if ( partitionKeyRestrictions . isInclusive ( Bound . START ) ) { return partitionKeyRestrictions . isInclusive ( Bound . END ) ? new Bounds < > ( startKey , finishKey ) : new IncludingExcludingBounds < > ( startKey , finishKey ) ; } return partitionKeyRestrictions . isInclusive ( Bound . END ) ? new Range < > ( startKey , finishKey ) : new ExcludingBounds < > ( startKey , finishKey ) ; } private AbstractBounds < PartitionPosition > getPartitionKeyBoundsForTokenRestrictions ( IPartitioner p , QueryOptions options ) { Token startToken = getTokenBound ( Bound . START , options , p ) ; Token endToken = getTokenBound ( Bound . END , options , p ) ; boolean includeStart = partitionKeyRestrictions . isInclusive ( Bound . START ) ; boolean includeEnd = partitionKeyRestrictions . isInclusive ( Bound . END ) ; int cmp = startToken . compareTo ( endToken ) ; if ( ! startToken . isMinimum ( ) & & ! endToken . isMinimum ( ) & & ( cmp > <int> | | ( cmp = = <int> & & ( ! includeStart | | ! includeEnd ) ) ) ) return null ; PartitionPosition start = includeStart ? startToken . minKeyBound ( ) : startToken . maxKeyBound ( ) ; PartitionPosition end = includeEnd ? endToken . maxKeyBound ( ) : endToken . minKeyBound ( ) ; return new Range < > ( start , end ) ; } private Token getTokenBound ( Bound b , QueryOptions options , IPartitioner p ) { if ( ! partitionKeyRestrictions . hasBound ( b ) ) return p . getMinimumToken ( ) ; ByteBuffer value = partitionKeyRestrictions . bounds ( b , options ) . get ( <int> ) ; checkNotNull ( value , <str> ) ; return p . getTokenFactory ( ) . fromByteArray ( value ) ; } public boolean hasClusteringColumnsRestriction ( ) { return ! clusteringColumnsRestrictions . isEmpty ( ) ; } public NavigableSet < Clustering > getClusteringColumns ( QueryOptions options ) { if ( cfm . isStaticCompactTable ( ) ) return BTreeSet . empty ( cfm . comparator ) ; return clusteringColumnsRestrictions . valuesAsClustering ( options ) ; } public NavigableSet < Slice . Bound > getClusteringColumnsBounds ( Bound b , QueryOptions options ) { return clusteringColumnsRestrictions . boundsAsClustering ( b , options ) ; } public boolean areRequestedBoundsInclusive ( Bound bound ) { return clusteringColumnsRestrictions . isInclusive ( bound ) ; } public boolean isColumnRange ( ) { int numberOfClusteringColumns = cfm . isStaticCompactTable ( ) ? <int> : cfm . clusteringColumns ( ) . size ( ) ; return clusteringColumnsRestrictions . size ( ) < numberOfClusteringColumns | | ( ! clusteringColumnsRestrictions . isEQ ( ) & & ! clusteringColumnsRestrictions . isIN ( ) ) ; } public boolean needFiltering ( ) { int numberOfRestrictions = indexRestrictions . getCustomIndexExpressions ( ) . size ( ) ; for ( Restrictions restrictions : indexRestrictions . getRestrictions ( ) ) numberOfRestrictions + = restrictions . size ( ) ; return numberOfRestrictions > <int> | | ( numberOfRestrictions = = <int> & & ! clusteringColumnsRestrictions . isEmpty ( ) ) | | ( numberOfRestrictions ! = <int> & & nonPrimaryKeyRestrictions . hasMultipleContains ( ) ) ; } private void validateSecondaryIndexSelections ( boolean selectsOnlyStaticColumns ) { checkFalse ( keyIsInRelation ( ) , <str> ) ; checkFalse ( selectsOnlyStaticColumns , <str> ) ; } public boolean hasAllPKColumnsRestrictedByEqualities ( ) { return ! isPartitionKeyRestrictionsOnToken ( ) & & ! hasUnrestrictedPartitionKeyComponents ( ) & & ( partitionKeyRestrictions . isEQ ( ) | | partitionKeyRestrictions . isIN ( ) ) & & ! hasUnrestrictedClusteringColumns ( ) & & ( clusteringColumnsRestrictions . isEQ ( ) | | clusteringColumnsRestrictions . isIN ( ) ) ; } } 
