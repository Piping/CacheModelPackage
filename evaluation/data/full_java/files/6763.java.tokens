package org . elasticsearch . index . shard ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . index . IndexWriterConfig ; import org . apache . lucene . index . SegmentInfos ; import org . apache . lucene . store . Directory ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RestoreSource ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . engine . EngineException ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . index . snapshots . IndexShardRestoreFailedException ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . indices . recovery . RecoveryState ; import java . io . IOException ; import java . util . Arrays ; import static org . elasticsearch . common . unit . TimeValue . timeValueMillis ; final class StoreRecovery { private final ESLogger logger ; private final ShardId shardId ; StoreRecovery ( ShardId shardId , ESLogger logger ) { this . logger = logger ; this . shardId = shardId ; } boolean recoverFromStore ( final IndexShard indexShard , final boolean indexShouldExists , DiscoveryNode localNode ) { if ( canRecover ( indexShard ) ) { if ( indexShard . routingEntry ( ) . restoreSource ( ) ! = null ) { throw new IllegalStateException ( <str> ) ; } return executeRecovery ( indexShard , ( ) - > { logger . debug ( <str> ) ; internalRecoverFromStore ( indexShard , indexShouldExists ) ; } ) ; } return false ; } boolean recoverFromRepository ( final IndexShard indexShard , IndexShardRepository repository , DiscoveryNode localNode ) { if ( canRecover ( indexShard ) ) { final ShardRouting shardRouting = indexShard . routingEntry ( ) ; if ( shardRouting . restoreSource ( ) = = null ) { throw new IllegalStateException ( <str> ) ; } return executeRecovery ( indexShard , ( ) - > { logger . debug ( <str> , shardRouting . restoreSource ( ) ) ; restore ( indexShard , repository ) ; } ) ; } return false ; } private boolean canRecover ( IndexShard indexShard ) { if ( indexShard . state ( ) = = IndexShardState . CLOSED ) { return false ; } if ( ! indexShard . routingEntry ( ) . primary ( ) ) { throw new IndexShardRecoveryException ( shardId , <str> , null ) ; } return true ; } private boolean executeRecovery ( final IndexShard indexShard , Runnable recoveryRunnable ) throws IndexShardRecoveryException { try { recoveryRunnable . run ( ) ; final IndexShardState shardState = indexShard . state ( ) ; final RecoveryState recoveryState = indexShard . recoveryState ( ) ; assert shardState ! = IndexShardState . CREATED & & shardState ! = IndexShardState . RECOVERING : <str> + shardId + <str> + shardState + <str> ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( <str> ) . append ( <str> ) . append ( timeValueMillis ( recoveryState . getTimer ( ) . time ( ) ) ) . append ( <str> ) ; RecoveryState . Index index = recoveryState . getIndex ( ) ; sb . append ( <str> ) . append ( index . totalFileCount ( ) ) . append ( <str> ) . append ( new ByteSizeValue ( index . totalBytes ( ) ) ) . append ( <str> ) . append ( TimeValue . timeValueMillis ( index . time ( ) ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( index . recoveredFileCount ( ) ) . append ( <str> ) . append ( new ByteSizeValue ( index . recoveredBytes ( ) ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( index . reusedFileCount ( ) ) . append ( <str> ) . append ( new ByteSizeValue ( index . reusedBytes ( ) ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( TimeValue . timeValueMillis ( recoveryState . getVerifyIndex ( ) . time ( ) ) ) . append ( <str> ) . append ( timeValueMillis ( recoveryState . getVerifyIndex ( ) . checkIndexTime ( ) ) ) . append ( <str> ) ; sb . append ( <str> ) . append ( recoveryState . getTranslog ( ) . recoveredOperations ( ) ) . append ( <str> ) . append ( TimeValue . timeValueMillis ( recoveryState . getTranslog ( ) . time ( ) ) ) . append ( <str> ) ; logger . trace ( sb . toString ( ) ) ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , timeValueMillis ( recoveryState . getTimer ( ) . time ( ) ) ) ; } return true ; } catch ( IndexShardRecoveryException e ) { if ( indexShard . state ( ) = = IndexShardState . CLOSED ) { return false ; } if ( ( e . getCause ( ) instanceof IndexShardClosedException ) | | ( e . getCause ( ) instanceof IndexShardNotStartedException ) ) { return false ; } throw e ; } catch ( IndexShardClosedException | IndexShardNotStartedException e ) { } catch ( Exception e ) { if ( indexShard . state ( ) = = IndexShardState . CLOSED ) { return false ; } throw new IndexShardRecoveryException ( shardId , <str> , e ) ; } return false ; } private void internalRecoverFromStore ( IndexShard indexShard , boolean indexShouldExists ) throws IndexShardRecoveryException { final RecoveryState recoveryState = indexShard . recoveryState ( ) ; indexShard . prepareForIndexRecovery ( ) ; long version = - <int> ; SegmentInfos si = null ; final Store store = indexShard . store ( ) ; store . incRef ( ) ; try { try { store . failIfCorrupted ( ) ; try { si = store . readLastCommittedSegmentsInfo ( ) ; } catch ( Throwable e ) { String files = <str> ; try { files = Arrays . toString ( store . directory ( ) . listAll ( ) ) ; } catch ( Throwable e1 ) { files + = <str> + ExceptionsHelper . detailedMessage ( e1 ) + <str> ; } if ( indexShouldExists ) { throw new IndexShardRecoveryException ( shardId , <str> + files , e ) ; } } if ( si ! = null ) { if ( indexShouldExists ) { version = si . getVersion ( ) ; } else { logger . trace ( <str> ) ; IndexWriter writer = new IndexWriter ( store . directory ( ) , new IndexWriterConfig ( Lucene . STANDARD_ANALYZER ) . setOpenMode ( IndexWriterConfig . OpenMode . CREATE ) ) ; writer . close ( ) ; recoveryState . getTranslog ( ) . totalOperations ( <int> ) ; } } } catch ( Throwable e ) { throw new IndexShardRecoveryException ( shardId , <str> , e ) ; } recoveryState . getIndex ( ) . updateVersion ( version ) ; try { final RecoveryState . Index index = recoveryState . getIndex ( ) ; if ( si ! = null ) { final Directory directory = store . directory ( ) ; for ( String name : Lucene . files ( si ) ) { long length = directory . fileLength ( name ) ; index . addFileDetail ( name , length , true ) ; } } } catch ( IOException e ) { logger . debug ( <str> , e ) ; } if ( indexShouldExists = = false ) { recoveryState . getTranslog ( ) . totalOperations ( <int> ) ; recoveryState . getTranslog ( ) . totalOperationsOnStart ( <int> ) ; } indexShard . performTranslogRecovery ( indexShouldExists ) ; indexShard . finalizeRecovery ( ) ; indexShard . postRecovery ( <str> ) ; } catch ( EngineException e ) { throw new IndexShardRecoveryException ( shardId , <str> , e ) ; } finally { store . decRef ( ) ; } } private void restore ( final IndexShard indexShard , final IndexShardRepository indexShardRepository ) { RestoreSource restoreSource = indexShard . routingEntry ( ) . restoreSource ( ) ; final RecoveryState . Translog translogState = indexShard . recoveryState ( ) . getTranslog ( ) ; if ( restoreSource = = null ) { throw new IndexShardRestoreFailedException ( shardId , <str> ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , restoreSource . snapshotId ( ) , shardId ) ; } try { translogState . totalOperations ( <int> ) ; translogState . totalOperationsOnStart ( <int> ) ; indexShard . prepareForIndexRecovery ( ) ; ShardId snapshotShardId = shardId ; if ( ! shardId . getIndex ( ) . equals ( restoreSource . index ( ) ) ) { snapshotShardId = new ShardId ( restoreSource . index ( ) , shardId . id ( ) ) ; } indexShardRepository . restore ( restoreSource . snapshotId ( ) , restoreSource . version ( ) , shardId , snapshotShardId , indexShard . recoveryState ( ) ) ; indexShard . skipTranslogRecovery ( ) ; indexShard . finalizeRecovery ( ) ; indexShard . postRecovery ( <str> ) ; } catch ( Throwable t ) { throw new IndexShardRestoreFailedException ( shardId , <str> , t ) ; } } } 
