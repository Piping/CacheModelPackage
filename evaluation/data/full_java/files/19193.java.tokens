package io . netty . handler . codec . http . websocketx ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . util . CharsetUtil ; import static io . netty . handler . codec . http . HttpVersion . * ; public class WebSocketServerHandshaker08 extends WebSocketServerHandshaker { public static final String WEBSOCKET_08_ACCEPT_GUID = <str> ; private final boolean allowExtensions ; private final boolean allowMaskMismatch ; public WebSocketServerHandshaker08 ( String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength ) { this ( webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength , false ) ; } public WebSocketServerHandshaker08 ( String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength , boolean allowMaskMismatch ) { super ( WebSocketVersion . V08 , webSocketURL , subprotocols , maxFramePayloadLength ) ; this . allowExtensions = allowExtensions ; this . allowMaskMismatch = allowMaskMismatch ; } @Override protected FullHttpResponse newHandshakeResponse ( FullHttpRequest req , HttpHeaders headers ) { FullHttpResponse res = new DefaultFullHttpResponse ( HTTP_1_1 , HttpResponseStatus . SWITCHING_PROTOCOLS ) ; if ( headers ! = null ) { res . headers ( ) . add ( headers ) ; } CharSequence key = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_KEY ) ; if ( key = = null ) { throw new WebSocketHandshakeException ( <str> ) ; } String acceptSeed = key + WEBSOCKET_08_ACCEPT_GUID ; byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; String accept = WebSocketUtil . base64 ( sha1 ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , key , accept ) ; } res . headers ( ) . add ( HttpHeaderNames . UPGRADE , HttpHeaderValues . WEBSOCKET ) ; res . headers ( ) . add ( HttpHeaderNames . CONNECTION , HttpHeaderValues . UPGRADE ) ; res . headers ( ) . add ( HttpHeaderNames . SEC_WEBSOCKET_ACCEPT , accept ) ; String subprotocols = req . headers ( ) . get ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL ) ; if ( subprotocols ! = null ) { String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; if ( selectedSubprotocol = = null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , subprotocols ) ; } } else { res . headers ( ) . add ( HttpHeaderNames . SEC_WEBSOCKET_PROTOCOL , selectedSubprotocol ) ; } } return res ; } @Override protected WebSocketFrameDecoder newWebsocketDecoder ( ) { return new WebSocket08FrameDecoder ( true , allowExtensions , maxFramePayloadLength ( ) , allowMaskMismatch ) ; } @Override protected WebSocketFrameEncoder newWebSocketEncoder ( ) { return new WebSocket08FrameEncoder ( false ) ; } } 
