package com . nostra13 . universalimageloader . core . decode ; import android . graphics . Bitmap ; import android . graphics . BitmapFactory ; import android . graphics . BitmapFactory . Options ; import android . graphics . Matrix ; import android . media . ExifInterface ; import com . nostra13 . universalimageloader . core . assist . ImageScaleType ; import com . nostra13 . universalimageloader . core . assist . ImageSize ; import com . nostra13 . universalimageloader . core . download . ImageDownloader . Scheme ; import com . nostra13 . universalimageloader . utils . ImageSizeUtils ; import com . nostra13 . universalimageloader . utils . IoUtils ; import com . nostra13 . universalimageloader . utils . L ; import java . io . IOException ; import java . io . InputStream ; public class BaseImageDecoder implements ImageDecoder { protected static final String LOG_SUBSAMPLE_IMAGE = <str> ; protected static final String LOG_SCALE_IMAGE = <str> ; protected static final String LOG_ROTATE_IMAGE = <str> ; protected static final String LOG_FLIP_IMAGE = <str> ; protected static final String ERROR_NO_IMAGE_STREAM = <str> ; protected static final String ERROR_CANT_DECODE_IMAGE = <str> ; protected final boolean loggingEnabled ; public BaseImageDecoder ( boolean loggingEnabled ) { this . loggingEnabled = loggingEnabled ; } @Override public Bitmap decode ( ImageDecodingInfo decodingInfo ) throws IOException { Bitmap decodedBitmap ; ImageFileInfo imageInfo ; InputStream imageStream = getImageStream ( decodingInfo ) ; if ( imageStream = = null ) { L . e ( ERROR_NO_IMAGE_STREAM , decodingInfo . getImageKey ( ) ) ; return null ; } try { imageInfo = defineImageSizeAndRotation ( imageStream , decodingInfo ) ; imageStream = resetStream ( imageStream , decodingInfo ) ; Options decodingOptions = prepareDecodingOptions ( imageInfo . imageSize , decodingInfo ) ; decodedBitmap = BitmapFactory . decodeStream ( imageStream , null , decodingOptions ) ; } finally { IoUtils . closeSilently ( imageStream ) ; } if ( decodedBitmap = = null ) { L . e ( ERROR_CANT_DECODE_IMAGE , decodingInfo . getImageKey ( ) ) ; } else { decodedBitmap = considerExactScaleAndOrientatiton ( decodedBitmap , decodingInfo , imageInfo . exif . rotation , imageInfo . exif . flipHorizontal ) ; } return decodedBitmap ; } protected InputStream getImageStream ( ImageDecodingInfo decodingInfo ) throws IOException { return decodingInfo . getDownloader ( ) . getStream ( decodingInfo . getImageUri ( ) , decodingInfo . getExtraForDownloader ( ) ) ; } protected ImageFileInfo defineImageSizeAndRotation ( InputStream imageStream , ImageDecodingInfo decodingInfo ) throws IOException { Options options = new Options ( ) ; options . inJustDecodeBounds = true ; BitmapFactory . decodeStream ( imageStream , null , options ) ; ExifInfo exif ; String imageUri = decodingInfo . getImageUri ( ) ; if ( decodingInfo . shouldConsiderExifParams ( ) & & canDefineExifParams ( imageUri , options . outMimeType ) ) { exif = defineExifOrientation ( imageUri ) ; } else { exif = new ExifInfo ( ) ; } return new ImageFileInfo ( new ImageSize ( options . outWidth , options . outHeight , exif . rotation ) , exif ) ; } private boolean canDefineExifParams ( String imageUri , String mimeType ) { return <str> . equalsIgnoreCase ( mimeType ) & & ( Scheme . ofUri ( imageUri ) = = Scheme . FILE ) ; } protected ExifInfo defineExifOrientation ( String imageUri ) { int rotation = <int> ; boolean flip = false ; try { ExifInterface exif = new ExifInterface ( Scheme . FILE . crop ( imageUri ) ) ; int exifOrientation = exif . getAttributeInt ( ExifInterface . TAG_ORIENTATION , ExifInterface . ORIENTATION_NORMAL ) ; switch ( exifOrientation ) { case ExifInterface . ORIENTATION_FLIP_HORIZONTAL : flip = true ; case ExifInterface . ORIENTATION_NORMAL : rotation = <int> ; break ; case ExifInterface . ORIENTATION_TRANSVERSE : flip = true ; case ExifInterface . ORIENTATION_ROTATE_90 : rotation = <int> ; break ; case ExifInterface . ORIENTATION_FLIP_VERTICAL : flip = true ; case ExifInterface . ORIENTATION_ROTATE_180 : rotation = <int> ; break ; case ExifInterface . ORIENTATION_TRANSPOSE : flip = true ; case ExifInterface . ORIENTATION_ROTATE_270 : rotation = <int> ; break ; } } catch ( IOException e ) { L . w ( <str> , imageUri ) ; } return new ExifInfo ( rotation , flip ) ; } protected Options prepareDecodingOptions ( ImageSize imageSize , ImageDecodingInfo decodingInfo ) { ImageScaleType scaleType = decodingInfo . getImageScaleType ( ) ; int scale ; if ( scaleType = = ImageScaleType . NONE ) { scale = <int> ; } else if ( scaleType = = ImageScaleType . NONE_SAFE ) { scale = ImageSizeUtils . computeMinImageSampleSize ( imageSize ) ; } else { ImageSize targetSize = decodingInfo . getTargetSize ( ) ; boolean powerOf2 = scaleType = = ImageScaleType . IN_SAMPLE_POWER_OF_2 ; scale = ImageSizeUtils . computeImageSampleSize ( imageSize , targetSize , decodingInfo . getViewScaleType ( ) , powerOf2 ) ; } if ( scale > <int> & & loggingEnabled ) { L . d ( LOG_SUBSAMPLE_IMAGE , imageSize , imageSize . scaleDown ( scale ) , scale , decodingInfo . getImageKey ( ) ) ; } Options decodingOptions = decodingInfo . getDecodingOptions ( ) ; decodingOptions . inSampleSize = scale ; return decodingOptions ; } protected InputStream resetStream ( InputStream imageStream , ImageDecodingInfo decodingInfo ) throws IOException { if ( imageStream . markSupported ( ) ) { try { imageStream . reset ( ) ; return imageStream ; } catch ( IOException ignored ) { } } IoUtils . closeSilently ( imageStream ) ; return getImageStream ( decodingInfo ) ; } protected Bitmap considerExactScaleAndOrientatiton ( Bitmap subsampledBitmap , ImageDecodingInfo decodingInfo , int rotation , boolean flipHorizontal ) { Matrix m = new Matrix ( ) ; ImageScaleType scaleType = decodingInfo . getImageScaleType ( ) ; if ( scaleType = = ImageScaleType . EXACTLY | | scaleType = = ImageScaleType . EXACTLY_STRETCHED ) { ImageSize srcSize = new ImageSize ( subsampledBitmap . getWidth ( ) , subsampledBitmap . getHeight ( ) , rotation ) ; float scale = ImageSizeUtils . computeImageScale ( srcSize , decodingInfo . getTargetSize ( ) , decodingInfo . getViewScaleType ( ) , scaleType = = ImageScaleType . EXACTLY_STRETCHED ) ; if ( Float . compare ( scale , <float> ) ! = <int> ) { m . setScale ( scale , scale ) ; if ( loggingEnabled ) { L . d ( LOG_SCALE_IMAGE , srcSize , srcSize . scale ( scale ) , scale , decodingInfo . getImageKey ( ) ) ; } } } if ( flipHorizontal ) { m . postScale ( - <int> , <int> ) ; if ( loggingEnabled ) L . d ( LOG_FLIP_IMAGE , decodingInfo . getImageKey ( ) ) ; } if ( rotation ! = <int> ) { m . postRotate ( rotation ) ; if ( loggingEnabled ) L . d ( LOG_ROTATE_IMAGE , rotation , decodingInfo . getImageKey ( ) ) ; } Bitmap finalBitmap = Bitmap . createBitmap ( subsampledBitmap , <int> , <int> , subsampledBitmap . getWidth ( ) , subsampledBitmap . getHeight ( ) , m , true ) ; if ( finalBitmap ! = subsampledBitmap ) { subsampledBitmap . recycle ( ) ; } return finalBitmap ; } protected static class ExifInfo { public final int rotation ; public final boolean flipHorizontal ; protected ExifInfo ( ) { this . rotation = <int> ; this . flipHorizontal = false ; } protected ExifInfo ( int rotation , boolean flipHorizontal ) { this . rotation = rotation ; this . flipHorizontal = flipHorizontal ; } } protected static class ImageFileInfo { public final ImageSize imageSize ; public final ExifInfo exif ; protected ImageFileInfo ( ImageSize imageSize , ExifInfo exif ) { this . imageSize = imageSize ; this . exif = exif ; } } } 
