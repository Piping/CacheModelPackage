package io . netty . channel ; import io . netty . buffer . ByteBufUtil ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . ThreadLocalRandom ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . reflect . Method ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . regex . Pattern ; final class DefaultChannelId implements ChannelId { private static final long serialVersionUID = <int> ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DefaultChannelId . class ) ; private static final Pattern MACHINE_ID_PATTERN = Pattern . compile ( <str> ) ; private static final int MACHINE_ID_LEN = <int> ; private static final byte [ ] MACHINE_ID ; private static final int PROCESS_ID_LEN = <int> ; private static final int MAX_PROCESS_ID = <int> ; private static final int PROCESS_ID ; private static final int SEQUENCE_LEN = <int> ; private static final int TIMESTAMP_LEN = <int> ; private static final int RANDOM_LEN = <int> ; private static final AtomicInteger nextSequence = new AtomicInteger ( ) ; static ChannelId newInstance ( ) { DefaultChannelId id = new DefaultChannelId ( ) ; id . init ( ) ; return id ; } static { int processId = - <int> ; String customProcessId = SystemPropertyUtil . get ( <str> ) ; if ( customProcessId ! = null ) { try { processId = Integer . parseInt ( customProcessId ) ; } catch ( NumberFormatException e ) { } if ( processId < <int> | | processId > MAX_PROCESS_ID ) { processId = - <int> ; logger . warn ( <str> , customProcessId ) ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , processId ) ; } } if ( processId < <int> ) { processId = defaultProcessId ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , processId ) ; } } PROCESS_ID = processId ; byte [ ] machineId = null ; String customMachineId = SystemPropertyUtil . get ( <str> ) ; if ( customMachineId ! = null ) { if ( MACHINE_ID_PATTERN . matcher ( customMachineId ) . matches ( ) ) { machineId = parseMachineId ( customMachineId ) ; logger . debug ( <str> , customMachineId ) ; } else { logger . warn ( <str> , customMachineId ) ; } } if ( machineId = = null ) { machineId = defaultMachineId ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , formatAddress ( machineId ) ) ; } } MACHINE_ID = machineId ; } @SuppressWarnings ( <str> ) private static byte [ ] parseMachineId ( String value ) { value = value . replaceAll ( <str> , <str> ) ; byte [ ] machineId = new byte [ MACHINE_ID_LEN ] ; for ( int i = <int> ; i < value . length ( ) ; i + = <int> ) { machineId [ i ] = ( byte ) Integer . parseInt ( value . substring ( i , i + <int> ) , <int> ) ; } return machineId ; } private static byte [ ] defaultMachineId ( ) { final byte [ ] NOT_FOUND = { - <int> } ; byte [ ] bestMacAddr = NOT_FOUND ; InetAddress bestInetAddr = null ; try { bestInetAddr = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } catch ( UnknownHostException e ) { PlatformDependent . throwException ( e ) ; } Map < NetworkInterface , InetAddress > ifaces = new LinkedHashMap < NetworkInterface , InetAddress > ( ) ; try { for ( Enumeration < NetworkInterface > i = NetworkInterface . getNetworkInterfaces ( ) ; i . hasMoreElements ( ) ; ) { NetworkInterface iface = i . nextElement ( ) ; Enumeration < InetAddress > addrs = iface . getInetAddresses ( ) ; if ( addrs . hasMoreElements ( ) ) { InetAddress a = addrs . nextElement ( ) ; if ( ! a . isLoopbackAddress ( ) ) { ifaces . put ( iface , a ) ; } } } } catch ( SocketException e ) { logger . warn ( <str> , e ) ; } for ( Entry < NetworkInterface , InetAddress > entry : ifaces . entrySet ( ) ) { NetworkInterface iface = entry . getKey ( ) ; InetAddress inetAddr = entry . getValue ( ) ; if ( iface . isVirtual ( ) ) { continue ; } byte [ ] macAddr ; try { macAddr = iface . getHardwareAddress ( ) ; } catch ( SocketException e ) { logger . debug ( <str> , iface , e ) ; continue ; } boolean replace = false ; int res = compareAddresses ( bestMacAddr , macAddr ) ; if ( res < <int> ) { replace = true ; } else if ( res = = <int> ) { res = compareAddresses ( bestInetAddr , inetAddr ) ; if ( res < <int> ) { replace = true ; } else if ( res = = <int> ) { if ( bestMacAddr . length < macAddr . length ) { replace = true ; } } } if ( replace ) { bestMacAddr = macAddr ; bestInetAddr = inetAddr ; } } if ( bestMacAddr = = NOT_FOUND ) { bestMacAddr = new byte [ MACHINE_ID_LEN ] ; ThreadLocalRandom . current ( ) . nextBytes ( bestMacAddr ) ; logger . warn ( <str> , formatAddress ( bestMacAddr ) ) ; } switch ( bestMacAddr . length ) { case <int> : byte [ ] newAddr = new byte [ MACHINE_ID_LEN ] ; System . arraycopy ( bestMacAddr , <int> , newAddr , <int> , <int> ) ; newAddr [ <int> ] = ( byte ) <hex> ; newAddr [ <int> ] = ( byte ) <hex> ; System . arraycopy ( bestMacAddr , <int> , newAddr , <int> , <int> ) ; bestMacAddr = newAddr ; break ; default : bestMacAddr = Arrays . copyOf ( bestMacAddr , MACHINE_ID_LEN ) ; } return bestMacAddr ; } private static int compareAddresses ( byte [ ] current , byte [ ] candidate ) { if ( candidate = = null ) { return <int> ; } if ( candidate . length < <int> ) { return <int> ; } boolean onlyZeroAndOne = true ; for ( byte b : candidate ) { if ( b ! = <int> & & b ! = <int> ) { onlyZeroAndOne = false ; break ; } } if ( onlyZeroAndOne ) { return <int> ; } if ( ( candidate [ <int> ] & <int> ) ! = <int> ) { return <int> ; } if ( ( current [ <int> ] & <int> ) = = <int> ) { if ( ( candidate [ <int> ] & <int> ) = = <int> ) { return <int> ; } else { return <int> ; } } else { if ( ( candidate [ <int> ] & <int> ) = = <int> ) { return - <int> ; } else { return <int> ; } } } private static int compareAddresses ( InetAddress current , InetAddress candidate ) { return scoreAddress ( current ) - scoreAddress ( candidate ) ; } private static int scoreAddress ( InetAddress addr ) { if ( addr . isAnyLocalAddress ( ) | | addr . isLoopbackAddress ( ) ) { return <int> ; } if ( addr . isMulticastAddress ( ) ) { return <int> ; } if ( addr . isLinkLocalAddress ( ) ) { return <int> ; } if ( addr . isSiteLocalAddress ( ) ) { return <int> ; } return <int> ; } private static String formatAddress ( byte [ ] addr ) { StringBuilder buf = new StringBuilder ( <int> ) ; for ( byte b : addr ) { buf . append ( String . format ( <str> , b & <hex> ) ) ; } return buf . substring ( <int> , buf . length ( ) - <int> ) ; } private static int defaultProcessId ( ) { final ClassLoader loader = PlatformDependent . getSystemClassLoader ( ) ; String value ; try { Class < ? > mgmtFactoryType = Class . forName ( <str> , true , loader ) ; Class < ? > runtimeMxBeanType = Class . forName ( <str> , true , loader ) ; Method getRuntimeMXBean = mgmtFactoryType . getMethod ( <str> , EmptyArrays . EMPTY_CLASSES ) ; Object bean = getRuntimeMXBean . invoke ( null , EmptyArrays . EMPTY_OBJECTS ) ; Method getName = runtimeMxBeanType . getDeclaredMethod ( <str> , EmptyArrays . EMPTY_CLASSES ) ; value = ( String ) getName . invoke ( bean , EmptyArrays . EMPTY_OBJECTS ) ; } catch ( Exception e ) { logger . debug ( <str> , e ) ; try { Class < ? > processType = Class . forName ( <str> , true , loader ) ; Method myPid = processType . getMethod ( <str> , EmptyArrays . EMPTY_CLASSES ) ; value = myPid . invoke ( null , EmptyArrays . EMPTY_OBJECTS ) . toString ( ) ; } catch ( Exception e2 ) { logger . debug ( <str> , e2 ) ; value = <str> ; } } int atIndex = value . indexOf ( <str> ) ; if ( atIndex > = <int> ) { value = value . substring ( <int> , atIndex ) ; } int pid ; try { pid = Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { pid = - <int> ; } if ( pid < <int> | | pid > MAX_PROCESS_ID ) { pid = ThreadLocalRandom . current ( ) . nextInt ( MAX_PROCESS_ID + <int> ) ; logger . warn ( <str> , value , pid ) ; } return pid ; } private final byte [ ] data = new byte [ MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN + RANDOM_LEN ] ; private int hashCode ; private transient String shortValue ; private transient String longValue ; private void init ( ) { int i = <int> ; System . arraycopy ( MACHINE_ID , <int> , data , i , MACHINE_ID_LEN ) ; i + = MACHINE_ID_LEN ; i = writeInt ( i , PROCESS_ID ) ; i = writeInt ( i , nextSequence . getAndIncrement ( ) ) ; i = writeLong ( i , Long . reverse ( System . nanoTime ( ) ) ^ System . currentTimeMillis ( ) ) ; int random = ThreadLocalRandom . current ( ) . nextInt ( ) ; hashCode = random ; i = writeInt ( i , random ) ; assert i = = data . length ; } private int writeInt ( int i , int value ) { data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) value ; return i ; } private int writeLong ( int i , long value ) { data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) ( value > > > <int> ) ; data [ i + + ] = ( byte ) value ; return i ; } @Override public String asShortText ( ) { String shortValue = this . shortValue ; if ( shortValue = = null ) { this . shortValue = shortValue = ByteBufUtil . hexDump ( data , MACHINE_ID_LEN + PROCESS_ID_LEN + SEQUENCE_LEN + TIMESTAMP_LEN , RANDOM_LEN ) ; } return shortValue ; } @Override public String asLongText ( ) { String longValue = this . longValue ; if ( longValue = = null ) { this . longValue = longValue = newLongValue ( ) ; } return longValue ; } private String newLongValue ( ) { StringBuilder buf = new StringBuilder ( <int> * data . length + <int> ) ; int i = <int> ; i = appendHexDumpField ( buf , i , MACHINE_ID_LEN ) ; i = appendHexDumpField ( buf , i , PROCESS_ID_LEN ) ; i = appendHexDumpField ( buf , i , SEQUENCE_LEN ) ; i = appendHexDumpField ( buf , i , TIMESTAMP_LEN ) ; i = appendHexDumpField ( buf , i , RANDOM_LEN ) ; assert i = = data . length ; return buf . substring ( <int> , buf . length ( ) - <int> ) ; } private int appendHexDumpField ( StringBuilder buf , int i , int length ) { buf . append ( ByteBufUtil . hexDump ( data , i , length ) ) ; buf . append ( <str> ) ; i + = length ; return i ; } @Override public int hashCode ( ) { return hashCode ; } @Override public int compareTo ( ChannelId o ) { return <int> ; } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof DefaultChannelId ) ) { return false ; } return Arrays . equals ( data , ( ( DefaultChannelId ) obj ) . data ) ; } @Override public String toString ( ) { return asShortText ( ) ; } } 
