package org . elasticsearch . index . mapper . geo ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . GeoUtils ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . test . VersionUtils ; import org . hamcrest . MatcherAssert ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class GeohashMappingGeoPointTests extends ESSingleNodeTestCase { public void testLatLonValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testLatLonInOneValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; if ( version . before ( Version . V_2_2_0 ) ) { assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } else { assertThat ( Long . parseLong ( doc . rootDoc ( ) . get ( <str> ) ) , equalTo ( GeoUtils . mortonHash ( <float> , <float> ) ) ) ; } } public void testGeoHashValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( GeoHashUtils . stringEncode ( <float> , <float> ) ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , notNullValue ( ) ) ; } public void testGeoHashPrecisionAsInteger ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( BaseGeoPointFieldMapper . class ) ) ; BaseGeoPointFieldMapper geoPointFieldMapper = ( BaseGeoPointFieldMapper ) mapper ; assertThat ( geoPointFieldMapper . fieldType ( ) . geoHashPrecision ( ) , is ( <int> ) ) ; } public void testGeoHashPrecisionAsLength ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; FieldMapper mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( BaseGeoPointFieldMapper . class ) ) ; BaseGeoPointFieldMapper geoPointFieldMapper = ( BaseGeoPointFieldMapper ) mapper ; assertThat ( geoPointFieldMapper . fieldType ( ) . geoHashPrecision ( ) , is ( <int> ) ) ; } public void testNullValue ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; DocumentMapper defaultMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , ( Object ) null ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , nullValue ( ) ) ; } } 
