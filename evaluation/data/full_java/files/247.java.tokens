package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . HashMultiset ; import com . google . common . collect . Multiset ; import org . apache . commons . lang3 . StringUtils ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . schema . TableParams ; import org . apache . cassandra . schema . Types ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . Event ; public class CreateTableStatement extends SchemaAlteringStatement { private List < AbstractType < ? > > keyTypes ; private List < AbstractType < ? > > clusteringTypes ; private final Map < ByteBuffer , CollectionType > collections = new HashMap < > ( ) ; private final List < ColumnIdentifier > keyAliases = new ArrayList < > ( ) ; private final List < ColumnIdentifier > columnAliases = new ArrayList < > ( ) ; private boolean isDense ; private boolean isCompound ; private boolean hasCounters ; private final Map < ColumnIdentifier , AbstractType > columns = new TreeMap < > ( ( o1 , o2 ) - > o1 . bytes . compareTo ( o2 . bytes ) ) ; private final Set < ColumnIdentifier > staticColumns ; private final TableParams params ; private final boolean ifNotExists ; public CreateTableStatement ( CFName name , TableParams params , boolean ifNotExists , Set < ColumnIdentifier > staticColumns ) { super ( name ) ; this . params = params ; this . ifNotExists = ifNotExists ; this . staticColumns = staticColumns ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . hasKeyspaceAccess ( keyspace ( ) , Permission . CREATE ) ; } public void validate ( ClientState state ) { } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { try { MigrationManager . announceNewColumnFamily ( getCFMetaData ( ) , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , keyspace ( ) , columnFamily ( ) ) ; } catch ( AlreadyExistsException e ) { if ( ifNotExists ) return null ; throw e ; } } protected void grantPermissionsToCreator ( QueryState state ) { try { IResource resource = DataResource . table ( keyspace ( ) , columnFamily ( ) ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , resource . applicablePermissions ( ) , resource , RoleResource . role ( state . getClientState ( ) . getUser ( ) . getName ( ) ) ) ; } catch ( RequestExecutionException e ) { throw new RuntimeException ( e ) ; } } public CFMetaData . Builder metadataBuilder ( ) { CFMetaData . Builder builder = CFMetaData . Builder . create ( keyspace ( ) , columnFamily ( ) , isDense , isCompound , hasCounters ) ; for ( int i = <int> ; i < keyAliases . size ( ) ; i + + ) builder . addPartitionKey ( keyAliases . get ( i ) , keyTypes . get ( i ) ) ; for ( int i = <int> ; i < columnAliases . size ( ) ; i + + ) builder . addClusteringColumn ( columnAliases . get ( i ) , clusteringTypes . get ( i ) ) ; boolean isStaticCompact = ! isDense & & ! isCompound ; for ( Map . Entry < ColumnIdentifier , AbstractType > entry : columns . entrySet ( ) ) { ColumnIdentifier name = entry . getKey ( ) ; if ( staticColumns . contains ( name ) | | isStaticCompact ) builder . addStaticColumn ( name , entry . getValue ( ) ) ; else builder . addRegularColumn ( name , entry . getValue ( ) ) ; } boolean isCompactTable = isDense | | ! isCompound ; if ( isCompactTable ) { CompactTables . DefaultNames names = CompactTables . defaultNameGenerator ( builder . usedColumnNames ( ) ) ; if ( isStaticCompact ) { builder . addClusteringColumn ( names . defaultClusteringName ( ) , UTF8Type . instance ) ; builder . addRegularColumn ( names . defaultCompactValueName ( ) , hasCounters ? CounterColumnType . instance : BytesType . instance ) ; } else if ( isDense & & ! builder . hasRegulars ( ) ) { builder . addRegularColumn ( names . defaultCompactValueName ( ) , EmptyType . instance ) ; } } return builder ; } public CFMetaData getCFMetaData ( ) { return metadataBuilder ( ) . build ( ) . params ( params ) ; } public TableParams params ( ) { return params ; } public static class RawStatement extends CFStatement { private final Map < ColumnIdentifier , CQL3Type . Raw > definitions = new HashMap < > ( ) ; public final CFProperties properties = new CFProperties ( ) ; private final List < List < ColumnIdentifier > > keyAliases = new ArrayList < > ( ) ; private final List < ColumnIdentifier > columnAliases = new ArrayList < > ( ) ; private final Set < ColumnIdentifier > staticColumns = new HashSet < > ( ) ; private final Multiset < ColumnIdentifier > definedNames = HashMultiset . create ( <int> ) ; private final boolean ifNotExists ; public RawStatement ( CFName name , boolean ifNotExists ) { super ( name ) ; this . ifNotExists = ifNotExists ; } public ParsedStatement . Prepared prepare ( ) throws RequestValidationException { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( keyspace ( ) ) ; if ( ksm = = null ) throw new ConfigurationException ( String . format ( <str> , keyspace ( ) ) ) ; return prepare ( ksm . types ) ; } public ParsedStatement . Prepared prepare ( Types udts ) throws RequestValidationException { if ( ! columnFamily ( ) . matches ( <str> ) ) throw new InvalidRequestException ( String . format ( <str> , columnFamily ( ) ) ) ; if ( columnFamily ( ) . length ( ) > Schema . NAME_LENGTH ) throw new InvalidRequestException ( String . format ( <str> , Schema . NAME_LENGTH , columnFamily ( ) ) ) ; for ( Multiset . Entry < ColumnIdentifier > entry : definedNames . entrySet ( ) ) if ( entry . getCount ( ) > <int> ) throw new InvalidRequestException ( String . format ( <str> , entry . getElement ( ) ) ) ; properties . validate ( ) ; TableParams params = properties . properties . asNewTableParams ( ) ; CreateTableStatement stmt = new CreateTableStatement ( cfName , params , ifNotExists , staticColumns ) ; for ( Map . Entry < ColumnIdentifier , CQL3Type . Raw > entry : definitions . entrySet ( ) ) { ColumnIdentifier id = entry . getKey ( ) ; CQL3Type pt = entry . getValue ( ) . prepare ( keyspace ( ) , udts ) ; if ( pt . isCollection ( ) & & ( ( CollectionType ) pt . getType ( ) ) . isMultiCell ( ) ) stmt . collections . put ( id . bytes , ( CollectionType ) pt . getType ( ) ) ; if ( entry . getValue ( ) . isCounter ( ) ) stmt . hasCounters = true ; stmt . columns . put ( id , pt . getType ( ) ) ; } if ( keyAliases . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; if ( keyAliases . size ( ) > <int> ) throw new InvalidRequestException ( <str> ) ; if ( stmt . hasCounters & & params . defaultTimeToLive > <int> ) throw new InvalidRequestException ( <str> ) ; List < ColumnIdentifier > kAliases = keyAliases . get ( <int> ) ; stmt . keyTypes = new ArrayList < > ( kAliases . size ( ) ) ; for ( ColumnIdentifier alias : kAliases ) { stmt . keyAliases . add ( alias ) ; AbstractType < ? > t = getTypeAndRemove ( stmt . columns , alias ) ; if ( t instanceof CounterColumnType ) throw new InvalidRequestException ( String . format ( <str> , alias ) ) ; if ( staticColumns . contains ( alias ) ) throw new InvalidRequestException ( String . format ( <str> , alias ) ) ; stmt . keyTypes . add ( t ) ; } stmt . clusteringTypes = new ArrayList < > ( columnAliases . size ( ) ) ; for ( ColumnIdentifier t : columnAliases ) { stmt . columnAliases . add ( t ) ; AbstractType < ? > type = getTypeAndRemove ( stmt . columns , t ) ; if ( type instanceof CounterColumnType ) throw new InvalidRequestException ( String . format ( <str> , t ) ) ; if ( staticColumns . contains ( t ) ) throw new InvalidRequestException ( String . format ( <str> , t ) ) ; stmt . clusteringTypes . add ( type ) ; } if ( stmt . hasCounters ) { for ( AbstractType < ? > type : stmt . columns . values ( ) ) if ( ! type . isCounter ( ) ) throw new InvalidRequestException ( <str> ) ; } boolean useCompactStorage = properties . useCompactStorage ; stmt . isDense = useCompactStorage & & ! stmt . clusteringTypes . isEmpty ( ) ; stmt . isCompound = ! ( useCompactStorage & & stmt . clusteringTypes . size ( ) < = <int> ) ; if ( useCompactStorage ) { if ( ! stmt . collections . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; if ( ! staticColumns . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; if ( stmt . clusteringTypes . isEmpty ( ) ) { if ( stmt . columns . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; } if ( stmt . isDense ) { if ( stmt . columns . size ( ) > <int> ) throw new InvalidRequestException ( String . format ( <str> , StringUtils . join ( stmt . columns . keySet ( ) , <str> ) ) ) ; } else { if ( stmt . columns . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; } } else { if ( stmt . clusteringTypes . isEmpty ( ) & & ! staticColumns . isEmpty ( ) ) { if ( columnAliases . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; } } if ( ! properties . definedOrdering . isEmpty ( ) ) { if ( properties . definedOrdering . size ( ) > columnAliases . size ( ) ) throw new InvalidRequestException ( <str> ) ; int i = <int> ; for ( ColumnIdentifier id : properties . definedOrdering . keySet ( ) ) { ColumnIdentifier c = columnAliases . get ( i ) ; if ( ! id . equals ( c ) ) { if ( properties . definedOrdering . containsKey ( c ) ) throw new InvalidRequestException ( String . format ( <str> , c , id ) ) ; else throw new InvalidRequestException ( String . format ( <str> , c ) ) ; } + + i ; } } return new ParsedStatement . Prepared ( stmt ) ; } private AbstractType < ? > getTypeAndRemove ( Map < ColumnIdentifier , AbstractType > columns , ColumnIdentifier t ) throws InvalidRequestException { AbstractType type = columns . get ( t ) ; if ( type = = null ) throw new InvalidRequestException ( String . format ( <str> , t ) ) ; if ( type . isCollection ( ) & & type . isMultiCell ( ) ) throw new InvalidRequestException ( String . format ( <str> , t ) ) ; columns . remove ( t ) ; Boolean isReversed = properties . definedOrdering . get ( t ) ; return isReversed ! = null & & isReversed ? ReversedType . getInstance ( type ) : type ; } public void addDefinition ( ColumnIdentifier def , CQL3Type . Raw type , boolean isStatic ) { definedNames . add ( def ) ; definitions . put ( def , type ) ; if ( isStatic ) staticColumns . add ( def ) ; } public void addKeyAliases ( List < ColumnIdentifier > aliases ) { keyAliases . add ( aliases ) ; } public void addColumnAlias ( ColumnIdentifier alias ) { columnAliases . add ( alias ) ; } } } 
