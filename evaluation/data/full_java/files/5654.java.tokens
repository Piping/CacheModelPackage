package org . elasticsearch . common ; import org . apache . lucene . util . BytesRef ; public final class Numbers { private Numbers ( ) { } public static short bytesToShort ( byte [ ] arr ) { return ( short ) ( ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( arr [ <int> ] & <hex> ) ) ; } public static short bytesToShort ( BytesRef bytes ) { return ( short ) ( ( ( bytes . bytes [ bytes . offset ] & <hex> ) < < <int> ) | ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) ) ; } public static int bytesToInt ( byte [ ] arr ) { return ( arr [ <int> ] < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( arr [ <int> ] & <hex> ) ; } public static int bytesToInt ( BytesRef bytes ) { return ( bytes . bytes [ bytes . offset ] < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) ; } public static long bytesToLong ( byte [ ] arr ) { int high = ( arr [ <int> ] < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( arr [ <int> ] & <hex> ) ; int low = ( arr [ <int> ] < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( ( arr [ <int> ] & <hex> ) < < <int> ) | ( arr [ <int> ] & <hex> ) ; return ( ( ( long ) high ) < < <int> ) | ( low & <hex> ) ; } public static long bytesToLong ( BytesRef bytes ) { int high = ( bytes . bytes [ bytes . offset + <int> ] < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) ; int low = ( bytes . bytes [ bytes . offset + <int> ] < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) < < <int> ) | ( bytes . bytes [ bytes . offset + <int> ] & <hex> ) ; return ( ( ( long ) high ) < < <int> ) | ( low & <hex> ) ; } public static float bytesToFloat ( byte [ ] arr ) { return Float . intBitsToFloat ( bytesToInt ( arr ) ) ; } public static float bytesToFloat ( BytesRef bytes ) { return Float . intBitsToFloat ( bytesToInt ( bytes ) ) ; } public static double bytesToDouble ( byte [ ] arr ) { return Double . longBitsToDouble ( bytesToLong ( arr ) ) ; } public static double bytesToDouble ( BytesRef bytes ) { return Double . longBitsToDouble ( bytesToLong ( bytes ) ) ; } public static byte [ ] intToBytes ( int val ) { byte [ ] arr = new byte [ <int> ] ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val ) ; return arr ; } public static byte [ ] shortToBytes ( int val ) { byte [ ] arr = new byte [ <int> ] ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val ) ; return arr ; } public static byte [ ] longToBytes ( long val ) { byte [ ] arr = new byte [ <int> ] ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val > > > <int> ) ; arr [ <int> ] = ( byte ) ( val ) ; return arr ; } public static byte [ ] floatToBytes ( float val ) { return intToBytes ( Float . floatToRawIntBits ( val ) ) ; } public static byte [ ] doubleToBytes ( double val ) { return longToBytes ( Double . doubleToRawLongBits ( val ) ) ; } public static boolean isValidDouble ( double value ) { if ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) { return false ; } return true ; } } 
