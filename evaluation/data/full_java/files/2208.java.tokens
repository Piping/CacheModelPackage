package org . nd4j . linalg . indexing ; import com . google . common . base . Function ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . api . shape . loop . coordinatefunction . CoordinateFunction ; import org . nd4j . linalg . indexing . conditions . Condition ; import java . util . concurrent . atomic . AtomicBoolean ; public class BooleanIndexing { public static boolean and ( IComplexNDArray n , Condition cond ) { boolean ret = true ; IComplexNDArray linear = n . linearView ( ) ; for ( int i = <int> ; i < linear . length ( ) ; i + + ) { ret = ret & & cond . apply ( linear . getComplex ( i ) ) ; } return ret ; } public static boolean or ( IComplexNDArray n , Condition cond ) { boolean ret = false ; IComplexNDArray linear = n . linearView ( ) ; for ( int i = <int> ; i < linear . length ( ) ; i + + ) { ret = ret | | cond . apply ( linear . getComplex ( i ) ) ; } return ret ; } public static boolean and ( final INDArray n , final Condition cond ) { boolean ret = true ; final AtomicBoolean a = new AtomicBoolean ( ret ) ; Shape . iterate ( n , new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { a . set ( a . get ( ) & & cond . apply ( n . getFloat ( coord [ <int> ] ) ) ) ; } } ) ; return ret ; } public static boolean or ( final INDArray n , final Condition cond ) { boolean ret = false ; final AtomicBoolean a = new AtomicBoolean ( ret ) ; Shape . iterate ( n , new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { a . set ( a . get ( ) | | cond . apply ( n . getFloat ( coord [ <int> ] ) ) ) ; } } ) ; return ret ; } public static void applyWhere ( final INDArray to , final Condition condition , final Function < Number , Number > function ) { Shape . iterate ( to , new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { if ( condition . apply ( to . getDouble ( coord [ <int> ] ) ) ) to . putScalar ( coord [ <int> ] , function . apply ( to . getDouble ( coord [ <int> ] ) ) . floatValue ( ) ) ; } } ) ; } public static void applyWhere ( final INDArray to , final Condition condition , final Function < Number , Number > function , final Function < Number , Number > alternativeFunction ) { Shape . iterate ( to , new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { if ( condition . apply ( to . getFloat ( coord [ <int> ] ) ) ) { to . putScalar ( coord [ <int> ] , function . apply ( to . getDouble ( coord [ <int> ] ) ) . floatValue ( ) ) ; } else { to . putScalar ( coord [ <int> ] , alternativeFunction . apply ( to . getDouble ( coord [ <int> ] ) ) . floatValue ( ) ) ; } } } ) ; } public static void applyWhere ( IComplexNDArray to , Condition condition , Function < IComplexNumber , IComplexNumber > function ) { IComplexNDArray linear = to . linearView ( ) ; for ( int i = <int> ; i < linear . linearView ( ) . length ( ) ; i + + ) { if ( condition . apply ( linear . getFloat ( i ) ) ) { linear . putScalar ( i , function . apply ( linear . getComplex ( i ) ) ) ; } } } } 
