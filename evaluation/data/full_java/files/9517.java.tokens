package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static com . google . common . util . concurrent . MoreExecutors . rejectionPropagatingExecutor ; import static com . google . common . util . concurrent . Uninterruptibles . getUninterruptibly ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . errorprone . annotations . ForOverride ; import java . lang . reflect . UndeclaredThrowableException ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import javax . annotation . Nullable ; @GwtCompatible abstract class AbstractTransformFuture < I , O , F > extends AbstractFuture . TrustedFuture < O > implements Runnable { static < I , O > ListenableFuture < O > create ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function ) { AsyncTransformFuture < I , O > output = new AsyncTransformFuture < I , O > ( input , function ) ; input . addListener ( output , directExecutor ( ) ) ; return output ; } static < I , O > ListenableFuture < O > create ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function , Executor executor ) { checkNotNull ( executor ) ; AsyncTransformFuture < I , O > output = new AsyncTransformFuture < I , O > ( input , function ) ; input . addListener ( output , rejectionPropagatingExecutor ( executor , output ) ) ; return output ; } static < I , O > ListenableFuture < O > create ( ListenableFuture < I > input , Function < ? super I , ? extends O > function ) { checkNotNull ( function ) ; TransformFuture < I , O > output = new TransformFuture < I , O > ( input , function ) ; input . addListener ( output , directExecutor ( ) ) ; return output ; } static < I , O > ListenableFuture < O > create ( ListenableFuture < I > input , Function < ? super I , ? extends O > function , Executor executor ) { checkNotNull ( function ) ; TransformFuture < I , O > output = new TransformFuture < I , O > ( input , function ) ; input . addListener ( output , rejectionPropagatingExecutor ( executor , output ) ) ; return output ; } @Nullable ListenableFuture < ? extends I > inputFuture ; @Nullable F function ; AbstractTransformFuture ( ListenableFuture < ? extends I > inputFuture , F function ) { this . inputFuture = checkNotNull ( inputFuture ) ; this . function = checkNotNull ( function ) ; } @Override public final void run ( ) { try { ListenableFuture < ? extends I > localInputFuture = inputFuture ; F localFunction = function ; if ( isCancelled ( ) | localInputFuture = = null | localFunction = = null ) { return ; } inputFuture = null ; function = null ; I sourceResult ; try { sourceResult = getUninterruptibly ( localInputFuture ) ; } catch ( CancellationException e ) { cancel ( false ) ; return ; } catch ( ExecutionException e ) { setException ( e . getCause ( ) ) ; return ; } doTransform ( localFunction , sourceResult ) ; } catch ( UndeclaredThrowableException e ) { setException ( e . getCause ( ) ) ; } catch ( Throwable t ) { setException ( t ) ; } } @ForOverride abstract void doTransform ( F function , I result ) throws Exception ; @Override final void done ( ) { maybePropagateCancellation ( inputFuture ) ; this . inputFuture = null ; this . function = null ; } private static final class AsyncTransformFuture < I , O > extends AbstractTransformFuture < I , O , AsyncFunction < ? super I , ? extends O > > { AsyncTransformFuture ( ListenableFuture < ? extends I > inputFuture , AsyncFunction < ? super I , ? extends O > function ) { super ( inputFuture , function ) ; } @Override void doTransform ( AsyncFunction < ? super I , ? extends O > function , I input ) throws Exception { ListenableFuture < ? extends O > outputFuture = function . apply ( input ) ; checkNotNull ( outputFuture , <str> + <str> ) ; setFuture ( outputFuture ) ; } } private static final class TransformFuture < I , O > extends AbstractTransformFuture < I , O , Function < ? super I , ? extends O > > { TransformFuture ( ListenableFuture < ? extends I > inputFuture , Function < ? super I , ? extends O > function ) { super ( inputFuture , function ) ; } @Override void doTransform ( Function < ? super I , ? extends O > function , I input ) { set ( function . apply ( input ) ) ; } } } 
