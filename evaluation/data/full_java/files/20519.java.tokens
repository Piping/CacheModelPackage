package com . nostra13 . universalimageloader . cache . disc . impl . ext ; import java . io . BufferedWriter ; import java . io . Closeable ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . FilterOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; final class DiskLruCache implements Closeable { static final String JOURNAL_FILE = <str> ; static final String JOURNAL_FILE_TEMP = <str> ; static final String JOURNAL_FILE_BACKUP = <str> ; static final String MAGIC = <str> ; static final String VERSION_1 = <str> ; static final long ANY_SEQUENCE_NUMBER = - <int> ; static final Pattern LEGAL_KEY_PATTERN = Pattern . compile ( <str> ) ; private static final String CLEAN = <str> ; private static final String DIRTY = <str> ; private static final String REMOVE = <str> ; private static final String READ = <str> ; private final File directory ; private final File journalFile ; private final File journalFileTmp ; private final File journalFileBackup ; private final int appVersion ; private long maxSize ; private int maxFileCount ; private final int valueCount ; private long size = <int> ; private int fileCount = <int> ; private Writer journalWriter ; private final LinkedHashMap < String , Entry > lruEntries = new LinkedHashMap < String , Entry > ( <int> , <float> , true ) ; private int redundantOpCount ; private long nextSequenceNumber = <int> ; final ThreadPoolExecutor executorService = new ThreadPoolExecutor ( <int> , <int> , <int> , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) ) ; private final Callable < Void > cleanupCallable = new Callable < Void > ( ) { public Void call ( ) throws Exception { synchronized ( DiskLruCache . this ) { if ( journalWriter = = null ) { return null ; } trimToSize ( ) ; trimToFileCount ( ) ; if ( journalRebuildRequired ( ) ) { rebuildJournal ( ) ; redundantOpCount = <int> ; } } return null ; } } ; private DiskLruCache ( File directory , int appVersion , int valueCount , long maxSize , int maxFileCount ) { this . directory = directory ; this . appVersion = appVersion ; this . journalFile = new File ( directory , JOURNAL_FILE ) ; this . journalFileTmp = new File ( directory , JOURNAL_FILE_TEMP ) ; this . journalFileBackup = new File ( directory , JOURNAL_FILE_BACKUP ) ; this . valueCount = valueCount ; this . maxSize = maxSize ; this . maxFileCount = maxFileCount ; } public static DiskLruCache open ( File directory , int appVersion , int valueCount , long maxSize , int maxFileCount ) throws IOException { if ( maxSize < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( maxFileCount < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( valueCount < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } File backupFile = new File ( directory , JOURNAL_FILE_BACKUP ) ; if ( backupFile . exists ( ) ) { File journalFile = new File ( directory , JOURNAL_FILE ) ; if ( journalFile . exists ( ) ) { backupFile . delete ( ) ; } else { renameTo ( backupFile , journalFile , false ) ; } } DiskLruCache cache = new DiskLruCache ( directory , appVersion , valueCount , maxSize , maxFileCount ) ; if ( cache . journalFile . exists ( ) ) { try { cache . readJournal ( ) ; cache . processJournal ( ) ; cache . journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( cache . journalFile , true ) , Util . US_ASCII ) ) ; return cache ; } catch ( IOException journalIsCorrupt ) { System . out . println ( <str> + directory + <str> + journalIsCorrupt . getMessage ( ) + <str> ) ; cache . delete ( ) ; } } directory . mkdirs ( ) ; cache = new DiskLruCache ( directory , appVersion , valueCount , maxSize , maxFileCount ) ; cache . rebuildJournal ( ) ; return cache ; } private void readJournal ( ) throws IOException { StrictLineReader reader = new StrictLineReader ( new FileInputStream ( journalFile ) , Util . US_ASCII ) ; try { String magic = reader . readLine ( ) ; String version = reader . readLine ( ) ; String appVersionString = reader . readLine ( ) ; String valueCountString = reader . readLine ( ) ; String blank = reader . readLine ( ) ; if ( ! MAGIC . equals ( magic ) | | ! VERSION_1 . equals ( version ) | | ! Integer . toString ( appVersion ) . equals ( appVersionString ) | | ! Integer . toString ( valueCount ) . equals ( valueCountString ) | | ! <str> . equals ( blank ) ) { throw new IOException ( <str> + magic + <str> + version + <str> + valueCountString + <str> + blank + <str> ) ; } int lineCount = <int> ; while ( true ) { try { readJournalLine ( reader . readLine ( ) ) ; lineCount + + ; } catch ( EOFException endOfJournal ) { break ; } } redundantOpCount = lineCount - lruEntries . size ( ) ; } finally { Util . closeQuietly ( reader ) ; } } private void readJournalLine ( String line ) throws IOException { int firstSpace = line . indexOf ( <str> ) ; if ( firstSpace = = - <int> ) { throw new IOException ( <str> + line ) ; } int keyBegin = firstSpace + <int> ; int secondSpace = line . indexOf ( <str> , keyBegin ) ; final String key ; if ( secondSpace = = - <int> ) { key = line . substring ( keyBegin ) ; if ( firstSpace = = REMOVE . length ( ) & & line . startsWith ( REMOVE ) ) { lruEntries . remove ( key ) ; return ; } } else { key = line . substring ( keyBegin , secondSpace ) ; } Entry entry = lruEntries . get ( key ) ; if ( entry = = null ) { entry = new Entry ( key ) ; lruEntries . put ( key , entry ) ; } if ( secondSpace ! = - <int> & & firstSpace = = CLEAN . length ( ) & & line . startsWith ( CLEAN ) ) { String [ ] parts = line . substring ( secondSpace + <int> ) . split ( <str> ) ; entry . readable = true ; entry . currentEditor = null ; entry . setLengths ( parts ) ; } else if ( secondSpace = = - <int> & & firstSpace = = DIRTY . length ( ) & & line . startsWith ( DIRTY ) ) { entry . currentEditor = new Editor ( entry ) ; } else if ( secondSpace = = - <int> & & firstSpace = = READ . length ( ) & & line . startsWith ( READ ) ) { } else { throw new IOException ( <str> + line ) ; } } private void processJournal ( ) throws IOException { deleteIfExists ( journalFileTmp ) ; for ( Iterator < Entry > i = lruEntries . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Entry entry = i . next ( ) ; if ( entry . currentEditor = = null ) { for ( int t = <int> ; t < valueCount ; t + + ) { size + = entry . lengths [ t ] ; fileCount + + ; } } else { entry . currentEditor = null ; for ( int t = <int> ; t < valueCount ; t + + ) { deleteIfExists ( entry . getCleanFile ( t ) ) ; deleteIfExists ( entry . getDirtyFile ( t ) ) ; } i . remove ( ) ; } } } private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter ! = null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( <str> ) ; writer . write ( VERSION_1 ) ; writer . write ( <str> ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( <str> ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( <str> ) ; writer . write ( <str> ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor ! = null ) { writer . write ( DIRTY + <str> + entry . key + <str> ) ; } else { writer . write ( CLEAN + <str> + entry . key + entry . getLengths ( ) + <str> ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , true ) ; } renameTo ( journalFileTmp , journalFile , false ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , true ) , Util . US_ASCII ) ) ; } private static void deleteIfExists ( File file ) throws IOException { if ( file . exists ( ) & & ! file . delete ( ) ) { throw new IOException ( ) ; } } private static void renameTo ( File from , File to , boolean deleteDestination ) throws IOException { if ( deleteDestination ) { deleteIfExists ( to ) ; } if ( ! from . renameTo ( to ) ) { throw new IOException ( ) ; } } public synchronized Snapshot get ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry = = null ) { return null ; } if ( ! entry . readable ) { return null ; } File [ ] files = new File [ valueCount ] ; InputStream [ ] ins = new InputStream [ valueCount ] ; try { File file ; for ( int i = <int> ; i < valueCount ; i + + ) { file = entry . getCleanFile ( i ) ; files [ i ] = file ; ins [ i ] = new FileInputStream ( file ) ; } } catch ( FileNotFoundException e ) { for ( int i = <int> ; i < valueCount ; i + + ) { if ( ins [ i ] ! = null ) { Util . closeQuietly ( ins [ i ] ) ; } else { break ; } } return null ; } redundantOpCount + + ; journalWriter . append ( READ + <str> + key + <str> ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return new Snapshot ( key , entry . sequenceNumber , files , ins , entry . lengths ) ; } public Editor edit ( String key ) throws IOException { return edit ( key , ANY_SEQUENCE_NUMBER ) ; } private synchronized Editor edit ( String key , long expectedSequenceNumber ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( expectedSequenceNumber ! = ANY_SEQUENCE_NUMBER & & ( entry = = null | | entry . sequenceNumber ! = expectedSequenceNumber ) ) { return null ; } if ( entry = = null ) { entry = new Entry ( key ) ; lruEntries . put ( key , entry ) ; } else if ( entry . currentEditor ! = null ) { return null ; } Editor editor = new Editor ( entry ) ; entry . currentEditor = editor ; journalWriter . write ( DIRTY + <str> + key + <str> ) ; journalWriter . flush ( ) ; return editor ; } public File getDirectory ( ) { return directory ; } public synchronized long getMaxSize ( ) { return maxSize ; } public synchronized int getMaxFileCount ( ) { return maxFileCount ; } public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } public synchronized long size ( ) { return size ; } public synchronized long fileCount ( ) { return fileCount ; } private synchronized void completeEdit ( Editor editor , boolean success ) throws IOException { Entry entry = editor . entry ; if ( entry . currentEditor ! = editor ) { throw new IllegalStateException ( ) ; } if ( success & & ! entry . readable ) { for ( int i = <int> ; i < valueCount ; i + + ) { if ( ! editor . written [ i ] ) { editor . abort ( ) ; throw new IllegalStateException ( <str> + i ) ; } if ( ! entry . getDirtyFile ( i ) . exists ( ) ) { editor . abort ( ) ; return ; } } } for ( int i = <int> ; i < valueCount ; i + + ) { File dirty = entry . getDirtyFile ( i ) ; if ( success ) { if ( dirty . exists ( ) ) { File clean = entry . getCleanFile ( i ) ; dirty . renameTo ( clean ) ; long oldLength = entry . lengths [ i ] ; long newLength = clean . length ( ) ; entry . lengths [ i ] = newLength ; size = size - oldLength + newLength ; fileCount + + ; } } else { deleteIfExists ( dirty ) ; } } redundantOpCount + + ; entry . currentEditor = null ; if ( entry . readable | success ) { entry . readable = true ; journalWriter . write ( CLEAN + <str> + entry . key + entry . getLengths ( ) + <str> ) ; if ( success ) { entry . sequenceNumber = nextSequenceNumber + + ; } } else { lruEntries . remove ( entry . key ) ; journalWriter . write ( REMOVE + <str> + entry . key + <str> ) ; } journalWriter . flush ( ) ; if ( size > maxSize | | fileCount > maxFileCount | | journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } } private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = <int> ; return redundantOpCount > = redundantOpCompactThreshold & & redundantOpCount > = lruEntries . size ( ) ; } public synchronized boolean remove ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry = = null | | entry . currentEditor ! = null ) { return false ; } for ( int i = <int> ; i < valueCount ; i + + ) { File file = entry . getCleanFile ( i ) ; if ( file . exists ( ) & & ! file . delete ( ) ) { throw new IOException ( <str> + file ) ; } size - = entry . lengths [ i ] ; fileCount - - ; entry . lengths [ i ] = <int> ; } redundantOpCount + + ; journalWriter . append ( REMOVE + <str> + key + <str> ) ; lruEntries . remove ( key ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return true ; } public synchronized boolean isClosed ( ) { return journalWriter = = null ; } private void checkNotClosed ( ) { if ( journalWriter = = null ) { throw new IllegalStateException ( <str> ) ; } } public synchronized void flush ( ) throws IOException { checkNotClosed ( ) ; trimToSize ( ) ; trimToFileCount ( ) ; journalWriter . flush ( ) ; } public synchronized void close ( ) throws IOException { if ( journalWriter = = null ) { return ; } for ( Entry entry : new ArrayList < Entry > ( lruEntries . values ( ) ) ) { if ( entry . currentEditor ! = null ) { entry . currentEditor . abort ( ) ; } } trimToSize ( ) ; trimToFileCount ( ) ; journalWriter . close ( ) ; journalWriter = null ; } private void trimToSize ( ) throws IOException { while ( size > maxSize ) { Map . Entry < String , Entry > toEvict = lruEntries . entrySet ( ) . iterator ( ) . next ( ) ; remove ( toEvict . getKey ( ) ) ; } } private void trimToFileCount ( ) throws IOException { while ( fileCount > maxFileCount ) { Map . Entry < String , Entry > toEvict = lruEntries . entrySet ( ) . iterator ( ) . next ( ) ; remove ( toEvict . getKey ( ) ) ; } } public void delete ( ) throws IOException { close ( ) ; Util . deleteContents ( directory ) ; } private void validateKey ( String key ) { Matcher matcher = LEGAL_KEY_PATTERN . matcher ( key ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( <str> + key + <str> ) ; } } private static String inputStreamToString ( InputStream in ) throws IOException { return Util . readFully ( new InputStreamReader ( in , Util . UTF_8 ) ) ; } public final class Snapshot implements Closeable { private final String key ; private final long sequenceNumber ; private File [ ] files ; private final InputStream [ ] ins ; private final long [ ] lengths ; private Snapshot ( String key , long sequenceNumber , File [ ] files , InputStream [ ] ins , long [ ] lengths ) { this . key = key ; this . sequenceNumber = sequenceNumber ; this . files = files ; this . ins = ins ; this . lengths = lengths ; } public Editor edit ( ) throws IOException { return DiskLruCache . this . edit ( key , sequenceNumber ) ; } public File getFile ( int index ) { return files [ index ] ; } public InputStream getInputStream ( int index ) { return ins [ index ] ; } public String getString ( int index ) throws IOException { return inputStreamToString ( getInputStream ( index ) ) ; } public long getLength ( int index ) { return lengths [ index ] ; } public void close ( ) { for ( InputStream in : ins ) { Util . closeQuietly ( in ) ; } } } private static final OutputStream NULL_OUTPUT_STREAM = new OutputStream ( ) { @Override public void write ( int b ) throws IOException { } } ; public final class Editor { private final Entry entry ; private final boolean [ ] written ; private boolean hasErrors ; private boolean committed ; private Editor ( Entry entry ) { this . entry = entry ; this . written = ( entry . readable ) ? null : new boolean [ valueCount ] ; } public InputStream newInputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor ! = this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { return null ; } try { return new FileInputStream ( entry . getCleanFile ( index ) ) ; } catch ( FileNotFoundException e ) { return null ; } } } public String getString ( int index ) throws IOException { InputStream in = newInputStream ( index ) ; return in ! = null ? inputStreamToString ( in ) : null ; } public OutputStream newOutputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor ! = this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { written [ index ] = true ; } File dirtyFile = entry . getDirtyFile ( index ) ; FileOutputStream outputStream ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e ) { directory . mkdirs ( ) ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e2 ) { return NULL_OUTPUT_STREAM ; } } return new FaultHidingOutputStream ( outputStream ) ; } } public void set ( int index , String value ) throws IOException { Writer writer = null ; try { writer = new OutputStreamWriter ( newOutputStream ( index ) , Util . UTF_8 ) ; writer . write ( value ) ; } finally { Util . closeQuietly ( writer ) ; } } public void commit ( ) throws IOException { if ( hasErrors ) { completeEdit ( this , false ) ; remove ( entry . key ) ; } else { completeEdit ( this , true ) ; } committed = true ; } public void abort ( ) throws IOException { completeEdit ( this , false ) ; } public void abortUnlessCommitted ( ) { if ( ! committed ) { try { abort ( ) ; } catch ( IOException ignored ) { } } } private class FaultHidingOutputStream extends FilterOutputStream { private FaultHidingOutputStream ( OutputStream out ) { super ( out ) ; } @Override public void write ( int oneByte ) { try { out . write ( oneByte ) ; } catch ( IOException e ) { hasErrors = true ; } } @Override public void write ( byte [ ] buffer , int offset , int length ) { try { out . write ( buffer , offset , length ) ; } catch ( IOException e ) { hasErrors = true ; } } @Override public void close ( ) { try { out . close ( ) ; } catch ( IOException e ) { hasErrors = true ; } } @Override public void flush ( ) { try { out . flush ( ) ; } catch ( IOException e ) { hasErrors = true ; } } } } private final class Entry { private final String key ; private final long [ ] lengths ; private boolean readable ; private Editor currentEditor ; private long sequenceNumber ; private Entry ( String key ) { this . key = key ; this . lengths = new long [ valueCount ] ; } public String getLengths ( ) throws IOException { StringBuilder result = new StringBuilder ( ) ; for ( long size : lengths ) { result . append ( <str> ) . append ( size ) ; } return result . toString ( ) ; } private void setLengths ( String [ ] strings ) throws IOException { if ( strings . length ! = valueCount ) { throw invalidLengths ( strings ) ; } try { for ( int i = <int> ; i < strings . length ; i + + ) { lengths [ i ] = Long . parseLong ( strings [ i ] ) ; } } catch ( NumberFormatException e ) { throw invalidLengths ( strings ) ; } } private IOException invalidLengths ( String [ ] strings ) throws IOException { throw new IOException ( <str> + java . util . Arrays . toString ( strings ) ) ; } public File getCleanFile ( int i ) { return new File ( directory , key + <str> + i ) ; } public File getDirtyFile ( int i ) { return new File ( directory , key + <str> + i + <str> ) ; } } } 
