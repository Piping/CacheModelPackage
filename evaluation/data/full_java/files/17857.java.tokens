package com . badlogic . gdx . tools . hiero . unicodefont . effects ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Shape ; import java . awt . Stroke ; import java . awt . geom . FlatteningPathIterator ; import java . awt . geom . GeneralPath ; import java . awt . geom . PathIterator ; import java . util . Iterator ; import java . util . List ; public class OutlineZigzagEffect extends OutlineEffect { float amplitude = <int> ; float wavelength = <int> ; public OutlineZigzagEffect ( ) { setStroke ( new ZigzagStroke ( ) ) ; } public OutlineZigzagEffect ( int width , Color color ) { super ( width , color ) ; } public String toString ( ) { return <str> ; } public List getValues ( ) { List values = super . getValues ( ) ; values . add ( EffectUtil . floatValue ( <str> , wavelength , <int> , <int> , <str> + <str> ) ) ; values . add ( EffectUtil . floatValue ( <str> , amplitude , <float> , <int> , <str> + <str> ) ) ; return values ; } public void setValues ( List values ) { super . setValues ( values ) ; for ( Iterator iter = values . iterator ( ) ; iter . hasNext ( ) ; ) { Value value = ( Value ) iter . next ( ) ; if ( value . getName ( ) . equals ( <str> ) ) { wavelength = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } else if ( value . getName ( ) . equals ( <str> ) ) { amplitude = ( ( Float ) value . getObject ( ) ) . floatValue ( ) ; } } } class ZigzagStroke implements Stroke { private static final float FLATNESS = <int> ; public Shape createStrokedShape ( Shape shape ) { GeneralPath result = new GeneralPath ( ) ; PathIterator it = new FlatteningPathIterator ( shape . getPathIterator ( null ) , FLATNESS ) ; float points [ ] = new float [ <int> ] ; float moveX = <int> , moveY = <int> ; float lastX = <int> , lastY = <int> ; float thisX = <int> , thisY = <int> ; int type = <int> ; float next = <int> ; int phase = <int> ; while ( ! it . isDone ( ) ) { type = it . currentSegment ( points ) ; switch ( type ) { case PathIterator . SEG_MOVETO : moveX = lastX = points [ <int> ] ; moveY = lastY = points [ <int> ] ; result . moveTo ( moveX , moveY ) ; next = wavelength / <int> ; break ; case PathIterator . SEG_CLOSE : points [ <int> ] = moveX ; points [ <int> ] = moveY ; case PathIterator . SEG_LINETO : thisX = points [ <int> ] ; thisY = points [ <int> ] ; float dx = thisX - lastX ; float dy = thisY - lastY ; float distance = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; if ( distance > = next ) { float r = <float> / distance ; while ( distance > = next ) { float x = lastX + next * dx * r ; float y = lastY + next * dy * r ; if ( ( phase & <int> ) = = <int> ) result . lineTo ( x + amplitude * dy * r , y - amplitude * dx * r ) ; else result . lineTo ( x - amplitude * dy * r , y + amplitude * dx * r ) ; next + = wavelength ; phase + + ; } } next - = distance ; lastX = thisX ; lastY = thisY ; if ( type = = PathIterator . SEG_CLOSE ) result . closePath ( ) ; break ; } it . next ( ) ; } return new BasicStroke ( getWidth ( ) , BasicStroke . CAP_SQUARE , getJoin ( ) ) . createStrokedShape ( result ) ; } } } 
