package org . gradle . internal . concurrent ; import org . gradle . internal . UncheckedException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . Closeable ; import java . io . IOException ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; public class CompositeStoppable implements Stoppable { private static final Logger LOGGER = LoggerFactory . getLogger ( CompositeStoppable . class ) ; public static final Stoppable NO_OP_STOPPABLE = new Stoppable ( ) { public void stop ( ) { } } ; private final List < Stoppable > elements = new CopyOnWriteArrayList < Stoppable > ( ) ; public CompositeStoppable ( ) { } public static CompositeStoppable stoppable ( Object . . . elements ) { return new CompositeStoppable ( ) . add ( elements ) ; } public static CompositeStoppable stoppable ( Iterable < ? > elements ) { return new CompositeStoppable ( ) . add ( elements ) ; } public CompositeStoppable add ( Iterable < ? > elements ) { for ( Object element : elements ) { this . elements . add ( toStoppable ( element ) ) ; } return this ; } public CompositeStoppable add ( Object . . . elements ) { for ( Object closeable : elements ) { this . elements . add ( toStoppable ( closeable ) ) ; } return this ; } private static Stoppable toStoppable ( final Object object ) { if ( object instanceof Stoppable ) { return ( Stoppable ) object ; } if ( object instanceof Closeable ) { final Closeable closeable = ( Closeable ) object ; return new Stoppable ( ) { @Override public String toString ( ) { return closeable . toString ( ) ; } public void stop ( ) { try { closeable . close ( ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } ; } return NO_OP_STOPPABLE ; } public void stop ( ) { Throwable failure = null ; try { for ( Stoppable element : elements ) { try { element . stop ( ) ; } catch ( Throwable throwable ) { if ( failure = = null ) { failure = throwable ; } else { LOGGER . error ( String . format ( <str> , element ) , throwable ) ; } } } } finally { elements . clear ( ) ; } if ( failure ! = null ) { throw UncheckedException . throwAsUncheckedException ( failure ) ; } } } 
