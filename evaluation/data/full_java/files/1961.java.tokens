package org . nd4j . linalg . api . blas . params ; import lombok . Data ; import org . nd4j . linalg . api . ndarray . INDArray ; public @Data class GemmParams { private int lda , ldb , ldc , m , n , k ; private INDArray a , b , c ; private char aOrdering = <str> ; private char bOrdering = <str> ; public GemmParams ( INDArray a , INDArray b , INDArray c ) { if ( b . columns ( ) ! = c . columns ( ) ) throw new IllegalArgumentException ( <str> ) ; if ( a . rows ( ) ! = c . rows ( ) ) throw new IllegalArgumentException ( <str> ) ; this . a = copyIfNeccessary ( a ) ; this . b = copyIfNeccessary ( b ) ; this . c = c ; this . m = c . rows ( ) ; this . n = c . columns ( ) ; this . k = a . columns ( ) ; this . lda = ( this . a . ordering ( ) = = <str> ? this . a . rows ( ) : this . a . columns ( ) ) ; this . ldb = ( this . b . ordering ( ) = = <str> ? this . b . rows ( ) : this . b . columns ( ) ) ; this . ldc = c . rows ( ) ; this . aOrdering = ( this . a . ordering ( ) = = <str> ? <str> : <str> ) ; this . bOrdering = ( this . b . ordering ( ) = = <str> ? <str> : <str> ) ; validate ( ) ; } public GemmParams ( INDArray a , INDArray b , INDArray c , boolean transposeA , boolean transposeB ) { if ( transposeA & & a . columns ( ) ! = c . rows ( ) ) throw new IllegalArgumentException ( <str> ) ; else if ( ! transposeA & & a . rows ( ) ! = c . rows ( ) ) throw new IllegalArgumentException ( <str> ) ; if ( transposeB & & b . rows ( ) ! = c . columns ( ) ) throw new IllegalArgumentException ( <str> ) ; else if ( ! transposeB & & b . columns ( ) ! = c . columns ( ) ) throw new IllegalArgumentException ( <str> ) ; if ( c . ordering ( ) ! = <str> | | c . offset ( ) ! = <int> | | c . length ( ) ! = c . data ( ) . length ( ) ) throw new IllegalArgumentException ( <str> ) ; this . a = copyIfNeccessary ( a ) ; this . b = copyIfNeccessary ( b ) ; this . c = c ; this . m = c . rows ( ) ; this . n = c . columns ( ) ; this . k = ( transposeA ? a . rows ( ) : a . columns ( ) ) ; boolean transposeAOut = transposeA ^ this . a . ordering ( ) = = <str> ; boolean transposeBOut = transposeB ^ this . b . ordering ( ) = = <str> ; this . lda = ( this . a . ordering ( ) = = <str> ? this . a . rows ( ) : this . a . columns ( ) ) ; this . ldb = ( this . b . ordering ( ) = = <str> ? this . b . rows ( ) : this . b . columns ( ) ) ; this . ldc = c . rows ( ) ; this . aOrdering = ( transposeAOut ? <str> : <str> ) ; this . bOrdering = ( transposeBOut ? <str> : <str> ) ; } private INDArray copyIfNeccessary ( INDArray arr ) { if ( arr . isMatrix ( ) ) { if ( arr . ordering ( ) = = <str> & & ( arr . stride ( <int> ) ! = arr . size ( <int> ) | | arr . stride ( <int> ) ! = <int> ) ) return arr . dup ( ) ; else if ( arr . ordering ( ) = = <str> & & ( arr . stride ( <int> ) ! = <int> | | arr . stride ( <int> ) ! = arr . size ( <int> ) ) ) return arr . dup ( ) ; } return arr ; } private void validate ( ) { if ( c . ordering ( ) ! = <str> ) throw new IllegalStateException ( <str> ) ; } } 
