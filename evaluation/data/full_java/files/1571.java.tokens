package org . apache . cassandra . io . util ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . SyncUtil ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . Arrays ; import static org . apache . cassandra . Util . expectEOF ; import static org . apache . cassandra . Util . expectException ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . assertEquals ; import org . junit . Test ; public class BufferedRandomAccessFileTest { @Test public void testReadAndWrite ( ) throws Exception { SequentialWriter w = createTempFile ( <str> ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; byte [ ] data = <str> . getBytes ( ) ; w . write ( data ) ; assertEquals ( data . length , w . length ( ) ) ; assertEquals ( data . length , w . position ( ) ) ; w . sync ( ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ; byte [ ] buffer = new byte [ data . length ] ; assertEquals ( data . length , r . read ( buffer ) ) ; assertTrue ( Arrays . equals ( buffer , data ) ) ; assertEquals ( r . read ( ) , - <int> ) ; assert r . bytesRemaining ( ) = = <int> & & r . isEOF ( ) ; r . close ( ) ; byte [ ] bigData = new byte [ RandomAccessReader . DEFAULT_BUFFER_SIZE + <int> ] ; for ( int i = <int> ; i < bigData . length ; i + + ) bigData [ i ] = <str> ; long initialPosition = w . position ( ) ; w . write ( bigData ) ; assertEquals ( w . position ( ) , initialPosition + bigData . length ) ; assertEquals ( w . length ( ) , initialPosition + bigData . length ) ; w . sync ( ) ; r = RandomAccessReader . open ( channel ) ; r . seek ( initialPosition ) ; data = new byte [ bigData . length ] ; long sizeRead = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) r . read ( ) ; sizeRead + + ; } assertEquals ( sizeRead , data . length ) ; assertEquals ( r . getFilePointer ( ) , initialPosition + data . length ) ; assertEquals ( r . length ( ) , initialPosition + bigData . length ) ; assertTrue ( Arrays . equals ( bigData , data ) ) ; assertTrue ( r . bytesRemaining ( ) = = <int> & & r . isEOF ( ) ) ; r . seek ( <int> ) ; ByteBuffer fileContent = ByteBufferUtil . read ( r , ( int ) w . length ( ) ) ; assertEquals ( fileContent . limit ( ) , w . length ( ) ) ; assert ByteBufferUtil . string ( fileContent ) . equals ( <str> + new String ( bigData ) ) ; data = new byte [ bigData . length ] ; r . seek ( initialPosition ) ; r . readFully ( data ) ; assert r . bytesRemaining ( ) = = <int> & & r . isEOF ( ) ; assertTrue ( Arrays . equals ( bigData , data ) ) ; data = new byte [ <int> ] ; assertEquals ( r . read ( ) , - <int> ) ; assertEquals ( r . read ( data ) , - <int> ) ; assertEquals ( r . read ( data , <int> , data . length ) , - <int> ) ; r . seek ( <int> ) ; data = new byte [ <int> ] ; assertEquals ( <int> , r . read ( data , <int> , <int> ) ) ; assertTrue ( new String ( data ) . contains ( <str> ) ) ; for ( int i = <int> ; i < data . length ; i + + ) { assert data [ i ] = = <int> ; } w . finish ( ) ; r . close ( ) ; channel . close ( ) ; } @Test public void testReadAndWriteOnCapacity ( ) throws IOException { File tmpFile = File . createTempFile ( <str> , <str> ) ; SequentialWriter w = SequentialWriter . open ( tmpFile ) ; byte [ ] in = generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE ) ; w . write ( in ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ; byte [ ] out = new byte [ RandomAccessReader . DEFAULT_BUFFER_SIZE ] ; r . read ( out ) ; int negone = r . read ( ) ; assert negone = = - <int> : <str> + negone ; r . close ( ) ; w . finish ( ) ; channel . close ( ) ; } @Test public void testLength ( ) throws IOException { File tmpFile = File . createTempFile ( <str> , <str> ) ; SequentialWriter w = SequentialWriter . open ( tmpFile ) ; assertEquals ( <int> , w . length ( ) ) ; byte [ ] lessThenBuffer = generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE / <int> ) ; w . write ( lessThenBuffer ) ; assertEquals ( lessThenBuffer . length , w . length ( ) ) ; w . sync ( ) ; assertEquals ( lessThenBuffer . length , w . length ( ) ) ; byte [ ] biggerThenBuffer = generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE * <int> ) ; w . write ( biggerThenBuffer ) ; assertEquals ( biggerThenBuffer . length + lessThenBuffer . length , w . length ( ) ) ; w . finish ( ) ; try ( ChannelProxy channel = new ChannelProxy ( tmpFile ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ) { assertEquals ( lessThenBuffer . length + biggerThenBuffer . length , r . length ( ) ) ; } } @Test public void testReadBytes ( ) throws IOException { final SequentialWriter w = createTempFile ( <str> ) ; byte [ ] data = new byte [ RandomAccessReader . DEFAULT_BUFFER_SIZE + <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = <str> ; } w . write ( data ) ; w . sync ( ) ; final ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; final RandomAccessReader r = RandomAccessReader . open ( channel ) ; ByteBuffer content = ByteBufferUtil . read ( r , ( int ) r . length ( ) ) ; assertEquals ( <int> , ByteBufferUtil . compare ( content , data ) ) ; assert r . bytesRemaining ( ) = = <int> & & r . isEOF ( ) ; r . seek ( <int> ) ; content = ByteBufferUtil . read ( r , <int> ) ; assertEquals ( ByteBufferUtil . compare ( content , <str> . getBytes ( ) ) , <int> ) ; assertEquals ( r . bytesRemaining ( ) , r . length ( ) - content . limit ( ) ) ; expectEOF ( ( ) - > ByteBufferUtil . read ( r , ( int ) r . length ( ) + <int> ) ) ; w . finish ( ) ; r . close ( ) ; channel . close ( ) ; } @Test public void testSeek ( ) throws Exception { SequentialWriter w = createTempFile ( <str> ) ; byte [ ] data = generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE + <int> ) ; w . write ( data ) ; w . finish ( ) ; final ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; final RandomAccessReader file = RandomAccessReader . open ( channel ) ; file . seek ( <int> ) ; assertEquals ( file . getFilePointer ( ) , <int> ) ; assertEquals ( file . bytesRemaining ( ) , file . length ( ) ) ; file . seek ( <int> ) ; assertEquals ( file . getFilePointer ( ) , <int> ) ; assertEquals ( file . bytesRemaining ( ) , file . length ( ) - <int> ) ; expectException ( ( ) - > { file . seek ( file . length ( ) + <int> ) ; return null ; } , IllegalArgumentException . class ) ; expectException ( ( ) - > { file . seek ( - <int> ) ; return null ; } , IllegalArgumentException . class ) ; file . close ( ) ; channel . close ( ) ; } @Test public void testSkipBytes ( ) throws IOException { SequentialWriter w = createTempFile ( <str> ) ; w . write ( generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE * <int> ) ) ; w . finish ( ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader file = RandomAccessReader . open ( channel ) ; file . seek ( <int> ) ; assertEquals ( file . skipBytes ( <int> ) , <int> ) ; assertEquals ( file . bytesRemaining ( ) , file . length ( ) - <int> ) ; int initialPosition = ( int ) file . getFilePointer ( ) ; assertEquals ( file . skipBytes ( ( int ) file . length ( ) + <int> ) , file . length ( ) - initialPosition ) ; assertEquals ( file . getFilePointer ( ) , file . length ( ) ) ; assert file . bytesRemaining ( ) = = <int> & & file . isEOF ( ) ; file . seek ( <int> ) ; assertEquals ( file . skipBytes ( - <int> ) , <int> ) ; assertEquals ( file . getFilePointer ( ) , <int> ) ; assertEquals ( file . bytesRemaining ( ) , file . length ( ) ) ; file . close ( ) ; channel . close ( ) ; } @Test public void testGetFilePointer ( ) throws IOException { final SequentialWriter w = createTempFile ( <str> ) ; assertEquals ( w . position ( ) , <int> ) ; w . write ( generateByteArray ( <int> ) ) ; assertEquals ( w . position ( ) , <int> ) ; w . sync ( ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ; r . seek ( <int> ) ; r . skipBytes ( <int> ) ; assertEquals ( r . getFilePointer ( ) , <int> ) ; r . read ( ) ; assertEquals ( r . getFilePointer ( ) , <int> ) ; r . read ( new byte [ <int> ] ) ; assertEquals ( r . getFilePointer ( ) , <int> ) ; w . finish ( ) ; r . close ( ) ; channel . close ( ) ; } @Test public void testGetPath ( ) throws IOException { SequentialWriter file = createTempFile ( <str> ) ; assert file . getPath ( ) . contains ( <str> ) ; file . finish ( ) ; } @Test public void testIsEOF ( ) throws IOException { for ( int bufferSize : Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ) { final byte [ ] target = new byte [ <int> ] ; for ( final int offset : Arrays . asList ( <int> , <int> ) ) { File file1 = writeTemporaryFile ( new byte [ <int> ] ) ; try ( final ChannelProxy channel = new ChannelProxy ( file1 ) ; final RandomAccessReader file = new RandomAccessReader . Builder ( channel ) . bufferSize ( bufferSize ) . build ( ) ) { expectEOF ( ( ) - > { file . readFully ( target , offset , <int> ) ; return null ; } ) ; } } for ( final int n : Arrays . asList ( <int> , <int> , <int> , <int> ) ) { File file1 = writeTemporaryFile ( new byte [ <int> ] ) ; try ( final ChannelProxy channel = new ChannelProxy ( file1 ) ; final RandomAccessReader file = new RandomAccessReader . Builder ( channel ) . bufferSize ( bufferSize ) . build ( ) ) { expectEOF ( ( ) - > { while ( true ) file . readFully ( target , <int> , n ) ; } ) ; } } } } @Test public void testNotEOF ( ) throws IOException { try ( final RandomAccessReader reader = RandomAccessReader . open ( writeTemporaryFile ( new byte [ <int> ] ) ) ) { assertEquals ( <int> , reader . read ( new byte [ <int> ] ) ) ; } } @Test public void testBytesRemaining ( ) throws IOException { SequentialWriter w = createTempFile ( <str> ) ; int toWrite = RandomAccessReader . DEFAULT_BUFFER_SIZE + <int> ; w . write ( generateByteArray ( toWrite ) ) ; w . sync ( ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ; assertEquals ( r . bytesRemaining ( ) , toWrite ) ; for ( int i = <int> ; i < = r . length ( ) ; i + + ) { r . read ( ) ; assertEquals ( r . bytesRemaining ( ) , r . length ( ) - i ) ; } r . seek ( <int> ) ; r . skipBytes ( <int> ) ; assertEquals ( r . bytesRemaining ( ) , r . length ( ) - <int> ) ; w . finish ( ) ; r . close ( ) ; channel . close ( ) ; } @Test public void testBytesPastMark ( ) throws IOException { File tmpFile = File . createTempFile ( <str> , <str> ) ; tmpFile . deleteOnExit ( ) ; try ( final RandomAccessReader r = RandomAccessReader . open ( new File ( tmpFile . getPath ( ) ) ) ) { assert tmpFile . getPath ( ) . equals ( r . getPath ( ) ) ; final FileMark mark = r . mark ( ) ; r . reset ( mark ) ; r . bytesPastMark ( mark ) ; } } @Test public void testClose ( ) throws IOException { final SequentialWriter w = createTempFile ( <str> ) ; byte [ ] data = generateByteArray ( RandomAccessReader . DEFAULT_BUFFER_SIZE + <int> ) ; w . write ( data ) ; w . finish ( ) ; final RandomAccessReader r = RandomAccessReader . open ( new File ( w . getPath ( ) ) ) ; r . close ( ) ; expectException ( ( ) - > r . read ( ) , NullPointerException . class ) ; expectException ( ( ) - > { w . write ( generateByteArray ( <int> ) ) ; return null ; } , NullPointerException . class ) ; try ( RandomAccessReader copy = RandomAccessReader . open ( new File ( r . getPath ( ) ) ) ) { ByteBuffer contents = ByteBufferUtil . read ( copy , ( int ) copy . length ( ) ) ; assertEquals ( contents . limit ( ) , data . length ) ; assertEquals ( ByteBufferUtil . compare ( contents , data ) , <int> ) ; } } @Test public void testMarkAndReset ( ) throws IOException { SequentialWriter w = createTempFile ( <str> ) ; w . write ( new byte [ <int> ] ) ; w . finish ( ) ; ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader file = RandomAccessReader . open ( channel ) ; file . seek ( <int> ) ; FileMark mark = file . mark ( ) ; file . seek ( file . length ( ) ) ; assertTrue ( file . isEOF ( ) ) ; file . reset ( ) ; assertEquals ( file . bytesRemaining ( ) , <int> ) ; file . seek ( file . length ( ) ) ; assertTrue ( file . isEOF ( ) ) ; file . reset ( mark ) ; assertEquals ( file . bytesRemaining ( ) , <int> ) ; file . seek ( file . length ( ) ) ; assertEquals ( file . bytesPastMark ( ) , <int> ) ; assertEquals ( file . bytesPastMark ( mark ) , <int> ) ; file . reset ( mark ) ; assertEquals ( file . bytesPastMark ( ) , <int> ) ; file . close ( ) ; channel . close ( ) ; } @Test ( expected = AssertionError . class ) public void testAssertionErrorWhenBytesPastMarkIsNegative ( ) throws IOException { try ( SequentialWriter w = createTempFile ( <str> ) ) { w . write ( new byte [ <int> ] ) ; w . flush ( ) ; try ( ChannelProxy channel = new ChannelProxy ( w . getPath ( ) ) ; RandomAccessReader r = RandomAccessReader . open ( channel ) ) { r . seek ( <int> ) ; r . mark ( ) ; r . seek ( <int> ) ; r . bytesPastMark ( ) ; } } } @Test public void testReadOnly ( ) throws IOException { SequentialWriter file = createTempFile ( <str> ) ; byte [ ] data = new byte [ <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) data [ i ] = <str> ; file . write ( data ) ; file . sync ( ) ; final RandomAccessReader copy = RandomAccessReader . open ( new File ( file . getPath ( ) ) ) ; copy . seek ( copy . length ( ) ) ; assertTrue ( copy . bytesRemaining ( ) = = <int> & & copy . isEOF ( ) ) ; expectException ( ( ) - > { copy . seek ( copy . length ( ) + <int> ) ; return null ; } , IllegalArgumentException . class ) ; copy . seek ( <int> ) ; copy . skipBytes ( <int> ) ; assertEquals ( copy . bytesRemaining ( ) , <int> ) ; assertEquals ( copy . getFilePointer ( ) , <int> ) ; assertTrue ( ! copy . isEOF ( ) ) ; copy . seek ( <int> ) ; ByteBuffer contents = ByteBufferUtil . read ( copy , ( int ) copy . length ( ) ) ; assertEquals ( contents . limit ( ) , copy . length ( ) ) ; assertTrue ( ByteBufferUtil . compare ( contents , data ) = = <int> ) ; copy . seek ( <int> ) ; int count = <int> ; while ( ! copy . isEOF ( ) ) { assertEquals ( ( byte ) copy . read ( ) , <str> ) ; count + + ; } assertEquals ( count , copy . length ( ) ) ; copy . seek ( <int> ) ; byte [ ] content = new byte [ <int> ] ; copy . read ( content ) ; assertEquals ( new String ( content ) , <str> ) ; file . finish ( ) ; copy . close ( ) ; } @Test ( expected = IllegalArgumentException . class ) public void testSetNegativeLength ( ) throws IOException , IllegalArgumentException { File tmpFile = File . createTempFile ( <str> , <str> ) ; try ( SequentialWriter file = SequentialWriter . open ( tmpFile ) ) { file . truncate ( - <int> ) ; } } private SequentialWriter createTempFile ( String name ) throws IOException { File tempFile = File . createTempFile ( name , null ) ; tempFile . deleteOnExit ( ) ; return SequentialWriter . open ( tempFile ) ; } private File writeTemporaryFile ( byte [ ] data ) throws IOException { File f = File . createTempFile ( <str> , null ) ; f . deleteOnExit ( ) ; FileOutputStream fout = new FileOutputStream ( f ) ; fout . write ( data ) ; SyncUtil . sync ( fout ) ; fout . close ( ) ; return f ; } private byte [ ] generateByteArray ( int length ) { byte [ ] arr = new byte [ length ] ; for ( int i = <int> ; i < length ; i + + ) arr [ i ] = <str> ; return arr ; } } 
