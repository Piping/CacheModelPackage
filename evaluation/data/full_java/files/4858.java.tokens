package org . eclipse . ui . externaltools . internal . ui ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import org . eclipse . core . externaltools . internal . IExternalToolConstants ; import org . eclipse . core . externaltools . internal . model . BuilderCoreUtils ; import org . eclipse . core . externaltools . internal . model . ExternalToolBuilder ; import org . eclipse . core . resources . ICommand ; import org . eclipse . core . resources . IFolder ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IProjectDescription ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . IWorkspaceDescription ; import org . eclipse . core . resources . IncrementalProjectBuilder ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IExtension ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationListener ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . jface . dialogs . ErrorDialog ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . MessageDialogWithToggle ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . CheckboxTableViewer ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . ILabelProvider ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . window . Window ; import org . eclipse . osgi . util . NLS ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Button ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Label ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . dialogs . ElementListSelectionDialog ; import org . eclipse . ui . dialogs . PropertyPage ; import org . eclipse . ui . externaltools . internal . launchConfigurations . ExternalToolsMainTab ; import org . eclipse . ui . externaltools . internal . launchConfigurations . ExternalToolsUtil ; import org . eclipse . ui . externaltools . internal . launchConfigurations . IgnoreWhiteSpaceComparator ; import org . eclipse . ui . externaltools . internal . model . BuilderUtils ; import org . eclipse . ui . externaltools . internal . model . ExternalToolsPlugin ; import org . eclipse . ui . externaltools . internal . model . IExternalToolsHelpContextIds ; import org . eclipse . ui . externaltools . internal . model . IPreferenceConstants ; import org . eclipse . ui . progress . IProgressService ; public final class BuilderPropertyPage extends PropertyPage implements ICheckStateListener { private static final String COMMAND_ENABLED = <str> ; private Button upButton , downButton , newButton , importButton , editButton , removeButton ; private boolean userHasMadeChanges = false ; private List < ILaunchConfiguration > configsToBeDeleted = null ; private List < ICommand > commandsToBeDeleted = null ; private CheckboxTableViewer viewer = null ; private boolean fWarned = false ; private boolean fCanEdit = false ; private ILabelProvider labelProvider = new BuilderLabelProvider ( ) ; public class ErrorConfig { private ICommand command ; public ErrorConfig ( ICommand command ) { this . command = command ; } public ICommand getCommand ( ) { return command ; } } private List < ILaunchConfiguration > newConfigList = new ArrayList < ILaunchConfiguration > ( ) ; private SelectionListener buttonListener = new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { handleButtonPressed ( ( Button ) e . widget ) ; } } ; private ILaunchConfigurationListener configurationListener = new ILaunchConfigurationListener ( ) { @Override public void launchConfigurationAdded ( final ILaunchConfiguration configuration ) { ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; final ILaunchConfiguration oldConfig = manager . getMovedFrom ( configuration ) ; if ( oldConfig = = null ) { return ; } if ( newConfigList . remove ( oldConfig ) ) { newConfigList . add ( configuration ) ; } Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { TableItem [ ] items = viewer . getTable ( ) . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { TableItem item = items [ i ] ; Object data = item . getData ( ) ; if ( data = = oldConfig ) { item . setData ( configuration ) ; viewer . update ( configuration , null ) ; break ; } } } } ) ; } @Override public void launchConfigurationChanged ( ILaunchConfiguration configuration ) { } @Override public void launchConfigurationRemoved ( ILaunchConfiguration configuration ) { } } ; public BuilderPropertyPage ( ) { super ( ) ; noDefaultAndApplyButton ( ) ; } private void addBuildersToTable ( ) { IProject project = getInputProject ( ) ; if ( project = = null ) { return ; } ICommand [ ] commands = null ; try { commands = project . getDescription ( ) . getBuildSpec ( ) ; } catch ( CoreException e ) { handleException ( e ) ; return ; } boolean projectNeedsMigration = false ; for ( int i = <int> ; i < commands . length ; i + + ) { String [ ] version = new String [ ] { IExternalToolConstants . EMPTY_STRING } ; ILaunchConfiguration config = BuilderUtils . configFromBuildCommandArgs ( project , commands [ i ] . getArguments ( ) , version ) ; if ( BuilderCoreUtils . VERSION_2_1 . equals ( version [ <int> ] ) ) { projectNeedsMigration = true ; } Object element = null ; if ( config ! = null ) { if ( ! config . isWorkingCopy ( ) & & ! config . exists ( ) ) { Shell shell = getShell ( ) ; if ( shell = = null ) { return ; } IStatus status = new Status ( IStatus . ERROR , ExternalToolsPlugin . PLUGIN_ID , <int> , NLS . bind ( ExternalToolsUIMessages . BuilderPropertyPage_Exists , new String [ ] { config . getName ( ) } ) , null ) ; ErrorDialog . openError ( getShell ( ) , ExternalToolsUIMessages . BuilderPropertyPage_errorTitle , NLS . bind ( ExternalToolsUIMessages . BuilderPropertyPage_External_Tool_Builder__0__Not_Added_2 , new String [ ] { config . getName ( ) } ) , status ) ; userHasMadeChanges = true ; } else { element = config ; } } else { String builderID = commands [ i ] . getBuilderName ( ) ; if ( builderID . equals ( ExternalToolBuilder . ID ) & & commands [ i ] . getArguments ( ) . get ( BuilderCoreUtils . LAUNCH_CONFIG_HANDLE ) ! = null ) { element = new ErrorConfig ( commands [ i ] ) ; } else { element = commands [ i ] ; } } if ( element ! = null ) { viewer . add ( element ) ; viewer . setChecked ( element , isEnabled ( element ) ) ; } } if ( projectNeedsMigration ) { IPreferenceStore store = ExternalToolsPlugin . getDefault ( ) . getPreferenceStore ( ) ; boolean prompt = store . getBoolean ( IPreferenceConstants . PROMPT_FOR_PROJECT_MIGRATION ) ; boolean proceed = true ; if ( prompt ) { Shell shell = getShell ( ) ; if ( shell = = null ) { return ; } MessageDialogWithToggle dialog = MessageDialogWithToggle . openYesNoQuestion ( shell , ExternalToolsUIMessages . BuilderPropertyPage_0 , ExternalToolsUIMessages . BuilderPropertyPage_1 , ExternalToolsUIMessages . BuilderPropertyPage_2 , false , null , null ) ; proceed = dialog . getReturnCode ( ) = = IDialogConstants . YES_ID ; store . setValue ( IPreferenceConstants . PROMPT_FOR_PROJECT_MIGRATION , ! dialog . getToggleState ( ) ) ; } if ( ! proceed ) { viewer . getTable ( ) . setEnabled ( false ) ; downButton . setEnabled ( false ) ; editButton . setEnabled ( false ) ; importButton . setEnabled ( false ) ; newButton . setEnabled ( false ) ; removeButton . setEnabled ( false ) ; } } } private Button createButton ( Composite parent , String label ) { Button button = new Button ( parent , SWT . PUSH ) ; button . setFont ( parent . getFont ( ) ) ; button . setText ( label ) ; button . setEnabled ( false ) ; button . addSelectionListener ( buttonListener ) ; GridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; data . grabExcessHorizontalSpace = true ; button . setLayoutData ( data ) ; int widthHint = convertHorizontalDLUsToPixels ( IDialogConstants . BUTTON_WIDTH ) ; data . widthHint = Math . max ( widthHint , button . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ; return button ; } @Override protected Control createContents ( Composite parent ) { PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( parent , IExternalToolsHelpContextIds . EXTERNAL_TOOLS_BUILDER_PROPERTY_PAGE ) ; Font font = parent . getFont ( ) ; Composite topLevel = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . marginHeight = <int> ; layout . marginWidth = <int> ; topLevel . setLayout ( layout ) ; topLevel . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Label description = new Label ( topLevel , SWT . WRAP ) ; description . setText ( ExternalToolsUIMessages . BuilderPropertyPage_description ) ; description . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; description . setFont ( font ) ; Composite tableAndButtons = new Composite ( topLevel , SWT . NONE ) ; tableAndButtons . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; layout = new GridLayout ( ) ; layout . marginHeight = <int> ; layout . marginWidth = <int> ; layout . numColumns = <int> ; tableAndButtons . setLayout ( layout ) ; viewer = CheckboxTableViewer . newCheckList ( tableAndButtons , SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL | SWT . FULL_SELECTION | SWT . BORDER ) ; viewer . setLabelProvider ( labelProvider ) ; viewer . addCheckStateListener ( this ) ; Table builderTable = viewer . getTable ( ) ; builderTable . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; builderTable . setFont ( font ) ; builderTable . addSelectionListener ( new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { handleTableSelectionChanged ( ) ; } } ) ; builderTable . addListener ( SWT . MouseDoubleClick , new Listener ( ) { @Override public void handleEvent ( Event event ) { if ( fCanEdit ) { handleEditButtonPressed ( ) ; } } } ) ; Composite buttonArea = new Composite ( tableAndButtons , SWT . NONE ) ; layout = new GridLayout ( ) ; layout . marginHeight = <int> ; layout . marginWidth = <int> ; buttonArea . setLayout ( layout ) ; buttonArea . setFont ( font ) ; buttonArea . setLayoutData ( new GridData ( GridData . FILL_VERTICAL ) ) ; newButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage_newButton ) ; importButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage__Import____3 ) ; editButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage_editButton ) ; removeButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage_removeButton ) ; new Label ( buttonArea , SWT . LEFT ) ; upButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage_upButton ) ; downButton = createButton ( buttonArea , ExternalToolsUIMessages . BuilderPropertyPage_downButton ) ; newButton . setEnabled ( true ) ; importButton . setEnabled ( true ) ; addBuildersToTable ( ) ; return topLevel ; } private void setAutobuild ( boolean newState ) throws CoreException { IWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; IWorkspaceDescription wsDescription = workspace . getDescription ( ) ; boolean oldState = wsDescription . isAutoBuilding ( ) ; if ( oldState ! = newState ) { wsDescription . setAutoBuilding ( newState ) ; workspace . setDescription ( wsDescription ) ; } } private IProject getInputProject ( ) { IAdaptable element = getElement ( ) ; if ( element instanceof IProject ) { return ( IProject ) element ; } Object resource = element . getAdapter ( IResource . class ) ; if ( resource instanceof IProject ) { return ( IProject ) resource ; } return null ; } private void handleButtonPressed ( Button button ) { if ( button = = newButton ) { handleNewButtonPressed ( ) ; } else if ( button = = importButton ) { handleImportButtonPressed ( ) ; } else if ( button = = editButton ) { handleEditButtonPressed ( ) ; } else if ( button = = removeButton ) { handleRemoveButtonPressed ( ) ; } else if ( button = = upButton ) { moveSelectionUp ( ) ; } else if ( button = = downButton ) { moveSelectionDown ( ) ; } if ( getControl ( ) . isDisposed ( ) ) { return ; } handleTableSelectionChanged ( ) ; viewer . getTable ( ) . setFocus ( ) ; } @Override public void checkStateChanged ( CheckStateChangedEvent event ) { Object element = event . getElement ( ) ; boolean checked = event . getChecked ( ) ; if ( element instanceof ILaunchConfiguration ) { enableLaunchConfiguration ( ( ILaunchConfiguration ) element , checked ) ; } else if ( element instanceof ICommand ) { Shell shell = getShell ( ) ; if ( shell = = null ) { return ; } if ( checked ) { enableCommand ( ( ICommand ) element , checked ) ; return ; } else if ( ! fWarned ) { if ( MessageDialog . openConfirm ( shell , ExternalToolsUIMessages . BuilderPropertyPage_6 , ExternalToolsUIMessages . BuilderPropertyPage_7 ) ) { fWarned = true ; } } if ( fWarned ) { enableCommand ( ( ICommand ) element , checked ) ; } else { viewer . removeCheckStateListener ( this ) ; viewer . setChecked ( element , true ) ; viewer . addCheckStateListener ( this ) ; } } } private void enableLaunchConfiguration ( ILaunchConfiguration configuration , boolean enable ) { ILaunchConfigurationWorkingCopy workingCopy = null ; try { if ( configuration instanceof ILaunchConfigurationWorkingCopy ) { workingCopy = ( ILaunchConfigurationWorkingCopy ) configuration ; } else { TableItem [ ] items = viewer . getTable ( ) . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { TableItem item = items [ i ] ; if ( item . getData ( ) = = configuration ) { workingCopy = configuration . getWorkingCopy ( ) ; item . setData ( workingCopy ) ; } } } if ( workingCopy ! = null ) { workingCopy . setAttribute ( IExternalToolConstants . ATTR_BUILDER_ENABLED , enable ) ; } } catch ( CoreException e ) { return ; } userHasMadeChanges = true ; } private void enableCommand ( ICommand command , boolean enable ) { Map < String , String > args = command . getArguments ( ) ; if ( args = = null ) { args = new HashMap < String , String > ( <int> ) ; } args . put ( COMMAND_ENABLED , Boolean . toString ( enable ) ) ; command . setArguments ( args ) ; userHasMadeChanges = true ; } private void handleImportButtonPressed ( ) { ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; List < ILaunchConfigurationType > toolTypes = getConfigurationTypes ( IExternalToolConstants . ID_EXTERNAL_TOOLS_LAUNCH_CATEGORY ) ; List < ILaunchConfiguration > configurations = new ArrayList < ILaunchConfiguration > ( ) ; for ( ILaunchConfigurationType type : toolTypes ) { try { ILaunchConfiguration [ ] configs = manager . getLaunchConfigurations ( type ) ; for ( int i = <int> ; i < configs . length ; i + + ) { ILaunchConfiguration launchConfiguration = configs [ i ] ; if ( ! DebugUITools . isPrivate ( launchConfiguration ) ) { configurations . add ( launchConfiguration ) ; } } } catch ( CoreException e ) { } } Shell shell = getShell ( ) ; if ( shell = = null ) { return ; } ElementListSelectionDialog dialog = new ElementListSelectionDialog ( shell , new BuilderLabelProvider ( ) ) ; dialog . setTitle ( ExternalToolsUIMessages . BuilderPropertyPage_4 ) ; dialog . setMessage ( ExternalToolsUIMessages . BuilderPropertyPage_5 ) ; dialog . setElements ( configurations . toArray ( ) ) ; if ( dialog . open ( ) = = Window . CANCEL ) { return ; } Object results [ ] = dialog . getResult ( ) ; if ( results . length = = <int> ) { return ; } ILaunchConfiguration config = ( ILaunchConfiguration ) results [ <int> ] ; ILaunchConfiguration newConfig = null ; boolean wasAutobuilding = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ; try { setAutobuild ( false ) ; newConfig = BuilderUtils . duplicateConfiguration ( getInputProject ( ) , config ) ; } catch ( CoreException e ) { handleException ( e ) ; } finally { try { setAutobuild ( wasAutobuilding ) ; } catch ( CoreException e ) { handleException ( e ) ; } } if ( newConfig ! = null ) { userHasMadeChanges = true ; viewer . add ( newConfig ) ; viewer . setChecked ( newConfig , isEnabled ( newConfig ) ) ; newConfigList . add ( newConfig ) ; } } private void handleRemoveButtonPressed ( ) { IStructuredSelection selection = ( IStructuredSelection ) viewer . getSelection ( ) ; if ( selection ! = null ) { int numSelected = selection . size ( ) ; userHasMadeChanges = true ; Iterator < ? > iterator = selection . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object item = iterator . next ( ) ; if ( item instanceof ILaunchConfiguration ) { if ( configsToBeDeleted = = null ) { configsToBeDeleted = new ArrayList < ILaunchConfiguration > ( numSelected ) ; } configsToBeDeleted . add ( ( ILaunchConfiguration ) item ) ; } else if ( item instanceof ICommand ) { if ( commandsToBeDeleted = = null ) { commandsToBeDeleted = new ArrayList < ICommand > ( numSelected ) ; } commandsToBeDeleted . add ( ( ICommand ) item ) ; } viewer . remove ( item ) ; } } } private void handleNewButtonPressed ( ) { ILaunchConfigurationType type = promptForConfigurationType ( ) ; if ( type = = null ) { return ; } boolean wasAutobuilding = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ; try { ILaunchConfigurationWorkingCopy workingCopy = null ; String name = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateLaunchConfigurationName ( ExternalToolsUIMessages . BuilderPropertyPage_New_Builder_7 ) ; workingCopy = type . newInstance ( BuilderUtils . getBuilderFolder ( getInputProject ( ) , true ) , name ) ; StringBuffer buffer = new StringBuffer ( IExternalToolConstants . BUILD_TYPE_FULL ) ; buffer . append ( <str> ) ; buffer . append ( IExternalToolConstants . BUILD_TYPE_INCREMENTAL ) ; buffer . append ( <str> ) ; workingCopy . setAttribute ( IExternalToolConstants . ATTR_RUN_BUILD_KINDS , buffer . toString ( ) ) ; workingCopy . setAttribute ( ExternalToolsMainTab . FIRST_EDIT , true ) ; ILaunchConfiguration config = null ; setAutobuild ( false ) ; config = workingCopy . doSave ( ) ; newConfigList . add ( config ) ; int code = editConfiguration ( config ) ; if ( code = = Window . CANCEL ) { newConfigList . remove ( config ) ; config . delete ( ) ; } else { userHasMadeChanges = true ; config = newConfigList . get ( newConfigList . size ( ) - <int> ) ; viewer . add ( config ) ; viewer . setChecked ( config , isEnabled ( config ) ) ; } } catch ( CoreException e ) { handleException ( e ) ; } finally { try { setAutobuild ( wasAutobuilding ) ; } catch ( CoreException e ) { handleException ( e ) ; } } } private int editConfiguration ( ILaunchConfiguration config ) { ILaunchManager manager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; manager . addLaunchConfigurationListener ( configurationListener ) ; Shell shell = getShell ( ) ; if ( shell = = null ) { return Window . CANCEL ; } int code = DebugUITools . openLaunchConfigurationPropertiesDialog ( shell , config , org . eclipse . ui . externaltools . internal . model . IExternalToolConstants . ID_EXTERNAL_TOOLS_BUILDER_LAUNCH_GROUP ) ; manager . removeLaunchConfigurationListener ( configurationListener ) ; return code ; } private ILaunchConfigurationType promptForConfigurationType ( ) { List < ILaunchConfigurationType > externalToolTypes = getConfigurationTypes ( IExternalToolConstants . ID_EXTERNAL_TOOLS_BUILDER_LAUNCH_CATEGORY ) ; Shell shell = getShell ( ) ; if ( shell = = null ) { return null ; } ElementListSelectionDialog dialog = new ElementListSelectionDialog ( shell , new BuilderLabelProvider ( ) ) ; dialog . setElements ( externalToolTypes . toArray ( ) ) ; dialog . setMultipleSelection ( false ) ; dialog . setTitle ( ExternalToolsUIMessages . BuilderPropertyPage_Choose_configuration_type_8 ) ; dialog . setMessage ( ExternalToolsUIMessages . BuilderPropertyPage_Choose_an_external_tool_type_to_create_9 ) ; dialog . open ( ) ; Object result [ ] = dialog . getResult ( ) ; if ( result = = null | | result . length = = <int> ) { return null ; } return ( ILaunchConfigurationType ) result [ <int> ] ; } private List < ILaunchConfigurationType > getConfigurationTypes ( String category ) { ILaunchConfigurationType types [ ] = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfigurationTypes ( ) ; List < ILaunchConfigurationType > externalToolTypes = new ArrayList < ILaunchConfigurationType > ( ) ; for ( int i = <int> ; i < types . length ; i + + ) { ILaunchConfigurationType configurationType = types [ i ] ; if ( category . equals ( configurationType . getCategory ( ) ) ) { externalToolTypes . add ( configurationType ) ; } } return externalToolTypes ; } private void handleEditButtonPressed ( ) { TableItem [ ] items = viewer . getTable ( ) . getSelection ( ) ; if ( items . length = = <int> ) { return ; } TableItem selection = items [ <int> ] ; if ( selection ! = null ) { Object data = selection . getData ( ) ; if ( data instanceof ILaunchConfiguration ) { ILaunchConfiguration config = ( ILaunchConfiguration ) data ; if ( BuilderUtils . isUnmigratedConfig ( config ) ) { if ( ! shouldProceedWithMigration ( ) ) { return ; } try { config = BuilderUtils . migrateBuilderConfiguration ( getInputProject ( ) , ( ILaunchConfigurationWorkingCopy ) config ) ; } catch ( CoreException e ) { handleException ( e ) ; return ; } selection . setData ( config ) ; } userHasMadeChanges = true ; boolean wasAutobuilding = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ; try { setAutobuild ( false ) ; editConfiguration ( config ) ; } catch ( CoreException e ) { handleException ( e ) ; } finally { try { setAutobuild ( wasAutobuilding ) ; } catch ( CoreException e ) { handleException ( e ) ; } } } else if ( data instanceof ICommand ) { ICommand command = ( ICommand ) data ; if ( command . isConfigurable ( ) ) { if ( editCommand ( command ) ) { userHasMadeChanges = true ; } } } } } private boolean editCommand ( ICommand data ) { EditCommandDialog dialog = new EditCommandDialog ( getShell ( ) , data ) ; return Window . OK = = dialog . open ( ) ; } private boolean shouldProceedWithMigration ( ) { if ( ! ExternalToolsPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IPreferenceConstants . PROMPT_FOR_TOOL_MIGRATION ) ) { return true ; } Shell shell = getShell ( ) ; if ( shell = = null ) { return false ; } MessageDialogWithToggle dialog = MessageDialogWithToggle . openYesNoQuestion ( getShell ( ) , ExternalToolsUIMessages . BuilderPropertyPage_Migrate_project_builder_10 , ExternalToolsUIMessages . BuilderPropertyPage_Not_Support , ExternalToolsUIMessages . BuilderPropertyPage_Prompt , false , ExternalToolsPlugin . getDefault ( ) . getPreferenceStore ( ) , IPreferenceConstants . PROMPT_FOR_TOOL_MIGRATION ) ; return dialog . getReturnCode ( ) = = IDialogConstants . YES_ID ; } private void handleException ( Exception e ) { final IStatus [ ] status = new IStatus [ <int> ] ; if ( e instanceof CoreException ) { status [ <int> ] = ( ( CoreException ) e ) . getStatus ( ) ; } else { status [ <int> ] = new Status ( IStatus . ERROR , ExternalToolsPlugin . PLUGIN_ID , <int> , ExternalToolsUIMessages . BuilderPropertyPage_statusMessage , e ) ; } Display . getDefault ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { Shell shell = getShell ( ) ; if ( shell ! = null ) { ErrorDialog . openError ( shell , ExternalToolsUIMessages . BuilderPropertyPage_errorTitle , ExternalToolsUIMessages . BuilderPropertyPage_errorMessage , status [ <int> ] ) ; } } } ) ; } private void handleTableSelectionChanged ( ) { newButton . setEnabled ( true ) ; Table builderTable = viewer . getTable ( ) ; TableItem [ ] items = builderTable . getSelection ( ) ; fCanEdit = false ; boolean enableRemove = false ; boolean enableUp = false ; boolean enableDown = false ; if ( items ! = null ) { boolean validSelection = items . length > <int> ; fCanEdit = validSelection ; enableRemove = validSelection ; enableUp = validSelection ; enableDown = validSelection ; if ( items . length > <int> ) { fCanEdit = false ; } int indices [ ] = builderTable . getSelectionIndices ( ) ; int max = builderTable . getItemCount ( ) ; if ( indices . length > <int> ) { enableUp = indices [ <int> ] ! = <int> ; enableDown = indices [ indices . length - <int> ] < max - <int> ; } for ( int i = <int> ; i < items . length ; i + + ) { TableItem item = items [ i ] ; Object data = item . getData ( ) ; if ( data instanceof ILaunchConfiguration ) { ILaunchConfiguration config = ( ILaunchConfiguration ) data ; String builderName = null ; try { builderName = config . getAttribute ( IExternalToolConstants . ATTR_DISABLED_BUILDER , ( String ) null ) ; } catch ( CoreException e ) { } if ( builderName ! = null ) { IExtension ext = Platform . getExtensionRegistry ( ) . getExtension ( ResourcesPlugin . PI_RESOURCES , ResourcesPlugin . PT_BUILDERS , builderName ) ; fCanEdit = false ; enableRemove = ext = = null ; } } else { if ( data instanceof ErrorConfig ) { fCanEdit = false ; continue ; } ICommand command = ( ICommand ) data ; fCanEdit = command . isConfigurable ( ) ; IExtension ext = Platform . getExtensionRegistry ( ) . getExtension ( ResourcesPlugin . PI_RESOURCES , ResourcesPlugin . PT_BUILDERS , command . getBuilderName ( ) ) ; enableRemove = ext = = null ; break ; } } } editButton . setEnabled ( fCanEdit ) ; removeButton . setEnabled ( enableRemove ) ; upButton . setEnabled ( enableUp ) ; downButton . setEnabled ( enableDown ) ; } private boolean isEnabled ( Object element ) { if ( element instanceof ICommand ) { ICommand command = ( ICommand ) element ; String val = command . getArguments ( ) . get ( COMMAND_ENABLED ) ; if ( val ! = null ) { return Boolean . parseBoolean ( val ) ; } } else if ( element instanceof ILaunchConfiguration ) { try { return ExternalToolsUtil . isBuilderEnabled ( ( ILaunchConfiguration ) element ) ; } catch ( CoreException e ) { } } else if ( element instanceof ErrorConfig ) { return false ; } return true ; } private void move ( TableItem item , int index ) { userHasMadeChanges = true ; Object data = item . getData ( ) ; item . dispose ( ) ; viewer . insert ( data , index ) ; viewer . setChecked ( data , isEnabled ( data ) ) ; } private void moveSelectionDown ( ) { Table builderTable = viewer . getTable ( ) ; int indices [ ] = builderTable . getSelectionIndices ( ) ; if ( indices . length < <int> ) { return ; } int newSelection [ ] = new int [ indices . length ] ; int max = builderTable . getItemCount ( ) - <int> ; for ( int i = indices . length - <int> ; i > = <int> ; i - - ) { int index = indices [ i ] ; if ( index < max ) { move ( builderTable . getItem ( index ) , index + <int> ) ; newSelection [ i ] = index + <int> ; } } builderTable . setSelection ( newSelection ) ; } private void moveSelectionUp ( ) { Table builderTable = viewer . getTable ( ) ; int indices [ ] = builderTable . getSelectionIndices ( ) ; int newSelection [ ] = new int [ indices . length ] ; for ( int i = <int> ; i < indices . length ; i + + ) { int index = indices [ i ] ; if ( index > <int> ) { move ( builderTable . getItem ( index ) , index - <int> ) ; newSelection [ i ] = index - <int> ; } } builderTable . setSelection ( newSelection ) ; } @Override public boolean performOk ( ) { if ( ! userHasMadeChanges ) { return super . performOk ( ) ; } userHasMadeChanges = false ; Table builderTable = viewer . getTable ( ) ; int numCommands = builderTable . getItemCount ( ) ; final Object [ ] itemData = new Object [ numCommands ] ; for ( int i = <int> ; i < numCommands ; i + + ) { itemData [ i ] = builderTable . getItem ( i ) . getData ( ) ; } IRunnableWithProgress runnable = new IRunnableWithProgress ( ) { @Override public void run ( IProgressMonitor monitor ) throws InvocationTargetException , InterruptedException { doPerformOk ( monitor , itemData ) ; if ( monitor . isCanceled ( ) ) { throw new InterruptedException ( ) ; } } } ; IProgressService service = PlatformUI . getWorkbench ( ) . getProgressService ( ) ; try { service . busyCursorWhile ( runnable ) ; } catch ( InvocationTargetException e ) { return false ; } catch ( InterruptedException e ) { return false ; } return super . performOk ( ) ; } private void doPerformOk ( IProgressMonitor monitor , Object [ ] itemData ) { if ( monitor . isCanceled ( ) ) { return ; } IProject project = getInputProject ( ) ; int numCommands = itemData . length ; monitor . beginTask ( ExternalToolsUIMessages . BuilderPropertyPage_3 , numCommands + <int> ) ; List < ICommand > possibleCommands = new ArrayList < ICommand > ( numCommands ) ; for ( int i = <int> ; i < numCommands ; i + + ) { Object data = itemData [ i ] ; if ( data instanceof ICommand ) { if ( commandsToBeDeleted ! = null & & commandsToBeDeleted . contains ( data ) ) { data = null ; continue ; } ICommand command = ( ICommand ) data ; Map < String , String > args = command . getArguments ( ) ; String val = args . get ( COMMAND_ENABLED ) ; if ( val ! = null ) { if ( ! Boolean . parseBoolean ( val ) ) { ILaunchConfiguration config = disableCommand ( command ) ; if ( config ! = null ) { data = BuilderUtils . commandFromLaunchConfig ( project , config ) ; } } else { args . remove ( COMMAND_ENABLED ) ; command . setArguments ( args ) ; } } } else if ( data instanceof ILaunchConfiguration ) { ILaunchConfiguration config = ( ILaunchConfiguration ) data ; String disabledBuilderName ; try { disabledBuilderName = config . getAttribute ( IExternalToolConstants . ATTR_DISABLED_BUILDER , ( String ) null ) ; if ( disabledBuilderName ! = null & & ExternalToolsUtil . isBuilderEnabled ( config ) ) { possibleCommands . add ( translateBackToCommand ( config , project ) ) ; continue ; } } catch ( CoreException e1 ) { } if ( ! BuilderUtils . isUnmigratedConfig ( config ) & & ( config instanceof ILaunchConfigurationWorkingCopy ) ) { ILaunchConfigurationWorkingCopy workingCopy = ( ( ILaunchConfigurationWorkingCopy ) config ) ; if ( workingCopy . isDirty ( ) ) { try { workingCopy . doSave ( ) ; } catch ( CoreException e ) { Shell shell = getShell ( ) ; if ( shell ! = null ) { MessageDialog . openError ( shell , ExternalToolsUIMessages . BuilderPropertyPage_39 , NLS . bind ( ExternalToolsUIMessages . BuilderPropertyPage_40 , new String [ ] { workingCopy . getName ( ) } ) ) ; } } } } data = BuilderUtils . commandFromLaunchConfig ( project , config ) ; } else if ( data instanceof ErrorConfig ) { data = ( ( ErrorConfig ) data ) . getCommand ( ) ; } if ( data instanceof ICommand ) { possibleCommands . add ( ( ICommand ) data ) ; } monitor . worked ( <int> ) ; } ICommand [ ] commands = new ICommand [ possibleCommands . size ( ) ] ; possibleCommands . toArray ( commands ) ; if ( checkCommandsForChange ( commands ) ) { try { IProjectDescription desc = project . getDescription ( ) ; desc . setBuildSpec ( commands ) ; project . setDescription ( desc , IResource . FORCE , monitor ) ; } catch ( CoreException e ) { handleException ( e ) ; performCancel ( ) ; } } if ( configsToBeDeleted ! = null ) { deleteConfigurations ( ) ; } monitor . done ( ) ; } private void checkBuilderFolder ( ) { try { IFolder builderFolder = BuilderUtils . getBuilderFolder ( getInputProject ( ) , false ) ; if ( builderFolder ! = null & & builderFolder . exists ( ) & & builderFolder . members ( ) . length = = <int> ) { builderFolder . delete ( true , false , null ) ; } } catch ( CoreException e ) { handleException ( e ) ; } } private ICommand translateBackToCommand ( ILaunchConfiguration config , IProject project ) { try { ICommand newCommand = project . getDescription ( ) . newCommand ( ) ; String builderName = config . getAttribute ( IExternalToolConstants . ATTR_DISABLED_BUILDER , ( String ) null ) ; Map < String , String > args = config . getAttribute ( IExternalToolConstants . ATTR_TOOL_ARGUMENTS , new HashMap < String , String > ( <int> ) ) ; newCommand . setBuilderName ( builderName ) ; newCommand . setArguments ( args ) ; if ( configsToBeDeleted = = null ) { configsToBeDeleted = new ArrayList < ILaunchConfiguration > ( ) ; } configsToBeDeleted . add ( config ) ; return newCommand ; } catch ( CoreException exception ) { Shell shell = getShell ( ) ; if ( shell ! = null ) { MessageDialog . openError ( shell , ExternalToolsUIMessages . BuilderPropertyPage_13 , ExternalToolsUIMessages . BuilderPropertyPage_error ) ; } return null ; } } private ILaunchConfiguration disableCommand ( ICommand command ) { Map < String , String > arguments = command . getArguments ( ) ; if ( arguments ! = null ) { arguments . remove ( COMMAND_ENABLED ) ; } List < ILaunchConfigurationType > externalToolTypes = getConfigurationTypes ( IExternalToolConstants . ID_EXTERNAL_TOOLS_BUILDER_LAUNCH_CATEGORY ) ; if ( externalToolTypes . size ( ) = = <int> ) { return null ; } ILaunchConfigurationType type = externalToolTypes . get ( <int> ) ; if ( type = = null ) { return null ; } boolean wasAutobuilding = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ; try { ILaunchConfigurationWorkingCopy workingCopy = null ; String builderName = command . getBuilderName ( ) ; String name = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateLaunchConfigurationName ( builderName ) ; workingCopy = type . newInstance ( BuilderUtils . getBuilderFolder ( getInputProject ( ) , true ) , name ) ; workingCopy . setAttribute ( IExternalToolConstants . ATTR_DISABLED_BUILDER , builderName ) ; if ( arguments ! = null ) { workingCopy . setAttribute ( IExternalToolConstants . ATTR_TOOL_ARGUMENTS , arguments ) ; } workingCopy . setAttribute ( IExternalToolConstants . ATTR_BUILDER_ENABLED , false ) ; ILaunchConfiguration config = null ; setAutobuild ( false ) ; config = workingCopy . doSave ( ) ; return config ; } catch ( CoreException e ) { handleException ( e ) ; } finally { try { setAutobuild ( wasAutobuilding ) ; } catch ( CoreException e ) { handleException ( e ) ; } } return null ; } private void deleteConfigurations ( ) { boolean wasAutobuilding = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . isAutoBuilding ( ) ; try { setAutobuild ( false ) ; for ( ILaunchConfiguration config : configsToBeDeleted ) { config . delete ( ) ; } checkBuilderFolder ( ) ; } catch ( CoreException e ) { handleException ( e ) ; } finally { try { setAutobuild ( wasAutobuilding ) ; } catch ( CoreException e ) { handleException ( e ) ; } } } private boolean checkCommandsForChange ( ICommand [ ] newCommands ) { try { ICommand [ ] oldCommands = getInputProject ( ) . getDescription ( ) . getBuildSpec ( ) ; if ( oldCommands . length ! = newCommands . length ) { return true ; } IgnoreWhiteSpaceComparator comparator = new IgnoreWhiteSpaceComparator ( ) ; for ( int i = <int> ; i < oldCommands . length ; i + + ) { ICommand oldCommand = oldCommands [ i ] ; ICommand newCommand = newCommands [ i ] ; String oldName = oldCommand . getBuilderName ( ) ; String newName = newCommand . getBuilderName ( ) ; if ( oldName = = null & & newName ! = null ) { return true ; } if ( oldName ! = null & & ! oldName . equals ( newName ) ) { return true ; } Map < String , String > oldArgs = oldCommand . getArguments ( ) ; Map < String , String > newArgs = newCommand . getArguments ( ) ; if ( oldArgs = = null ) { if ( newArgs ! = null ) { return true ; } continue ; } if ( oldArgs . size ( ) ! = newArgs . size ( ) ) { return true ; } for ( String key : oldArgs . keySet ( ) ) { if ( comparator . compare ( oldArgs . get ( key ) , newArgs . get ( key ) ) ! = <int> ) { return true ; } } if ( oldCommand . isBuilding ( IncrementalProjectBuilder . AUTO_BUILD ) ! = newCommand . isBuilding ( IncrementalProjectBuilder . AUTO_BUILD ) | | oldCommand . isBuilding ( IncrementalProjectBuilder . CLEAN_BUILD ) ! = newCommand . isBuilding ( IncrementalProjectBuilder . CLEAN_BUILD ) | | oldCommand . isBuilding ( IncrementalProjectBuilder . INCREMENTAL_BUILD ) ! = newCommand . isBuilding ( IncrementalProjectBuilder . INCREMENTAL_BUILD ) | | oldCommand . isBuilding ( IncrementalProjectBuilder . FULL_BUILD ) ! = newCommand . isBuilding ( IncrementalProjectBuilder . FULL_BUILD ) ) { return true ; } } } catch ( CoreException ce ) { return true ; } return false ; } @Override public boolean performCancel ( ) { for ( ILaunchConfiguration config : newConfigList ) { try { config . delete ( ) ; } catch ( CoreException e ) { handleException ( e ) ; } } checkBuilderFolder ( ) ; Table builderTable = viewer . getTable ( ) ; int numCommands = builderTable . getItemCount ( ) ; for ( int i = <int> ; i < numCommands ; i + + ) { Object data = builderTable . getItem ( i ) . getData ( ) ; if ( data instanceof ICommand ) { ICommand command = ( ICommand ) data ; Map < String , String > args = command . getArguments ( ) ; args . remove ( COMMAND_ENABLED ) ; command . setArguments ( args ) ; } } return super . performCancel ( ) ; } @Override public Shell getShell ( ) { if ( getControl ( ) . isDisposed ( ) ) { return null ; } return super . getShell ( ) ; } } 
