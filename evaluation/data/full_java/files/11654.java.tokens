package org . gradle . api . internal . project . antbuilder ; import com . google . common . collect . Lists ; import groovy . lang . Closure ; import org . gradle . api . Action ; import org . gradle . api . internal . ClassPathRegistry ; import org . gradle . api . internal . classloading . GroovySystemLoader ; import org . gradle . api . internal . classloading . GroovySystemLoaderFactory ; import org . gradle . api . internal . project . IsolatedAntBuilder ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . classloader . * ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . jvm . Jvm ; import org . gradle . util . ConfigureUtil ; import java . io . File ; import java . lang . reflect . Method ; import java . util . List ; import java . util . Vector ; public class DefaultIsolatedAntBuilder implements IsolatedAntBuilder , Stoppable { private final static Logger LOG = Logging . getLogger ( DefaultIsolatedAntBuilder . class ) ; private final ClassLoader antLoader ; private final ClassLoader baseAntLoader ; private final ClassPath libClasspath ; private final ClassLoader antAdapterLoader ; private final ClassPathRegistry classPathRegistry ; private final ClassLoaderFactory classLoaderFactory ; private final ClassPathToClassLoaderCache classLoaderCache ; private final GroovySystemLoader gradleApiGroovyLoader ; private final GroovySystemLoader antAdapterGroovyLoader ; public DefaultIsolatedAntBuilder ( ClassPathRegistry classPathRegistry , ClassLoaderFactory classLoaderFactory ) { this . classPathRegistry = classPathRegistry ; this . classLoaderFactory = classLoaderFactory ; this . libClasspath = new DefaultClassPath ( ) ; GroovySystemLoaderFactory groovySystemLoaderFactory = new GroovySystemLoaderFactory ( ) ; this . classLoaderCache = new ClassPathToClassLoaderCache ( groovySystemLoaderFactory ) ; List < File > antClasspath = Lists . newArrayList ( classPathRegistry . getClassPath ( <str> ) . getAsFiles ( ) ) ; File toolsJar = Jvm . current ( ) . getToolsJar ( ) ; if ( toolsJar ! = null ) { antClasspath . add ( toolsJar ) ; } antLoader = classLoaderFactory . createIsolatedClassLoader ( new DefaultClassPath ( antClasspath ) ) ; FilteringClassLoader loggingLoader = new FilteringClassLoader ( getClass ( ) . getClassLoader ( ) ) ; loggingLoader . allowPackage ( <str> ) ; loggingLoader . allowPackage ( <str> ) ; loggingLoader . allowPackage ( <str> ) ; loggingLoader . allowClass ( Logger . class ) ; loggingLoader . allowClass ( LogLevel . class ) ; this . baseAntLoader = new CachingClassLoader ( new MultiParentClassLoader ( antLoader , loggingLoader ) ) ; ClassPath gradleCoreUrls = classPathRegistry . getClassPath ( <str> ) ; gradleCoreUrls = gradleCoreUrls . plus ( classPathRegistry . getClassPath ( <str> ) ) ; gradleCoreUrls = gradleCoreUrls . plus ( classPathRegistry . getClassPath ( <str> ) ) ; this . antAdapterLoader = new MutableURLClassLoader ( baseAntLoader , gradleCoreUrls ) ; gradleApiGroovyLoader = groovySystemLoaderFactory . forClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; antAdapterGroovyLoader = groovySystemLoaderFactory . forClassLoader ( antAdapterLoader ) ; } protected DefaultIsolatedAntBuilder ( DefaultIsolatedAntBuilder copy , Iterable < File > libClasspath ) { this . classPathRegistry = copy . classPathRegistry ; this . classLoaderFactory = copy . classLoaderFactory ; this . antLoader = copy . antLoader ; this . baseAntLoader = copy . baseAntLoader ; this . antAdapterLoader = copy . antAdapterLoader ; this . libClasspath = new DefaultClassPath ( libClasspath ) ; this . gradleApiGroovyLoader = copy . gradleApiGroovyLoader ; this . antAdapterGroovyLoader = copy . antAdapterGroovyLoader ; this . classLoaderCache = copy . classLoaderCache ; } public ClassPathToClassLoaderCache getClassLoaderCache ( ) { return classLoaderCache ; } public IsolatedAntBuilder withClasspath ( Iterable < File > classpath ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , classpath ) ) ; } return new DefaultIsolatedAntBuilder ( this , classpath ) ; } public void execute ( final Closure antClosure ) { classLoaderCache . withCachedClassLoader ( libClasspath , gradleApiGroovyLoader , antAdapterGroovyLoader , new Factory < ClassLoader > ( ) { @Override public ClassLoader create ( ) { return new MutableURLClassLoader ( baseAntLoader , libClasspath ) ; } } , new Action < CachedClassLoader > ( ) { @Override public void execute ( CachedClassLoader cachedClassLoader ) { ClassLoader classLoader = cachedClassLoader . getClassLoader ( ) ; Object antBuilder = newInstanceOf ( <str> ) ; Object antLogger = newInstanceOf ( <str> ) ; ClassLoader originalLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; try { configureAntBuilder ( antBuilder , antLogger ) ; Object delegate = new AntBuilderDelegate ( antBuilder , classLoader ) ; ConfigureUtil . configure ( antClosure , delegate ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( originalLoader ) ; disposeBuilder ( antBuilder , antLogger ) ; } } } ) ; } private Object newInstanceOf ( String className ) { try { return antAdapterLoader . loadClass ( className ) . newInstance ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } private Object getProject ( Object antBuilder ) throws Exception { return antBuilder . getClass ( ) . getMethod ( <str> ) . invoke ( antBuilder ) ; } protected void configureAntBuilder ( Object antBuilder , Object antLogger ) { try { Object project = getProject ( antBuilder ) ; Class < ? > projectClass = project . getClass ( ) ; ClassLoader cl = projectClass . getClassLoader ( ) ; Class < ? > buildListenerClass = cl . loadClass ( <str> ) ; Method addBuildListener = projectClass . getDeclaredMethod ( <str> , buildListenerClass ) ; Method removeBuildListener = projectClass . getDeclaredMethod ( <str> , buildListenerClass ) ; Method getBuildListeners = projectClass . getDeclaredMethod ( <str> ) ; Vector listeners = ( Vector ) getBuildListeners . invoke ( project ) ; removeBuildListener . invoke ( project , listeners . get ( <int> ) ) ; addBuildListener . invoke ( project , antLogger ) ; } catch ( Exception ex ) { throw UncheckedException . throwAsUncheckedException ( ex ) ; } } protected void disposeBuilder ( Object antBuilder , Object antLogger ) { try { Object project = getProject ( antBuilder ) ; Class < ? > projectClass = project . getClass ( ) ; ClassLoader cl = projectClass . getClassLoader ( ) ; Class < ? > buildListenerClass = cl . loadClass ( <str> ) ; Method removeBuildListener = projectClass . getDeclaredMethod ( <str> , buildListenerClass ) ; removeBuildListener . invoke ( project , antLogger ) ; antBuilder . getClass ( ) . getDeclaredMethod ( <str> ) . invoke ( antBuilder ) ; } catch ( Exception ex ) { throw UncheckedException . throwAsUncheckedException ( ex ) ; } } @Override public void stop ( ) { classLoaderCache . stop ( ) ; gradleApiGroovyLoader . discardTypesFrom ( antAdapterLoader ) ; gradleApiGroovyLoader . discardTypesFrom ( antLoader ) ; antAdapterGroovyLoader . shutdown ( ) ; } } 
