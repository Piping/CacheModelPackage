package org . elasticsearch . discovery ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . discovery . ClusterDiscoveryConfiguration ; import org . junit . Before ; import java . util . List ; import java . util . concurrent . ExecutionException ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) @ESIntegTestCase.SuppressLocalMode public class ZenUnicastDiscoveryIT extends ESIntegTestCase { private ClusterDiscoveryConfiguration discoveryConfig ; @Override protected Settings nodeSettings ( int nodeOrdinal ) { return discoveryConfig . nodeSettings ( nodeOrdinal ) ; } @Before public void clearConfig ( ) { discoveryConfig = null ; } public void testNormalClusterForming ( ) throws ExecutionException , InterruptedException { int currentNumNodes = randomIntBetween ( <int> , <int> ) ; int [ ] unicastHostOrdinals = new int [ randomIntBetween ( <int> , currentNumNodes ) ] ; for ( int i = <int> ; i < unicastHostOrdinals . length ; i + + ) { unicastHostOrdinals [ i ] = i ; } discoveryConfig = new ClusterDiscoveryConfiguration . UnicastZen ( currentNumNodes , unicastHostOrdinals ) ; internalCluster ( ) . startNodesAsync ( unicastHostOrdinals . length ) . get ( ) ; internalCluster ( ) . startNodesAsync ( currentNumNodes - unicastHostOrdinals . length ) . get ( ) ; if ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> + currentNumNodes ) . get ( ) . isTimedOut ( ) ) { logger . info ( <str> , client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . prettyPrint ( ) ) ; fail ( <str> + currentNumNodes + <str> ) ; } } public void testMinimumMasterNodes ( ) throws Exception { int currentNumNodes = randomIntBetween ( <int> , <int> ) ; final int min_master_nodes = currentNumNodes / <int> + <int> ; int currentNumOfUnicastHosts = randomIntBetween ( min_master_nodes , currentNumNodes ) ; final Settings settings = Settings . settingsBuilder ( ) . put ( <str> , TimeValue . timeValueSeconds ( <int> ) ) . put ( <str> , min_master_nodes ) . build ( ) ; discoveryConfig = new ClusterDiscoveryConfiguration . UnicastZen ( currentNumNodes , currentNumOfUnicastHosts , settings ) ; List < String > nodes = internalCluster ( ) . startNodesAsync ( currentNumNodes ) . get ( ) ; ensureStableCluster ( currentNumNodes ) ; DiscoveryNode masterDiscoNode = null ; for ( String node : nodes ) { ClusterState state = internalCluster ( ) . client ( node ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . nodes ( ) . size ( ) , equalTo ( currentNumNodes ) ) ; if ( masterDiscoNode = = null ) { masterDiscoNode = state . nodes ( ) . masterNode ( ) ; } else { assertThat ( masterDiscoNode . equals ( state . nodes ( ) . masterNode ( ) ) , equalTo ( true ) ) ; } } } } 
