package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . OrthoCamController ; public class ParallaxTest extends GdxTest { class ParallaxCamera extends OrthographicCamera { Matrix4 parallaxView = new Matrix4 ( ) ; Matrix4 parallaxCombined = new Matrix4 ( ) ; Vector3 tmp = new Vector3 ( ) ; Vector3 tmp2 = new Vector3 ( ) ; public ParallaxCamera ( float viewportWidth , float viewportHeight ) { super ( viewportWidth , viewportHeight ) ; } public Matrix4 calculateParallaxMatrix ( float parallaxX , float parallaxY ) { update ( ) ; tmp . set ( position ) ; tmp . x * = parallaxX ; tmp . y * = parallaxY ; parallaxView . setToLookAt ( tmp , tmp2 . set ( tmp ) . add ( direction ) , up ) ; parallaxCombined . set ( projection ) ; Matrix4 . mul ( parallaxCombined . val , parallaxView . val ) ; return parallaxCombined ; } } TextureRegion [ ] layers ; ParallaxCamera camera ; OrthoCamController controller ; SpriteBatch batch ; BitmapFont font ; @Override public void create ( ) { Texture texture = new Texture ( Gdx . files . internal ( <str> ) ) ; layers = new TextureRegion [ <int> ] ; layers [ <int> ] = new TextureRegion ( texture , <int> , <int> , <int> , <int> ) ; layers [ <int> ] = new TextureRegion ( texture , <int> , <int> , <int> , <int> ) ; layers [ <int> ] = new TextureRegion ( texture , <int> , <int> , <int> , <int> ) ; camera = new ParallaxCamera ( <int> , <int> ) ; controller = new OrthoCamController ( camera ) ; Gdx . input . setInputProcessor ( controller ) ; batch = new SpriteBatch ( ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , false ) ; } @Override public void dispose ( ) { layers [ <int> ] . getTexture ( ) . dispose ( ) ; batch . dispose ( ) ; font . dispose ( ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <int> / <float> , <int> / <float> , <int> / <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; boolean updateCamera = false ; if ( camera . position . x < - <int> + camera . viewportWidth / <int> ) { camera . position . x = - <int> + ( int ) ( camera . viewportWidth / <int> ) ; updateCamera = true ; } if ( camera . position . x > <int> - camera . viewportWidth / <int> ) { camera . position . x = <int> - ( int ) ( camera . viewportWidth / <int> ) ; updateCamera = true ; } if ( camera . position . y < <int> ) { camera . position . y = <int> ; updateCamera = true ; } if ( camera . position . y > <int> - camera . viewportHeight / <int> ) { camera . position . y = <int> - ( int ) ( camera . viewportHeight / <int> ) ; updateCamera = true ; } batch . setProjectionMatrix ( camera . calculateParallaxMatrix ( <int> , <int> ) ) ; batch . disableBlending ( ) ; batch . begin ( ) ; batch . draw ( layers [ <int> ] , - ( int ) ( layers [ <int> ] . getRegionWidth ( ) / <int> ) , - ( int ) ( layers [ <int> ] . getRegionHeight ( ) / <int> ) ) ; batch . end ( ) ; batch . enableBlending ( ) ; batch . setProjectionMatrix ( camera . calculateParallaxMatrix ( <float> , <int> ) ) ; batch . begin ( ) ; batch . draw ( layers [ <int> ] , - <int> , - <int> ) ; batch . end ( ) ; batch . setProjectionMatrix ( camera . calculateParallaxMatrix ( <float> , <int> ) ) ; batch . begin ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { batch . draw ( layers [ <int> ] , i * layers [ <int> ] . getRegionWidth ( ) - <int> , - <int> ) ; } batch . end ( ) ; batch . getProjectionMatrix ( ) . setToOrtho2D ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; batch . begin ( ) ; font . draw ( batch , <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; batch . end ( ) ; } } 
