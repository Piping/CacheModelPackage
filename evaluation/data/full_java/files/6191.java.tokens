package org . elasticsearch . env ; import org . apache . lucene . util . Constants ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . settings . Settings ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URISyntaxException ; import java . net . URL ; import java . nio . file . FileStore ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import static org . elasticsearch . common . Strings . cleanPath ; @SuppressForbidden ( reason = <str> ) public class Environment { private final Settings settings ; private final Path [ ] dataFiles ; private final Path [ ] dataWithClusterFiles ; private final Path [ ] repoFiles ; private final Path configFile ; private final Path scriptsFile ; private final Path pluginsFile ; private final Path modulesFile ; private final Path sharedDataFile ; private final Path binFile ; private final Path libFile ; private final Path logsFile ; private final Path pidFile ; private final Path tmpFile = PathUtils . get ( System . getProperty ( <str> ) ) ; private static final FileStore [ ] fileStores ; static { ArrayList < FileStore > allStores = new ArrayList < > ( ) ; for ( FileStore store : PathUtils . getDefaultFileSystem ( ) . getFileStores ( ) ) { allStores . add ( new ESFileStore ( store ) ) ; } fileStores = allStores . toArray ( new ESFileStore [ allStores . size ( ) ] ) ; } public Environment ( Settings settings ) { this . settings = settings ; final Path homeFile ; if ( settings . get ( <str> ) ! = null ) { homeFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { throw new IllegalStateException ( <str> ) ; } if ( settings . get ( <str> ) ! = null ) { configFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { configFile = homeFile . resolve ( <str> ) ; } if ( settings . get ( <str> ) ! = null ) { scriptsFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { scriptsFile = configFile . resolve ( <str> ) ; } if ( settings . get ( <str> ) ! = null ) { pluginsFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { pluginsFile = homeFile . resolve ( <str> ) ; } String [ ] dataPaths = settings . getAsArray ( <str> ) ; if ( dataPaths . length > <int> ) { dataFiles = new Path [ dataPaths . length ] ; dataWithClusterFiles = new Path [ dataPaths . length ] ; for ( int i = <int> ; i < dataPaths . length ; i + + ) { dataFiles [ i ] = PathUtils . get ( dataPaths [ i ] ) ; dataWithClusterFiles [ i ] = dataFiles [ i ] . resolve ( ClusterName . clusterNameFromSettings ( settings ) . value ( ) ) ; } } else { dataFiles = new Path [ ] { homeFile . resolve ( <str> ) } ; dataWithClusterFiles = new Path [ ] { homeFile . resolve ( <str> ) . resolve ( ClusterName . clusterNameFromSettings ( settings ) . value ( ) ) } ; } if ( settings . get ( <str> ) ! = null ) { sharedDataFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { sharedDataFile = null ; } String [ ] repoPaths = settings . getAsArray ( <str> ) ; if ( repoPaths . length > <int> ) { repoFiles = new Path [ repoPaths . length ] ; for ( int i = <int> ; i < repoPaths . length ; i + + ) { repoFiles [ i ] = PathUtils . get ( repoPaths [ i ] ) ; } } else { repoFiles = new Path [ <int> ] ; } if ( settings . get ( <str> ) ! = null ) { logsFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { logsFile = homeFile . resolve ( <str> ) ; } if ( settings . get ( <str> ) ! = null ) { pidFile = PathUtils . get ( cleanPath ( settings . get ( <str> ) ) ) ; } else { pidFile = null ; } binFile = homeFile . resolve ( <str> ) ; libFile = homeFile . resolve ( <str> ) ; modulesFile = homeFile . resolve ( <str> ) ; } public Settings settings ( ) { return this . settings ; } public Path [ ] dataFiles ( ) { return dataFiles ; } public Path sharedDataFile ( ) { return sharedDataFile ; } public Path [ ] dataWithClusterFiles ( ) { return dataWithClusterFiles ; } public Path [ ] repoFiles ( ) { return repoFiles ; } public Path resolveRepoFile ( String location ) { return PathUtils . get ( repoFiles , location ) ; } public URL resolveRepoURL ( URL url ) { try { if ( <str> . equalsIgnoreCase ( url . getProtocol ( ) ) ) { if ( url . getHost ( ) = = null | | <str> . equals ( url . getHost ( ) ) ) { Path path = PathUtils . get ( repoFiles , url . toURI ( ) ) ; if ( path = = null ) { return null ; } return path . toUri ( ) . toURL ( ) ; } return null ; } else if ( <str> . equals ( url . getProtocol ( ) ) ) { String file = url . getFile ( ) ; int pos = file . indexOf ( <str> ) ; if ( pos < <int> ) { return null ; } String jarTail = file . substring ( pos ) ; String filePath = file . substring ( <int> , pos ) ; URL internalUrl = new URL ( filePath ) ; URL normalizedUrl = resolveRepoURL ( internalUrl ) ; if ( normalizedUrl = = null ) { return null ; } return new URL ( <str> , <str> , normalizedUrl . toExternalForm ( ) + jarTail ) ; } else { return null ; } } catch ( MalformedURLException ex ) { return null ; } catch ( URISyntaxException ex ) { return null ; } } public Path configFile ( ) { return configFile ; } public Path scriptsFile ( ) { return scriptsFile ; } public Path pluginsFile ( ) { return pluginsFile ; } public Path binFile ( ) { return binFile ; } public Path libFile ( ) { return libFile ; } public Path modulesFile ( ) { return modulesFile ; } public Path logsFile ( ) { return logsFile ; } public Path pidFile ( ) { return pidFile ; } public Path tmpFile ( ) { return tmpFile ; } public static FileStore getFileStore ( Path path ) throws IOException { return ESFileStore . getMatchingFileStore ( path , fileStores ) ; } @SuppressForbidden ( reason = <str> ) public static boolean isWritable ( Path path ) throws IOException { boolean v = Files . isWritable ( path ) ; if ( v | | Constants . WINDOWS = = false ) { return v ; } try { Files . setLastModifiedTime ( path , Files . getLastModifiedTime ( path ) ) ; return true ; } catch ( Throwable e ) { return false ; } } } 
