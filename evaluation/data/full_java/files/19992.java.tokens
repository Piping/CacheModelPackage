package io . netty . handler . ssl ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import javax . net . ssl . KeyManagerFactory ; import javax . net . ssl . SSLException ; import javax . net . ssl . TrustManagerFactory ; import java . io . File ; import java . security . PrivateKey ; import java . security . cert . X509Certificate ; public final class SslContextBuilder { public static SslContextBuilder forClient ( ) { return new SslContextBuilder ( false ) ; } public static SslContextBuilder forServer ( File keyCertChainFile , File keyFile ) { return new SslContextBuilder ( true ) . keyManager ( keyCertChainFile , keyFile ) ; } public static SslContextBuilder forServer ( PrivateKey key , X509Certificate . . . keyCertChain ) { return new SslContextBuilder ( true ) . keyManager ( key , keyCertChain ) ; } public static SslContextBuilder forServer ( File keyCertChainFile , File keyFile , String keyPassword ) { return new SslContextBuilder ( true ) . keyManager ( keyCertChainFile , keyFile , keyPassword ) ; } public static SslContextBuilder forServer ( PrivateKey key , String keyPassword , X509Certificate . . . keyCertChain ) { return new SslContextBuilder ( true ) . keyManager ( key , keyPassword , keyCertChain ) ; } public static SslContextBuilder forServer ( KeyManagerFactory keyManagerFactory ) { return new SslContextBuilder ( true ) . keyManager ( keyManagerFactory ) ; } private final boolean forServer ; private SslProvider provider ; private X509Certificate [ ] trustCertChain ; private TrustManagerFactory trustManagerFactory ; private X509Certificate [ ] keyCertChain ; private PrivateKey key ; private String keyPassword ; private KeyManagerFactory keyManagerFactory ; private Iterable < String > ciphers ; private CipherSuiteFilter cipherFilter = IdentityCipherSuiteFilter . INSTANCE ; private ApplicationProtocolConfig apn ; private long sessionCacheSize ; private long sessionTimeout ; private ClientAuth clientAuth = ClientAuth . NONE ; private SslContextBuilder ( boolean forServer ) { this . forServer = forServer ; } public SslContextBuilder sslProvider ( SslProvider provider ) { this . provider = provider ; return this ; } public SslContextBuilder trustManager ( File trustCertChainFile ) { try { return trustManager ( SslContext . toX509Certificates ( trustCertChainFile ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + trustCertChainFile , e ) ; } } public SslContextBuilder trustManager ( X509Certificate . . . trustCertChain ) { this . trustCertChain = trustCertChain ! = null ? trustCertChain . clone ( ) : null ; trustManagerFactory = null ; return this ; } public SslContextBuilder trustManager ( TrustManagerFactory trustManagerFactory ) { trustCertChain = null ; this . trustManagerFactory = trustManagerFactory ; return this ; } public SslContextBuilder keyManager ( File keyCertChainFile , File keyFile ) { return keyManager ( keyCertChainFile , keyFile , null ) ; } public SslContextBuilder keyManager ( PrivateKey key , X509Certificate . . . keyCertChain ) { return keyManager ( key , null , keyCertChain ) ; } public SslContextBuilder keyManager ( File keyCertChainFile , File keyFile , String keyPassword ) { X509Certificate [ ] keyCertChain ; PrivateKey key ; try { keyCertChain = SslContext . toX509Certificates ( keyCertChainFile ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + keyCertChainFile , e ) ; } try { key = SslContext . toPrivateKey ( keyFile , keyPassword ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + keyFile , e ) ; } return keyManager ( key , keyPassword , keyCertChain ) ; } public SslContextBuilder keyManager ( PrivateKey key , String keyPassword , X509Certificate . . . keyCertChain ) { if ( forServer ) { checkNotNull ( keyCertChain , <str> ) ; if ( keyCertChain . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } checkNotNull ( key , <str> ) ; } if ( keyCertChain = = null | | keyCertChain . length = = <int> ) { this . keyCertChain = null ; } else { for ( X509Certificate cert : keyCertChain ) { if ( cert = = null ) { throw new IllegalArgumentException ( <str> ) ; } } this . keyCertChain = keyCertChain . clone ( ) ; } this . key = key ; this . keyPassword = keyPassword ; keyManagerFactory = null ; return this ; } public SslContextBuilder keyManager ( KeyManagerFactory keyManagerFactory ) { if ( forServer ) { checkNotNull ( keyManagerFactory , <str> ) ; } keyCertChain = null ; key = null ; keyPassword = null ; this . keyManagerFactory = keyManagerFactory ; return this ; } public SslContextBuilder ciphers ( Iterable < String > ciphers ) { return ciphers ( ciphers , IdentityCipherSuiteFilter . INSTANCE ) ; } public SslContextBuilder ciphers ( Iterable < String > ciphers , CipherSuiteFilter cipherFilter ) { checkNotNull ( cipherFilter , <str> ) ; this . ciphers = ciphers ; this . cipherFilter = cipherFilter ; return this ; } public SslContextBuilder applicationProtocolConfig ( ApplicationProtocolConfig apn ) { this . apn = apn ; return this ; } public SslContextBuilder sessionCacheSize ( long sessionCacheSize ) { this . sessionCacheSize = sessionCacheSize ; return this ; } public SslContextBuilder sessionTimeout ( long sessionTimeout ) { this . sessionTimeout = sessionTimeout ; return this ; } public SslContextBuilder clientAuth ( ClientAuth clientAuth ) { this . clientAuth = checkNotNull ( clientAuth , <str> ) ; return this ; } public SslContext build ( ) throws SSLException { if ( forServer ) { return SslContext . newServerContextInternal ( provider , trustCertChain , trustManagerFactory , keyCertChain , key , keyPassword , keyManagerFactory , ciphers , cipherFilter , apn , sessionCacheSize , sessionTimeout , clientAuth ) ; } else { return SslContext . newClientContextInternal ( provider , trustCertChain , trustManagerFactory , keyCertChain , key , keyPassword , keyManagerFactory , ciphers , cipherFilter , apn , sessionCacheSize , sessionTimeout ) ; } } } 
