package org . eclipse . debug . internal . ui . views . memory ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . NullProgressMonitor ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IMemoryBlockListener ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . IMemoryBlockRetrieval ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . DebugUIMessages ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . debug . ui . memory . IMemoryRendering ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ActionContributionItem ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . action . IMenuCreator ; import org . eclipse . jface . viewers . ILabelDecorator ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Menu ; import org . eclipse . ui . IActionDelegate2 ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; import org . eclipse . ui . progress . UIJob ; import org . eclipse . ui . progress . WorkbenchJob ; public class SwitchMemoryBlockAction extends Action implements IViewActionDelegate , IActionDelegate2 { class UpdateActionEnablementJob extends UIJob { public UpdateActionEnablementJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( fAction ! = null ) { IAdaptable context = getDebugContext ( ) ; if ( context ! = null ) { IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( context ) ; if ( retrieval ! = null ) { IMemoryBlock [ ] memoryBlocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieval ) ; fAction . setEnabled ( memoryBlocks . length > <int> ) ; return Status . OK_STATUS ; } else if ( getViewer ( ) ! = null ) { Object input = getViewer ( ) . getInput ( ) ; if ( input instanceof IMemoryBlockRetrieval ) { retrieval = ( IMemoryBlockRetrieval ) input ; IMemoryBlock [ ] memoryBlocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieval ) ; fAction . setEnabled ( memoryBlocks . length > <int> ) ; return Status . OK_STATUS ; } } } fAction . setEnabled ( false ) ; } return Status . CANCEL_STATUS ; } } private IViewPart fView ; private MenuCreator fMenuCreator ; private IAction fAction ; private UpdateActionEnablementJob fUpdateJob = new UpdateActionEnablementJob ( ) ; private IMemoryBlockListener fListener = new IMemoryBlockListener ( ) { @Override public void memoryBlocksAdded ( IMemoryBlock [ ] memory ) { if ( fAction ! = null ) { fUpdateJob . schedule ( ) ; } } @Override public void memoryBlocksRemoved ( IMemoryBlock [ ] memory ) { if ( fAction ! = null ) { fUpdateJob . schedule ( ) ; } } } ; private IDebugContextListener fDebugContextListener = new IDebugContextListener ( ) { @Override public void debugContextChanged ( DebugContextEvent event ) { if ( fAction ! = null ) { fUpdateJob . schedule ( ) ; } } } ; class SwitchToAction extends Action { private IMemoryBlock fMemoryblock ; @Override public void run ( ) { if ( fView = = null ) { return ; } fView . getSite ( ) . getSelectionProvider ( ) . setSelection ( new StructuredSelection ( fMemoryblock ) ) ; } public SwitchToAction ( final IMemoryBlock memBlk , boolean buildLabel ) { super ( ) ; if ( buildLabel ) { setText ( DebugUIMessages . SwitchMemoryBlockAction_4 ) ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { getLabels ( memBlk ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } fMemoryblock = memBlk ; } public SwitchToAction ( final IMemoryBlock memBlk , String label ) { super ( label ) ; fMemoryblock = memBlk ; } private void getLabels ( final IMemoryBlock memBlk ) { StringBuffer text = new StringBuffer ( IInternalDebugCoreConstants . EMPTY_STRING ) ; String label = new String ( IInternalDebugCoreConstants . EMPTY_STRING ) ; if ( memBlk instanceof IMemoryBlockExtension ) { String expression = ( ( IMemoryBlockExtension ) memBlk ) . getExpression ( ) ; if ( expression = = null ) { expression = DebugUIMessages . SwitchMemoryBlockAction_0 ; } text . append ( expression ) ; } else { long address = memBlk . getStartAddress ( ) ; text . append ( Long . toHexString ( address ) ) ; } label = text . toString ( ) ; label = decorateLabel ( memBlk , label ) ; final String finalLabel = label ; WorkbenchJob job = new WorkbenchJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { SwitchToAction . super . setText ( finalLabel ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } class MenuCreator implements IMenuCreator { Menu dropdown ; @Override public void dispose ( ) { if ( dropdown ! = null ) dropdown . dispose ( ) ; } @Override public Menu getMenu ( Control parent ) { if ( dropdown ! = null ) { dropdown . dispose ( ) ; dropdown = null ; } if ( dropdown = = null ) { dropdown = new Menu ( parent ) ; IMemoryBlock [ ] allMemoryBlocks = null ; IMemoryBlock memoryBlock = getCurrentMemoryBlock ( ) ; Object context = getDebugContext ( ) ; IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( context ) ; if ( retrieval ! = null ) { allMemoryBlocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieval ) ; } if ( allMemoryBlocks ! = null ) { for ( int i = <int> ; i < allMemoryBlocks . length ; i + + ) { SwitchToAction action = new SwitchToAction ( allMemoryBlocks [ i ] , true ) ; if ( allMemoryBlocks [ i ] = = memoryBlock ) { action . setChecked ( true ) ; } ActionContributionItem item = new ActionContributionItem ( action ) ; item . fill ( dropdown , - <int> ) ; item . getAction ( ) . setChecked ( true ) ; } } } return dropdown ; } @Override public Menu getMenu ( Menu parent ) { return null ; } } @Override public void init ( IViewPart view ) { fView = view ; DebugUITools . getDebugContextManager ( ) . getContextService ( fView . getViewSite ( ) . getWorkbenchWindow ( ) ) . addDebugContextListener ( fDebugContextListener ) ; DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . addListener ( fListener ) ; fUpdateJob . runInUIThread ( new NullProgressMonitor ( ) ) ; } private StructuredViewer getViewer ( ) { if ( fView instanceof MemoryView ) { MemoryView memView = ( MemoryView ) fView ; IMemoryViewPane pane = memView . getViewPane ( MemoryBlocksTreeViewPane . PANE_ID ) ; if ( pane instanceof MemoryBlocksTreeViewPane ) { StructuredViewer viewer = ( ( MemoryBlocksTreeViewPane ) pane ) . getViewer ( ) ; return viewer ; } } return null ; } @Override public void run ( IAction action ) { switchToNext ( ) ; } @Override public void run ( ) { switchToNext ( ) ; } private void switchToNext ( ) { IAdaptable context = getDebugContext ( ) ; if ( context instanceof IDebugElement ) { IDebugElement debugContext = ( IDebugElement ) context ; IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( debugContext ) ; if ( retrieval ! = null ) { IMemoryBlock [ ] memoryBlocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( retrieval ) ; doSwitchToNext ( memoryBlocks ) ; } } } private void doSwitchToNext ( IMemoryBlock [ ] memoryBlocks ) { if ( memoryBlocks . length > <int> ) { IMemoryBlock current = getCurrentMemoryBlock ( ) ; int next = <int> ; if ( current ! = null ) { for ( int i = <int> ; i < memoryBlocks . length ; i + + ) { if ( memoryBlocks [ i ] = = current ) { next = i + <int> ; } } } if ( next > memoryBlocks . length - <int> ) { next = <int> ; } SwitchToAction switchAction = new SwitchToAction ( memoryBlocks [ next ] , false ) ; switchAction . run ( ) ; } } @Override public void selectionChanged ( IAction action , ISelection selection ) { } @Override public void init ( IAction action ) { fAction = action ; fUpdateJob . runInUIThread ( new NullProgressMonitor ( ) ) ; fMenuCreator = new MenuCreator ( ) ; action . setMenuCreator ( fMenuCreator ) ; } @Override public void dispose ( ) { fAction = null ; DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . removeListener ( fListener ) ; DebugUITools . getDebugContextManager ( ) . getContextService ( fView . getViewSite ( ) . getWorkbenchWindow ( ) ) . removeDebugContextListener ( fDebugContextListener ) ; if ( fMenuCreator ! = null ) { fMenuCreator . dispose ( ) ; } } @Override public void runWithEvent ( IAction action , Event event ) { switchToNext ( ) ; } private IMemoryBlock getCurrentMemoryBlock ( ) { if ( fView = = null ) { return null ; } ISelection memBlkSelection = fView . getSite ( ) . getSelectionProvider ( ) . getSelection ( ) ; IMemoryBlock memoryBlock = null ; if ( memBlkSelection ! = null ) { if ( ! memBlkSelection . isEmpty ( ) & & memBlkSelection instanceof IStructuredSelection ) { Object obj = ( ( IStructuredSelection ) memBlkSelection ) . getFirstElement ( ) ; if ( obj instanceof IMemoryBlock ) { memoryBlock = ( IMemoryBlock ) obj ; } else if ( obj instanceof IMemoryRendering ) { memoryBlock = ( ( IMemoryRendering ) obj ) . getMemoryBlock ( ) ; } } } return memoryBlock ; } private String decorateLabel ( final IMemoryBlock memBlk , String label ) { ILabelDecorator decorator = memBlk . getAdapter ( ILabelDecorator . class ) ; if ( decorator ! = null ) { label = decorator . decorateText ( label , memBlk ) ; } return label ; } private IAdaptable getDebugContext ( ) { if ( fView ! = null ) { return DebugUITools . getPartDebugContext ( fView . getSite ( ) ) ; } else { return DebugUITools . getDebugContext ( ) ; } } } 
