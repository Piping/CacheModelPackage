package org . elasticsearch . search . aggregations . pipeline . movavg . models ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . pipeline . movavg . MovAvgParser ; import java . io . IOException ; import java . text . ParseException ; import java . util . * ; public class HoltLinearModel extends MovAvgModel { protected static final ParseField NAME_FIELD = new ParseField ( <str> ) ; private final double alpha ; private final double beta ; public HoltLinearModel ( double alpha , double beta ) { this . alpha = alpha ; this . beta = beta ; } @Override public boolean canBeMinimized ( ) { return true ; } @Override public MovAvgModel neighboringModel ( ) { double newValue = Math . random ( ) ; switch ( ( int ) ( Math . random ( ) * <int> ) ) { case <int> : return new HoltLinearModel ( newValue , this . beta ) ; case <int> : return new HoltLinearModel ( this . alpha , newValue ) ; default : assert ( false ) : <str> ; return new HoltLinearModel ( newValue , this . beta ) ; } } @Override public MovAvgModel clone ( ) { return new HoltLinearModel ( this . alpha , this . beta ) ; } @Override protected < T extends Number > double [ ] doPredict ( Collection < T > values , int numPredictions ) { return next ( values , numPredictions ) ; } @Override public < T extends Number > double next ( Collection < T > values ) { return next ( values , <int> ) [ <int> ] ; } public < T extends Number > double [ ] next ( Collection < T > values , int numForecasts ) { if ( values . size ( ) = = <int> ) { return emptyPredictions ( numForecasts ) ; } double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; int counter = <int> ; T last ; for ( T v : values ) { last = v ; if ( counter = = <int> ) { s = v . doubleValue ( ) ; b = v . doubleValue ( ) - last . doubleValue ( ) ; } else { s = alpha * v . doubleValue ( ) + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; } counter + = <int> ; last_s = s ; last_b = b ; } double [ ] forecastValues = new double [ numForecasts ] ; for ( int i = <int> ; i < numForecasts ; i + + ) { forecastValues [ i ] = s + ( i * b ) ; } return forecastValues ; } public static final MovAvgModelStreams . Stream STREAM = new MovAvgModelStreams . Stream ( ) { @Override public MovAvgModel readResult ( StreamInput in ) throws IOException { return new HoltLinearModel ( in . readDouble ( ) , in . readDouble ( ) ) ; } @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } } ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; out . writeDouble ( alpha ) ; out . writeDouble ( beta ) ; } public static class DoubleExpModelParser extends AbstractModelParser { @Override public String getName ( ) { return NAME_FIELD . getPreferredName ( ) ; } @Override public MovAvgModel parse ( @Nullable Map < String , Object > settings , String pipelineName , int windowSize , ParseFieldMatcher parseFieldMatcher ) throws ParseException { double alpha = parseDoubleParam ( settings , <str> , <float> ) ; double beta = parseDoubleParam ( settings , <str> , <float> ) ; checkUnrecognizedParams ( settings ) ; return new HoltLinearModel ( alpha , beta ) ; } } public static class HoltLinearModelBuilder implements MovAvgModelBuilder { private Double alpha ; private Double beta ; public HoltLinearModelBuilder alpha ( double alpha ) { this . alpha = alpha ; return this ; } public HoltLinearModelBuilder beta ( double beta ) { this . beta = beta ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( MovAvgParser . MODEL . getPreferredName ( ) , NAME_FIELD . getPreferredName ( ) ) ; builder . startObject ( MovAvgParser . SETTINGS . getPreferredName ( ) ) ; if ( alpha ! = null ) { builder . field ( <str> , alpha ) ; } if ( beta ! = null ) { builder . field ( <str> , beta ) ; } builder . endObject ( ) ; return builder ; } } } 
