package jcuda . jcublas ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . assertArrayEquals ; import jcuda . Pointer ; import jcuda . Sizeof ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . jcublas . CublasPointer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . util . ComplexUtil ; import org . nd4j . linalg . api . shape . Shape ; public class CublasPointerTests { @Test public void testAllocateArrays ( ) { INDArray arr1OffsetFor = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray arr1Offset = arr1OffsetFor . get ( NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . all ( ) ) ; arr1Offset = Shape . toOffsetZero ( arr1Offset ) ; CublasPointer p = new CublasPointer ( arr1Offset ) ; String s = p . toString ( ) ; float [ ] data = new float [ <int> ] ; float [ ] assertion = { <int> , <int> , <int> , <int> , <int> , <int> } ; JCublas2 . cublasGetVector ( <int> , Sizeof . FLOAT , p . getDevicePointer ( ) . withByteOffset ( arr1Offset . offset ( ) * arr1Offset . data ( ) . getElementSize ( ) ) , arr1Offset . majorStride ( ) , Pointer . to ( data ) , <int> ) ; for ( int i = <int> ; i < assertion . length ; i + + ) assertEquals ( data [ i ] , assertion [ i ] , <float> ) ; } @Test public void testVectorAlongDimension ( ) throws Exception { INDArray arr = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } , <str> ) ; INDArray column = arr . getColumn ( <int> ) ; INDArray otherColumnAssertion = column . dup ( ) ; CublasPointer p = new CublasPointer ( column ) ; p . copyToHost ( ) ; assertEquals ( otherColumnAssertion , column ) ; p . close ( ) ; } @Test public void testTwoByTwoBuffer ( ) throws Exception { IComplexNDArray arr = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> } ) , new int [ ] { <int> , <int> } ) ; IComplexNDArray dup = arr . dup ( ) ; CublasPointer pointer = new CublasPointer ( arr ) ; pointer . copyToHost ( ) ; assertEquals ( dup , arr ) ; pointer . close ( ) ; } @Test public void testBufferPointer ( ) throws Exception { DataBuffer buff = Nd4j . createBuffer ( new double [ ] { <int> } ) ; DataBuffer clone = buff . dup ( ) ; CublasPointer pointer = new CublasPointer ( ( JCudaBuffer ) buff ) ; pointer . copyToHost ( ) ; pointer . close ( ) ; assertEquals ( clone , buff ) ; INDArray arr = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; System . err . println ( <str> + arr ) ; INDArray brr = Nd4j . create ( new float [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; System . err . println ( <str> + brr ) ; INDArray row = arr . getRow ( <int> ) ; CublasPointer pointer2 = new CublasPointer ( row ) ; pointer2 . copyToHost ( ) ; } @Test public void testAllocateAndCopyBackToHostC ( ) throws Exception { Nd4j . factory ( ) . setOrder ( <str> ) ; INDArray test = Nd4j . rand ( <int> , <int> ) ; CublasPointer p = new CublasPointer ( test ) ; CublasPointer p1 = new CublasPointer ( ( JCudaBuffer ) test . data ( ) ) ; p . copyToHost ( ) ; p1 . copyToHost ( ) ; assertEquals ( p . getBuffer ( ) , p1 . getBuffer ( ) ) ; assertArrayEquals ( p . getBuffer ( ) . asBytes ( ) , p1 . getBuffer ( ) . asBytes ( ) ) ; p . close ( ) ; p1 . close ( ) ; } @Test public void testAllocateAndCopyBackToHost ( ) throws Exception { INDArray test = Nd4j . rand ( <int> , <int> ) ; CublasPointer p = new CublasPointer ( test ) ; CublasPointer p1 = new CublasPointer ( ( JCudaBuffer ) test . data ( ) ) ; p . copyToHost ( ) ; p1 . copyToHost ( ) ; assertEquals ( p . getBuffer ( ) , p1 . getBuffer ( ) ) ; assertArrayEquals ( p . getBuffer ( ) . asBytes ( ) , p1 . getBuffer ( ) . asBytes ( ) ) ; p . close ( ) ; p1 . close ( ) ; } @Test public void testColumnCopy ( ) throws Exception { INDArray mat = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray column = mat . getColumn ( <int> ) ; INDArray columnDup = column . dup ( ) ; CublasPointer copy = new CublasPointer ( column ) ; copy . getDevicePointer ( ) ; copy . copyToHost ( ) ; copy . close ( ) ; assertEquals ( columnDup , column ) ; } @Test public void testColumnCopyCOrdering ( ) throws Exception { Nd4j . factory ( ) . setOrder ( <str> ) ; INDArray mat = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray column = mat . getColumn ( <int> ) ; INDArray columnDup = column . dup ( ) ; CublasPointer copy = new CublasPointer ( column ) ; copy . getDevicePointer ( ) ; copy . copyToHost ( ) ; copy . close ( ) ; assertEquals ( columnDup , column ) ; Nd4j . factory ( ) . setOrder ( <str> ) ; } @Test public void testSlicePointers ( ) throws Exception { INDArray arr = Nd4j . create ( <int> , <int> ) ; JCudaBuffer buffer = ( JCudaBuffer ) arr . data ( ) ; for ( int i = <int> ; i < arr . slices ( ) ; i + + ) { CublasPointer pointer = new CublasPointer ( arr . slice ( i ) ) ; pointer . copyToHost ( ) ; pointer . close ( ) ; } } } 
