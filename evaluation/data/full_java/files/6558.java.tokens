package org . elasticsearch . index . mapper . core ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . SortedSetDocValuesField ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . support . XContentMapValues ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import java . io . IOException ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . apache . lucene . index . IndexOptions . NONE ; import static org . elasticsearch . index . mapper . MapperBuilders . stringField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseTextField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseMultiField ; public class StringFieldMapper extends FieldMapper implements AllFieldMapper . IncludeInAll { public static final String CONTENT_TYPE = <str> ; private static final int POSITION_INCREMENT_GAP_USE_ANALYZER = - <int> ; public static class Defaults { public static final MappedFieldType FIELD_TYPE = new StringFieldType ( ) ; static { FIELD_TYPE . freeze ( ) ; } public static final String NULL_VALUE = null ; public static final int POSITION_INCREMENT_GAP = <int> ; public static final int POSITION_INCREMENT_GAP_PRE_2_0 = <int> ; public static final int IGNORE_ABOVE = - <int> ; public static int positionIncrementGap ( Version version ) { if ( version . before ( Version . V_2_0_0_beta1 ) ) { return POSITION_INCREMENT_GAP_PRE_2_0 ; } return POSITION_INCREMENT_GAP ; } } public static class Builder extends FieldMapper . Builder < Builder , StringFieldMapper > { protected String nullValue = Defaults . NULL_VALUE ; protected int positionIncrementGap = POSITION_INCREMENT_GAP_USE_ANALYZER ; protected int ignoreAbove = Defaults . IGNORE_ABOVE ; public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE ) ; builder = this ; } @Override public Builder searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { super . searchAnalyzer ( searchAnalyzer ) ; return this ; } public Builder positionIncrementGap ( int positionIncrementGap ) { this . positionIncrementGap = positionIncrementGap ; return this ; } public Builder searchQuotedAnalyzer ( NamedAnalyzer analyzer ) { this . fieldType . setSearchQuoteAnalyzer ( analyzer ) ; return builder ; } public Builder ignoreAbove ( int ignoreAbove ) { this . ignoreAbove = ignoreAbove ; return this ; } @Override public StringFieldMapper build ( BuilderContext context ) { if ( positionIncrementGap ! = POSITION_INCREMENT_GAP_USE_ANALYZER ) { fieldType . setIndexAnalyzer ( new NamedAnalyzer ( fieldType . indexAnalyzer ( ) , positionIncrementGap ) ) ; fieldType . setSearchAnalyzer ( new NamedAnalyzer ( fieldType . searchAnalyzer ( ) , positionIncrementGap ) ) ; fieldType . setSearchQuoteAnalyzer ( new NamedAnalyzer ( fieldType . searchQuoteAnalyzer ( ) , positionIncrementGap ) ) ; } if ( fieldType . indexOptions ( ) ! = IndexOptions . NONE & & ! fieldType . tokenized ( ) ) { defaultFieldType . setOmitNorms ( true ) ; defaultFieldType . setIndexOptions ( IndexOptions . DOCS ) ; if ( ! omitNormsSet & & fieldType . boost ( ) = = <float> ) { fieldType . setOmitNorms ( true ) ; } if ( ! indexOptionsSet ) { fieldType . setIndexOptions ( IndexOptions . DOCS ) ; } } setupFieldType ( context ) ; StringFieldMapper fieldMapper = new StringFieldMapper ( name , fieldType , defaultFieldType , positionIncrementGap , ignoreAbove , context . indexSettings ( ) , multiFieldsBuilder . build ( this , context ) , copyTo ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } } public static class TypeParser implements Mapper . TypeParser { @Override public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { StringFieldMapper . Builder builder = stringField ( name ) ; parseTextField ( builder , name , node , parserContext ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { if ( propNode = = null ) { throw new MapperParsingException ( <str> ) ; } builder . nullValue ( propNode . toString ( ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { NamedAnalyzer analyzer = parserContext . analysisService ( ) . analyzer ( propNode . toString ( ) ) ; if ( analyzer = = null ) { throw new MapperParsingException ( <str> + propNode . toString ( ) + <str> + name + <str> ) ; } builder . searchQuotedAnalyzer ( analyzer ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) | | parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0 ) & & propName . equals ( <str> ) ) { int newPositionIncrementGap = XContentMapValues . nodeIntegerValue ( propNode , - <int> ) ; if ( newPositionIncrementGap < <int> ) { throw new MapperParsingException ( <str> ) ; } builder . positionIncrementGap ( newPositionIncrementGap ) ; if ( builder . fieldType ( ) . indexAnalyzer ( ) = = null ) { builder . fieldType ( ) . setIndexAnalyzer ( parserContext . analysisService ( ) . defaultIndexAnalyzer ( ) ) ; } if ( builder . fieldType ( ) . searchAnalyzer ( ) = = null ) { builder . fieldType ( ) . setSearchAnalyzer ( parserContext . analysisService ( ) . defaultSearchAnalyzer ( ) ) ; } if ( builder . fieldType ( ) . searchQuoteAnalyzer ( ) = = null ) { builder . fieldType ( ) . setSearchQuoteAnalyzer ( parserContext . analysisService ( ) . defaultSearchQuoteAnalyzer ( ) ) ; } iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . ignoreAbove ( XContentMapValues . nodeIntegerValue ( propNode , - <int> ) ) ; iterator . remove ( ) ; } else if ( parseMultiField ( builder , name , parserContext , propName , propNode ) ) { iterator . remove ( ) ; } } return builder ; } } public static final class StringFieldType extends MappedFieldType { public StringFieldType ( ) { } protected StringFieldType ( StringFieldType ref ) { super ( ref ) ; } public StringFieldType clone ( ) { return new StringFieldType ( this ) ; } @Override public String typeName ( ) { return CONTENT_TYPE ; } @Override public String value ( Object value ) { if ( value = = null ) { return null ; } return value . toString ( ) ; } @Override public Query nullValueQuery ( ) { if ( nullValue ( ) = = null ) { return null ; } return termQuery ( nullValue ( ) , null ) ; } } private Boolean includeInAll ; private int positionIncrementGap ; private int ignoreAbove ; protected StringFieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , int positionIncrementGap , int ignoreAbove , Settings indexSettings , MultiFields multiFields , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , indexSettings , multiFields , copyTo ) ; if ( fieldType . tokenized ( ) & & fieldType . indexOptions ( ) ! = NONE & & fieldType ( ) . hasDocValues ( ) ) { throw new MapperParsingException ( <str> + fieldType . names ( ) . fullName ( ) + <str> ) ; } this . positionIncrementGap = positionIncrementGap ; this . ignoreAbove = ignoreAbove ; } @Override public void includeInAll ( Boolean includeInAll ) { if ( includeInAll ! = null ) { this . includeInAll = includeInAll ; } } @Override public void includeInAllIfNotSet ( Boolean includeInAll ) { if ( includeInAll ! = null & & this . includeInAll = = null ) { this . includeInAll = includeInAll ; } } @Override public void unsetIncludeInAll ( ) { includeInAll = null ; } @Override protected boolean customBoost ( ) { return true ; } public int getPositionIncrementGap ( ) { return this . positionIncrementGap ; } public int getIgnoreAbove ( ) { return ignoreAbove ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { ValueAndBoost valueAndBoost = parseCreateFieldForString ( context , fieldType ( ) . nullValueAsString ( ) , fieldType ( ) . boost ( ) ) ; if ( valueAndBoost . value ( ) = = null ) { return ; } if ( ignoreAbove > <int> & & valueAndBoost . value ( ) . length ( ) > ignoreAbove ) { return ; } if ( context . includeInAll ( includeInAll , this ) ) { context . allEntries ( ) . addText ( fieldType ( ) . names ( ) . fullName ( ) , valueAndBoost . value ( ) , valueAndBoost . boost ( ) ) ; } if ( fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE | | fieldType ( ) . stored ( ) ) { Field field = new Field ( fieldType ( ) . names ( ) . indexName ( ) , valueAndBoost . value ( ) , fieldType ( ) ) ; field . setBoost ( valueAndBoost . boost ( ) ) ; fields . add ( field ) ; } if ( fieldType ( ) . hasDocValues ( ) ) { fields . add ( new SortedSetDocValuesField ( fieldType ( ) . names ( ) . indexName ( ) , new BytesRef ( valueAndBoost . value ( ) ) ) ) ; } if ( fields . isEmpty ( ) ) { context . ignoredValue ( fieldType ( ) . names ( ) . indexName ( ) , valueAndBoost . value ( ) ) ; } } public static ValueAndBoost parseCreateFieldForString ( ParseContext context , String nullValue , float defaultBoost ) throws IOException { if ( context . externalValueSet ( ) ) { return new ValueAndBoost ( ( String ) context . externalValue ( ) , defaultBoost ) ; } XContentParser parser = context . parser ( ) ; if ( parser . currentToken ( ) = = XContentParser . Token . VALUE_NULL ) { return new ValueAndBoost ( nullValue , defaultBoost ) ; } if ( parser . currentToken ( ) = = XContentParser . Token . START_OBJECT ) { XContentParser . Token token ; String currentFieldName = null ; String value = nullValue ; float boost = defaultBoost ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else { if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { value = parser . textOrNull ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { boost = parser . floatValue ( ) ; } else { throw new IllegalArgumentException ( <str> + currentFieldName + <str> ) ; } } } return new ValueAndBoost ( value , boost ) ; } return new ValueAndBoost ( parser . textOrNull ( ) , defaultBoost ) ; } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { super . merge ( mergeWith , mergeResult ) ; if ( ! this . getClass ( ) . equals ( mergeWith . getClass ( ) ) ) { return ; } if ( ! mergeResult . simulate ( ) ) { this . includeInAll = ( ( StringFieldMapper ) mergeWith ) . includeInAll ; this . ignoreAbove = ( ( StringFieldMapper ) mergeWith ) . ignoreAbove ; } } @Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { super . doXContentBody ( builder , includeDefaults , params ) ; if ( includeDefaults | | fieldType ( ) . nullValue ( ) ! = null ) { builder . field ( <str> , fieldType ( ) . nullValue ( ) ) ; } if ( includeInAll ! = null ) { builder . field ( <str> , includeInAll ) ; } else if ( includeDefaults ) { builder . field ( <str> , false ) ; } if ( includeDefaults | | positionIncrementGap ! = POSITION_INCREMENT_GAP_USE_ANALYZER ) { builder . field ( <str> , positionIncrementGap ) ; } NamedAnalyzer searchQuoteAnalyzer = fieldType ( ) . searchQuoteAnalyzer ( ) ; if ( searchQuoteAnalyzer ! = null & & ! searchQuoteAnalyzer . name ( ) . equals ( fieldType ( ) . searchAnalyzer ( ) . name ( ) ) ) { builder . field ( <str> , searchQuoteAnalyzer . name ( ) ) ; } else if ( includeDefaults ) { if ( searchQuoteAnalyzer = = null ) { builder . field ( <str> , <str> ) ; } else { builder . field ( <str> , searchQuoteAnalyzer . name ( ) ) ; } } if ( includeDefaults | | ignoreAbove ! = Defaults . IGNORE_ABOVE ) { builder . field ( <str> , ignoreAbove ) ; } } public static class ValueAndBoost { private final String value ; private final float boost ; public ValueAndBoost ( String value , float boost ) { this . value = value ; this . boost = boost ; } public String value ( ) { return value ; } public float boost ( ) { return boost ; } } } 
