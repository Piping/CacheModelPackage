package com . google . common . hash ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import com . google . common . primitives . Chars ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import com . google . common . primitives . Shorts ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; abstract class AbstractByteHasher extends AbstractHasher { private final ByteBuffer scratch = ByteBuffer . allocate ( <int> ) . order ( ByteOrder . LITTLE_ENDIAN ) ; protected abstract void update ( byte b ) ; protected void update ( byte [ ] b ) { update ( b , <int> , b . length ) ; } protected void update ( byte [ ] b , int off , int len ) { for ( int i = off ; i < off + len ; i + + ) { update ( b [ i ] ) ; } } @Override public Hasher putByte ( byte b ) { update ( b ) ; return this ; } @Override public Hasher putBytes ( byte [ ] bytes ) { checkNotNull ( bytes ) ; update ( bytes ) ; return this ; } @Override public Hasher putBytes ( byte [ ] bytes , int off , int len ) { checkPositionIndexes ( off , off + len , bytes . length ) ; update ( bytes , off , len ) ; return this ; } private Hasher update ( int bytes ) { try { update ( scratch . array ( ) , <int> , bytes ) ; } finally { scratch . clear ( ) ; } return this ; } @Override public Hasher putShort ( short s ) { scratch . putShort ( s ) ; return update ( Shorts . BYTES ) ; } @Override public Hasher putInt ( int i ) { scratch . putInt ( i ) ; return update ( Ints . BYTES ) ; } @Override public Hasher putLong ( long l ) { scratch . putLong ( l ) ; return update ( Longs . BYTES ) ; } @Override public Hasher putChar ( char c ) { scratch . putChar ( c ) ; return update ( Chars . BYTES ) ; } @Override public < T > Hasher putObject ( T instance , Funnel < ? super T > funnel ) { funnel . funnel ( instance , this ) ; return this ; } } 
