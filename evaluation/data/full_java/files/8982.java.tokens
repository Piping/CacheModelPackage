package org . elasticsearch . test . disruption ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . InternalTestCluster ; import java . util . HashSet ; import java . util . Random ; import java . util . Set ; import java . util . regex . Pattern ; public class LongGCDisruption extends SingleNodeDisruption { private final static Pattern [ ] unsafeClasses = new Pattern [ ] { Pattern . compile ( <str> ) } ; protected final String disruptedNode ; private Set < Thread > suspendedThreads ; public LongGCDisruption ( Random random , String disruptedNode ) { super ( random ) ; this . disruptedNode = disruptedNode ; } @Override public synchronized void startDisrupting ( ) { if ( suspendedThreads = = null ) { suspendedThreads = new HashSet < > ( ) ; stopNodeThreads ( disruptedNode , suspendedThreads ) ; } else { throw new IllegalStateException ( <str> ) ; } } @Override public synchronized void stopDisrupting ( ) { if ( suspendedThreads ! = null ) { resumeThreads ( suspendedThreads ) ; suspendedThreads = null ; } } @Override public void removeAndEnsureHealthy ( InternalTestCluster cluster ) { removeFromCluster ( cluster ) ; ensureNodeCount ( cluster ) ; } @Override public TimeValue expectedTimeToHeal ( ) { return TimeValue . timeValueMillis ( <int> ) ; } @SuppressForbidden ( reason = <str> ) protected boolean stopNodeThreads ( String node , Set < Thread > nodeThreads ) { Thread [ ] allThreads = null ; while ( allThreads = = null ) { allThreads = new Thread [ Thread . activeCount ( ) ] ; if ( Thread . enumerate ( allThreads ) > allThreads . length ) { allThreads = null ; } } boolean stopped = false ; final String nodeThreadNamePart = <str> + node + <str> ; for ( Thread thread : allThreads ) { if ( thread = = null ) { continue ; } String name = thread . getName ( ) ; if ( name . contains ( nodeThreadNamePart ) ) { if ( thread . isAlive ( ) & & nodeThreads . add ( thread ) ) { stopped = true ; thread . suspend ( ) ; boolean safe = true ; safe : for ( StackTraceElement stackElement : thread . getStackTrace ( ) ) { String className = stackElement . getClassName ( ) ; for ( Pattern unsafePattern : unsafeClasses ) { if ( unsafePattern . matcher ( className ) . find ( ) ) { safe = false ; break safe ; } } } if ( ! safe ) { thread . resume ( ) ; nodeThreads . remove ( thread ) ; } } } } return stopped ; } @SuppressForbidden ( reason = <str> ) protected void resumeThreads ( Set < Thread > threads ) { for ( Thread thread : threads ) { thread . resume ( ) ; } } } 
