package org . elasticsearch . snapshots ; import org . elasticsearch . ElasticsearchCorruptionException ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . blobstore . BlobContainer ; import org . elasticsearch . common . blobstore . BlobMetaData ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . BlobStore ; import org . elasticsearch . common . blobstore . fs . FsBlobStore ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . FromXContentBuilder ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . translog . BufferedChecksumStreamOutput ; import org . elasticsearch . repositories . blobstore . ChecksumBlobStoreFormat ; import org . elasticsearch . repositories . blobstore . LegacyBlobStoreFormat ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . greaterThan ; public class BlobStoreFormatIT extends AbstractSnapshotIntegTestCase { private static final ParseFieldMatcher parseFieldMatcher = new ParseFieldMatcher ( Settings . EMPTY ) ; public static final String BLOB_CODEC = <str> ; private static class BlobObj implements ToXContent , FromXContentBuilder < BlobObj > { public static final BlobObj PROTO = new BlobObj ( <str> ) ; private final String text ; public BlobObj ( String text ) { this . text = text ; } public String getText ( ) { return text ; } @Override public BlobObj fromXContent ( XContentParser parser , ParseFieldMatcher parseFieldMatcher ) throws IOException { String text = null ; XContentParser . Token token = parser . currentToken ( ) ; if ( token = = null ) { token = parser . nextToken ( ) ; } if ( token = = XContentParser . Token . START_OBJECT ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new ElasticsearchParseException ( <str> , token ) ; } String currentFieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { text = parser . text ( ) ; } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } } if ( text = = null ) { throw new ElasticsearchParseException ( <str> ) ; } return new BlobObj ( text ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . field ( <str> , getText ( ) ) ; return builder ; } } private static final class LegacyEmulationBlobStoreFormat < T extends ToXContent > extends LegacyBlobStoreFormat < T > { protected final XContentType xContentType ; protected final boolean compress ; public LegacyEmulationBlobStoreFormat ( String blobNameFormat , FromXContentBuilder < T > reader , ParseFieldMatcher parseFieldMatcher , boolean compress , XContentType xContentType ) { super ( blobNameFormat , reader , parseFieldMatcher ) ; this . xContentType = xContentType ; this . compress = compress ; } public void write ( T obj , BlobContainer blobContainer , String blobName ) throws IOException { BytesReference bytes = write ( obj ) ; blobContainer . writeBlob ( blobName , bytes ) ; } private BytesReference write ( T obj ) throws IOException { try ( BytesStreamOutput bytesStreamOutput = new BytesStreamOutput ( ) ) { if ( compress ) { try ( StreamOutput compressedStreamOutput = CompressorFactory . defaultCompressor ( ) . streamOutput ( bytesStreamOutput ) ) { write ( obj , compressedStreamOutput ) ; } } else { write ( obj , bytesStreamOutput ) ; } return bytesStreamOutput . bytes ( ) ; } } private void write ( T obj , StreamOutput streamOutput ) throws IOException { XContentBuilder builder = XContentFactory . contentBuilder ( xContentType , streamOutput ) ; builder . startObject ( ) ; obj . toXContent ( builder , SNAPSHOT_ONLY_FORMAT_PARAMS ) ; builder . endObject ( ) ; builder . close ( ) ; } } public void testBlobStoreOperations ( ) throws IOException { BlobStore blobStore = createTestBlobStore ( ) ; BlobContainer blobContainer = blobStore . blobContainer ( BlobPath . cleanPath ( ) ) ; ChecksumBlobStoreFormat < BlobObj > checksumJSON = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , false , XContentType . JSON ) ; ChecksumBlobStoreFormat < BlobObj > checksumSMILE = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , false , XContentType . SMILE ) ; ChecksumBlobStoreFormat < BlobObj > checksumSMILECompressed = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , true , XContentType . SMILE ) ; LegacyEmulationBlobStoreFormat < BlobObj > legacyJSON = new LegacyEmulationBlobStoreFormat < > ( <str> , BlobObj . PROTO , parseFieldMatcher , false , XContentType . JSON ) ; LegacyEmulationBlobStoreFormat < BlobObj > legacySMILE = new LegacyEmulationBlobStoreFormat < > ( <str> , BlobObj . PROTO , parseFieldMatcher , false , XContentType . SMILE ) ; LegacyEmulationBlobStoreFormat < BlobObj > legacySMILECompressed = new LegacyEmulationBlobStoreFormat < > ( <str> , BlobObj . PROTO , parseFieldMatcher , true , XContentType . SMILE ) ; checksumJSON . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; checksumSMILE . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; checksumSMILECompressed . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; legacyJSON . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; legacySMILE . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; legacySMILECompressed . write ( new BlobObj ( <str> ) , blobContainer , <str> ) ; assertEquals ( checksumJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( checksumSMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( checksumJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( checksumSMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( checksumJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( checksumSMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacyJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacySMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacyJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacySMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacyJSON . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; assertEquals ( legacySMILE . read ( blobContainer , <str> ) . getText ( ) , <str> ) ; } public void testCompressionIsApplied ( ) throws IOException { BlobStore blobStore = createTestBlobStore ( ) ; BlobContainer blobContainer = blobStore . blobContainer ( BlobPath . cleanPath ( ) ) ; StringBuilder veryRedundantText = new StringBuilder ( ) ; for ( int i = <int> ; i < randomIntBetween ( <int> , <int> ) ; i + + ) { veryRedundantText . append ( <str> ) ; } ChecksumBlobStoreFormat < BlobObj > checksumFormat = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , false , randomBoolean ( ) ? XContentType . SMILE : XContentType . JSON ) ; ChecksumBlobStoreFormat < BlobObj > checksumFormatComp = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , true , randomBoolean ( ) ? XContentType . SMILE : XContentType . JSON ) ; BlobObj blobObj = new BlobObj ( veryRedundantText . toString ( ) ) ; checksumFormatComp . write ( blobObj , blobContainer , <str> ) ; checksumFormat . write ( blobObj , blobContainer , <str> ) ; Map < String , BlobMetaData > blobs = blobContainer . listBlobsByPrefix ( <str> ) ; assertEquals ( blobs . size ( ) , <int> ) ; assertThat ( blobs . get ( <str> ) . length ( ) , greaterThan ( blobs . get ( <str> ) . length ( ) ) ) ; } public void testBlobCorruption ( ) throws IOException { BlobStore blobStore = createTestBlobStore ( ) ; BlobContainer blobContainer = blobStore . blobContainer ( BlobPath . cleanPath ( ) ) ; String testString = randomAsciiOfLength ( randomInt ( <int> ) ) ; BlobObj blobObj = new BlobObj ( testString ) ; ChecksumBlobStoreFormat < BlobObj > checksumFormat = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , randomBoolean ( ) , randomBoolean ( ) ? XContentType . SMILE : XContentType . JSON ) ; checksumFormat . write ( blobObj , blobContainer , <str> ) ; assertEquals ( checksumFormat . read ( blobContainer , <str> ) . getText ( ) , testString ) ; randomCorruption ( blobContainer , <str> ) ; try { checksumFormat . read ( blobContainer , <str> ) ; fail ( <str> ) ; } catch ( ElasticsearchCorruptionException ex ) { assertThat ( ex . getMessage ( ) , containsString ( <str> ) ) ; } catch ( EOFException ex ) { } } public void testAtomicWrite ( ) throws Exception { final BlobStore blobStore = createTestBlobStore ( ) ; final BlobContainer blobContainer = blobStore . blobContainer ( BlobPath . cleanPath ( ) ) ; String testString = randomAsciiOfLength ( randomInt ( <int> ) ) ; final CountDownLatch block = new CountDownLatch ( <int> ) ; final CountDownLatch unblock = new CountDownLatch ( <int> ) ; final BlobObj blobObj = new BlobObj ( testString ) { @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { super . toXContent ( builder , params ) ; try { block . countDown ( ) ; unblock . await ( <int> , TimeUnit . SECONDS ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } return builder ; } } ; final ChecksumBlobStoreFormat < BlobObj > checksumFormat = new ChecksumBlobStoreFormat < > ( BLOB_CODEC , <str> , BlobObj . PROTO , parseFieldMatcher , randomBoolean ( ) , randomBoolean ( ) ? XContentType . SMILE : XContentType . JSON ) ; ExecutorService threadPool = Executors . newFixedThreadPool ( <int> ) ; try { Future < Void > future = threadPool . submit ( new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { checksumFormat . writeAtomic ( blobObj , blobContainer , <str> ) ; return null ; } } ) ; block . await ( <int> , TimeUnit . SECONDS ) ; assertFalse ( blobContainer . blobExists ( <str> ) ) ; unblock . countDown ( ) ; future . get ( ) ; assertTrue ( blobContainer . blobExists ( <str> ) ) ; } finally { threadPool . shutdown ( ) ; } } protected BlobStore createTestBlobStore ( ) throws IOException { Settings settings = Settings . builder ( ) . build ( ) ; return new FsBlobStore ( settings , randomRepoPath ( ) ) ; } protected void randomCorruption ( BlobContainer blobContainer , String blobName ) throws IOException { byte [ ] buffer = new byte [ ( int ) blobContainer . listBlobsByPrefix ( blobName ) . get ( blobName ) . length ( ) ] ; long originalChecksum = checksum ( buffer ) ; try ( InputStream inputStream = blobContainer . readBlob ( blobName ) ) { Streams . readFully ( inputStream , buffer ) ; } do { int location = randomIntBetween ( <int> , buffer . length - <int> ) ; buffer [ location ] = ( byte ) ( buffer [ location ] ^ <int> ) ; } while ( originalChecksum = = checksum ( buffer ) ) ; blobContainer . writeBlob ( blobName , new BytesArray ( buffer ) ) ; } private long checksum ( byte [ ] buffer ) throws IOException { try ( BytesStreamOutput streamOutput = new BytesStreamOutput ( ) ) { try ( BufferedChecksumStreamOutput checksumOutput = new BufferedChecksumStreamOutput ( streamOutput ) ) { checksumOutput . write ( buffer ) ; return checksumOutput . getChecksum ( ) ; } } } } 
