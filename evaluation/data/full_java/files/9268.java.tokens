package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . collect . ObjectArrays . checkElementNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . primitives . Ints ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . EnumSet ; import java . util . Iterator ; import java . util . Set ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) @SuppressWarnings ( <str> ) public abstract class ImmutableSet < E > extends ImmutableCollection < E > implements Set < E > { @SuppressWarnings ( { <str> } ) public static < E > ImmutableSet < E > of ( ) { return ( ImmutableSet < E > ) RegularImmutableSet . EMPTY ; } public static < E > ImmutableSet < E > of ( E element ) { return new SingletonImmutableSet < E > ( element ) ; } public static < E > ImmutableSet < E > of ( E e1 , E e2 ) { return construct ( <int> , e1 , e2 ) ; } public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 ) { return construct ( <int> , e1 , e2 , e3 ) ; } public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { return construct ( <int> , e1 , e2 , e3 , e4 ) ; } public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( <int> , e1 , e2 , e3 , e4 , e5 ) ; } public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E . . . others ) { final int paramCount = <int> ; Object [ ] elements = new Object [ paramCount + others . length ] ; elements [ <int> ] = e1 ; elements [ <int> ] = e2 ; elements [ <int> ] = e3 ; elements [ <int> ] = e4 ; elements [ <int> ] = e5 ; elements [ <int> ] = e6 ; System . arraycopy ( others , <int> , elements , paramCount , others . length ) ; return construct ( elements . length , elements ) ; } private static < E > ImmutableSet < E > construct ( int n , Object . . . elements ) { switch ( n ) { case <int> : return of ( ) ; case <int> : @SuppressWarnings ( <str> ) E elem = ( E ) elements [ <int> ] ; return of ( elem ) ; default : } int tableSize = chooseTableSize ( n ) ; Object [ ] table = new Object [ tableSize ] ; int mask = tableSize - <int> ; int hashCode = <int> ; int uniques = <int> ; for ( int i = <int> ; i < n ; i + + ) { Object element = checkElementNotNull ( elements [ i ] , i ) ; int hash = element . hashCode ( ) ; for ( int j = Hashing . smear ( hash ) ; ; j + + ) { int index = j & mask ; Object value = table [ index ] ; if ( value = = null ) { elements [ uniques + + ] = element ; table [ index ] = element ; hashCode + = hash ; break ; } else if ( value . equals ( element ) ) { break ; } } } Arrays . fill ( elements , uniques , n , null ) ; if ( uniques = = <int> ) { @SuppressWarnings ( <str> ) E element = ( E ) elements [ <int> ] ; return new SingletonImmutableSet < E > ( element , hashCode ) ; } else if ( tableSize ! = chooseTableSize ( uniques ) ) { return construct ( uniques , elements ) ; } else { Object [ ] uniqueElements = ( uniques < elements . length ) ? ObjectArrays . arraysCopyOf ( elements , uniques ) : elements ; return new RegularImmutableSet < E > ( uniqueElements , hashCode , table , mask ) ; } } static final int MAX_TABLE_SIZE = Ints . MAX_POWER_OF_TWO ; private static final double DESIRED_LOAD_FACTOR = <float> ; private static final int CUTOFF = ( int ) ( MAX_TABLE_SIZE * DESIRED_LOAD_FACTOR ) ; @VisibleForTesting static int chooseTableSize ( int setSize ) { if ( setSize < CUTOFF ) { int tableSize = Integer . highestOneBit ( setSize - <int> ) < < <int> ; while ( tableSize * DESIRED_LOAD_FACTOR < setSize ) { tableSize < < = <int> ; } return tableSize ; } checkArgument ( setSize < MAX_TABLE_SIZE , <str> ) ; return MAX_TABLE_SIZE ; } public static < E > ImmutableSet < E > copyOf ( Collection < ? extends E > elements ) { if ( elements instanceof ImmutableSet & & ! ( elements instanceof ImmutableSortedSet ) ) { @SuppressWarnings ( <str> ) ImmutableSet < E > set = ( ImmutableSet < E > ) elements ; if ( ! set . isPartialView ( ) ) { return set ; } } else if ( elements instanceof EnumSet ) { return copyOfEnumSet ( ( EnumSet ) elements ) ; } Object [ ] array = elements . toArray ( ) ; return construct ( array . length , array ) ; } public static < E > ImmutableSet < E > copyOf ( Iterable < ? extends E > elements ) { return ( elements instanceof Collection ) ? copyOf ( ( Collection < ? extends E > ) elements ) : copyOf ( elements . iterator ( ) ) ; } public static < E > ImmutableSet < E > copyOf ( Iterator < ? extends E > elements ) { if ( ! elements . hasNext ( ) ) { return of ( ) ; } E first = elements . next ( ) ; if ( ! elements . hasNext ( ) ) { return of ( first ) ; } else { return new ImmutableSet . Builder < E > ( ) . add ( first ) . addAll ( elements ) . build ( ) ; } } public static < E > ImmutableSet < E > copyOf ( E [ ] elements ) { switch ( elements . length ) { case <int> : return of ( ) ; case <int> : return of ( elements [ <int> ] ) ; default : return construct ( elements . length , elements . clone ( ) ) ; } } @SuppressWarnings ( <str> ) private static ImmutableSet copyOfEnumSet ( EnumSet enumSet ) { return ImmutableEnumSet . asImmutable ( EnumSet . copyOf ( enumSet ) ) ; } ImmutableSet ( ) { } boolean isHashCodeFast ( ) { return false ; } @Override public boolean equals ( @Nullable Object object ) { if ( object = = this ) { return true ; } else if ( object instanceof ImmutableSet & & isHashCodeFast ( ) & & ( ( ImmutableSet < ? > ) object ) . isHashCodeFast ( ) & & hashCode ( ) ! = object . hashCode ( ) ) { return false ; } return Sets . equalsImpl ( this , object ) ; } @Override public int hashCode ( ) { return Sets . hashCodeImpl ( this ) ; } @Override public abstract UnmodifiableIterator < E > iterator ( ) ; abstract static class Indexed < E > extends ImmutableSet < E > { abstract E get ( int index ) ; @Override public UnmodifiableIterator < E > iterator ( ) { return asList ( ) . iterator ( ) ; } @Override ImmutableList < E > createAsList ( ) { return new ImmutableAsList < E > ( ) { @Override public E get ( int index ) { return Indexed . this . get ( index ) ; } @Override Indexed < E > delegateCollection ( ) { return Indexed . this ; } } ; } } private static class SerializedForm implements Serializable { final Object [ ] elements ; SerializedForm ( Object [ ] elements ) { this . elements = elements ; } Object readResolve ( ) { return copyOf ( elements ) ; } private static final long serialVersionUID = <int> ; } @Override Object writeReplace ( ) { return new SerializedForm ( toArray ( ) ) ; } public static < E > Builder < E > builder ( ) { return new Builder < E > ( ) ; } public static class Builder < E > extends ImmutableCollection . ArrayBasedBuilder < E > { public Builder ( ) { this ( DEFAULT_INITIAL_CAPACITY ) ; } Builder ( int capacity ) { super ( capacity ) ; } @Override public Builder < E > add ( E element ) { super . add ( element ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableSet < E > build ( ) { ImmutableSet < E > result = construct ( size , contents ) ; size = result . size ( ) ; return result ; } } } 
