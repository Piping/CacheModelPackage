package org . eclipse . debug . core . model ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspace ; import org . eclipse . core . resources . IWorkspaceRunnable ; import org . eclipse . core . resources . IncrementalProjectBuilder ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . SubMonitor ; import org . eclipse . core . runtime . SubProgressMonitor ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IBreakpointManager ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . core . IStatusHandler ; import org . eclipse . debug . internal . core . DebugCoreMessages ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import com . ibm . icu . text . MessageFormat ; public abstract class LaunchConfigurationDelegate implements ILaunchConfigurationDelegate2 { private static final String DEBUG_CORE = <str> ; private static final String DEBUG_UI = <str> ; protected static final IStatus promptStatus = new Status ( IStatus . INFO , DEBUG_UI , <int> , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; protected static final IStatus switchToDebugPromptStatus = new Status ( IStatus . INFO , DEBUG_CORE , <int> , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; protected static final IStatus complileErrorPromptStatus = new Status ( IStatus . INFO , DEBUG_CORE , <int> , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; protected static final IStatus saveScopedDirtyEditors = new Status ( IStatus . INFO , DEBUG_CORE , <int> , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; protected static final IStatus complileErrorProjectPromptStatus = new Status ( IStatus . INFO , DEBUG_CORE , <int> , IInternalDebugCoreConstants . EMPTY_STRING , null ) ; @Override public ILaunch getLaunch ( ILaunchConfiguration configuration , String mode ) throws CoreException { return null ; } @Override public boolean buildForLaunch ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { if ( monitor ! = null ) { monitor . beginTask ( <str> , <int> ) ; } try { IProject [ ] projects = getBuildOrder ( configuration , mode ) ; if ( projects = = null ) { return true ; } buildProjects ( projects , new SubProgressMonitor ( monitor , <int> ) ) ; return false ; } finally { if ( monitor ! = null ) { monitor . done ( ) ; } } } protected IProject [ ] getBuildOrder ( ILaunchConfiguration configuration , String mode ) throws CoreException { return null ; } protected IProject [ ] getProjectsForProblemSearch ( ILaunchConfiguration configuration , String mode ) throws CoreException { return null ; } @Override public boolean finalLaunchCheck ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { monitor . beginTask ( <str> , <int> ) ; try { IProject [ ] projects = getProjectsForProblemSearch ( configuration , mode ) ; if ( projects = = null ) { return true ; } boolean continueLaunch = true ; monitor . subTask ( DebugCoreMessages . LaunchConfigurationDelegate_6 ) ; List < IAdaptable > errors = new ArrayList < IAdaptable > ( ) ; for ( int i = <int> ; i < projects . length ; i + + ) { monitor . subTask ( MessageFormat . format ( DebugCoreMessages . LaunchConfigurationDelegate_7 , new Object [ ] { projects [ i ] . getName ( ) } ) ) ; if ( existsProblems ( projects [ i ] ) ) { errors . add ( projects [ i ] ) ; } } if ( ! errors . isEmpty ( ) ) { errors . add ( <int> , configuration ) ; IStatusHandler prompter = DebugPlugin . getDefault ( ) . getStatusHandler ( promptStatus ) ; if ( prompter ! = null ) { continueLaunch = ( ( Boolean ) prompter . handleStatus ( complileErrorProjectPromptStatus , errors ) ) . booleanValue ( ) ; } } return continueLaunch ; } finally { monitor . done ( ) ; } } @Override public boolean preLaunchCheck ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { if ( ! saveBeforeLaunch ( configuration , mode , monitor ) ) { return false ; } if ( mode . equals ( ILaunchManager . RUN_MODE ) & & configuration . supportsMode ( ILaunchManager . DEBUG_MODE ) ) { IBreakpoint [ ] breakpoints = getBreakpoints ( configuration ) ; if ( breakpoints = = null ) { return true ; } for ( int i = <int> ; i < breakpoints . length ; i + + ) { if ( breakpoints [ i ] . isEnabled ( ) ) { IStatusHandler prompter = DebugPlugin . getDefault ( ) . getStatusHandler ( promptStatus ) ; if ( prompter ! = null ) { boolean launchInDebugModeInstead = ( ( Boolean ) prompter . handleStatus ( switchToDebugPromptStatus , configuration ) ) . booleanValue ( ) ; if ( launchInDebugModeInstead ) { return false ; } } return true ; } } } return true ; } protected boolean saveBeforeLaunch ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { monitor . beginTask ( <str> , <int> ) ; try { IStatusHandler prompter = DebugPlugin . getDefault ( ) . getStatusHandler ( promptStatus ) ; if ( prompter ! = null ) { IProject [ ] buildOrder = getBuildOrder ( configuration , mode ) ; if ( ! ( ( Boolean ) prompter . handleStatus ( saveScopedDirtyEditors , new Object [ ] { configuration , buildOrder } ) ) . booleanValue ( ) ) { return false ; } } return true ; } finally { monitor . done ( ) ; } } protected IBreakpoint [ ] getBreakpoints ( ILaunchConfiguration configuration ) { IBreakpointManager breakpointManager = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) ; if ( ! breakpointManager . isEnabled ( ) ) { return null ; } return breakpointManager . getBreakpoints ( ) ; } protected IProject [ ] computeReferencedBuildOrder ( IProject [ ] baseProjects ) throws CoreException { HashSet < IProject > unorderedProjects = new HashSet < IProject > ( ) ; for ( int i = <int> ; i < baseProjects . length ; i + + ) { unorderedProjects . add ( baseProjects [ i ] ) ; addReferencedProjects ( baseProjects [ i ] , unorderedProjects ) ; } IProject [ ] projectSet = unorderedProjects . toArray ( new IProject [ unorderedProjects . size ( ) ] ) ; return computeBuildOrder ( projectSet ) ; } protected void addReferencedProjects ( IProject project , Set < IProject > references ) throws CoreException { if ( project . isOpen ( ) ) { IProject [ ] projects = project . getReferencedProjects ( ) ; for ( int i = <int> ; i < projects . length ; i + + ) { IProject refProject = projects [ i ] ; if ( refProject . exists ( ) & & ! references . contains ( refProject ) ) { references . add ( refProject ) ; addReferencedProjects ( refProject , references ) ; } } } } protected IProject [ ] computeBuildOrder ( IProject [ ] projects ) { String [ ] orderedNames = ResourcesPlugin . getWorkspace ( ) . getDescription ( ) . getBuildOrder ( ) ; if ( orderedNames ! = null ) { List < IProject > orderedProjects = new ArrayList < IProject > ( projects . length ) ; List < IProject > unorderedProjects = new ArrayList < IProject > ( projects . length ) ; for ( int i = <int> ; i < projects . length ; + + i ) { unorderedProjects . add ( projects [ i ] ) ; } for ( int i = <int> ; i < orderedNames . length ; i + + ) { String projectName = orderedNames [ i ] ; for ( Iterator < IProject > iterator = unorderedProjects . iterator ( ) ; iterator . hasNext ( ) ; ) { IProject project = iterator . next ( ) ; if ( project . getName ( ) . equals ( projectName ) ) { orderedProjects . add ( project ) ; iterator . remove ( ) ; break ; } } } orderedProjects . addAll ( unorderedProjects ) ; return orderedProjects . toArray ( new IProject [ orderedProjects . size ( ) ] ) ; } IWorkspace . ProjectOrder po = ResourcesPlugin . getWorkspace ( ) . computeProjectOrder ( projects ) ; return po . projects ; } protected boolean existsProblems ( IProject proj ) throws CoreException { IMarker [ ] markers = proj . findMarkers ( IMarker . PROBLEM , true , IResource . DEPTH_INFINITE ) ; if ( markers . length > <int> ) { for ( int i = <int> ; i < markers . length ; i + + ) { if ( isLaunchProblem ( markers [ i ] ) ) { return true ; } } } return false ; } protected boolean isLaunchProblem ( IMarker problemMarker ) throws CoreException { Integer severity = ( Integer ) problemMarker . getAttribute ( IMarker . SEVERITY ) ; if ( severity ! = null ) { return severity . intValue ( ) > = IMarker . SEVERITY_ERROR ; } return false ; } protected void buildProjects ( final IProject [ ] projects , IProgressMonitor monitor ) throws CoreException { IWorkspaceRunnable build = new IWorkspaceRunnable ( ) { @Override public void run ( IProgressMonitor pm ) throws CoreException { SubMonitor localmonitor = SubMonitor . convert ( pm , DebugCoreMessages . LaunchConfigurationDelegate_scoped_incremental_build , projects . length ) ; try { for ( int i = <int> ; i < projects . length ; i + + ) { if ( localmonitor . isCanceled ( ) ) { throw new OperationCanceledException ( ) ; } projects [ i ] . build ( IncrementalProjectBuilder . INCREMENTAL_BUILD , localmonitor . newChild ( <int> ) ) ; } } finally { localmonitor . done ( ) ; } } } ; ResourcesPlugin . getWorkspace ( ) . run ( build , monitor ) ; } } 
