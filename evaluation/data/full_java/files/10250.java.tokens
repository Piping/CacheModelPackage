package com . google . common . base ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Maps ; import com . google . common . testing . ClassSanityTester ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . io . Serializable ; import java . util . Map ; @GwtCompatible ( emulated = true ) public class FunctionsTest extends TestCase { public void testIdentity_same ( ) { Function < String , String > identity = Functions . identity ( ) ; assertNull ( identity . apply ( null ) ) ; assertSame ( <str> , identity . apply ( <str> ) ) ; } public void testIdentity_notSame ( ) { Function < Long , Long > identity = Functions . identity ( ) ; assertNotSame ( new Long ( <int> ) , identity . apply ( new Long ( <int> ) ) ) ; } @GwtIncompatible ( <str> ) public void testIdentitySerializable ( ) { checkCanReserializeSingleton ( Functions . identity ( ) ) ; } public void testToStringFunction_apply ( ) { assertEquals ( <str> , Functions . toStringFunction ( ) . apply ( <int> ) ) ; assertEquals ( <str> , Functions . toStringFunction ( ) . apply ( <str> ) ) ; assertEquals ( <str> , Functions . toStringFunction ( ) . apply ( new Object ( ) { @Override public String toString ( ) { return <str> ; } } ) ) ; try { Functions . toStringFunction ( ) . apply ( null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } } @GwtIncompatible ( <str> ) public void testToStringFunctionSerializable ( ) { checkCanReserializeSingleton ( Functions . toStringFunction ( ) ) ; } @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( Functions . class ) ; } public void testForMapWithoutDefault ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , null ) ; Function < String , Integer > function = Functions . forMap ( map ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertNull ( function . apply ( <str> ) ) ; try { function . apply ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } new EqualsTester ( ) . addEqualityGroup ( function , Functions . forMap ( map ) ) . addEqualityGroup ( Functions . forMap ( map , <int> ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForMapWithoutDefaultSerializable ( ) { checkCanReserialize ( Functions . forMap ( ImmutableMap . of ( <int> , <int> ) ) ) ; } public void testForMapWithDefault ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; map . put ( <str> , null ) ; Function < String , Integer > function = Functions . forMap ( map , <int> ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertNull ( function . apply ( <str> ) ) ; new EqualsTester ( ) . addEqualityGroup ( function , Functions . forMap ( map , <int> ) ) . addEqualityGroup ( Functions . forMap ( map ) ) . addEqualityGroup ( Functions . forMap ( map , null ) ) . addEqualityGroup ( Functions . forMap ( map , <int> ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForMapWithDefault_includeSerializable ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Function < String , Integer > function = Functions . forMap ( map , <int> ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; new EqualsTester ( ) . addEqualityGroup ( function , Functions . forMap ( map , <int> ) , SerializableTester . reserialize ( function ) ) . addEqualityGroup ( Functions . forMap ( map ) ) . addEqualityGroup ( Functions . forMap ( map , null ) ) . addEqualityGroup ( Functions . forMap ( map , <int> ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForMapWithDefaultSerializable ( ) { checkCanReserialize ( Functions . forMap ( ImmutableMap . of ( <int> , <int> ) , <int> ) ) ; } public void testForMapWithDefault_null ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( <str> , <int> ) ; Function < String , Integer > function = Functions . forMap ( map , null ) ; assertEquals ( ( Integer ) <int> , function . apply ( <str> ) ) ; assertNull ( function . apply ( <str> ) ) ; new EqualsTester ( ) . addEqualityGroup ( function ) . addEqualityGroup ( Functions . forMap ( map , <int> ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForMapWithDefault_null_compareWithSerializable ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( <str> , <int> ) ; Function < String , Integer > function = Functions . forMap ( map , null ) ; assertEquals ( ( Integer ) <int> , function . apply ( <str> ) ) ; assertNull ( function . apply ( <str> ) ) ; new EqualsTester ( ) . addEqualityGroup ( function , SerializableTester . reserialize ( function ) ) . addEqualityGroup ( Functions . forMap ( map , <int> ) ) . testEquals ( ) ; } public void testForMapWildCardWithDefault ( ) { Map < String , Integer > map = Maps . newHashMap ( ) ; map . put ( <str> , <int> ) ; map . put ( <str> , <int> ) ; Number number = Double . valueOf ( <int> ) ; Function < String , Number > function = Functions . forMap ( map , number ) ; assertEquals ( <int> , function . apply ( <str> ) . intValue ( ) ) ; assertEquals ( number , function . apply ( <str> ) ) ; assertEquals ( <int> , function . apply ( <str> ) . longValue ( ) ) ; } public void testComposition ( ) { Map < String , Integer > mJapaneseToInteger = Maps . newHashMap ( ) ; mJapaneseToInteger . put ( <str> , <int> ) ; mJapaneseToInteger . put ( <str> , <int> ) ; mJapaneseToInteger . put ( <str> , <int> ) ; Function < String , Integer > japaneseToInteger = Functions . forMap ( mJapaneseToInteger ) ; Map < Integer , String > mIntegerToSpanish = Maps . newHashMap ( ) ; mIntegerToSpanish . put ( <int> , <str> ) ; mIntegerToSpanish . put ( <int> , <str> ) ; mIntegerToSpanish . put ( <int> , <str> ) ; Function < Integer , String > integerToSpanish = Functions . forMap ( mIntegerToSpanish ) ; Function < String , String > japaneseToSpanish = Functions . compose ( integerToSpanish , japaneseToInteger ) ; assertEquals ( <str> , japaneseToSpanish . apply ( <str> ) ) ; try { japaneseToSpanish . apply ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } assertEquals ( <str> , japaneseToSpanish . apply ( <str> ) ) ; try { japaneseToSpanish . apply ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } new EqualsTester ( ) . addEqualityGroup ( japaneseToSpanish , Functions . compose ( integerToSpanish , japaneseToInteger ) ) . addEqualityGroup ( japaneseToInteger ) . addEqualityGroup ( integerToSpanish ) . addEqualityGroup ( Functions . compose ( japaneseToInteger , integerToSpanish ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testComposition_includeReserializabled ( ) { Map < String , Integer > mJapaneseToInteger = Maps . newHashMap ( ) ; mJapaneseToInteger . put ( <str> , <int> ) ; mJapaneseToInteger . put ( <str> , <int> ) ; mJapaneseToInteger . put ( <str> , <int> ) ; Function < String , Integer > japaneseToInteger = Functions . forMap ( mJapaneseToInteger ) ; Map < Integer , String > mIntegerToSpanish = Maps . newHashMap ( ) ; mIntegerToSpanish . put ( <int> , <str> ) ; mIntegerToSpanish . put ( <int> , <str> ) ; mIntegerToSpanish . put ( <int> , <str> ) ; Function < Integer , String > integerToSpanish = Functions . forMap ( mIntegerToSpanish ) ; Function < String , String > japaneseToSpanish = Functions . compose ( integerToSpanish , japaneseToInteger ) ; new EqualsTester ( ) . addEqualityGroup ( japaneseToSpanish , Functions . compose ( integerToSpanish , japaneseToInteger ) , SerializableTester . reserialize ( japaneseToSpanish ) ) . addEqualityGroup ( japaneseToInteger ) . addEqualityGroup ( integerToSpanish ) . addEqualityGroup ( Functions . compose ( japaneseToInteger , integerToSpanish ) ) . testEquals ( ) ; } public void testCompositionWildcard ( ) { Map < String , Integer > mapJapaneseToInteger = Maps . newHashMap ( ) ; Function < String , Integer > japaneseToInteger = Functions . forMap ( mapJapaneseToInteger ) ; Function < Object , String > numberToSpanish = Functions . constant ( <str> ) ; Function < String , String > japaneseToSpanish = Functions . compose ( numberToSpanish , japaneseToInteger ) ; } private static class HashCodeFunction implements Function < Object , Integer > { @Override public Integer apply ( Object o ) { return ( o = = null ) ? <int> : o . hashCode ( ) ; } } public void testComposeOfFunctionsIsAssociative ( ) { Map < Float , String > m = ImmutableMap . of ( <float> , <str> , <float> , <str> , <float> , <str> , <float> , <str> ) ; Function < ? super Integer , Boolean > h = Functions . constant ( Boolean . TRUE ) ; Function < ? super String , Integer > g = new HashCodeFunction ( ) ; Function < Float , String > f = Functions . forMap ( m , <str> ) ; Function < Float , Boolean > c1 = Functions . compose ( Functions . compose ( h , g ) , f ) ; Function < Float , Boolean > c2 = Functions . compose ( h , Functions . compose ( g , f ) ) ; assertEquals ( c1 . hashCode ( ) , c2 . hashCode ( ) ) ; assertEquals ( c1 . apply ( <float> ) , c2 . apply ( <float> ) ) ; assertEquals ( c1 . apply ( <float> ) , c2 . apply ( <float> ) ) ; } public void testComposeOfPredicateAndFunctionIsAssociative ( ) { Map < Float , String > m = ImmutableMap . of ( <float> , <str> , <float> , <str> , <float> , <str> , <float> , <str> ) ; Predicate < ? super Integer > h = Predicates . equalTo ( <int> ) ; Function < ? super String , Integer > g = new HashCodeFunction ( ) ; Function < Float , String > f = Functions . forMap ( m , <str> ) ; Predicate < Float > p1 = Predicates . compose ( Predicates . compose ( h , g ) , f ) ; Predicate < Float > p2 = Predicates . compose ( h , Functions . compose ( g , f ) ) ; assertEquals ( p1 . hashCode ( ) , p2 . hashCode ( ) ) ; assertEquals ( p1 . apply ( <float> ) , p2 . apply ( <float> ) ) ; assertEquals ( p1 . apply ( <float> ) , p2 . apply ( <float> ) ) ; } public void testForPredicate ( ) { Function < Object , Boolean > alwaysTrue = Functions . forPredicate ( Predicates . alwaysTrue ( ) ) ; Function < Object , Boolean > alwaysFalse = Functions . forPredicate ( Predicates . alwaysFalse ( ) ) ; assertTrue ( alwaysTrue . apply ( <int> ) ) ; assertFalse ( alwaysFalse . apply ( <int> ) ) ; new EqualsTester ( ) . addEqualityGroup ( alwaysTrue , Functions . forPredicate ( Predicates . alwaysTrue ( ) ) ) . addEqualityGroup ( alwaysFalse ) . addEqualityGroup ( Functions . identity ( ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForPredicateSerializable ( ) { checkCanReserialize ( Functions . forPredicate ( Predicates . equalTo ( <int> ) ) ) ; } public void testConstant ( ) { Function < Object , Object > f = Functions . < Object > constant ( <str> ) ; assertEquals ( <str> , f . apply ( new Object ( ) ) ) ; assertEquals ( <str> , f . apply ( null ) ) ; Function < Object , String > g = Functions . constant ( null ) ; assertEquals ( null , g . apply ( <int> ) ) ; assertEquals ( null , g . apply ( null ) ) ; new EqualsTester ( ) . addEqualityGroup ( f , Functions . constant ( <str> ) ) . addEqualityGroup ( Functions . constant ( <str> ) ) . addEqualityGroup ( Functions . toStringFunction ( ) ) . addEqualityGroup ( g ) . testEquals ( ) ; new EqualsTester ( ) . addEqualityGroup ( g , Functions . constant ( null ) ) . addEqualityGroup ( Functions . constant ( <str> ) ) . addEqualityGroup ( Functions . toStringFunction ( ) ) . addEqualityGroup ( f ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testConstantSerializable ( ) { checkCanReserialize ( Functions . constant ( <int> ) ) ; } private static class CountingSupplier implements Supplier < Integer > , Serializable { private static final long serialVersionUID = <int> ; private int value ; @Override public Integer get ( ) { return + + value ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof CountingSupplier ) { return this . value = = ( ( CountingSupplier ) obj ) . value ; } return false ; } @Override public int hashCode ( ) { return value ; } } public void testForSupplier ( ) { Supplier < Integer > supplier = new CountingSupplier ( ) ; Function < Object , Integer > function = Functions . forSupplier ( supplier ) ; assertEquals ( <int> , ( int ) function . apply ( null ) ) ; assertEquals ( <int> , ( int ) function . apply ( <str> ) ) ; new EqualsTester ( ) . addEqualityGroup ( function , Functions . forSupplier ( supplier ) ) . addEqualityGroup ( Functions . forSupplier ( new CountingSupplier ( ) ) ) . addEqualityGroup ( Functions . forSupplier ( Suppliers . ofInstance ( <int> ) ) ) . addEqualityGroup ( Functions . toStringFunction ( ) ) . testEquals ( ) ; } @GwtIncompatible ( <str> ) public void testForSupplierSerializable ( ) { checkCanReserialize ( Functions . forSupplier ( new CountingSupplier ( ) ) ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) throws Exception { new ClassSanityTester ( ) . forAllPublicStaticMethods ( Functions . class ) . testNulls ( ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testEqualsAndSerializable ( ) throws Exception { new ClassSanityTester ( ) . forAllPublicStaticMethods ( Functions . class ) . testEqualsAndSerializable ( ) ; } @GwtIncompatible ( <str> ) private static < Y > void checkCanReserialize ( Function < ? super Integer , Y > f ) { Function < ? super Integer , Y > g = SerializableTester . reserializeAndAssert ( f ) ; for ( int i = <int> ; i < <int> ; i + + ) { Y expected = null ; try { expected = f . apply ( i ) ; } catch ( IllegalArgumentException e ) { try { g . apply ( i ) ; fail ( ) ; } catch ( IllegalArgumentException ok ) { continue ; } } assertEquals ( expected , g . apply ( i ) ) ; } } @GwtIncompatible ( <str> ) private static < Y > void checkCanReserializeSingleton ( Function < ? super String , Y > f ) { Function < ? super String , Y > g = SerializableTester . reserializeAndAssert ( f ) ; assertSame ( f , g ) ; for ( Integer i = <int> ; i < <int> ; i + + ) { assertEquals ( f . apply ( i . toString ( ) ) , g . apply ( i . toString ( ) ) ) ; } } } 
