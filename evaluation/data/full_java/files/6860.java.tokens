package org . elasticsearch . indices . memory ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . engine . EngineClosedException ; import org . elasticsearch . index . engine . FlushNotAllowedEngineException ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . * ; import java . util . concurrent . ScheduledFuture ; public class IndexingMemoryController extends AbstractLifecycleComponent < IndexingMemoryController > implements IndexEventListener { public static final String INDEX_BUFFER_SIZE_SETTING = <str> ; public static final String MIN_INDEX_BUFFER_SIZE_SETTING = <str> ; public static final String MAX_INDEX_BUFFER_SIZE_SETTING = <str> ; public static final String MIN_SHARD_INDEX_BUFFER_SIZE_SETTING = <str> ; public static final String MAX_SHARD_INDEX_BUFFER_SIZE_SETTING = <str> ; public static final String TRANSLOG_BUFFER_SIZE_SETTING = <str> ; public static final String MIN_TRANSLOG_BUFFER_SIZE_SETTING = <str> ; public static final String MAX_TRANSLOG_BUFFER_SIZE_SETTING = <str> ; public static final String MIN_SHARD_TRANSLOG_BUFFER_SIZE_SETTING = <str> ; public static final String MAX_SHARD_TRANSLOG_BUFFER_SIZE_SETTING = <str> ; public static final String SHARD_INACTIVE_INTERVAL_TIME_SETTING = <str> ; public static final ByteSizeValue INACTIVE_SHARD_INDEXING_BUFFER = ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ; public static final ByteSizeValue INACTIVE_SHARD_TRANSLOG_BUFFER = ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) ; private final ThreadPool threadPool ; private final IndicesService indicesService ; private final ByteSizeValue indexingBuffer ; private final ByteSizeValue minShardIndexBufferSize ; private final ByteSizeValue maxShardIndexBufferSize ; private final ByteSizeValue translogBuffer ; private final ByteSizeValue minShardTranslogBufferSize ; private final ByteSizeValue maxShardTranslogBufferSize ; private final TimeValue interval ; private volatile ScheduledFuture scheduler ; private static final EnumSet < IndexShardState > CAN_UPDATE_INDEX_BUFFER_STATES = EnumSet . of ( IndexShardState . RECOVERING , IndexShardState . POST_RECOVERY , IndexShardState . STARTED , IndexShardState . RELOCATED ) ; private final ShardsIndicesStatusChecker statusChecker ; @Inject public IndexingMemoryController ( Settings settings , ThreadPool threadPool , IndicesService indicesService ) { this ( settings , threadPool , indicesService , JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapMax ( ) . bytes ( ) ) ; } protected IndexingMemoryController ( Settings settings , ThreadPool threadPool , IndicesService indicesService , long jvmMemoryInBytes ) { super ( settings ) ; this . threadPool = threadPool ; this . indicesService = indicesService ; ByteSizeValue indexingBuffer ; String indexingBufferSetting = this . settings . get ( INDEX_BUFFER_SIZE_SETTING , <str> ) ; if ( indexingBufferSetting . endsWith ( <str> ) ) { double percent = Double . parseDouble ( indexingBufferSetting . substring ( <int> , indexingBufferSetting . length ( ) - <int> ) ) ; indexingBuffer = new ByteSizeValue ( ( long ) ( ( ( double ) jvmMemoryInBytes ) * ( percent / <int> ) ) ) ; ByteSizeValue minIndexingBuffer = this . settings . getAsBytesSize ( MIN_INDEX_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; ByteSizeValue maxIndexingBuffer = this . settings . getAsBytesSize ( MAX_INDEX_BUFFER_SIZE_SETTING , null ) ; if ( indexingBuffer . bytes ( ) < minIndexingBuffer . bytes ( ) ) { indexingBuffer = minIndexingBuffer ; } if ( maxIndexingBuffer ! = null & & indexingBuffer . bytes ( ) > maxIndexingBuffer . bytes ( ) ) { indexingBuffer = maxIndexingBuffer ; } } else { indexingBuffer = ByteSizeValue . parseBytesSizeValue ( indexingBufferSetting , INDEX_BUFFER_SIZE_SETTING ) ; } this . indexingBuffer = indexingBuffer ; this . minShardIndexBufferSize = this . settings . getAsBytesSize ( MIN_SHARD_INDEX_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; this . maxShardIndexBufferSize = this . settings . getAsBytesSize ( MAX_SHARD_INDEX_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; ByteSizeValue translogBuffer ; String translogBufferSetting = this . settings . get ( TRANSLOG_BUFFER_SIZE_SETTING , <str> ) ; if ( translogBufferSetting . endsWith ( <str> ) ) { double percent = Double . parseDouble ( translogBufferSetting . substring ( <int> , translogBufferSetting . length ( ) - <int> ) ) ; translogBuffer = new ByteSizeValue ( ( long ) ( ( ( double ) jvmMemoryInBytes ) * ( percent / <int> ) ) ) ; ByteSizeValue minTranslogBuffer = this . settings . getAsBytesSize ( MIN_TRANSLOG_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; ByteSizeValue maxTranslogBuffer = this . settings . getAsBytesSize ( MAX_TRANSLOG_BUFFER_SIZE_SETTING , null ) ; if ( translogBuffer . bytes ( ) < minTranslogBuffer . bytes ( ) ) { translogBuffer = minTranslogBuffer ; } if ( maxTranslogBuffer ! = null & & translogBuffer . bytes ( ) > maxTranslogBuffer . bytes ( ) ) { translogBuffer = maxTranslogBuffer ; } } else { translogBuffer = ByteSizeValue . parseBytesSizeValue ( translogBufferSetting , TRANSLOG_BUFFER_SIZE_SETTING ) ; } this . translogBuffer = translogBuffer ; this . minShardTranslogBufferSize = this . settings . getAsBytesSize ( MIN_SHARD_TRANSLOG_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; this . maxShardTranslogBufferSize = this . settings . getAsBytesSize ( MAX_SHARD_TRANSLOG_BUFFER_SIZE_SETTING , new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ) ; this . interval = this . settings . getAsTime ( SHARD_INACTIVE_INTERVAL_TIME_SETTING , TimeValue . timeValueSeconds ( <int> ) ) ; this . statusChecker = new ShardsIndicesStatusChecker ( ) ; logger . debug ( <str> , this . indexingBuffer , MIN_SHARD_INDEX_BUFFER_SIZE_SETTING , this . minShardIndexBufferSize , MAX_SHARD_INDEX_BUFFER_SIZE_SETTING , this . maxShardIndexBufferSize , SHARD_INACTIVE_INTERVAL_TIME_SETTING , this . interval ) ; } @Override protected void doStart ( ) { this . scheduler = threadPool . scheduleWithFixedDelay ( statusChecker , interval ) ; } @Override protected void doStop ( ) { FutureUtils . cancel ( scheduler ) ; scheduler = null ; } @Override protected void doClose ( ) { } public ByteSizeValue indexingBufferSize ( ) { return indexingBuffer ; } public ByteSizeValue translogBufferSize ( ) { return translogBuffer ; } protected List < IndexShard > availableShards ( ) { List < IndexShard > availableShards = new ArrayList < > ( ) ; for ( IndexService indexService : indicesService ) { for ( IndexShard shard : indexService ) { if ( shardAvailable ( shard ) ) { availableShards . add ( shard ) ; } } } return availableShards ; } protected boolean shardAvailable ( IndexShard shard ) { return shard . canIndex ( ) & & CAN_UPDATE_INDEX_BUFFER_STATES . contains ( shard . state ( ) ) ; } protected void updateShardBuffers ( IndexShard shard , ByteSizeValue shardIndexingBufferSize , ByteSizeValue shardTranslogBufferSize ) { try { shard . updateBufferSize ( shardIndexingBufferSize , shardTranslogBufferSize ) ; } catch ( EngineClosedException | FlushNotAllowedEngineException e ) { } catch ( Exception e ) { logger . warn ( <str> , e , shard . shardId ( ) , shardIndexingBufferSize ) ; } } public void forceCheck ( ) { statusChecker . run ( ) ; } class ShardsIndicesStatusChecker implements Runnable { @Override public synchronized void run ( ) { List < IndexShard > availableShards = availableShards ( ) ; List < IndexShard > activeShards = new ArrayList < > ( ) ; for ( IndexShard shard : availableShards ) { if ( ! checkIdle ( shard ) ) { activeShards . add ( shard ) ; } } int activeShardCount = activeShards . size ( ) ; if ( activeShardCount = = <int> ) { return ; } ByteSizeValue shardIndexingBufferSize = new ByteSizeValue ( indexingBuffer . bytes ( ) / activeShardCount ) ; if ( shardIndexingBufferSize . bytes ( ) < minShardIndexBufferSize . bytes ( ) ) { shardIndexingBufferSize = minShardIndexBufferSize ; } if ( shardIndexingBufferSize . bytes ( ) > maxShardIndexBufferSize . bytes ( ) ) { shardIndexingBufferSize = maxShardIndexBufferSize ; } ByteSizeValue shardTranslogBufferSize = new ByteSizeValue ( translogBuffer . bytes ( ) / activeShardCount ) ; if ( shardTranslogBufferSize . bytes ( ) < minShardTranslogBufferSize . bytes ( ) ) { shardTranslogBufferSize = minShardTranslogBufferSize ; } if ( shardTranslogBufferSize . bytes ( ) > maxShardTranslogBufferSize . bytes ( ) ) { shardTranslogBufferSize = maxShardTranslogBufferSize ; } logger . debug ( <str> , indexingBuffer , activeShardCount , shardIndexingBufferSize , shardTranslogBufferSize ) ; for ( IndexShard shard : activeShards ) { updateShardBuffers ( shard , shardIndexingBufferSize , shardTranslogBufferSize ) ; } } } protected long currentTimeInNanos ( ) { return System . nanoTime ( ) ; } protected boolean checkIdle ( IndexShard shard ) { try { return shard . checkIdle ( ) ; } catch ( EngineClosedException | FlushNotAllowedEngineException e ) { logger . trace ( <str> , e . getClass ( ) . getSimpleName ( ) , shard . shardId ( ) ) ; return true ; } } @Override public void onShardActive ( IndexShard indexShard ) { forceCheck ( ) ; } } 
