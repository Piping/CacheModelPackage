package com . badlogic . gdx . graphics . g2d ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . utils . NumberUtils ; public class PolygonSprite { PolygonRegion region ; private float x , y ; private float width , height ; private float scaleX = <float> , scaleY = <float> ; private float rotation ; private float originX , originY ; private float [ ] vertices ; private boolean dirty ; private Rectangle bounds = new Rectangle ( ) ; private final Color color = new Color ( <float> , <float> , <float> , <float> ) ; public PolygonSprite ( PolygonRegion region ) { setRegion ( region ) ; setColor ( <int> , <int> , <int> , <int> ) ; setSize ( region . region . regionWidth , region . region . regionHeight ) ; setOrigin ( width / <int> , height / <int> ) ; } public PolygonSprite ( PolygonSprite sprite ) { set ( sprite ) ; } public void set ( PolygonSprite sprite ) { if ( sprite = = null ) throw new IllegalArgumentException ( <str> ) ; setRegion ( sprite . region ) ; x = sprite . x ; y = sprite . y ; width = sprite . width ; height = sprite . height ; originX = sprite . originX ; originY = sprite . originY ; rotation = sprite . rotation ; scaleX = sprite . scaleX ; scaleY = sprite . scaleY ; color . set ( sprite . color ) ; dirty = sprite . dirty ; } public void setBounds ( float x , float y , float width , float height ) { this . x = x ; this . y = y ; this . width = width ; this . height = height ; dirty = true ; } public void setSize ( float width , float height ) { this . width = width ; this . height = height ; dirty = true ; } public void setPosition ( float x , float y ) { translate ( x - this . x , y - this . y ) ; } public void setX ( float x ) { translateX ( x - this . x ) ; } public void setY ( float y ) { translateY ( y - this . y ) ; } public void translateX ( float xAmount ) { this . x + = xAmount ; if ( dirty ) return ; final float [ ] vertices = this . vertices ; for ( int i = <int> ; i < vertices . length ; i + = Sprite . VERTEX_SIZE ) vertices [ i ] + = xAmount ; } public void translateY ( float yAmount ) { y + = yAmount ; if ( dirty ) return ; final float [ ] vertices = this . vertices ; for ( int i = <int> ; i < vertices . length ; i + = Sprite . VERTEX_SIZE ) vertices [ i ] + = yAmount ; } public void translate ( float xAmount , float yAmount ) { x + = xAmount ; y + = yAmount ; if ( dirty ) return ; final float [ ] vertices = this . vertices ; for ( int i = <int> ; i < vertices . length ; i + = Sprite . VERTEX_SIZE ) { vertices [ i ] + = xAmount ; vertices [ i + <int> ] + = yAmount ; } } public void setColor ( Color tint ) { color . set ( tint ) ; float color = tint . toFloatBits ( ) ; final float [ ] vertices = this . vertices ; for ( int i = <int> ; i < vertices . length ; i + = Sprite . VERTEX_SIZE ) vertices [ i ] = color ; } public void setColor ( float r , float g , float b , float a ) { color . set ( r , g , b , a ) ; int intBits = ( ( int ) ( <int> * a ) < < <int> ) | ( ( int ) ( <int> * b ) < < <int> ) | ( ( int ) ( <int> * g ) < < <int> ) | ( ( int ) ( <int> * r ) ) ; float color = NumberUtils . intToFloatColor ( intBits ) ; final float [ ] vertices = this . vertices ; for ( int i = <int> ; i < vertices . length ; i + = Sprite . VERTEX_SIZE ) vertices [ i ] = color ; } public void setOrigin ( float originX , float originY ) { this . originX = originX ; this . originY = originY ; dirty = true ; } public void setRotation ( float degrees ) { this . rotation = degrees ; dirty = true ; } public void rotate ( float degrees ) { rotation + = degrees ; dirty = true ; } public void setScale ( float scaleXY ) { this . scaleX = scaleXY ; this . scaleY = scaleXY ; dirty = true ; } public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ; dirty = true ; } public void scale ( float amount ) { this . scaleX + = amount ; this . scaleY + = amount ; dirty = true ; } public float [ ] getVertices ( ) { if ( ! dirty ) return vertices ; dirty = false ; final float originX = this . originX ; final float originY = this . originY ; final float scaleX = this . scaleX ; final float scaleY = this . scaleY ; final PolygonRegion region = this . region ; final float [ ] vertices = this . vertices ; final float [ ] regionVertices = region . vertices ; final float worldOriginX = x + originX ; final float worldOriginY = y + originY ; final float sX = width / region . region . getRegionWidth ( ) ; final float sY = height / region . region . getRegionHeight ( ) ; final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; float fx , fy ; for ( int i = <int> , v = <int> , n = regionVertices . length ; i < n ; i + = <int> , v + = <int> ) { fx = ( regionVertices [ i ] * sX - originX ) * scaleX ; fy = ( regionVertices [ i + <int> ] * sY - originY ) * scaleY ; vertices [ v ] = cos * fx - sin * fy + worldOriginX ; vertices [ v + <int> ] = sin * fx + cos * fy + worldOriginY ; } return vertices ; } public Rectangle getBoundingRectangle ( ) { final float [ ] vertices = getVertices ( ) ; float minx = vertices [ <int> ] ; float miny = vertices [ <int> ] ; float maxx = vertices [ <int> ] ; float maxy = vertices [ <int> ] ; for ( int i = <int> ; i < vertices . length ; i + = <int> ) { float x = vertices [ i ] ; float y = vertices [ i + <int> ] ; minx = minx > x ? x : minx ; maxx = maxx < x ? x : maxx ; miny = miny > y ? y : miny ; maxy = maxy < y ? y : maxy ; } bounds . x = minx ; bounds . y = miny ; bounds . width = maxx - minx ; bounds . height = maxy - miny ; return bounds ; } public void draw ( PolygonSpriteBatch spriteBatch ) { final PolygonRegion region = this . region ; spriteBatch . draw ( region . region . texture , getVertices ( ) , <int> , vertices . length , region . triangles , <int> , region . triangles . length ) ; } public void draw ( PolygonSpriteBatch spriteBatch , float alphaModulation ) { Color color = getColor ( ) ; float oldAlpha = color . a ; color . a * = alphaModulation ; setColor ( color ) ; draw ( spriteBatch ) ; color . a = oldAlpha ; setColor ( color ) ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public float getWidth ( ) { return width ; } public float getHeight ( ) { return height ; } public float getOriginX ( ) { return originX ; } public float getOriginY ( ) { return originY ; } public float getRotation ( ) { return rotation ; } public float getScaleX ( ) { return scaleX ; } public float getScaleY ( ) { return scaleY ; } public Color getColor ( ) { return color ; } public Color getVertexColor ( ) { int intBits = NumberUtils . floatToIntColor ( vertices [ <int> ] ) ; Color color = this . color ; color . r = ( intBits & <hex> ) / <int> f ; color . g = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . b = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . a = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; return color ; } public void setRegion ( PolygonRegion region ) { this . region = region ; float [ ] regionVertices = region . vertices ; float [ ] textureCoords = region . textureCoords ; if ( vertices = = null | | regionVertices . length ! = vertices . length ) vertices = new float [ ( regionVertices . length / <int> ) * <int> ] ; float [ ] vertices = this . vertices ; for ( int i = <int> , v = <int> , n = regionVertices . length ; i < n ; i + = <int> , v + = <int> ) { vertices [ v ] = color . toFloatBits ( ) ; vertices [ v + <int> ] = textureCoords [ i ] ; vertices [ v + <int> ] = textureCoords [ i + <int> ] ; } dirty = true ; } public PolygonRegion getRegion ( ) { return region ; } } 
