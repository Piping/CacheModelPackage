package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . Event ; public final class CreateAggregateStatement extends SchemaAlteringStatement { private final boolean orReplace ; private final boolean ifNotExists ; private FunctionName functionName ; private FunctionName stateFunc ; private FunctionName finalFunc ; private final CQL3Type . Raw stateTypeRaw ; private final List < CQL3Type . Raw > argRawTypes ; private final Term . Raw ival ; private List < AbstractType < ? > > argTypes ; private AbstractType < ? > returnType ; private ScalarFunction stateFunction ; private ScalarFunction finalFunction ; private ByteBuffer initcond ; public CreateAggregateStatement ( FunctionName functionName , List < CQL3Type . Raw > argRawTypes , String stateFunc , CQL3Type . Raw stateType , String finalFunc , Term . Raw ival , boolean orReplace , boolean ifNotExists ) { this . functionName = functionName ; this . argRawTypes = argRawTypes ; this . stateFunc = new FunctionName ( functionName . keyspace , stateFunc ) ; this . finalFunc = finalFunc ! = null ? new FunctionName ( functionName . keyspace , finalFunc ) : null ; this . stateTypeRaw = stateType ; this . ival = ival ; this . orReplace = orReplace ; this . ifNotExists = ifNotExists ; } public Prepared prepare ( ) { argTypes = new ArrayList < > ( argRawTypes . size ( ) ) ; for ( CQL3Type . Raw rawType : argRawTypes ) argTypes . add ( prepareType ( <str> , rawType ) ) ; AbstractType < ? > stateType = prepareType ( <str> , stateTypeRaw ) ; List < AbstractType < ? > > stateArgs = stateArguments ( stateType , argTypes ) ; Function f = Schema . instance . findFunction ( stateFunc , stateArgs ) . orElse ( null ) ; if ( ! ( f instanceof ScalarFunction ) ) throw new InvalidRequestException ( <str> + stateFuncSig ( stateFunc , stateTypeRaw , argRawTypes ) + <str> ) ; stateFunction = ( ScalarFunction ) f ; AbstractType < ? > stateReturnType = stateFunction . returnType ( ) ; if ( ! stateReturnType . equals ( stateType ) ) throw new InvalidRequestException ( <str> + stateFuncSig ( stateFunction . name ( ) , stateTypeRaw , argRawTypes ) + <str> ) ; if ( finalFunc ! = null ) { List < AbstractType < ? > > finalArgs = Collections . < AbstractType < ? > > singletonList ( stateType ) ; f = Schema . instance . findFunction ( finalFunc , finalArgs ) . orElse ( null ) ; if ( ! ( f instanceof ScalarFunction ) ) throw new InvalidRequestException ( <str> + finalFunc + <str> + stateTypeRaw + <str> ) ; finalFunction = ( ScalarFunction ) f ; returnType = finalFunction . returnType ( ) ; } else { returnType = stateReturnType ; } if ( ival ! = null ) { initcond = Terms . asBytes ( functionName . keyspace , ival . toString ( ) , stateType ) ; if ( Constants . NULL_LITERAL ! = ival & & UDHelper . isNullOrEmpty ( stateType , initcond ) ) throw new InvalidRequestException ( <str> ) ; } return super . prepare ( ) ; } private AbstractType < ? > prepareType ( String typeName , CQL3Type . Raw rawType ) { if ( rawType . isFrozen ( ) ) throw new InvalidRequestException ( String . format ( <str> , typeName ) ) ; if ( ! rawType . canBeNonFrozen ( ) ) rawType . freeze ( ) ; AbstractType < ? > type = rawType . prepare ( functionName . keyspace ) . getType ( ) ; return type ; } public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( ! functionName . hasKeyspace ( ) & & state . getRawKeyspace ( ) ! = null ) functionName = new FunctionName ( state . getKeyspace ( ) , functionName . name ) ; if ( ! functionName . hasKeyspace ( ) ) throw new InvalidRequestException ( <str> ) ; ThriftValidation . validateKeyspaceNotSystem ( functionName . keyspace ) ; stateFunc = new FunctionName ( functionName . keyspace , stateFunc . name ) ; if ( finalFunc ! = null ) finalFunc = new FunctionName ( functionName . keyspace , finalFunc . name ) ; } protected void grantPermissionsToCreator ( QueryState state ) { try { IResource resource = FunctionResource . function ( functionName . keyspace , functionName . name , argTypes ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , resource . applicablePermissions ( ) , resource , RoleResource . role ( state . getClientState ( ) . getUser ( ) . getName ( ) ) ) ; } catch ( RequestExecutionException e ) { throw new RuntimeException ( e ) ; } } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { if ( Schema . instance . findFunction ( functionName , argTypes ) . isPresent ( ) & & orReplace ) state . ensureHasPermission ( Permission . ALTER , FunctionResource . function ( functionName . keyspace , functionName . name , argTypes ) ) ; else state . ensureHasPermission ( Permission . CREATE , FunctionResource . keyspace ( functionName . keyspace ) ) ; for ( Function referencedFunction : stateFunction . getFunctions ( ) ) state . ensureHasPermission ( Permission . EXECUTE , referencedFunction ) ; if ( finalFunction ! = null ) for ( Function referencedFunction : finalFunction . getFunctions ( ) ) state . ensureHasPermission ( Permission . EXECUTE , referencedFunction ) ; } public void validate ( ClientState state ) throws InvalidRequestException { if ( ifNotExists & & orReplace ) throw new InvalidRequestException ( <str> ) ; if ( Schema . instance . getKSMetaData ( functionName . keyspace ) = = null ) throw new InvalidRequestException ( String . format ( <str> , functionName . name , functionName . keyspace ) ) ; } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { Function old = Schema . instance . findFunction ( functionName , argTypes ) . orElse ( null ) ; boolean replaced = old ! = null ; if ( replaced ) { if ( ifNotExists ) return null ; if ( ! orReplace ) throw new InvalidRequestException ( String . format ( <str> , old ) ) ; if ( ! ( old instanceof AggregateFunction ) ) throw new InvalidRequestException ( String . format ( <str> , old ) ) ; if ( old . isNative ( ) ) throw new InvalidRequestException ( String . format ( <str> , old ) ) ; if ( ! old . returnType ( ) . isValueCompatibleWith ( returnType ) ) throw new InvalidRequestException ( String . format ( <str> , functionName , returnType . asCQL3Type ( ) , old . returnType ( ) . asCQL3Type ( ) ) ) ; } if ( ! stateFunction . isCalledOnNullInput ( ) & & initcond = = null ) throw new InvalidRequestException ( String . format ( <str> , functionName , stateFunc ) ) ; UDAggregate udAggregate = new UDAggregate ( functionName , argTypes , returnType , stateFunction , finalFunction , initcond ) ; MigrationManager . announceNewAggregate ( udAggregate , isLocalOnly ) ; return new Event . SchemaChange ( replaced ? Event . SchemaChange . Change . UPDATED : Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . AGGREGATE , udAggregate . name ( ) . keyspace , udAggregate . name ( ) . name , AbstractType . asCQLTypeStringList ( udAggregate . argTypes ( ) ) ) ; } private static String stateFuncSig ( FunctionName stateFuncName , CQL3Type . Raw stateTypeRaw , List < CQL3Type . Raw > argRawTypes ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( stateFuncName . toString ( ) ) . append ( <str> ) . append ( stateTypeRaw ) ; for ( CQL3Type . Raw argRawType : argRawTypes ) sb . append ( <str> ) . append ( argRawType ) ; sb . append ( <str> ) ; return sb . toString ( ) ; } private static List < AbstractType < ? > > stateArguments ( AbstractType < ? > stateType , List < AbstractType < ? > > argTypes ) { List < AbstractType < ? > > r = new ArrayList < > ( argTypes . size ( ) + <int> ) ; r . add ( stateType ) ; r . addAll ( argTypes ) ; return r ; } } 
