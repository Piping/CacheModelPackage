package com . google . common . graph ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . graph . GraphErrorMessageUtils . ADDING_PARALLEL_EDGE ; import static com . google . common . graph . GraphErrorMessageUtils . EDGE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . NODE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . REUSING_EDGE ; import static com . google . common . graph . GraphErrorMessageUtils . SELF_LOOPS_NOT_ALLOWED ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import java . util . Collections ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; final class IncidenceSetDirectedGraph < N , E > implements DirectedGraph < N , E > { private final Map < N , IncidentEdges < E > > nodeToIncidentEdges ; private final Map < E , IncidentNodes < N > > edgeToIncidentNodes ; private final GraphConfig config ; IncidenceSetDirectedGraph ( GraphConfig config ) { this . nodeToIncidentEdges = Maps . newLinkedHashMapWithExpectedSize ( config . getExpectedNodeCount ( ) . or ( <int> ) ) ; this . edgeToIncidentNodes = Maps . newLinkedHashMapWithExpectedSize ( config . getExpectedEdgeCount ( ) . or ( <int> ) ) ; this . config = config ; } @Override public Set < N > nodes ( ) { return Collections . unmodifiableSet ( nodeToIncidentEdges . keySet ( ) ) ; } @Override public Set < E > edges ( ) { return Collections . unmodifiableSet ( edgeToIncidentNodes . keySet ( ) ) ; } @Override public GraphConfig config ( ) { return config ; } @Override public Set < E > incidentEdges ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return Sets . union ( incidentEdges . inEdges ( ) , incidentEdges . outEdges ( ) ) ; } @Override public Set < N > incidentNodes ( final Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . asImmutableSet ( ) ; } @Override public Set < N > adjacentNodes ( Object node ) { return Sets . union ( predecessors ( node ) , successors ( node ) ) ; } @Override public Set < E > adjacentEdges ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return Sets . difference ( Sets . union ( incidentEdges ( endpoints . target ( ) ) , incidentEdges ( endpoints . source ( ) ) ) , ImmutableSet . of ( edge ) ) ; } @Override public Set < E > edgesConnecting ( Object node1 , Object node2 ) { checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; IncidentEdges < E > incidentEdgesN1 = nodeToIncidentEdges . get ( node1 ) ; checkArgument ( incidentEdgesN1 ! = null , NODE_NOT_IN_GRAPH , node1 ) ; IncidentEdges < E > incidentEdgesN2 = nodeToIncidentEdges . get ( node2 ) ; checkArgument ( incidentEdgesN2 ! = null , NODE_NOT_IN_GRAPH , node2 ) ; Set < E > outEdges = incidentEdgesN1 . outEdges ( ) ; Set < E > inEdges = incidentEdgesN2 . inEdges ( ) ; return outEdges . size ( ) < = inEdges . size ( ) ? Sets . intersection ( outEdges , inEdges ) : Sets . intersection ( inEdges , outEdges ) ; } @Override public Set < E > inEdges ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return Collections . unmodifiableSet ( incidentEdges . inEdges ( ) ) ; } @Override public Set < E > outEdges ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return Collections . unmodifiableSet ( incidentEdges . outEdges ( ) ) ; } @Override public Set < N > predecessors ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; final Set < E > inEdges = incidentEdges . inEdges ( ) ; return new SetView < N > ( ) { @Override public boolean isEmpty ( ) { return inEdges . isEmpty ( ) ; } @Override Set < N > elements ( ) { Set < N > nodes = Sets . newLinkedHashSet ( ) ; for ( E edge : inEdges ) { nodes . add ( source ( edge ) ) ; } return nodes ; } } ; } @Override public Set < N > successors ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; final Set < E > outEdges = incidentEdges . outEdges ( ) ; return new SetView < N > ( ) { @Override public boolean isEmpty ( ) { return outEdges . isEmpty ( ) ; } @Override Set < N > elements ( ) { Set < N > nodes = Sets . newLinkedHashSet ( ) ; for ( E edge : outEdges ) { nodes . add ( target ( edge ) ) ; } return nodes ; } } ; } @Override public long degree ( Object node ) { checkNotNull ( node , <str> ) ; return config . isSelfLoopsAllowed ( ) ? inDegree ( node ) + outDegree ( node ) - edgesConnecting ( node , node ) . size ( ) : inDegree ( node ) + outDegree ( node ) ; } @Override public long inDegree ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges . inEdges ( ) . size ( ) ; } @Override public long outDegree ( Object node ) { checkNotNull ( node , <str> ) ; IncidentEdges < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges . outEdges ( ) . size ( ) ; } @Override public N source ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . source ( ) ; } @Override public N target ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; checkArgument ( endpoints ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return endpoints . target ( ) ; } @Override public boolean addNode ( N node ) { checkNotNull ( node , <str> ) ; if ( containsNode ( node ) ) { return false ; } nodeToIncidentEdges . put ( node , IncidentEdges . < E > of ( ) ) ; return true ; } @Override public boolean addEdge ( E edge , N node1 , N node2 ) { checkNotNull ( edge , <str> ) ; checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; checkArgument ( config . isSelfLoopsAllowed ( ) | | ! node1 . equals ( node2 ) , SELF_LOOPS_NOT_ALLOWED , node1 ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; if ( endpoints ! = null ) { N source = endpoints . source ( ) ; N target = endpoints . target ( ) ; checkArgument ( source . equals ( node1 ) & & target . equals ( node2 ) , REUSING_EDGE , edge , ImmutableList . of ( source , target ) , ImmutableList . of ( node1 , node2 ) ) ; return false ; } else if ( ! config . isMultigraph ( ) & & containsNode ( node1 ) & & containsNode ( node2 ) ) { E edgeConnecting = Iterables . getOnlyElement ( edgesConnecting ( node1 , node2 ) , null ) ; checkArgument ( edgeConnecting = = null , ADDING_PARALLEL_EDGE , node1 , node2 , edgeConnecting ) ; } addNode ( node1 ) ; addNode ( node2 ) ; edgeToIncidentNodes . put ( edge , IncidentNodes . of ( node1 , node2 ) ) ; nodeToIncidentEdges . get ( node1 ) . outEdges ( ) . add ( edge ) ; nodeToIncidentEdges . get ( node2 ) . inEdges ( ) . add ( edge ) ; return true ; } @Override public boolean removeNode ( Object node ) { checkNotNull ( node , <str> ) ; if ( ! containsNode ( node ) ) { return false ; } for ( Object edge : incidentEdges ( node ) . toArray ( ) ) { removeEdge ( edge ) ; } nodeToIncidentEdges . remove ( node ) ; return true ; } @Override public boolean removeEdge ( Object edge ) { checkNotNull ( edge , <str> ) ; IncidentNodes < N > endpoints = edgeToIncidentNodes . get ( edge ) ; if ( endpoints = = null ) { return false ; } nodeToIncidentEdges . get ( endpoints . source ( ) ) . outEdges ( ) . remove ( edge ) ; nodeToIncidentEdges . get ( endpoints . target ( ) ) . inEdges ( ) . remove ( edge ) ; edgeToIncidentNodes . remove ( edge ) ; return true ; } @Override public boolean equals ( @Nullable Object other ) { return ( other instanceof DirectedGraph ) & & Graphs . equal ( this , ( DirectedGraph ) other ) ; } @Override public int hashCode ( ) { return nodeToIncidentEdges . hashCode ( ) ; } @Override public String toString ( ) { return String . format ( <str> , config , nodeToIncidentEdges . keySet ( ) , edgeToIncidentNodes ) ; } private boolean containsNode ( Object node ) { return nodeToIncidentEdges . containsKey ( node ) ; } } 
