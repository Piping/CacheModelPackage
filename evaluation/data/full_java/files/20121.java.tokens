package io . netty . resolver . dns ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufHolder ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . channel . socket . nio . NioDatagramChannel ; import io . netty . handler . codec . dns . DefaultDnsQuestion ; import io . netty . handler . codec . dns . DnsRecord ; import io . netty . handler . codec . dns . DnsRecordType ; import io . netty . handler . codec . dns . DnsResponse ; import io . netty . handler . codec . dns . DnsResponseCode ; import io . netty . handler . codec . dns . DnsSection ; import io . netty . util . NetUtil ; import io . netty . util . concurrent . Future ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . ThreadLocalRandom ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . apache . directory . server . dns . DnsServer ; import org . apache . directory . server . dns . io . encoder . DnsMessageEncoder ; import org . apache . directory . server . dns . io . encoder . ResourceRecordEncoder ; import org . apache . directory . server . dns . messages . DnsMessage ; import org . apache . directory . server . dns . messages . QuestionRecord ; import org . apache . directory . server . dns . messages . RecordClass ; import org . apache . directory . server . dns . messages . RecordType ; import org . apache . directory . server . dns . messages . ResourceRecord ; import org . apache . directory . server . dns . messages . ResourceRecordModifier ; import org . apache . directory . server . dns . protocol . DnsProtocolHandler ; import org . apache . directory . server . dns . protocol . DnsUdpDecoder ; import org . apache . directory . server . dns . protocol . DnsUdpEncoder ; import org . apache . directory . server . dns . store . DnsAttribute ; import org . apache . directory . server . dns . store . RecordStore ; import org . apache . directory . server . protocol . shared . transport . UdpTransport ; import org . apache . mina . core . buffer . IoBuffer ; import org . apache . mina . core . session . IoSession ; import org . apache . mina . filter . codec . ProtocolCodecFactory ; import org . apache . mina . filter . codec . ProtocolCodecFilter ; import org . apache . mina . filter . codec . ProtocolDecoder ; import org . apache . mina . filter . codec . ProtocolEncoder ; import org . apache . mina . filter . codec . ProtocolEncoderOutput ; import org . apache . mina . transport . socket . DatagramAcceptor ; import org . apache . mina . transport . socket . DatagramSessionConfig ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class DnsNameResolverTest { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DnsNameResolver . class ) ; private static final Set < String > DOMAINS = Collections . unmodifiableSet ( new HashSet < String > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ) ; private static final Set < String > EXCLUSIONS_RESOLVE_A = new HashSet < String > ( ) ; static { Collections . addAll ( EXCLUSIONS_RESOLVE_A , <str> , <str> , StringUtil . EMPTY_STRING ) ; } private static final Set < String > EXCLUSIONS_RESOLVE_AAAA = new HashSet < String > ( ) ; static { EXCLUSIONS_RESOLVE_AAAA . addAll ( EXCLUSIONS_RESOLVE_A ) ; EXCLUSIONS_RESOLVE_AAAA . addAll ( DOMAINS ) ; EXCLUSIONS_RESOLVE_AAAA . removeAll ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; } private static final Set < String > EXCLUSIONS_QUERY_MX = new HashSet < String > ( ) ; static { Collections . addAll ( EXCLUSIONS_QUERY_MX , <str> , <str> , <str> , <str> , <str> , <str> , <str> , StringUtil . EMPTY_STRING ) ; } private static final TestDnsServer dnsServer = new TestDnsServer ( ) ; private static final EventLoopGroup group = new NioEventLoopGroup ( <int> ) ; private static DnsNameResolver resolver ; @BeforeClass public static void init ( ) throws Exception { dnsServer . start ( ) ; resolver = new DnsNameResolver ( group . next ( ) , NioDatagramChannel . class , DnsServerAddresses . singleton ( dnsServer . localAddress ( ) ) ) ; resolver . setMaxQueriesPerResolve ( <int> ) ; resolver . setOptResourceEnabled ( false ) ; } @AfterClass public static void destroy ( ) { dnsServer . stop ( ) ; group . shutdownGracefully ( ) ; } @After public void reset ( ) throws Exception { resolver . clearCache ( ) ; } @Test public void testResolveAorAAAA ( ) throws Exception { testResolve0 ( EXCLUSIONS_RESOLVE_A , InternetProtocolFamily . IPv4 , InternetProtocolFamily . IPv6 ) ; } @Test public void testResolveAAAAorA ( ) throws Exception { testResolve0 ( EXCLUSIONS_RESOLVE_A , InternetProtocolFamily . IPv6 , InternetProtocolFamily . IPv4 ) ; } @Test public void testResolveA ( ) throws Exception { final int oldMinTtl = resolver . minTtl ( ) ; final int oldMaxTtl = resolver . maxTtl ( ) ; resolver . setTtl ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ; try { final Map < String , InetAddress > resultA = testResolve0 ( EXCLUSIONS_RESOLVE_A , InternetProtocolFamily . IPv4 ) ; final Map < String , InetAddress > resultB = testResolve0 ( EXCLUSIONS_RESOLVE_A , InternetProtocolFamily . IPv4 ) ; assertThat ( resultB . size ( ) , is ( resultA . size ( ) ) ) ; for ( Entry < String , InetAddress > e : resultA . entrySet ( ) ) { InetAddress expected = e . getValue ( ) ; InetAddress actual = resultB . get ( e . getKey ( ) ) ; if ( ! actual . equals ( expected ) ) { System . err . println ( <str> + e . getKey ( ) + <str> + resolver . resolveAll ( e . getKey ( ) , <int> ) . getNow ( ) ) ; } assertThat ( actual , is ( expected ) ) ; } } finally { resolver . setTtl ( oldMinTtl , oldMaxTtl ) ; } } @Test public void testResolveAAAA ( ) throws Exception { testResolve0 ( EXCLUSIONS_RESOLVE_AAAA , InternetProtocolFamily . IPv6 ) ; } private static Map < String , InetAddress > testResolve0 ( Set < String > excludedDomains , InternetProtocolFamily . . . famililies ) throws InterruptedException { final List < InternetProtocolFamily > oldResolveAddressTypes = resolver . resolveAddressTypes ( ) ; assertThat ( resolver . isRecursionDesired ( ) , is ( true ) ) ; assertThat ( oldResolveAddressTypes . size ( ) , is ( InternetProtocolFamily . values ( ) . length ) ) ; resolver . setResolveAddressTypes ( famililies ) ; final Map < String , InetAddress > results = new HashMap < String , InetAddress > ( ) ; try { final Map < InetSocketAddress , Future < InetSocketAddress > > futures = new LinkedHashMap < InetSocketAddress , Future < InetSocketAddress > > ( ) ; for ( String name : DOMAINS ) { if ( excludedDomains . contains ( name ) ) { continue ; } resolve ( futures , name ) ; } for ( Entry < InetSocketAddress , Future < InetSocketAddress > > e : futures . entrySet ( ) ) { InetSocketAddress unresolved = e . getKey ( ) ; InetSocketAddress resolved = e . getValue ( ) . sync ( ) . getNow ( ) ; logger . info ( <str> , unresolved . getHostString ( ) , resolved . getAddress ( ) . getHostAddress ( ) ) ; assertThat ( resolved . isUnresolved ( ) , is ( false ) ) ; assertThat ( resolved . getHostString ( ) , is ( unresolved . getHostString ( ) ) ) ; assertThat ( resolved . getPort ( ) , is ( unresolved . getPort ( ) ) ) ; boolean typeMatches = false ; for ( InternetProtocolFamily f : famililies ) { Class < ? > resolvedType = resolved . getAddress ( ) . getClass ( ) ; if ( f . addressType ( ) . isAssignableFrom ( resolvedType ) ) { typeMatches = true ; } } assertThat ( typeMatches , is ( true ) ) ; results . put ( resolved . getHostString ( ) , resolved . getAddress ( ) ) ; } } finally { resolver . setResolveAddressTypes ( oldResolveAddressTypes ) ; } return results ; } @Test public void testQueryMx ( ) throws Exception { assertThat ( resolver . isRecursionDesired ( ) , is ( true ) ) ; Map < String , Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > futures = new LinkedHashMap < String , Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > ( ) ; for ( String name : DOMAINS ) { if ( EXCLUSIONS_QUERY_MX . contains ( name ) ) { continue ; } queryMx ( futures , name ) ; } for ( Entry < String , Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > e : futures . entrySet ( ) ) { String hostname = e . getKey ( ) ; Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > f = e . getValue ( ) . awaitUninterruptibly ( ) ; DnsResponse response = f . getNow ( ) . content ( ) ; assertThat ( response . code ( ) , is ( DnsResponseCode . NOERROR ) ) ; final int answerCount = response . count ( DnsSection . ANSWER ) ; final List < DnsRecord > mxList = new ArrayList < DnsRecord > ( answerCount ) ; for ( int i = <int> ; i < answerCount ; i + + ) { final DnsRecord r = response . recordAt ( DnsSection . ANSWER , i ) ; if ( r . type ( ) = = DnsRecordType . MX ) { mxList . add ( r ) ; } } assertThat ( mxList . size ( ) , is ( greaterThan ( <int> ) ) ) ; StringBuilder buf = new StringBuilder ( ) ; for ( DnsRecord r : mxList ) { ByteBuf recordContent = ( ( ByteBufHolder ) r ) . content ( ) ; buf . append ( StringUtil . NEWLINE ) ; buf . append ( <str> ) ; buf . append ( r . name ( ) ) ; buf . append ( <str> ) ; buf . append ( r . type ( ) . name ( ) ) ; buf . append ( <str> ) ; buf . append ( recordContent . readUnsignedShort ( ) ) ; buf . append ( <str> ) ; buf . append ( DnsNameResolverContext . decodeDomainName ( recordContent ) ) ; } logger . info ( <str> , hostname , buf ) ; response . release ( ) ; } } @Test public void testNegativeTtl ( ) throws Exception { final int oldNegativeTtl = resolver . negativeTtl ( ) ; resolver . setNegativeTtl ( <int> ) ; try { resolveNonExistentDomain ( ) ; final int size = <int> ; final List < UnknownHostException > exceptions = new ArrayList < UnknownHostException > ( ) ; final Thread negativeLookupThread = new Thread ( ) { @Override public void run ( ) { for ( int i = <int> ; i < size ; i + + ) { exceptions . add ( resolveNonExistentDomain ( ) ) ; if ( isInterrupted ( ) ) { break ; } } } } ; negativeLookupThread . start ( ) ; negativeLookupThread . join ( <int> ) ; if ( negativeLookupThread . isAlive ( ) ) { negativeLookupThread . interrupt ( ) ; fail ( <str> ) ; } assertThat ( exceptions , hasSize ( size ) ) ; } finally { resolver . setNegativeTtl ( oldNegativeTtl ) ; } } private static UnknownHostException resolveNonExistentDomain ( ) { try { resolver . resolve ( <str> , <int> ) . sync ( ) ; fail ( ) ; return null ; } catch ( Exception e ) { assertThat ( e , is ( instanceOf ( UnknownHostException . class ) ) ) ; return ( UnknownHostException ) e ; } } @Test public void testResolveIp ( ) { InetSocketAddress unresolved = InetSocketAddress . createUnresolved ( <str> , ThreadLocalRandom . current ( ) . nextInt ( <int> ) ) ; InetSocketAddress address = resolver . resolve ( unresolved ) . syncUninterruptibly ( ) . getNow ( ) ; assertEquals ( <str> , address . getHostName ( ) ) ; } private static void resolve ( Map < InetSocketAddress , Future < InetSocketAddress > > futures , String hostname ) { InetSocketAddress unresolved = InetSocketAddress . createUnresolved ( hostname , ThreadLocalRandom . current ( ) . nextInt ( <int> ) ) ; futures . put ( unresolved , resolver . resolve ( unresolved ) ) ; } private static void queryMx ( Map < String , Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > > futures , String hostname ) throws Exception { futures . put ( hostname , resolver . query ( new DefaultDnsQuestion ( hostname , DnsRecordType . MX ) ) ) ; } private static final class TestDnsServer extends DnsServer { private static final Map < String , byte [ ] > BYTES = new HashMap < String , byte [ ] > ( ) ; private static final String [ ] IPV6_ADDRESSES ; static { BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; BYTES . put ( <str> , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; IPV6_ADDRESSES = BYTES . keySet ( ) . toArray ( new String [ BYTES . size ( ) ] ) ; } @Override public void start ( ) throws IOException { InetSocketAddress address = new InetSocketAddress ( NetUtil . LOCALHOST4 , <int> ) ; UdpTransport transport = new UdpTransport ( address . getHostName ( ) , address . getPort ( ) ) ; setTransports ( transport ) ; DatagramAcceptor acceptor = transport . getAcceptor ( ) ; acceptor . setHandler ( new DnsProtocolHandler ( this , new TestRecordStore ( ) ) { @Override public void sessionCreated ( IoSession session ) throws Exception { session . getFilterChain ( ) . addFirst ( <str> , new ProtocolCodecFilter ( new TestDnsProtocolUdpCodecFactory ( ) ) ) ; } } ) ; ( ( DatagramSessionConfig ) acceptor . getSessionConfig ( ) ) . setReuseAddress ( true ) ; acceptor . bind ( ) ; } public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) getTransports ( ) [ <int> ] . getAcceptor ( ) . getLocalAddress ( ) ; } private static final class TestDnsProtocolUdpCodecFactory implements ProtocolCodecFactory { private final DnsMessageEncoder encoder = new DnsMessageEncoder ( ) ; private final TestAAAARecordEncoder recordEncoder = new TestAAAARecordEncoder ( ) ; @Override public ProtocolEncoder getEncoder ( IoSession session ) throws Exception { return new DnsUdpEncoder ( ) { @Override public void encode ( IoSession session , Object message , ProtocolEncoderOutput out ) { IoBuffer buf = IoBuffer . allocate ( <int> ) ; DnsMessage dnsMessage = ( DnsMessage ) message ; encoder . encode ( buf , dnsMessage ) ; for ( ResourceRecord record : dnsMessage . getAnswerRecords ( ) ) { if ( record . getRecordType ( ) = = RecordType . AAAA ) { try { recordEncoder . put ( buf , record ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } } buf . flip ( ) ; out . write ( buf ) ; } } ; } @Override public ProtocolDecoder getDecoder ( IoSession session ) throws Exception { return new DnsUdpDecoder ( ) ; } private static final class TestAAAARecordEncoder extends ResourceRecordEncoder { @Override protected void putResourceRecordData ( IoBuffer ioBuffer , ResourceRecord resourceRecord ) { byte [ ] bytes = BYTES . get ( resourceRecord . get ( DnsAttribute . IP_ADDRESS ) ) ; if ( bytes = = null ) { throw new IllegalStateException ( ) ; } ioBuffer . put ( bytes ) ; } } } private static final class TestRecordStore implements RecordStore { private static final int [ ] NUMBERS = new int [ <int> ] ; private static final char [ ] CHARS = new char [ <int> ] ; static { for ( int i = <int> ; i < NUMBERS . length ; i + + ) { NUMBERS [ i ] = i + <int> ; } for ( int i = <int> ; i < CHARS . length ; i + + ) { CHARS [ i ] = ( char ) ( <str> + i ) ; } } private static int index ( int arrayLength ) { return Math . abs ( ThreadLocalRandom . current ( ) . nextInt ( ) ) % arrayLength ; } private static String nextDomain ( ) { return CHARS [ index ( CHARS . length ) ] + <str> ; } private static String nextIp ( ) { return ippart ( ) + <str> + ippart ( ) + <str> + ippart ( ) + <str> + ippart ( ) ; } private static int ippart ( ) { return NUMBERS [ index ( NUMBERS . length ) ] ; } private static String nextIp6 ( ) { return IPV6_ADDRESSES [ index ( IPV6_ADDRESSES . length ) ] ; } @Override public Set < ResourceRecord > getRecords ( QuestionRecord questionRecord ) { String name = questionRecord . getDomainName ( ) ; if ( DOMAINS . contains ( name ) ) { ResourceRecordModifier rm = new ResourceRecordModifier ( ) ; rm . setDnsClass ( RecordClass . IN ) ; rm . setDnsName ( name ) ; rm . setDnsTtl ( <int> ) ; rm . setDnsType ( questionRecord . getRecordType ( ) ) ; switch ( questionRecord . getRecordType ( ) ) { case A : do { rm . put ( DnsAttribute . IP_ADDRESS , nextIp ( ) ) ; } while ( ThreadLocalRandom . current ( ) . nextBoolean ( ) ) ; break ; case AAAA : do { rm . put ( DnsAttribute . IP_ADDRESS , nextIp6 ( ) ) ; } while ( ThreadLocalRandom . current ( ) . nextBoolean ( ) ) ; break ; case MX : int prioritity = <int> ; do { rm . put ( DnsAttribute . DOMAIN_NAME , nextDomain ( ) ) ; rm . put ( DnsAttribute . MX_PREFERENCE , String . valueOf ( + + prioritity ) ) ; } while ( ThreadLocalRandom . current ( ) . nextBoolean ( ) ) ; break ; default : return null ; } return Collections . singleton ( rm . getEntry ( ) ) ; } return null ; } } } } 
