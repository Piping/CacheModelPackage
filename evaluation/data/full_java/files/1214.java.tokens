package org . apache . cassandra . utils ; import java . lang . reflect . Field ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . security . AccessController ; import java . security . PrivilegedAction ; import com . google . common . primitives . * ; import net . nicoulaj . compilecommand . annotations . Inline ; import sun . misc . Unsafe ; public class FastByteOperations { public static int compareUnsigned ( byte [ ] b1 , int s1 , int l1 , byte [ ] b2 , int s2 , int l2 ) { return BestHolder . BEST . compare ( b1 , s1 , l1 , b2 , s2 , l2 ) ; } public static int compareUnsigned ( ByteBuffer b1 , byte [ ] b2 , int s2 , int l2 ) { return BestHolder . BEST . compare ( b1 , b2 , s2 , l2 ) ; } public static int compareUnsigned ( byte [ ] b1 , int s1 , int l1 , ByteBuffer b2 ) { return - BestHolder . BEST . compare ( b2 , b1 , s1 , l1 ) ; } public static int compareUnsigned ( ByteBuffer b1 , ByteBuffer b2 ) { return BestHolder . BEST . compare ( b1 , b2 ) ; } public static void copy ( ByteBuffer src , int srcPosition , byte [ ] trg , int trgPosition , int length ) { BestHolder . BEST . copy ( src , srcPosition , trg , trgPosition , length ) ; } public static void copy ( ByteBuffer src , int srcPosition , ByteBuffer trg , int trgPosition , int length ) { BestHolder . BEST . copy ( src , srcPosition , trg , trgPosition , length ) ; } public interface ByteOperations { abstract public int compare ( byte [ ] buffer1 , int offset1 , int length1 , byte [ ] buffer2 , int offset2 , int length2 ) ; abstract public int compare ( ByteBuffer buffer1 , byte [ ] buffer2 , int offset2 , int length2 ) ; abstract public int compare ( ByteBuffer buffer1 , ByteBuffer buffer2 ) ; abstract public void copy ( ByteBuffer src , int srcPosition , byte [ ] trg , int trgPosition , int length ) ; abstract public void copy ( ByteBuffer src , int srcPosition , ByteBuffer trg , int trgPosition , int length ) ; } private static class BestHolder { static final String UNSAFE_COMPARER_NAME = FastByteOperations . class . getName ( ) + <str> ; static final ByteOperations BEST = getBest ( ) ; static ByteOperations getBest ( ) { String arch = System . getProperty ( <str> ) ; boolean unaligned = arch . equals ( <str> ) | | arch . equals ( <str> ) | | arch . equals ( <str> ) | | arch . equals ( <str> ) ; if ( ! unaligned ) return new PureJavaOperations ( ) ; try { Class < ? > theClass = Class . forName ( UNSAFE_COMPARER_NAME ) ; @SuppressWarnings ( <str> ) ByteOperations comparer = ( ByteOperations ) theClass . getConstructor ( ) . newInstance ( ) ; return comparer ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; return new PureJavaOperations ( ) ; } } } @SuppressWarnings ( <str> ) public static final class UnsafeOperations implements ByteOperations { static final Unsafe theUnsafe ; static final long BYTE_ARRAY_BASE_OFFSET ; static final long DIRECT_BUFFER_ADDRESS_OFFSET ; static { theUnsafe = ( Unsafe ) AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { @Override public Object run ( ) { try { Field f = Unsafe . class . getDeclaredField ( <str> ) ; f . setAccessible ( true ) ; return f . get ( null ) ; } catch ( NoSuchFieldException e ) { throw new Error ( ) ; } catch ( IllegalAccessException e ) { throw new Error ( ) ; } } } ) ; try { BYTE_ARRAY_BASE_OFFSET = theUnsafe . arrayBaseOffset ( byte [ ] . class ) ; DIRECT_BUFFER_ADDRESS_OFFSET = theUnsafe . objectFieldOffset ( Buffer . class . getDeclaredField ( <str> ) ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } if ( theUnsafe . arrayIndexScale ( byte [ ] . class ) ! = <int> ) { throw new AssertionError ( ) ; } } static final boolean BIG_ENDIAN = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG_ENDIAN ) ; public int compare ( byte [ ] buffer1 , int offset1 , int length1 , byte [ ] buffer2 , int offset2 , int length2 ) { return compareTo ( buffer1 , BYTE_ARRAY_BASE_OFFSET + offset1 , length1 , buffer2 , BYTE_ARRAY_BASE_OFFSET + offset2 , length2 ) ; } public int compare ( ByteBuffer buffer1 , byte [ ] buffer2 , int offset2 , int length2 ) { Object obj1 ; long offset1 ; if ( buffer1 . hasArray ( ) ) { obj1 = buffer1 . array ( ) ; offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1 . arrayOffset ( ) ; } else { obj1 = null ; offset1 = theUnsafe . getLong ( buffer1 , DIRECT_BUFFER_ADDRESS_OFFSET ) ; } int length1 ; { int position = buffer1 . position ( ) ; int limit = buffer1 . limit ( ) ; length1 = limit - position ; offset1 + = position ; } return compareTo ( obj1 , offset1 , length1 , buffer2 , BYTE_ARRAY_BASE_OFFSET + offset2 , length2 ) ; } public int compare ( ByteBuffer buffer1 , ByteBuffer buffer2 ) { return compareTo ( buffer1 , buffer2 ) ; } public void copy ( ByteBuffer src , int srcPosition , byte [ ] trg , int trgPosition , int length ) { if ( src . hasArray ( ) ) System . arraycopy ( src . array ( ) , src . arrayOffset ( ) + srcPosition , trg , trgPosition , length ) ; else copy ( null , srcPosition + theUnsafe . getLong ( src , DIRECT_BUFFER_ADDRESS_OFFSET ) , trg , trgPosition , length ) ; } public void copy ( ByteBuffer srcBuf , int srcPosition , ByteBuffer trgBuf , int trgPosition , int length ) { Object src ; long srcOffset ; if ( srcBuf . hasArray ( ) ) { src = srcBuf . array ( ) ; srcOffset = BYTE_ARRAY_BASE_OFFSET + srcBuf . arrayOffset ( ) ; } else { src = null ; srcOffset = theUnsafe . getLong ( srcBuf , DIRECT_BUFFER_ADDRESS_OFFSET ) ; } copy ( src , srcOffset + srcPosition , trgBuf , trgPosition , length ) ; } public static void copy ( Object src , long srcOffset , ByteBuffer trgBuf , int trgPosition , int length ) { if ( trgBuf . hasArray ( ) ) copy ( src , srcOffset , trgBuf . array ( ) , trgBuf . arrayOffset ( ) + trgPosition , length ) ; else copy ( src , srcOffset , null , trgPosition + theUnsafe . getLong ( trgBuf , DIRECT_BUFFER_ADDRESS_OFFSET ) , length ) ; } public static void copy ( Object src , long srcOffset , byte [ ] trg , int trgPosition , int length ) { if ( length < = MIN_COPY_THRESHOLD ) { for ( int i = <int> ; i < length ; i + + ) trg [ trgPosition + i ] = theUnsafe . getByte ( src , srcOffset + i ) ; } else { copy ( src , srcOffset , trg , BYTE_ARRAY_BASE_OFFSET + trgPosition , length ) ; } } private static final long UNSAFE_COPY_THRESHOLD = <int> < < <int> ; private static final long MIN_COPY_THRESHOLD = <int> ; public static void copy ( Object src , long srcOffset , Object dst , long dstOffset , long length ) { while ( length > <int> ) { long size = ( length > UNSAFE_COPY_THRESHOLD ) ? UNSAFE_COPY_THRESHOLD : length ; theUnsafe . copyMemory ( src , srcOffset , dst , dstOffset , size ) ; length - = size ; srcOffset + = size ; dstOffset + = size ; } } @Inline public static int compareTo ( ByteBuffer buffer1 , ByteBuffer buffer2 ) { Object obj1 ; long offset1 ; int length1 ; if ( buffer1 . hasArray ( ) ) { obj1 = buffer1 . array ( ) ; offset1 = BYTE_ARRAY_BASE_OFFSET + buffer1 . arrayOffset ( ) ; } else { obj1 = null ; offset1 = theUnsafe . getLong ( buffer1 , DIRECT_BUFFER_ADDRESS_OFFSET ) ; } offset1 + = buffer1 . position ( ) ; length1 = buffer1 . remaining ( ) ; return compareTo ( obj1 , offset1 , length1 , buffer2 ) ; } @Inline public static int compareTo ( Object buffer1 , long offset1 , int length1 , ByteBuffer buffer ) { Object obj2 ; long offset2 ; int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; if ( buffer . hasArray ( ) ) { obj2 = buffer . array ( ) ; offset2 = BYTE_ARRAY_BASE_OFFSET + buffer . arrayOffset ( ) ; } else { obj2 = null ; offset2 = theUnsafe . getLong ( buffer , DIRECT_BUFFER_ADDRESS_OFFSET ) ; } int length2 = limit - position ; offset2 + = position ; return compareTo ( buffer1 , offset1 , length1 , obj2 , offset2 , length2 ) ; } @Inline public static int compareTo ( Object buffer1 , long memoryOffset1 , int length1 , Object buffer2 , long memoryOffset2 , int length2 ) { int minLength = Math . min ( length1 , length2 ) ; int wordComparisons = minLength & ~ <int> ; for ( int i = <int> ; i < wordComparisons ; i + = Longs . BYTES ) { long lw = theUnsafe . getLong ( buffer1 , memoryOffset1 + i ) ; long rw = theUnsafe . getLong ( buffer2 , memoryOffset2 + i ) ; if ( lw ! = rw ) { if ( BIG_ENDIAN ) return UnsignedLongs . compare ( lw , rw ) ; return UnsignedLongs . compare ( Long . reverseBytes ( lw ) , Long . reverseBytes ( rw ) ) ; } } for ( int i = wordComparisons ; i < minLength ; i + + ) { int b1 = theUnsafe . getByte ( buffer1 , memoryOffset1 + i ) & <hex> ; int b2 = theUnsafe . getByte ( buffer2 , memoryOffset2 + i ) & <hex> ; if ( b1 ! = b2 ) return b1 - b2 ; } return length1 - length2 ; } } @SuppressWarnings ( <str> ) public static final class PureJavaOperations implements ByteOperations { @Override public int compare ( byte [ ] buffer1 , int offset1 , int length1 , byte [ ] buffer2 , int offset2 , int length2 ) { if ( buffer1 = = buffer2 & & offset1 = = offset2 & & length1 = = length2 ) return <int> ; int end1 = offset1 + length1 ; int end2 = offset2 + length2 ; for ( int i = offset1 , j = offset2 ; i < end1 & & j < end2 ; i + + , j + + ) { int a = ( buffer1 [ i ] & <hex> ) ; int b = ( buffer2 [ j ] & <hex> ) ; if ( a ! = b ) { return a - b ; } } return length1 - length2 ; } public int compare ( ByteBuffer buffer1 , byte [ ] buffer2 , int offset2 , int length2 ) { if ( buffer1 . hasArray ( ) ) return compare ( buffer1 . array ( ) , buffer1 . arrayOffset ( ) + buffer1 . position ( ) , buffer1 . remaining ( ) , buffer2 , offset2 , length2 ) ; return compare ( buffer1 , ByteBuffer . wrap ( buffer2 , offset2 , length2 ) ) ; } public int compare ( ByteBuffer buffer1 , ByteBuffer buffer2 ) { int end1 = buffer1 . limit ( ) ; int end2 = buffer2 . limit ( ) ; for ( int i = buffer1 . position ( ) , j = buffer2 . position ( ) ; i < end1 & & j < end2 ; i + + , j + + ) { int a = ( buffer1 . get ( i ) & <hex> ) ; int b = ( buffer2 . get ( j ) & <hex> ) ; if ( a ! = b ) { return a - b ; } } return buffer1 . remaining ( ) - buffer2 . remaining ( ) ; } public void copy ( ByteBuffer src , int srcPosition , byte [ ] trg , int trgPosition , int length ) { if ( src . hasArray ( ) ) { System . arraycopy ( src . array ( ) , src . arrayOffset ( ) + srcPosition , trg , trgPosition , length ) ; return ; } src = src . duplicate ( ) ; src . position ( srcPosition ) ; src . get ( trg , trgPosition , length ) ; } public void copy ( ByteBuffer src , int srcPosition , ByteBuffer trg , int trgPosition , int length ) { if ( src . hasArray ( ) & & trg . hasArray ( ) ) { System . arraycopy ( src . array ( ) , src . arrayOffset ( ) + srcPosition , trg . array ( ) , trg . arrayOffset ( ) + trgPosition , length ) ; return ; } src = src . duplicate ( ) ; src . position ( srcPosition ) . limit ( srcPosition + length ) ; trg = trg . duplicate ( ) ; trg . position ( trgPosition ) ; trg . put ( src ) ; } } } 
