package org . elasticsearch . common . lucene ; import org . apache . lucene . analysis . MockAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . Field . Store ; import org . apache . lucene . document . StringField ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . * ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . MMapDirectory ; import org . apache . lucene . store . MockDirectoryWrapper ; import org . apache . lucene . util . Version ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; public class LuceneTests extends ESTestCase { public void testVersion ( ) { assertEquals ( Lucene . VERSION , Version . LATEST ) ; } public void testWaitForIndex ( ) throws Exception { final MockDirectoryWrapper dir = newMockDirectory ( ) ; final AtomicBoolean succeeded = new AtomicBoolean ( false ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; Thread t = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { latch . await ( ) ; if ( Lucene . waitForIndex ( dir , <int> ) ) { succeeded . set ( true ) ; } else { fail ( <str> ) ; } } catch ( InterruptedException e ) { } catch ( Exception e ) { fail ( <str> + e . getMessage ( ) ) ; } } } ) ; t . start ( ) ; latch . countDown ( ) ; dir . setEnableVirusScanner ( false ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; iwc . setIndexDeletionPolicy ( NoDeletionPolicy . INSTANCE ) ; iwc . setMergePolicy ( NoMergePolicy . INSTANCE ) ; iwc . setMaxBufferedDocs ( <int> ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; t . join ( ) ; writer . close ( ) ; dir . close ( ) ; assertTrue ( <str> , succeeded . get ( ) ) ; } public void testCleanIndex ( ) throws IOException { MockDirectoryWrapper dir = newMockDirectory ( ) ; dir . setEnableVirusScanner ( false ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; iwc . setIndexDeletionPolicy ( NoDeletionPolicy . INSTANCE ) ; iwc . setMergePolicy ( NoMergePolicy . INSTANCE ) ; iwc . setMaxBufferedDocs ( <int> ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . deleteDocuments ( new Term ( <str> , <str> ) ) ; writer . commit ( ) ; try ( DirectoryReader open = DirectoryReader . open ( writer , true ) ) { assertEquals ( <int> , open . numDocs ( ) ) ; assertEquals ( <int> , open . numDeletedDocs ( ) ) ; assertEquals ( <int> , open . maxDoc ( ) ) ; } writer . close ( ) ; if ( random ( ) . nextBoolean ( ) ) { for ( String file : dir . listAll ( ) ) { if ( file . startsWith ( <str> ) ) { dir . deleteFile ( file ) ; break ; } } } Lucene . cleanLuceneIndex ( dir ) ; if ( dir . listAll ( ) . length > <int> ) { for ( String file : dir . listAll ( ) ) { if ( file . startsWith ( <str> ) = = false ) { assertEquals ( file , <str> ) ; } } } dir . close ( ) ; } public void testPruneUnreferencedFiles ( ) throws IOException { MockDirectoryWrapper dir = newMockDirectory ( ) ; dir . setEnableVirusScanner ( false ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; iwc . setIndexDeletionPolicy ( NoDeletionPolicy . INSTANCE ) ; iwc . setMergePolicy ( NoMergePolicy . INSTANCE ) ; iwc . setMaxBufferedDocs ( <int> ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; SegmentInfos segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . deleteDocuments ( new Term ( <str> , <str> ) ) ; writer . commit ( ) ; DirectoryReader open = DirectoryReader . open ( writer , true ) ; assertEquals ( <int> , open . numDocs ( ) ) ; assertEquals ( <int> , open . numDeletedDocs ( ) ) ; assertEquals ( <int> , open . maxDoc ( ) ) ; open . close ( ) ; writer . close ( ) ; SegmentInfos si = Lucene . pruneUnreferencedFiles ( segmentCommitInfos . getSegmentsFileName ( ) , dir ) ; assertEquals ( si . getSegmentsFileName ( ) , segmentCommitInfos . getSegmentsFileName ( ) ) ; open = DirectoryReader . open ( dir ) ; assertEquals ( <int> , open . numDocs ( ) ) ; assertEquals ( <int> , open . numDeletedDocs ( ) ) ; assertEquals ( <int> , open . maxDoc ( ) ) ; IndexSearcher s = new IndexSearcher ( open ) ; assertEquals ( s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits , <int> ) ; assertEquals ( s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits , <int> ) ; assertEquals ( s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits , <int> ) ; assertEquals ( s . search ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) . totalHits , <int> ) ; for ( String file : dir . listAll ( ) ) { assertFalse ( <str> + file , file . equals ( <str> ) | | file . startsWith ( <str> ) ) ; } open . close ( ) ; dir . close ( ) ; } public void testFiles ( ) throws IOException { MockDirectoryWrapper dir = newMockDirectory ( ) ; dir . setEnableVirusScanner ( false ) ; IndexWriterConfig iwc = newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ; iwc . setMergePolicy ( NoMergePolicy . INSTANCE ) ; iwc . setMaxBufferedDocs ( <int> ) ; iwc . setUseCompoundFile ( true ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; Set < String > files = new HashSet < > ( ) ; for ( String f : Lucene . files ( Lucene . readSegmentInfos ( dir ) ) ) { files . add ( f ) ; } final boolean simpleTextCFS = files . contains ( <str> ) ; assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; if ( simpleTextCFS ) { assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; } else { assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; } assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; files . clear ( ) ; for ( String f : Lucene . files ( Lucene . readSegmentInfos ( dir ) ) ) { files . add ( f ) ; } assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; if ( simpleTextCFS ) { assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; } else { assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; } assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; if ( simpleTextCFS ) { assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; assertFalse ( files . toString ( ) , files . contains ( <str> ) ) ; } else { assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; } assertTrue ( files . toString ( ) , files . contains ( <str> ) ) ; writer . close ( ) ; dir . close ( ) ; } public void testNumDocs ( ) throws IOException { MockDirectoryWrapper dir = newMockDirectory ( ) ; dir . setEnableVirusScanner ( false ) ; IndexWriterConfig iwc = newIndexWriterConfig ( ) ; IndexWriter writer = new IndexWriter ( dir , iwc ) ; Document doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; writer . commit ( ) ; SegmentInfos segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; assertEquals ( <int> , Lucene . getNumDocs ( segmentCommitInfos ) ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; writer . addDocument ( doc ) ; segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; assertEquals ( <int> , Lucene . getNumDocs ( segmentCommitInfos ) ) ; writer . commit ( ) ; segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; assertEquals ( <int> , Lucene . getNumDocs ( segmentCommitInfos ) ) ; writer . deleteDocuments ( new Term ( <str> , <str> ) ) ; writer . commit ( ) ; segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; assertEquals ( <int> , Lucene . getNumDocs ( segmentCommitInfos ) ) ; int numDocsToIndex = randomIntBetween ( <int> , <int> ) ; List < Term > deleteTerms = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocsToIndex ; i + + ) { doc = new Document ( ) ; doc . add ( new TextField ( <str> , <str> + i , random ( ) . nextBoolean ( ) ? Field . Store . YES : Field . Store . NO ) ) ; deleteTerms . add ( new Term ( <str> , <str> + i ) ) ; writer . addDocument ( doc ) ; } int numDocsToDelete = randomIntBetween ( <int> , numDocsToIndex ) ; Collections . shuffle ( deleteTerms , random ( ) ) ; for ( int i = <int> ; i < numDocsToDelete ; i + + ) { Term remove = deleteTerms . remove ( <int> ) ; writer . deleteDocuments ( remove ) ; } writer . commit ( ) ; segmentCommitInfos = Lucene . readSegmentInfos ( dir ) ; assertEquals ( <int> + deleteTerms . size ( ) , Lucene . getNumDocs ( segmentCommitInfos ) ) ; writer . close ( ) ; dir . close ( ) ; } public void testCount ( ) throws Exception { Directory dir = newDirectory ( ) ; RandomIndexWriter w = new RandomIndexWriter ( getRandom ( ) , dir ) ; try ( DirectoryReader reader = w . getReader ( ) ) { IndexSearcher searcher = newSearcher ( reader ) ; assertFalse ( Lucene . exists ( searcher , new MatchAllDocsQuery ( ) ) ) ; } Document doc = new Document ( ) ; w . addDocument ( doc ) ; doc . add ( new StringField ( <str> , <str> , Store . NO ) ) ; w . addDocument ( doc ) ; try ( DirectoryReader reader = w . getReader ( ) ) { IndexSearcher searcher = newSearcher ( reader ) ; assertTrue ( Lucene . exists ( searcher , new MatchAllDocsQuery ( ) ) ) ; assertFalse ( Lucene . exists ( searcher , new TermQuery ( new Term ( <str> , <str> ) ) ) ) ; assertTrue ( Lucene . exists ( searcher , new TermQuery ( new Term ( <str> , <str> ) ) ) ) ; } w . deleteDocuments ( new Term ( <str> , <str> ) ) ; try ( DirectoryReader reader = w . getReader ( ) ) { IndexSearcher searcher = newSearcher ( reader ) ; assertFalse ( Lucene . exists ( searcher , new TermQuery ( new Term ( <str> , <str> ) ) ) ) ; } w . close ( ) ; dir . close ( ) ; } public void testMMapHackSupported ( ) throws Exception { assertTrue ( MMapDirectory . UNMAP_SUPPORTED ) ; } } 
