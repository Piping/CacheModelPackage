package org . apache . cassandra . utils . memory ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . utils . concurrent . OpOrder ; import org . apache . cassandra . utils . concurrent . WaitQueue ; public abstract class MemtableAllocator { private final SubAllocator onHeap ; private final SubAllocator offHeap ; volatile LifeCycle state = LifeCycle . LIVE ; static enum LifeCycle { LIVE , DISCARDING , DISCARDED ; LifeCycle transition ( LifeCycle targetState ) { switch ( targetState ) { case DISCARDING : assert this = = LifeCycle . LIVE ; return LifeCycle . DISCARDING ; case DISCARDED : assert this = = LifeCycle . DISCARDING ; return LifeCycle . DISCARDED ; default: throw new IllegalStateException ( ) ; } } } MemtableAllocator ( SubAllocator onHeap , SubAllocator offHeap ) { this . onHeap = onHeap ; this . offHeap = offHeap ; } public abstract Row . Builder rowBuilder ( OpOrder . Group opGroup ) ; public abstract DecoratedKey clone ( DecoratedKey key , OpOrder . Group opGroup ) ; public abstract DataReclaimer reclaimer ( ) ; public SubAllocator onHeap ( ) { return onHeap ; } public SubAllocator offHeap ( ) { return offHeap ; } public void setDiscarding ( ) { state = state . transition ( LifeCycle . DISCARDING ) ; onHeap . markAllReclaiming ( ) ; offHeap . markAllReclaiming ( ) ; } public void setDiscarded ( ) { state = state . transition ( LifeCycle . DISCARDED ) ; onHeap . releaseAll ( ) ; offHeap . releaseAll ( ) ; } public boolean isLive ( ) { return state = = LifeCycle . LIVE ; } public static interface DataReclaimer { public DataReclaimer reclaim ( Row row ) ; public DataReclaimer reclaimImmediately ( Row row ) ; public DataReclaimer reclaimImmediately ( DecoratedKey key ) ; public void cancel ( ) ; public void commit ( ) ; } public static final DataReclaimer NO_OP = new DataReclaimer ( ) { public DataReclaimer reclaim ( Row update ) { return this ; } public DataReclaimer reclaimImmediately ( Row update ) { return this ; } public DataReclaimer reclaimImmediately ( DecoratedKey key ) { return this ; } @Override public void cancel ( ) { } @Override public void commit ( ) { } } ; public static final class SubAllocator { private final MemtablePool . SubPool parent ; private volatile long owns ; private volatile long reclaiming ; SubAllocator ( MemtablePool . SubPool parent ) { this . parent = parent ; } void releaseAll ( ) { parent . released ( ownsUpdater . getAndSet ( this , <int> ) ) ; parent . reclaimed ( reclaimingUpdater . getAndSet ( this , <int> ) ) ; } public void adjust ( long size , OpOrder . Group opGroup ) { if ( size < = <int> ) released ( - size ) ; else allocate ( size , opGroup ) ; } public void allocate ( long size , OpOrder . Group opGroup ) { assert size > = <int> ; while ( true ) { if ( parent . tryAllocate ( size ) ) { acquired ( size ) ; return ; } WaitQueue . Signal signal = opGroup . isBlockingSignal ( parent . hasRoom ( ) . register ( ) ) ; boolean allocated = parent . tryAllocate ( size ) ; if ( allocated | | opGroup . isBlocking ( ) ) { signal . cancel ( ) ; if ( allocated ) acquired ( size ) ; else allocated ( size ) ; return ; } else signal . awaitUninterruptibly ( ) ; } } private void allocated ( long size ) { parent . allocated ( size ) ; ownsUpdater . addAndGet ( this , size ) ; } private void acquired ( long size ) { parent . acquired ( size ) ; ownsUpdater . addAndGet ( this , size ) ; } void released ( long size ) { parent . released ( size ) ; ownsUpdater . addAndGet ( this , - size ) ; } void markAllReclaiming ( ) { while ( true ) { long cur = owns ; long prev = reclaiming ; if ( ! reclaimingUpdater . compareAndSet ( this , prev , cur ) ) continue ; parent . reclaiming ( cur - prev ) ; return ; } } public long owns ( ) { return owns ; } public float ownershipRatio ( ) { float r = owns / ( float ) parent . limit ; if ( Float . isNaN ( r ) ) return <int> ; return r ; } private static final AtomicLongFieldUpdater < SubAllocator > ownsUpdater = AtomicLongFieldUpdater . newUpdater ( SubAllocator . class , <str> ) ; private static final AtomicLongFieldUpdater < SubAllocator > reclaimingUpdater = AtomicLongFieldUpdater . newUpdater ( SubAllocator . class , <str> ) ; } } 
