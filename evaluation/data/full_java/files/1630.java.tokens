package org . apache . cassandra . streaming ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . TimeUnit ; import com . google . common . collect . Iterables ; import com . google . common . util . concurrent . FutureCallback ; import com . google . common . util . concurrent . Futures ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import junit . framework . Assert ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . concurrent . Refs ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class StreamingTransferTest { private static final Logger logger = LoggerFactory . getLogger ( StreamingTransferTest . class ) ; public static final InetAddress LOCAL = FBUtilities . getBroadcastAddress ( ) ; public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; public static final String CF_COUNTER = <str> ; public static final String CF_STANDARDINT = <str> ; public static final String CF_INDEX = <str> ; public static final String KEYSPACE_CACHEKEY = <str> ; public static final String CF_STANDARD2 = <str> ; public static final String CF_STANDARD3 = <str> ; public static final String KEYSPACE2 = <str> ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; StorageService . instance . initServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) , CFMetaData . Builder . create ( KEYSPACE1 , CF_COUNTER , false , true , true ) . addPartitionKey ( <str> , BytesType . instance ) . build ( ) , CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARDINT ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , Int32Type . instance ) . addRegularColumn ( <str> , BytesType . instance ) . build ( ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE1 , CF_INDEX , true ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simple ( <int> ) ) ; SchemaLoader . createKeyspace ( KEYSPACE_CACHEKEY , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHEKEY , CF_STANDARD ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHEKEY , CF_STANDARD2 ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHEKEY , CF_STANDARD3 ) ) ; } @Test public void testEmptyStreamPlan ( ) throws Exception { StreamResultFuture futureResult = new StreamPlan ( <str> ) . execute ( ) ; final UUID planId = futureResult . planId ; Futures . addCallback ( futureResult , new FutureCallback < StreamState > ( ) { public void onSuccess ( StreamState result ) { assert planId . equals ( result . planId ) ; assert result . description . equals ( <str> ) ; assert result . sessions . isEmpty ( ) ; } public void onFailure ( Throwable t ) { fail ( ) ; } } ) ; futureResult . get ( <int> , TimeUnit . MILLISECONDS ) ; } @Test public void testRequestEmpty ( ) throws Exception { IPartitioner p = Util . testPartitioner ( ) ; List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( new Range < > ( p . getMinimumToken ( ) , p . getToken ( ByteBufferUtil . bytes ( <str> ) ) ) ) ; ranges . add ( new Range < > ( p . getToken ( ByteBufferUtil . bytes ( <str> ) ) , p . getMinimumToken ( ) ) ) ; StreamResultFuture futureResult = new StreamPlan ( <str> ) . requestRanges ( LOCAL , LOCAL , KEYSPACE2 , ranges ) . execute ( ) ; UUID planId = futureResult . planId ; StreamState result = futureResult . get ( ) ; assert planId . equals ( result . planId ) ; assert result . description . equals ( <str> ) ; assert result . sessions . size ( ) = = <int> ; SessionInfo session = Iterables . get ( result . sessions , <int> ) ; assert session . peer . equals ( LOCAL ) ; assert session . getTotalFilesReceived ( ) = = <int> ; assert session . getTotalFilesSent ( ) = = <int> ; assert session . getTotalSizeReceived ( ) = = <int> ; assert session . getTotalSizeSent ( ) = = <int> ; } private List < String > createAndTransfer ( ColumnFamilyStore cfs , Mutator mutator , boolean transferSSTables ) throws Exception { logger . debug ( <str> , cfs . name ) ; long timestamp = <int> ; for ( int i = <int> ; i < = <int> ; i + + ) mutator . mutate ( <str> + i , <str> + i , timestamp ) ; cfs . forceBlockingFlush ( ) ; Util . compactAll ( cfs , Integer . MAX_VALUE ) . get ( ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; logger . debug ( <str> , cfs . name ) ; int [ ] offs ; if ( transferSSTables ) { SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; cfs . clearUnsafe ( ) ; transferSSTables ( sstable ) ; offs = new int [ ] { <int> , <int> } ; } else { long beforeStreaming = System . currentTimeMillis ( ) ; transferRanges ( cfs ) ; cfs . discardSSTables ( beforeStreaming ) ; offs = new int [ ] { <int> , <int> } ; } assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; List < ImmutableBTreePartition > partitions = Util . getAllUnfiltered ( Util . cmd ( cfs ) . build ( ) ) ; assertEquals ( offs . length , partitions . size ( ) ) ; for ( int i = <int> ; i < offs . length ; i + + ) { String key = <str> + offs [ i ] ; String col = <str> + offs [ i ] ; assert ! Util . getAll ( Util . cmd ( cfs , key ) . build ( ) ) . isEmpty ( ) ; ImmutableBTreePartition partition = partitions . get ( i ) ; assert ByteBufferUtil . compareUnsigned ( partition . partitionKey ( ) . getKey ( ) , ByteBufferUtil . bytes ( key ) ) = = <int> ; assert ByteBufferUtil . compareUnsigned ( partition . iterator ( ) . next ( ) . clustering ( ) . get ( <int> ) , ByteBufferUtil . bytes ( col ) ) = = <int> ; } assertEquals ( timestamp , cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) . getMaxTimestamp ( ) ) ; List < String > keys = new ArrayList < > ( ) ; for ( int off : offs ) keys . add ( <str> + off ) ; logger . debug ( <str> , cfs . name ) ; return keys ; } private void transferSSTables ( SSTableReader sstable ) throws Exception { IPartitioner p = sstable . getPartitioner ( ) ; List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( new Range < > ( p . getMinimumToken ( ) , p . getToken ( ByteBufferUtil . bytes ( <str> ) ) ) ) ; ranges . add ( new Range < > ( p . getToken ( ByteBufferUtil . bytes ( <str> ) ) , p . getMinimumToken ( ) ) ) ; transfer ( sstable , ranges ) ; } private void transferRanges ( ColumnFamilyStore cfs ) throws Exception { IPartitioner p = cfs . getPartitioner ( ) ; List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( new Range < Token > ( p . getToken ( ByteBufferUtil . bytes ( <str> ) ) , p . getToken ( ByteBufferUtil . bytes ( <str> ) ) ) ) ; new StreamPlan ( <str> ) . transferRanges ( LOCAL , cfs . keyspace . getName ( ) , ranges , cfs . getColumnFamilyName ( ) ) . execute ( ) . get ( ) ; } private void transfer ( SSTableReader sstable , List < Range < Token > > ranges ) throws Exception { new StreamPlan ( <str> ) . transferFiles ( LOCAL , makeStreamingDetails ( ranges , Refs . tryRef ( Arrays . asList ( sstable ) ) ) ) . execute ( ) . get ( ) ; } private Collection < StreamSession . SSTableStreamingSections > makeStreamingDetails ( List < Range < Token > > ranges , Refs < SSTableReader > sstables ) { ArrayList < StreamSession . SSTableStreamingSections > details = new ArrayList < > ( ) ; for ( SSTableReader sstable : sstables ) { details . add ( new StreamSession . SSTableStreamingSections ( sstables . get ( sstable ) , sstable . getPositionsForRanges ( ranges ) , sstable . estimatedKeysForRanges ( ranges ) , sstable . getSSTableMetadata ( ) . repairedAt ) ) ; } return details ; } private void doTransferTable ( boolean transferSSTables ) throws Exception { final Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; final ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_INDEX ) ; List < String > keys = createAndTransfer ( cfs , new Mutator ( ) { public void mutate ( String key , String col , long timestamp ) throws Exception { long val = key . hashCode ( ) ; RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , timestamp , key ) ; builder . clustering ( col ) . add ( <str> , ByteBufferUtil . bytes ( val ) ) ; builder . build ( ) . applyUnsafe ( ) ; } } , transferSSTables ) ; for ( String key : keys ) { long val = key . hashCode ( ) ; UntypedResultSet result = QueryProcessor . executeInternal ( String . format ( <str> , cfs . metadata . ksName , cfs . metadata . cfName , val ) ) ; assertEquals ( <int> , result . size ( ) ) ; assert result . iterator ( ) . next ( ) . getBytes ( <str> ) . equals ( ByteBufferUtil . bytes ( key ) ) ; } } @Test public void testTransferRangeTombstones ( ) throws Exception { String ks = KEYSPACE1 ; String cfname = <str> ; Keyspace keyspace = Keyspace . open ( ks ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; ClusteringComparator comparator = cfs . getComparator ( ) ; String key = <str> ; RowUpdateBuilder updates = new RowUpdateBuilder ( cfs . metadata , FBUtilities . timestampMicros ( ) , key ) ; updates . clustering ( <int> ) . add ( <str> , ByteBuffer . wrap ( new byte [ DatabaseDescriptor . getColumnIndexSize ( ) - <int> ] ) ) . build ( ) . apply ( ) ; updates = new RowUpdateBuilder ( cfs . metadata , FBUtilities . timestampMicros ( ) , key ) ; updates . clustering ( <int> ) . add ( <str> , ByteBuffer . wrap ( new byte [ DatabaseDescriptor . getColumnIndexSize ( ) ] ) ) . build ( ) . apply ( ) ; updates = new RowUpdateBuilder ( cfs . metadata , FBUtilities . timestampMicros ( ) + <int> , key ) ; updates . addRangeTombstone ( Slice . make ( comparator . make ( <int> ) , comparator . make ( <int> ) ) ) . build ( ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; cfs . clearUnsafe ( ) ; transferSSTables ( sstable ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; Row r = Util . getOnlyRow ( Util . cmd ( cfs ) . build ( ) ) ; Assert . assertFalse ( r . isEmpty ( ) ) ; Assert . assertTrue ( <int> = = Int32Type . instance . compose ( r . clustering ( ) . get ( <int> ) ) ) ; } @Test public void testTransferTableViaRanges ( ) throws Exception { doTransferTable ( false ) ; } @Test public void testTransferTableViaSSTables ( ) throws Exception { doTransferTable ( true ) ; } public interface Mutator { public void mutate ( String key , String col , long timestamp ) throws Exception ; } } 
