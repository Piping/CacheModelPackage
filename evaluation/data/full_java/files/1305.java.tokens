package org . apache . cassandra . utils . memory ; import java . nio . ByteBuffer ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import com . google . common . util . concurrent . Uninterruptibles ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . utils . DynamicList ; import static org . junit . Assert . * ; public class LongBufferPoolTest { private static final Logger logger = LoggerFactory . getLogger ( LongBufferPoolTest . class ) ; @Test public void testAllocate ( ) throws InterruptedException , ExecutionException { testAllocate ( Runtime . getRuntime ( ) . availableProcessors ( ) * <int> , TimeUnit . MINUTES . toNanos ( <int> ) , <int> < < <int> ) ; } private static final class BufferCheck { final ByteBuffer buffer ; final long val ; DynamicList . Node < BufferCheck > listnode ; private BufferCheck ( ByteBuffer buffer , long val ) { this . buffer = buffer ; this . val = val ; } void validate ( ) { ByteBuffer read = buffer . duplicate ( ) ; while ( read . remaining ( ) > <int> ) assert read . getLong ( ) = = val ; } void init ( ) { ByteBuffer write = buffer . duplicate ( ) ; while ( write . remaining ( ) > <int> ) write . putLong ( val ) ; } } public void testAllocate ( int threadCount , long duration , int poolSize ) throws InterruptedException , ExecutionException { final int avgBufferSize = <int> < < <int> ; final int stdevBufferSize = <int> < < <int> ; final DateFormat dateFormat = new SimpleDateFormat ( <str> ) ; System . out . println ( String . format ( <str> , dateFormat . format ( new Date ( ) ) , threadCount , TimeUnit . NANOSECONDS . toMinutes ( duration ) ) ) ; final long until = System . nanoTime ( ) + duration ; final CountDownLatch latch = new CountDownLatch ( threadCount ) ; final SPSCQueue < BufferCheck > [ ] sharedRecycle = new SPSCQueue [ threadCount ] ; final AtomicBoolean [ ] makingProgress = new AtomicBoolean [ threadCount ] ; for ( int i = <int> ; i < sharedRecycle . length ; i + + ) { sharedRecycle [ i ] = new SPSCQueue < > ( ) ; makingProgress [ i ] = new AtomicBoolean ( true ) ; } ExecutorService executorService = Executors . newFixedThreadPool ( threadCount + <int> ) ; List < Future < Boolean > > ret = new ArrayList < > ( threadCount ) ; long prevPoolSize = BufferPool . MEMORY_USAGE_THRESHOLD ; BufferPool . MEMORY_USAGE_THRESHOLD = poolSize ; BufferPool . DEBUG = true ; int targetSizeQuanta = ( ( threadCount ) * ( threadCount - <int> ) ) / <int> ; targetSizeQuanta = ( targetSizeQuanta * poolSize ) / <int> ; { final SPSCQueue < ByteBuffer > burn = new SPSCQueue < > ( ) ; final CountDownLatch doneAdd = new CountDownLatch ( <int> ) ; executorService . submit ( new TestUntil ( until ) { int count = <int> ; void testOne ( ) throws Exception { if ( count * BufferPool . CHUNK_SIZE > = poolSize / <int> ) { if ( burn . exhausted ) count = <int> ; else Thread . yield ( ) ; return ; } ByteBuffer buffer = BufferPool . tryGet ( BufferPool . CHUNK_SIZE ) ; if ( buffer = = null ) { Thread . yield ( ) ; return ; } BufferPool . put ( buffer ) ; burn . add ( buffer ) ; count + + ; } void cleanup ( ) { doneAdd . countDown ( ) ; } } ) ; executorService . submit ( new TestUntil ( until ) { void testOne ( ) throws Exception { ByteBuffer buffer = burn . poll ( ) ; if ( buffer = = null ) { Thread . yield ( ) ; return ; } BufferPool . put ( buffer ) ; } void cleanup ( ) { Uninterruptibles . awaitUninterruptibly ( doneAdd ) ; } } ) ; } for ( int t = <int> ; t < threadCount ; t + + ) { final int threadIdx = t ; final int targetSize = t = = <int> ? BufferPool . CHUNK_SIZE : targetSizeQuanta * t ; ret . add ( executorService . submit ( new TestUntil ( until ) { final SPSCQueue < BufferCheck > shareFrom = sharedRecycle [ threadIdx ] ; final DynamicList < BufferCheck > checks = new DynamicList < > ( ( int ) Math . max ( <int> , targetSize / ( <int> < < <int> ) ) ) ; final SPSCQueue < BufferCheck > shareTo = sharedRecycle [ ( threadIdx + <int> ) % threadCount ] ; final ThreadLocalRandom rand = ThreadLocalRandom . current ( ) ; int totalSize = <int> ; int freeingSize = <int> ; int size = <int> ; void checkpoint ( ) { if ( ! makingProgress [ threadIdx ] . get ( ) ) makingProgress [ threadIdx ] . set ( true ) ; } void testOne ( ) throws Exception { long currentTargetSize = rand . nextInt ( poolSize / <int> ) = = <int> ? <int> : targetSize ; int spinCount = <int> ; while ( totalSize > currentTargetSize - freeingSize ) { if ( checks . size ( ) = = <int> ) { if ( shareTo . exhausted ) { totalSize - = freeingSize ; freeingSize = <int> ; } else if ( ! recycleFromNeighbour ( ) ) { if ( + + spinCount > <int> & & System . nanoTime ( ) > until ) return ; Thread . yield ( ) ; } continue ; } BufferCheck check = sample ( ) ; checks . remove ( check . listnode ) ; check . validate ( ) ; size = BufferPool . roundUpNormal ( check . buffer . capacity ( ) ) ; if ( size > BufferPool . CHUNK_SIZE ) size = <int> ; if ( rand . nextBoolean ( ) ) { shareTo . add ( check ) ; freeingSize + = size ; recycleFromNeighbour ( ) ; } else { check . validate ( ) ; BufferPool . put ( check . buffer ) ; totalSize - = size ; } } size = ( int ) Math . max ( <int> , avgBufferSize + ( stdevBufferSize * rand . nextGaussian ( ) ) ) ; if ( size < = BufferPool . CHUNK_SIZE ) { totalSize + = BufferPool . roundUpNormal ( size ) ; allocate ( size ) ; } else if ( rand . nextBoolean ( ) ) { allocate ( size ) ; } else { while ( totalSize < poolSize ) { size = ( int ) Math . max ( <int> , avgBufferSize + ( stdevBufferSize * rand . nextGaussian ( ) ) ) ; if ( size < = BufferPool . CHUNK_SIZE ) { allocate ( size ) ; totalSize + = BufferPool . roundUpNormal ( size ) ; } } } checks . get ( rand . nextInt ( checks . size ( ) ) ) . validate ( ) ; while ( recycleFromNeighbour ( ) ) ; } void cleanup ( ) { while ( checks . size ( ) > <int> ) { BufferCheck check = checks . get ( <int> ) ; BufferPool . put ( check . buffer ) ; checks . remove ( check . listnode ) ; } latch . countDown ( ) ; } boolean recycleFromNeighbour ( ) { BufferCheck check = shareFrom . poll ( ) ; if ( check = = null ) return false ; check . validate ( ) ; BufferPool . put ( check . buffer ) ; return true ; } BufferCheck allocate ( int size ) { ByteBuffer buffer = BufferPool . get ( size ) ; assertNotNull ( buffer ) ; BufferCheck check = new BufferCheck ( buffer , rand . nextLong ( ) ) ; assertEquals ( size , buffer . capacity ( ) ) ; assertEquals ( <int> , buffer . position ( ) ) ; check . init ( ) ; check . listnode = checks . append ( check ) ; return check ; } BufferCheck sample ( ) { int size = checks . size ( ) ; int sampleRange = sum1toN ( size ) ; int sampleIndex = rand . nextInt ( sampleRange ) ; int moveBy = Math . max ( size / <int> , <int> ) ; int index = size / <int> ; while ( true ) { int baseSampleIndex = sum1toN ( index ) ; int endOfSampleIndex = sum1toN ( index + <int> ) ; if ( sampleIndex > = baseSampleIndex ) { if ( sampleIndex < endOfSampleIndex ) break ; index + = moveBy ; } else index - = moveBy ; moveBy = Math . max ( moveBy / <int> , <int> ) ; } index = size - ( index + <int> ) ; return checks . get ( index ) ; } private int sum1toN ( int n ) { return ( n * ( n + <int> ) ) / <int> ; } } ) ) ; } boolean first = true ; while ( ! latch . await ( <int> , TimeUnit . SECONDS ) ) { if ( ! first ) BufferPool . assertAllRecycled ( ) ; first = false ; for ( AtomicBoolean progress : makingProgress ) { assert progress . get ( ) ; progress . set ( false ) ; } } for ( SPSCQueue < BufferCheck > queue : sharedRecycle ) { BufferCheck check ; while ( null ! = ( check = queue . poll ( ) ) ) { check . validate ( ) ; BufferPool . put ( check . buffer ) ; } } assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; BufferPool . MEMORY_USAGE_THRESHOLD = prevPoolSize ; for ( Future < Boolean > r : ret ) assertTrue ( r . get ( ) ) ; System . out . println ( String . format ( <str> , dateFormat . format ( new Date ( ) ) ) ) ; } static abstract class TestUntil implements Callable < Boolean > { final long until ; protected TestUntil ( long until ) { this . until = until ; } abstract void testOne ( ) throws Exception ; void checkpoint ( ) { } void cleanup ( ) { } public Boolean call ( ) throws Exception { try { while ( System . nanoTime ( ) < until ) { checkpoint ( ) ; for ( int i = <int> ; i < <int> ; i + + ) testOne ( ) ; } } catch ( Exception ex ) { logger . error ( <str> , ex . getMessage ( ) , BufferPool . currentChunk ( ) ) ; ex . printStackTrace ( ) ; return false ; } finally { cleanup ( ) ; } return true ; } } public static void main ( String [ ] args ) throws InterruptedException , ExecutionException { new LongBufferPoolTest ( ) . testAllocate ( Runtime . getRuntime ( ) . availableProcessors ( ) , TimeUnit . HOURS . toNanos ( <int> ) , <int> < < <int> ) ; } private static final class SPSCQueue < V > { static final class Node < V > { volatile Node < V > next ; final V value ; Node ( V value ) { this . value = value ; } } private volatile boolean exhausted = true ; Node < V > head = new Node < > ( null ) ; Node < V > tail = head ; void add ( V value ) { exhausted = false ; tail = tail . next = new Node < > ( value ) ; } V poll ( ) { Node < V > next = head . next ; if ( next = = null ) { exhausted = true ; return null ; } head = next ; return next . value ; } } } 
