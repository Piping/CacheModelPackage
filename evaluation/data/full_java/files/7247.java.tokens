package org . elasticsearch . search . aggregations . bucket . significant . heuristics ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class JLHScore extends SignificanceHeuristic { public static final JLHScore INSTANCE = new JLHScore ( ) ; protected static final String [ ] NAMES = { <str> } ; private JLHScore ( ) { } public static final SignificanceHeuristicStreams . Stream STREAM = new SignificanceHeuristicStreams . Stream ( ) { @Override public SignificanceHeuristic readResult ( StreamInput in ) throws IOException { return readFrom ( in ) ; } @Override public String getName ( ) { return NAMES [ <int> ] ; } } ; public static SignificanceHeuristic readFrom ( StreamInput in ) throws IOException { return INSTANCE ; } @Override public double getScore ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize ) { checkFrequencyValidity ( subsetFreq , subsetSize , supersetFreq , supersetSize , <str> ) ; if ( ( subsetSize = = <int> ) | | ( supersetSize = = <int> ) ) { return <int> ; } if ( supersetFreq = = <int> ) { supersetFreq = <int> ; } double subsetProbability = ( double ) subsetFreq / ( double ) subsetSize ; double supersetProbability = ( double ) supersetFreq / ( double ) supersetSize ; double absoluteProbabilityChange = subsetProbability - supersetProbability ; if ( absoluteProbabilityChange < = <int> ) { return <int> ; } double relativeProbabilityChange = ( subsetProbability / supersetProbability ) ; return absoluteProbabilityChange * relativeProbabilityChange ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; } public static class JLHScoreParser implements SignificanceHeuristicParser { @Override public SignificanceHeuristic parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher , SearchContext context ) throws IOException , QueryShardException { if ( ! parser . nextToken ( ) . equals ( XContentParser . Token . END_OBJECT ) ) { throw new ElasticsearchParseException ( <str> , parser . currentToken ( ) ) ; } return new JLHScore ( ) ; } @Override public String [ ] getNames ( ) { return NAMES ; } } public static class JLHScoreBuilder implements SignificanceHeuristicBuilder { @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( STREAM . getName ( ) ) . endObject ( ) ; return builder ; } } } 
