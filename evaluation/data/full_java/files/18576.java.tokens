package com . badlogic . gdx . tests ; import java . util . Random ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . SpriteCache ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . OrthoCamController ; import com . badlogic . gdx . utils . TimeUtils ; public class TileTest extends GdxTest { static final int LAYERS = <int> ; static final int BLOCK_TILES = <int> ; static final int WIDTH = <int> ; static final int HEIGHT = <int> ; static final int TILES_PER_LAYER = WIDTH * HEIGHT ; SpriteCache [ ] caches = new SpriteCache [ LAYERS ] ; Texture texture ; int [ ] layers = new int [ LAYERS ] ; OrthographicCamera cam ; OrthoCamController camController ; long startTime = TimeUtils . nanoTime ( ) ; @Override public void create ( ) { cam = new OrthographicCamera ( <int> , <int> ) ; cam . position . set ( WIDTH * <int> / <int> , HEIGHT * <int> / <int> , <int> ) ; camController = new OrthoCamController ( cam ) ; Gdx . input . setInputProcessor ( camController ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; Random rand = new Random ( ) ; for ( int i = <int> ; i < LAYERS ; i + + ) { caches [ i ] = new SpriteCache ( ) ; SpriteCache cache = caches [ i ] ; cache . beginCache ( ) ; for ( int y = <int> ; y < HEIGHT ; y + + ) { for ( int x = <int> ; x < WIDTH ; x + + ) { int tileX = rand . nextInt ( <int> ) ; int tileY = rand . nextInt ( <int> ) ; cache . add ( texture , x < < <int> , y < < <int> , <int> + tileX * <int> , <int> + tileY * <int> , <int> , <int> ) ; } } layers [ i ] = cache . endCache ( ) ; } } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; cam . update ( ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; Gdx . gl . glBlendFunc ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; for ( int i = <int> ; i < LAYERS ; i + + ) { SpriteCache cache = caches [ i ] ; cache . setProjectionMatrix ( cam . combined ) ; cache . begin ( ) ; for ( int j = <int> ; j < TILES_PER_LAYER ; j + = BLOCK_TILES ) { cache . draw ( layers [ i ] , j , BLOCK_TILES ) ; } cache . end ( ) ; } if ( TimeUtils . nanoTime ( ) - startTime > = <int> ) { Gdx . app . log ( <str> , <str> + Gdx . graphics . getFramesPerSecond ( ) ) ; startTime = TimeUtils . nanoTime ( ) ; } } } 
