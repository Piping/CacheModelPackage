package org . apache . cassandra . io . sstable ; import java . util . * ; public class Downsampling { public static final int BASE_SAMPLING_LEVEL = <int> ; private static final Map < Integer , List < Integer > > samplePatternCache = new HashMap < > ( ) ; private static final Map < Integer , List < Integer > > originalIndexCache = new HashMap < > ( ) ; public static List < Integer > getSamplingPattern ( int samplingLevel ) { List < Integer > pattern = samplePatternCache . get ( samplingLevel ) ; if ( pattern ! = null ) return pattern ; if ( samplingLevel < = <int> ) return Arrays . asList ( <int> ) ; int [ ] odds = new int [ samplingLevel / <int> ] ; int [ ] evens = new int [ samplingLevel / <int> ] ; for ( int i = <int> ; i < samplingLevel ; i + = <int> ) odds [ i / <int> ] = i ; for ( int i = <int> ; i < samplingLevel ; i + = <int> ) evens [ i / <int> ] = i ; List < Integer > ordering = getSamplingPattern ( samplingLevel / <int> ) ; List < Integer > startIndices = new ArrayList < > ( samplingLevel ) ; for ( Integer index : ordering ) startIndices . add ( odds [ index ] ) ; for ( Integer index : ordering ) startIndices . add ( evens [ index ] ) ; samplePatternCache . put ( samplingLevel , startIndices ) ; return startIndices ; } public static List < Integer > getOriginalIndexes ( int samplingLevel ) { List < Integer > originalIndexes = originalIndexCache . get ( samplingLevel ) ; if ( originalIndexes ! = null ) return originalIndexes ; List < Integer > pattern = getSamplingPattern ( BASE_SAMPLING_LEVEL ) . subList ( <int> , BASE_SAMPLING_LEVEL - samplingLevel ) ; originalIndexes = new ArrayList < > ( samplingLevel ) ; for ( int j = <int> ; j < BASE_SAMPLING_LEVEL ; j + + ) { if ( ! pattern . contains ( j ) ) originalIndexes . add ( j ) ; } originalIndexCache . put ( samplingLevel , originalIndexes ) ; return originalIndexes ; } public static int getEffectiveIndexIntervalAfterIndex ( int index , int samplingLevel , int minIndexInterval ) { assert index > = <int> ; index % = samplingLevel ; List < Integer > originalIndexes = getOriginalIndexes ( samplingLevel ) ; int nextEntryOriginalIndex = ( index = = originalIndexes . size ( ) - <int> ) ? BASE_SAMPLING_LEVEL : originalIndexes . get ( index + <int> ) ; return ( nextEntryOriginalIndex - originalIndexes . get ( index ) ) * minIndexInterval ; } public static int [ ] getStartPoints ( int currentSamplingLevel , int newSamplingLevel ) { List < Integer > allStartPoints = getSamplingPattern ( BASE_SAMPLING_LEVEL ) ; int initialRound = BASE_SAMPLING_LEVEL - currentSamplingLevel ; int numRounds = Math . abs ( currentSamplingLevel - newSamplingLevel ) ; int [ ] startPoints = new int [ numRounds ] ; for ( int i = <int> ; i < numRounds ; + + i ) { int start = allStartPoints . get ( initialRound + i ) ; int adjustment = <int> ; for ( int j = <int> ; j < initialRound ; + + j ) { if ( allStartPoints . get ( j ) < start ) adjustment + + ; } startPoints [ i ] = start - adjustment ; } return startPoints ; } } 
