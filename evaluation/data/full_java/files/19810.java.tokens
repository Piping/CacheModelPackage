package io . netty . example . http . snoop ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpObject ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . QueryStringDecoder ; import io . netty . handler . codec . http . cookie . Cookie ; import io . netty . handler . codec . http . cookie . ServerCookieDecoder ; import io . netty . handler . codec . http . cookie . ServerCookieEncoder ; import io . netty . util . CharsetUtil ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . * ; public class HttpSnoopServerHandler extends SimpleChannelInboundHandler < Object > { private HttpRequest request ; private final StringBuilder buf = new StringBuilder ( ) ; @Override public void channelReadComplete ( ChannelHandlerContext ctx ) { ctx . flush ( ) ; } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) { if ( msg instanceof HttpRequest ) { HttpRequest request = this . request = ( HttpRequest ) msg ; if ( HttpUtil . is100ContinueExpected ( request ) ) { send100Continue ( ctx ) ; } buf . setLength ( <int> ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( <str> ) . append ( request . protocolVersion ( ) ) . append ( <str> ) ; buf . append ( <str> ) . append ( request . headers ( ) . get ( HttpHeaderNames . HOST , <str> ) ) . append ( <str> ) ; buf . append ( <str> ) . append ( request . uri ( ) ) . append ( <str> ) ; HttpHeaders headers = request . headers ( ) ; if ( ! headers . isEmpty ( ) ) { for ( Map . Entry < String , String > h : headers ) { CharSequence key = h . getKey ( ) ; CharSequence value = h . getValue ( ) ; buf . append ( <str> ) . append ( key ) . append ( <str> ) . append ( value ) . append ( <str> ) ; } buf . append ( <str> ) ; } QueryStringDecoder queryStringDecoder = new QueryStringDecoder ( request . uri ( ) ) ; Map < String , List < String > > params = queryStringDecoder . parameters ( ) ; if ( ! params . isEmpty ( ) ) { for ( Entry < String , List < String > > p : params . entrySet ( ) ) { String key = p . getKey ( ) ; List < String > vals = p . getValue ( ) ; for ( String val : vals ) { buf . append ( <str> ) . append ( key ) . append ( <str> ) . append ( val ) . append ( <str> ) ; } } buf . append ( <str> ) ; } appendDecoderResult ( buf , request ) ; } if ( msg instanceof HttpContent ) { HttpContent httpContent = ( HttpContent ) msg ; ByteBuf content = httpContent . content ( ) ; if ( content . isReadable ( ) ) { buf . append ( <str> ) ; buf . append ( content . toString ( CharsetUtil . UTF_8 ) ) ; buf . append ( <str> ) ; appendDecoderResult ( buf , request ) ; } if ( msg instanceof LastHttpContent ) { buf . append ( <str> ) ; LastHttpContent trailer = ( LastHttpContent ) msg ; if ( ! trailer . trailingHeaders ( ) . isEmpty ( ) ) { buf . append ( <str> ) ; for ( CharSequence name : trailer . trailingHeaders ( ) . names ( ) ) { for ( CharSequence value : trailer . trailingHeaders ( ) . getAll ( name ) ) { buf . append ( <str> ) ; buf . append ( name ) . append ( <str> ) . append ( value ) . append ( <str> ) ; } } buf . append ( <str> ) ; } if ( ! writeResponse ( trailer , ctx ) ) { ctx . writeAndFlush ( Unpooled . EMPTY_BUFFER ) . addListener ( ChannelFutureListener . CLOSE ) ; } } } } private static void appendDecoderResult ( StringBuilder buf , HttpObject o ) { DecoderResult result = o . decoderResult ( ) ; if ( result . isSuccess ( ) ) { return ; } buf . append ( <str> ) ; buf . append ( result . cause ( ) ) ; buf . append ( <str> ) ; } private boolean writeResponse ( HttpObject currentObj , ChannelHandlerContext ctx ) { boolean keepAlive = HttpUtil . isKeepAlive ( request ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , currentObj . decoderResult ( ) . isSuccess ( ) ? OK : BAD_REQUEST , Unpooled . copiedBuffer ( buf . toString ( ) , CharsetUtil . UTF_8 ) ) ; response . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> ) ; if ( keepAlive ) { response . headers ( ) . setInt ( HttpHeaderNames . CONTENT_LENGTH , response . content ( ) . readableBytes ( ) ) ; response . headers ( ) . set ( HttpHeaderNames . CONNECTION , HttpHeaderValues . KEEP_ALIVE ) ; } String cookieString = request . headers ( ) . get ( HttpHeaderNames . COOKIE ) ; if ( cookieString ! = null ) { Set < Cookie > cookies = ServerCookieDecoder . STRICT . decode ( cookieString ) ; if ( ! cookies . isEmpty ( ) ) { for ( Cookie cookie : cookies ) { response . headers ( ) . add ( HttpHeaderNames . SET_COOKIE , ServerCookieEncoder . STRICT . encode ( cookie ) ) ; } } } else { response . headers ( ) . add ( HttpHeaderNames . SET_COOKIE , ServerCookieEncoder . STRICT . encode ( <str> , <str> ) ) ; response . headers ( ) . add ( HttpHeaderNames . SET_COOKIE , ServerCookieEncoder . STRICT . encode ( <str> , <str> ) ) ; } ctx . write ( response ) ; return keepAlive ; } private static void send100Continue ( ChannelHandlerContext ctx ) { FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , CONTINUE ) ; ctx . write ( response ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } } 
