package com . badlogic . gdx . tools . ktx ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . nio . ByteBuffer ; import java . util . zip . GZIPOutputStream ; import com . badlogic . gdx . ApplicationAdapter ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . backends . headless . HeadlessApplication ; import com . badlogic . gdx . backends . lwjgl . LwjglNativesLoader ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Pixmap . Filter ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . glutils . ETC1 ; import com . badlogic . gdx . graphics . glutils . ETC1 . ETC1Data ; import com . badlogic . gdx . graphics . glutils . KTXTextureData ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class KTXProcessor { final static byte [ ] HEADER_MAGIC = { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; public static void convert ( String input , String output , boolean genMipmaps , boolean packETC1 , boolean genAlphaAtlas ) throws Exception { Array < String > opts = new Array < String > ( String . class ) ; opts . add ( input ) ; opts . add ( output ) ; if ( genMipmaps ) opts . add ( <str> ) ; if ( packETC1 & & ! genAlphaAtlas ) opts . add ( <str> ) ; if ( packETC1 & & genAlphaAtlas ) opts . add ( <str> ) ; main ( opts . toArray ( ) ) ; } public static void convert ( String inPx , String inNx , String inPy , String inNy , String inPz , String inNz , String output , boolean genMipmaps , boolean packETC1 , boolean genAlphaAtlas ) throws Exception { Array < String > opts = new Array < String > ( String . class ) ; opts . add ( inPx ) ; opts . add ( inNx ) ; opts . add ( inPy ) ; opts . add ( inNy ) ; opts . add ( inPz ) ; opts . add ( inNz ) ; opts . add ( output ) ; if ( genMipmaps ) opts . add ( <str> ) ; if ( packETC1 & & ! genAlphaAtlas ) opts . add ( <str> ) ; if ( packETC1 & & genAlphaAtlas ) opts . add ( <str> ) ; main ( opts . toArray ( ) ) ; } private final static int DISPOSE_DONT = <int> ; private final static int DISPOSE_PACK = <int> ; private final static int DISPOSE_FACE = <int> ; private final static int DISPOSE_LEVEL = <int> ; public static void main ( String [ ] args ) { new HeadlessApplication ( new KTXProcessorListener ( args ) ) ; } public static class KTXProcessorListener extends ApplicationAdapter { String [ ] args ; KTXProcessorListener ( String [ ] args ) { this . args = args ; } @Override public void create ( ) { boolean isCubemap = args . length = = <int> | | args . length = = <int> | | args . length = = <int> ; boolean isTexture = args . length = = <int> | | args . length = = <int> | | args . length = = <int> ; boolean isPackETC1 = false , isAlphaAtlas = false , isGenMipMaps = false ; if ( ! isCubemap & & ! isTexture ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . exit ( - <int> ) ; } LwjglNativesLoader . load ( ) ; for ( int i = <int> ; i < args . length ; i + + ) { System . out . println ( i + <str> + args [ i ] ) ; if ( isTexture & & i < <int> ) continue ; if ( isCubemap & & i < <int> ) continue ; if ( <str> . equals ( args [ i ] ) ) isPackETC1 = true ; if ( <str> . equals ( args [ i ] ) ) isAlphaAtlas = isPackETC1 = true ; if ( <str> . equals ( args [ i ] ) ) isGenMipMaps = true ; } File output = new File ( args [ isCubemap ? <int> : <int> ] ) ; int ktxDispose = DISPOSE_DONT ; KTXTextureData ktx = null ; FileHandle file = new FileHandle ( args [ <int> ] ) ; if ( file . name ( ) . toLowerCase ( ) . endsWith ( <str> ) | | file . name ( ) . toLowerCase ( ) . endsWith ( <str> ) ) { ktx = new KTXTextureData ( file , false ) ; if ( ktx . getNumberOfFaces ( ) = = <int> ) isCubemap = true ; ktxDispose = DISPOSE_PACK ; } int nFaces = isCubemap ? <int> : <int> ; Image [ ] [ ] images = new Image [ nFaces ] [ ] ; Pixmap . setBlending ( Blending . None ) ; Pixmap . setFilter ( Filter . BiLinear ) ; int texWidth = - <int> , texHeight = - <int> , texFormat = - <int> , nLevels = <int> ; for ( int face = <int> ; face < nFaces ; face + + ) { ETC1Data etc1 = null ; Pixmap facePixmap = null ; int ktxFace = <int> ; if ( ktx ! = null & & ktx . getNumberOfFaces ( ) = = <int> ) { nLevels = ktx . getNumberOfMipMapLevels ( ) ; ktxFace = face ; } else { file = new FileHandle ( args [ face ] ) ; System . out . println ( <str> + file + <str> + face ) ; if ( file . name ( ) . toLowerCase ( ) . endsWith ( <str> ) | | file . name ( ) . toLowerCase ( ) . endsWith ( <str> ) ) { if ( ktx = = null | | ktx . getNumberOfFaces ( ) ! = <int> ) { ktxDispose = DISPOSE_FACE ; ktx = new KTXTextureData ( file , false ) ; ktx . prepare ( ) ; } nLevels = ktx . getNumberOfMipMapLevels ( ) ; texWidth = ktx . getWidth ( ) ; texHeight = ktx . getHeight ( ) ; } else if ( file . name ( ) . toLowerCase ( ) . endsWith ( <str> ) ) { etc1 = new ETC1Data ( file ) ; nLevels = <int> ; texWidth = etc1 . width ; texHeight = etc1 . height ; } else { facePixmap = new Pixmap ( file ) ; nLevels = <int> ; texWidth = facePixmap . getWidth ( ) ; texHeight = facePixmap . getHeight ( ) ; } if ( isGenMipMaps ) { if ( ! MathUtils . isPowerOfTwo ( texWidth ) | | ! MathUtils . isPowerOfTwo ( texHeight ) ) throw new GdxRuntimeException ( <str> + file ) ; nLevels = Math . max ( Integer . SIZE - Integer . numberOfLeadingZeros ( texWidth ) , Integer . SIZE - Integer . numberOfLeadingZeros ( texHeight ) ) ; } } images [ face ] = new Image [ nLevels ] ; for ( int level = <int> ; level < nLevels ; level + + ) { int levelWidth = Math . max ( <int> , texWidth > > level ) ; int levelHeight = Math . max ( <int> , texHeight > > level ) ; Pixmap levelPixmap = null ; ETC1Data levelETCData = null ; if ( ktx ! = null ) { ByteBuffer ktxData = ktx . getData ( level , ktxFace ) ; if ( ktxData ! = null & & ktx . getGlInternalFormat ( ) = = ETC1 . ETC1_RGB8_OES ) levelETCData = new ETC1Data ( levelWidth , levelHeight , ktxData , <int> ) ; } if ( ktx ! = null & & levelETCData = = null & & facePixmap = = null ) { ByteBuffer ktxData = ktx . getData ( <int> , ktxFace ) ; if ( ktxData ! = null & & ktx . getGlInternalFormat ( ) = = ETC1 . ETC1_RGB8_OES ) facePixmap = ETC1 . decodeImage ( new ETC1Data ( levelWidth , levelHeight , ktxData , <int> ) , Format . RGB888 ) ; } if ( level = = <int> & & etc1 ! = null ) { levelETCData = etc1 ; } if ( levelETCData = = null & & etc1 ! = null & & facePixmap = = null ) { facePixmap = ETC1 . decodeImage ( etc1 , Format . RGB888 ) ; } if ( levelETCData = = null ) { levelPixmap = new Pixmap ( levelWidth , levelHeight , facePixmap . getFormat ( ) ) ; levelPixmap . drawPixmap ( facePixmap , <int> , <int> , facePixmap . getWidth ( ) , facePixmap . getHeight ( ) , <int> , <int> , levelPixmap . getWidth ( ) , levelPixmap . getHeight ( ) ) ; } if ( levelETCData = = null & & levelPixmap = = null ) throw new GdxRuntimeException ( <str> + face + <str> + level ) ; if ( isAlphaAtlas ) { if ( levelPixmap = = null ) levelPixmap = ETC1 . decodeImage ( levelETCData , Format . RGB888 ) ; int w = levelPixmap . getWidth ( ) , h = levelPixmap . getHeight ( ) ; Pixmap pm = new Pixmap ( w , h * <int> , levelPixmap . getFormat ( ) ) ; pm . drawPixmap ( levelPixmap , <int> , <int> ) ; for ( int y = <int> ; y < h ; y + + ) { for ( int x = <int> ; x < w ; x + + ) { int alpha = ( levelPixmap . getPixel ( x , y ) ) & <hex> ; pm . drawPixel ( x , y + h , ( alpha < < <int> ) | ( alpha < < <int> ) | ( alpha < < <int> ) | <hex> ) ; } } levelPixmap . dispose ( ) ; levelPixmap = pm ; levelETCData = null ; } if ( levelETCData = = null & & isPackETC1 ) { if ( levelPixmap . getFormat ( ) ! = Format . RGB888 & & levelPixmap . getFormat ( ) ! = Format . RGB565 ) { if ( ! isAlphaAtlas ) System . out . println ( <str> + levelPixmap . getFormat ( ) + <str> ) ; Pixmap tmp = new Pixmap ( levelPixmap . getWidth ( ) , levelPixmap . getHeight ( ) , Format . RGB888 ) ; tmp . drawPixmap ( levelPixmap , <int> , <int> , <int> , <int> , levelPixmap . getWidth ( ) , levelPixmap . getHeight ( ) ) ; levelPixmap . dispose ( ) ; levelPixmap = tmp ; } levelETCData = ETC1 . encodeImagePKM ( levelPixmap ) ; levelPixmap . dispose ( ) ; levelPixmap = null ; } images [ face ] [ level ] = new Image ( ) ; images [ face ] [ level ] . etcData = levelETCData ; images [ face ] [ level ] . pixmap = levelPixmap ; if ( levelPixmap ! = null ) { levelPixmap . dispose ( ) ; facePixmap = null ; } } if ( facePixmap ! = null ) { facePixmap . dispose ( ) ; facePixmap = null ; } if ( etc1 ! = null ) { etc1 . dispose ( ) ; etc1 = null ; } if ( ktx ! = null & & ktxDispose = = DISPOSE_FACE ) { ktx . disposePreparedData ( ) ; ktx = null ; } } if ( ktx ! = null ) { ktx . disposePreparedData ( ) ; ktx = null ; } int glType , glTypeSize , glFormat , glInternalFormat , glBaseInternalFormat ; if ( isPackETC1 ) { glType = glFormat = <int> ; glTypeSize = <int> ; glInternalFormat = ETC1 . ETC1_RGB8_OES ; glBaseInternalFormat = GL20 . GL_RGB ; } else if ( images [ <int> ] [ <int> ] . pixmap ! = null ) { glType = images [ <int> ] [ <int> ] . pixmap . getGLType ( ) ; glTypeSize = <int> ; glFormat = images [ <int> ] [ <int> ] . pixmap . getGLFormat ( ) ; glInternalFormat = images [ <int> ] [ <int> ] . pixmap . getGLInternalFormat ( ) ; glBaseInternalFormat = glFormat ; } else throw new GdxRuntimeException ( <str> ) ; int totalSize = <int> + <int> * <int> ; for ( int level = <int> ; level < nLevels ; level + + ) { System . out . println ( <str> + level ) ; int faceLodSize = images [ <int> ] [ level ] . getSize ( ) ; int faceLodSizeRounded = ( faceLodSize + <int> ) & ~ <int> ; totalSize + = <int> ; totalSize + = nFaces * faceLodSizeRounded ; } try { DataOutputStream out ; if ( output . getName ( ) . toLowerCase ( ) . endsWith ( <str> ) ) { out = new DataOutputStream ( new GZIPOutputStream ( new FileOutputStream ( output ) ) ) ; out . writeInt ( totalSize ) ; } else out = new DataOutputStream ( new FileOutputStream ( output ) ) ; out . write ( HEADER_MAGIC ) ; out . writeInt ( <hex> ) ; out . writeInt ( glType ) ; out . writeInt ( glTypeSize ) ; out . writeInt ( glFormat ) ; out . writeInt ( glInternalFormat ) ; out . writeInt ( glBaseInternalFormat ) ; out . writeInt ( texWidth ) ; out . writeInt ( isAlphaAtlas ? ( <int> * texHeight ) : texHeight ) ; out . writeInt ( <int> ) ; out . writeInt ( <int> ) ; out . writeInt ( nFaces ) ; out . writeInt ( nLevels ) ; out . writeInt ( <int> ) ; for ( int level = <int> ; level < nLevels ; level + + ) { int faceLodSize = images [ <int> ] [ level ] . getSize ( ) ; int faceLodSizeRounded = ( faceLodSize + <int> ) & ~ <int> ; out . writeInt ( faceLodSize ) ; for ( int face = <int> ; face < nFaces ; face + + ) { byte [ ] bytes = images [ face ] [ level ] . getBytes ( ) ; out . write ( bytes ) ; for ( int j = bytes . length ; j < faceLodSizeRounded ; j + + ) out . write ( ( byte ) <hex> ) ; } } out . close ( ) ; } catch ( Exception e ) { Gdx . app . error ( <str> , <str> + output . getName ( ) , e ) ; } } } private static class Image { public ETC1Data etcData ; public Pixmap pixmap ; public Image ( ) { } public int getSize ( ) { if ( etcData ! = null ) return etcData . compressedData . limit ( ) - etcData . dataOffset ; throw new GdxRuntimeException ( <str> ) ; } public byte [ ] getBytes ( ) { if ( etcData ! = null ) { byte [ ] result = new byte [ getSize ( ) ] ; etcData . compressedData . position ( etcData . dataOffset ) ; etcData . compressedData . get ( result ) ; return result ; } throw new GdxRuntimeException ( <str> ) ; } } } 
