package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . buffer . UnpooledDirectByteBuf ; import io . netty . buffer . UnpooledUnsafeDirectByteBuf ; import io . netty . util . Recycler ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; final class ThreadLocalPooledDirectByteBuf { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ThreadLocalPooledDirectByteBuf . class ) ; public static final int threadLocalDirectBufferSize ; static { threadLocalDirectBufferSize = SystemPropertyUtil . getInt ( <str> , <int> * <int> ) ; logger . debug ( <str> , threadLocalDirectBufferSize ) ; } public static ByteBuf newInstance ( ) { if ( PlatformDependent . hasUnsafe ( ) ) { return ThreadLocalUnsafeDirectByteBuf . newInstance ( ) ; } else { return ThreadLocalDirectByteBuf . newInstance ( ) ; } } private ThreadLocalPooledDirectByteBuf ( ) { } static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf { private static final Recycler < ThreadLocalUnsafeDirectByteBuf > RECYCLER = new Recycler < ThreadLocalUnsafeDirectByteBuf > ( ) { @Override protected ThreadLocalUnsafeDirectByteBuf newObject ( Handle < ThreadLocalUnsafeDirectByteBuf > handle ) { return new ThreadLocalUnsafeDirectByteBuf ( handle ) ; } } ; static ThreadLocalUnsafeDirectByteBuf newInstance ( ) { ThreadLocalUnsafeDirectByteBuf buf = RECYCLER . get ( ) ; buf . setRefCnt ( <int> ) ; return buf ; } private final Recycler . Handle < ThreadLocalUnsafeDirectByteBuf > handle ; private ThreadLocalUnsafeDirectByteBuf ( Recycler . Handle < ThreadLocalUnsafeDirectByteBuf > handle ) { super ( UnpooledByteBufAllocator . DEFAULT , <int> , Integer . MAX_VALUE ) ; this . handle = handle ; } @Override protected void deallocate ( ) { if ( capacity ( ) > threadLocalDirectBufferSize ) { super . deallocate ( ) ; } else { clear ( ) ; RECYCLER . recycle ( this , handle ) ; } } } static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf { private static final Recycler < ThreadLocalDirectByteBuf > RECYCLER = new Recycler < ThreadLocalDirectByteBuf > ( ) { @Override protected ThreadLocalDirectByteBuf newObject ( Handle < ThreadLocalDirectByteBuf > handle ) { return new ThreadLocalDirectByteBuf ( handle ) ; } } ; static ThreadLocalDirectByteBuf newInstance ( ) { ThreadLocalDirectByteBuf buf = RECYCLER . get ( ) ; buf . setRefCnt ( <int> ) ; return buf ; } private final Recycler . Handle < ThreadLocalDirectByteBuf > handle ; private ThreadLocalDirectByteBuf ( Recycler . Handle < ThreadLocalDirectByteBuf > handle ) { super ( UnpooledByteBufAllocator . DEFAULT , <int> , Integer . MAX_VALUE ) ; this . handle = handle ; } @Override protected void deallocate ( ) { if ( capacity ( ) > threadLocalDirectBufferSize ) { super . deallocate ( ) ; } else { clear ( ) ; RECYCLER . recycle ( this , handle ) ; } } } } 
