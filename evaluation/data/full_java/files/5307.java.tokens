package org . elasticsearch . action . get ; import com . carrotsearch . hppc . IntArrayList ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . support . single . shard . SingleShardRequest ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class MultiGetShardRequest extends SingleShardRequest < MultiGetShardRequest > { private int shardId ; private String preference ; Boolean realtime ; boolean refresh ; boolean ignoreErrorsOnGeneratedFields = false ; IntArrayList locations ; List < MultiGetRequest . Item > items ; public MultiGetShardRequest ( ) { } MultiGetShardRequest ( MultiGetRequest multiGetRequest , String index , int shardId ) { super ( multiGetRequest , index ) ; this . shardId = shardId ; locations = new IntArrayList ( ) ; items = new ArrayList < > ( ) ; preference = multiGetRequest . preference ; realtime = multiGetRequest . realtime ; refresh = multiGetRequest . refresh ; ignoreErrorsOnGeneratedFields = multiGetRequest . ignoreErrorsOnGeneratedFields ; } @Override public ActionRequestValidationException validate ( ) { return super . validateNonNullIndex ( ) ; } public int shardId ( ) { return this . shardId ; } public MultiGetShardRequest preference ( String preference ) { this . preference = preference ; return this ; } public String preference ( ) { return this . preference ; } public boolean realtime ( ) { return this . realtime = = null ? true : this . realtime ; } public MultiGetShardRequest realtime ( Boolean realtime ) { this . realtime = realtime ; return this ; } public MultiGetShardRequest ignoreErrorsOnGeneratedFields ( Boolean ignoreErrorsOnGeneratedFields ) { this . ignoreErrorsOnGeneratedFields = ignoreErrorsOnGeneratedFields ; return this ; } public boolean refresh ( ) { return this . refresh ; } public MultiGetShardRequest refresh ( boolean refresh ) { this . refresh = refresh ; return this ; } void add ( int location , MultiGetRequest . Item item ) { this . locations . add ( location ) ; this . items . add ( item ) ; } @Override public String [ ] indices ( ) { String [ ] indices = new String [ items . size ( ) ] ; for ( int i = <int> ; i < indices . length ; i + + ) { indices [ i ] = items . get ( i ) . index ( ) ; } return indices ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; locations = new IntArrayList ( size ) ; items = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { locations . add ( in . readVInt ( ) ) ; items . add ( MultiGetRequest . Item . readItem ( in ) ) ; } preference = in . readOptionalString ( ) ; refresh = in . readBoolean ( ) ; byte realtime = in . readByte ( ) ; if ( realtime = = <int> ) { this . realtime = false ; } else if ( realtime = = <int> ) { this . realtime = true ; } ignoreErrorsOnGeneratedFields = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( locations . size ( ) ) ; for ( int i = <int> ; i < locations . size ( ) ; i + + ) { out . writeVInt ( locations . get ( i ) ) ; items . get ( i ) . writeTo ( out ) ; } out . writeOptionalString ( preference ) ; out . writeBoolean ( refresh ) ; if ( realtime = = null ) { out . writeByte ( ( byte ) - <int> ) ; } else if ( ! realtime ) { out . writeByte ( ( byte ) <int> ) ; } else { out . writeByte ( ( byte ) <int> ) ; } out . writeBoolean ( ignoreErrorsOnGeneratedFields ) ; } public boolean ignoreErrorsOnGeneratedFields ( ) { return ignoreErrorsOnGeneratedFields ; } } 
