package org . gradle . launcher . daemon . bootstrap ; import com . google . common . io . Files ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . internal . nativeintegration . services . NativeServices ; import org . gradle . internal . serialize . kryo . KryoBackedDecoder ; import org . gradle . launcher . bootstrap . EntryPoint ; import org . gradle . launcher . bootstrap . ExecutionListener ; import org . gradle . launcher . daemon . configuration . DaemonServerConfiguration ; import org . gradle . launcher . daemon . configuration . DefaultDaemonServerConfiguration ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . server . Daemon ; import org . gradle . launcher . daemon . server . DaemonServices ; import org . gradle . logging . LoggingManagerInternal ; import org . gradle . logging . LoggingServiceRegistry ; import org . gradle . messaging . remote . Address ; import org . gradle . process . internal . child . EncodedStream ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeUnit ; public class DaemonMain extends EntryPoint { private static final Logger LOGGER = Logging . getLogger ( DaemonMain . class ) ; private PrintStream originalOut ; private PrintStream originalErr ; @Override protected void doAction ( String [ ] args , ExecutionListener listener ) { if ( args . length ! = <int> ) { invalidArgs ( <str> ) ; } List < String > startupOpts ; File gradleHomeDir ; File daemonBaseDir ; int idleTimeoutMs ; String daemonUid ; List < File > additionalClassPath ; KryoBackedDecoder decoder = new KryoBackedDecoder ( new EncodedStream . EncodedInput ( System . in ) ) ; try { gradleHomeDir = new File ( decoder . readString ( ) ) ; daemonBaseDir = new File ( decoder . readString ( ) ) ; idleTimeoutMs = decoder . readSmallInt ( ) ; daemonUid = decoder . readString ( ) ; int argCount = decoder . readSmallInt ( ) ; startupOpts = new ArrayList < String > ( argCount ) ; for ( int i = <int> ; i < argCount ; i + + ) { startupOpts . add ( decoder . readString ( ) ) ; } int additionalClassPathLength = decoder . readSmallInt ( ) ; additionalClassPath = new ArrayList < File > ( additionalClassPathLength ) ; for ( int i = <int> ; i < additionalClassPathLength ; i + + ) { additionalClassPath . add ( new File ( decoder . readString ( ) ) ) ; } } catch ( EOFException e ) { throw new UncheckedIOException ( e ) ; } LOGGER . debug ( <str> , startupOpts ) ; NativeServices . initialize ( gradleHomeDir ) ; DaemonServerConfiguration parameters = new DefaultDaemonServerConfiguration ( daemonUid , daemonBaseDir , idleTimeoutMs , startupOpts ) ; LoggingServiceRegistry loggingRegistry = LoggingServiceRegistry . newCommandLineProcessLogging ( ) ; LoggingManagerInternal loggingManager = loggingRegistry . newInstance ( LoggingManagerInternal . class ) ; DaemonServices daemonServices = new DaemonServices ( parameters , loggingRegistry , loggingManager , new DefaultClassPath ( additionalClassPath ) ) ; File daemonLog = daemonServices . getDaemonLogFile ( ) ; initialiseLogging ( loggingManager , daemonLog ) ; Daemon daemon = daemonServices . get ( Daemon . class ) ; daemon . start ( ) ; try { DaemonContext daemonContext = daemonServices . get ( DaemonContext . class ) ; Long pid = daemonContext . getPid ( ) ; daemonStarted ( pid , daemon . getUid ( ) , daemon . getAddress ( ) , daemonLog ) ; daemon . requestStopOnIdleTimeout ( parameters . getIdleTimeout ( ) , TimeUnit . MILLISECONDS ) ; } finally { daemon . stop ( ) ; } } private static void invalidArgs ( String message ) { System . out . println ( <str> ) ; System . out . println ( message ) ; System . exit ( <int> ) ; } protected void daemonStarted ( Long pid , String uid , Address address , File daemonLog ) { new DaemonStartupCommunication ( ) . printDaemonStarted ( originalOut , pid , uid , address , daemonLog ) ; try { originalOut . close ( ) ; originalErr . close ( ) ; } finally { originalOut = null ; originalErr = null ; } } protected void initialiseLogging ( LoggingManagerInternal loggingManager , File daemonLog ) { PrintStream result ; try { Files . createParentDirs ( daemonLog ) ; result = new PrintStream ( new FileOutputStream ( daemonLog ) , true ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } final PrintStream log = result ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { log . println ( DaemonMessages . DAEMON_VM_SHUTTING_DOWN ) ; } } ) ; redirectOutputsAndInput ( log ) ; loggingManager . attachSystemOutAndErr ( ) ; loggingManager . setLevel ( LogLevel . DEBUG ) ; loggingManager . start ( ) ; } private void redirectOutputsAndInput ( PrintStream printStream ) { this . originalOut = System . out ; this . originalErr = System . err ; System . setOut ( printStream ) ; System . setErr ( printStream ) ; System . setIn ( new ByteArrayInputStream ( new byte [ <int> ] ) ) ; } } 
