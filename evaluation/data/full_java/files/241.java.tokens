package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . Multimap ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . partitions . FilteredPartition ; import org . apache . cassandra . db . partitions . Partition ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . service . CASRequest ; import org . apache . cassandra . utils . Pair ; public class CQL3CasRequest implements CASRequest { public final CFMetaData cfm ; public final DecoratedKey key ; public final boolean isBatch ; private final PartitionColumns conditionColumns ; private final boolean updatesRegularRows ; private final boolean updatesStaticRow ; private boolean hasExists ; private final SortedMap < Clustering , RowCondition > conditions ; private final List < RowUpdate > updates = new ArrayList < > ( ) ; public CQL3CasRequest ( CFMetaData cfm , DecoratedKey key , boolean isBatch , PartitionColumns conditionColumns , boolean updatesRegularRows , boolean updatesStaticRow ) { this . cfm = cfm ; this . key = key ; this . conditions = new TreeMap < > ( cfm . comparator ) ; this . isBatch = isBatch ; this . conditionColumns = conditionColumns ; this . updatesRegularRows = updatesRegularRows ; this . updatesStaticRow = updatesStaticRow ; } public void addRowUpdate ( Clustering clustering , ModificationStatement stmt , QueryOptions options , long timestamp ) { updates . add ( new RowUpdate ( clustering , stmt , options , timestamp ) ) ; } public void addNotExist ( Clustering clustering ) throws InvalidRequestException { RowCondition previous = conditions . put ( clustering , new NotExistCondition ( clustering ) ) ; if ( previous ! = null & & ! ( previous instanceof NotExistCondition ) ) { if ( previous instanceof ExistCondition ) throw new InvalidRequestException ( <str> ) ; else throw new InvalidRequestException ( <str> ) ; } hasExists = true ; } public void addExist ( Clustering clustering ) throws InvalidRequestException { RowCondition previous = conditions . put ( clustering , new ExistCondition ( clustering ) ) ; if ( previous instanceof NotExistCondition ) throw new InvalidRequestException ( <str> ) ; hasExists = true ; } public void addConditions ( Clustering clustering , Collection < ColumnCondition > conds , QueryOptions options ) throws InvalidRequestException { RowCondition condition = conditions . get ( clustering ) ; if ( condition = = null ) { condition = new ColumnsConditions ( clustering ) ; conditions . put ( clustering , condition ) ; } else if ( ! ( condition instanceof ColumnsConditions ) ) { throw new InvalidRequestException ( <str> ) ; } ( ( ColumnsConditions ) condition ) . addConditions ( conds , options ) ; } private PartitionColumns columnsToRead ( ) { if ( hasExists ) { PartitionColumns allColumns = cfm . partitionColumns ( ) ; Columns statics = updatesStaticRow ? allColumns . statics : Columns . NONE ; Columns regulars = updatesRegularRows ? allColumns . regulars : Columns . NONE ; return new PartitionColumns ( statics , regulars ) ; } return conditionColumns ; } public SinglePartitionReadCommand readCommand ( int nowInSec ) { assert ! conditions . isEmpty ( ) ; Slices . Builder builder = new Slices . Builder ( cfm . comparator , conditions . size ( ) ) ; for ( Clustering clustering : conditions . keySet ( ) ) { if ( clustering ! = Clustering . STATIC_CLUSTERING ) builder . add ( Slice . make ( clustering ) ) ; } ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter ( builder . build ( ) , false ) ; return SinglePartitionReadCommand . create ( cfm , nowInSec , key , ColumnFilter . selection ( columnsToRead ( ) ) , filter ) ; } public boolean appliesTo ( FilteredPartition current ) throws InvalidRequestException { for ( RowCondition condition : conditions . values ( ) ) { if ( ! condition . appliesTo ( current ) ) return false ; } return true ; } private PartitionColumns updatedColumns ( ) { PartitionColumns . Builder builder = PartitionColumns . builder ( ) ; for ( RowUpdate upd : updates ) builder . addAll ( upd . stmt . updatedColumns ( ) ) ; return builder . build ( ) ; } public PartitionUpdate makeUpdates ( FilteredPartition current ) throws InvalidRequestException { PartitionUpdate update = new PartitionUpdate ( cfm , key , updatedColumns ( ) , conditions . size ( ) ) ; for ( RowUpdate upd : updates ) upd . applyUpdates ( current , update ) ; Keyspace . openAndGetStore ( cfm ) . indexManager . validate ( update ) ; if ( isBatch ) BatchStatement . verifyBatchSize ( Collections . singleton ( update ) ) ; return update ; } private class RowUpdate { private final Clustering clustering ; private final ModificationStatement stmt ; private final QueryOptions options ; private final long timestamp ; private RowUpdate ( Clustering clustering , ModificationStatement stmt , QueryOptions options , long timestamp ) { this . clustering = clustering ; this . stmt = stmt ; this . options = options ; this . timestamp = timestamp ; } public void applyUpdates ( FilteredPartition current , PartitionUpdate updates ) throws InvalidRequestException { Map < DecoratedKey , Partition > map = stmt . requiresRead ( ) ? Collections . < DecoratedKey , Partition > singletonMap ( key , current ) : null ; UpdateParameters params = new UpdateParameters ( cfm , updates . columns ( ) , options , timestamp , stmt . getTimeToLive ( options ) , map ) ; stmt . addUpdateForKey ( updates , clustering , params ) ; } } private static abstract class RowCondition { public final Clustering clustering ; protected RowCondition ( Clustering clustering ) { this . clustering = clustering ; } public abstract boolean appliesTo ( FilteredPartition current ) throws InvalidRequestException ; } private static class NotExistCondition extends RowCondition { private NotExistCondition ( Clustering clustering ) { super ( clustering ) ; } public boolean appliesTo ( FilteredPartition current ) { return current = = null | | current . getRow ( clustering ) = = null ; } } private static class ExistCondition extends RowCondition { private ExistCondition ( Clustering clustering ) { super ( clustering ) ; } public boolean appliesTo ( FilteredPartition current ) { return current ! = null & & current . getRow ( clustering ) ! = null ; } } private static class ColumnsConditions extends RowCondition { private final Multimap < Pair < ColumnIdentifier , ByteBuffer > , ColumnCondition . Bound > conditions = HashMultimap . create ( ) ; private ColumnsConditions ( Clustering clustering ) { super ( clustering ) ; } public void addConditions ( Collection < ColumnCondition > conds , QueryOptions options ) throws InvalidRequestException { for ( ColumnCondition condition : conds ) { ColumnCondition . Bound current = condition . bind ( options ) ; conditions . put ( Pair . create ( condition . column . name , current . getCollectionElementValue ( ) ) , current ) ; } } public boolean appliesTo ( FilteredPartition current ) throws InvalidRequestException { if ( current = = null ) return conditions . isEmpty ( ) ; for ( ColumnCondition . Bound condition : conditions . values ( ) ) { if ( ! condition . appliesTo ( current . getRow ( clustering ) ) ) return false ; } return true ; } } } 
