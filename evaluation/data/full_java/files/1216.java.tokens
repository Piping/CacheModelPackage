package org . apache . cassandra . utils ; import java . io . DataInput ; import java . io . IOException ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . obs . IBitSet ; import org . apache . cassandra . utils . obs . OffHeapBitSet ; import org . apache . cassandra . utils . obs . OpenBitSet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class FilterFactory { public static final IFilter AlwaysPresent = new AlwaysPresentFilter ( ) ; private static final Logger logger = LoggerFactory . getLogger ( FilterFactory . class ) ; private static final long BITSET_EXCESS = <int> ; public static void serialize ( IFilter bf , DataOutputPlus output ) throws IOException { BloomFilterSerializer . serialize ( ( BloomFilter ) bf , output ) ; } public static IFilter deserialize ( DataInput input , boolean offheap , boolean oldBfHashOrder ) throws IOException { return BloomFilterSerializer . deserialize ( input , offheap , oldBfHashOrder ) ; } public static IFilter getFilter ( long numElements , int targetBucketsPerElem , boolean offheap , boolean oldBfHashOrder ) { int maxBucketsPerElement = Math . max ( <int> , BloomCalculations . maxBucketsPerElement ( numElements ) ) ; int bucketsPerElement = Math . min ( targetBucketsPerElem , maxBucketsPerElement ) ; if ( bucketsPerElement < targetBucketsPerElem ) { logger . warn ( String . format ( <str> , numElements , bucketsPerElement , targetBucketsPerElem ) ) ; } BloomCalculations . BloomSpecification spec = BloomCalculations . computeBloomSpec ( bucketsPerElement ) ; return createFilter ( spec . K , numElements , spec . bucketsPerElement , offheap , oldBfHashOrder ) ; } public static IFilter getFilter ( long numElements , double maxFalsePosProbability , boolean offheap , boolean oldBfHashOrder ) { assert maxFalsePosProbability < = <float> : <str> ; if ( maxFalsePosProbability = = <float> ) return new AlwaysPresentFilter ( ) ; int bucketsPerElement = BloomCalculations . maxBucketsPerElement ( numElements ) ; BloomCalculations . BloomSpecification spec = BloomCalculations . computeBloomSpec ( bucketsPerElement , maxFalsePosProbability ) ; return createFilter ( spec . K , numElements , spec . bucketsPerElement , offheap , oldBfHashOrder ) ; } @SuppressWarnings ( <str> ) private static IFilter createFilter ( int hash , long numElements , int bucketsPer , boolean offheap , boolean oldBfHashOrder ) { long numBits = ( numElements * bucketsPer ) + BITSET_EXCESS ; IBitSet bitset = offheap ? new OffHeapBitSet ( numBits ) : new OpenBitSet ( numBits ) ; return new BloomFilter ( hash , bitset , oldBfHashOrder ) ; } } 
