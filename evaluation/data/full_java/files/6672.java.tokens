package org . elasticsearch . index . query ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . spans . SpanNearQuery ; import org . apache . lucene . search . spans . SpanQuery ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; public class SpanNearQueryBuilder extends AbstractQueryBuilder < SpanNearQueryBuilder > implements SpanQueryBuilder < SpanNearQueryBuilder > { public static final String NAME = <str> ; public static boolean DEFAULT_IN_ORDER = true ; public static boolean DEFAULT_COLLECT_PAYLOADS = true ; private final List < SpanQueryBuilder > clauses = new ArrayList < > ( ) ; private final int slop ; private boolean inOrder = DEFAULT_IN_ORDER ; private boolean collectPayloads = DEFAULT_COLLECT_PAYLOADS ; static final SpanNearQueryBuilder PROTOTYPE = new SpanNearQueryBuilder ( SpanTermQueryBuilder . PROTOTYPE , <int> ) ; public SpanNearQueryBuilder ( SpanQueryBuilder initialClause , int slop ) { if ( initialClause = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . clauses . add ( initialClause ) ; this . slop = slop ; } public int slop ( ) { return this . slop ; } public SpanNearQueryBuilder clause ( SpanQueryBuilder clause ) { if ( clause = = null ) { throw new IllegalArgumentException ( <str> ) ; } clauses . add ( clause ) ; return this ; } public List < SpanQueryBuilder > clauses ( ) { return this . clauses ; } public SpanNearQueryBuilder inOrder ( boolean inOrder ) { this . inOrder = inOrder ; return this ; } public boolean inOrder ( ) { return this . inOrder ; } public SpanNearQueryBuilder collectPayloads ( boolean collectPayloads ) { this . collectPayloads = collectPayloads ; return this ; } public boolean collectPayloads ( ) { return this . collectPayloads ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startArray ( SpanNearQueryParser . CLAUSES_FIELD . getPreferredName ( ) ) ; for ( SpanQueryBuilder clause : clauses ) { clause . toXContent ( builder , params ) ; } builder . endArray ( ) ; builder . field ( SpanNearQueryParser . SLOP_FIELD . getPreferredName ( ) , slop ) ; builder . field ( SpanNearQueryParser . IN_ORDER_FIELD . getPreferredName ( ) , inOrder ) ; builder . field ( SpanNearQueryParser . COLLECT_PAYLOADS_FIELD . getPreferredName ( ) , collectPayloads ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { SpanQuery [ ] spanQueries = new SpanQuery [ clauses . size ( ) ] ; for ( int i = <int> ; i < clauses . size ( ) ; i + + ) { Query query = clauses . get ( i ) . toQuery ( context ) ; assert query instanceof SpanQuery ; spanQueries [ i ] = ( SpanQuery ) query ; } return new SpanNearQuery ( spanQueries , slop , inOrder , collectPayloads ) ; } @Override protected SpanNearQueryBuilder doReadFrom ( StreamInput in ) throws IOException { List < QueryBuilder > clauses = readQueries ( in ) ; SpanNearQueryBuilder queryBuilder = new SpanNearQueryBuilder ( ( SpanQueryBuilder ) clauses . get ( <int> ) , in . readVInt ( ) ) ; for ( int i = <int> ; i < clauses . size ( ) ; i + + ) { queryBuilder . clauses . add ( ( SpanQueryBuilder ) clauses . get ( i ) ) ; } queryBuilder . collectPayloads = in . readBoolean ( ) ; queryBuilder . inOrder = in . readBoolean ( ) ; return queryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { writeQueries ( out , clauses ) ; out . writeVInt ( slop ) ; out . writeBoolean ( collectPayloads ) ; out . writeBoolean ( inOrder ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( clauses , slop , collectPayloads , inOrder ) ; } @Override protected boolean doEquals ( SpanNearQueryBuilder other ) { return Objects . equals ( clauses , other . clauses ) & & Objects . equals ( slop , other . slop ) & & Objects . equals ( collectPayloads , other . collectPayloads ) & & Objects . equals ( inOrder , other . inOrder ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
