package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentLocation ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . InternalMultiBucketAggregation ; import org . elasticsearch . search . aggregations . InvalidAggregationPathException ; import org . elasticsearch . search . aggregations . metrics . InternalNumericMetricsAggregation ; import org . elasticsearch . search . aggregations . pipeline . derivative . DerivativeParser ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class BucketHelpers { public static enum GapPolicy { INSERT_ZEROS ( ( byte ) <int> , <str> ) , SKIP ( ( byte ) <int> , <str> ) ; public static GapPolicy parse ( SearchContext context , String text , XContentLocation tokenLocation ) { GapPolicy result = null ; for ( GapPolicy policy : values ( ) ) { if ( context . parseFieldMatcher ( ) . match ( text , policy . parseField ) ) { if ( result = = null ) { result = policy ; } else { throw new IllegalStateException ( <str> + text + <str> + <str> + Arrays . asList ( result , policy ) ) ; } } } if ( result = = null ) { final List < String > validNames = new ArrayList < > ( ) ; for ( GapPolicy policy : values ( ) ) { validNames . add ( policy . getName ( ) ) ; } throw new SearchParseException ( context , <str> + text + <str> + validNames , tokenLocation ) ; } return result ; } private final byte id ; private final ParseField parseField ; private GapPolicy ( byte id , String name ) { this . id = id ; this . parseField = new ParseField ( name ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeByte ( id ) ; } public static GapPolicy readFrom ( StreamInput in ) throws IOException { byte id = in . readByte ( ) ; for ( GapPolicy gapPolicy : values ( ) ) { if ( id = = gapPolicy . id ) { return gapPolicy ; } } throw new IllegalStateException ( <str> + id + <str> ) ; } public String getName ( ) { return parseField . getPreferredName ( ) ; } } public static Double resolveBucketValue ( InternalMultiBucketAggregation < ? , ? extends InternalMultiBucketAggregation . Bucket > agg , InternalMultiBucketAggregation . Bucket bucket , String aggPath , GapPolicy gapPolicy ) { List < String > aggPathsList = AggregationPath . parse ( aggPath ) . getPathElementsAsStringList ( ) ; return resolveBucketValue ( agg , bucket , aggPathsList , gapPolicy ) ; } public static Double resolveBucketValue ( InternalMultiBucketAggregation < ? , ? extends InternalMultiBucketAggregation . Bucket > agg , InternalMultiBucketAggregation . Bucket bucket , List < String > aggPathAsList , GapPolicy gapPolicy ) { try { Object propertyValue = bucket . getProperty ( agg . getName ( ) , aggPathAsList ) ; if ( propertyValue = = null ) { throw new AggregationExecutionException ( DerivativeParser . BUCKETS_PATH . getPreferredName ( ) + <str> ) ; } else { double value ; if ( propertyValue instanceof Number ) { value = ( ( Number ) propertyValue ) . doubleValue ( ) ; } else if ( propertyValue instanceof InternalNumericMetricsAggregation . SingleValue ) { value = ( ( InternalNumericMetricsAggregation . SingleValue ) propertyValue ) . value ( ) ; } else { throw new AggregationExecutionException ( DerivativeParser . BUCKETS_PATH . getPreferredName ( ) + <str> + propertyValue . getClass ( ) . getCanonicalName ( ) ) ; } boolean isDocCountProperty = aggPathAsList . size ( ) = = <int> & & <str> . equals ( aggPathAsList . get ( <int> ) ) ; if ( Double . isInfinite ( value ) | | Double . isNaN ( value ) | | ( bucket . getDocCount ( ) = = <int> & & ! isDocCountProperty ) ) { switch ( gapPolicy ) { case INSERT_ZEROS : return <float> ; case SKIP : default : return Double . NaN ; } } else { return value ; } } } catch ( InvalidAggregationPathException e ) { return null ; } } } 
