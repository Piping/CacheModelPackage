package io . netty . handler . ssl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . util . CharsetUtil ; import io . netty . util . DomainNameMapping ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . IDN ; import java . util . List ; import java . util . Locale ; public class SniHandler extends ByteToMessageDecoder { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( SniHandler . class ) ; private final DomainNameMapping < SslContext > mapping ; private boolean handshaken ; private volatile String hostname ; private volatile SslContext selectedContext ; @SuppressWarnings ( <str> ) public SniHandler ( DomainNameMapping < ? extends SslContext > mapping ) { if ( mapping = = null ) { throw new NullPointerException ( <str> ) ; } this . mapping = ( DomainNameMapping < SslContext > ) mapping ; handshaken = false ; } public String hostname ( ) { return hostname ; } public SslContext sslContext ( ) { return selectedContext ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( ! handshaken & & in . readableBytes ( ) > = <int> ) { String hostname = sniHostNameFromHandshakeInfo ( in ) ; if ( hostname ! = null ) { hostname = IDN . toASCII ( hostname , IDN . ALLOW_UNASSIGNED ) . toLowerCase ( Locale . US ) ; } this . hostname = hostname ; selectedContext = mapping . map ( hostname ) ; } if ( handshaken ) { SslHandler sslHandler = selectedContext . newHandler ( ctx . alloc ( ) ) ; ctx . pipeline ( ) . replace ( this , SslHandler . class . getName ( ) , sslHandler ) ; } } private String sniHostNameFromHandshakeInfo ( ByteBuf in ) { int readerIndex = in . readerIndex ( ) ; try { int command = in . getUnsignedByte ( readerIndex ) ; switch ( command ) { case SslConstants . SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC : case SslConstants . SSL_CONTENT_TYPE_ALERT : case SslConstants . SSL_CONTENT_TYPE_APPLICATION_DATA : return null ; case SslConstants . SSL_CONTENT_TYPE_HANDSHAKE : break ; default : handshaken = true ; return null ; } int majorVersion = in . getUnsignedByte ( readerIndex + <int> ) ; if ( majorVersion = = <int> ) { int packetLength = in . getUnsignedShort ( readerIndex + <int> ) + <int> ; if ( in . readableBytes ( ) > = packetLength ) { int offset = readerIndex + <int> ; int sessionIdLength = in . getUnsignedByte ( offset ) ; offset + = sessionIdLength + <int> ; int cipherSuitesLength = in . getUnsignedShort ( offset ) ; offset + = cipherSuitesLength + <int> ; int compressionMethodLength = in . getUnsignedByte ( offset ) ; offset + = compressionMethodLength + <int> ; int extensionsLength = in . getUnsignedShort ( offset ) ; offset + = <int> ; int extensionsLimit = offset + extensionsLength ; while ( offset < extensionsLimit ) { int extensionType = in . getUnsignedShort ( offset ) ; offset + = <int> ; int extensionLength = in . getUnsignedShort ( offset ) ; offset + = <int> ; if ( extensionType = = <int> ) { handshaken = true ; int serverNameType = in . getUnsignedByte ( offset + <int> ) ; if ( serverNameType = = <int> ) { int serverNameLength = in . getUnsignedShort ( offset + <int> ) ; return in . toString ( offset + <int> , serverNameLength , CharsetUtil . UTF_8 ) ; } else { return null ; } } offset + = extensionLength ; } handshaken = true ; return null ; } else { return null ; } } else { handshaken = true ; return null ; } } catch ( Throwable e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + ByteBufUtil . hexDump ( in ) , e ) ; } handshaken = true ; return null ; } } } 
