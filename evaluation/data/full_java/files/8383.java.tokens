package org . elasticsearch . percolator ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . indices . delete . DeleteIndexResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . percolate . MultiPercolateRequestBuilder ; import org . elasticsearch . action . percolate . MultiPercolateResponse ; import org . elasticsearch . action . percolate . PercolateRequestBuilder ; import org . elasticsearch . action . percolate . PercolateResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import java . util . function . Predicate ; import static org . elasticsearch . action . percolate . PercolateSourceBuilder . docBuilder ; import static org . elasticsearch . client . Requests . clusterHealthRequest ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . rangeQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . percolator . PercolatorTestUtil . convertFromTextArray ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertMatchCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . arrayContainingInAnyOrder ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . emptyArray ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . nullValue ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , numClientNodes = <int> , transportClientRatio = <int> ) public class RecoveryPercolatorIT extends ESIntegTestCase { @Override protected int numberOfShards ( ) { return <int> ; } public void testRestartNodePercolator1 ( ) throws Exception { internalCluster ( ) . startNode ( ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . addMapping ( PercolatorService . TYPE_NAME , <str> , <str> ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; PercolateResponse percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; internalCluster ( ) . rollingRestart ( ) ; logger . info ( <str> ) ; ensureYellow ( ) ; percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( percolate , <int> ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; } public void testRestartNodePercolator2 ( ) throws Exception { internalCluster ( ) . startNode ( ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . addMapping ( PercolatorService . TYPE_NAME , <str> , <str> ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; assertThat ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( PercolatorService . TYPE_NAME ) . setQuery ( matchAllQuery ( ) ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; PercolateResponse percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( percolate , <int> ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; internalCluster ( ) . rollingRestart ( ) ; logger . info ( <str> ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForYellowStatus ( ) . waitForActiveShards ( <int> ) ) . actionGet ( ) ; logger . info ( <str> + clusterHealth . getStatus ( ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( PercolatorService . TYPE_NAME ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( countResponse , <int> ) ; DeleteIndexResponse actionGet = client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; assertThat ( actionGet . isAcknowledged ( ) , equalTo ( true ) ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . get ( ) ; clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( ) . waitForYellowStatus ( ) . waitForActiveShards ( <int> ) ) . actionGet ( ) ; logger . info ( <str> + clusterHealth . getStatus ( ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( PercolatorService . TYPE_NAME ) . setQuery ( matchAllQuery ( ) ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> l ) ) ; percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( percolate , <int> l ) ; assertThat ( percolate . getMatches ( ) , emptyArray ( ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , termQuery ( <str> , <str> ) ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; assertThat ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( PercolatorService . TYPE_NAME ) . setQuery ( matchAllQuery ( ) ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; percolate = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( percolate , <int> ) ; assertThat ( percolate . getMatches ( ) , arrayWithSize ( <int> ) ) ; } public void testLoadingPercolateQueriesDuringCloseAndOpen ( ) throws Exception { internalCluster ( ) . startNode ( ) ; internalCluster ( ) . startNode ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . get ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . get ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < = <int> ; i + + ) { client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , rangeQuery ( <str> ) . from ( <int> ) . to ( i ) ) . endObject ( ) ) . get ( ) ; } logger . info ( <str> ) ; PercolateResponse response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( response , <int> ) ; assertThat ( response . getMatches ( ) , arrayWithSize ( <int> ) ) ; assertThat ( convertFromTextArray ( response . getMatches ( ) , <str> ) , arrayContainingInAnyOrder ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareOpen ( <str> ) ) ; ensureGreen ( ) ; logger . info ( <str> ) ; response = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) . get ( ) ; assertMatchCount ( response , <int> ) ; assertThat ( response . getMatches ( ) , arrayWithSize ( <int> ) ) ; assertThat ( response . getMatches ( ) [ <int> ] . getId ( ) . string ( ) , equalTo ( <str> ) ) ; } public void testSinglePercolatorRecovery ( ) throws Exception { percolatorRecovery ( false ) ; } public void testMultiPercolatorRecovery ( ) throws Exception { percolatorRecovery ( true ) ; } private void percolatorRecovery ( final boolean multiPercolate ) throws Exception { internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , true ) ) ; internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , false ) ) ; internalCluster ( ) . startNode ( settingsBuilder ( ) . put ( <str> , false ) ) ; ensureGreen ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) . get ( ) ; ensureGreen ( ) ; final Client client = internalCluster ( ) . client ( input - > input . getAsBoolean ( <str> , true ) ) ; final int numQueries = randomIntBetween ( <int> , <int> ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < numQueries ; i + + ) { client . prepareIndex ( <str> , PercolatorService . TYPE_NAME , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , matchAllQuery ( ) ) . endObject ( ) ) . get ( ) ; } final String document = <str> ; client . prepareIndex ( <str> , <str> , <str> ) . setSource ( document ) . get ( ) ; final AtomicBoolean run = new AtomicBoolean ( true ) ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { while ( run . get ( ) ) { if ( multiPercolate ) { MultiPercolateRequestBuilder builder = client . prepareMultiPercolate ( ) ; int numPercolateRequest = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numPercolateRequest ; i + + ) { PercolateRequestBuilder percolateBuilder = client . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) ; if ( randomBoolean ( ) ) { percolateBuilder . setGetRequest ( Requests . getRequest ( <str> ) . type ( <str> ) . id ( <str> ) ) ; } else { percolateBuilder . setPercolateDoc ( docBuilder ( ) . setDoc ( document ) ) ; } builder . add ( percolateBuilder ) ; } MultiPercolateResponse response = builder . get ( ) ; assertThat ( response . items ( ) . length , equalTo ( numPercolateRequest ) ) ; for ( MultiPercolateResponse . Item item : response ) { assertThat ( item . isFailure ( ) , equalTo ( false ) ) ; assertNoFailures ( item . getResponse ( ) ) ; assertThat ( item . getResponse ( ) . getSuccessfulShards ( ) , equalTo ( item . getResponse ( ) . getTotalShards ( ) ) ) ; assertThat ( item . getResponse ( ) . getCount ( ) , equalTo ( ( long ) numQueries ) ) ; assertThat ( item . getResponse ( ) . getMatches ( ) . length , equalTo ( numQueries ) ) ; } } else { PercolateRequestBuilder percolateBuilder = client . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) ; if ( randomBoolean ( ) ) { percolateBuilder . setPercolateDoc ( docBuilder ( ) . setDoc ( document ) ) ; } else { percolateBuilder . setGetRequest ( Requests . getRequest ( <str> ) . type ( <str> ) . id ( <str> ) ) ; } PercolateResponse response = percolateBuilder . get ( ) ; assertNoFailures ( response ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( response . getTotalShards ( ) ) ) ; assertThat ( response . getCount ( ) , equalTo ( ( long ) numQueries ) ) ; assertThat ( response . getMatches ( ) . length , equalTo ( numQueries ) ) ; } } } catch ( Throwable t ) { logger . info ( <str> , t ) ; run . set ( false ) ; error . set ( t ) ; } } } ; Thread t = new Thread ( r ) ; t . start ( ) ; Predicate < Settings > nodePredicate = input - > ! input . getAsBoolean ( <str> , false ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { internalCluster ( ) . stopRandomNode ( nodePredicate ) ; client . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( TimeValue . timeValueMinutes ( <int> ) ) . setWaitForYellowStatus ( ) . setWaitForActiveShards ( <int> ) . get ( ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; internalCluster ( ) . stopRandomNode ( nodePredicate ) ; client . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( TimeValue . timeValueMinutes ( <int> ) ) . setWaitForYellowStatus ( ) . setWaitForActiveShards ( <int> ) . get ( ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; internalCluster ( ) . startNode ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( TimeValue . timeValueMinutes ( <int> ) ) . setWaitForYellowStatus ( ) . setWaitForActiveShards ( <int> ) . get ( ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; internalCluster ( ) . startNode ( ) ; client . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( TimeValue . timeValueMinutes ( <int> ) ) . setWaitForGreenStatus ( ) . setWaitForActiveShards ( <int> ) . get ( ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; } } finally { run . set ( false ) ; } t . join ( ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; } } 
