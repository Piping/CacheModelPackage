package com . google . common . testing ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Equivalence ; import com . google . common . base . MoreObjects ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableTable ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; @GwtCompatible public class EquivalenceTesterTest extends TestCase { private EquivalenceTester < Object > tester ; private MockEquivalence equivalenceMock ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; this . equivalenceMock = new MockEquivalence ( ) ; this . tester = EquivalenceTester . of ( equivalenceMock ) ; } public void testOf_NullPointerException ( ) { try { EquivalenceTester . of ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testTest_NoData ( ) { tester . test ( ) ; } public void testTest ( ) { Object group1Item1 = new TestObject ( <int> , <int> ) ; Object group1Item2 = new TestObject ( <int> , <int> ) ; Object group2Item1 = new TestObject ( <int> , <int> ) ; Object group2Item2 = new TestObject ( <int> , <int> ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item2 ) ; equivalenceMock . expectDistinct ( group1Item1 , group2Item1 ) ; equivalenceMock . expectDistinct ( group1Item1 , group2Item2 ) ; equivalenceMock . expectEquivalent ( group1Item2 , group1Item1 ) ; equivalenceMock . expectDistinct ( group1Item2 , group2Item1 ) ; equivalenceMock . expectDistinct ( group1Item2 , group2Item2 ) ; equivalenceMock . expectDistinct ( group2Item1 , group1Item1 ) ; equivalenceMock . expectDistinct ( group2Item1 , group1Item2 ) ; equivalenceMock . expectEquivalent ( group2Item1 , group2Item2 ) ; equivalenceMock . expectDistinct ( group2Item2 , group1Item1 ) ; equivalenceMock . expectDistinct ( group2Item2 , group1Item2 ) ; equivalenceMock . expectEquivalent ( group2Item2 , group2Item1 ) ; equivalenceMock . expectHash ( group1Item1 , <int> ) ; equivalenceMock . expectHash ( group1Item2 , <int> ) ; equivalenceMock . expectHash ( group2Item1 , <int> ) ; equivalenceMock . expectHash ( group2Item2 , <int> ) ; equivalenceMock . replay ( ) ; tester . addEquivalenceGroup ( group1Item1 , group1Item2 ) . addEquivalenceGroup ( group2Item1 , group2Item2 ) . test ( ) ; } public void testTest_symmetric ( ) { Object group1Item1 = new TestObject ( <int> , <int> ) ; Object group1Item2 = new TestObject ( <int> , <int> ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item2 ) ; equivalenceMock . expectDistinct ( group1Item2 , group1Item1 ) ; equivalenceMock . expectHash ( group1Item1 , <int> ) ; equivalenceMock . expectHash ( group1Item2 , <int> ) ; equivalenceMock . replay ( ) ; try { tester . addEquivalenceGroup ( group1Item1 , group1Item2 ) . test ( ) ; } catch ( AssertionFailedError expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> + <str> ) ; return ; } fail ( ) ; } public void testTest_trasitive ( ) { Object group1Item1 = new TestObject ( <int> , <int> ) ; Object group1Item2 = new TestObject ( <int> , <int> ) ; Object group1Item3 = new TestObject ( <int> , <int> ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item2 ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item3 ) ; equivalenceMock . expectEquivalent ( group1Item2 , group1Item1 ) ; equivalenceMock . expectDistinct ( group1Item2 , group1Item3 ) ; equivalenceMock . expectEquivalent ( group1Item3 , group1Item1 ) ; equivalenceMock . expectEquivalent ( group1Item3 , group1Item2 ) ; equivalenceMock . expectHash ( group1Item1 , <int> ) ; equivalenceMock . expectHash ( group1Item2 , <int> ) ; equivalenceMock . expectHash ( group1Item3 , <int> ) ; equivalenceMock . replay ( ) ; try { tester . addEquivalenceGroup ( group1Item1 , group1Item2 , group1Item3 ) . test ( ) ; } catch ( AssertionFailedError expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> + <str> ) ; return ; } fail ( ) ; } public void testTest_inequivalence ( ) { Object group1Item1 = new TestObject ( <int> , <int> ) ; Object group2Item1 = new TestObject ( <int> , <int> ) ; equivalenceMock . expectEquivalent ( group1Item1 , group2Item1 ) ; equivalenceMock . expectDistinct ( group2Item1 , group1Item1 ) ; equivalenceMock . expectHash ( group1Item1 , <int> ) ; equivalenceMock . expectHash ( group2Item1 , <int> ) ; equivalenceMock . replay ( ) ; try { tester . addEquivalenceGroup ( group1Item1 ) . addEquivalenceGroup ( group2Item1 ) . test ( ) ; } catch ( AssertionFailedError expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> + <str> ) ; return ; } fail ( ) ; } public void testTest_hash ( ) { Object group1Item1 = new TestObject ( <int> , <int> ) ; Object group1Item2 = new TestObject ( <int> , <int> ) ; equivalenceMock . expectEquivalent ( group1Item1 , group1Item2 ) ; equivalenceMock . expectEquivalent ( group1Item2 , group1Item1 ) ; equivalenceMock . expectHash ( group1Item1 , <int> ) ; equivalenceMock . expectHash ( group1Item2 , <int> ) ; equivalenceMock . replay ( ) ; try { tester . addEquivalenceGroup ( group1Item1 , group1Item2 ) . test ( ) ; } catch ( AssertionFailedError expected ) { String expectedMessage = <str> + <str> ; if ( ! expected . getMessage ( ) . contains ( expectedMessage ) ) { fail ( <str> + expected . getMessage ( ) + <str> + expectedMessage + <str> ) ; } return ; } fail ( ) ; } private static final class TestObject { final int group ; final int item ; TestObject ( int group , int item ) { this . group = group ; this . item = item ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( <str> ) . add ( <str> , group ) . add ( <str> , item ) . toString ( ) ; } } private static final class MockEquivalence extends Equivalence < Object > { final ImmutableTable . Builder < Object , Object , Boolean > equivalentExpectationsBuilder = ImmutableTable . builder ( ) ; final ImmutableMap . Builder < Object , Integer > hashExpectationsBuilder = ImmutableMap . builder ( ) ; ImmutableTable < Object , Object , Boolean > equivalentExpectations ; ImmutableMap < Object , Integer > hashExpectations ; void expectEquivalent ( Object a , Object b ) { checkRecording ( ) ; equivalentExpectationsBuilder . put ( a , b , true ) ; } void expectDistinct ( Object a , Object b ) { checkRecording ( ) ; equivalentExpectationsBuilder . put ( a , b , false ) ; } void expectHash ( Object object , int hash ) { checkRecording ( ) ; hashExpectationsBuilder . put ( object , hash ) ; } void replay ( ) { checkRecording ( ) ; equivalentExpectations = equivalentExpectationsBuilder . build ( ) ; hashExpectations = hashExpectationsBuilder . build ( ) ; } @Override protected boolean doEquivalent ( Object a , Object b ) { return equivalentExpectations . get ( a , b ) ; } @Override protected int doHash ( Object object ) { return hashExpectations . get ( object ) ; } void checkRecording ( ) { checkState ( equivalentExpectations = = null & & hashExpectations = = null ) ; } } } 
