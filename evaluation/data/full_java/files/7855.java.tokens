package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . test . ESAllocationTestCase ; import static java . util . Collections . singletonMap ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . RELOCATING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . STARTED ; import static org . elasticsearch . cluster . routing . ShardRoutingState . UNASSIGNED ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; public class PreferLocalPrimariesToRelocatingPrimariesTests extends ESAllocationTestCase { public void testPreferLocalPrimaryAllocationOverFiltered ( ) { int concurrentRecoveries = randomIntBetween ( <int> , <int> ) ; int primaryRecoveries = randomIntBetween ( <int> , <int> ) ; int numberOfShards = randomIntBetween ( <int> , <int> ) ; int totalNumberOfShards = numberOfShards * <int> ; logger . info ( <str> , primaryRecoveries , concurrentRecoveries ) ; AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , concurrentRecoveries ) . put ( <str> , primaryRecoveries ) . build ( ) ) ; logger . info ( <str> , numberOfShards ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( numberOfShards ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( numberOfShards ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> , singletonMap ( <str> , <str> ) ) ) . put ( newNode ( <str> , singletonMap ( <str> , <str> ) ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; while ( ! clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . isEmpty ( ) ) { routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; } logger . info ( <str> ) ; metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( <str> , numberOfShards ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( <str> , numberOfShards ) . put ( <str> , <int> ) . put ( <str> , <str> ) . build ( ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . metaData ( metaData ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( <str> ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> , numberOfShards , numberOfShards ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( numberOfShards ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . routingTable ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( numberOfShards ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> , singletonMap ( <str> , <str> ) ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; while ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) < totalNumberOfShards ) { int localInitializations = <int> ; int relocatingInitializations = <int> ; for ( ShardRouting routing : clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) { if ( routing . relocatingNodeId ( ) = = null ) { localInitializations + + ; } else { relocatingInitializations + + ; } } int needToInitialize = totalNumberOfShards - clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) - clusterState . getRoutingNodes ( ) . shardsWithState ( RELOCATING ) . size ( ) ; logger . info ( <str> , localInitializations , relocatingInitializations , needToInitialize ) ; assertThat ( localInitializations , equalTo ( Math . min ( primaryRecoveries , needToInitialize ) ) ) ; clusterState = startRandomInitializingShard ( clusterState , strategy ) ; } } } 
