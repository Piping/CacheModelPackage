package org . apache . cassandra . utils ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Collection ; import java . util . Random ; import java . util . UUID ; import com . google . common . annotations . VisibleForTesting ; public class UUIDGen { private static final long START_EPOCH = - <int> ; private static final long clockSeqAndNode = makeClockSeqAndNode ( ) ; private static final long MIN_CLOCK_SEQ_AND_NODE = <hex> ; private static final long MAX_CLOCK_SEQ_AND_NODE = <hex> ; private static final UUIDGen instance = new UUIDGen ( ) ; private long lastNanos ; private UUIDGen ( ) { if ( clockSeqAndNode = = <int> ) throw new RuntimeException ( <str> ) ; } public static UUID getTimeUUID ( ) { return new UUID ( instance . createTimeSafe ( ) , clockSeqAndNode ) ; } public static UUID getTimeUUID ( long when ) { return new UUID ( createTime ( fromUnixTimestamp ( when ) ) , clockSeqAndNode ) ; } public static UUID getTimeUUIDFromMicros ( long whenInMicros ) { long whenInMillis = whenInMicros / <int> ; long nanos = ( whenInMicros - ( whenInMillis * <int> ) ) * <int> ; return getTimeUUID ( whenInMillis , nanos ) ; } public static UUID getTimeUUID ( long when , long nanos ) { return new UUID ( createTime ( fromUnixTimestamp ( when , nanos ) ) , clockSeqAndNode ) ; } @VisibleForTesting public static UUID getTimeUUID ( long when , long nanos , long clockSeqAndNode ) { return new UUID ( createTime ( fromUnixTimestamp ( when , nanos ) ) , clockSeqAndNode ) ; } public static UUID getUUID ( ByteBuffer raw ) { return new UUID ( raw . getLong ( raw . position ( ) ) , raw . getLong ( raw . position ( ) + <int> ) ) ; } public static ByteBuffer toByteBuffer ( UUID uuid ) { ByteBuffer buffer = ByteBuffer . allocate ( <int> ) ; buffer . putLong ( uuid . getMostSignificantBits ( ) ) ; buffer . putLong ( uuid . getLeastSignificantBits ( ) ) ; buffer . flip ( ) ; return buffer ; } public static byte [ ] decompose ( UUID uuid ) { long most = uuid . getMostSignificantBits ( ) ; long least = uuid . getLeastSignificantBits ( ) ; byte [ ] b = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { b [ i ] = ( byte ) ( most > > > ( ( <int> - i ) * <int> ) ) ; b [ <int> + i ] = ( byte ) ( least > > > ( ( <int> - i ) * <int> ) ) ; } return b ; } public static byte [ ] getTimeUUIDBytes ( ) { return createTimeUUIDBytes ( instance . createTimeSafe ( ) ) ; } public static UUID minTimeUUID ( long timestamp ) { return new UUID ( createTime ( fromUnixTimestamp ( timestamp ) ) , MIN_CLOCK_SEQ_AND_NODE ) ; } public static UUID maxTimeUUID ( long timestamp ) { long uuidTstamp = fromUnixTimestamp ( timestamp + <int> ) - <int> ; return new UUID ( createTime ( uuidTstamp ) , MAX_CLOCK_SEQ_AND_NODE ) ; } public static long unixTimestamp ( UUID uuid ) { return ( uuid . timestamp ( ) / <int> ) + START_EPOCH ; } public static long microsTimestamp ( UUID uuid ) { return ( uuid . timestamp ( ) / <int> ) + START_EPOCH * <int> ; } private static long fromUnixTimestamp ( long timestamp ) { return fromUnixTimestamp ( timestamp , <int> L ) ; } private static long fromUnixTimestamp ( long timestamp , long nanos ) { return ( ( timestamp - START_EPOCH ) * <int> ) + nanos ; } public static byte [ ] getTimeUUIDBytes ( long timeMillis , int nanos ) { if ( nanos > = <int> ) throw new IllegalArgumentException ( ) ; return createTimeUUIDBytes ( instance . createTimeUnsafe ( timeMillis , nanos ) ) ; } private static byte [ ] createTimeUUIDBytes ( long msb ) { long lsb = clockSeqAndNode ; byte [ ] uuidBytes = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) uuidBytes [ i ] = ( byte ) ( msb > > > <int> * ( <int> - i ) ) ; for ( int i = <int> ; i < <int> ; i + + ) uuidBytes [ i ] = ( byte ) ( lsb > > > <int> * ( <int> - i ) ) ; return uuidBytes ; } public static long getAdjustedTimestamp ( UUID uuid ) { if ( uuid . version ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + uuid . version ( ) ) ; return ( uuid . timestamp ( ) / <int> ) + START_EPOCH ; } private static long makeClockSeqAndNode ( ) { long clock = new Random ( System . currentTimeMillis ( ) ) . nextLong ( ) ; long lsb = <int> ; lsb | = <hex> ; lsb | = ( clock & <hex> ) < < <int> ; lsb | = makeNode ( ) ; return lsb ; } private synchronized long createTimeSafe ( ) { long nanosSince = ( System . currentTimeMillis ( ) - START_EPOCH ) * <int> ; if ( nanosSince > lastNanos ) lastNanos = nanosSince ; else nanosSince = + + lastNanos ; return createTime ( nanosSince ) ; } private long createTimeUnsafe ( long when , int nanos ) { long nanosSince = ( ( when - START_EPOCH ) * <int> ) + nanos ; return createTime ( nanosSince ) ; } private static long createTime ( long nanosSince ) { long msb = <int> L ; msb | = ( <hex> & nanosSince ) < < <int> ; msb | = ( <hex> & nanosSince ) > > > <int> ; msb | = ( <hex> & nanosSince ) > > > <int> ; msb | = <hex> ; return msb ; } private static long makeNode ( ) { Collection < InetAddress > localAddresses = FBUtilities . getAllLocalAddresses ( ) ; if ( localAddresses . isEmpty ( ) ) throw new RuntimeException ( <str> ) ; byte [ ] hash = hash ( localAddresses ) ; long node = <int> ; for ( int i = <int> ; i < Math . min ( <int> , hash . length ) ; i + + ) node | = ( <hex> & ( long ) hash [ i ] ) < < ( <int> - i ) * <int> ; assert ( <hex> & node ) = = <int> ; return node | <hex> ; } private static byte [ ] hash ( Collection < InetAddress > data ) { try { MessageDigest messageDigest = MessageDigest . getInstance ( <str> ) ; for ( InetAddress addr : data ) messageDigest . update ( addr . getAddress ( ) ) ; return messageDigest . digest ( ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( <str> , nsae ) ; } } } 
