package com . google . common . primitives ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Locale ; @GwtCompatible ( emulated = true ) @SuppressWarnings ( <str> ) public class CharsTest extends TestCase { private static final char [ ] EMPTY = { } ; private static final char [ ] ARRAY1 = { ( char ) <int> } ; private static final char [ ] ARRAY234 = { ( char ) <int> , ( char ) <int> , ( char ) <int> } ; private static final char LEAST = Character . MIN_VALUE ; private static final char GREATEST = Character . MAX_VALUE ; private static final char [ ] VALUES = { LEAST , <str> , <str> , <str> , GREATEST } ; public void testHashCode ( ) { for ( char value : VALUES ) { assertEquals ( ( ( Character ) value ) . hashCode ( ) , Chars . hashCode ( value ) ) ; } } public void testCheckedCast ( ) { for ( char value : VALUES ) { assertEquals ( value , Chars . checkedCast ( ( long ) value ) ) ; } assertCastFails ( GREATEST + <int> ) ; assertCastFails ( LEAST - <int> ) ; assertCastFails ( Long . MAX_VALUE ) ; assertCastFails ( Long . MIN_VALUE ) ; } public void testSaturatedCast ( ) { for ( char value : VALUES ) { assertEquals ( value , Chars . saturatedCast ( ( long ) value ) ) ; } assertEquals ( GREATEST , Chars . saturatedCast ( GREATEST + <int> ) ) ; assertEquals ( LEAST , Chars . saturatedCast ( LEAST - <int> ) ) ; assertEquals ( GREATEST , Chars . saturatedCast ( Long . MAX_VALUE ) ) ; assertEquals ( LEAST , Chars . saturatedCast ( Long . MIN_VALUE ) ) ; } @SuppressWarnings ( <str> ) private void assertCastFails ( long value ) { try { Chars . checkedCast ( value ) ; fail ( <str> + value ) ; } catch ( IllegalArgumentException ex ) { assertTrue ( value + <str> + ex . getMessage ( ) , ex . getMessage ( ) . contains ( String . valueOf ( value ) ) ) ; } } public void testCompare ( ) { for ( char x : VALUES ) { for ( char y : VALUES ) { assertEquals ( x + <str> + y , Character . valueOf ( x ) . compareTo ( y ) , Chars . compare ( x , y ) ) ; } } } public void testContains ( ) { assertFalse ( Chars . contains ( EMPTY , ( char ) <int> ) ) ; assertFalse ( Chars . contains ( ARRAY1 , ( char ) <int> ) ) ; assertFalse ( Chars . contains ( ARRAY234 , ( char ) <int> ) ) ; assertTrue ( Chars . contains ( new char [ ] { ( char ) - <int> } , ( char ) - <int> ) ) ; assertTrue ( Chars . contains ( ARRAY234 , ( char ) <int> ) ) ; assertTrue ( Chars . contains ( ARRAY234 , ( char ) <int> ) ) ; assertTrue ( Chars . contains ( ARRAY234 , ( char ) <int> ) ) ; } public void testIndexOf ( ) { assertEquals ( - <int> , Chars . indexOf ( EMPTY , ( char ) <int> ) ) ; assertEquals ( - <int> , Chars . indexOf ( ARRAY1 , ( char ) <int> ) ) ; assertEquals ( - <int> , Chars . indexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . indexOf ( new char [ ] { ( char ) - <int> } , ( char ) - <int> ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . indexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , ( char ) <int> ) ) ; } public void testIndexOf_arrayTarget ( ) { assertEquals ( <int> , Chars . indexOf ( EMPTY , EMPTY ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , EMPTY ) ) ; assertEquals ( - <int> , Chars . indexOf ( EMPTY , ARRAY234 ) ) ; assertEquals ( - <int> , Chars . indexOf ( ARRAY234 , ARRAY1 ) ) ; assertEquals ( - <int> , Chars . indexOf ( ARRAY1 , ARRAY234 ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY1 , ARRAY1 ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , ARRAY234 ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , new char [ ] { ( char ) <int> , ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , new char [ ] { ( char ) <int> , ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , new char [ ] { ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( ARRAY234 , new char [ ] { ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , new char [ ] { ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } ) ) ; assertEquals ( <int> , Chars . indexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } ) ) ; assertEquals ( - <int> , Chars . indexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } , new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } ) ) ; } public void testLastIndexOf ( ) { assertEquals ( - <int> , Chars . lastIndexOf ( EMPTY , ( char ) <int> ) ) ; assertEquals ( - <int> , Chars . lastIndexOf ( ARRAY1 , ( char ) <int> ) ) ; assertEquals ( - <int> , Chars . lastIndexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . lastIndexOf ( new char [ ] { ( char ) - <int> } , ( char ) - <int> ) ) ; assertEquals ( <int> , Chars . lastIndexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . lastIndexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . lastIndexOf ( ARRAY234 , ( char ) <int> ) ) ; assertEquals ( <int> , Chars . lastIndexOf ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , ( char ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { Chars . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( LEAST , Chars . max ( LEAST ) ) ; assertEquals ( GREATEST , Chars . max ( GREATEST ) ) ; assertEquals ( ( char ) <int> , Chars . max ( ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { Chars . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( LEAST , Chars . min ( LEAST ) ) ; assertEquals ( GREATEST , Chars . min ( GREATEST ) ) ; assertEquals ( ( char ) <int> , Chars . min ( ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> ) ) ; } public void testConcat ( ) { assertTrue ( Arrays . equals ( EMPTY , Chars . concat ( ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Chars . concat ( EMPTY ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Chars . concat ( EMPTY , EMPTY , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Chars . concat ( ARRAY1 ) ) ) ; assertNotSame ( ARRAY1 , Chars . concat ( ARRAY1 ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Chars . concat ( EMPTY , ARRAY1 , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } , Chars . concat ( ARRAY1 , ARRAY1 , ARRAY1 ) ) ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } , Chars . concat ( ARRAY1 , ARRAY234 ) ) ) ; } @GwtIncompatible ( <str> ) public void testFromByteArray ( ) { assertEquals ( <str> , Chars . fromByteArray ( new byte [ ] { <hex> , <hex> , ( byte ) <hex> } ) ) ; assertEquals ( <str> , Chars . fromByteArray ( new byte [ ] { ( byte ) <hex> , ( byte ) <hex> } ) ) ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) public void testFromByteArrayFails ( ) { try { Chars . fromByteArray ( new byte [ Chars . BYTES - <int> ] ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testFromBytes ( ) { assertEquals ( <str> , Chars . fromBytes ( ( byte ) <hex> , ( byte ) <hex> ) ) ; assertEquals ( <str> , Chars . fromBytes ( ( byte ) <hex> , ( byte ) <hex> ) ) ; } @GwtIncompatible ( <str> ) public void testByteArrayRoundTrips ( ) { char c = <int> ; for ( int hi = <int> ; hi < <int> ; hi + + ) { for ( int lo = <int> ; lo < <int> ; lo + + ) { char result = Chars . fromByteArray ( new byte [ ] { ( byte ) hi , ( byte ) lo } ) ; assertEquals ( String . format ( Locale . ROOT , <str> , hi , lo , ( int ) c , ( int ) result ) , c , result ) ; byte [ ] bytes = Chars . toByteArray ( c ) ; assertEquals ( ( byte ) hi , bytes [ <int> ] ) ; assertEquals ( ( byte ) lo , bytes [ <int> ] ) ; c + + ; } } assertEquals ( ( char ) <int> , c ) ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) public void testByteArrayRoundTripsFails ( ) { try { Chars . fromByteArray ( new byte [ ] { <hex> } ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testEnsureCapacity ( ) { assertSame ( EMPTY , Chars . ensureCapacity ( EMPTY , <int> , <int> ) ) ; assertSame ( ARRAY1 , Chars . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertSame ( ARRAY1 , Chars . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } , Chars . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testEnsureCapacity_fail ( ) { try { Chars . ensureCapacity ( ARRAY1 , - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { Chars . ensureCapacity ( ARRAY1 , <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testJoin ( ) { assertEquals ( <str> , Chars . join ( <str> , EMPTY ) ) ; assertEquals ( <str> , Chars . join ( <str> , <str> ) ) ; assertEquals ( <str> , Chars . join ( <str> , <str> , <str> ) ) ; assertEquals ( <str> , Chars . join ( <str> , <str> , <str> , <str> ) ) ; } public void testLexicographicalComparator ( ) { List < char [ ] > ordered = Arrays . asList ( new char [ ] { } , new char [ ] { LEAST } , new char [ ] { LEAST , LEAST } , new char [ ] { LEAST , ( char ) <int> } , new char [ ] { ( char ) <int> } , new char [ ] { ( char ) <int> , LEAST } , new char [ ] { GREATEST , GREATEST - ( char ) <int> } , new char [ ] { GREATEST , GREATEST } , new char [ ] { GREATEST , GREATEST , GREATEST } ) ; Comparator < char [ ] > comparator = Chars . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; } @GwtIncompatible ( <str> ) public void testLexicographicalComparatorSerializable ( ) { Comparator < char [ ] > comparator = Chars . lexicographicalComparator ( ) ; assertSame ( comparator , SerializableTester . reserialize ( comparator ) ) ; } public void testToArray ( ) { List < Character > none = Arrays . < Character > asList ( ) ; assertTrue ( Arrays . equals ( EMPTY , Chars . toArray ( none ) ) ) ; List < Character > one = Arrays . asList ( ( char ) <int> ) ; assertTrue ( Arrays . equals ( ARRAY1 , Chars . toArray ( one ) ) ) ; char [ ] array = { ( char ) <int> , ( char ) <int> , <str> } ; List < Character > three = Arrays . asList ( ( char ) <int> , ( char ) <int> , <str> ) ; assertTrue ( Arrays . equals ( array , Chars . toArray ( three ) ) ) ; assertTrue ( Arrays . equals ( array , Chars . toArray ( Chars . asList ( array ) ) ) ) ; } public void testToArray_threadSafe ( ) { for ( int delta : new int [ ] { + <int> , <int> , - <int> } ) { for ( int i = <int> ; i < VALUES . length ; i + + ) { List < Character > list = Chars . asList ( VALUES ) . subList ( <int> , i ) ; Collection < Character > misleadingSize = Helpers . misleadingSizeCollection ( delta ) ; misleadingSize . addAll ( list ) ; char [ ] arr = Chars . toArray ( misleadingSize ) ; assertEquals ( i , arr . length ) ; for ( int j = <int> ; j < i ; j + + ) { assertEquals ( VALUES [ j ] , arr [ j ] ) ; } } } } @SuppressWarnings ( <str> ) public void testToArray_withNull ( ) { List < Character > list = Arrays . asList ( ( char ) <int> , ( char ) <int> , null ) ; try { Chars . toArray ( list ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testAsList_isAView ( ) { char [ ] array = { ( char ) <int> , ( char ) <int> } ; List < Character > list = Chars . asList ( array ) ; list . set ( <int> , ( char ) <int> ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> } , array ) ) ; array [ <int> ] = ( char ) <int> ; assertEquals ( Arrays . asList ( ( char ) <int> , ( char ) <int> ) , list ) ; } public void testAsList_toArray_roundTrip ( ) { char [ ] array = { ( char ) <int> , ( char ) <int> , ( char ) <int> } ; List < Character > list = Chars . asList ( array ) ; char [ ] newArray = Chars . toArray ( list ) ; list . set ( <int> , ( char ) <int> ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> , ( char ) <int> } , newArray ) ) ; newArray [ <int> ] = ( char ) <int> ; assertEquals ( ( char ) <int> , ( char ) list . get ( <int> ) ) ; } public void testAsList_subList_toArray_roundTrip ( ) { char [ ] array = { ( char ) <int> , ( char ) <int> , ( char ) <int> , ( char ) <int> } ; List < Character > list = Chars . asList ( array ) ; assertTrue ( Arrays . equals ( new char [ ] { ( char ) <int> , ( char ) <int> } , Chars . toArray ( list . subList ( <int> , <int> ) ) ) ) ; assertTrue ( Arrays . equals ( new char [ ] { } , Chars . toArray ( list . subList ( <int> , <int> ) ) ) ) ; } public void testAsListEmpty ( ) { assertSame ( Collections . emptyList ( ) , Chars . asList ( EMPTY ) ) ; } @GwtIncompatible ( <str> ) public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Chars . class ) ; } } 
