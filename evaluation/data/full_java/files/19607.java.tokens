package io . netty . handler . codec . stomp ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; public class StompSubframeEncoderTest { private EmbeddedChannel channel ; @Before public void setup ( ) throws Exception { channel = new EmbeddedChannel ( new StompSubframeEncoder ( ) ) ; } @After public void teardown ( ) throws Exception { assertFalse ( channel . finish ( ) ) ; } @Test public void testFrameAndContentEncoding ( ) { StompHeadersSubframe frame = new DefaultStompHeadersSubframe ( StompCommand . CONNECT ) ; StompHeaders headers = frame . headers ( ) ; headers . set ( StompHeaders . HOST , <str> ) ; headers . set ( StompHeaders . ACCEPT_VERSION , <str> ) ; channel . writeOutbound ( frame ) ; channel . writeOutbound ( LastStompContentSubframe . EMPTY_LAST_CONTENT ) ; ByteBuf aggregatedBuffer = Unpooled . buffer ( ) ; ByteBuf byteBuf = channel . readOutbound ( ) ; assertNotNull ( byteBuf ) ; aggregatedBuffer . writeBytes ( byteBuf ) ; byteBuf = channel . readOutbound ( ) ; assertNotNull ( byteBuf ) ; aggregatedBuffer . writeBytes ( byteBuf ) ; aggregatedBuffer . resetReaderIndex ( ) ; String content = aggregatedBuffer . toString ( CharsetUtil . UTF_8 ) ; assertEquals ( StompTestConstants . CONNECT_FRAME , content ) ; } } 
