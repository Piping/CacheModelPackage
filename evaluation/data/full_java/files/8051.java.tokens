package org . elasticsearch . gateway ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; public class PriorityComparatorTests extends ESTestCase { public void testPreferNewIndices ( ) { RoutingNodes . UnassignedShards shards = new RoutingNodes . UnassignedShards ( ( RoutingNodes ) null ) ; List < ShardRouting > shardRoutings = Arrays . asList ( TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , randomBoolean ( ) , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( randomFrom ( UnassignedInfo . Reason . values ( ) ) , <str> ) ) , TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , randomBoolean ( ) , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( randomFrom ( UnassignedInfo . Reason . values ( ) ) , <str> ) ) ) ; Collections . shuffle ( shardRoutings , random ( ) ) ; for ( ShardRouting routing : shardRoutings ) { shards . add ( routing ) ; } shards . sort ( new PriorityComparator ( ) { @Override protected Settings getIndexSettings ( String index ) { if ( <str> . equals ( index ) ) { return Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , <int> ) . put ( IndexMetaData . SETTING_PRIORITY , <int> ) . build ( ) ; } else if ( <str> . equals ( index ) ) { return Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , <int> ) . put ( IndexMetaData . SETTING_PRIORITY , <int> ) . build ( ) ; } return Settings . EMPTY ; } } ) ; RoutingNodes . UnassignedShards . UnassignedIterator iterator = shards . iterator ( ) ; ShardRouting next = iterator . next ( ) ; assertEquals ( <str> , next . index ( ) ) ; next = iterator . next ( ) ; assertEquals ( <str> , next . index ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testPreferPriorityIndices ( ) { RoutingNodes . UnassignedShards shards = new RoutingNodes . UnassignedShards ( ( RoutingNodes ) null ) ; List < ShardRouting > shardRoutings = Arrays . asList ( TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , randomBoolean ( ) , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( randomFrom ( UnassignedInfo . Reason . values ( ) ) , <str> ) ) , TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , randomBoolean ( ) , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( randomFrom ( UnassignedInfo . Reason . values ( ) ) , <str> ) ) ) ; Collections . shuffle ( shardRoutings , random ( ) ) ; for ( ShardRouting routing : shardRoutings ) { shards . add ( routing ) ; } shards . sort ( new PriorityComparator ( ) { @Override protected Settings getIndexSettings ( String index ) { if ( <str> . equals ( index ) ) { return Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , <int> ) . put ( IndexMetaData . SETTING_PRIORITY , <int> ) . build ( ) ; } else if ( <str> . equals ( index ) ) { return Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , <int> ) . put ( IndexMetaData . SETTING_PRIORITY , <int> ) . build ( ) ; } return Settings . EMPTY ; } } ) ; RoutingNodes . UnassignedShards . UnassignedIterator iterator = shards . iterator ( ) ; ShardRouting next = iterator . next ( ) ; assertEquals ( <str> , next . index ( ) ) ; next = iterator . next ( ) ; assertEquals ( <str> , next . index ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testPriorityComparatorSort ( ) { RoutingNodes . UnassignedShards shards = new RoutingNodes . UnassignedShards ( ( RoutingNodes ) null ) ; int numIndices = randomIntBetween ( <int> , <int> ) ; IndexMeta [ ] indices = new IndexMeta [ numIndices ] ; final Map < String , IndexMeta > map = new HashMap < > ( ) ; for ( int i = <int> ; i < indices . length ; i + + ) { if ( frequently ( ) ) { indices [ i ] = new IndexMeta ( <str> + String . format ( Locale . ROOT , <str> , i ) , randomIntBetween ( <int> , <int> ) , randomIntBetween ( <int> , <int> ) ) ; } else { indices [ i ] = new IndexMeta ( <str> + String . format ( Locale . ROOT , <str> , i ) ) ; } map . put ( indices [ i ] . name , indices [ i ] ) ; } int numShards = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numShards ; i + + ) { IndexMeta indexMeta = randomFrom ( indices ) ; shards . add ( TestShardRouting . newShardRouting ( indexMeta . name , randomIntBetween ( <int> , <int> ) , null , null , null , randomBoolean ( ) , ShardRoutingState . UNASSIGNED , randomIntBetween ( <int> , <int> ) , new UnassignedInfo ( randomFrom ( UnassignedInfo . Reason . values ( ) ) , <str> ) ) ) ; } shards . sort ( new PriorityComparator ( ) { @Override protected Settings getIndexSettings ( String index ) { IndexMeta indexMeta = map . get ( index ) ; return indexMeta . settings ; } } ) ; ShardRouting previous = null ; for ( ShardRouting routing : shards ) { if ( previous ! = null ) { IndexMeta prevMeta = map . get ( previous . getIndex ( ) ) ; IndexMeta currentMeta = map . get ( routing . getIndex ( ) ) ; if ( prevMeta . priority = = currentMeta . priority ) { if ( prevMeta . creationDate = = currentMeta . creationDate ) { if ( prevMeta . name . equals ( currentMeta . name ) = = false ) { assertTrue ( <str> + currentMeta . name + <str> + prevMeta . name + <str> + prevMeta . name . compareTo ( currentMeta . name ) , prevMeta . name . compareTo ( currentMeta . name ) > <int> ) ; } } else { assertTrue ( <str> + currentMeta . creationDate + <str> + prevMeta . creationDate , prevMeta . creationDate > currentMeta . creationDate ) ; } } else { assertTrue ( <str> + currentMeta . priority + <str> + prevMeta . priority , prevMeta . priority > currentMeta . priority ) ; } } previous = routing ; } } private static class IndexMeta { final String name ; final int priority ; final long creationDate ; final Settings settings ; private IndexMeta ( String name ) { this . name = name ; this . priority = <int> ; this . creationDate = - <int> ; this . settings = Settings . EMPTY ; } private IndexMeta ( String name , int priority , long creationDate ) { this . name = name ; this . priority = priority ; this . creationDate = creationDate ; this . settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , creationDate ) . put ( IndexMetaData . SETTING_PRIORITY , priority ) . build ( ) ; } } } 
