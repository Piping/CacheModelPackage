package org . elasticsearch . rest . action . admin . cluster . node . info ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoRequest ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . rest . BaseRestHandler ; import org . elasticsearch . rest . BytesRestResponse ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import java . util . Set ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestNodesInfoAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; private final static Set < String > ALLOWED_METRICS = Sets . newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; @Inject public RestNodesInfoAction ( Settings settings , RestController controller , Client client , SettingsFilter settingsFilter ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; this . settingsFilter = settingsFilter ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { String [ ] nodeIds ; Set < String > metrics ; if ( request . hasParam ( <str> ) & & ! request . hasParam ( <str> ) ) { Set < String > metricsOrNodeIds = Strings . splitStringByCommaToSet ( request . param ( <str> , <str> ) ) ; boolean isMetricsOnly = ALLOWED_METRICS . containsAll ( metricsOrNodeIds ) ; if ( isMetricsOnly ) { nodeIds = new String [ ] { <str> } ; metrics = metricsOrNodeIds ; } else { nodeIds = metricsOrNodeIds . toArray ( new String [ ] { } ) ; metrics = Sets . newHashSet ( <str> ) ; } } else { nodeIds = Strings . splitStringByCommaToArray ( request . param ( <str> , <str> ) ) ; metrics = Strings . splitStringByCommaToSet ( request . param ( <str> , <str> ) ) ; } final NodesInfoRequest nodesInfoRequest = new NodesInfoRequest ( nodeIds ) ; nodesInfoRequest . timeout ( request . param ( <str> ) ) ; if ( metrics . size ( ) = = <int> & & metrics . contains ( <str> ) ) { nodesInfoRequest . all ( ) ; } else { nodesInfoRequest . clear ( ) ; nodesInfoRequest . settings ( metrics . contains ( <str> ) ) ; nodesInfoRequest . os ( metrics . contains ( <str> ) ) ; nodesInfoRequest . process ( metrics . contains ( <str> ) ) ; nodesInfoRequest . jvm ( metrics . contains ( <str> ) ) ; nodesInfoRequest . threadPool ( metrics . contains ( <str> ) ) ; nodesInfoRequest . transport ( metrics . contains ( <str> ) ) ; nodesInfoRequest . http ( metrics . contains ( <str> ) ) ; nodesInfoRequest . plugins ( metrics . contains ( <str> ) ) ; } settingsFilter . addFilterSettingParams ( request ) ; client . admin ( ) . cluster ( ) . nodesInfo ( nodesInfoRequest , new RestBuilderListener < NodesInfoResponse > ( channel ) { @Override public RestResponse buildResponse ( NodesInfoResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; return new BytesRestResponse ( RestStatus . OK , builder ) ; } } ) ; } } 
