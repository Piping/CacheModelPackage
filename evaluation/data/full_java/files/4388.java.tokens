package org . eclipse . debug . internal . ui . viewers . model ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . jface . viewers . TreePath ; public class FilterTransform { private Node root = new Node ( ) ; class Node { private int [ ] filteredIndexes = null ; private Object [ ] filteredElements = null ; private Map < Object , Node > children = null ; Node ( ) { } boolean addFilter ( TreePath path , int childIndex , int pathIndex , Object filtered ) { if ( pathIndex = = path . getSegmentCount ( ) ) { if ( filteredIndexes = = null ) { filteredIndexes = new int [ ] { childIndex } ; filteredElements = new Object [ ] { filtered } ; return true ; } int location = Arrays . binarySearch ( filteredIndexes , childIndex ) ; if ( location > = <int> ) { return false ; } location = <int> - ( location + <int> ) ; int [ ] next = new int [ filteredIndexes . length + <int> ] ; Object [ ] filt = new Object [ next . length ] ; if ( location = = <int> ) { next [ <int> ] = childIndex ; filt [ <int> ] = filtered ; System . arraycopy ( filteredIndexes , <int> , next , <int> , filteredIndexes . length ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , filteredElements . length ) ; } else if ( location = = filteredIndexes . length ) { next [ filteredIndexes . length ] = childIndex ; filt [ filteredElements . length ] = filtered ; System . arraycopy ( filteredIndexes , <int> , next , <int> , filteredIndexes . length ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , filteredElements . length ) ; } else { System . arraycopy ( filteredIndexes , <int> , next , <int> , location ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , location ) ; next [ location ] = childIndex ; filt [ location ] = filtered ; System . arraycopy ( filteredIndexes , location , next , location + <int> , filteredIndexes . length - location ) ; System . arraycopy ( filteredElements , location , filt , location + <int> , filteredElements . length - location ) ; } filteredIndexes = next ; filteredElements = filt ; return true ; } if ( children = = null ) { children = new HashMap < Object , Node > ( ) ; } Object element = path . getSegment ( pathIndex ) ; Node node = children . get ( element ) ; if ( node = = null ) { node = new Node ( ) ; children . put ( element , node ) ; } return node . addFilter ( path , childIndex , pathIndex + <int> , filtered ) ; } boolean clear ( TreePath path , int pathIndex ) { if ( pathIndex = = path . getSegmentCount ( ) ) { return true ; } if ( children = = null ) { return false ; } Object child = path . getSegment ( pathIndex ) ; Node node = children . get ( child ) ; if ( node ! = null ) { if ( node . clear ( path , pathIndex + <int> ) ) { children . remove ( child ) ; } } return children . isEmpty ( ) & & ( filteredIndexes = = null | | filteredIndexes . length = = <int> ) ; } boolean clear ( TreePath path , int childIndex , int pathIndex ) { if ( pathIndex = = path . getSegmentCount ( ) ) { if ( filteredIndexes ! = null ) { int location = Arrays . binarySearch ( filteredIndexes , childIndex ) ; if ( location > = <int> ) { if ( location = = <int> & & filteredIndexes . length = = <int> ) { filteredIndexes = null ; filteredElements = null ; return true ; } int [ ] next = new int [ filteredIndexes . length - <int> ] ; Object [ ] filt = new Object [ next . length ] ; if ( location = = <int> ) { System . arraycopy ( filteredIndexes , <int> , next , <int> , next . length ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , filt . length ) ; } else if ( location = = ( filteredIndexes . length - <int> ) ) { System . arraycopy ( filteredIndexes , <int> , next , <int> , location ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , location ) ; } else { System . arraycopy ( filteredIndexes , <int> , next , <int> , location ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , location ) ; System . arraycopy ( filteredIndexes , location + <int> , next , location , next . length - location ) ; System . arraycopy ( filteredElements , location + <int> , filt , location , filt . length - location ) ; } filteredIndexes = next ; filteredElements = filt ; return false ; } } else { return false ; } } if ( children = = null ) { return false ; } Object element = path . getSegment ( pathIndex ) ; Node node = children . get ( element ) ; if ( node = = null ) { return false ; } boolean remove = node . clear ( path , childIndex , pathIndex + <int> ) ; if ( remove ) { children . remove ( element ) ; return filteredIndexes = = null & & children . isEmpty ( ) ; } else { return false ; } } Node find ( TreePath path , int pathIndex ) { if ( pathIndex = = path . getSegmentCount ( ) ) { return this ; } if ( children = = null ) { return null ; } Object child = path . getSegment ( pathIndex ) ; Node node = children . get ( child ) ; if ( node ! = null ) { return node . find ( path , pathIndex + <int> ) ; } return null ; } int viewToModel ( int childIndex ) { if ( filteredIndexes = = null ) { return childIndex ; } int count = - <int> ; int missingNumbers = <int> ; int offset = <int> ; while ( missingNumbers < ( childIndex + <int> ) ) { count + + ; if ( offset < filteredIndexes . length ) { if ( filteredIndexes [ offset ] = = count ) { offset + + ; } else { missingNumbers + + ; } } else { missingNumbers + + ; } } return count ; } int modelToView ( int childIndex ) { if ( filteredIndexes = = null ) { return childIndex ; } int offset = <int> ; for ( int i = <int> ; i < filteredIndexes . length ; i + + ) { if ( childIndex = = filteredIndexes [ i ] ) { return - <int> ; } else if ( childIndex > filteredIndexes [ i ] ) { offset + + ; } else { break ; } } return childIndex - offset ; } int modelToViewCount ( int childCount ) { if ( filteredIndexes = = null ) { return childCount ; } return childCount - filteredIndexes . length ; } boolean isFiltered ( int index ) { if ( filteredIndexes ! = null ) { int location = Arrays . binarySearch ( filteredIndexes , index ) ; return location > = <int> ; } return false ; } int indexOfFilteredElement ( Object element ) { if ( filteredElements ! = null ) { for ( int i = <int> ; i < filteredElements . length ; i + + ) { if ( element . equals ( filteredElements [ i ] ) ) { return filteredIndexes [ i ] ; } } } return - <int> ; } void setModelChildCount ( int childCount ) { if ( filteredIndexes ! = null ) { for ( int i = <int> ; i < filteredIndexes . length ; i + + ) { if ( filteredIndexes [ i ] > = childCount ) { if ( i = = <int> ) { filteredIndexes = null ; filteredElements = null ; return ; } else { int [ ] temp = new int [ i + <int> ] ; System . arraycopy ( filteredIndexes , <int> , temp , <int> , temp . length ) ; filteredIndexes = temp ; Object [ ] temp2 = new Object [ i + <int> ] ; System . arraycopy ( filteredElements , <int> , temp2 , <int> , temp2 . length ) ; filteredElements = temp2 ; } } } } } void removeElementFromFilters ( int index ) { if ( filteredIndexes ! = null ) { int location = Arrays . binarySearch ( filteredIndexes , index ) ; if ( location > = <int> ) { if ( filteredIndexes . length = = <int> ) { filteredIndexes = null ; filteredElements = null ; } else { int [ ] next = new int [ filteredIndexes . length - <int> ] ; Object [ ] filt = new Object [ next . length ] ; if ( location = = <int> ) { System . arraycopy ( filteredIndexes , <int> , next , <int> , next . length ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , filt . length ) ; } else if ( location = = ( filteredIndexes . length - <int> ) ) { System . arraycopy ( filteredIndexes , <int> , next , <int> , next . length ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , filt . length ) ; } else { System . arraycopy ( filteredIndexes , <int> , next , <int> , location ) ; System . arraycopy ( filteredElements , <int> , filt , <int> , location ) ; System . arraycopy ( filteredIndexes , location + <int> , next , location , next . length - location ) ; System . arraycopy ( filteredElements , location + <int> , filt , location , filt . length - location ) ; } filteredIndexes = next ; filteredElements = filt ; } } else { location = <int> - ( location + <int> ) ; } if ( filteredIndexes ! = null ) { for ( int i = location ; i < filteredIndexes . length ; i + + ) { filteredIndexes [ i ] - - ; } } } } } public boolean addFilteredIndex ( TreePath parentPath , int childIndex , Object element ) { return root . addFilter ( parentPath , childIndex , <int> , element ) ; } public void clear ( ) { root = new Node ( ) ; } public void clear ( TreePath path ) { root . clear ( path , <int> ) ; } public void clear ( TreePath parentPath , int index ) { root . clear ( parentPath , index , <int> ) ; } public int indexOfFilteredElement ( TreePath parentPath , Object element ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return - <int> ; } return parentNode . indexOfFilteredElement ( element ) ; } public int modelToViewIndex ( TreePath parentPath , int childIndex ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return childIndex ; } return parentNode . modelToView ( childIndex ) ; } public int viewToModelIndex ( TreePath parentPath , int childIndex ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return childIndex ; } return parentNode . viewToModel ( childIndex ) ; } public int viewToModelCount ( TreePath parentPath , int viewCount ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode ! = null ) { if ( parentNode . filteredIndexes ! = null ) { return viewCount + parentNode . filteredIndexes . length ; } } return viewCount ; } public int modelToViewCount ( TreePath parentPath , int count ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return count ; } return parentNode . modelToViewCount ( count ) ; } public boolean isFiltered ( TreePath parentPath , int index ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return false ; } return parentNode . isFiltered ( index ) ; } public int [ ] getFilteredChildren ( TreePath parentPath ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode = = null ) { return null ; } return parentNode . filteredIndexes ; } public void setModelChildCount ( TreePath parentPath , int childCount ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode ! = null ) { parentNode . setModelChildCount ( childCount ) ; } } public void removeElementFromFilters ( TreePath parentPath , int index ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode ! = null ) { parentNode . removeElementFromFilters ( index ) ; } } public boolean removeElementFromFilters ( TreePath parentPath , Object element ) { Node parentNode = root . find ( parentPath , <int> ) ; if ( parentNode ! = null ) { int index = parentNode . indexOfFilteredElement ( element ) ; if ( index > = <int> ) { parentNode . removeElementFromFilters ( index ) ; return true ; } } return false ; } } 
