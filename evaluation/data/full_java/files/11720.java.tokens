package org . gradle . api . internal . tasks . options ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . * ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; public class OptionNotationParserFactory { public ValueAwareNotationParser < Object > toComposite ( Class < ? > targetType ) throws OptionValidationException { assert targetType ! = null : <str> ; List < ValueAwareNotationParser < ? > > parsers = new ArrayList < ValueAwareNotationParser < ? > > ( ) ; if ( targetType = = Void . TYPE ) { parsers . add ( new UnsupportedNotationParser ( ) ) ; } if ( targetType . isAssignableFrom ( String . class ) ) { parsers . add ( new NoDescriptionValuesJustReturningParser ( ) ) ; } if ( targetType . isEnum ( ) ) { parsers . add ( new EnumFromCharSequenceNotationParser < Enum > ( targetType . asSubclass ( Enum . class ) ) ) ; } if ( parsers . isEmpty ( ) ) { throw new OptionValidationException ( String . format ( <str> , targetType . getName ( ) ) ) ; } return new ValueAwareCompositeNotationParser < Object > ( parsers ) ; } private static class UnsupportedNotationParser implements ValueAwareNotationParser < Object > { public Object parseNotation ( CharSequence notation ) throws UnsupportedNotationException , TypeConversionException { throw new UnsupportedOperationException ( ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { } public void describeValues ( Collection < String > collector ) { } } private static class NoDescriptionValuesJustReturningParser implements ValueAwareNotationParser < String > { public String parseNotation ( CharSequence notation ) { return notation . toString ( ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) ; } public void describeValues ( Collection < String > collector ) { } } private static class ValueAwareCompositeNotationParser < T > extends CompositeNotationParser < CharSequence , T > implements ValueAwareNotationParser < T > { private final Collection < ValueAwareNotationParser < ? extends T > > delegates ; public ValueAwareCompositeNotationParser ( Collection < ValueAwareNotationParser < ? extends T > > delegates ) { super ( delegates ) ; this . delegates = delegates ; } public void describeValues ( Collection < String > collector ) { for ( ValueAwareNotationParser < ? extends T > delegate : delegates ) { delegate . describeValues ( collector ) ; } } } } 
