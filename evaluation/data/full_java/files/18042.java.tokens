package com . badlogic . gdx . graphics . g3d . particles ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . g3d . particles . renderers . ParticleControllerRenderData ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; public abstract class ParticleSorter { static final Vector3 TMP_V1 = new Vector3 ( ) ; public static class None extends ParticleSorter { int currentCapacity = <int> ; int [ ] indices ; @Override public void ensureCapacity ( int capacity ) { if ( currentCapacity < capacity ) { indices = new int [ capacity ] ; for ( int i = <int> ; i < capacity ; + + i ) indices [ i ] = i ; currentCapacity = capacity ; } } @Override public < T extends ParticleControllerRenderData > int [ ] sort ( Array < T > renderData ) { return indices ; } } public static class Distance extends ParticleSorter { private float [ ] distances ; private int [ ] particleIndices , particleOffsets ; private int currentSize = <int> ; @Override public void ensureCapacity ( int capacity ) { if ( currentSize < capacity ) { distances = new float [ capacity ] ; particleIndices = new int [ capacity ] ; particleOffsets = new int [ capacity ] ; currentSize = capacity ; } } @Override public < T extends ParticleControllerRenderData > int [ ] sort ( Array < T > renderData ) { float [ ] val = camera . view . val ; float cx = val [ Matrix4 . M20 ] , cy = val [ Matrix4 . M21 ] , cz = val [ Matrix4 . M22 ] ; int count = <int> , i = <int> ; for ( ParticleControllerRenderData data : renderData ) { for ( int k = <int> , c = i + data . controller . particles . size ; i < c ; + + i , k + = data . positionChannel . strideSize ) { distances [ i ] = cx * data . positionChannel . data [ k + ParticleChannels . XOffset ] + cy * data . positionChannel . data [ k + ParticleChannels . YOffset ] + cz * data . positionChannel . data [ k + ParticleChannels . ZOffset ] ; particleIndices [ i ] = i ; } count + = data . controller . particles . size ; } qsort ( <int> , count - <int> ) ; for ( i = <int> ; i < count ; + + i ) { particleOffsets [ particleIndices [ i ] ] = i ; } return particleOffsets ; } public void qsort ( int si , int ei ) { if ( si < ei ) { float tmp ; int tmpIndex , particlesPivotIndex ; if ( ei - si < = <int> ) { for ( int i = si ; i < = ei ; i + + ) for ( int j = i ; j > si & & distances [ j - <int> ] > distances [ j ] ; j - - ) { tmp = distances [ j ] ; distances [ j ] = distances [ j - <int> ] ; distances [ j - <int> ] = tmp ; tmpIndex = particleIndices [ j ] ; particleIndices [ j ] = particleIndices [ j - <int> ] ; particleIndices [ j - <int> ] = tmpIndex ; } return ; } float pivot = distances [ si ] ; int i = si + <int> ; particlesPivotIndex = particleIndices [ si ] ; for ( int j = si + <int> ; j < = ei ; j + + ) { if ( pivot > distances [ j ] ) { if ( j > i ) { tmp = distances [ j ] ; distances [ j ] = distances [ i ] ; distances [ i ] = tmp ; tmpIndex = particleIndices [ j ] ; particleIndices [ j ] = particleIndices [ i ] ; particleIndices [ i ] = tmpIndex ; } i + + ; } } distances [ si ] = distances [ i - <int> ] ; distances [ i - <int> ] = pivot ; particleIndices [ si ] = particleIndices [ i - <int> ] ; particleIndices [ i - <int> ] = particlesPivotIndex ; qsort ( si , i - <int> ) ; qsort ( i , ei ) ; } } } protected Camera camera ; public abstract < T extends ParticleControllerRenderData > int [ ] sort ( Array < T > renderData ) ; public void setCamera ( Camera camera ) { this . camera = camera ; } public void ensureCapacity ( int capacity ) { } } 
