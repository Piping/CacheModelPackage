package org . apache . cassandra . utils . memory ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . * ; import org . junit . After ; import org . junit . Before ; import org . junit . Ignore ; import org . junit . Test ; import org . apache . cassandra . io . compress . BufferType ; import org . apache . cassandra . io . util . RandomAccessReader ; import static org . junit . Assert . * ; public class BufferPoolTest { @Before public void setUp ( ) { BufferPool . MEMORY_USAGE_THRESHOLD = <int> * <int> * <int> ; BufferPool . DISABLED = false ; } @After public void cleanUp ( ) { BufferPool . reset ( ) ; } @Test public void testGetPut ( ) throws InterruptedException { final int size = RandomAccessReader . DEFAULT_BUFFER_SIZE ; ByteBuffer buffer = BufferPool . get ( size ) ; assertNotNull ( buffer ) ; assertEquals ( size , buffer . capacity ( ) ) ; assertEquals ( true , buffer . isDirect ( ) ) ; BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; assertEquals ( BufferPool . GlobalPool . MACRO_CHUNK_SIZE , BufferPool . sizeInBytes ( ) ) ; BufferPool . put ( buffer ) ; assertEquals ( null , BufferPool . currentChunk ( ) ) ; assertEquals ( BufferPool . GlobalPool . MACRO_CHUNK_SIZE , BufferPool . sizeInBytes ( ) ) ; } @Test public void testPageAligned ( ) { final int size = <int> ; for ( int i = size ; i < = BufferPool . CHUNK_SIZE ; i + = size ) { checkPageAligned ( i ) ; } } private void checkPageAligned ( int size ) { ByteBuffer buffer = BufferPool . get ( size ) ; assertNotNull ( buffer ) ; assertEquals ( size , buffer . capacity ( ) ) ; assertTrue ( buffer . isDirect ( ) ) ; long address = MemoryUtil . getAddress ( buffer ) ; assertTrue ( ( address % MemoryUtil . pageSize ( ) ) = = <int> ) ; BufferPool . put ( buffer ) ; } @Test public void testDifferentSizes ( ) throws InterruptedException { final int size1 = <int> ; final int size2 = <int> ; ByteBuffer buffer1 = BufferPool . get ( size1 ) ; assertNotNull ( buffer1 ) ; assertEquals ( size1 , buffer1 . capacity ( ) ) ; ByteBuffer buffer2 = BufferPool . get ( size2 ) ; assertNotNull ( buffer2 ) ; assertEquals ( size2 , buffer2 . capacity ( ) ) ; BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; assertEquals ( BufferPool . GlobalPool . MACRO_CHUNK_SIZE , BufferPool . sizeInBytes ( ) ) ; BufferPool . put ( buffer1 ) ; BufferPool . put ( buffer2 ) ; assertEquals ( null , BufferPool . currentChunk ( ) ) ; assertEquals ( BufferPool . GlobalPool . MACRO_CHUNK_SIZE , BufferPool . sizeInBytes ( ) ) ; } @Test public void testMaxMemoryExceededDirect ( ) { boolean cur = BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false ; requestDoubleMaxMemory ( ) ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur ; } @Test public void testMaxMemoryExceededHeap ( ) { boolean cur = BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true ; requestDoubleMaxMemory ( ) ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = cur ; } @Test public void testMaxMemoryExceeded_SameAsChunkSize ( ) { BufferPool . MEMORY_USAGE_THRESHOLD = BufferPool . GlobalPool . MACRO_CHUNK_SIZE ; requestDoubleMaxMemory ( ) ; } @Test public void testMaxMemoryExceeded_SmallerThanChunkSize ( ) { BufferPool . MEMORY_USAGE_THRESHOLD = BufferPool . GlobalPool . MACRO_CHUNK_SIZE / <int> ; requestDoubleMaxMemory ( ) ; } @Test public void testRecycle ( ) { requestUpToSize ( RandomAccessReader . DEFAULT_BUFFER_SIZE , <int> * BufferPool . CHUNK_SIZE ) ; } private void requestDoubleMaxMemory ( ) { requestUpToSize ( RandomAccessReader . DEFAULT_BUFFER_SIZE , ( int ) ( <int> * BufferPool . MEMORY_USAGE_THRESHOLD ) ) ; } private void requestUpToSize ( int bufferSize , int totalSize ) { final int numBuffers = totalSize / bufferSize ; List < ByteBuffer > buffers = new ArrayList < > ( numBuffers ) ; for ( int i = <int> ; i < numBuffers ; i + + ) { ByteBuffer buffer = BufferPool . get ( bufferSize ) ; assertNotNull ( buffer ) ; assertEquals ( bufferSize , buffer . capacity ( ) ) ; if ( BufferPool . sizeInBytes ( ) > BufferPool . MEMORY_USAGE_THRESHOLD ) assertEquals ( BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED , ! buffer . isDirect ( ) ) ; buffers . add ( buffer ) ; } for ( ByteBuffer buffer : buffers ) BufferPool . put ( buffer ) ; } @Test public void testBigRequest ( ) { final int size = BufferPool . CHUNK_SIZE + <int> ; ByteBuffer buffer = BufferPool . get ( size ) ; assertNotNull ( buffer ) ; assertEquals ( size , buffer . capacity ( ) ) ; BufferPool . put ( buffer ) ; } @Test public void testFillUpChunks ( ) { final int size = RandomAccessReader . DEFAULT_BUFFER_SIZE ; final int numBuffers = BufferPool . CHUNK_SIZE / size ; List < ByteBuffer > buffers1 = new ArrayList < > ( numBuffers ) ; List < ByteBuffer > buffers2 = new ArrayList < > ( numBuffers ) ; for ( int i = <int> ; i < numBuffers ; i + + ) buffers1 . add ( BufferPool . get ( size ) ) ; BufferPool . Chunk chunk1 = BufferPool . currentChunk ( ) ; assertNotNull ( chunk1 ) ; for ( int i = <int> ; i < numBuffers ; i + + ) buffers2 . add ( BufferPool . get ( size ) ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; for ( ByteBuffer buffer : buffers1 ) BufferPool . put ( buffer ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; for ( ByteBuffer buffer : buffers2 ) BufferPool . put ( buffer ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; buffers2 . clear ( ) ; } @Test public void testOutOfOrderFrees ( ) { final int size = <int> ; final int maxFreeSlots = BufferPool . CHUNK_SIZE / size ; final int [ ] idxs = new int [ maxFreeSlots ] ; for ( int i = <int> ; i < maxFreeSlots ; i + + ) idxs [ i ] = i ; doTestFrees ( size , maxFreeSlots , idxs ) ; } @Test public void testInOrderFrees ( ) { final int size = <int> ; final int maxFreeSlots = BufferPool . CHUNK_SIZE / size ; final int [ ] idxs = new int [ maxFreeSlots ] ; for ( int i = <int> ; i < maxFreeSlots ; i + + ) idxs [ i ] = maxFreeSlots - <int> - i ; doTestFrees ( size , maxFreeSlots , idxs ) ; } @Test public void testRandomFrees ( ) { doTestRandomFrees ( <int> ) ; BufferPool . reset ( ) ; doTestRandomFrees ( <int> ) ; BufferPool . reset ( ) ; doTestRandomFrees ( <int> ) ; BufferPool . reset ( ) ; doTestRandomFrees ( <int> ) ; BufferPool . reset ( ) ; doTestRandomFrees ( <int> ) ; } private void doTestRandomFrees ( long seed ) { final int size = <int> ; final int maxFreeSlots = BufferPool . CHUNK_SIZE / size ; final int [ ] idxs = new int [ maxFreeSlots ] ; for ( int i = <int> ; i < maxFreeSlots ; i + + ) idxs [ i ] = maxFreeSlots - <int> - i ; Random rnd = new Random ( ) ; rnd . setSeed ( seed ) ; for ( int i = idxs . length - <int> ; i > <int> ; i - - ) { int idx = rnd . nextInt ( i + <int> ) ; int v = idxs [ idx ] ; idxs [ idx ] = idxs [ i ] ; idxs [ i ] = v ; } doTestFrees ( size , maxFreeSlots , idxs ) ; } private void doTestFrees ( final int size , final int maxFreeSlots , final int [ ] toReleaseIdxs ) { List < ByteBuffer > buffers = new ArrayList < > ( maxFreeSlots ) ; for ( int i = <int> ; i < maxFreeSlots ; i + + ) { buffers . add ( BufferPool . get ( size ) ) ; } BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertFalse ( chunk . isFree ( ) ) ; int freeSize = BufferPool . CHUNK_SIZE - maxFreeSlots * size ; assertEquals ( freeSize , chunk . free ( ) ) ; for ( int i : toReleaseIdxs ) { ByteBuffer buffer = buffers . get ( i ) ; assertNotNull ( buffer ) ; assertEquals ( size , buffer . capacity ( ) ) ; BufferPool . put ( buffer ) ; freeSize + = size ; if ( freeSize = = chunk . capacity ( ) ) assertEquals ( <int> , chunk . free ( ) ) ; else assertEquals ( freeSize , chunk . free ( ) ) ; } assertFalse ( chunk . isFree ( ) ) ; } @Test public void testDifferentSizeBuffersOnOneChunk ( ) { int [ ] sizes = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; int sum = <int> ; List < ByteBuffer > buffers = new ArrayList < > ( sizes . length ) ; for ( int i = <int> ; i < sizes . length ; i + + ) { ByteBuffer buffer = BufferPool . get ( sizes [ i ] ) ; assertNotNull ( buffer ) ; assertTrue ( buffer . capacity ( ) > = sizes [ i ] ) ; buffers . add ( buffer ) ; sum + = BufferPool . currentChunk ( ) . roundUp ( buffer . capacity ( ) ) ; } assertTrue ( sum < = BufferPool . GlobalPool . MACRO_CHUNK_SIZE ) ; BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; Random rnd = new Random ( ) ; rnd . setSeed ( <int> ) ; while ( ! buffers . isEmpty ( ) ) { int index = rnd . nextInt ( buffers . size ( ) ) ; ByteBuffer buffer = buffers . remove ( index ) ; BufferPool . put ( buffer ) ; } assertEquals ( null , BufferPool . currentChunk ( ) ) ; assertEquals ( <int> , chunk . free ( ) ) ; } @Test public void testChunkExhausted ( ) { final int size = BufferPool . CHUNK_SIZE / <int> ; int [ ] sizes = new int [ <int> ] ; Arrays . fill ( sizes , size ) ; int sum = <int> ; List < ByteBuffer > buffers = new ArrayList < > ( sizes . length ) ; for ( int i = <int> ; i < sizes . length ; i + + ) { ByteBuffer buffer = BufferPool . get ( sizes [ i ] ) ; assertNotNull ( buffer ) ; assertTrue ( buffer . capacity ( ) > = sizes [ i ] ) ; buffers . add ( buffer ) ; sum + = buffer . capacity ( ) ; } assertTrue ( sum < = BufferPool . GlobalPool . MACRO_CHUNK_SIZE ) ; BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; for ( int i = <int> ; i < sizes . length ; i + + ) { BufferPool . put ( buffers . get ( i ) ) ; } assertEquals ( null , BufferPool . currentChunk ( ) ) ; assertEquals ( <int> , chunk . free ( ) ) ; } @Test public void testCompactIfOutOfCapacity ( ) { final int size = <int> ; final int numBuffersInChunk = BufferPool . GlobalPool . MACRO_CHUNK_SIZE / size ; List < ByteBuffer > buffers = new ArrayList < > ( numBuffersInChunk ) ; Set < Long > addresses = new HashSet < > ( numBuffersInChunk ) ; for ( int i = <int> ; i < numBuffersInChunk ; i + + ) { ByteBuffer buffer = BufferPool . get ( size ) ; buffers . add ( buffer ) ; addresses . add ( MemoryUtil . getAddress ( buffer ) ) ; } for ( int i = numBuffersInChunk - <int> ; i > = <int> ; i - - ) BufferPool . put ( buffers . get ( i ) ) ; buffers . clear ( ) ; for ( int i = <int> ; i < numBuffersInChunk ; i + + ) { ByteBuffer buffer = BufferPool . get ( size ) ; assertNotNull ( buffer ) ; assertEquals ( size , buffer . capacity ( ) ) ; addresses . remove ( MemoryUtil . getAddress ( buffer ) ) ; buffers . add ( buffer ) ; } assertTrue ( addresses . isEmpty ( ) ) ; for ( ByteBuffer buffer : buffers ) BufferPool . put ( buffer ) ; } @Test public void testHeapBuffer ( ) { ByteBuffer buffer = BufferPool . get ( <int> , BufferType . ON_HEAP ) ; assertNotNull ( buffer ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertFalse ( buffer . isDirect ( ) ) ; assertNotNull ( buffer . array ( ) ) ; BufferPool . put ( buffer ) ; } @Test public void testSingleBufferOneChunk ( ) { checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; checkBuffer ( <int> ) ; } private void checkBuffer ( int size ) { ByteBuffer buffer = BufferPool . get ( size ) ; assertEquals ( size , buffer . capacity ( ) ) ; if ( size > <int> & & size < BufferPool . CHUNK_SIZE ) { BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; assertEquals ( chunk . capacity ( ) , chunk . free ( ) + chunk . roundUp ( size ) ) ; } BufferPool . put ( buffer ) ; } @Test public void testMultipleBuffersOneChunk ( ) { checkBuffers ( <int> , <int> ) ; checkBuffers ( <int> , <int> ) ; checkBuffers ( <int> , <int> ) ; checkBuffers ( <int> , <int> , <int> ) ; } private void checkBuffers ( int . . . sizes ) { List < ByteBuffer > buffers = new ArrayList < > ( sizes . length ) ; for ( int size : sizes ) { ByteBuffer buffer = BufferPool . get ( size ) ; assertEquals ( size , buffer . capacity ( ) ) ; buffers . add ( buffer ) ; } for ( ByteBuffer buffer : buffers ) BufferPool . put ( buffer ) ; } @Test public void testBuffersWithGivenSlots ( ) { checkBufferWithGivenSlots ( <int> , ( - <int> < < <int> ) ^ ( <int> < < <int> ) ) ; } private void checkBufferWithGivenSlots ( int size , long freeSlots ) { ByteBuffer buffer = BufferPool . get ( size ) ; BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; long oldFreeSlots = chunk . setFreeSlots ( freeSlots ) ; ByteBuffer buffer2 = BufferPool . get ( size ) ; assertEquals ( size , buffer . capacity ( ) ) ; BufferPool . put ( buffer2 ) ; chunk . setFreeSlots ( oldFreeSlots ) ; BufferPool . put ( buffer ) ; } @Test public void testZeroSizeRequest ( ) { ByteBuffer buffer = BufferPool . get ( <int> ) ; assertNotNull ( buffer ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; BufferPool . put ( buffer ) ; } @Test ( expected = IllegalArgumentException . class ) public void testNegativeSizeRequest ( ) { BufferPool . get ( - <int> ) ; } @Test public void testBufferPoolDisabled ( ) { BufferPool . DISABLED = true ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true ; ByteBuffer buffer = BufferPool . get ( <int> ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; assertNotNull ( buffer ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertFalse ( buffer . isDirect ( ) ) ; assertNotNull ( buffer . array ( ) ) ; BufferPool . put ( buffer ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = false ; buffer = BufferPool . get ( <int> ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; assertNotNull ( buffer ) ; assertEquals ( <int> , buffer . capacity ( ) ) ; assertTrue ( buffer . isDirect ( ) ) ; BufferPool . put ( buffer ) ; assertEquals ( <int> , BufferPool . numChunks ( ) ) ; BufferPool . DISABLED = false ; BufferPool . ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = true ; } @Test public void testMT_SameSizeImmediateReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , true , RandomAccessReader . DEFAULT_BUFFER_SIZE ) ; } @Test public void testMT_SameSizePostponedReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , false , RandomAccessReader . DEFAULT_BUFFER_SIZE ) ; } @Test public void testMT_TwoSizesOneBufferImmediateReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , true , <int> , <int> ) ; } @Test public void testMT_TwoSizesOneBufferPostponedReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , false , <int> , <int> ) ; } @Test public void testMT_TwoSizesTwoBuffersImmediateReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , true , <int> , <int> ) ; } @Test public void testMT_TwoSizesTwoBuffersPostponedReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , false , <int> , <int> ) ; } @Test public void testMT_MultipleSizesOneBufferImmediateReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , true , <int> , <int> , <int> , <int> , <int> ) ; } @Test public void testMT_MultipleSizesOneBufferPostponedReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , false , <int> , <int> , <int> , <int> , <int> ) ; } @Test public void testMT_MultipleSizesMultipleBuffersImmediateReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , true , <int> , <int> , <int> , <int> , <int> ) ; } @Test public void testMT_MultipleSizesMultipleBuffersPostponedReturn ( ) throws InterruptedException { checkMultipleThreads ( <int> , <int> , false , <int> , <int> , <int> , <int> , <int> ) ; } private void checkMultipleThreads ( int threadCount , int numBuffersPerThread , final boolean returnImmediately , final int . . . sizes ) throws InterruptedException { ExecutorService executorService = Executors . newFixedThreadPool ( threadCount ) ; final CountDownLatch finished = new CountDownLatch ( threadCount ) ; for ( int i = <int> ; i < threadCount ; i + + ) { final int [ ] threadSizes = new int [ numBuffersPerThread ] ; for ( int j = <int> ; j < threadSizes . length ; j + + ) threadSizes [ j ] = sizes [ ( i * numBuffersPerThread + j ) % sizes . length ] ; final Random rand = new Random ( ) ; executorService . submit ( new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( rand . nextInt ( <int> ) ) ; List < ByteBuffer > toBeReturned = new ArrayList < ByteBuffer > ( threadSizes . length ) ; for ( int j = <int> ; j < threadSizes . length ; j + + ) { ByteBuffer buffer = BufferPool . get ( threadSizes [ j ] ) ; assertNotNull ( buffer ) ; assertEquals ( threadSizes [ j ] , buffer . capacity ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) buffer . putInt ( i ) ; buffer . rewind ( ) ; Thread . sleep ( rand . nextInt ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( i , buffer . getInt ( ) ) ; if ( returnImmediately ) BufferPool . put ( buffer ) ; else toBeReturned . add ( buffer ) ; assertTrue ( BufferPool . sizeInBytes ( ) > <int> ) ; } Thread . sleep ( rand . nextInt ( <int> ) ) ; for ( ByteBuffer buffer : toBeReturned ) BufferPool . put ( buffer ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; fail ( ex . getMessage ( ) ) ; } finally { finished . countDown ( ) ; } } } ) ; } finished . await ( ) ; assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { System . gc ( ) ; Thread . sleep ( <int> ) ; } } @Ignore public void testMultipleThreadsReleaseSameBuffer ( ) throws InterruptedException { doMultipleThreadsReleaseBuffers ( <int> , <int> ) ; } @Ignore public void testMultipleThreadsReleaseDifferentBuffer ( ) throws InterruptedException { doMultipleThreadsReleaseBuffers ( <int> , <int> , <int> ) ; } private void doMultipleThreadsReleaseBuffers ( final int threadCount , final int . . . sizes ) throws InterruptedException { final ByteBuffer [ ] buffers = new ByteBuffer [ sizes . length ] ; int sum = <int> ; for ( int i = <int> ; i < sizes . length ; i + + ) { buffers [ i ] = BufferPool . get ( sizes [ i ] ) ; assertNotNull ( buffers [ i ] ) ; assertEquals ( sizes [ i ] , buffers [ i ] . capacity ( ) ) ; sum + = BufferPool . currentChunk ( ) . roundUp ( buffers [ i ] . capacity ( ) ) ; } final BufferPool . Chunk chunk = BufferPool . currentChunk ( ) ; assertNotNull ( chunk ) ; assertFalse ( chunk . isFree ( ) ) ; assertTrue ( sum < BufferPool . GlobalPool . MACRO_CHUNK_SIZE ) ; ExecutorService executorService = Executors . newFixedThreadPool ( threadCount ) ; final CountDownLatch finished = new CountDownLatch ( threadCount ) ; for ( int i = <int> ; i < threadCount ; i + + ) { final int idx = i % sizes . length ; final ByteBuffer buffer = buffers [ idx ] ; executorService . submit ( new Runnable ( ) { @Override public void run ( ) { try { assertNotSame ( chunk , BufferPool . currentChunk ( ) ) ; BufferPool . put ( buffer ) ; } catch ( AssertionError ex ) { ex . printStackTrace ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; fail ( t . getMessage ( ) ) ; } finally { finished . countDown ( ) ; } } } ) ; } finished . await ( ) ; assertEquals ( <int> , executorService . shutdownNow ( ) . size ( ) ) ; executorService = null ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; assertTrue ( BufferPool . currentChunk ( ) . isFree ( ) ) ; ByteBuffer buffer = BufferPool . get ( sizes [ <int> ] ) ; assertNotNull ( buffer ) ; assertEquals ( sizes [ <int> ] , buffer . capacity ( ) ) ; BufferPool . put ( buffer ) ; } } 
