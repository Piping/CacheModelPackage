package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . base . Predicates . equalTo ; import static com . google . common . base . Predicates . in ; import static com . google . common . base . Predicates . instanceOf ; import static com . google . common . base . Predicates . not ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Objects ; import com . google . common . base . Optional ; import com . google . common . base . Preconditions ; import com . google . common . base . Predicate ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Enumeration ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . NoSuchElementException ; import java . util . PriorityQueue ; import java . util . Queue ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public final class Iterators { private Iterators ( ) { } static final UnmodifiableListIterator < Object > EMPTY_LIST_ITERATOR = new UnmodifiableListIterator < Object > ( ) { @Override public boolean hasNext ( ) { return false ; } @Override public Object next ( ) { throw new NoSuchElementException ( ) ; } @Override public boolean hasPrevious ( ) { return false ; } @Override public Object previous ( ) { throw new NoSuchElementException ( ) ; } @Override public int nextIndex ( ) { return <int> ; } @Override public int previousIndex ( ) { return - <int> ; } } ; @Deprecated public static < T > UnmodifiableIterator < T > emptyIterator ( ) { return emptyListIterator ( ) ; } @SuppressWarnings ( <str> ) static < T > UnmodifiableListIterator < T > emptyListIterator ( ) { return ( UnmodifiableListIterator < T > ) EMPTY_LIST_ITERATOR ; } private static final Iterator < Object > EMPTY_MODIFIABLE_ITERATOR = new Iterator < Object > ( ) { @Override public boolean hasNext ( ) { return false ; } @Override public Object next ( ) { throw new NoSuchElementException ( ) ; } @Override public void remove ( ) { checkRemove ( false ) ; } } ; @SuppressWarnings ( <str> ) static < T > Iterator < T > emptyModifiableIterator ( ) { return ( Iterator < T > ) EMPTY_MODIFIABLE_ITERATOR ; } public static < T > UnmodifiableIterator < T > unmodifiableIterator ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; if ( iterator instanceof UnmodifiableIterator ) { return ( UnmodifiableIterator < T > ) iterator ; } return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public T next ( ) { return iterator . next ( ) ; } } ; } @Deprecated public static < T > UnmodifiableIterator < T > unmodifiableIterator ( UnmodifiableIterator < T > iterator ) { return checkNotNull ( iterator ) ; } public static int size ( Iterator < ? > iterator ) { int count = <int> ; while ( iterator . hasNext ( ) ) { iterator . next ( ) ; count + + ; } return count ; } public static boolean contains ( Iterator < ? > iterator , @Nullable Object element ) { return any ( iterator , equalTo ( element ) ) ; } public static boolean removeAll ( Iterator < ? > removeFrom , Collection < ? > elementsToRemove ) { return removeIf ( removeFrom , in ( elementsToRemove ) ) ; } public static < T > boolean removeIf ( Iterator < T > removeFrom , Predicate < ? super T > predicate ) { checkNotNull ( predicate ) ; boolean modified = false ; while ( removeFrom . hasNext ( ) ) { if ( predicate . apply ( removeFrom . next ( ) ) ) { removeFrom . remove ( ) ; modified = true ; } } return modified ; } public static boolean retainAll ( Iterator < ? > removeFrom , Collection < ? > elementsToRetain ) { return removeIf ( removeFrom , not ( in ( elementsToRetain ) ) ) ; } public static boolean elementsEqual ( Iterator < ? > iterator1 , Iterator < ? > iterator2 ) { while ( iterator1 . hasNext ( ) ) { if ( ! iterator2 . hasNext ( ) ) { return false ; } Object o1 = iterator1 . next ( ) ; Object o2 = iterator2 . next ( ) ; if ( ! Objects . equal ( o1 , o2 ) ) { return false ; } } return ! iterator2 . hasNext ( ) ; } public static String toString ( Iterator < ? > iterator ) { return Collections2 . STANDARD_JOINER . appendTo ( new StringBuilder ( ) . append ( <str> ) , iterator ) . append ( <str> ) . toString ( ) ; } public static < T > T getOnlyElement ( Iterator < T > iterator ) { T first = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return first ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> + first ) ; for ( int i = <int> ; i < <int> & & iterator . hasNext ( ) ; i + + ) { sb . append ( <str> + iterator . next ( ) ) ; } if ( iterator . hasNext ( ) ) { sb . append ( <str> ) ; } sb . append ( <str> ) ; throw new IllegalArgumentException ( sb . toString ( ) ) ; } @Nullable public static < T > T getOnlyElement ( Iterator < ? extends T > iterator , @Nullable T defaultValue ) { return iterator . hasNext ( ) ? getOnlyElement ( iterator ) : defaultValue ; } @GwtIncompatible ( <str> ) public static < T > T [ ] toArray ( Iterator < ? extends T > iterator , Class < T > type ) { List < T > list = Lists . newArrayList ( iterator ) ; return Iterables . toArray ( list , type ) ; } public static < T > boolean addAll ( Collection < T > addTo , Iterator < ? extends T > iterator ) { checkNotNull ( addTo ) ; checkNotNull ( iterator ) ; boolean wasModified = false ; while ( iterator . hasNext ( ) ) { wasModified | = addTo . add ( iterator . next ( ) ) ; } return wasModified ; } public static int frequency ( Iterator < ? > iterator , @Nullable Object element ) { return size ( filter ( iterator , equalTo ( element ) ) ) ; } public static < T > Iterator < T > cycle ( final Iterable < T > iterable ) { checkNotNull ( iterable ) ; return new Iterator < T > ( ) { Iterator < T > iterator = emptyModifiableIterator ( ) ; @Override public boolean hasNext ( ) { return iterator . hasNext ( ) | | iterable . iterator ( ) . hasNext ( ) ; } @Override public T next ( ) { if ( ! iterator . hasNext ( ) ) { iterator = iterable . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { throw new NoSuchElementException ( ) ; } } return iterator . next ( ) ; } @Override public void remove ( ) { iterator . remove ( ) ; } } ; } public static < T > Iterator < T > cycle ( T . . . elements ) { return cycle ( Lists . newArrayList ( elements ) ) ; } public static < T > Iterator < T > concat ( Iterator < ? extends T > a , Iterator < ? extends T > b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; return concat ( new ConsumingQueueIterator < Iterator < ? extends T > > ( a , b ) ) ; } public static < T > Iterator < T > concat ( Iterator < ? extends T > a , Iterator < ? extends T > b , Iterator < ? extends T > c ) { checkNotNull ( a ) ; checkNotNull ( b ) ; checkNotNull ( c ) ; return concat ( new ConsumingQueueIterator < Iterator < ? extends T > > ( a , b , c ) ) ; } public static < T > Iterator < T > concat ( Iterator < ? extends T > a , Iterator < ? extends T > b , Iterator < ? extends T > c , Iterator < ? extends T > d ) { checkNotNull ( a ) ; checkNotNull ( b ) ; checkNotNull ( c ) ; checkNotNull ( d ) ; return concat ( new ConsumingQueueIterator < Iterator < ? extends T > > ( a , b , c , d ) ) ; } public static < T > Iterator < T > concat ( Iterator < ? extends T > . . . inputs ) { for ( Iterator < ? extends T > input : checkNotNull ( inputs ) ) { checkNotNull ( input ) ; } return concat ( new ConsumingQueueIterator < Iterator < ? extends T > > ( inputs ) ) ; } public static < T > Iterator < T > concat ( final Iterator < ? extends Iterator < ? extends T > > inputs ) { checkNotNull ( inputs ) ; return new Iterator < T > ( ) { Iterator < ? extends T > current = emptyIterator ( ) ; Iterator < ? extends T > removeFrom ; @Override public boolean hasNext ( ) { boolean currentHasNext ; while ( ! ( currentHasNext = checkNotNull ( current ) . hasNext ( ) ) & & inputs . hasNext ( ) ) { current = inputs . next ( ) ; } return currentHasNext ; } @Override public T next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } removeFrom = current ; return current . next ( ) ; } @Override public void remove ( ) { checkRemove ( removeFrom ! = null ) ; removeFrom . remove ( ) ; removeFrom = null ; } } ; } public static < T > UnmodifiableIterator < List < T > > partition ( Iterator < T > iterator , int size ) { return partitionImpl ( iterator , size , false ) ; } public static < T > UnmodifiableIterator < List < T > > paddedPartition ( Iterator < T > iterator , int size ) { return partitionImpl ( iterator , size , true ) ; } private static < T > UnmodifiableIterator < List < T > > partitionImpl ( final Iterator < T > iterator , final int size , final boolean pad ) { checkNotNull ( iterator ) ; checkArgument ( size > <int> ) ; return new UnmodifiableIterator < List < T > > ( ) { @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public List < T > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Object [ ] array = new Object [ size ] ; int count = <int> ; for ( ; count < size & & iterator . hasNext ( ) ; count + + ) { array [ count ] = iterator . next ( ) ; } for ( int i = count ; i < size ; i + + ) { array [ i ] = null ; } @SuppressWarnings ( <str> ) List < T > list = Collections . unmodifiableList ( ( List < T > ) Arrays . asList ( array ) ) ; return ( pad | | count = = size ) ? list : list . subList ( <int> , count ) ; } } ; } @CheckReturnValue public static < T > UnmodifiableIterator < T > filter ( final Iterator < T > unfiltered , final Predicate < ? super T > retainIfTrue ) { checkNotNull ( unfiltered ) ; checkNotNull ( retainIfTrue ) ; return new AbstractIterator < T > ( ) { @Override protected T computeNext ( ) { while ( unfiltered . hasNext ( ) ) { T element = unfiltered . next ( ) ; if ( retainIfTrue . apply ( element ) ) { return element ; } } return endOfData ( ) ; } } ; } @SuppressWarnings ( <str> ) @GwtIncompatible ( <str> ) @CheckReturnValue public static < T > UnmodifiableIterator < T > filter ( Iterator < ? > unfiltered , Class < T > desiredType ) { return ( UnmodifiableIterator < T > ) filter ( unfiltered , instanceOf ( desiredType ) ) ; } public static < T > boolean any ( Iterator < T > iterator , Predicate < ? super T > predicate ) { return indexOf ( iterator , predicate ) ! = - <int> ; } public static < T > boolean all ( Iterator < T > iterator , Predicate < ? super T > predicate ) { checkNotNull ( predicate ) ; while ( iterator . hasNext ( ) ) { T element = iterator . next ( ) ; if ( ! predicate . apply ( element ) ) { return false ; } } return true ; } public static < T > T find ( Iterator < T > iterator , Predicate < ? super T > predicate ) { return filter ( iterator , predicate ) . next ( ) ; } @Nullable public static < T > T find ( Iterator < ? extends T > iterator , Predicate < ? super T > predicate , @Nullable T defaultValue ) { return getNext ( filter ( iterator , predicate ) , defaultValue ) ; } public static < T > Optional < T > tryFind ( Iterator < T > iterator , Predicate < ? super T > predicate ) { UnmodifiableIterator < T > filteredIterator = filter ( iterator , predicate ) ; return filteredIterator . hasNext ( ) ? Optional . of ( filteredIterator . next ( ) ) : Optional . < T > absent ( ) ; } public static < T > int indexOf ( Iterator < T > iterator , Predicate < ? super T > predicate ) { checkNotNull ( predicate , <str> ) ; for ( int i = <int> ; iterator . hasNext ( ) ; i + + ) { T current = iterator . next ( ) ; if ( predicate . apply ( current ) ) { return i ; } } return - <int> ; } public static < F , T > Iterator < T > transform ( final Iterator < F > fromIterator , final Function < ? super F , ? extends T > function ) { checkNotNull ( function ) ; return new TransformedIterator < F , T > ( fromIterator ) { @Override T transform ( F from ) { return function . apply ( from ) ; } } ; } public static < T > T get ( Iterator < T > iterator , int position ) { checkNonnegative ( position ) ; int skipped = advance ( iterator , position ) ; if ( ! iterator . hasNext ( ) ) { throw new IndexOutOfBoundsException ( <str> + position + <str> + skipped + <str> ) ; } return iterator . next ( ) ; } static void checkNonnegative ( int position ) { if ( position < <int> ) { throw new IndexOutOfBoundsException ( <str> + position + <str> ) ; } } @Nullable public static < T > T get ( Iterator < ? extends T > iterator , int position , @Nullable T defaultValue ) { checkNonnegative ( position ) ; advance ( iterator , position ) ; return getNext ( iterator , defaultValue ) ; } @Nullable public static < T > T getNext ( Iterator < ? extends T > iterator , @Nullable T defaultValue ) { return iterator . hasNext ( ) ? iterator . next ( ) : defaultValue ; } public static < T > T getLast ( Iterator < T > iterator ) { while ( true ) { T current = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return current ; } } } @Nullable public static < T > T getLast ( Iterator < ? extends T > iterator , @Nullable T defaultValue ) { return iterator . hasNext ( ) ? getLast ( iterator ) : defaultValue ; } public static int advance ( Iterator < ? > iterator , int numberToAdvance ) { checkNotNull ( iterator ) ; checkArgument ( numberToAdvance > = <int> , <str> ) ; int i ; for ( i = <int> ; i < numberToAdvance & & iterator . hasNext ( ) ; i + + ) { iterator . next ( ) ; } return i ; } public static < T > Iterator < T > limit ( final Iterator < T > iterator , final int limitSize ) { checkNotNull ( iterator ) ; checkArgument ( limitSize > = <int> , <str> ) ; return new Iterator < T > ( ) { private int count ; @Override public boolean hasNext ( ) { return count < limitSize & & iterator . hasNext ( ) ; } @Override public T next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } count + + ; return iterator . next ( ) ; } @Override public void remove ( ) { iterator . remove ( ) ; } } ; } public static < T > Iterator < T > consumingIterator ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @Override public T next ( ) { T next = iterator . next ( ) ; iterator . remove ( ) ; return next ; } @Override public String toString ( ) { return <str> ; } } ; } @Nullable static < T > T pollNext ( Iterator < T > iterator ) { if ( iterator . hasNext ( ) ) { T result = iterator . next ( ) ; iterator . remove ( ) ; return result ; } else { return null ; } } static void clear ( Iterator < ? > iterator ) { checkNotNull ( iterator ) ; while ( iterator . hasNext ( ) ) { iterator . next ( ) ; iterator . remove ( ) ; } } public static < T > UnmodifiableIterator < T > forArray ( final T . . . array ) { return forArray ( array , <int> , array . length , <int> ) ; } static < T > UnmodifiableListIterator < T > forArray ( final T [ ] array , final int offset , int length , int index ) { checkArgument ( length > = <int> ) ; int end = offset + length ; Preconditions . checkPositionIndexes ( offset , end , array . length ) ; Preconditions . checkPositionIndex ( index , length ) ; if ( length = = <int> ) { return emptyListIterator ( ) ; } return new AbstractIndexedListIterator < T > ( length , index ) { @Override protected T get ( int index ) { return array [ offset + index ] ; } } ; } public static < T > UnmodifiableIterator < T > singletonIterator ( @Nullable final T value ) { return new UnmodifiableIterator < T > ( ) { boolean done ; @Override public boolean hasNext ( ) { return ! done ; } @Override public T next ( ) { if ( done ) { throw new NoSuchElementException ( ) ; } done = true ; return value ; } } ; } public static < T > UnmodifiableIterator < T > forEnumeration ( final Enumeration < T > enumeration ) { checkNotNull ( enumeration ) ; return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return enumeration . hasMoreElements ( ) ; } @Override public T next ( ) { return enumeration . nextElement ( ) ; } } ; } public static < T > Enumeration < T > asEnumeration ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new Enumeration < T > ( ) { @Override public boolean hasMoreElements ( ) { return iterator . hasNext ( ) ; } @Override public T nextElement ( ) { return iterator . next ( ) ; } } ; } private static class PeekingImpl < E > implements PeekingIterator < E > { private final Iterator < ? extends E > iterator ; private boolean hasPeeked ; private E peekedElement ; public PeekingImpl ( Iterator < ? extends E > iterator ) { this . iterator = checkNotNull ( iterator ) ; } @Override public boolean hasNext ( ) { return hasPeeked | | iterator . hasNext ( ) ; } @Override public E next ( ) { if ( ! hasPeeked ) { return iterator . next ( ) ; } E result = peekedElement ; hasPeeked = false ; peekedElement = null ; return result ; } @Override public void remove ( ) { checkState ( ! hasPeeked , <str> ) ; iterator . remove ( ) ; } @Override public E peek ( ) { if ( ! hasPeeked ) { peekedElement = iterator . next ( ) ; hasPeeked = true ; } return peekedElement ; } } public static < T > PeekingIterator < T > peekingIterator ( Iterator < ? extends T > iterator ) { if ( iterator instanceof PeekingImpl ) { @SuppressWarnings ( <str> ) PeekingImpl < T > peeking = ( PeekingImpl < T > ) iterator ; return peeking ; } return new PeekingImpl < T > ( iterator ) ; } @Deprecated public static < T > PeekingIterator < T > peekingIterator ( PeekingIterator < T > iterator ) { return checkNotNull ( iterator ) ; } @Beta public static < T > UnmodifiableIterator < T > mergeSorted ( Iterable < ? extends Iterator < ? extends T > > iterators , Comparator < ? super T > comparator ) { checkNotNull ( iterators , <str> ) ; checkNotNull ( comparator , <str> ) ; return new MergingIterator < T > ( iterators , comparator ) ; } private static class MergingIterator < T > extends UnmodifiableIterator < T > { final Queue < PeekingIterator < T > > queue ; public MergingIterator ( Iterable < ? extends Iterator < ? extends T > > iterators , final Comparator < ? super T > itemComparator ) { Comparator < PeekingIterator < T > > heapComparator = new Comparator < PeekingIterator < T > > ( ) { @Override public int compare ( PeekingIterator < T > o1 , PeekingIterator < T > o2 ) { return itemComparator . compare ( o1 . peek ( ) , o2 . peek ( ) ) ; } } ; queue = new PriorityQueue < PeekingIterator < T > > ( <int> , heapComparator ) ; for ( Iterator < ? extends T > iterator : iterators ) { if ( iterator . hasNext ( ) ) { queue . add ( Iterators . peekingIterator ( iterator ) ) ; } } } @Override public boolean hasNext ( ) { return ! queue . isEmpty ( ) ; } @Override public T next ( ) { PeekingIterator < T > nextIter = queue . remove ( ) ; T next = nextIter . next ( ) ; if ( nextIter . hasNext ( ) ) { queue . add ( nextIter ) ; } return next ; } } static < T > ListIterator < T > cast ( Iterator < T > iterator ) { return ( ListIterator < T > ) iterator ; } } 
