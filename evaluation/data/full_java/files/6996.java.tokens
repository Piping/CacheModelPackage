package org . elasticsearch . rest . action . admin . indices . get ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . admin . indices . get . GetIndexRequest ; import org . elasticsearch . action . admin . indices . get . GetIndexRequest . Feature ; import org . elasticsearch . action . admin . indices . get . GetIndexResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . AliasMetaData ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent . Params ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . rest . BaseRestHandler ; import org . elasticsearch . rest . BytesRestResponse ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import org . elasticsearch . search . warmer . IndexWarmersMetaData ; import java . io . IOException ; import java . util . List ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestGetIndicesAction extends BaseRestHandler { @Inject public RestGetIndicesAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; String [ ] featureParams = request . paramAsStringArray ( <str> , null ) ; if ( featureParams = = null & & indices . length > <int> & & indices [ <int> ] ! = null & & indices [ <int> ] . startsWith ( <str> ) & & ! <str> . equals ( indices [ <int> ] ) ) { featureParams = indices ; indices = new String [ ] { <str> } ; } final GetIndexRequest getIndexRequest = new GetIndexRequest ( ) ; getIndexRequest . indices ( indices ) ; if ( featureParams ! = null ) { Feature [ ] features = Feature . convertToFeatures ( featureParams ) ; getIndexRequest . features ( features ) ; } getIndexRequest . indicesOptions ( IndicesOptions . fromRequest ( request , getIndexRequest . indicesOptions ( ) ) ) ; getIndexRequest . local ( request . paramAsBoolean ( <str> , getIndexRequest . local ( ) ) ) ; getIndexRequest . humanReadable ( request . paramAsBoolean ( <str> , false ) ) ; client . admin ( ) . indices ( ) . getIndex ( getIndexRequest , new RestBuilderListener < GetIndexResponse > ( channel ) { @Override public RestResponse buildResponse ( GetIndexResponse response , XContentBuilder builder ) throws Exception { Feature [ ] features = getIndexRequest . featuresAsEnums ( ) ; String [ ] indices = response . indices ( ) ; builder . startObject ( ) ; for ( String index : indices ) { builder . startObject ( index ) ; for ( Feature feature : features ) { switch ( feature ) { case ALIASES : writeAliases ( response . aliases ( ) . get ( index ) , builder , request ) ; break ; case MAPPINGS : writeMappings ( response . mappings ( ) . get ( index ) , builder , request ) ; break ; case SETTINGS : writeSettings ( response . settings ( ) . get ( index ) , builder , request ) ; break ; case WARMERS : writeWarmers ( response . warmers ( ) . get ( index ) , builder , request ) ; break ; default : throw new IllegalStateException ( <str> + feature + <str> ) ; } } builder . endObject ( ) ; } builder . endObject ( ) ; return new BytesRestResponse ( OK , builder ) ; } private void writeAliases ( List < AliasMetaData > aliases , XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . ALIASES ) ; if ( aliases ! = null ) { for ( AliasMetaData alias : aliases ) { AliasMetaData . Builder . toXContent ( alias , builder , params ) ; } } builder . endObject ( ) ; } private void writeMappings ( ImmutableOpenMap < String , MappingMetaData > mappings , XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . MAPPINGS ) ; if ( mappings ! = null ) { for ( ObjectObjectCursor < String , MappingMetaData > typeEntry : mappings ) { builder . field ( typeEntry . key ) ; builder . map ( typeEntry . value . sourceAsMap ( ) ) ; } } builder . endObject ( ) ; } private void writeSettings ( Settings settings , XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . SETTINGS ) ; settings . toXContent ( builder , params ) ; builder . endObject ( ) ; } private void writeWarmers ( List < IndexWarmersMetaData . Entry > warmers , XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . WARMERS ) ; if ( warmers ! = null ) { for ( IndexWarmersMetaData . Entry warmer : warmers ) { IndexWarmersMetaData . toXContent ( warmer , builder , params ) ; } } builder . endObject ( ) ; } } ) ; } static class Fields { static final XContentBuilderString ALIASES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MAPPINGS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SETTINGS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString WARMERS = new XContentBuilderString ( <str> ) ; } } 
