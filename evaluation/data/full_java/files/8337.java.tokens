package org . elasticsearch . indices . mapping ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . emptyIterable ; @ESIntegTestCase.ClusterScope ( randomDynamicTemplates = false ) public class ConcurrentDynamicTemplateIT extends ESIntegTestCase { private final String mappingType = <str> ; public void testConcurrentDynamicMapping ( ) throws Exception { final String fieldName = <str> ; final String mapping = <str> + mappingType + <str> + <str> + <str> + fieldName + <str> + <str> + <str> + <str> + <str> + <str> ; int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { cluster ( ) . wipeIndices ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( mappingType , mapping ) ) ; ensureYellow ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; final CountDownLatch latch = new CountDownLatch ( numDocs ) ; final List < Throwable > throwable = new CopyOnWriteArrayList < > ( ) ; int currentID = <int> ; for ( int j = <int> ; j < numDocs ; j + + ) { Map < String , Object > source = new HashMap < > ( ) ; source . put ( fieldName , <str> ) ; client ( ) . prepareIndex ( <str> , mappingType , Integer . toString ( currentID + + ) ) . setSource ( source ) . execute ( new ActionListener < IndexResponse > ( ) { @Override public void onResponse ( IndexResponse response ) { latch . countDown ( ) ; } @Override public void onFailure ( Throwable e ) { throwable . add ( e ) ; latch . countDown ( ) ; } } ) ; } latch . await ( ) ; assertThat ( throwable , emptyIterable ( ) ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . matchQuery ( fieldName , <str> ) ) . get ( ) , numDocs ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . matchQuery ( fieldName , <str> ) ) . get ( ) , <int> ) ; } } } 
