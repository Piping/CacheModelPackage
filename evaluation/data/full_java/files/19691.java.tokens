package io . netty . util . concurrent ; import java . util . Queue ; import java . util . concurrent . Callable ; import java . util . concurrent . Delayed ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; @SuppressWarnings ( <str> ) final class ScheduledFutureTask < V > extends PromiseTask < V > implements ScheduledFuture < V > { private static final AtomicLong nextTaskId = new AtomicLong ( ) ; private static final long START_TIME = System . nanoTime ( ) ; static long nanoTime ( ) { return System . nanoTime ( ) - START_TIME ; } static long deadlineNanos ( long delay ) { return nanoTime ( ) + delay ; } private final long id = nextTaskId . getAndIncrement ( ) ; private long deadlineNanos ; private final long periodNanos ; ScheduledFutureTask ( AbstractScheduledEventExecutor executor , Runnable runnable , V result , long nanoTime ) { this ( executor , toCallable ( runnable , result ) , nanoTime ) ; } ScheduledFutureTask ( AbstractScheduledEventExecutor executor , Callable < V > callable , long nanoTime , long period ) { super ( executor , callable ) ; if ( period = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } deadlineNanos = nanoTime ; periodNanos = period ; } ScheduledFutureTask ( AbstractScheduledEventExecutor executor , Callable < V > callable , long nanoTime ) { super ( executor , callable ) ; deadlineNanos = nanoTime ; periodNanos = <int> ; } @Override protected EventExecutor executor ( ) { return super . executor ( ) ; } public long deadlineNanos ( ) { return deadlineNanos ; } public long delayNanos ( ) { return Math . max ( <int> , deadlineNanos ( ) - nanoTime ( ) ) ; } public long delayNanos ( long currentTimeNanos ) { return Math . max ( <int> , deadlineNanos ( ) - ( currentTimeNanos - START_TIME ) ) ; } @Override public long getDelay ( TimeUnit unit ) { return unit . convert ( delayNanos ( ) , TimeUnit . NANOSECONDS ) ; } @Override public int compareTo ( Delayed o ) { if ( this = = o ) { return <int> ; } ScheduledFutureTask < ? > that = ( ScheduledFutureTask < ? > ) o ; long d = deadlineNanos ( ) - that . deadlineNanos ( ) ; if ( d < <int> ) { return - <int> ; } else if ( d > <int> ) { return <int> ; } else if ( id < that . id ) { return - <int> ; } else if ( id = = that . id ) { throw new Error ( ) ; } else { return <int> ; } } @Override public void run ( ) { assert executor ( ) . inEventLoop ( ) ; try { if ( periodNanos = = <int> ) { if ( setUncancellableInternal ( ) ) { V result = task . call ( ) ; setSuccessInternal ( result ) ; } } else { if ( ! isCancelled ( ) ) { task . call ( ) ; if ( ! executor ( ) . isShutdown ( ) ) { long p = periodNanos ; if ( p > <int> ) { deadlineNanos + = p ; } else { deadlineNanos = nanoTime ( ) - p ; } if ( ! isCancelled ( ) ) { Queue < ScheduledFutureTask < ? > > scheduledTaskQueue = ( ( AbstractScheduledEventExecutor ) executor ( ) ) . scheduledTaskQueue ; assert scheduledTaskQueue ! = null ; scheduledTaskQueue . add ( this ) ; } } } } } catch ( Throwable cause ) { setFailureInternal ( cause ) ; } } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { boolean canceled = super . cancel ( mayInterruptIfRunning ) ; if ( canceled ) { ( ( AbstractScheduledEventExecutor ) executor ( ) ) . removeScheduled ( this ) ; } return canceled ; } boolean cancelWithoutRemove ( boolean mayInterruptIfRunning ) { return super . cancel ( mayInterruptIfRunning ) ; } @Override protected StringBuilder toStringBuilder ( ) { StringBuilder buf = super . toStringBuilder ( ) ; buf . setCharAt ( buf . length ( ) - <int> , <str> ) ; return buf . append ( <str> ) . append ( id ) . append ( <str> ) . append ( deadlineNanos ) . append ( <str> ) . append ( periodNanos ) . append ( <str> ) ; } } 
