package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . SortedMapInterfaceTest ; import com . google . common . collect . testing . SortedMapTestSuiteBuilder ; import com . google . common . collect . testing . TestStringSortedMapGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestSuite ; import java . util . Collections ; import java . util . Comparator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . SortedMap ; @GwtCompatible ( emulated = true ) public class TreeBasedTableTest extends AbstractTableTest { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( TreeBasedTableTest . class ) ; suite . addTestSuite ( TreeRowTest . class ) ; suite . addTest ( SortedMapTestSuiteBuilder . using ( new TestStringSortedMapGenerator ( ) { @Override protected SortedMap < String , String > create ( Entry < String , String > [ ] entries ) { TreeBasedTable < String , String , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; for ( Entry < String , String > entry : entries ) { table . put ( <str> , entry . getKey ( ) , entry . getValue ( ) ) ; } return table . row ( <str> ) ; } } ) . withFeatures ( MapFeature . GENERAL_PURPOSE , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionSize . ANY ) . named ( <str> ) . createTestSuite ( ) ) ; return suite ; } public static class TreeRowTest extends SortedMapInterfaceTest < String , String > { public TreeRowTest ( ) { super ( false , false , true , true , true ) ; } @Override protected SortedMap < String , String > makeEmptyMap ( ) { TreeBasedTable < String , String , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; return table . row ( <str> ) ; } @Override protected SortedMap < String , String > makePopulatedMap ( ) { TreeBasedTable < String , String , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; return table . row ( <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected String getValueNotInPopulatedMap ( ) { return <str> ; } public void testClearSubMapOfRowMap ( ) { TreeBasedTable < String , String , String > table = TreeBasedTable . create ( ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . put ( <str> , <str> , <str> ) ; table . row ( <str> ) . subMap ( <str> , <str> ) . clear ( ) ; assertEquals ( table . row ( <str> ) , ImmutableMap . of ( <str> , <str> , <str> , <str> ) ) ; table . row ( <str> ) . subMap ( <str> , <str> ) . clear ( ) ; assertEquals ( table . row ( <str> ) , ImmutableMap . of ( ) ) ; assertFalse ( table . backingMap . containsKey ( <str> ) ) ; } } private TreeBasedTable < String , Integer , Character > sortedTable ; protected TreeBasedTable < String , Integer , Character > create ( Comparator < ? super String > rowComparator , Comparator < ? super Integer > columnComparator , Object . . . data ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( rowComparator , columnComparator ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . clear ( ) ; populate ( table , data ) ; return table ; } @Override protected TreeBasedTable < String , Integer , Character > create ( Object . . . data ) { TreeBasedTable < String , Integer , Character > table = TreeBasedTable . create ( ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . clear ( ) ; populate ( table , data ) ; return table ; } public void testCreateExplicitComparators ( ) { table = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; table . put ( <str> , <int> , <str> ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testCreateCopy ( ) { TreeBasedTable < String , Integer , Character > original = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; original . put ( <str> , <int> , <str> ) ; original . put ( <str> , <int> , <str> ) ; original . put ( <str> , <int> , <str> ) ; original . put ( <str> , <int> , <str> ) ; table = TreeBasedTable . create ( original ) ; assertThat ( table . rowKeySet ( ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( table . row ( <str> ) . keySet ( ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertEquals ( original , table ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; SerializableTester . reserializeAndAssert ( table ) ; } public void testToString_ordered ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . toString ( ) ) ; assertEquals ( <str> , table . rowMap ( ) . toString ( ) ) ; } public void testCellSetToString_ordered ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . cellSet ( ) . toString ( ) ) ; } public void testRowKeySetToString_ordered ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . rowKeySet ( ) . toString ( ) ) ; } public void testValuesToString_ordered ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . values ( ) . toString ( ) ) ; } public void testRowComparator ( ) { sortedTable = TreeBasedTable . create ( ) ; assertSame ( Ordering . natural ( ) , sortedTable . rowComparator ( ) ) ; sortedTable = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; assertSame ( Collections . reverseOrder ( ) , sortedTable . rowComparator ( ) ) ; } public void testColumnComparator ( ) { sortedTable = TreeBasedTable . create ( ) ; assertSame ( Ordering . natural ( ) , sortedTable . columnComparator ( ) ) ; sortedTable = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; assertSame ( Ordering . usingToString ( ) , sortedTable . columnComparator ( ) ) ; } public void testRowKeySetComparator ( ) { sortedTable = TreeBasedTable . create ( ) ; assertSame ( Ordering . natural ( ) , sortedTable . rowKeySet ( ) . comparator ( ) ) ; sortedTable = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; assertSame ( Collections . reverseOrder ( ) , sortedTable . rowKeySet ( ) . comparator ( ) ) ; } public void testRowKeySetFirst ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertSame ( <str> , sortedTable . rowKeySet ( ) . first ( ) ) ; } public void testRowKeySetLast ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertSame ( <str> , sortedTable . rowKeySet ( ) . last ( ) ) ; } public void testRowKeySetHeadSet ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Set < String > set = sortedTable . rowKeySet ( ) . headSet ( <str> ) ; assertEquals ( Collections . singleton ( <str> ) , set ) ; set . clear ( ) ; assertTrue ( set . isEmpty ( ) ) ; assertEquals ( Collections . singleton ( <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowKeySetTailSet ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Set < String > set = sortedTable . rowKeySet ( ) . tailSet ( <str> ) ; assertEquals ( Collections . singleton ( <str> ) , set ) ; set . clear ( ) ; assertTrue ( set . isEmpty ( ) ) ; assertEquals ( Collections . singleton ( <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowKeySetSubSet ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Set < String > set = sortedTable . rowKeySet ( ) . subSet ( <str> , <str> ) ; assertEquals ( Collections . singleton ( <str> ) , set ) ; set . clear ( ) ; assertTrue ( set . isEmpty ( ) ) ; assertEquals ( ImmutableSet . of ( <str> , <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowMapComparator ( ) { sortedTable = TreeBasedTable . create ( ) ; assertSame ( Ordering . natural ( ) , sortedTable . rowMap ( ) . comparator ( ) ) ; sortedTable = TreeBasedTable . create ( Collections . reverseOrder ( ) , Ordering . usingToString ( ) ) ; assertSame ( Collections . reverseOrder ( ) , sortedTable . rowMap ( ) . comparator ( ) ) ; } public void testRowMapFirstKey ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertSame ( <str> , sortedTable . rowMap ( ) . firstKey ( ) ) ; } public void testRowMapLastKey ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertSame ( <str> , sortedTable . rowMap ( ) . lastKey ( ) ) ; } public void testRowKeyMapHeadMap ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Map < String , Map < Integer , Character > > map = sortedTable . rowMap ( ) . headMap ( <str> ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , map . get ( <str> ) ) ; map . clear ( ) ; assertTrue ( map . isEmpty ( ) ) ; assertEquals ( Collections . singleton ( <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowKeyMapTailMap ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Map < String , Map < Integer , Character > > map = sortedTable . rowMap ( ) . tailMap ( <str> ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableMap . of ( <int> , <str> , <int> , <str> ) , map . get ( <str> ) ) ; map . clear ( ) ; assertTrue ( map . isEmpty ( ) ) ; assertEquals ( Collections . singleton ( <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowKeyMapSubMap ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; Map < String , Map < Integer , Character > > map = sortedTable . rowMap ( ) . subMap ( <str> , <str> ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , map . get ( <str> ) ) ; map . clear ( ) ; assertTrue ( map . isEmpty ( ) ) ; assertEquals ( ImmutableSet . of ( <str> , <str> ) , sortedTable . rowKeySet ( ) ) ; } public void testRowMapValuesAreSorted ( ) { sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertTrue ( sortedTable . rowMap ( ) . get ( <str> ) instanceof SortedMap ) ; } public void testColumnKeySet_isSorted ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testColumnKeySet_isSortedWithRealComparator ( ) { table = create ( String . CASE_INSENSITIVE_ORDER , Ordering . natural ( ) . reverse ( ) , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testColumnKeySet_empty ( ) { table = create ( ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testColumnKeySet_oneRow ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testColumnKeySet_oneColumn ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testColumnKeySet_oneEntry ( ) { table = create ( <str> , <int> , <str> ) ; assertEquals ( <str> , table . columnKeySet ( ) . toString ( ) ) ; } public void testRowEntrySetContains ( ) { table = sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; SortedMap < Integer , Character > row = sortedTable . row ( <str> ) ; Set < Map . Entry < Integer , Character > > entrySet = row . entrySet ( ) ; assertTrue ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertTrue ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertFalse ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; entrySet = row . tailMap ( <int> ) . entrySet ( ) ; assertFalse ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertTrue ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertFalse ( entrySet . contains ( Maps . immutableEntry ( <int> , <str> ) ) ) ; } public void testRowEntrySetRemove ( ) { table = sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; SortedMap < Integer , Character > row = sortedTable . row ( <str> ) ; Set < Map . Entry < Integer , Character > > entrySet = row . tailMap ( <int> ) . entrySet ( ) ; assertFalse ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertTrue ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertFalse ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; entrySet = row . entrySet ( ) ; assertTrue ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertFalse ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; assertFalse ( entrySet . remove ( Maps . immutableEntry ( <int> , <str> ) ) ) ; } public void testRowSize ( ) { table = sortedTable = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; SortedMap < Integer , Character > row = sortedTable . row ( <str> ) ; assertEquals ( row . size ( ) , <int> ) ; assertEquals ( row . tailMap ( <int> ) . size ( ) , <int> ) ; } public void testSubRowClearAndPut ( ) { table = create ( <str> , <int> , <str> , <str> , <int> , <str> , <str> , <int> , <str> ) ; SortedMap < Integer , Character > row = ( SortedMap < Integer , Character > ) table . row ( <str> ) ; SortedMap < Integer , Character > subRow = row . tailMap ( <int> ) ; assertEquals ( ImmutableMap . of ( <int> , <str> , <int> , <str> ) , row ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , subRow ) ; table . remove ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , row ) ; assertEquals ( ImmutableMap . of ( ) , subRow ) ; table . remove ( <str> , <int> ) ; assertEquals ( ImmutableMap . of ( ) , row ) ; assertEquals ( ImmutableMap . of ( ) , subRow ) ; table . put ( <str> , <int> , <str> ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , row ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , subRow ) ; row . clear ( ) ; assertEquals ( ImmutableMap . of ( ) , row ) ; assertEquals ( ImmutableMap . of ( ) , subRow ) ; table . put ( <str> , <int> , <str> ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , row ) ; assertEquals ( ImmutableMap . of ( <int> , <str> ) , subRow ) ; } } 
