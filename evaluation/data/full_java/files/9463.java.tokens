package com . google . common . math ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . primitives . Doubles . isFinite ; import static java . lang . Double . NaN ; import static java . lang . Double . isNaN ; import com . google . common . annotations . Beta ; @Beta public final class PairedStatsAccumulator { private final StatsAccumulator xStats = new StatsAccumulator ( ) ; private final StatsAccumulator yStats = new StatsAccumulator ( ) ; private double sumOfProductsOfDeltas = <float> ; public void add ( double x , double y ) { xStats . add ( x ) ; if ( isFinite ( x ) & & isFinite ( y ) ) { if ( xStats . count ( ) > <int> ) { sumOfProductsOfDeltas + = ( x - xStats . mean ( ) ) * ( y - yStats . mean ( ) ) ; } } else { sumOfProductsOfDeltas = NaN ; } yStats . add ( y ) ; } public PairedStats snapshot ( ) { return new PairedStats ( xStats . snapshot ( ) , yStats . snapshot ( ) , sumOfProductsOfDeltas ) ; } public long count ( ) { return xStats . count ( ) ; } public Stats xStats ( ) { return xStats . snapshot ( ) ; } public Stats yStats ( ) { return yStats . snapshot ( ) ; } public double populationCovariance ( ) { checkState ( count ( ) ! = <int> ) ; return sumOfProductsOfDeltas / count ( ) ; } public final double sampleCovariance ( ) { checkState ( count ( ) > <int> ) ; return sumOfProductsOfDeltas / ( count ( ) - <int> ) ; } public final double pearsonsCorrelationCoefficient ( ) { checkState ( count ( ) > <int> ) ; if ( isNaN ( sumOfProductsOfDeltas ) ) { return NaN ; } double xSumOfSquaresOfDeltas = xStats . sumOfSquaresOfDeltas ( ) ; double ySumOfSquaresOfDeltas = yStats . sumOfSquaresOfDeltas ( ) ; checkState ( xSumOfSquaresOfDeltas > <float> ) ; checkState ( ySumOfSquaresOfDeltas > <float> ) ; double productOfSumsOfSquaresOfDeltas = ensurePositive ( xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas ) ; return ensureInUnitRange ( sumOfProductsOfDeltas / Math . sqrt ( productOfSumsOfSquaresOfDeltas ) ) ; } public final LinearTransformation leastSquaresFit ( ) { checkState ( count ( ) > <int> ) ; if ( isNaN ( sumOfProductsOfDeltas ) ) { return LinearTransformation . forNaN ( ) ; } double xSumOfSquaresOfDeltas = xStats . sumOfSquaresOfDeltas ( ) ; if ( xSumOfSquaresOfDeltas > <float> ) { if ( yStats . sumOfSquaresOfDeltas ( ) > <float> ) { return LinearTransformation . mapping ( xStats . mean ( ) , yStats . mean ( ) ) . withSlope ( sumOfProductsOfDeltas / xSumOfSquaresOfDeltas ) ; } else { return LinearTransformation . horizontal ( yStats . mean ( ) ) ; } } else { checkState ( yStats . sumOfSquaresOfDeltas ( ) > <float> ) ; return LinearTransformation . vertical ( xStats . mean ( ) ) ; } } private double ensurePositive ( double value ) { if ( value > <float> ) { return value ; } else { return Double . MIN_VALUE ; } } private static double ensureInUnitRange ( double value ) { if ( value > = <float> ) { return <float> ; } if ( value < = - <float> ) { return - <float> ; } return value ; } } 
