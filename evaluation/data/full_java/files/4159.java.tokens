package org . eclipse . debug . internal . ui . contexts ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . regex . Pattern ; import org . eclipse . core . commands . common . NotDefinedException ; import org . eclipse . core . commands . contexts . Context ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchesListener2 ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugModelProvider ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . ActivityManagerEvent ; import org . eclipse . ui . activities . IActivity ; import org . eclipse . ui . activities . IActivityManager ; import org . eclipse . ui . activities . IActivityManagerListener ; import org . eclipse . ui . activities . IActivityPatternBinding ; import org . eclipse . ui . activities . IWorkbenchActivitySupport ; import org . eclipse . ui . contexts . IContextActivation ; import org . eclipse . ui . contexts . IContextService ; import org . eclipse . ui . progress . UIJob ; public class DebugModelContextBindingManager implements IDebugContextListener , ILaunchesListener2 , IActivityManagerListener { private Map < String , List < String > > fModelToContextIds = new HashMap < String , List < String > > ( ) ; private Map < ILaunch , Set < String > > fLaunchToModelIds = new HashMap < ILaunch , Set < String > > ( ) ; private Map < ILaunch , List < IContextActivation > > fLanuchToContextActivations = new HashMap < ILaunch , List < IContextActivation > > ( ) ; private List < IActivityPatternBinding > fModelPatternBindings = new ArrayList < IActivityPatternBinding > ( ) ; private Map < String , Set < String > > fModelToActivities = new HashMap < String , Set < String > > ( ) ; private Set < String > fModelsEnabledForActivities = new HashSet < String > ( ) ; public static final String ID_DEBUG_MODEL_CONTEXT_BINDINGS = <str> ; public static final String ATTR_CONTEXT_ID = <str> ; public static final String ATTR_DEBUG_MODEL_ID = <str> ; public static final String DEBUG_CONTEXT = <str> ; private static final String DEBUG_MODEL_ACTIVITY_SUFFIX = <str> ; private static DebugModelContextBindingManager fgManager ; private static IContextService fgContextService = PlatformUI . getWorkbench ( ) . getAdapter ( IContextService . class ) ; public static DebugModelContextBindingManager getDefault ( ) { if ( fgManager = = null ) { fgManager = new DebugModelContextBindingManager ( ) ; } return fgManager ; } private DebugModelContextBindingManager ( ) { loadDebugModelContextBindings ( ) ; loadDebugModelActivityExtensions ( ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunchListener ( this ) ; DebugUITools . getDebugContextManager ( ) . addDebugContextListener ( this ) ; IWorkbenchActivitySupport activitySupport = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; activitySupport . getActivityManager ( ) . addActivityManagerListener ( this ) ; } private void loadDebugModelContextBindings ( ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugUIPlugin . getUniqueIdentifier ( ) , ID_DEBUG_MODEL_CONTEXT_BINDINGS ) ; IConfigurationElement [ ] configurationElements = extensionPoint . getConfigurationElements ( ) ; for ( int i = <int> ; i < configurationElements . length ; i + + ) { IConfigurationElement element = configurationElements [ i ] ; String modelIdentifier = element . getAttribute ( ATTR_DEBUG_MODEL_ID ) ; String contextId = element . getAttribute ( ATTR_CONTEXT_ID ) ; synchronized ( this ) { if ( modelIdentifier ! = null & & contextId ! = null ) { List < String > contextIds = fModelToContextIds . get ( modelIdentifier ) ; if ( contextIds = = null ) { contextIds = new ArrayList < String > ( ) ; fModelToContextIds . put ( modelIdentifier , contextIds ) ; } contextIds . add ( contextId ) ; } } } } private void loadDebugModelActivityExtensions ( ) { IActivityManager activityManager = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) . getActivityManager ( ) ; Set < String > activityIds = activityManager . getDefinedActivityIds ( ) ; for ( String activityId : activityIds ) { IActivity activity = activityManager . getActivity ( activityId ) ; if ( activity ! = null ) { Set < IActivityPatternBinding > patternBindings = activity . getActivityPatternBindings ( ) ; for ( IActivityPatternBinding patternBinding : patternBindings ) { String pattern = patternBinding . getPattern ( ) . pattern ( ) ; if ( pattern . endsWith ( DEBUG_MODEL_ACTIVITY_SUFFIX ) ) { fModelPatternBindings . add ( patternBinding ) ; } } } } } @Override public void debugContextChanged ( DebugContextEvent event ) { if ( ( event . getFlags ( ) & DebugContextEvent . ACTIVATED ) > <int> ) { ISelection selection = event . getContext ( ) ; if ( selection instanceof IStructuredSelection ) { IStructuredSelection ss = ( IStructuredSelection ) selection ; Iterator < ? > iterator = ss . iterator ( ) ; while ( iterator . hasNext ( ) ) { activated ( iterator . next ( ) ) ; } } } } private void activated ( Object object ) { String [ ] modelIds = getDebugModelIds ( object ) ; if ( modelIds = = null ) { return ; } ILaunch launch = getLaunch ( object ) ; if ( launch = = null | | launch . isTerminated ( ) ) { return ; } List < String > toEnable = new ArrayList < String > ( modelIds . length ) ; synchronized ( this ) { Set < String > alreadyEnabled = fLaunchToModelIds . get ( launch ) ; if ( alreadyEnabled = = null ) { alreadyEnabled = new HashSet < String > ( ) ; fLaunchToModelIds . put ( launch , alreadyEnabled ) ; } for ( int i = <int> ; i < modelIds . length ; i + + ) { String id = modelIds [ i ] ; if ( ! alreadyEnabled . contains ( id ) ) { alreadyEnabled . add ( id ) ; toEnable . add ( id ) ; } } } for ( int i = <int> ; i < toEnable . size ( ) ; i + + ) { activateModel ( toEnable . get ( i ) , launch ) ; } enableActivitiesFor ( modelIds ) ; } private void activateModel ( String modelId , ILaunch launch ) { List < String > contextIds = null ; synchronized ( this ) { contextIds = fModelToContextIds . get ( modelId ) ; if ( contextIds = = null ) { contextIds = new ArrayList < String > ( ) ; contextIds . add ( DEBUG_CONTEXT ) ; fModelToContextIds . put ( modelId , contextIds ) ; } } for ( String id : contextIds ) { activateContext ( id , launch ) ; } } private void activateContext ( String contextId , ILaunch launch ) { while ( contextId ! = null ) { Context context = fgContextService . getContext ( contextId ) ; IContextActivation activation = fgContextService . activateContext ( contextId ) ; addActivation ( launch , activation ) ; try { if ( contextId . equals ( DEBUG_CONTEXT ) ) { break ; } contextId = context . getParentId ( ) ; } catch ( NotDefinedException e ) { contextId = null ; DebugUIPlugin . log ( e ) ; } } } private synchronized void addActivation ( ILaunch launch , IContextActivation activation ) { List < IContextActivation > activations = fLanuchToContextActivations . get ( launch ) ; if ( activations = = null ) { activations = new ArrayList < IContextActivation > ( ) ; fLanuchToContextActivations . put ( launch , activations ) ; } activations . add ( activation ) ; } private String [ ] getDebugModelIds ( Object object ) { if ( object instanceof IAdaptable ) { IDebugModelProvider modelProvider = ( ( IAdaptable ) object ) . getAdapter ( IDebugModelProvider . class ) ; if ( modelProvider ! = null ) { String [ ] modelIds = modelProvider . getModelIdentifiers ( ) ; if ( modelIds ! = null ) { return modelIds ; } } } if ( object instanceof IStackFrame ) { return new String [ ] { ( ( IStackFrame ) object ) . getModelIdentifier ( ) } ; } return null ; } public static ILaunch getLaunch ( Object object ) { ILaunch launch = null ; if ( object instanceof IAdaptable ) { launch = ( ( IAdaptable ) object ) . getAdapter ( ILaunch . class ) ; } if ( launch = = null & & object instanceof IDebugElement ) { launch = ( ( IDebugElement ) object ) . getLaunch ( ) ; } return launch ; } @Override public void launchesTerminated ( ILaunch [ ] launches ) { for ( int i = <int> ; i < launches . length ; i + + ) { ILaunch launch = launches [ i ] ; List < IContextActivation > activations ; synchronized ( this ) { activations = fLanuchToContextActivations . remove ( launch ) ; fLaunchToModelIds . remove ( launch ) ; } if ( activations ! = null ) { final List < IContextActivation > _activations = activations ; UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { for ( IContextActivation activation : _activations ) { activation . getContextService ( ) . deactivateContext ( activation ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } } @Override public void launchesRemoved ( ILaunch [ ] launches ) { } @Override public void launchesAdded ( ILaunch [ ] launches ) { } @Override public void launchesChanged ( ILaunch [ ] launches ) { } public List < String > getWorkbenchContextsForDebugContext ( Object target ) { List < String > workbenchContexts = new ArrayList < String > ( ) ; String [ ] modelIds = getDebugModelIds ( target ) ; if ( modelIds ! = null ) { for ( int i = <int> ; i < modelIds . length ; i + + ) { String modelId = modelIds [ i ] ; synchronized ( this ) { List < String > contextIds = fModelToContextIds . get ( modelId ) ; if ( contextIds ! = null ) { for ( String contextId : contextIds ) { if ( ! workbenchContexts . contains ( contextId ) ) { workbenchContexts . add ( contextId ) ; } } } } } } return workbenchContexts ; } private void enableActivitiesFor ( String [ ] modelIds ) { Set < String > activities = null ; for ( int i = <int> ; i < modelIds . length ; i + + ) { String id = modelIds [ i ] ; if ( ! fModelsEnabledForActivities . contains ( id ) ) { Set < String > ids = fModelToActivities . get ( id ) ; if ( ids = = null ) { ids = new HashSet < String > ( ) ; fModelToActivities . put ( id , ids ) ; for ( IActivityPatternBinding binding : fModelPatternBindings ) { String regex = binding . getPattern ( ) . pattern ( ) ; regex = regex . substring ( <int> , regex . length ( ) - DEBUG_MODEL_ACTIVITY_SUFFIX . length ( ) ) ; if ( Pattern . matches ( regex , id ) ) { ids . add ( binding . getActivityId ( ) ) ; } } } if ( ! ids . isEmpty ( ) ) { if ( activities = = null ) { activities = new HashSet < String > ( ) ; } activities . addAll ( ids ) ; } fModelsEnabledForActivities . add ( id ) ; } } if ( activities ! = null ) { IWorkbenchActivitySupport activitySupport = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; Set < String > enabledActivityIds = activitySupport . getActivityManager ( ) . getEnabledActivityIds ( ) ; if ( ! enabledActivityIds . containsAll ( activities ) ) { enabledActivityIds = new HashSet < String > ( enabledActivityIds ) ; enabledActivityIds . addAll ( activities ) ; activitySupport . setEnabledActivityIds ( activities ) ; } } } @Override public void activityManagerChanged ( ActivityManagerEvent activityManagerEvent ) { if ( activityManagerEvent . haveEnabledActivityIdsChanged ( ) ) { fModelsEnabledForActivities . clear ( ) ; } } } 
