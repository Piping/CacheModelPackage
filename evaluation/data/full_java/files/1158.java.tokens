package org . apache . cassandra . transport ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicLong ; @ChannelHandler.Sharable final class ConnectionLimitHandler extends ChannelInboundHandlerAdapter { private static final Logger logger = LoggerFactory . getLogger ( ConnectionLimitHandler . class ) ; private final ConcurrentMap < InetAddress , AtomicLong > connectionsPerClient = new ConcurrentHashMap < > ( ) ; private final AtomicLong counter = new AtomicLong ( <int> ) ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { final long count = counter . incrementAndGet ( ) ; long limit = DatabaseDescriptor . getNativeTransportMaxConcurrentConnections ( ) ; if ( limit < <int> ) { limit = Long . MAX_VALUE ; } if ( count > limit ) { logger . warn ( <str> , limit , count ) ; ctx . close ( ) ; } else { long perIpLimit = DatabaseDescriptor . getNativeTransportMaxConcurrentConnectionsPerIp ( ) ; if ( perIpLimit > <int> ) { InetAddress address = ( ( InetSocketAddress ) ctx . channel ( ) . remoteAddress ( ) ) . getAddress ( ) ; AtomicLong perIpCount = connectionsPerClient . get ( address ) ; if ( perIpCount = = null ) { perIpCount = new AtomicLong ( <int> ) ; AtomicLong old = connectionsPerClient . putIfAbsent ( address , perIpCount ) ; if ( old ! = null ) { perIpCount = old ; } } if ( perIpCount . incrementAndGet ( ) > perIpLimit ) { logger . warn ( <str> , perIpLimit , perIpCount ) ; ctx . close ( ) ; return ; } } ctx . fireChannelActive ( ) ; } } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { counter . decrementAndGet ( ) ; InetAddress address = ( ( InetSocketAddress ) ctx . channel ( ) . remoteAddress ( ) ) . getAddress ( ) ; AtomicLong count = connectionsPerClient . get ( address ) ; if ( count ! = null ) { if ( count . decrementAndGet ( ) < = <int> ) { connectionsPerClient . remove ( address ) ; } } ctx . fireChannelInactive ( ) ; } } 
