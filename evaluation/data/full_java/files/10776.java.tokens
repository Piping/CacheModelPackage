package org . gradle . api . plugins . antlr . internal . antlr2 ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; public class GenerationPlanBuilder { private static final Logger LOGGER = LoggerFactory . getLogger ( GenerationPlanBuilder . class ) ; private final LinkedHashMap < String , GenerationPlan > generationPlans = new LinkedHashMap < String , GenerationPlan > ( ) ; private final File outputDirectory ; private XRef metadataXRef ; public GenerationPlanBuilder ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } public synchronized List < GenerationPlan > buildGenerationPlans ( XRef metadataXRef ) { this . metadataXRef = metadataXRef ; Iterator < GrammarFileMetadata > grammarFiles = metadataXRef . iterateGrammarFiles ( ) ; while ( grammarFiles . hasNext ( ) ) { final GrammarFileMetadata grammarFileMetadata = grammarFiles . next ( ) ; locateOrBuildGenerationPlan ( grammarFileMetadata ) ; } return new ArrayList < GenerationPlan > ( generationPlans . values ( ) ) ; } private GenerationPlan locateOrBuildGenerationPlan ( GrammarFileMetadata grammarFileMetadata ) { GenerationPlan generationPlan = generationPlans . get ( grammarFileMetadata . getFilePath ( ) . getPath ( ) ) ; if ( generationPlan = = null ) { generationPlan = buildGenerationPlan ( grammarFileMetadata ) ; } return generationPlan ; } private GenerationPlan buildGenerationPlan ( GrammarFileMetadata grammarFileMetadata ) { File generationDirectory = isEmpty ( grammarFileMetadata . getPackageName ( ) ) ? outputDirectory : new File ( outputDirectory , grammarFileMetadata . getPackageName ( ) . replace ( <str> , File . separatorChar ) ) ; GenerationPlan generationPlan = new GenerationPlan ( grammarFileMetadata . getFilePath ( ) , generationDirectory ) ; for ( GrammarMetadata grammarMetadata : grammarFileMetadata . getGrammars ( ) ) { final File generatedParserFile = new File ( outputDirectory , grammarMetadata . determineGeneratedParserPath ( ) ) ; if ( ! generatedParserFile . exists ( ) ) { generationPlan . markOutOfDate ( ) ; } else if ( generatedParserFile . lastModified ( ) < generationPlan . getSource ( ) . lastModified ( ) ) { generationPlan . markOutOfDate ( ) ; } if ( ! grammarMetadata . extendsStandardGrammar ( ) ) { final GrammarFileMetadata superGrammarGrammarFileMetadata = grammarMetadata . getSuperGrammarDelegate ( ) . getAssociatedGrammarMetadata ( ) . getGrammarFile ( ) ; if ( superGrammarGrammarFileMetadata ! = null ) { final GenerationPlan superGrammarGenerationPlan = locateOrBuildGenerationPlan ( superGrammarGrammarFileMetadata ) ; if ( superGrammarGenerationPlan . isOutOfDate ( ) ) { generationPlan . markOutOfDate ( ) ; } else if ( superGrammarGenerationPlan . getSource ( ) . lastModified ( ) > generatedParserFile . lastModified ( ) ) { generationPlan . markOutOfDate ( ) ; } } } if ( isNotEmpty ( grammarMetadata . getImportVocab ( ) ) ) { final GrammarFileMetadata importVocabGrammarFileMetadata = metadataXRef . getGrammarFileByExportVocab ( grammarMetadata . getImportVocab ( ) ) ; if ( importVocabGrammarFileMetadata = = null ) { LOGGER . warn ( <str> + grammarMetadata . getImportVocab ( ) + <str> ) ; } else if ( ! importVocabGrammarFileMetadata . getFilePath ( ) . equals ( grammarFileMetadata . getFilePath ( ) ) ) { final GenerationPlan importVocabGrammarGenerationPlan = locateOrBuildGenerationPlan ( importVocabGrammarFileMetadata ) ; generationPlan . setImportVocabTokenTypesDirectory ( importVocabGrammarGenerationPlan . getGenerationDirectory ( ) ) ; if ( importVocabGrammarGenerationPlan . isOutOfDate ( ) ) { generationPlan . markOutOfDate ( ) ; } else if ( importVocabGrammarGenerationPlan . getSource ( ) . lastModified ( ) > generatedParserFile . lastModified ( ) ) { generationPlan . markOutOfDate ( ) ; } } } } generationPlans . put ( generationPlan . getId ( ) , generationPlan ) ; return generationPlan ; } private boolean isEmpty ( String string ) { return string = = null | | string . trim ( ) . length ( ) = = <int> ; } private boolean isNotEmpty ( String string ) { return ! isEmpty ( string ) ; } } 
