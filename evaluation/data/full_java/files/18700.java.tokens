package com . badlogic . gdx . tests . g3d . voxel ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . RenderableProvider ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; public class VoxelWorld implements RenderableProvider { public static final int CHUNK_SIZE_X = <int> ; public static final int CHUNK_SIZE_Y = <int> ; public static final int CHUNK_SIZE_Z = <int> ; public final VoxelChunk [ ] chunks ; public final Mesh [ ] meshes ; public final Material [ ] materials ; public final boolean [ ] dirty ; public final int [ ] numVertices ; public float [ ] vertices ; public final int chunksX ; public final int chunksY ; public final int chunksZ ; public final int voxelsX ; public final int voxelsY ; public final int voxelsZ ; public int renderedChunks ; public int numChunks ; private final TextureRegion [ ] tiles ; public VoxelWorld ( TextureRegion [ ] tiles , int chunksX , int chunksY , int chunksZ ) { this . tiles = tiles ; this . chunks = new VoxelChunk [ chunksX * chunksY * chunksZ ] ; this . chunksX = chunksX ; this . chunksY = chunksY ; this . chunksZ = chunksZ ; this . numChunks = chunksX * chunksY * chunksZ ; this . voxelsX = chunksX * CHUNK_SIZE_X ; this . voxelsY = chunksY * CHUNK_SIZE_Y ; this . voxelsZ = chunksZ * CHUNK_SIZE_Z ; int i = <int> ; for ( int y = <int> ; y < chunksY ; y + + ) { for ( int z = <int> ; z < chunksZ ; z + + ) { for ( int x = <int> ; x < chunksX ; x + + ) { VoxelChunk chunk = new VoxelChunk ( CHUNK_SIZE_X , CHUNK_SIZE_Y , CHUNK_SIZE_Z ) ; chunk . offset . set ( x * CHUNK_SIZE_X , y * CHUNK_SIZE_Y , z * CHUNK_SIZE_Z ) ; chunks [ i + + ] = chunk ; } } } int len = CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z * <int> * <int> / <int> ; short [ ] indices = new short [ len ] ; short j = <int> ; for ( i = <int> ; i < len ; i + = <int> , j + = <int> ) { indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; } this . meshes = new Mesh [ chunksX * chunksY * chunksZ ] ; for ( i = <int> ; i < meshes . length ; i + + ) { meshes [ i ] = new Mesh ( true , CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z * <int> * <int> , CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z * <int> / <int> , VertexAttribute . Position ( ) , VertexAttribute . Normal ( ) ) ; meshes [ i ] . setIndices ( indices ) ; } this . dirty = new boolean [ chunksX * chunksY * chunksZ ] ; for ( i = <int> ; i < dirty . length ; i + + ) dirty [ i ] = true ; this . numVertices = new int [ chunksX * chunksY * chunksZ ] ; for ( i = <int> ; i < numVertices . length ; i + + ) numVertices [ i ] = <int> ; this . vertices = new float [ VoxelChunk . VERTEX_SIZE * <int> * CHUNK_SIZE_X * CHUNK_SIZE_Y * CHUNK_SIZE_Z ] ; this . materials = new Material [ chunksX * chunksY * chunksZ ] ; for ( i = <int> ; i < materials . length ; i + + ) { materials [ i ] = new Material ( new ColorAttribute ( ColorAttribute . Diffuse , MathUtils . random ( <float> , <float> ) , MathUtils . random ( <float> , <float> ) , MathUtils . random ( <float> , <float> ) , <int> ) ) ; } } public void set ( float x , float y , float z , byte voxel ) { int ix = ( int ) x ; int iy = ( int ) y ; int iz = ( int ) z ; int chunkX = ix / CHUNK_SIZE_X ; if ( chunkX < <int> | | chunkX > = chunksX ) return ; int chunkY = iy / CHUNK_SIZE_Y ; if ( chunkY < <int> | | chunkY > = chunksY ) return ; int chunkZ = iz / CHUNK_SIZE_Z ; if ( chunkZ < <int> | | chunkZ > = chunksZ ) return ; chunks [ chunkX + chunkZ * chunksX + chunkY * chunksX * chunksZ ] . set ( ix % CHUNK_SIZE_X , iy % CHUNK_SIZE_Y , iz % CHUNK_SIZE_Z , voxel ) ; } public byte get ( float x , float y , float z ) { int ix = ( int ) x ; int iy = ( int ) y ; int iz = ( int ) z ; int chunkX = ix / CHUNK_SIZE_X ; if ( chunkX < <int> | | chunkX > = chunksX ) return <int> ; int chunkY = iy / CHUNK_SIZE_Y ; if ( chunkY < <int> | | chunkY > = chunksY ) return <int> ; int chunkZ = iz / CHUNK_SIZE_Z ; if ( chunkZ < <int> | | chunkZ > = chunksZ ) return <int> ; return chunks [ chunkX + chunkZ * chunksX + chunkY * chunksX * chunksZ ] . get ( ix % CHUNK_SIZE_X , iy % CHUNK_SIZE_Y , iz % CHUNK_SIZE_Z ) ; } public float getHighest ( float x , float z ) { int ix = ( int ) x ; int iz = ( int ) z ; if ( ix < <int> | | ix > = voxelsX ) return <int> ; if ( iz < <int> | | iz > = voxelsZ ) return <int> ; for ( int y = voxelsY - <int> ; y > <int> ; y - - ) { if ( get ( ix , y , iz ) > <int> ) return y + <int> ; } return <int> ; } public void setColumn ( float x , float y , float z , byte voxel ) { int ix = ( int ) x ; int iy = ( int ) y ; int iz = ( int ) z ; if ( ix < <int> | | ix > = voxelsX ) return ; if ( iy < <int> | | iy > = voxelsY ) return ; if ( iz < <int> | | iz > = voxelsZ ) return ; for ( ; iy > <int> ; iy - - ) { set ( ix , iy , iz , voxel ) ; } } public void setCube ( float x , float y , float z , float width , float height , float depth , byte voxel ) { int ix = ( int ) x ; int iy = ( int ) y ; int iz = ( int ) z ; int iwidth = ( int ) width ; int iheight = ( int ) height ; int idepth = ( int ) depth ; int startX = Math . max ( ix , <int> ) ; int endX = Math . min ( voxelsX , ix + iwidth ) ; int startY = Math . max ( iy , <int> ) ; int endY = Math . min ( voxelsY , iy + iheight ) ; int startZ = Math . max ( iz , <int> ) ; int endZ = Math . min ( voxelsZ , iz + idepth ) ; for ( iy = startY ; iy < endY ; iy + + ) { for ( iz = startZ ; iz < endZ ; iz + + ) { for ( ix = startX ; ix < endX ; ix + + ) { set ( ix , iy , iz , voxel ) ; } } } } @Override public void getRenderables ( Array < Renderable > renderables , Pool < Renderable > pool ) { renderedChunks = <int> ; for ( int i = <int> ; i < chunks . length ; i + + ) { VoxelChunk chunk = chunks [ i ] ; Mesh mesh = meshes [ i ] ; if ( dirty [ i ] ) { int numVerts = chunk . calculateVertices ( vertices ) ; numVertices [ i ] = numVerts / <int> * <int> ; mesh . setVertices ( vertices , <int> , numVerts * VoxelChunk . VERTEX_SIZE ) ; dirty [ i ] = false ; } if ( numVertices [ i ] = = <int> ) continue ; Renderable renderable = pool . obtain ( ) ; renderable . material = materials [ i ] ; renderable . meshPart . mesh = mesh ; renderable . meshPart . offset = <int> ; renderable . meshPart . size = numVertices [ i ] ; renderable . meshPart . primitiveType = GL20 . GL_TRIANGLES ; renderables . add ( renderable ) ; renderedChunks + + ; } } } 
