package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . ListMultimapTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringListMultimapGenerator ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . ConcurrentModificationException ; import java . util . List ; import java . util . Map . Entry ; import java . util . RandomAccess ; @GwtCompatible ( emulated = true ) public class ArrayListMultimapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( ListMultimapTestSuiteBuilder . using ( new TestStringListMultimapGenerator ( ) { @Override protected ListMultimap < String , String > create ( Entry < String , String > [ ] entries ) { ListMultimap < String , String > multimap = ArrayListMultimap . create ( ) ; for ( Entry < String , String > entry : entries ) { multimap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return multimap ; } } ) . named ( <str> ) . withFeatures ( MapFeature . ALLOWS_NULL_KEYS , MapFeature . ALLOWS_NULL_VALUES , MapFeature . ALLOWS_ANY_NULL_QUERIES , MapFeature . GENERAL_PURPOSE , MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionFeature . SERIALIZABLE , CollectionSize . ANY ) . createTestSuite ( ) ) ; suite . addTestSuite ( ArrayListMultimapTest . class ) ; return suite ; } protected ListMultimap < String , Integer > create ( ) { return ArrayListMultimap . create ( ) ; } public void testGetRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; } public void testRemoveAllRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertTrue ( multimap . removeAll ( <str> ) instanceof RandomAccess ) ; assertTrue ( multimap . removeAll ( <str> ) instanceof RandomAccess ) ; } public void testReplaceValuesRandomAccess ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; assertTrue ( multimap . replaceValues ( <str> , asList ( <int> , <int> ) ) instanceof RandomAccess ) ; assertTrue ( multimap . replaceValues ( <str> , asList ( <int> , <int> ) ) instanceof RandomAccess ) ; } public void testSublistConcurrentModificationException ( ) { ListMultimap < String , Integer > multimap = create ( ) ; multimap . putAll ( <str> , asList ( <int> , <int> , <int> , <int> , <int> ) ) ; List < Integer > list = multimap . get ( <str> ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; List < Integer > sublist = list . subList ( <int> , <int> ) ; assertThat ( sublist ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; sublist . clear ( ) ; assertTrue ( sublist . isEmpty ( ) ) ; multimap . put ( <str> , <int> ) ; try { sublist . isEmpty ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } public void testCreateFromMultimap ( ) { Multimap < String , Integer > multimap = create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; ArrayListMultimap < String , Integer > copy = ArrayListMultimap . create ( multimap ) ; assertEquals ( multimap , copy ) ; } public void testCreate ( ) { ArrayListMultimap < String , Integer > multimap = ArrayListMultimap . create ( ) ; assertEquals ( <int> , multimap . expectedValuesPerKey ) ; } public void testCreateFromSizes ( ) { ArrayListMultimap < String , Integer > multimap = ArrayListMultimap . create ( <int> , <int> ) ; assertEquals ( <int> , multimap . expectedValuesPerKey ) ; } public void testCreateFromIllegalSizes ( ) { try { ArrayListMultimap . create ( <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { ArrayListMultimap . create ( - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCreateFromHashMultimap ( ) { Multimap < String , Integer > original = HashMultimap . create ( ) ; ArrayListMultimap < String , Integer > multimap = ArrayListMultimap . create ( original ) ; assertEquals ( <int> , multimap . expectedValuesPerKey ) ; } public void testCreateFromArrayListMultimap ( ) { ArrayListMultimap < String , Integer > original = ArrayListMultimap . create ( <int> , <int> ) ; ArrayListMultimap < String , Integer > multimap = ArrayListMultimap . create ( original ) ; assertEquals ( <int> , multimap . expectedValuesPerKey ) ; } public void testTrimToSize ( ) { ArrayListMultimap < String , Integer > multimap = ArrayListMultimap . create ( ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . put ( <str> , <int> ) ; multimap . trimToSize ( ) ; assertEquals ( <int> , multimap . size ( ) ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . contains ( <int> ) ; } } 
