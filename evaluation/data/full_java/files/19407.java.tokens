package io . netty . handler . codec . http2 ; import io . netty . util . collection . IntObjectHashMap ; import io . netty . util . collection . IntObjectMap ; import org . junit . Before ; import org . junit . Test ; import org . mockito . AdditionalMatchers ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import org . mockito . verification . VerificationMode ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . eq ; import static org . mockito . Matchers . same ; import static org . mockito . Mockito . atMost ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . doNothing ; import static org . mockito . Mockito . doThrow ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; public class PriorityStreamByteDistributorTest { private static final int STREAM_A = <int> ; private static final int STREAM_B = <int> ; private static final int STREAM_C = <int> ; private static final int STREAM_D = <int> ; private static final int STREAM_E = <int> ; private Http2Connection connection ; private PriorityStreamByteDistributor distributor ; @Mock private StreamByteDistributor . Writer writer ; @Before public void setup ( ) throws Http2Exception { MockitoAnnotations . initMocks ( this ) ; connection = new DefaultHttp2Connection ( false ) ; distributor = new PriorityStreamByteDistributor ( connection ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock in ) throws Throwable { Http2Stream stream = ( Http2Stream ) in . getArguments ( ) [ <int> ] ; int numBytes = ( Integer ) in . getArguments ( ) [ <int> ] ; int streamableBytes = distributor . unallocatedStreamableBytes ( stream ) - numBytes ; updateStream ( stream . id ( ) , streamableBytes , streamableBytes > <int> ) ; return null ; } } ) . when ( writer ) . write ( any ( Http2Stream . class ) , anyInt ( ) ) ; connection . local ( ) . createStream ( STREAM_A , false ) ; connection . local ( ) . createStream ( STREAM_B , false ) ; Http2Stream streamC = connection . local ( ) . createStream ( STREAM_C , false ) ; Http2Stream streamD = connection . local ( ) . createStream ( STREAM_D , false ) ; streamC . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; streamD . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; } @Test public void bytesUnassignedAfterProcessing ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertFalse ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; assertFalse ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void connectionErrorForWriterException ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; Exception fakeException = new RuntimeException ( <str> ) ; doThrow ( fakeException ) . when ( writer ) . write ( same ( stream ( STREAM_C ) ) , eq ( <int> ) ) ; try { write ( <int> ) ; fail ( <str> ) ; } catch ( Http2Exception e ) { assertFalse ( Http2Exception . isStreamError ( e ) ) ; assertEquals ( Http2Error . INTERNAL_ERROR , e . error ( ) ) ; assertSame ( fakeException , e . getCause ( ) ) ; } verifyWrite ( atMost ( <int> ) , STREAM_A , <int> ) ; verifyWrite ( atMost ( <int> ) , STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( atMost ( <int> ) , STREAM_D , <int> ) ; doNothing ( ) . when ( writer ) . write ( same ( stream ( STREAM_C ) ) , eq ( <int> ) ) ; write ( <int> ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( times ( <int> ) , STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void blockedStreamShouldSpreadDataToChildren ( ) throws Http2Exception { updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void childrenShouldNotSendDataUntilParentBlocked ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void parentShouldWaterFallDataToChildren ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void reprioritizeShouldAdjustOutboundFlow ( ) throws Http2Exception { updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; setPriority ( STREAM_D , <int> , DEFAULT_PRIORITY_WEIGHT , false ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void unstreamableParentsShouldFeedHungryChildren ( ) throws Http2Exception { setPriority ( STREAM_A , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_B , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_C , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_D , STREAM_A , ( short ) <int> , false ) ; final int writableBytes = <int> ; final int expectedUnsentAmount = <int> ; updateStream ( STREAM_D , writableBytes + expectedUnsentAmount , true ) ; assertTrue ( write ( writableBytes ) ) ; verifyWrite ( STREAM_D , writableBytes ) ; assertEquals ( expectedUnsentAmount , streamableBytesForTree ( stream ( STREAM_D ) ) ) ; } @Test public void writeShouldPreferHighestWeight ( ) throws Http2Exception { setPriority ( STREAM_A , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_B , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_C , <int> , ( short ) <int> , false ) ; setPriority ( STREAM_D , <int> , ( short ) <int> , false ) ; updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; int allowedError = <int> ; verifyWriteWithDelta ( STREAM_A , <int> , allowedError ) ; verifyWriteWithDelta ( STREAM_B , <int> , allowedError ) ; verifyWriteWithDelta ( STREAM_C , <int> , allowedError ) ; verifyWriteWithDelta ( STREAM_D , <int> , allowedError ) ; } @Test public void samePriorityShouldDistributeBasedOnData ( ) throws Http2Exception { setPriority ( STREAM_A , <int> , DEFAULT_PRIORITY_WEIGHT , false ) ; setPriority ( STREAM_B , <int> , DEFAULT_PRIORITY_WEIGHT , false ) ; setPriority ( STREAM_C , <int> , DEFAULT_PRIORITY_WEIGHT , false ) ; setPriority ( STREAM_D , <int> , DEFAULT_PRIORITY_WEIGHT , false ) ; updateStream ( STREAM_A , <int> , true ) ; updateStream ( STREAM_B , <int> , true ) ; updateStream ( STREAM_C , <int> , true ) ; updateStream ( STREAM_D , <int> , true ) ; assertTrue ( write ( <int> ) ) ; verifyWrite ( STREAM_A , <int> ) ; verifyWrite ( STREAM_B , <int> ) ; verifyWrite ( STREAM_C , <int> ) ; verifyWrite ( STREAM_D , <int> ) ; } @Test public void subTreeBytesShouldBeCorrect ( ) throws Http2Exception { Http2Stream stream0 = connection . connectionStream ( ) ; Http2Stream streamA = connection . stream ( STREAM_A ) ; Http2Stream streamB = connection . stream ( STREAM_B ) ; Http2Stream streamC = connection . stream ( STREAM_C ) ; Http2Stream streamD = connection . stream ( STREAM_D ) ; final IntObjectMap < Integer > streamSizes = new IntObjectHashMap < Integer > ( <int> ) ; streamSizes . put ( STREAM_A , ( Integer ) <int> ) ; streamSizes . put ( STREAM_B , ( Integer ) <int> ) ; streamSizes . put ( STREAM_C , ( Integer ) <int> ) ; streamSizes . put ( STREAM_D , ( Integer ) <int> ) ; updateStream ( STREAM_A , streamSizes . get ( STREAM_A ) , true ) ; updateStream ( STREAM_B , streamSizes . get ( STREAM_B ) , true ) ; updateStream ( STREAM_C , streamSizes . get ( STREAM_C ) , true ) ; updateStream ( STREAM_D , streamSizes . get ( STREAM_D ) , true ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_B , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( stream0 ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamA ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_B ) ) , streamableBytesForTree ( streamB ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_C ) ) , streamableBytesForTree ( streamC ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_D ) ) , streamableBytesForTree ( streamD ) ) ; } @Test public void subTreeBytesShouldBeCorrectWithRestructure ( ) throws Http2Exception { Http2Stream stream0 = connection . connectionStream ( ) ; Http2Stream streamA = connection . stream ( STREAM_A ) ; Http2Stream streamB = connection . stream ( STREAM_B ) ; Http2Stream streamC = connection . stream ( STREAM_C ) ; Http2Stream streamD = connection . stream ( STREAM_D ) ; final IntObjectMap < Integer > streamSizes = new IntObjectHashMap < Integer > ( <int> ) ; streamSizes . put ( STREAM_A , ( Integer ) <int> ) ; streamSizes . put ( STREAM_B , ( Integer ) <int> ) ; streamSizes . put ( STREAM_C , ( Integer ) <int> ) ; streamSizes . put ( STREAM_D , ( Integer ) <int> ) ; updateStream ( STREAM_A , streamSizes . get ( STREAM_A ) , true ) ; updateStream ( STREAM_B , streamSizes . get ( STREAM_B ) , true ) ; updateStream ( STREAM_C , streamSizes . get ( STREAM_C ) , true ) ; updateStream ( STREAM_D , streamSizes . get ( STREAM_D ) , true ) ; streamB . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , true ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_B , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( stream0 ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_B , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamA ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_B , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamB ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_C ) ) , streamableBytesForTree ( streamC ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_D ) ) , streamableBytesForTree ( streamD ) ) ; } @Test public void subTreeBytesShouldBeCorrectWithAddition ( ) throws Http2Exception { Http2Stream stream0 = connection . connectionStream ( ) ; Http2Stream streamA = connection . stream ( STREAM_A ) ; Http2Stream streamB = connection . stream ( STREAM_B ) ; Http2Stream streamC = connection . stream ( STREAM_C ) ; Http2Stream streamD = connection . stream ( STREAM_D ) ; Http2Stream streamE = connection . local ( ) . createStream ( STREAM_E , false ) ; streamE . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , true ) ; final IntObjectMap < Integer > streamSizes = new IntObjectHashMap < Integer > ( <int> ) ; streamSizes . put ( STREAM_A , ( Integer ) <int> ) ; streamSizes . put ( STREAM_B , ( Integer ) <int> ) ; streamSizes . put ( STREAM_C , ( Integer ) <int> ) ; streamSizes . put ( STREAM_D , ( Integer ) <int> ) ; streamSizes . put ( STREAM_E , ( Integer ) <int> ) ; updateStream ( STREAM_A , streamSizes . get ( STREAM_A ) , true ) ; updateStream ( STREAM_B , streamSizes . get ( STREAM_B ) , true ) ; updateStream ( STREAM_C , streamSizes . get ( STREAM_C ) , true ) ; updateStream ( STREAM_D , streamSizes . get ( STREAM_D ) , true ) ; updateStream ( STREAM_E , streamSizes . get ( STREAM_E ) , true ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_B , STREAM_C , STREAM_D , STREAM_E ) ) , streamableBytesForTree ( stream0 ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_E , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamA ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_B ) ) , streamableBytesForTree ( streamB ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_C ) ) , streamableBytesForTree ( streamC ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_D ) ) , streamableBytesForTree ( streamD ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_E , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamE ) ) ; } @Test public void subTreeBytesShouldBeCorrectWithInternalStreamClose ( ) throws Http2Exception { Http2Stream stream0 = connection . connectionStream ( ) ; Http2Stream streamA = connection . stream ( STREAM_A ) ; Http2Stream streamB = connection . stream ( STREAM_B ) ; Http2Stream streamC = connection . stream ( STREAM_C ) ; Http2Stream streamD = connection . stream ( STREAM_D ) ; final IntObjectMap < Integer > streamSizes = new IntObjectHashMap < Integer > ( <int> ) ; streamSizes . put ( STREAM_A , ( Integer ) <int> ) ; streamSizes . put ( STREAM_B , ( Integer ) <int> ) ; streamSizes . put ( STREAM_C , ( Integer ) <int> ) ; streamSizes . put ( STREAM_D , ( Integer ) <int> ) ; updateStream ( STREAM_A , streamSizes . get ( STREAM_A ) , true ) ; updateStream ( STREAM_B , streamSizes . get ( STREAM_B ) , true ) ; updateStream ( STREAM_C , streamSizes . get ( STREAM_C ) , true ) ; updateStream ( STREAM_D , streamSizes . get ( STREAM_D ) , true ) ; streamA . close ( ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_B , STREAM_C , STREAM_D ) ) , streamableBytesForTree ( stream0 ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_C , STREAM_D ) ) , streamableBytesForTree ( streamA ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_B ) ) , streamableBytesForTree ( streamB ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_C ) ) , streamableBytesForTree ( streamC ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_D ) ) , streamableBytesForTree ( streamD ) ) ; } @Test public void subTreeBytesShouldBeCorrectWithLeafStreamClose ( ) throws Http2Exception { Http2Stream stream0 = connection . connectionStream ( ) ; Http2Stream streamA = connection . stream ( STREAM_A ) ; Http2Stream streamB = connection . stream ( STREAM_B ) ; Http2Stream streamC = connection . stream ( STREAM_C ) ; Http2Stream streamD = connection . stream ( STREAM_D ) ; final IntObjectMap < Integer > streamSizes = new IntObjectHashMap < Integer > ( <int> ) ; streamSizes . put ( STREAM_A , ( Integer ) <int> ) ; streamSizes . put ( STREAM_B , ( Integer ) <int> ) ; streamSizes . put ( STREAM_C , ( Integer ) <int> ) ; streamSizes . put ( STREAM_D , ( Integer ) <int> ) ; updateStream ( STREAM_A , streamSizes . get ( STREAM_A ) , true ) ; updateStream ( STREAM_B , streamSizes . get ( STREAM_B ) , true ) ; updateStream ( STREAM_C , streamSizes . get ( STREAM_C ) , true ) ; updateStream ( STREAM_D , streamSizes . get ( STREAM_D ) , true ) ; streamC . close ( ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_B , STREAM_D ) ) , streamableBytesForTree ( stream0 ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Arrays . asList ( STREAM_A , STREAM_D ) ) , streamableBytesForTree ( streamA ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_B ) ) , streamableBytesForTree ( streamB ) ) ; assertEquals ( <int> , streamableBytesForTree ( streamC ) ) ; assertEquals ( calculateStreamSizeSum ( streamSizes , Collections . singletonList ( STREAM_D ) ) , streamableBytesForTree ( streamD ) ) ; } private Http2Stream stream ( int streamId ) { return connection . stream ( streamId ) ; } private void updateStream ( final int streamId , final int streamableBytes , final boolean hasFrame ) { final Http2Stream stream = stream ( streamId ) ; distributor . updateStreamableBytes ( new StreamByteDistributor . StreamState ( ) { @Override public Http2Stream stream ( ) { return stream ; } @Override public int streamableBytes ( ) { return streamableBytes ; } @Override public boolean hasFrame ( ) { return hasFrame ; } } ) ; } private void setPriority ( int streamId , int parent , int weight , boolean exclusive ) throws Http2Exception { stream ( streamId ) . setPriority ( parent , ( short ) weight , exclusive ) ; } private long streamableBytesForTree ( Http2Stream stream ) { return distributor . unallocatedStreamableBytesForTree ( stream ) ; } private boolean write ( int numBytes ) throws Http2Exception { return distributor . distribute ( numBytes , writer ) ; } private void verifyWrite ( int streamId , int numBytes ) { verify ( writer ) . write ( same ( stream ( streamId ) ) , eq ( numBytes ) ) ; } private void verifyWrite ( VerificationMode mode , int streamId , int numBytes ) { verify ( writer , mode ) . write ( same ( stream ( streamId ) ) , eq ( numBytes ) ) ; } private void verifyWriteWithDelta ( int streamId , int numBytes , int delta ) { verify ( writer ) . write ( same ( stream ( streamId ) ) , ( int ) AdditionalMatchers . eq ( numBytes , delta ) ) ; } private static long calculateStreamSizeSum ( IntObjectMap < Integer > streamSizes , List < Integer > streamIds ) { long sum = <int> ; for ( Integer streamId : streamIds ) { Integer streamSize = streamSizes . get ( streamId ) ; if ( streamSize ! = null ) { sum + = streamSize ; } } return sum ; } } 
