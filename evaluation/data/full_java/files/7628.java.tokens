package org . elasticsearch . snapshots ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . elasticsearch . Version ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . rest . RestStatus ; public class SnapshotInfo implements ToXContent , Streamable { private static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( <str> ) ; private String name ; private SnapshotState state ; private String reason ; private List < String > indices ; private long startTime ; private long endTime ; private int totalShards ; private int successfulShards ; private Version version ; private List < SnapshotShardFailure > shardFailures ; SnapshotInfo ( ) { } public SnapshotInfo ( Snapshot snapshot ) { name = snapshot . name ( ) ; state = snapshot . state ( ) ; reason = snapshot . reason ( ) ; indices = snapshot . indices ( ) ; startTime = snapshot . startTime ( ) ; endTime = snapshot . endTime ( ) ; totalShards = snapshot . totalShard ( ) ; successfulShards = snapshot . successfulShards ( ) ; shardFailures = snapshot . shardFailures ( ) ; version = snapshot . version ( ) ; } public String name ( ) { return name ; } public SnapshotState state ( ) { return state ; } public String reason ( ) { return reason ; } public List < String > indices ( ) { return indices ; } public long startTime ( ) { return startTime ; } public long endTime ( ) { return endTime ; } public int totalShards ( ) { return totalShards ; } public int failedShards ( ) { return totalShards - successfulShards ; } public int successfulShards ( ) { return successfulShards ; } public List < SnapshotShardFailure > shardFailures ( ) { return shardFailures ; } public Version version ( ) { return version ; } public RestStatus status ( ) { if ( state = = SnapshotState . FAILED ) { return RestStatus . INTERNAL_SERVER_ERROR ; } if ( shardFailures . size ( ) = = <int> ) { return RestStatus . OK ; } return RestStatus . status ( successfulShards , totalShards , shardFailures . toArray ( new ShardOperationFailedException [ shardFailures . size ( ) ] ) ) ; } static final class Fields { static final XContentBuilderString INDICES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STATE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString REASON = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString END_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString END_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DURATION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DURATION_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FAILURES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FAILED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SUCCESSFUL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VERSION_ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VERSION = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( <str> , name ) ; builder . field ( Fields . VERSION_ID , version . id ) ; builder . field ( Fields . VERSION , version . toString ( ) ) ; builder . startArray ( Fields . INDICES ) ; for ( String index : indices ) { builder . value ( index ) ; } builder . endArray ( ) ; builder . field ( Fields . STATE , state ) ; if ( reason ! = null ) { builder . field ( Fields . REASON , reason ) ; } if ( startTime ! = <int> ) { builder . field ( Fields . START_TIME , DATE_TIME_FORMATTER . printer ( ) . print ( startTime ) ) ; builder . field ( Fields . START_TIME_IN_MILLIS , startTime ) ; } if ( endTime ! = <int> ) { builder . field ( Fields . END_TIME , DATE_TIME_FORMATTER . printer ( ) . print ( endTime ) ) ; builder . field ( Fields . END_TIME_IN_MILLIS , endTime ) ; builder . timeValueField ( Fields . DURATION_IN_MILLIS , Fields . DURATION , endTime - startTime ) ; } builder . startArray ( Fields . FAILURES ) ; for ( SnapshotShardFailure shardFailure : shardFailures ) { builder . startObject ( ) ; shardFailure . toXContent ( builder , params ) ; builder . endObject ( ) ; } builder . endArray ( ) ; builder . startObject ( Fields . SHARDS ) ; builder . field ( Fields . TOTAL , totalShards ) ; builder . field ( Fields . FAILED , failedShards ( ) ) ; builder . field ( Fields . SUCCESSFUL , successfulShards ) ; builder . endObject ( ) ; builder . endObject ( ) ; return builder ; } @Override public void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; int size = in . readVInt ( ) ; List < String > indicesListBuilder = new ArrayList < > ( ) ; for ( int i = <int> ; i < size ; i + + ) { indicesListBuilder . add ( in . readString ( ) ) ; } indices = Collections . unmodifiableList ( indicesListBuilder ) ; state = SnapshotState . fromValue ( in . readByte ( ) ) ; reason = in . readOptionalString ( ) ; startTime = in . readVLong ( ) ; endTime = in . readVLong ( ) ; totalShards = in . readVInt ( ) ; successfulShards = in . readVInt ( ) ; size = in . readVInt ( ) ; if ( size > <int> ) { List < SnapshotShardFailure > failureBuilder = new ArrayList < > ( ) ; for ( int i = <int> ; i < size ; i + + ) { failureBuilder . add ( SnapshotShardFailure . readSnapshotShardFailure ( in ) ) ; } shardFailures = Collections . unmodifiableList ( failureBuilder ) ; } else { shardFailures = Collections . emptyList ( ) ; } version = Version . readVersion ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; out . writeVInt ( indices . size ( ) ) ; for ( String index : indices ) { out . writeString ( index ) ; } out . writeByte ( state . value ( ) ) ; out . writeOptionalString ( reason ) ; out . writeVLong ( startTime ) ; out . writeVLong ( endTime ) ; out . writeVInt ( totalShards ) ; out . writeVInt ( successfulShards ) ; out . writeVInt ( shardFailures . size ( ) ) ; for ( SnapshotShardFailure failure : shardFailures ) { failure . writeTo ( out ) ; } Version . writeVersion ( version , out ) ; } public static SnapshotInfo readSnapshotInfo ( StreamInput in ) throws IOException { SnapshotInfo snapshotInfo = new SnapshotInfo ( ) ; snapshotInfo . readFrom ( in ) ; return snapshotInfo ; } public static SnapshotInfo readOptionalSnapshotInfo ( StreamInput in ) throws IOException { return in . readOptionalStreamable ( SnapshotInfo : : new ) ; } } 
