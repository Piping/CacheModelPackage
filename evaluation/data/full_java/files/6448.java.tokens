package org . elasticsearch . index . fielddata ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . SortField ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . index . fielddata . ordinals . OrdinalsBuilder ; import org . elasticsearch . index . mapper . core . BooleanFieldMapper ; public interface IndexNumericFieldData extends IndexFieldData < AtomicNumericFieldData > { public static enum NumericType { BOOLEAN ( <int> , false , SortField . Type . INT , <int> , <int> ) { @Override public long toLong ( BytesRef indexForm ) { if ( indexForm . equals ( BooleanFieldMapper . Values . FALSE ) ) { return <int> ; } else if ( indexForm . equals ( BooleanFieldMapper . Values . TRUE ) ) { return <int> ; } else { throw new IllegalArgumentException ( <str> + indexForm + <str> ) ; } } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { bytes . append ( number . intValue ( ) ! = <int> ? BooleanFieldMapper . Values . TRUE : BooleanFieldMapper . Values . FALSE ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return toLong ( indexForm ) ; } } , BYTE ( <int> , false , SortField . Type . INT , Byte . MIN_VALUE , Byte . MAX_VALUE ) { @Override public long toLong ( BytesRef indexForm ) { return INT . toLong ( indexForm ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { INT . toIndexForm ( number , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return INT . toNumber ( indexForm ) ; } } , SHORT ( <int> , false , SortField . Type . INT , Short . MIN_VALUE , Short . MAX_VALUE ) { @Override public long toLong ( BytesRef indexForm ) { return INT . toLong ( indexForm ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { INT . toIndexForm ( number , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return INT . toNumber ( indexForm ) ; } } , INT ( <int> , false , SortField . Type . INT , Integer . MIN_VALUE , Integer . MAX_VALUE ) { @Override public long toLong ( BytesRef indexForm ) { return NumericUtils . prefixCodedToInt ( indexForm ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { NumericUtils . intToPrefixCodedBytes ( number . intValue ( ) , <int> , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return NumericUtils . prefixCodedToInt ( indexForm ) ; } } , LONG ( <int> , false , SortField . Type . LONG , Long . MIN_VALUE , Long . MAX_VALUE ) { @Override public long toLong ( BytesRef indexForm ) { return NumericUtils . prefixCodedToLong ( indexForm ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { NumericUtils . longToPrefixCodedBytes ( number . longValue ( ) , <int> , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return NumericUtils . prefixCodedToLong ( indexForm ) ; } } , FLOAT ( <int> , true , SortField . Type . FLOAT , Float . NEGATIVE_INFINITY , Float . POSITIVE_INFINITY ) { @Override public double toDouble ( BytesRef indexForm ) { return NumericUtils . sortableIntToFloat ( NumericUtils . prefixCodedToInt ( indexForm ) ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { NumericUtils . intToPrefixCodedBytes ( NumericUtils . floatToSortableInt ( number . floatValue ( ) ) , <int> , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return NumericUtils . sortableIntToFloat ( NumericUtils . prefixCodedToInt ( indexForm ) ) ; } } , DOUBLE ( <int> , true , SortField . Type . DOUBLE , Double . NEGATIVE_INFINITY , Double . POSITIVE_INFINITY ) { @Override public double toDouble ( BytesRef indexForm ) { return NumericUtils . sortableLongToDouble ( NumericUtils . prefixCodedToLong ( indexForm ) ) ; } @Override public void toIndexForm ( Number number , BytesRefBuilder bytes ) { NumericUtils . longToPrefixCodedBytes ( NumericUtils . doubleToSortableLong ( number . doubleValue ( ) ) , <int> , bytes ) ; } @Override public Number toNumber ( BytesRef indexForm ) { return NumericUtils . sortableLongToDouble ( NumericUtils . prefixCodedToLong ( indexForm ) ) ; } } ; private final int requiredBits ; private final boolean floatingPoint ; private final SortField . Type type ; private final Number minValue , maxValue ; private NumericType ( int requiredBits , boolean floatingPoint , SortField . Type type , Number minValue , Number maxValue ) { this . requiredBits = requiredBits ; this . floatingPoint = floatingPoint ; this . type = type ; this . minValue = minValue ; this . maxValue = maxValue ; } public final SortField . Type sortFieldType ( ) { return type ; } public final Number minValue ( ) { return minValue ; } public final Number maxValue ( ) { return maxValue ; } public final boolean isFloatingPoint ( ) { return floatingPoint ; } public final int requiredBits ( ) { return requiredBits ; } public abstract void toIndexForm ( Number number , BytesRefBuilder bytes ) ; public long toLong ( BytesRef indexForm ) { return ( long ) toDouble ( indexForm ) ; } public double toDouble ( BytesRef indexForm ) { return ( double ) toLong ( indexForm ) ; } public abstract Number toNumber ( BytesRef indexForm ) ; public final TermsEnum wrapTermsEnum ( TermsEnum termsEnum ) { if ( requiredBits ( ) = = <int> ) { return termsEnum ; } else if ( requiredBits ( ) > <int> ) { return OrdinalsBuilder . wrapNumeric64Bit ( termsEnum ) ; } else { return OrdinalsBuilder . wrapNumeric32Bit ( termsEnum ) ; } } } NumericType getNumericType ( ) ; } 
