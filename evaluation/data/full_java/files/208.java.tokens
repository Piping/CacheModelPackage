package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . utils . btree . BTreeSet ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; final class PrimaryKeyRestrictionSet extends AbstractPrimaryKeyRestrictions { private final RestrictionSet restrictions ; private boolean eq ; private boolean in ; private boolean slice ; private boolean contains ; private boolean isPartitionKey ; public PrimaryKeyRestrictionSet ( ClusteringComparator comparator , boolean isPartitionKey ) { super ( comparator ) ; this . restrictions = new RestrictionSet ( ) ; this . eq = true ; this . isPartitionKey = isPartitionKey ; } private PrimaryKeyRestrictionSet ( PrimaryKeyRestrictionSet primaryKeyRestrictions , Restriction restriction ) throws InvalidRequestException { super ( primaryKeyRestrictions . comparator ) ; this . restrictions = primaryKeyRestrictions . restrictions . addRestriction ( restriction ) ; this . isPartitionKey = primaryKeyRestrictions . isPartitionKey ; if ( ! primaryKeyRestrictions . isEmpty ( ) ) { ColumnDefinition lastRestrictionStart = primaryKeyRestrictions . restrictions . lastRestriction ( ) . getFirstColumn ( ) ; ColumnDefinition newRestrictionStart = restriction . getFirstColumn ( ) ; checkFalse ( primaryKeyRestrictions . isSlice ( ) & & newRestrictionStart . position ( ) > lastRestrictionStart . position ( ) , <str> , newRestrictionStart . name , lastRestrictionStart . name ) ; if ( newRestrictionStart . position ( ) < lastRestrictionStart . position ( ) & & restriction . isSlice ( ) ) throw invalidRequest ( <str> , restrictions . nextColumn ( newRestrictionStart ) . name , newRestrictionStart . name ) ; } if ( restriction . isSlice ( ) | | primaryKeyRestrictions . isSlice ( ) ) this . slice = true ; else if ( restriction . isContains ( ) | | primaryKeyRestrictions . isContains ( ) ) this . contains = true ; else if ( restriction . isIN ( ) | | primaryKeyRestrictions . isIN ( ) ) this . in = true ; else this . eq = true ; } private List < ByteBuffer > toByteBuffers ( SortedSet < ? extends ClusteringPrefix > clusterings ) { List < ByteBuffer > l = new ArrayList < > ( clusterings . size ( ) ) ; for ( ClusteringPrefix clustering : clusterings ) l . add ( CFMetaData . serializePartitionKey ( clustering ) ) ; return l ; } @Override public boolean isSlice ( ) { return slice ; } @Override public boolean isEQ ( ) { return eq ; } @Override public boolean isIN ( ) { return in ; } @Override public boolean isOnToken ( ) { return false ; } @Override public boolean isContains ( ) { return contains ; } @Override public boolean isMultiColumn ( ) { return false ; } @Override public Iterable < Function > getFunctions ( ) { return restrictions . getFunctions ( ) ; } @Override public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException { if ( restriction . isOnToken ( ) ) { if ( isEmpty ( ) ) return ( PrimaryKeyRestrictions ) restriction ; return new TokenFilter ( this , ( TokenRestriction ) restriction ) ; } return new PrimaryKeyRestrictionSet ( this , restriction ) ; } private boolean hasIN ( ) { if ( isIN ( ) ) return true ; for ( Restriction restriction : restrictions ) { if ( restriction . isIN ( ) ) return true ; } return false ; } @Override public NavigableSet < Clustering > valuesAsClustering ( QueryOptions options ) throws InvalidRequestException { return appendTo ( MultiCBuilder . create ( comparator , hasIN ( ) ) , options ) . build ( ) ; } @Override public MultiCBuilder appendTo ( MultiCBuilder builder , QueryOptions options ) { for ( Restriction r : restrictions ) { r . appendTo ( builder , options ) ; if ( builder . hasMissingElements ( ) ) break ; } return builder ; } @Override public MultiCBuilder appendBoundTo ( MultiCBuilder builder , Bound bound , QueryOptions options ) { throw new UnsupportedOperationException ( ) ; } @Override public NavigableSet < Slice . Bound > boundsAsClustering ( Bound bound , QueryOptions options ) throws InvalidRequestException { MultiCBuilder builder = MultiCBuilder . create ( comparator , hasIN ( ) ) ; int keyPosition = <int> ; for ( Restriction r : restrictions ) { ColumnDefinition def = r . getFirstColumn ( ) ; Bound b = ! def . isReversedType ( ) ? bound : bound . reverse ( ) ; if ( keyPosition ! = def . position ( ) | | r . isContains ( ) ) break ; if ( r . isSlice ( ) ) { if ( ! r . hasBound ( b ) ) { return builder . buildBound ( bound . isStart ( ) , true ) ; } r . appendBoundTo ( builder , b , options ) ; return builder . buildBound ( bound . isStart ( ) , r . isInclusive ( b ) ) ; } r . appendBoundTo ( builder , b , options ) ; if ( builder . hasMissingElements ( ) ) return BTreeSet . empty ( comparator ) ; keyPosition = r . getLastColumn ( ) . position ( ) + <int> ; } return builder . buildBound ( bound . isStart ( ) , true ) ; } @Override public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException { if ( ! isPartitionKey ) throw new UnsupportedOperationException ( ) ; return toByteBuffers ( valuesAsClustering ( options ) ) ; } @Override public List < ByteBuffer > bounds ( Bound b , QueryOptions options ) throws InvalidRequestException { if ( ! isPartitionKey ) throw new UnsupportedOperationException ( ) ; return toByteBuffers ( boundsAsClustering ( b , options ) ) ; } @Override public boolean hasBound ( Bound b ) { if ( isEmpty ( ) ) return false ; return restrictions . lastRestriction ( ) . hasBound ( b ) ; } @Override public boolean isInclusive ( Bound b ) { if ( isEmpty ( ) ) return false ; return restrictions . lastRestriction ( ) . isInclusive ( b ) ; } @Override public boolean hasSupportingIndex ( SecondaryIndexManager indexManager ) { return restrictions . hasSupportingIndex ( indexManager ) ; } @Override public void addRowFilterTo ( RowFilter filter , SecondaryIndexManager indexManager , QueryOptions options ) throws InvalidRequestException { int position = <int> ; for ( Restriction restriction : restrictions ) { ColumnDefinition columnDef = restriction . getFirstColumn ( ) ; if ( ! isPartitionKey & & ! restriction . isContains ( ) & & position = = columnDef . position ( ) ) { position = restriction . getLastColumn ( ) . position ( ) + <int> ; if ( ! restriction . hasSupportingIndex ( indexManager ) ) continue ; } restriction . addRowFilterTo ( filter , indexManager , options ) ; } } @Override public Collection < ColumnDefinition > getColumnDefs ( ) { return restrictions . getColumnDefs ( ) ; } @Override public ColumnDefinition getFirstColumn ( ) { return restrictions . firstColumn ( ) ; } @Override public ColumnDefinition getLastColumn ( ) { return restrictions . lastColumn ( ) ; } } 
