package io . netty . channel . nio ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelOption ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import org . junit . Test ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . InputStream ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketAddress ; import java . nio . channels . ClosedChannelException ; import java . util . Queue ; import java . util . concurrent . LinkedBlockingQueue ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class NioSocketChannelTest { @Test public void testFlushCloseReentrance ( ) throws Exception { NioEventLoopGroup group = new NioEventLoopGroup ( <int> ) ; try { final Queue < ChannelFuture > futures = new LinkedBlockingQueue < ChannelFuture > ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( NioServerSocketChannel . class ) ; sb . childOption ( ChannelOption . SO_SNDBUF , <int> ) ; sb . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { futures . add ( ctx . write ( ctx . alloc ( ) . buffer ( ) . writeZero ( <int> ) ) . addListener ( ChannelFutureListener . CLOSE ) ) ; futures . add ( ctx . write ( ctx . alloc ( ) . buffer ( ) . writeZero ( <int> ) ) ) ; ctx . flush ( ) ; futures . add ( ctx . write ( ctx . alloc ( ) . buffer ( ) . writeZero ( <int> ) ) ) ; ctx . flush ( ) ; } } ) ; SocketAddress address = sb . bind ( <int> ) . sync ( ) . channel ( ) . localAddress ( ) ; Socket s = new Socket ( NetUtil . LOCALHOST , ( ( InetSocketAddress ) address ) . getPort ( ) ) ; InputStream in = s . getInputStream ( ) ; byte [ ] buf = new byte [ <int> ] ; for ( ; ; ) { if ( in . read ( buf ) = = - <int> ) { break ; } Thread . sleep ( <int> ) ; } s . close ( ) ; assertThat ( futures . size ( ) , is ( <int> ) ) ; ChannelFuture f1 = futures . poll ( ) ; ChannelFuture f2 = futures . poll ( ) ; ChannelFuture f3 = futures . poll ( ) ; assertThat ( f1 . isSuccess ( ) , is ( true ) ) ; assertThat ( f2 . isDone ( ) , is ( true ) ) ; assertThat ( f2 . isSuccess ( ) , is ( false ) ) ; assertThat ( f2 . cause ( ) , is ( instanceOf ( ClosedChannelException . class ) ) ) ; assertThat ( f3 . isDone ( ) , is ( true ) ) ; assertThat ( f3 . isSuccess ( ) , is ( false ) ) ; assertThat ( f3 . cause ( ) , is ( instanceOf ( ClosedChannelException . class ) ) ) ; } finally { group . shutdownGracefully ( ) . sync ( ) ; } } @Test public void testFlushAfterGatheredFlush ( ) throws Exception { NioEventLoopGroup group = new NioEventLoopGroup ( <int> ) ; try { ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( NioServerSocketChannel . class ) ; sb . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { ctx . write ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; ChannelFuture f = ctx . write ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; f . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { ctx . writeAndFlush ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; } } ) ; ctx . flush ( ) ; } } ) ; SocketAddress address = sb . bind ( <int> ) . sync ( ) . channel ( ) . localAddress ( ) ; Socket s = new Socket ( NetUtil . LOCALHOST , ( ( InetSocketAddress ) address ) . getPort ( ) ) ; DataInput in = new DataInputStream ( s . getInputStream ( ) ) ; byte [ ] buf = new byte [ <int> ] ; in . readFully ( buf ) ; assertThat ( new String ( buf , CharsetUtil . US_ASCII ) , is ( <str> ) ) ; s . close ( ) ; } finally { group . shutdownGracefully ( ) . sync ( ) ; } } } 
