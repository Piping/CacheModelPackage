package io . netty . handler . proxy ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . handler . codec . base64 . Base64 ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpClientCodec ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; public final class HttpProxyHandler extends ProxyHandler { private static final String PROTOCOL = <str> ; private static final String AUTH_BASIC = <str> ; private final HttpClientCodec codec = new HttpClientCodec ( ) ; private final String username ; private final String password ; private final CharSequence authorization ; private HttpResponseStatus status ; public HttpProxyHandler ( SocketAddress proxyAddress ) { super ( proxyAddress ) ; username = null ; password = null ; authorization = null ; } public HttpProxyHandler ( SocketAddress proxyAddress , String username , String password ) { super ( proxyAddress ) ; if ( username = = null ) { throw new NullPointerException ( <str> ) ; } if ( password = = null ) { throw new NullPointerException ( <str> ) ; } this . username = username ; this . password = password ; ByteBuf authz = Unpooled . copiedBuffer ( username + <str> + password , CharsetUtil . UTF_8 ) ; ByteBuf authzBase64 = Base64 . encode ( authz , false ) ; authorization = new AsciiString ( <str> + authzBase64 . toString ( CharsetUtil . US_ASCII ) ) ; authz . release ( ) ; authzBase64 . release ( ) ; } @Override public String protocol ( ) { return PROTOCOL ; } @Override public String authScheme ( ) { return authorization ! = null ? AUTH_BASIC : AUTH_NONE ; } public String username ( ) { return username ; } public String password ( ) { return password ; } @Override protected void addCodec ( ChannelHandlerContext ctx ) throws Exception { ChannelPipeline p = ctx . pipeline ( ) ; String name = ctx . name ( ) ; p . addBefore ( name , null , codec ) ; } @Override protected void removeEncoder ( ChannelHandlerContext ctx ) throws Exception { ctx . pipeline ( ) . remove ( codec . encoder ( ) ) ; } @Override protected void removeDecoder ( ChannelHandlerContext ctx ) throws Exception { ctx . pipeline ( ) . remove ( codec . decoder ( ) ) ; } @Override protected Object newInitialMessage ( ChannelHandlerContext ctx ) throws Exception { InetSocketAddress raddr = destinationAddress ( ) ; String rhost ; if ( raddr . isUnresolved ( ) ) { rhost = raddr . getHostString ( ) ; } else { rhost = raddr . getAddress ( ) . getHostAddress ( ) ; } FullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_0 , HttpMethod . CONNECT , rhost + <str> + raddr . getPort ( ) , Unpooled . EMPTY_BUFFER , false ) ; SocketAddress proxyAddress = proxyAddress ( ) ; if ( proxyAddress instanceof InetSocketAddress ) { InetSocketAddress hostAddr = ( InetSocketAddress ) proxyAddress ; req . headers ( ) . set ( HttpHeaderNames . HOST , hostAddr . getHostString ( ) + <str> + hostAddr . getPort ( ) ) ; } if ( authorization ! = null ) { req . headers ( ) . set ( HttpHeaderNames . PROXY_AUTHORIZATION , authorization ) ; } return req ; } @Override protected boolean handleResponse ( ChannelHandlerContext ctx , Object response ) throws Exception { if ( response instanceof HttpResponse ) { if ( status ! = null ) { throw new ProxyConnectException ( exceptionMessage ( <str> ) ) ; } status = ( ( HttpResponse ) response ) . status ( ) ; } boolean finished = response instanceof LastHttpContent ; if ( finished ) { if ( status = = null ) { throw new ProxyConnectException ( exceptionMessage ( <str> ) ) ; } if ( status . code ( ) ! = <int> ) { throw new ProxyConnectException ( exceptionMessage ( <str> + status ) ) ; } } return finished ; } } 
