package io . netty . handler . ssl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . base64 . Base64 ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . apache . tomcat . jni . CertificateVerifier ; import org . apache . tomcat . jni . Pool ; import org . apache . tomcat . jni . SSL ; import org . apache . tomcat . jni . SSLContext ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLException ; import javax . net . ssl . SSLHandshakeException ; import javax . net . ssl . TrustManager ; import javax . net . ssl . X509ExtendedTrustManager ; import javax . net . ssl . X509TrustManager ; import java . security . PrivateKey ; import java . security . cert . Certificate ; import java . security . cert . X509Certificate ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static io . netty . handler . ssl . ApplicationProtocolConfig . SelectorFailureBehavior ; import static io . netty . handler . ssl . ApplicationProtocolConfig . SelectedListenerFailureBehavior ; public abstract class OpenSslContext extends SslContext { private static final byte [ ] BEGIN_CERT = <str> . getBytes ( CharsetUtil . US_ASCII ) ; private static final byte [ ] END_CERT = <str> . getBytes ( CharsetUtil . US_ASCII ) ; private static final byte [ ] BEGIN_PRIVATE_KEY = <str> . getBytes ( CharsetUtil . US_ASCII ) ; private static final byte [ ] END_PRIVATE_KEY = <str> . getBytes ( CharsetUtil . US_ASCII ) ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OpenSslContext . class ) ; private static final boolean JDK_REJECT_CLIENT_INITIATED_RENEGOTIATION = SystemPropertyUtil . getBoolean ( <str> , false ) ; private static final List < String > DEFAULT_CIPHERS ; protected static final int VERIFY_DEPTH = <int> ; protected volatile long ctx ; long aprPool ; @SuppressWarnings ( { <str> , <str> } ) private volatile int aprPoolDestroyed ; private volatile boolean rejectRemoteInitiatedRenegotiation ; private final List < String > unmodifiableCiphers ; private final long sessionCacheSize ; private final long sessionTimeout ; private final OpenSslEngineMap engineMap = new DefaultOpenSslEngineMap ( ) ; private final OpenSslApplicationProtocolNegotiator apn ; private final int mode ; private final Certificate [ ] keyCertChain ; private final ClientAuth clientAuth ; static final OpenSslApplicationProtocolNegotiator NONE_PROTOCOL_NEGOTIATOR = new OpenSslApplicationProtocolNegotiator ( ) { @Override public ApplicationProtocolConfig . Protocol protocol ( ) { return ApplicationProtocolConfig . Protocol . NONE ; } @Override public List < String > protocols ( ) { return Collections . emptyList ( ) ; } @Override public SelectorFailureBehavior selectorFailureBehavior ( ) { return SelectorFailureBehavior . CHOOSE_MY_LAST_PROTOCOL ; } @Override public SelectedListenerFailureBehavior selectedListenerFailureBehavior ( ) { return SelectedListenerFailureBehavior . ACCEPT ; } } ; static { List < String > ciphers = new ArrayList < String > ( ) ; Collections . addAll ( ciphers , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; DEFAULT_CIPHERS = Collections . unmodifiableList ( ciphers ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + ciphers ) ; } } OpenSslContext ( Iterable < String > ciphers , CipherSuiteFilter cipherFilter , ApplicationProtocolConfig apnCfg , long sessionCacheSize , long sessionTimeout , int mode , Certificate [ ] keyCertChain , ClientAuth clientAuth ) throws SSLException { this ( ciphers , cipherFilter , toNegotiator ( apnCfg ) , sessionCacheSize , sessionTimeout , mode , keyCertChain , clientAuth ) ; } OpenSslContext ( Iterable < String > ciphers , CipherSuiteFilter cipherFilter , OpenSslApplicationProtocolNegotiator apn , long sessionCacheSize , long sessionTimeout , int mode , Certificate [ ] keyCertChain , ClientAuth clientAuth ) throws SSLException { OpenSsl . ensureAvailability ( ) ; if ( mode ! = SSL . SSL_MODE_SERVER & & mode ! = SSL . SSL_MODE_CLIENT ) { throw new IllegalArgumentException ( <str> ) ; } this . mode = mode ; this . clientAuth = isServer ( ) ? checkNotNull ( clientAuth , <str> ) : ClientAuth . NONE ; if ( mode = = SSL . SSL_MODE_SERVER ) { rejectRemoteInitiatedRenegotiation = JDK_REJECT_CLIENT_INITIATED_RENEGOTIATION ; } this . keyCertChain = keyCertChain = = null ? null : keyCertChain . clone ( ) ; final List < String > convertedCiphers ; if ( ciphers = = null ) { convertedCiphers = null ; } else { convertedCiphers = new ArrayList < String > ( ) ; for ( String c : ciphers ) { if ( c = = null ) { break ; } String converted = CipherSuiteConverter . toOpenSsl ( c ) ; if ( converted ! = null ) { c = converted ; } convertedCiphers . add ( c ) ; } } unmodifiableCiphers = Arrays . asList ( checkNotNull ( cipherFilter , <str> ) . filterCipherSuites ( convertedCiphers , DEFAULT_CIPHERS , OpenSsl . availableCipherSuites ( ) ) ) ; this . apn = checkNotNull ( apn , <str> ) ; aprPool = Pool . create ( <int> ) ; boolean success = false ; try { synchronized ( OpenSslContext . class ) { try { ctx = SSLContext . make ( aprPool , SSL . SSL_PROTOCOL_ALL , mode ) ; } catch ( Exception e ) { throw new SSLException ( <str> , e ) ; } SSLContext . setOptions ( ctx , SSL . SSL_OP_ALL ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_NO_SSLv2 ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_NO_SSLv3 ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_CIPHER_SERVER_PREFERENCE ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_SINGLE_ECDH_USE ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_SINGLE_DH_USE ) ; SSLContext . setOptions ( ctx , SSL . SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION ) ; try { SSLContext . setCipherSuite ( ctx , CipherSuiteConverter . toOpenSsl ( unmodifiableCiphers ) ) ; } catch ( SSLException e ) { throw e ; } catch ( Exception e ) { throw new SSLException ( <str> + unmodifiableCiphers , e ) ; } List < String > nextProtoList = apn . protocols ( ) ; if ( ! nextProtoList . isEmpty ( ) ) { String [ ] protocols = nextProtoList . toArray ( new String [ nextProtoList . size ( ) ] ) ; int selectorBehavior = opensslSelectorFailureBehavior ( apn . selectorFailureBehavior ( ) ) ; switch ( apn . protocol ( ) ) { case NPN : SSLContext . setNpnProtos ( ctx , protocols , selectorBehavior ) ; break ; case ALPN : SSLContext . setAlpnProtos ( ctx , protocols , selectorBehavior ) ; break ; case NPN_AND_ALPN : SSLContext . setNpnProtos ( ctx , protocols , selectorBehavior ) ; SSLContext . setAlpnProtos ( ctx , protocols , selectorBehavior ) ; break ; default : throw new Error ( ) ; } } if ( sessionCacheSize > <int> ) { this . sessionCacheSize = sessionCacheSize ; SSLContext . setSessionCacheSize ( ctx , sessionCacheSize ) ; } else { this . sessionCacheSize = sessionCacheSize = SSLContext . setSessionCacheSize ( ctx , <int> ) ; SSLContext . setSessionCacheSize ( ctx , sessionCacheSize ) ; } if ( sessionTimeout > <int> ) { this . sessionTimeout = sessionTimeout ; SSLContext . setSessionCacheTimeout ( ctx , sessionTimeout ) ; } else { this . sessionTimeout = sessionTimeout = SSLContext . setSessionCacheTimeout ( ctx , <int> ) ; SSLContext . setSessionCacheTimeout ( ctx , sessionTimeout ) ; } } success = true ; } finally { if ( ! success ) { destroy ( ) ; } } } private static int opensslSelectorFailureBehavior ( SelectorFailureBehavior behavior ) { switch ( behavior ) { case NO_ADVERTISE : return SSL . SSL_SELECTOR_FAILURE_NO_ADVERTISE ; case CHOOSE_MY_LAST_PROTOCOL : return SSL . SSL_SELECTOR_FAILURE_CHOOSE_MY_LAST_PROTOCOL ; default : throw new Error ( ) ; } } @Override public final List < String > cipherSuites ( ) { return unmodifiableCiphers ; } @Override public final long sessionCacheSize ( ) { return sessionCacheSize ; } @Override public final long sessionTimeout ( ) { return sessionTimeout ; } @Override public ApplicationProtocolNegotiator applicationProtocolNegotiator ( ) { return apn ; } @Override public final boolean isClient ( ) { return mode = = SSL . SSL_MODE_CLIENT ; } @Override public final SSLEngine newEngine ( ByteBufAllocator alloc , String peerHost , int peerPort ) { final OpenSslEngine engine = new OpenSslEngine ( ctx , alloc , isClient ( ) , sessionContext ( ) , apn , engineMap , rejectRemoteInitiatedRenegotiation , peerHost , peerPort , keyCertChain , clientAuth ) ; engineMap . add ( engine ) ; return engine ; } @Override public final SSLEngine newEngine ( ByteBufAllocator alloc ) { return newEngine ( alloc , null , - <int> ) ; } @Deprecated public final long context ( ) { return ctx ; } @Deprecated public final OpenSslSessionStats stats ( ) { return sessionContext ( ) . stats ( ) ; } public void setRejectRemoteInitiatedRenegotiation ( boolean rejectRemoteInitiatedRenegotiation ) { this . rejectRemoteInitiatedRenegotiation = rejectRemoteInitiatedRenegotiation ; } @Override @SuppressWarnings ( <str> ) protected final void finalize ( ) throws Throwable { super . finalize ( ) ; destroy ( ) ; } @Deprecated public final void setTicketKeys ( byte [ ] keys ) { sessionContext ( ) . setTicketKeys ( keys ) ; } @Override public abstract OpenSslSessionContext sessionContext ( ) ; public final long sslCtxPointer ( ) { return ctx ; } protected final void destroy ( ) { synchronized ( OpenSslContext . class ) { if ( ctx ! = <int> ) { SSLContext . free ( ctx ) ; ctx = <int> ; } if ( aprPool ! = <int> ) { Pool . destroy ( aprPool ) ; aprPool = <int> ; } } } protected static X509Certificate [ ] certificates ( byte [ ] [ ] chain ) { X509Certificate [ ] peerCerts = new X509Certificate [ chain . length ] ; for ( int i = <int> ; i < peerCerts . length ; i + + ) { peerCerts [ i ] = new OpenSslX509Certificate ( chain [ i ] ) ; } return peerCerts ; } protected static X509TrustManager chooseTrustManager ( TrustManager [ ] managers ) { for ( TrustManager m : managers ) { if ( m instanceof X509TrustManager ) { return ( X509TrustManager ) m ; } } throw new IllegalStateException ( <str> ) ; } static OpenSslApplicationProtocolNegotiator toNegotiator ( ApplicationProtocolConfig config ) { if ( config = = null ) { return NONE_PROTOCOL_NEGOTIATOR ; } switch ( config . protocol ( ) ) { case NONE : return NONE_PROTOCOL_NEGOTIATOR ; case ALPN : case NPN : case NPN_AND_ALPN : switch ( config . selectedListenerFailureBehavior ( ) ) { case CHOOSE_MY_LAST_PROTOCOL : case ACCEPT : switch ( config . selectorFailureBehavior ( ) ) { case CHOOSE_MY_LAST_PROTOCOL : case NO_ADVERTISE : return new OpenSslDefaultApplicationProtocolNegotiator ( config ) ; default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectorFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectedListenerFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } default : throw new Error ( ) ; } } static boolean useExtendedTrustManager ( X509TrustManager trustManager ) { return PlatformDependent . javaVersion ( ) > = <int> & & trustManager instanceof X509ExtendedTrustManager ; } abstract class AbstractCertificateVerifier implements CertificateVerifier { @Override public final boolean verify ( long ssl , byte [ ] [ ] chain , String auth ) { X509Certificate [ ] peerCerts = certificates ( chain ) ; final OpenSslEngine engine = engineMap . remove ( ssl ) ; try { verify ( engine , peerCerts , auth ) ; return true ; } catch ( Throwable cause ) { logger . debug ( <str> , cause ) ; SSLHandshakeException e = new SSLHandshakeException ( <str> ) ; e . initCause ( cause ) ; engine . handshakeException = e ; } return false ; } abstract void verify ( OpenSslEngine engine , X509Certificate [ ] peerCerts , String auth ) throws Exception ; } private static final class DefaultOpenSslEngineMap implements OpenSslEngineMap { private final Map < Long , OpenSslEngine > engines = PlatformDependent . newConcurrentHashMap ( ) ; @Override public OpenSslEngine remove ( long ssl ) { return engines . remove ( ssl ) ; } @Override public void add ( OpenSslEngine engine ) { engines . put ( engine . sslPointer ( ) , engine ) ; } } static long toBIO ( PrivateKey key ) throws Exception { if ( key = = null ) { return <int> ; } ByteBuf buffer = Unpooled . directBuffer ( ) ; try { buffer . writeBytes ( BEGIN_PRIVATE_KEY ) ; buffer . writeBytes ( Base64 . encode ( Unpooled . wrappedBuffer ( key . getEncoded ( ) ) , true ) ) ; buffer . writeBytes ( END_PRIVATE_KEY ) ; return newBIO ( buffer ) ; } finally { buffer . release ( ) ; } } static long toBIO ( X509Certificate [ ] certChain ) throws Exception { if ( certChain = = null ) { return <int> ; } ByteBuf buffer = Unpooled . directBuffer ( ) ; try { for ( X509Certificate cert : certChain ) { buffer . writeBytes ( BEGIN_CERT ) ; buffer . writeBytes ( Base64 . encode ( Unpooled . wrappedBuffer ( cert . getEncoded ( ) ) , true ) ) ; buffer . writeBytes ( END_CERT ) ; } return newBIO ( buffer ) ; } finally { buffer . release ( ) ; } } private static long newBIO ( ByteBuf buffer ) throws Exception { long bio = SSL . newMemBIO ( ) ; int readable = buffer . readableBytes ( ) ; if ( SSL . writeToBIO ( bio , buffer . memoryAddress ( ) , readable ) ! = readable ) { SSL . freeBIO ( bio ) ; throw new IllegalStateException ( <str> ) ; } return bio ; } } 
