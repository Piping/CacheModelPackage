package org . apache . cassandra . service ; import java . net . InetAddress ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . TimeUnit ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . config . ReadRepairDecision ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . ConsistencyLevel ; import org . apache . cassandra . db . ReadCommand ; import org . apache . cassandra . db . SinglePartitionReadCommand ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . exceptions . ReadFailureException ; import org . apache . cassandra . exceptions . ReadTimeoutException ; import org . apache . cassandra . exceptions . UnavailableException ; import org . apache . cassandra . metrics . ReadRepairMetrics ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . SpeculativeRetryParam ; import org . apache . cassandra . service . StorageProxy . LocalReadRunnable ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; public abstract class AbstractReadExecutor { private static final Logger logger = LoggerFactory . getLogger ( AbstractReadExecutor . class ) ; protected final ReadCommand command ; protected final List < InetAddress > targetReplicas ; protected final ReadCallback handler ; protected final TraceState traceState ; AbstractReadExecutor ( Keyspace keyspace , ReadCommand command , ConsistencyLevel consistencyLevel , List < InetAddress > targetReplicas ) { this . command = command ; this . targetReplicas = targetReplicas ; this . handler = new ReadCallback ( new DigestResolver ( keyspace , command , consistencyLevel , targetReplicas . size ( ) ) , consistencyLevel , command , targetReplicas ) ; this . traceState = Tracing . instance . get ( ) ; int digestVersion = MessagingService . current_version ; for ( InetAddress replica : targetReplicas ) digestVersion = Math . min ( digestVersion , MessagingService . instance ( ) . getVersion ( replica ) ) ; command . setDigestVersion ( digestVersion ) ; } protected void makeDataRequests ( Iterable < InetAddress > endpoints ) { makeRequests ( command , endpoints ) ; } protected void makeDigestRequests ( Iterable < InetAddress > endpoints ) { makeRequests ( command . copy ( ) . setIsDigestQuery ( true ) , endpoints ) ; } private void makeRequests ( ReadCommand readCommand , Iterable < InetAddress > endpoints ) { boolean hasLocalEndpoint = false ; for ( InetAddress endpoint : endpoints ) { if ( StorageProxy . canDoLocalRequest ( endpoint ) ) { hasLocalEndpoint = true ; continue ; } if ( traceState ! = null ) traceState . trace ( <str> , readCommand . isDigestQuery ( ) ? <str> : <str> , endpoint ) ; logger . trace ( <str> , readCommand . isDigestQuery ( ) ? <str> : <str> , endpoint ) ; MessageOut < ReadCommand > message = readCommand . createMessage ( MessagingService . instance ( ) . getVersion ( endpoint ) ) ; MessagingService . instance ( ) . sendRRWithFailure ( message , endpoint , handler ) ; } if ( hasLocalEndpoint ) { logger . trace ( <str> , readCommand . isDigestQuery ( ) ? <str> : <str> ) ; StageManager . getStage ( Stage . READ ) . maybeExecuteImmediately ( new LocalReadRunnable ( command , handler ) ) ; } } public abstract void maybeTryAdditionalReplicas ( ) ; public abstract Collection < InetAddress > getContactedReplicas ( ) ; public abstract void executeAsync ( ) ; public PartitionIterator get ( ) throws ReadFailureException , ReadTimeoutException , DigestMismatchException { return handler . get ( ) ; } public static AbstractReadExecutor getReadExecutor ( SinglePartitionReadCommand command , ConsistencyLevel consistencyLevel ) throws UnavailableException { Keyspace keyspace = Keyspace . open ( command . metadata ( ) . ksName ) ; List < InetAddress > allReplicas = StorageProxy . getLiveSortedEndpoints ( keyspace , command . partitionKey ( ) ) ; ReadRepairDecision repairDecision = command . metadata ( ) . newReadRepairDecision ( ) ; List < InetAddress > targetReplicas = consistencyLevel . filterForQuery ( keyspace , allReplicas , repairDecision ) ; consistencyLevel . assureSufficientLiveNodes ( keyspace , targetReplicas ) ; if ( repairDecision ! = ReadRepairDecision . NONE ) { Tracing . trace ( <str> , repairDecision ) ; ReadRepairMetrics . attempted . mark ( ) ; } ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( command . metadata ( ) . cfId ) ; SpeculativeRetryParam retry = cfs . metadata . params . speculativeRetry ; if ( retry . equals ( SpeculativeRetryParam . NONE ) | | consistencyLevel . blockFor ( keyspace ) = = allReplicas . size ( ) ) return new NeverSpeculatingReadExecutor ( keyspace , command , consistencyLevel , targetReplicas ) ; if ( targetReplicas . size ( ) = = allReplicas . size ( ) ) { return new AlwaysSpeculatingReadExecutor ( keyspace , cfs , command , consistencyLevel , targetReplicas ) ; } InetAddress extraReplica = allReplicas . get ( targetReplicas . size ( ) ) ; if ( repairDecision = = ReadRepairDecision . DC_LOCAL & & targetReplicas . contains ( extraReplica ) ) { for ( InetAddress address : allReplicas ) { if ( ! targetReplicas . contains ( address ) ) { extraReplica = address ; break ; } } } targetReplicas . add ( extraReplica ) ; if ( retry . equals ( SpeculativeRetryParam . ALWAYS ) ) return new AlwaysSpeculatingReadExecutor ( keyspace , cfs , command , consistencyLevel , targetReplicas ) ; else return new SpeculatingReadExecutor ( keyspace , cfs , command , consistencyLevel , targetReplicas ) ; } public static class NeverSpeculatingReadExecutor extends AbstractReadExecutor { public NeverSpeculatingReadExecutor ( Keyspace keyspace , ReadCommand command , ConsistencyLevel consistencyLevel , List < InetAddress > targetReplicas ) { super ( keyspace , command , consistencyLevel , targetReplicas ) ; } public void executeAsync ( ) { makeDataRequests ( targetReplicas . subList ( <int> , <int> ) ) ; if ( targetReplicas . size ( ) > <int> ) makeDigestRequests ( targetReplicas . subList ( <int> , targetReplicas . size ( ) ) ) ; } public void maybeTryAdditionalReplicas ( ) { } public Collection < InetAddress > getContactedReplicas ( ) { return targetReplicas ; } } private static class SpeculatingReadExecutor extends AbstractReadExecutor { private final ColumnFamilyStore cfs ; private volatile boolean speculated = false ; public SpeculatingReadExecutor ( Keyspace keyspace , ColumnFamilyStore cfs , ReadCommand command , ConsistencyLevel consistencyLevel , List < InetAddress > targetReplicas ) { super ( keyspace , command , consistencyLevel , targetReplicas ) ; this . cfs = cfs ; } public void executeAsync ( ) { List < InetAddress > initialReplicas = targetReplicas . subList ( <int> , targetReplicas . size ( ) - <int> ) ; if ( handler . blockfor < initialReplicas . size ( ) ) { makeDataRequests ( initialReplicas . subList ( <int> , <int> ) ) ; if ( initialReplicas . size ( ) > <int> ) makeDigestRequests ( initialReplicas . subList ( <int> , initialReplicas . size ( ) ) ) ; } else { makeDataRequests ( initialReplicas . subList ( <int> , <int> ) ) ; if ( initialReplicas . size ( ) > <int> ) makeDigestRequests ( initialReplicas . subList ( <int> , initialReplicas . size ( ) ) ) ; } } public void maybeTryAdditionalReplicas ( ) { if ( cfs . sampleLatencyNanos > TimeUnit . MILLISECONDS . toNanos ( command . getTimeout ( ) ) ) return ; if ( ! handler . await ( cfs . sampleLatencyNanos , TimeUnit . NANOSECONDS ) ) { ReadCommand retryCommand = command ; if ( handler . resolver . isDataPresent ( ) ) retryCommand = command . copy ( ) . setIsDigestQuery ( true ) ; InetAddress extraReplica = Iterables . getLast ( targetReplicas ) ; if ( traceState ! = null ) traceState . trace ( <str> , extraReplica ) ; logger . trace ( <str> , extraReplica ) ; int version = MessagingService . instance ( ) . getVersion ( extraReplica ) ; MessagingService . instance ( ) . sendRRWithFailure ( retryCommand . createMessage ( version ) , extraReplica , handler ) ; speculated = true ; cfs . metric . speculativeRetries . inc ( ) ; } } public Collection < InetAddress > getContactedReplicas ( ) { return speculated ? targetReplicas : targetReplicas . subList ( <int> , targetReplicas . size ( ) - <int> ) ; } } private static class AlwaysSpeculatingReadExecutor extends AbstractReadExecutor { private final ColumnFamilyStore cfs ; public AlwaysSpeculatingReadExecutor ( Keyspace keyspace , ColumnFamilyStore cfs , ReadCommand command , ConsistencyLevel consistencyLevel , List < InetAddress > targetReplicas ) { super ( keyspace , command , consistencyLevel , targetReplicas ) ; this . cfs = cfs ; } public void maybeTryAdditionalReplicas ( ) { } public Collection < InetAddress > getContactedReplicas ( ) { return targetReplicas ; } @Override public void executeAsync ( ) { makeDataRequests ( targetReplicas . subList ( <int> , targetReplicas . size ( ) > <int> ? <int> : <int> ) ) ; if ( targetReplicas . size ( ) > <int> ) makeDigestRequests ( targetReplicas . subList ( <int> , targetReplicas . size ( ) ) ) ; cfs . metric . speculativeRetries . inc ( ) ; } } } 
