package org . elasticsearch . common . geo . builders ; import com . spatial4j . core . exception . InvalidShapeException ; import com . spatial4j . core . shape . Shape ; import com . vividsolutions . jts . geom . Coordinate ; import com . vividsolutions . jts . geom . Geometry ; import com . vividsolutions . jts . geom . GeometryFactory ; import com . vividsolutions . jts . geom . LinearRing ; import com . vividsolutions . jts . geom . MultiPolygon ; import com . vividsolutions . jts . geom . Polygon ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . concurrent . atomic . AtomicBoolean ; public class PolygonBuilder extends ShapeBuilder { public static final GeoShapeType TYPE = GeoShapeType . POLYGON ; private LineStringBuilder shell ; private final ArrayList < LineStringBuilder > holes = new ArrayList < > ( ) ; public PolygonBuilder ( ) { this ( new ArrayList < Coordinate > ( ) , Orientation . RIGHT ) ; } public PolygonBuilder ( Orientation orientation ) { this ( new ArrayList < Coordinate > ( ) , orientation ) ; } public PolygonBuilder ( ArrayList < Coordinate > points , Orientation orientation ) { super ( orientation ) ; this . shell = new LineStringBuilder ( ) . points ( points ) ; } public PolygonBuilder point ( double longitude , double latitude ) { shell . point ( longitude , latitude ) ; return this ; } public PolygonBuilder point ( Coordinate coordinate ) { shell . point ( coordinate ) ; return this ; } public PolygonBuilder points ( Coordinate . . . coordinates ) { shell . points ( coordinates ) ; return this ; } public PolygonBuilder hole ( LineStringBuilder hole ) { holes . add ( hole ) ; return this ; } public PolygonBuilder close ( ) { shell . close ( ) ; return this ; } protected void validateHole ( LineStringBuilder shell , LineStringBuilder hole ) { HashSet < Coordinate > exterior = Sets . newHashSet ( shell . points ) ; HashSet < Coordinate > interior = Sets . newHashSet ( hole . points ) ; exterior . retainAll ( interior ) ; if ( exterior . size ( ) > = <int> ) { throw new InvalidShapeException ( <str> ) ; } } public Coordinate [ ] [ ] [ ] coordinates ( ) { int numEdges = shell . points . size ( ) - <int> ; for ( int i = <int> ; i < holes . size ( ) ; i + + ) { numEdges + = holes . get ( i ) . points . size ( ) - <int> ; validateHole ( shell , this . holes . get ( i ) ) ; } Edge [ ] edges = new Edge [ numEdges ] ; Edge [ ] holeComponents = new Edge [ holes . size ( ) ] ; final AtomicBoolean translated = new AtomicBoolean ( false ) ; int offset = createEdges ( <int> , orientation , shell , null , edges , <int> , translated ) ; for ( int i = <int> ; i < holes . size ( ) ; i + + ) { int length = createEdges ( i + <int> , orientation , shell , this . holes . get ( i ) , edges , offset , translated ) ; holeComponents [ i ] = edges [ offset ] ; offset + = length ; } int numHoles = holeComponents . length ; numHoles = merge ( edges , <int> , intersections ( + DATELINE , edges ) , holeComponents , numHoles ) ; numHoles = merge ( edges , <int> , intersections ( - DATELINE , edges ) , holeComponents , numHoles ) ; return compose ( edges , holeComponents , numHoles ) ; } @Override public Shape build ( ) { return jtsGeometry ( buildGeometry ( FACTORY , wrapdateline ) ) ; } protected XContentBuilder coordinatesArray ( XContentBuilder builder , Params params ) throws IOException { shell . coordinatesToXcontent ( builder , true ) ; for ( LineStringBuilder hole : holes ) { hole . coordinatesToXcontent ( builder , true ) ; } return builder ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( FIELD_TYPE , TYPE . shapeName ( ) ) ; builder . startArray ( FIELD_COORDINATES ) ; coordinatesArray ( builder , params ) ; builder . endArray ( ) ; builder . endObject ( ) ; return builder ; } public Geometry buildGeometry ( GeometryFactory factory , boolean fixDateline ) { if ( fixDateline ) { Coordinate [ ] [ ] [ ] polygons = coordinates ( ) ; return polygons . length = = <int> ? polygon ( factory , polygons [ <int> ] ) : multipolygon ( factory , polygons ) ; } else { return toPolygon ( factory ) ; } } public Polygon toPolygon ( ) { return toPolygon ( FACTORY ) ; } protected Polygon toPolygon ( GeometryFactory factory ) { final LinearRing shell = linearRing ( factory , this . shell . points ) ; final LinearRing [ ] holes = new LinearRing [ this . holes . size ( ) ] ; Iterator < LineStringBuilder > iterator = this . holes . iterator ( ) ; for ( int i = <int> ; iterator . hasNext ( ) ; i + + ) { holes [ i ] = linearRing ( factory , iterator . next ( ) . points ) ; } return factory . createPolygon ( shell , holes ) ; } protected static LinearRing linearRing ( GeometryFactory factory , ArrayList < Coordinate > coordinates ) { return factory . createLinearRing ( coordinates . toArray ( new Coordinate [ coordinates . size ( ) ] ) ) ; } @Override public GeoShapeType type ( ) { return TYPE ; } protected static Polygon polygon ( GeometryFactory factory , Coordinate [ ] [ ] polygon ) { LinearRing shell = factory . createLinearRing ( polygon [ <int> ] ) ; LinearRing [ ] holes ; if ( polygon . length > <int> ) { holes = new LinearRing [ polygon . length - <int> ] ; for ( int i = <int> ; i < holes . length ; i + + ) { holes [ i ] = factory . createLinearRing ( polygon [ i + <int> ] ) ; } } else { holes = null ; } return factory . createPolygon ( shell , holes ) ; } protected static MultiPolygon multipolygon ( GeometryFactory factory , Coordinate [ ] [ ] [ ] polygons ) { Polygon [ ] polygonSet = new Polygon [ polygons . length ] ; for ( int i = <int> ; i < polygonSet . length ; i + + ) { polygonSet [ i ] = polygon ( factory , polygons [ i ] ) ; } return factory . createMultiPolygon ( polygonSet ) ; } private static int component ( final Edge edge , final int id , final ArrayList < Edge > edges ) { Edge any = edge ; while ( any . coordinate . x = = + DATELINE | | any . coordinate . x = = - DATELINE ) { if ( ( any = any . next ) = = edge ) { break ; } } double shiftOffset = any . coordinate . x > DATELINE ? DATELINE : ( any . coordinate . x < - DATELINE ? - DATELINE : <int> ) ; if ( debugEnabled ( ) ) { LOGGER . debug ( <str> , shiftOffset ) ; } int length = <int> , connectedComponents = <int> ; int splitIndex = <int> ; Edge current = edge ; Edge prev = edge ; HashMap < Coordinate , Tuple < Edge , Edge > > visitedEdge = new HashMap < > ( ) ; do { current . coordinate = shift ( current . coordinate , shiftOffset ) ; current . component = id ; if ( edges ! = null ) { if ( visitedEdge . containsKey ( current . coordinate ) ) { if ( connectedComponents > <int> & & current . next ! = edge ) { throw new InvalidShapeException ( <str> ) ; } final int visitID = - id ; Edge firstAppearance = visitedEdge . get ( current . coordinate ) . v2 ( ) ; Edge temp = firstAppearance . next ; firstAppearance . next = current . next ; current . next = temp ; current . component = visitID ; do { prev . component = visitID ; prev = visitedEdge . get ( prev . coordinate ) . v1 ( ) ; + + splitIndex ; } while ( ! current . coordinate . equals ( prev . coordinate ) ) ; + + connectedComponents ; } else { visitedEdge . put ( current . coordinate , new Tuple < Edge , Edge > ( prev , current ) ) ; } edges . add ( current ) ; prev = current ; } length + + ; } while ( connectedComponents = = <int> & & ( current = current . next ) ! = edge ) ; return ( splitIndex ! = <int> ) ? length - splitIndex : length ; } private static Coordinate [ ] coordinates ( Edge component , Coordinate [ ] coordinates ) { for ( int i = <int> ; i < coordinates . length ; i + + ) { coordinates [ i ] = ( component = component . next ) . coordinate ; } return coordinates ; } private static Coordinate [ ] [ ] [ ] buildCoordinates ( ArrayList < ArrayList < Coordinate [ ] > > components ) { Coordinate [ ] [ ] [ ] result = new Coordinate [ components . size ( ) ] [ ] [ ] ; for ( int i = <int> ; i < result . length ; i + + ) { ArrayList < Coordinate [ ] > component = components . get ( i ) ; result [ i ] = component . toArray ( new Coordinate [ component . size ( ) ] [ ] ) ; } if ( debugEnabled ( ) ) { for ( int i = <int> ; i < result . length ; i + + ) { LOGGER . debug ( <str> , i ) ; for ( int j = <int> ; j < result [ i ] . length ; j + + ) { LOGGER . debug ( <str> + Arrays . toString ( result [ i ] [ j ] ) ) ; } } } return result ; } private static final Coordinate [ ] [ ] EMPTY = new Coordinate [ <int> ] [ ] ; private static Coordinate [ ] [ ] holes ( Edge [ ] holes , int numHoles ) { if ( numHoles = = <int> ) { return EMPTY ; } final Coordinate [ ] [ ] points = new Coordinate [ numHoles ] [ ] ; for ( int i = <int> ; i < numHoles ; i + + ) { int length = component ( holes [ i ] , - ( i + <int> ) , null ) ; points [ i ] = coordinates ( holes [ i ] , new Coordinate [ length + <int> ] ) ; } return points ; } private static Edge [ ] edges ( Edge [ ] edges , int numHoles , ArrayList < ArrayList < Coordinate [ ] > > components ) { ArrayList < Edge > mainEdges = new ArrayList < > ( edges . length ) ; for ( int i = <int> ; i < edges . length ; i + + ) { if ( edges [ i ] . component > = <int> ) { int length = component ( edges [ i ] , - ( components . size ( ) + numHoles + <int> ) , mainEdges ) ; ArrayList < Coordinate [ ] > component = new ArrayList < > ( ) ; component . add ( coordinates ( edges [ i ] , new Coordinate [ length + <int> ] ) ) ; components . add ( component ) ; } } return mainEdges . toArray ( new Edge [ mainEdges . size ( ) ] ) ; } private static Coordinate [ ] [ ] [ ] compose ( Edge [ ] edges , Edge [ ] holes , int numHoles ) { final ArrayList < ArrayList < Coordinate [ ] > > components = new ArrayList < > ( ) ; assign ( holes , holes ( holes , numHoles ) , numHoles , edges ( edges , numHoles , components ) , components ) ; return buildCoordinates ( components ) ; } private static void assign ( Edge [ ] holes , Coordinate [ ] [ ] points , int numHoles , Edge [ ] edges , ArrayList < ArrayList < Coordinate [ ] > > components ) { if ( debugEnabled ( ) ) { LOGGER . debug ( <str> + Arrays . toString ( holes ) ) ; } for ( int i = <int> ; i < numHoles ; i + + ) { final Edge current = new Edge ( holes [ i ] . coordinate , holes [ i ] . next ) ; current . intersect = current . coordinate ; final int intersections = intersections ( current . coordinate . x , edges ) ; final int pos ; boolean sharedVertex = false ; if ( intersections = = <int> | | ( ( pos = Arrays . binarySearch ( edges , <int> , intersections , current , INTERSECTION_ORDER ) ) > = <int> ) & & ! ( sharedVertex = ( edges [ pos ] . intersect . compareTo ( current . coordinate ) = = <int> ) ) ) { throw new InvalidShapeException ( <str> ) ; } final int index = - ( ( sharedVertex ) ? <int> : pos + <int> ) ; final int component = - edges [ index ] . component - numHoles - <int> ; if ( debugEnabled ( ) ) { LOGGER . debug ( <str> + index + <str> + current + <str> + edges [ index ] ) ; LOGGER . debug ( <str> + component ) ; LOGGER . debug ( <str> + current . coordinate . x + <str> + Arrays . toString ( edges ) ) ; } components . get ( component ) . add ( points [ i ] ) ; } } private static int merge ( Edge [ ] intersections , int offset , int length , Edge [ ] holes , int numHoles ) { for ( int i = <int> ; i < length ; i + = <int> ) { Edge e1 = intersections [ offset + i + <int> ] ; Edge e2 = intersections [ offset + i + <int> ] ; if ( e2 . component > <int> ) { numHoles - - ; holes [ e2 . component - <int> ] = holes [ numHoles ] ; holes [ numHoles ] = null ; } if ( e1 . intersect ! = Edge . MAX_COORDINATE & & e2 . intersect ! = Edge . MAX_COORDINATE & & ! ( e1 . next . next . coordinate . equals3D ( e2 . coordinate ) & & Math . abs ( e1 . next . coordinate . x ) = = DATELINE & & Math . abs ( e2 . coordinate . x ) = = DATELINE ) ) { connect ( e1 , e2 ) ; } } return numHoles ; } private static void connect ( Edge in , Edge out ) { assert in ! = null & & out ! = null ; assert in ! = out ; if ( in . intersect ! = in . next . coordinate ) { Edge e1 = new Edge ( in . intersect , in . next ) ; if ( out . intersect ! = out . next . coordinate ) { Edge e2 = new Edge ( out . intersect , out . next ) ; in . next = new Edge ( in . intersect , e2 , in . intersect ) ; } else { in . next = new Edge ( in . intersect , out . next , in . intersect ) ; } out . next = new Edge ( out . intersect , e1 , out . intersect ) ; } else if ( in . next ! = out & & in . coordinate ! = out . intersect ) { Edge e2 = new Edge ( out . intersect , in . next , out . intersect ) ; if ( out . intersect ! = out . next . coordinate ) { Edge e1 = new Edge ( out . intersect , out . next ) ; in . next = new Edge ( in . intersect , e1 , in . intersect ) ; } else { in . next = new Edge ( in . intersect , out . next , in . intersect ) ; } out . next = e2 ; } } private static int createEdges ( int component , Orientation orientation , LineStringBuilder shell , LineStringBuilder hole , Edge [ ] edges , int offset , final AtomicBoolean translated ) { boolean direction = ( component = = <int> ^ orientation = = Orientation . RIGHT ) ; Coordinate [ ] points = ( hole ! = null ) ? hole . coordinates ( false ) : shell . coordinates ( false ) ; ring ( component , direction , orientation = = Orientation . LEFT , shell , points , <int> , edges , offset , points . length - <int> , translated ) ; return points . length - <int> ; } private static Edge [ ] ring ( int component , boolean direction , boolean handedness , LineStringBuilder shell , Coordinate [ ] points , int offset , Edge [ ] edges , int toffset , int length , final AtomicBoolean translated ) { final int top = top ( points , offset , length ) ; final int prev = ( offset + ( ( top + length - <int> ) % length ) ) ; final int next = ( offset + ( ( top + <int> ) % length ) ) ; boolean orientation = points [ offset + prev ] . x > points [ offset + next ] . x ; double [ ] range = range ( points , offset , length ) ; final double rng = range [ <int> ] - range [ <int> ] ; boolean incorrectOrientation = component = = <int> & & handedness ! = orientation ; if ( ( incorrectOrientation & & ( rng > DATELINE & & rng ! = <int> * DATELINE ) ) | | ( translated . get ( ) & & component ! = <int> ) ) { translate ( points ) ; if ( component = = <int> ) { translated . set ( true ) ; } if ( component = = <int> | | ( component ! = <int> & & handedness = = orientation ) ) { orientation = ! orientation ; } } return concat ( component , direction ^ orientation , points , offset , edges , toffset , length ) ; } private static final int top ( Coordinate [ ] points , int offset , int length ) { int top = <int> ; for ( int i = <int> ; i < length ; i + + ) { if ( points [ offset + i ] . y < points [ offset + top ] . y ) { top = i ; } else if ( points [ offset + i ] . y = = points [ offset + top ] . y ) { if ( points [ offset + i ] . x < points [ offset + top ] . x ) { top = i ; } } } return top ; } private static final double [ ] range ( Coordinate [ ] points , int offset , int length ) { double minX = points [ <int> ] . x ; double maxX = points [ <int> ] . x ; double minY = points [ <int> ] . y ; double maxY = points [ <int> ] . y ; for ( int i = <int> ; i < length ; + + i ) { if ( points [ offset + i ] . x < minX ) { minX = points [ offset + i ] . x ; } if ( points [ offset + i ] . x > maxX ) { maxX = points [ offset + i ] . x ; } if ( points [ offset + i ] . y < minY ) { minY = points [ offset + i ] . y ; } if ( points [ offset + i ] . y > maxY ) { maxY = points [ offset + i ] . y ; } } return new double [ ] { minX , maxX , minY , maxY } ; } private static Edge [ ] concat ( int component , boolean direction , Coordinate [ ] points , final int pointOffset , Edge [ ] edges , final int edgeOffset , int length ) { assert edges . length > = length + edgeOffset ; assert points . length > = length + pointOffset ; edges [ edgeOffset ] = new Edge ( points [ pointOffset ] , null ) ; for ( int i = <int> ; i < length ; i + + ) { if ( direction ) { edges [ edgeOffset + i ] = new Edge ( points [ pointOffset + i ] , edges [ edgeOffset + i - <int> ] ) ; edges [ edgeOffset + i ] . component = component ; } else if ( ! edges [ edgeOffset + i - <int> ] . coordinate . equals ( points [ pointOffset + i ] ) ) { edges [ edgeOffset + i - <int> ] . next = edges [ edgeOffset + i ] = new Edge ( points [ pointOffset + i ] , null ) ; edges [ edgeOffset + i - <int> ] . component = component ; } else { throw new InvalidShapeException ( <str> + points [ pointOffset + i ] ) ; } } if ( direction ) { edges [ edgeOffset ] . setNext ( edges [ edgeOffset + length - <int> ] ) ; edges [ edgeOffset ] . component = component ; } else { edges [ edgeOffset + length - <int> ] . setNext ( edges [ edgeOffset ] ) ; edges [ edgeOffset + length - <int> ] . component = component ; } return edges ; } private static void translate ( Coordinate [ ] points ) { for ( Coordinate c : points ) { if ( c . x < <int> ) { c . x + = <int> * DATELINE ; } } } } 
