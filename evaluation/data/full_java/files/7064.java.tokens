package org . elasticsearch . rest . action . support ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . io . UTF8StreamWriter ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . SizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . rest . * ; import java . io . IOException ; import java . util . * ; public class RestTable { public static RestResponse buildResponse ( Table table , RestChannel channel ) throws Exception { RestRequest request = channel . request ( ) ; XContentType xContentType = XContentType . fromRestContentType ( request . param ( <str> , request . header ( <str> ) ) ) ; if ( xContentType ! = null ) { return buildXContentBuilder ( table , channel ) ; } return buildTextPlainResponse ( table , channel ) ; } public static RestResponse buildXContentBuilder ( Table table , RestChannel channel ) throws Exception { RestRequest request = channel . request ( ) ; XContentBuilder builder = channel . newBuilder ( ) ; List < DisplayHeader > displayHeaders = buildDisplayHeaders ( table , request ) ; builder . startArray ( ) ; for ( int row = <int> ; row < table . getRows ( ) . size ( ) ; row + + ) { builder . startObject ( ) ; for ( DisplayHeader header : displayHeaders ) { builder . field ( header . display , renderValue ( request , table . getAsMap ( ) . get ( header . name ) . get ( row ) . value ) ) ; } builder . endObject ( ) ; } builder . endArray ( ) ; return new BytesRestResponse ( RestStatus . OK , builder ) ; } public static RestResponse buildTextPlainResponse ( Table table , RestChannel channel ) throws IOException { RestRequest request = channel . request ( ) ; boolean verbose = request . paramAsBoolean ( <str> , false ) ; List < DisplayHeader > headers = buildDisplayHeaders ( table , request ) ; int [ ] width = buildWidths ( table , request , verbose , headers ) ; BytesStreamOutput bytesOut = channel . bytesOutput ( ) ; UTF8StreamWriter out = new UTF8StreamWriter ( ) . setOutput ( bytesOut ) ; int lastHeader = headers . size ( ) - <int> ; if ( verbose ) { for ( int col = <int> ; col < headers . size ( ) ; col + + ) { DisplayHeader header = headers . get ( col ) ; boolean isLastColumn = col = = lastHeader ; pad ( new Table . Cell ( header . display , table . findHeaderByName ( header . name ) ) , width [ col ] , request , out , isLastColumn ) ; if ( ! isLastColumn ) { out . append ( <str> ) ; } } out . append ( <str> ) ; } for ( int row = <int> ; row < table . getRows ( ) . size ( ) ; row + + ) { for ( int col = <int> ; col < headers . size ( ) ; col + + ) { DisplayHeader header = headers . get ( col ) ; boolean isLastColumn = col = = lastHeader ; pad ( table . getAsMap ( ) . get ( header . name ) . get ( row ) , width [ col ] , request , out , isLastColumn ) ; if ( ! isLastColumn ) { out . append ( <str> ) ; } } out . append ( <str> ) ; } out . close ( ) ; return new BytesRestResponse ( RestStatus . OK , BytesRestResponse . TEXT_CONTENT_TYPE , bytesOut . bytes ( ) ) ; } static List < DisplayHeader > buildDisplayHeaders ( Table table , RestRequest request ) { List < DisplayHeader > display = new ArrayList < > ( ) ; if ( request . hasParam ( <str> ) ) { Set < String > headers = expandHeadersFromRequest ( table , request ) ; for ( String possibility : headers ) { DisplayHeader dispHeader = null ; if ( table . getAsMap ( ) . containsKey ( possibility ) ) { dispHeader = new DisplayHeader ( possibility , possibility ) ; } else { for ( Table . Cell headerCell : table . getHeaders ( ) ) { String aliases = headerCell . attr . get ( <str> ) ; if ( aliases ! = null ) { for ( String alias : Strings . splitStringByCommaToArray ( aliases ) ) { if ( possibility . equals ( alias ) ) { dispHeader = new DisplayHeader ( headerCell . value . toString ( ) , alias ) ; break ; } } } } } if ( dispHeader ! = null ) { display . add ( dispHeader ) ; Table . Cell hcell = table . getHeaderMap ( ) . get ( dispHeader . name ) ; String siblingFlag = hcell . attr . get ( <str> ) ; if ( siblingFlag ! = null ) { String sibling = siblingFlag + <str> + dispHeader . name ; Table . Cell c = table . getHeaderMap ( ) . get ( sibling ) ; if ( c ! = null & & request . paramAsBoolean ( siblingFlag , false ) ) { display . add ( new DisplayHeader ( c . value . toString ( ) , siblingFlag + <str> + dispHeader . display ) ) ; } } } } } else { for ( Table . Cell cell : table . getHeaders ( ) ) { String d = cell . attr . get ( <str> ) ; if ( Booleans . parseBoolean ( d , true ) ) { display . add ( new DisplayHeader ( cell . value . toString ( ) , cell . value . toString ( ) ) ) ; } } } return display ; } private static Set < String > expandHeadersFromRequest ( Table table , RestRequest request ) { Set < String > headers = new LinkedHashSet < > ( table . getHeaders ( ) . size ( ) ) ; for ( String header : Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ) { if ( Regex . isSimpleMatchPattern ( header ) ) { for ( Table . Cell tableHeaderCell : table . getHeaders ( ) ) { String configuredHeader = tableHeaderCell . value . toString ( ) ; if ( Regex . simpleMatch ( header , configuredHeader ) ) { headers . add ( configuredHeader ) ; } else if ( tableHeaderCell . attr . containsKey ( <str> ) ) { String [ ] aliases = Strings . splitStringByCommaToArray ( tableHeaderCell . attr . get ( <str> ) ) ; for ( String alias : aliases ) { if ( Regex . simpleMatch ( header , alias ) ) { headers . add ( configuredHeader ) ; break ; } } } } } else { headers . add ( header ) ; } } return headers ; } public static int [ ] buildHelpWidths ( Table table , RestRequest request ) { int [ ] width = new int [ <int> ] ; for ( Table . Cell cell : table . getHeaders ( ) ) { String v = renderValue ( request , cell . value ) ; int vWidth = v = = null ? <int> : v . length ( ) ; if ( width [ <int> ] < vWidth ) { width [ <int> ] = vWidth ; } v = renderValue ( request , cell . attr . containsKey ( <str> ) ? cell . attr . get ( <str> ) : <str> ) ; vWidth = v = = null ? <int> : v . length ( ) ; if ( width [ <int> ] < vWidth ) { width [ <int> ] = vWidth ; } v = renderValue ( request , cell . attr . containsKey ( <str> ) ? cell . attr . get ( <str> ) : <str> ) ; vWidth = v = = null ? <int> : v . length ( ) ; if ( width [ <int> ] < vWidth ) { width [ <int> ] = vWidth ; } } return width ; } private static int [ ] buildWidths ( Table table , RestRequest request , boolean verbose , List < DisplayHeader > headers ) { int [ ] width = new int [ headers . size ( ) ] ; int i ; if ( verbose ) { i = <int> ; for ( DisplayHeader hdr : headers ) { int vWidth = hdr . display . length ( ) ; if ( width [ i ] < vWidth ) { width [ i ] = vWidth ; } i + + ; } } i = <int> ; for ( DisplayHeader hdr : headers ) { for ( Table . Cell cell : table . getAsMap ( ) . get ( hdr . name ) ) { String v = renderValue ( request , cell . value ) ; int vWidth = v = = null ? <int> : v . length ( ) ; if ( width [ i ] < vWidth ) { width [ i ] = vWidth ; } } i + + ; } return width ; } public static void pad ( Table . Cell cell , int width , RestRequest request , UTF8StreamWriter out ) throws IOException { pad ( cell , width , request , out , false ) ; } public static void pad ( Table . Cell cell , int width , RestRequest request , UTF8StreamWriter out , boolean isLast ) throws IOException { String sValue = renderValue ( request , cell . value ) ; int length = sValue = = null ? <int> : sValue . length ( ) ; byte leftOver = ( byte ) ( width - length ) ; String textAlign = cell . attr . get ( <str> ) ; if ( textAlign = = null ) { textAlign = <str> ; } if ( leftOver > <int> & & textAlign . equals ( <str> ) ) { for ( byte i = <int> ; i < leftOver ; i + + ) { out . append ( <str> ) ; } if ( sValue ! = null ) { out . append ( sValue ) ; } } else { if ( sValue ! = null ) { out . append ( sValue ) ; } if ( ! isLast ) { for ( byte i = <int> ; i < leftOver ; i + + ) { out . append ( <str> ) ; } } } } private static String renderValue ( RestRequest request , Object value ) { if ( value = = null ) { return null ; } if ( value instanceof ByteSizeValue ) { ByteSizeValue v = ( ByteSizeValue ) value ; String resolution = request . param ( <str> ) ; if ( <str> . equals ( resolution ) ) { return Long . toString ( v . bytes ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . kb ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . mb ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . gb ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . tb ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . pb ( ) ) ; } else { return v . toString ( ) ; } } if ( value instanceof SizeValue ) { SizeValue v = ( SizeValue ) value ; String resolution = request . param ( <str> ) ; if ( <str> . equals ( resolution ) ) { return Long . toString ( v . singles ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . kilo ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . mega ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . giga ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . tera ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . peta ( ) ) ; } else { return v . toString ( ) ; } } if ( value instanceof TimeValue ) { TimeValue v = ( TimeValue ) value ; String resolution = request . param ( <str> ) ; if ( <str> . equals ( resolution ) ) { return Long . toString ( v . millis ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . seconds ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . minutes ( ) ) ; } else if ( <str> . equals ( resolution ) ) { return Long . toString ( v . hours ( ) ) ; } else { return v . toString ( ) ; } } return value . toString ( ) ; } static class DisplayHeader { public final String name ; public final String display ; DisplayHeader ( String name , String display ) { this . name = name ; this . display = display ; } } } 
