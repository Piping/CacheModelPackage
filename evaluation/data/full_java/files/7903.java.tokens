package org . elasticsearch . common . collect ; import org . elasticsearch . test . ESTestCase ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . emptyMap ; public class CopyOnWriteHashMapTests extends ESTestCase { private static class O { private final int value , hashCode ; O ( int value , int hashCode ) { super ( ) ; this . value = value ; this . hashCode = hashCode ; } @Override public int hashCode ( ) { return hashCode ; } @Override public boolean equals ( Object obj ) { if ( obj = = null | | ! ( obj instanceof O ) ) { return false ; } return value = = ( ( O ) obj ) . value ; } } public void testDuel ( ) { final int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int iter = <int> ; iter < iters ; + + iter ) { final int valueBits = randomIntBetween ( <int> , <int> ) ; final int hashBits = randomInt ( valueBits ) ; final int numOps = randomInt ( <int> + hashBits * <int> ) ; Map < O , Integer > ref = new HashMap < > ( ) ; CopyOnWriteHashMap < O , Integer > map = new CopyOnWriteHashMap < > ( ) ; assertEquals ( ref , map ) ; final int hashBase = randomInt ( ) ; for ( int i = <int> ; i < numOps ; + + i ) { final int v = randomInt ( <int> < < valueBits ) ; final int h = ( v & ( ( <int> < < hashBits ) - <int> ) ) ^ hashBase ; O key = new O ( v , h ) ; Map < O , Integer > newRef = new HashMap < > ( ref ) ; final CopyOnWriteHashMap < O , Integer > newMap ; if ( randomBoolean ( ) ) { Integer value = v ; newRef . put ( key , value ) ; newMap = map . copyAndPut ( key , value ) ; } else { final Integer removed = newRef . remove ( key ) ; newMap = map . copyAndRemove ( key ) ; if ( removed = = null ) { assertSame ( map , newMap ) ; } } assertEquals ( ref , map ) ; assertEquals ( newRef , newMap ) ; assertEquals ( newMap , newRef ) ; ref = newRef ; map = newMap ; } assertEquals ( ref , CopyOnWriteHashMap . copyOf ( ref ) ) ; assertEquals ( emptyMap ( ) , CopyOnWriteHashMap . copyOf ( ref ) . copyAndRemoveAll ( ref . keySet ( ) ) ) ; } } public void testCollision ( ) { CopyOnWriteHashMap < O , Integer > map = new CopyOnWriteHashMap < > ( ) ; map = map . copyAndPut ( new O ( <int> , <int> ) , <int> ) ; assertEquals ( ( Integer ) <int> , map . get ( new O ( <int> , <int> ) ) ) ; assertNull ( map . get ( new O ( <int> , <int> ) ) ) ; map = map . copyAndPut ( new O ( <int> , <int> ) , <int> ) ; assertEquals ( ( Integer ) <int> , map . get ( new O ( <int> , <int> ) ) ) ; assertEquals ( ( Integer ) <int> , map . get ( new O ( <int> , <int> ) ) ) ; map = map . copyAndRemove ( new O ( <int> , <int> ) ) ; assertNull ( map . get ( new O ( <int> , <int> ) ) ) ; assertEquals ( ( Integer ) <int> , map . get ( new O ( <int> , <int> ) ) ) ; map = map . copyAndRemove ( new O ( <int> , <int> ) ) ; assertNull ( map . get ( new O ( <int> , <int> ) ) ) ; assertNull ( map . get ( new O ( <int> , <int> ) ) ) ; } public void testUnsupportedAPIs ( ) { try { new CopyOnWriteHashMap < > ( ) . put ( <str> , <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } try { new CopyOnWriteHashMap < > ( ) . copyAndPut ( <str> , <str> ) . remove ( <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } public void testUnsupportedValues ( ) { try { new CopyOnWriteHashMap < > ( ) . copyAndPut ( <str> , null ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } try { new CopyOnWriteHashMap < > ( ) . copyAndPut ( null , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } } } 
