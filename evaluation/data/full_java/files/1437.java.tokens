package org . apache . cassandra . db ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static junit . framework . Assert . assertFalse ; import static junit . framework . Assert . assertTrue ; public class DeletePartitionTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) ) ; } @Test public void testDeletePartition ( ) { testDeletePartition ( Util . dk ( <str> ) , true , true ) ; testDeletePartition ( Util . dk ( <str> ) , true , false ) ; testDeletePartition ( Util . dk ( <str> ) , false , true ) ; testDeletePartition ( Util . dk ( <str> ) , false , false ) ; } public void testDeletePartition ( DecoratedKey key , boolean flushBeforeRemove , boolean flushAfterRemove ) { ColumnFamilyStore store = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; ColumnDefinition column = store . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; new RowUpdateBuilder ( store . metadata , <int> , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; FilteredPartition partition = Util . getOnlyPartition ( Util . cmd ( store , key ) . build ( ) ) ; assertTrue ( partition . rowCount ( ) > <int> ) ; Row r = partition . iterator ( ) . next ( ) ; assertTrue ( r . getCell ( column ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; if ( flushBeforeRemove ) store . forceBlockingFlush ( ) ; new Mutation ( KEYSPACE1 , key ) . add ( PartitionUpdate . fullPartitionDelete ( store . metadata , key , <int> , FBUtilities . nowInSeconds ( ) ) ) . applyUnsafe ( ) ; if ( flushAfterRemove ) store . forceBlockingFlush ( ) ; ImmutableBTreePartition partitionUnfiltered = Util . getOnlyPartitionUnfiltered ( Util . cmd ( store , key ) . build ( ) ) ; assertFalse ( partitionUnfiltered . partitionLevelDeletion ( ) . isLive ( ) ) ; assertFalse ( partitionUnfiltered . iterator ( ) . hasNext ( ) ) ; } } 
