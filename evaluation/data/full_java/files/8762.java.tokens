package org . elasticsearch . plugin . discovery . multicast ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . apache . lucene . util . Constants ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . SpecialPermission ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . network . NetworkUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . discovery . zen . ping . PingContextProvider ; import org . elasticsearch . discovery . zen . ping . ZenPing ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . EmptyTransportResponseHandler ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . net . InetAddress ; import java . net . SocketAddress ; import java . security . AccessController ; import java . security . PrivilegedExceptionAction ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . cluster . node . DiscoveryNode . readNode ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; import static org . elasticsearch . common . util . concurrent . ConcurrentCollections . newConcurrentMap ; public class MulticastZenPing extends AbstractLifecycleComponent < ZenPing > implements ZenPing { public static final String ACTION_NAME = <str> ; private static final byte [ ] INTERNAL_HEADER = new byte [ ] { <int> , <int> , <int> , <int> } ; private static final int PING_SIZE_ESTIMATE = <int> ; private final String address ; private final int port ; private final String group ; private final int bufferSize ; private final int ttl ; private final ThreadPool threadPool ; private final TransportService transportService ; private final ClusterName clusterName ; private final NetworkService networkService ; private final Version version ; private volatile PingContextProvider contextProvider ; private final boolean pingEnabled ; private volatile MulticastChannel multicastChannel ; private final AtomicInteger pingIdGenerator = new AtomicInteger ( ) ; private final Map < Integer , PingCollection > receivedResponses = newConcurrentMap ( ) ; public MulticastZenPing ( ThreadPool threadPool , TransportService transportService , ClusterName clusterName , Version version ) { this ( EMPTY_SETTINGS , threadPool , transportService , clusterName , new NetworkService ( EMPTY_SETTINGS ) , version ) ; } @Inject public MulticastZenPing ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterName clusterName , NetworkService networkService , Version version ) { super ( settings ) ; this . threadPool = threadPool ; this . transportService = transportService ; this . clusterName = clusterName ; this . networkService = networkService ; this . version = version ; this . address = this . settings . get ( <str> ) ; this . port = this . settings . getAsInt ( <str> , <int> ) ; this . group = this . settings . get ( <str> , <str> ) ; this . bufferSize = this . settings . getAsInt ( <str> , <int> ) ; this . ttl = this . settings . getAsInt ( <str> , <int> ) ; this . pingEnabled = this . settings . getAsBoolean ( <str> , true ) ; logger . debug ( <str> , group , port , ttl , address ) ; this . transportService . registerRequestHandler ( ACTION_NAME , MulticastPingResponse : : new , ThreadPool . Names . SAME , new MulticastPingResponseRequestHandler ( ) ) ; } @Override public void setPingContextProvider ( PingContextProvider nodesProvider ) { if ( lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } this . contextProvider = nodesProvider ; } @Override protected void doStart ( ) { try { boolean shared = settings . getAsBoolean ( <str> , Constants . MAC_OS_X ) ; boolean deferToInterface = settings . getAsBoolean ( <str> , Constants . MAC_OS_X ) ; List < InetAddress > addresses = Arrays . asList ( networkService . resolveBindHostAddresses ( address = = null ? null : new String [ ] { address } ) ) ; NetworkUtils . sortAddresses ( addresses ) ; final MulticastChannel . Config config = new MulticastChannel . Config ( port , group , bufferSize , ttl , addresses . get ( <int> ) , deferToInterface ) ; SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new SpecialPermission ( ) ) ; } multicastChannel = AccessController . doPrivileged ( new PrivilegedExceptionAction < MulticastChannel > ( ) { @Override public MulticastChannel run ( ) throws Exception { return MulticastChannel . getChannel ( nodeName ( ) , shared , config , new Receiver ( ) ) ; } } ) ; } catch ( Throwable t ) { String msg = <str> ; logger . info ( msg , t , ExceptionsHelper . detailedMessage ( t ) ) ; } } @Override protected void doStop ( ) { if ( multicastChannel ! = null ) { multicastChannel . close ( ) ; multicastChannel = null ; } } @Override protected void doClose ( ) { } public PingResponse [ ] pingAndWait ( TimeValue timeout ) { final AtomicReference < PingResponse [ ] > response = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; try { ping ( new PingListener ( ) { @Override public void onPing ( PingResponse [ ] pings ) { response . set ( pings ) ; latch . countDown ( ) ; } } , timeout ) ; } catch ( EsRejectedExecutionException ex ) { logger . debug ( <str> , ex ) ; return PingResponse . EMPTY ; } try { latch . await ( ) ; return response . get ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; return PingResponse . EMPTY ; } } @Override public void ping ( final PingListener listener , final TimeValue timeout ) { if ( ! pingEnabled | | multicastChannel = = null ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { listener . onPing ( PingResponse . EMPTY ) ; } } ) ; return ; } final int id = pingIdGenerator . incrementAndGet ( ) ; try { receivedResponses . put ( id , new PingCollection ( ) ) ; sendPingRequest ( id ) ; threadPool . schedule ( TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , t , id ) ; finalizePingCycle ( id , listener ) ; } @Override public void doRun ( ) { sendPingRequest ( id ) ; threadPool . schedule ( TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , t , id ) ; finalizePingCycle ( id , listener ) ; } @Override public void doRun ( ) { PingCollection collection = receivedResponses . get ( id ) ; FinalizingPingCollection finalizingPingCollection = new FinalizingPingCollection ( id , collection , collection . size ( ) , listener ) ; receivedResponses . put ( id , finalizingPingCollection ) ; logger . trace ( <str> , id ) ; sendPingRequest ( id ) ; threadPool . schedule ( TimeValue . timeValueMillis ( timeout . millis ( ) / <int> ) , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . warn ( <str> , t , id ) ; } @Override protected void doRun ( ) throws Exception { finalizePingCycle ( id , listener ) ; } } ) ; } } ) ; } } ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; finalizePingCycle ( id , listener ) ; } } private void finalizePingCycle ( int id , final PingListener listener ) { PingCollection responses = receivedResponses . remove ( id ) ; if ( responses ! = null ) { listener . onPing ( responses . toArray ( ) ) ; } } private void sendPingRequest ( int id ) { try { BytesStreamOutput out = new BytesStreamOutput ( PING_SIZE_ESTIMATE ) ; out . writeBytes ( INTERNAL_HEADER ) ; Version . writeVersion ( version , out ) ; out . writeInt ( id ) ; clusterName . writeTo ( out ) ; contextProvider . nodes ( ) . localNode ( ) . writeTo ( out ) ; out . close ( ) ; multicastChannel . send ( out . bytes ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , id ) ; } } catch ( Exception e ) { if ( lifecycle . stoppedOrClosed ( ) ) { return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , e ) ; } else { logger . warn ( <str> , ExceptionsHelper . detailedMessage ( e ) ) ; } } } class FinalizingPingCollection extends PingCollection { final private PingCollection internalCollection ; final private int expectedResponses ; final private AtomicInteger responseCount ; final private PingListener listener ; final private int id ; public FinalizingPingCollection ( int id , PingCollection internalCollection , int expectedResponses , PingListener listener ) { this . id = id ; this . internalCollection = internalCollection ; this . expectedResponses = expectedResponses ; this . responseCount = new AtomicInteger ( ) ; this . listener = listener ; } @Override public synchronized boolean addPing ( PingResponse ping ) { if ( internalCollection . addPing ( ping ) ) { if ( responseCount . incrementAndGet ( ) > = expectedResponses ) { logger . trace ( <str> , id ) ; finish ( ) ; } return true ; } return false ; } @Override public synchronized void addPings ( PingResponse [ ] pings ) { internalCollection . addPings ( pings ) ; } @Override public synchronized PingResponse [ ] toArray ( ) { return internalCollection . toArray ( ) ; } void finish ( ) { threadPool . generic ( ) . execute ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; } @Override protected void doRun ( ) throws Exception { finalizePingCycle ( id , listener ) ; } } ) ; } } class MulticastPingResponseRequestHandler implements TransportRequestHandler < MulticastPingResponse > { @Override public void messageReceived ( MulticastPingResponse request , TransportChannel channel ) throws Exception { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , request . id , request . pingResponse ) ; } PingCollection responses = receivedResponses . get ( request . id ) ; if ( responses = = null ) { logger . warn ( <str> , request . pingResponse , request . id ) ; } else { responses . addPing ( request . pingResponse ) ; } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } public static class MulticastPingResponse extends TransportRequest { int id ; PingResponse pingResponse ; public MulticastPingResponse ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; id = in . readInt ( ) ; pingResponse = PingResponse . readPingResponse ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( id ) ; pingResponse . writeTo ( out ) ; } } private class Receiver implements MulticastChannel . Listener { @Override public void onMessage ( BytesReference data , SocketAddress address ) { int id = - <int> ; DiscoveryNode requestingNodeX = null ; ClusterName clusterName = null ; Map < String , Object > externalPingData = null ; XContentType xContentType = null ; try { boolean internal = false ; if ( data . length ( ) > <int> ) { int counter = <int> ; for ( ; counter < INTERNAL_HEADER . length ; counter + + ) { if ( data . get ( counter ) ! = INTERNAL_HEADER [ counter ] ) { break ; } } if ( counter = = INTERNAL_HEADER . length ) { internal = true ; } } if ( internal ) { StreamInput input = StreamInput . wrap ( new BytesArray ( data . toBytes ( ) , INTERNAL_HEADER . length , data . length ( ) - INTERNAL_HEADER . length ) ) ; Version version = Version . readVersion ( input ) ; input . setVersion ( version ) ; id = input . readInt ( ) ; clusterName = ClusterName . readClusterName ( input ) ; requestingNodeX = readNode ( input ) ; } else { xContentType = XContentFactory . xContentType ( data ) ; if ( xContentType ! = null ) { try ( XContentParser parser = XContentFactory . xContent ( xContentType ) . createParser ( data ) ) { externalPingData = parser . map ( ) ; } } else { throw new IllegalStateException ( <str> ) ; } } if ( externalPingData ! = null ) { handleExternalPingRequest ( externalPingData , xContentType , address ) ; } else { handleNodePingRequest ( id , requestingNodeX , clusterName ) ; } } catch ( Exception e ) { if ( ! lifecycle . started ( ) | | ( e instanceof EsRejectedExecutionException ) ) { logger . debug ( <str> , e , address ) ; } else { logger . warn ( <str> , e , address ) ; } } } @SuppressWarnings ( <str> ) private void handleExternalPingRequest ( Map < String , Object > externalPingData , XContentType contentType , SocketAddress remoteAddress ) { if ( externalPingData . containsKey ( <str> ) ) { logger . trace ( <str> , remoteAddress , externalPingData ) ; return ; } if ( multicastChannel = = null ) { logger . debug ( <str> , remoteAddress , externalPingData ) ; return ; } Map < String , Object > request = ( Map < String , Object > ) externalPingData . get ( <str> ) ; if ( request = = null ) { logger . warn ( <str> , remoteAddress , externalPingData ) ; return ; } final String requestClusterName = request . containsKey ( <str> ) ? request . get ( <str> ) . toString ( ) : request . containsKey ( <str> ) ? request . get ( <str> ) . toString ( ) : null ; if ( requestClusterName = = null ) { logger . warn ( <str> , remoteAddress , externalPingData ) ; return ; } if ( ! requestClusterName . equals ( clusterName . value ( ) ) ) { logger . trace ( <str> , requestClusterName , clusterName . value ( ) , remoteAddress , externalPingData ) ; return ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , remoteAddress , externalPingData ) ; } try { DiscoveryNode localNode = contextProvider . nodes ( ) . localNode ( ) ; XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) . startObject ( <str> ) ; builder . field ( <str> , clusterName . value ( ) ) ; builder . startObject ( <str> ) . field ( <str> , version . number ( ) ) . field ( <str> , version . snapshot ) . endObject ( ) ; builder . field ( <str> , localNode . address ( ) . toString ( ) ) ; if ( contextProvider . nodeService ( ) ! = null ) { for ( Map . Entry < String , String > attr : contextProvider . nodeService ( ) . attributes ( ) . entrySet ( ) ) { builder . field ( attr . getKey ( ) , attr . getValue ( ) ) ; } } builder . startObject ( <str> ) ; for ( ObjectObjectCursor < String , String > attr : localNode . attributes ( ) ) { builder . field ( attr . key , attr . value ) ; } builder . endObject ( ) ; builder . endObject ( ) . endObject ( ) ; multicastChannel . send ( builder . bytes ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , builder . string ( ) ) ; } } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } private void handleNodePingRequest ( int id , DiscoveryNode requestingNodeX , ClusterName requestClusterName ) { if ( ! pingEnabled | | multicastChannel = = null ) { return ; } final DiscoveryNodes discoveryNodes = contextProvider . nodes ( ) ; final DiscoveryNode requestingNode = requestingNodeX ; if ( requestingNode . id ( ) . equals ( discoveryNodes . localNodeId ( ) ) ) { return ; } if ( ! requestClusterName . equals ( clusterName ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , id , requestingNode , requestClusterName . value ( ) , clusterName . value ( ) ) ; } return ; } if ( ! discoveryNodes . localNode ( ) . shouldConnectTo ( requestingNode ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , id , requestingNode , requestClusterName ) ; } return ; } final MulticastPingResponse multicastPingResponse = new MulticastPingResponse ( ) ; multicastPingResponse . id = id ; multicastPingResponse . pingResponse = new PingResponse ( discoveryNodes . localNode ( ) , discoveryNodes . masterNode ( ) , clusterName , contextProvider . nodeHasJoinedClusterOnce ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , id , requestingNode , multicastPingResponse . pingResponse ) ; } if ( ! transportService . nodeConnected ( requestingNode ) ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { transportService . connectToNode ( requestingNode ) ; transportService . sendRequest ( requestingNode , ACTION_NAME , multicastPingResponse , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleException ( TransportException exp ) { logger . warn ( <str> , exp , requestingNode ) ; } } ) ; } catch ( Exception e ) { if ( lifecycle . started ( ) ) { logger . warn ( <str> , e , requestingNode ) ; } } } } ) ; } else { transportService . sendRequest ( requestingNode , ACTION_NAME , multicastPingResponse , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleException ( TransportException exp ) { if ( lifecycle . started ( ) ) { logger . warn ( <str> , exp , requestingNode ) ; } } } ) ; } } } } 
