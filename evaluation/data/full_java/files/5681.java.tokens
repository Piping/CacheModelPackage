package org . elasticsearch . common . breaker ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . indices . breaker . BreakerSettings ; import org . elasticsearch . indices . breaker . HierarchyCircuitBreakerService ; import java . util . concurrent . atomic . AtomicLong ; public class ChildMemoryCircuitBreaker implements CircuitBreaker { private final long memoryBytesLimit ; private final BreakerSettings settings ; private final double overheadConstant ; private final AtomicLong used ; private final AtomicLong trippedCount ; private final ESLogger logger ; private final HierarchyCircuitBreakerService parent ; private final String name ; public ChildMemoryCircuitBreaker ( BreakerSettings settings , ESLogger logger , HierarchyCircuitBreakerService parent , String name ) { this ( settings , null , logger , parent , name ) ; } public ChildMemoryCircuitBreaker ( BreakerSettings settings , ChildMemoryCircuitBreaker oldBreaker , ESLogger logger , HierarchyCircuitBreakerService parent , String name ) { this . name = name ; this . settings = settings ; this . memoryBytesLimit = settings . getLimit ( ) ; this . overheadConstant = settings . getOverhead ( ) ; if ( oldBreaker = = null ) { this . used = new AtomicLong ( <int> ) ; this . trippedCount = new AtomicLong ( <int> ) ; } else { this . used = oldBreaker . used ; this . trippedCount = oldBreaker . trippedCount ; } this . logger = logger ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . settings ) ; } this . parent = parent ; } @Override public void circuitBreak ( String fieldName , long bytesNeeded ) { this . trippedCount . incrementAndGet ( ) ; final String message = <str> + this . name + <str> + fieldName + <str> + memoryBytesLimit + <str> + new ByteSizeValue ( memoryBytesLimit ) + <str> ; logger . debug ( message ) ; throw new CircuitBreakingException ( message , bytesNeeded , this . memoryBytesLimit ) ; } @Override public double addEstimateBytesAndMaybeBreak ( long bytes , String label ) throws CircuitBreakingException { if ( memoryBytesLimit = = <int> ) { circuitBreak ( label , bytes ) ; } long newUsed ; if ( this . memoryBytesLimit = = - <int> ) { newUsed = this . used . addAndGet ( bytes ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . name , new ByteSizeValue ( bytes ) , label , new ByteSizeValue ( newUsed ) ) ; } } else { long currentUsed ; do { currentUsed = this . used . get ( ) ; newUsed = currentUsed + bytes ; long newUsedWithOverhead = ( long ) ( newUsed * overheadConstant ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . name , new ByteSizeValue ( bytes ) , label , new ByteSizeValue ( newUsed ) , memoryBytesLimit , new ByteSizeValue ( memoryBytesLimit ) , newUsedWithOverhead , new ByteSizeValue ( newUsedWithOverhead ) ) ; } if ( memoryBytesLimit > <int> & & newUsedWithOverhead > memoryBytesLimit ) { logger . warn ( <str> , this . name , newUsedWithOverhead , new ByteSizeValue ( newUsedWithOverhead ) , label , memoryBytesLimit , new ByteSizeValue ( memoryBytesLimit ) ) ; circuitBreak ( label , newUsedWithOverhead ) ; } } while ( ! this . used . compareAndSet ( currentUsed , newUsed ) ) ; } try { parent . checkParentLimit ( label ) ; } catch ( CircuitBreakingException e ) { this . addWithoutBreaking ( - bytes ) ; throw e ; } return newUsed ; } @Override public long addWithoutBreaking ( long bytes ) { long u = used . addAndGet ( bytes ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . name , bytes , u ) ; } assert u > = <int> : <str> + u + <str> ; return u ; } @Override public long getUsed ( ) { return this . used . get ( ) ; } @Override public long getLimit ( ) { return this . memoryBytesLimit ; } @Override public double getOverhead ( ) { return this . overheadConstant ; } @Override public long getTrippedCount ( ) { return this . trippedCount . get ( ) ; } @Override public String getName ( ) { return this . name ; } } 
