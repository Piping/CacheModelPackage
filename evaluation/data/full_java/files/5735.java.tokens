package org . elasticsearch . common . geo . builders ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . elasticsearch . common . geo . XShapeCollection ; import org . elasticsearch . common . xcontent . XContentBuilder ; import com . spatial4j . core . shape . Shape ; import com . vividsolutions . jts . geom . Coordinate ; public class MultiPolygonBuilder extends ShapeBuilder { public static final GeoShapeType TYPE = GeoShapeType . MULTIPOLYGON ; protected final ArrayList < PolygonBuilder > polygons = new ArrayList < > ( ) ; public MultiPolygonBuilder ( ) { this ( Orientation . RIGHT ) ; } public MultiPolygonBuilder ( Orientation orientation ) { super ( orientation ) ; } public MultiPolygonBuilder polygon ( PolygonBuilder polygon ) { this . polygons . add ( polygon ) ; return this ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( FIELD_TYPE , TYPE . shapeName ( ) ) ; builder . startArray ( FIELD_COORDINATES ) ; for ( PolygonBuilder polygon : polygons ) { builder . startArray ( ) ; polygon . coordinatesArray ( builder , params ) ; builder . endArray ( ) ; } builder . endArray ( ) ; return builder . endObject ( ) ; } @Override public GeoShapeType type ( ) { return TYPE ; } @Override public Shape build ( ) { List < Shape > shapes = new ArrayList < > ( this . polygons . size ( ) ) ; if ( wrapdateline ) { for ( PolygonBuilder polygon : this . polygons ) { for ( Coordinate [ ] [ ] part : polygon . coordinates ( ) ) { shapes . add ( jtsGeometry ( PolygonBuilder . polygon ( FACTORY , part ) ) ) ; } } } else { for ( PolygonBuilder polygon : this . polygons ) { shapes . add ( jtsGeometry ( polygon . toPolygon ( FACTORY ) ) ) ; } } if ( shapes . size ( ) = = <int> ) return shapes . get ( <int> ) ; else return new XShapeCollection < > ( shapes , SPATIAL_CONTEXT ) ; } } 
