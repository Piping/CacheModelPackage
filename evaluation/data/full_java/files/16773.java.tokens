package com . badlogic . gdx . backends . lwjgl ; import java . awt . Canvas ; import java . io . File ; import org . lwjgl . LWJGLException ; import org . lwjgl . opengl . Display ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Audio ; import com . badlogic . gdx . Files ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . LifecycleListener ; import com . badlogic . gdx . Net ; import com . badlogic . gdx . Preferences ; import com . badlogic . gdx . backends . lwjgl . audio . OpenALAudio ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Clipboard ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; public class LwjglApplication implements Application { protected final LwjglGraphics graphics ; protected OpenALAudio audio ; protected final LwjglFiles files ; protected final LwjglInput input ; protected final LwjglNet net ; protected final ApplicationListener listener ; protected Thread mainLoopThread ; protected boolean running = true ; protected final Array < Runnable > runnables = new Array < Runnable > ( ) ; protected final Array < Runnable > executedRunnables = new Array < Runnable > ( ) ; protected final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; protected int logLevel = LOG_INFO ; protected String preferencesdir ; protected Files . FileType preferencesFileType ; public LwjglApplication ( ApplicationListener listener , String title , int width , int height ) { this ( listener , createConfig ( title , width , height ) ) ; } public LwjglApplication ( ApplicationListener listener ) { this ( listener , null , <int> , <int> ) ; } public LwjglApplication ( ApplicationListener listener , LwjglApplicationConfiguration config ) { this ( listener , config , new LwjglGraphics ( config ) ) ; } public LwjglApplication ( ApplicationListener listener , Canvas canvas ) { this ( listener , new LwjglApplicationConfiguration ( ) , new LwjglGraphics ( canvas ) ) ; } public LwjglApplication ( ApplicationListener listener , LwjglApplicationConfiguration config , Canvas canvas ) { this ( listener , config , new LwjglGraphics ( canvas , config ) ) ; } public LwjglApplication ( ApplicationListener listener , LwjglApplicationConfiguration config , LwjglGraphics graphics ) { LwjglNativesLoader . load ( ) ; if ( config . title = = null ) config . title = listener . getClass ( ) . getSimpleName ( ) ; this . graphics = graphics ; if ( ! LwjglApplicationConfiguration . disableAudio ) { try { audio = new OpenALAudio ( config . audioDeviceSimultaneousSources , config . audioDeviceBufferCount , config . audioDeviceBufferSize ) ; } catch ( Throwable t ) { log ( <str> , <str> , t ) ; LwjglApplicationConfiguration . disableAudio = true ; } } files = new LwjglFiles ( ) ; input = new LwjglInput ( ) ; net = new LwjglNet ( ) ; this . listener = listener ; this . preferencesdir = config . preferencesDirectory ; this . preferencesFileType = config . preferencesFileType ; Gdx . app = this ; Gdx . graphics = graphics ; Gdx . audio = audio ; Gdx . files = files ; Gdx . input = input ; Gdx . net = net ; initialize ( ) ; } private static LwjglApplicationConfiguration createConfig ( String title , int width , int height ) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . title = title ; config . width = width ; config . height = height ; config . vSyncEnabled = true ; return config ; } private void initialize ( ) { mainLoopThread = new Thread ( <str> ) { @Override public void run ( ) { graphics . setVSync ( graphics . config . vSyncEnabled ) ; try { LwjglApplication . this . mainLoop ( ) ; } catch ( Throwable t ) { if ( audio ! = null ) audio . dispose ( ) ; Gdx . input . setCursorCatched ( false ) ; if ( t instanceof RuntimeException ) throw ( RuntimeException ) t ; else throw new GdxRuntimeException ( t ) ; } } } ; mainLoopThread . start ( ) ; } void mainLoop ( ) { Array < LifecycleListener > lifecycleListeners = this . lifecycleListeners ; try { graphics . setupDisplay ( ) ; } catch ( LWJGLException e ) { throw new GdxRuntimeException ( e ) ; } listener . create ( ) ; graphics . resize = true ; int lastWidth = graphics . getWidth ( ) ; int lastHeight = graphics . getHeight ( ) ; graphics . lastTime = System . nanoTime ( ) ; boolean wasActive = true ; while ( running ) { Display . processMessages ( ) ; if ( Display . isCloseRequested ( ) ) exit ( ) ; boolean isActive = Display . isActive ( ) ; if ( wasActive & & ! isActive ) { wasActive = false ; synchronized ( lifecycleListeners ) { for ( LifecycleListener listener : lifecycleListeners ) listener . pause ( ) ; } listener . pause ( ) ; } if ( ! wasActive & & isActive ) { wasActive = true ; synchronized ( lifecycleListeners ) { for ( LifecycleListener listener : lifecycleListeners ) listener . resume ( ) ; } listener . resume ( ) ; } boolean shouldRender = false ; if ( graphics . canvas ! = null ) { int width = graphics . canvas . getWidth ( ) ; int height = graphics . canvas . getHeight ( ) ; if ( lastWidth ! = width | | lastHeight ! = height ) { lastWidth = width ; lastHeight = height ; Gdx . gl . glViewport ( <int> , <int> , lastWidth , lastHeight ) ; listener . resize ( lastWidth , lastHeight ) ; shouldRender = true ; } } else { graphics . config . x = Display . getX ( ) ; graphics . config . y = Display . getY ( ) ; if ( graphics . resize | | Display . wasResized ( ) | | ( int ) ( Display . getWidth ( ) * Display . getPixelScaleFactor ( ) ) ! = graphics . config . width | | ( int ) ( Display . getHeight ( ) * Display . getPixelScaleFactor ( ) ) ! = graphics . config . height ) { graphics . resize = false ; graphics . config . width = ( int ) ( Display . getWidth ( ) * Display . getPixelScaleFactor ( ) ) ; graphics . config . height = ( int ) ( Display . getHeight ( ) * Display . getPixelScaleFactor ( ) ) ; Gdx . gl . glViewport ( <int> , <int> , graphics . config . width , graphics . config . height ) ; if ( listener ! = null ) listener . resize ( graphics . config . width , graphics . config . height ) ; graphics . requestRendering ( ) ; } } if ( executeRunnables ( ) ) shouldRender = true ; if ( ! running ) break ; input . update ( ) ; shouldRender | = graphics . shouldRender ( ) ; input . processEvents ( ) ; if ( audio ! = null ) audio . update ( ) ; if ( ! isActive & & graphics . config . backgroundFPS = = - <int> ) shouldRender = false ; int frameRate = isActive ? graphics . config . foregroundFPS : graphics . config . backgroundFPS ; if ( shouldRender ) { graphics . updateTime ( ) ; graphics . frameId + + ; listener . render ( ) ; Display . update ( false ) ; } else { if ( frameRate = = - <int> ) frameRate = <int> ; if ( frameRate = = <int> ) frameRate = graphics . config . backgroundFPS ; if ( frameRate = = <int> ) frameRate = <int> ; } if ( frameRate > <int> ) Display . sync ( frameRate ) ; } synchronized ( lifecycleListeners ) { for ( LifecycleListener listener : lifecycleListeners ) { listener . pause ( ) ; listener . dispose ( ) ; } } listener . pause ( ) ; listener . dispose ( ) ; Display . destroy ( ) ; if ( audio ! = null ) audio . dispose ( ) ; if ( graphics . config . forceExit ) System . exit ( - <int> ) ; } public boolean executeRunnables ( ) { synchronized ( runnables ) { for ( int i = runnables . size - <int> ; i > = <int> ; i - - ) executedRunnables . add ( runnables . get ( i ) ) ; runnables . clear ( ) ; } if ( executedRunnables . size = = <int> ) return false ; do executedRunnables . pop ( ) . run ( ) ; while ( executedRunnables . size > <int> ) ; return true ; } @Override public ApplicationListener getApplicationListener ( ) { return listener ; } @Override public Audio getAudio ( ) { return audio ; } @Override public Files getFiles ( ) { return files ; } @Override public LwjglGraphics getGraphics ( ) { return graphics ; } @Override public Input getInput ( ) { return input ; } @Override public Net getNet ( ) { return net ; } @Override public ApplicationType getType ( ) { return ApplicationType . Desktop ; } @Override public int getVersion ( ) { return <int> ; } public void stop ( ) { running = false ; try { mainLoopThread . join ( ) ; } catch ( Exception ex ) { } } @Override public long getJavaHeap ( ) { return Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) ; } @Override public long getNativeHeap ( ) { return getJavaHeap ( ) ; } ObjectMap < String , Preferences > preferences = new ObjectMap < String , Preferences > ( ) ; @Override public Preferences getPreferences ( String name ) { if ( preferences . containsKey ( name ) ) { return preferences . get ( name ) ; } else { Preferences prefs = new LwjglPreferences ( new LwjglFileHandle ( new File ( preferencesdir , name ) , preferencesFileType ) ) ; preferences . put ( name , prefs ) ; return prefs ; } } @Override public Clipboard getClipboard ( ) { return new LwjglClipboard ( ) ; } @Override public void postRunnable ( Runnable runnable ) { synchronized ( runnables ) { runnables . add ( runnable ) ; Gdx . graphics . requestRendering ( ) ; } } @Override public void debug ( String tag , String message ) { if ( logLevel > = LOG_DEBUG ) { System . out . println ( tag + <str> + message ) ; } } @Override public void debug ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_DEBUG ) { System . out . println ( tag + <str> + message ) ; exception . printStackTrace ( System . out ) ; } } @Override public void log ( String tag , String message ) { if ( logLevel > = LOG_INFO ) { System . out . println ( tag + <str> + message ) ; } } @Override public void log ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_INFO ) { System . out . println ( tag + <str> + message ) ; exception . printStackTrace ( System . out ) ; } } @Override public void error ( String tag , String message ) { if ( logLevel > = LOG_ERROR ) { System . err . println ( tag + <str> + message ) ; } } @Override public void error ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_ERROR ) { System . err . println ( tag + <str> + message ) ; exception . printStackTrace ( System . err ) ; } } @Override public void setLogLevel ( int logLevel ) { this . logLevel = logLevel ; } @Override public int getLogLevel ( ) { return logLevel ; } @Override public void exit ( ) { postRunnable ( new Runnable ( ) { @Override public void run ( ) { running = false ; } } ) ; } @Override public void addLifecycleListener ( LifecycleListener listener ) { synchronized ( lifecycleListeners ) { lifecycleListeners . add ( listener ) ; } } @Override public void removeLifecycleListener ( LifecycleListener listener ) { synchronized ( lifecycleListeners ) { lifecycleListeners . removeValue ( listener , true ) ; } } } 
