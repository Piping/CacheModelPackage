package org . elasticsearch . cluster . metadata ; import org . elasticsearch . Version ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData . State ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . IndexClosedException ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; import static org . hamcrest . Matchers . arrayContaining ; import static org . hamcrest . Matchers . arrayContainingInAnyOrder ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . emptyArray ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; public class IndexNameExpressionResolverTests extends ESTestCase { private final IndexNameExpressionResolver indexNameExpressionResolver = new IndexNameExpressionResolver ( Settings . EMPTY ) ; public void testIndexOptionsStrict ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndicesOptions [ ] indicesOptions = new IndicesOptions [ ] { IndicesOptions . strictExpandOpen ( ) , IndicesOptions . strictExpand ( ) } ; for ( IndicesOptions options : indicesOptions ) { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( new HashSet < > ( Arrays . asList ( <str> , <str> ) ) , new HashSet < > ( Arrays . asList ( results ) ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; } IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpen ( ) ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; results = indexNameExpressionResolver . concreteIndices ( context , ( String [ ] ) null ) ; assertEquals ( <int> , results . length ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpand ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; results = indexNameExpressionResolver . concreteIndices ( context , ( String [ ] ) null ) ; assertEquals ( <int> , results . length ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpen ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpand ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> , <str> ) ) ; } public void testIndexOptionsLenient ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndicesOptions lenientExpand = IndicesOptions . fromOptions ( true , true , true , true ) ; IndicesOptions [ ] indicesOptions = new IndicesOptions [ ] { IndicesOptions . lenientExpandOpen ( ) , lenientExpand } ; for ( IndicesOptions options : indicesOptions ) { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( new HashSet < > ( Arrays . asList ( <str> , <str> ) ) , new HashSet < > ( Arrays . asList ( results ) ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; } IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; context = new IndexNameExpressionResolver . Context ( state , lenientExpand ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> ) ) ; context = new IndexNameExpressionResolver . Context ( state , lenientExpand ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> , <str> ) ) ; } public void testIndexOptionsAllowUnavailableDisallowEmpty ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndicesOptions expandOpen = IndicesOptions . fromOptions ( true , false , true , false ) ; IndicesOptions expand = IndicesOptions . fromOptions ( true , false , true , true ) ; IndicesOptions [ ] indicesOptions = new IndicesOptions [ ] { expandOpen , expand } ; for ( IndicesOptions options : indicesOptions ) { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } } IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , expandOpen ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; context = new IndexNameExpressionResolver . Context ( state , expand ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; } public void testIndexOptionsWildcardExpansion ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndicesOptions options = IndicesOptions . fromOptions ( false , true , false , true ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; options = IndicesOptions . fromOptions ( false , true , true , false ) ; context = new IndexNameExpressionResolver . Context ( state , options ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; options = IndicesOptions . fromOptions ( false , true , true , true ) ; context = new IndexNameExpressionResolver . Context ( state , options ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; options = IndicesOptions . fromOptions ( false , false , true , true ) ; context = new IndexNameExpressionResolver . Context ( state , options ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getResourceId ( ) . toString ( ) , equalTo ( <str> ) ) ; } } public void testIndexOptionsNoExpandWildcards ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; { IndicesOptions noExpandLenient = IndicesOptions . fromOptions ( true , true , false , false ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , noExpandLenient ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , ( String [ ] ) null ) ; assertEquals ( <int> , results . length ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertEquals ( <int> , results . length ) ; } { IndicesOptions noExpandDisallowEmpty = IndicesOptions . fromOptions ( true , false , false , false ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , noExpandDisallowEmpty ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertEquals ( <str> , results [ <int> ] ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; } { IndicesOptions noExpandErrorUnavailable = IndicesOptions . fromOptions ( false , true , false , false ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , noExpandErrorUnavailable ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; } { IndicesOptions noExpandStrict = IndicesOptions . fromOptions ( false , false , false , false ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , noExpandStrict ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; } } public void testIndexOptionsSingleIndexNoExpandWildcards ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; try { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } try { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } try { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } try { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexClosedException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; assertEquals ( e . getIndex ( ) , <str> ) ; } IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertEquals ( <int> , results . length ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> ) ) ; } public void testIndexOptionsEmptyCluster ( ) { ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( MetaData . builder ( ) . build ( ) ) . build ( ) ; IndicesOptions options = IndicesOptions . strictExpandOpen ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertThat ( results , emptyArray ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getIndex ( ) , equalTo ( <str> ) ) ; } context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; assertThat ( results , emptyArray ( ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , false , true , false ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , Strings . EMPTY_ARRAY ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getResourceId ( ) . toString ( ) , equalTo ( <str> ) ) ; } } private IndexMetaData . Builder indexBuilder ( String index ) { return IndexMetaData . builder ( index ) . settings ( settings ( Version . CURRENT ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ; } public void testConcreteIndicesIgnoreIndicesOneMissingIndex ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpen ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( <str> ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testConcreteIndicesIgnoreIndicesOneMissingIndexOtherFound ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ) , equalTo ( newHashSet ( <str> ) ) ) ; } public void testConcreteIndicesIgnoreIndicesAllMissing ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpen ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> , <str> ) ; fail ( <str> ) ; } catch ( IndexNotFoundException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testConcreteIndicesIgnoreIndicesEmptyRequest ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) ) . put ( indexBuilder ( <str> ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , new String [ ] { } ) ) , equalTo ( newHashSet ( <str> , <str> ) ) ) ; } public void testConcreteIndicesWildcardExpansion ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) ) . put ( indexBuilder ( <str> ) . state ( State . CLOSE ) ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , true , false , false ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , <str> ) ) , equalTo ( new HashSet < String > ( ) ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , true , true , false ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , <str> ) ) , equalTo ( newHashSet ( <str> , <str> ) ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , true , false , true ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , <str> ) ) , equalTo ( newHashSet ( <str> ) ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , true , true , true ) ) ; assertThat ( newHashSet ( indexNameExpressionResolver . concreteIndices ( context , <str> ) ) , equalTo ( newHashSet ( <str> , <str> , <str> ) ) ) ; } public void testConcreteIndicesAllPatternRandom ( ) { for ( int i = <int> ; i < <int> ; i + + ) { String [ ] allIndices = null ; switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : break ; case <int> : allIndices = new String [ <int> ] ; break ; case <int> : allIndices = new String [ ] { MetaData . ALL } ; break ; } IndicesOptions indicesOptions = IndicesOptions . fromOptions ( randomBoolean ( ) , randomBoolean ( ) , randomBoolean ( ) , randomBoolean ( ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( MetaData . builder ( ) . build ( ) ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , indicesOptions ) ; if ( indicesOptions . allowNoIndices ( ) ) { String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( context , allIndices ) ; assertThat ( concreteIndices , notNullValue ( ) ) ; assertThat ( concreteIndices . length , equalTo ( <int> ) ) ; } else { checkCorrectException ( indexNameExpressionResolver , context , allIndices ) ; } MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( State . CLOSE ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; context = new IndexNameExpressionResolver . Context ( state , indicesOptions ) ; if ( indicesOptions . expandWildcardsOpen ( ) | | indicesOptions . expandWildcardsClosed ( ) | | indicesOptions . allowNoIndices ( ) ) { String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( context , allIndices ) ; assertThat ( concreteIndices , notNullValue ( ) ) ; int expectedNumberOfIndices = <int> ; if ( indicesOptions . expandWildcardsOpen ( ) ) { expectedNumberOfIndices + = <int> ; } if ( indicesOptions . expandWildcardsClosed ( ) ) { expectedNumberOfIndices + = <int> ; } assertThat ( concreteIndices . length , equalTo ( expectedNumberOfIndices ) ) ; } else { checkCorrectException ( indexNameExpressionResolver , context , allIndices ) ; } } } private void checkCorrectException ( IndexNameExpressionResolver indexNameExpressionResolver , IndexNameExpressionResolver . Context context , String [ ] allIndices ) { try { indexNameExpressionResolver . concreteIndices ( context , allIndices ) ; fail ( <str> ) ; } catch ( IndexNotFoundException e ) { } } public void testConcreteIndicesWildcardNoMatch ( ) { for ( int i = <int> ; i < <int> ; i + + ) { IndicesOptions indicesOptions = IndicesOptions . fromOptions ( randomBoolean ( ) , randomBoolean ( ) , randomBoolean ( ) , randomBoolean ( ) ) ; MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( State . OPEN ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( State . CLOSE ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , indicesOptions ) ; if ( indicesOptions . allowNoIndices ( ) ) { String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( concreteIndices , notNullValue ( ) ) ; assertThat ( concreteIndices . length , equalTo ( <int> ) ) ; } else { try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( <str> ) ; } catch ( IndexNotFoundException e ) { } } } } public void testIsAllIndicesNull ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( null ) , equalTo ( true ) ) ; } public void testIsAllIndicesEmpty ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( Collections . < String > emptyList ( ) ) , equalTo ( true ) ) ; } public void testIsAllIndicesExplicitAll ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( Arrays . asList ( <str> ) ) , equalTo ( true ) ) ; } public void testIsAllIndicesExplicitAllPlusOther ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( Arrays . asList ( <str> , <str> ) ) , equalTo ( false ) ) ; } public void testIsAllIndicesNormalIndexes ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( Arrays . asList ( <str> , <str> , <str> ) ) , equalTo ( false ) ) ; } public void testIsAllIndicesWildcard ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isAllIndices ( Arrays . asList ( <str> ) ) , equalTo ( false ) ) ; } public void testIsExplicitAllIndicesNull ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( null ) , equalTo ( false ) ) ; } public void testIsExplicitAllIndicesEmpty ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( Collections . < String > emptyList ( ) ) , equalTo ( false ) ) ; } public void testIsExplicitAllIndicesExplicitAll ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( Arrays . asList ( <str> ) ) , equalTo ( true ) ) ; } public void testIsExplicitAllIndicesExplicitAllPlusOther ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( Arrays . asList ( <str> , <str> ) ) , equalTo ( false ) ) ; } public void testIsExplicitAllIndicesNormalIndexes ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( Arrays . asList ( <str> , <str> , <str> ) ) , equalTo ( false ) ) ; } public void testIsExplicitAllIndicesWildcard ( ) throws Exception { assertThat ( IndexNameExpressionResolver . isExplicitAllPattern ( Arrays . asList ( <str> ) ) , equalTo ( false ) ) ; } public void testIsPatternMatchingAllIndicesExplicitList ( ) throws Exception { String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( concreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , concreteIndices , concreteIndices ) , equalTo ( false ) ) ; } public void testIsPatternMatchingAllIndicesOnlyWildcard ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( concreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( true ) ) ; } public void testIsPatternMatchingAllIndicesMatchingTrailingWildcard ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( concreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( true ) ) ; } public void testIsPatternMatchingAllIndicesNonMatchingTrailingWildcard ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; String [ ] allConcreteIndices = new String [ ] { <str> , <str> , <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( allConcreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( false ) ) ; } public void testIsPatternMatchingAllIndicesMatchingSingleExclusion ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> , <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( concreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( true ) ) ; } public void testIsPatternMatchingAllIndicesNonMatchingSingleExclusion ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> } ; String [ ] allConcreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( allConcreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( false ) ) ; } public void testIsPatternMatchingAllIndicesMatchingTrailingWildcardAndExclusion ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> , <str> , <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( concreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( true ) ) ; } public void testIsPatternMatchingAllIndicesNonMatchingTrailingWildcardAndExclusion ( ) throws Exception { String [ ] indicesOrAliases = new String [ ] { <str> , <str> } ; String [ ] concreteIndices = new String [ ] { <str> , <str> } ; String [ ] allConcreteIndices = new String [ ] { <str> , <str> , <str> } ; MetaData metaData = metaDataBuilder ( allConcreteIndices ) ; assertThat ( indexNameExpressionResolver . isPatternMatchingAllIndices ( metaData , indicesOrAliases , concreteIndices ) , equalTo ( false ) ) ; } public void testIndexOptionsFailClosedIndicesAndAliases ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) . putAlias ( AliasMetaData . builder ( <str> ) ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . state ( IndexMetaData . State . CLOSE ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpenAndForbidClosed ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( <str> ) ; } catch ( IndexClosedException e ) { } try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( <str> ) ; } catch ( IndexClosedException e ) { } context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , context . getOptions ( ) . allowNoIndices ( ) , context . getOptions ( ) . expandWildcardsOpen ( ) , context . getOptions ( ) . expandWildcardsClosed ( ) , context . getOptions ( ) ) ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , emptyArray ( ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , arrayWithSize ( <int> ) ) ; assertThat ( results , arrayContaining ( <str> ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , arrayWithSize ( <int> ) ) ; assertThat ( results , arrayContaining ( <str> ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . strictExpandOpenAndForbidClosed ( ) ) ; try { indexNameExpressionResolver . concreteIndices ( context , <str> ) ; fail ( <str> ) ; } catch ( IndexClosedException e ) { } context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . fromOptions ( true , context . getOptions ( ) . allowNoIndices ( ) , context . getOptions ( ) . expandWildcardsOpen ( ) , context . getOptions ( ) . expandWildcardsClosed ( ) , context . getOptions ( ) ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , arrayWithSize ( <int> ) ) ; assertThat ( results , arrayContaining ( <str> ) ) ; context = new IndexNameExpressionResolver . Context ( state , IndicesOptions . lenientExpandOpen ( ) ) ; results = indexNameExpressionResolver . concreteIndices ( context , <str> ) ; assertThat ( results , arrayWithSize ( <int> ) ) ; assertThat ( results , arrayContainingInAnyOrder ( <str> , <str> , <str> ) ) ; } public void testDedupConcreteIndices ( ) { MetaData . Builder mdBuilder = MetaData . builder ( ) . put ( indexBuilder ( <str> ) . putAlias ( AliasMetaData . builder ( <str> ) ) ) ; ClusterState state = ClusterState . builder ( new ClusterName ( <str> ) ) . metaData ( mdBuilder ) . build ( ) ; IndicesOptions [ ] indicesOptions = new IndicesOptions [ ] { IndicesOptions . strictExpandOpen ( ) , IndicesOptions . strictExpand ( ) , IndicesOptions . lenientExpandOpen ( ) , IndicesOptions . strictExpandOpenAndForbidClosed ( ) } ; for ( IndicesOptions options : indicesOptions ) { IndexNameExpressionResolver . Context context = new IndexNameExpressionResolver . Context ( state , options ) ; String [ ] results = indexNameExpressionResolver . concreteIndices ( context , <str> , <str> , <str> ) ; assertThat ( results , equalTo ( new String [ ] { <str> } ) ) ; } } private MetaData metaDataBuilder ( String . . . indices ) { MetaData . Builder mdBuilder = MetaData . builder ( ) ; for ( String concreteIndex : indices ) { mdBuilder . put ( indexBuilder ( concreteIndex ) ) ; } return mdBuilder . build ( ) ; } } 
