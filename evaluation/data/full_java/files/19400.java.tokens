package io . netty . handler . codec . http2 ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerAdapter ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultEventLoopGroup ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalServerChannel ; import io . netty . handler . codec . http2 . Http2TestUtil . FrameCountDown ; import io . netty . handler . codec . http2 . Http2TestUtil . Http2Runnable ; import io . netty . util . AsciiString ; import io . netty . util . concurrent . Future ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . io . ByteArrayOutputStream ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2TestUtil . randomString ; import static io . netty . handler . codec . http2 . Http2TestUtil . runInChannel ; import static io . netty . util . CharsetUtil . UTF_8 ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . doThrow ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; public class Http2ConnectionRoundtripTest { @Mock private Http2FrameListener clientListener ; @Mock private Http2FrameListener serverListener ; private Http2ConnectionHandler http2Client ; private ServerBootstrap sb ; private Bootstrap cb ; private Channel serverChannel ; private Channel clientChannel ; private FrameCountDown serverFrameCountDown ; private CountDownLatch requestLatch ; private CountDownLatch serverSettingsAckLatch ; private CountDownLatch dataLatch ; private CountDownLatch trailersLatch ; private CountDownLatch goAwayLatch ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; mockFlowControl ( clientListener ) ; mockFlowControl ( serverListener ) ; } @After public void teardown ( ) throws Exception { if ( clientChannel ! = null ) { clientChannel . close ( ) . sync ( ) ; clientChannel = null ; } if ( serverChannel ! = null ) { serverChannel . close ( ) . sync ( ) ; serverChannel = null ; } Future < ? > serverGroup = sb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > serverChildGroup = sb . childGroup ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > clientGroup = cb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; serverGroup . sync ( ) ; serverChildGroup . sync ( ) ; clientGroup . sync ( ) ; } @Test public void headersWithEndStreamShouldNotSendError ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> , <int> ) ; final short weight = <int> ; final Http2Headers headers = dummyHeaders ( ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , weight , false , <int> , true , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( requestLatch . await ( <int> , SECONDS ) ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) , eq ( weight ) , eq ( false ) , eq ( <int> ) , eq ( true ) ) ; Thread . sleep ( <int> ) ; verify ( serverListener , never ( ) ) . onGoAwayRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , anyLong ( ) , any ( ByteBuf . class ) ) ; verify ( serverListener , never ( ) ) . onRstStreamRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , anyLong ( ) ) ; http2Client . gracefulShutdownTimeoutMillis ( <int> ) ; } @Test public void http2ExceptionInPipelineShouldCloseConnection ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> , <int> ) ; final CountDownLatch closeLatch = new CountDownLatch ( <int> ) ; clientChannel . closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { closeLatch . countDown ( ) ; } } ) ; final Http2Headers headers = dummyHeaders ( ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , false , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; assertTrue ( requestLatch . await ( <int> , SECONDS ) ) ; clientChannel . pipeline ( ) . addFirst ( new ChannelHandlerAdapter ( ) { @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { throw Http2Exception . connectionError ( PROTOCOL_ERROR , <str> ) ; } } ) ; assertTrue ( closeLatch . await ( <int> , SECONDS ) ) ; assertFalse ( clientChannel . isOpen ( ) ) ; } @Test public void listenerExceptionShouldCloseConnection ( ) throws Exception { final Http2Headers headers = dummyHeaders ( ) ; doThrow ( new RuntimeException ( <str> ) ) . when ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( false ) , eq ( <int> ) , eq ( false ) ) ; bootstrapEnv ( <int> , <int> , <int> , <int> ) ; final CountDownLatch closeLatch = new CountDownLatch ( <int> ) ; clientChannel . closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { closeLatch . countDown ( ) ; } } ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , false , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; assertTrue ( requestLatch . await ( <int> , SECONDS ) ) ; assertTrue ( closeLatch . await ( <int> , SECONDS ) ) ; assertFalse ( clientChannel . isOpen ( ) ) ; } @Test public void nonHttp2ExceptionInPipelineShouldNotCloseConnection ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> , <int> ) ; final CountDownLatch closeLatch = new CountDownLatch ( <int> ) ; clientChannel . closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { closeLatch . countDown ( ) ; } } ) ; final Http2Headers headers = dummyHeaders ( ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , false , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; assertTrue ( requestLatch . await ( <int> , SECONDS ) ) ; clientChannel . pipeline ( ) . addFirst ( new ChannelHandlerAdapter ( ) { @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { throw new RuntimeException ( <str> ) ; } } ) ; assertFalse ( closeLatch . await ( <int> , SECONDS ) ) ; assertTrue ( clientChannel . isOpen ( ) ) ; http2Client . gracefulShutdownTimeoutMillis ( <int> ) ; } @Test public void noMoreStreamIdsShouldSendGoAway ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> , <int> , <int> ) ; http2Client . gracefulShutdownTimeoutMillis ( <int> ) ; final Http2Headers headers = dummyHeaders ( ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , true , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , Integer . MAX_VALUE + <int> , headers , <int> , ( short ) <int> , false , <int> , true , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( goAwayLatch . await ( <int> , SECONDS ) ) ; verify ( serverListener ) . onGoAwayRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( Http2Error . PROTOCOL_ERROR . code ( ) ) , any ( ByteBuf . class ) ) ; } @Test public void flowControlProperlyChunksLargeMessage ( ) throws Exception { final Http2Headers headers = dummyHeaders ( ) ; final int length = <int> ; final ByteBuf data = randomBytes ( length ) ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( length ) ; doAnswer ( new Answer < Integer > ( ) { @Override public Integer answer ( InvocationOnMock in ) throws Throwable { ByteBuf buf = ( ByteBuf ) in . getArguments ( ) [ <int> ] ; int padding = ( Integer ) in . getArguments ( ) [ <int> ] ; int processedBytes = buf . readableBytes ( ) + padding ; buf . readBytes ( out , buf . readableBytes ( ) ) ; return processedBytes ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , anyBoolean ( ) ) ; try { bootstrapEnv ( length , <int> , <int> , <int> ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , false , newPromise ( ) ) ; http2Client . encoder ( ) . writeData ( ctx ( ) , <int> , data . duplicate ( ) . retain ( ) , <int> , false , newPromise ( ) ) ; http2Client . encoder ( ) . writeHeaders ( ctx ( ) , <int> , headers , <int> , ( short ) <int> , false , <int> , true , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; assertTrue ( trailersLatch . await ( <int> , SECONDS ) ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( false ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( false ) , eq ( <int> ) , eq ( true ) ) ; assertEquals ( <int> , dataLatch . getCount ( ) ) ; out . flush ( ) ; byte [ ] received = out . toByteArray ( ) ; assertArrayEquals ( data . array ( ) , received ) ; } finally { http2Client . gracefulShutdownTimeoutMillis ( <int> ) ; data . release ( ) ; out . close ( ) ; } } @Test public void stressTest ( ) throws Exception { final Http2Headers headers = dummyHeaders ( ) ; final String pingMsg = <str> ; int length = <int> ; final ByteBuf data = randomBytes ( length ) ; final String dataAsHex = ByteBufUtil . hexDump ( data ) ; final ByteBuf pingData = Unpooled . copiedBuffer ( pingMsg , UTF_8 ) ; final int numStreams = <int> ; final String [ ] receivedPings = new String [ numStreams ] ; doAnswer ( new Answer < Void > ( ) { int nextIndex ; @Override public Void answer ( InvocationOnMock in ) throws Throwable { receivedPings [ nextIndex + + ] = ( ( ByteBuf ) in . getArguments ( ) [ <int> ] ) . toString ( UTF_8 ) ; return null ; } } ) . when ( serverListener ) . onPingRead ( any ( ChannelHandlerContext . class ) , any ( ByteBuf . class ) ) ; final StringBuilder [ ] receivedData = new StringBuilder [ numStreams ] ; doAnswer ( new Answer < Integer > ( ) { @Override public Integer answer ( InvocationOnMock in ) throws Throwable { int streamId = ( Integer ) in . getArguments ( ) [ <int> ] ; ByteBuf buf = ( ByteBuf ) in . getArguments ( ) [ <int> ] ; int padding = ( Integer ) in . getArguments ( ) [ <int> ] ; int processedBytes = buf . readableBytes ( ) + padding ; int streamIndex = ( streamId - <int> ) / <int> ; StringBuilder builder = receivedData [ streamIndex ] ; if ( builder = = null ) { builder = new StringBuilder ( dataAsHex . length ( ) ) ; receivedData [ streamIndex ] = builder ; } builder . append ( ByteBufUtil . hexDump ( buf ) ) ; return processedBytes ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) ) ; try { bootstrapEnv ( numStreams * length , <int> , numStreams * <int> , numStreams ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { int upperLimit = <int> + <int> * numStreams ; for ( int streamId = <int> ; streamId < upperLimit ; streamId + = <int> ) { http2Client . encoder ( ) . writeHeaders ( ctx ( ) , streamId , headers , <int> , ( short ) <int> , false , <int> , false , newPromise ( ) ) ; http2Client . encoder ( ) . writePing ( ctx ( ) , false , pingData . slice ( ) . retain ( ) , newPromise ( ) ) ; http2Client . encoder ( ) . writeData ( ctx ( ) , streamId , data . slice ( ) . retain ( ) , <int> , false , newPromise ( ) ) ; http2Client . encoder ( ) . writeHeaders ( ctx ( ) , streamId , headers , <int> , ( short ) <int> , false , <int> , true , newPromise ( ) ) ; http2Client . flush ( ctx ( ) ) ; } } } ) ; assertTrue ( serverSettingsAckLatch . await ( <int> , SECONDS ) ) ; assertTrue ( trailersLatch . await ( <int> , SECONDS ) ) ; verify ( serverListener , times ( numStreams ) ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( false ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener , times ( numStreams ) ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , eq ( headers ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( false ) , eq ( <int> ) , eq ( true ) ) ; verify ( serverListener , times ( numStreams ) ) . onPingRead ( any ( ChannelHandlerContext . class ) , any ( ByteBuf . class ) ) ; verify ( serverListener , never ( ) ) . onDataRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( true ) ) ; for ( StringBuilder builder : receivedData ) { assertEquals ( dataAsHex , builder . toString ( ) ) ; } for ( String receivedPing : receivedPings ) { assertEquals ( pingMsg , receivedPing ) ; } } finally { http2Client . gracefulShutdownTimeoutMillis ( <int> ) ; data . release ( ) ; pingData . release ( ) ; } } private void bootstrapEnv ( int dataCountDown , int settingsAckCount , int requestCountDown , int trailersCountDown ) throws Exception { bootstrapEnv ( dataCountDown , settingsAckCount , requestCountDown , trailersCountDown , - <int> ) ; } private void bootstrapEnv ( int dataCountDown , int settingsAckCount , int requestCountDown , int trailersCountDown , int goAwayCountDown ) throws Exception { requestLatch = new CountDownLatch ( requestCountDown ) ; serverSettingsAckLatch = new CountDownLatch ( settingsAckCount ) ; dataLatch = new CountDownLatch ( dataCountDown ) ; trailersLatch = new CountDownLatch ( trailersCountDown ) ; goAwayLatch = goAwayCountDown > <int> ? new CountDownLatch ( goAwayCountDown ) : requestLatch ; sb = new ServerBootstrap ( ) ; cb = new Bootstrap ( ) ; sb . group ( new DefaultEventLoopGroup ( ) ) ; sb . channel ( LocalServerChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; serverFrameCountDown = new FrameCountDown ( serverListener , serverSettingsAckLatch , requestLatch , dataLatch , trailersLatch , goAwayLatch ) ; p . addLast ( new Http2ConnectionHandler . Builder ( ) . server ( true ) . frameListener ( serverFrameCountDown ) . validateHeaders ( false ) . build ( ) ) ; } } ) ; cb . group ( new DefaultEventLoopGroup ( ) ) ; cb . channel ( LocalChannel . class ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; p . addLast ( new Http2ConnectionHandler . Builder ( ) . server ( false ) . frameListener ( clientListener ) . validateHeaders ( false ) . build ( ) ) ; } } ) ; serverChannel = sb . bind ( new LocalAddress ( <str> ) ) . sync ( ) . channel ( ) ; ChannelFuture ccf = cb . connect ( serverChannel . localAddress ( ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; clientChannel = ccf . channel ( ) ; http2Client = clientChannel . pipeline ( ) . get ( Http2ConnectionHandler . class ) ; } private ChannelHandlerContext ctx ( ) { return clientChannel . pipeline ( ) . firstContext ( ) ; } private ChannelPromise newPromise ( ) { return ctx ( ) . newPromise ( ) ; } private static Http2Headers dummyHeaders ( ) { return new DefaultHttp2Headers ( false ) . method ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . add ( randomString ( ) , randomString ( ) ) ; } private void mockFlowControl ( Http2FrameListener listener ) throws Http2Exception { doAnswer ( new Answer < Integer > ( ) { @Override public Integer answer ( InvocationOnMock invocation ) throws Throwable { ByteBuf buf = ( ByteBuf ) invocation . getArguments ( ) [ <int> ] ; int padding = ( Integer ) invocation . getArguments ( ) [ <int> ] ; int processedBytes = buf . readableBytes ( ) + padding ; return processedBytes ; } } ) . when ( listener ) . onDataRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) ) ; } private static ByteBuf randomBytes ( int length ) { final byte [ ] bytes = new byte [ length ] ; new Random ( ) . nextBytes ( bytes ) ; return Unpooled . wrappedBuffer ( bytes ) ; } } 
