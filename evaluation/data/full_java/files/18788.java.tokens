package io . netty . buffer ; import io . netty . util . internal . PlatformDependent ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . ScatteringByteChannel ; public class UnpooledUnsafeDirectByteBuf extends AbstractReferenceCountedByteBuf { private final ByteBufAllocator alloc ; private long memoryAddress ; private ByteBuffer buffer ; private ByteBuffer tmpNioBuf ; private int capacity ; private boolean doNotFree ; protected UnpooledUnsafeDirectByteBuf ( ByteBufAllocator alloc , int initialCapacity , int maxCapacity ) { super ( maxCapacity ) ; if ( alloc = = null ) { throw new NullPointerException ( <str> ) ; } if ( initialCapacity < <int> ) { throw new IllegalArgumentException ( <str> + initialCapacity ) ; } if ( maxCapacity < <int> ) { throw new IllegalArgumentException ( <str> + maxCapacity ) ; } if ( initialCapacity > maxCapacity ) { throw new IllegalArgumentException ( String . format ( <str> , initialCapacity , maxCapacity ) ) ; } this . alloc = alloc ; setByteBuffer ( allocateDirect ( initialCapacity ) ) ; } protected UnpooledUnsafeDirectByteBuf ( ByteBufAllocator alloc , ByteBuffer initialBuffer , int maxCapacity ) { super ( maxCapacity ) ; if ( alloc = = null ) { throw new NullPointerException ( <str> ) ; } if ( initialBuffer = = null ) { throw new NullPointerException ( <str> ) ; } if ( ! initialBuffer . isDirect ( ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( initialBuffer . isReadOnly ( ) ) { throw new IllegalArgumentException ( <str> ) ; } int initialCapacity = initialBuffer . remaining ( ) ; if ( initialCapacity > maxCapacity ) { throw new IllegalArgumentException ( String . format ( <str> , initialCapacity , maxCapacity ) ) ; } this . alloc = alloc ; doNotFree = true ; setByteBuffer ( initialBuffer . slice ( ) . order ( ByteOrder . BIG_ENDIAN ) ) ; writerIndex ( initialCapacity ) ; } protected ByteBuffer allocateDirect ( int initialCapacity ) { return ByteBuffer . allocateDirect ( initialCapacity ) ; } protected void freeDirect ( ByteBuffer buffer ) { PlatformDependent . freeDirectBuffer ( buffer ) ; } private void setByteBuffer ( ByteBuffer buffer ) { ByteBuffer oldBuffer = this . buffer ; if ( oldBuffer ! = null ) { if ( doNotFree ) { doNotFree = false ; } else { freeDirect ( oldBuffer ) ; } } this . buffer = buffer ; memoryAddress = PlatformDependent . directBufferAddress ( buffer ) ; tmpNioBuf = null ; capacity = buffer . remaining ( ) ; } @Override public boolean isDirect ( ) { return true ; } @Override public int capacity ( ) { return capacity ; } @Override public ByteBuf capacity ( int newCapacity ) { ensureAccessible ( ) ; if ( newCapacity < <int> | | newCapacity > maxCapacity ( ) ) { throw new IllegalArgumentException ( <str> + newCapacity ) ; } int readerIndex = readerIndex ( ) ; int writerIndex = writerIndex ( ) ; int oldCapacity = capacity ; if ( newCapacity > oldCapacity ) { ByteBuffer oldBuffer = buffer ; ByteBuffer newBuffer = allocateDirect ( newCapacity ) ; oldBuffer . position ( <int> ) . limit ( oldBuffer . capacity ( ) ) ; newBuffer . position ( <int> ) . limit ( oldBuffer . capacity ( ) ) ; newBuffer . put ( oldBuffer ) ; newBuffer . clear ( ) ; setByteBuffer ( newBuffer ) ; } else if ( newCapacity < oldCapacity ) { ByteBuffer oldBuffer = buffer ; ByteBuffer newBuffer = allocateDirect ( newCapacity ) ; if ( readerIndex < newCapacity ) { if ( writerIndex > newCapacity ) { writerIndex ( writerIndex = newCapacity ) ; } oldBuffer . position ( readerIndex ) . limit ( writerIndex ) ; newBuffer . position ( readerIndex ) . limit ( writerIndex ) ; newBuffer . put ( oldBuffer ) ; newBuffer . clear ( ) ; } else { setIndex ( newCapacity , newCapacity ) ; } setByteBuffer ( newBuffer ) ; } return this ; } @Override public ByteBufAllocator alloc ( ) { return alloc ; } @Override public ByteOrder order ( ) { return ByteOrder . BIG_ENDIAN ; } @Override public boolean hasArray ( ) { return false ; } @Override public byte [ ] array ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public int arrayOffset ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public boolean hasMemoryAddress ( ) { return true ; } @Override public long memoryAddress ( ) { ensureAccessible ( ) ; return memoryAddress ; } @Override protected byte _getByte ( int index ) { return UnsafeByteBufUtil . getByte ( addr ( index ) ) ; } @Override protected short _getShort ( int index ) { return UnsafeByteBufUtil . getShort ( addr ( index ) ) ; } @Override protected short _getShortLE ( int index ) { return UnsafeByteBufUtil . getShortLE ( addr ( index ) ) ; } @Override protected int _getUnsignedMedium ( int index ) { return UnsafeByteBufUtil . getUnsignedMedium ( addr ( index ) ) ; } @Override protected int _getUnsignedMediumLE ( int index ) { return UnsafeByteBufUtil . getUnsignedMediumLE ( addr ( index ) ) ; } @Override protected int _getInt ( int index ) { return UnsafeByteBufUtil . getInt ( addr ( index ) ) ; } @Override protected int _getIntLE ( int index ) { return UnsafeByteBufUtil . getIntLE ( addr ( index ) ) ; } @Override protected long _getLong ( int index ) { return UnsafeByteBufUtil . getLong ( addr ( index ) ) ; } @Override protected long _getLongLE ( int index ) { return UnsafeByteBufUtil . getLongLE ( addr ( index ) ) ; } @Override public ByteBuf getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { UnsafeByteBufUtil . getBytes ( this , addr ( index ) , index , dst , dstIndex , length ) ; return this ; } @Override public ByteBuf getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { UnsafeByteBufUtil . getBytes ( this , addr ( index ) , index , dst , dstIndex , length ) ; return this ; } @Override public ByteBuf getBytes ( int index , ByteBuffer dst ) { UnsafeByteBufUtil . getBytes ( this , addr ( index ) , index , dst ) ; return this ; } @Override public ByteBuf readBytes ( ByteBuffer dst ) { int length = dst . remaining ( ) ; checkReadableBytes ( length ) ; getBytes ( readerIndex , dst ) ; readerIndex + = length ; return this ; } @Override protected void _setByte ( int index , int value ) { UnsafeByteBufUtil . setByte ( addr ( index ) , value ) ; } @Override protected void _setShort ( int index , int value ) { UnsafeByteBufUtil . setShort ( addr ( index ) , value ) ; } @Override protected void _setShortLE ( int index , int value ) { UnsafeByteBufUtil . setShortLE ( addr ( index ) , value ) ; } @Override protected void _setMedium ( int index , int value ) { UnsafeByteBufUtil . setMedium ( addr ( index ) , value ) ; } @Override protected void _setMediumLE ( int index , int value ) { UnsafeByteBufUtil . setMediumLE ( addr ( index ) , value ) ; } @Override protected void _setInt ( int index , int value ) { UnsafeByteBufUtil . setInt ( addr ( index ) , value ) ; } @Override protected void _setIntLE ( int index , int value ) { UnsafeByteBufUtil . setIntLE ( addr ( index ) , value ) ; } @Override protected void _setLong ( int index , long value ) { UnsafeByteBufUtil . setLong ( addr ( index ) , value ) ; } @Override protected void _setLongLE ( int index , long value ) { UnsafeByteBufUtil . setLongLE ( addr ( index ) , value ) ; } @Override public ByteBuf setBytes ( int index , ByteBuf src , int srcIndex , int length ) { UnsafeByteBufUtil . setBytes ( this , addr ( index ) , index , src , srcIndex , length ) ; return this ; } @Override public ByteBuf setBytes ( int index , byte [ ] src , int srcIndex , int length ) { UnsafeByteBufUtil . setBytes ( this , addr ( index ) , index , src , srcIndex , length ) ; return this ; } @Override public ByteBuf setBytes ( int index , ByteBuffer src ) { UnsafeByteBufUtil . setBytes ( this , addr ( index ) , index , src ) ; return this ; } @Override public ByteBuf getBytes ( int index , OutputStream out , int length ) throws IOException { UnsafeByteBufUtil . getBytes ( this , addr ( index ) , index , out , length ) ; return this ; } @Override public int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException { return getBytes ( index , out , length , false ) ; } private int getBytes ( int index , GatheringByteChannel out , int length , boolean internal ) throws IOException { ensureAccessible ( ) ; if ( length = = <int> ) { return <int> ; } ByteBuffer tmpBuf ; if ( internal ) { tmpBuf = internalNioBuffer ( ) ; } else { tmpBuf = buffer . duplicate ( ) ; } tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; return out . write ( tmpBuf ) ; } @Override public int readBytes ( GatheringByteChannel out , int length ) throws IOException { checkReadableBytes ( length ) ; int readBytes = getBytes ( readerIndex , out , length , true ) ; readerIndex + = readBytes ; return readBytes ; } @Override public int setBytes ( int index , InputStream in , int length ) throws IOException { return UnsafeByteBufUtil . setBytes ( this , addr ( index ) , index , in , length ) ; } @Override public int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException { ensureAccessible ( ) ; ByteBuffer tmpBuf = internalNioBuffer ( ) ; tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; try { return in . read ( tmpBuf ) ; } catch ( ClosedChannelException ignored ) { return - <int> ; } } @Override public int nioBufferCount ( ) { return <int> ; } @Override public ByteBuffer [ ] nioBuffers ( int index , int length ) { return new ByteBuffer [ ] { nioBuffer ( index , length ) } ; } @Override public ByteBuf copy ( int index , int length ) { return UnsafeByteBufUtil . copy ( this , addr ( index ) , index , length ) ; } @Override public ByteBuffer internalNioBuffer ( int index , int length ) { checkIndex ( index , length ) ; return ( ByteBuffer ) internalNioBuffer ( ) . clear ( ) . position ( index ) . limit ( index + length ) ; } private ByteBuffer internalNioBuffer ( ) { ByteBuffer tmpNioBuf = this . tmpNioBuf ; if ( tmpNioBuf = = null ) { this . tmpNioBuf = tmpNioBuf = buffer . duplicate ( ) ; } return tmpNioBuf ; } @Override public ByteBuffer nioBuffer ( int index , int length ) { checkIndex ( index , length ) ; return ( ( ByteBuffer ) buffer . duplicate ( ) . position ( index ) . limit ( index + length ) ) . slice ( ) ; } @Override protected void deallocate ( ) { ByteBuffer buffer = this . buffer ; if ( buffer = = null ) { return ; } this . buffer = null ; if ( ! doNotFree ) { freeDirect ( buffer ) ; } } @Override public ByteBuf unwrap ( ) { return null ; } long addr ( int index ) { return memoryAddress + index ; } @Override protected SwappedByteBuf newSwappedByteBuf ( ) { if ( PlatformDependent . isUnaligned ( ) ) { return new UnsafeDirectSwappedByteBuf ( this ) ; } return super . newSwappedByteBuf ( ) ; } } 
