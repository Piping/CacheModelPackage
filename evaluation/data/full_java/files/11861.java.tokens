package org . gradle . cache . internal . btree ; import com . google . common . io . CountingInputStream ; import com . google . common . io . CountingOutputStream ; import org . gradle . api . UncheckedIOException ; import org . gradle . internal . io . RandomAccessFileInputStream ; import org . gradle . internal . io . RandomAccessFileOutputStream ; import java . io . * ; public class FileBackedBlockStore implements BlockStore { private RandomAccessFile file ; private final File cacheFile ; private long nextBlock ; private Factory factory ; private long currentFileSize ; public FileBackedBlockStore ( File cacheFile ) { this . cacheFile = cacheFile ; } @Override public String toString ( ) { return String . format ( <str> , cacheFile ) ; } public void open ( Runnable runnable , Factory factory ) { this . factory = factory ; try { cacheFile . getParentFile ( ) . mkdirs ( ) ; file = new RandomAccessFile ( cacheFile , <str> ) ; currentFileSize = file . length ( ) ; nextBlock = currentFileSize ; if ( currentFileSize = = <int> ) { runnable . run ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public void close ( ) { try { file . close ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public void clear ( ) { try { file . setLength ( <int> ) ; currentFileSize = <int> ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } nextBlock = <int> ; } public void attach ( BlockPayload block ) { if ( block . getBlock ( ) = = null ) { block . setBlock ( new BlockImpl ( block ) ) ; } } public void remove ( BlockPayload block ) { BlockImpl blockImpl = ( BlockImpl ) block . getBlock ( ) ; blockImpl . detach ( ) ; } public void flush ( ) { } public < T extends BlockPayload > T readFirst ( Class < T > payloadType ) { return read ( new BlockPointer ( <int> ) , payloadType ) ; } public < T extends BlockPayload > T read ( BlockPointer pos , Class < T > payloadType ) { assert ! pos . isNull ( ) ; try { T payload = payloadType . cast ( factory . create ( payloadType ) ) ; BlockImpl block = new BlockImpl ( payload , pos ) ; block . read ( ) ; return payload ; } catch ( CorruptedCacheException e ) { throw e ; } catch ( Exception e ) { throw new UncheckedIOException ( e ) ; } } public void write ( BlockPayload block ) { BlockImpl blockImpl = ( BlockImpl ) block . getBlock ( ) ; try { blockImpl . write ( ) ; } catch ( CorruptedCacheException e ) { throw e ; } catch ( Exception e ) { throw new UncheckedIOException ( e ) ; } } private long alloc ( long length ) { long pos = nextBlock ; nextBlock + = length ; return pos ; } private final class BlockImpl extends Block { private static final int HEADER_SIZE = <int> + INT_SIZE ; private static final int TAIL_SIZE = LONG_SIZE ; static final int BLOCK_MARKER = <hex> ; private BlockPointer pos ; private int payloadSize ; private BlockImpl ( BlockPayload payload , BlockPointer pos ) { this ( payload ) ; setPos ( pos ) ; } public BlockImpl ( BlockPayload payload ) { super ( payload ) ; pos = null ; payloadSize = - <int> ; } @Override public boolean hasPos ( ) { return pos ! = null ; } @Override public BlockPointer getPos ( ) { if ( pos = = null ) { pos = new BlockPointer ( alloc ( getSize ( ) ) ) ; } return pos ; } @Override public void setPos ( BlockPointer pos ) { assert this . pos = = null & & ! pos . isNull ( ) ; this . pos = pos ; } public int getSize ( ) { if ( payloadSize < <int> ) { payloadSize = getPayload ( ) . getSize ( ) ; } return payloadSize + HEADER_SIZE + TAIL_SIZE ; } @Override public void setSize ( int size ) { int newPayloadSize = size - HEADER_SIZE - TAIL_SIZE ; assert newPayloadSize > = payloadSize ; payloadSize = newPayloadSize ; } public void write ( ) throws Exception { long pos = getPos ( ) . getPos ( ) ; file . seek ( pos ) ; CountingOutputStream countingOutputStream = new CountingOutputStream ( new BufferedOutputStream ( new RandomAccessFileOutputStream ( file ) ) ) ; DataOutputStream outputStream = new DataOutputStream ( countingOutputStream ) ; BlockPayload payload = getPayload ( ) ; outputStream . writeByte ( BLOCK_MARKER ) ; outputStream . writeByte ( payload . getType ( ) ) ; outputStream . writeInt ( payloadSize ) ; long finalSize = pos + HEADER_SIZE + TAIL_SIZE + payloadSize ; payload . write ( outputStream ) ; outputStream . writeLong ( countingOutputStream . getCount ( ) ) ; outputStream . close ( ) ; if ( currentFileSize < finalSize ) { file . setLength ( finalSize ) ; currentFileSize = finalSize ; } } public void read ( ) throws Exception { long pos = getPos ( ) . getPos ( ) ; assert pos > = <int> ; if ( pos + HEADER_SIZE > = currentFileSize ) { throw blockCorruptedException ( ) ; } file . seek ( pos ) ; CountingInputStream countingInputStream = new CountingInputStream ( new BufferedInputStream ( new RandomAccessFileInputStream ( file ) ) ) ; DataInputStream inputStream = new DataInputStream ( countingInputStream ) ; BlockPayload payload = getPayload ( ) ; byte type = inputStream . readByte ( ) ; if ( type ! = ( byte ) BLOCK_MARKER ) { throw blockCorruptedException ( ) ; } type = inputStream . readByte ( ) ; if ( type ! = ( byte ) payload . getType ( ) ) { throw blockCorruptedException ( ) ; } payloadSize = inputStream . readInt ( ) ; if ( pos + HEADER_SIZE + TAIL_SIZE + payloadSize > currentFileSize ) { throw blockCorruptedException ( ) ; } payload . read ( inputStream ) ; long actualCount = countingInputStream . getCount ( ) ; long count = inputStream . readLong ( ) ; if ( actualCount ! = count ) { throw blockCorruptedException ( ) ; } inputStream . close ( ) ; } public RuntimeException blockCorruptedException ( ) { return new CorruptedCacheException ( String . format ( <str> , this , FileBackedBlockStore . this ) ) ; } } } 
