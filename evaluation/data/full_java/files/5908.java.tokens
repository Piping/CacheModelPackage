package org . elasticsearch . common . inject . spi ; import org . elasticsearch . common . inject . Binder ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . Provider ; import java . util . Objects ; public final class ProviderLookup < T > implements Element { public static class ProviderImpl < T > implements Provider < T > { private ProviderLookup < T > lookup ; private ProviderImpl ( ProviderLookup < T > lookup ) { this . lookup = lookup ; } @Override public T get ( ) { if ( lookup . delegate = = null ) { throw new IllegalStateException ( <str> ) ; } return lookup . delegate . get ( ) ; } @Override public String toString ( ) { return <str> + lookup . key . getTypeLiteral ( ) + <str> ; } public Key < T > getKey ( ) { return lookup . getKey ( ) ; } } private final Object source ; private final Key < T > key ; private Provider < T > delegate ; public ProviderLookup ( Object source , Key < T > key ) { this . source = Objects . requireNonNull ( source , <str> ) ; this . key = Objects . requireNonNull ( key , <str> ) ; } @Override public Object getSource ( ) { return source ; } public Key < T > getKey ( ) { return key ; } @Override public < T > T acceptVisitor ( ElementVisitor < T > visitor ) { return visitor . visit ( this ) ; } public void initializeDelegate ( Provider < T > delegate ) { if ( this . delegate ! = null ) { throw new IllegalStateException ( <str> ) ; } this . delegate = Objects . requireNonNull ( delegate , <str> ) ; } @Override public void applyTo ( Binder binder ) { initializeDelegate ( binder . withSource ( getSource ( ) ) . getProvider ( key ) ) ; } public Provider < T > getDelegate ( ) { return delegate ; } public Provider < T > getProvider ( ) { return new ProviderImpl < > ( this ) ; } } 
