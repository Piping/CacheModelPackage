package org . elasticsearch . index . search ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . MultiMatchQueryBuilder ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . junit . Before ; import java . io . IOException ; import java . util . Arrays ; import static org . elasticsearch . index . query . QueryBuilders . multiMatchQuery ; public class MultiMatchQueryTests extends ESSingleNodeTestCase { private IndexService indexService ; @Before public void setup ( ) throws IOException { IndexService indexService = createIndex ( <str> ) ; MapperService mapperService = indexService . mapperService ( ) ; String mapping = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; mapperService . merge ( <str> , new CompressedXContent ( mapping ) , true , false ) ; this . indexService = indexService ; } public void testCrossFieldMultiMatchQuery ( ) throws IOException { QueryShardContext queryShardContext = indexService . getShard ( <int> ) . getQueryShardContext ( ) ; queryShardContext . setAllowUnmappedFields ( true ) ; Query parsedQuery = multiMatchQuery ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . field ( <str> ) . type ( MultiMatchQueryBuilder . Type . CROSS_FIELDS ) . toQuery ( queryShardContext ) ; try ( Engine . Searcher searcher = indexService . getShard ( <int> ) . acquireSearcher ( <str> ) ) { Query rewrittenQuery = searcher . searcher ( ) . rewrite ( parsedQuery ) ; BooleanQuery . Builder expected = new BooleanQuery . Builder ( ) ; expected . add ( new TermQuery ( new Term ( <str> , <str> ) ) , BooleanClause . Occur . SHOULD ) ; Query tq1 = new BoostQuery ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) ; Query tq2 = new BoostQuery ( new TermQuery ( new Term ( <str> , <str> ) ) , <int> ) ; expected . add ( new DisjunctionMaxQuery ( Arrays . < Query > asList ( tq1 , tq2 ) , <float> ) , BooleanClause . Occur . SHOULD ) ; assertEquals ( expected . build ( ) , rewrittenQuery ) ; } } } 
