package org . gradle . api . internal . file . collections ; import groovy . lang . Closure ; import org . gradle . api . Task ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . internal . file . FileCollectionInternal ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . internal . file . FileTreeInternal ; import org . gradle . api . internal . file . IdentityFileResolver ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . api . tasks . TaskOutputs ; import org . gradle . internal . Cast ; import org . gradle . internal . UncheckedException ; import org . gradle . util . GUtil ; import java . io . File ; import java . util . * ; import java . util . concurrent . Callable ; public class DefaultFileCollectionResolveContext implements ResolvableFileCollectionResolveContext { private final FileResolver fileResolver ; private final List < Object > queue = new LinkedList < Object > ( ) ; private List < Object > addTo = queue ; private final Converter < ? extends FileCollectionInternal > fileCollectionConverter ; private final Converter < ? extends FileTreeInternal > fileTreeConverter ; public DefaultFileCollectionResolveContext ( ) { this ( new IdentityFileResolver ( ) ) ; } public DefaultFileCollectionResolveContext ( FileResolver fileResolver ) { this . fileResolver = fileResolver ; fileCollectionConverter = new FileCollectionConverter ( ) ; fileTreeConverter = new FileTreeConverter ( ) ; } protected DefaultFileCollectionResolveContext ( FileResolver fileResolver , Converter < ? extends FileCollectionInternal > fileCollectionConverter , Converter < ? extends FileTreeInternal > fileTreeConverter ) { this . fileResolver = fileResolver ; this . fileCollectionConverter = fileCollectionConverter ; this . fileTreeConverter = fileTreeConverter ; } public DefaultFileCollectionResolveContext add ( Object element ) { addTo . add ( element ) ; return this ; } public DefaultFileCollectionResolveContext push ( FileResolver fileResolver ) { DefaultFileCollectionResolveContext nestedContext = new DefaultFileCollectionResolveContext ( fileResolver , fileCollectionConverter , fileTreeConverter ) ; add ( nestedContext ) ; return nestedContext ; } public ResolvableFileCollectionResolveContext newContext ( ) { return new DefaultFileCollectionResolveContext ( fileResolver , fileCollectionConverter , fileTreeConverter ) ; } public List < FileTreeInternal > resolveAsFileTrees ( ) { return doResolve ( fileTreeConverter ) ; } public List < FileCollectionInternal > resolveAsFileCollections ( ) { return doResolve ( fileCollectionConverter ) ; } public List < MinimalFileCollection > resolveAsMinimalFileCollections ( ) { return doResolve ( new MinimalFileCollectionConverter ( ) ) ; } private < T > List < T > doResolve ( Converter < ? extends T > converter ) { List < T > result = new ArrayList < T > ( ) ; while ( ! queue . isEmpty ( ) ) { Object element = queue . remove ( <int> ) ; if ( element instanceof DefaultFileCollectionResolveContext ) { DefaultFileCollectionResolveContext nestedContext = ( DefaultFileCollectionResolveContext ) element ; converter . convertInto ( nestedContext , result , fileResolver ) ; } else if ( element instanceof FileCollectionContainer ) { FileCollectionContainer fileCollection = ( FileCollectionContainer ) element ; resolveNested ( fileCollection ) ; } else if ( element instanceof FileCollection | | element instanceof MinimalFileCollection ) { converter . convertInto ( element , result , fileResolver ) ; } else if ( element instanceof Task ) { Task task = ( Task ) element ; queue . add ( <int> , task . getOutputs ( ) . getFiles ( ) ) ; } else if ( element instanceof TaskOutputs ) { TaskOutputs outputs = ( TaskOutputs ) element ; queue . add ( <int> , outputs . getFiles ( ) ) ; } else if ( element instanceof Closure ) { Closure closure = ( Closure ) element ; Object closureResult = closure . call ( ) ; if ( closureResult ! = null ) { queue . add ( <int> , closureResult ) ; } } else if ( element instanceof Callable ) { Callable callable = ( Callable ) element ; Object callableResult ; try { callableResult = callable . call ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } if ( callableResult ! = null ) { queue . add ( <int> , callableResult ) ; } } else if ( element instanceof Iterable ) { Iterable < ? > iterable = ( Iterable ) element ; GUtil . addToCollection ( queue . subList ( <int> , <int> ) , iterable ) ; } else if ( element instanceof Object [ ] ) { Object [ ] array = ( Object [ ] ) element ; GUtil . addToCollection ( queue . subList ( <int> , <int> ) , Arrays . asList ( array ) ) ; } else { converter . convertInto ( element , result , fileResolver ) ; } } return result ; } private void resolveNested ( FileCollectionContainer fileCollection ) { addTo = queue . subList ( <int> , <int> ) ; try { fileCollection . visitContents ( this ) ; } finally { addTo = queue ; } } protected interface Converter < T > { void convertInto ( Object element , Collection < ? super T > result , FileResolver resolver ) ; } private static class FileCollectionConverter implements Converter < FileCollectionInternal > { public void convertInto ( Object element , Collection < ? super FileCollectionInternal > result , FileResolver fileResolver ) { if ( element instanceof DefaultFileCollectionResolveContext ) { DefaultFileCollectionResolveContext nestedContext = ( DefaultFileCollectionResolveContext ) element ; result . addAll ( nestedContext . resolveAsFileCollections ( ) ) ; } else if ( element instanceof FileCollection ) { FileCollection fileCollection = ( FileCollection ) element ; result . add ( Cast . cast ( FileCollectionInternal . class , fileCollection ) ) ; } else if ( element instanceof MinimalFileTree ) { MinimalFileTree fileTree = ( MinimalFileTree ) element ; result . add ( new FileTreeAdapter ( fileTree ) ) ; } else if ( element instanceof MinimalFileSet ) { MinimalFileSet fileSet = ( MinimalFileSet ) element ; result . add ( new FileCollectionAdapter ( fileSet ) ) ; } else if ( element instanceof MinimalFileCollection ) { throw new UnsupportedOperationException ( String . format ( <str> , element . getClass ( ) . getSimpleName ( ) ) ) ; } else if ( element instanceof TaskDependency ) { return ; } else { result . add ( new FileCollectionAdapter ( new ListBackedFileSet ( fileResolver . resolve ( element ) ) ) ) ; } } } private static class FileTreeConverter implements Converter < FileTreeInternal > { public void convertInto ( Object element , Collection < ? super FileTreeInternal > result , FileResolver fileResolver ) { if ( element instanceof DefaultFileCollectionResolveContext ) { DefaultFileCollectionResolveContext nestedContext = ( DefaultFileCollectionResolveContext ) element ; result . addAll ( nestedContext . resolveAsFileTrees ( ) ) ; } else if ( element instanceof FileTree ) { FileTree fileTree = ( FileTree ) element ; result . add ( Cast . cast ( FileTreeInternal . class , fileTree ) ) ; } else if ( element instanceof MinimalFileTree ) { MinimalFileTree fileTree = ( MinimalFileTree ) element ; result . add ( new FileTreeAdapter ( fileTree ) ) ; } else if ( element instanceof MinimalFileSet ) { MinimalFileSet fileSet = ( MinimalFileSet ) element ; for ( File file : fileSet . getFiles ( ) ) { convertFileToFileTree ( file , result ) ; } } else if ( element instanceof FileCollection ) { FileCollection fileCollection = ( FileCollection ) element ; for ( File file : fileCollection . getFiles ( ) ) { convertFileToFileTree ( file , result ) ; } } else if ( element instanceof MinimalFileCollection ) { throw new UnsupportedOperationException ( String . format ( <str> , element . getClass ( ) . getSimpleName ( ) ) ) ; } else if ( element instanceof TaskDependency ) { return ; } else { convertFileToFileTree ( fileResolver . resolve ( element ) , result ) ; } } private void convertFileToFileTree ( File file , Collection < ? super FileTreeInternal > result ) { if ( file . isDirectory ( ) ) { result . add ( new FileTreeAdapter ( new DirectoryFileTree ( file ) ) ) ; } else if ( file . isFile ( ) ) { result . add ( new FileTreeAdapter ( new SingletonFileTree ( file ) ) ) ; } } } private static class MinimalFileCollectionConverter implements Converter < MinimalFileCollection > { public void convertInto ( Object element , Collection < ? super MinimalFileCollection > result , FileResolver resolver ) { if ( element instanceof DefaultFileCollectionResolveContext ) { DefaultFileCollectionResolveContext nestedContext = ( DefaultFileCollectionResolveContext ) element ; result . addAll ( nestedContext . resolveAsMinimalFileCollections ( ) ) ; } else if ( element instanceof MinimalFileCollection ) { MinimalFileCollection collection = ( MinimalFileCollection ) element ; result . add ( collection ) ; } else if ( element instanceof FileCollection ) { throw new UnsupportedOperationException ( String . format ( <str> , element . getClass ( ) . getSimpleName ( ) ) ) ; } else if ( element instanceof TaskDependency ) { return ; } else { result . add ( new ListBackedFileSet ( resolver . resolve ( element ) ) ) ; } } } } 
