package org . elasticsearch . test ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . transport . TransportClient ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . plugins . Plugin ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . nio . file . Path ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . concurrent . atomic . AtomicInteger ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . assertThat ; public final class ExternalTestCluster extends TestCluster { private static final ESLogger logger = Loggers . getLogger ( ExternalTestCluster . class ) ; private static final AtomicInteger counter = new AtomicInteger ( ) ; public static final String EXTERNAL_CLUSTER_PREFIX = <str> ; private final Client client ; private final InetSocketAddress [ ] httpAddresses ; private final String clusterName ; private final int numDataNodes ; private final int numMasterAndDataNodes ; public ExternalTestCluster ( Path tempDir , Settings additionalSettings , Collection < Class < ? extends Plugin > > pluginClasses , TransportAddress . . . transportAddresses ) { super ( <int> ) ; Settings clientSettings = Settings . settingsBuilder ( ) . put ( additionalSettings ) . put ( <str> , InternalTestCluster . TRANSPORT_CLIENT_PREFIX + EXTERNAL_CLUSTER_PREFIX + counter . getAndIncrement ( ) ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . put ( <str> , true ) . put ( <str> , tempDir ) . put ( <str> , <str> ) . build ( ) ; TransportClient . Builder transportClientBuilder = TransportClient . builder ( ) . settings ( clientSettings ) ; for ( Class < ? extends Plugin > pluginClass : pluginClasses ) { transportClientBuilder . addPlugin ( pluginClass ) ; } TransportClient client = transportClientBuilder . build ( ) ; try { client . addTransportAddresses ( transportAddresses ) ; NodesInfoResponse nodeInfos = client . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . clear ( ) . setSettings ( true ) . setHttp ( true ) . get ( ) ; httpAddresses = new InetSocketAddress [ nodeInfos . getNodes ( ) . length ] ; this . clusterName = nodeInfos . getClusterName ( ) . value ( ) ; int dataNodes = <int> ; int masterAndDataNodes = <int> ; for ( int i = <int> ; i < nodeInfos . getNodes ( ) . length ; i + + ) { NodeInfo nodeInfo = nodeInfos . getNodes ( ) [ i ] ; httpAddresses [ i ] = ( ( InetSocketTransportAddress ) nodeInfo . getHttp ( ) . address ( ) . publishAddress ( ) ) . address ( ) ; if ( DiscoveryNode . dataNode ( nodeInfo . getSettings ( ) ) ) { dataNodes + + ; masterAndDataNodes + + ; } else if ( DiscoveryNode . masterNode ( nodeInfo . getSettings ( ) ) ) { masterAndDataNodes + + ; } } this . numDataNodes = dataNodes ; this . numMasterAndDataNodes = masterAndDataNodes ; this . client = client ; logger . info ( <str> , nodeInfos . getClusterName ( ) . value ( ) , size ( ) ) ; } catch ( Exception e ) { client . close ( ) ; throw e ; } } @Override public void afterTest ( ) { } @Override public Client client ( ) { return client ; } @Override public int size ( ) { return httpAddresses . length ; } @Override public int numDataNodes ( ) { return numDataNodes ; } @Override public int numDataAndMasterNodes ( ) { return numMasterAndDataNodes ; } @Override public InetSocketAddress [ ] httpAddresses ( ) { return httpAddresses ; } @Override public void close ( ) throws IOException { client . close ( ) ; } @Override public void ensureEstimatedStats ( ) { if ( size ( ) > <int> ) { NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . setIndices ( true ) . execute ( ) . actionGet ( ) ; for ( NodeStats stats : nodeStats . getNodes ( ) ) { assertThat ( <str> + stats . getNode ( ) , stats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; assertThat ( <str> + stats . getNode ( ) , stats . getIndices ( ) . getFieldData ( ) . getMemorySizeInBytes ( ) , equalTo ( <int> l ) ) ; assertThat ( <str> + stats . getNode ( ) , stats . getIndices ( ) . getQueryCache ( ) . getMemorySizeInBytes ( ) , equalTo ( <int> l ) ) ; assertThat ( <str> + stats . getNode ( ) , stats . getIndices ( ) . getSegments ( ) . getBitsetMemoryInBytes ( ) , equalTo ( <int> l ) ) ; } } } @Override public Iterator < Client > iterator ( ) { return Collections . singleton ( client ) . iterator ( ) ; } @Override public String getClusterName ( ) { return clusterName ; } } 
