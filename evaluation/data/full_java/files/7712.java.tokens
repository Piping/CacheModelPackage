package org . elasticsearch ; import junit . framework . TestCase ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . ESTokenStreamTestCase ; import java . io . IOException ; import java . lang . reflect . Modifier ; import java . net . URISyntaxException ; import java . nio . file . FileVisitResult ; import java . nio . file . FileVisitor ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . HashSet ; import java . util . Set ; import java . util . stream . Collectors ; public class NamingConventionTests extends ESTestCase { public void testNamingConventions ( ) throws ClassNotFoundException , IOException , URISyntaxException { final Set < Class > notImplementing = new HashSet < > ( ) ; final Set < Class > pureUnitTest = new HashSet < > ( ) ; final Set < Class > missingSuffix = new HashSet < > ( ) ; final Set < Class > integTestsInDisguise = new HashSet < > ( ) ; final Set < Class > notRunnable = new HashSet < > ( ) ; final Set < Class > innerClasses = new HashSet < > ( ) ; String [ ] packages = { <str> , <str> } ; for ( final String packageName : packages ) { final String path = <str> + packageName . replace ( <str> , <str> ) ; final Path startPath = getDataPath ( path ) ; Files . walkFileTree ( startPath , new FileVisitor < Path > ( ) { private Path pkgPrefix = PathUtils . get ( path ) . getParent ( ) ; @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { pkgPrefix = pkgPrefix . resolve ( dir . getFileName ( ) ) ; return FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { try { String filename = file . getFileName ( ) . toString ( ) ; if ( filename . endsWith ( <str> ) ) { Class < ? > clazz = loadClass ( filename ) ; if ( clazz . getName ( ) . endsWith ( <str> ) ) { if ( ESIntegTestCase . class . isAssignableFrom ( clazz ) ) { integTestsInDisguise . add ( clazz ) ; } if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) | | Modifier . isInterface ( clazz . getModifiers ( ) ) ) { notRunnable . add ( clazz ) ; } else if ( isTestCase ( clazz ) = = false ) { notImplementing . add ( clazz ) ; } else if ( Modifier . isStatic ( clazz . getModifiers ( ) ) ) { innerClasses . add ( clazz ) ; } } else if ( clazz . getName ( ) . endsWith ( <str> ) ) { if ( isTestCase ( clazz ) = = false ) { notImplementing . add ( clazz ) ; } } else if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) = = false & & Modifier . isInterface ( clazz . getModifiers ( ) ) = = false ) { if ( isTestCase ( clazz ) ) { missingSuffix . add ( clazz ) ; } else if ( junit . framework . Test . class . isAssignableFrom ( clazz ) ) { pureUnitTest . add ( clazz ) ; } } } } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } return FileVisitResult . CONTINUE ; } private boolean isTestCase ( Class < ? > clazz ) { return LuceneTestCase . class . isAssignableFrom ( clazz ) ; } private Class < ? > loadClass ( String filename ) throws ClassNotFoundException { StringBuilder pkg = new StringBuilder ( ) ; for ( Path p : pkgPrefix ) { pkg . append ( p . getFileName ( ) . toString ( ) ) . append ( <str> ) ; } pkg . append ( filename . substring ( <int> , filename . length ( ) - <int> ) ) ; return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( pkg . toString ( ) ) ; } @Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) throws IOException { throw exc ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { pkgPrefix = pkgPrefix . getParent ( ) ; return FileVisitResult . CONTINUE ; } } ) ; } assertTrue ( missingSuffix . remove ( WrongName . class ) ) ; assertTrue ( missingSuffix . remove ( WrongNameTheSecond . class ) ) ; assertTrue ( notRunnable . remove ( DummyAbstractTests . class ) ) ; assertTrue ( notRunnable . remove ( DummyInterfaceTests . class ) ) ; assertTrue ( innerClasses . remove ( InnerTests . class ) ) ; assertTrue ( notImplementing . remove ( NotImplementingTests . class ) ) ; assertTrue ( pureUnitTest . remove ( PlainUnit . class ) ) ; String classesToSubclass = String . join ( <str> , ESTestCase . class . getSimpleName ( ) , ESTestCase . class . getSimpleName ( ) , ESTokenStreamTestCase . class . getSimpleName ( ) , LuceneTestCase . class . getSimpleName ( ) ) ; assertNoViolations ( <str> + ESTestCase . class . getSimpleName ( ) + <str> , missingSuffix ) ; assertNoViolations ( <str> , notRunnable ) ; assertNoViolations ( <str> , innerClasses ) ; assertNoViolations ( <str> + classesToSubclass + <str> , pureUnitTest ) ; assertNoViolations ( <str> + classesToSubclass + <str> , notImplementing ) ; assertNoViolations ( <str> , integTestsInDisguise ) ; } private String join ( Set < Class > set ) { return set . stream ( ) . map ( Object : : toString ) . collect ( Collectors . joining ( <str> ) ) ; } private void assertNoViolations ( String message , Set < Class > set ) { assertTrue ( message + join ( set ) , set . isEmpty ( ) ) ; } public static final class NotImplementingTests { } public static final class WrongName extends ESTestCase { } public static abstract class DummyAbstractTests extends ESTestCase { } public interface DummyInterfaceTests { } public static final class InnerTests extends ESTestCase { } public static final class WrongNameTheSecond extends ESTestCase { } public static final class PlainUnit extends TestCase { } } 
