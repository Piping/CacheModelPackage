package org . apache . cassandra . cql3 . restrictions ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . collect . BoundType ; import com . google . common . collect . ImmutableRangeSet ; import com . google . common . collect . Range ; import com . google . common . collect . RangeSet ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . * ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . InvalidRequestException ; import static org . apache . cassandra . cql3 . statements . Bound . END ; import static org . apache . cassandra . cql3 . statements . Bound . START ; final class TokenFilter extends ForwardingPrimaryKeyRestrictions { private PrimaryKeyRestrictions restrictions ; private TokenRestriction tokenRestriction ; private final IPartitioner partitioner ; @Override protected PrimaryKeyRestrictions getDelegate ( ) { return restrictions ; } @Override public boolean isOnToken ( ) { return restrictions . size ( ) < tokenRestriction . size ( ) ; } public TokenFilter ( PrimaryKeyRestrictions restrictions , TokenRestriction tokenRestriction ) { this . restrictions = restrictions ; this . tokenRestriction = tokenRestriction ; this . partitioner = tokenRestriction . metadata . partitioner ; } @Override public List < ByteBuffer > values ( QueryOptions options ) throws InvalidRequestException { return filter ( restrictions . values ( options ) , options ) ; } @Override public NavigableSet < Clustering > valuesAsClustering ( QueryOptions options ) throws InvalidRequestException { throw new UnsupportedOperationException ( ) ; } @Override public PrimaryKeyRestrictions mergeWith ( Restriction restriction ) throws InvalidRequestException { if ( restriction . isOnToken ( ) ) return new TokenFilter ( restrictions , ( TokenRestriction ) tokenRestriction . mergeWith ( restriction ) ) ; return new TokenFilter ( super . mergeWith ( restriction ) , tokenRestriction ) ; } @Override public boolean isInclusive ( Bound bound ) { return tokenRestriction . isInclusive ( bound ) ; } @Override public boolean hasBound ( Bound b ) { return tokenRestriction . hasBound ( b ) ; } @Override public List < ByteBuffer > bounds ( Bound bound , QueryOptions options ) throws InvalidRequestException { return tokenRestriction . bounds ( bound , options ) ; } @Override public NavigableSet < Slice . Bound > boundsAsClustering ( Bound bound , QueryOptions options ) throws InvalidRequestException { return tokenRestriction . boundsAsClustering ( bound , options ) ; } private List < ByteBuffer > filter ( List < ByteBuffer > values , QueryOptions options ) throws InvalidRequestException { RangeSet < Token > rangeSet = tokenRestriction . isSlice ( ) ? toRangeSet ( tokenRestriction , options ) : toRangeSet ( tokenRestriction . values ( options ) ) ; return filterWithRangeSet ( rangeSet , values ) ; } private List < ByteBuffer > filterWithRangeSet ( RangeSet < Token > tokens , List < ByteBuffer > values ) { List < ByteBuffer > remaining = new ArrayList < > ( ) ; for ( ByteBuffer value : values ) { Token token = partitioner . getToken ( value ) ; if ( ! tokens . contains ( token ) ) continue ; remaining . add ( value ) ; } return remaining ; } private RangeSet < Token > toRangeSet ( List < ByteBuffer > buffers ) { ImmutableRangeSet . Builder < Token > builder = ImmutableRangeSet . builder ( ) ; for ( ByteBuffer buffer : buffers ) builder . add ( Range . singleton ( deserializeToken ( buffer ) ) ) ; return builder . build ( ) ; } private RangeSet < Token > toRangeSet ( TokenRestriction slice , QueryOptions options ) throws InvalidRequestException { if ( slice . hasBound ( START ) ) { Token start = deserializeToken ( slice . bounds ( START , options ) . get ( <int> ) ) ; BoundType startBoundType = toBoundType ( slice . isInclusive ( START ) ) ; if ( slice . hasBound ( END ) ) { BoundType endBoundType = toBoundType ( slice . isInclusive ( END ) ) ; Token end = deserializeToken ( slice . bounds ( END , options ) . get ( <int> ) ) ; if ( start . equals ( end ) & & ( BoundType . OPEN = = startBoundType | | BoundType . OPEN = = endBoundType ) ) return ImmutableRangeSet . of ( ) ; if ( start . compareTo ( end ) < = <int> ) return ImmutableRangeSet . of ( Range . range ( start , startBoundType , end , endBoundType ) ) ; return ImmutableRangeSet . < Token > builder ( ) . add ( Range . upTo ( end , endBoundType ) ) . add ( Range . downTo ( start , startBoundType ) ) . build ( ) ; } return ImmutableRangeSet . of ( Range . downTo ( start , startBoundType ) ) ; } Token end = deserializeToken ( slice . bounds ( END , options ) . get ( <int> ) ) ; return ImmutableRangeSet . of ( Range . upTo ( end , toBoundType ( slice . isInclusive ( END ) ) ) ) ; } private Token deserializeToken ( ByteBuffer buffer ) { return partitioner . getTokenFactory ( ) . fromByteArray ( buffer ) ; } private static BoundType toBoundType ( boolean inclusive ) { return inclusive ? BoundType . CLOSED : BoundType . OPEN ; } } 
