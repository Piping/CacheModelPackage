package org . eclipse . debug . internal . ui . views . breakpoints ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . OtherBreakpointCategory ; import org . eclipse . debug . ui . IBreakpointOrganizerDelegate ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . AbstractTreeViewer ; import org . eclipse . jface . viewers . ITreeContentProvider ; import org . eclipse . jface . viewers . Viewer ; public class BreakpointsContentProvider implements ITreeContentProvider , IPropertyChangeListener { private IBreakpointOrganizer [ ] fOrganizers = null ; private BreakpointsViewer fViewer ; private Object [ ] fElements ; private boolean fDisposed = false ; @Override public Object [ ] getChildren ( Object parentElement ) { if ( parentElement . equals ( DebugPlugin . getDefault ( ) . getBreakpointManager ( ) ) ) { return fElements ; } else if ( parentElement instanceof BreakpointContainer ) { return ( ( BreakpointContainer ) parentElement ) . getChildren ( ) ; } return new Object [ <int> ] ; } @Override public Object getParent ( Object element ) { return null ; } @Override public boolean hasChildren ( Object element ) { return getChildren ( element ) . length > <int> ; } @Override public Object [ ] getElements ( Object inputElement ) { return getChildren ( inputElement ) ; } @Override public void dispose ( ) { fDisposed = true ; fElements = null ; setOrganizers ( null ) ; } @Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { fViewer = ( BreakpointsViewer ) viewer ; if ( newInput ! = null ) { reorganize ( ) ; } } public void setOrganizers ( IBreakpointOrganizer [ ] organizers ) { if ( fOrganizers ! = null ) { for ( int i = <int> ; i < fOrganizers . length ; i + + ) { fOrganizers [ i ] . removePropertyChangeListener ( this ) ; } } fOrganizers = organizers ; if ( organizers ! = null & & organizers . length = = <int> ) { fOrganizers = null ; } if ( fOrganizers ! = null ) { for ( int i = <int> ; i < fOrganizers . length ; i + + ) { fOrganizers [ i ] . addPropertyChangeListener ( this ) ; } } if ( ! fDisposed ) { fViewer . getControl ( ) . setRedraw ( false ) ; IBreakpoint [ ] breakpoints = null ; if ( isShowingGroups ( ) ) { breakpoints = fViewer . getVisibleBreakpoints ( ) ; } reorganize ( ) ; if ( isShowingGroups ( ) & & breakpoints ! = null ) { for ( int i = <int> ; i < fElements . length ; i + + ) { BreakpointContainer container = ( BreakpointContainer ) fElements [ i ] ; for ( int j = <int> ; j < breakpoints . length ; j + + ) { if ( container . contains ( breakpoints [ j ] ) ) { fViewer . expandToLevel ( container , AbstractTreeViewer . ALL_LEVELS ) ; fViewer . updateCheckedState ( container ) ; break ; } } } } fViewer . getControl ( ) . setRedraw ( true ) ; } } public BreakpointContainer [ ] getRoots ( IBreakpoint breakpoint ) { if ( isShowingGroups ( ) ) { List < BreakpointContainer > list = new ArrayList < BreakpointContainer > ( ) ; for ( int i = <int> ; i < fElements . length ; i + + ) { BreakpointContainer container = ( BreakpointContainer ) fElements [ i ] ; if ( container . contains ( breakpoint ) ) { list . add ( container ) ; } } return list . toArray ( new BreakpointContainer [ list . size ( ) ] ) ; } return null ; } IBreakpointOrganizer [ ] getOrganizers ( ) { return fOrganizers ; } protected void reorganize ( ) { IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( ) ; if ( fOrganizers = = null ) { fElements = breakpoints ; } else { IBreakpointOrganizer organizer = fOrganizers [ <int> ] ; Map < IAdaptable , BreakpointContainer > categoriesToContainers = new HashMap < IAdaptable , BreakpointContainer > ( ) ; for ( int i = <int> ; i < breakpoints . length ; i + + ) { IBreakpoint breakpoint = breakpoints [ i ] ; IAdaptable [ ] categories = organizer . getCategories ( breakpoint ) ; if ( categories = = null | | categories . length = = <int> ) { categories = OtherBreakpointCategory . getCategories ( organizer ) ; } for ( int j = <int> ; j < categories . length ; j + + ) { IAdaptable category = categories [ j ] ; BreakpointContainer container = categoriesToContainers . get ( category ) ; if ( container = = null ) { IBreakpointOrganizer [ ] nesting = null ; if ( fOrganizers . length > <int> ) { nesting = new IBreakpointOrganizer [ fOrganizers . length - <int> ] ; System . arraycopy ( fOrganizers , <int> , nesting , <int> , nesting . length ) ; } container = new BreakpointContainer ( category , organizer , nesting ) ; categoriesToContainers . put ( category , container ) ; } container . addBreakpoint ( breakpoint ) ; } } IAdaptable [ ] emptyCategories = organizer . getCategories ( ) ; if ( emptyCategories ! = null ) { for ( int i = <int> ; i < emptyCategories . length ; i + + ) { IAdaptable category = emptyCategories [ i ] ; BreakpointContainer container = categoriesToContainers . get ( category ) ; if ( container = = null ) { container = new BreakpointContainer ( category , organizer , null ) ; categoriesToContainers . put ( category , container ) ; } } } fElements = categoriesToContainers . values ( ) . toArray ( ) ; } fViewer . getControl ( ) . setRedraw ( false ) ; fViewer . refresh ( ) ; fViewer . getControl ( ) . setRedraw ( true ) ; } @Override public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( IBreakpointOrganizerDelegate . P_CATEGORY_CHANGED ) ) { reorganize ( ) ; } } protected BreakpointContainer [ ] getContainers ( IBreakpoint breakpoint ) { if ( isShowingGroups ( ) ) { IAdaptable [ ] categories = fOrganizers [ <int> ] . getCategories ( breakpoint ) ; if ( categories = = null | | categories . length = = <int> ) { categories = OtherBreakpointCategory . getCategories ( fOrganizers [ <int> ] ) ; } BreakpointContainer [ ] containers = new BreakpointContainer [ categories . length ] ; int index = <int> ; for ( int i = <int> ; i < fElements . length ; i + + ) { BreakpointContainer container = ( BreakpointContainer ) fElements [ i ] ; for ( int j = <int> ; j < categories . length ; j + + ) { IAdaptable category = categories [ j ] ; if ( container . getCategory ( ) . equals ( category ) ) { containers [ index ] = container ; index + + ; } } } return containers ; } return null ; } protected boolean isShowingGroups ( ) { return fOrganizers ! = null ; } } 
