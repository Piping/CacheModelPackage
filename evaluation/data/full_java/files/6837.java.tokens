package org . elasticsearch . indices . analysis ; import org . apache . lucene . analysis . hunspell . Dictionary ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . function . Function ; public class HunspellService extends AbstractComponent { public final static String HUNSPELL_LAZY_LOAD = <str> ; public final static String HUNSPELL_IGNORE_CASE = <str> ; private final static String OLD_HUNSPELL_LOCATION = <str> ; private final ConcurrentHashMap < String , Dictionary > dictionaries = new ConcurrentHashMap < > ( ) ; private final Map < String , Dictionary > knownDictionaries ; private final boolean defaultIgnoreCase ; private final Path hunspellDir ; private final Function < String , Dictionary > loadingFunction ; public HunspellService ( final Settings settings , final Environment env , final Map < String , Dictionary > knownDictionaries ) throws IOException { super ( settings ) ; this . knownDictionaries = Collections . unmodifiableMap ( knownDictionaries ) ; this . hunspellDir = resolveHunspellDirectory ( settings , env ) ; this . defaultIgnoreCase = settings . getAsBoolean ( HUNSPELL_IGNORE_CASE , false ) ; this . loadingFunction = ( locale ) - > { try { return loadDictionary ( locale , settings , env ) ; } catch ( Throwable e ) { throw new IllegalStateException ( <str> + locale , e ) ; } } ; if ( ! settings . getAsBoolean ( HUNSPELL_LAZY_LOAD , false ) ) { scanAndLoadDictionaries ( ) ; } } public Dictionary getDictionary ( String locale ) { Dictionary dictionary = knownDictionaries . get ( locale ) ; if ( dictionary = = null ) { dictionary = dictionaries . computeIfAbsent ( locale , loadingFunction ) ; } return dictionary ; } private Path resolveHunspellDirectory ( Settings settings , Environment env ) { String location = settings . get ( OLD_HUNSPELL_LOCATION , null ) ; if ( location ! = null ) { throw new IllegalArgumentException ( <str> ) ; } return env . configFile ( ) . resolve ( <str> ) ; } private void scanAndLoadDictionaries ( ) throws IOException { if ( Files . isDirectory ( hunspellDir ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( hunspellDir ) ) { for ( Path file : stream ) { if ( Files . isDirectory ( file ) ) { try ( DirectoryStream < Path > inner = Files . newDirectoryStream ( hunspellDir . resolve ( file ) , <str> ) ) { if ( inner . iterator ( ) . hasNext ( ) ) { try { getDictionary ( file . getFileName ( ) . toString ( ) ) ; } catch ( Throwable e ) { logger . error ( <str> , e , file . getFileName ( ) ) ; } } } } } } } } private Dictionary loadDictionary ( String locale , Settings nodeSettings , Environment env ) throws Exception { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , locale ) ; } Path dicDir = hunspellDir . resolve ( locale ) ; if ( FileSystemUtils . isAccessibleDirectory ( dicDir , logger ) = = false ) { throw new ElasticsearchException ( String . format ( Locale . ROOT , <str> , locale ) ) ; } nodeSettings = loadDictionarySettings ( dicDir , nodeSettings . getByPrefix ( <str> + locale + <str> ) ) ; boolean ignoreCase = nodeSettings . getAsBoolean ( <str> , defaultIgnoreCase ) ; Path [ ] affixFiles = FileSystemUtils . files ( dicDir , <str> ) ; if ( affixFiles . length = = <int> ) { throw new ElasticsearchException ( String . format ( Locale . ROOT , <str> , locale ) ) ; } if ( affixFiles . length ! = <int> ) { throw new ElasticsearchException ( String . format ( Locale . ROOT , <str> , locale ) ) ; } InputStream affixStream = null ; Path [ ] dicFiles = FileSystemUtils . files ( dicDir , <str> ) ; List < InputStream > dicStreams = new ArrayList < > ( dicFiles . length ) ; try { for ( int i = <int> ; i < dicFiles . length ; i + + ) { dicStreams . add ( Files . newInputStream ( dicFiles [ i ] ) ) ; } affixStream = Files . newInputStream ( affixFiles [ <int> ] ) ; return new Dictionary ( affixStream , dicStreams , ignoreCase ) ; } catch ( Exception e ) { logger . error ( <str> , e , locale ) ; throw e ; } finally { IOUtils . close ( affixStream ) ; IOUtils . close ( dicStreams ) ; } } private static Settings loadDictionarySettings ( Path dir , Settings defaults ) { Path file = dir . resolve ( <str> ) ; if ( Files . exists ( file ) ) { return Settings . settingsBuilder ( ) . loadFromPath ( file ) . put ( defaults ) . build ( ) ; } file = dir . resolve ( <str> ) ; if ( Files . exists ( file ) ) { return Settings . settingsBuilder ( ) . loadFromPath ( file ) . put ( defaults ) . build ( ) ; } return defaults ; } } 
