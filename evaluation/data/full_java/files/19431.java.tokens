package io . netty . handler . codec . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerAppender ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . PrematureChannelClosureException ; import io . netty . handler . codec . memcache . LastMemcacheContent ; import java . util . List ; import java . util . concurrent . atomic . AtomicLong ; public final class BinaryMemcacheClientCodec extends ChannelHandlerAppender { private final boolean failOnMissingResponse ; private final AtomicLong requestResponseCounter = new AtomicLong ( ) ; public BinaryMemcacheClientCodec ( ) { this ( AbstractBinaryMemcacheDecoder . DEFAULT_MAX_CHUNK_SIZE ) ; } public BinaryMemcacheClientCodec ( int decodeChunkSize ) { this ( decodeChunkSize , false ) ; } public BinaryMemcacheClientCodec ( int decodeChunkSize , boolean failOnMissingResponse ) { this . failOnMissingResponse = failOnMissingResponse ; add ( new Decoder ( decodeChunkSize ) ) ; add ( new Encoder ( ) ) ; } private final class Encoder extends BinaryMemcacheRequestEncoder { @Override protected void encode ( ChannelHandlerContext ctx , Object msg , List < Object > out ) throws Exception { super . encode ( ctx , msg , out ) ; if ( failOnMissingResponse & & msg instanceof LastMemcacheContent ) { requestResponseCounter . incrementAndGet ( ) ; } } } private final class Decoder extends BinaryMemcacheResponseDecoder { Decoder ( int chunkSize ) { super ( chunkSize ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { int oldSize = out . size ( ) ; super . decode ( ctx , in , out ) ; if ( failOnMissingResponse ) { final int size = out . size ( ) ; for ( int i = oldSize ; i < size ; i + + ) { Object msg = out . get ( i ) ; if ( msg instanceof LastMemcacheContent ) { requestResponseCounter . decrementAndGet ( ) ; } } } } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { super . channelInactive ( ctx ) ; if ( failOnMissingResponse ) { long missingResponses = requestResponseCounter . get ( ) ; if ( missingResponses > <int> ) { ctx . fireExceptionCaught ( new PrematureChannelClosureException ( <str> + missingResponses + <str> ) ) ; } } } } } 
