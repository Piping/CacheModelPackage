package org . elasticsearch . rest . action . cat ; import com . carrotsearch . hppc . ObjectIntScatterMap ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsRequest ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateRequest ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . stats . CommonStatsFlags ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActionListener ; import org . elasticsearch . rest . action . support . RestResponseListener ; import org . elasticsearch . rest . action . support . RestTable ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestAllocationAction extends AbstractCatAction { @Inject public RestAllocationAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override protected void documentation ( StringBuilder sb ) { sb . append ( <str> ) ; } @Override public void doRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final String [ ] nodes = Strings . splitStringByCommaToArray ( request . param ( <str> , <str> ) ) ; final ClusterStateRequest clusterStateRequest = new ClusterStateRequest ( ) ; clusterStateRequest . clear ( ) . routingTable ( true ) ; clusterStateRequest . local ( request . paramAsBoolean ( <str> , clusterStateRequest . local ( ) ) ) ; clusterStateRequest . masterNodeTimeout ( request . paramAsTime ( <str> , clusterStateRequest . masterNodeTimeout ( ) ) ) ; client . admin ( ) . cluster ( ) . state ( clusterStateRequest , new RestActionListener < ClusterStateResponse > ( channel ) { @Override public void processResponse ( final ClusterStateResponse state ) { NodesStatsRequest statsRequest = new NodesStatsRequest ( nodes ) ; statsRequest . clear ( ) . fs ( true ) . indices ( new CommonStatsFlags ( CommonStatsFlags . Flag . Store ) ) ; client . admin ( ) . cluster ( ) . nodesStats ( statsRequest , new RestResponseListener < NodesStatsResponse > ( channel ) { @Override public RestResponse buildResponse ( NodesStatsResponse stats ) throws Exception { Table tab = buildTable ( request , state , stats ) ; return RestTable . buildResponse ( tab , channel ) ; } } ) ; } } ) ; } @Override protected Table getTableWithHeader ( final RestRequest request ) { final Table table = new Table ( ) ; table . startHeaders ( ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . endHeaders ( ) ; return table ; } private Table buildTable ( RestRequest request , final ClusterStateResponse state , final NodesStatsResponse stats ) { final ObjectIntScatterMap < String > allocs = new ObjectIntScatterMap < > ( ) ; for ( ShardRouting shard : state . getState ( ) . routingTable ( ) . allShards ( ) ) { String nodeId = <str> ; if ( shard . assignedToNode ( ) ) { nodeId = shard . currentNodeId ( ) ; } allocs . addTo ( nodeId , <int> ) ; } Table table = getTableWithHeader ( request ) ; for ( NodeStats nodeStats : stats . getNodes ( ) ) { DiscoveryNode node = nodeStats . getNode ( ) ; int shardCount = allocs . getOrDefault ( node . id ( ) , <int> ) ; ByteSizeValue total = nodeStats . getFs ( ) . getTotal ( ) . getTotal ( ) ; ByteSizeValue avail = nodeStats . getFs ( ) . getTotal ( ) . getAvailable ( ) ; long used = <int> ; short diskPercent = - <int> ; if ( total . bytes ( ) > <int> ) { used = total . bytes ( ) - avail . bytes ( ) ; if ( used > = <int> & & avail . bytes ( ) > = <int> ) { diskPercent = ( short ) ( used * <int> / ( used + avail . bytes ( ) ) ) ; } } table . startRow ( ) ; table . addCell ( shardCount ) ; table . addCell ( nodeStats . getIndices ( ) . getStore ( ) . getSize ( ) ) ; table . addCell ( used < <int> ? null : new ByteSizeValue ( used ) ) ; table . addCell ( avail . bytes ( ) < <int> ? null : avail ) ; table . addCell ( total . bytes ( ) < <int> ? null : total ) ; table . addCell ( diskPercent < <int> ? null : diskPercent ) ; table . addCell ( node . getHostName ( ) ) ; table . addCell ( node . getHostAddress ( ) ) ; table . addCell ( node . name ( ) ) ; table . endRow ( ) ; } final String UNASSIGNED = <str> ; if ( allocs . containsKey ( UNASSIGNED ) ) { table . startRow ( ) ; table . addCell ( allocs . get ( UNASSIGNED ) ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( null ) ; table . addCell ( UNASSIGNED ) ; table . endRow ( ) ; } return table ; } } 
