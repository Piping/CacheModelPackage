package org . elasticsearch . monitor . jvm ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . monitor . jvm . JvmStats . GarbageCollector ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . ScheduledFuture ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . unit . TimeValue . timeValueSeconds ; import static org . elasticsearch . monitor . jvm . JvmStats . jvmStats ; public class JvmMonitorService extends AbstractLifecycleComponent < JvmMonitorService > { private final ThreadPool threadPool ; private final boolean enabled ; private final TimeValue interval ; private final Map < String , GcThreshold > gcThresholds ; private volatile ScheduledFuture scheduledFuture ; static class GcThreshold { public final String name ; public final long warnThreshold ; public final long infoThreshold ; public final long debugThreshold ; GcThreshold ( String name , long warnThreshold , long infoThreshold , long debugThreshold ) { this . name = name ; this . warnThreshold = warnThreshold ; this . infoThreshold = infoThreshold ; this . debugThreshold = debugThreshold ; } @Override public String toString ( ) { return <str> + <str> + name + <str> + <str> + warnThreshold + <str> + infoThreshold + <str> + debugThreshold + <str> ; } } public JvmMonitorService ( Settings settings , ThreadPool threadPool ) { super ( settings ) ; this . threadPool = threadPool ; this . enabled = this . settings . getAsBoolean ( <str> , true ) ; this . interval = this . settings . getAsTime ( <str> , timeValueSeconds ( <int> ) ) ; Map < String , GcThreshold > gcThresholds = new HashMap < > ( ) ; Map < String , Settings > gcThresholdGroups = this . settings . getGroups ( <str> ) ; for ( Map . Entry < String , Settings > entry : gcThresholdGroups . entrySet ( ) ) { String name = entry . getKey ( ) ; TimeValue warn = entry . getValue ( ) . getAsTime ( <str> , null ) ; TimeValue info = entry . getValue ( ) . getAsTime ( <str> , null ) ; TimeValue debug = entry . getValue ( ) . getAsTime ( <str> , null ) ; if ( warn = = null | | info = = null | | debug = = null ) { logger . warn ( <str> , name ) ; } else { gcThresholds . put ( name , new GcThreshold ( name , warn . millis ( ) , info . millis ( ) , debug . millis ( ) ) ) ; } } gcThresholds . putIfAbsent ( GcNames . YOUNG , new GcThreshold ( GcNames . YOUNG , <int> , <int> , <int> ) ) ; gcThresholds . putIfAbsent ( GcNames . OLD , new GcThreshold ( GcNames . OLD , <int> , <int> , <int> ) ) ; gcThresholds . putIfAbsent ( <str> , new GcThreshold ( <str> , <int> , <int> , <int> ) ) ; this . gcThresholds = unmodifiableMap ( gcThresholds ) ; logger . debug ( <str> , enabled , interval , this . gcThresholds ) ; } @Override protected void doStart ( ) { if ( ! enabled ) { return ; } scheduledFuture = threadPool . scheduleWithFixedDelay ( new JvmMonitor ( ) , interval ) ; } @Override protected void doStop ( ) { if ( ! enabled ) { return ; } FutureUtils . cancel ( scheduledFuture ) ; } @Override protected void doClose ( ) { } private class JvmMonitor implements Runnable { private JvmStats lastJvmStats = jvmStats ( ) ; private long seq = <int> ; public JvmMonitor ( ) { } @Override public void run ( ) { try { monitorLongGc ( ) ; } catch ( Throwable t ) { logger . debug ( <str> , t ) ; } } private synchronized void monitorLongGc ( ) { seq + + ; JvmStats currentJvmStats = jvmStats ( ) ; for ( int i = <int> ; i < currentJvmStats . getGc ( ) . getCollectors ( ) . length ; i + + ) { GarbageCollector gc = currentJvmStats . getGc ( ) . getCollectors ( ) [ i ] ; GarbageCollector prevGc = lastJvmStats . gc . collectors [ i ] ; long collections = gc . collectionCount - prevGc . collectionCount ; if ( collections = = <int> ) { continue ; } long collectionTime = gc . collectionTime - prevGc . collectionTime ; if ( collectionTime = = <int> ) { continue ; } GcThreshold gcThreshold = gcThresholds . get ( gc . getName ( ) ) ; if ( gcThreshold = = null ) { gcThreshold = gcThresholds . get ( <str> ) ; } long avgCollectionTime = collectionTime / collections ; if ( avgCollectionTime > gcThreshold . warnThreshold ) { logger . warn ( <str> , gc . getName ( ) , seq , gc . getCollectionCount ( ) , TimeValue . timeValueMillis ( collectionTime ) , collections , TimeValue . timeValueMillis ( currentJvmStats . getTimestamp ( ) - lastJvmStats . getTimestamp ( ) ) , TimeValue . timeValueMillis ( collectionTime ) , gc . getCollectionTime ( ) , lastJvmStats . getMem ( ) . getHeapUsed ( ) , currentJvmStats . getMem ( ) . getHeapUsed ( ) , JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapMax ( ) , buildPools ( lastJvmStats , currentJvmStats ) ) ; } else if ( avgCollectionTime > gcThreshold . infoThreshold ) { logger . info ( <str> , gc . getName ( ) , seq , gc . getCollectionCount ( ) , TimeValue . timeValueMillis ( collectionTime ) , collections , TimeValue . timeValueMillis ( currentJvmStats . getTimestamp ( ) - lastJvmStats . getTimestamp ( ) ) , TimeValue . timeValueMillis ( collectionTime ) , gc . getCollectionTime ( ) , lastJvmStats . getMem ( ) . getHeapUsed ( ) , currentJvmStats . getMem ( ) . getHeapUsed ( ) , JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapMax ( ) , buildPools ( lastJvmStats , currentJvmStats ) ) ; } else if ( avgCollectionTime > gcThreshold . debugThreshold & & logger . isDebugEnabled ( ) ) { logger . debug ( <str> , gc . getName ( ) , seq , gc . getCollectionCount ( ) , TimeValue . timeValueMillis ( collectionTime ) , collections , TimeValue . timeValueMillis ( currentJvmStats . getTimestamp ( ) - lastJvmStats . getTimestamp ( ) ) , TimeValue . timeValueMillis ( collectionTime ) , gc . getCollectionTime ( ) , lastJvmStats . getMem ( ) . getHeapUsed ( ) , currentJvmStats . getMem ( ) . getHeapUsed ( ) , JvmInfo . jvmInfo ( ) . getMem ( ) . getHeapMax ( ) , buildPools ( lastJvmStats , currentJvmStats ) ) ; } } lastJvmStats = currentJvmStats ; } private String buildPools ( JvmStats prev , JvmStats current ) { StringBuilder sb = new StringBuilder ( ) ; for ( JvmStats . MemoryPool currentPool : current . getMem ( ) ) { JvmStats . MemoryPool prevPool = null ; for ( JvmStats . MemoryPool pool : prev . getMem ( ) ) { if ( pool . getName ( ) . equals ( currentPool . getName ( ) ) ) { prevPool = pool ; break ; } } sb . append ( <str> ) . append ( currentPool . getName ( ) ) . append ( <str> ) . append ( prevPool = = null ? <str> : prevPool . getUsed ( ) ) . append ( <str> ) . append ( currentPool . getUsed ( ) ) . append ( <str> ) . append ( currentPool . getMax ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } } } 
