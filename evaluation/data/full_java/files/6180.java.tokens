package org . elasticsearch . discovery . zen . fd ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . cluster . NotMasterException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; public class MasterFaultDetection extends FaultDetection { public static final String MASTER_PING_ACTION_NAME = <str> ; public static interface Listener { void onMasterFailure ( DiscoveryNode masterNode , Throwable cause , String reason ) ; } private final ClusterService clusterService ; private final CopyOnWriteArrayList < Listener > listeners = new CopyOnWriteArrayList < > ( ) ; private volatile MasterPinger masterPinger ; private final Object masterNodeMutex = new Object ( ) ; private volatile DiscoveryNode masterNode ; private volatile int retryCount ; private final AtomicBoolean notifiedMasterFailure = new AtomicBoolean ( ) ; public MasterFaultDetection ( Settings settings , ThreadPool threadPool , TransportService transportService , ClusterName clusterName , ClusterService clusterService ) { super ( settings , threadPool , transportService , clusterName ) ; this . clusterService = clusterService ; logger . debug ( <str> , pingInterval , pingRetryTimeout , pingRetryCount ) ; transportService . registerRequestHandler ( MASTER_PING_ACTION_NAME , MasterPingRequest : : new , ThreadPool . Names . SAME , new MasterPingRequestHandler ( ) ) ; } public DiscoveryNode masterNode ( ) { return this . masterNode ; } public void addListener ( Listener listener ) { listeners . add ( listener ) ; } public void removeListener ( Listener listener ) { listeners . remove ( listener ) ; } public void restart ( DiscoveryNode masterNode , String reason ) { synchronized ( masterNodeMutex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , masterNode , reason ) ; } innerStop ( ) ; innerStart ( masterNode ) ; } } public void start ( final DiscoveryNode masterNode , String reason ) { synchronized ( masterNodeMutex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , masterNode , reason ) ; } innerStart ( masterNode ) ; } } private void innerStart ( final DiscoveryNode masterNode ) { this . masterNode = masterNode ; this . retryCount = <int> ; this . notifiedMasterFailure . set ( false ) ; try { transportService . connectToNode ( masterNode ) ; } catch ( final Exception e ) { notifyMasterFailure ( masterNode , e , <str> ) ; return ; } if ( masterPinger ! = null ) { masterPinger . stop ( ) ; } this . masterPinger = new MasterPinger ( ) ; threadPool . schedule ( pingInterval , ThreadPool . Names . SAME , masterPinger ) ; } public void stop ( String reason ) { synchronized ( masterNodeMutex ) { if ( masterNode ! = null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , masterNode , reason ) ; } } innerStop ( ) ; } } private void innerStop ( ) { this . retryCount = <int> ; if ( masterPinger ! = null ) { masterPinger . stop ( ) ; masterPinger = null ; } this . masterNode = null ; } @Override public void close ( ) { super . close ( ) ; stop ( <str> ) ; this . listeners . clear ( ) ; transportService . removeHandler ( MASTER_PING_ACTION_NAME ) ; } @Override protected void handleTransportDisconnect ( DiscoveryNode node ) { synchronized ( masterNodeMutex ) { if ( ! node . equals ( this . masterNode ) ) { return ; } if ( connectOnNetworkDisconnect ) { try { transportService . connectToNode ( node ) ; if ( masterPinger ! = null ) { masterPinger . stop ( ) ; } this . masterPinger = new MasterPinger ( ) ; threadPool . schedule ( TimeValue . timeValueMillis ( <int> ) , ThreadPool . Names . SAME , masterPinger ) ; } catch ( Exception e ) { logger . trace ( <str> , masterNode ) ; notifyMasterFailure ( masterNode , null , <str> ) ; } } else { logger . trace ( <str> , node ) ; notifyMasterFailure ( node , null , <str> ) ; } } } private void notifyMasterFailure ( final DiscoveryNode masterNode , final Throwable cause , final String reason ) { if ( notifiedMasterFailure . compareAndSet ( false , true ) ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { for ( Listener listener : listeners ) { listener . onMasterFailure ( masterNode , cause , reason ) ; } } } ) ; stop ( <str> + reason ) ; } } private class MasterPinger implements Runnable { private volatile boolean running = true ; public void stop ( ) { this . running = false ; } @Override public void run ( ) { if ( ! running ) { return ; } final DiscoveryNode masterToPing = masterNode ; if ( masterToPing = = null ) { threadPool . schedule ( pingInterval , ThreadPool . Names . SAME , MasterPinger . this ) ; return ; } final MasterPingRequest request = new MasterPingRequest ( clusterService . localNode ( ) . id ( ) , masterToPing . id ( ) , clusterName ) ; final TransportRequestOptions options = TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . PING ) . withTimeout ( pingRetryTimeout ) . build ( ) ; transportService . sendRequest ( masterToPing , MASTER_PING_ACTION_NAME , request , options , new BaseTransportResponseHandler < MasterPingResponseResponse > ( ) { @Override public MasterPingResponseResponse newInstance ( ) { return new MasterPingResponseResponse ( ) ; } @Override public void handleResponse ( MasterPingResponseResponse response ) { if ( ! running ) { return ; } MasterFaultDetection . this . retryCount = <int> ; if ( masterToPing . equals ( MasterFaultDetection . this . masterNode ( ) ) ) { threadPool . schedule ( pingInterval , ThreadPool . Names . SAME , MasterPinger . this ) ; } } @Override public void handleException ( TransportException exp ) { if ( ! running ) { return ; } synchronized ( masterNodeMutex ) { if ( masterToPing . equals ( MasterFaultDetection . this . masterNode ( ) ) ) { if ( exp instanceof ConnectTransportException | | exp . getCause ( ) instanceof ConnectTransportException ) { handleTransportDisconnect ( masterToPing ) ; return ; } else if ( exp . getCause ( ) instanceof NotMasterException ) { logger . debug ( <str> , masterNode ) ; notifyMasterFailure ( masterToPing , exp , <str> ) ; return ; } else if ( exp . getCause ( ) instanceof ThisIsNotTheMasterYouAreLookingForException ) { logger . debug ( <str> , masterNode ) ; notifyMasterFailure ( masterToPing , exp , <str> ) ; return ; } else if ( exp . getCause ( ) instanceof NodeDoesNotExistOnMasterException ) { logger . debug ( <str> , masterNode ) ; notifyMasterFailure ( masterToPing , exp , <str> ) ; return ; } int retryCount = + + MasterFaultDetection . this . retryCount ; logger . trace ( <str> , exp , masterNode , retryCount , pingRetryCount ) ; if ( retryCount > = pingRetryCount ) { logger . debug ( <str> , masterNode , pingRetryCount , pingRetryTimeout ) ; notifyMasterFailure ( masterToPing , null , <str> + pingRetryCount + <str> + pingRetryTimeout + <str> ) ; } else { transportService . sendRequest ( masterToPing , MASTER_PING_ACTION_NAME , request , options , this ) ; } } } } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } } static class ThisIsNotTheMasterYouAreLookingForException extends IllegalStateException { ThisIsNotTheMasterYouAreLookingForException ( String msg ) { super ( msg ) ; } ThisIsNotTheMasterYouAreLookingForException ( ) { } @Override public Throwable fillInStackTrace ( ) { return null ; } } static class NodeDoesNotExistOnMasterException extends IllegalStateException { @Override public Throwable fillInStackTrace ( ) { return null ; } } private class MasterPingRequestHandler implements TransportRequestHandler < MasterPingRequest > { @Override public void messageReceived ( final MasterPingRequest request , final TransportChannel channel ) throws Exception { final DiscoveryNodes nodes = clusterService . state ( ) . nodes ( ) ; if ( ! request . masterNodeId . equals ( nodes . localNodeId ( ) ) ) { throw new ThisIsNotTheMasterYouAreLookingForException ( ) ; } if ( request . clusterName ! = null & & ! request . clusterName . equals ( clusterName ) ) { logger . trace ( <str> , request . clusterName , clusterName ) ; throw new ThisIsNotTheMasterYouAreLookingForException ( <str> + request . clusterName + <str> + clusterName + <str> ) ; } if ( ! nodes . localNodeMaster ( ) | | ! nodes . nodeExists ( request . nodeId ) ) { logger . trace ( <str> , request . nodeId ) ; clusterService . submitStateUpdateTask ( <str> + request . nodeId + <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { DiscoveryNodes nodes = currentState . nodes ( ) ; if ( ! nodes . nodeExists ( request . nodeId ) ) { throw new NodeDoesNotExistOnMasterException ( ) ; } return currentState ; } @Override public void onNoLongerMaster ( String source ) { onFailure ( source , new NotMasterException ( <str> ) ) ; } @Override public void onFailure ( String source , @Nullable Throwable t ) { if ( t = = null ) { t = new ElasticsearchException ( <str> ) ; } try { channel . sendResponse ( t ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { try { channel . sendResponse ( new MasterPingResponseResponse ( ) ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } } ) ; } else { channel . sendResponse ( new MasterPingResponseResponse ( ) ) ; } } } public static class MasterPingRequest extends TransportRequest { private String nodeId ; private String masterNodeId ; private ClusterName clusterName ; public MasterPingRequest ( ) { } private MasterPingRequest ( String nodeId , String masterNodeId , ClusterName clusterName ) { this . nodeId = nodeId ; this . masterNodeId = masterNodeId ; this . clusterName = clusterName ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; nodeId = in . readString ( ) ; masterNodeId = in . readString ( ) ; clusterName = ClusterName . readClusterName ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( nodeId ) ; out . writeString ( masterNodeId ) ; clusterName . writeTo ( out ) ; } } private static class MasterPingResponseResponse extends TransportResponse { private MasterPingResponseResponse ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; } } } 
