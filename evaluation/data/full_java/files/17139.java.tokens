package org . jbox2d . collision ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Vec2 ; import org . jbox2d . pooling . IWorldPool ; import org . jbox2d . pooling . normal . DefaultWorldPool ; public class AABB { public final Vec2 lowerBound ; public final Vec2 upperBound ; public AABB ( ) { lowerBound = new Vec2 ( ) ; upperBound = new Vec2 ( ) ; } public AABB ( final AABB copy ) { this ( copy . lowerBound , copy . upperBound ) ; } public AABB ( final Vec2 lowerVertex , final Vec2 upperVertex ) { this . lowerBound = lowerVertex . clone ( ) ; this . upperBound = upperVertex . clone ( ) ; } public final void set ( final AABB aabb ) { Vec2 v = aabb . lowerBound ; lowerBound . x = v . x ; lowerBound . y = v . y ; Vec2 v1 = aabb . upperBound ; upperBound . x = v1 . x ; upperBound . y = v1 . y ; } public final boolean isValid ( ) { final float dx = upperBound . x - lowerBound . x ; if ( dx < <float> ) { return false ; } final float dy = upperBound . y - lowerBound . y ; if ( dy < <int> ) { return false ; } return lowerBound . isValid ( ) & & upperBound . isValid ( ) ; } public final Vec2 getCenter ( ) { final Vec2 center = new Vec2 ( lowerBound ) ; center . addLocal ( upperBound ) ; center . mulLocal ( <float> ) ; return center ; } public final void getCenterToOut ( final Vec2 out ) { out . x = ( lowerBound . x + upperBound . x ) * <float> ; out . y = ( lowerBound . y + upperBound . y ) * <float> ; } public final Vec2 getExtents ( ) { final Vec2 center = new Vec2 ( upperBound ) ; center . subLocal ( lowerBound ) ; center . mulLocal ( <float> ) ; return center ; } public final void getExtentsToOut ( final Vec2 out ) { out . x = ( upperBound . x - lowerBound . x ) * <float> ; out . y = ( upperBound . y - lowerBound . y ) * <float> ; } public final void getVertices ( Vec2 [ ] argRay ) { argRay [ <int> ] . set ( lowerBound ) ; argRay [ <int> ] . set ( lowerBound ) ; argRay [ <int> ] . x + = upperBound . x - lowerBound . x ; argRay [ <int> ] . set ( upperBound ) ; argRay [ <int> ] . set ( upperBound ) ; argRay [ <int> ] . x - = upperBound . x - lowerBound . x ; } public final void combine ( final AABB aabb1 , final AABB aab ) { lowerBound . x = aabb1 . lowerBound . x < aab . lowerBound . x ? aabb1 . lowerBound . x : aab . lowerBound . x ; lowerBound . y = aabb1 . lowerBound . y < aab . lowerBound . y ? aabb1 . lowerBound . y : aab . lowerBound . y ; upperBound . x = aabb1 . upperBound . x > aab . upperBound . x ? aabb1 . upperBound . x : aab . upperBound . x ; upperBound . y = aabb1 . upperBound . y > aab . upperBound . y ? aabb1 . upperBound . y : aab . upperBound . y ; } public final float getPerimeter ( ) { return <float> * ( upperBound . x - lowerBound . x + upperBound . y - lowerBound . y ) ; } public final void combine ( final AABB aabb ) { lowerBound . x = lowerBound . x < aabb . lowerBound . x ? lowerBound . x : aabb . lowerBound . x ; lowerBound . y = lowerBound . y < aabb . lowerBound . y ? lowerBound . y : aabb . lowerBound . y ; upperBound . x = upperBound . x > aabb . upperBound . x ? upperBound . x : aabb . upperBound . x ; upperBound . y = upperBound . y > aabb . upperBound . y ? upperBound . y : aabb . upperBound . y ; } public final boolean contains ( final AABB aabb ) { return lowerBound . x < = aabb . lowerBound . x & & lowerBound . y < = aabb . lowerBound . y & & aabb . upperBound . x < = upperBound . x & & aabb . upperBound . y < = upperBound . y ; } public final boolean raycast ( final RayCastOutput output , final RayCastInput input ) { return raycast ( output , input , new DefaultWorldPool ( <int> , <int> ) ) ; } public final boolean raycast ( final RayCastOutput output , final RayCastInput input , IWorldPool argPool ) { float tmin = - Float . MAX_VALUE ; float tmax = Float . MAX_VALUE ; final Vec2 p = argPool . popVec2 ( ) ; final Vec2 d = argPool . popVec2 ( ) ; final Vec2 absD = argPool . popVec2 ( ) ; final Vec2 normal = argPool . popVec2 ( ) ; p . set ( input . p1 ) ; d . set ( input . p2 ) . subLocal ( input . p1 ) ; Vec2 . absToOut ( d , absD ) ; if ( absD . x < Settings . EPSILON ) { if ( p . x < lowerBound . x | | upperBound . x < p . x ) { argPool . pushVec2 ( <int> ) ; return false ; } } else { final float inv_d = <float> / d . x ; float t1 = ( lowerBound . x - p . x ) * inv_d ; float t2 = ( upperBound . x - p . x ) * inv_d ; float s = - <float> ; if ( t1 > t2 ) { final float temp = t1 ; t1 = t2 ; t2 = temp ; s = <float> ; } if ( t1 > tmin ) { normal . setZero ( ) ; normal . x = s ; tmin = t1 ; } tmax = MathUtils . min ( tmax , t2 ) ; if ( tmin > tmax ) { argPool . pushVec2 ( <int> ) ; return false ; } } if ( absD . y < Settings . EPSILON ) { if ( p . y < lowerBound . y | | upperBound . y < p . y ) { argPool . pushVec2 ( <int> ) ; return false ; } } else { final float inv_d = <float> / d . y ; float t1 = ( lowerBound . y - p . y ) * inv_d ; float t2 = ( upperBound . y - p . y ) * inv_d ; float s = - <float> ; if ( t1 > t2 ) { final float temp = t1 ; t1 = t2 ; t2 = temp ; s = <float> ; } if ( t1 > tmin ) { normal . setZero ( ) ; normal . y = s ; tmin = t1 ; } tmax = MathUtils . min ( tmax , t2 ) ; if ( tmin > tmax ) { argPool . pushVec2 ( <int> ) ; return false ; } } if ( tmin < <float> | | input . maxFraction < tmin ) { argPool . pushVec2 ( <int> ) ; return false ; } output . fraction = tmin ; output . normal . x = normal . x ; output . normal . y = normal . y ; argPool . pushVec2 ( <int> ) ; return true ; } public static final boolean testOverlap ( final AABB a , final AABB b ) { if ( b . lowerBound . x - a . upperBound . x > <float> | | b . lowerBound . y - a . upperBound . y > <float> ) { return false ; } if ( a . lowerBound . x - b . upperBound . x > <float> | | a . lowerBound . y - b . upperBound . y > <float> ) { return false ; } return true ; } @Override public final String toString ( ) { final String s = <str> + lowerBound + <str> + upperBound + <str> ; return s ; } } 
