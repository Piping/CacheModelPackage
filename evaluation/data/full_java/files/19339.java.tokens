package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOutboundHandler ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . http2 . Http2Exception . CompositeStreamException ; import io . netty . handler . codec . http2 . Http2Exception . StreamException ; import io . netty . util . concurrent . ScheduledFuture ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . SocketAddress ; import java . util . List ; import java . util . concurrent . TimeUnit ; import static io . netty . buffer . ByteBufUtil . hexDump ; import static io . netty . handler . codec . http2 . Http2CodecUtil . HTTP_UPGRADE_STREAM_ID ; import static io . netty . handler . codec . http2 . Http2CodecUtil . connectionPrefaceBuf ; import static io . netty . handler . codec . http2 . Http2CodecUtil . getEmbeddedHttp2Exception ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . NO_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . handler . codec . http2 . Http2Exception . isStreamError ; import static io . netty . handler . codec . http2 . Http2FrameTypes . SETTINGS ; import static io . netty . handler . codec . http2 . Http2Stream . State . IDLE ; import static io . netty . util . CharsetUtil . UTF_8 ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . min ; import static java . lang . String . format ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; public class Http2ConnectionHandler extends ByteToMessageDecoder implements Http2LifecycleManager , ChannelOutboundHandler { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( Http2ConnectionHandler . class ) ; private static final long DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS = MILLISECONDS . convert ( <int> , SECONDS ) ; private final Http2ConnectionDecoder decoder ; private final Http2ConnectionEncoder encoder ; private final Http2Settings initialSettings ; private ChannelFutureListener closeListener ; private BaseDecoder byteDecoder ; private long gracefulShutdownTimeoutMillis ; public static final class Builder extends BuilderBase < Http2ConnectionHandler , Builder > { @Override public Http2ConnectionHandler build0 ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder ) { return new Http2ConnectionHandler ( decoder , encoder , initialSettings ( ) ) ; } } public abstract static class BuilderBase < T extends Http2ConnectionHandler , B extends BuilderBase < T , B > > { private Http2Settings initialSettings = new Http2Settings ( ) ; private Http2FrameListener frameListener ; private Http2FrameLogger frameLogger ; private Http2HeadersEncoder . SensitivityDetector headersSensativityDetector = Http2HeadersEncoder . NEVER_SENSITIVE ; private boolean validateHeaders = true ; private boolean server = true ; private boolean encoderEnforceMaxConcurrentStreams ; private long gracefulShutdownTimeoutMillis = DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS ; public B frameListener ( Http2FrameListener listener ) { frameListener = listener ; return thisB ( ) ; } public B validateHeaders ( boolean validate ) { validateHeaders = validate ; return thisB ( ) ; } public final boolean isValidateHeaders ( ) { return validateHeaders ; } public B initialSettings ( Http2Settings settings ) { initialSettings = settings ; return thisB ( ) ; } public final Http2Settings initialSettings ( ) { return initialSettings ; } public B server ( boolean isServer ) { server = isServer ; return thisB ( ) ; } public B frameLogger ( Http2FrameLogger logger ) { frameLogger = logger ; return thisB ( ) ; } public B gracefulShutdownTimeoutMillis ( long gracefulShutdownTimeoutMillis ) { this . gracefulShutdownTimeoutMillis = gracefulShutdownTimeoutMillis ; return thisB ( ) ; } public B encoderEnforceMaxConcurrentStreams ( boolean encoderEnforceMaxConcurrentStreams ) { this . encoderEnforceMaxConcurrentStreams = encoderEnforceMaxConcurrentStreams ; return thisB ( ) ; } public B headersSensativityDetector ( Http2HeadersEncoder . SensitivityDetector headersSensativityDetector ) { this . headersSensativityDetector = checkNotNull ( headersSensativityDetector , <str> ) ; return thisB ( ) ; } public final T build ( ) { return build ( new DefaultHttp2Connection ( server ) ) ; } public final T build ( Http2Connection connection ) { Http2FrameReader reader = new DefaultHttp2FrameReader ( validateHeaders ) ; Http2FrameWriter writer = new DefaultHttp2FrameWriter ( headersSensativityDetector ) ; if ( frameLogger ! = null ) { reader = new Http2InboundFrameLogger ( reader , frameLogger ) ; writer = new Http2OutboundFrameLogger ( writer , frameLogger ) ; } Http2ConnectionEncoder encoder = new DefaultHttp2ConnectionEncoder ( connection , writer ) ; if ( encoderEnforceMaxConcurrentStreams ) { if ( connection . isServer ( ) ) { encoder . close ( ) ; reader . close ( ) ; throw new IllegalArgumentException ( <str> + encoderEnforceMaxConcurrentStreams + <str> ) ; } encoder = new StreamBufferingEncoder ( encoder ) ; } Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder ( connection , encoder , reader ) ; return build ( decoder , encoder ) ; } public final T build ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder ) { final T handler ; try { handler = build0 ( decoder , encoder ) ; } catch ( RuntimeException e ) { encoder . close ( ) ; decoder . close ( ) ; throw e ; } handler . gracefulShutdownTimeoutMillis ( gracefulShutdownTimeoutMillis ) ; if ( handler . decoder ( ) . frameListener ( ) = = null ) { handler . decoder ( ) . frameListener ( frameListener ) ; } return handler ; } protected abstract T build0 ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder ) ; @SuppressWarnings ( <str> ) protected B thisB ( ) { return ( B ) this ; } } protected Http2ConnectionHandler ( Http2ConnectionDecoder decoder , Http2ConnectionEncoder encoder , Http2Settings initialSettings ) { this . initialSettings = checkNotNull ( initialSettings , <str> ) ; this . decoder = checkNotNull ( decoder , <str> ) ; this . encoder = checkNotNull ( encoder , <str> ) ; if ( encoder . connection ( ) ! = decoder . connection ( ) ) { throw new IllegalArgumentException ( <str> ) ; } } public long gracefulShutdownTimeoutMillis ( ) { return gracefulShutdownTimeoutMillis ; } public void gracefulShutdownTimeoutMillis ( long gracefulShutdownTimeoutMillis ) { if ( gracefulShutdownTimeoutMillis < <int> ) { throw new IllegalArgumentException ( <str> + gracefulShutdownTimeoutMillis + <str> ) ; } this . gracefulShutdownTimeoutMillis = gracefulShutdownTimeoutMillis ; } public Http2Connection connection ( ) { return encoder . connection ( ) ; } public Http2ConnectionDecoder decoder ( ) { return decoder ; } public Http2ConnectionEncoder encoder ( ) { return encoder ; } private boolean prefaceSent ( ) { return byteDecoder ! = null & & byteDecoder . prefaceSent ( ) ; } public void onHttpClientUpgrade ( ) throws Http2Exception { if ( connection ( ) . isServer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } if ( prefaceSent ( ) | | decoder . prefaceReceived ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } connection ( ) . local ( ) . createStream ( HTTP_UPGRADE_STREAM_ID , true ) ; } public void onHttpServerUpgrade ( Http2Settings settings ) throws Http2Exception { if ( ! connection ( ) . isServer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } if ( prefaceSent ( ) | | decoder . prefaceReceived ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } encoder . remoteSettings ( settings ) ; connection ( ) . remote ( ) . createStream ( HTTP_UPGRADE_STREAM_ID , true ) ; } @Override public void flush ( ChannelHandlerContext ctx ) throws Http2Exception { encoder . flowController ( ) . writePendingBytes ( ) ; try { ctx . flush ( ) ; } catch ( Throwable t ) { throw new Http2Exception ( INTERNAL_ERROR , <str> , t ) ; } } private abstract class BaseDecoder { public abstract void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception ; public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { } public void channelActive ( ChannelHandlerContext ctx ) throws Exception { } public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { encoder ( ) . close ( ) ; decoder ( ) . close ( ) ; final Http2Connection connection = connection ( ) ; if ( connection . numActiveStreams ( ) > <int> ) { final ChannelFuture future = ctx . newSucceededFuture ( ) ; connection . forEachActiveStream ( new Http2StreamVisitor ( ) { @Override public boolean visit ( Http2Stream stream ) throws Http2Exception { closeStream ( stream , future ) ; return true ; } } ) ; } } public boolean prefaceSent ( ) { return true ; } } private final class PrefaceDecoder extends BaseDecoder { private ByteBuf clientPrefaceString ; private boolean prefaceSent ; public PrefaceDecoder ( ChannelHandlerContext ctx ) { clientPrefaceString = clientPrefaceString ( encoder . connection ( ) ) ; sendPreface ( ctx ) ; } @Override public boolean prefaceSent ( ) { return prefaceSent ; } @Override public void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { if ( readClientPrefaceString ( in ) & & verifyFirstFrameIsSettings ( in ) ) { byteDecoder = new FrameDecoder ( ) ; byteDecoder . decode ( ctx , in , out ) ; } } catch ( Throwable e ) { onError ( ctx , e ) ; } } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { sendPreface ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; super . channelInactive ( ctx ) ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; } private void cleanup ( ) { if ( clientPrefaceString ! = null ) { clientPrefaceString . release ( ) ; clientPrefaceString = null ; } } private boolean readClientPrefaceString ( ByteBuf in ) throws Http2Exception { if ( clientPrefaceString = = null ) { return true ; } int prefaceRemaining = clientPrefaceString . readableBytes ( ) ; int bytesRead = min ( in . readableBytes ( ) , prefaceRemaining ) ; if ( bytesRead = = <int> | | ! ByteBufUtil . equals ( in , in . readerIndex ( ) , clientPrefaceString , clientPrefaceString . readerIndex ( ) , bytesRead ) ) { String receivedBytes = hexDump ( in , in . readerIndex ( ) , min ( in . readableBytes ( ) , clientPrefaceString . readableBytes ( ) ) ) ; throw connectionError ( PROTOCOL_ERROR , <str> + <str> , receivedBytes ) ; } in . skipBytes ( bytesRead ) ; clientPrefaceString . skipBytes ( bytesRead ) ; if ( ! clientPrefaceString . isReadable ( ) ) { clientPrefaceString . release ( ) ; clientPrefaceString = null ; return true ; } return false ; } private boolean verifyFirstFrameIsSettings ( ByteBuf in ) throws Http2Exception { if ( in . readableBytes ( ) < <int> ) { return false ; } short frameType = in . getUnsignedByte ( in . readerIndex ( ) + <int> ) ; short flags = in . getUnsignedByte ( in . readerIndex ( ) + <int> ) ; if ( frameType ! = SETTINGS | | ( flags & Http2Flags . ACK ) ! = <int> ) { throw connectionError ( PROTOCOL_ERROR , <str> + <str> , hexDump ( in , in . readerIndex ( ) , <int> ) ) ; } return true ; } private void sendPreface ( ChannelHandlerContext ctx ) { if ( prefaceSent | | ! ctx . channel ( ) . isActive ( ) ) { return ; } prefaceSent = true ; if ( ! connection ( ) . isServer ( ) ) { ctx . write ( connectionPrefaceBuf ( ) ) . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; } encoder . writeSettings ( ctx , initialSettings , ctx . newPromise ( ) ) . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; } } private final class FrameDecoder extends BaseDecoder { @Override public void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { decoder . decodeFrame ( ctx , in , out ) ; } catch ( Throwable e ) { onError ( ctx , e ) ; } } } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { encoder . lifecycleManager ( this ) ; decoder . lifecycleManager ( this ) ; encoder . flowController ( ) . channelHandlerContext ( ctx ) ; decoder . flowController ( ) . channelHandlerContext ( ctx ) ; byteDecoder = new PrefaceDecoder ( ctx ) ; } @Override protected void handlerRemoved0 ( ChannelHandlerContext ctx ) throws Exception { if ( byteDecoder ! = null ) { byteDecoder . handlerRemoved ( ctx ) ; byteDecoder = null ; } } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { if ( byteDecoder = = null ) { byteDecoder = new PrefaceDecoder ( ctx ) ; } byteDecoder . channelActive ( ctx ) ; super . channelActive ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { super . channelInactive ( ctx ) ; if ( byteDecoder ! = null ) { byteDecoder . channelInactive ( ctx ) ; byteDecoder = null ; } } @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { try { if ( ctx . channel ( ) . isWritable ( ) ) { flush ( ctx ) ; } encoder . flowController ( ) . channelWritabilityChanged ( ) ; } finally { super . channelWritabilityChanged ( ctx ) ; } } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { byteDecoder . decode ( ctx , in , out ) ; } @Override public void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . bind ( localAddress , promise ) ; } @Override public void connect ( ChannelHandlerContext ctx , SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . connect ( remoteAddress , localAddress , promise ) ; } @Override public void disconnect ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . disconnect ( promise ) ; } @Override public void close ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { if ( ! ctx . channel ( ) . isActive ( ) ) { ctx . close ( promise ) ; return ; } ChannelFuture future = goAway ( ctx , null ) ; ctx . flush ( ) ; doGracefulShutdown ( ctx , future , promise ) ; } private void doGracefulShutdown ( ChannelHandlerContext ctx , ChannelFuture future , ChannelPromise promise ) { if ( isGracefulShutdownComplete ( ) ) { future . addListener ( new ClosingChannelFutureListener ( ctx , promise ) ) ; } else { closeListener = new ClosingChannelFutureListener ( ctx , promise , gracefulShutdownTimeoutMillis , MILLISECONDS ) ; } } @Override public void deregister ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . deregister ( promise ) ; } @Override public void read ( ChannelHandlerContext ctx ) throws Exception { ctx . read ( ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { ctx . write ( msg , promise ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { try { flush ( ctx ) ; } finally { super . channelReadComplete ( ctx ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( getEmbeddedHttp2Exception ( cause ) ! = null ) { onError ( ctx , cause ) ; } else { super . exceptionCaught ( ctx , cause ) ; } } @Override public void closeStreamLocal ( Http2Stream stream , ChannelFuture future ) { switch ( stream . state ( ) ) { case HALF_CLOSED_LOCAL : case OPEN : stream . closeLocalSide ( ) ; break ; default : closeStream ( stream , future ) ; break ; } } @Override public void closeStreamRemote ( Http2Stream stream , ChannelFuture future ) { switch ( stream . state ( ) ) { case HALF_CLOSED_REMOTE : case OPEN : stream . closeRemoteSide ( ) ; break ; default : closeStream ( stream , future ) ; break ; } } @Override public void closeStream ( final Http2Stream stream , ChannelFuture future ) { stream . close ( ) ; if ( future . isDone ( ) ) { checkCloseConnection ( future ) ; } else { future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { checkCloseConnection ( future ) ; } } ) ; } } @Override public void onError ( ChannelHandlerContext ctx , Throwable cause ) { Http2Exception embedded = getEmbeddedHttp2Exception ( cause ) ; if ( isStreamError ( embedded ) ) { onStreamError ( ctx , cause , ( StreamException ) embedded ) ; } else if ( embedded instanceof CompositeStreamException ) { CompositeStreamException compositException = ( CompositeStreamException ) embedded ; for ( StreamException streamException : compositException ) { onStreamError ( ctx , cause , streamException ) ; } } else { onConnectionError ( ctx , cause , embedded ) ; } ctx . flush ( ) ; } protected boolean isGracefulShutdownComplete ( ) { return connection ( ) . numActiveStreams ( ) = = <int> ; } protected void onConnectionError ( ChannelHandlerContext ctx , Throwable cause , Http2Exception http2Ex ) { if ( http2Ex = = null ) { http2Ex = new Http2Exception ( INTERNAL_ERROR , cause . getMessage ( ) , cause ) ; } ChannelPromise promise = ctx . newPromise ( ) ; ChannelFuture future = goAway ( ctx , http2Ex ) ; switch ( http2Ex . shutdownHint ( ) ) { case GRACEFUL_SHUTDOWN : doGracefulShutdown ( ctx , future , promise ) ; break ; default : future . addListener ( new ClosingChannelFutureListener ( ctx , promise ) ) ; break ; } } protected void onStreamError ( ChannelHandlerContext ctx , @SuppressWarnings ( <str> ) Throwable cause , StreamException http2Ex ) { resetStream ( ctx , http2Ex . streamId ( ) , http2Ex . error ( ) . code ( ) , ctx . newPromise ( ) ) ; } protected Http2FrameWriter frameWriter ( ) { return encoder ( ) . frameWriter ( ) ; } @Override public ChannelFuture resetStream ( final ChannelHandlerContext ctx , int streamId , long errorCode , final ChannelPromise promise ) { final Http2Stream stream = connection ( ) . stream ( streamId ) ; if ( stream = = null | | stream . isResetSent ( ) ) { return promise . setSuccess ( ) ; } final ChannelFuture future ; if ( stream . state ( ) = = IDLE | | ( connection ( ) . local ( ) . created ( stream ) & & ! stream . isHeaderSent ( ) ) ) { future = promise . setSuccess ( ) ; } else { future = frameWriter ( ) . writeRstStream ( ctx , streamId , errorCode , promise ) ; } stream . resetSent ( ) ; future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( future . isSuccess ( ) ) { closeStream ( stream , promise ) ; } else { onConnectionError ( ctx , future . cause ( ) , null ) ; } } } ) ; return future ; } @Override public ChannelFuture goAway ( final ChannelHandlerContext ctx , final int lastStreamId , final long errorCode , final ByteBuf debugData , ChannelPromise promise ) { try { final Http2Connection connection = connection ( ) ; if ( connection . goAwaySent ( ) & & lastStreamId > connection . remote ( ) . lastStreamKnownByPeer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> + <str> , connection . remote ( ) . lastStreamKnownByPeer ( ) , lastStreamId ) ; } connection . goAwaySent ( lastStreamId , errorCode , debugData ) ; debugData . retain ( ) ; ChannelFuture future = frameWriter ( ) . writeGoAway ( ctx , lastStreamId , errorCode , debugData , promise ) ; if ( future . isDone ( ) ) { processGoAwayWriteResult ( ctx , lastStreamId , errorCode , debugData , future ) ; } else { future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { processGoAwayWriteResult ( ctx , lastStreamId , errorCode , debugData , future ) ; } } ) ; } return future ; } catch ( Throwable cause ) { debugData . release ( ) ; return promise . setFailure ( cause ) ; } } private void checkCloseConnection ( ChannelFuture future ) { if ( closeListener ! = null & & isGracefulShutdownComplete ( ) ) { ChannelFutureListener closeListener = Http2ConnectionHandler . this . closeListener ; Http2ConnectionHandler . this . closeListener = null ; try { closeListener . operationComplete ( future ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> , e ) ; } } } private ChannelFuture goAway ( ChannelHandlerContext ctx , Http2Exception cause ) { long errorCode = cause ! = null ? cause . error ( ) . code ( ) : NO_ERROR . code ( ) ; ByteBuf debugData = Http2CodecUtil . toByteBuf ( ctx , cause ) ; int lastKnownStream = connection ( ) . remote ( ) . lastStreamCreated ( ) ; return goAway ( ctx , lastKnownStream , errorCode , debugData , ctx . newPromise ( ) ) ; } private static ByteBuf clientPrefaceString ( Http2Connection connection ) { return connection . isServer ( ) ? connectionPrefaceBuf ( ) : null ; } private static void processGoAwayWriteResult ( final ChannelHandlerContext ctx , final int lastStreamId , final long errorCode , final ByteBuf debugData , ChannelFuture future ) { try { if ( future . isSuccess ( ) ) { if ( errorCode ! = NO_ERROR . code ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( <str> + <str> , lastStreamId , errorCode , debugData . toString ( UTF_8 ) ) , future . cause ( ) ) ; } ctx . close ( ) ; } } else { if ( logger . isErrorEnabled ( ) ) { logger . error ( format ( <str> + <str> , lastStreamId , errorCode , debugData . toString ( UTF_8 ) ) , future . cause ( ) ) ; } ctx . close ( ) ; } } finally { debugData . release ( ) ; } } private static final class ClosingChannelFutureListener implements ChannelFutureListener { private final ChannelHandlerContext ctx ; private final ChannelPromise promise ; private final ScheduledFuture < ? > timeoutTask ; ClosingChannelFutureListener ( ChannelHandlerContext ctx , ChannelPromise promise ) { this . ctx = ctx ; this . promise = promise ; timeoutTask = null ; } ClosingChannelFutureListener ( final ChannelHandlerContext ctx , final ChannelPromise promise , long timeout , TimeUnit unit ) { this . ctx = ctx ; this . promise = promise ; timeoutTask = ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { ctx . close ( promise ) ; } } , timeout , unit ) ; } @Override public void operationComplete ( ChannelFuture sentGoAwayFuture ) throws Exception { if ( timeoutTask ! = null ) { timeoutTask . cancel ( false ) ; } ctx . close ( promise ) ; } } } 
