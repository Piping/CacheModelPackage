package org . elasticsearch . indices ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . MockIndexEventListener ; import org . hamcrest . Matchers ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . BooleanSupplier ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . builder ; import static org . elasticsearch . index . shard . IndexShardState . CLOSED ; import static org . elasticsearch . index . shard . IndexShardState . CREATED ; import static org . elasticsearch . index . shard . IndexShardState . POST_RECOVERY ; import static org . elasticsearch . index . shard . IndexShardState . RECOVERING ; import static org . elasticsearch . index . shard . IndexShardState . STARTED ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . hasSize ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class IndicesLifecycleListenerIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockIndexEventListener . TestPlugin . class ) ; } public void testBeforeIndexAddedToCluster ( ) throws Exception { String node1 = internalCluster ( ) . startNode ( ) ; String node2 = internalCluster ( ) . startNode ( ) ; String node3 = internalCluster ( ) . startNode ( ) ; final AtomicInteger beforeAddedCount = new AtomicInteger ( <int> ) ; final AtomicInteger allCreatedCount = new AtomicInteger ( <int> ) ; IndexEventListener listener = new IndexEventListener ( ) { @Override public void beforeIndexAddedToCluster ( Index index , Settings indexSettings ) { beforeAddedCount . incrementAndGet ( ) ; if ( indexSettings . getAsBoolean ( <str> , false ) ) { throw new ElasticsearchException ( <str> ) ; } } @Override public void beforeIndexCreated ( Index index , Settings indexSettings ) { allCreatedCount . incrementAndGet ( ) ; } } ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node1 ) . setNewDelegate ( listener ) ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node2 ) . setNewDelegate ( listener ) ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node3 ) . setNewDelegate ( listener ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> , IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . get ( ) ; ensureGreen ( <str> ) ; assertThat ( <str> , beforeAddedCount . get ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , allCreatedCount . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; try { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( <str> , true ) . get ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertFalse ( resp . getState ( ) . routingTable ( ) . indicesRouting ( ) . keys ( ) . contains ( <str> ) ) ; } } public void testIndexShardFailedOnRelocation ( ) throws Throwable { String node1 = internalCluster ( ) . startNode ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) . get ( ) ; ensureGreen ( <str> ) ; String node2 = internalCluster ( ) . startNode ( ) ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node2 ) . setNewDelegate ( new IndexShardStateChangeListener ( ) { @Override public void beforeIndexCreated ( Index index , Settings indexSettings ) { throw new RuntimeException ( <str> ) ; } } ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node1 , node2 ) ) . get ( ) ; ensureGreen ( <str> ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; List < ShardRouting > shard = state . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) ; assertThat ( shard , hasSize ( <int> ) ) ; assertThat ( state . nodes ( ) . resolveNode ( shard . get ( <int> ) . currentNodeId ( ) ) . getName ( ) , Matchers . equalTo ( node1 ) ) ; } public void testIndexStateShardChanged ( ) throws Throwable { String node1 = internalCluster ( ) . startNode ( ) ; IndexShardStateChangeListener stateChangeListenerNode1 = new IndexShardStateChangeListener ( ) ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node1 ) . setNewDelegate ( stateChangeListenerNode1 ) ; try { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , <str> , true ) . get ( ) ; fail ( <str> ) ; } catch ( ElasticsearchException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertFalse ( resp . getState ( ) . routingTable ( ) . indicesRouting ( ) . keys ( ) . contains ( <str> ) ) ; } assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) ) ; ensureGreen ( ) ; assertThat ( stateChangeListenerNode1 . creationSettings . getAsInt ( SETTING_NUMBER_OF_SHARDS , - <int> ) , equalTo ( <int> ) ) ; assertThat ( stateChangeListenerNode1 . creationSettings . getAsInt ( SETTING_NUMBER_OF_REPLICAS , - <int> ) , equalTo ( <int> ) ) ; assertShardStatesMatch ( stateChangeListenerNode1 , <int> , CREATED , RECOVERING , POST_RECOVERY , STARTED ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; String node2 = internalCluster ( ) . startNode ( ) ; IndexShardStateChangeListener stateChangeListenerNode2 = new IndexShardStateChangeListener ( ) ; internalCluster ( ) . getInstance ( MockIndexEventListener . TestEventListener . class , node2 ) . setNewDelegate ( stateChangeListenerNode2 ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( builder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) ) ; ensureGreen ( ) ; assertShardStatesMatch ( stateChangeListenerNode1 , <int> , CLOSED ) ; assertShardStatesMatch ( stateChangeListenerNode2 , <int> , CREATED , RECOVERING , POST_RECOVERY , STARTED ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( builder ( ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( ) ; assertShardStatesMatch ( stateChangeListenerNode1 , <int> , CREATED , RECOVERING , POST_RECOVERY , STARTED ) ; assertShardStatesMatch ( stateChangeListenerNode2 , <int> , CREATED , RECOVERING , POST_RECOVERY , STARTED ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) ) ; assertThat ( stateChangeListenerNode1 . afterCloseSettings . getAsInt ( SETTING_NUMBER_OF_SHARDS , - <int> ) , equalTo ( <int> ) ) ; assertThat ( stateChangeListenerNode1 . afterCloseSettings . getAsInt ( SETTING_NUMBER_OF_REPLICAS , - <int> ) , equalTo ( <int> ) ) ; assertShardStatesMatch ( stateChangeListenerNode1 , <int> , CLOSED ) ; assertShardStatesMatch ( stateChangeListenerNode2 , <int> , CLOSED ) ; } private static void assertShardStatesMatch ( final IndexShardStateChangeListener stateChangeListener , final int numShards , final IndexShardState . . . shardStates ) throws InterruptedException { BooleanSupplier waitPredicate = ( ) - > { if ( stateChangeListener . shardStates . size ( ) ! = numShards ) { return false ; } for ( List < IndexShardState > indexShardStates : stateChangeListener . shardStates . values ( ) ) { if ( indexShardStates = = null | | indexShardStates . size ( ) ! = shardStates . length ) { return false ; } for ( int i = <int> ; i < shardStates . length ; i + + ) { if ( indexShardStates . get ( i ) ! = shardStates [ i ] ) { return false ; } } } return true ; } ; if ( ! awaitBusy ( waitPredicate , <int> , TimeUnit . MINUTES ) ) { fail ( <str> + <str> + numShards + <str> + Strings . arrayToCommaDelimitedString ( shardStates ) + <str> + <str> + stateChangeListener ) ; } stateChangeListener . shardStates . clear ( ) ; } private static class IndexShardStateChangeListener implements IndexEventListener { final ConcurrentMap < ShardId , List < IndexShardState > > shardStates = new ConcurrentHashMap < > ( ) ; Settings creationSettings = Settings . EMPTY ; Settings afterCloseSettings = Settings . EMPTY ; @Override public void indexShardStateChanged ( IndexShard indexShard , @Nullable IndexShardState previousState , IndexShardState newState , @Nullable String reason ) { List < IndexShardState > shardStates = this . shardStates . putIfAbsent ( indexShard . shardId ( ) , new CopyOnWriteArrayList < > ( new IndexShardState [ ] { newState } ) ) ; if ( shardStates ! = null ) { shardStates . add ( newState ) ; } } @Override public void beforeIndexCreated ( Index index , Settings indexSettings ) { this . creationSettings = indexSettings ; if ( indexSettings . getAsBoolean ( <str> , false ) ) { throw new ElasticsearchException ( <str> ) ; } } @Override public void afterIndexShardClosed ( ShardId shardId , @Nullable IndexShard indexShard , Settings indexSettings ) { this . afterCloseSettings = indexSettings ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < ShardId , List < IndexShardState > > entry : shardStates . entrySet ( ) ) { sb . append ( entry . getKey ( ) ) . append ( <str> ) . append ( Strings . collectionToCommaDelimitedString ( entry . getValue ( ) ) ) . append ( <str> ) ; } return sb . toString ( ) ; } } } 
