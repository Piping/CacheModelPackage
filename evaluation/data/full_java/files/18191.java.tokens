package com . badlogic . gdx . math ; public abstract class Interpolation { abstract public float apply ( float a ) ; public float apply ( float start , float end , float a ) { return start + ( end - start ) * apply ( a ) ; } static public final Interpolation linear = new Interpolation ( ) { public float apply ( float a ) { return a ; } } ; static public final Interpolation fade = new Interpolation ( ) { public float apply ( float a ) { return MathUtils . clamp ( a * a * a * ( a * ( a * <int> - <int> ) + <int> ) , <int> , <int> ) ; } } ; static public final Pow pow2 = new Pow ( <int> ) ; static public final PowIn pow2In = new PowIn ( <int> ) ; static public final PowOut pow2Out = new PowOut ( <int> ) ; static public final Pow pow3 = new Pow ( <int> ) ; static public final PowIn pow3In = new PowIn ( <int> ) ; static public final PowOut pow3Out = new PowOut ( <int> ) ; static public final Pow pow4 = new Pow ( <int> ) ; static public final PowIn pow4In = new PowIn ( <int> ) ; static public final PowOut pow4Out = new PowOut ( <int> ) ; static public final Pow pow5 = new Pow ( <int> ) ; static public final PowIn pow5In = new PowIn ( <int> ) ; static public final PowOut pow5Out = new PowOut ( <int> ) ; static public final Interpolation sine = new Interpolation ( ) { public float apply ( float a ) { return ( <int> - MathUtils . cos ( a * MathUtils . PI ) ) / <int> ; } } ; static public final Interpolation sineIn = new Interpolation ( ) { public float apply ( float a ) { return <int> - MathUtils . cos ( a * MathUtils . PI / <int> ) ; } } ; static public final Interpolation sineOut = new Interpolation ( ) { public float apply ( float a ) { return MathUtils . sin ( a * MathUtils . PI / <int> ) ; } } ; static public final Exp exp10 = new Exp ( <int> , <int> ) ; static public final ExpIn exp10In = new ExpIn ( <int> , <int> ) ; static public final ExpOut exp10Out = new ExpOut ( <int> , <int> ) ; static public final Exp exp5 = new Exp ( <int> , <int> ) ; static public final ExpIn exp5In = new ExpIn ( <int> , <int> ) ; static public final ExpOut exp5Out = new ExpOut ( <int> , <int> ) ; static public final Interpolation circle = new Interpolation ( ) { public float apply ( float a ) { if ( a < = <float> ) { a * = <int> ; return ( <int> - ( float ) Math . sqrt ( <int> - a * a ) ) / <int> ; } a - - ; a * = <int> ; return ( ( float ) Math . sqrt ( <int> - a * a ) + <int> ) / <int> ; } } ; static public final Interpolation circleIn = new Interpolation ( ) { public float apply ( float a ) { return <int> - ( float ) Math . sqrt ( <int> - a * a ) ; } } ; static public final Interpolation circleOut = new Interpolation ( ) { public float apply ( float a ) { a - - ; return ( float ) Math . sqrt ( <int> - a * a ) ; } } ; static public final Elastic elastic = new Elastic ( <int> , <int> , <int> , <int> ) ; static public final ElasticIn elasticIn = new ElasticIn ( <int> , <int> , <int> , <int> ) ; static public final ElasticOut elasticOut = new ElasticOut ( <int> , <int> , <int> , <int> ) ; static public final Swing swing = new Swing ( <float> ) ; static public final SwingIn swingIn = new SwingIn ( <float> ) ; static public final SwingOut swingOut = new SwingOut ( <float> ) ; static public final Bounce bounce = new Bounce ( <int> ) ; static public final BounceIn bounceIn = new BounceIn ( <int> ) ; static public final BounceOut bounceOut = new BounceOut ( <int> ) ; static public class Pow extends Interpolation { final int power ; public Pow ( int power ) { this . power = power ; } public float apply ( float a ) { if ( a < = <float> ) return ( float ) Math . pow ( a * <int> , power ) / <int> ; return ( float ) Math . pow ( ( a - <int> ) * <int> , power ) / ( power % <int> = = <int> ? - <int> : <int> ) + <int> ; } } static public class PowIn extends Pow { public PowIn ( int power ) { super ( power ) ; } public float apply ( float a ) { return ( float ) Math . pow ( a , power ) ; } } static public class PowOut extends Pow { public PowOut ( int power ) { super ( power ) ; } public float apply ( float a ) { return ( float ) Math . pow ( a - <int> , power ) * ( power % <int> = = <int> ? - <int> : <int> ) + <int> ; } } static public class Exp extends Interpolation { final float value , power , min , scale ; public Exp ( float value , float power ) { this . value = value ; this . power = power ; min = ( float ) Math . pow ( value , - power ) ; scale = <int> / ( <int> - min ) ; } public float apply ( float a ) { if ( a < = <float> ) return ( ( float ) Math . pow ( value , power * ( a * <int> - <int> ) ) - min ) * scale / <int> ; return ( <int> - ( ( float ) Math . pow ( value , - power * ( a * <int> - <int> ) ) - min ) * scale ) / <int> ; } } ; static public class ExpIn extends Exp { public ExpIn ( float value , float power ) { super ( value , power ) ; } public float apply ( float a ) { return ( ( float ) Math . pow ( value , power * ( a - <int> ) ) - min ) * scale ; } } static public class ExpOut extends Exp { public ExpOut ( float value , float power ) { super ( value , power ) ; } public float apply ( float a ) { return <int> - ( ( float ) Math . pow ( value , - power * a ) - min ) * scale ; } } static public class Elastic extends Interpolation { final float value , power , scale , bounces ; public Elastic ( float value , float power , int bounces , float scale ) { this . value = value ; this . power = power ; this . scale = scale ; this . bounces = bounces * MathUtils . PI * ( bounces % <int> = = <int> ? <int> : - <int> ) ; } public float apply ( float a ) { if ( a < = <float> ) { a * = <int> ; return ( float ) Math . pow ( value , power * ( a - <int> ) ) * MathUtils . sin ( a * bounces ) * scale / <int> ; } a = <int> - a ; a * = <int> ; return <int> - ( float ) Math . pow ( value , power * ( a - <int> ) ) * MathUtils . sin ( ( a ) * bounces ) * scale / <int> ; } } static public class ElasticIn extends Elastic { public ElasticIn ( float value , float power , int bounces , float scale ) { super ( value , power , bounces , scale ) ; } public float apply ( float a ) { if ( a > = <float> ) return <int> ; return ( float ) Math . pow ( value , power * ( a - <int> ) ) * MathUtils . sin ( a * bounces ) * scale ; } } static public class ElasticOut extends Elastic { public ElasticOut ( float value , float power , int bounces , float scale ) { super ( value , power , bounces , scale ) ; } public float apply ( float a ) { a = <int> - a ; return ( <int> - ( float ) Math . pow ( value , power * ( a - <int> ) ) * MathUtils . sin ( a * bounces ) * scale ) ; } } static public class Bounce extends BounceOut { public Bounce ( float [ ] widths , float [ ] heights ) { super ( widths , heights ) ; } public Bounce ( int bounces ) { super ( bounces ) ; } private float out ( float a ) { float test = a + widths [ <int> ] / <int> ; if ( test < widths [ <int> ] ) return test / ( widths [ <int> ] / <int> ) - <int> ; return super . apply ( a ) ; } public float apply ( float a ) { if ( a < = <float> ) return ( <int> - out ( <int> - a * <int> ) ) / <int> ; return out ( a * <int> - <int> ) / <int> + <float> ; } } static public class BounceOut extends Interpolation { final float [ ] widths , heights ; public BounceOut ( float [ ] widths , float [ ] heights ) { if ( widths . length ! = heights . length ) throw new IllegalArgumentException ( <str> ) ; this . widths = widths ; this . heights = heights ; } public BounceOut ( int bounces ) { if ( bounces < <int> | | bounces > <int> ) throw new IllegalArgumentException ( <str> + bounces ) ; widths = new float [ bounces ] ; heights = new float [ bounces ] ; heights [ <int> ] = <int> ; switch ( bounces ) { case <int> : widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; heights [ <int> ] = <float> ; break ; case <int> : widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; break ; case <int> : widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; break ; case <int> : widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; widths [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; heights [ <int> ] = <float> ; break ; } widths [ <int> ] * = <int> ; } public float apply ( float a ) { a + = widths [ <int> ] / <int> ; float width = <int> , height = <int> ; for ( int i = <int> , n = widths . length ; i < n ; i + + ) { width = widths [ i ] ; if ( a < = width ) { height = heights [ i ] ; break ; } a - = width ; } a / = width ; float z = <int> / width * height * a ; return <int> - ( z - z * a ) * width ; } } static public class BounceIn extends BounceOut { public BounceIn ( float [ ] widths , float [ ] heights ) { super ( widths , heights ) ; } public BounceIn ( int bounces ) { super ( bounces ) ; } public float apply ( float a ) { return <int> - super . apply ( <int> - a ) ; } } static public class Swing extends Interpolation { private final float scale ; public Swing ( float scale ) { this . scale = scale * <int> ; } public float apply ( float a ) { if ( a < = <float> ) { a * = <int> ; return a * a * ( ( scale + <int> ) * a - scale ) / <int> ; } a - - ; a * = <int> ; return a * a * ( ( scale + <int> ) * a + scale ) / <int> + <int> ; } } static public class SwingOut extends Interpolation { private final float scale ; public SwingOut ( float scale ) { this . scale = scale ; } public float apply ( float a ) { a - - ; return a * a * ( ( scale + <int> ) * a + scale ) + <int> ; } } static public class SwingIn extends Interpolation { private final float scale ; public SwingIn ( float scale ) { this . scale = scale ; } public float apply ( float a ) { return a * a * ( ( scale + <int> ) * a - scale ) ; } } } 
