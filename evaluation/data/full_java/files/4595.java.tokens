package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import java . util . ArrayList ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . AsynchronousModel ; import org . eclipse . debug . internal . ui . viewers . AsynchronousTableViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStatusMonitor ; import org . eclipse . debug . internal . ui . viewers . provisional . ILabelRequestMonitor ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . swt . events . SelectionAdapter ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . SelectionListener ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . ScrollBar ; import org . eclipse . swt . widgets . Table ; import org . eclipse . swt . widgets . TableColumn ; import org . eclipse . swt . widgets . TableItem ; import org . eclipse . ui . progress . UIJob ; abstract public class AsyncVirtualContentTableViewer extends AsynchronousTableViewer { private Object fPendingTopIndexKey ; private ArrayList < Object > fTopIndexQueue = new ArrayList < Object > ( ) ; private boolean fPendingResizeColumns ; private ListenerList fVirtualContentListeners ; private SelectionListener fScrollSelectionListener ; private ListenerList fPresentationErrorListeners ; private Object fTopIndexKey ; public AsyncVirtualContentTableViewer ( Composite parent , int style ) { super ( parent , style ) ; fVirtualContentListeners = new ListenerList ( ) ; fPresentationErrorListeners = new ListenerList ( ) ; initScrollBarListener ( ) ; } private void initScrollBarListener ( ) { ScrollBar scroll = getTable ( ) . getVerticalBar ( ) ; fScrollSelectionListener = new SelectionAdapter ( ) { @Override public void widgetSelected ( SelectionEvent e ) { handleScrollBarSelection ( ) ; } } ; scroll . addSelectionListener ( fScrollSelectionListener ) ; } public void setTopIndex ( Object key ) { fPendingTopIndexKey = key ; attemptSetTopIndex ( ) ; } protected Object getPendingSetTopIndexKey ( ) { return fPendingTopIndexKey ; } @Override protected void handlePresentationFailure ( IStatusMonitor monitor , IStatus status ) { notifyPresentationError ( monitor , status ) ; } public void disposeColumns ( ) { TableColumn [ ] oldColumns = getTable ( ) . getColumns ( ) ; for ( int i = <int> ; i < oldColumns . length ; i + + ) { oldColumns [ i ] . dispose ( ) ; } } public void disposeCellEditors ( ) { CellEditor [ ] oldCellEditors = getCellEditors ( ) ; if ( oldCellEditors ! = null ) { for ( int i = <int> ; i < oldCellEditors . length ; i + + ) { oldCellEditors [ i ] . dispose ( ) ; } } } public void resizeColumnsToPreferredSize ( ) { fPendingResizeColumns = true ; fPendingResizeColumns = attemptResizeColumnsToPreferredSize ( ) ; } private boolean attemptResizeColumnsToPreferredSize ( ) { if ( fPendingResizeColumns ) { if ( ! hasPendingUpdates ( ) ) { UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { Table table = getTable ( ) ; if ( ! table . isDisposed ( ) ) { if ( table . getSize ( ) . x > <int> ) { TableColumn [ ] columns = table . getColumns ( ) ; for ( int i = <int> ; i < columns . length - <int> ; i + + ) { columns [ i ] . pack ( ) ; } } else { fPendingResizeColumns = true ; } } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; return false ; } } return fPendingResizeColumns ; } protected synchronized void attemptSetTopIndex ( ) { if ( fPendingTopIndexKey ! = null ) { Object remaining = doAttemptSetTopIndex ( fPendingTopIndexKey ) ; if ( remaining = = null ) { fPendingTopIndexKey = remaining ; } } } private synchronized Object doAttemptSetTopIndex ( final Object topIndexKey ) { final int i = getVirtualContentModel ( ) . indexOfKey ( topIndexKey ) ; if ( i > = <int> ) { UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( getTable ( ) . isDisposed ( ) ) { fTopIndexQueue . clear ( ) ; return Status . OK_STATUS ; } int idx = getVirtualContentModel ( ) . indexOfKey ( topIndexKey ) ; if ( idx > = <int> ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + ( ( BigInteger ) topIndexKey ) . toString ( <int> ) ) ; } fPendingTopIndexKey = null ; setTopIndexKey ( topIndexKey ) ; getTable ( ) . setTopIndex ( idx ) ; tableTopIndexSetComplete ( ) ; if ( getTable ( ) . getTopIndex ( ) ! = idx ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + ( ( BigInteger ) topIndexKey ) . toString ( <int> ) ) ; } if ( hasPendingUpdates ( ) ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + ( ( BigInteger ) topIndexKey ) . toString ( <int> ) ) ; } fPendingTopIndexKey = topIndexKey ; } } } else { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + topIndexKey ) ; } fPendingTopIndexKey = topIndexKey ; } removeKeyFromQueue ( topIndexKey ) ; return Status . OK_STATUS ; } } ; addKeyToQueue ( topIndexKey ) ; job . setSystem ( true ) ; job . schedule ( ) ; return topIndexKey ; } return topIndexKey ; } protected void tableTopIndexSetComplete ( ) { } public void addVirtualContentListener ( IVirtualContentListener listener ) { fVirtualContentListeners . add ( listener ) ; } public void removeVirtualContentListener ( IVirtualContentListener listener ) { fVirtualContentListeners . remove ( listener ) ; } protected void notifyListenersAtBufferStart ( ) { int topIdx = getTable ( ) . getTopIndex ( ) ; Object [ ] listeners = fVirtualContentListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { final IVirtualContentListener listener = ( IVirtualContentListener ) listeners [ i ] ; if ( topIdx < listener . getThreshold ( IVirtualContentListener . BUFFER_START ) ) { SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { listener . handledAtBufferStart ( ) ; } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } protected void notifyListenersAtBufferEnd ( ) { Object [ ] listeners = fVirtualContentListeners . getListeners ( ) ; int topIdx = getTable ( ) . getTopIndex ( ) ; int bottomIdx = topIdx + getNumberOfVisibleLines ( ) ; int elementsCnt = getVirtualContentModel ( ) . getElements ( ) . length ; int numLinesLeft = elementsCnt - bottomIdx ; for ( int i = <int> ; i < listeners . length ; i + + ) { final IVirtualContentListener listener = ( IVirtualContentListener ) listeners [ i ] ; if ( numLinesLeft < = listener . getThreshold ( IVirtualContentListener . BUFFER_END ) ) { SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { listener . handleAtBufferEnd ( ) ; } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } protected void handleScrollBarSelection ( ) { if ( ! fTopIndexQueue . isEmpty ( ) ) { return ; } topIndexChanged ( ) ; } public void topIndexChanged ( ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { MemorySegment a = ( MemorySegment ) getTable ( ) . getItem ( getTable ( ) . getTopIndex ( ) ) . getData ( ) ; DebugUIPlugin . trace ( Thread . currentThread ( ) . getName ( ) + <str> + this + <str> + a . getAddress ( ) . toString ( <int> ) ) ; } setTopIndexKey ( getVirtualContentModel ( ) . getKey ( getTable ( ) . getTopIndex ( ) ) ) ; notifyListenersAtBufferStart ( ) ; notifyListenersAtBufferEnd ( ) ; } protected void setTopIndexKey ( Object key ) { fTopIndexKey = key ; } protected Object getTopIndexKey ( ) { return fTopIndexKey ; } @Override protected synchronized void preservingSelection ( Runnable updateCode ) { Object oldTopIndexKey = null ; if ( fPendingTopIndexKey = = null ) { oldTopIndexKey = getTopIndexKey ( ) ; } else { oldTopIndexKey = fPendingTopIndexKey ; } try { updateCode . run ( ) ; } finally { if ( oldTopIndexKey ! = null ) { setTopIndex ( oldTopIndexKey ) ; } } } public void addPresentationErrorListener ( IPresentationErrorListener errorListener ) { fPresentationErrorListeners . add ( errorListener ) ; } public void removePresentationErrorListener ( IPresentationErrorListener errorListener ) { fPresentationErrorListeners . remove ( errorListener ) ; } private void notifyPresentationError ( final IStatusMonitor monitor , final IStatus status ) { Object [ ] listeners = fPresentationErrorListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { if ( listeners [ i ] instanceof IPresentationErrorListener ) { final IPresentationErrorListener listener = ( IPresentationErrorListener ) listeners [ i ] ; SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { listener . handlePresentationFailure ( monitor , status ) ; } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } @Override protected AsynchronousModel createModel ( ) { return createVirtualContentTableModel ( ) ; } abstract protected AbstractVirtualContentTableModel createVirtualContentTableModel ( ) ; private void addKeyToQueue ( Object topIndexKey ) { synchronized ( fTopIndexQueue ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + ( ( BigInteger ) topIndexKey ) . toString ( <int> ) ) ; } fTopIndexQueue . add ( topIndexKey ) ; } } private void removeKeyFromQueue ( Object topIndexKey ) { synchronized ( fTopIndexQueue ) { if ( DebugUIPlugin . DEBUG_DYNAMIC_LOADING ) { DebugUIPlugin . trace ( <str> + ( ( BigInteger ) topIndexKey ) . toString ( <int> ) ) ; } fTopIndexQueue . remove ( topIndexKey ) ; } } public AbstractVirtualContentTableModel getVirtualContentModel ( ) { if ( getModel ( ) instanceof AbstractVirtualContentTableModel ) { return ( AbstractVirtualContentTableModel ) getModel ( ) ; } return null ; } private int getNumberOfVisibleLines ( ) { Table table = getTable ( ) ; int height = table . getSize ( ) . y ; if ( height = = <int> ) { height = table . getParent ( ) . getSize ( ) . y ; } int border = table . getHeaderHeight ( ) ; int scroll = table . getHorizontalBar ( ) . getSize ( ) . y ; height = height - border - scroll ; int lineHeight = getMinTableItemHeight ( table ) ; int numberOfLines = height / lineHeight ; if ( numberOfLines < = <int> ) { return <int> ; } return numberOfLines ; } private int getMinTableItemHeight ( Table table ) { if ( MemoryViewUtil . isLinuxGTK ( ) ) { TableItem [ ] items = table . getItems ( ) ; int minHeight = table . getItemHeight ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { if ( items [ i ] . getData ( ) ! = null ) { minHeight = Math . min ( items [ i ] . getBounds ( <int> ) . height , minHeight ) ; } } return minHeight ; } return table . getItemHeight ( ) ; } @Override protected void updateComplete ( IStatusMonitor monitor ) { super . updateComplete ( monitor ) ; attemptSetTopIndex ( ) ; if ( monitor instanceof ILabelRequestMonitor ) { fPendingResizeColumns = attemptResizeColumnsToPreferredSize ( ) ; } } protected boolean hasPendingSetTopIndex ( ) { return ! fTopIndexQueue . isEmpty ( ) ; } } 
