package com . google . common . base ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . util . Arrays ; import java . util . Iterator ; public class JoinerBenchmark { private static final String DELIMITER_STRING = <str> ; private static final char DELIMITER_CHARACTER = <str> ; private static final Joiner JOINER_ON_STRING = Joiner . on ( DELIMITER_STRING ) ; private static final Joiner JOINER_ON_CHARACTER = Joiner . on ( DELIMITER_CHARACTER ) ; @Param ( { <str> , <str> , <str> } ) int count ; @Param ( { <str> , <str> , <str> , <str> , <str> } ) int componentLength ; private Iterable < String > components ; @BeforeExperiment void setUp ( ) { String component = Strings . repeat ( <str> , componentLength ) ; String [ ] raw = new String [ count ] ; Arrays . fill ( raw , component ) ; components = Arrays . asList ( raw ) ; } @Benchmark int joinerWithStringDelimiter ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { dummy ^ = JOINER_ON_STRING . join ( components ) . length ( ) ; } return dummy ; } @Benchmark int joinerWithCharacterDelimiter ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { dummy ^ = JOINER_ON_CHARACTER . join ( components ) . length ( ) ; } return dummy ; } @Benchmark int joinerInlined ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringBuilder sb = new StringBuilder ( ) ; Iterator < String > iterator = components . iterator ( ) ; if ( iterator . hasNext ( ) ) { sb . append ( iterator . next ( ) . toString ( ) ) ; while ( iterator . hasNext ( ) ) { sb . append ( DELIMITER_STRING ) ; sb . append ( iterator . next ( ) ) ; } } dummy ^ = sb . toString ( ) . length ( ) ; } return dummy ; } @Benchmark int stringBuilderIsEmpty ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringBuilder sb = new StringBuilder ( ) ; for ( String comp : components ) { if ( sb . length ( ) > <int> ) { sb . append ( DELIMITER_STRING ) ; } sb . append ( comp ) ; } dummy ^ = sb . toString ( ) . length ( ) ; } return dummy ; } @Benchmark int booleanIfFirst ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringBuilder sb = new StringBuilder ( ) ; boolean append = false ; for ( String comp : components ) { if ( append ) { sb . append ( DELIMITER_STRING ) ; } sb . append ( comp ) ; append = true ; } dummy ^ = sb . toString ( ) . length ( ) ; } return dummy ; } @Benchmark int assignDelimiter ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringBuilder sb = new StringBuilder ( ) ; String delim = <str> ; for ( String comp : components ) { sb . append ( delim ) ; sb . append ( comp ) ; delim = DELIMITER_STRING ; } dummy ^ = sb . toString ( ) . length ( ) ; } return dummy ; } @Benchmark int alwaysAppendThenBackUp ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringBuilder sb = new StringBuilder ( ) ; for ( String comp : components ) { sb . append ( comp ) ; sb . append ( DELIMITER_STRING ) ; } if ( sb . length ( ) > <int> ) { sb . setLength ( sb . length ( ) - DELIMITER_STRING . length ( ) ) ; } dummy ^ = sb . toString ( ) . length ( ) ; } return dummy ; } } 
