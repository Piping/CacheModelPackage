package io . netty . util ; import io . netty . util . internal . MpscLinkedQueueNode ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . Collections ; import java . util . HashSet ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class HashedWheelTimer implements Timer { static final InternalLogger logger = InternalLoggerFactory . getInstance ( HashedWheelTimer . class ) ; private static final ResourceLeakDetector < HashedWheelTimer > leakDetector = new ResourceLeakDetector < HashedWheelTimer > ( HashedWheelTimer . class , <int> , Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ) ; private static final AtomicIntegerFieldUpdater < HashedWheelTimer > WORKER_STATE_UPDATER ; static { AtomicIntegerFieldUpdater < HashedWheelTimer > workerStateUpdater = PlatformDependent . newAtomicIntegerFieldUpdater ( HashedWheelTimer . class , <str> ) ; if ( workerStateUpdater = = null ) { workerStateUpdater = AtomicIntegerFieldUpdater . newUpdater ( HashedWheelTimer . class , <str> ) ; } WORKER_STATE_UPDATER = workerStateUpdater ; } private final ResourceLeak leak ; private final Worker worker = new Worker ( ) ; private final Thread workerThread ; public static final int WORKER_STATE_INIT = <int> ; public static final int WORKER_STATE_STARTED = <int> ; public static final int WORKER_STATE_SHUTDOWN = <int> ; @SuppressWarnings ( { <str> , <str> , <str> } ) private volatile int workerState = WORKER_STATE_INIT ; private final long tickDuration ; private final HashedWheelBucket [ ] wheel ; private final int mask ; private final CountDownLatch startTimeInitialized = new CountDownLatch ( <int> ) ; private final Queue < HashedWheelTimeout > timeouts = PlatformDependent . newMpscQueue ( ) ; private final Queue < Runnable > cancelledTimeouts = PlatformDependent . newMpscQueue ( ) ; private volatile long startTime ; public HashedWheelTimer ( ) { this ( Executors . defaultThreadFactory ( ) ) ; } public HashedWheelTimer ( long tickDuration , TimeUnit unit ) { this ( Executors . defaultThreadFactory ( ) , tickDuration , unit ) ; } public HashedWheelTimer ( long tickDuration , TimeUnit unit , int ticksPerWheel ) { this ( Executors . defaultThreadFactory ( ) , tickDuration , unit , ticksPerWheel ) ; } public HashedWheelTimer ( ThreadFactory threadFactory ) { this ( threadFactory , <int> , TimeUnit . MILLISECONDS ) ; } public HashedWheelTimer ( ThreadFactory threadFactory , long tickDuration , TimeUnit unit ) { this ( threadFactory , tickDuration , unit , <int> ) ; } public HashedWheelTimer ( ThreadFactory threadFactory , long tickDuration , TimeUnit unit , int ticksPerWheel ) { if ( threadFactory = = null ) { throw new NullPointerException ( <str> ) ; } if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( tickDuration < = <int> ) { throw new IllegalArgumentException ( <str> + tickDuration ) ; } if ( ticksPerWheel < = <int> ) { throw new IllegalArgumentException ( <str> + ticksPerWheel ) ; } wheel = createWheel ( ticksPerWheel ) ; mask = wheel . length - <int> ; this . tickDuration = unit . toNanos ( tickDuration ) ; if ( this . tickDuration > = Long . MAX_VALUE / wheel . length ) { throw new IllegalArgumentException ( String . format ( <str> , tickDuration , Long . MAX_VALUE / wheel . length ) ) ; } workerThread = threadFactory . newThread ( worker ) ; leak = leakDetector . open ( this ) ; } private static HashedWheelBucket [ ] createWheel ( int ticksPerWheel ) { if ( ticksPerWheel < = <int> ) { throw new IllegalArgumentException ( <str> + ticksPerWheel ) ; } if ( ticksPerWheel > <int> ) { throw new IllegalArgumentException ( <str> + ticksPerWheel ) ; } ticksPerWheel = normalizeTicksPerWheel ( ticksPerWheel ) ; HashedWheelBucket [ ] wheel = new HashedWheelBucket [ ticksPerWheel ] ; for ( int i = <int> ; i < wheel . length ; i + + ) { wheel [ i ] = new HashedWheelBucket ( ) ; } return wheel ; } private static int normalizeTicksPerWheel ( int ticksPerWheel ) { int normalizedTicksPerWheel = <int> ; while ( normalizedTicksPerWheel < ticksPerWheel ) { normalizedTicksPerWheel < < = <int> ; } return normalizedTicksPerWheel ; } public void start ( ) { switch ( WORKER_STATE_UPDATER . get ( this ) ) { case WORKER_STATE_INIT : if ( WORKER_STATE_UPDATER . compareAndSet ( this , WORKER_STATE_INIT , WORKER_STATE_STARTED ) ) { workerThread . start ( ) ; } break ; case WORKER_STATE_STARTED : break ; case WORKER_STATE_SHUTDOWN : throw new IllegalStateException ( <str> ) ; default : throw new Error ( <str> ) ; } while ( startTime = = <int> ) { try { startTimeInitialized . await ( ) ; } catch ( InterruptedException ignore ) { } } } @Override public Set < Timeout > stop ( ) { if ( Thread . currentThread ( ) = = workerThread ) { throw new IllegalStateException ( HashedWheelTimer . class . getSimpleName ( ) + <str> + TimerTask . class . getSimpleName ( ) ) ; } if ( ! WORKER_STATE_UPDATER . compareAndSet ( this , WORKER_STATE_STARTED , WORKER_STATE_SHUTDOWN ) ) { WORKER_STATE_UPDATER . set ( this , WORKER_STATE_SHUTDOWN ) ; if ( leak ! = null ) { leak . close ( ) ; } return Collections . emptySet ( ) ; } boolean interrupted = false ; while ( workerThread . isAlive ( ) ) { workerThread . interrupt ( ) ; try { workerThread . join ( <int> ) ; } catch ( InterruptedException ignored ) { interrupted = true ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } if ( leak ! = null ) { leak . close ( ) ; } return worker . unprocessedTimeouts ( ) ; } @Override public Timeout newTimeout ( TimerTask task , long delay , TimeUnit unit ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } start ( ) ; long deadline = System . nanoTime ( ) + unit . toNanos ( delay ) - startTime ; HashedWheelTimeout timeout = new HashedWheelTimeout ( this , task , deadline ) ; timeouts . add ( timeout ) ; return timeout ; } private final class Worker implements Runnable { private final Set < Timeout > unprocessedTimeouts = new HashSet < Timeout > ( ) ; private long tick ; @Override public void run ( ) { startTime = System . nanoTime ( ) ; if ( startTime = = <int> ) { startTime = <int> ; } startTimeInitialized . countDown ( ) ; do { final long deadline = waitForNextTick ( ) ; if ( deadline > <int> ) { int idx = ( int ) ( tick & mask ) ; processCancelledTasks ( ) ; HashedWheelBucket bucket = wheel [ idx ] ; transferTimeoutsToBuckets ( ) ; bucket . expireTimeouts ( deadline ) ; tick + + ; } } while ( WORKER_STATE_UPDATER . get ( HashedWheelTimer . this ) = = WORKER_STATE_STARTED ) ; for ( HashedWheelBucket bucket : wheel ) { bucket . clearTimeouts ( unprocessedTimeouts ) ; } for ( ; ; ) { HashedWheelTimeout timeout = timeouts . poll ( ) ; if ( timeout = = null ) { break ; } if ( ! timeout . isCancelled ( ) ) { unprocessedTimeouts . add ( timeout ) ; } } processCancelledTasks ( ) ; } private void transferTimeoutsToBuckets ( ) { for ( int i = <int> ; i < <int> ; i + + ) { HashedWheelTimeout timeout = timeouts . poll ( ) ; if ( timeout = = null ) { break ; } if ( timeout . state ( ) = = HashedWheelTimeout . ST_CANCELLED ) { continue ; } long calculated = timeout . deadline / tickDuration ; timeout . remainingRounds = ( calculated - tick ) / wheel . length ; final long ticks = Math . max ( calculated , tick ) ; int stopIndex = ( int ) ( ticks & mask ) ; HashedWheelBucket bucket = wheel [ stopIndex ] ; bucket . addTimeout ( timeout ) ; } } private void processCancelledTasks ( ) { for ( ; ; ) { Runnable task = cancelledTimeouts . poll ( ) ; if ( task = = null ) { break ; } try { task . run ( ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , t ) ; } } } } private long waitForNextTick ( ) { long deadline = tickDuration * ( tick + <int> ) ; for ( ; ; ) { final long currentTime = System . nanoTime ( ) - startTime ; long sleepTimeMs = ( deadline - currentTime + <int> ) / <int> ; if ( sleepTimeMs < = <int> ) { if ( currentTime = = Long . MIN_VALUE ) { return - Long . MAX_VALUE ; } else { return currentTime ; } } if ( PlatformDependent . isWindows ( ) ) { sleepTimeMs = sleepTimeMs / <int> * <int> ; } try { Thread . sleep ( sleepTimeMs ) ; } catch ( InterruptedException ignored ) { if ( WORKER_STATE_UPDATER . get ( HashedWheelTimer . this ) = = WORKER_STATE_SHUTDOWN ) { return Long . MIN_VALUE ; } } } } public Set < Timeout > unprocessedTimeouts ( ) { return Collections . unmodifiableSet ( unprocessedTimeouts ) ; } } private static final class HashedWheelTimeout extends MpscLinkedQueueNode < Timeout > implements Timeout { private static final int ST_INIT = <int> ; private static final int ST_CANCELLED = <int> ; private static final int ST_EXPIRED = <int> ; private static final AtomicIntegerFieldUpdater < HashedWheelTimeout > STATE_UPDATER ; static { AtomicIntegerFieldUpdater < HashedWheelTimeout > updater = PlatformDependent . newAtomicIntegerFieldUpdater ( HashedWheelTimeout . class , <str> ) ; if ( updater = = null ) { updater = AtomicIntegerFieldUpdater . newUpdater ( HashedWheelTimeout . class , <str> ) ; } STATE_UPDATER = updater ; } private final HashedWheelTimer timer ; private final TimerTask task ; private final long deadline ; @SuppressWarnings ( { <str> , <str> , <str> } ) private volatile int state = ST_INIT ; long remainingRounds ; HashedWheelTimeout next ; HashedWheelTimeout prev ; HashedWheelBucket bucket ; HashedWheelTimeout ( HashedWheelTimer timer , TimerTask task , long deadline ) { this . timer = timer ; this . task = task ; this . deadline = deadline ; } @Override public Timer timer ( ) { return timer ; } @Override public TimerTask task ( ) { return task ; } @Override public boolean cancel ( ) { if ( ! compareAndSetState ( ST_INIT , ST_CANCELLED ) ) { return false ; } timer . cancelledTimeouts . add ( new Runnable ( ) { @Override public void run ( ) { HashedWheelBucket bucket = HashedWheelTimeout . this . bucket ; if ( bucket ! = null ) { bucket . remove ( HashedWheelTimeout . this ) ; } } } ) ; return true ; } public boolean compareAndSetState ( int expected , int state ) { return STATE_UPDATER . compareAndSet ( this , expected , state ) ; } public int state ( ) { return state ; } @Override public boolean isCancelled ( ) { return state ( ) = = ST_CANCELLED ; } @Override public boolean isExpired ( ) { return state ( ) = = ST_EXPIRED ; } @Override public HashedWheelTimeout value ( ) { return this ; } public void expire ( ) { if ( ! compareAndSetState ( ST_INIT , ST_EXPIRED ) ) { return ; } try { task . run ( this ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> + TimerTask . class . getSimpleName ( ) + <str> , t ) ; } } } @Override public String toString ( ) { final long currentTime = System . nanoTime ( ) ; long remaining = deadline - currentTime + timer . startTime ; StringBuilder buf = new StringBuilder ( <int> ) . append ( StringUtil . simpleClassName ( this ) ) . append ( <str> ) . append ( <str> ) ; if ( remaining > <int> ) { buf . append ( remaining ) . append ( <str> ) ; } else if ( remaining < <int> ) { buf . append ( - remaining ) . append ( <str> ) ; } else { buf . append ( <str> ) ; } if ( isCancelled ( ) ) { buf . append ( <str> ) ; } return buf . append ( <str> ) . append ( task ( ) ) . append ( <str> ) . toString ( ) ; } } private static final class HashedWheelBucket { private HashedWheelTimeout head ; private HashedWheelTimeout tail ; public void addTimeout ( HashedWheelTimeout timeout ) { assert timeout . bucket = = null ; timeout . bucket = this ; if ( head = = null ) { head = tail = timeout ; } else { tail . next = timeout ; timeout . prev = tail ; tail = timeout ; } } public void expireTimeouts ( long deadline ) { HashedWheelTimeout timeout = head ; while ( timeout ! = null ) { boolean remove = false ; if ( timeout . remainingRounds < = <int> ) { if ( timeout . deadline < = deadline ) { timeout . expire ( ) ; } else { throw new IllegalStateException ( String . format ( <str> , timeout . deadline , deadline ) ) ; } remove = true ; } else if ( timeout . isCancelled ( ) ) { remove = true ; } else { timeout . remainingRounds - - ; } HashedWheelTimeout next = timeout . next ; if ( remove ) { remove ( timeout ) ; } timeout = next ; } } public void remove ( HashedWheelTimeout timeout ) { HashedWheelTimeout next = timeout . next ; if ( timeout . prev ! = null ) { timeout . prev . next = next ; } if ( timeout . next ! = null ) { timeout . next . prev = timeout . prev ; } if ( timeout = = head ) { if ( timeout = = tail ) { tail = null ; head = null ; } else { head = next ; } } else if ( timeout = = tail ) { tail = timeout . prev ; } timeout . prev = null ; timeout . next = null ; timeout . bucket = null ; } public void clearTimeouts ( Set < Timeout > set ) { for ( ; ; ) { HashedWheelTimeout timeout = pollTimeout ( ) ; if ( timeout = = null ) { return ; } if ( timeout . isExpired ( ) | | timeout . isCancelled ( ) ) { continue ; } set . add ( timeout ) ; } } private HashedWheelTimeout pollTimeout ( ) { HashedWheelTimeout head = this . head ; if ( head = = null ) { return null ; } HashedWheelTimeout next = head . next ; if ( next = = null ) { tail = this . head = null ; } else { this . head = next ; next . prev = null ; } head . next = null ; head . prev = null ; head . bucket = null ; return head ; } } } 
