package org . gradle . api . internal . file . copy ; import groovy . lang . Closure ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . * ; import java . io . File ; import java . util . concurrent . Callable ; public class PathNotationConverter implements NotationConverter < Object , String > { @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; visitor . candidate ( <str> ) . example ( <str> ) . example ( <str> ) ; visitor . candidate ( <str> ) . example ( <str> ) . example ( <str> ) ; visitor . candidate ( <str> ) ; visitor . candidate ( <str> ) ; visitor . candidate ( <str> ) ; } public static NotationParser < Object , String > parser ( ) { return NotationParserBuilder . toType ( String . class ) . noImplicitConverters ( ) . allowNullInput ( ) . converter ( new PathNotationConverter ( ) ) . toComposite ( ) ; } @Override public void convert ( Object notation , NotationConvertResult < ? super String > result ) throws TypeConversionException { if ( notation = = null ) { result . converted ( null ) ; } else if ( notation instanceof CharSequence | | notation instanceof File | | notation instanceof Number | | notation instanceof Boolean ) { result . converted ( notation . toString ( ) ) ; } else if ( notation instanceof Closure ) { final Closure closure = ( Closure ) notation ; final Object called = closure . call ( ) ; convert ( called , result ) ; } else if ( notation instanceof Callable ) { try { final Callable callableNotation = ( Callable ) notation ; final Object called = callableNotation . call ( ) ; convert ( called , result ) ; if ( ! result . hasResult ( ) ) { throw new TypeConversionException ( <str> + notation ) ; } } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } } 
