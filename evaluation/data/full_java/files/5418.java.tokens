package org . elasticsearch . action . support . broadcast . node ; import org . elasticsearch . action . * ; import org . elasticsearch . action . support . * ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . action . support . broadcast . BroadcastResponse ; import org . elasticsearch . action . support . broadcast . BroadcastShardOperationFailedException ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardsIterator ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReferenceArray ; import java . util . function . Supplier ; public abstract class TransportBroadcastByNodeAction < Request extends BroadcastRequest , Response extends BroadcastResponse , ShardOperationResult extends Streamable > extends HandledTransportAction < Request , Response > { private final ClusterService clusterService ; private final TransportService transportService ; final String transportNodeBroadcastAction ; public TransportBroadcastByNodeAction ( Settings settings , String actionName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , Supplier < Request > request , String executor ) { super ( settings , actionName , threadPool , transportService , actionFilters , indexNameExpressionResolver , request ) ; this . clusterService = clusterService ; this . transportService = transportService ; transportNodeBroadcastAction = actionName + <str> ; transportService . registerRequestHandler ( transportNodeBroadcastAction , NodeRequest : : new , executor , new BroadcastByNodeTransportRequestHandler ( ) ) ; } private Response newResponse ( Request request , AtomicReferenceArray responses , List < NoShardAvailableActionException > unavailableShardExceptions , Map < String , List < ShardRouting > > nodes , ClusterState clusterState ) { int totalShards = <int> ; int successfulShards = <int> ; List < ShardOperationResult > broadcastByNodeResponses = new ArrayList < > ( ) ; List < ShardOperationFailedException > exceptions = new ArrayList < > ( ) ; for ( int i = <int> ; i < responses . length ( ) ; i + + ) { if ( responses . get ( i ) instanceof FailedNodeException ) { FailedNodeException exception = ( FailedNodeException ) responses . get ( i ) ; totalShards + = nodes . get ( exception . nodeId ( ) ) . size ( ) ; for ( ShardRouting shard : nodes . get ( exception . nodeId ( ) ) ) { exceptions . add ( new DefaultShardOperationFailedException ( shard . getIndex ( ) , shard . getId ( ) , exception ) ) ; } } else { NodeResponse response = ( NodeResponse ) responses . get ( i ) ; broadcastByNodeResponses . addAll ( response . results ) ; totalShards + = response . getTotalShards ( ) ; successfulShards + = response . getSuccessfulShards ( ) ; for ( BroadcastShardOperationFailedException throwable : response . getExceptions ( ) ) { if ( ! TransportActions . isShardNotAvailableException ( throwable ) ) { exceptions . add ( new DefaultShardOperationFailedException ( throwable . getIndex ( ) , throwable . getShardId ( ) . getId ( ) , throwable ) ) ; } } } } totalShards + = unavailableShardExceptions . size ( ) ; int failedShards = exceptions . size ( ) ; return newResponse ( request , totalShards , successfulShards , failedShards , broadcastByNodeResponses , exceptions , clusterState ) ; } protected abstract ShardOperationResult readShardResult ( StreamInput in ) throws IOException ; protected abstract Response newResponse ( Request request , int totalShards , int successfulShards , int failedShards , List < ShardOperationResult > results , List < ShardOperationFailedException > shardFailures , ClusterState clusterState ) ; protected abstract Request readRequestFrom ( StreamInput in ) throws IOException ; protected abstract ShardOperationResult shardOperation ( Request request , ShardRouting shardRouting ) throws IOException ; protected abstract ShardsIterator shards ( ClusterState clusterState , Request request , String [ ] concreteIndices ) ; protected abstract ClusterBlockException checkGlobalBlock ( ClusterState state , Request request ) ; protected abstract ClusterBlockException checkRequestBlock ( ClusterState state , Request request , String [ ] concreteIndices ) ; @Override protected void doExecute ( Request request , ActionListener < Response > listener ) { new AsyncAction ( request , listener ) . start ( ) ; } protected class AsyncAction { private final Request request ; private final ActionListener < Response > listener ; private final ClusterState clusterState ; private final DiscoveryNodes nodes ; private final Map < String , List < ShardRouting > > nodeIds ; private final AtomicReferenceArray < Object > responses ; private final AtomicInteger counter = new AtomicInteger ( ) ; private List < NoShardAvailableActionException > unavailableShardExceptions = new ArrayList < > ( ) ; protected AsyncAction ( Request request , ActionListener < Response > listener ) { this . request = request ; this . listener = listener ; clusterState = clusterService . state ( ) ; nodes = clusterState . nodes ( ) ; ClusterBlockException globalBlockException = checkGlobalBlock ( clusterState , request ) ; if ( globalBlockException ! = null ) { throw globalBlockException ; } String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request ) ; ClusterBlockException requestBlockException = checkRequestBlock ( clusterState , request , concreteIndices ) ; if ( requestBlockException ! = null ) { throw requestBlockException ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , clusterState . version ( ) ) ; } ShardsIterator shardIt = shards ( clusterState , request , concreteIndices ) ; nodeIds = new HashMap < > ( ) ; for ( ShardRouting shard : shardIt . asUnordered ( ) ) { if ( shard . assignedToNode ( ) & & nodes . get ( shard . currentNodeId ( ) ) ! = null ) { String nodeId = shard . currentNodeId ( ) ; if ( ! nodeIds . containsKey ( nodeId ) ) { nodeIds . put ( nodeId , new ArrayList < > ( ) ) ; } nodeIds . get ( nodeId ) . add ( shard ) ; } else { unavailableShardExceptions . add ( new NoShardAvailableActionException ( shard . shardId ( ) , <str> + shard . toString ( ) + <str> + actionName ) ) ; } } responses = new AtomicReferenceArray < > ( nodeIds . size ( ) ) ; } public void start ( ) { if ( nodeIds . size ( ) = = <int> ) { try { onCompletion ( ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; } } else { int nodeIndex = - <int> ; for ( Map . Entry < String , List < ShardRouting > > entry : nodeIds . entrySet ( ) ) { nodeIndex + + ; DiscoveryNode node = nodes . get ( entry . getKey ( ) ) ; sendNodeRequest ( node , entry . getValue ( ) , nodeIndex ) ; } } } private void sendNodeRequest ( final DiscoveryNode node , List < ShardRouting > shards , final int nodeIndex ) { try { NodeRequest nodeRequest = new NodeRequest ( node . getId ( ) , request , shards ) ; transportService . sendRequest ( node , transportNodeBroadcastAction , nodeRequest , new BaseTransportResponseHandler < NodeResponse > ( ) { @Override public NodeResponse newInstance ( ) { return new NodeResponse ( ) ; } @Override public void handleResponse ( NodeResponse response ) { onNodeResponse ( node , nodeIndex , response ) ; } @Override public void handleException ( TransportException exp ) { onNodeFailure ( node , nodeIndex , exp ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } catch ( Throwable e ) { onNodeFailure ( node , nodeIndex , e ) ; } } protected void onNodeResponse ( DiscoveryNode node , int nodeIndex , NodeResponse response ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , node . id ( ) ) ; } if ( responses . compareAndSet ( nodeIndex , null , response ) ) { if ( counter . incrementAndGet ( ) = = responses . length ( ) ) { onCompletion ( ) ; } } } protected void onNodeFailure ( DiscoveryNode node , int nodeIndex , Throwable t ) { String nodeId = node . id ( ) ; if ( logger . isDebugEnabled ( ) & & ! ( t instanceof NodeShouldNotConnectException ) ) { logger . debug ( <str> , t , actionName , nodeId ) ; } if ( responses . compareAndSet ( nodeIndex , null , new FailedNodeException ( nodeId , <str> + nodeId + <str> , t ) ) ) { if ( counter . incrementAndGet ( ) = = responses . length ( ) ) { onCompletion ( ) ; } } } protected void onCompletion ( ) { Response response = null ; try { response = newResponse ( request , responses , unavailableShardExceptions , nodeIds , clusterState ) ; } catch ( Throwable t ) { logger . debug ( <str> , t ) ; listener . onFailure ( t ) ; } if ( response ! = null ) { try { listener . onResponse ( response ) ; } catch ( Throwable t ) { listener . onFailure ( t ) ; } } } } class BroadcastByNodeTransportRequestHandler implements TransportRequestHandler < NodeRequest > { @Override public void messageReceived ( final NodeRequest request , TransportChannel channel ) throws Exception { List < ShardRouting > shards = request . getShards ( ) ; final int totalShards = shards . size ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , totalShards ) ; } final Object [ ] shardResultOrExceptions = new Object [ totalShards ] ; int shardIndex = - <int> ; for ( final ShardRouting shardRouting : shards ) { shardIndex + + ; onShardOperation ( request , shardResultOrExceptions , shardIndex , shardRouting ) ; } List < BroadcastShardOperationFailedException > accumulatedExceptions = new ArrayList < > ( ) ; List < ShardOperationResult > results = new ArrayList < > ( ) ; for ( int i = <int> ; i < totalShards ; i + + ) { if ( shardResultOrExceptions [ i ] instanceof BroadcastShardOperationFailedException ) { accumulatedExceptions . add ( ( BroadcastShardOperationFailedException ) shardResultOrExceptions [ i ] ) ; } else { results . add ( ( ShardOperationResult ) shardResultOrExceptions [ i ] ) ; } } channel . sendResponse ( new NodeResponse ( request . getNodeId ( ) , totalShards , results , accumulatedExceptions ) ) ; } private void onShardOperation ( final NodeRequest request , final Object [ ] shardResults , final int shardIndex , final ShardRouting shardRouting ) { try { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , shardRouting . shortSummary ( ) ) ; } ShardOperationResult result = shardOperation ( request . indicesLevelRequest , shardRouting ) ; shardResults [ shardIndex ] = result ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , shardRouting . shortSummary ( ) ) ; } } catch ( Throwable t ) { BroadcastShardOperationFailedException e = new BroadcastShardOperationFailedException ( shardRouting . shardId ( ) , <str> + actionName + <str> , t ) ; e . setIndex ( shardRouting . getIndex ( ) ) ; e . setShard ( shardRouting . shardId ( ) ) ; shardResults [ shardIndex ] = e ; logger . debug ( <str> , e , actionName , shardRouting . shortSummary ( ) ) ; } } } public class NodeRequest extends TransportRequest implements IndicesRequest { private String nodeId ; private List < ShardRouting > shards ; protected Request indicesLevelRequest ; public NodeRequest ( ) { } public NodeRequest ( String nodeId , Request request , List < ShardRouting > shards ) { super ( request ) ; this . indicesLevelRequest = request ; this . shards = shards ; this . nodeId = nodeId ; } public List < ShardRouting > getShards ( ) { return shards ; } public String getNodeId ( ) { return nodeId ; } public String [ ] indices ( ) { return indicesLevelRequest . indices ( ) ; } public IndicesOptions indicesOptions ( ) { return indicesLevelRequest . indicesOptions ( ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; indicesLevelRequest = readRequestFrom ( in ) ; int size = in . readVInt ( ) ; shards = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { shards . add ( ShardRouting . readShardRoutingEntry ( in ) ) ; } nodeId = in . readString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; indicesLevelRequest . writeTo ( out ) ; int size = shards . size ( ) ; out . writeVInt ( size ) ; for ( int i = <int> ; i < size ; i + + ) { shards . get ( i ) . writeTo ( out ) ; } out . writeString ( nodeId ) ; } } class NodeResponse extends TransportResponse { protected String nodeId ; protected int totalShards ; protected List < BroadcastShardOperationFailedException > exceptions ; protected List < ShardOperationResult > results ; public NodeResponse ( ) { } public NodeResponse ( String nodeId , int totalShards , List < ShardOperationResult > results , List < BroadcastShardOperationFailedException > exceptions ) { this . nodeId = nodeId ; this . totalShards = totalShards ; this . results = results ; this . exceptions = exceptions ; } public String getNodeId ( ) { return nodeId ; } public int getTotalShards ( ) { return totalShards ; } public int getSuccessfulShards ( ) { return results . size ( ) ; } public List < BroadcastShardOperationFailedException > getExceptions ( ) { return exceptions ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; nodeId = in . readString ( ) ; totalShards = in . readVInt ( ) ; int resultsSize = in . readVInt ( ) ; results = new ArrayList < > ( resultsSize ) ; for ( ; resultsSize > <int> ; resultsSize - - ) { final ShardOperationResult result = in . readBoolean ( ) ? readShardResult ( in ) : null ; results . add ( result ) ; } if ( in . readBoolean ( ) ) { int failureShards = in . readVInt ( ) ; exceptions = new ArrayList < > ( failureShards ) ; for ( int i = <int> ; i < failureShards ; i + + ) { exceptions . add ( new BroadcastShardOperationFailedException ( in ) ) ; } } else { exceptions = null ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( nodeId ) ; out . writeVInt ( totalShards ) ; out . writeVInt ( results . size ( ) ) ; for ( ShardOperationResult result : results ) { out . writeOptionalStreamable ( result ) ; } out . writeBoolean ( exceptions ! = null ) ; if ( exceptions ! = null ) { int failureShards = exceptions . size ( ) ; out . writeVInt ( failureShards ) ; for ( int i = <int> ; i < failureShards ; i + + ) { exceptions . get ( i ) . writeTo ( out ) ; } } } } public final static class EmptyResult implements Streamable { public static EmptyResult INSTANCE = new EmptyResult ( ) ; private EmptyResult ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { } @Override public void writeTo ( StreamOutput out ) throws IOException { } public static EmptyResult readEmptyResultFrom ( StreamInput in ) { return INSTANCE ; } } } 
