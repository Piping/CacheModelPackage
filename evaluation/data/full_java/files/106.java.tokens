package org . apache . cassandra . concurrent ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import org . apache . cassandra . metrics . SEPMetrics ; import org . apache . cassandra . utils . concurrent . SimpleCondition ; import org . apache . cassandra . utils . concurrent . WaitQueue ; import static org . apache . cassandra . concurrent . SEPWorker . Work ; public class SEPExecutor extends AbstractTracingAwareExecutorService { private final SharedExecutorPool pool ; public final int maxWorkers ; private final int maxTasksQueued ; private final SEPMetrics metrics ; private final AtomicLong permits = new AtomicLong ( ) ; private final WaitQueue hasRoom = new WaitQueue ( ) ; private final AtomicLong completedTasks = new AtomicLong ( ) ; volatile boolean shuttingDown = false ; final SimpleCondition shutdown = new SimpleCondition ( ) ; protected final ConcurrentLinkedQueue < FutureTask < ? > > tasks = new ConcurrentLinkedQueue < > ( ) ; SEPExecutor ( SharedExecutorPool pool , int maxWorkers , int maxTasksQueued , String jmxPath , String name ) { this . pool = pool ; this . maxWorkers = maxWorkers ; this . maxTasksQueued = maxTasksQueued ; this . permits . set ( combine ( <int> , maxWorkers ) ) ; this . metrics = new SEPMetrics ( this , jmxPath , name ) ; } protected void onCompletion ( ) { completedTasks . incrementAndGet ( ) ; } boolean maybeSchedule ( ) { if ( pool . spinningCount . get ( ) > <int> | | ! takeWorkPermit ( true ) ) return false ; pool . schedule ( new Work ( this ) ) ; return true ; } protected void addTask ( FutureTask < ? > task ) { tasks . add ( task ) ; int taskPermits ; while ( true ) { long current = permits . get ( ) ; taskPermits = taskPermits ( current ) ; if ( permits . compareAndSet ( current , updateTaskPermits ( current , taskPermits + <int> ) ) ) break ; } if ( taskPermits = = <int> ) { pool . maybeStartSpinningWorker ( ) ; } else if ( taskPermits > = maxTasksQueued ) { WaitQueue . Signal s = hasRoom . register ( ) ; if ( taskPermits ( permits . get ( ) ) > maxTasksQueued ) { if ( takeWorkPermit ( true ) ) pool . schedule ( new Work ( this ) ) ; metrics . totalBlocked . inc ( ) ; metrics . currentBlocked . inc ( ) ; s . awaitUninterruptibly ( ) ; metrics . currentBlocked . dec ( ) ; } else s . cancel ( ) ; } } boolean takeTaskPermit ( ) { while ( true ) { long current = permits . get ( ) ; int taskPermits = taskPermits ( current ) ; if ( taskPermits = = <int> ) return false ; if ( permits . compareAndSet ( current , updateTaskPermits ( current , taskPermits - <int> ) ) ) { if ( taskPermits = = maxTasksQueued & & hasRoom . hasWaiters ( ) ) hasRoom . signalAll ( ) ; return true ; } } } boolean takeWorkPermit ( boolean takeTaskPermit ) { int taskDelta = takeTaskPermit ? <int> : <int> ; while ( true ) { long current = permits . get ( ) ; int workPermits = workPermits ( current ) ; int taskPermits = taskPermits ( current ) ; if ( workPermits = = <int> | | taskPermits = = <int> ) return false ; if ( permits . compareAndSet ( current , combine ( taskPermits - taskDelta , workPermits - <int> ) ) ) { if ( takeTaskPermit & & taskPermits = = maxTasksQueued & & hasRoom . hasWaiters ( ) ) hasRoom . signalAll ( ) ; return true ; } } } void returnWorkPermit ( ) { while ( true ) { long current = permits . get ( ) ; int workPermits = workPermits ( current ) ; if ( permits . compareAndSet ( current , updateWorkPermits ( current , workPermits + <int> ) ) ) return ; } } public void maybeExecuteImmediately ( Runnable command ) { FutureTask < ? > ft = newTaskFor ( command , null ) ; if ( ! takeWorkPermit ( false ) ) { addTask ( ft ) ; } else { try { ft . run ( ) ; } finally { returnWorkPermit ( ) ; maybeSchedule ( ) ; } } } public synchronized void shutdown ( ) { shuttingDown = true ; pool . executors . remove ( this ) ; if ( getActiveCount ( ) = = <int> ) shutdown . signalAll ( ) ; metrics . release ( ) ; } public synchronized List < Runnable > shutdownNow ( ) { shutdown ( ) ; List < Runnable > aborted = new ArrayList < > ( ) ; while ( takeTaskPermit ( ) ) aborted . add ( tasks . poll ( ) ) ; return aborted ; } public boolean isShutdown ( ) { return shuttingDown ; } public boolean isTerminated ( ) { return shuttingDown & & shutdown . isSignaled ( ) ; } public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { shutdown . await ( timeout , unit ) ; return isTerminated ( ) ; } public long getPendingTasks ( ) { return taskPermits ( permits . get ( ) ) ; } public long getCompletedTasks ( ) { return completedTasks . get ( ) ; } public int getActiveCount ( ) { return maxWorkers - workPermits ( permits . get ( ) ) ; } private static int taskPermits ( long both ) { return ( int ) both ; } private static int workPermits ( long both ) { return ( int ) ( both > > > <int> ) ; } private static long updateTaskPermits ( long prev , int taskPermits ) { return ( prev & ( - <int> < < <int> ) ) | taskPermits ; } private static long updateWorkPermits ( long prev , int workPermits ) { return ( ( ( long ) workPermits ) < < <int> ) | ( prev & ( - <int> > > > <int> ) ) ; } private static long combine ( int taskPermits , int workPermits ) { return ( ( ( long ) workPermits ) < < <int> ) | taskPermits ; } } 
