package org . apache . cassandra . metrics ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import com . codahale . metrics . * ; import com . codahale . metrics . Timer ; import com . google . common . collect . Iterables ; import com . google . common . collect . Maps ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . Memtable ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . EstimatedHistogram ; import org . apache . cassandra . utils . TopKSampler ; import static org . apache . cassandra . metrics . CassandraMetricsRegistry . Metrics ; public class TableMetrics { public final Gauge < Long > memtableOnHeapSize ; public final Gauge < Long > memtableOffHeapSize ; public final Gauge < Long > memtableLiveDataSize ; public final Gauge < Long > allMemtablesOnHeapSize ; public final Gauge < Long > allMemtablesOffHeapSize ; public final Gauge < Long > allMemtablesLiveDataSize ; public final Gauge < Long > memtableColumnsCount ; public final Counter memtableSwitchCount ; public final Gauge < Double > compressionRatio ; public final Gauge < long [ ] > estimatedPartitionSizeHistogram ; public final Gauge < Long > estimatedPartitionCount ; public final Gauge < long [ ] > estimatedColumnCountHistogram ; public final TableHistogram sstablesPerReadHistogram ; public final LatencyMetrics readLatency ; public final LatencyMetrics rangeLatency ; public final LatencyMetrics writeLatency ; public final Counter pendingFlushes ; public final Gauge < Integer > pendingCompactions ; public final Gauge < Integer > liveSSTableCount ; public final Counter liveDiskSpaceUsed ; public final Counter totalDiskSpaceUsed ; public final Gauge < Long > minPartitionSize ; public final Gauge < Long > maxPartitionSize ; public final Gauge < Long > meanPartitionSize ; public final Gauge < Long > bloomFilterFalsePositives ; public final Gauge < Long > recentBloomFilterFalsePositives ; public final Gauge < Double > bloomFilterFalseRatio ; public final Gauge < Double > recentBloomFilterFalseRatio ; public final Gauge < Long > bloomFilterDiskSpaceUsed ; public final Gauge < Long > bloomFilterOffHeapMemoryUsed ; public final Gauge < Long > indexSummaryOffHeapMemoryUsed ; public final Gauge < Long > compressionMetadataOffHeapMemoryUsed ; public final Gauge < Double > keyCacheHitRate ; public final TableHistogram tombstoneScannedHistogram ; public final TableHistogram liveScannedHistogram ; public final TableHistogram colUpdateTimeDeltaHistogram ; public final TableTimer viewLockAcquireTime ; public final TableTimer viewReadTime ; public final Gauge < Long > trueSnapshotsSize ; public final Counter rowCacheHitOutOfRange ; public final Counter rowCacheHit ; public final Counter rowCacheMiss ; public final LatencyMetrics casPrepare ; public final LatencyMetrics casPropose ; public final LatencyMetrics casCommit ; public final Timer coordinatorReadLatency ; public final Timer coordinatorScanLatency ; public final Histogram waitingOnFreeMemtableSpace ; private final MetricNameFactory factory ; private final MetricNameFactory aliasFactory ; private static final MetricNameFactory globalFactory = new AllTableMetricNameFactory ( <str> ) ; private static final MetricNameFactory globalAliasFactory = new AllTableMetricNameFactory ( <str> ) ; public final Counter speculativeRetries ; public final static LatencyMetrics globalReadLatency = new LatencyMetrics ( globalFactory , globalAliasFactory , <str> ) ; public final static LatencyMetrics globalWriteLatency = new LatencyMetrics ( globalFactory , globalAliasFactory , <str> ) ; public final static LatencyMetrics globalRangeLatency = new LatencyMetrics ( globalFactory , globalAliasFactory , <str> ) ; public final Map < Sampler , TopKSampler < ByteBuffer > > samplers ; public final static ConcurrentMap < String , Set < Metric > > allTableMetrics = Maps . newConcurrentMap ( ) ; public final static Map < String , String > all = Maps . newHashMap ( ) ; private interface GetHistogram { EstimatedHistogram getHistogram ( SSTableReader reader ) ; } private static long [ ] combineHistograms ( Iterable < SSTableReader > sstables , GetHistogram getHistogram ) { Iterator < SSTableReader > iterator = sstables . iterator ( ) ; if ( ! iterator . hasNext ( ) ) { return new long [ <int> ] ; } long [ ] firstBucket = getHistogram . getHistogram ( iterator . next ( ) ) . getBuckets ( false ) ; long [ ] values = new long [ firstBucket . length ] ; System . arraycopy ( firstBucket , <int> , values , <int> , values . length ) ; while ( iterator . hasNext ( ) ) { long [ ] nextBucket = getHistogram . getHistogram ( iterator . next ( ) ) . getBuckets ( false ) ; if ( nextBucket . length > values . length ) { long [ ] newValues = new long [ nextBucket . length ] ; System . arraycopy ( firstBucket , <int> , newValues , <int> , firstBucket . length ) ; for ( int i = <int> ; i < newValues . length ; i + + ) { newValues [ i ] + = nextBucket [ i ] ; } values = newValues ; } else { for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] + = nextBucket [ i ] ; } } } return values ; } public TableMetrics ( final ColumnFamilyStore cfs ) { factory = new TableMetricNameFactory ( cfs , <str> ) ; aliasFactory = new TableMetricNameFactory ( cfs , <str> ) ; samplers = Maps . newHashMap ( ) ; for ( Sampler sampler : Sampler . values ( ) ) { samplers . put ( sampler , new TopKSampler < > ( ) ) ; } memtableColumnsCount = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { return cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getOperations ( ) ; } } ) ; memtableOnHeapSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { return cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getAllocator ( ) . onHeap ( ) . owns ( ) ; } } ) ; memtableOffHeapSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { return cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getAllocator ( ) . offHeap ( ) . owns ( ) ; } } ) ; memtableLiveDataSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { return cfs . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getLiveDataSize ( ) ; } } ) ; allMemtablesOnHeapSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long size = <int> ; for ( ColumnFamilyStore cfs2 : cfs . concatWithIndexes ( ) ) size + = cfs2 . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getAllocator ( ) . onHeap ( ) . owns ( ) ; return size ; } } ) ; allMemtablesOffHeapSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long size = <int> ; for ( ColumnFamilyStore cfs2 : cfs . concatWithIndexes ( ) ) size + = cfs2 . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getAllocator ( ) . offHeap ( ) . owns ( ) ; return size ; } } ) ; allMemtablesLiveDataSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long size = <int> ; for ( ColumnFamilyStore cfs2 : cfs . concatWithIndexes ( ) ) size + = cfs2 . getTracker ( ) . getView ( ) . getCurrentMemtable ( ) . getLiveDataSize ( ) ; return size ; } } ) ; memtableSwitchCount = createTableCounter ( <str> ) ; estimatedPartitionSizeHistogram = Metrics . register ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) , new Gauge < long [ ] > ( ) { public long [ ] getValue ( ) { return combineHistograms ( cfs . getSSTables ( SSTableSet . CANONICAL ) , new GetHistogram ( ) { public EstimatedHistogram getHistogram ( SSTableReader reader ) { return reader . getEstimatedPartitionSize ( ) ; } } ) ; } } ) ; estimatedPartitionCount = Metrics . register ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) , new Gauge < Long > ( ) { public Long getValue ( ) { long memtablePartitions = <int> ; for ( Memtable memtable : cfs . getTracker ( ) . getView ( ) . getAllMemtables ( ) ) memtablePartitions + = memtable . partitionCount ( ) ; return SSTableReader . getApproximateKeyCount ( cfs . getSSTables ( SSTableSet . CANONICAL ) ) + memtablePartitions ; } } ) ; estimatedColumnCountHistogram = Metrics . register ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) , new Gauge < long [ ] > ( ) { public long [ ] getValue ( ) { return combineHistograms ( cfs . getSSTables ( SSTableSet . CANONICAL ) , new GetHistogram ( ) { public EstimatedHistogram getHistogram ( SSTableReader reader ) { return reader . getEstimatedColumnCount ( ) ; } } ) ; } } ) ; sstablesPerReadHistogram = createTableHistogram ( <str> , cfs . keyspace . metric . sstablesPerReadHistogram , true ) ; compressionRatio = createTableGauge ( <str> , new Gauge < Double > ( ) { public Double getValue ( ) { return computeCompressionRatio ( cfs . getSSTables ( SSTableSet . CANONICAL ) ) ; } } , new Gauge < Double > ( ) { public Double getValue ( ) { return computeCompressionRatio ( Iterables . concat ( Iterables . transform ( Keyspace . all ( ) , p - > p . getAllSSTables ( SSTableSet . CANONICAL ) ) ) ) ; } } ) ; readLatency = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . readLatency , globalReadLatency ) ; writeLatency = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . writeLatency , globalWriteLatency ) ; rangeLatency = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . rangeLatency , globalRangeLatency ) ; pendingFlushes = createTableCounter ( <str> ) ; pendingCompactions = createTableGauge ( <str> , new Gauge < Integer > ( ) { public Integer getValue ( ) { return cfs . getCompactionStrategyManager ( ) . getEstimatedRemainingTasks ( ) ; } } ) ; liveSSTableCount = createTableGauge ( <str> , new Gauge < Integer > ( ) { public Integer getValue ( ) { return cfs . getTracker ( ) . getView ( ) . liveSSTables ( ) . size ( ) ; } } ) ; liveDiskSpaceUsed = createTableCounter ( <str> ) ; totalDiskSpaceUsed = createTableCounter ( <str> ) ; minPartitionSize = createTableGauge ( <str> , <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long min = <int> ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . CANONICAL ) ) { if ( min = = <int> | | sstable . getEstimatedPartitionSize ( ) . min ( ) < min ) min = sstable . getEstimatedPartitionSize ( ) . min ( ) ; } return min ; } } , new Gauge < Long > ( ) { public Long getValue ( ) { long min = Long . MAX_VALUE ; for ( Metric cfGauge : allTableMetrics . get ( <str> ) ) { min = Math . min ( min , ( ( Gauge < ? extends Number > ) cfGauge ) . getValue ( ) . longValue ( ) ) ; } return min ; } } ) ; maxPartitionSize = createTableGauge ( <str> , <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long max = <int> ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . CANONICAL ) ) { if ( sstable . getEstimatedPartitionSize ( ) . max ( ) > max ) max = sstable . getEstimatedPartitionSize ( ) . max ( ) ; } return max ; } } , new Gauge < Long > ( ) { public Long getValue ( ) { long max = <int> ; for ( Metric cfGauge : allTableMetrics . get ( <str> ) ) { max = Math . max ( max , ( ( Gauge < ? extends Number > ) cfGauge ) . getValue ( ) . longValue ( ) ) ; } return max ; } } ) ; meanPartitionSize = createTableGauge ( <str> , <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long sum = <int> ; long count = <int> ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . CANONICAL ) ) { long n = sstable . getEstimatedPartitionSize ( ) . count ( ) ; sum + = sstable . getEstimatedPartitionSize ( ) . mean ( ) * n ; count + = n ; } return count > <int> ? sum / count : <int> ; } } , new Gauge < Long > ( ) { public Long getValue ( ) { long sum = <int> ; long count = <int> ; for ( Keyspace keyspace : Keyspace . all ( ) ) { for ( SSTableReader sstable : keyspace . getAllSSTables ( SSTableSet . CANONICAL ) ) { long n = sstable . getEstimatedPartitionSize ( ) . count ( ) ; sum + = sstable . getEstimatedPartitionSize ( ) . mean ( ) * n ; count + = n ; } } return count > <int> ? sum / count : <int> ; } } ) ; bloomFilterFalsePositives = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long count = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) count + = sstable . getBloomFilterFalsePositiveCount ( ) ; return count ; } } ) ; recentBloomFilterFalsePositives = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long count = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) count + = sstable . getRecentBloomFilterFalsePositiveCount ( ) ; return count ; } } ) ; bloomFilterFalseRatio = createTableGauge ( <str> , new Gauge < Double > ( ) { public Double getValue ( ) { long falseCount = <int> L ; long trueCount = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) { falseCount + = sstable . getBloomFilterFalsePositiveCount ( ) ; trueCount + = sstable . getBloomFilterTruePositiveCount ( ) ; } if ( falseCount = = <int> L & & trueCount = = <int> L ) return <float> ; return ( double ) falseCount / ( trueCount + falseCount ) ; } } , new Gauge < Double > ( ) { public Double getValue ( ) { long falseCount = <int> L ; long trueCount = <int> L ; for ( Keyspace keyspace : Keyspace . all ( ) ) { for ( SSTableReader sstable : keyspace . getAllSSTables ( SSTableSet . LIVE ) ) { falseCount + = sstable . getBloomFilterFalsePositiveCount ( ) ; trueCount + = sstable . getBloomFilterTruePositiveCount ( ) ; } } if ( falseCount = = <int> L & & trueCount = = <int> L ) return <float> ; return ( double ) falseCount / ( trueCount + falseCount ) ; } } ) ; recentBloomFilterFalseRatio = createTableGauge ( <str> , new Gauge < Double > ( ) { public Double getValue ( ) { long falseCount = <int> L ; long trueCount = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) { falseCount + = sstable . getRecentBloomFilterFalsePositiveCount ( ) ; trueCount + = sstable . getRecentBloomFilterTruePositiveCount ( ) ; } if ( falseCount = = <int> L & & trueCount = = <int> L ) return <float> ; return ( double ) falseCount / ( trueCount + falseCount ) ; } } , new Gauge < Double > ( ) { public Double getValue ( ) { long falseCount = <int> L ; long trueCount = <int> L ; for ( Keyspace keyspace : Keyspace . all ( ) ) { for ( SSTableReader sstable : keyspace . getAllSSTables ( SSTableSet . LIVE ) ) { falseCount + = sstable . getRecentBloomFilterFalsePositiveCount ( ) ; trueCount + = sstable . getRecentBloomFilterTruePositiveCount ( ) ; } } if ( falseCount = = <int> L & & trueCount = = <int> L ) return <float> ; return ( double ) falseCount / ( trueCount + falseCount ) ; } } ) ; bloomFilterDiskSpaceUsed = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( SSTableReader sst : cfs . getSSTables ( SSTableSet . CANONICAL ) ) total + = sst . getBloomFilterSerializedSize ( ) ; return total ; } } ) ; bloomFilterOffHeapMemoryUsed = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( SSTableReader sst : cfs . getSSTables ( SSTableSet . LIVE ) ) total + = sst . getBloomFilterOffHeapSize ( ) ; return total ; } } ) ; indexSummaryOffHeapMemoryUsed = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( SSTableReader sst : cfs . getSSTables ( SSTableSet . LIVE ) ) total + = sst . getIndexSummaryOffHeapSize ( ) ; return total ; } } ) ; compressionMetadataOffHeapMemoryUsed = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( SSTableReader sst : cfs . getSSTables ( SSTableSet . LIVE ) ) total + = sst . getCompressionMetadataOffHeapSize ( ) ; return total ; } } ) ; speculativeRetries = createTableCounter ( <str> ) ; keyCacheHitRate = Metrics . register ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) , new RatioGauge ( ) { @Override public Ratio getRatio ( ) { return Ratio . of ( getNumerator ( ) , getDenominator ( ) ) ; } protected double getNumerator ( ) { long hits = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) hits + = sstable . getKeyCacheHit ( ) ; return hits ; } protected double getDenominator ( ) { long requests = <int> L ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . LIVE ) ) requests + = sstable . getKeyCacheRequest ( ) ; return Math . max ( requests , <int> ) ; } } ) ; tombstoneScannedHistogram = createTableHistogram ( <str> , cfs . keyspace . metric . tombstoneScannedHistogram , false ) ; liveScannedHistogram = createTableHistogram ( <str> , cfs . keyspace . metric . liveScannedHistogram , false ) ; colUpdateTimeDeltaHistogram = createTableHistogram ( <str> , cfs . keyspace . metric . colUpdateTimeDeltaHistogram , false ) ; coordinatorReadLatency = Metrics . timer ( factory . createMetricName ( <str> ) ) ; coordinatorScanLatency = Metrics . timer ( factory . createMetricName ( <str> ) ) ; waitingOnFreeMemtableSpace = Metrics . histogram ( factory . createMetricName ( <str> ) , false ) ; if ( cfs . metadata . isView ( ) ) { viewLockAcquireTime = null ; viewReadTime = null ; } else { viewLockAcquireTime = createTableTimer ( <str> , cfs . keyspace . metric . viewLockAcquireTime ) ; viewReadTime = createTableTimer ( <str> , cfs . keyspace . metric . viewReadTime ) ; } trueSnapshotsSize = createTableGauge ( <str> , new Gauge < Long > ( ) { public Long getValue ( ) { return cfs . trueSnapshotsSize ( ) ; } } ) ; rowCacheHitOutOfRange = createTableCounter ( <str> ) ; rowCacheHit = createTableCounter ( <str> ) ; rowCacheMiss = createTableCounter ( <str> ) ; casPrepare = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . casPrepare ) ; casPropose = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . casPropose ) ; casCommit = new LatencyMetrics ( factory , <str> , cfs . keyspace . metric . casCommit ) ; } public void updateSSTableIterated ( int count ) { sstablesPerReadHistogram . update ( count ) ; } public void release ( ) { for ( Map . Entry < String , String > entry : all . entrySet ( ) ) { CassandraMetricsRegistry . MetricName name = factory . createMetricName ( entry . getKey ( ) ) ; CassandraMetricsRegistry . MetricName alias = aliasFactory . createMetricName ( entry . getValue ( ) ) ; allTableMetrics . get ( entry . getKey ( ) ) . remove ( Metrics . getMetrics ( ) . get ( name . getMetricName ( ) ) ) ; Metrics . remove ( name , alias ) ; } readLatency . release ( ) ; writeLatency . release ( ) ; rangeLatency . release ( ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; Metrics . remove ( factory . createMetricName ( <str> ) , aliasFactory . createMetricName ( <str> ) ) ; } protected < T extends Number > Gauge < T > createTableGauge ( final String name , Gauge < T > gauge ) { return createTableGauge ( name , gauge , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( Metric cfGauge : allTableMetrics . get ( name ) ) { total = total + ( ( Gauge < ? extends Number > ) cfGauge ) . getValue ( ) . longValue ( ) ; } return total ; } } ) ; } protected < G , T > Gauge < T > createTableGauge ( String name , Gauge < T > gauge , Gauge < G > globalGauge ) { return createTableGauge ( name , name , gauge , globalGauge ) ; } protected < G , T > Gauge < T > createTableGauge ( String name , String alias , Gauge < T > gauge , Gauge < G > globalGauge ) { Gauge < T > cfGauge = Metrics . register ( factory . createMetricName ( name ) , aliasFactory . createMetricName ( alias ) , gauge ) ; if ( register ( name , alias , cfGauge ) ) { Metrics . register ( globalFactory . createMetricName ( name ) , globalAliasFactory . createMetricName ( alias ) , globalGauge ) ; } return cfGauge ; } protected Counter createTableCounter ( final String name ) { return createTableCounter ( name , name ) ; } protected Counter createTableCounter ( final String name , final String alias ) { Counter cfCounter = Metrics . counter ( factory . createMetricName ( name ) , aliasFactory . createMetricName ( alias ) ) ; if ( register ( name , alias , cfCounter ) ) { Metrics . register ( globalFactory . createMetricName ( name ) , globalAliasFactory . createMetricName ( alias ) , new Gauge < Long > ( ) { public Long getValue ( ) { long total = <int> ; for ( Metric cfGauge : allTableMetrics . get ( name ) ) { total + = ( ( Counter ) cfGauge ) . getCount ( ) ; } return total ; } } ) ; } return cfCounter ; } private static Double computeCompressionRatio ( Iterable < SSTableReader > sstables ) { double compressedLengthSum = <int> ; double dataLengthSum = <int> ; for ( SSTableReader sstable : sstables ) { if ( sstable . compression ) { assert sstable . openReason ! = SSTableReader . OpenReason . EARLY ; CompressionMetadata compressionMetadata = sstable . getCompressionMetadata ( ) ; compressedLengthSum + = compressionMetadata . compressedFileLength ; dataLengthSum + = compressionMetadata . dataLength ; } } return dataLengthSum ! = <int> ? compressedLengthSum / dataLengthSum : <int> ; } protected TableHistogram createTableHistogram ( String name , Histogram keyspaceHistogram , boolean considerZeroes ) { return createTableHistogram ( name , name , keyspaceHistogram , considerZeroes ) ; } protected TableHistogram createTableHistogram ( String name , String alias , Histogram keyspaceHistogram , boolean considerZeroes ) { Histogram cfHistogram = Metrics . histogram ( factory . createMetricName ( name ) , aliasFactory . createMetricName ( alias ) , considerZeroes ) ; register ( name , alias , cfHistogram ) ; return new TableHistogram ( cfHistogram , keyspaceHistogram , Metrics . histogram ( globalFactory . createMetricName ( name ) , globalAliasFactory . createMetricName ( alias ) , considerZeroes ) ) ; } protected TableTimer createTableTimer ( String name , Timer keyspaceTimer ) { return createTableTimer ( name , name , keyspaceTimer ) ; } protected TableTimer createTableTimer ( String name , String alias , Timer keyspaceTimer ) { Timer cfTimer = Metrics . timer ( factory . createMetricName ( name ) , aliasFactory . createMetricName ( alias ) ) ; register ( name , alias , cfTimer ) ; return new TableTimer ( cfTimer , keyspaceTimer , Metrics . timer ( globalFactory . createMetricName ( name ) , globalAliasFactory . createMetricName ( alias ) ) ) ; } private boolean register ( String name , String alias , Metric metric ) { boolean ret = allTableMetrics . putIfAbsent ( name , new HashSet < > ( ) ) = = null ; allTableMetrics . get ( name ) . add ( metric ) ; all . put ( name , alias ) ; return ret ; } public static class TableHistogram { public final Histogram [ ] all ; public final Histogram cf ; private TableHistogram ( Histogram cf , Histogram keyspace , Histogram global ) { this . cf = cf ; this . all = new Histogram [ ] { cf , keyspace , global } ; } public void update ( long i ) { for ( Histogram histo : all ) { histo . update ( i ) ; } } } public static class TableTimer { public final Timer [ ] all ; public final Timer cf ; private TableTimer ( Timer cf , Timer keyspace , Timer global ) { this . cf = cf ; this . all = new Timer [ ] { cf , keyspace , global } ; } public void update ( long i , TimeUnit unit ) { for ( Timer timer : all ) { timer . update ( i , unit ) ; } } } static class TableMetricNameFactory implements MetricNameFactory { private final String keyspaceName ; private final String tableName ; private final boolean isIndex ; private final String type ; TableMetricNameFactory ( ColumnFamilyStore cfs , String type ) { this . keyspaceName = cfs . keyspace . getName ( ) ; this . tableName = cfs . name ; this . isIndex = cfs . isIndex ( ) ; this . type = type ; } public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) { String groupName = TableMetrics . class . getPackage ( ) . getName ( ) ; String type = isIndex ? <str> + this . type : this . type ; StringBuilder mbeanName = new StringBuilder ( ) ; mbeanName . append ( groupName ) . append ( <str> ) ; mbeanName . append ( <str> ) . append ( type ) ; mbeanName . append ( <str> ) . append ( keyspaceName ) ; mbeanName . append ( <str> ) . append ( tableName ) ; mbeanName . append ( <str> ) . append ( metricName ) ; return new CassandraMetricsRegistry . MetricName ( groupName , type , metricName , keyspaceName + <str> + tableName , mbeanName . toString ( ) ) ; } } static class AllTableMetricNameFactory implements MetricNameFactory { private final String type ; public AllTableMetricNameFactory ( String type ) { this . type = type ; } public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) { String groupName = TableMetrics . class . getPackage ( ) . getName ( ) ; StringBuilder mbeanName = new StringBuilder ( ) ; mbeanName . append ( groupName ) . append ( <str> ) ; mbeanName . append ( <str> + type ) ; mbeanName . append ( <str> ) . append ( metricName ) ; return new CassandraMetricsRegistry . MetricName ( groupName , type , metricName , <str> , mbeanName . toString ( ) ) ; } } public enum Sampler { READS , WRITES } } 
