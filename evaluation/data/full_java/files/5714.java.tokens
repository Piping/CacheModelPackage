package org . elasticsearch . common . compress ; import org . apache . lucene . store . IndexInput ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . LongArray ; import java . io . EOFException ; import java . io . IOException ; @Deprecated public abstract class CompressedIndexInput extends IndexInput { private IndexInput in ; private int version ; private long totalUncompressedLength ; private LongArray offsets ; private boolean closed ; protected byte [ ] uncompressed ; protected int uncompressedLength ; private int position = <int> ; private int valid = <int> ; private int currentOffsetIdx ; private long currentUncompressedChunkPointer ; public CompressedIndexInput ( IndexInput in ) throws IOException { super ( <str> + in . toString ( ) + <str> ) ; this . in = in ; readHeader ( in ) ; this . version = in . readInt ( ) ; long metaDataPosition = in . readLong ( ) ; long headerLength = in . getFilePointer ( ) ; in . seek ( metaDataPosition ) ; this . totalUncompressedLength = in . readVLong ( ) ; int size = in . readVInt ( ) ; offsets = BigArrays . NON_RECYCLING_INSTANCE . newLongArray ( size ) ; for ( int i = <int> ; i < size ; i + + ) { offsets . set ( i , in . readVLong ( ) ) ; } this . currentOffsetIdx = - <int> ; this . currentUncompressedChunkPointer = <int> ; in . seek ( headerLength ) ; } public int available ( ) throws IOException { if ( closed ) { return - <int> ; } int left = ( valid - position ) ; return ( left < = <int> ) ? <int> : left ; } @Override public byte readByte ( ) throws IOException { if ( ! readyBuffer ( ) ) { throw new EOFException ( ) ; } return uncompressed [ position + + ] ; } public int read ( byte [ ] buffer , int offset , int length , boolean fullRead ) throws IOException { if ( length < <int> ) { return <int> ; } if ( ! readyBuffer ( ) ) { return - <int> ; } int chunkLength = Math . min ( valid - position , length ) ; System . arraycopy ( uncompressed , position , buffer , offset , chunkLength ) ; position + = chunkLength ; if ( chunkLength = = length | | ! fullRead ) { return chunkLength ; } int totalRead = chunkLength ; do { offset + = chunkLength ; if ( ! readyBuffer ( ) ) { break ; } chunkLength = Math . min ( valid - position , ( length - totalRead ) ) ; System . arraycopy ( uncompressed , position , buffer , offset , chunkLength ) ; position + = chunkLength ; totalRead + = chunkLength ; } while ( totalRead < length ) ; return totalRead ; } @Override public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { int result = read ( b , offset , len , true ) ; if ( result < len ) { throw new EOFException ( ) ; } } @Override public long getFilePointer ( ) { return currentUncompressedChunkPointer + position ; } @Override public void seek ( long pos ) throws IOException { int idx = ( int ) ( pos / uncompressedLength ) ; if ( idx > = offsets . size ( ) ) { currentOffsetIdx = idx ; position = <int> ; valid = <int> ; return ; } if ( idx ! = currentOffsetIdx ) { long pointer = offsets . get ( idx ) ; in . seek ( pointer ) ; position = <int> ; valid = <int> ; currentOffsetIdx = idx - <int> ; readyBuffer ( ) ; } position = ( int ) ( pos % uncompressedLength ) ; } @Override public long length ( ) { return totalUncompressedLength ; } @Override public void close ( ) throws IOException { position = valid = <int> ; if ( ! closed ) { closed = true ; doClose ( ) ; in . close ( ) ; } } protected abstract void doClose ( ) throws IOException ; protected boolean readyBuffer ( ) throws IOException { if ( position < valid ) { return true ; } if ( closed ) { return false ; } if ( currentOffsetIdx + <int> > = offsets . size ( ) ) { return false ; } valid = uncompress ( in , uncompressed ) ; if ( valid < <int> ) { return false ; } currentOffsetIdx + + ; currentUncompressedChunkPointer = ( ( long ) currentOffsetIdx ) * uncompressedLength ; position = <int> ; return ( position < valid ) ; } protected abstract void readHeader ( IndexInput in ) throws IOException ; protected abstract int uncompress ( IndexInput in , byte [ ] out ) throws IOException ; @Override public IndexInput clone ( ) { CompressedIndexInput cloned = ( CompressedIndexInput ) super . clone ( ) ; cloned . uncompressed = new byte [ uncompressedLength ] ; System . arraycopy ( uncompressed , <int> , cloned . uncompressed , <int> , uncompressedLength ) ; cloned . in = ( IndexInput ) cloned . in . clone ( ) ; return cloned ; } } 
