package org . elasticsearch . index . shard ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . engine . IgnoreOnRecoveryEngineException ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . index . translog . Translog ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . index . mapper . SourceToParse . source ; public class TranslogRecoveryPerformer { private final MapperService mapperService ; private final ESLogger logger ; private final Map < String , Mapping > recoveredTypes = new HashMap < > ( ) ; private final ShardId shardId ; protected TranslogRecoveryPerformer ( ShardId shardId , MapperService mapperService , ESLogger logger ) { this . shardId = shardId ; this . mapperService = mapperService ; this . logger = logger ; } protected DocumentMapperForType docMapper ( String type ) { return mapperService . documentMapperWithAutoCreate ( type ) ; } int performBatchRecovery ( Engine engine , Iterable < Translog . Operation > operations ) { int numOps = <int> ; try { for ( Translog . Operation operation : operations ) { performRecoveryOperation ( engine , operation , false ) ; numOps + + ; } } catch ( Throwable t ) { throw new BatchOperationException ( shardId , <str> , numOps , t ) ; } return numOps ; } public static class BatchOperationException extends ElasticsearchException { private final int completedOperations ; public BatchOperationException ( ShardId shardId , String msg , int completedOperations , Throwable cause ) { super ( msg , cause ) ; setShard ( shardId ) ; this . completedOperations = completedOperations ; } public BatchOperationException ( StreamInput in ) throws IOException { super ( in ) ; completedOperations = in . readInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeInt ( completedOperations ) ; } public int completedOperations ( ) { return completedOperations ; } } private void maybeAddMappingUpdate ( String type , Mapping update , String docId , boolean allowMappingUpdates ) { if ( update = = null ) { return ; } if ( allowMappingUpdates = = false ) { throw new MapperException ( <str> + type + <str> + docId + <str> ) ; } Mapping currentUpdate = recoveredTypes . get ( type ) ; if ( currentUpdate = = null ) { recoveredTypes . put ( type , update ) ; } else { MapperUtils . merge ( currentUpdate , update ) ; } } public void performRecoveryOperation ( Engine engine , Translog . Operation operation , boolean allowMappingUpdates ) { try { switch ( operation . opType ( ) ) { case INDEX : Translog . Index index = ( Translog . Index ) operation ; Engine . Index engineIndex = IndexShard . prepareIndex ( docMapper ( index . type ( ) ) , source ( index . source ( ) ) . type ( index . type ( ) ) . id ( index . id ( ) ) . routing ( index . routing ( ) ) . parent ( index . parent ( ) ) . timestamp ( index . timestamp ( ) ) . ttl ( index . ttl ( ) ) , index . version ( ) , index . versionType ( ) . versionTypeForReplicationAndRecovery ( ) , Engine . Operation . Origin . RECOVERY ) ; maybeAddMappingUpdate ( engineIndex . type ( ) , engineIndex . parsedDoc ( ) . dynamicMappingsUpdate ( ) , engineIndex . id ( ) , allowMappingUpdates ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , index . type ( ) , index . id ( ) ) ; } engine . index ( engineIndex ) ; break ; case DELETE : Translog . Delete delete = ( Translog . Delete ) operation ; Uid uid = Uid . createUid ( delete . uid ( ) . text ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , uid . type ( ) , uid . id ( ) ) ; } engine . delete ( new Engine . Delete ( uid . type ( ) , uid . id ( ) , delete . uid ( ) , delete . version ( ) , delete . versionType ( ) . versionTypeForReplicationAndRecovery ( ) , Engine . Operation . Origin . RECOVERY , System . nanoTime ( ) , false ) ) ; break ; default : throw new IllegalStateException ( <str> + operation + <str> ) ; } } catch ( ElasticsearchException e ) { boolean hasIgnoreOnRecoveryException = false ; ElasticsearchException current = e ; while ( true ) { if ( current instanceof IgnoreOnRecoveryEngineException ) { hasIgnoreOnRecoveryException = true ; break ; } if ( current . getCause ( ) instanceof ElasticsearchException ) { current = ( ElasticsearchException ) current . getCause ( ) ; } else { break ; } } if ( ! hasIgnoreOnRecoveryException ) { throw e ; } } operationProcessed ( ) ; } protected void operationProcessed ( ) { } public Map < String , Mapping > getRecoveredTypes ( ) { return recoveredTypes ; } } 
