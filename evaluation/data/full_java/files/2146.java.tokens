package org . nd4j . linalg . api . parallel . tasks . cpu . transform ; import io . netty . buffer . ByteBuf ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ops . TransformOp ; import org . nd4j . linalg . api . parallel . tasks . Task ; import java . util . ArrayList ; import java . util . concurrent . RecursiveAction ; public class CPUTransformOpAction extends BaseCPUTransformOpAction { public CPUTransformOpAction ( TransformOp op , int threshold , int n , int offsetX , int offsetY , int offsetZ , int incrX , int incrY , int incrZ ) { super ( op , threshold , n , offsetX , offsetY , offsetZ , incrX , incrY , incrZ ) ; } public CPUTransformOpAction ( TransformOp op , int threshold ) { super ( op , threshold ) ; } public CPUTransformOpAction ( TransformOp op , int threshold , int tadIdx , int tadDim ) { super ( op , threshold , tadIdx , tadDim ) ; } @Override public Void call ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; if ( n > threshold ) { int nSubTasks = <int> + n / threshold ; subTasks = new ArrayList < > ( nSubTasks ) ; int taskSize = n / nSubTasks ; int soFar = <int> ; for ( int i = <int> ; i < nSubTasks ; i + + ) { int nInTask ; if ( i = = nSubTasks - <int> ) { nInTask = n - soFar ; } else { nInTask = taskSize ; } int offsetXNew = offsetX + soFar * incrX ; int offsetYNew = offsetY + soFar * incrY ; int offsetZNew = offsetZ + soFar * incrZ ; Task t = new CPUTransformOpAction ( op , threshold , nInTask , offsetXNew , offsetYNew , offsetZNew , incrX , incrY , incrZ ) ; t . invokeAsync ( ) ; subTasks . add ( t ) ; soFar + = nInTask ; } } else { execute ( ) ; } return null ; } @Override protected void compute ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; if ( n > threshold ) { int nFirst = n / <int> ; RecursiveAction first = new CPUTransformOpAction ( op , threshold , nFirst , offsetX , offsetY , offsetZ , incrX , incrY , incrZ ) ; first . fork ( ) ; int nSecond = n - nFirst ; int offsetX2 = offsetX + nFirst * incrX ; int offsetY2 = offsetY + nFirst * incrY ; int offsetZ2 = offsetZ + nFirst * incrZ ; RecursiveAction second = new CPUTransformOpAction ( op , threshold , nSecond , offsetX2 , offsetY2 , offsetZ2 , incrX , incrY , incrZ ) ; second . fork ( ) ; first . join ( ) ; second . join ( ) ; } else { execute ( ) ; } } private void execute ( ) { DataBuffer x = op . x ( ) . data ( ) ; DataBuffer y = ( op . y ( ) ! = null ? op . y ( ) . data ( ) : null ) ; DataBuffer z = op . z ( ) . data ( ) ; if ( y ! = null ) { if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; float [ ] yf = ( float [ ] ) y . array ( ) ; if ( incrX = = <int> & & incrY = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xf [ xIdx ] = op . op ( xf [ xIdx ] , yf [ offsetY + i ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i ] = op . op ( xf [ offsetX + i ] , yf [ offsetY + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xf [ xIdx ] = op . op ( xf [ xIdx ] , yf [ offsetY + i * incrY ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i * incrZ ] = op . op ( xf [ offsetX + i * incrX ] , yf [ offsetY + i * incrY ] ) ; } } } } else { double [ ] xd = ( double [ ] ) x . array ( ) ; double [ ] yd = ( double [ ] ) y . array ( ) ; if ( incrX = = <int> & & incrY = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xd [ xIdx ] = op . op ( xd [ xIdx ] , yd [ offsetY + i ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i ] = op . op ( xd [ offsetX + i ] , yd [ offsetY + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xd [ xIdx ] = op . op ( xd [ xIdx ] , yd [ offsetY + i * incrY ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i * incrZ ] = op . op ( xd [ offsetX + i * incrX ] , yd [ offsetY + i * incrY ] ) ; } } } } } else { ByteBuf nbbx = x . asNetty ( ) ; ByteBuf nbby = y . asNetty ( ) ; ByteBuf nbbz = z . asNetty ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = <int> * offsetX ; int byteOffsetY = <int> * offsetY ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & incrY = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i ; nbbx . setFloat ( xbOffset , op . op ( nbbx . getFloat ( xbOffset ) , nbby . getFloat ( byteOffsetY + i ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i , op . op ( nbbx . getFloat ( byteOffsetX + i ) , nbby . getFloat ( byteOffsetY + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i * incrX ; nbbx . setFloat ( xbOffset , op . op ( nbbx . getFloat ( xbOffset ) , nbby . getFloat ( byteOffsetY + i * incrY ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i * incrZ , op . op ( nbbx . getFloat ( byteOffsetX + i * incrX ) , nbby . getFloat ( byteOffsetY + i * incrY ) ) ) ; } } } } else { int byteOffsetX = <int> * offsetX ; int byteOffsetY = <int> * offsetY ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & incrY = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i ; nbbx . setDouble ( xbOffset , op . op ( nbbx . getDouble ( xbOffset ) , nbby . getDouble ( byteOffsetY + i ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i , op . op ( nbbx . getDouble ( byteOffsetX + i ) , nbby . getDouble ( byteOffsetY + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i * incrX ; nbbx . setDouble ( xbOffset , op . op ( nbbx . getDouble ( xbOffset ) , nbby . getDouble ( byteOffsetY + i * incrY ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i * incrZ , op . op ( nbbx . getDouble ( byteOffsetX + i * incrX ) , nbby . getDouble ( byteOffsetY + i * incrY ) ) ) ; } } } } } } else { if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xf [ xIdx ] = op . op ( xf [ xIdx ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i ] = op . op ( xf [ offsetX + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xf [ xIdx ] = op . op ( xf [ xIdx ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i * incrZ ] = op . op ( xf [ offsetX + i * incrX ] ) ; } } } } else { double [ ] xd = ( double [ ] ) x . array ( ) ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xd [ xIdx ] = op . op ( xd [ xIdx ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i ] = op . op ( xd [ offsetX + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xd [ xIdx ] = op . op ( xd [ xIdx ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i * incrZ ] = op . op ( xd [ offsetX + i * incrX ] ) ; } } } } } else { ByteBuf nbbx = x . asNetty ( ) ; ByteBuf nbbz = z . asNetty ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = <int> * offsetX ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i ; nbbx . setFloat ( xbOffset , op . op ( nbbx . getFloat ( xbOffset ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i , op . op ( nbbx . getFloat ( byteOffsetX + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i * incrX ; nbbx . setFloat ( xbOffset , op . op ( nbbx . getFloat ( xbOffset ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i * incrZ , op . op ( nbbx . getFloat ( byteOffsetX + i * incrX ) ) ) ; } } } } else { int byteOffsetX = <int> * offsetX ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i ; nbbx . setDouble ( xbOffset , op . op ( nbbx . getDouble ( xbOffset ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i , op . op ( nbbx . getDouble ( byteOffsetX + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbOffset = byteOffsetX + i * incrX ; nbbx . setDouble ( xbOffset , op . op ( nbbx . getDouble ( xbOffset ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i * incrZ , op . op ( nbbx . getDouble ( byteOffsetX + i * incrX ) ) ) ; } } } } } } } } 
