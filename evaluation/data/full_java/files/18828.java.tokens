package io . netty . handler . codec ; import java . util . Map . Entry ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . util . AsciiString ; public final class AsciiHeadersEncoder { public enum SeparatorType { COLON , COLON_SPACE , } public enum NewlineType { LF , CRLF } private final ByteBuf buf ; private final SeparatorType separatorType ; private final NewlineType newlineType ; public AsciiHeadersEncoder ( ByteBuf buf ) { this ( buf , SeparatorType . COLON_SPACE , NewlineType . CRLF ) ; } public AsciiHeadersEncoder ( ByteBuf buf , SeparatorType separatorType , NewlineType newlineType ) { if ( buf = = null ) { throw new NullPointerException ( <str> ) ; } if ( separatorType = = null ) { throw new NullPointerException ( <str> ) ; } if ( newlineType = = null ) { throw new NullPointerException ( <str> ) ; } this . buf = buf ; this . separatorType = separatorType ; this . newlineType = newlineType ; } public void encode ( Entry < CharSequence , CharSequence > entry ) { final CharSequence name = entry . getKey ( ) ; final CharSequence value = entry . getValue ( ) ; final ByteBuf buf = this . buf ; final int nameLen = name . length ( ) ; final int valueLen = value . length ( ) ; final int entryLen = nameLen + valueLen + <int> ; int offset = buf . writerIndex ( ) ; buf . ensureWritable ( entryLen ) ; writeAscii ( buf , offset , name , nameLen ) ; offset + = nameLen ; switch ( separatorType ) { case COLON : buf . setByte ( offset + + , <str> ) ; break ; case COLON_SPACE : buf . setByte ( offset + + , <str> ) ; buf . setByte ( offset + + , <str> ) ; break ; default : throw new Error ( ) ; } writeAscii ( buf , offset , value , valueLen ) ; offset + = valueLen ; switch ( newlineType ) { case LF : buf . setByte ( offset + + , <str> ) ; break ; case CRLF : buf . setByte ( offset + + , <str> ) ; buf . setByte ( offset + + , <str> ) ; break ; default : throw new Error ( ) ; } buf . writerIndex ( offset ) ; } private static void writeAscii ( ByteBuf buf , int offset , CharSequence value , int valueLen ) { if ( value instanceof AsciiString ) { writeAsciiString ( buf , offset , ( AsciiString ) value , valueLen ) ; } else { writeCharSequence ( buf , offset , value , valueLen ) ; } } private static void writeAsciiString ( ByteBuf buf , int offset , AsciiString value , int valueLen ) { ByteBufUtil . copy ( value , <int> , buf , offset , valueLen ) ; } private static void writeCharSequence ( ByteBuf buf , int offset , CharSequence value , int valueLen ) { for ( int i = <int> ; i < valueLen ; i + + ) { buf . setByte ( offset + + , c2b ( value . charAt ( i ) ) ) ; } } private static int c2b ( char ch ) { return ch < <int> ? ( byte ) ch : <str> ; } } 
