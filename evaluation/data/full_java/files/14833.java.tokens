package org . gradle . jvm . tasks ; import groovy . lang . Closure ; import org . gradle . api . Action ; import org . gradle . api . Incubating ; import org . gradle . api . file . CopySpec ; import org . gradle . api . file . FileCopyDetails ; import org . gradle . api . internal . file . collections . FileTreeAdapter ; import org . gradle . api . internal . file . collections . MapFileTree ; import org . gradle . api . internal . file . copy . CopySpecInternal ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . java . archives . Manifest ; import org . gradle . api . java . archives . internal . DefaultManifest ; import org . gradle . api . tasks . ParallelizableTask ; import org . gradle . api . tasks . bundling . Zip ; import org . gradle . util . ConfigureUtil ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . util . concurrent . Callable ; @ParallelizableTask @Incubating public class Jar extends Zip { public static final String DEFAULT_EXTENSION = <str> ; private Manifest manifest ; private final CopySpecInternal metaInf ; public Jar ( ) { setExtension ( DEFAULT_EXTENSION ) ; manifest = new DefaultManifest ( getFileResolver ( ) ) ; metaInf = ( CopySpecInternal ) getRootSpec ( ) . addFirst ( ) . into ( <str> ) ; metaInf . addChild ( ) . from ( new Callable < FileTreeAdapter > ( ) { public FileTreeAdapter call ( ) throws Exception { MapFileTree manifestSource = new MapFileTree ( getTemporaryDirFactory ( ) , getFileSystem ( ) ) ; manifestSource . add ( <str> , new Action < OutputStream > ( ) { public void execute ( OutputStream outputStream ) { Manifest manifest = getManifest ( ) ; if ( manifest = = null ) { manifest = new DefaultManifest ( null ) ; } manifest . writeTo ( new OutputStreamWriter ( outputStream ) ) ; } } ) ; return new FileTreeAdapter ( manifestSource ) ; } } ) ; getMainSpec ( ) . eachFile ( new Action < FileCopyDetails > ( ) { public void execute ( FileCopyDetails details ) { if ( details . getPath ( ) . equalsIgnoreCase ( <str> ) ) { details . exclude ( ) ; } } } ) ; } public Manifest getManifest ( ) { return manifest ; } public void setManifest ( Manifest manifest ) { this . manifest = manifest ; } public Jar manifest ( Closure < ? > configureClosure ) { if ( getManifest ( ) = = null ) { manifest = new DefaultManifest ( ( ( ProjectInternal ) getProject ( ) ) . getFileResolver ( ) ) ; } ConfigureUtil . configure ( configureClosure , getManifest ( ) ) ; return this ; } public CopySpec getMetaInf ( ) { return metaInf . addChild ( ) ; } public CopySpec metaInf ( Closure < ? > configureClosure ) { return ConfigureUtil . configure ( configureClosure , getMetaInf ( ) ) ; } } 
