package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; final class HttpPostBodyUtil { public static final int chunkSize = <int> ; public static final String DEFAULT_BINARY_CONTENT_TYPE = <str> ; public static final String DEFAULT_TEXT_CONTENT_TYPE = <str> ; public enum TransferEncodingMechanism { BIT7 ( <str> ) , BIT8 ( <str> ) , BINARY ( <str> ) ; private final String value ; TransferEncodingMechanism ( String value ) { this . value = value ; } TransferEncodingMechanism ( ) { value = name ( ) ; } public String value ( ) { return value ; } @Override public String toString ( ) { return value ; } } private HttpPostBodyUtil ( ) { } static class SeekAheadNoBackArrayException extends Exception { private static final long serialVersionUID = - <int> ; } static class SeekAheadOptimize { byte [ ] bytes ; int readerIndex ; int pos ; int origPos ; int limit ; ByteBuf buffer ; SeekAheadOptimize ( ByteBuf buffer ) throws SeekAheadNoBackArrayException { if ( ! buffer . hasArray ( ) ) { throw new SeekAheadNoBackArrayException ( ) ; } this . buffer = buffer ; bytes = buffer . array ( ) ; readerIndex = buffer . readerIndex ( ) ; origPos = pos = buffer . arrayOffset ( ) + readerIndex ; limit = buffer . arrayOffset ( ) + buffer . writerIndex ( ) ; } void setReadPosition ( int minus ) { pos - = minus ; readerIndex = getReadPosition ( pos ) ; buffer . readerIndex ( readerIndex ) ; } int getReadPosition ( int index ) { return index - origPos + readerIndex ; } void clear ( ) { buffer = null ; bytes = null ; limit = <int> ; pos = <int> ; readerIndex = <int> ; } } static int findNonWhitespace ( String sb , int offset ) { int result ; for ( result = offset ; result < sb . length ( ) ; result + + ) { if ( ! Character . isWhitespace ( sb . charAt ( result ) ) ) { break ; } } return result ; } static int findWhitespace ( String sb , int offset ) { int result ; for ( result = offset ; result < sb . length ( ) ; result + + ) { if ( Character . isWhitespace ( sb . charAt ( result ) ) ) { break ; } } return result ; } static int findEndOfString ( String sb ) { int result ; for ( result = sb . length ( ) ; result > <int> ; result - - ) { if ( ! Character . isWhitespace ( sb . charAt ( result - <int> ) ) ) { break ; } } return result ; } } 
