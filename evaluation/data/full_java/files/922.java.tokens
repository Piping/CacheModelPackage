package org . apache . cassandra . serializers ; import java . nio . ByteBuffer ; import java . util . concurrent . TimeUnit ; import java . util . regex . Pattern ; import org . apache . cassandra . utils . ByteBufferUtil ; public class TimeSerializer implements TypeSerializer < Long > { public static final Pattern timePattern = Pattern . compile ( <str> ) ; public static final TimeSerializer instance = new TimeSerializer ( ) ; public Long deserialize ( ByteBuffer bytes ) { return bytes . remaining ( ) = = <int> ? null : ByteBufferUtil . toLong ( bytes ) ; } public ByteBuffer serialize ( Long value ) { return value = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : ByteBufferUtil . bytes ( value ) ; } public static Long timeStringToLong ( String source ) throws MarshalException { if ( timePattern . matcher ( source ) . matches ( ) ) { try { long result = Long . parseLong ( source ) ; if ( result < <int> | | result > = TimeUnit . DAYS . toNanos ( <int> ) ) throw new NumberFormatException ( <str> + source ) ; return result ; } catch ( NumberFormatException e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } } try { return parseTimeStrictly ( source ) ; } catch ( IllegalArgumentException e1 ) { throw new MarshalException ( String . format ( <str> , source ) , e1 ) ; } } public void validate ( ByteBuffer bytes ) throws MarshalException { if ( bytes . remaining ( ) ! = <int> ) throw new MarshalException ( String . format ( <str> , bytes . remaining ( ) ) ) ; } public String toString ( Long value ) { if ( value = = null ) return <str> ; int nano = ( int ) ( value % <int> ) ; value - = nano ; value / = <int> ; int micro = ( int ) ( value % <int> ) ; value - = micro ; value / = <int> ; int milli = ( int ) ( value % <int> ) ; value - = milli ; value / = <int> ; int seconds = ( int ) ( value % <int> ) ; value - = seconds ; value / = <int> ; int minutes = ( int ) ( value % <int> ) ; value - = minutes ; value / = <int> ; int hours = ( int ) ( value % <int> ) ; value - = hours ; value / = <int> ; assert ( value = = <int> ) ; StringBuilder sb = new StringBuilder ( ) ; leftPadZeros ( hours , <int> , sb ) ; sb . append ( <str> ) ; leftPadZeros ( minutes , <int> , sb ) ; sb . append ( <str> ) ; leftPadZeros ( seconds , <int> , sb ) ; sb . append ( <str> ) ; leftPadZeros ( milli , <int> , sb ) ; leftPadZeros ( micro , <int> , sb ) ; leftPadZeros ( nano , <int> , sb ) ; return sb . toString ( ) ; } private void leftPadZeros ( int value , int digits , StringBuilder sb ) { for ( int i = <int> ; i < digits ; + + i ) { if ( value < Math . pow ( <int> , i ) ) sb . append ( <str> ) ; } sb . append ( value ) ; } public Class < Long > getType ( ) { return Long . class ; } private static Long parseTimeStrictly ( String s ) throws IllegalArgumentException { String nanos_s ; long hour ; long minute ; long second ; long a_nanos = <int> ; String formatError = <str> ; String zeros = <str> ; if ( s = = null ) throw new java . lang . IllegalArgumentException ( formatError ) ; s = s . trim ( ) ; int firstColon = s . indexOf ( <str> ) ; int secondColon = s . indexOf ( <str> , firstColon + <int> ) ; if ( firstColon > <int> & & secondColon > <int> & & secondColon < s . length ( ) - <int> ) { int period = s . indexOf ( <str> , secondColon + <int> ) ; hour = Integer . parseInt ( s . substring ( <int> , firstColon ) ) ; if ( hour < <int> | | hour > = <int> ) throw new IllegalArgumentException ( <str> ) ; minute = Integer . parseInt ( s . substring ( firstColon + <int> , secondColon ) ) ; if ( minute < <int> | | minute > = <int> ) throw new IllegalArgumentException ( <str> ) ; if ( period > <int> & & period < s . length ( ) - <int> ) { second = Integer . parseInt ( s . substring ( secondColon + <int> , period ) ) ; if ( second < <int> | | second > = <int> ) throw new IllegalArgumentException ( <str> ) ; nanos_s = s . substring ( period + <int> ) ; if ( nanos_s . length ( ) > <int> ) throw new IllegalArgumentException ( formatError ) ; if ( ! Character . isDigit ( nanos_s . charAt ( <int> ) ) ) throw new IllegalArgumentException ( formatError ) ; nanos_s = nanos_s + zeros . substring ( <int> , <int> - nanos_s . length ( ) ) ; a_nanos = Integer . parseInt ( nanos_s ) ; } else if ( period > <int> ) throw new IllegalArgumentException ( formatError ) ; else { second = Integer . parseInt ( s . substring ( secondColon + <int> ) ) ; if ( second < <int> | | second > = <int> ) throw new IllegalArgumentException ( <str> ) ; } } else throw new IllegalArgumentException ( formatError ) ; long rawTime = <int> ; rawTime + = TimeUnit . HOURS . toNanos ( hour ) ; rawTime + = TimeUnit . MINUTES . toNanos ( minute ) ; rawTime + = TimeUnit . SECONDS . toNanos ( second ) ; rawTime + = a_nanos ; return rawTime ; } } 
