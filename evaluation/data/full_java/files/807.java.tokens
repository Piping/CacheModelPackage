package org . apache . cassandra . metrics ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import static java . lang . Math . exp ; import com . codahale . metrics . Clock ; public class RestorableMeter { private static final long TICK_INTERVAL = TimeUnit . SECONDS . toNanos ( <int> ) ; private static final double NANOS_PER_SECOND = TimeUnit . SECONDS . toNanos ( <int> ) ; private final RestorableEWMA m15Rate ; private final RestorableEWMA m120Rate ; private final AtomicLong count = new AtomicLong ( ) ; private final long startTime ; private final AtomicLong lastTick ; private final Clock clock = Clock . defaultClock ( ) ; public RestorableMeter ( ) { this . m15Rate = new RestorableEWMA ( TimeUnit . MINUTES . toSeconds ( <int> ) ) ; this . m120Rate = new RestorableEWMA ( TimeUnit . MINUTES . toSeconds ( <int> ) ) ; this . startTime = this . clock . getTick ( ) ; this . lastTick = new AtomicLong ( startTime ) ; } public RestorableMeter ( double lastM15Rate , double lastM120Rate ) { this . m15Rate = new RestorableEWMA ( lastM15Rate , TimeUnit . MINUTES . toSeconds ( <int> ) ) ; this . m120Rate = new RestorableEWMA ( lastM120Rate , TimeUnit . MINUTES . toSeconds ( <int> ) ) ; this . startTime = this . clock . getTick ( ) ; this . lastTick = new AtomicLong ( startTime ) ; } private void tickIfNecessary ( ) { final long oldTick = lastTick . get ( ) ; final long newTick = clock . getTick ( ) ; final long age = newTick - oldTick ; if ( age > TICK_INTERVAL ) { final long newIntervalStartTick = newTick - age % TICK_INTERVAL ; if ( lastTick . compareAndSet ( oldTick , newIntervalStartTick ) ) { final long requiredTicks = age / TICK_INTERVAL ; for ( long i = <int> ; i < requiredTicks ; i + + ) { m15Rate . tick ( ) ; m120Rate . tick ( ) ; } } } } public void mark ( ) { mark ( <int> ) ; } public void mark ( long n ) { tickIfNecessary ( ) ; count . addAndGet ( n ) ; m15Rate . update ( n ) ; m120Rate . update ( n ) ; } public double fifteenMinuteRate ( ) { tickIfNecessary ( ) ; return m15Rate . rate ( ) ; } public double twoHourRate ( ) { tickIfNecessary ( ) ; return m120Rate . rate ( ) ; } public long count ( ) { return count . get ( ) ; } public double meanRate ( ) { if ( count ( ) = = <int> ) { return <float> ; } else { final long elapsed = ( clock . getTick ( ) - startTime ) ; return ( count ( ) / ( double ) elapsed ) * NANOS_PER_SECOND ; } } static class RestorableEWMA { private volatile boolean initialized = false ; private volatile double rate = <float> ; private final AtomicLong uncounted = new AtomicLong ( ) ; private final double alpha , interval ; public RestorableEWMA ( long windowInSeconds ) { this . alpha = <int> - exp ( ( - TICK_INTERVAL / NANOS_PER_SECOND ) / windowInSeconds ) ; this . interval = TICK_INTERVAL ; } public RestorableEWMA ( double lastRate , long intervalInSeconds ) { this ( intervalInSeconds ) ; this . rate = lastRate / NANOS_PER_SECOND ; this . initialized = true ; } public void update ( long n ) { uncounted . addAndGet ( n ) ; } public void tick ( ) { final long count = uncounted . getAndSet ( <int> ) ; final double instantRate = count / interval ; if ( initialized ) { rate + = ( alpha * ( instantRate - rate ) ) ; } else { rate = instantRate ; initialized = true ; } } public double rate ( ) { return rate * NANOS_PER_SECOND ; } } } 
