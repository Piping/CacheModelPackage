package org . elasticsearch . test ; import org . apache . lucene . util . Constants ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . transport . TransportClient ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . discovery . DiscoveryModule ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . transport . TransportModule ; import java . io . Closeable ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Random ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; final class ExternalNode implements Closeable { public static final Settings REQUIRED_SETTINGS = Settings . builder ( ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . put ( DiscoveryModule . DISCOVERY_TYPE_KEY , <str> ) . put ( <str> , <str> ) . build ( ) ; private final Path path ; private final Random random ; private final NodeConfigurationSource nodeConfigurationSource ; private Process process ; private NodeInfo nodeInfo ; private final String clusterName ; private TransportClient client ; private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private Settings externalNodeSettings ; ExternalNode ( Path path , long seed , NodeConfigurationSource nodeConfigurationSource ) { this ( path , null , seed , nodeConfigurationSource ) ; } ExternalNode ( Path path , String clusterName , long seed , NodeConfigurationSource nodeConfigurationSource ) { if ( ! Files . isDirectory ( path ) ) { throw new IllegalArgumentException ( <str> ) ; } this . path = path ; this . clusterName = clusterName ; this . random = new Random ( seed ) ; this . nodeConfigurationSource = nodeConfigurationSource ; } synchronized ExternalNode start ( Client localNode , Settings defaultSettings , String nodeName , String clusterName , int nodeOrdinal ) throws IOException , InterruptedException { ExternalNode externalNode = new ExternalNode ( path , clusterName , random . nextLong ( ) , nodeConfigurationSource ) ; Settings settings = Settings . builder ( ) . put ( defaultSettings ) . put ( nodeConfigurationSource . nodeSettings ( nodeOrdinal ) ) . build ( ) ; externalNode . startInternal ( localNode , settings , nodeName , clusterName ) ; return externalNode ; } @SuppressForbidden ( reason = <str> ) synchronized void startInternal ( Client client , Settings settings , String nodeName , String clusterName ) throws IOException , InterruptedException { if ( process ! = null ) { throw new IllegalStateException ( <str> ) ; } List < String > params = new ArrayList < > ( ) ; if ( ! Constants . WINDOWS ) { params . add ( <str> ) ; } else { params . add ( <str> ) ; } params . add ( <str> + clusterName ) ; params . add ( <str> + nodeName ) ; Settings . Builder externaNodeSettingsBuilder = Settings . builder ( ) ; for ( Map . Entry < String , String > entry : settings . getAsMap ( ) . entrySet ( ) ) { switch ( entry . getKey ( ) ) { case <str> : case <str> : case <str> : case <str> : case <str> : case TransportModule . TRANSPORT_TYPE_KEY : case DiscoveryModule . DISCOVERY_TYPE_KEY : case TransportModule . TRANSPORT_SERVICE_TYPE_KEY : case InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING : continue ; default : externaNodeSettingsBuilder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } this . externalNodeSettings = externaNodeSettingsBuilder . put ( REQUIRED_SETTINGS ) . build ( ) ; for ( Map . Entry < String , String > entry : externalNodeSettings . getAsMap ( ) . entrySet ( ) ) { params . add ( <str> + entry . getKey ( ) + <str> + entry . getValue ( ) ) ; } params . add ( <str> + PathUtils . get ( <str> ) . toAbsolutePath ( ) ) ; params . add ( <str> + path + <str> ) ; ProcessBuilder builder = new ProcessBuilder ( params ) ; builder . directory ( path . toFile ( ) ) ; builder . inheritIO ( ) ; boolean success = false ; try { logger . info ( <str> , nodeName , builder . command ( ) ) ; process = builder . start ( ) ; this . nodeInfo = null ; if ( waitForNode ( client , nodeName ) ) { nodeInfo = nodeInfo ( client , nodeName ) ; assert nodeInfo ! = null ; logger . info ( <str> , nodeInfo . getNode ( ) , nodeInfo . getVersion ( ) , nodeInfo . getBuild ( ) ) ; } else { throw new IllegalStateException ( <str> + nodeName + <str> ) ; } success = true ; } finally { if ( ! success ) { stop ( ) ; } } } static boolean waitForNode ( final Client client , final String name ) throws InterruptedException { return ESTestCase . awaitBusy ( ( ) - > { final NodesInfoResponse nodeInfos = client . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . get ( ) ; final NodeInfo [ ] nodes = nodeInfos . getNodes ( ) ; for ( NodeInfo info : nodes ) { if ( name . equals ( info . getNode ( ) . getName ( ) ) ) { return true ; } } return false ; } , <int> , TimeUnit . SECONDS ) ; } static NodeInfo nodeInfo ( final Client client , final String nodeName ) { final NodesInfoResponse nodeInfos = client . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . get ( ) ; final NodeInfo [ ] nodes = nodeInfos . getNodes ( ) ; for ( NodeInfo info : nodes ) { if ( nodeName . equals ( info . getNode ( ) . getName ( ) ) ) { return info ; } } return null ; } synchronized TransportAddress getTransportAddress ( ) { if ( nodeInfo = = null ) { throw new IllegalStateException ( <str> ) ; } return nodeInfo . getTransport ( ) . getAddress ( ) . publishAddress ( ) ; } synchronized Client getClient ( ) { if ( nodeInfo = = null ) { throw new IllegalStateException ( <str> ) ; } if ( client = = null ) { TransportAddress addr = nodeInfo . getTransport ( ) . getAddress ( ) . publishAddress ( ) ; Settings clientSettings = settingsBuilder ( ) . put ( externalNodeSettings ) . put ( <str> , <str> ) . put ( <str> , <str> + nodeInfo . getNode ( ) . name ( ) ) . put ( ClusterName . SETTING , clusterName ) . put ( <str> , false ) . build ( ) ; TransportClient client = TransportClient . builder ( ) . settings ( clientSettings ) . build ( ) ; client . addTransportAddress ( addr ) ; this . client = client ; } return client ; } synchronized void reset ( long seed ) { this . random . setSeed ( seed ) ; } synchronized void stop ( ) throws InterruptedException { if ( running ( ) ) { try { if ( this . client ! = null ) { client . close ( ) ; } } finally { process . destroy ( ) ; process . waitFor ( ) ; process = null ; nodeInfo = null ; } } } synchronized boolean running ( ) { return process ! = null ; } @Override public void close ( ) { try { stop ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } synchronized String getName ( ) { if ( nodeInfo = = null ) { throw new IllegalStateException ( <str> ) ; } return nodeInfo . getNode ( ) . getName ( ) ; } } 
