package org . elasticsearch . discovery . zen ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . service . InternalClusterService ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . component . Lifecycle ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . internal . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . DiscoveryStats ; import org . elasticsearch . discovery . InitialStateDiscoveryListener ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . fd . MasterFaultDetection ; import org . elasticsearch . discovery . zen . fd . NodesFaultDetection ; import org . elasticsearch . discovery . zen . membership . MembershipAction ; import org . elasticsearch . discovery . zen . ping . PingContextProvider ; import org . elasticsearch . discovery . zen . ping . ZenPing ; import org . elasticsearch . discovery . zen . ping . ZenPingService ; import org . elasticsearch . discovery . zen . publish . PendingClusterStateStats ; import org . elasticsearch . discovery . zen . publish . PublishClusterStateAction ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . unit . TimeValue . timeValueSeconds ; public class ZenDiscovery extends AbstractLifecycleComponent < Discovery > implements Discovery , PingContextProvider { public final static String SETTING_REJOIN_ON_MASTER_GONE = <str> ; public final static String SETTING_PING_TIMEOUT = <str> ; public final static String SETTING_JOIN_TIMEOUT = <str> ; public final static String SETTING_JOIN_RETRY_ATTEMPTS = <str> ; public final static String SETTING_JOIN_RETRY_DELAY = <str> ; public final static String SETTING_MAX_PINGS_FROM_ANOTHER_MASTER = <str> ; public final static String SETTING_SEND_LEAVE_REQUEST = <str> ; public final static String SETTING_MASTER_ELECTION_FILTER_CLIENT = <str> ; public final static String SETTING_MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT = <str> ; public final static String SETTING_MASTER_ELECTION_FILTER_DATA = <str> ; public static final String DISCOVERY_REJOIN_ACTION_NAME = <str> ; private final TransportService transportService ; private final ClusterService clusterService ; private RoutingService routingService ; private final ClusterName clusterName ; private final DiscoverySettings discoverySettings ; private final ZenPingService pingService ; private final MasterFaultDetection masterFD ; private final NodesFaultDetection nodesFD ; private final PublishClusterStateAction publishClusterState ; private final MembershipAction membership ; private final TimeValue pingTimeout ; private final TimeValue joinTimeout ; private final int joinRetryAttempts ; private final TimeValue joinRetryDelay ; private final int maxPingsFromAnotherMaster ; private final boolean sendLeaveRequest ; private final ElectMasterService electMaster ; private final boolean masterElectionFilterClientNodes ; private final boolean masterElectionFilterDataNodes ; private final TimeValue masterElectionWaitForJoinsTimeout ; private final CopyOnWriteArrayList < InitialStateDiscoveryListener > initialStateListeners = new CopyOnWriteArrayList < > ( ) ; private final JoinThreadControl joinThreadControl ; private final AtomicBoolean initialStateSent = new AtomicBoolean ( ) ; private volatile boolean rejoinOnMasterGone ; private final AtomicLong clusterJoinsCounter = new AtomicLong ( ) ; @Nullable private NodeService nodeService ; private volatile NodeJoinController nodeJoinController ; @Inject public ZenDiscovery ( Settings settings , ClusterName clusterName , ThreadPool threadPool , TransportService transportService , final ClusterService clusterService , NodeSettingsService nodeSettingsService , ZenPingService pingService , ElectMasterService electMasterService , DiscoverySettings discoverySettings ) { super ( settings ) ; this . clusterName = clusterName ; this . clusterService = clusterService ; this . transportService = transportService ; this . discoverySettings = discoverySettings ; this . pingService = pingService ; this . electMaster = electMasterService ; this . pingTimeout = settings . getAsTime ( SETTING_PING_TIMEOUT , timeValueSeconds ( <int> ) ) ; this . joinTimeout = settings . getAsTime ( SETTING_JOIN_TIMEOUT , TimeValue . timeValueMillis ( this . pingTimeout . millis ( ) * <int> ) ) ; this . joinRetryAttempts = settings . getAsInt ( SETTING_JOIN_RETRY_ATTEMPTS , <int> ) ; this . joinRetryDelay = settings . getAsTime ( SETTING_JOIN_RETRY_DELAY , TimeValue . timeValueMillis ( <int> ) ) ; this . maxPingsFromAnotherMaster = settings . getAsInt ( SETTING_MAX_PINGS_FROM_ANOTHER_MASTER , <int> ) ; this . sendLeaveRequest = settings . getAsBoolean ( SETTING_SEND_LEAVE_REQUEST , true ) ; this . masterElectionFilterClientNodes = settings . getAsBoolean ( SETTING_MASTER_ELECTION_FILTER_CLIENT , true ) ; this . masterElectionFilterDataNodes = settings . getAsBoolean ( SETTING_MASTER_ELECTION_FILTER_DATA , false ) ; this . masterElectionWaitForJoinsTimeout = settings . getAsTime ( SETTING_MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT , TimeValue . timeValueMillis ( joinTimeout . millis ( ) / <int> ) ) ; this . rejoinOnMasterGone = settings . getAsBoolean ( SETTING_REJOIN_ON_MASTER_GONE , true ) ; if ( this . joinRetryAttempts < <int> ) { throw new IllegalArgumentException ( <str> + SETTING_JOIN_RETRY_ATTEMPTS + <str> + SETTING_JOIN_RETRY_ATTEMPTS + <str> ) ; } if ( this . maxPingsFromAnotherMaster < <int> ) { throw new IllegalArgumentException ( <str> + SETTING_MAX_PINGS_FROM_ANOTHER_MASTER + <str> + this . maxPingsFromAnotherMaster + <str> ) ; } logger . debug ( <str> , this . pingTimeout , joinTimeout , masterElectionFilterClientNodes , masterElectionFilterDataNodes ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; this . masterFD = new MasterFaultDetection ( settings , threadPool , transportService , clusterName , clusterService ) ; this . masterFD . addListener ( new MasterNodeFailureListener ( ) ) ; this . nodesFD = new NodesFaultDetection ( settings , threadPool , transportService , clusterName ) ; this . nodesFD . addListener ( new NodeFaultDetectionListener ( ) ) ; this . publishClusterState = new PublishClusterStateAction ( settings , transportService , this , new NewPendingClusterStateListener ( ) , discoverySettings , clusterName ) ; this . pingService . setPingContextProvider ( this ) ; this . membership = new MembershipAction ( settings , clusterService , transportService , this , new MembershipListener ( ) ) ; this . joinThreadControl = new JoinThreadControl ( threadPool ) ; transportService . registerRequestHandler ( DISCOVERY_REJOIN_ACTION_NAME , RejoinClusterRequest : : new , ThreadPool . Names . SAME , new RejoinClusterRequestHandler ( ) ) ; } @Override public void setNodeService ( @Nullable NodeService nodeService ) { this . nodeService = nodeService ; } @Override public void setRoutingService ( RoutingService routingService ) { this . routingService = routingService ; } @Override protected void doStart ( ) { nodesFD . setLocalNode ( clusterService . localNode ( ) ) ; joinThreadControl . start ( ) ; pingService . start ( ) ; this . nodeJoinController = new NodeJoinController ( clusterService , routingService , discoverySettings , settings ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { joinThreadControl . startNewThreadIfNotRunning ( ) ; return currentState ; } @Override public void onFailure ( String source , @org.elasticsearch.common.Nullable Throwable t ) { logger . warn ( <str> , t ) ; } } ) ; } @Override protected void doStop ( ) { joinThreadControl . stop ( ) ; pingService . stop ( ) ; masterFD . stop ( <str> ) ; nodesFD . stop ( ) ; initialStateSent . set ( false ) ; DiscoveryNodes nodes = nodes ( ) ; if ( sendLeaveRequest ) { if ( nodes . masterNode ( ) = = null ) { } else if ( ! nodes . localNodeMaster ( ) ) { try { membership . sendLeaveRequestBlocking ( nodes . masterNode ( ) , nodes . localNode ( ) , TimeValue . timeValueSeconds ( <int> ) ) ; } catch ( Exception e ) { logger . debug ( <str> , e , nodes . masterNode ( ) ) ; } } else { DiscoveryNode [ ] possibleMasters = electMaster . nextPossibleMasters ( nodes . nodes ( ) . values ( ) , <int> ) ; for ( DiscoveryNode possibleMaster : possibleMasters ) { if ( nodes . localNode ( ) . equals ( possibleMaster ) ) { continue ; } try { membership . sendLeaveRequest ( nodes . localNode ( ) , possibleMaster ) ; } catch ( Exception e ) { logger . debug ( <str> , e , nodes . masterNode ( ) , possibleMaster ) ; } } } } } @Override protected void doClose ( ) { masterFD . close ( ) ; nodesFD . close ( ) ; publishClusterState . close ( ) ; membership . close ( ) ; pingService . close ( ) ; } @Override public DiscoveryNode localNode ( ) { return clusterService . localNode ( ) ; } @Override public void addListener ( InitialStateDiscoveryListener listener ) { this . initialStateListeners . add ( listener ) ; } @Override public void removeListener ( InitialStateDiscoveryListener listener ) { this . initialStateListeners . remove ( listener ) ; } @Override public String nodeDescription ( ) { return clusterName . value ( ) + <str> + clusterService . localNode ( ) . id ( ) ; } @Override public DiscoveryNodes nodes ( ) { return clusterService . state ( ) . nodes ( ) ; } @Override public NodeService nodeService ( ) { return this . nodeService ; } @Override public boolean nodeHasJoinedClusterOnce ( ) { return clusterJoinsCounter . get ( ) > <int> ; } @Override public void publish ( ClusterChangedEvent clusterChangedEvent , AckListener ackListener ) { if ( ! clusterChangedEvent . state ( ) . getNodes ( ) . localNodeMaster ( ) ) { throw new IllegalStateException ( <str> ) ; } nodesFD . updateNodesAndPing ( clusterChangedEvent . state ( ) ) ; try { publishClusterState . publish ( clusterChangedEvent , electMaster . minimumMasterNodes ( ) , ackListener ) ; } catch ( FailedToCommitClusterStateException t ) { logger . debug ( <str> , clusterChangedEvent . state ( ) . version ( ) , electMaster . minimumMasterNodes ( ) ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) { return rejoin ( currentState , <str> ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } } ) ; throw t ; } } @Override public DiscoveryStats stats ( ) { PendingClusterStateStats queueStats = publishClusterState . pendingStatesQueue ( ) . stats ( ) ; return new DiscoveryStats ( queueStats ) ; } public boolean joiningCluster ( ) { return joinThreadControl . joinThreadActive ( ) ; } public ClusterState [ ] pendingClusterStates ( ) { return publishClusterState . pendingStatesQueue ( ) . pendingClusterStates ( ) ; } private void innerJoinCluster ( ) { DiscoveryNode masterNode = null ; final Thread currentThread = Thread . currentThread ( ) ; nodeJoinController . startAccumulatingJoins ( ) ; while ( masterNode = = null & & joinThreadControl . joinThreadActive ( currentThread ) ) { masterNode = findMaster ( ) ; } if ( ! joinThreadControl . joinThreadActive ( currentThread ) ) { logger . trace ( <str> ) ; return ; } if ( clusterService . localNode ( ) . equals ( masterNode ) ) { final int requiredJoins = Math . max ( <int> , electMaster . minimumMasterNodes ( ) - <int> ) ; logger . debug ( <str> , requiredJoins ) ; nodeJoinController . waitToBeElectedAsMaster ( requiredJoins , masterElectionWaitForJoinsTimeout , new NodeJoinController . ElectionCallback ( ) { @Override public void onElectedAsMaster ( ClusterState state ) { joinThreadControl . markThreadAsDone ( currentThread ) ; nodesFD . updateNodesAndPing ( state ) ; sendInitialStateEventIfNeeded ( ) ; long count = clusterJoinsCounter . incrementAndGet ( ) ; logger . trace ( <str> , count ) ; } @Override public void onFailure ( Throwable t ) { logger . trace ( <str> , t ) ; joinThreadControl . markThreadAsDoneAndStartNew ( currentThread ) ; } } ) ; } else { nodeJoinController . stopAccumulatingJoins ( <str> ) ; final boolean success = joinElectedMaster ( masterNode ) ; final DiscoveryNode finalMasterNode = masterNode ; clusterService . submitStateUpdateTask ( <str> + masterNode + <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { if ( ! success ) { joinThreadControl . markThreadAsDoneAndStartNew ( currentThread ) ; return currentState ; } if ( currentState . getNodes ( ) . masterNode ( ) = = null ) { logger . debug ( <str> ) ; joinThreadControl . markThreadAsDoneAndStartNew ( currentThread ) ; return currentState ; } if ( ! currentState . getNodes ( ) . masterNode ( ) . equals ( finalMasterNode ) ) { return joinThreadControl . stopRunningThreadAndRejoin ( currentState , <str> ) ; } joinThreadControl . markThreadAsDone ( currentThread ) ; return currentState ; } @Override public void onFailure ( String source , @Nullable Throwable t ) { logger . error ( <str> , t ) ; joinThreadControl . markThreadAsDoneAndStartNew ( currentThread ) ; } } ) ; } } private boolean joinElectedMaster ( DiscoveryNode masterNode ) { try { transportService . connectToNode ( masterNode ) ; } catch ( Exception e ) { logger . warn ( <str> , e , masterNode ) ; return false ; } int joinAttempt = <int> ; while ( true ) { try { logger . trace ( <str> , masterNode ) ; membership . sendJoinRequestBlocking ( masterNode , clusterService . localNode ( ) , joinTimeout ) ; return true ; } catch ( Throwable t ) { Throwable unwrap = ExceptionsHelper . unwrapCause ( t ) ; if ( unwrap instanceof NotMasterException ) { if ( + + joinAttempt = = this . joinRetryAttempts ) { logger . info ( <str> , masterNode , ExceptionsHelper . detailedMessage ( t ) , joinAttempt ) ; return false ; } else { logger . trace ( <str> , masterNode , ExceptionsHelper . detailedMessage ( t ) , joinAttempt ) ; } } else { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , t , masterNode ) ; } else { logger . info ( <str> , masterNode , ExceptionsHelper . detailedMessage ( t ) ) ; } return false ; } } try { Thread . sleep ( this . joinRetryDelay . millis ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } private void handleLeaveRequest ( final DiscoveryNode node ) { if ( lifecycleState ( ) ! = Lifecycle . State . STARTED ) { return ; } if ( localNodeMaster ( ) ) { clusterService . submitStateUpdateTask ( <str> + node + <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes . Builder builder = DiscoveryNodes . builder ( currentState . nodes ( ) ) . remove ( node . id ( ) ) ; currentState = ClusterState . builder ( currentState ) . nodes ( builder ) . build ( ) ; if ( ! electMaster . hasEnoughMasterNodes ( currentState . nodes ( ) ) ) { return rejoin ( currentState , <str> ) ; } RoutingAllocation . Result routingResult = routingService . getAllocationService ( ) . reroute ( ClusterState . builder ( currentState ) . build ( ) , <str> + node + <str> ) ; return ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; } @Override public void onNoLongerMaster ( String source ) { } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } } ) ; } else if ( node . equals ( nodes ( ) . masterNode ( ) ) ) { handleMasterGone ( node , null , <str> ) ; } } private void handleNodeFailure ( final DiscoveryNode node , String reason ) { if ( lifecycleState ( ) ! = Lifecycle . State . STARTED ) { return ; } if ( ! localNodeMaster ( ) ) { return ; } clusterService . submitStateUpdateTask ( <str> + node + <str> + reason , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) { if ( currentState . nodes ( ) . get ( node . id ( ) ) = = null ) { logger . debug ( <str> , node ) ; return currentState ; } DiscoveryNodes . Builder builder = DiscoveryNodes . builder ( currentState . nodes ( ) ) . remove ( node . id ( ) ) ; currentState = ClusterState . builder ( currentState ) . nodes ( builder ) . build ( ) ; if ( ! electMaster . hasEnoughMasterNodes ( currentState . nodes ( ) ) ) { return rejoin ( currentState , <str> ) ; } RoutingAllocation . Result routingResult = routingService . getAllocationService ( ) . reroute ( ClusterState . builder ( currentState ) . build ( ) , <str> + node + <str> ) ; return ClusterState . builder ( currentState ) . routingResult ( routingResult ) . build ( ) ; } @Override public void onNoLongerMaster ( String source ) { } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; } } ) ; } private void handleMinimumMasterNodesChanged ( final int minimumMasterNodes ) { if ( lifecycleState ( ) ! = Lifecycle . State . STARTED ) { return ; } final int prevMinimumMasterNode = ZenDiscovery . this . electMaster . minimumMasterNodes ( ) ; ZenDiscovery . this . electMaster . minimumMasterNodes ( minimumMasterNodes ) ; if ( ! localNodeMaster ( ) ) { return ; } clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) { if ( ! electMaster . hasEnoughMasterNodes ( currentState . nodes ( ) ) ) { return rejoin ( currentState , <str> + prevMinimumMasterNode + <str> + minimumMasterNodes + <str> ) ; } return currentState ; } @Override public void onNoLongerMaster ( String source ) { } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; } } ) ; } private void handleMasterGone ( final DiscoveryNode masterNode , final Throwable cause , final String reason ) { if ( lifecycleState ( ) ! = Lifecycle . State . STARTED ) { return ; } if ( localNodeMaster ( ) ) { return ; } logger . info ( <str> , cause , masterNode , reason ) ; clusterService . submitStateUpdateTask ( <str> + masterNode + <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { if ( ! masterNode . id ( ) . equals ( currentState . nodes ( ) . masterNodeId ( ) ) ) { return currentState ; } DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( currentState . nodes ( ) ) . remove ( masterNode . id ( ) ) . masterNodeId ( null ) . build ( ) ; publishClusterState . pendingStatesQueue ( ) . failAllStatesAndClear ( new ElasticsearchException ( <str> , reason ) ) ; if ( rejoinOnMasterGone ) { return rejoin ( ClusterState . builder ( currentState ) . nodes ( discoveryNodes ) . build ( ) , <str> + reason + <str> ) ; } if ( ! electMaster . hasEnoughMasterNodes ( discoveryNodes ) ) { return rejoin ( ClusterState . builder ( currentState ) . nodes ( discoveryNodes ) . build ( ) , <str> + reason + <str> ) ; } final DiscoveryNode electedMaster = electMaster . electMaster ( discoveryNodes ) ; final DiscoveryNode localNode = currentState . nodes ( ) . localNode ( ) ; if ( localNode . equals ( electedMaster ) ) { masterFD . stop ( <str> + reason + <str> ) ; discoveryNodes = DiscoveryNodes . builder ( discoveryNodes ) . masterNodeId ( localNode . id ( ) ) . build ( ) ; ClusterState newState = ClusterState . builder ( currentState ) . nodes ( discoveryNodes ) . build ( ) ; nodesFD . updateNodesAndPing ( newState ) ; return newState ; } else { nodesFD . stop ( ) ; if ( electedMaster ! = null ) { discoveryNodes = DiscoveryNodes . builder ( discoveryNodes ) . masterNodeId ( electedMaster . id ( ) ) . build ( ) ; masterFD . restart ( electedMaster , <str> + reason + <str> ) ; return ClusterState . builder ( currentState ) . nodes ( discoveryNodes ) . build ( ) ; } else { return rejoin ( ClusterState . builder ( currentState ) . nodes ( discoveryNodes ) . build ( ) , <str> ) ; } } } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; } } ) ; } void processNextPendingClusterState ( String reason ) { clusterService . submitStateUpdateTask ( <str> + reason + <str> , new ClusterStateUpdateTask ( Priority . URGENT ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } ClusterState newClusterState = null ; @Override public ClusterState execute ( ClusterState currentState ) { newClusterState = publishClusterState . pendingStatesQueue ( ) . getNextClusterStateToProcess ( ) ; if ( newClusterState = = null ) { return currentState ; } assert newClusterState . nodes ( ) . masterNode ( ) ! = null : <str> ; assert ! newClusterState . blocks ( ) . hasGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) : <str> ; if ( currentState . nodes ( ) . localNodeMaster ( ) ) { return handleAnotherMaster ( currentState , newClusterState . nodes ( ) . masterNode ( ) , newClusterState . version ( ) , <str> ) ; } if ( shouldIgnoreOrRejectNewClusterState ( logger , currentState , newClusterState ) ) { return currentState ; } if ( masterFD . masterNode ( ) = = null | | ! masterFD . masterNode ( ) . equals ( newClusterState . nodes ( ) . masterNode ( ) ) ) { masterFD . restart ( newClusterState . nodes ( ) . masterNode ( ) , <str> + masterFD . masterNode ( ) + <str> ) ; } if ( currentState . blocks ( ) . hasGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) ) { logger . debug ( <str> , newClusterState . nodes ( ) . masterNodeId ( ) ) ; long count = clusterJoinsCounter . incrementAndGet ( ) ; logger . trace ( <str> , count ) ; return newClusterState ; } ClusterState . Builder builder = ClusterState . builder ( newClusterState ) ; if ( newClusterState . routingTable ( ) . version ( ) = = currentState . routingTable ( ) . version ( ) ) { builder . routingTable ( currentState . routingTable ( ) ) ; } if ( newClusterState . metaData ( ) . version ( ) = = currentState . metaData ( ) . version ( ) ) { builder . metaData ( currentState . metaData ( ) ) ; } else { MetaData . Builder metaDataBuilder = MetaData . builder ( newClusterState . metaData ( ) ) . removeAllIndices ( ) ; for ( IndexMetaData indexMetaData : newClusterState . metaData ( ) ) { IndexMetaData currentIndexMetaData = currentState . metaData ( ) . index ( indexMetaData . getIndex ( ) ) ; if ( currentIndexMetaData ! = null & & currentIndexMetaData . isSameUUID ( indexMetaData . getIndexUUID ( ) ) & & currentIndexMetaData . getVersion ( ) = = indexMetaData . getVersion ( ) ) { metaDataBuilder . put ( currentIndexMetaData , false ) ; } else { metaDataBuilder . put ( indexMetaData , false ) ; } } builder . metaData ( metaDataBuilder ) ; } return builder . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; if ( newClusterState ! = null ) { try { publishClusterState . pendingStatesQueue ( ) . markAsFailed ( newClusterState , t ) ; } catch ( Throwable unexpected ) { logger . error ( <str> , unexpected , source ) ; } } } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { try { sendInitialStateEventIfNeeded ( ) ; if ( newClusterState ! = null ) { publishClusterState . pendingStatesQueue ( ) . markAsProcessed ( newClusterState ) ; } } catch ( Throwable t ) { onFailure ( source , t ) ; } } } ) ; } static boolean shouldIgnoreOrRejectNewClusterState ( ESLogger logger , ClusterState currentState , ClusterState newClusterState ) { validateStateIsFromCurrentMaster ( logger , currentState . nodes ( ) , newClusterState ) ; if ( currentState . supersedes ( newClusterState ) ) { logger . debug ( <str> , newClusterState . version ( ) , currentState . version ( ) ) ; return true ; } else { return false ; } } public static void validateStateIsFromCurrentMaster ( ESLogger logger , DiscoveryNodes currentNodes , ClusterState newClusterState ) { if ( currentNodes . masterNodeId ( ) = = null ) { return ; } if ( ! currentNodes . masterNodeId ( ) . equals ( newClusterState . nodes ( ) . masterNodeId ( ) ) ) { logger . warn ( <str> , newClusterState . nodes ( ) . masterNode ( ) , currentNodes . masterNode ( ) ) ; throw new IllegalStateException ( <str> + newClusterState . nodes ( ) . masterNode ( ) + <str> + currentNodes . masterNode ( ) + <str> ) ; } } void handleJoinRequest ( final DiscoveryNode node , final MembershipAction . JoinCallback callback ) { if ( ! transportService . addressSupported ( node . address ( ) . getClass ( ) ) ) { logger . warn ( <str> , node ) ; } else if ( nodeJoinController = = null ) { throw new IllegalStateException ( <str> ) ; } else { Version minimumNodeJoinVersion = localNode ( ) . getVersion ( ) . minimumCompatibilityVersion ( ) ; if ( node . getVersion ( ) . before ( minimumNodeJoinVersion ) ) { callback . onFailure ( new IllegalStateException ( <str> + node . getVersion ( ) + <str> + minimumNodeJoinVersion . minimumCompatibilityVersion ( ) + <str> ) ) ; return ; } transportService . connectToNode ( node ) ; membership . sendValidateJoinRequestBlocking ( node , joinTimeout ) ; nodeJoinController . handleJoinRequest ( node , callback ) ; } } private DiscoveryNode findMaster ( ) { logger . trace ( <str> ) ; ZenPing . PingResponse [ ] fullPingResponses = pingService . pingAndWait ( pingTimeout ) ; if ( fullPingResponses = = null ) { logger . trace ( <str> ) ; return null ; } if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) ; if ( fullPingResponses . length = = <int> ) { sb . append ( <str> ) ; } else { for ( ZenPing . PingResponse pingResponse : fullPingResponses ) { sb . append ( <str> ) . append ( pingResponse ) ; } } logger . trace ( sb . toString ( ) ) ; } List < ZenPing . PingResponse > pingResponses = new ArrayList < > ( ) ; for ( ZenPing . PingResponse pingResponse : fullPingResponses ) { DiscoveryNode node = pingResponse . node ( ) ; if ( masterElectionFilterClientNodes & & ( node . clientNode ( ) | | ( ! node . masterNode ( ) & & ! node . dataNode ( ) ) ) ) { } else if ( masterElectionFilterDataNodes & & ( ! node . masterNode ( ) & & node . dataNode ( ) ) ) { } else { pingResponses . add ( pingResponse ) ; } } if ( logger . isDebugEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) . append ( masterElectionFilterClientNodes ) . append ( <str> ) . append ( masterElectionFilterDataNodes ) . append ( <str> ) ; if ( pingResponses . isEmpty ( ) ) { sb . append ( <str> ) ; } else { for ( ZenPing . PingResponse pingResponse : pingResponses ) { sb . append ( <str> ) . append ( pingResponse ) ; } } logger . debug ( sb . toString ( ) ) ; } final DiscoveryNode localNode = clusterService . localNode ( ) ; List < DiscoveryNode > pingMasters = new ArrayList < > ( ) ; for ( ZenPing . PingResponse pingResponse : pingResponses ) { if ( pingResponse . master ( ) ! = null ) { if ( ! localNode . equals ( pingResponse . master ( ) ) ) { pingMasters . add ( pingResponse . master ( ) ) ; } } } Set < DiscoveryNode > activeNodes = new HashSet < > ( ) ; Set < DiscoveryNode > joinedOnceActiveNodes = new HashSet < > ( ) ; if ( localNode . masterNode ( ) ) { activeNodes . add ( localNode ) ; long joinsCounter = clusterJoinsCounter . get ( ) ; if ( joinsCounter > <int> ) { logger . trace ( <str> , joinsCounter ) ; joinedOnceActiveNodes . add ( localNode ) ; } } for ( ZenPing . PingResponse pingResponse : pingResponses ) { activeNodes . add ( pingResponse . node ( ) ) ; if ( pingResponse . hasJoinedOnce ( ) ) { joinedOnceActiveNodes . add ( pingResponse . node ( ) ) ; } } if ( pingMasters . isEmpty ( ) ) { if ( electMaster . hasEnoughMasterNodes ( activeNodes ) ) { DiscoveryNode master = electMaster . electMaster ( joinedOnceActiveNodes ) ; if ( master ! = null ) { return master ; } return electMaster . electMaster ( activeNodes ) ; } else { logger . trace ( <str> , activeNodes ) ; return null ; } } else { assert ! pingMasters . contains ( localNode ) : <str> ; return electMaster . electMaster ( pingMasters ) ; } } protected ClusterState rejoin ( ClusterState clusterState , String reason ) { assert Thread . currentThread ( ) . getName ( ) . contains ( InternalClusterService . UPDATE_THREAD_NAME ) ; logger . warn ( reason + <str> , clusterState . nodes ( ) ) ; nodesFD . stop ( ) ; masterFD . stop ( reason ) ; ClusterBlocks clusterBlocks = ClusterBlocks . builder ( ) . blocks ( clusterState . blocks ( ) ) . addGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) . build ( ) ; DiscoveryNodes discoveryNodes = new DiscoveryNodes . Builder ( clusterState . nodes ( ) ) . masterNodeId ( null ) . build ( ) ; joinThreadControl . startNewThreadIfNotRunning ( ) ; return ClusterState . builder ( clusterState ) . blocks ( clusterBlocks ) . nodes ( discoveryNodes ) . build ( ) ; } private boolean localNodeMaster ( ) { return nodes ( ) . localNodeMaster ( ) ; } private ClusterState handleAnotherMaster ( ClusterState localClusterState , final DiscoveryNode otherMaster , long otherClusterStateVersion , String reason ) { assert localClusterState . nodes ( ) . localNodeMaster ( ) : <str> ; assert Thread . currentThread ( ) . getName ( ) . contains ( InternalClusterService . UPDATE_THREAD_NAME ) : <str> ; if ( otherClusterStateVersion > localClusterState . version ( ) ) { return rejoin ( localClusterState , <str> + otherMaster + <str> + reason + <str> ) ; } else { logger . warn ( <str> , otherMaster , otherMaster , reason ) ; try { transportService . connectToNode ( otherMaster ) ; transportService . sendRequest ( otherMaster , DISCOVERY_REJOIN_ACTION_NAME , new RejoinClusterRequest ( localClusterState . nodes ( ) . localNodeId ( ) ) , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleException ( TransportException exp ) { logger . warn ( <str> , exp , otherMaster ) ; } } ) ; } catch ( Exception e ) { logger . warn ( <str> , e , otherMaster ) ; } return localClusterState ; } } private void sendInitialStateEventIfNeeded ( ) { if ( initialStateSent . compareAndSet ( false , true ) ) { for ( InitialStateDiscoveryListener listener : initialStateListeners ) { listener . initialStateProcessed ( ) ; } } } private class NewPendingClusterStateListener implements PublishClusterStateAction . NewPendingClusterStateListener { @Override public void onNewClusterState ( String reason ) { processNextPendingClusterState ( reason ) ; } } private class MembershipListener implements MembershipAction . MembershipListener { @Override public void onJoin ( DiscoveryNode node , MembershipAction . JoinCallback callback ) { handleJoinRequest ( node , callback ) ; } @Override public void onLeave ( DiscoveryNode node ) { handleLeaveRequest ( node ) ; } } private class NodeFaultDetectionListener extends NodesFaultDetection . Listener { private final AtomicInteger pingsWhileMaster = new AtomicInteger ( <int> ) ; @Override public void onNodeFailure ( DiscoveryNode node , String reason ) { handleNodeFailure ( node , reason ) ; } @Override public void onPingReceived ( final NodesFaultDetection . PingRequest pingRequest ) { if ( ! localNodeMaster ( ) ) { pingsWhileMaster . set ( <int> ) ; return ; } if ( pingsWhileMaster . incrementAndGet ( ) < maxPingsFromAnotherMaster ) { logger . trace ( <str> , pingRequest . masterNode ( ) , pingsWhileMaster . get ( ) ) ; return ; } logger . debug ( <str> , pingRequest . masterNode ( ) , pingsWhileMaster . get ( ) ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { pingsWhileMaster . set ( <int> ) ; return handleAnotherMaster ( currentState , pingRequest . masterNode ( ) , pingRequest . clusterStateVersion ( ) , <str> ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . debug ( <str> , t ) ; } } ) ; } } private class MasterNodeFailureListener implements MasterFaultDetection . Listener { @Override public void onMasterFailure ( DiscoveryNode masterNode , Throwable cause , String reason ) { handleMasterGone ( masterNode , cause , reason ) ; } } boolean isRejoinOnMasterGone ( ) { return rejoinOnMasterGone ; } public static class RejoinClusterRequest extends TransportRequest { private String fromNodeId ; RejoinClusterRequest ( String fromNodeId ) { this . fromNodeId = fromNodeId ; } public RejoinClusterRequest ( ) { } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; fromNodeId = in . readOptionalString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeOptionalString ( fromNodeId ) ; } } class RejoinClusterRequestHandler implements TransportRequestHandler < RejoinClusterRequest > { @Override public void messageReceived ( final RejoinClusterRequest request , final TransportChannel channel ) throws Exception { clusterService . submitStateUpdateTask ( <str> + request . fromNodeId + <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { try { channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } return rejoin ( currentState , <str> + request . fromNodeId + <str> ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } } ) ; } } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { int minimumMasterNodes = settings . getAsInt ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , ZenDiscovery . this . electMaster . minimumMasterNodes ( ) ) ; if ( minimumMasterNodes ! = ZenDiscovery . this . electMaster . minimumMasterNodes ( ) ) { logger . info ( <str> , ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , ZenDiscovery . this . electMaster . minimumMasterNodes ( ) , minimumMasterNodes ) ; handleMinimumMasterNodesChanged ( minimumMasterNodes ) ; } boolean rejoinOnMasterGone = settings . getAsBoolean ( SETTING_REJOIN_ON_MASTER_GONE , ZenDiscovery . this . rejoinOnMasterGone ) ; if ( rejoinOnMasterGone ! = ZenDiscovery . this . rejoinOnMasterGone ) { logger . info ( <str> , SETTING_REJOIN_ON_MASTER_GONE , ZenDiscovery . this . rejoinOnMasterGone , rejoinOnMasterGone ) ; ZenDiscovery . this . rejoinOnMasterGone = rejoinOnMasterGone ; } } } private class JoinThreadControl { private final ThreadPool threadPool ; private final AtomicBoolean running = new AtomicBoolean ( false ) ; private final AtomicReference < Thread > currentJoinThread = new AtomicReference < > ( ) ; public JoinThreadControl ( ThreadPool threadPool ) { this . threadPool = threadPool ; } public boolean joinThreadActive ( ) { Thread currentThread = currentJoinThread . get ( ) ; return running . get ( ) & & currentThread ! = null & & currentThread . isAlive ( ) ; } public boolean joinThreadActive ( Thread joinThread ) { return running . get ( ) & & joinThread . equals ( currentJoinThread . get ( ) ) ; } public ClusterState stopRunningThreadAndRejoin ( ClusterState clusterState , String reason ) { assertClusterStateThread ( ) ; currentJoinThread . set ( null ) ; return rejoin ( clusterState , reason ) ; } public void startNewThreadIfNotRunning ( ) { assertClusterStateThread ( ) ; if ( joinThreadActive ( ) ) { return ; } threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { Thread currentThread = Thread . currentThread ( ) ; if ( ! currentJoinThread . compareAndSet ( null , currentThread ) ) { return ; } while ( running . get ( ) & & joinThreadActive ( currentThread ) ) { try { innerJoinCluster ( ) ; return ; } catch ( Exception e ) { logger . error ( <str> , e ) ; assert ExceptionsHelper . reThrowIfNotNull ( e ) ; } } } } ) ; } public void markThreadAsDoneAndStartNew ( Thread joinThread ) { assertClusterStateThread ( ) ; if ( ! markThreadAsDone ( joinThread ) ) { return ; } startNewThreadIfNotRunning ( ) ; } public boolean markThreadAsDone ( Thread joinThread ) { assertClusterStateThread ( ) ; return currentJoinThread . compareAndSet ( joinThread , null ) ; } public void stop ( ) { running . set ( false ) ; Thread joinThread = currentJoinThread . getAndSet ( null ) ; if ( joinThread ! = null ) { joinThread . interrupt ( ) ; } } public void start ( ) { running . set ( true ) ; } private void assertClusterStateThread ( ) { assert clusterService instanceof InternalClusterService = = false | | ( ( InternalClusterService ) clusterService ) . assertClusterStateThread ( ) ; } } } 
