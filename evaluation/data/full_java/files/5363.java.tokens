package org . elasticsearch . action . search ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . script . Template ; import org . elasticsearch . search . Scroll ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import java . io . IOException ; import static org . elasticsearch . search . Scroll . readScroll ; public class SearchRequest extends ActionRequest < SearchRequest > implements IndicesRequest . Replaceable { private SearchType searchType = SearchType . DEFAULT ; private String [ ] indices ; @Nullable private String routing ; @Nullable private String preference ; private SearchSourceBuilder source ; private Boolean requestCache ; private Scroll scroll ; private String [ ] types = Strings . EMPTY_ARRAY ; public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions . strictExpandOpenAndForbidClosed ( ) ; private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS ; private Template template ; public SearchRequest ( ) { } public SearchRequest ( SearchRequest searchRequest , ActionRequest originalRequest ) { super ( originalRequest ) ; this . searchType = searchRequest . searchType ; this . indices = searchRequest . indices ; this . routing = searchRequest . routing ; this . preference = searchRequest . preference ; this . template = searchRequest . template ; this . source = searchRequest . source ; this . requestCache = searchRequest . requestCache ; this . scroll = searchRequest . scroll ; this . types = searchRequest . types ; this . indicesOptions = searchRequest . indicesOptions ; } public SearchRequest ( ActionRequest request ) { super ( request ) ; this . source = new SearchSourceBuilder ( ) ; } public SearchRequest ( String . . . indices ) { this ( indices , new SearchSourceBuilder ( ) ) ; } public SearchRequest ( String [ ] indices , SearchSourceBuilder source ) { if ( source = = null ) { throw new IllegalArgumentException ( <str> ) ; } indices ( indices ) ; this . source = source ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; return validationException ; } @Override public SearchRequest indices ( String . . . indices ) { if ( indices = = null ) { throw new IllegalArgumentException ( <str> ) ; } else { for ( int i = <int> ; i < indices . length ; i + + ) { if ( indices [ i ] = = null ) { throw new IllegalArgumentException ( <str> + i + <str> ) ; } } } this . indices = indices ; return this ; } @Override public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public SearchRequest indicesOptions ( IndicesOptions indicesOptions ) { this . indicesOptions = indicesOptions ; return this ; } public String [ ] types ( ) { return types ; } public SearchRequest types ( String . . . types ) { this . types = types ; return this ; } public String routing ( ) { return this . routing ; } public SearchRequest routing ( String routing ) { this . routing = routing ; return this ; } public SearchRequest routing ( String . . . routings ) { this . routing = Strings . arrayToCommaDelimitedString ( routings ) ; return this ; } public SearchRequest preference ( String preference ) { this . preference = preference ; return this ; } public String preference ( ) { return this . preference ; } public SearchRequest searchType ( SearchType searchType ) { this . searchType = searchType ; return this ; } public SearchRequest searchType ( String searchType ) { return searchType ( SearchType . fromString ( searchType , ParseFieldMatcher . EMPTY ) ) ; } public SearchRequest source ( SearchSourceBuilder sourceBuilder ) { if ( sourceBuilder = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . source = sourceBuilder ; return this ; } public SearchSourceBuilder source ( ) { return source ; } public void template ( Template template ) { this . template = template ; } public Template template ( ) { return template ; } public SearchType searchType ( ) { return searchType ; } @Override public String [ ] indices ( ) { return indices ; } public Scroll scroll ( ) { return scroll ; } public SearchRequest scroll ( Scroll scroll ) { this . scroll = scroll ; return this ; } public SearchRequest scroll ( TimeValue keepAlive ) { return scroll ( new Scroll ( keepAlive ) ) ; } public SearchRequest scroll ( String keepAlive ) { return scroll ( new Scroll ( TimeValue . parseTimeValue ( keepAlive , null , getClass ( ) . getSimpleName ( ) + <str> ) ) ) ; } public SearchRequest requestCache ( Boolean requestCache ) { this . requestCache = requestCache ; return this ; } public Boolean requestCache ( ) { return this . requestCache ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; searchType = SearchType . fromId ( in . readByte ( ) ) ; indices = new String [ in . readVInt ( ) ] ; for ( int i = <int> ; i < indices . length ; i + + ) { indices [ i ] = in . readString ( ) ; } routing = in . readOptionalString ( ) ; preference = in . readOptionalString ( ) ; if ( in . readBoolean ( ) ) { scroll = readScroll ( in ) ; } if ( in . readBoolean ( ) ) { source = SearchSourceBuilder . readSearchSourceFrom ( in ) ; } types = in . readStringArray ( ) ; indicesOptions = IndicesOptions . readIndicesOptions ( in ) ; requestCache = in . readOptionalBoolean ( ) ; template = in . readOptionalStreamable ( Template : : new ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeByte ( searchType . id ( ) ) ; out . writeVInt ( indices . length ) ; for ( String index : indices ) { out . writeString ( index ) ; } out . writeOptionalString ( routing ) ; out . writeOptionalString ( preference ) ; if ( scroll = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; scroll . writeTo ( out ) ; } if ( source = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; source . writeTo ( out ) ; } out . writeStringArray ( types ) ; indicesOptions . writeIndicesOptions ( out ) ; out . writeOptionalBoolean ( requestCache ) ; out . writeOptionalStreamable ( template ) ; } } 
