package org . elasticsearch . common . joda ; import org . elasticsearch . common . Strings ; import org . joda . time . * ; import org . joda . time . field . DividedDateTimeField ; import org . joda . time . field . OffsetDateTimeField ; import org . joda . time . field . ScaledDurationField ; import org . joda . time . format . * ; import java . io . IOException ; import java . io . Writer ; import java . util . Locale ; import java . util . regex . Pattern ; public class Joda { public static FormatDateTimeFormatter forPattern ( String input ) { return forPattern ( input , Locale . ROOT ) ; } public static FormatDateTimeFormatter forPattern ( String input , Locale locale ) { if ( Strings . hasLength ( input ) ) { input = input . trim ( ) ; } if ( input = = null | | input . length ( ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } DateTimeFormatter formatter ; if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicOrdinalDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicOrdinalDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicOrdinalDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicTTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicTTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicWeekDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicWeekDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . basicWeekDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) ) { formatter = ISODateTimeFormat . date ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateHour ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateHourMinute ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateHourMinuteSecond ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateHourMinuteSecondFraction ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateHourMinuteSecondMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { return new FormatDateTimeFormatter ( input , ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) , ISODateTimeFormat . dateTime ( ) . withZone ( DateTimeZone . UTC ) , locale ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . dateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) ) { formatter = ISODateTimeFormat . hour ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . hourMinute ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . hourMinuteSecond ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . hourMinuteSecondFraction ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . hourMinuteSecondMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . ordinalDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . ordinalDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . ordinalDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) ) { formatter = ISODateTimeFormat . time ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . timeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . tTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . tTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekyear ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekyearWeek ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . weekyearWeekDay ( ) ; } else if ( <str> . equals ( input ) ) { formatter = ISODateTimeFormat . year ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . yearMonth ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = ISODateTimeFormat . yearMonthDay ( ) ; } else if ( <str> . equals ( input ) ) { formatter = new DateTimeFormatterBuilder ( ) . append ( new EpochTimePrinter ( false ) , new EpochTimeParser ( false ) ) . toFormatter ( ) ; } else if ( <str> . equals ( input ) ) { formatter = new DateTimeFormatterBuilder ( ) . append ( new EpochTimePrinter ( true ) , new EpochTimeParser ( true ) ) . toFormatter ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . basicWeekDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . basicWeekDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . basicWeekDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . date ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateHour ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateHourMinute ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateHourMinuteSecond ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateHourMinuteSecondFraction ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateHourMinuteSecondMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { return new FormatDateTimeFormatter ( input , StrictISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( DateTimeZone . UTC ) , StrictISODateTimeFormat . dateTime ( ) . withZone ( DateTimeZone . UTC ) , locale ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . dateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . hour ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . hourMinute ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . hourMinuteSecond ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . hourMinuteSecondFraction ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . hourMinuteSecondMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . ordinalDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . ordinalDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . ordinalDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . time ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . timeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . tTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . tTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekDate ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekDateTime ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekDateTimeNoMillis ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekyear ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekyearWeek ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . weekyearWeekDay ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . year ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . yearMonth ( ) ; } else if ( <str> . equals ( input ) | | <str> . equals ( input ) ) { formatter = StrictISODateTimeFormat . yearMonthDay ( ) ; } else if ( Strings . hasLength ( input ) & & input . contains ( <str> ) ) { String [ ] formats = Strings . delimitedListToStringArray ( input , <str> ) ; DateTimeParser [ ] parsers = new DateTimeParser [ formats . length ] ; if ( formats . length = = <int> ) { formatter = forPattern ( input , locale ) . parser ( ) ; } else { DateTimeFormatter dateTimeFormatter = null ; for ( int i = <int> ; i < formats . length ; i + + ) { FormatDateTimeFormatter currentFormatter = forPattern ( formats [ i ] , locale ) ; DateTimeFormatter currentParser = currentFormatter . parser ( ) ; if ( dateTimeFormatter = = null ) { dateTimeFormatter = currentFormatter . printer ( ) ; } parsers [ i ] = currentParser . getParser ( ) ; } DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( ) . append ( dateTimeFormatter . withZone ( DateTimeZone . UTC ) . getPrinter ( ) , parsers ) ; formatter = builder . toFormatter ( ) ; } } else { try { formatter = DateTimeFormat . forPattern ( input ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + input + <str> + e . getMessage ( ) , e ) ; } } return new FormatDateTimeFormatter ( input , formatter . withZone ( DateTimeZone . UTC ) , locale ) ; } public static FormatDateTimeFormatter getStrictStandardDateFormatter ( ) { DateTimeFormatter shortFormatter = new DateTimeFormatterBuilder ( ) . appendFixedDecimal ( DateTimeFieldType . year ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedDecimal ( DateTimeFieldType . monthOfYear ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedDecimal ( DateTimeFieldType . dayOfMonth ( ) , <int> ) . toFormatter ( ) . withZoneUTC ( ) ; DateTimeFormatter longFormatter = new DateTimeFormatterBuilder ( ) . appendFixedDecimal ( DateTimeFieldType . year ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedDecimal ( DateTimeFieldType . monthOfYear ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedDecimal ( DateTimeFieldType . dayOfMonth ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedSignedDecimal ( DateTimeFieldType . hourOfDay ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedSignedDecimal ( DateTimeFieldType . minuteOfHour ( ) , <int> ) . appendLiteral ( <str> ) . appendFixedSignedDecimal ( DateTimeFieldType . secondOfMinute ( ) , <int> ) . toFormatter ( ) . withZoneUTC ( ) ; DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( ) . append ( longFormatter . withZone ( DateTimeZone . UTC ) . getPrinter ( ) , new DateTimeParser [ ] { longFormatter . getParser ( ) , shortFormatter . getParser ( ) , new EpochTimeParser ( true ) } ) ; return new FormatDateTimeFormatter ( <str> , builder . toFormatter ( ) . withZone ( DateTimeZone . UTC ) , Locale . ROOT ) ; } public static final DurationFieldType Quarters = new DurationFieldType ( <str> ) { private static final long serialVersionUID = - <int> ; @Override public DurationField getField ( Chronology chronology ) { return new ScaledDurationField ( chronology . months ( ) , Quarters , <int> ) ; } } ; public static final DateTimeFieldType QuarterOfYear = new DateTimeFieldType ( <str> ) { private static final long serialVersionUID = - <int> ; @Override public DurationFieldType getDurationType ( ) { return Quarters ; } @Override public DurationFieldType getRangeDurationType ( ) { return DurationFieldType . years ( ) ; } @Override public DateTimeField getField ( Chronology chronology ) { return new OffsetDateTimeField ( new DividedDateTimeField ( new OffsetDateTimeField ( chronology . monthOfYear ( ) , - <int> ) , QuarterOfYear , <int> ) , <int> ) ; } } ; public static class EpochTimeParser implements DateTimeParser { private static final Pattern MILLI_SECOND_PRECISION_PATTERN = Pattern . compile ( <str> ) ; private static final Pattern SECOND_PRECISION_PATTERN = Pattern . compile ( <str> ) ; private final boolean hasMilliSecondPrecision ; private final Pattern pattern ; public EpochTimeParser ( boolean hasMilliSecondPrecision ) { this . hasMilliSecondPrecision = hasMilliSecondPrecision ; this . pattern = hasMilliSecondPrecision ? MILLI_SECOND_PRECISION_PATTERN : SECOND_PRECISION_PATTERN ; } @Override public int estimateParsedLength ( ) { return hasMilliSecondPrecision ? <int> : <int> ; } @Override public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { boolean isPositive = text . startsWith ( <str> ) = = false ; boolean isTooLong = text . length ( ) > estimateParsedLength ( ) ; if ( ( isPositive & & isTooLong ) | | bucket . getZone ( ) ! = DateTimeZone . UTC | | pattern . matcher ( text ) . matches ( ) = = false ) { return - <int> ; } int factor = hasMilliSecondPrecision ? <int> : <int> ; try { long millis = Long . valueOf ( text ) * factor ; DateTime dt = new DateTime ( millis , DateTimeZone . UTC ) ; bucket . saveField ( DateTimeFieldType . year ( ) , dt . getYear ( ) ) ; bucket . saveField ( DateTimeFieldType . monthOfYear ( ) , dt . getMonthOfYear ( ) ) ; bucket . saveField ( DateTimeFieldType . dayOfMonth ( ) , dt . getDayOfMonth ( ) ) ; bucket . saveField ( DateTimeFieldType . hourOfDay ( ) , dt . getHourOfDay ( ) ) ; bucket . saveField ( DateTimeFieldType . minuteOfHour ( ) , dt . getMinuteOfHour ( ) ) ; bucket . saveField ( DateTimeFieldType . secondOfMinute ( ) , dt . getSecondOfMinute ( ) ) ; bucket . saveField ( DateTimeFieldType . millisOfSecond ( ) , dt . getMillisOfSecond ( ) ) ; bucket . setZone ( DateTimeZone . UTC ) ; } catch ( Exception e ) { return - <int> ; } return text . length ( ) ; } } public static class EpochTimePrinter implements DateTimePrinter { private boolean hasMilliSecondPrecision ; public EpochTimePrinter ( boolean hasMilliSecondPrecision ) { this . hasMilliSecondPrecision = hasMilliSecondPrecision ; } @Override public int estimatePrintedLength ( ) { return hasMilliSecondPrecision ? <int> : <int> ; } @Override public void printTo ( StringBuffer buf , long instant , Chronology chrono , int displayOffset , DateTimeZone displayZone , Locale locale ) { if ( hasMilliSecondPrecision ) { buf . append ( instant ) ; } else { buf . append ( instant / <int> ) ; } } @Override public void printTo ( Writer out , long instant , Chronology chrono , int displayOffset , DateTimeZone displayZone , Locale locale ) throws IOException { if ( hasMilliSecondPrecision ) { out . write ( String . valueOf ( instant ) ) ; } else { out . append ( String . valueOf ( instant / <int> ) ) ; } } @Override public void printTo ( StringBuffer buf , ReadablePartial partial , Locale locale ) { if ( hasMilliSecondPrecision ) { buf . append ( String . valueOf ( getDateTimeMillis ( partial ) ) ) ; } else { buf . append ( String . valueOf ( getDateTimeMillis ( partial ) / <int> ) ) ; } } @Override public void printTo ( Writer out , ReadablePartial partial , Locale locale ) throws IOException { if ( hasMilliSecondPrecision ) { out . append ( String . valueOf ( getDateTimeMillis ( partial ) ) ) ; } else { out . append ( String . valueOf ( getDateTimeMillis ( partial ) / <int> ) ) ; } } private long getDateTimeMillis ( ReadablePartial partial ) { int year = partial . get ( DateTimeFieldType . year ( ) ) ; int monthOfYear = partial . get ( DateTimeFieldType . monthOfYear ( ) ) ; int dayOfMonth = partial . get ( DateTimeFieldType . dayOfMonth ( ) ) ; int hourOfDay = partial . get ( DateTimeFieldType . hourOfDay ( ) ) ; int minuteOfHour = partial . get ( DateTimeFieldType . minuteOfHour ( ) ) ; int secondOfMinute = partial . get ( DateTimeFieldType . secondOfMinute ( ) ) ; int millisOfSecond = partial . get ( DateTimeFieldType . millisOfSecond ( ) ) ; return partial . getChronology ( ) . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } } } 
