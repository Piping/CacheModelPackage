package io . netty . handler . codec . http ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . util . Arrays ; import java . util . List ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . hamcrest . CoreMatchers . sameInstance ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; public class HttpResponseDecoderTest { @Test public void testMaxHeaderSize1 ( ) { final int maxHeaderSize = <int> ; final EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( <int> , maxHeaderSize , <int> ) ) ; final char [ ] bytes = new char [ maxHeaderSize / <int> - <int> ] ; Arrays . fill ( bytes , <str> ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( bytes , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( bytes , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertNull ( res . decoderResult ( ) . cause ( ) ) ; assertTrue ( res . decoderResult ( ) . isSuccess ( ) ) ; assertNull ( ch . readInbound ( ) ) ; assertTrue ( ch . finish ( ) ) ; assertThat ( ch . readInbound ( ) , instanceOf ( LastHttpContent . class ) ) ; } @Test public void testMaxHeaderSize2 ( ) { final int maxHeaderSize = <int> ; final EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( <int> , maxHeaderSize , <int> ) ) ; final char [ ] bytes = new char [ maxHeaderSize / <int> - <int> ] ; Arrays . fill ( bytes , <str> ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( bytes , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( bytes , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertTrue ( res . decoderResult ( ) . cause ( ) instanceof TooLongFrameException ) ; assertFalse ( ch . finish ( ) ) ; assertNull ( ch . readInbound ( ) ) ; } @Test public void testResponseChunked ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; byte [ ] data = new byte [ <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } for ( int i = <int> ; i < <int> ; i + + ) { assertFalse ( ch . writeInbound ( Unpooled . copiedBuffer ( Integer . toHexString ( data . length ) + <str> , CharsetUtil . US_ASCII ) ) ) ; assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( data ) ) ) ; HttpContent content = ch . readInbound ( ) ; assertEquals ( data . length , content . content ( ) . readableBytes ( ) ) ; byte [ ] decodedData = new byte [ data . length ] ; content . content ( ) . readBytes ( decodedData ) ; assertArrayEquals ( data , decodedData ) ; content . release ( ) ; assertFalse ( ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; } ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; LastHttpContent content = ch . readInbound ( ) ; assertFalse ( content . content ( ) . isReadable ( ) ) ; content . release ( ) ; ch . finish ( ) ; assertNull ( ch . readInbound ( ) ) ; } @Test public void testResponseChunkedExceedMaxChunkSize ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( <int> , <int> , <int> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; byte [ ] data = new byte [ <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } for ( int i = <int> ; i < <int> ; i + + ) { assertFalse ( ch . writeInbound ( Unpooled . copiedBuffer ( Integer . toHexString ( data . length ) + <str> , CharsetUtil . US_ASCII ) ) ) ; assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( data ) ) ) ; byte [ ] decodedData = new byte [ data . length ] ; HttpContent content = ch . readInbound ( ) ; assertEquals ( <int> , content . content ( ) . readableBytes ( ) ) ; content . content ( ) . readBytes ( decodedData , <int> , <int> ) ; content . release ( ) ; content = ch . readInbound ( ) ; assertEquals ( <int> , content . content ( ) . readableBytes ( ) ) ; content . content ( ) . readBytes ( decodedData , <int> , <int> ) ; assertArrayEquals ( data , decodedData ) ; content . release ( ) ; assertFalse ( ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ) ; } ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; LastHttpContent content = ch . readInbound ( ) ; assertFalse ( content . content ( ) . isReadable ( ) ) ; content . release ( ) ; ch . finish ( ) ; assertNull ( ch . readInbound ( ) ) ; } @Test public void testClosureWithoutContentLength1 ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; assertTrue ( ch . finish ( ) ) ; LastHttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . isReadable ( ) , is ( false ) ) ; content . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testClosureWithoutContentLength2 ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertThat ( content , is ( not ( instanceOf ( LastHttpContent . class ) ) ) ) ; content . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; assertTrue ( ch . finish ( ) ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertThat ( lastContent . content ( ) . isReadable ( ) , is ( false ) ) ; lastContent . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testPrematureClosureWithChunkedEncoding1 ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( <str> ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . finish ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testPrematureClosureWithChunkedEncoding2 ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( res . headers ( ) . get ( HttpHeaderNames . TRANSFER_ENCODING ) , is ( <str> ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . US_ASCII ) , is ( <str> ) ) ; assertThat ( content , is ( not ( instanceOf ( LastHttpContent . class ) ) ) ) ; content . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . finish ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testLastResponseWithEmptyHeaderAndEmptyContent ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; assertThat ( ch . finish ( ) , is ( true ) ) ; LastHttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . isReadable ( ) , is ( false ) ) ; content . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testLastResponseWithoutContentLengthHeader ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content . release ( ) ; assertThat ( ch . finish ( ) , is ( true ) ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertThat ( lastContent . content ( ) . isReadable ( ) , is ( false ) ) ; lastContent . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testLastResponseWithHeaderRemoveTrailingSpaces ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; assertThat ( res . headers ( ) . get ( of ( <str> ) ) , is ( <str> ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ <int> ] ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content . release ( ) ; assertThat ( ch . finish ( ) , is ( true ) ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertThat ( lastContent . content ( ) . isReadable ( ) , is ( false ) ) ; lastContent . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testLastResponseWithTrailingHeader ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + <str> + <str> + <str> + <str> + <str> , CharsetUtil . US_ASCII ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertThat ( lastContent . content ( ) . isReadable ( ) , is ( false ) ) ; HttpHeaders headers = lastContent . trailingHeaders ( ) ; assertEquals ( <int> , headers . names ( ) . size ( ) ) ; List < String > values = headers . getAll ( of ( <str> ) ) ; assertEquals ( <int> , values . size ( ) ) ; assertTrue ( values . contains ( <str> ) ) ; assertTrue ( values . contains ( <str> ) ) ; lastContent . release ( ) ; assertThat ( ch . finish ( ) , is ( false ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testLastResponseWithTrailingHeaderFragmented ( ) { byte [ ] data = ( <str> + <str> + <str> + <str> + <str> + <str> + <str> ) . getBytes ( CharsetUtil . US_ASCII ) ; for ( int i = <int> ; i < data . length ; i + + ) { testLastResponseWithTrailingHeaderFragmented ( data , i ) ; } } private static void testLastResponseWithTrailingHeaderFragmented ( byte [ ] content , int fragmentSize ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; int headerLength = <int> ; for ( int a = <int> ; a < headerLength ; ) { int amount = fragmentSize ; if ( a + amount > headerLength ) { amount = headerLength - a ; } boolean headerDone = a + amount = = headerLength ; assertEquals ( headerDone , ch . writeInbound ( Unpooled . wrappedBuffer ( content , a , amount ) ) ) ; a + = amount ; } ch . writeInbound ( Unpooled . wrappedBuffer ( content , headerLength , content . length - headerLength ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertThat ( lastContent . content ( ) . isReadable ( ) , is ( false ) ) ; HttpHeaders headers = lastContent . trailingHeaders ( ) ; assertEquals ( <int> , headers . names ( ) . size ( ) ) ; List < String > values = headers . getAll ( of ( <str> ) ) ; assertEquals ( <int> , values . size ( ) ) ; assertTrue ( values . contains ( <str> ) ) ; assertTrue ( values . contains ( <str> ) ) ; lastContent . release ( ) ; assertThat ( ch . finish ( ) , is ( false ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testResponseWithContentLength ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + <str> , CharsetUtil . US_ASCII ) ) ; byte [ ] data = new byte [ <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } ch . writeInbound ( Unpooled . wrappedBuffer ( data , <int> , data . length / <int> ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data , <int> , data . length / <int> ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; HttpContent firstContent = ch . readInbound ( ) ; assertThat ( firstContent . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertEquals ( Unpooled . wrappedBuffer ( data , <int> , <int> ) , firstContent . content ( ) ) ; firstContent . release ( ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertEquals ( <int> , lastContent . content ( ) . readableBytes ( ) ) ; assertEquals ( Unpooled . wrappedBuffer ( data , <int> , <int> ) , lastContent . content ( ) ) ; lastContent . release ( ) ; assertThat ( ch . finish ( ) , is ( false ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testResponseWithContentLengthFragmented ( ) { byte [ ] data = ( <str> + <str> + <str> ) . getBytes ( CharsetUtil . US_ASCII ) ; for ( int i = <int> ; i < data . length ; i + + ) { testResponseWithContentLengthFragmented ( data , i ) ; } } private static void testResponseWithContentLengthFragmented ( byte [ ] header , int fragmentSize ) { EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; for ( int a = <int> ; a < header . length ; ) { int amount = fragmentSize ; if ( a + amount > header . length ) { amount = header . length - a ; } ch . writeInbound ( Unpooled . wrappedBuffer ( header , a , amount ) ) ; a + = amount ; } byte [ ] data = new byte [ <int> ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) i ; } ch . writeInbound ( Unpooled . wrappedBuffer ( data , <int> , data . length / <int> ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data , <int> , data . length / <int> ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . OK ) ) ; HttpContent firstContent = ch . readInbound ( ) ; assertThat ( firstContent . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertEquals ( Unpooled . wrappedBuffer ( data , <int> , <int> ) , firstContent . content ( ) ) ; firstContent . release ( ) ; LastHttpContent lastContent = ch . readInbound ( ) ; assertEquals ( <int> , lastContent . content ( ) . readableBytes ( ) ) ; assertEquals ( Unpooled . wrappedBuffer ( data , <int> , <int> ) , lastContent . content ( ) ) ; lastContent . release ( ) ; assertThat ( ch . finish ( ) , is ( false ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testWebSocketResponse ( ) { byte [ ] data = ( <str> + <str> + <str> + <str> + <str> + <str> + <str> ) . getBytes ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . SWITCHING_PROTOCOLS ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content . release ( ) ; assertThat ( ch . finish ( ) , is ( false ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testWebSocketResponseWithDataFollowing ( ) { byte [ ] data = ( <str> + <str> + <str> + <str> + <str> + <str> + <str> ) . getBytes ( ) ; byte [ ] otherData = { <int> , <int> , <int> , <int> } ; EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data , otherData ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_1 ) ) ; assertThat ( res . status ( ) , is ( HttpResponseStatus . SWITCHING_PROTOCOLS ) ) ; HttpContent content = ch . readInbound ( ) ; assertThat ( content . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content . release ( ) ; assertThat ( ch . finish ( ) , is ( true ) ) ; assertEquals ( ch . readInbound ( ) , Unpooled . wrappedBuffer ( otherData ) ) ; } @Test public void testGarbageHeaders ( ) { byte [ ] data = ( <str> + <str> + <str> + <str> + <str> + <str> + <str> ) . getBytes ( ) ; EmbeddedChannel ch = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data ) ) ; HttpResponse res = ch . readInbound ( ) ; assertThat ( res . protocolVersion ( ) , sameInstance ( HttpVersion . HTTP_1_0 ) ) ; assertThat ( res . status ( ) . code ( ) , is ( <int> ) ) ; assertThat ( res . decoderResult ( ) . isFailure ( ) , is ( true ) ) ; assertThat ( res . decoderResult ( ) . isFinished ( ) , is ( true ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( data ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ch . finish ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; } @Test public void testGarbageChunk ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new HttpResponseDecoder ( ) ) ; String responseWithIllegalChunk = <str> + <str> + <str> ; channel . writeInbound ( Unpooled . copiedBuffer ( responseWithIllegalChunk , CharsetUtil . US_ASCII ) ) ; assertThat ( channel . readInbound ( ) , is ( instanceOf ( HttpResponse . class ) ) ) ; LastHttpContent invalidChunk = channel . readInbound ( ) ; assertThat ( invalidChunk . decoderResult ( ) . isFailure ( ) , is ( true ) ) ; invalidChunk . release ( ) ; assertThat ( channel . readInbound ( ) , is ( nullValue ( ) ) ) ; assertThat ( channel . finish ( ) , is ( false ) ) ; } } 
