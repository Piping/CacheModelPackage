package org . elasticsearch . discovery . zen ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . NotMasterException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingService ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . FailedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . BaseFuture ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . membership . MembershipAction ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . junit . Before ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; @TestLogging ( <str> ) public class NodeJoinControllerTests extends ESTestCase { private TestClusterService clusterService ; private NodeJoinController nodeJoinController ; @Before public void setUp ( ) throws Exception { super . setUp ( ) ; clusterService = new TestClusterService ( ) ; final DiscoveryNodes initialNodes = clusterService . state ( ) . nodes ( ) ; final DiscoveryNode localNode = initialNodes . localNode ( ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( DiscoveryNodes . builder ( initialNodes ) . masterNodeId ( localNode . id ( ) ) ) ) ; nodeJoinController = new NodeJoinController ( clusterService , new NoopRoutingService ( Settings . EMPTY ) , new DiscoverySettings ( Settings . EMPTY , new NodeSettingsService ( Settings . EMPTY ) ) , Settings . EMPTY ) ; } public void testSimpleJoinAccumulation ( ) throws InterruptedException , ExecutionException { List < DiscoveryNode > nodes = new ArrayList < > ( ) ; nodes . add ( clusterService . localNode ( ) ) ; int nodeId = <int> ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { DiscoveryNode node = newNode ( nodeId + + ) ; nodes . add ( node ) ; joinNode ( node ) ; } nodeJoinController . startAccumulatingJoins ( ) ; ArrayList < Future < Void > > pendingJoins = new ArrayList < > ( ) ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { DiscoveryNode node = newNode ( nodeId + + ) ; nodes . add ( node ) ; pendingJoins . add ( joinNodeAsync ( node ) ) ; } nodeJoinController . stopAccumulatingJoins ( <str> ) ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { DiscoveryNode node = newNode ( nodeId + + ) ; nodes . add ( node ) ; joinNode ( node ) ; } assertNodesInCurrentState ( nodes ) ; for ( Future < Void > joinFuture : pendingJoins ) { assertThat ( joinFuture . isDone ( ) , equalTo ( true ) ) ; } } public void testFailingJoinsWhenNotMaster ( ) throws ExecutionException , InterruptedException { DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterService . state ( ) . nodes ( ) ) . masterNodeId ( null ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( nodes ) ) ; int nodeId = <int> ; try { joinNode ( newNode ( nodeId + + ) ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } logger . debug ( <str> ) ; ArrayList < Future < Void > > pendingJoins = new ArrayList < > ( ) ; nodeJoinController . startAccumulatingJoins ( ) ; for ( int i = <int> + randomInt ( <int> ) ; i > <int> ; i - - ) { DiscoveryNode node = newNode ( nodeId + + ) ; final Future < Void > future = joinNodeAsync ( node ) ; pendingJoins . add ( future ) ; assertThat ( future . isDone ( ) , equalTo ( false ) ) ; } nodeJoinController . stopAccumulatingJoins ( <str> ) ; for ( Future < Void > future : pendingJoins ) { try { future . get ( ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } } } public void testSimpleMasterElectionWithoutRequiredJoins ( ) throws InterruptedException , ExecutionException { DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterService . state ( ) . nodes ( ) ) . masterNodeId ( null ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( nodes ) ) ; int nodeId = <int> ; final int requiredJoins = <int> ; logger . debug ( <str> , requiredJoins ) ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { try { joinNode ( newNode ( nodeId + + ) ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } } nodeJoinController . startAccumulatingJoins ( ) ; final SimpleFuture electionFuture = new SimpleFuture ( <str> ) ; final Thread masterElection = new Thread ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; electionFuture . markAsFailed ( t ) ; } @Override protected void doRun ( ) throws Exception { nodeJoinController . waitToBeElectedAsMaster ( requiredJoins , TimeValue . timeValueHours ( <int> ) , new NodeJoinController . ElectionCallback ( ) { @Override public void onElectedAsMaster ( ClusterState state ) { assertThat ( <str> , state . nodes ( ) . localNodeMaster ( ) , equalTo ( true ) ) ; electionFuture . markAsDone ( ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; electionFuture . markAsFailed ( t ) ; } } ) ; } } ) ; masterElection . start ( ) ; logger . debug ( <str> ) ; electionFuture . get ( ) ; } public void testSimpleMasterElection ( ) throws InterruptedException , ExecutionException { DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterService . state ( ) . nodes ( ) ) . masterNodeId ( null ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( nodes ) ) ; int nodeId = <int> ; final int requiredJoins = <int> + randomInt ( <int> ) ; logger . debug ( <str> , requiredJoins ) ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { try { joinNode ( newNode ( nodeId + + ) ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } } nodeJoinController . startAccumulatingJoins ( ) ; final SimpleFuture electionFuture = new SimpleFuture ( <str> ) ; final Thread masterElection = new Thread ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; electionFuture . markAsFailed ( t ) ; } @Override protected void doRun ( ) throws Exception { nodeJoinController . waitToBeElectedAsMaster ( requiredJoins , TimeValue . timeValueHours ( <int> ) , new NodeJoinController . ElectionCallback ( ) { @Override public void onElectedAsMaster ( ClusterState state ) { assertThat ( <str> , state . nodes ( ) . localNodeMaster ( ) , equalTo ( true ) ) ; electionFuture . markAsDone ( ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; electionFuture . markAsFailed ( t ) ; } } ) ; } } ) ; masterElection . start ( ) ; assertThat ( <str> + requiredJoins + <str> , electionFuture . isDone ( ) , equalTo ( false ) ) ; final int initialJoins = randomIntBetween ( <int> , requiredJoins - <int> ) ; final ArrayList < SimpleFuture > pendingJoins = new ArrayList < > ( ) ; ArrayList < DiscoveryNode > nodesToJoin = new ArrayList < > ( ) ; for ( int i = <int> ; i < initialJoins ; i + + ) { DiscoveryNode node = newNode ( nodeId + + , true ) ; for ( int j = <int> + randomInt ( <int> ) ; j > <int> ; j - - ) { nodesToJoin . add ( node ) ; } } for ( int i = <int> ; i < requiredJoins ; i + + ) { DiscoveryNode node = newNode ( nodeId + + , false ) ; for ( int j = <int> + randomInt ( <int> ) ; j > <int> ; j - - ) { nodesToJoin . add ( node ) ; } } Collections . shuffle ( nodesToJoin , random ( ) ) ; logger . debug ( <str> , initialJoins , nodesToJoin . size ( ) ) ; for ( DiscoveryNode node : nodesToJoin ) { pendingJoins . add ( joinNodeAsync ( node ) ) ; } logger . debug ( <str> ) ; assertThat ( <str> + initialJoins + <str> + requiredJoins + <str> , electionFuture . isDone ( ) , equalTo ( false ) ) ; final int finalJoins = requiredJoins - initialJoins + randomInt ( <int> ) ; nodesToJoin . clear ( ) ; for ( int i = <int> ; i < finalJoins ; i + + ) { DiscoveryNode node = newNode ( nodeId + + , true ) ; for ( int j = <int> + randomInt ( <int> ) ; j > <int> ; j - - ) { nodesToJoin . add ( node ) ; } } for ( int i = <int> ; i < requiredJoins ; i + + ) { DiscoveryNode node = newNode ( nodeId + + , false ) ; for ( int j = <int> + randomInt ( <int> ) ; j > <int> ; j - - ) { nodesToJoin . add ( node ) ; } } Collections . shuffle ( nodesToJoin , random ( ) ) ; logger . debug ( <str> , finalJoins , nodesToJoin . size ( ) ) ; for ( DiscoveryNode node : nodesToJoin ) { pendingJoins . add ( joinNodeAsync ( node ) ) ; } logger . debug ( <str> ) ; electionFuture . get ( ) ; logger . debug ( <str> ) ; for ( SimpleFuture future : pendingJoins ) { logger . debug ( <str> , future ) ; future . get ( ) ; } logger . debug ( <str> ) ; nodeJoinController . startAccumulatingJoins ( ) ; nodeJoinController . stopAccumulatingJoins ( <str> ) ; } public void testMasterElectionTimeout ( ) throws InterruptedException { DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterService . state ( ) . nodes ( ) ) . masterNodeId ( null ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( nodes ) ) ; int nodeId = <int> ; final int requiredJoins = <int> + randomInt ( <int> ) ; logger . debug ( <str> , requiredJoins ) ; for ( int i = randomInt ( <int> ) ; i > <int> ; i - - ) { try { joinNode ( newNode ( nodeId + + ) ) ; fail ( <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } } nodeJoinController . startAccumulatingJoins ( ) ; final int initialJoins = randomIntBetween ( <int> , requiredJoins - <int> ) ; final ArrayList < SimpleFuture > pendingJoins = new ArrayList < > ( ) ; ArrayList < DiscoveryNode > nodesToJoin = new ArrayList < > ( ) ; for ( int i = <int> ; i < initialJoins ; i + + ) { DiscoveryNode node = newNode ( nodeId + + ) ; for ( int j = <int> + randomInt ( <int> ) ; j > <int> ; j - - ) { nodesToJoin . add ( node ) ; } } Collections . shuffle ( nodesToJoin , random ( ) ) ; logger . debug ( <str> , initialJoins , nodesToJoin . size ( ) ) ; for ( DiscoveryNode node : nodesToJoin ) { pendingJoins . add ( joinNodeAsync ( node ) ) ; } final AtomicReference < Throwable > failure = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; nodeJoinController . waitToBeElectedAsMaster ( requiredJoins , TimeValue . timeValueMillis ( <int> ) , new NodeJoinController . ElectionCallback ( ) { @Override public void onElectedAsMaster ( ClusterState state ) { assertThat ( <str> , state . nodes ( ) . localNodeMaster ( ) , equalTo ( true ) ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable t ) { failure . set ( t ) ; latch . countDown ( ) ; } } ) ; latch . await ( ) ; logger . debug ( <str> ) ; assertThat ( failure . get ( ) , instanceOf ( ElasticsearchTimeoutException . class ) ) ; logger . debug ( <str> ) ; for ( SimpleFuture future : pendingJoins ) { logger . debug ( <str> , future ) ; try { future . get ( ) ; fail ( <str> + future + <str> ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) , instanceOf ( NotMasterException . class ) ) ; } } } public void testNewClusterStateOnExistingNodeJoin ( ) throws InterruptedException , ExecutionException { ClusterState state = clusterService . state ( ) ; final DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( state . nodes ( ) ) ; final DiscoveryNode other_node = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; nodesBuilder . put ( other_node ) ; clusterService . setState ( ClusterState . builder ( state ) . nodes ( nodesBuilder ) ) ; state = clusterService . state ( ) ; joinNode ( other_node ) ; assertTrue ( <str> , clusterService . state ( ) ! = state ) ; } public void testNormalConcurrentJoins ( ) throws InterruptedException { Thread [ ] threads = new Thread [ <int> + randomInt ( <int> ) ] ; ArrayList < DiscoveryNode > nodes = new ArrayList < > ( ) ; nodes . add ( clusterService . localNode ( ) ) ; final CyclicBarrier barrier = new CyclicBarrier ( threads . length ) ; final List < Throwable > backgroundExceptions = new CopyOnWriteArrayList < > ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { final DiscoveryNode node = newNode ( i ) ; final int iterations = rarely ( ) ? randomIntBetween ( <int> , <int> ) : <int> ; nodes . add ( node ) ; threads [ i ] = new Thread ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; backgroundExceptions . add ( t ) ; } @Override protected void doRun ( ) throws Exception { barrier . await ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { logger . debug ( <str> , node ) ; joinNode ( node ) ; } } } , <str> + i ) ; threads [ i ] . start ( ) ; } logger . info ( <str> ) ; for ( Thread thread : threads ) { thread . join ( ) ; } assertNodesInCurrentState ( nodes ) ; } public void testElectionWithConcurrentJoins ( ) throws InterruptedException , BrokenBarrierException { DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( clusterService . state ( ) . nodes ( ) ) . masterNodeId ( null ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . nodes ( nodesBuilder ) ) ; nodeJoinController . startAccumulatingJoins ( ) ; Thread [ ] threads = new Thread [ <int> + randomInt ( <int> ) ] ; final int requiredJoins = randomInt ( threads . length ) ; ArrayList < DiscoveryNode > nodes = new ArrayList < > ( ) ; nodes . add ( clusterService . localNode ( ) ) ; final CyclicBarrier barrier = new CyclicBarrier ( threads . length + <int> ) ; final List < Throwable > backgroundExceptions = new CopyOnWriteArrayList < > ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { final DiscoveryNode node = newNode ( i , true ) ; final int iterations = rarely ( ) ? randomIntBetween ( <int> , <int> ) : <int> ; nodes . add ( node ) ; threads [ i ] = new Thread ( new AbstractRunnable ( ) { @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; backgroundExceptions . add ( t ) ; } @Override protected void doRun ( ) throws Exception { barrier . await ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { logger . debug ( <str> , node ) ; joinNode ( node ) ; } } } , <str> + i ) ; threads [ i ] . start ( ) ; } barrier . await ( ) ; logger . info ( <str> , requiredJoins ) ; final AtomicReference < Throwable > failure = new AtomicReference < > ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; nodeJoinController . waitToBeElectedAsMaster ( requiredJoins , TimeValue . timeValueHours ( <int> ) , new NodeJoinController . ElectionCallback ( ) { @Override public void onElectedAsMaster ( ClusterState state ) { assertThat ( <str> , state . nodes ( ) . localNodeMaster ( ) , equalTo ( true ) ) ; latch . countDown ( ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; failure . set ( t ) ; latch . countDown ( ) ; } } ) ; latch . await ( ) ; ExceptionsHelper . reThrowIfNotNull ( failure . get ( ) ) ; logger . info ( <str> ) ; for ( Thread thread : threads ) { thread . join ( ) ; } assertNodesInCurrentState ( nodes ) ; } static class NoopRoutingService extends RoutingService { public NoopRoutingService ( Settings settings ) { super ( settings , null , null , new NoopAllocationService ( settings ) ) ; } @Override protected void performReroute ( String reason ) { } } static class NoopAllocationService extends AllocationService { public NoopAllocationService ( Settings settings ) { super ( settings , null , null , null ) ; } @Override public RoutingAllocation . Result applyStartedShards ( ClusterState clusterState , List < ? extends ShardRouting > startedShards , boolean withReroute ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } @Override public RoutingAllocation . Result applyFailedShards ( ClusterState clusterState , List < FailedRerouteAllocation . FailedShard > failedShards ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } @Override protected RoutingAllocation . Result reroute ( ClusterState clusterState , String reason , boolean debug ) { return new RoutingAllocation . Result ( false , clusterState . routingTable ( ) , clusterState . metaData ( ) ) ; } } protected void assertNodesInCurrentState ( List < DiscoveryNode > expectedNodes ) { DiscoveryNodes discoveryNodes = clusterService . state ( ) . nodes ( ) ; assertThat ( discoveryNodes . prettyPrint ( ) + <str> + expectedNodes . toString ( ) , discoveryNodes . size ( ) , equalTo ( expectedNodes . size ( ) ) ) ; for ( DiscoveryNode node : expectedNodes ) { assertThat ( <str> + node + <str> + discoveryNodes . prettyPrint ( ) , discoveryNodes . get ( node . id ( ) ) , equalTo ( node ) ) ; } } static class SimpleFuture extends BaseFuture < Void > { final String description ; SimpleFuture ( String description ) { this . description = description ; } public void markAsDone ( ) { set ( null ) ; } public void markAsFailed ( Throwable t ) { setException ( t ) ; } @Override public String toString ( ) { return <str> + description + <str> ; } } final static AtomicInteger joinId = new AtomicInteger ( ) ; private SimpleFuture joinNodeAsync ( final DiscoveryNode node ) throws InterruptedException { final SimpleFuture future = new SimpleFuture ( <str> + node + <str> + joinId . incrementAndGet ( ) + <str> ) ; logger . debug ( <str> , future ) ; nodeJoinController . handleJoinRequest ( node , new MembershipAction . JoinCallback ( ) { @Override public void onSuccess ( ) { logger . debug ( <str> , future ) ; future . markAsDone ( ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t , future ) ; future . markAsFailed ( t ) ; } } ) ; return future ; } private void joinNode ( final DiscoveryNode node ) throws InterruptedException , ExecutionException { joinNodeAsync ( node ) . get ( ) ; } protected DiscoveryNode newNode ( int i ) { return newNode ( i , randomBoolean ( ) ) ; } protected DiscoveryNode newNode ( int i , boolean master ) { Map < String , String > attributes = new HashMap < > ( ) ; attributes . put ( <str> , Boolean . toString ( master ) ) ; final String prefix = master ? <str> : <str> ; return new DiscoveryNode ( prefix + i , i + <str> , new LocalTransportAddress ( <str> + i ) , attributes , Version . CURRENT ) ; } } 
