package org . nd4j . linalg . jcublas . context ; import jcuda . driver . CUevent ; import jcuda . driver . CUstream ; import jcuda . driver . CUstream_flags ; import jcuda . driver . JCudaDriver ; import jcuda . jcublas . JCublas2 ; import jcuda . jcublas . cublasHandle ; import jcuda . runtime . JCuda ; import jcuda . runtime . cudaEvent_t ; import jcuda . runtime . cudaStream_t ; import lombok . Data ; import org . nd4j . linalg . jcublas . CublasPointer ; import java . util . concurrent . atomic . AtomicBoolean ; @Data public class CudaContext implements AutoCloseable { private CUstream stream ; private CUevent cUevent ; private cudaStream_t oldStream ; private cudaEvent_t oldEvent ; private cublasHandle handle ; private CublasPointer resultPointer ; private AtomicBoolean oldStreamReturned = new AtomicBoolean ( false ) ; private AtomicBoolean handleReturned = new AtomicBoolean ( false ) ; private AtomicBoolean streamReturned = new AtomicBoolean ( false ) ; private boolean streamFromPool = true ; private boolean handleFromPool = true ; private boolean oldStreamFromPool = true ; private boolean free = true ; private boolean oldEventDestroyed = true ; private boolean eventDestroyed = true ; public CudaContext ( boolean free ) { this ( ) ; this . free = free ; } public CudaContext ( ) { ContextHolder . getInstance ( ) . setContext ( ) ; } public void syncStream ( ) { if ( eventDestroyed ) { return ; } JCudaDriver . cuEventSynchronize ( cUevent ) ; JCudaDriver . cuEventDestroy ( cUevent ) ; eventDestroyed = true ; } public void syncOldStream ( ) { if ( ! oldEventDestroyed ) { JCuda . cudaStreamWaitEvent ( oldStream , oldEvent , <int> ) ; JCuda . cudaEventDestroy ( oldEvent ) ; oldEventDestroyed = true ; } } public void syncHandle ( ) { syncOldStream ( ) ; } public CublasPointer getResultPointer ( ) { return resultPointer ; } public void associateHandle ( ) { ContextHolder . getInstance ( ) . setContext ( ) ; JCublas2 . cublasSetStream ( handle , oldStream ) ; } public void startOldEvent ( ) { JCuda . cudaEventRecord ( oldEvent , oldStream ) ; } public void startNewEvent ( ) { JCudaDriver . cuEventRecord ( cUevent , stream ) ; } public void initStream ( ) { if ( stream = = null ) { try { stream = ContextHolder . getInstance ( ) . getStreamPool ( ) . borrowObject ( ) ; } catch ( Exception e ) { stream = new CUstream ( ) ; JCudaDriver . cuStreamCreate ( stream , CUstream_flags . CU_STREAM_NON_BLOCKING ) ; streamFromPool = false ; } cUevent = new CUevent ( ) ; JCudaDriver . cuEventCreate ( cUevent , <int> ) ; eventDestroyed = false ; } } public void initOldStream ( ) { if ( oldStream = = null ) { try { oldStream = ContextHolder . getInstance ( ) . getOldStreamPool ( ) . borrowObject ( ) ; } catch ( Exception e ) { oldStreamFromPool = false ; oldStream = new cudaStream_t ( ) ; JCuda . cudaStreamCreate ( oldStream ) ; } oldEvent = new cudaEvent_t ( ) ; JCuda . cudaEventCreate ( oldEvent ) ; oldEventDestroyed = false ; } } public void initHandle ( ) { if ( handle = = null ) { try { handle = ContextHolder . getInstance ( ) . getHandlePool ( ) . borrowObject ( ) ; } catch ( Exception e ) { handle = new cublasHandle ( ) ; JCublas2 . cublasCreate ( handle ) ; handleFromPool = false ; } associateHandle ( ) ; } } public void destroy ( CublasPointer resultPointer , boolean freeIfNotEqual ) { if ( handle ! = null & & ! handleReturned . get ( ) ) { try { if ( handleFromPool ) ContextHolder . getInstance ( ) . getHandlePool ( ) . returnObject ( handle ) ; else { JCublas2 . cublasDestroy ( handle ) ; } handleReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( stream ! = null & & ! streamReturned . get ( ) ) { try { if ( streamFromPool ) ContextHolder . getInstance ( ) . getStreamPool ( ) . returnObject ( stream ) ; else { JCudaDriver . cuStreamDestroy ( stream ) ; } streamReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( oldStream ! = null & & ! oldStreamReturned . get ( ) ) { try { if ( oldStreamFromPool ) ContextHolder . getInstance ( ) . getOldStreamPool ( ) . returnObject ( oldStream ) ; else { JCuda . cudaStreamDestroy ( oldStream ) ; } oldStreamReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( resultPointer ! = null & & freeIfNotEqual & & freeIfNotEqual ) { resultPointer . copyToHost ( ) ; try { resultPointer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( ! oldEventDestroyed ) { JCuda . cudaEventDestroy ( oldEvent ) ; oldEventDestroyed = true ; } if ( ! eventDestroyed ) { JCudaDriver . cuEventDestroy ( cUevent ) ; eventDestroyed = true ; } } public void destroy ( ) { if ( handle ! = null & & ! handleReturned . get ( ) ) { try { if ( handleFromPool ) ContextHolder . getInstance ( ) . getHandlePool ( ) . returnObject ( handle ) ; else { JCublas2 . cublasDestroy ( handle ) ; } handleReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( stream ! = null & & ! streamReturned . get ( ) ) { try { if ( streamFromPool ) ContextHolder . getInstance ( ) . getStreamPool ( ) . returnObject ( stream ) ; else { JCudaDriver . cuStreamDestroy ( stream ) ; } streamReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( oldStream ! = null & & ! oldStreamReturned . get ( ) ) { try { if ( oldStreamFromPool ) ContextHolder . getInstance ( ) . getOldStreamPool ( ) . returnObject ( oldStream ) ; else { JCuda . cudaStreamDestroy ( oldStream ) ; } oldStreamReturned . set ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( resultPointer ! = null ) { resultPointer . copyToHost ( ) ; try { resultPointer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void finishBlasOperation ( ) { destroy ( ) ; } public static CudaContext getBlasContext ( ) { CudaContext ctx = new CudaContext ( ) ; ctx . initOldStream ( ) ; ctx . initHandle ( ) ; return ctx ; } public void syncDevice ( ) { JCuda . cudaDeviceSynchronize ( ) ; } @Override public void close ( ) throws Exception { destroy ( ) ; } } 
