package org . elasticsearch . search . lookup ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . IntsRefBuilder ; import java . io . IOException ; import java . util . Iterator ; public class CachedPositionIterator extends PositionIterator { public CachedPositionIterator ( IndexFieldTerm indexFieldTerm ) { super ( indexFieldTerm ) ; } final BytesRefBuilder payloads = new BytesRefBuilder ( ) ; final IntsRefBuilder payloadsLengths = new IntsRefBuilder ( ) ; final IntsRefBuilder payloadsStarts = new IntsRefBuilder ( ) ; final IntsRefBuilder positions = new IntsRefBuilder ( ) ; final IntsRefBuilder startOffsets = new IntsRefBuilder ( ) ; final IntsRefBuilder endOffsets = new IntsRefBuilder ( ) ; final BytesRef payload = new BytesRef ( ) ; @Override public Iterator < TermPosition > reset ( ) { return new Iterator < TermPosition > ( ) { private int pos = <int> ; private final TermPosition termPosition = new TermPosition ( ) ; @Override public boolean hasNext ( ) { return pos < freq ; } @Override public TermPosition next ( ) { termPosition . position = positions . intAt ( pos ) ; termPosition . startOffset = startOffsets . intAt ( pos ) ; termPosition . endOffset = endOffsets . intAt ( pos ) ; termPosition . payload = payload ; payload . bytes = payloads . bytes ( ) ; payload . offset = payloadsStarts . intAt ( pos ) ; payload . length = payloadsLengths . intAt ( pos ) ; pos + + ; return termPosition ; } @Override public void remove ( ) { } } ; } private void record ( ) throws IOException { TermPosition termPosition ; for ( int i = <int> ; i < freq ; i + + ) { termPosition = super . next ( ) ; positions . setIntAt ( i , termPosition . position ) ; addPayload ( i , termPosition . payload ) ; startOffsets . setIntAt ( i , termPosition . startOffset ) ; endOffsets . setIntAt ( i , termPosition . endOffset ) ; } } private void ensureSize ( int freq ) { if ( freq = = <int> ) { return ; } startOffsets . grow ( freq ) ; endOffsets . grow ( freq ) ; positions . grow ( freq ) ; payloadsLengths . grow ( freq ) ; payloadsStarts . grow ( freq ) ; payloads . grow ( freq * <int> ) ; } private void addPayload ( int i , BytesRef currPayload ) { if ( currPayload ! = null ) { payloadsLengths . setIntAt ( i , currPayload . length ) ; payloadsStarts . setIntAt ( i , i = = <int> ? <int> : payloadsStarts . intAt ( i - <int> ) + payloadsLengths . intAt ( i - <int> ) ) ; payloads . grow ( payloadsStarts . intAt ( i ) + currPayload . length ) ; System . arraycopy ( currPayload . bytes , currPayload . offset , payloads . bytes ( ) , payloadsStarts . intAt ( i ) , currPayload . length ) ; } else { payloadsLengths . setIntAt ( i , <int> ) ; payloadsStarts . setIntAt ( i , i = = <int> ? <int> : payloadsStarts . intAt ( i - <int> ) + payloadsLengths . intAt ( i - <int> ) ) ; } } @Override public void nextDoc ( ) throws IOException { super . nextDoc ( ) ; ensureSize ( freq ) ; record ( ) ; } @Override public TermPosition next ( ) { throw new UnsupportedOperationException ( ) ; } } 
