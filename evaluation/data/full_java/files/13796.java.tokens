package org . gradle . launcher . daemon . client ; import org . gradle . api . internal . specs . ExplainingSpec ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . serialize . Serializers ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . launcher . daemon . context . DaemonInstanceDetails ; import org . gradle . launcher . daemon . diagnostics . DaemonStartupInfo ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . protocol . DaemonMessageSerializer ; import org . gradle . launcher . daemon . protocol . Message ; import org . gradle . launcher . daemon . registry . DaemonInfo ; import org . gradle . launcher . daemon . registry . DaemonRegistry ; import org . gradle . messaging . remote . internal . * ; import java . util . List ; public class DefaultDaemonConnector implements DaemonConnector { private static final Logger LOGGER = Logging . getLogger ( DefaultDaemonConnector . class ) ; public static final int DEFAULT_CONNECT_TIMEOUT = <int> ; public static final String STARTING_DAEMON_MESSAGE = <str> ; public static final String DISABLE_STARTING_DAEMON_MESSAGE_PROPERTY = <str> ; private final DaemonRegistry daemonRegistry ; protected final OutgoingConnector connector ; private final DaemonStarter daemonStarter ; private long connectTimeout = DefaultDaemonConnector . DEFAULT_CONNECT_TIMEOUT ; public DefaultDaemonConnector ( DaemonRegistry daemonRegistry , OutgoingConnector connector , DaemonStarter daemonStarter ) { this . daemonRegistry = daemonRegistry ; this . connector = connector ; this . daemonStarter = daemonStarter ; } public void setConnectTimeout ( long connectTimeout ) { this . connectTimeout = connectTimeout ; } public long getConnectTimeout ( ) { return connectTimeout ; } public DaemonRegistry getDaemonRegistry ( ) { return daemonRegistry ; } public DaemonClientConnection maybeConnect ( ExplainingSpec < DaemonContext > constraint ) { return findConnection ( daemonRegistry . getAll ( ) , constraint ) ; } public DaemonClientConnection maybeConnect ( DaemonInstanceDetails daemon ) { try { return connectToDaemon ( daemon , new CleanupOnStaleAddress ( daemon , true ) ) ; } catch ( ConnectException e ) { LOGGER . debug ( <str> , daemon , e ) ; return null ; } } public DaemonClientConnection connect ( ExplainingSpec < DaemonContext > constraint ) { DaemonClientConnection connection = findConnection ( daemonRegistry . getIdle ( ) , constraint ) ; if ( connection ! = null ) { return connection ; } if ( ! Boolean . getBoolean ( DISABLE_STARTING_DAEMON_MESSAGE_PROPERTY ) ) { LOGGER . lifecycle ( STARTING_DAEMON_MESSAGE ) ; } return startDaemon ( constraint ) ; } private DaemonClientConnection findConnection ( List < DaemonInfo > daemons , ExplainingSpec < DaemonContext > constraint ) { for ( DaemonInfo daemon : daemons ) { if ( ! constraint . isSatisfiedBy ( daemon . getContext ( ) ) ) { LOGGER . debug ( <str> + constraint . whyUnsatisfied ( daemon . getContext ( ) ) + <str> + <str> , daemon ) ; continue ; } try { return connectToDaemon ( daemon , new CleanupOnStaleAddress ( daemon , true ) ) ; } catch ( ConnectException e ) { LOGGER . debug ( <str> , daemon , e ) ; } } return null ; } public DaemonClientConnection startDaemon ( ExplainingSpec < DaemonContext > constraint ) { final DaemonStartupInfo startupInfo = daemonStarter . startDaemon ( ) ; LOGGER . debug ( <str> , startupInfo ) ; long expiry = System . currentTimeMillis ( ) + connectTimeout ; do { DaemonClientConnection daemonConnection = connectToDaemonWithId ( startupInfo , constraint ) ; if ( daemonConnection ! = null ) { return daemonConnection ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } while ( System . currentTimeMillis ( ) < expiry ) ; throw new DaemonConnectionException ( <str> + startupInfo . describe ( ) ) ; } private DaemonClientConnection connectToDaemonWithId ( DaemonStartupInfo daemon , ExplainingSpec < DaemonContext > constraint ) throws ConnectException { for ( DaemonInfo daemonInfo : daemonRegistry . getBusy ( ) ) { if ( daemonInfo . getUid ( ) . equals ( daemon . getUid ( ) ) ) { try { if ( ! constraint . isSatisfiedBy ( daemonInfo . getContext ( ) ) ) { throw new DaemonConnectionException ( <str> + <str> + <str> + constraint . whyUnsatisfied ( daemonInfo . getContext ( ) ) ) ; } return connectToDaemon ( daemonInfo , new CleanupOnStaleAddress ( daemonInfo , false ) ) ; } catch ( ConnectException e ) { throw new DaemonConnectionException ( <str> + daemon . describe ( ) , e ) ; } } } return null ; } private DaemonClientConnection connectToDaemon ( DaemonInstanceDetails daemon , DaemonClientConnection . StaleAddressDetector staleAddressDetector ) throws ConnectException { RemoteConnection < Message > connection ; try { MessageSerializer < Message > serializer = new KryoBackedMessageSerializer < Message > ( Serializers . stateful ( DaemonMessageSerializer . create ( ) ) ) ; connection = connector . connect ( daemon . getAddress ( ) ) . create ( serializer ) ; } catch ( ConnectException e ) { staleAddressDetector . maybeStaleAddress ( e ) ; throw e ; } return new DaemonClientConnection ( connection , daemon , staleAddressDetector ) ; } private class CleanupOnStaleAddress implements DaemonClientConnection . StaleAddressDetector { private final DaemonInstanceDetails daemon ; private final boolean exposeAsStale ; public CleanupOnStaleAddress ( DaemonInstanceDetails daemon , boolean exposeAsStale ) { this . daemon = daemon ; this . exposeAsStale = exposeAsStale ; } public boolean maybeStaleAddress ( Exception failure ) { LOGGER . info ( <str> , DaemonMessages . REMOVING_DAEMON_ADDRESS_ON_FAILURE , daemon ) ; daemonRegistry . remove ( daemon . getAddress ( ) ) ; return exposeAsStale ; } } } 
