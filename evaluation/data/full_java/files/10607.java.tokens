package com . google . common . reflect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Charsets ; import com . google . common . collect . ImmutableMap ; import com . google . common . io . Closer ; import com . google . common . io . Files ; import com . google . common . io . Resources ; import com . google . common . reflect . ClassPath . ClassInfo ; import com . google . common . reflect . ClassPath . ResourceInfo ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import org . junit . Test ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . Set ; import java . util . jar . Attributes ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . JarOutputStream ; import java . util . jar . Manifest ; import java . util . zip . ZipEntry ; public class ClassPathTest extends TestCase { public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( classInfo ( ClassPathTest . class ) , classInfo ( ClassPathTest . class ) ) . addEqualityGroup ( classInfo ( Test . class ) , classInfo ( Test . class , getClass ( ) . getClassLoader ( ) ) ) . addEqualityGroup ( new ResourceInfo ( <str> , getClass ( ) . getClassLoader ( ) ) , new ResourceInfo ( <str> , getClass ( ) . getClassLoader ( ) ) ) . addEqualityGroup ( new ResourceInfo ( <str> , getClass ( ) . getClassLoader ( ) ) ) . testEquals ( ) ; } @AndroidIncompatible public void testClassPathEntries_emptyURLClassLoader_noParent ( ) { assertThat ( ClassPath . Scanner . getClassPathEntries ( new URLClassLoader ( new URL [ <int> ] , null ) ) . keySet ( ) ) . isEmpty ( ) ; } @AndroidIncompatible public void testClassPathEntries_URLClassLoader_noParent ( ) throws Exception { URL url1 = new URL ( <str> ) ; URL url2 = new URL ( <str> ) ; URLClassLoader classloader = new URLClassLoader ( new URL [ ] { url1 , url2 } , null ) ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , classloader , new File ( <str> ) , classloader ) , ClassPath . Scanner . getClassPathEntries ( classloader ) ) ; } @AndroidIncompatible public void testClassPathEntries_URLClassLoader_withParent ( ) throws Exception { URL url1 = new URL ( <str> ) ; URL url2 = new URL ( <str> ) ; URLClassLoader parent = new URLClassLoader ( new URL [ ] { url1 } , null ) ; URLClassLoader child = new URLClassLoader ( new URL [ ] { url2 } , parent ) { } ; ImmutableMap < File , ClassLoader > classPathEntries = ClassPath . Scanner . getClassPathEntries ( child ) ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , parent , new File ( <str> ) , child ) , classPathEntries ) ; assertThat ( classPathEntries . keySet ( ) ) . containsExactly ( new File ( <str> ) , new File ( <str> ) ) . inOrder ( ) ; } @AndroidIncompatible public void testClassPathEntries_duplicateUri_parentWins ( ) throws Exception { URL url = new URL ( <str> ) ; URLClassLoader parent = new URLClassLoader ( new URL [ ] { url } , null ) ; URLClassLoader child = new URLClassLoader ( new URL [ ] { url } , parent ) { } ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , parent ) , ClassPath . Scanner . getClassPathEntries ( child ) ) ; } @AndroidIncompatible public void testClassPathEntries_notURLClassLoader_noParent ( ) { assertThat ( ClassPath . Scanner . getClassPathEntries ( new ClassLoader ( null ) { } ) . keySet ( ) ) . isEmpty ( ) ; } @AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParent ( ) throws Exception { URL url = new URL ( <str> ) ; URLClassLoader parent = new URLClassLoader ( new URL [ ] { url } , null ) ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , parent ) , ClassPath . Scanner . getClassPathEntries ( new ClassLoader ( parent ) { } ) ) ; } @AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withParentAndGrandParent ( ) throws Exception { URL url1 = new URL ( <str> ) ; URL url2 = new URL ( <str> ) ; URLClassLoader grandParent = new URLClassLoader ( new URL [ ] { url1 } , null ) ; URLClassLoader parent = new URLClassLoader ( new URL [ ] { url2 } , grandParent ) ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , grandParent , new File ( <str> ) , parent ) , ClassPath . Scanner . getClassPathEntries ( new ClassLoader ( parent ) { } ) ) ; } @AndroidIncompatible public void testClassPathEntries_notURLClassLoader_withGrandParent ( ) throws Exception { URL url = new URL ( <str> ) ; URLClassLoader grandParent = new URLClassLoader ( new URL [ ] { url } , null ) ; ClassLoader parent = new ClassLoader ( grandParent ) { } ; assertEquals ( ImmutableMap . of ( new File ( <str> ) , grandParent ) , ClassPath . Scanner . getClassPathEntries ( new ClassLoader ( parent ) { } ) ) ; } public void testScan_classPathCycle ( ) throws IOException { File jarFile = File . createTempFile ( <str> , <str> ) ; try { writeSelfReferencingJarFile ( jarFile , <str> ) ; ClassPath . DefaultScanner scanner = new ClassPath . DefaultScanner ( ) ; scanner . scan ( jarFile , ClassPathTest . class . getClassLoader ( ) ) ; assertEquals ( <int> , scanner . getResources ( ) . size ( ) ) ; } finally { jarFile . delete ( ) ; } } public void testScanFromFile_fileNotExists ( ) throws IOException { ClassLoader classLoader = ClassPathTest . class . getClassLoader ( ) ; ClassPath . DefaultScanner scanner = new ClassPath . DefaultScanner ( ) ; scanner . scan ( new File ( <str> ) , classLoader ) ; assertThat ( scanner . getResources ( ) ) . isEmpty ( ) ; } public void testScanFromFile_notJarFile ( ) throws IOException { ClassLoader classLoader = ClassPathTest . class . getClassLoader ( ) ; File notJar = File . createTempFile ( <str> , <str> ) ; ClassPath . DefaultScanner scanner = new ClassPath . DefaultScanner ( ) ; try { scanner . scan ( notJar , classLoader ) ; } finally { notJar . delete ( ) ; } assertThat ( scanner . getResources ( ) ) . isEmpty ( ) ; } public void testGetClassPathEntry ( ) throws MalformedURLException , URISyntaxException { assertEquals ( new File ( <str> ) . toURI ( ) , ClassPath . Scanner . getClassPathEntry ( new File ( <str> ) , <str> ) . toURI ( ) ) ; assertEquals ( new File ( <str> ) . toURI ( ) , ClassPath . Scanner . getClassPathEntry ( new File ( <str> ) , <str> ) . toURI ( ) ) ; assertEquals ( new File ( <str> ) . toURI ( ) , ClassPath . Scanner . getClassPathEntry ( new File ( <str> ) , <str> ) . toURI ( ) ) ; assertEquals ( new File ( <str> ) . toURI ( ) , ClassPath . Scanner . getClassPathEntry ( new File ( <str> ) , <str> ) . toURI ( ) ) ; assertEquals ( <str> , ClassPath . Scanner . getClassPathEntry ( new File ( <str> ) , <str> ) . getFile ( ) ) ; } public void testGetClassPathFromManifest_nullManifest ( ) { assertThat ( ClassPath . Scanner . getClassPathFromManifest ( new File ( <str> ) , null ) ) . isEmpty ( ) ; } public void testGetClassPathFromManifest_noClassPath ( ) throws IOException { File jarFile = new File ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ( <str> ) ) ) . isEmpty ( ) ; } public void testGetClassPathFromManifest_emptyClassPath ( ) throws IOException { File jarFile = new File ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifestClasspath ( <str> ) ) ) . isEmpty ( ) ; } public void testGetClassPathFromManifest_badClassPath ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . isEmpty ( ) ; } public void testGetClassPathFromManifest_pathWithStrangeCharacter ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_relativeDirectory ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_relativeJar ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_jarInCurrentDirectory ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_absoluteDirectory ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_absoluteJar ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_multiplePaths ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) , fullpath ( <str> ) , fullpath ( <str> ) ) . inOrder ( ) ; } public void testGetClassPathFromManifest_leadingBlanks ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassPathFromManifest_trailingBlanks ( ) throws IOException { File jarFile = new File ( <str> ) ; Manifest manifest = manifestClasspath ( <str> ) ; assertThat ( ClassPath . Scanner . getClassPathFromManifest ( jarFile , manifest ) ) . containsExactly ( fullpath ( <str> ) ) ; } public void testGetClassName ( ) { assertEquals ( <str> , ClassPath . getClassName ( <str> ) ) ; } public void testResourceInfo_of ( ) { assertEquals ( ClassInfo . class , resourceInfo ( ClassPathTest . class ) . getClass ( ) ) ; assertEquals ( ClassInfo . class , resourceInfo ( ClassPath . class ) . getClass ( ) ) ; assertEquals ( ClassInfo . class , resourceInfo ( Nested . class ) . getClass ( ) ) ; } public void testGetSimpleName ( ) { ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , classLoader ) . getSimpleName ( ) ) ; } public void testGetPackageName ( ) { assertEquals ( <str> , new ClassInfo ( <str> , getClass ( ) . getClassLoader ( ) ) . getPackageName ( ) ) ; assertEquals ( <str> , new ClassInfo ( <str> , getClass ( ) . getClassLoader ( ) ) . getPackageName ( ) ) ; } private static boolean contentEquals ( URL left , URL right ) throws IOException { return Resources . asByteSource ( left ) . contentEquals ( Resources . asByteSource ( right ) ) ; } private static class Nested { } public void testNulls ( ) throws IOException { new NullPointerTester ( ) . testAllPublicStaticMethods ( ClassPath . class ) ; new NullPointerTester ( ) . testAllPublicInstanceMethods ( ClassPath . from ( getClass ( ) . getClassLoader ( ) ) ) ; } public void testResourceScanner ( ) throws IOException { ResourceScanner scanner = new ResourceScanner ( ) ; scanner . scan ( ClassLoader . getSystemClassLoader ( ) ) ; assertThat ( scanner . resources ) . contains ( <str> ) ; } private static ClassPath . ClassInfo findClass ( Iterable < ClassPath . ClassInfo > classes , Class < ? > cls ) { for ( ClassPath . ClassInfo classInfo : classes ) { if ( classInfo . getName ( ) . equals ( cls . getName ( ) ) ) { return classInfo ; } } throw new AssertionError ( <str> + cls ) ; } private static ResourceInfo resourceInfo ( Class < ? > cls ) { String resource = cls . getName ( ) . replace ( <str> , <str> ) + <str> ; ClassLoader loader = cls . getClassLoader ( ) ; return ResourceInfo . of ( resource , loader ) ; } private static ClassInfo classInfo ( Class < ? > cls ) { return classInfo ( cls , cls . getClassLoader ( ) ) ; } private static ClassInfo classInfo ( Class < ? > cls , ClassLoader classLoader ) { String resource = cls . getName ( ) . replace ( <str> , <str> ) + <str> ; return new ClassInfo ( resource , classLoader ) ; } private static Manifest manifestClasspath ( String classpath ) throws IOException { return manifest ( <str> + classpath + <str> ) ; } private static void writeSelfReferencingJarFile ( File jarFile , String . . . entries ) throws IOException { Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . MANIFEST_VERSION , <str> ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . CLASS_PATH , jarFile . getName ( ) ) ; Closer closer = Closer . create ( ) ; try { FileOutputStream fileOut = closer . register ( new FileOutputStream ( jarFile ) ) ; JarOutputStream jarOut = closer . register ( new JarOutputStream ( fileOut ) ) ; for ( String entry : entries ) { jarOut . putNextEntry ( new ZipEntry ( entry ) ) ; Resources . copy ( ClassPathTest . class . getResource ( entry ) , jarOut ) ; jarOut . closeEntry ( ) ; } } catch ( Throwable e ) { throw closer . rethrow ( e ) ; } finally { closer . close ( ) ; } } private static Manifest manifest ( String content ) throws IOException { InputStream in = new ByteArrayInputStream ( content . getBytes ( Charsets . US_ASCII ) ) ; Manifest manifest = new Manifest ( ) ; manifest . read ( in ) ; return manifest ; } private static File fullpath ( String path ) { return new File ( new File ( path ) . toURI ( ) ) ; } private static class ResourceScanner extends ClassPath . Scanner { final Set < String > resources = new HashSet < String > ( ) ; @Override protected void scanDirectory ( ClassLoader loader , File root ) throws IOException { URI base = root . toURI ( ) ; for ( File entry : Files . fileTreeTraverser ( ) . preOrderTraversal ( root ) ) { String resourceName = new File ( base . relativize ( entry . toURI ( ) ) . getPath ( ) ) . getPath ( ) ; resources . add ( resourceName ) ; } } @Override protected void scanJarFile ( ClassLoader loader , JarFile file ) throws IOException { Enumeration < JarEntry > entries = file . entries ( ) ; while ( entries . hasMoreElements ( ) ) { resources . add ( entries . nextElement ( ) . getName ( ) ) ; } } } } 
