package org . apache . cassandra . locator ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Map ; import com . google . common . collect . Iterators ; import com . google . common . collect . Multimap ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import static junit . framework . Assert . assertNotNull ; import static org . junit . Assert . assertEquals ; import static org . apache . cassandra . Util . token ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . service . StorageService ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class TokenMetadataTest { public final static String ONE = <str> ; public final static String SIX = <str> ; static TokenMetadata tmd ; @BeforeClass public static void beforeClass ( ) throws Throwable { tmd = StorageService . instance . getTokenMetadata ( ) ; tmd . updateNormalToken ( token ( ONE ) , InetAddress . getByName ( <str> ) ) ; tmd . updateNormalToken ( token ( SIX ) , InetAddress . getByName ( <str> ) ) ; } private static void testRingIterator ( ArrayList < Token > ring , String start , boolean includeMin , String . . . expected ) { ArrayList < Token > actual = new ArrayList < > ( ) ; Iterators . addAll ( actual , TokenMetadata . ringIterator ( ring , token ( start ) , includeMin ) ) ; assertEquals ( actual . toString ( ) , expected . length , actual . size ( ) ) ; for ( int i = <int> ; i < expected . length ; i + + ) assertEquals ( <str> + i + <str> + actual , token ( expected [ i ] ) , actual . get ( i ) ) ; } @Test public void testRingIterator ( ) { ArrayList < Token > ring = tmd . sortedTokens ( ) ; testRingIterator ( ring , <str> , false , <str> , <str> ) ; testRingIterator ( ring , <str> , false , <str> , <str> ) ; testRingIterator ( ring , <str> , false , <str> , <str> ) ; testRingIterator ( ring , <str> , false , <str> , <str> ) ; } @Test public void testRingIteratorIncludeMin ( ) { ArrayList < Token > ring = tmd . sortedTokens ( ) ; testRingIterator ( ring , <str> , true , <str> , <str> , <str> ) ; testRingIterator ( ring , <str> , true , <str> , <str> , <str> ) ; testRingIterator ( ring , <str> , true , <str> , <str> , <str> ) ; testRingIterator ( ring , <str> , true , <str> , <str> , <str> ) ; } @Test public void testRingIteratorEmptyRing ( ) { testRingIterator ( new ArrayList < Token > ( ) , <str> , false ) ; } @Test public void testTopologyUpdate_RackConsolidation ( ) throws UnknownHostException { final InetAddress first = InetAddress . getByName ( <str> ) ; final InetAddress second = InetAddress . getByName ( <str> ) ; final String DATA_CENTER = <str> ; final String RACK1 = <str> ; final String RACK2 = <str> ; DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) { @Override public String getRack ( InetAddress endpoint ) { return endpoint . equals ( first ) ? RACK1 : RACK2 ; } @Override public String getDatacenter ( InetAddress endpoint ) { return DATA_CENTER ; } @Override public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) { return <int> ; } } ) ; tmd . updateNormalToken ( token ( ONE ) , first ) ; tmd . updateNormalToken ( token ( SIX ) , second ) ; TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; assertNotNull ( tokenMetadata ) ; TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; assertNotNull ( topology ) ; Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; assertNotNull ( allEndpoints ) ; assertTrue ( allEndpoints . size ( ) = = <int> ) ; assertTrue ( allEndpoints . containsKey ( DATA_CENTER ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( first ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( second ) ) ; Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; assertNotNull ( racks ) ; assertTrue ( racks . size ( ) = = <int> ) ; assertTrue ( racks . containsKey ( DATA_CENTER ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . size ( ) = = <int> ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK1 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK2 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( first ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK2 ) . contains ( second ) ) ; DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) { @Override public String getRack ( InetAddress endpoint ) { return RACK1 ; } @Override public String getDatacenter ( InetAddress endpoint ) { return DATA_CENTER ; } @Override public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) { return <int> ; } } ) ; tokenMetadata . updateTopology ( first ) ; tokenMetadata . updateTopology ( second ) ; allEndpoints = topology . getDatacenterEndpoints ( ) ; assertNotNull ( allEndpoints ) ; assertTrue ( allEndpoints . size ( ) = = <int> ) ; assertTrue ( allEndpoints . containsKey ( DATA_CENTER ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( first ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( second ) ) ; racks = topology . getDatacenterRacks ( ) ; assertNotNull ( racks ) ; assertTrue ( racks . size ( ) = = <int> ) ; assertTrue ( racks . containsKey ( DATA_CENTER ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . size ( ) = = <int> ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK1 ) ) ; assertFalse ( racks . get ( DATA_CENTER ) . containsKey ( RACK2 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( first ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( second ) ) ; } @Test public void testTopologyUpdate_RackExpansion ( ) throws UnknownHostException { final InetAddress first = InetAddress . getByName ( <str> ) ; final InetAddress second = InetAddress . getByName ( <str> ) ; final String DATA_CENTER = <str> ; final String RACK1 = <str> ; final String RACK2 = <str> ; DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) { @Override public String getRack ( InetAddress endpoint ) { return RACK1 ; } @Override public String getDatacenter ( InetAddress endpoint ) { return DATA_CENTER ; } @Override public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) { return <int> ; } } ) ; tmd . updateNormalToken ( token ( ONE ) , first ) ; tmd . updateNormalToken ( token ( SIX ) , second ) ; TokenMetadata tokenMetadata = tmd . cloneOnlyTokenMap ( ) ; assertNotNull ( tokenMetadata ) ; TokenMetadata . Topology topology = tokenMetadata . getTopology ( ) ; assertNotNull ( topology ) ; Multimap < String , InetAddress > allEndpoints = topology . getDatacenterEndpoints ( ) ; assertNotNull ( allEndpoints ) ; assertTrue ( allEndpoints . size ( ) = = <int> ) ; assertTrue ( allEndpoints . containsKey ( DATA_CENTER ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( first ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( second ) ) ; Map < String , Multimap < String , InetAddress > > racks = topology . getDatacenterRacks ( ) ; assertNotNull ( racks ) ; assertTrue ( racks . size ( ) = = <int> ) ; assertTrue ( racks . containsKey ( DATA_CENTER ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . size ( ) = = <int> ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK1 ) ) ; assertFalse ( racks . get ( DATA_CENTER ) . containsKey ( RACK2 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( first ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( second ) ) ; DatabaseDescriptor . setEndpointSnitch ( new AbstractEndpointSnitch ( ) { @Override public String getRack ( InetAddress endpoint ) { return endpoint . equals ( first ) ? RACK1 : RACK2 ; } @Override public String getDatacenter ( InetAddress endpoint ) { return DATA_CENTER ; } @Override public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) { return <int> ; } } ) ; tokenMetadata . updateTopology ( ) ; allEndpoints = topology . getDatacenterEndpoints ( ) ; assertNotNull ( allEndpoints ) ; assertTrue ( allEndpoints . size ( ) = = <int> ) ; assertTrue ( allEndpoints . containsKey ( DATA_CENTER ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( first ) ) ; assertTrue ( allEndpoints . get ( DATA_CENTER ) . contains ( second ) ) ; racks = topology . getDatacenterRacks ( ) ; assertNotNull ( racks ) ; assertTrue ( racks . size ( ) = = <int> ) ; assertTrue ( racks . containsKey ( DATA_CENTER ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . size ( ) = = <int> ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK1 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . containsKey ( RACK2 ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK1 ) . contains ( first ) ) ; assertTrue ( racks . get ( DATA_CENTER ) . get ( RACK2 ) . contains ( second ) ) ; } } 
