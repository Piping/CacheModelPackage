package org . gradle . model . internal . inspect ; import org . gradle . internal . BiAction ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . model . RuleSource ; import org . gradle . model . Rules ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . model . internal . type . ModelType ; import java . util . Collections ; import java . util . List ; public class RuleDefinitionRuleExtractor extends AbstractAnnotationDrivenModelRuleExtractor < Rules > { private static final ModelType < RuleSource > RULE_SOURCE_MODEL_TYPE = ModelType . of ( RuleSource . class ) ; @Override public < R , S > ExtractedModelRule registration ( final MethodRuleDefinition < R , S > ruleDefinition , ValidationProblemCollector problems ) { validateIsVoidMethod ( ruleDefinition , problems ) ; if ( ruleDefinition . getReferences ( ) . size ( ) < <int> ) { problems . add ( ruleDefinition , <str> + getDescription ( ) + <str> ) ; return null ; } ModelType < ? > ruleType = ruleDefinition . getReferences ( ) . get ( <int> ) . getType ( ) ; if ( ! RULE_SOURCE_MODEL_TYPE . isAssignableFrom ( ruleType ) ) { problems . add ( ruleDefinition , <str> + getDescription ( ) + <str> ) ; } if ( problems . hasProblems ( ) ) { return null ; } final ModelType < ? extends RuleSource > ruleSourceType = ruleType . asSubtype ( RULE_SOURCE_MODEL_TYPE ) ; return new ExtractedModelRule ( ) { @Override public void apply ( ModelRegistry modelRegistry , ModelPath scope ) { final ModelReference < ? > targetReference = ruleDefinition . getReferences ( ) . get ( <int> ) ; List < ModelReference < ? > > inputs = ruleDefinition . getReferences ( ) . subList ( <int> , ruleDefinition . getReferences ( ) . size ( ) ) ; modelRegistry . configure ( ModelActionRole . Defaults , DirectNodeInputUsingModelAction . of ( targetReference , ruleDefinition . getDescriptor ( ) , inputs , new BiAction < MutableModelNode , List < ModelView < ? > > > ( ) { @Override public void execute ( MutableModelNode subjectNode , List < ModelView < ? > > modelViews ) { Object [ ] parameters = new Object [ <int> + modelViews . size ( ) ] ; parameters [ <int> ] = DirectInstantiator . INSTANCE . newInstance ( ruleSourceType . getConcreteClass ( ) ) ; parameters [ <int> ] = subjectNode . asImmutable ( targetReference . getType ( ) , ruleDefinition . getDescriptor ( ) ) . getInstance ( ) ; for ( int i = <int> ; i < parameters . length ; i + + ) { parameters [ i ] = modelViews . get ( i ) . getInstance ( ) ; } ruleDefinition . getRuleInvoker ( ) . invoke ( parameters ) ; subjectNode . applyToSelf ( ruleSourceType . getConcreteClass ( ) ) ; } } ) ) ; } @Override public List < ? extends Class < ? > > getRuleDependencies ( ) { return Collections . emptyList ( ) ; } } ; } } 
