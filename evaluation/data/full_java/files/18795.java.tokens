package io . netty . buffer ; import org . junit . Test ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . ArrayList ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import static io . netty . buffer . Unpooled . * ; import static io . netty . util . ReferenceCountUtil . * ; import static io . netty . util . internal . EmptyArrays . * ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public abstract class AbstractCompositeByteBufTest extends AbstractByteBufTest { private final ByteOrder order ; protected AbstractCompositeByteBufTest ( ByteOrder order ) { if ( order = = null ) { throw new NullPointerException ( <str> ) ; } this . order = order ; } @Override protected ByteBuf newBuffer ( int length ) { List < ByteBuf > buffers = new ArrayList < ByteBuf > ( ) ; for ( int i = <int> ; i < length + <int> ; i + = <int> ) { buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; buffers . add ( wrappedBuffer ( new byte [ <int> ] ) ) ; buffers . add ( EMPTY_BUFFER ) ; } ByteBuf buffer = wrappedBuffer ( Integer . MAX_VALUE , buffers . toArray ( new ByteBuf [ buffers . size ( ) ] ) ) . order ( order ) ; buffer . capacity ( length ) ; assertEquals ( length , buffer . capacity ( ) ) ; assertEquals ( length , buffer . readableBytes ( ) ) ; assertFalse ( buffer . isWritable ( ) ) ; buffer . writerIndex ( <int> ) ; return buffer ; } @Override protected boolean discardReadBytesDoesNotMoveWritableBytes ( ) { return false ; } @Test public void testComponentAtOffset ( ) { CompositeByteBuf buf = releaseLater ( ( CompositeByteBuf ) wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) ; assertEquals ( <int> , buf . componentAtOffset ( <int> ) . capacity ( ) ) ; byte index = <int> ; while ( index < buf . capacity ( ) ) { ByteBuf _buf = buf . componentAtOffset ( index + + ) ; assertNotNull ( _buf ) ; assertTrue ( _buf . capacity ( ) > <int> ) ; assertNotNull ( _buf . getByte ( <int> ) ) ; assertNotNull ( _buf . getByte ( _buf . readableBytes ( ) - <int> ) ) ; } } @Test public void testDiscardReadBytes3 ( ) { ByteBuf a , b ; a = wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) ) ) ; a . skipBytes ( <int> ) ; a . markReaderIndex ( ) ; b . skipBytes ( <int> ) ; b . markReaderIndex ( ) ; assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; a . readerIndex ( a . readerIndex ( ) - <int> ) ; b . readerIndex ( b . readerIndex ( ) - <int> ) ; assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; a . writerIndex ( a . writerIndex ( ) - <int> ) ; a . markWriterIndex ( ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . markWriterIndex ( ) ; assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; a . writerIndex ( a . writerIndex ( ) + <int> ) ; b . writerIndex ( b . writerIndex ( ) + <int> ) ; assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a . discardReadBytes ( ) ; b . discardReadBytes ( ) ; assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a . resetReaderIndex ( ) ; b . resetReaderIndex ( ) ; assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; a . resetWriterIndex ( ) ; b . resetWriterIndex ( ) ; assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; } @Test public void testAutoConsolidation ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( <int> ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; assertTrue ( buf . hasArray ( ) ) ; assertNotNull ( buf . array ( ) ) ; assertEquals ( <int> , buf . arrayOffset ( ) ) ; } @Test public void testCompositeToSingleBuffer ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( <int> ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; ByteBuffer nioBuffer = buf . nioBuffer ( <int> , <int> ) ; byte [ ] bytes = nioBuffer . array ( ) ; assertEquals ( <int> , bytes . length ) ; assertArrayEquals ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , bytes ) ; } @Test public void testFullConsolidation ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( Integer . MAX_VALUE ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) ; buf . consolidate ( ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; assertTrue ( buf . hasArray ( ) ) ; assertNotNull ( buf . array ( ) ) ; assertEquals ( <int> , buf . arrayOffset ( ) ) ; } @Test public void testRangedConsolidation ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( Integer . MAX_VALUE ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } ) ) ; buf . consolidate ( <int> , <int> ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> } ) , buf . component ( <int> ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) , buf . component ( <int> ) ) ; assertEquals ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } ) , buf . component ( <int> ) ) ; } @Test public void testCompositeWrappedBuffer ( ) { ByteBuf header = releaseLater ( buffer ( <int> ) ) . order ( order ) ; ByteBuf payload = releaseLater ( buffer ( <int> ) ) . order ( order ) ; header . writeBytes ( new byte [ <int> ] ) ; payload . writeBytes ( new byte [ <int> ] ) ; ByteBuf buffer = releaseLater ( wrappedBuffer ( header , payload ) ) ; assertEquals ( <int> , header . readableBytes ( ) ) ; assertEquals ( <int> , payload . readableBytes ( ) ) ; assertEquals ( <int> + <int> , buffer . readableBytes ( ) ) ; assertEquals ( <int> , buffer . nioBufferCount ( ) ) ; } @Test public void testSeveralBuffersEquals ( ) { ByteBuf a , b ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } ) . order ( order ) ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) . order ( order ) ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) . order ( order ) ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; } @Test public void testWrappedBuffer ( ) { assertEquals ( <int> , wrappedBuffer ( wrappedBuffer ( ByteBuffer . allocateDirect ( <int> ) ) ) . capacity ( ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , wrappedBuffer ( wrappedBuffer ( new byte [ ] [ ] { new byte [ ] { <int> , <int> , <int> } } ) . order ( order ) ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } , new byte [ ] { <int> } , new byte [ ] { <int> } ) . order ( order ) ) ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , wrappedBuffer ( new ByteBuf [ ] { wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) } ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) , wrappedBuffer ( new byte [ ] { <int> } ) . order ( order ) ) ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , wrappedBuffer ( wrappedBuffer ( new ByteBuffer [ ] { ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> } ) } ) ) ) ; assertEquals ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) . order ( order ) ) , releaseLater ( wrappedBuffer ( wrappedBuffer ( ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) , ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ) ) ; } @Test public void testWrittenBuffersEquals ( ) { ByteBuf a , b ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> } , new byte [ <int> ] ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) ) . order ( order ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> } , new byte [ <int> ] ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) ) . order ( order ) ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) ) . order ( order ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) . order ( order ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> } , new byte [ <int> ] ) ) . order ( order ) ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> } ) ) . order ( order ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) . order ( order ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } , new byte [ <int> ] ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> } ) ) . order ( order ) ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> } ) ) . order ( order ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) . order ( order ) ) ; assertTrue ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } , new byte [ <int> ] ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) ) . order ( order ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; a = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ) . order ( order ) ; b = releaseLater ( wrappedBuffer ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) ) . order ( order ) ) ; b . writerIndex ( b . writerIndex ( ) - <int> ) ; b . writeBytes ( releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , <int> , <int> ) ) . order ( order ) ) ; assertFalse ( ByteBufUtil . equals ( a , b ) ) ; } @Test public void testEmptyBuffer ( ) { ByteBuf b = releaseLater ( wrappedBuffer ( new byte [ ] { <int> , <int> } , new byte [ ] { <int> , <int> } ) ) ; b . readBytes ( new byte [ <int> ] ) ; b . readBytes ( EMPTY_BYTES ) ; } @Test public void testReadWithEmptyCompositeBuffer ( ) { ByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; int n = <int> ; for ( int i = <int> ; i < n ; i + + ) { buf . writeByte ( <int> ) ; assertEquals ( <int> , buf . readByte ( ) ) ; } } @Test public void testComponentMustBeSlice ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( buffer ( <int> ) . setIndex ( <int> , <int> ) ) ; assertThat ( buf . component ( <int> ) , is ( instanceOf ( SlicedByteBuf . class ) ) ) ; assertThat ( buf . component ( <int> ) . capacity ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . maxCapacity ( ) , is ( <int> ) ) ; } @Test public void testReferenceCounts1 ( ) { ByteBuf c1 = buffer ( ) . writeByte ( <int> ) ; ByteBuf c2 = buffer ( ) . writeByte ( <int> ) . retain ( ) ; ByteBuf c3 = buffer ( ) . writeByte ( <int> ) . retain ( <int> ) ; CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; assertThat ( buf . refCnt ( ) , is ( <int> ) ) ; buf . addComponents ( c1 , c2 , c3 ) ; assertThat ( buf . refCnt ( ) , is ( <int> ) ) ; assertThat ( c1 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c2 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c3 . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; c3 . release ( <int> ) ; c2 . release ( ) ; } @Test public void testReferenceCounts2 ( ) { ByteBuf c1 = buffer ( ) . writeByte ( <int> ) ; ByteBuf c2 = buffer ( ) . writeByte ( <int> ) . retain ( ) ; ByteBuf c3 = buffer ( ) . writeByte ( <int> ) . retain ( <int> ) ; CompositeByteBuf bufA = compositeBuffer ( ) ; bufA . addComponents ( c1 , c2 , c3 ) . writerIndex ( <int> ) ; CompositeByteBuf bufB = compositeBuffer ( ) ; bufB . addComponents ( bufA ) ; assertThat ( bufA . refCnt ( ) , is ( <int> ) ) ; assertThat ( c1 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c2 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c3 . refCnt ( ) , is ( <int> ) ) ; bufB . release ( ) ; assertThat ( bufB . refCnt ( ) , is ( <int> ) ) ; assertThat ( bufA . refCnt ( ) , is ( <int> ) ) ; assertThat ( c1 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c2 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c3 . refCnt ( ) , is ( <int> ) ) ; c3 . release ( <int> ) ; c2 . release ( ) ; } @Test public void testReferenceCounts3 ( ) { ByteBuf c1 = buffer ( ) . writeByte ( <int> ) ; ByteBuf c2 = buffer ( ) . writeByte ( <int> ) . retain ( ) ; ByteBuf c3 = buffer ( ) . writeByte ( <int> ) . retain ( <int> ) ; CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; assertThat ( buf . refCnt ( ) , is ( <int> ) ) ; List < ByteBuf > components = new ArrayList < ByteBuf > ( ) ; Collections . addAll ( components , c1 , c2 , c3 ) ; buf . addComponents ( components ) ; assertThat ( c1 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c2 . refCnt ( ) , is ( <int> ) ) ; assertThat ( c3 . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; assertThat ( buf . component ( <int> ) . refCnt ( ) , is ( <int> ) ) ; c3 . release ( <int> ) ; c2 . release ( ) ; } @Test public void testNestedLayout ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( compositeBuffer ( ) . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) . slice ( <int> , <int> ) ) ; ByteBuffer [ ] nioBuffers = buf . nioBuffers ( <int> , <int> ) ; assertThat ( nioBuffers . length , is ( <int> ) ) ; assertThat ( nioBuffers [ <int> ] . remaining ( ) , is ( <int> ) ) ; assertThat ( nioBuffers [ <int> ] . get ( ) , is ( ( byte ) <int> ) ) ; assertThat ( nioBuffers [ <int> ] . remaining ( ) , is ( <int> ) ) ; assertThat ( nioBuffers [ <int> ] . get ( ) , is ( ( byte ) <int> ) ) ; } @Test public void testRemoveLastComponent ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . removeComponent ( <int> ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; } @Test public void testCopyEmpty ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; assertEquals ( <int> , releaseLater ( buf . copy ( ) ) . readableBytes ( ) ) ; } @Test public void testDuplicateEmpty ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; assertEquals ( <int> , releaseLater ( buf . duplicate ( ) ) . readableBytes ( ) ) ; } @Test public void testRemoveLastComponentWithOthersLeft ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; buf . addComponent ( wrappedBuffer ( new byte [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; buf . removeComponent ( <int> ) ; assertEquals ( <int> , buf . numComponents ( ) ) ; } @Test public void testGatheringWritesHeap ( ) throws Exception { testGatheringWrites ( buffer ( ) . order ( order ) , buffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesDirect ( ) throws Exception { testGatheringWrites ( directBuffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesMixes ( ) throws Exception { testGatheringWrites ( buffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesHeapPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesDirectPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesMixesPooled ( ) throws Exception { testGatheringWrites ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) ) ; } private static void testGatheringWrites ( ByteBuf buf1 , ByteBuf buf2 ) throws Exception { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( buf1 . writeBytes ( new byte [ ] { <int> , <int> } ) ) ; buf . addComponent ( buf2 . writeBytes ( new byte [ ] { <int> , <int> } ) ) ; buf . writerIndex ( <int> ) ; buf . readerIndex ( <int> ) ; TestGatheringByteChannel channel = new TestGatheringByteChannel ( ) ; buf . readBytes ( channel , <int> ) ; byte [ ] data = new byte [ <int> ] ; buf . getBytes ( <int> , data ) ; assertArrayEquals ( data , channel . writtenBytes ( ) ) ; } @Test public void testGatheringWritesPartialHeap ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) . order ( order ) , buffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialDirect ( ) throws Exception { testGatheringWritesPartial ( directBuffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialMixes ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialHeapSlice ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) . order ( order ) , buffer ( ) . order ( order ) , true ) ; } @Test public void testGatheringWritesPartialDirectSlice ( ) throws Exception { testGatheringWritesPartial ( directBuffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) , true ) ; } @Test public void testGatheringWritesPartialMixesSlice ( ) throws Exception { testGatheringWritesPartial ( buffer ( ) . order ( order ) , directBuffer ( ) . order ( order ) , true ) ; } @Test public void testGatheringWritesPartialHeapPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialDirectPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialMixesPooled ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , false ) ; } @Test public void testGatheringWritesPartialHeapPooledSliced ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , true ) ; } @Test public void testGatheringWritesPartialDirectPooledSliced ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , true ) ; } @Test public void testGatheringWritesPartialMixesPooledSliced ( ) throws Exception { testGatheringWritesPartial ( PooledByteBufAllocator . DEFAULT . heapBuffer ( ) . order ( order ) , PooledByteBufAllocator . DEFAULT . directBuffer ( ) . order ( order ) , true ) ; } private static void testGatheringWritesPartial ( ByteBuf buf1 , ByteBuf buf2 , boolean slice ) throws Exception { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf1 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; buf2 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; if ( slice ) { buf1 = buf1 . readerIndex ( <int> ) . slice ( ) ; buf2 = buf2 . writerIndex ( <int> ) . slice ( ) ; buf . addComponent ( buf1 ) ; buf . addComponent ( buf2 ) ; buf . writerIndex ( <int> ) ; } else { buf . addComponent ( buf1 ) ; buf . addComponent ( buf2 ) ; buf . writerIndex ( <int> ) ; buf . readerIndex ( <int> ) ; } TestGatheringByteChannel channel = new TestGatheringByteChannel ( <int> ) ; while ( buf . isReadable ( ) ) { buf . readBytes ( channel , buf . readableBytes ( ) ) ; } byte [ ] data = new byte [ <int> ] ; if ( slice ) { buf . getBytes ( <int> , data ) ; } else { buf . getBytes ( <int> , data ) ; } assertArrayEquals ( data , channel . writtenBytes ( ) ) ; } @Test public void testGatheringWritesSingleHeap ( ) throws Exception { testGatheringWritesSingleBuf ( buffer ( ) . order ( order ) ) ; } @Test public void testGatheringWritesSingleDirect ( ) throws Exception { testGatheringWritesSingleBuf ( directBuffer ( ) . order ( order ) ) ; } private static void testGatheringWritesSingleBuf ( ByteBuf buf1 ) throws Exception { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; buf . addComponent ( buf1 . writeBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ) ; buf . writerIndex ( <int> ) ; buf . readerIndex ( <int> ) ; TestGatheringByteChannel channel = new TestGatheringByteChannel ( ) ; buf . readBytes ( channel , <int> ) ; byte [ ] data = new byte [ <int> ] ; buf . getBytes ( <int> , data ) ; assertArrayEquals ( data , channel . writtenBytes ( ) ) ; } @Override @Test public void testInternalNioBuffer ( ) { } @Test public void testisDirectMultipleBufs ( ) { CompositeByteBuf buf = releaseLater ( compositeBuffer ( ) ) ; assertFalse ( buf . isDirect ( ) ) ; buf . addComponent ( directBuffer ( ) . writeByte ( <int> ) ) ; assertTrue ( buf . isDirect ( ) ) ; buf . addComponent ( directBuffer ( ) . writeByte ( <int> ) ) ; assertTrue ( buf . isDirect ( ) ) ; buf . addComponent ( buffer ( ) . writeByte ( <int> ) ) ; assertFalse ( buf . isDirect ( ) ) ; } @Test public void testDiscardSomeReadBytes ( ) { CompositeByteBuf cbuf = releaseLater ( compositeBuffer ( ) ) ; int len = <int> * <int> ; for ( int i = <int> ; i < len ; i + = <int> ) { ByteBuf buf = buffer ( ) . writeInt ( i ) ; cbuf . capacity ( cbuf . writerIndex ( ) ) . addComponent ( buf ) . writerIndex ( i + <int> ) ; } cbuf . writeByte ( <int> ) ; byte [ ] me = new byte [ len ] ; cbuf . readBytes ( me ) ; cbuf . readByte ( ) ; cbuf . discardSomeReadBytes ( ) ; } @Test public void testAddEmptyBufferRelease ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; ByteBuf buf = buffer ( ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; cbuf . addComponent ( buf ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; cbuf . release ( ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; } @Test public void testAddEmptyBuffersRelease ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; ByteBuf buf = buffer ( ) ; ByteBuf buf2 = buffer ( ) . writeInt ( <int> ) ; ByteBuf buf3 = buffer ( ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; assertEquals ( <int> , buf2 . refCnt ( ) ) ; assertEquals ( <int> , buf3 . refCnt ( ) ) ; cbuf . addComponents ( buf , buf2 , buf3 ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; assertEquals ( <int> , buf2 . refCnt ( ) ) ; assertEquals ( <int> , buf3 . refCnt ( ) ) ; cbuf . release ( ) ; assertEquals ( <int> , buf . refCnt ( ) ) ; assertEquals ( <int> , buf2 . refCnt ( ) ) ; assertEquals ( <int> , buf3 . refCnt ( ) ) ; } @Test public void testAddEmptyBufferInMiddle ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; ByteBuf buf1 = buffer ( ) . writeByte ( ( byte ) <int> ) ; cbuf . addComponent ( buf1 ) . writerIndex ( cbuf . writerIndex ( ) + buf1 . readableBytes ( ) ) ; ByteBuf buf2 = EMPTY_BUFFER ; cbuf . addComponent ( buf2 ) . writerIndex ( cbuf . writerIndex ( ) + buf2 . readableBytes ( ) ) ; ByteBuf buf3 = buffer ( ) . writeByte ( ( byte ) <int> ) ; cbuf . addComponent ( buf3 ) . writerIndex ( cbuf . writerIndex ( ) + buf3 . readableBytes ( ) ) ; assertEquals ( <int> , cbuf . readableBytes ( ) ) ; assertEquals ( ( byte ) <int> , cbuf . readByte ( ) ) ; assertEquals ( ( byte ) <int> , cbuf . readByte ( ) ) ; assertSame ( EMPTY_BUFFER , cbuf . internalComponent ( <int> ) ) ; assertNotSame ( EMPTY_BUFFER , cbuf . internalComponentAtOffset ( <int> ) ) ; cbuf . release ( ) ; } @Test public void testIterator ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; cbuf . addComponent ( EMPTY_BUFFER ) ; cbuf . addComponent ( EMPTY_BUFFER ) ; Iterator < ByteBuf > it = cbuf . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertSame ( EMPTY_BUFFER , it . next ( ) ) ; assertTrue ( it . hasNext ( ) ) ; assertSame ( EMPTY_BUFFER , it . next ( ) ) ; assertFalse ( it . hasNext ( ) ) ; try { it . next ( ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } cbuf . release ( ) ; } @Test public void testEmptyIterator ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; Iterator < ByteBuf > it = cbuf . iterator ( ) ; assertFalse ( it . hasNext ( ) ) ; try { it . next ( ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } cbuf . release ( ) ; } @Test ( expected = ConcurrentModificationException . class ) public void testIteratorConcurrentModificationAdd ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; cbuf . addComponent ( EMPTY_BUFFER ) ; Iterator < ByteBuf > it = cbuf . iterator ( ) ; cbuf . addComponent ( EMPTY_BUFFER ) ; assertTrue ( it . hasNext ( ) ) ; try { it . next ( ) ; } finally { cbuf . release ( ) ; } } @Test ( expected = ConcurrentModificationException . class ) public void testIteratorConcurrentModificationRemove ( ) { CompositeByteBuf cbuf = compositeBuffer ( ) ; cbuf . addComponent ( EMPTY_BUFFER ) ; Iterator < ByteBuf > it = cbuf . iterator ( ) ; cbuf . removeComponent ( <int> ) ; assertTrue ( it . hasNext ( ) ) ; try { it . next ( ) ; } finally { cbuf . release ( ) ; } } } 
