package org . elasticsearch . cluster . routing . allocation . command ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . cluster . routing . allocation . RerouteExplanation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; public class AllocateAllocationCommand implements AllocationCommand { public static final String NAME = <str> ; public static class Factory implements AllocationCommand . Factory < AllocateAllocationCommand > { @Override public AllocateAllocationCommand readFrom ( StreamInput in ) throws IOException { return new AllocateAllocationCommand ( ShardId . readShardId ( in ) , in . readString ( ) , in . readBoolean ( ) ) ; } @Override public void writeTo ( AllocateAllocationCommand command , StreamOutput out ) throws IOException { command . shardId ( ) . writeTo ( out ) ; out . writeString ( command . node ( ) ) ; out . writeBoolean ( command . allowPrimary ( ) ) ; } @Override public AllocateAllocationCommand fromXContent ( XContentParser parser ) throws IOException { String index = null ; int shardId = - <int> ; String nodeId = null ; boolean allowPrimary = false ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { index = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { shardId = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { nodeId = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { allowPrimary = parser . booleanValue ( ) ; } else { throw new ElasticsearchParseException ( <str> , NAME , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , NAME , token ) ; } } if ( index = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( shardId = = - <int> ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( nodeId = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } return new AllocateAllocationCommand ( new ShardId ( index , shardId ) , nodeId , allowPrimary ) ; } @Override public void toXContent ( AllocateAllocationCommand command , XContentBuilder builder , ToXContent . Params params , String objectName ) throws IOException { if ( objectName = = null ) { builder . startObject ( ) ; } else { builder . startObject ( objectName ) ; } builder . field ( <str> , command . shardId ( ) . index ( ) . name ( ) ) ; builder . field ( <str> , command . shardId ( ) . id ( ) ) ; builder . field ( <str> , command . node ( ) ) ; builder . field ( <str> , command . allowPrimary ( ) ) ; builder . endObject ( ) ; } } private final ShardId shardId ; private final String node ; private final boolean allowPrimary ; public AllocateAllocationCommand ( ShardId shardId , String node , boolean allowPrimary ) { this . shardId = shardId ; this . node = node ; this . allowPrimary = allowPrimary ; } @Override public String name ( ) { return NAME ; } public ShardId shardId ( ) { return this . shardId ; } public String node ( ) { return this . node ; } public boolean allowPrimary ( ) { return this . allowPrimary ; } @Override public RerouteExplanation execute ( RoutingAllocation allocation , boolean explain ) { final DiscoveryNode discoNode = allocation . nodes ( ) . resolveNode ( node ) ; final RoutingNodes routingNodes = allocation . routingNodes ( ) ; ShardRouting shardRouting = null ; for ( ShardRouting routing : routingNodes . unassigned ( ) ) { if ( routing . shardId ( ) . equals ( shardId ) ) { if ( shardRouting = = null | | routing . primary ( ) ) { shardRouting = routing ; } } } if ( shardRouting = = null ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> ) ; } if ( shardRouting . primary ( ) & & ! allowPrimary ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> ) ; } RoutingNode routingNode = routingNodes . node ( discoNode . id ( ) ) ; if ( routingNode = = null ) { if ( ! discoNode . dataNode ( ) ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + node + <str> ) ) ; } throw new IllegalArgumentException ( <str> + node + <str> ) ; } else { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + node + <str> ) ) ; } throw new IllegalStateException ( <str> + node + <str> ) ; } } Decision decision = allocation . deciders ( ) . canAllocate ( shardRouting , routingNode , allocation ) ; if ( decision . type ( ) = = Decision . Type . NO ) { if ( explain ) { return new RerouteExplanation ( this , decision ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + discoNode + <str> + decision ) ; } for ( RoutingNodes . UnassignedShards . UnassignedIterator it = routingNodes . unassigned ( ) . iterator ( ) ; it . hasNext ( ) ; ) { ShardRouting unassigned = it . next ( ) ; if ( unassigned ! = shardRouting ) { continue ; } if ( unassigned . primary ( ) & & unassigned . unassignedInfo ( ) . getReason ( ) ! = UnassignedInfo . Reason . INDEX_CREATED ) { unassigned . updateUnassignedInfo ( new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> + unassigned . unassignedInfo ( ) . getReason ( ) + <str> + unassigned . unassignedInfo ( ) . getMessage ( ) , unassigned . unassignedInfo ( ) . getFailure ( ) , System . nanoTime ( ) , System . currentTimeMillis ( ) ) ) ; } it . initialize ( routingNode . nodeId ( ) , unassigned . version ( ) , allocation . clusterInfo ( ) . getShardSize ( unassigned , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; break ; } return new RerouteExplanation ( this , decision ) ; } } 
