package org . gradle . internal . concurrent ; import org . gradle . internal . Factories ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class ServiceLifecycle implements AsyncStoppable { private enum State { RUNNING , STOPPING , STOPPED } private final String displayName ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private State state = State . RUNNING ; private Map < Thread , Integer > usages = new HashMap < Thread , Integer > ( ) ; public ServiceLifecycle ( String displayName ) { this . displayName = displayName ; } public void use ( Runnable runnable ) { use ( Factories . toFactory ( runnable ) ) ; } public < T > T use ( Factory < T > factory ) { lock . lock ( ) ; try { switch ( state ) { case STOPPING : throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; case STOPPED : throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; } Integer depth = usages . get ( Thread . currentThread ( ) ) ; if ( depth = = null ) { usages . put ( Thread . currentThread ( ) , <int> ) ; } else { usages . put ( Thread . currentThread ( ) , depth + <int> ) ; } } finally { lock . unlock ( ) ; } try { return factory . create ( ) ; } finally { lock . lock ( ) ; try { Integer depth = usages . remove ( Thread . currentThread ( ) ) ; if ( depth > <int> ) { usages . put ( Thread . currentThread ( ) , depth - <int> ) ; } if ( usages . isEmpty ( ) ) { condition . signalAll ( ) ; if ( state = = State . STOPPING ) { state = State . STOPPED ; } } } finally { lock . unlock ( ) ; } } } public void requestStop ( ) { lock . lock ( ) ; try { if ( state = = State . RUNNING ) { if ( usages . isEmpty ( ) ) { state = State . STOPPED ; } else { state = State . STOPPING ; } } } finally { lock . unlock ( ) ; } } public void stop ( ) { lock . lock ( ) ; try { if ( usages . containsKey ( Thread . currentThread ( ) ) ) { throw new IllegalStateException ( String . format ( <str> , displayName ) ) ; } if ( state = = State . RUNNING ) { state = State . STOPPING ; } while ( ! usages . isEmpty ( ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } if ( state ! = State . STOPPED ) { state = State . STOPPED ; } } finally { lock . unlock ( ) ; } } } 
