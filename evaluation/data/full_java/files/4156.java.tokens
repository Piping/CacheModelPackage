package org . eclipse . debug . internal . ui . contextlaunching ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Map . Entry ; import java . util . Set ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchesListener2 ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . ILaunchHistoryChangedListener ; import org . eclipse . debug . internal . ui . ILaunchLabelChangedListener ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchConfigurationManager ; import org . eclipse . debug . internal . ui . launchConfigurations . LaunchShortcutExtension ; import org . eclipse . debug . internal . ui . stringsubstitution . SelectedResourceManager ; import org . eclipse . debug . ui . ILaunchGroup ; import org . eclipse . debug . ui . ILaunchShortcut ; import org . eclipse . jface . action . IContributionItem ; import org . eclipse . jface . action . ICoolBarManager ; import org . eclipse . jface . action . ToolBarContributionItem ; import org . eclipse . jface . action . ToolBarManager ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . MouseTrackAdapter ; import org . eclipse . swt . widgets . ToolBar ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . ISelectionListener ; import org . eclipse . ui . IWindowListener ; import org . eclipse . ui . IWorkbench ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . eclipse . ui . internal . WorkbenchWindow ; import com . ibm . icu . text . MessageFormat ; @SuppressWarnings ( <str> ) public class LaunchingResourceManager implements IPropertyChangeListener , IWindowListener , ISelectionListener , ILaunchHistoryChangedListener , ILaunchesListener2 { private ListenerList fLabelListeners = new ListenerList ( ) ; private HashMap < IWorkbenchWindow , ToolBar > fToolbars = new HashMap < IWorkbenchWindow , ToolBar > ( ) ; private HashMap < ILaunchGroup , String > fCurrentLabels = new HashMap < ILaunchGroup , String > ( ) ; private boolean fUpdateLabel = true ; private HashSet < IWorkbenchWindow > fWindows = new HashSet < IWorkbenchWindow > ( ) ; private HashMap < IResource , ILaunchConfiguration [ ] > fConfigCache = new HashMap < IResource , ILaunchConfiguration [ ] > ( ) ; private HashMap < IResource , List < LaunchShortcutExtension > > fExtCache = new HashMap < IResource , List < LaunchShortcutExtension > > ( ) ; private static final String EMPTY_STRING = IInternalDebugCoreConstants . EMPTY_STRING ; private MouseTrackAdapter fMouseListener = new MouseTrackAdapter ( ) { @Override public void mouseEnter ( MouseEvent e ) { if ( fUpdateLabel ) { fUpdateLabel = false ; fCurrentLabels . clear ( ) ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { computeLabels ( ) ; fConfigCache . clear ( ) ; fExtCache . clear ( ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } } } ; public static boolean isContextLaunchEnabled ( ) { return DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_USE_CONTEXTUAL_LAUNCH ) ; } public static boolean isContextLaunchEnabled ( String launchgroupid ) { return isContextLaunchEnabled ( ) & & ! <str> . equals ( launchgroupid ) ; } public void addLaunchLabelUpdateListener ( ILaunchLabelChangedListener listener ) { fLabelListeners . add ( listener ) ; } public void removeLaunchLabelChangedListener ( ILaunchLabelChangedListener listener ) { fLabelListeners . remove ( listener ) ; } public String getLaunchLabel ( ILaunchGroup group ) { return fCurrentLabels . get ( group ) ; } protected boolean shouldCheckParent ( ) { return DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_LAUNCH_PARENT_PROJECT ) ; } protected boolean shouldLaunchLast ( ) { return DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IInternalDebugUIConstants . PREF_LAUNCH_LAST_IF_NOT_LAUNCHABLE ) ; } protected void computeLabels ( ) { ILaunchGroup group = null ; ILaunchConfiguration config = null ; String label = null ; Object [ ] listeners = fLabelListeners . getListeners ( ) ; SelectedResourceManager srm = SelectedResourceManager . getDefault ( ) ; IStructuredSelection selection = srm . getCurrentSelection ( ) ; List < LaunchShortcutExtension > shortcuts = null ; IResource resource = srm . getSelectedResource ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { group = ( ( ILaunchLabelChangedListener ) listeners [ i ] ) . getLaunchGroup ( ) ; if ( group ! = null ) { if ( isContextLaunchEnabled ( group . getIdentifier ( ) ) ) { shortcuts = getShortcutsForSelection ( selection , group . getMode ( ) ) ; if ( resource = = null ) { resource = getLaunchableResource ( shortcuts , selection ) ; } label = getLabel ( selection , resource , shortcuts , group ) ; } else { config = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getFilteredLastLaunch ( group . getIdentifier ( ) ) ; if ( config ! = null ) { label = appendLaunched ( config ) ; } } fCurrentLabels . put ( group , label ) ; label = null ; } } notifyLabelChanged ( ) ; } protected void notifyLabelChanged ( ) { Object [ ] listeners = fLabelListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { ( ( ILaunchLabelChangedListener ) listeners [ i ] ) . labelChanged ( ) ; } } private String appendLaunched ( ILaunchConfiguration config ) { ILaunch [ ] launches = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunches ( ) ; boolean launched = false ; ILaunchConfiguration tmp = null ; for ( int i = <int> ; i < launches . length ; i + + ) { tmp = launches [ i ] . getLaunchConfiguration ( ) ; if ( tmp ! = null ) { if ( ! launches [ i ] . isTerminated ( ) & & tmp . equals ( config ) ) { launched = true ; break ; } } } if ( launched ) { return MessageFormat . format ( ContextMessages . LaunchingResourceManager_0 , new Object [ ] { config . getName ( ) } ) ; } return config . getName ( ) ; } protected String getlastLaunchedLabel ( ILaunchGroup group ) { ILaunchConfiguration config = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getFilteredLastLaunch ( group . getIdentifier ( ) ) ; if ( config ! = null ) { return appendLaunched ( config ) ; } return EMPTY_STRING ; } protected String getLabel ( IStructuredSelection selection , IResource resource , List < LaunchShortcutExtension > shortcuts , ILaunchGroup group ) { List < LaunchShortcutExtension > sc = pruneShortcuts ( shortcuts , resource , group . getMode ( ) ) ; LaunchConfigurationManager lcm = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) ; ILaunchConfiguration config = lcm . isSharedConfig ( resource ) ; if ( config ! = null ) { return appendLaunched ( config ) ; } List < ILaunchConfiguration > configs = getParticipatingLaunchConfigurations ( selection , resource , sc , group . getMode ( ) ) ; int csize = configs . size ( ) ; if ( csize = = <int> ) { return appendLaunched ( configs . get ( <int> ) ) ; } else if ( csize > <int> ) { config = lcm . getMRUConfiguration ( configs , group , resource ) ; if ( config ! = null ) { return appendLaunched ( config ) ; } else { return ContextMessages . ContextRunner_14 ; } } else { List < LaunchShortcutExtension > exts = fExtCache . get ( resource ) ; if ( exts = = null & & resource ! = null ) { fExtCache . put ( resource , sc ) ; } int esize = sc . size ( ) ; if ( esize = = <int> ) { if ( resource ! = null & & shouldCheckParent ( ) ) { IProject project = resource . getProject ( ) ; if ( project ! = null & & ! project . equals ( resource ) ) { return getLabel ( selection , project , sc , group ) ; } } else if ( shouldLaunchLast ( ) | | resource = = null ) { return getlastLaunchedLabel ( group ) ; } else { return ContextMessages . ContextRunner_15 ; } } if ( esize = = <int> ) { if ( resource ! = null ) { return resource . getName ( ) ; } else { return MessageFormat . format ( ContextMessages . LaunchingResourceManager_1 , new Object [ ] { sc . get ( <int> ) . getLabel ( ) } ) ; } } else { return ContextMessages . ContextRunner_14 ; } } } protected List < LaunchShortcutExtension > pruneShortcuts ( List < LaunchShortcutExtension > shortcuts , IResource resource , String mode ) { List < LaunchShortcutExtension > list = new ArrayList < LaunchShortcutExtension > ( shortcuts ) ; if ( resource = = null ) { LaunchShortcutExtension ext = null ; for ( ListIterator < LaunchShortcutExtension > iter = list . listIterator ( ) ; iter . hasNext ( ) ; ) { ext = iter . next ( ) ; if ( ! ext . isParticipant ( ) ) { iter . remove ( ) ; } } } else { list = getShortcutsForSelection ( new StructuredSelection ( resource ) , mode ) ; } return list ; } public IResource getLaunchableResource ( List < LaunchShortcutExtension > shortcuts , IStructuredSelection selection ) { if ( selection ! = null & & ! selection . isEmpty ( ) ) { ArrayList < IResource > resources = new ArrayList < IResource > ( ) ; IResource resource = null ; Object o = selection . getFirstElement ( ) ; for ( LaunchShortcutExtension ext : shortcuts ) { if ( o instanceof IEditorPart ) { resource = ext . getLaunchableResource ( ( IEditorPart ) o ) ; } else { resource = ext . getLaunchableResource ( selection ) ; } if ( resource ! = null & & ! resources . contains ( resource ) ) { resources . add ( resource ) ; resource = null ; } } if ( resources . size ( ) > <int> ) { return resources . get ( <int> ) ; } } return null ; } public List < LaunchShortcutExtension > getShortcutsForSelection ( IStructuredSelection selection , String mode ) { ArrayList < LaunchShortcutExtension > list = new ArrayList < LaunchShortcutExtension > ( ) ; List < LaunchShortcutExtension > sc = DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getLaunchShortcuts ( ) ; List < IEditorInput > ctxt = new ArrayList < IEditorInput > ( ) ; ctxt . addAll ( selection . toList ( ) ) ; Object o = selection . getFirstElement ( ) ; if ( o instanceof IEditorPart ) { ctxt . set ( <int> , ( ( IEditorPart ) o ) . getEditorInput ( ) ) ; } IEvaluationContext context = DebugUIPlugin . createEvaluationContext ( ctxt ) ; context . addVariable ( <str> , ctxt ) ; for ( LaunchShortcutExtension ext : sc ) { try { if ( ext . evalEnablementExpression ( context , ext . getContextualLaunchEnablementExpression ( ) ) & & ext . getModes ( ) . contains ( mode ) & & ! WorkbenchActivityHelper . filterItem ( ext ) ) { if ( ! list . contains ( ext ) ) { list . add ( ext ) ; } } } catch ( CoreException ce ) { } } return list ; } public List < ILaunchConfiguration > getParticipatingLaunchConfigurations ( IStructuredSelection selection , IResource resource , List < LaunchShortcutExtension > shortcuts , String mode ) { List < ILaunchConfiguration > configs = new ArrayList < ILaunchConfiguration > ( ) ; int voteDefault = <int> ; if ( selection ! = null ) { Object o = selection . getFirstElement ( ) ; LaunchShortcutExtension ext = null ; ILaunchConfiguration [ ] cfgs = null ; for ( int i = <int> ; i < shortcuts . size ( ) ; i + + ) { ext = shortcuts . get ( i ) ; if ( o instanceof IEditorPart ) { cfgs = ext . getLaunchConfigurations ( ( IEditorPart ) o ) ; } else { cfgs = ext . getLaunchConfigurations ( selection ) ; } if ( cfgs = = null ) { Set < String > types = ext . getAssociatedConfigurationTypes ( ) ; addAllToList ( configs , DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getApplicableLaunchConfigurations ( types . toArray ( new String [ types . size ( ) ] ) , resource ) ) ; voteDefault + + ; } else { if ( cfgs . length > <int> ) { for ( int j = <int> ; j < cfgs . length ; j + + ) { configs . add ( cfgs [ j ] ) ; } } } } } if ( voteDefault = = shortcuts . size ( ) ) { addAllToList ( configs , DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . getApplicableLaunchConfigurations ( null , resource ) ) ; } Iterator < ILaunchConfiguration > iterator = configs . iterator ( ) ; while ( iterator . hasNext ( ) ) { ILaunchConfiguration config = iterator . next ( ) ; try { Set < String > modes = config . getModes ( ) ; modes . add ( mode ) ; if ( ! config . getType ( ) . supportsModeCombination ( modes ) ) { iterator . remove ( ) ; } } catch ( CoreException e ) { } } return configs ; } private void addAllToList ( List < ILaunchConfiguration > list , ILaunchConfiguration [ ] configs ) { if ( list = = null | | configs = = null ) { return ; } for ( int i = <int> ; i < configs . length ; i + + ) { if ( ! list . contains ( configs [ i ] ) ) { list . add ( configs [ i ] ) ; } } } public void startup ( ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { workbench . addWindowListener ( this ) ; IWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; for ( int i = <int> ; i < workbenchWindows . length ; i + + ) { if ( workbenchWindows [ i ] . getSelectionService ( ) ! = null ) { windowOpened ( workbenchWindows [ i ] ) ; } } } DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . addPropertyChangeListener ( this ) ; DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . addLaunchHistoryListener ( this ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunchListener ( this ) ; } public void shutdown ( ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { workbench . removeWindowListener ( this ) ; } DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . removePropertyChangeListener ( this ) ; DebugUIPlugin . getDefault ( ) . getLaunchConfigurationManager ( ) . removeLaunchHistoryListener ( this ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunchListener ( this ) ; for ( IWorkbenchWindow window : fWindows ) { window . getSelectionService ( ) . removeSelectionListener ( this ) ; } fUpdateLabel = false ; for ( Entry < IWorkbenchWindow , ToolBar > entry : fToolbars . entrySet ( ) ) { final ToolBar bar = entry . getValue ( ) ; if ( bar ! = null & & ! bar . isDisposed ( ) ) { final MouseTrackAdapter listener = fMouseListener ; DebugUIPlugin . getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { bar . removeMouseTrackListener ( listener ) ; } } ) ; } } fWindows . clear ( ) ; fToolbars . clear ( ) ; fLabelListeners . clear ( ) ; fCurrentLabels . clear ( ) ; } @Override public void windowActivated ( IWorkbenchWindow window ) { if ( ! fToolbars . containsKey ( window ) ) { addMouseListener ( window ) ; } } @Override public void windowClosed ( IWorkbenchWindow window ) { ToolBar bar = fToolbars . remove ( window ) ; if ( bar ! = null & & ! bar . isDisposed ( ) ) { bar . removeMouseTrackListener ( fMouseListener ) ; } if ( fWindows . remove ( window ) ) { window . getSelectionService ( ) . removeSelectionListener ( this ) ; } } @Override public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { if ( fWindows . add ( window ) ) { window . getSelectionService ( ) . addSelectionListener ( this ) ; } } private void addMouseListener ( IWorkbenchWindow window ) { ICoolBarManager cmgr = ( ( WorkbenchWindow ) window ) . getCoolBarManager2 ( ) ; if ( cmgr ! = null ) { IContributionItem item = cmgr . find ( <str> ) ; if ( item instanceof ToolBarContributionItem ) { ToolBarManager tmgr = ( ToolBarManager ) ( ( ToolBarContributionItem ) item ) . getToolBarManager ( ) ; ToolBar bar = tmgr . getControl ( ) ; if ( bar ! = null & & ! bar . isDisposed ( ) ) { bar . addMouseTrackListener ( fMouseListener ) ; fToolbars . put ( window , bar ) ; } } } } @Override public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( IInternalDebugUIConstants . PREF_USE_CONTEXTUAL_LAUNCH ) | | event . getProperty ( ) . equals ( IInternalDebugUIConstants . PREF_LAUNCH_LAST_IF_NOT_LAUNCHABLE ) ) { if ( isContextLaunchEnabled ( ) ) { windowActivated ( DebugUIPlugin . getActiveWorkbenchWindow ( ) ) ; } fUpdateLabel = true ; } } @Override public void selectionChanged ( IWorkbenchPart part , ISelection selection ) { if ( isContextLaunchEnabled ( ) ) { fUpdateLabel = true ; } } @Override public void launchHistoryChanged ( ) { fUpdateLabel = true ; } @Override public void launchesTerminated ( ILaunch [ ] launches ) { fUpdateLabel = true ; } @Override public void launchesAdded ( ILaunch [ ] launches ) { fUpdateLabel = true ; } @Override public void launchesChanged ( ILaunch [ ] launches ) { } @Override public void launchesRemoved ( ILaunch [ ] launches ) { for ( int i = <int> ; i < launches . length ; i + + ) { if ( ! launches [ i ] . isTerminated ( ) ) { fUpdateLabel = true ; return ; } } } } 
