package org . elasticsearch . messy . tests ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . script . groovy . GroovyPlugin ; import org . elasticsearch . script . groovy . GroovyScriptEngineService ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram . Bucket ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . SimpleValue ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . bucketScript ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; @ESIntegTestCase.SuiteScopeTestCase public class BucketScriptTests extends ESIntegTestCase { private static final String FIELD_1_NAME = <str> ; private static final String FIELD_2_NAME = <str> ; private static final String FIELD_3_NAME = <str> ; private static final String FIELD_4_NAME = <str> ; private static int interval ; private static int numDocs ; private static int minNumber ; private static int maxNumber ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Collections . singleton ( GroovyPlugin . class ) ; } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; interval = randomIntBetween ( <int> , <int> ) ; numDocs = randomIntBetween ( <int> , <int> ) ; minNumber = - <int> ; maxNumber = <int> ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int docs = <int> ; docs < numDocs ; docs + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( newDocBuilder ( ) ) ) ; } client ( ) . preparePutIndexedScript ( ) . setId ( <str> ) . setScriptLang ( GroovyScriptEngineService . NAME ) . setSource ( <str> ) . get ( ) ; indexRandom ( true , builders ) ; ensureSearchable ( ) ; } private XContentBuilder newDocBuilder ( ) throws IOException { XContentBuilder jsonBuilder = jsonBuilder ( ) ; jsonBuilder . startObject ( ) ; jsonBuilder . field ( FIELD_1_NAME , randomIntBetween ( minNumber , maxNumber ) ) ; jsonBuilder . field ( FIELD_2_NAME , randomIntBetween ( minNumber , maxNumber ) ) ; jsonBuilder . field ( FIELD_3_NAME , randomIntBetween ( minNumber , maxNumber ) ) ; jsonBuilder . field ( FIELD_4_NAME , randomIntBetween ( minNumber , maxNumber ) ) ; jsonBuilder . endObject ( ) ; return jsonBuilder ; } public void testInlineScript ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue + field4SumValue ) ) ; } } } public void testInlineScript2 ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue / field4SumValue ) ) ; } } } public void testInlineScriptSingleVariable ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue ) ) ; } } } public void testInlineScriptNamedVars ( ) { Map < String , String > bucketsPathsMap = new HashMap < > ( ) ; bucketsPathsMap . put ( <str> , <str> ) ; bucketsPathsMap . put ( <str> , <str> ) ; bucketsPathsMap . put ( <str> , <str> ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPathsMap ( bucketsPathsMap ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue + field4SumValue ) ) ; } } } public void testInlineScriptWithParams ( ) { Map < String , Object > params = new HashMap < > ( ) ; params . put ( <str> , <int> ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , params ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( ( field2SumValue + field3SumValue + field4SumValue ) * <int> ) ) ; } } } public void testInlineScriptInsertZeros ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) . gapPolicy ( GapPolicy . INSERT_ZEROS ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( <float> ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue + field4SumValue ) ) ; } } } public void testIndexedScript ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INDEXED , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue + field4SumValue ) ) ; } } } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testPartiallyUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( histogram ( <str> ) . field ( FIELD_1_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( FIELD_2_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_3_NAME ) ) . subAggregation ( sum ( <str> ) . field ( FIELD_4_NAME ) ) . subAggregation ( bucketScript ( <str> ) . setBucketsPaths ( <str> , <str> , <str> ) . script ( new Script ( <str> , ScriptType . INLINE , null , null ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; if ( bucket . getDocCount ( ) = = <int> ) { SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , nullValue ( ) ) ; } else { Sum field2Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field2Sum , notNullValue ( ) ) ; double field2SumValue = field2Sum . getValue ( ) ; Sum field3Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field3Sum , notNullValue ( ) ) ; double field3SumValue = field3Sum . getValue ( ) ; Sum field4Sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( field4Sum , notNullValue ( ) ) ; double field4SumValue = field4Sum . getValue ( ) ; SimpleValue seriesArithmetic = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( seriesArithmetic , notNullValue ( ) ) ; double seriesArithmeticValue = seriesArithmetic . value ( ) ; assertThat ( seriesArithmeticValue , equalTo ( field2SumValue + field3SumValue + field4SumValue ) ) ; } } } } 
