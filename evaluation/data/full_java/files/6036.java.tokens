package org . elasticsearch . common . regex ; import org . elasticsearch . common . Strings ; import java . util . Locale ; import java . util . regex . Pattern ; public class Regex { public static final int UNICODE_CHARACTER_CLASS = <hex> ; public static boolean isSimpleMatchPattern ( String str ) { return str . indexOf ( <str> ) ! = - <int> ; } public static boolean isMatchAllPattern ( String str ) { return str . equals ( <str> ) ; } public static boolean simpleMatch ( String pattern , String str ) { if ( pattern = = null | | str = = null ) { return false ; } int firstIndex = pattern . indexOf ( <str> ) ; if ( firstIndex = = - <int> ) { return pattern . equals ( str ) ; } if ( firstIndex = = <int> ) { if ( pattern . length ( ) = = <int> ) { return true ; } int nextIndex = pattern . indexOf ( <str> , firstIndex + <int> ) ; if ( nextIndex = = - <int> ) { return str . endsWith ( pattern . substring ( <int> ) ) ; } else if ( nextIndex = = <int> ) { return simpleMatch ( pattern . substring ( <int> ) , str ) ; } String part = pattern . substring ( <int> , nextIndex ) ; int partIndex = str . indexOf ( part ) ; while ( partIndex ! = - <int> ) { if ( simpleMatch ( pattern . substring ( nextIndex ) , str . substring ( partIndex + part . length ( ) ) ) ) { return true ; } partIndex = str . indexOf ( part , partIndex + <int> ) ; } return false ; } return ( str . length ( ) > = firstIndex & & pattern . substring ( <int> , firstIndex ) . equals ( str . substring ( <int> , firstIndex ) ) & & simpleMatch ( pattern . substring ( firstIndex ) , str . substring ( firstIndex ) ) ) ; } public static boolean simpleMatch ( String [ ] patterns , String str ) { if ( patterns ! = null ) { for ( String pattern : patterns ) { if ( simpleMatch ( pattern , str ) ) { return true ; } } } return false ; } public static boolean simpleMatch ( String [ ] patterns , String [ ] types ) { if ( patterns ! = null & & types ! = null ) { for ( String type : types ) { for ( String pattern : patterns ) { if ( simpleMatch ( pattern , type ) ) { return true ; } } } } return false ; } public static Pattern compile ( String regex , String flags ) { int pFlags = flags = = null ? <int> : flagsFromString ( flags ) ; return Pattern . compile ( regex , pFlags ) ; } public static int flagsFromString ( String flags ) { int pFlags = <int> ; for ( String s : Strings . delimitedListToStringArray ( flags , <str> ) ) { if ( s . isEmpty ( ) ) { continue ; } s = s . toUpperCase ( Locale . ROOT ) ; if ( <str> . equals ( s ) ) { pFlags | = Pattern . CASE_INSENSITIVE ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . MULTILINE ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . DOTALL ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . UNICODE_CASE ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . CANON_EQ ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . UNIX_LINES ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . LITERAL ; } else if ( <str> . equals ( s ) ) { pFlags | = Pattern . COMMENTS ; } else if ( ( <str> . equals ( s ) ) | | ( <str> . equals ( s ) ) ) { pFlags | = UNICODE_CHARACTER_CLASS ; } else { throw new IllegalArgumentException ( <str> + s + <str> ) ; } } return pFlags ; } public static String flagsToString ( int flags ) { StringBuilder sb = new StringBuilder ( ) ; if ( ( flags & Pattern . CASE_INSENSITIVE ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . MULTILINE ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . DOTALL ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . UNICODE_CASE ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . CANON_EQ ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . UNIX_LINES ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . LITERAL ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & Pattern . COMMENTS ) ! = <int> ) { sb . append ( <str> ) ; } if ( ( flags & UNICODE_CHARACTER_CLASS ) ! = <int> ) { sb . append ( <str> ) ; } return sb . toString ( ) ; } } 
