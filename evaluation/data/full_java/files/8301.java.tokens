package org . elasticsearch . index . snapshots . blobstore ; import com . carrotsearch . randomizedtesting . generators . RandomInts ; import org . elasticsearch . test . ESTestCase ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . Random ; import static org . hamcrest . Matchers . equalTo ; public class SlicedInputStreamTests extends ESTestCase { public void testReadRandom ( ) throws IOException { int parts = randomIntBetween ( <int> , <int> ) ; ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; int numWriteOps = scaledRandomIntBetween ( <int> , <int> ) ; final long seed = randomLong ( ) ; Random random = new Random ( seed ) ; for ( int i = <int> ; i < numWriteOps ; i + + ) { switch ( random . nextInt ( <int> ) ) { case <int> : stream . write ( random . nextInt ( Byte . MAX_VALUE ) ) ; break ; default : stream . write ( randomBytes ( random ) ) ; break ; } } final CheckClosedInputStream [ ] streams = new CheckClosedInputStream [ parts ] ; byte [ ] bytes = stream . toByteArray ( ) ; int slice = bytes . length / parts ; int offset = <int> ; int length ; for ( int i = <int> ; i < parts ; i + + ) { length = i = = parts - <int> ? bytes . length - offset : slice ; streams [ i ] = new CheckClosedInputStream ( new ByteArrayInputStream ( bytes , offset , length ) ) ; offset + = length ; } SlicedInputStream input = new SlicedInputStream ( parts ) { @Override protected InputStream openSlice ( long slice ) throws IOException { return streams [ ( int ) slice ] ; } } ; random = new Random ( seed ) ; assertThat ( input . available ( ) , equalTo ( streams [ <int> ] . available ( ) ) ) ; for ( int i = <int> ; i < numWriteOps ; i + + ) { switch ( random . nextInt ( <int> ) ) { case <int> : assertThat ( random . nextInt ( Byte . MAX_VALUE ) , equalTo ( input . read ( ) ) ) ; break ; default : byte [ ] b = randomBytes ( random ) ; byte [ ] buffer = new byte [ b . length ] ; int read = readFully ( input , buffer ) ; assertThat ( b . length , equalTo ( read ) ) ; assertArrayEquals ( b , buffer ) ; break ; } } assertThat ( input . available ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < streams . length - <int> ; i + + ) { assertTrue ( streams [ i ] . closed ) ; } input . close ( ) ; for ( int i = <int> ; i < streams . length ; i + + ) { assertTrue ( streams [ i ] . closed ) ; } } private int readFully ( InputStream stream , byte [ ] buffer ) throws IOException { for ( int i = <int> ; i < buffer . length ; ) { int read = stream . read ( buffer , i , buffer . length - i ) ; if ( read = = - <int> ) { if ( i = = <int> ) { return - <int> ; } else { return i ; } } i + = read ; } return buffer . length ; } private byte [ ] randomBytes ( Random random ) { int length = RandomInts . randomIntBetween ( random , <int> , <int> ) ; byte [ ] data = new byte [ length ] ; random . nextBytes ( data ) ; return data ; } private static final class CheckClosedInputStream extends FilterInputStream { public boolean closed = false ; public CheckClosedInputStream ( InputStream in ) { super ( in ) ; } @Override public void close ( ) throws IOException { closed = true ; super . close ( ) ; } } } 
