package com . google . common . util . concurrent . testing ; import com . google . common . annotations . Beta ; import com . google . common . util . concurrent . CheckedFuture ; import com . google . common . util . concurrent . ListenableFuture ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; @Beta public abstract class AbstractCheckedFutureTest extends AbstractListenableFutureTest { protected abstract < V > CheckedFuture < V , ? > createCheckedFuture ( V value , Exception except , CountDownLatch waitOn ) ; protected abstract void checkCancelledException ( Exception e ) ; protected abstract void checkExecutionException ( Exception e ) ; protected abstract void checkInterruptedException ( Exception e ) ; @Override protected < V > ListenableFuture < V > createListenableFuture ( V value , Exception except , CountDownLatch waitOn ) { return createCheckedFuture ( value , except , waitOn ) ; } public void testCheckedGetThrowsApplicationExceptionOnCancellation ( ) { final CheckedFuture < Boolean , ? > future = createCheckedFuture ( Boolean . TRUE , null , latch ) ; assertFalse ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { future . cancel ( true ) ; } } ) . start ( ) ; try { future . checkedGet ( ) ; fail ( <str> ) ; } catch ( Exception e ) { checkCancelledException ( e ) ; } assertTrue ( future . isDone ( ) ) ; assertTrue ( future . isCancelled ( ) ) ; } public void testCheckedGetThrowsApplicationExceptionOnInterruption ( ) throws InterruptedException { final CheckedFuture < Boolean , ? > future = createCheckedFuture ( Boolean . TRUE , null , latch ) ; final CountDownLatch startingGate = new CountDownLatch ( <int> ) ; final CountDownLatch successLatch = new CountDownLatch ( <int> ) ; assertFalse ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; Thread getThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { startingGate . countDown ( ) ; try { future . checkedGet ( ) ; } catch ( Exception e ) { checkInterruptedException ( e ) ; successLatch . countDown ( ) ; } } } ) ; getThread . start ( ) ; assertTrue ( startingGate . await ( <int> , TimeUnit . MILLISECONDS ) ) ; getThread . interrupt ( ) ; assertTrue ( successLatch . await ( <int> , TimeUnit . MILLISECONDS ) ) ; assertFalse ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; } public void testCheckedGetThrowsApplicationExceptionOnError ( ) { final CheckedFuture < Boolean , ? > future = createCheckedFuture ( Boolean . TRUE , new Exception ( <str> ) , latch ) ; assertFalse ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { latch . countDown ( ) ; } } ) . start ( ) ; try { future . checkedGet ( ) ; fail ( ) ; } catch ( Exception e ) { checkExecutionException ( e ) ; } assertTrue ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; } } 
