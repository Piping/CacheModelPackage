package org . elasticsearch . index . query ; import org . apache . lucene . analysis . core . WhitespaceAnalyzer ; import org . apache . lucene . index . Fields ; import org . apache . lucene . index . MultiFields ; import org . apache . lucene . index . memory . MemoryIndex ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . termvectors . MultiTermVectorsItemResponse ; import org . elasticsearch . action . termvectors . MultiTermVectorsRequest ; import org . elasticsearch . action . termvectors . MultiTermVectorsResponse ; import org . elasticsearch . action . termvectors . TermVectorsRequest ; import org . elasticsearch . action . termvectors . TermVectorsResponse ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . lucene . search . MoreLikeThisQuery ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . query . MoreLikeThisQueryBuilder . Item ; import org . junit . Before ; import java . io . IOException ; import java . util . Arrays ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . Map ; import java . util . stream . Stream ; import static org . elasticsearch . index . query . QueryBuilders . moreLikeThisQuery ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; public class MoreLikeThisQueryBuilderTests extends AbstractQueryTestCase < MoreLikeThisQueryBuilder > { private static String [ ] randomFields ; private static Item [ ] randomLikeItems ; private static Item [ ] randomUnlikeItems ; @Before public void setup ( ) { randomFields = randomStringFields ( ) ; randomLikeItems = new Item [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < randomLikeItems . length ; i + + ) { randomLikeItems [ i ] = generateRandomItem ( ) ; } randomUnlikeItems = new Item [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < randomUnlikeItems . length ; i + + ) { randomUnlikeItems [ i ] = generateRandomItem ( ) ; } } private static String [ ] randomStringFields ( ) { String [ ] mappedStringFields = new String [ ] { STRING_FIELD_NAME , STRING_FIELD_NAME_2 } ; String [ ] unmappedStringFields = generateRandomStringArray ( <int> , <int> , false , false ) ; return Stream . concat ( Arrays . stream ( mappedStringFields ) , Arrays . stream ( unmappedStringFields ) ) . toArray ( String [ ] : : new ) ; } private Item generateRandomItem ( ) { String index = randomBoolean ( ) ? getIndex ( ) . getName ( ) : null ; String type = getRandomType ( ) ; Item item ; if ( randomBoolean ( ) ) { item = new Item ( index , type , randomAsciiOfLength ( <int> ) ) ; } else { item = new Item ( index , type , randomArtificialDoc ( ) ) ; } if ( randomBoolean ( ) ) { item . fields ( randomFrom ( randomFields ) ) ; } if ( randomBoolean ( ) ) { item . perFieldAnalyzer ( randomPerFieldAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { item . routing ( randomAsciiOfLength ( <int> ) ) ; } if ( randomBoolean ( ) ) { item . version ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { item . versionType ( randomFrom ( VersionType . values ( ) ) ) ; } return item ; } private XContentBuilder randomArtificialDoc ( ) { XContentBuilder doc ; try { doc = XContentFactory . jsonBuilder ( ) . startObject ( ) ; for ( String field : randomFields ) { doc . field ( field , randomAsciiOfLength ( <int> ) ) ; } } catch ( IOException e ) { throw new ElasticsearchException ( <str> ) ; } return doc ; } private Map < String , String > randomPerFieldAnalyzer ( ) { Map < String , String > perFieldAnalyzer = new HashMap < > ( ) ; for ( String field : randomFields ) { perFieldAnalyzer . put ( field , randomAnalyzer ( ) ) ; } return perFieldAnalyzer ; } @Override protected MoreLikeThisQueryBuilder doCreateTestQueryBuilder ( ) { MoreLikeThisQueryBuilder queryBuilder ; String [ ] likeTexts = null ; Item [ ] likeItems = null ; if ( randomBoolean ( ) ) { likeTexts = generateRandomStringArray ( <int> , <int> , false , false ) ; } else { likeItems = randomLikeItems ; } if ( randomBoolean ( ) ) { queryBuilder = new MoreLikeThisQueryBuilder ( likeTexts , likeItems ) ; } else { queryBuilder = new MoreLikeThisQueryBuilder ( randomFields , likeTexts , likeItems ) ; } if ( randomBoolean ( ) ) { queryBuilder . unlike ( generateRandomStringArray ( <int> , <int> , false , false ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . unlike ( randomUnlikeItems ) ; } if ( randomBoolean ( ) ) { queryBuilder . maxQueryTerms ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . minTermFreq ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . minDocFreq ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . maxDocFreq ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . minWordLength ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . maxWordLength ( randomInt ( <int> ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . stopWords ( generateRandomStringArray ( <int> , <int> , false , false ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . analyzer ( randomAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . minimumShouldMatch ( randomMinimumShouldMatch ( ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . boostTerms ( randomFloat ( ) * <int> ) ; } if ( randomBoolean ( ) ) { queryBuilder . include ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryBuilder . failOnUnsupportedField ( randomBoolean ( ) ) ; } return queryBuilder ; } @Override protected MultiTermVectorsResponse executeMultiTermVectors ( MultiTermVectorsRequest mtvRequest ) { try { MultiTermVectorsItemResponse [ ] responses = new MultiTermVectorsItemResponse [ mtvRequest . size ( ) ] ; int i = <int> ; for ( TermVectorsRequest request : mtvRequest ) { TermVectorsResponse response = new TermVectorsResponse ( request . index ( ) , request . type ( ) , request . id ( ) ) ; response . setExists ( true ) ; Fields generatedFields ; if ( request . doc ( ) ! = null ) { generatedFields = generateFields ( randomFields , request . doc ( ) . toUtf8 ( ) ) ; } else { generatedFields = generateFields ( request . selectedFields ( ) . toArray ( new String [ request . selectedFields ( ) . size ( ) ] ) , request . id ( ) ) ; } EnumSet < TermVectorsRequest . Flag > flags = EnumSet . of ( TermVectorsRequest . Flag . Positions , TermVectorsRequest . Flag . Offsets ) ; response . setFields ( generatedFields , request . selectedFields ( ) , flags , generatedFields ) ; responses [ i + + ] = new MultiTermVectorsItemResponse ( response , null ) ; } return new MultiTermVectorsResponse ( responses ) ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } } private static Fields generateFields ( String [ ] fieldNames , String text ) throws IOException { MemoryIndex index = new MemoryIndex ( ) ; for ( String fieldName : fieldNames ) { index . addField ( fieldName , text , new WhitespaceAnalyzer ( ) ) ; } return MultiFields . getFields ( index . createSearcher ( ) . getIndexReader ( ) ) ; } @Override protected void doAssertLuceneQuery ( MoreLikeThisQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( queryBuilder . likeItems ( ) ! = null & & queryBuilder . likeItems ( ) . length > <int> ) { assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; } else { assertThat ( query , instanceOf ( MoreLikeThisQuery . class ) ) ; } } public void testValidateEmptyFields ( ) { try { new MoreLikeThisQueryBuilder ( new String [ <int> ] , new String [ ] { <str> } , null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testValidateEmptyLike ( ) { String [ ] likeTexts = randomBoolean ( ) ? null : new String [ <int> ] ; Item [ ] likeItems = randomBoolean ( ) ? null : new Item [ <int> ] ; try { new MoreLikeThisQueryBuilder ( likeTexts , likeItems ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testUnsupportedFields ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String unsupportedField = randomFrom ( INT_FIELD_NAME , DOUBLE_FIELD_NAME , DATE_FIELD_NAME ) ; MoreLikeThisQueryBuilder queryBuilder = new MoreLikeThisQueryBuilder ( new String [ ] { unsupportedField } , new String [ ] { <str> } , null ) . failOnUnsupportedField ( true ) ; try { queryBuilder . toQuery ( createShardContext ( ) ) ; fail ( <str> + unsupportedField ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testMoreLikeThisBuilder ( ) throws Exception { Query parsedQuery = parseQuery ( moreLikeThisQuery ( new String [ ] { <str> , <str> } , new String [ ] { <str> } , null ) . minTermFreq ( <int> ) . maxQueryTerms ( <int> ) . buildAsBytes ( ) ) . toQuery ( createShardContext ( ) ) ; assertThat ( parsedQuery , instanceOf ( MoreLikeThisQuery . class ) ) ; MoreLikeThisQuery mltQuery = ( MoreLikeThisQuery ) parsedQuery ; assertThat ( mltQuery . getMoreLikeFields ( ) [ <int> ] , equalTo ( <str> ) ) ; assertThat ( mltQuery . getLikeText ( ) , equalTo ( <str> ) ) ; assertThat ( mltQuery . getMinTermFrequency ( ) , equalTo ( <int> ) ) ; assertThat ( mltQuery . getMaxQueryTerms ( ) , equalTo ( <int> ) ) ; } public void testItemSerialization ( ) throws IOException { Item expectedItem = generateRandomItem ( ) ; BytesStreamOutput output = new BytesStreamOutput ( ) ; expectedItem . writeTo ( output ) ; Item newItem = Item . readItemFrom ( StreamInput . wrap ( output . bytes ( ) ) ) ; assertEquals ( expectedItem , newItem ) ; } public void testItemFromXContent ( ) throws IOException { Item expectedItem = generateRandomItem ( ) ; String json = expectedItem . toXContent ( XContentFactory . jsonBuilder ( ) , ToXContent . EMPTY_PARAMS ) . string ( ) ; XContentParser parser = XContentFactory . xContent ( json ) . createParser ( json ) ; Item newItem = Item . parse ( parser , ParseFieldMatcher . STRICT , new Item ( ) ) ; assertEquals ( expectedItem , newItem ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; MoreLikeThisQueryBuilder parsed = ( MoreLikeThisQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <int> , parsed . fields ( ) . length ) ; assertEquals ( json , <str> , parsed . likeTexts ( ) [ <int> ] ) ; } } 
