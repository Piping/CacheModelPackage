package org . gradle . api . internal . changedetection . state ; import com . google . common . cache . * ; import org . gradle . api . internal . cache . HeapProportionalSizer ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . cache . internal . CacheDecorator ; import org . gradle . cache . internal . FileLock ; import org . gradle . cache . internal . MultiProcessSafePersistentIndexedCache ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; public class InMemoryTaskArtifactCache implements CacheDecorator { private final static Logger LOG = Logging . getLogger ( InMemoryTaskArtifactCache . class ) ; private final static Object NULL = new Object ( ) ; private static final Map < String , Integer > CACHE_CAPS = new CacheCapSizer ( ) . calculateCaps ( ) ; static class CacheCapSizer { private static final Map < String , Integer > DEFAULT_CAP_SIZES = new HashMap < String , Integer > ( ) ; static { DEFAULT_CAP_SIZES . put ( <str> , <int> ) ; DEFAULT_CAP_SIZES . put ( <str> , <int> ) ; DEFAULT_CAP_SIZES . put ( <str> , <int> ) ; DEFAULT_CAP_SIZES . put ( <str> , <int> ) ; DEFAULT_CAP_SIZES . put ( <str> , <int> ) ; } final HeapProportionalSizer sizer ; CacheCapSizer ( int maxHeapMB ) { this . sizer = maxHeapMB > <int> ? new HeapProportionalSizer ( maxHeapMB ) : new HeapProportionalSizer ( ) ; } CacheCapSizer ( ) { this ( <int> ) ; } public Map < String , Integer > calculateCaps ( ) { Map < String , Integer > capSizes = new HashMap < String , Integer > ( ) ; for ( Map . Entry < String , Integer > entry : DEFAULT_CAP_SIZES . entrySet ( ) ) { capSizes . put ( entry . getKey ( ) , sizer . scaleValue ( entry . getValue ( ) , <int> ) ) ; } return capSizes ; } } private final Object lock = new Object ( ) ; private final Cache < String , Cache < Object , Object > > cache = CacheBuilder . newBuilder ( ) . maximumSize ( CACHE_CAPS . size ( ) * <int> ) . build ( ) ; private final Map < String , FileLock . State > states = new HashMap < String , FileLock . State > ( ) ; public < K , V > MultiProcessSafePersistentIndexedCache < K , V > decorate ( final String cacheId , String cacheName , final MultiProcessSafePersistentIndexedCache < K , V > original ) { final Cache < Object , Object > data = loadData ( cacheId , cacheName ) ; return new MultiProcessSafePersistentIndexedCache < K , V > ( ) { public void close ( ) { original . close ( ) ; } public V get ( K key ) { assert key instanceof String | | key instanceof Long | | key instanceof File : <str> + key ; Object value = data . getIfPresent ( key ) ; if ( value = = NULL ) { return null ; } if ( value ! = null ) { return ( V ) value ; } V out = original . get ( key ) ; data . put ( key , out = = null ? NULL : out ) ; return out ; } public void put ( K key , V value ) { original . put ( key , value ) ; data . put ( key , value ) ; } public void remove ( K key ) { data . put ( key , NULL ) ; original . remove ( key ) ; } public void onStartWork ( String operationDisplayName , FileLock . State currentCacheState ) { boolean outOfDate ; synchronized ( lock ) { FileLock . State previousState = states . get ( cacheId ) ; outOfDate = previousState = = null | | currentCacheState . hasBeenUpdatedSince ( previousState ) ; } if ( outOfDate ) { LOG . info ( <str> , cacheId ) ; data . invalidateAll ( ) ; } } public void onEndWork ( FileLock . State currentCacheState ) { synchronized ( lock ) { states . put ( cacheId , currentCacheState ) ; } } } ; } private Cache < Object , Object > loadData ( String cacheId , String cacheName ) { Cache < Object , Object > theData ; synchronized ( lock ) { theData = this . cache . getIfPresent ( cacheId ) ; if ( theData ! = null ) { LOG . info ( <str> , cacheId , theData . size ( ) , theData . stats ( ) ) ; } else { Integer maxSize = CACHE_CAPS . get ( cacheName ) ; assert maxSize ! = null : <str> ; LOG . info ( <str> , cacheId , maxSize ) ; LoggingEvictionListener evictionListener = new LoggingEvictionListener ( cacheId , maxSize ) ; theData = CacheBuilder . newBuilder ( ) . maximumSize ( maxSize ) . recordStats ( ) . removalListener ( evictionListener ) . build ( ) ; evictionListener . setCache ( theData ) ; this . cache . put ( cacheId , theData ) ; } } return theData ; } private static class LoggingEvictionListener implements RemovalListener < Object , Object > { private static Logger logger = Logging . getLogger ( LoggingEvictionListener . class ) ; private static final String EVICTION_MITIGATION_MESSAGE = <str> ; volatile int evictionCounter ; private final String cacheId ; private Cache < Object , Object > cache ; private final int maxSize ; private final int logInterval ; private LoggingEvictionListener ( String cacheId , int maxSize ) { this . cacheId = cacheId ; this . maxSize = maxSize ; this . logInterval = maxSize / <int> ; } public void setCache ( Cache < Object , Object > cache ) { this . cache = cache ; } @Override public void onRemoval ( RemovalNotification < Object , Object > notification ) { if ( notification . getCause ( ) = = RemovalCause . SIZE ) { if ( evictionCounter % logInterval = = <int> ) { logger . log ( LogLevel . INFO , <str> , cacheId , cache . size ( ) , maxSize , cache . stats ( ) , EVICTION_MITIGATION_MESSAGE ) ; } evictionCounter + + ; } } } } 
