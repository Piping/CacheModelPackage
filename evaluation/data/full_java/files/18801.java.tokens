package io . netty . buffer ; import org . junit . Test ; import java . nio . ByteOrder ; import java . util . Random ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class ByteBufDerivationTest { @Test public void testSlice ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf slice = buf . slice ( <int> , <int> ) ; assertThat ( slice , instanceOf ( SlicedByteBuf . class ) ) ; assertThat ( slice . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( slice . readerIndex ( ) , is ( <int> ) ) ; assertThat ( slice . writerIndex ( ) , is ( <int> ) ) ; assertThat ( slice . capacity ( ) , is ( <int> ) ) ; assertThat ( slice . maxCapacity ( ) , is ( <int> ) ) ; slice . setIndex ( <int> , <int> ) ; assertThat ( buf . readerIndex ( ) , is ( <int> ) ) ; assertThat ( buf . writerIndex ( ) , is ( <int> ) ) ; } @Test public void testSliceOfSlice ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) ; ByteBuf slice = buf . slice ( <int> , <int> ) ; ByteBuf slice2 = slice . slice ( <int> , <int> ) ; assertThat ( slice2 , not ( sameInstance ( slice ) ) ) ; assertThat ( slice2 , instanceOf ( SlicedByteBuf . class ) ) ; assertThat ( slice2 . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( slice2 . writerIndex ( ) , is ( <int> ) ) ; assertThat ( slice2 . capacity ( ) , is ( <int> ) ) ; } @Test public void testDuplicate ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf dup = buf . duplicate ( ) ; assertThat ( dup , instanceOf ( DuplicatedByteBuf . class ) ) ; assertThat ( dup . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( dup . readerIndex ( ) , is ( buf . readerIndex ( ) ) ) ; assertThat ( dup . writerIndex ( ) , is ( buf . writerIndex ( ) ) ) ; assertThat ( dup . capacity ( ) , is ( buf . capacity ( ) ) ) ; assertThat ( dup . maxCapacity ( ) , is ( buf . maxCapacity ( ) ) ) ; dup . setIndex ( <int> , <int> ) ; assertThat ( buf . readerIndex ( ) , is ( <int> ) ) ; assertThat ( buf . writerIndex ( ) , is ( <int> ) ) ; } @Test public void testDuplicateOfDuplicate ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf dup = buf . duplicate ( ) . setIndex ( <int> , <int> ) ; ByteBuf dup2 = dup . duplicate ( ) ; assertThat ( dup2 , not ( sameInstance ( dup ) ) ) ; assertThat ( dup2 , instanceOf ( DuplicatedByteBuf . class ) ) ; assertThat ( dup2 . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( dup2 . readerIndex ( ) , is ( dup . readerIndex ( ) ) ) ; assertThat ( dup2 . writerIndex ( ) , is ( dup . writerIndex ( ) ) ) ; assertThat ( dup2 . capacity ( ) , is ( dup . capacity ( ) ) ) ; assertThat ( dup2 . maxCapacity ( ) , is ( dup . maxCapacity ( ) ) ) ; } @Test public void testReadOnly ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf ro = Unpooled . unmodifiableBuffer ( buf ) ; assertThat ( ro , instanceOf ( ReadOnlyByteBuf . class ) ) ; assertThat ( ro . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( ro . readerIndex ( ) , is ( buf . readerIndex ( ) ) ) ; assertThat ( ro . writerIndex ( ) , is ( buf . writerIndex ( ) ) ) ; assertThat ( ro . capacity ( ) , is ( buf . capacity ( ) ) ) ; assertThat ( ro . maxCapacity ( ) , is ( buf . maxCapacity ( ) ) ) ; ro . setIndex ( <int> , <int> ) ; assertThat ( buf . readerIndex ( ) , is ( <int> ) ) ; } @Test public void testReadOnlyOfReadOnly ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf ro = Unpooled . unmodifiableBuffer ( buf ) . setIndex ( <int> , <int> ) ; ByteBuf ro2 = Unpooled . unmodifiableBuffer ( ro ) ; assertThat ( ro2 , not ( sameInstance ( ro ) ) ) ; assertThat ( ro2 , instanceOf ( ReadOnlyByteBuf . class ) ) ; assertThat ( ro2 . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( ro2 . readerIndex ( ) , is ( ro . readerIndex ( ) ) ) ; assertThat ( ro2 . writerIndex ( ) , is ( ro . writerIndex ( ) ) ) ; assertThat ( ro2 . capacity ( ) , is ( ro . capacity ( ) ) ) ; assertThat ( ro2 . maxCapacity ( ) , is ( ro . maxCapacity ( ) ) ) ; } @Test public void testReadOnlyOfDuplicate ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf dup = buf . duplicate ( ) . setIndex ( <int> , <int> ) ; ByteBuf ro = Unpooled . unmodifiableBuffer ( dup ) ; assertThat ( ro , instanceOf ( ReadOnlyByteBuf . class ) ) ; assertThat ( ro . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( ro . readerIndex ( ) , is ( dup . readerIndex ( ) ) ) ; assertThat ( ro . writerIndex ( ) , is ( dup . writerIndex ( ) ) ) ; assertThat ( ro . capacity ( ) , is ( dup . capacity ( ) ) ) ; assertThat ( ro . maxCapacity ( ) , is ( dup . maxCapacity ( ) ) ) ; } @Test public void testDuplicateOfReadOnly ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf ro = Unpooled . unmodifiableBuffer ( buf ) . setIndex ( <int> , <int> ) ; ByteBuf dup = ro . duplicate ( ) ; assertThat ( dup , instanceOf ( ReadOnlyByteBuf . class ) ) ; assertThat ( dup . unwrap ( ) , sameInstance ( buf ) ) ; assertThat ( dup . readerIndex ( ) , is ( ro . readerIndex ( ) ) ) ; assertThat ( dup . writerIndex ( ) , is ( ro . writerIndex ( ) ) ) ; assertThat ( dup . capacity ( ) , is ( ro . capacity ( ) ) ) ; assertThat ( dup . maxCapacity ( ) , is ( ro . maxCapacity ( ) ) ) ; } @Test public void testSwap ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) . setIndex ( <int> , <int> ) ; ByteBuf swapped = buf . order ( ByteOrder . LITTLE_ENDIAN ) ; assertThat ( swapped , instanceOf ( SwappedByteBuf . class ) ) ; assertThat ( swapped . unwrap ( ) , is ( ( ByteBuf ) null ) ) ; assertThat ( swapped . order ( ByteOrder . LITTLE_ENDIAN ) , sameInstance ( swapped ) ) ; assertThat ( swapped . order ( ByteOrder . BIG_ENDIAN ) , sameInstance ( buf ) ) ; buf . setIndex ( <int> , <int> ) ; assertThat ( swapped . readerIndex ( ) , is ( <int> ) ) ; assertThat ( swapped . writerIndex ( ) , is ( <int> ) ) ; } @Test public void testMixture ( ) throws Exception { ByteBuf buf = Unpooled . buffer ( <int> ) ; ByteBuf derived = buf ; Random rnd = new Random ( ) ; for ( int i = <int> ; i < buf . capacity ( ) ; i + + ) { ByteBuf newDerived ; switch ( rnd . nextInt ( <int> ) ) { case <int> : newDerived = derived . slice ( <int> , derived . capacity ( ) - <int> ) ; break ; case <int> : newDerived = derived . duplicate ( ) ; break ; case <int> : newDerived = derived . order ( derived . order ( ) = = ByteOrder . BIG_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; break ; case <int> : newDerived = Unpooled . unmodifiableBuffer ( derived ) ; break ; default : throw new Error ( ) ; } assertThat ( <str> + newDerived , nestLevel ( newDerived ) , is ( lessThanOrEqualTo ( <int> ) ) ) ; assertThat ( <str> + newDerived . order ( ByteOrder . BIG_ENDIAN ) , nestLevel ( newDerived . order ( ByteOrder . BIG_ENDIAN ) ) , is ( lessThanOrEqualTo ( <int> ) ) ) ; derived = newDerived ; } } private static int nestLevel ( ByteBuf buf ) { int depth = <int> ; for ( ByteBuf b = buf . order ( ByteOrder . BIG_ENDIAN ) ; ; ) { if ( b . unwrap ( ) = = null & & ! ( b instanceof SwappedByteBuf ) ) { break ; } depth + + ; if ( b instanceof SwappedByteBuf ) { b = b . order ( ByteOrder . BIG_ENDIAN ) ; } else { b = b . unwrap ( ) ; } } return depth ; } } 
