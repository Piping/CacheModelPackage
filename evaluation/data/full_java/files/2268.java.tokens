package org . nd4j . linalg . ops . transforms ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . ScalarOp ; import org . nd4j . linalg . api . ops . TransformOp ; import org . nd4j . linalg . api . ops . impl . accum . distances . CosineSimilarity ; import org . nd4j . linalg . api . ops . impl . scalar . ScalarMax ; import org . nd4j . linalg . api . ops . impl . transforms . * ; import org . nd4j . linalg . api . ops . impl . transforms . comparison . Eps ; import org . nd4j . linalg . api . ops . impl . transforms . comparison . GreaterThanOrEqual ; import org . nd4j . linalg . api . ops . impl . transforms . comparison . LessThanOrEqual ; import org . nd4j . linalg . convolution . Convolution ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . INDArrayIndex ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . util . ArrayUtil ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class Transforms { public static INDArray maxPool ( INDArray input , int [ ] ds , boolean ignoreBorder ) { assert input . length ( ) > = <int> : <str> ; assert ds . length = = <int> : <str> ; assert input . shape ( ) . length = = <int> : <str> ; int batchSize = ArrayUtil . prod ( new int [ ] { input . size ( <int> ) * input . size ( <int> ) } ) ; int rows = input . size ( <int> ) ; int cols = input . size ( <int> ) ; INDArray signalNDArray = input . reshape ( batchSize , <int> , rows , cols ) ; INDArray zz = Nd4j . create ( signalNDArray . shape ( ) ) ; int rowIter = ignoreBorder ? ( int ) ( rows / Math . pow ( ds [ <int> ] , <int> ) ) : rows ; int colIter = ignoreBorder ? ( int ) ( cols / Math . pow ( ds [ <int> ] , <int> ) ) : cols ; rowIter = Math . max ( <int> , rowIter ) ; colIter = Math . max ( <int> , colIter ) ; for ( int i = <int> ; i < signalNDArray . size ( <int> ) ; i + + ) { for ( int j = <int> ; j < signalNDArray . size ( <int> ) ; j + + ) { for ( int k = <int> ; k < rowIter ; k + + ) { int zk = k / ds [ <int> ] ; for ( int l = <int> ; l < colIter ; l + + ) { int zl = l / ds [ <int> ] ; double num = input . getDouble ( i , j , k , l ) ; double zzGet = zz . getDouble ( i , j , zk , zl ) ; zz . putScalar ( new int [ ] { i , j , zk , zl } , Math . max ( num , zzGet ) ) ; } } } } return zz . reshape ( signalNDArray . shape ( ) ) ; } public static INDArray downSample ( INDArray d1 , int [ ] stride ) { INDArray d = Nd4j . ones ( stride ) ; d . divi ( ArrayUtil . prod ( stride ) ) ; if ( stride . length ! = d1 . shape ( ) . length ) { if ( stride . length > d1 . shape ( ) . length ) { int [ ] newShape = new int [ stride . length ] ; Arrays . fill ( newShape , <int> ) ; int delta = Math . abs ( d . shape ( ) . length - newShape . length ) ; for ( int i = newShape . length - <int> ; i > = delta ; i - - ) newShape [ i ] = d . shape ( ) [ i - delta ] ; d1 = d1 . reshape ( newShape ) ; } else { int [ ] newStride = new int [ d1 . shape ( ) . length ] ; Arrays . fill ( newStride , <int> ) ; int delta = Math . abs ( d . shape ( ) . length - newStride . length ) ; for ( int i = newStride . length - <int> ; i > = delta ; i - - ) newStride [ i ] = d . shape ( ) [ i - delta ] ; d = d . reshape ( newStride ) ; } } INDArray ret = Convolution . convn ( d1 , d , Convolution . Type . VALID ) ; INDArrayIndex [ ] indices = new INDArrayIndex [ d1 . shape ( ) . length ] ; for ( int i = <int> ; i < indices . length ; i + + ) { if ( i < stride . length ) { indices [ i ] = NDArrayIndex . interval ( <int> , stride [ i ] , d1 . size ( i ) , true ) ; } else { indices [ i ] = NDArrayIndex . interval ( <int> , d1 . size ( i ) , true ) ; } } ret = ret . get ( indices ) ; return ret ; } public static INDArray avgPooling ( INDArray toPool , int [ ] stride ) { int nDims = toPool . shape ( ) . length ; assert nDims > = <int> : <str> ; int nRows = toPool . shape ( ) [ nDims - <int> ] ; int nCols = toPool . shape ( ) [ nDims - <int> ] ; int yStride = stride [ <int> ] , xStride = stride [ <int> ] ; INDArray blocks = Nd4j . create ( toPool . shape ( ) ) ; for ( int iR = <int> ; iR < Math . ceil ( nRows / yStride ) ; iR + + ) { INDArrayIndex rows = NDArrayIndex . interval ( iR * yStride , iR * yStride , true ) ; for ( int jC = <int> ; jC < Math . ceil ( nCols / xStride ) ; jC + + ) { INDArrayIndex cols = NDArrayIndex . interval ( jC * xStride , ( jC * xStride ) + <int> , true ) ; INDArray blockVal = toPool . get ( rows , cols ) . sum ( toPool . shape ( ) . length - <int> ) . mean ( toPool . shape ( ) . length - <int> ) ; blocks . put ( new INDArrayIndex [ ] { rows , cols } , blockVal . permute ( new int [ ] { <int> , <int> , <int> } ) ) . repmat ( new int [ ] { rows . length ( ) , cols . length ( ) } ) ; } } return blocks ; } public static INDArray sumPooling ( INDArray toPool , int [ ] stride ) { int nDims = toPool . shape ( ) . length ; assert nDims > = <int> : <str> ; int nRows = toPool . shape ( ) [ nDims - <int> ] ; int nCols = toPool . shape ( ) [ nDims - <int> ] ; int yStride = stride [ <int> ] , xStride = stride [ <int> ] ; INDArray blocks = Nd4j . create ( toPool . shape ( ) ) ; for ( int iR = <int> ; iR < Math . ceil ( nRows / yStride ) ; iR + + ) { INDArrayIndex rows = NDArrayIndex . interval ( iR * yStride , iR * yStride , true ) ; for ( int jC = <int> ; jC < Math . ceil ( nCols / xStride ) ; jC + + ) { INDArrayIndex cols = NDArrayIndex . interval ( jC * xStride , ( jC * xStride ) + <int> , true ) ; INDArray blockVal = toPool . get ( rows , cols ) . sum ( toPool . shape ( ) . length - <int> ) . sum ( toPool . shape ( ) . length - <int> ) ; blocks . put ( new INDArrayIndex [ ] { rows , cols } , blockVal . permute ( new int [ ] { <int> , <int> , <int> } ) ) . repmat ( new int [ ] { rows . length ( ) , cols . length ( ) } ) ; } } return blocks ; } public static INDArray upSample ( INDArray d , INDArray scale ) { List < INDArray > idx = new ArrayList < > ( ) ; for ( int i = <int> ; i < d . shape ( ) . length ; i + + ) { INDArray tmp = Nd4j . zeros ( d . size ( i ) * ( int ) scale . getDouble ( i ) , <int> ) ; int [ ] indices = ArrayUtil . range ( <int> , ( int ) scale . getDouble ( i ) * d . size ( i ) , ( int ) scale . getDouble ( i ) ) ; NDArrayIndex index = new NDArrayIndex ( indices ) ; tmp . put ( new NDArrayIndex [ ] { index } , <int> ) ; INDArray put = tmp . cumsum ( <int> ) ; idx . add ( put . sub ( <int> ) ) ; } INDArray ret = Nd4j . create ( ArrayUtil . toInts ( ArrayUtil . toNDArray ( d . shape ( ) ) . muli ( scale ) ) ) ; INDArray retLinear = ret . linearView ( ) ; for ( int i = <int> ; i < retLinear . length ( ) ; i + + ) { for ( int j = <int> ; j < idx . get ( <int> ) . length ( ) ; j + + ) { int slice = idx . get ( <int> ) . getInt ( j ) ; for ( int k = <int> ; k < idx . size ( ) ; k + + ) { } } } return ret ; } public static double cosineSim ( INDArray d1 , INDArray d2 ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new CosineSimilarity ( d1 , d2 , d1 . length ( ) ) ) . getFinalResult ( ) . doubleValue ( ) ; } public static INDArray normalizeZeroMeanAndUnitVariance ( INDArray toNormalize ) { INDArray columnMeans = toNormalize . mean ( <int> ) ; INDArray columnStds = toNormalize . std ( <int> ) ; toNormalize . subiRowVector ( columnMeans ) ; columnStds . addi ( Nd4j . EPS_THRESHOLD ) ; toNormalize . diviRowVector ( columnStds ) ; return toNormalize ; } public static INDArray unitVec ( INDArray toScale ) { double length = toScale . norm2Number ( ) . doubleValue ( ) ; if ( length > <int> ) { if ( toScale . data ( ) . dataType ( ) = = ( DataBuffer . Type . FLOAT ) ) return Nd4j . getBlasWrapper ( ) . scal ( <float> / ( float ) length , toScale ) ; else return Nd4j . getBlasWrapper ( ) . scal ( <float> / length , toScale ) ; } return toScale ; } public static INDArray neg ( INDArray ndArray ) { return neg ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray floor ( INDArray ndArray ) { return floor ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray ceiling ( INDArray ndArray ) { return ceiling ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray ceiling ( INDArray ndArray , boolean copyOnOps ) { return exec ( copyOnOps ? new Ceil ( ndArray , ndArray . dup ( ) ) : new Ceil ( ndArray , ndArray ) ) ; } public static INDArray sign ( INDArray toSign ) { return sign ( toSign , Nd4j . copyOnOps ) ; } public static INDArray stabilize ( INDArray ndArray , double k ) { return stabilize ( ndArray , k , Nd4j . copyOnOps ) ; } public static INDArray sin ( INDArray in ) { return sin ( in , Nd4j . copyOnOps ) ; } public static INDArray sin ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new Sin ( ( copy ? in . dup ( ) : in ) ) ) ; } public static INDArray cos ( INDArray in ) { return cos ( in , Nd4j . copyOnOps ) ; } public static INDArray cos ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new Cos ( ( copy ? in . dup ( ) : in ) ) ) ; } public static INDArray acos ( INDArray arr ) { return acos ( arr , Nd4j . copyOnOps ) ; } public static INDArray acos ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new ACos ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray asin ( INDArray arr ) { return asin ( arr , Nd4j . copyOnOps ) ; } public static INDArray asin ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new ASin ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray atan ( INDArray arr ) { return acos ( arr , Nd4j . copyOnOps ) ; } public static INDArray atan ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new ATan ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray ceil ( INDArray arr ) { return ceil ( arr , Nd4j . copyOnOps ) ; } public static INDArray ceil ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new Ceil ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray relu ( INDArray arr ) { return relu ( arr , Nd4j . copyOnOps ) ; } public static INDArray relu ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new RectifedLinear ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray leakyRelu ( INDArray arr ) { return leakyRelu ( arr , Nd4j . copyOnOps ) ; } public static INDArray leakyRelu ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new LeakyReLU ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray softPlus ( INDArray arr ) { return softPlus ( arr , Nd4j . copyOnOps ) ; } public static INDArray softPlus ( INDArray in , boolean copy ) { return Nd4j . getExecutioner ( ) . execAndReturn ( new SoftPlus ( ( ( copy ? in . dup ( ) : in ) ) ) ) ; } public static INDArray abs ( INDArray ndArray ) { return abs ( ndArray , true ) ; } public static INDArray exp ( INDArray ndArray ) { return exp ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray hardTanh ( INDArray ndArray ) { return hardTanh ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray identity ( INDArray ndArray ) { return identity ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray pow ( INDArray ndArray , Number power ) { return pow ( ndArray , power , Nd4j . copyOnOps ) ; } public static INDArray round ( INDArray ndArray ) { return round ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray sigmoid ( INDArray ndArray ) { return sigmoid ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray sqrt ( INDArray ndArray ) { return sqrt ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray tanh ( INDArray ndArray ) { return tanh ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray log ( INDArray ndArray ) { return log ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray eps ( INDArray ndArray ) { return eps ( ndArray , Nd4j . copyOnOps ) ; } public static INDArray greaterThanOrEqual ( INDArray first , INDArray ndArray ) { return greaterThanOrEqual ( first , ndArray , Nd4j . copyOnOps ) ; } public static INDArray lessThanOrEqual ( INDArray first , INDArray ndArray ) { return lessThanOrEqual ( first , ndArray , Nd4j . copyOnOps ) ; } public static INDArray lessThanOrEqual ( INDArray first , INDArray ndArray , boolean dup ) { return exec ( dup ? new LessThanOrEqual ( first . dup ( ) , ndArray ) : new LessThanOrEqual ( first , ndArray ) ) ; } public static INDArray greaterThanOrEqual ( INDArray first , INDArray ndArray , boolean dup ) { return exec ( dup ? new GreaterThanOrEqual ( first . dup ( ) , ndArray ) : new GreaterThanOrEqual ( first , ndArray ) ) ; } public static INDArray eps ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Eps ( ndArray . dup ( ) ) : new Eps ( ndArray ) ) ; } public static INDArray floor ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Floor ( ndArray . dup ( ) ) : new Floor ( ndArray ) ) ; } public static INDArray sign ( INDArray toSign , boolean dup ) { return exec ( dup ? new Sign ( toSign , toSign . dup ( ) ) : new Sign ( toSign ) ) ; } public static INDArray max ( INDArray ndArray , double k , boolean dup ) { return exec ( dup ? new ScalarMax ( ndArray . dup ( ) , k ) : new ScalarMax ( ndArray , k ) ) ; } public static INDArray max ( INDArray ndArray , double k ) { return max ( ndArray , k , Nd4j . copyOnOps ) ; } public static INDArray stabilize ( INDArray ndArray , double k , boolean dup ) { return exec ( dup ? new Stabilize ( ndArray , ndArray . dup ( ) , k ) : new Stabilize ( ndArray , k ) ) ; } public static INDArray abs ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Abs ( ndArray , ndArray . dup ( ) ) : new Abs ( ndArray ) ) ; } public static INDArray exp ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Exp ( ndArray , ndArray . dup ( ) ) : new Exp ( ndArray ) ) ; } public static INDArray hardTanh ( INDArray ndArray , boolean dup ) { return exec ( dup ? new HardTanh ( ndArray , ndArray . dup ( ) ) : new HardTanh ( ndArray ) ) ; } public static INDArray identity ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Identity ( ndArray , ndArray . dup ( ) ) : new Identity ( ndArray ) ) ; } public static INDArray pow ( INDArray ndArray , Number power , boolean dup ) { return exec ( dup ? new Pow ( ndArray , ndArray . dup ( ) , power . doubleValue ( ) ) : new Pow ( ndArray , power . doubleValue ( ) ) ) ; } public static INDArray round ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Round ( ndArray , ndArray . dup ( ) ) : new Round ( ndArray ) ) ; } public static INDArray sigmoid ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Sigmoid ( ndArray , ndArray . dup ( ) ) : new Sigmoid ( ndArray ) ) ; } public static INDArray sqrt ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Sqrt ( ndArray , ndArray . dup ( ) ) : new Sqrt ( ndArray ) ) ; } public static INDArray tanh ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Tanh ( ndArray , ndArray . dup ( ) ) : new Tanh ( ndArray ) ) ; } public static INDArray log ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Log ( ndArray , ndArray . dup ( ) ) : new Log ( ndArray ) ) ; } public static INDArray neg ( INDArray ndArray , boolean dup ) { return exec ( dup ? new Negative ( ndArray , ndArray . dup ( ) ) : new Negative ( ndArray ) ) ; } private static INDArray exec ( ScalarOp op ) { if ( op . x ( ) . isCleanedUp ( ) ) throw new IllegalStateException ( <str> ) ; return Nd4j . getExecutioner ( ) . exec ( op ) . z ( ) ; } private static INDArray exec ( TransformOp op ) { if ( op . x ( ) . isCleanedUp ( ) ) throw new IllegalStateException ( <str> ) ; return Nd4j . getExecutioner ( ) . execAndReturn ( op ) ; } } 
