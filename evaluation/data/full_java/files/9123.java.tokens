package com . google . common . base ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static java . util . concurrent . TimeUnit . DAYS ; import static java . util . concurrent . TimeUnit . HOURS ; import static java . util . concurrent . TimeUnit . MICROSECONDS ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . MINUTES ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; import javax . annotation . CheckReturnValue ; @GwtCompatible ( emulated = true ) public final class Stopwatch { private final Ticker ticker ; private boolean isRunning ; private long elapsedNanos ; private long startTick ; @CheckReturnValue public static Stopwatch createUnstarted ( ) { return new Stopwatch ( ) ; } @CheckReturnValue public static Stopwatch createUnstarted ( Ticker ticker ) { return new Stopwatch ( ticker ) ; } @CheckReturnValue public static Stopwatch createStarted ( ) { return new Stopwatch ( ) . start ( ) ; } @CheckReturnValue public static Stopwatch createStarted ( Ticker ticker ) { return new Stopwatch ( ticker ) . start ( ) ; } Stopwatch ( ) { this . ticker = Ticker . systemTicker ( ) ; } Stopwatch ( Ticker ticker ) { this . ticker = checkNotNull ( ticker , <str> ) ; } @CheckReturnValue public boolean isRunning ( ) { return isRunning ; } public Stopwatch start ( ) { checkState ( ! isRunning , <str> ) ; isRunning = true ; startTick = ticker . read ( ) ; return this ; } public Stopwatch stop ( ) { long tick = ticker . read ( ) ; checkState ( isRunning , <str> ) ; isRunning = false ; elapsedNanos + = tick - startTick ; return this ; } public Stopwatch reset ( ) { elapsedNanos = <int> ; isRunning = false ; return this ; } private long elapsedNanos ( ) { return isRunning ? ticker . read ( ) - startTick + elapsedNanos : elapsedNanos ; } @CheckReturnValue public long elapsed ( TimeUnit desiredUnit ) { return desiredUnit . convert ( elapsedNanos ( ) , NANOSECONDS ) ; } @GwtIncompatible ( <str> ) @Override public String toString ( ) { long nanos = elapsedNanos ( ) ; TimeUnit unit = chooseUnit ( nanos ) ; double value = ( double ) nanos / NANOSECONDS . convert ( <int> , unit ) ; return String . format ( Locale . ROOT , <str> , value , abbreviate ( unit ) ) ; } private static TimeUnit chooseUnit ( long nanos ) { if ( DAYS . convert ( nanos , NANOSECONDS ) > <int> ) { return DAYS ; } if ( HOURS . convert ( nanos , NANOSECONDS ) > <int> ) { return HOURS ; } if ( MINUTES . convert ( nanos , NANOSECONDS ) > <int> ) { return MINUTES ; } if ( SECONDS . convert ( nanos , NANOSECONDS ) > <int> ) { return SECONDS ; } if ( MILLISECONDS . convert ( nanos , NANOSECONDS ) > <int> ) { return MILLISECONDS ; } if ( MICROSECONDS . convert ( nanos , NANOSECONDS ) > <int> ) { return MICROSECONDS ; } return NANOSECONDS ; } private static String abbreviate ( TimeUnit unit ) { switch ( unit ) { case NANOSECONDS : return <str> ; case MICROSECONDS : return <str> ; case MILLISECONDS : return <str> ; case SECONDS : return <str> ; case MINUTES : return <str> ; case HOURS : return <str> ; case DAYS : return <str> ; default : throw new AssertionError ( ) ; } } } 
