package org . jbox2d . collision ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; public class WorldManifold { public final Vec2 normal ; public final Vec2 [ ] points ; public final float [ ] separations ; public WorldManifold ( ) { normal = new Vec2 ( ) ; points = new Vec2 [ Settings . maxManifoldPoints ] ; separations = new float [ Settings . maxManifoldPoints ] ; for ( int i = <int> ; i < Settings . maxManifoldPoints ; i + + ) { points [ i ] = new Vec2 ( ) ; } } private final Vec2 pool3 = new Vec2 ( ) ; private final Vec2 pool4 = new Vec2 ( ) ; public final void initialize ( final Manifold manifold , final Transform xfA , float radiusA , final Transform xfB , float radiusB ) { if ( manifold . pointCount = = <int> ) { return ; } switch ( manifold . type ) { case CIRCLES : { final Vec2 pointA = pool3 ; final Vec2 pointB = pool4 ; normal . x = <int> ; normal . y = <int> ; Vec2 v = manifold . localPoint ; pointA . x = ( xfA . q . c * v . x - xfA . q . s * v . y ) + xfA . p . x ; pointA . y = ( xfA . q . s * v . x + xfA . q . c * v . y ) + xfA . p . y ; Vec2 mp0p = manifold . points [ <int> ] . localPoint ; pointB . x = ( xfB . q . c * mp0p . x - xfB . q . s * mp0p . y ) + xfB . p . x ; pointB . y = ( xfB . q . s * mp0p . x + xfB . q . c * mp0p . y ) + xfB . p . y ; if ( MathUtils . distanceSquared ( pointA , pointB ) > Settings . EPSILON * Settings . EPSILON ) { normal . x = pointB . x - pointA . x ; normal . y = pointB . y - pointA . y ; normal . normalize ( ) ; } final float cAx = normal . x * radiusA + pointA . x ; final float cAy = normal . y * radiusA + pointA . y ; final float cBx = - normal . x * radiusB + pointB . x ; final float cBy = - normal . y * radiusB + pointB . y ; points [ <int> ] . x = ( cAx + cBx ) * <float> ; points [ <int> ] . y = ( cAy + cBy ) * <float> ; separations [ <int> ] = ( cBx - cAx ) * normal . x + ( cBy - cAy ) * normal . y ; } break ; case FACE_A : { final Vec2 planePoint = pool3 ; Rot . mulToOutUnsafe ( xfA . q , manifold . localNormal , normal ) ; Transform . mulToOut ( xfA , manifold . localPoint , planePoint ) ; final Vec2 clipPoint = pool4 ; for ( int i = <int> ; i < manifold . pointCount ; i + + ) { Transform . mulToOut ( xfB , manifold . points [ i ] . localPoint , clipPoint ) ; final float scalar = radiusA - ( ( clipPoint . x - planePoint . x ) * normal . x + ( clipPoint . y - planePoint . y ) * normal . y ) ; final float cAx = normal . x * scalar + clipPoint . x ; final float cAy = normal . y * scalar + clipPoint . y ; final float cBx = - normal . x * radiusB + clipPoint . x ; final float cBy = - normal . y * radiusB + clipPoint . y ; points [ i ] . x = ( cAx + cBx ) * <float> ; points [ i ] . y = ( cAy + cBy ) * <float> ; separations [ i ] = ( cBx - cAx ) * normal . x + ( cBy - cAy ) * normal . y ; } } break ; case FACE_B : final Vec2 planePoint = pool3 ; Rot . mulToOutUnsafe ( xfB . q , manifold . localNormal , normal ) ; Transform . mulToOut ( xfB , manifold . localPoint , planePoint ) ; final Vec2 clipPoint = pool4 ; for ( int i = <int> ; i < manifold . pointCount ; i + + ) { Transform . mulToOut ( xfA , manifold . points [ i ] . localPoint , clipPoint ) ; final float scalar = radiusB - ( ( clipPoint . x - planePoint . x ) * normal . x + ( clipPoint . y - planePoint . y ) * normal . y ) ; final float cBx = normal . x * scalar + clipPoint . x ; final float cBy = normal . y * scalar + clipPoint . y ; final float cAx = - normal . x * radiusA + clipPoint . x ; final float cAy = - normal . y * radiusA + clipPoint . y ; points [ i ] . x = ( cAx + cBx ) * <float> ; points [ i ] . y = ( cAy + cBy ) * <float> ; separations [ i ] = ( cAx - cBx ) * normal . x + ( cAy - cBy ) * normal . y ; } normal . x = - normal . x ; normal . y = - normal . y ; break ; } } } 
