package com . google . common . primitives ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Double . NaN ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Converter ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @GwtCompatible ( emulated = true ) @SuppressWarnings ( <str> ) public class DoublesTest extends TestCase { private static final double [ ] EMPTY = { } ; private static final double [ ] ARRAY1 = { ( double ) <int> } ; private static final double [ ] ARRAY234 = { ( double ) <int> , ( double ) <int> , ( double ) <int> } ; private static final double LEAST = Double . NEGATIVE_INFINITY ; private static final double GREATEST = Double . POSITIVE_INFINITY ; private static final double [ ] NUMBERS = new double [ ] { LEAST , - Double . MAX_VALUE , - <float> , - <float> , - <float> , - <float> , <float> , <float> , <float> , <float> , Double . MAX_VALUE , GREATEST , Double . MIN_NORMAL , - Double . MIN_NORMAL , Double . MIN_VALUE , - Double . MIN_VALUE , Integer . MIN_VALUE , Integer . MAX_VALUE , Long . MIN_VALUE , Long . MAX_VALUE } ; private static final double [ ] VALUES = Doubles . concat ( NUMBERS , new double [ ] { NaN } ) ; public void testHashCode ( ) { for ( double value : VALUES ) { assertEquals ( ( ( Double ) value ) . hashCode ( ) , Doubles . hashCode ( value ) ) ; } } public void testIsFinite ( ) { for ( double value : NUMBERS ) { assertEquals ( ! ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) , Doubles . isFinite ( value ) ) ; } } public void testCompare ( ) { for ( double x : VALUES ) { for ( double y : VALUES ) { assertEquals ( x + <str> + y , Double . valueOf ( x ) . compareTo ( y ) , Doubles . compare ( x , y ) ) ; } } } public void testContains ( ) { assertFalse ( Doubles . contains ( EMPTY , ( double ) <int> ) ) ; assertFalse ( Doubles . contains ( ARRAY1 , ( double ) <int> ) ) ; assertFalse ( Doubles . contains ( ARRAY234 , ( double ) <int> ) ) ; assertTrue ( Doubles . contains ( new double [ ] { ( double ) - <int> } , ( double ) - <int> ) ) ; assertTrue ( Doubles . contains ( ARRAY234 , ( double ) <int> ) ) ; assertTrue ( Doubles . contains ( ARRAY234 , ( double ) <int> ) ) ; assertTrue ( Doubles . contains ( ARRAY234 , ( double ) <int> ) ) ; for ( double value : NUMBERS ) { assertTrue ( <str> + value , Doubles . contains ( new double [ ] { <float> , value } , value ) ) ; } assertFalse ( Doubles . contains ( new double [ ] { <float> , NaN } , NaN ) ) ; } public void testIndexOf ( ) { assertEquals ( - <int> , Doubles . indexOf ( EMPTY , ( double ) <int> ) ) ; assertEquals ( - <int> , Doubles . indexOf ( ARRAY1 , ( double ) <int> ) ) ; assertEquals ( - <int> , Doubles . indexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . indexOf ( new double [ ] { ( double ) - <int> } , ( double ) - <int> ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . indexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , ( double ) <int> ) ) ; for ( double value : NUMBERS ) { assertEquals ( <str> + value , <int> , Doubles . indexOf ( new double [ ] { <float> , value } , value ) ) ; } assertEquals ( - <int> , Doubles . indexOf ( new double [ ] { <float> , NaN } , NaN ) ) ; } public void testIndexOf_arrayTarget ( ) { assertEquals ( <int> , Doubles . indexOf ( EMPTY , EMPTY ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , EMPTY ) ) ; assertEquals ( - <int> , Doubles . indexOf ( EMPTY , ARRAY234 ) ) ; assertEquals ( - <int> , Doubles . indexOf ( ARRAY234 , ARRAY1 ) ) ; assertEquals ( - <int> , Doubles . indexOf ( ARRAY1 , ARRAY234 ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY1 , ARRAY1 ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , ARRAY234 ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , new double [ ] { ( double ) <int> , ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , new double [ ] { ( double ) <int> , ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , new double [ ] { ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( ARRAY234 , new double [ ] { ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , new double [ ] { ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } ) ) ; assertEquals ( <int> , Doubles . indexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } ) ) ; assertEquals ( - <int> , Doubles . indexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } , new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } ) ) ; for ( double value : NUMBERS ) { assertEquals ( <str> + value , <int> , Doubles . indexOf ( new double [ ] { <float> , value , value , <float> } , new double [ ] { value , value } ) ) ; } assertEquals ( - <int> , Doubles . indexOf ( new double [ ] { <float> , NaN , NaN , <float> } , new double [ ] { NaN , NaN } ) ) ; } public void testLastIndexOf ( ) { assertEquals ( - <int> , Doubles . lastIndexOf ( EMPTY , ( double ) <int> ) ) ; assertEquals ( - <int> , Doubles . lastIndexOf ( ARRAY1 , ( double ) <int> ) ) ; assertEquals ( - <int> , Doubles . lastIndexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . lastIndexOf ( new double [ ] { ( double ) - <int> } , ( double ) - <int> ) ) ; assertEquals ( <int> , Doubles . lastIndexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . lastIndexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . lastIndexOf ( ARRAY234 , ( double ) <int> ) ) ; assertEquals ( <int> , Doubles . lastIndexOf ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , ( double ) <int> ) ) ; for ( double value : NUMBERS ) { assertEquals ( <str> + value , <int> , Doubles . lastIndexOf ( new double [ ] { value , <float> } , value ) ) ; } assertEquals ( - <int> , Doubles . lastIndexOf ( new double [ ] { NaN , <float> } , NaN ) ) ; } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { Doubles . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( LEAST , Doubles . max ( LEAST ) ) ; assertEquals ( GREATEST , Doubles . max ( GREATEST ) ) ; assertEquals ( ( double ) <int> , Doubles . max ( ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> ) ) ; assertEquals ( <float> , Doubles . max ( - <float> , <float> ) ) ; assertEquals ( <float> , Doubles . max ( <float> , - <float> ) ) ; assertEquals ( GREATEST , Doubles . max ( NUMBERS ) ) ; assertTrue ( Double . isNaN ( Doubles . max ( VALUES ) ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { Doubles . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( LEAST , Doubles . min ( LEAST ) ) ; assertEquals ( GREATEST , Doubles . min ( GREATEST ) ) ; assertEquals ( ( double ) <int> , Doubles . min ( ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> ) ) ; assertEquals ( - <float> , Doubles . min ( - <float> , <float> ) ) ; assertEquals ( - <float> , Doubles . min ( <float> , - <float> ) ) ; assertEquals ( LEAST , Doubles . min ( NUMBERS ) ) ; assertTrue ( Double . isNaN ( Doubles . min ( VALUES ) ) ) ; } public void testConcat ( ) { assertTrue ( Arrays . equals ( EMPTY , Doubles . concat ( ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Doubles . concat ( EMPTY ) ) ) ; assertTrue ( Arrays . equals ( EMPTY , Doubles . concat ( EMPTY , EMPTY , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Doubles . concat ( ARRAY1 ) ) ) ; assertNotSame ( ARRAY1 , Doubles . concat ( ARRAY1 ) ) ; assertTrue ( Arrays . equals ( ARRAY1 , Doubles . concat ( EMPTY , ARRAY1 , EMPTY ) ) ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } , Doubles . concat ( ARRAY1 , ARRAY1 , ARRAY1 ) ) ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } , Doubles . concat ( ARRAY1 , ARRAY234 ) ) ) ; } public void testEnsureCapacity ( ) { assertSame ( EMPTY , Doubles . ensureCapacity ( EMPTY , <int> , <int> ) ) ; assertSame ( ARRAY1 , Doubles . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertSame ( ARRAY1 , Doubles . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } , Doubles . ensureCapacity ( ARRAY1 , <int> , <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testEnsureCapacity_fail ( ) { try { Doubles . ensureCapacity ( ARRAY1 , - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { Doubles . ensureCapacity ( ARRAY1 , <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testJoin ( ) { assertEquals ( <str> , Doubles . join ( <str> , EMPTY ) ) ; assertEquals ( <str> , Doubles . join ( <str> , ARRAY1 ) ) ; assertEquals ( <str> , Doubles . join ( <str> , ( double ) <int> , ( double ) <int> ) ) ; assertEquals ( <str> , Doubles . join ( <str> , ( double ) <int> , ( double ) <int> , ( double ) <int> ) ) ; } public void testJoinNonTrivialDoubles ( ) { assertEquals ( <str> , Doubles . join ( <str> , EMPTY ) ) ; assertEquals ( <str> , Doubles . join ( <str> , <float> ) ) ; assertEquals ( <str> , Doubles . join ( <str> , <float> , <float> ) ) ; assertEquals ( <str> , Doubles . join ( <str> , <float> , <float> , <float> ) ) ; } public void testLexicographicalComparator ( ) { List < double [ ] > ordered = Arrays . asList ( new double [ ] { } , new double [ ] { LEAST } , new double [ ] { LEAST , LEAST } , new double [ ] { LEAST , ( double ) <int> } , new double [ ] { ( double ) <int> } , new double [ ] { ( double ) <int> , LEAST } , new double [ ] { GREATEST , Double . MAX_VALUE } , new double [ ] { GREATEST , GREATEST } , new double [ ] { GREATEST , GREATEST , GREATEST } ) ; Comparator < double [ ] > comparator = Doubles . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; } @GwtIncompatible ( <str> ) public void testLexicographicalComparatorSerializable ( ) { Comparator < double [ ] > comparator = Doubles . lexicographicalComparator ( ) ; assertSame ( comparator , SerializableTester . reserialize ( comparator ) ) ; } @GwtIncompatible ( <str> ) public void testStringConverterSerialization ( ) { SerializableTester . reserializeAndAssert ( Doubles . stringConverter ( ) ) ; } public void testToArray ( ) { List < Double > none = Arrays . < Double > asList ( ) ; assertTrue ( Arrays . equals ( EMPTY , Doubles . toArray ( none ) ) ) ; List < Double > one = Arrays . asList ( ( double ) <int> ) ; assertTrue ( Arrays . equals ( ARRAY1 , Doubles . toArray ( one ) ) ) ; double [ ] array = { ( double ) <int> , ( double ) <int> , Math . PI } ; List < Double > three = Arrays . asList ( ( double ) <int> , ( double ) <int> , Math . PI ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( three ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( Doubles . asList ( array ) ) ) ) ; } public void testToArray_threadSafe ( ) { for ( int delta : new int [ ] { + <int> , <int> , - <int> } ) { for ( int i = <int> ; i < VALUES . length ; i + + ) { List < Double > list = Doubles . asList ( VALUES ) . subList ( <int> , i ) ; Collection < Double > misleadingSize = Helpers . misleadingSizeCollection ( delta ) ; misleadingSize . addAll ( list ) ; double [ ] arr = Doubles . toArray ( misleadingSize ) ; assertEquals ( i , arr . length ) ; for ( int j = <int> ; j < i ; j + + ) { assertEquals ( VALUES [ j ] , arr [ j ] ) ; } } } } @SuppressWarnings ( <str> ) public void testToArray_withNull ( ) { List < Double > list = Arrays . asList ( ( double ) <int> , ( double ) <int> , null ) ; try { Doubles . toArray ( list ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testToArray_withConversion ( ) { double [ ] array = { ( double ) <int> , ( double ) <int> , ( double ) <int> } ; List < Byte > bytes = Arrays . asList ( ( byte ) <int> , ( byte ) <int> , ( byte ) <int> ) ; List < Short > shorts = Arrays . asList ( ( short ) <int> , ( short ) <int> , ( short ) <int> ) ; List < Integer > ints = Arrays . asList ( <int> , <int> , <int> ) ; List < Float > floats = Arrays . asList ( ( float ) <int> , ( float ) <int> , ( float ) <int> ) ; List < Long > longs = Arrays . asList ( ( long ) <int> , ( long ) <int> , ( long ) <int> ) ; List < Double > doubles = Arrays . asList ( ( double ) <int> , ( double ) <int> , ( double ) <int> ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( bytes ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( shorts ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( ints ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( floats ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( longs ) ) ) ; assertTrue ( Arrays . equals ( array , Doubles . toArray ( doubles ) ) ) ; } public void testAsList_isAView ( ) { double [ ] array = { ( double ) <int> , ( double ) <int> } ; List < Double > list = Doubles . asList ( array ) ; list . set ( <int> , ( double ) <int> ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> } , array ) ) ; array [ <int> ] = ( double ) <int> ; assertThat ( list ) . containsExactly ( ( double ) <int> , ( double ) <int> ) . inOrder ( ) ; } public void testAsList_toArray_roundTrip ( ) { double [ ] array = { ( double ) <int> , ( double ) <int> , ( double ) <int> } ; List < Double > list = Doubles . asList ( array ) ; double [ ] newArray = Doubles . toArray ( list ) ; list . set ( <int> , ( double ) <int> ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> , ( double ) <int> } , newArray ) ) ; newArray [ <int> ] = ( double ) <int> ; assertEquals ( ( double ) <int> , ( double ) list . get ( <int> ) ) ; } public void testAsList_subList_toArray_roundTrip ( ) { double [ ] array = { ( double ) <int> , ( double ) <int> , ( double ) <int> , ( double ) <int> } ; List < Double > list = Doubles . asList ( array ) ; assertTrue ( Arrays . equals ( new double [ ] { ( double ) <int> , ( double ) <int> } , Doubles . toArray ( list . subList ( <int> , <int> ) ) ) ) ; assertTrue ( Arrays . equals ( new double [ ] { } , Doubles . toArray ( list . subList ( <int> , <int> ) ) ) ) ; } public void testAsListEmpty ( ) { assertSame ( Collections . emptyList ( ) , Doubles . asList ( EMPTY ) ) ; } private static Double referenceTryParse ( String input ) { if ( input . trim ( ) . length ( ) < input . length ( ) ) { return null ; } try { return Double . valueOf ( input ) ; } catch ( NumberFormatException e ) { return null ; } } @GwtIncompatible ( <str> ) private static void checkTryParse ( String input ) { Double expected = referenceTryParse ( input ) ; assertEquals ( expected , Doubles . tryParse ( input ) ) ; if ( expected ! = null & & ! Doubles . FLOATING_POINT_PATTERN . matcher ( input ) . matches ( ) ) { StringBuilder escapedInput = new StringBuilder ( ) ; for ( char c : input . toCharArray ( ) ) { if ( c > = <hex> & & c < = <hex> ) { escapedInput . append ( c ) ; } else { escapedInput . append ( String . format ( <str> , ( int ) c ) ) ; } } fail ( <str> + escapedInput + <str> ) ; } } @GwtIncompatible ( <str> ) private static void checkTryParse ( double expected , String input ) { assertEquals ( Double . valueOf ( expected ) , Doubles . tryParse ( input ) ) ; assertThat ( input ) . matches ( Doubles . FLOATING_POINT_PATTERN ) ; } @GwtIncompatible ( <str> ) public void testTryParseHex ( ) { for ( String signChar : ImmutableList . of ( <str> , <str> , <str> ) ) { for ( String hexPrefix : ImmutableList . of ( <str> , <str> ) ) { for ( String iPart : ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) { for ( String fPart : ImmutableList . of ( <str> , <str> , <str> , <str> , <str> ) ) { for ( String expMarker : ImmutableList . of ( <str> , <str> ) ) { for ( String exponent : ImmutableList . of ( <str> , <str> , <str> , <str> ) ) { for ( String typePart : ImmutableList . of ( <str> , <str> , <str> , <str> , <str> ) ) { checkTryParse ( signChar + hexPrefix + iPart + fPart + expMarker + exponent + typePart ) ; } } } } } } } } @AndroidIncompatible @GwtIncompatible ( <str> ) public void testTryParseAllCodePoints ( ) { char [ ] tmp = new char [ <int> ] ; for ( int i = Character . MIN_CODE_POINT ; i < Character . MAX_CODE_POINT ; i + + ) { Character . toChars ( i , tmp , <int> ) ; checkTryParse ( String . copyValueOf ( tmp , <int> , Character . charCount ( i ) ) ) ; } } @GwtIncompatible ( <str> ) public void testTryParseOfToStringIsOriginal ( ) { for ( double d : NUMBERS ) { checkTryParse ( d , Double . toString ( d ) ) ; } } @GwtIncompatible ( <str> ) public void testTryParseOfToHexStringIsOriginal ( ) { for ( double d : NUMBERS ) { checkTryParse ( d , Double . toHexString ( d ) ) ; } } @GwtIncompatible ( <str> ) public void testTryParseNaN ( ) { checkTryParse ( <str> ) ; checkTryParse ( <str> ) ; checkTryParse ( <str> ) ; } @GwtIncompatible ( <str> ) public void testTryParseInfinity ( ) { checkTryParse ( Double . POSITIVE_INFINITY , <str> ) ; checkTryParse ( Double . POSITIVE_INFINITY , <str> ) ; checkTryParse ( Double . NEGATIVE_INFINITY , <str> ) ; } private static final String [ ] BAD_TRY_PARSE_INPUTS = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; @GwtIncompatible ( <str> ) public void testTryParseFailures ( ) { for ( String badInput : BAD_TRY_PARSE_INPUTS ) { assertThat ( badInput ) . doesNotMatch ( Doubles . FLOATING_POINT_PATTERN ) ; assertEquals ( referenceTryParse ( badInput ) , Doubles . tryParse ( badInput ) ) ; assertNull ( Doubles . tryParse ( badInput ) ) ; } } @GwtIncompatible ( <str> ) public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Doubles . class ) ; } public void testStringConverter_convert ( ) { Converter < String , Double > converter = Doubles . stringConverter ( ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) ( - <float> ) , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) ( - <float> ) , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; assertEquals ( ( Double ) <float> , converter . convert ( <str> ) ) ; } @SuppressWarnings ( <str> ) public void testStringConverter_convertError ( ) { try { Doubles . stringConverter ( ) . convert ( <str> ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testStringConverter_nullConversions ( ) { assertNull ( Doubles . stringConverter ( ) . convert ( null ) ) ; assertNull ( Doubles . stringConverter ( ) . reverse ( ) . convert ( null ) ) ; } @GwtIncompatible ( <str> ) public void testStringConverter_reverse ( ) { Converter < String , Double > converter = Doubles . stringConverter ( ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <float> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <float> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( - <float> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <float> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <float> ) ) ; } @GwtIncompatible ( <str> ) public void testStringConverter_nullPointerTester ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( Doubles . stringConverter ( ) ) ; } } 
