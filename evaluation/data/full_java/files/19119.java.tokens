package io . netty . handler . codec . http ; import io . netty . util . CharsetUtil ; import java . net . URI ; import java . net . URLDecoder ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; public class QueryStringDecoder { private static final int DEFAULT_MAX_PARAMS = <int> ; private final Charset charset ; private final String uri ; private final boolean hasPath ; private final int maxParams ; private String path ; private Map < String , List < String > > params ; private int nParams ; public QueryStringDecoder ( String uri ) { this ( uri , HttpConstants . DEFAULT_CHARSET ) ; } public QueryStringDecoder ( String uri , boolean hasPath ) { this ( uri , HttpConstants . DEFAULT_CHARSET , hasPath ) ; } public QueryStringDecoder ( String uri , Charset charset ) { this ( uri , charset , true ) ; } public QueryStringDecoder ( String uri , Charset charset , boolean hasPath ) { this ( uri , charset , hasPath , DEFAULT_MAX_PARAMS ) ; } public QueryStringDecoder ( String uri , Charset charset , boolean hasPath , int maxParams ) { if ( uri = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxParams < = <int> ) { throw new IllegalArgumentException ( <str> + maxParams + <str> ) ; } this . uri = uri ; this . charset = charset ; this . maxParams = maxParams ; this . hasPath = hasPath ; } public QueryStringDecoder ( URI uri ) { this ( uri , HttpConstants . DEFAULT_CHARSET ) ; } public QueryStringDecoder ( URI uri , Charset charset ) { this ( uri , charset , DEFAULT_MAX_PARAMS ) ; } public QueryStringDecoder ( URI uri , Charset charset , int maxParams ) { if ( uri = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxParams < = <int> ) { throw new IllegalArgumentException ( <str> + maxParams + <str> ) ; } String rawPath = uri . getRawPath ( ) ; if ( rawPath ! = null ) { hasPath = true ; } else { rawPath = <str> ; hasPath = false ; } this . uri = rawPath + ( uri . getRawQuery ( ) = = null ? <str> : <str> + uri . getRawQuery ( ) ) ; this . charset = charset ; this . maxParams = maxParams ; } public String uri ( ) { return uri ; } public String path ( ) { if ( path = = null ) { if ( ! hasPath ) { return path = <str> ; } int pathEndPos = uri . indexOf ( <str> ) ; if ( pathEndPos < <int> ) { path = uri ; } else { return path = uri . substring ( <int> , pathEndPos ) ; } } return path ; } public Map < String , List < String > > parameters ( ) { if ( params = = null ) { if ( hasPath ) { int pathLength = path ( ) . length ( ) ; if ( uri . length ( ) = = pathLength ) { return Collections . emptyMap ( ) ; } decodeParams ( uri . substring ( pathLength + <int> ) ) ; } else { if ( uri . isEmpty ( ) ) { return Collections . emptyMap ( ) ; } decodeParams ( uri ) ; } } return params ; } private void decodeParams ( String s ) { Map < String , List < String > > params = this . params = new LinkedHashMap < String , List < String > > ( ) ; nParams = <int> ; String name = null ; int pos = <int> ; int i ; char c ; for ( i = <int> ; i < s . length ( ) ; i + + ) { c = s . charAt ( i ) ; if ( c = = <str> & & name = = null ) { if ( pos ! = i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + <int> ; } else if ( c = = <str> | | c = = <str> ) { if ( name = = null & & pos ! = i ) { if ( ! addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , <str> ) ) { return ; } } else if ( name ! = null ) { if ( ! addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ) { return ; } name = null ; } pos = i + <int> ; } } if ( pos ! = i ) { if ( name = = null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , <str> ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name ! = null ) { addParam ( params , name , <str> ) ; } } private boolean addParam ( Map < String , List < String > > params , String name , String value ) { if ( nParams > = maxParams ) { return false ; } List < String > values = params . get ( name ) ; if ( values = = null ) { values = new ArrayList < String > ( <int> ) ; params . put ( name , values ) ; } values . add ( value ) ; nParams + + ; return true ; } public static String decodeComponent ( final String s ) { return decodeComponent ( s , HttpConstants . DEFAULT_CHARSET ) ; } public static String decodeComponent ( final String s , final Charset charset ) { if ( s = = null ) { return <str> ; } final int size = s . length ( ) ; boolean modified = false ; for ( int i = <int> ; i < size ; i + + ) { final char c = s . charAt ( i ) ; if ( c = = <str> | | c = = <str> ) { modified = true ; break ; } } if ( ! modified ) { return s ; } final byte [ ] buf = new byte [ size ] ; int pos = <int> ; for ( int i = <int> ; i < size ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case <str> : buf [ pos + + ] = <str> ; break ; case <str> : if ( i = = size - <int> ) { throw new IllegalArgumentException ( <str> + <str> + s ) ; } c = s . charAt ( + + i ) ; if ( c = = <str> ) { buf [ pos + + ] = <str> ; break ; } if ( i = = size - <int> ) { throw new IllegalArgumentException ( <str> + <str> + s ) ; } c = decodeHexNibble ( c ) ; final char c2 = decodeHexNibble ( s . charAt ( + + i ) ) ; if ( c = = Character . MAX_VALUE | | c2 = = Character . MAX_VALUE ) { throw new IllegalArgumentException ( <str> + s . charAt ( i - <int> ) + s . charAt ( i ) + <str> + ( i - <int> ) + <str> + s ) ; } c = ( char ) ( c * <int> + c2 ) ; default : buf [ pos + + ] = ( byte ) c ; break ; } } return new String ( buf , <int> , pos , charset ) ; } private static char decodeHexNibble ( final char c ) { if ( <str> < = c & & c < = <str> ) { return ( char ) ( c - <str> ) ; } else if ( <str> < = c & & c < = <str> ) { return ( char ) ( c - <str> + <int> ) ; } else if ( <str> < = c & & c < = <str> ) { return ( char ) ( c - <str> + <int> ) ; } else { return Character . MAX_VALUE ; } } } 
