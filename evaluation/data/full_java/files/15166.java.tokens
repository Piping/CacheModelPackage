package org . gradle . play . internal . run ; import com . google . common . collect . ImmutableList ; import org . gradle . api . Transformer ; import org . gradle . api . artifacts . Dependency ; import org . gradle . api . internal . artifacts . dependencies . DefaultExternalModuleDependency ; import org . gradle . internal . Cast ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . scala . internal . reflect . ScalaMethod ; import org . gradle . scala . internal . reflect . ScalaReflectionUtil ; import org . gradle . util . CollectionUtils ; import org . gradle . util . VersionNumber ; import java . io . File ; import java . util . List ; public class PlayRunAdapterV23X extends DefaultVersionedPlayRunAdapter { protected static final String RUN_SUPPORT_PLAY_MODULE = <str> ; private static final VersionNumber MINIMUM_PLAY_VERSION_WITH_RUN_SUPPORT = VersionNumber . parse ( <str> ) ; @Override protected Class < ? > getBuildLinkClass ( ClassLoader classLoader ) throws ClassNotFoundException { return classLoader . loadClass ( <str> ) ; } @Override protected Class < ? > getBuildDocHandlerClass ( ClassLoader classLoader ) throws ClassNotFoundException { return classLoader . loadClass ( <str> ) ; } @Override protected Class < ? > getDocHandlerFactoryClass ( ClassLoader docsClassLoader ) throws ClassNotFoundException { return docsClassLoader . loadClass ( <str> ) ; } @Override protected ClassLoader createAssetsClassLoader ( File assetsJar , Iterable < File > assetsDirs , ClassLoader classLoader ) { Class < ? > assetsClassLoaderClass ; assetsClassLoaderClass = loadClass ( classLoader , <str> ) ; final Class < ? > tuple2Class = loadClass ( classLoader , <str> ) ; List < ? > tuples = CollectionUtils . collect ( assetsDirs , new Transformer < Object , File > ( ) { @Override public Object transform ( File file ) { return DirectInstantiator . instantiate ( tuple2Class , <str> , file ) ; } } ) ; ScalaMethod listToScalaSeqMethod = ScalaReflectionUtil . scalaMethod ( classLoader , <str> , <str> , List . class ) ; Object scalaTuples = listToScalaSeqMethod . invoke ( tuples ) ; return Cast . uncheckedCast ( DirectInstantiator . instantiate ( assetsClassLoaderClass , classLoader , scalaTuples ) ) ; } private Class < ? > loadClass ( ClassLoader classLoader , String className ) { try { return classLoader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } @Override public Iterable < Dependency > getRunsupportClasspathDependencies ( String playVersion , String scalaCompatibilityVersion ) { ImmutableList . Builder < Dependency > listBuilder = ImmutableList . builder ( ) ; String runsupportPlayVersion = playVersion ; boolean transitive = true ; if ( VersionNumber . parse ( playVersion ) . compareTo ( MINIMUM_PLAY_VERSION_WITH_RUN_SUPPORT ) < <int> ) { runsupportPlayVersion = <str> ; transitive = false ; } DefaultExternalModuleDependency runSupportDependency = new DefaultExternalModuleDependency ( <str> , String . format ( <str> , RUN_SUPPORT_PLAY_MODULE , scalaCompatibilityVersion ) , runsupportPlayVersion ) ; runSupportDependency . setTransitive ( transitive ) ; listBuilder . add ( runSupportDependency ) ; String name = scalaCompatibilityVersion . equals ( <str> ) ? <str> : String . format ( <str> , <str> , scalaCompatibilityVersion ) ; DefaultExternalModuleDependency dependency = new DefaultExternalModuleDependency ( <str> , name , getIOSupportDependencyVersion ( ) , <str> ) ; dependency . setTransitive ( false ) ; listBuilder . add ( dependency ) ; return listBuilder . build ( ) ; } protected String getIOSupportDependencyVersion ( ) { return <str> ; } } 
