package org . elasticsearch . common . cli ; import org . apache . commons . cli . CommandLine ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . cli . CliTool . ExitStatus . OK ; import static org . elasticsearch . common . cli . CliTool . ExitStatus . USAGE ; import static org . elasticsearch . common . cli . CliToolConfig . Builder . cmd ; import static org . hamcrest . Matchers . arrayContaining ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . hasItem ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; @SuppressForbidden ( reason = <str> ) public class CliToolTests extends CliToolTestCase { public void testOK ( ) throws Exception { Terminal terminal = new MockTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) { executed . set ( true ) ; return OK ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; CliTool . ExitStatus status = tool . execute ( ) ; assertStatus ( status , OK ) ; assertCommandHasBeenExecuted ( executed ) ; } public void testUsageError ( ) throws Exception { Terminal terminal = new MockTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) { executed . set ( true ) ; return CliTool . ExitStatus . USAGE ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; CliTool . ExitStatus status = tool . execute ( ) ; assertStatus ( status , CliTool . ExitStatus . USAGE ) ; assertCommandHasBeenExecuted ( executed ) ; } public void testIOError ( ) throws Exception { Terminal terminal = new MockTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { executed . set ( true ) ; throw new IOException ( <str> ) ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; CliTool . ExitStatus status = tool . execute ( ) ; assertStatus ( status , CliTool . ExitStatus . IO_ERROR ) ; assertCommandHasBeenExecuted ( executed ) ; } public void testCodeError ( ) throws Exception { Terminal terminal = new MockTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { executed . set ( true ) ; throw new Exception ( <str> ) ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; CliTool . ExitStatus status = tool . execute ( ) ; assertStatus ( status , CliTool . ExitStatus . CODE_ERROR ) ; assertCommandHasBeenExecuted ( executed ) ; } public void testMultiCommand ( ) { Terminal terminal = new MockTerminal ( ) ; int count = randomIntBetween ( <int> , <int> ) ; final AtomicReference < Boolean > [ ] executed = new AtomicReference [ count ] ; for ( int i = <int> ; i < executed . length ; i + + ) { executed [ i ] = new AtomicReference < > ( false ) ; } NamedCommand [ ] cmds = new NamedCommand [ count ] ; for ( int i = <int> ; i < count ; i + + ) { final int index = i ; cmds [ i ] = new NamedCommand ( <str> + index , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { executed [ index ] . set ( true ) ; return OK ; } } ; } MultiCmdTool tool = new MultiCmdTool ( <str> , terminal , cmds ) ; int cmdIndex = randomIntBetween ( <int> , count - <int> ) ; CliTool . ExitStatus status = tool . execute ( <str> + cmdIndex ) ; assertThat ( status , is ( OK ) ) ; for ( int i = <int> ; i < executed . length ; i + + ) { assertThat ( executed [ i ] . get ( ) , is ( i = = cmdIndex ) ) ; } } public void testMultiCommandUnknownCommand ( ) { Terminal terminal = new MockTerminal ( ) ; int count = randomIntBetween ( <int> , <int> ) ; final AtomicReference < Boolean > [ ] executed = new AtomicReference [ count ] ; for ( int i = <int> ; i < executed . length ; i + + ) { executed [ i ] = new AtomicReference < > ( false ) ; } NamedCommand [ ] cmds = new NamedCommand [ count ] ; for ( int i = <int> ; i < count ; i + + ) { final int index = i ; cmds [ i ] = new NamedCommand ( <str> + index , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { executed [ index ] . set ( true ) ; return OK ; } } ; } MultiCmdTool tool = new MultiCmdTool ( <str> , terminal , cmds ) ; CliTool . ExitStatus status = tool . execute ( <str> + count ) ; assertThat ( status , is ( CliTool . ExitStatus . USAGE ) ) ; for ( int i = <int> ; i < executed . length ; i + + ) { assertThat ( executed [ i ] . get ( ) , is ( false ) ) ; } } public void testSingleCommandToolHelp ( ) throws Exception { CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { executed . set ( true ) ; throw new IOException ( <str> ) ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; CliTool . ExitStatus status = tool . execute ( args ( <str> ) ) ; assertStatus ( status , CliTool . ExitStatus . OK_AND_EXIT ) ; assertThat ( terminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testMultiCommandToolHelp ( ) { CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; NamedCommand [ ] cmds = new NamedCommand [ <int> ] ; cmds [ <int> ] = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { return OK ; } } ; cmds [ <int> ] = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { return OK ; } } ; MultiCmdTool tool = new MultiCmdTool ( <str> , terminal , cmds ) ; CliTool . ExitStatus status = tool . execute ( args ( <str> ) ) ; assertStatus ( status , CliTool . ExitStatus . OK_AND_EXIT ) ; assertThat ( terminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testMultiCommandCmdHelp ( ) { CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; NamedCommand [ ] cmds = new NamedCommand [ <int> ] ; cmds [ <int> ] = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { return OK ; } } ; cmds [ <int> ] = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { return OK ; } } ; MultiCmdTool tool = new MultiCmdTool ( <str> , terminal , cmds ) ; CliTool . ExitStatus status = tool . execute ( args ( <str> ) ) ; assertStatus ( status , CliTool . ExitStatus . OK_AND_EXIT ) ; assertThat ( terminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } public void testThatThrowExceptionCanBeLogged ( ) throws Exception { CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) throws Exception { throw new ElasticsearchException ( <str> ) ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; assertStatus ( tool . execute ( ) , CliTool . ExitStatus . CODE_ERROR ) ; assertThat ( terminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; try { System . setProperty ( Terminal . DEBUG_SYSTEM_PROPERTY , <str> ) ; terminal = new CaptureOutputTerminal ( ) ; assertStatus ( new SingleCmdTool ( <str> , terminal , cmd ) . execute ( ) , CliTool . ExitStatus . CODE_ERROR ) ; assertThat ( terminal . getTerminalOutput ( ) , hasSize ( <int> ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( getClass ( ) . getName ( ) ) ) ) ; } finally { System . clearProperty ( Terminal . DEBUG_SYSTEM_PROPERTY ) ; } } public void testMultipleLaunch ( ) throws Exception { Terminal terminal = new MockTerminal ( ) ; final AtomicReference < Boolean > executed = new AtomicReference < > ( false ) ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) { executed . set ( true ) ; return OK ; } } ; SingleCmdTool tool = new SingleCmdTool ( <str> , terminal , cmd ) ; tool . parse ( <str> , Strings . splitStringByCommaToArray ( <str> ) ) ; tool . parse ( <str> , Strings . splitStringByCommaToArray ( <str> ) ) ; tool . parse ( <str> , Strings . splitStringByCommaToArray ( <str> ) ) ; } public void testPromptForSetting ( ) throws Exception { final AtomicInteger counter = new AtomicInteger ( ) ; final AtomicReference < String > promptedSecretValue = new AtomicReference < > ( null ) ; final AtomicReference < String > promptedTextValue = new AtomicReference < > ( null ) ; final Terminal terminal = new MockTerminal ( ) { @Override public char [ ] readSecret ( String text , Object . . . args ) { counter . incrementAndGet ( ) ; assertThat ( args , arrayContaining ( ( Object ) <str> ) ) ; return <str> . toCharArray ( ) ; } @Override public String readText ( String text , Object . . . args ) { counter . incrementAndGet ( ) ; assertThat ( args , arrayContaining ( ( Object ) <str> ) ) ; return <str> ; } } ; final NamedCommand cmd = new NamedCommand ( <str> , terminal ) { @Override public CliTool . ExitStatus execute ( Settings settings , Environment env ) { promptedSecretValue . set ( settings . get ( <str> ) ) ; promptedTextValue . set ( settings . get ( <str> ) ) ; return OK ; } } ; System . setProperty ( <str> , InternalSettingsPreparer . SECRET_PROMPT_VALUE ) ; System . setProperty ( <str> , InternalSettingsPreparer . TEXT_PROMPT_VALUE ) ; try { new SingleCmdTool ( <str> , terminal , cmd ) . execute ( ) ; } finally { System . clearProperty ( <str> ) ; System . clearProperty ( <str> ) ; } assertThat ( counter . intValue ( ) , is ( <int> ) ) ; assertThat ( promptedSecretValue . get ( ) , is ( <str> ) ) ; assertThat ( promptedTextValue . get ( ) , is ( <str> ) ) ; } public void testStopAtNonOptionParsing ( ) throws Exception { final CliToolConfig . Cmd lenientCommand = cmd ( <str> , CliTool . Command . Exit . class ) . stopAtNonOption ( true ) . build ( ) ; final CliToolConfig . Cmd strictCommand = cmd ( <str> , CliTool . Command . Exit . class ) . stopAtNonOption ( false ) . build ( ) ; final CliToolConfig config = CliToolConfig . config ( <str> , CliTool . class ) . cmds ( lenientCommand , strictCommand ) . build ( ) ; final CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; final CliTool cliTool = new CliTool ( config , terminal ) { @Override protected Command parse ( String cmdName , CommandLine cli ) throws Exception { return new NamedCommand ( cmdName , terminal ) { @Override public ExitStatus execute ( Settings settings , Environment env ) throws Exception { return OK ; } } ; } } ; assertStatus ( cliTool . execute ( args ( <str> ) ) , OK ) ; assertStatus ( cliTool . execute ( args ( <str> ) ) , OK ) ; assertStatus ( cliTool . execute ( args ( <str> ) ) , OK ) ; assertStatus ( cliTool . execute ( args ( <str> ) ) , OK ) ; assertStatus ( cliTool . execute ( args ( <str> ) ) , USAGE ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; terminal . getTerminalOutput ( ) . clear ( ) ; assertStatus ( cliTool . execute ( args ( <str> ) ) , USAGE ) ; assertThat ( terminal . getTerminalOutput ( ) , hasItem ( containsString ( <str> ) ) ) ; } private void assertStatus ( CliTool . ExitStatus status , CliTool . ExitStatus expectedStatus ) { assertThat ( status , is ( expectedStatus ) ) ; } private void assertCommandHasBeenExecuted ( AtomicReference < Boolean > executed ) { assertThat ( <str> , executed . get ( ) , is ( Boolean . TRUE ) ) ; } private static class SingleCmdTool extends CliTool { private final Command command ; private SingleCmdTool ( String name , Terminal terminal , NamedCommand command ) { super ( CliToolConfig . config ( name , SingleCmdTool . class ) . cmds ( cmd ( command . name , command . getClass ( ) ) ) . build ( ) , terminal ) ; this . command = command ; } @Override protected Command parse ( String cmdName , CommandLine cli ) throws Exception { return command ; } } private static class MultiCmdTool extends CliTool { private final Map < String , Command > commands ; private MultiCmdTool ( String name , Terminal terminal , NamedCommand . . . commands ) { super ( CliToolConfig . config ( name , MultiCmdTool . class ) . cmds ( cmds ( commands ) ) . build ( ) , terminal ) ; Map < String , Command > commandByName = new HashMap < > ( ) ; for ( int i = <int> ; i < commands . length ; i + + ) { commandByName . put ( commands [ i ] . name , commands [ i ] ) ; } this . commands = unmodifiableMap ( commandByName ) ; } @Override protected Command parse ( String cmdName , CommandLine cli ) throws Exception { return commands . get ( cmdName ) ; } private static CliToolConfig . Cmd [ ] cmds ( NamedCommand . . . commands ) { CliToolConfig . Cmd [ ] cmds = new CliToolConfig . Cmd [ commands . length ] ; for ( int i = <int> ; i < commands . length ; i + + ) { cmds [ i ] = cmd ( commands [ i ] . name , commands [ i ] . getClass ( ) ) . build ( ) ; } return cmds ; } } private static abstract class NamedCommand extends CliTool . Command { private final String name ; private NamedCommand ( String name , Terminal terminal ) { super ( terminal ) ; this . name = name ; } } } 
