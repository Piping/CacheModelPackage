package clojure . lang ; import java . io . IOException ; import java . io . PushbackReader ; import java . io . Reader ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class EdnReader { static IFn [ ] macros = new IFn [ <int> ] ; static IFn [ ] dispatchMacros = new IFn [ <int> ] ; static Pattern symbolPat = Pattern . compile ( <str> ) ; static Pattern intPat = Pattern . compile ( <str> ) ; static Pattern ratioPat = Pattern . compile ( <str> ) ; static Pattern floatPat = Pattern . compile ( <str> ) ; static IFn taggedReader = new TaggedReader ( ) ; static { macros [ <str> ] = new StringReader ( ) ; macros [ <str> ] = new CommentReader ( ) ; macros [ <str> ] = new MetaReader ( ) ; macros [ <str> ] = new ListReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new VectorReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new MapReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new CharacterReader ( ) ; macros [ <str> ] = new DispatchReader ( ) ; dispatchMacros [ <str> ] = new MetaReader ( ) ; dispatchMacros [ <str> ] = new SetReader ( ) ; dispatchMacros [ <str> ] = new UnreadableReader ( ) ; dispatchMacros [ <str> ] = new DiscardReader ( ) ; } static boolean nonConstituent ( int ch ) { return ch = = <str> | | ch = = <str> | | ch = = <str> ; } static public Object readString ( String s , IPersistentMap opts ) { PushbackReader r = new PushbackReader ( new java . io . StringReader ( s ) ) ; return read ( r , opts ) ; } static boolean isWhitespace ( int ch ) { return Character . isWhitespace ( ch ) | | ch = = <str> ; } static void unread ( PushbackReader r , int ch ) { if ( ch ! = - <int> ) try { r . unread ( ch ) ; } catch ( IOException e ) { throw Util . sneakyThrow ( e ) ; } } public static class ReaderException extends RuntimeException { final int line ; final int column ; public ReaderException ( int line , int column , Throwable cause ) { super ( cause ) ; this . line = line ; this . column = column ; } } static public int read1 ( Reader r ) { try { return r . read ( ) ; } catch ( IOException e ) { throw Util . sneakyThrow ( e ) ; } } static final Keyword EOF = Keyword . intern ( null , <str> ) ; static public Object read ( PushbackReader r , IPersistentMap opts ) { return read ( r , ! opts . containsKey ( EOF ) , opts . valAt ( EOF ) , false , opts ) ; } static public Object read ( PushbackReader r , boolean eofIsError , Object eofValue , boolean isRecursive , Object opts ) { try { for ( ; ; ) { int ch = read1 ( r ) ; while ( isWhitespace ( ch ) ) ch = read1 ( r ) ; if ( ch = = - <int> ) { if ( eofIsError ) throw Util . runtimeException ( <str> ) ; return eofValue ; } if ( Character . isDigit ( ch ) ) { Object n = readNumber ( r , ( char ) ch ) ; if ( RT . suppressRead ( ) ) return null ; return n ; } IFn macroFn = getMacro ( ch ) ; if ( macroFn ! = null ) { Object ret = macroFn . invoke ( r , ( char ) ch , opts ) ; if ( RT . suppressRead ( ) ) return null ; if ( ret = = r ) continue ; return ret ; } if ( ch = = <str> | | ch = = <str> ) { int ch2 = read1 ( r ) ; if ( Character . isDigit ( ch2 ) ) { unread ( r , ch2 ) ; Object n = readNumber ( r , ( char ) ch ) ; if ( RT . suppressRead ( ) ) return null ; return n ; } unread ( r , ch2 ) ; } String token = readToken ( r , ( char ) ch , true ) ; if ( RT . suppressRead ( ) ) return null ; return interpretToken ( token ) ; } } catch ( Exception e ) { if ( isRecursive | | ! ( r instanceof LineNumberingPushbackReader ) ) throw Util . sneakyThrow ( e ) ; LineNumberingPushbackReader rdr = ( LineNumberingPushbackReader ) r ; throw new ReaderException ( rdr . getLineNumber ( ) , rdr . getColumnNumber ( ) , e ) ; } } static private String readToken ( PushbackReader r , char initch , boolean leadConstituent ) { StringBuilder sb = new StringBuilder ( ) ; if ( leadConstituent & & nonConstituent ( initch ) ) throw Util . runtimeException ( <str> + ( char ) initch ) ; sb . append ( initch ) ; for ( ; ; ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isTerminatingMacro ( ch ) ) { unread ( r , ch ) ; return sb . toString ( ) ; } else if ( nonConstituent ( ch ) ) throw Util . runtimeException ( <str> + ( char ) ch ) ; sb . append ( ( char ) ch ) ; } } static private Object readNumber ( PushbackReader r , char initch ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( initch ) ; for ( ; ; ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isMacro ( ch ) ) { unread ( r , ch ) ; break ; } sb . append ( ( char ) ch ) ; } String s = sb . toString ( ) ; Object n = matchNumber ( s ) ; if ( n = = null ) throw new NumberFormatException ( <str> + s ) ; return n ; } static private int readUnicodeChar ( String token , int offset , int length , int base ) { if ( token . length ( ) ! = offset + length ) throw new IllegalArgumentException ( <str> + token ) ; int uc = <int> ; for ( int i = offset ; i < offset + length ; + + i ) { int d = Character . digit ( token . charAt ( i ) , base ) ; if ( d = = - <int> ) throw new IllegalArgumentException ( <str> + token . charAt ( i ) ) ; uc = uc * base + d ; } return ( char ) uc ; } static private int readUnicodeChar ( PushbackReader r , int initch , int base , int length , boolean exact ) { int uc = Character . digit ( initch , base ) ; if ( uc = = - <int> ) throw new IllegalArgumentException ( <str> + ( char ) initch ) ; int i = <int> ; for ( ; i < length ; + + i ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isMacro ( ch ) ) { unread ( r , ch ) ; break ; } int d = Character . digit ( ch , base ) ; if ( d = = - <int> ) throw new IllegalArgumentException ( <str> + ( char ) ch ) ; uc = uc * base + d ; } if ( i ! = length & & exact ) throw new IllegalArgumentException ( <str> + i + <str> + length ) ; return uc ; } static private Object interpretToken ( String s ) { if ( s . equals ( <str> ) ) { return null ; } else if ( s . equals ( <str> ) ) { return RT . T ; } else if ( s . equals ( <str> ) ) { return RT . F ; } Object ret = null ; ret = matchSymbol ( s ) ; if ( ret ! = null ) return ret ; throw Util . runtimeException ( <str> + s ) ; } private static Object matchSymbol ( String s ) { Matcher m = symbolPat . matcher ( s ) ; if ( m . matches ( ) ) { int gc = m . groupCount ( ) ; String ns = m . group ( <int> ) ; String name = m . group ( <int> ) ; if ( ns ! = null & & ns . endsWith ( <str> ) | | name . endsWith ( <str> ) | | s . indexOf ( <str> , <int> ) ! = - <int> ) return null ; if ( s . startsWith ( <str> ) ) { return null ; } boolean isKeyword = s . charAt ( <int> ) = = <str> ; Symbol sym = Symbol . intern ( s . substring ( isKeyword ? <int> : <int> ) ) ; if ( isKeyword ) return Keyword . intern ( sym ) ; return sym ; } return null ; } private static Object matchNumber ( String s ) { Matcher m = intPat . matcher ( s ) ; if ( m . matches ( ) ) { if ( m . group ( <int> ) ! = null ) { if ( m . group ( <int> ) ! = null ) return BigInt . ZERO ; return Numbers . num ( <int> ) ; } boolean negate = ( m . group ( <int> ) . equals ( <str> ) ) ; String n ; int radix = <int> ; if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = Integer . parseInt ( m . group ( <int> ) ) ; if ( n = = null ) return null ; BigInteger bn = new BigInteger ( n , radix ) ; if ( negate ) bn = bn . negate ( ) ; if ( m . group ( <int> ) ! = null ) return BigInt . fromBigInteger ( bn ) ; return bn . bitLength ( ) < <int> ? Numbers . num ( bn . longValue ( ) ) : BigInt . fromBigInteger ( bn ) ; } m = floatPat . matcher ( s ) ; if ( m . matches ( ) ) { if ( m . group ( <int> ) ! = null ) return new BigDecimal ( m . group ( <int> ) ) ; return Double . parseDouble ( s ) ; } m = ratioPat . matcher ( s ) ; if ( m . matches ( ) ) { String numerator = m . group ( <int> ) ; if ( numerator . startsWith ( <str> ) ) numerator = numerator . substring ( <int> ) ; return Numbers . divide ( Numbers . reduceBigInt ( BigInt . fromBigInteger ( new BigInteger ( numerator ) ) ) , Numbers . reduceBigInt ( BigInt . fromBigInteger ( new BigInteger ( m . group ( <int> ) ) ) ) ) ; } return null ; } static private IFn getMacro ( int ch ) { if ( ch < macros . length ) return macros [ ch ] ; return null ; } static private boolean isMacro ( int ch ) { return ( ch < macros . length & & macros [ ch ] ! = null ) ; } static private boolean isTerminatingMacro ( int ch ) { return ( ch ! = <str> & & ch ! = <str> & & isMacro ( ch ) ) ; } public static class StringReader extends AFn { public Object invoke ( Object reader , Object doublequote , Object opts ) { StringBuilder sb = new StringBuilder ( ) ; Reader r = ( Reader ) reader ; for ( int ch = read1 ( r ) ; ch ! = <str> ; ch = read1 ( r ) ) { if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; if ( ch = = <str> ) { ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; switch ( ch ) { case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : break ; case <str> : break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : { ch = read1 ( r ) ; if ( Character . digit ( ch , <int> ) = = - <int> ) throw Util . runtimeException ( <str> + ( char ) ch ) ; ch = readUnicodeChar ( ( PushbackReader ) r , ch , <int> , <int> , true ) ; break ; } default : { if ( Character . isDigit ( ch ) ) { ch = readUnicodeChar ( ( PushbackReader ) r , ch , <int> , <int> , false ) ; if ( ch > <oct> ) throw Util . runtimeException ( <str> ) ; } else throw Util . runtimeException ( <str> + ( char ) ch ) ; } } } sb . append ( ( char ) ch ) ; } return sb . toString ( ) ; } } public static class CommentReader extends AFn { public Object invoke ( Object reader , Object semicolon , Object opts ) { Reader r = ( Reader ) reader ; int ch ; do { ch = read1 ( r ) ; } while ( ch ! = - <int> & & ch ! = <str> & & ch ! = <str> ) ; return r ; } } public static class DiscardReader extends AFn { public Object invoke ( Object reader , Object underscore , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; read ( r , true , null , true , opts ) ; return r ; } } public static class DispatchReader extends AFn { public Object invoke ( Object reader , Object hash , Object opts ) { int ch = read1 ( ( Reader ) reader ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; IFn fn = dispatchMacros [ ch ] ; if ( fn = = null ) { if ( Character . isLetter ( ch ) ) { unread ( ( PushbackReader ) reader , ch ) ; return taggedReader . invoke ( reader , ch , opts ) ; } throw Util . runtimeException ( String . format ( <str> , ( char ) ch ) ) ; } return fn . invoke ( reader , ch , opts ) ; } } public static class MetaReader extends AFn { public Object invoke ( Object reader , Object caret , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; int line = - <int> ; int column = - <int> ; if ( r instanceof LineNumberingPushbackReader ) { line = ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) ; column = ( ( LineNumberingPushbackReader ) r ) . getColumnNumber ( ) - <int> ; } Object meta = read ( r , true , null , true , opts ) ; if ( meta instanceof Symbol | | meta instanceof String ) meta = RT . map ( RT . TAG_KEY , meta ) ; else if ( meta instanceof Keyword ) meta = RT . map ( meta , RT . T ) ; else if ( ! ( meta instanceof IPersistentMap ) ) throw new IllegalArgumentException ( <str> ) ; Object o = read ( r , true , null , true , opts ) ; if ( o instanceof IMeta ) { if ( line ! = - <int> & & o instanceof ISeq ) { meta = ( ( IPersistentMap ) meta ) . assoc ( RT . LINE_KEY , line ) . assoc ( RT . COLUMN_KEY , column ) ; } if ( o instanceof IReference ) { ( ( IReference ) o ) . resetMeta ( ( IPersistentMap ) meta ) ; return o ; } Object ometa = RT . meta ( o ) ; for ( ISeq s = RT . seq ( meta ) ; s ! = null ; s = s . next ( ) ) { IMapEntry kv = ( IMapEntry ) s . first ( ) ; ometa = RT . assoc ( ometa , kv . getKey ( ) , kv . getValue ( ) ) ; } return ( ( IObj ) o ) . withMeta ( ( IPersistentMap ) ometa ) ; } else throw new IllegalArgumentException ( <str> ) ; } } public static class CharacterReader extends AFn { public Object invoke ( Object reader , Object backslash , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; int ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; String token = readToken ( r , ( char ) ch , false ) ; if ( token . length ( ) = = <int> ) return Character . valueOf ( token . charAt ( <int> ) ) ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . startsWith ( <str> ) ) { char c = ( char ) readUnicodeChar ( token , <int> , <int> , <int> ) ; if ( c > = <str> & & c < = <str> ) throw Util . runtimeException ( <str> + Integer . toString ( c , <int> ) ) ; return c ; } else if ( token . startsWith ( <str> ) ) { int len = token . length ( ) - <int> ; if ( len > <int> ) throw Util . runtimeException ( <str> + len ) ; int uc = readUnicodeChar ( token , <int> , len , <int> ) ; if ( uc > <oct> ) throw Util . runtimeException ( <str> ) ; return ( char ) uc ; } throw Util . runtimeException ( <str> + token ) ; } } public static class ListReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; int line = - <int> ; int column = - <int> ; if ( r instanceof LineNumberingPushbackReader ) { line = ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) ; column = ( ( LineNumberingPushbackReader ) r ) . getColumnNumber ( ) - <int> ; } List list = readDelimitedList ( <str> , r , true , opts ) ; if ( list . isEmpty ( ) ) return PersistentList . EMPTY ; IObj s = ( IObj ) PersistentList . create ( list ) ; return s ; } } public static class VectorReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; return LazilyPersistentVector . create ( readDelimitedList ( <str> , r , true , opts ) ) ; } } public static class MapReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; Object [ ] a = readDelimitedList ( <str> , r , true , opts ) . toArray ( ) ; if ( ( a . length & <int> ) = = <int> ) throw Util . runtimeException ( <str> ) ; return RT . map ( a ) ; } } public static class SetReader extends AFn { public Object invoke ( Object reader , Object leftbracket , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; return PersistentHashSet . createWithCheck ( readDelimitedList ( <str> , r , true , opts ) ) ; } } public static class UnmatchedDelimiterReader extends AFn { public Object invoke ( Object reader , Object rightdelim , Object opts ) { throw Util . runtimeException ( <str> + rightdelim ) ; } } public static class UnreadableReader extends AFn { public Object invoke ( Object reader , Object leftangle , Object opts ) { throw Util . runtimeException ( <str> ) ; } } public static List readDelimitedList ( char delim , PushbackReader r , boolean isRecursive , Object opts ) { final int firstline = ( r instanceof LineNumberingPushbackReader ) ? ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) : - <int> ; ArrayList a = new ArrayList ( ) ; for ( ; ; ) { int ch = read1 ( r ) ; while ( isWhitespace ( ch ) ) ch = read1 ( r ) ; if ( ch = = - <int> ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline ) ; } if ( ch = = delim ) break ; IFn macroFn = getMacro ( ch ) ; if ( macroFn ! = null ) { Object mret = macroFn . invoke ( r , ( char ) ch , opts ) ; if ( mret ! = r ) a . add ( mret ) ; } else { unread ( r , ch ) ; Object o = read ( r , true , null , isRecursive , opts ) ; if ( o ! = r ) a . add ( o ) ; } } return a ; } public static class TaggedReader extends AFn { public Object invoke ( Object reader , Object firstChar , Object opts ) { PushbackReader r = ( PushbackReader ) reader ; Object name = read ( r , true , null , false , opts ) ; if ( ! ( name instanceof Symbol ) ) throw new RuntimeException ( <str> ) ; Symbol sym = ( Symbol ) name ; return readTagged ( r , sym , ( IPersistentMap ) opts ) ; } static Keyword READERS = Keyword . intern ( null , <str> ) ; static Keyword DEFAULT = Keyword . intern ( null , <str> ) ; private Object readTagged ( PushbackReader reader , Symbol tag , IPersistentMap opts ) { Object o = read ( reader , true , null , true , opts ) ; ILookup readers = ( ILookup ) RT . get ( opts , READERS ) ; IFn dataReader = ( IFn ) RT . get ( readers , tag ) ; if ( dataReader = = null ) dataReader = ( IFn ) RT . get ( RT . DEFAULT_DATA_READERS . deref ( ) , tag ) ; if ( dataReader = = null ) { IFn defaultReader = ( IFn ) RT . get ( opts , DEFAULT ) ; if ( defaultReader ! = null ) return defaultReader . invoke ( tag , o ) ; else throw new RuntimeException ( <str> + tag . toString ( ) ) ; } else return dataReader . invoke ( o ) ; } } } 
