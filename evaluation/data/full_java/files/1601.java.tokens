package org . apache . cassandra . repair ; import java . net . InetAddress ; import java . util . Arrays ; import java . util . UUID ; import org . junit . After ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . BufferDecoratedKey ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . EmptyIterators ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . net . IMessageSink ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . repair . messages . RepairMessage ; import org . apache . cassandra . repair . messages . ValidationComplete ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . MerkleTrees ; import org . apache . cassandra . utils . concurrent . SimpleCondition ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; public class ValidatorTest { private static final String keyspace = <str> ; private static final String columnFamily = <str> ; private static IPartitioner partitioner ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( keyspace , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( keyspace , columnFamily ) ) ; partitioner = Schema . instance . getCFMetaData ( keyspace , columnFamily ) . partitioner ; } @After public void tearDown ( ) { MessagingService . instance ( ) . clearMessageSinks ( ) ; } @Test public void testValidatorComplete ( ) throws Throwable { Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , Arrays . asList ( range ) ) ; final SimpleCondition lock = new SimpleCondition ( ) ; MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) { public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) { try { if ( message . verb = = MessagingService . Verb . REPAIR_MESSAGE ) { RepairMessage m = ( RepairMessage ) message . payload ; assertEquals ( RepairMessage . Type . VALIDATION_COMPLETE , m . messageType ) ; assertEquals ( desc , m . desc ) ; assertTrue ( ( ( ValidationComplete ) m ) . success ( ) ) ; assertNotNull ( ( ( ValidationComplete ) m ) . trees ) ; } } finally { lock . signalAll ( ) ; } return false ; } public boolean allowIncomingMessage ( MessageIn message , int id ) { return false ; } } ) ; InetAddress remote = InetAddress . getByName ( <str> ) ; ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( columnFamily ) ; Validator validator = new Validator ( desc , remote , <int> ) ; MerkleTrees tree = new MerkleTrees ( partitioner ) ; tree . addMerkleTrees ( ( int ) Math . pow ( <int> , <int> ) , validator . desc . ranges ) ; validator . prepare ( cfs , tree ) ; assertTrue ( tree . size ( ) > <int> ) ; Token mid = partitioner . midpoint ( range . left , range . right ) ; validator . add ( EmptyIterators . unfilteredRow ( cfs . metadata , new BufferDecoratedKey ( mid , ByteBufferUtil . bytes ( <str> ) ) , false ) ) ; validator . complete ( ) ; Token min = tree . partitioner ( ) . getMinimumToken ( ) ; assertNotNull ( tree . hash ( new Range < > ( min , min ) ) ) ; if ( ! lock . isSignaled ( ) ) lock . await ( ) ; } @Test public void testValidatorFailed ( ) throws Throwable { Range < Token > range = new Range < > ( partitioner . getMinimumToken ( ) , partitioner . getRandomToken ( ) ) ; final RepairJobDesc desc = new RepairJobDesc ( UUID . randomUUID ( ) , UUID . randomUUID ( ) , keyspace , columnFamily , Arrays . asList ( range ) ) ; final SimpleCondition lock = new SimpleCondition ( ) ; MessagingService . instance ( ) . addMessageSink ( new IMessageSink ( ) { public boolean allowOutgoingMessage ( MessageOut message , int id , InetAddress to ) { try { if ( message . verb = = MessagingService . Verb . REPAIR_MESSAGE ) { RepairMessage m = ( RepairMessage ) message . payload ; assertEquals ( RepairMessage . Type . VALIDATION_COMPLETE , m . messageType ) ; assertEquals ( desc , m . desc ) ; assertFalse ( ( ( ValidationComplete ) m ) . success ( ) ) ; assertNull ( ( ( ValidationComplete ) m ) . trees ) ; } } finally { lock . signalAll ( ) ; } return false ; } public boolean allowIncomingMessage ( MessageIn message , int id ) { return false ; } } ) ; InetAddress remote = InetAddress . getByName ( <str> ) ; Validator validator = new Validator ( desc , remote , <int> ) ; validator . fail ( ) ; if ( ! lock . isSignaled ( ) ) lock . await ( ) ; } } 
