package org . elasticsearch . index . fielddata ; import org . apache . lucene . index . SortedNumericDocValues ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . unit . DistanceUnit ; import org . joda . time . DateTimeZone ; import org . joda . time . MutableDateTime ; import java . util . AbstractList ; import java . util . Collections ; import java . util . List ; public interface ScriptDocValues < T > extends List < T > { void setNextDocId ( int docId ) ; List < T > getValues ( ) ; public final static class Strings extends AbstractList < String > implements ScriptDocValues < String > { private final SortedBinaryDocValues values ; public Strings ( SortedBinaryDocValues values ) { this . values = values ; } @Override public void setNextDocId ( int docId ) { values . setDocument ( docId ) ; } public SortedBinaryDocValues getInternalValues ( ) { return this . values ; } public BytesRef getBytesValue ( ) { if ( values . count ( ) > <int> ) { return values . valueAt ( <int> ) ; } else { return null ; } } public String getValue ( ) { BytesRef value = getBytesValue ( ) ; if ( value = = null ) { return null ; } else { return value . utf8ToString ( ) ; } } @Override public List < String > getValues ( ) { return Collections . unmodifiableList ( this ) ; } @Override public String get ( int index ) { return values . valueAt ( index ) . utf8ToString ( ) ; } @Override public int size ( ) { return values . count ( ) ; } } public static class Longs extends AbstractList < Long > implements ScriptDocValues < Long > { private final SortedNumericDocValues values ; private final MutableDateTime date = new MutableDateTime ( <int> , DateTimeZone . UTC ) ; public Longs ( SortedNumericDocValues values ) { this . values = values ; } @Override public void setNextDocId ( int docId ) { values . setDocument ( docId ) ; } public SortedNumericDocValues getInternalValues ( ) { return this . values ; } public long getValue ( ) { int numValues = values . count ( ) ; if ( numValues = = <int> ) { return <int> l ; } return values . valueAt ( <int> ) ; } @Override public List < Long > getValues ( ) { return Collections . unmodifiableList ( this ) ; } public MutableDateTime getDate ( ) { date . setMillis ( getValue ( ) ) ; return date ; } @Override public Long get ( int index ) { return values . valueAt ( index ) ; } @Override public int size ( ) { return values . count ( ) ; } } public static class Doubles extends AbstractList < Double > implements ScriptDocValues < Double > { private final SortedNumericDoubleValues values ; public Doubles ( SortedNumericDoubleValues values ) { this . values = values ; } @Override public void setNextDocId ( int docId ) { values . setDocument ( docId ) ; } public SortedNumericDoubleValues getInternalValues ( ) { return this . values ; } public double getValue ( ) { int numValues = values . count ( ) ; if ( numValues = = <int> ) { return <float> ; } return values . valueAt ( <int> ) ; } @Override public List < Double > getValues ( ) { return Collections . unmodifiableList ( this ) ; } @Override public Double get ( int index ) { return values . valueAt ( index ) ; } @Override public int size ( ) { return values . count ( ) ; } } public static class GeoPoints extends AbstractList < GeoPoint > implements ScriptDocValues < GeoPoint > { private final MultiGeoPointValues values ; public GeoPoints ( MultiGeoPointValues values ) { this . values = values ; } @Override public void setNextDocId ( int docId ) { values . setDocument ( docId ) ; } public GeoPoint getValue ( ) { int numValues = values . count ( ) ; if ( numValues = = <int> ) { return null ; } return values . valueAt ( <int> ) ; } public double getLat ( ) { return getValue ( ) . lat ( ) ; } public double [ ] getLats ( ) { List < GeoPoint > points = getValues ( ) ; double [ ] lats = new double [ points . size ( ) ] ; for ( int i = <int> ; i < points . size ( ) ; i + + ) { lats [ i ] = points . get ( i ) . lat ( ) ; } return lats ; } public double [ ] getLons ( ) { List < GeoPoint > points = getValues ( ) ; double [ ] lons = new double [ points . size ( ) ] ; for ( int i = <int> ; i < points . size ( ) ; i + + ) { lons [ i ] = points . get ( i ) . lon ( ) ; } return lons ; } public double getLon ( ) { return getValue ( ) . lon ( ) ; } @Override public List < GeoPoint > getValues ( ) { return Collections . unmodifiableList ( this ) ; } @Override public GeoPoint get ( int index ) { final GeoPoint point = values . valueAt ( index ) ; return new GeoPoint ( point . lat ( ) , point . lon ( ) ) ; } @Override public int size ( ) { return values . count ( ) ; } public double factorDistance ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . FACTOR . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double factorDistanceWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . FACTOR . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double factorDistance02 ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . FACTOR . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) + <int> ; } public double factorDistance13 ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . FACTOR . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) + <int> ; } public double arcDistance ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double arcDistanceWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double arcDistanceInKm ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . KILOMETERS ) ; } public double arcDistanceInKmWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . KILOMETERS ) ; } public double arcDistanceInMiles ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . MILES ) ; } public double arcDistanceInMilesWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . MILES ) ; } public double distance ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double distanceWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . DEFAULT ) ; } public double distanceInKm ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . KILOMETERS ) ; } public double distanceInKmWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . KILOMETERS ) ; } public double distanceInMiles ( double lat , double lon ) { GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . MILES ) ; } public double distanceInMilesWithDefault ( double lat , double lon , double defaultValue ) { if ( isEmpty ( ) ) { return defaultValue ; } GeoPoint point = getValue ( ) ; return GeoDistance . PLANE . calculate ( point . lat ( ) , point . lon ( ) , lat , lon , DistanceUnit . MILES ) ; } public double geohashDistance ( String geohash ) { GeoPoint point = getValue ( ) ; GeoPoint p = new GeoPoint ( ) . resetFromGeoHash ( geohash ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , p . lat ( ) , p . lon ( ) , DistanceUnit . DEFAULT ) ; } public double geohashDistanceInKm ( String geohash ) { GeoPoint point = getValue ( ) ; GeoPoint p = new GeoPoint ( ) . resetFromGeoHash ( geohash ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , p . lat ( ) , p . lon ( ) , DistanceUnit . KILOMETERS ) ; } public double geohashDistanceInMiles ( String geohash ) { GeoPoint point = getValue ( ) ; GeoPoint p = new GeoPoint ( ) . resetFromGeoHash ( geohash ) ; return GeoDistance . ARC . calculate ( point . lat ( ) , point . lon ( ) , p . lat ( ) , p . lon ( ) , DistanceUnit . MILES ) ; } } } 
