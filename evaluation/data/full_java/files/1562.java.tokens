package org . apache . cassandra . io . sstable ; import java . nio . charset . CharacterCodingException ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ExecutionException ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . apache . cassandra . Util . getBytes ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class SSTableMetadataTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; public static final String CF_STANDARD2 = <str> ; public static final String CF_STANDARD3 = <str> ; public static final String CF_STANDARDCOMPOSITE2 = <str> ; public static final String CF_COUNTER1 = <str> ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD3 ) , CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARDCOMPOSITE2 ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , IntegerType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) , SchemaLoader . counterCFMD ( KEYSPACE1 , CF_COUNTER1 ) ) ; } @Test public void testTrackMaxDeletionTime ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; long timestamp = System . currentTimeMillis ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { DecoratedKey key = Util . dk ( Integer . toString ( i ) ) ; for ( int j = <int> ; j < <int> ; j + + ) new RowUpdateBuilder ( store . metadata , timestamp , <int> + j , Integer . toString ( i ) ) . clustering ( Integer . toString ( j ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } new RowUpdateBuilder ( store . metadata , timestamp , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; int ttltimestamp = ( int ) ( System . currentTimeMillis ( ) / <int> ) ; int firstDelTime = <int> ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { firstDelTime = sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ; assertEquals ( ttltimestamp + <int> , firstDelTime , <int> ) ; } new RowUpdateBuilder ( store . metadata , timestamp , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; ttltimestamp = ( int ) ( System . currentTimeMillis ( ) / <int> ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; List < SSTableReader > sstables = new ArrayList < > ( store . getLiveSSTables ( ) ) ; if ( sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime < sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime ) { assertEquals ( sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime , firstDelTime ) ; assertEquals ( sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime , ttltimestamp + <int> , <int> ) ; } else { assertEquals ( sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime , firstDelTime ) ; assertEquals ( sstables . get ( <int> ) . getSSTableMetadata ( ) . maxLocalDeletionTime , ttltimestamp + <int> , <int> ) ; } Util . compact ( store , store . getLiveSSTables ( ) ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { assertEquals ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime , ttltimestamp + <int> , <int> ) ; } } @Test public void testWithDeletes ( ) throws ExecutionException , InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; long timestamp = System . currentTimeMillis ( ) ; DecoratedKey key = Util . dk ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) new RowUpdateBuilder ( store . metadata , timestamp , <int> , <str> ) . clustering ( <str> + i ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( store . metadata , timestamp , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; int ttltimestamp = ( int ) ( System . currentTimeMillis ( ) / <int> ) ; int firstMaxDelTime = <int> ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { firstMaxDelTime = sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ; assertEquals ( ttltimestamp + <int> , firstMaxDelTime , <int> ) ; } RowUpdateBuilder . deleteRow ( store . metadata , timestamp + <int> , <str> , <str> ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; boolean foundDelete = false ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { if ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime ! = firstMaxDelTime ) { assertEquals ( sstable . getSSTableMetadata ( ) . maxLocalDeletionTime , ttltimestamp , <int> ) ; foundDelete = true ; } } assertTrue ( foundDelete ) ; Util . compact ( store , store . getLiveSSTables ( ) ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { assertEquals ( ttltimestamp + <int> , sstable . getSSTableMetadata ( ) . maxLocalDeletionTime , <int> ) ; } } @Test public void trackMaxMinColNames ( ) throws CharacterCodingException , ExecutionException , InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; for ( int j = <int> ; j < <int> ; j + + ) { String key = <str> + j ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( store . metadata , System . currentTimeMillis ( ) , key ) . clustering ( j + <str> + i ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } } store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { assertEquals ( ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . minClusteringValues . get ( <int> ) ) , <str> ) ; assertEquals ( ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . maxClusteringValues . get ( <int> ) ) , <str> ) ; } String key = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( store . metadata , System . currentTimeMillis ( ) , key ) . clustering ( <int> + <str> + i ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; store . forceMajorCompaction ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { assertEquals ( ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . minClusteringValues . get ( <int> ) ) , <str> ) ; assertEquals ( ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . maxClusteringValues . get ( <int> ) ) , <str> ) ; } } @Test public void testMaxMinComposites ( ) throws CharacterCodingException , ExecutionException , InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> + ( <int> - i ) , getBytes ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> + ( <int> - i ) , getBytes ( i ) ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; cfs . forceMajorCompaction ( ) ; assertEquals ( cfs . getLiveSSTables ( ) . size ( ) , <int> ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) { assertEquals ( <str> , ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . maxClusteringValues . get ( <int> ) ) ) ; assertEquals ( <int> , ByteBufferUtil . toInt ( sstable . getSSTableMetadata ( ) . maxClusteringValues . get ( <int> ) ) ) ; assertEquals ( <str> , ByteBufferUtil . string ( sstable . getSSTableMetadata ( ) . minClusteringValues . get ( <int> ) ) ) ; assertEquals ( <int> , ByteBufferUtil . toInt ( sstable . getSSTableMetadata ( ) . minClusteringValues . get ( <int> ) ) ) ; } } } 
