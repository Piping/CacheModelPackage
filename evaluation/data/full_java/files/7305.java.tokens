package org . elasticsearch . search . aggregations . metrics . geocentroid ; import org . apache . lucene . util . GeoUtils ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . metrics . InternalMetricsAggregation ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class InternalGeoCentroid extends InternalMetricsAggregation implements GeoCentroid { public final static Type TYPE = new Type ( <str> ) ; public final static AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public InternalGeoCentroid readResult ( StreamInput in ) throws IOException { InternalGeoCentroid result = new InternalGeoCentroid ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } protected GeoPoint centroid ; protected long count ; protected InternalGeoCentroid ( ) { } public InternalGeoCentroid ( String name , GeoPoint centroid , long count , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; this . centroid = centroid ; assert count > = <int> ; this . count = count ; } @Override public GeoPoint centroid ( ) { return ( centroid = = null | | Double . isNaN ( centroid . lon ( ) ) ? null : centroid ) ; } @Override public long count ( ) { return count ; } @Override public Type type ( ) { return TYPE ; } @Override public InternalGeoCentroid doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { double lonSum = Double . NaN ; double latSum = Double . NaN ; int totalCount = <int> ; for ( InternalAggregation aggregation : aggregations ) { InternalGeoCentroid centroidAgg = ( InternalGeoCentroid ) aggregation ; if ( centroidAgg . count > <int> ) { totalCount + = centroidAgg . count ; if ( Double . isNaN ( lonSum ) ) { lonSum = centroidAgg . count * centroidAgg . centroid . getLon ( ) ; latSum = centroidAgg . count * centroidAgg . centroid . getLat ( ) ; } else { lonSum + = ( centroidAgg . count * centroidAgg . centroid . getLon ( ) ) ; latSum + = ( centroidAgg . count * centroidAgg . centroid . getLat ( ) ) ; } } } final GeoPoint result = ( Double . isNaN ( lonSum ) ) ? null : new GeoPoint ( latSum / totalCount , lonSum / totalCount ) ; return new InternalGeoCentroid ( name , result , totalCount , pipelineAggregators ( ) , getMetaData ( ) ) ; } @Override public Object getProperty ( List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } else if ( path . size ( ) = = <int> ) { String coordinate = path . get ( <int> ) ; switch ( coordinate ) { case <str> : return centroid ; case <str> : return centroid . lat ( ) ; case <str> : return centroid . lon ( ) ; default : throw new IllegalArgumentException ( <str> + coordinate + <str> + getName ( ) + <str> ) ; } } else { throw new IllegalArgumentException ( <str> + getName ( ) + <str> + path ) ; } } @Override protected void doReadFrom ( StreamInput in ) throws IOException { count = in . readVLong ( ) ; if ( in . readBoolean ( ) ) { centroid = GeoPoint . fromIndexLong ( in . readLong ( ) ) ; } else { centroid = null ; } } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeVLong ( count ) ; if ( centroid ! = null ) { out . writeBoolean ( true ) ; out . writeLong ( GeoUtils . mortonHash ( centroid . lon ( ) , centroid . lat ( ) ) ) ; } else { out . writeBoolean ( false ) ; } } static class Fields { public static final XContentBuilderString CENTROID = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { if ( centroid ! = null ) { builder . startObject ( Fields . CENTROID ) . field ( <str> , centroid . lat ( ) ) . field ( <str> , centroid . lon ( ) ) . endObject ( ) ; } return builder ; } } 
