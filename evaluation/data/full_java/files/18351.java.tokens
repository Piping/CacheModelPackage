package com . badlogic . gdx . utils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . utils . JsonValue . ValueType ; public class JsonReader implements BaseJsonReader { public JsonValue parse ( String json ) { char [ ] data = json . toCharArray ( ) ; return parse ( data , <int> , data . length ) ; } public JsonValue parse ( Reader reader ) { try { char [ ] data = new char [ <int> ] ; int offset = <int> ; while ( true ) { int length = reader . read ( data , offset , data . length - offset ) ; if ( length = = - <int> ) break ; if ( length = = <int> ) { char [ ] newData = new char [ data . length * <int> ] ; System . arraycopy ( data , <int> , newData , <int> , data . length ) ; data = newData ; } else offset + = length ; } return parse ( data , <int> , offset ) ; } catch ( IOException ex ) { throw new SerializationException ( ex ) ; } finally { StreamUtils . closeQuietly ( reader ) ; } } public JsonValue parse ( InputStream input ) { try { return parse ( new InputStreamReader ( input , <str> ) ) ; } catch ( IOException ex ) { throw new SerializationException ( ex ) ; } finally { StreamUtils . closeQuietly ( input ) ; } } public JsonValue parse ( FileHandle file ) { try { return parse ( file . reader ( <str> ) ) ; } catch ( Exception ex ) { throw new SerializationException ( <str> + file , ex ) ; } } public JsonValue parse ( char [ ] data , int offset , int length ) { int cs , p = offset , pe = length , eof = pe , top = <int> ; int [ ] stack = new int [ <int> ] ; int s = <int> ; Array < String > names = new Array ( <int> ) ; boolean needsUnescape = false , stringIsName = false , stringIsUnquoted = false ; RuntimeException parseRuntimeEx = null ; boolean debug = false ; if ( debug ) System . out . println ( ) ; try { { cs = json_start ; top = <int> ; } { int _klen ; int _trans = <int> ; int _acts ; int _nacts ; int _keys ; int _goto_targ = <int> ; _goto: while ( true ) { switch ( _goto_targ ) { case <int> : if ( p = = pe ) { _goto_targ = <int> ; continue _goto ; } if ( cs = = <int> ) { _goto_targ = <int> ; continue _goto ; } case <int> : _match : do { _keys = _json_key_offsets [ cs ] ; _trans = _json_index_offsets [ cs ] ; _klen = _json_single_lengths [ cs ] ; if ( _klen > <int> ) { int _lower = _keys ; int _mid ; int _upper = _keys + _klen - <int> ; while ( true ) { if ( _upper < _lower ) break ; _mid = _lower + ( ( _upper - _lower ) > > <int> ) ; if ( data [ p ] < _json_trans_keys [ _mid ] ) _upper = _mid - <int> ; else if ( data [ p ] > _json_trans_keys [ _mid ] ) _lower = _mid + <int> ; else { _trans + = ( _mid - _keys ) ; break _match ; } } _keys + = _klen ; _trans + = _klen ; } _klen = _json_range_lengths [ cs ] ; if ( _klen > <int> ) { int _lower = _keys ; int _mid ; int _upper = _keys + ( _klen < < <int> ) - <int> ; while ( true ) { if ( _upper < _lower ) break ; _mid = _lower + ( ( ( _upper - _lower ) > > <int> ) & ~ <int> ) ; if ( data [ p ] < _json_trans_keys [ _mid ] ) _upper = _mid - <int> ; else if ( data [ p ] > _json_trans_keys [ _mid + <int> ] ) _lower = _mid + <int> ; else { _trans + = ( ( _mid - _keys ) > > <int> ) ; break _match ; } } _trans + = _klen ; } } while ( false ) ; _trans = _json_indicies [ _trans ] ; cs = _json_trans_targs [ _trans ] ; if ( _json_trans_actions [ _trans ] ! = <int> ) { _acts = _json_trans_actions [ _trans ] ; _nacts = ( int ) _json_actions [ _acts + + ] ; while ( _nacts - - > <int> ) { switch ( _json_actions [ _acts + + ] ) { case <int> : { stringIsName = true ; } break ; case <int> : { String value = new String ( data , s , p - s ) ; if ( needsUnescape ) value = unescape ( value ) ; outer : if ( stringIsName ) { stringIsName = false ; if ( debug ) System . out . println ( <str> + value ) ; names . add ( value ) ; } else { String name = names . size > <int> ? names . pop ( ) : null ; if ( stringIsUnquoted ) { if ( value . equals ( <str> ) ) { if ( debug ) System . out . println ( <str> + name + <str> ) ; bool ( name , true ) ; break outer ; } else if ( value . equals ( <str> ) ) { if ( debug ) System . out . println ( <str> + name + <str> ) ; bool ( name , false ) ; break outer ; } else if ( value . equals ( <str> ) ) { string ( name , null ) ; break outer ; } boolean couldBeDouble = false , couldBeLong = true ; outer2 : for ( int i = s ; i < p ; i + + ) { switch ( data [ i ] ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : break ; case <str> : case <str> : case <str> : couldBeDouble = true ; couldBeLong = false ; break ; default : couldBeDouble = false ; couldBeLong = false ; break outer2 ; } } if ( couldBeDouble ) { try { if ( debug ) System . out . println ( <str> + name + <str> + Double . parseDouble ( value ) ) ; number ( name , Double . parseDouble ( value ) , value ) ; break outer ; } catch ( NumberFormatException ignored ) { } } else if ( couldBeLong ) { if ( debug ) System . out . println ( <str> + name + <str> + Double . parseDouble ( value ) ) ; try { number ( name , Long . parseLong ( value ) , value ) ; break outer ; } catch ( NumberFormatException ignored ) { } } } if ( debug ) System . out . println ( <str> + name + <str> + value ) ; string ( name , value ) ; } stringIsUnquoted = false ; s = p ; } break ; case <int> : { String name = names . size > <int> ? names . pop ( ) : null ; if ( debug ) System . out . println ( <str> + name ) ; startObject ( name ) ; { if ( top = = stack . length ) { int [ ] newStack = new int [ stack . length * <int> ] ; System . arraycopy ( stack , <int> , newStack , <int> , stack . length ) ; stack = newStack ; } { stack [ top + + ] = cs ; cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } } break ; case <int> : { if ( debug ) System . out . println ( <str> ) ; pop ( ) ; { cs = stack [ - - top ] ; _goto_targ = <int> ; if ( true ) continue _goto ; } } break ; case <int> : { String name = names . size > <int> ? names . pop ( ) : null ; if ( debug ) System . out . println ( <str> + name ) ; startArray ( name ) ; { if ( top = = stack . length ) { int [ ] newStack = new int [ stack . length * <int> ] ; System . arraycopy ( stack , <int> , newStack , <int> , stack . length ) ; stack = newStack ; } { stack [ top + + ] = cs ; cs = <int> ; _goto_targ = <int> ; if ( true ) continue _goto ; } } } break ; case <int> : { if ( debug ) System . out . println ( <str> ) ; pop ( ) ; { cs = stack [ - - top ] ; _goto_targ = <int> ; if ( true ) continue _goto ; } } break ; case <int> : { int start = p - <int> ; if ( data [ p + + ] = = <str> ) { while ( p ! = eof & & data [ p ] ! = <str> ) p + + ; p - - ; } else { while ( p + <int> < eof & & data [ p ] ! = <str> | | data [ p + <int> ] ! = <str> ) p + + ; p + + ; } if ( debug ) System . out . println ( <str> + new String ( data , start , p - start ) ) ; } break ; case <int> : { if ( debug ) System . out . println ( <str> ) ; s = p ; needsUnescape = false ; stringIsUnquoted = true ; if ( stringIsName ) { outer : while ( true ) { switch ( data [ p ] ) { case <str> : needsUnescape = true ; break ; case <str> : if ( p + <int> = = eof ) break ; char c = data [ p + <int> ] ; if ( c = = <str> | | c = = <str> ) break outer ; break ; case <str> : case <str> : case <str> : break outer ; } if ( debug ) System . out . println ( <str> + data [ p ] + <str> ) ; p + + ; if ( p = = eof ) break ; } } else { outer : while ( true ) { switch ( data [ p ] ) { case <str> : needsUnescape = true ; break ; case <str> : if ( p + <int> = = eof ) break ; char c = data [ p + <int> ] ; if ( c = = <str> | | c = = <str> ) break outer ; break ; case <str> : case <str> : case <str> : case <str> : case <str> : break outer ; } if ( debug ) System . out . println ( <str> + data [ p ] + <str> ) ; p + + ; if ( p = = eof ) break ; } } p - - ; while ( data [ p ] = = <str> ) p - - ; } break ; case <int> : { if ( debug ) System . out . println ( <str> ) ; s = + + p ; needsUnescape = false ; outer : while ( true ) { switch ( data [ p ] ) { case <str> : needsUnescape = true ; p + + ; break ; case <str> : break outer ; } p + + ; if ( p = = eof ) break ; } p - - ; } break ; } } } case <int> : if ( cs = = <int> ) { _goto_targ = <int> ; continue _goto ; } if ( + + p ! = pe ) { _goto_targ = <int> ; continue _goto ; } case <int> : if ( p = = eof ) { int __acts = _json_eof_actions [ cs ] ; int __nacts = ( int ) _json_actions [ __acts + + ] ; while ( __nacts - - > <int> ) { switch ( _json_actions [ __acts + + ] ) { case <int> : { String value = new String ( data , s , p - s ) ; if ( needsUnescape ) value = unescape ( value ) ; outer : if ( stringIsName ) { stringIsName = false ; if ( debug ) System . out . println ( <str> + value ) ; names . add ( value ) ; } else { String name = names . size > <int> ? names . pop ( ) : null ; if ( stringIsUnquoted ) { if ( value . equals ( <str> ) ) { if ( debug ) System . out . println ( <str> + name + <str> ) ; bool ( name , true ) ; break outer ; } else if ( value . equals ( <str> ) ) { if ( debug ) System . out . println ( <str> + name + <str> ) ; bool ( name , false ) ; break outer ; } else if ( value . equals ( <str> ) ) { string ( name , null ) ; break outer ; } boolean couldBeDouble = false , couldBeLong = true ; outer2 : for ( int i = s ; i < p ; i + + ) { switch ( data [ i ] ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : break ; case <str> : case <str> : case <str> : couldBeDouble = true ; couldBeLong = false ; break ; default : couldBeDouble = false ; couldBeLong = false ; break outer2 ; } } if ( couldBeDouble ) { try { if ( debug ) System . out . println ( <str> + name + <str> + Double . parseDouble ( value ) ) ; number ( name , Double . parseDouble ( value ) , value ) ; break outer ; } catch ( NumberFormatException ignored ) { } } else if ( couldBeLong ) { if ( debug ) System . out . println ( <str> + name + <str> + Double . parseDouble ( value ) ) ; try { number ( name , Long . parseLong ( value ) , value ) ; break outer ; } catch ( NumberFormatException ignored ) { } } } if ( debug ) System . out . println ( <str> + name + <str> + value ) ; string ( name , value ) ; } stringIsUnquoted = false ; s = p ; } break ; } } } case <int> : } break ; } } } catch ( RuntimeException ex ) { parseRuntimeEx = ex ; } JsonValue root = this . root ; this . root = null ; current = null ; lastChild . clear ( ) ; if ( p < pe ) { int lineNumber = <int> ; for ( int i = <int> ; i < p ; i + + ) if ( data [ i ] = = <str> ) lineNumber + + ; int start = Math . max ( <int> , p - <int> ) ; throw new SerializationException ( <str> + lineNumber + <str> + new String ( data , start , p - start ) + <str> + new String ( data , p , Math . min ( <int> , pe - p ) ) , parseRuntimeEx ) ; } else if ( elements . size ! = <int> ) { JsonValue element = elements . peek ( ) ; elements . clear ( ) ; if ( element ! = null & & element . isObject ( ) ) throw new SerializationException ( <str> ) ; else throw new SerializationException ( <str> ) ; } else if ( parseRuntimeEx ! = null ) { throw new SerializationException ( <str> + new String ( data ) , parseRuntimeEx ) ; } return root ; } private static byte [ ] init__json_actions_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_actions [ ] = init__json_actions_0 ( ) ; private static short [ ] init__json_key_offsets_0 ( ) { return new short [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final short _json_key_offsets [ ] = init__json_key_offsets_0 ( ) ; private static char [ ] init__json_trans_keys_0 ( ) { return new char [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final char _json_trans_keys [ ] = init__json_trans_keys_0 ( ) ; private static byte [ ] init__json_single_lengths_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_single_lengths [ ] = init__json_single_lengths_0 ( ) ; private static byte [ ] init__json_range_lengths_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_range_lengths [ ] = init__json_range_lengths_0 ( ) ; private static short [ ] init__json_index_offsets_0 ( ) { return new short [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final short _json_index_offsets [ ] = init__json_index_offsets_0 ( ) ; private static byte [ ] init__json_indicies_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_indicies [ ] = init__json_indicies_0 ( ) ; private static byte [ ] init__json_trans_targs_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_trans_targs [ ] = init__json_trans_targs_0 ( ) ; private static byte [ ] init__json_trans_actions_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_trans_actions [ ] = init__json_trans_actions_0 ( ) ; private static byte [ ] init__json_eof_actions_0 ( ) { return new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; } private static final byte _json_eof_actions [ ] = init__json_eof_actions_0 ( ) ; static final int json_start = <int> ; static final int json_first_final = <int> ; static final int json_error = <int> ; static final int json_en_object = <int> ; static final int json_en_array = <int> ; static final int json_en_main = <int> ; private final Array < JsonValue > elements = new Array ( <int> ) ; private final Array < JsonValue > lastChild = new Array ( <int> ) ; private JsonValue root , current ; private void addChild ( String name , JsonValue child ) { child . setName ( name ) ; if ( current = = null ) { current = child ; root = child ; } else if ( current . isArray ( ) | | current . isObject ( ) ) { child . parent = current ; if ( current . size = = <int> ) current . child = child ; else { JsonValue last = lastChild . pop ( ) ; last . next = child ; child . prev = last ; } lastChild . add ( child ) ; current . size + + ; } else root = current ; } protected void startObject ( String name ) { JsonValue value = new JsonValue ( ValueType . object ) ; if ( current ! = null ) addChild ( name , value ) ; elements . add ( value ) ; current = value ; } protected void startArray ( String name ) { JsonValue value = new JsonValue ( ValueType . array ) ; if ( current ! = null ) addChild ( name , value ) ; elements . add ( value ) ; current = value ; } protected void pop ( ) { root = elements . pop ( ) ; if ( current . size > <int> ) lastChild . pop ( ) ; current = elements . size > <int> ? elements . peek ( ) : null ; } protected void string ( String name , String value ) { addChild ( name , new JsonValue ( value ) ) ; } protected void number ( String name , double value , String stringValue ) { addChild ( name , new JsonValue ( value , stringValue ) ) ; } protected void number ( String name , long value , String stringValue ) { addChild ( name , new JsonValue ( value , stringValue ) ) ; } protected void bool ( String name , boolean value ) { addChild ( name , new JsonValue ( value ) ) ; } private String unescape ( String value ) { int length = value . length ( ) ; StringBuilder buffer = new StringBuilder ( length + <int> ) ; for ( int i = <int> ; i < length ; ) { char c = value . charAt ( i + + ) ; if ( c ! = <str> ) { buffer . append ( c ) ; continue ; } if ( i = = length ) break ; c = value . charAt ( i + + ) ; if ( c = = <str> ) { buffer . append ( Character . toChars ( Integer . parseInt ( value . substring ( i , i + <int> ) , <int> ) ) ) ; i + = <int> ; continue ; } switch ( c ) { case <str> : case <str> : case <str> : break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; default : throw new SerializationException ( <str> + c ) ; } buffer . append ( c ) ; } return buffer . toString ( ) ; } } 
