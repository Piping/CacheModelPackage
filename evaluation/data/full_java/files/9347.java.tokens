package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . base . Supplier ; import java . io . Serializable ; import java . util . Comparator ; import java . util . Iterator ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; import java . util . TreeMap ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true ) @Beta public class TreeBasedTable < R , C , V > extends StandardRowSortedTable < R , C , V > { private final Comparator < ? super C > columnComparator ; private static class Factory < C , V > implements Supplier < TreeMap < C , V > > , Serializable { final Comparator < ? super C > comparator ; Factory ( Comparator < ? super C > comparator ) { this . comparator = comparator ; } @Override public TreeMap < C , V > get ( ) { return new TreeMap < C , V > ( comparator ) ; } private static final long serialVersionUID = <int> ; } public static < R extends Comparable , C extends Comparable , V > TreeBasedTable < R , C , V > create ( ) { return new TreeBasedTable < R , C , V > ( Ordering . natural ( ) , Ordering . natural ( ) ) ; } public static < R , C , V > TreeBasedTable < R , C , V > create ( Comparator < ? super R > rowComparator , Comparator < ? super C > columnComparator ) { checkNotNull ( rowComparator ) ; checkNotNull ( columnComparator ) ; return new TreeBasedTable < R , C , V > ( rowComparator , columnComparator ) ; } public static < R , C , V > TreeBasedTable < R , C , V > create ( TreeBasedTable < R , C , ? extends V > table ) { TreeBasedTable < R , C , V > result = new TreeBasedTable < R , C , V > ( table . rowComparator ( ) , table . columnComparator ( ) ) ; result . putAll ( table ) ; return result ; } TreeBasedTable ( Comparator < ? super R > rowComparator , Comparator < ? super C > columnComparator ) { super ( new TreeMap < R , Map < C , V > > ( rowComparator ) , new Factory < C , V > ( columnComparator ) ) ; this . columnComparator = columnComparator ; } public Comparator < ? super R > rowComparator ( ) { return rowKeySet ( ) . comparator ( ) ; } public Comparator < ? super C > columnComparator ( ) { return columnComparator ; } @Override public SortedMap < C , V > row ( R rowKey ) { return new TreeRow ( rowKey ) ; } private class TreeRow extends Row implements SortedMap < C , V > { @Nullable final C lowerBound ; @Nullable final C upperBound ; TreeRow ( R rowKey ) { this ( rowKey , null , null ) ; } TreeRow ( R rowKey , @Nullable C lowerBound , @Nullable C upperBound ) { super ( rowKey ) ; this . lowerBound = lowerBound ; this . upperBound = upperBound ; checkArgument ( lowerBound = = null | | upperBound = = null | | compare ( lowerBound , upperBound ) < = <int> ) ; } @Override public SortedSet < C > keySet ( ) { return new Maps . SortedKeySet < C , V > ( this ) ; } @Override public Comparator < ? super C > comparator ( ) { return columnComparator ( ) ; } int compare ( Object a , Object b ) { @SuppressWarnings ( { <str> , <str> } ) Comparator < Object > cmp = ( Comparator ) comparator ( ) ; return cmp . compare ( a , b ) ; } boolean rangeContains ( @Nullable Object o ) { return o ! = null & & ( lowerBound = = null | | compare ( lowerBound , o ) < = <int> ) & & ( upperBound = = null | | compare ( upperBound , o ) > <int> ) ; } @Override public SortedMap < C , V > subMap ( C fromKey , C toKey ) { checkArgument ( rangeContains ( checkNotNull ( fromKey ) ) & & rangeContains ( checkNotNull ( toKey ) ) ) ; return new TreeRow ( rowKey , fromKey , toKey ) ; } @Override public SortedMap < C , V > headMap ( C toKey ) { checkArgument ( rangeContains ( checkNotNull ( toKey ) ) ) ; return new TreeRow ( rowKey , lowerBound , toKey ) ; } @Override public SortedMap < C , V > tailMap ( C fromKey ) { checkArgument ( rangeContains ( checkNotNull ( fromKey ) ) ) ; return new TreeRow ( rowKey , fromKey , upperBound ) ; } @Override public C firstKey ( ) { SortedMap < C , V > backing = backingRowMap ( ) ; if ( backing = = null ) { throw new NoSuchElementException ( ) ; } return backingRowMap ( ) . firstKey ( ) ; } @Override public C lastKey ( ) { SortedMap < C , V > backing = backingRowMap ( ) ; if ( backing = = null ) { throw new NoSuchElementException ( ) ; } return backingRowMap ( ) . lastKey ( ) ; } transient SortedMap < C , V > wholeRow ; SortedMap < C , V > wholeRow ( ) { if ( wholeRow = = null | | ( wholeRow . isEmpty ( ) & & backingMap . containsKey ( rowKey ) ) ) { wholeRow = ( SortedMap < C , V > ) backingMap . get ( rowKey ) ; } return wholeRow ; } @Override SortedMap < C , V > backingRowMap ( ) { return ( SortedMap < C , V > ) super . backingRowMap ( ) ; } @Override SortedMap < C , V > computeBackingRowMap ( ) { SortedMap < C , V > map = wholeRow ( ) ; if ( map ! = null ) { if ( lowerBound ! = null ) { map = map . tailMap ( lowerBound ) ; } if ( upperBound ! = null ) { map = map . headMap ( upperBound ) ; } return map ; } return null ; } @Override void maintainEmptyInvariant ( ) { if ( wholeRow ( ) ! = null & & wholeRow . isEmpty ( ) ) { backingMap . remove ( rowKey ) ; wholeRow = null ; backingRowMap = null ; } } @Override public boolean containsKey ( Object key ) { return rangeContains ( key ) & & super . containsKey ( key ) ; } @Override public V put ( C key , V value ) { checkArgument ( rangeContains ( checkNotNull ( key ) ) ) ; return super . put ( key , value ) ; } } @Override public SortedSet < R > rowKeySet ( ) { return super . rowKeySet ( ) ; } @Override public SortedMap < R , Map < C , V > > rowMap ( ) { return super . rowMap ( ) ; } @Override Iterator < C > createColumnKeyIterator ( ) { final Comparator < ? super C > comparator = columnComparator ( ) ; final Iterator < C > merged = Iterators . mergeSorted ( Iterables . transform ( backingMap . values ( ) , new Function < Map < C , V > , Iterator < C > > ( ) { @Override public Iterator < C > apply ( Map < C , V > input ) { return input . keySet ( ) . iterator ( ) ; } } ) , comparator ) ; return new AbstractIterator < C > ( ) { C lastValue ; @Override protected C computeNext ( ) { while ( merged . hasNext ( ) ) { C next = merged . next ( ) ; boolean duplicate = lastValue ! = null & & comparator . compare ( next , lastValue ) = = <int> ; if ( ! duplicate ) { lastValue = next ; return lastValue ; } } lastValue = null ; return endOfData ( ) ; } } ; } private static final long serialVersionUID = <int> ; } 
