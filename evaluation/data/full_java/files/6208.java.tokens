package org . elasticsearch . gateway ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . index . Index ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class MetaStateService extends AbstractComponent { static final String FORMAT_SETTING = <str> ; static final String GLOBAL_STATE_FILE_PREFIX = <str> ; private static final String INDEX_STATE_FILE_PREFIX = <str> ; private final NodeEnvironment nodeEnv ; private final XContentType format ; private final ToXContent . Params formatParams ; private final ToXContent . Params gatewayModeFormatParams ; private final MetaDataStateFormat < IndexMetaData > indexStateFormat ; private final MetaDataStateFormat < MetaData > globalStateFormat ; @Inject public MetaStateService ( Settings settings , NodeEnvironment nodeEnv ) { super ( settings ) ; this . nodeEnv = nodeEnv ; this . format = XContentType . fromRestContentType ( settings . get ( FORMAT_SETTING , <str> ) ) ; if ( this . format = = XContentType . SMILE ) { Map < String , String > params = new HashMap < > ( ) ; params . put ( <str> , <str> ) ; formatParams = new ToXContent . MapParams ( params ) ; Map < String , String > gatewayModeParams = new HashMap < > ( ) ; gatewayModeParams . put ( <str> , <str> ) ; gatewayModeParams . put ( MetaData . CONTEXT_MODE_PARAM , MetaData . CONTEXT_MODE_GATEWAY ) ; gatewayModeFormatParams = new ToXContent . MapParams ( gatewayModeParams ) ; } else { formatParams = ToXContent . EMPTY_PARAMS ; Map < String , String > gatewayModeParams = new HashMap < > ( ) ; gatewayModeParams . put ( MetaData . CONTEXT_MODE_PARAM , MetaData . CONTEXT_MODE_GATEWAY ) ; gatewayModeFormatParams = new ToXContent . MapParams ( gatewayModeParams ) ; } indexStateFormat = indexStateFormat ( format , formatParams ) ; globalStateFormat = globalStateFormat ( format , gatewayModeFormatParams ) ; } MetaData loadFullState ( ) throws Exception { MetaData globalMetaData = loadGlobalState ( ) ; MetaData . Builder metaDataBuilder ; if ( globalMetaData ! = null ) { metaDataBuilder = MetaData . builder ( globalMetaData ) ; } else { metaDataBuilder = MetaData . builder ( ) ; } final Set < String > indices = nodeEnv . findAllIndices ( ) ; for ( String index : indices ) { IndexMetaData indexMetaData = loadIndexState ( index ) ; if ( indexMetaData = = null ) { logger . debug ( <str> , index ) ; } else { metaDataBuilder . put ( indexMetaData , false ) ; } } return metaDataBuilder . build ( ) ; } @Nullable IndexMetaData loadIndexState ( String index ) throws IOException { return indexStateFormat . loadLatestState ( logger , nodeEnv . indexPaths ( new Index ( index ) ) ) ; } MetaData loadGlobalState ( ) throws IOException { MetaData globalState = globalStateFormat . loadLatestState ( logger , nodeEnv . nodeDataPaths ( ) ) ; if ( globalState ! = null ) { return MetaData . addDefaultUnitsIfNeeded ( logger , globalState ) ; } else { return null ; } } void writeIndex ( String reason , IndexMetaData indexMetaData , @Nullable IndexMetaData previousIndexMetaData ) throws Exception { logger . trace ( <str> , indexMetaData . getIndex ( ) , reason ) ; try { indexStateFormat . write ( indexMetaData , indexMetaData . getVersion ( ) , nodeEnv . indexPaths ( new Index ( indexMetaData . getIndex ( ) ) ) ) ; } catch ( Throwable ex ) { logger . warn ( <str> , ex , indexMetaData . getIndex ( ) ) ; throw new IOException ( <str> + indexMetaData . getIndex ( ) + <str> , ex ) ; } } void writeGlobalState ( String reason , MetaData metaData ) throws Exception { logger . trace ( <str> , reason ) ; try { globalStateFormat . write ( metaData , metaData . version ( ) , nodeEnv . nodeDataPaths ( ) ) ; } catch ( Throwable ex ) { logger . warn ( <str> , ex ) ; throw new IOException ( <str> , ex ) ; } } static MetaDataStateFormat < MetaData > globalStateFormat ( XContentType format , final ToXContent . Params formatParams ) { return new MetaDataStateFormat < MetaData > ( format , GLOBAL_STATE_FILE_PREFIX ) { @Override public void toXContent ( XContentBuilder builder , MetaData state ) throws IOException { MetaData . Builder . toXContent ( state , builder , formatParams ) ; } @Override public MetaData fromXContent ( XContentParser parser ) throws IOException { return MetaData . Builder . fromXContent ( parser ) ; } } ; } static MetaDataStateFormat < IndexMetaData > indexStateFormat ( XContentType format , final ToXContent . Params formatParams ) { return new MetaDataStateFormat < IndexMetaData > ( format , INDEX_STATE_FILE_PREFIX ) { @Override public void toXContent ( XContentBuilder builder , IndexMetaData state ) throws IOException { IndexMetaData . Builder . toXContent ( state , builder , formatParams ) ; } @Override public IndexMetaData fromXContent ( XContentParser parser ) throws IOException { return IndexMetaData . Builder . fromXContent ( parser ) ; } } ; } } 
