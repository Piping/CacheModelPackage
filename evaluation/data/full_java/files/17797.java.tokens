package com . badlogic . gdx . tiledmappacker ; import java . awt . Graphics ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . FilenameFilter ; import java . io . IOException ; import java . util . HashMap ; import java . util . Iterator ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . assets . loaders . resolvers . AbsoluteFileHandleResolver ; import com . badlogic . gdx . backends . lwjgl . LwjglApplication ; import com . badlogic . gdx . backends . lwjgl . LwjglApplicationConfiguration ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . maps . MapLayer ; import com . badlogic . gdx . maps . tiled . TiledMap ; import com . badlogic . gdx . maps . tiled . TiledMapTile ; import com . badlogic . gdx . maps . tiled . TiledMapTileLayer ; import com . badlogic . gdx . maps . tiled . TiledMapTileSet ; import com . badlogic . gdx . maps . tiled . TmxMapLoader ; import com . badlogic . gdx . maps . tiled . tiles . AnimatedTiledMapTile ; import com . badlogic . gdx . maps . tiled . tiles . StaticTiledMapTile ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tools . texturepacker . TexturePacker ; import com . badlogic . gdx . tools . texturepacker . TexturePacker . Settings ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . ObjectMap ; public class TiledMapPacker { private TexturePacker packer ; private TiledMap map ; private TmxMapLoader mapLoader = new TmxMapLoader ( new AbsoluteFileHandleResolver ( ) ) ; private TiledMapPackerSettings settings ; private static final String TilesetsOutputDir = <str> ; static String AtlasOutputName = <str> ; private HashMap < String , IntArray > tilesetUsedIds = new HashMap < String , IntArray > ( ) ; private ObjectMap < String , TiledMapTileSet > tilesetsToPack ; static File inputDir ; static File outputDir ; private FileHandle currentDir ; private static class TmxFilter implements FilenameFilter { public TmxFilter ( ) { } @Override public boolean accept ( File dir , String name ) { return ( name . endsWith ( <str> ) ) ; } } private static class DirFilter implements FilenameFilter { public DirFilter ( ) { } @Override public boolean accept ( File f , String s ) { return ( new File ( f , s ) . isDirectory ( ) ) ; } } public TiledMapPacker ( ) { this ( new TiledMapPackerSettings ( ) ) ; } public TiledMapPacker ( TiledMapPackerSettings settings ) { this . settings = settings ; } public void processInputDir ( Settings texturePackerSettings ) throws IOException { FileHandle inputDirHandle = new FileHandle ( inputDir . getCanonicalPath ( ) ) ; File [ ] mapFilesInCurrentDir = inputDir . listFiles ( new TmxFilter ( ) ) ; tilesetsToPack = new ObjectMap < String , TiledMapTileSet > ( ) ; for ( File mapFile : mapFilesInCurrentDir ) { processSingleMap ( mapFile , inputDirHandle , texturePackerSettings ) ; } processSubdirectories ( inputDirHandle , texturePackerSettings ) ; boolean combineTilesets = this . settings . combineTilesets ; if ( combineTilesets = = true ) { packTilesets ( inputDirHandle , texturePackerSettings ) ; } } private void processSubdirectories ( FileHandle currentDir , Settings texturePackerSettings ) throws IOException { File parentPath = new File ( currentDir . path ( ) ) ; File [ ] directories = parentPath . listFiles ( new DirFilter ( ) ) ; for ( File directory : directories ) { currentDir = new FileHandle ( directory . getCanonicalPath ( ) ) ; File [ ] mapFilesInCurrentDir = directory . listFiles ( new TmxFilter ( ) ) ; for ( File mapFile : mapFilesInCurrentDir ) { processSingleMap ( mapFile , currentDir , texturePackerSettings ) ; } processSubdirectories ( currentDir , texturePackerSettings ) ; } } private void processSingleMap ( File mapFile , FileHandle dirHandle , Settings texturePackerSettings ) throws IOException { boolean combineTilesets = this . settings . combineTilesets ; if ( combineTilesets = = false ) { tilesetUsedIds = new HashMap < String , IntArray > ( ) ; tilesetsToPack = new ObjectMap < String , TiledMapTileSet > ( ) ; } map = mapLoader . load ( mapFile . getCanonicalPath ( ) ) ; boolean stripUnusedTiles = this . settings . stripUnusedTiles ; if ( stripUnusedTiles ) { stripUnusedTiles ( ) ; } else { for ( TiledMapTileSet tileset : map . getTileSets ( ) ) { String tilesetName = tileset . getName ( ) ; if ( ! tilesetsToPack . containsKey ( tilesetName ) ) { tilesetsToPack . put ( tilesetName , tileset ) ; } } } if ( combineTilesets = = false ) { FileHandle tmpHandle = new FileHandle ( mapFile . getName ( ) ) ; this . settings . atlasOutputName = tmpHandle . nameWithoutExtension ( ) ; packTilesets ( dirHandle , texturePackerSettings ) ; } FileHandle tmxFile = new FileHandle ( mapFile . getCanonicalPath ( ) ) ; writeUpdatedTMX ( map , tmxFile ) ; } private void stripUnusedTiles ( ) { int mapWidth = map . getProperties ( ) . get ( <str> , Integer . class ) ; int mapHeight = map . getProperties ( ) . get ( <str> , Integer . class ) ; int numlayers = map . getLayers ( ) . getCount ( ) ; int bucketSize = mapWidth * mapHeight * numlayers ; Iterator < MapLayer > it = map . getLayers ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { MapLayer layer = it . next ( ) ; if ( layer instanceof TiledMapTileLayer ) { TiledMapTileLayer tlayer = ( TiledMapTileLayer ) layer ; for ( int y = <int> ; y < mapHeight ; + + y ) { for ( int x = <int> ; x < mapWidth ; + + x ) { if ( tlayer . getCell ( x , y ) ! = null ) { TiledMapTile tile = tlayer . getCell ( x , y ) . getTile ( ) ; if ( tile instanceof AnimatedTiledMapTile ) { AnimatedTiledMapTile aTile = ( AnimatedTiledMapTile ) tile ; for ( StaticTiledMapTile t : aTile . getFrameTiles ( ) ) { addTile ( t , bucketSize ) ; } } addTile ( tile , bucketSize ) ; } } } } } } private void addTile ( TiledMapTile tile , int bucketSize ) { int tileid = tile . getId ( ) & ~ <hex> ; String tilesetName = tilesetNameFromTileId ( map , tileid ) ; IntArray usedIds = getUsedIdsBucket ( tilesetName , bucketSize ) ; usedIds . add ( tileid ) ; if ( ! tilesetsToPack . containsKey ( tilesetName ) ) { tilesetsToPack . put ( tilesetName , map . getTileSets ( ) . getTileSet ( tilesetName ) ) ; } } private String tilesetNameFromTileId ( TiledMap map , int tileid ) { String name = <str> ; if ( tileid = = <int> ) { return <str> ; } for ( TiledMapTileSet tileset : map . getTileSets ( ) ) { int firstgid = tileset . getProperties ( ) . get ( <str> , - <int> , Integer . class ) ; if ( firstgid = = - <int> ) continue ; if ( tileid > = firstgid ) { name = tileset . getName ( ) ; } else { return name ; } } return name ; } private IntArray getUsedIdsBucket ( String tilesetName , int size ) { if ( tilesetUsedIds . containsKey ( tilesetName ) ) { return tilesetUsedIds . get ( tilesetName ) ; } if ( size < = <int> ) { return null ; } IntArray bucket = new IntArray ( size ) ; tilesetUsedIds . put ( tilesetName , bucket ) ; return bucket ; } private void packTilesets ( FileHandle inputDirHandle , Settings texturePackerSettings ) throws IOException { BufferedImage tile ; Vector2 tileLocation ; Graphics g ; packer = new TexturePacker ( texturePackerSettings ) ; for ( TiledMapTileSet set : tilesetsToPack . values ( ) ) { String tilesetName = set . getName ( ) ; System . out . println ( <str> + tilesetName ) ; IntArray usedIds = this . settings . stripUnusedTiles ? getUsedIdsBucket ( tilesetName , - <int> ) : null ; int tileWidth = set . getProperties ( ) . get ( <str> , Integer . class ) ; int tileHeight = set . getProperties ( ) . get ( <str> , Integer . class ) ; int firstgid = set . getProperties ( ) . get ( <str> , Integer . class ) ; String imageName = set . getProperties ( ) . get ( <str> , String . class ) ; TileSetLayout layout = new TileSetLayout ( firstgid , set , inputDirHandle ) ; for ( int gid = layout . firstgid , i = <int> ; i < layout . numTiles ; gid + + , i + + ) { boolean verbose = this . settings . verbose ; if ( usedIds ! = null & & ! usedIds . contains ( gid ) ) { if ( verbose ) { System . out . println ( <str> + gid + <str> + tilesetName + <str> ) ; } continue ; } tileLocation = layout . getLocation ( gid ) ; tile = new BufferedImage ( tileWidth , tileHeight , BufferedImage . TYPE_4BYTE_ABGR ) ; g = tile . createGraphics ( ) ; g . drawImage ( layout . image , <int> , <int> , tileWidth , tileHeight , ( int ) tileLocation . x , ( int ) tileLocation . y , ( int ) tileLocation . x + tileWidth , ( int ) tileLocation . y + tileHeight , null ) ; if ( verbose ) { System . out . println ( <str> + tileWidth + <str> + tileHeight + <str> + ( int ) tileLocation . x + <str> + ( int ) tileLocation . y + <str> ) ; } int adjustedGid = gid - layout . firstgid ; final String separator = <str> ; String regionName = tilesetName + separator + adjustedGid ; packer . addImage ( tile , regionName ) ; } } String tilesetOutputDir = outputDir . toString ( ) + <str> + this . settings . tilesetOutputDirectory ; File relativeTilesetOutputDir = new File ( tilesetOutputDir ) ; File outputDirTilesets = new File ( relativeTilesetOutputDir . getCanonicalPath ( ) ) ; outputDirTilesets . mkdirs ( ) ; packer . pack ( outputDirTilesets , this . settings . atlasOutputName + <str> ) ; } private void writeUpdatedTMX ( TiledMap tiledMap , FileHandle tmxFileHandle ) throws IOException { Document doc ; DocumentBuilder docBuilder ; DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; try { docBuilder = docFactory . newDocumentBuilder ( ) ; doc = docBuilder . parse ( tmxFileHandle . read ( ) ) ; Node map = doc . getFirstChild ( ) ; while ( map . getNodeType ( ) ! = Node . ELEMENT_NODE | | map . getNodeName ( ) ! = <str> ) { if ( ( map = map . getNextSibling ( ) ) = = null ) { throw new GdxRuntimeException ( <str> ) ; } } setProperty ( doc , map , <str> , settings . tilesetOutputDirectory + <str> + settings . atlasOutputName + <str> ) ; TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; outputDir . mkdirs ( ) ; StreamResult result = new StreamResult ( new File ( outputDir , tmxFileHandle . name ( ) ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeException ( <str> + e . getMessage ( ) ) ; } catch ( SAXException e ) { throw new RuntimeException ( <str> + e . getMessage ( ) ) ; } catch ( TransformerConfigurationException e ) { throw new RuntimeException ( <str> + e . getMessage ( ) ) ; } catch ( TransformerException e ) { throw new RuntimeException ( <str> + e . getMessage ( ) ) ; } } private static void setProperty ( Document doc , Node parent , String name , String value ) { Node properties = getFirstChildNodeByName ( parent , <str> ) ; Node property = getFirstChildByNameAttrValue ( properties , <str> , <str> , name ) ; NamedNodeMap attributes = property . getAttributes ( ) ; Node valueNode = attributes . getNamedItem ( <str> ) ; if ( valueNode = = null ) { valueNode = doc . createAttribute ( <str> ) ; valueNode . setNodeValue ( value ) ; attributes . setNamedItem ( valueNode ) ; } else { valueNode . setNodeValue ( value ) ; } } private static Node getFirstChildNodeByName ( Node parent , String child ) { NodeList childNodes = parent . getChildNodes ( ) ; for ( int i = <int> ; i < childNodes . getLength ( ) ; i + + ) { if ( childNodes . item ( i ) . getNodeName ( ) . equals ( child ) ) { return childNodes . item ( i ) ; } } Node newNode = parent . getOwnerDocument ( ) . createElement ( child ) ; if ( childNodes . item ( <int> ) ! = null ) return parent . insertBefore ( newNode , childNodes . item ( <int> ) ) ; else return parent . appendChild ( newNode ) ; } private static Node getFirstChildByNameAttrValue ( Node node , String childName , String attr , String value ) { NodeList childNodes = node . getChildNodes ( ) ; for ( int i = <int> ; i < childNodes . getLength ( ) ; i + + ) { if ( childNodes . item ( i ) . getNodeName ( ) . equals ( childName ) ) { NamedNodeMap attributes = childNodes . item ( i ) . getAttributes ( ) ; Node attribute = attributes . getNamedItem ( attr ) ; if ( attribute . getNodeValue ( ) . equals ( value ) ) return childNodes . item ( i ) ; } } Node newNode = node . getOwnerDocument ( ) . createElement ( childName ) ; NamedNodeMap attributes = newNode . getAttributes ( ) ; Attr nodeAttr = node . getOwnerDocument ( ) . createAttribute ( attr ) ; nodeAttr . setNodeValue ( value ) ; attributes . setNamedItem ( nodeAttr ) ; if ( childNodes . item ( <int> ) ! = null ) { return node . insertBefore ( newNode , childNodes . item ( <int> ) ) ; } else { return node . appendChild ( newNode ) ; } } public static void main ( String [ ] args ) { final Settings texturePackerSettings = new Settings ( ) ; texturePackerSettings . paddingX = <int> ; texturePackerSettings . paddingY = <int> ; texturePackerSettings . edgePadding = true ; texturePackerSettings . duplicatePadding = true ; texturePackerSettings . bleed = true ; texturePackerSettings . alias = true ; texturePackerSettings . useIndexes = true ; final TiledMapPackerSettings packerSettings = new TiledMapPackerSettings ( ) ; if ( args . length = = <int> ) { printUsage ( ) ; System . exit ( <int> ) ; } else if ( args . length = = <int> ) { inputDir = new File ( args [ <int> ] ) ; outputDir = new File ( inputDir , <str> ) ; } else if ( args . length = = <int> ) { inputDir = new File ( args [ <int> ] ) ; outputDir = new File ( args [ <int> ] ) ; } else { inputDir = new File ( args [ <int> ] ) ; outputDir = new File ( args [ <int> ] ) ; processExtraArgs ( args , packerSettings ) ; } TiledMapPacker packer = new TiledMapPacker ( packerSettings ) ; LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; config . forceExit = false ; config . width = <int> ; config . height = <int> ; config . title = <str> ; new LwjglApplication ( new ApplicationListener ( ) { @Override public void resume ( ) { } @Override public void resize ( int width , int height ) { } @Override public void render ( ) { } @Override public void pause ( ) { } @Override public void dispose ( ) { } @Override public void create ( ) { TiledMapPacker packer = new TiledMapPacker ( packerSettings ) ; if ( ! inputDir . exists ( ) ) { System . out . println ( inputDir . getAbsolutePath ( ) ) ; throw new RuntimeException ( <str> + inputDir ) ; } try { packer . processInputDir ( texturePackerSettings ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> + e . getMessage ( ) ) ; } System . out . println ( <str> ) ; Gdx . app . exit ( ) ; } } , config ) ; } private static void processExtraArgs ( String [ ] args , TiledMapPackerSettings packerSettings ) { String stripUnused = <str> ; String combineTilesets = <str> ; String verbose = <str> ; int length = args . length - <int> ; String [ ] argsNotDir = new String [ length ] ; System . arraycopy ( args , <int> , argsNotDir , <int> , length ) ; for ( String string : argsNotDir ) { if ( stripUnused . equals ( string ) ) { packerSettings . stripUnusedTiles = true ; } else if ( combineTilesets . equals ( string ) ) { packerSettings . combineTilesets = true ; } else if ( verbose . equals ( string ) ) { packerSettings . verbose = true ; } else { System . out . println ( <str> + string + <str> ) ; printUsage ( ) ; System . exit ( <int> ) ; } } } private static void printUsage ( ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( ) ; } public static class TiledMapPackerSettings { public boolean stripUnusedTiles = false ; public boolean combineTilesets = false ; public boolean verbose = false ; public String tilesetOutputDirectory = TilesetsOutputDir ; public String atlasOutputName = AtlasOutputName ; } } 
