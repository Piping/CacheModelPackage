package org . elasticsearch . common . io . stream ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . bytes . PagedBytesReference ; import org . elasticsearch . common . io . BytesStream ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . ByteArray ; import java . io . IOException ; public class BytesStreamOutput extends StreamOutput implements BytesStream { protected final BigArrays bigarrays ; protected ByteArray bytes ; protected int count ; public BytesStreamOutput ( ) { this ( BigArrays . PAGE_SIZE_IN_BYTES ) ; } public BytesStreamOutput ( int expectedSize ) { this ( expectedSize , BigArrays . NON_RECYCLING_INSTANCE ) ; } protected BytesStreamOutput ( int expectedSize , BigArrays bigarrays ) { this . bigarrays = bigarrays ; this . bytes = bigarrays . newByteArray ( expectedSize ) ; } @Override public long position ( ) throws IOException { return count ; } @Override public void writeByte ( byte b ) throws IOException { ensureCapacity ( count + <int> ) ; bytes . set ( count , b ) ; count + + ; } @Override public void writeBytes ( byte [ ] b , int offset , int length ) throws IOException { if ( length = = <int> ) { return ; } if ( b . length < ( offset + length ) ) { throw new IllegalArgumentException ( <str> + offset + <str> + length + <str> + b . length ) ; } ensureCapacity ( count + length ) ; bytes . set ( count , b , offset , length ) ; count + = length ; } @Override public void reset ( ) { if ( bytes . size ( ) > BigArrays . PAGE_SIZE_IN_BYTES ) { bytes = bigarrays . resize ( bytes , BigArrays . PAGE_SIZE_IN_BYTES ) ; } count = <int> ; } @Override public void flush ( ) throws IOException { } @Override public void seek ( long position ) throws IOException { if ( position > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( <str> + position + <str> ) ; } count = ( int ) position ; ensureCapacity ( count ) ; } public void skip ( int length ) { count + = length ; ensureCapacity ( count ) ; } @Override public void close ( ) throws IOException { } public int size ( ) { return count ; } @Override public BytesReference bytes ( ) { return new PagedBytesReference ( bigarrays , bytes , count ) ; } public long ramBytesUsed ( ) { return bytes . ramBytesUsed ( ) ; } private void ensureCapacity ( int offset ) { bytes = bigarrays . grow ( bytes , offset ) ; } } 
