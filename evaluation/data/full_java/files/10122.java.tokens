package com . google . common . testing ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . fail ; import com . google . common . annotations . Beta ; import com . google . common . base . Function ; import com . google . common . base . Throwables ; import com . google . common . collect . Lists ; import com . google . common . reflect . AbstractInvocationHandler ; import com . google . common . reflect . Reflection ; import java . lang . reflect . AccessibleObject ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; @Beta public final class ForwardingWrapperTester { private boolean testsEquals = false ; public ForwardingWrapperTester includingEquals ( ) { this . testsEquals = true ; return this ; } public < T > void testForwarding ( Class < T > interfaceType , Function < ? super T , ? extends T > wrapperFunction ) { checkNotNull ( wrapperFunction ) ; checkArgument ( interfaceType . isInterface ( ) , <str> , interfaceType ) ; Method [ ] methods = getMostConcreteMethods ( interfaceType ) ; AccessibleObject . setAccessible ( methods , true ) ; for ( Method method : methods ) { if ( ! Modifier . isAbstract ( method . getModifiers ( ) ) ) { continue ; } if ( method . getName ( ) . equals ( <str> ) & & method . getParameterTypes ( ) . length = = <int> & & method . getParameterTypes ( ) [ <int> ] = = Object . class ) { continue ; } if ( method . getName ( ) . equals ( <str> ) & & method . getParameterTypes ( ) . length = = <int> ) { continue ; } if ( method . getName ( ) . equals ( <str> ) & & method . getParameterTypes ( ) . length = = <int> ) { continue ; } testSuccessfulForwarding ( interfaceType , method , wrapperFunction ) ; testExceptionPropagation ( interfaceType , method , wrapperFunction ) ; } if ( testsEquals ) { testEquals ( interfaceType , wrapperFunction ) ; } testToString ( interfaceType , wrapperFunction ) ; } private static Method [ ] getMostConcreteMethods ( Class < ? > type ) { Method [ ] methods = type . getMethods ( ) ; for ( int i = <int> ; i < methods . length ; i + + ) { try { methods [ i ] = type . getMethod ( methods [ i ] . getName ( ) , methods [ i ] . getParameterTypes ( ) ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } } return methods ; } private static < T > void testSuccessfulForwarding ( Class < T > interfaceType , Method method , Function < ? super T , ? extends T > wrapperFunction ) { new InteractionTester < T > ( interfaceType , method ) . testInteraction ( wrapperFunction ) ; } private static < T > void testExceptionPropagation ( Class < T > interfaceType , Method method , Function < ? super T , ? extends T > wrapperFunction ) { final RuntimeException exception = new RuntimeException ( ) ; T proxy = Reflection . newProxy ( interfaceType , new AbstractInvocationHandler ( ) { @Override protected Object handleInvocation ( Object p , Method m , Object [ ] args ) throws Throwable { throw exception ; } } ) ; T wrapper = wrapperFunction . apply ( proxy ) ; try { method . invoke ( wrapper , getParameterValues ( method ) ) ; fail ( method + <str> ) ; } catch ( InvocationTargetException e ) { if ( exception ! = e . getCause ( ) ) { throw new RuntimeException ( e ) ; } } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } } private static < T > void testEquals ( Class < T > interfaceType , Function < ? super T , ? extends T > wrapperFunction ) { FreshValueGenerator generator = new FreshValueGenerator ( ) ; T instance = generator . newFreshProxy ( interfaceType ) ; new EqualsTester ( ) . addEqualityGroup ( wrapperFunction . apply ( instance ) , wrapperFunction . apply ( instance ) ) . addEqualityGroup ( wrapperFunction . apply ( generator . newFreshProxy ( interfaceType ) ) ) . testEquals ( ) ; } private static < T > void testToString ( Class < T > interfaceType , Function < ? super T , ? extends T > wrapperFunction ) { T proxy = new FreshValueGenerator ( ) . newFreshProxy ( interfaceType ) ; assertEquals ( <str> , proxy . toString ( ) , wrapperFunction . apply ( proxy ) . toString ( ) ) ; } private static Object [ ] getParameterValues ( Method method ) { FreshValueGenerator paramValues = new FreshValueGenerator ( ) ; final List < Object > passedArgs = Lists . newArrayList ( ) ; for ( Class < ? > paramType : method . getParameterTypes ( ) ) { passedArgs . add ( paramValues . generateFresh ( paramType ) ) ; } return passedArgs . toArray ( ) ; } private static final class InteractionTester < T > extends AbstractInvocationHandler { private final Class < T > interfaceType ; private final Method method ; private final Object [ ] passedArgs ; private final Object returnValue ; private final AtomicInteger called = new AtomicInteger ( ) ; InteractionTester ( Class < T > interfaceType , Method method ) { this . interfaceType = interfaceType ; this . method = method ; this . passedArgs = getParameterValues ( method ) ; this . returnValue = new FreshValueGenerator ( ) . generateFresh ( method . getReturnType ( ) ) ; } @Override protected Object handleInvocation ( Object p , Method calledMethod , Object [ ] args ) throws Throwable { assertEquals ( method , calledMethod ) ; assertEquals ( method + <str> , <int> , called . get ( ) ) ; for ( int i = <int> ; i < passedArgs . length ; i + + ) { assertEquals ( <str> + i + <str> + method + <str> , passedArgs [ i ] , args [ i ] ) ; } called . getAndIncrement ( ) ; return returnValue ; } void testInteraction ( Function < ? super T , ? extends T > wrapperFunction ) { T proxy = Reflection . newProxy ( interfaceType , this ) ; T wrapper = wrapperFunction . apply ( proxy ) ; boolean isPossibleChainingCall = interfaceType . isAssignableFrom ( method . getReturnType ( ) ) ; try { Object actualReturnValue = method . invoke ( wrapper , passedArgs ) ; if ( ! isPossibleChainingCall | | wrapper ! = actualReturnValue ) { assertEquals ( <str> + method + <str> , returnValue , actualReturnValue ) ; } } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw Throwables . propagate ( e . getCause ( ) ) ; } assertEquals ( <str> + method , <int> , called . get ( ) ) ; } @Override public String toString ( ) { return <str> + interfaceType . getSimpleName ( ) ; } } } 
