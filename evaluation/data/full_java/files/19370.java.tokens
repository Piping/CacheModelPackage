package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http . HttpScheme . HTTP ; import static io . netty . handler . codec . http . HttpScheme . HTTPS ; import static io . netty . handler . codec . http . HttpUtil . isAsteriskForm ; import static io . netty . handler . codec . http . HttpUtil . isOriginForm ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . handler . codec . http2 . Http2Exception . streamError ; import static io . netty . util . AsciiString . EMPTY_STRING ; import static io . netty . util . ByteProcessor . FIND_SEMI_COLON ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static io . netty . util . internal . StringUtil . isNullOrEmpty ; import static io . netty . util . internal . StringUtil . length ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMessage ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . HttpResponse ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . util . AsciiString ; import java . net . URI ; import java . util . Iterator ; import java . util . Map . Entry ; public final class HttpConversionUtil { private static final CharSequenceMap < AsciiString > HTTP_TO_HTTP2_HEADER_BLACKLIST = new CharSequenceMap < AsciiString > ( ) ; static { HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( HttpHeaderNames . CONNECTION , EMPTY_STRING ) ; @SuppressWarnings ( <str> ) AsciiString keepAlive = HttpHeaderNames . KEEP_ALIVE ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( keepAlive , EMPTY_STRING ) ; @SuppressWarnings ( <str> ) AsciiString proxyConnection = HttpHeaderNames . PROXY_CONNECTION ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( proxyConnection , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( HttpHeaderNames . TRANSFER_ENCODING , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( HttpHeaderNames . HOST , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( HttpHeaderNames . UPGRADE , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( ExtensionHeaderNames . STREAM_ID . text ( ) , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( ExtensionHeaderNames . SCHEME . text ( ) , EMPTY_STRING ) ; HTTP_TO_HTTP2_HEADER_BLACKLIST . add ( ExtensionHeaderNames . PATH . text ( ) , EMPTY_STRING ) ; } public static final HttpMethod OUT_OF_MESSAGE_SEQUENCE_METHOD = HttpMethod . OPTIONS ; public static final String OUT_OF_MESSAGE_SEQUENCE_PATH = <str> ; public static final HttpResponseStatus OUT_OF_MESSAGE_SEQUENCE_RETURN_CODE = HttpResponseStatus . OK ; private static final AsciiString EMPTY_REQUEST_PATH = new AsciiString ( <str> ) ; private HttpConversionUtil ( ) { } public enum ExtensionHeaderNames { STREAM_ID ( <str> ) , SCHEME ( <str> ) , PATH ( <str> ) , STREAM_PROMISE_ID ( <str> ) , STREAM_DEPENDENCY_ID ( <str> ) , STREAM_WEIGHT ( <str> ) ; private final AsciiString text ; ExtensionHeaderNames ( String text ) { this . text = new AsciiString ( text ) ; } public AsciiString text ( ) { return text ; } } public static HttpResponseStatus parseStatus ( CharSequence status ) throws Http2Exception { HttpResponseStatus result ; try { result = HttpResponseStatus . parseLine ( status ) ; if ( result = = HttpResponseStatus . SWITCHING_PROTOCOLS ) { throw connectionError ( PROTOCOL_ERROR , <str> , result . code ( ) ) ; } } catch ( Http2Exception e ) { throw e ; } catch ( Throwable t ) { throw connectionError ( PROTOCOL_ERROR , t , <str> , status ) ; } return result ; } public static FullHttpResponse toHttpResponse ( int streamId , Http2Headers http2Headers , boolean validateHttpHeaders ) throws Http2Exception { HttpResponseStatus status = parseStatus ( http2Headers . status ( ) ) ; FullHttpResponse msg = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , status , validateHttpHeaders ) ; addHttp2ToHttpHeaders ( streamId , http2Headers , msg , false ) ; return msg ; } public static FullHttpRequest toHttpRequest ( int streamId , Http2Headers http2Headers , boolean validateHttpHeaders ) throws Http2Exception { final CharSequence method = checkNotNull ( http2Headers . method ( ) , <str> ) ; final CharSequence path = checkNotNull ( http2Headers . path ( ) , <str> ) ; FullHttpRequest msg = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . valueOf ( method . toString ( ) ) , path . toString ( ) , validateHttpHeaders ) ; addHttp2ToHttpHeaders ( streamId , http2Headers , msg , false ) ; return msg ; } public static void addHttp2ToHttpHeaders ( int streamId , Http2Headers sourceHeaders , FullHttpMessage destinationMessage , boolean addToTrailer ) throws Http2Exception { addHttp2ToHttpHeaders ( streamId , sourceHeaders , addToTrailer ? destinationMessage . trailingHeaders ( ) : destinationMessage . headers ( ) , destinationMessage . protocolVersion ( ) , addToTrailer , destinationMessage instanceof HttpRequest ) ; } public static void addHttp2ToHttpHeaders ( int streamId , Http2Headers inputHeaders , HttpHeaders outputHeaders , HttpVersion httpVersion , boolean isTrailer , boolean isRequest ) throws Http2Exception { Http2ToHttpHeaderTranslator translator = new Http2ToHttpHeaderTranslator ( streamId , outputHeaders , isRequest ) ; try { for ( Entry < CharSequence , CharSequence > entry : inputHeaders ) { translator . translate ( entry ) ; } } catch ( Http2Exception ex ) { throw ex ; } catch ( Throwable t ) { throw streamError ( streamId , PROTOCOL_ERROR , t , <str> ) ; } outputHeaders . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; outputHeaders . remove ( HttpHeaderNames . TRAILER ) ; if ( ! isTrailer ) { outputHeaders . setInt ( ExtensionHeaderNames . STREAM_ID . text ( ) , streamId ) ; HttpUtil . setKeepAlive ( outputHeaders , httpVersion , true ) ; } } public static Http2Headers toHttp2Headers ( HttpMessage in , boolean validateHeaders ) throws Exception { HttpHeaders inHeaders = in . headers ( ) ; final Http2Headers out = new DefaultHttp2Headers ( validateHeaders , inHeaders . size ( ) ) ; if ( in instanceof HttpRequest ) { HttpRequest request = ( HttpRequest ) in ; URI requestTargetUri = URI . create ( request . uri ( ) ) ; out . path ( toHttp2Path ( requestTargetUri ) ) ; out . method ( request . method ( ) . asciiName ( ) ) ; setHttp2Scheme ( inHeaders , requestTargetUri , out ) ; if ( ! isOriginForm ( requestTargetUri ) & & ! isAsteriskForm ( requestTargetUri ) ) { String host = inHeaders . getAsString ( HttpHeaderNames . HOST ) ; setHttp2Authority ( ( host = = null | | host . isEmpty ( ) ) ? requestTargetUri . getAuthority ( ) : host , out ) ; } } else if ( in instanceof HttpResponse ) { HttpResponse response = ( HttpResponse ) in ; out . status ( new AsciiString ( Integer . toString ( response . status ( ) . code ( ) ) ) ) ; } toHttp2Headers ( inHeaders , out ) ; return out ; } public static Http2Headers toHttp2Headers ( HttpHeaders inHeaders , boolean validateHeaders ) throws Exception { if ( inHeaders . isEmpty ( ) ) { return EmptyHttp2Headers . INSTANCE ; } final Http2Headers out = new DefaultHttp2Headers ( validateHeaders , inHeaders . size ( ) ) ; toHttp2Headers ( inHeaders , out ) ; return out ; } public static void toHttp2Headers ( HttpHeaders inHeaders , Http2Headers out ) throws Exception { Iterator < Entry < CharSequence , CharSequence > > iter = inHeaders . iteratorCharSequence ( ) ; while ( iter . hasNext ( ) ) { Entry < CharSequence , CharSequence > entry = iter . next ( ) ; final AsciiString aName = AsciiString . of ( entry . getKey ( ) ) . toLowerCase ( ) ; if ( ! HTTP_TO_HTTP2_HEADER_BLACKLIST . contains ( aName ) ) { if ( aName . contentEqualsIgnoreCase ( HttpHeaderNames . TE ) & & ! AsciiString . contentEqualsIgnoreCase ( entry . getValue ( ) , HttpHeaderValues . TRAILERS ) ) { throw new IllegalArgumentException ( <str> + HttpHeaderNames . TE + <str> + entry . getValue ( ) ) ; } if ( aName . contentEqualsIgnoreCase ( HttpHeaderNames . COOKIE ) ) { AsciiString value = AsciiString . of ( entry . getValue ( ) ) ; int index = value . forEachByte ( FIND_SEMI_COLON ) ; if ( index ! = - <int> ) { int start = <int> ; do { out . add ( HttpHeaderNames . COOKIE , value . subSequence ( start , index , false ) ) ; start = index + <int> ; } while ( start < value . length ( ) & & ( index = value . forEachByte ( start , value . length ( ) - start , FIND_SEMI_COLON ) ) ! = - <int> ) ; if ( start > = value . length ( ) ) { throw new IllegalArgumentException ( <str> + value ) ; } out . add ( HttpHeaderNames . COOKIE , value . subSequence ( start , value . length ( ) , false ) ) ; } else { out . add ( HttpHeaderNames . COOKIE , value ) ; } } else { out . add ( aName , entry . getValue ( ) ) ; } } } } private static AsciiString toHttp2Path ( URI uri ) { StringBuilder pathBuilder = new StringBuilder ( length ( uri . getRawPath ( ) ) + length ( uri . getRawQuery ( ) ) + length ( uri . getRawFragment ( ) ) + <int> ) ; if ( ! isNullOrEmpty ( uri . getRawPath ( ) ) ) { pathBuilder . append ( uri . getRawPath ( ) ) ; } if ( ! isNullOrEmpty ( uri . getRawQuery ( ) ) ) { pathBuilder . append ( <str> ) ; pathBuilder . append ( uri . getRawQuery ( ) ) ; } if ( ! isNullOrEmpty ( uri . getRawFragment ( ) ) ) { pathBuilder . append ( <str> ) ; pathBuilder . append ( uri . getRawFragment ( ) ) ; } String path = pathBuilder . toString ( ) ; return path . isEmpty ( ) ? EMPTY_REQUEST_PATH : new AsciiString ( path ) ; } private static void setHttp2Authority ( String autority , Http2Headers out ) { if ( autority ! = null ) { int endOfUserInfo = autority . indexOf ( <str> ) ; if ( endOfUserInfo < <int> ) { out . authority ( new AsciiString ( autority ) ) ; } else if ( endOfUserInfo + <int> < autority . length ( ) ) { out . authority ( new AsciiString ( autority . substring ( endOfUserInfo + <int> ) ) ) ; } else { throw new IllegalArgumentException ( <str> + autority ) ; } } } private static void setHttp2Scheme ( HttpHeaders in , URI uri , Http2Headers out ) { String value = uri . getScheme ( ) ; if ( value ! = null ) { out . scheme ( new AsciiString ( value ) ) ; return ; } CharSequence cValue = in . get ( ExtensionHeaderNames . SCHEME . text ( ) ) ; if ( cValue ! = null ) { out . scheme ( AsciiString . of ( cValue ) ) ; return ; } if ( uri . getPort ( ) = = HTTPS . port ( ) ) { out . scheme ( HTTPS . name ( ) ) ; } else if ( uri . getPort ( ) = = HTTP . port ( ) ) { out . scheme ( HTTP . name ( ) ) ; } else { throw new IllegalArgumentException ( <str> + <str> ) ; } } private static final class Http2ToHttpHeaderTranslator { private static final CharSequenceMap < AsciiString > REQUEST_HEADER_TRANSLATIONS = new CharSequenceMap < AsciiString > ( ) ; private static final CharSequenceMap < AsciiString > RESPONSE_HEADER_TRANSLATIONS = new CharSequenceMap < AsciiString > ( ) ; static { RESPONSE_HEADER_TRANSLATIONS . add ( Http2Headers . PseudoHeaderName . AUTHORITY . value ( ) , HttpHeaderNames . HOST ) ; RESPONSE_HEADER_TRANSLATIONS . add ( Http2Headers . PseudoHeaderName . SCHEME . value ( ) , ExtensionHeaderNames . SCHEME . text ( ) ) ; REQUEST_HEADER_TRANSLATIONS . add ( RESPONSE_HEADER_TRANSLATIONS ) ; RESPONSE_HEADER_TRANSLATIONS . add ( Http2Headers . PseudoHeaderName . PATH . value ( ) , ExtensionHeaderNames . PATH . text ( ) ) ; } private final int streamId ; private final HttpHeaders output ; private final CharSequenceMap < AsciiString > translations ; Http2ToHttpHeaderTranslator ( int streamId , HttpHeaders output , boolean request ) { this . streamId = streamId ; this . output = output ; translations = request ? REQUEST_HEADER_TRANSLATIONS : RESPONSE_HEADER_TRANSLATIONS ; } public void translate ( Entry < CharSequence , CharSequence > entry ) throws Http2Exception { final CharSequence name = entry . getKey ( ) ; final CharSequence value = entry . getValue ( ) ; AsciiString translatedName = translations . get ( name ) ; if ( translatedName ! = null ) { output . add ( translatedName , AsciiString . of ( value ) ) ; } else if ( ! Http2Headers . PseudoHeaderName . isPseudoHeader ( name ) ) { if ( name . length ( ) = = <int> | | name . charAt ( <int> ) = = <str> ) { throw streamError ( streamId , PROTOCOL_ERROR , <str> , name ) ; } if ( HttpHeaderNames . COOKIE . equals ( name ) ) { String existingCookie = output . get ( HttpHeaderNames . COOKIE ) ; output . set ( HttpHeaderNames . COOKIE , ( existingCookie ! = null ) ? ( existingCookie + <str> + value ) : value ) ; } else { output . add ( name , value ) ; } } } } } 
