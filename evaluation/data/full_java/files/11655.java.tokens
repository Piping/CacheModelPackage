package org . gradle . api . internal . project . antbuilder ; import com . google . common . collect . Maps ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . classpath . ClassPath ; import java . lang . ref . ReferenceQueue ; import java . util . Map ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . Lock ; class FinalizerThread extends Thread { private final static Logger LOG = Logging . getLogger ( FinalizerThread . class ) ; private final ReferenceQueue < CachedClassLoader > referenceQueue ; private final AtomicBoolean stopped = new AtomicBoolean ( ) ; private final Lock lock ; private final Map < ClassPath , Cleanup > cleanups ; private final Map < ClassPath , CacheEntry > cacheEntries ; public FinalizerThread ( Map < ClassPath , CacheEntry > cacheEntries , Lock lock ) { this . setName ( <str> ) ; this . setDaemon ( true ) ; this . referenceQueue = new ReferenceQueue < CachedClassLoader > ( ) ; this . cacheEntries = cacheEntries ; this . cleanups = Maps . newConcurrentMap ( ) ; this . lock = lock ; } public void run ( ) { try { while ( ! stopped . get ( ) ) { Cleanup entry = ( Cleanup ) referenceQueue . remove ( ) ; ClassPath key = entry . getKey ( ) ; removeCacheEntry ( key , entry ) ; } } catch ( InterruptedException ex ) { LOG . debug ( <str> ) ; } } private void removeCacheEntry ( ClassPath key , Cleanup entry ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( String . format ( <str> , key . getAsURIs ( ) ) ) ; } lock . lock ( ) ; try { cacheEntries . remove ( key ) ; cleanups . remove ( key ) ; } finally { lock . unlock ( ) ; } try { entry . clear ( ) ; entry . cleanup ( ) ; } catch ( Exception ex ) { LOG . error ( <str> + key , ex ) ; } } public ReferenceQueue < CachedClassLoader > getReferenceQueue ( ) { return referenceQueue ; } public void exit ( ) { stopped . set ( true ) ; interrupt ( ) ; lock . lock ( ) ; try { while ( ! cleanups . isEmpty ( ) ) { Map . Entry < ClassPath , Cleanup > entry = cleanups . entrySet ( ) . iterator ( ) . next ( ) ; removeCacheEntry ( entry . getKey ( ) , entry . getValue ( ) ) ; } LOG . debug ( <str> ) ; } finally { lock . unlock ( ) ; } } public void putCleanup ( ClassPath key , Cleanup cleanup ) { cleanups . put ( key , cleanup ) ; } } 
