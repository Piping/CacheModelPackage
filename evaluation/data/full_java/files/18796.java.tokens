package io . netty . buffer ; import org . junit . Test ; import static org . junit . Assert . * ; public abstract class AbstractPooledByteBufTest extends AbstractByteBufTest { protected abstract ByteBuf alloc ( int length ) ; @Override protected ByteBuf newBuffer ( int length ) { ByteBuf buffer = alloc ( length ) ; assertEquals ( <int> , buffer . writerIndex ( ) ) ; assertEquals ( <int> , buffer . readerIndex ( ) ) ; return buffer ; } @Test public void testDiscardMarks ( ) { testDiscardMarks ( <int> ) ; } @Test public void testDiscardMarksUnpooled ( ) { testDiscardMarks ( <int> * <int> * <int> ) ; } private void testDiscardMarks ( int capacity ) { ByteBuf buf = newBuffer ( capacity ) ; buf . writeShort ( <int> ) ; buf . skipBytes ( <int> ) ; buf . markReaderIndex ( ) ; buf . markWriterIndex ( ) ; assertTrue ( buf . release ( ) ) ; ByteBuf buf2 = newBuffer ( capacity ) ; assertSame ( unwrapIfNeeded ( buf ) , unwrapIfNeeded ( buf2 ) ) ; buf2 . writeShort ( <int> ) ; buf2 . resetReaderIndex ( ) ; buf2 . resetWriterIndex ( ) ; assertEquals ( <int> , buf2 . readerIndex ( ) ) ; assertEquals ( <int> , buf2 . writerIndex ( ) ) ; assertTrue ( buf2 . release ( ) ) ; } private static ByteBuf unwrapIfNeeded ( ByteBuf buf ) { if ( buf instanceof AdvancedLeakAwareByteBuf | | buf instanceof SimpleLeakAwareByteBuf ) { return buf . unwrap ( ) ; } return buf ; } } 
