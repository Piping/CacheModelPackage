package org . elasticsearch . index . fielddata . ordinals ; import org . apache . lucene . index . RandomAccessOrds ; import org . apache . lucene . index . SortedDocValues ; import org . apache . lucene . util . packed . PackedInts ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . fielddata . FieldData ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; import static org . hamcrest . Matchers . equalTo ; public class MultiOrdinalsTests extends ESTestCase { protected final Ordinals creationMultiOrdinals ( OrdinalsBuilder builder ) { return this . creationMultiOrdinals ( builder , Settings . builder ( ) ) ; } protected Ordinals creationMultiOrdinals ( OrdinalsBuilder builder , Settings . Builder settings ) { return builder . build ( settings . build ( ) ) ; } public void testRandomValues ( ) throws IOException { Random random = getRandom ( ) ; int numDocs = <int> + random . nextInt ( <int> ) ; int numOrdinals = <int> + random . nextInt ( <int> ) ; int numValues = <int> + random . nextInt ( <int> ) ; OrdinalsBuilder builder = new OrdinalsBuilder ( numDocs ) ; Set < OrdAndId > ordsAndIdSet = new HashSet < > ( ) ; for ( int i = <int> ; i < numValues ; i + + ) { ordsAndIdSet . add ( new OrdAndId ( random . nextInt ( numOrdinals ) , random . nextInt ( numDocs ) ) ) ; } List < OrdAndId > ordsAndIds = new ArrayList < > ( ordsAndIdSet ) ; Collections . sort ( ordsAndIds , new Comparator < OrdAndId > ( ) { @Override public int compare ( OrdAndId o1 , OrdAndId o2 ) { if ( o1 . ord < o2 . ord ) { return - <int> ; } if ( o1 . ord = = o2 . ord ) { if ( o1 . id < o2 . id ) { return - <int> ; } if ( o1 . id > o2 . id ) { return <int> ; } return <int> ; } return <int> ; } } ) ; long lastOrd = - <int> ; for ( OrdAndId ordAndId : ordsAndIds ) { if ( lastOrd ! = ordAndId . ord ) { lastOrd = ordAndId . ord ; builder . nextOrdinal ( ) ; } ordAndId . ord = builder . currentOrdinal ( ) ; builder . addDoc ( ordAndId . id ) ; } Collections . sort ( ordsAndIds , new Comparator < OrdAndId > ( ) { @Override public int compare ( OrdAndId o1 , OrdAndId o2 ) { if ( o1 . id < o2 . id ) { return - <int> ; } if ( o1 . id = = o2 . id ) { if ( o1 . ord < o2 . ord ) { return - <int> ; } if ( o1 . ord > o2 . ord ) { return <int> ; } return <int> ; } return <int> ; } } ) ; Ordinals ords = creationMultiOrdinals ( builder ) ; RandomAccessOrds docs = ords . ordinals ( ) ; final SortedDocValues singleOrds = MultiValueMode . MIN . select ( docs ) ; int docId = ordsAndIds . get ( <int> ) . id ; List < Long > docOrds = new ArrayList < > ( ) ; for ( OrdAndId ordAndId : ordsAndIds ) { if ( docId = = ordAndId . id ) { docOrds . add ( ordAndId . ord ) ; } else { if ( ! docOrds . isEmpty ( ) ) { assertThat ( ( long ) singleOrds . getOrd ( docId ) , equalTo ( docOrds . get ( <int> ) ) ) ; docs . setDocument ( docId ) ; final int numOrds = docs . cardinality ( ) ; assertThat ( numOrds , equalTo ( docOrds . size ( ) ) ) ; for ( int i = <int> ; i < numOrds ; i + + ) { assertThat ( docs . nextOrd ( ) , equalTo ( docOrds . get ( i ) ) ) ; } final long [ ] array = new long [ docOrds . size ( ) ] ; for ( int i = <int> ; i < array . length ; i + + ) { array [ i ] = docOrds . get ( i ) ; } assertIter ( docs , docId , array ) ; } for ( int i = docId + <int> ; i < ordAndId . id ; i + + ) { assertThat ( ( long ) singleOrds . getOrd ( i ) , equalTo ( RandomAccessOrds . NO_MORE_ORDS ) ) ; } docId = ordAndId . id ; docOrds . clear ( ) ; docOrds . add ( ordAndId . ord ) ; } } } public static class OrdAndId { long ord ; final int id ; public OrdAndId ( long ord , int id ) { this . ord = ord ; this . id = id ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + id ; result = prime * result + ( int ) ord ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } OrdAndId other = ( OrdAndId ) obj ; if ( id ! = other . id ) { return false ; } if ( ord ! = other . ord ) { return false ; } return true ; } } public void testOrdinals ( ) throws Exception { int maxDoc = <int> ; long maxOrds = <int> ; OrdinalsBuilder builder = new OrdinalsBuilder ( maxDoc ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) . addDoc ( <int> ) ; while ( builder . getValueCount ( ) < maxOrds ) { builder . nextOrdinal ( ) ; builder . addDoc ( <int> ) . addDoc ( <int> ) ; } long [ ] [ ] ordinalPlan = new long [ ] [ ] { { <int> , <int> } , { <int> } , { <int> } , { } , { <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } } ; Ordinals ordinals = creationMultiOrdinals ( builder ) ; RandomAccessOrds docs = ordinals . ordinals ( ) ; assertEquals ( docs , ordinalPlan ) ; } protected static void assertIter ( RandomAccessOrds docs , int docId , long . . . expectedOrdinals ) { docs . setDocument ( docId ) ; assertThat ( docs . cardinality ( ) , equalTo ( expectedOrdinals . length ) ) ; for ( long expectedOrdinal : expectedOrdinals ) { assertThat ( docs . nextOrd ( ) , equalTo ( expectedOrdinal ) ) ; } } public void testMultiValuesDocsWithOverlappingStorageArrays ( ) throws Exception { int maxDoc = <int> ; long maxOrds = <int> ; OrdinalsBuilder builder = new OrdinalsBuilder ( maxDoc ) ; for ( int i = <int> ; i < maxOrds ; i + + ) { builder . nextOrdinal ( ) ; if ( i < <int> ) { builder . addDoc ( <int> ) ; } builder . addDoc ( <int> ) ; if ( i = = <int> ) { builder . addDoc ( <int> ) ; } if ( i < <int> ) { builder . addDoc ( <int> ) ; } if ( i < <int> ) { builder . addDoc ( <int> ) ; } if ( i = = <int> ) { builder . addDoc ( <int> ) ; } if ( i < <int> ) { builder . addDoc ( <int> ) ; } } long [ ] [ ] ordinalPlan = new long [ ] [ ] { { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , { <int> } , { <int> , <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> , <int> , <int> } , { <int> } , { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } } ; Ordinals ordinals = new MultiOrdinals ( builder , PackedInts . FASTEST ) ; RandomAccessOrds docs = ordinals . ordinals ( ) ; assertEquals ( docs , ordinalPlan ) ; } private void assertEquals ( RandomAccessOrds docs , long [ ] [ ] ordinalPlan ) { long maxOrd = <int> ; for ( int doc = <int> ; doc < ordinalPlan . length ; + + doc ) { if ( ordinalPlan [ doc ] . length > <int> ) { maxOrd = Math . max ( maxOrd , <int> + ordinalPlan [ doc ] [ ordinalPlan [ doc ] . length - <int> ] ) ; } } assertThat ( docs . getValueCount ( ) , equalTo ( maxOrd ) ) ; assertThat ( FieldData . isMultiValued ( docs ) , equalTo ( true ) ) ; for ( int doc = <int> ; doc < ordinalPlan . length ; + + doc ) { long [ ] ords = ordinalPlan [ doc ] ; docs . setDocument ( doc ) ; assertThat ( docs . cardinality ( ) , equalTo ( ords . length ) ) ; for ( int i = <int> ; i < ords . length ; + + i ) { assertThat ( docs . ordAt ( i ) , equalTo ( ords [ i ] ) ) ; } } } } 
