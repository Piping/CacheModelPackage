package org . gradle . api . internal . file . archive ; import org . gradle . api . GradleException ; import org . gradle . api . InvalidUserDataException ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . gradle . util . Resources ; import org . junit . Rule ; import org . junit . Test ; import java . util . HashMap ; import java . util . Map ; import static org . gradle . api . file . FileVisitorUtil . * ; import static org . gradle . api . internal . file . TestFiles . fileSystem ; import static org . gradle . api . tasks . AntBuilderAwareUtil . assertSetContainsForAllTypes ; import static org . gradle . util . WrapUtil . toList ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class ZipFileTreeTest { @Rule public final TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; @Rule public final Resources resources = new Resources ( ) ; private final TestFile zipFile = tmpDir . getTestDirectory ( ) . file ( <str> ) ; private final TestFile rootDir = tmpDir . getTestDirectory ( ) . file ( <str> ) ; private final TestFile expandDir = tmpDir . getTestDirectory ( ) . file ( <str> ) ; private final ZipFileTree tree = new ZipFileTree ( zipFile , expandDir , fileSystem ( ) ) ; @Test public void displayName ( ) { assertThat ( tree . getDisplayName ( ) , equalTo ( <str> + zipFile + <str> ) ) ; } @Test public void visitsContentsOfZipFile ( ) { rootDir . file ( <str> ) . write ( <str> ) ; rootDir . file ( <str> ) . write ( <str> ) ; rootDir . zipTo ( zipFile ) ; assertVisits ( tree , toList ( <str> , <str> ) , toList ( <str> , <str> ) ) ; assertSetContainsForAllTypes ( tree , toList ( <str> , <str> ) ) ; } @Test public void canStopVisitingFiles ( ) { rootDir . file ( <str> ) . write ( <str> ) ; rootDir . file ( <str> ) . write ( <str> ) ; rootDir . zipTo ( zipFile ) ; assertCanStopVisiting ( tree ) ; } @Test public void failsWhenZipFileDoesNotExist ( ) { try { tree . visit ( null ) ; fail ( ) ; } catch ( InvalidUserDataException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + zipFile + <str> ) ) ; } } @Test public void failsWhenZipFileIsADirectory ( ) { zipFile . createDir ( ) ; try { tree . visit ( null ) ; fail ( ) ; } catch ( InvalidUserDataException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + zipFile + <str> ) ) ; } } @Test public void wrapsFailureToUnzipFile ( ) { zipFile . write ( <str> ) ; try { tree . visit ( null ) ; fail ( ) ; } catch ( GradleException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> + zipFile + <str> ) ) ; } } @Test public void expectedFilePermissionsAreFound ( ) { resources . findResource ( <str> ) . copyTo ( zipFile ) ; final Map < String , Integer > expected = new HashMap < String , Integer > ( ) ; expected . put ( <str> , <oct> ) ; expected . put ( <str> , <oct> ) ; assertVisitsPermissions ( tree , expected ) ; } @Test public void expectedDefaultForNoModeZips ( ) { resources . findResource ( <str> ) . copyTo ( zipFile ) ; final Map < String , Integer > expected = new HashMap < String , Integer > ( ) ; expected . put ( <str> , <oct> ) ; expected . put ( <str> , <oct> ) ; assertVisitsPermissions ( tree , expected ) ; } } 
