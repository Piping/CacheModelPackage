package org . apache . cassandra . db ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Optional ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . lifecycle . View ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . rows . BaseRowIterator ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . dht . AbstractBounds ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . metrics . TableMetrics ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . StorageProxy ; import org . apache . cassandra . service . pager . * ; import org . apache . cassandra . thrift . ThriftResultsMerger ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . FBUtilities ; public class PartitionRangeReadCommand extends ReadCommand { protected static final SelectionDeserializer selectionDeserializer = new Deserializer ( ) ; private final DataRange dataRange ; private int oldestUnrepairedTombstone = Integer . MAX_VALUE ; public PartitionRangeReadCommand ( boolean isDigest , int digestVersion , boolean isForThrift , CFMetaData metadata , int nowInSec , ColumnFilter columnFilter , RowFilter rowFilter , DataLimits limits , DataRange dataRange , Optional < IndexMetadata > index ) { super ( Kind . PARTITION_RANGE , isDigest , digestVersion , isForThrift , metadata , nowInSec , columnFilter , rowFilter , limits ) ; this . dataRange = dataRange ; this . index = index ; } public PartitionRangeReadCommand ( CFMetaData metadata , int nowInSec , ColumnFilter columnFilter , RowFilter rowFilter , DataLimits limits , DataRange dataRange , Optional < IndexMetadata > index ) { this ( false , <int> , false , metadata , nowInSec , columnFilter , rowFilter , limits , dataRange , index ) ; } public static PartitionRangeReadCommand allDataRead ( CFMetaData metadata , int nowInSec ) { return new PartitionRangeReadCommand ( metadata , nowInSec , ColumnFilter . all ( metadata ) , RowFilter . NONE , DataLimits . NONE , DataRange . allData ( metadata . partitioner ) , Optional . empty ( ) ) ; } public DataRange dataRange ( ) { return dataRange ; } public ClusteringIndexFilter clusteringIndexFilter ( DecoratedKey key ) { return dataRange . clusteringIndexFilter ( key ) ; } public boolean isNamesQuery ( ) { return dataRange . isNamesQuery ( ) ; } public PartitionRangeReadCommand forSubRange ( AbstractBounds < PartitionPosition > range ) { return new PartitionRangeReadCommand ( isDigestQuery ( ) , digestVersion ( ) , isForThrift ( ) , metadata ( ) , nowInSec ( ) , columnFilter ( ) , rowFilter ( ) , limits ( ) , dataRange ( ) . forSubRange ( range ) , index ) ; } public PartitionRangeReadCommand copy ( ) { return new PartitionRangeReadCommand ( isDigestQuery ( ) , digestVersion ( ) , isForThrift ( ) , metadata ( ) , nowInSec ( ) , columnFilter ( ) , rowFilter ( ) , limits ( ) , dataRange ( ) , index ) ; } public PartitionRangeReadCommand withUpdatedLimit ( DataLimits newLimits ) { return new PartitionRangeReadCommand ( metadata ( ) , nowInSec ( ) , columnFilter ( ) , rowFilter ( ) , newLimits , dataRange ( ) , index ) ; } public long getTimeout ( ) { return DatabaseDescriptor . getRangeRpcTimeout ( ) ; } public boolean selectsKey ( DecoratedKey key ) { if ( ! dataRange ( ) . contains ( key ) ) return false ; return rowFilter ( ) . partitionKeyRestrictionsAreSatisfiedBy ( key , metadata ( ) . getKeyValidator ( ) ) ; } public boolean selectsClustering ( DecoratedKey key , Clustering clustering ) { if ( clustering = = Clustering . STATIC_CLUSTERING ) return ! columnFilter ( ) . fetchedColumns ( ) . statics . isEmpty ( ) ; if ( ! dataRange ( ) . clusteringIndexFilter ( key ) . selects ( clustering ) ) return false ; return rowFilter ( ) . clusteringKeyRestrictionsAreSatisfiedBy ( clustering ) ; } public PartitionIterator execute ( ConsistencyLevel consistency , ClientState clientState ) throws RequestExecutionException { return StorageProxy . getRangeSlice ( this , consistency ) ; } public QueryPager getPager ( PagingState pagingState , int protocolVersion ) { if ( isNamesQuery ( ) ) return new RangeNamesQueryPager ( this , pagingState , protocolVersion ) ; else return new RangeSliceQueryPager ( this , pagingState , protocolVersion ) ; } protected void recordLatency ( TableMetrics metric , long latencyNanos ) { metric . rangeLatency . addNano ( latencyNanos ) ; } protected UnfilteredPartitionIterator queryStorage ( final ColumnFamilyStore cfs , ReadExecutionController executionController ) { ColumnFamilyStore . ViewFragment view = cfs . select ( View . select ( SSTableSet . LIVE , dataRange ( ) . keyRange ( ) ) ) ; Tracing . trace ( <str> , view . sstables . size ( ) , dataRange ( ) . keyRange ( ) . getString ( metadata ( ) . getKeyValidator ( ) ) ) ; final List < UnfilteredPartitionIterator > iterators = new ArrayList < > ( Iterables . size ( view . memtables ) + view . sstables . size ( ) ) ; try { for ( Memtable memtable : view . memtables ) { @SuppressWarnings ( <str> ) Memtable . MemtableUnfilteredPartitionIterator iter = memtable . makePartitionIterator ( columnFilter ( ) , dataRange ( ) , isForThrift ( ) ) ; oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , iter . getMinLocalDeletionTime ( ) ) ; iterators . add ( isForThrift ( ) ? ThriftResultsMerger . maybeWrap ( iter , metadata ( ) , nowInSec ( ) ) : iter ) ; } for ( SSTableReader sstable : view . sstables ) { @SuppressWarnings ( <str> ) UnfilteredPartitionIterator iter = sstable . getScanner ( columnFilter ( ) , dataRange ( ) , isForThrift ( ) ) ; iterators . add ( isForThrift ( ) ? ThriftResultsMerger . maybeWrap ( iter , metadata ( ) , nowInSec ( ) ) : iter ) ; if ( ! sstable . isRepaired ( ) ) oldestUnrepairedTombstone = Math . min ( oldestUnrepairedTombstone , sstable . getMinLocalDeletionTime ( ) ) ; } return checkCacheFilter ( UnfilteredPartitionIterators . mergeLazily ( iterators , nowInSec ( ) ) , cfs ) ; } catch ( RuntimeException | Error e ) { try { FBUtilities . closeAll ( iterators ) ; } catch ( Exception suppressed ) { e . addSuppressed ( suppressed ) ; } throw e ; } } @Override protected int oldestUnrepairedTombstone ( ) { return oldestUnrepairedTombstone ; } private UnfilteredPartitionIterator checkCacheFilter ( UnfilteredPartitionIterator iter , final ColumnFamilyStore cfs ) { class CacheFilter extends Transformation { @Override public BaseRowIterator applyToPartition ( BaseRowIterator iter ) { DecoratedKey dk = iter . partitionKey ( ) ; CachedPartition cached = cfs . getRawCachedPartition ( dk ) ; ClusteringIndexFilter filter = dataRange ( ) . clusteringIndexFilter ( dk ) ; if ( cached ! = null & & cfs . isFilterFullyCoveredBy ( filter , limits ( ) , cached , nowInSec ( ) ) ) { iter . close ( ) ; return filter . getUnfilteredRowIterator ( columnFilter ( ) , cached ) ; } return iter ; } } return Transformation . apply ( iter , new CacheFilter ( ) ) ; } public MessageOut < ReadCommand > createMessage ( int version ) { if ( version > = MessagingService . VERSION_30 ) return new MessageOut < > ( MessagingService . Verb . RANGE_SLICE , this , serializer ) ; return dataRange ( ) . isPaging ( ) ? new MessageOut < > ( MessagingService . Verb . PAGED_RANGE , this , legacyPagedRangeCommandSerializer ) : new MessageOut < > ( MessagingService . Verb . RANGE_SLICE , this , legacyRangeSliceCommandSerializer ) ; } protected void appendCQLWhereClause ( StringBuilder sb ) { if ( dataRange . isUnrestricted ( ) & & rowFilter ( ) . isEmpty ( ) ) return ; sb . append ( <str> ) ; if ( ! rowFilter ( ) . isEmpty ( ) ) { sb . append ( rowFilter ( ) ) ; if ( ! dataRange . isUnrestricted ( ) ) sb . append ( <str> ) ; } if ( ! dataRange . isUnrestricted ( ) ) sb . append ( dataRange . toCQLString ( metadata ( ) ) ) ; } public PartitionIterator postReconciliationProcessing ( PartitionIterator result ) { ColumnFamilyStore cfs = Keyspace . open ( metadata ( ) . ksName ) . getColumnFamilyStore ( metadata ( ) . cfName ) ; Index index = getIndex ( cfs ) ; return index = = null ? result : index . postProcessorFor ( this ) . apply ( result , this ) ; } @Override public String toString ( ) { return String . format ( <str> , metadata ( ) . ksName , metadata ( ) . cfName , columnFilter ( ) , rowFilter ( ) , limits ( ) , dataRange ( ) . toString ( metadata ( ) ) ) ; } protected void serializeSelection ( DataOutputPlus out , int version ) throws IOException { DataRange . serializer . serialize ( dataRange ( ) , out , version , metadata ( ) ) ; } protected long selectionSerializedSize ( int version ) { return DataRange . serializer . serializedSize ( dataRange ( ) , version , metadata ( ) ) ; } private static class Deserializer extends SelectionDeserializer { public ReadCommand deserialize ( DataInputPlus in , int version , boolean isDigest , int digestVersion , boolean isForThrift , CFMetaData metadata , int nowInSec , ColumnFilter columnFilter , RowFilter rowFilter , DataLimits limits , Optional < IndexMetadata > index ) throws IOException { DataRange range = DataRange . serializer . deserialize ( in , version , metadata ) ; return new PartitionRangeReadCommand ( isDigest , digestVersion , isForThrift , metadata , nowInSec , columnFilter , rowFilter , limits , range , index ) ; } } } 
