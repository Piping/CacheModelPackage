package org . gradle . tooling . internal . consumer . connection ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . UncheckedException ; import org . gradle . tooling . BuildCancelledException ; import org . gradle . tooling . internal . consumer . ConnectionParameters ; import org . gradle . tooling . internal . consumer . Distribution ; import org . gradle . tooling . internal . consumer . LoggingProvider ; import org . gradle . tooling . internal . consumer . loader . ToolingImplementationLoader ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class LazyConsumerActionExecutor implements ConsumerActionExecutor { private final Distribution distribution ; private final ToolingImplementationLoader implementationLoader ; private final LoggingProvider loggingProvider ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final Set < Thread > executing = new HashSet < Thread > ( ) ; private boolean stopped ; private ConsumerConnection connection ; private final ConnectionParameters connectionParameters ; public LazyConsumerActionExecutor ( Distribution distribution , ToolingImplementationLoader implementationLoader , LoggingProvider loggingProvider , ConnectionParameters connectionParameters ) { this . distribution = distribution ; this . implementationLoader = implementationLoader ; this . loggingProvider = loggingProvider ; this . connectionParameters = connectionParameters ; } public void stop ( ) { lock . lock ( ) ; try { stopped = true ; while ( ! executing . isEmpty ( ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } this . connection = null ; } finally { lock . unlock ( ) ; } } public String getDisplayName ( ) { return distribution . getDisplayName ( ) ; } public < T > T run ( ConsumerAction < T > action ) throws UnsupportedOperationException , IllegalStateException { try { BuildCancellationToken cancellationToken = action . getParameters ( ) . getCancellationToken ( ) ; if ( cancellationToken . isCancellationRequested ( ) ) { throw new BuildCancelledException ( <str> ) ; } ConsumerConnection connection = onStartAction ( cancellationToken ) ; return action . run ( connection ) ; } finally { onEndAction ( ) ; } } private ConsumerConnection onStartAction ( BuildCancellationToken cancellationToken ) { lock . lock ( ) ; try { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } executing . add ( Thread . currentThread ( ) ) ; if ( connection = = null ) { connection = implementationLoader . create ( distribution , loggingProvider . getProgressLoggerFactory ( ) , connectionParameters , cancellationToken ) ; } return connection ; } finally { lock . unlock ( ) ; } } private void onEndAction ( ) { lock . lock ( ) ; try { executing . remove ( Thread . currentThread ( ) ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } 
