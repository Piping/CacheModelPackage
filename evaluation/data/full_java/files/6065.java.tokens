package org . elasticsearch . common . transport ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public abstract class TransportAddressSerializers { private static final ESLogger logger = Loggers . getLogger ( TransportAddressSerializers . class ) ; private static final Map < Short , TransportAddress > ADDRESS_REGISTRY ; static { Map < Short , TransportAddress > registry = new HashMap < > ( ) ; try { addAddressType ( registry , DummyTransportAddress . INSTANCE ) ; addAddressType ( registry , InetSocketTransportAddress . PROTO ) ; addAddressType ( registry , LocalTransportAddress . PROTO ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } ADDRESS_REGISTRY = unmodifiableMap ( registry ) ; } public static synchronized void addAddressType ( Map < Short , TransportAddress > registry , TransportAddress address ) throws Exception { if ( registry . containsKey ( address . uniqueAddressTypeId ( ) ) ) { throw new IllegalStateException ( <str> + address . uniqueAddressTypeId ( ) + <str> ) ; } registry . put ( address . uniqueAddressTypeId ( ) , address ) ; } public static TransportAddress addressFromStream ( StreamInput input ) throws IOException { short addressUniqueId = input . readShort ( ) ; TransportAddress addressType = ADDRESS_REGISTRY . get ( addressUniqueId ) ; if ( addressType = = null ) { throw new IOException ( <str> + addressUniqueId + <str> ) ; } return addressType . readFrom ( input ) ; } public static void addressToStream ( StreamOutput out , TransportAddress address ) throws IOException { out . writeShort ( address . uniqueAddressTypeId ( ) ) ; address . writeTo ( out ) ; } } 
