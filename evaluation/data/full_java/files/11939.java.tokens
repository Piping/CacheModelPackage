package org . gradle . execution . taskgraph ; import org . gradle . api . Action ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import java . util . concurrent . Executor ; class ParallelTaskPlanExecutor extends AbstractTaskPlanExecutor { private static final Logger LOGGER = Logging . getLogger ( ParallelTaskPlanExecutor . class ) ; private final int executorCount ; private final ExecutorFactory executorFactory ; public ParallelTaskPlanExecutor ( int numberOfParallelExecutors , ExecutorFactory executorFactory ) { this . executorFactory = executorFactory ; if ( numberOfParallelExecutors < <int> ) { throw new IllegalArgumentException ( <str> + numberOfParallelExecutors ) ; } this . executorCount = numberOfParallelExecutors ; } @Override public void process ( TaskExecutionPlan taskExecutionPlan , Action < ? super TaskInternal > taskWorker ) { StoppableExecutor executor = executorFactory . create ( <str> ) ; try { startAdditionalWorkers ( taskExecutionPlan , taskWorker , executor ) ; taskWorker ( taskExecutionPlan , taskWorker ) . run ( ) ; taskExecutionPlan . awaitCompletion ( ) ; } finally { executor . stop ( ) ; } } private void startAdditionalWorkers ( TaskExecutionPlan taskExecutionPlan , Action < ? super TaskInternal > taskWorker , Executor executor ) { LOGGER . info ( <str> , executorCount ) ; for ( int i = <int> ; i < executorCount ; i + + ) { Runnable worker = taskWorker ( taskExecutionPlan , taskWorker ) ; executor . execute ( worker ) ; } } } 
