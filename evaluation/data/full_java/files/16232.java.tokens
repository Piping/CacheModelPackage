package org . gradle . gradleplugin . foundation . search ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextBlockSearchEditor { private List < SearchResult > matchedResults = new ArrayList < SearchResult > ( ) ; public int searchAllText ( String textToSearch , BasicTextSearchCriteria searchCriteria ) { matchedResults . clear ( ) ; if ( textToSearch = = null ) { return <int> ; } Pattern pattern = searchCriteria . getRegularExpressionPattern ( ) ; if ( pattern = = null ) { return <int> ; } Matcher matcher = pattern . matcher ( textToSearch ) ; searchCriteria . resetHasChanged ( ) ; boolean wasMatchFound = false ; int matcherStart = <int> ; do { wasMatchFound = matcher . find ( matcherStart ) ; if ( wasMatchFound ) { String matchedText = matcher . group ( ) ; int start = matcher . start ( ) ; int end = matcher . end ( ) ; matchedResults . add ( new SearchResult ( matchedText , start , end ) ) ; matcherStart = end + <int> ; } } while ( wasMatchFound ) ; return matchedResults . size ( ) ; } public List < SearchResult > getMatchedResults ( ) { return Collections . unmodifiableList ( matchedResults ) ; } public boolean hasMatches ( ) { return ! matchedResults . isEmpty ( ) ; } public static class SearchResult { private String matchedText ; private int beginningIndexOfMatch ; private int endingIndexOfMatch ; public SearchResult ( String matchedText , int beginningIndexOfMatch , int endingIndexOfMatch ) { this . beginningIndexOfMatch = beginningIndexOfMatch ; this . endingIndexOfMatch = endingIndexOfMatch ; this . matchedText = matchedText ; } public String getMatchedText ( ) { return matchedText ; } public int getBeginningIndexOfMatch ( ) { return beginningIndexOfMatch ; } public int getEndingIndexOfMatch ( ) { return endingIndexOfMatch ; } public boolean foundAMatch ( ) { return beginningIndexOfMatch ! = - <int> ; } public String toString ( ) { if ( ! foundAMatch ( ) ) { return <str> ; } return <str> + matchedText + <str> + beginningIndexOfMatch + <str> + endingIndexOfMatch ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } SearchResult that = ( SearchResult ) o ; if ( beginningIndexOfMatch ! = that . beginningIndexOfMatch ) { return false ; } if ( endingIndexOfMatch ! = that . endingIndexOfMatch ) { return false ; } if ( matchedText ! = null ? ! matchedText . equals ( that . matchedText ) : that . matchedText ! = null ) { return false ; } return true ; } @Override public int hashCode ( ) { int result = matchedText ! = null ? matchedText . hashCode ( ) : <int> ; result = <int> * result + beginningIndexOfMatch ; result = <int> * result + endingIndexOfMatch ; return result ; } } public SearchResult getNextSearchResult ( int fromLocation ) { if ( matchedResults . isEmpty ( ) ) { return null ; } Iterator < SearchResult > iterator = matchedResults . iterator ( ) ; while ( iterator . hasNext ( ) ) { SearchResult searchResult = iterator . next ( ) ; if ( searchResult . getBeginningIndexOfMatch ( ) > fromLocation ) { return searchResult ; } } return matchedResults . get ( <int> ) ; } public SearchResult getPreviousSearchResult ( int fromLocation ) { if ( matchedResults . isEmpty ( ) ) { return null ; } for ( int index = matchedResults . size ( ) - <int> ; index > = <int> ; index - - ) { SearchResult searchResult = matchedResults . get ( index ) ; if ( searchResult . getEndingIndexOfMatch ( ) < fromLocation ) { return searchResult ; } } return matchedResults . get ( matchedResults . size ( ) - <int> ) ; } } 
