package com . badlogic . gdx . graphics . g3d ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . model . Node ; import com . badlogic . gdx . graphics . g3d . model . NodeAnimation ; import com . badlogic . gdx . graphics . g3d . model . NodeKeyframe ; import com . badlogic . gdx . graphics . g3d . model . NodePart ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . ArrayMap ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . Pool ; public class ModelInstance implements RenderableProvider { public static boolean defaultShareKeyframes = true ; public final Array < Material > materials = new Array ( ) ; public final Array < Node > nodes = new Array ( ) ; public final Array < Animation > animations = new Array ( ) ; public final Model model ; public Matrix4 transform ; public Object userData ; public ModelInstance ( final Model model ) { this ( model , ( String [ ] ) null ) ; } public ModelInstance ( final Model model , final String nodeId , boolean mergeTransform ) { this ( model , null , nodeId , false , false , mergeTransform ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final String nodeId , boolean mergeTransform ) { this ( model , transform , nodeId , false , false , mergeTransform ) ; } public ModelInstance ( final Model model , final String nodeId , boolean parentTransform , boolean mergeTransform ) { this ( model , null , nodeId , true , parentTransform , mergeTransform ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final String nodeId , boolean parentTransform , boolean mergeTransform ) { this ( model , transform , nodeId , true , parentTransform , mergeTransform ) ; } public ModelInstance ( final Model model , final String nodeId , boolean recursive , boolean parentTransform , boolean mergeTransform ) { this ( model , null , nodeId , recursive , parentTransform , mergeTransform ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final String nodeId , boolean recursive , boolean parentTransform , boolean mergeTransform ) { this ( model , transform , nodeId , recursive , parentTransform , mergeTransform , defaultShareKeyframes ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final String nodeId , boolean recursive , boolean parentTransform , boolean mergeTransform , boolean shareKeyframes ) { this . model = model ; this . transform = transform = = null ? new Matrix4 ( ) : transform ; Node copy , node = model . getNode ( nodeId , recursive ) ; this . nodes . add ( copy = node . copy ( ) ) ; if ( mergeTransform ) { this . transform . mul ( parentTransform ? node . globalTransform : node . localTransform ) ; copy . translation . set ( <int> , <int> , <int> ) ; copy . rotation . idt ( ) ; copy . scale . set ( <int> , <int> , <int> ) ; } else if ( parentTransform & & copy . hasParent ( ) ) this . transform . mul ( node . getParent ( ) . globalTransform ) ; invalidate ( ) ; copyAnimations ( model . animations , shareKeyframes ) ; calculateTransforms ( ) ; } public ModelInstance ( final Model model , final String . . . rootNodeIds ) { this ( model , null , rootNodeIds ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final String . . . rootNodeIds ) { this . model = model ; this . transform = transform = = null ? new Matrix4 ( ) : transform ; if ( rootNodeIds = = null ) copyNodes ( model . nodes ) ; else copyNodes ( model . nodes , rootNodeIds ) ; copyAnimations ( model . animations , defaultShareKeyframes ) ; calculateTransforms ( ) ; } public ModelInstance ( final Model model , final Array < String > rootNodeIds ) { this ( model , null , rootNodeIds ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final Array < String > rootNodeIds ) { this ( model , transform , rootNodeIds , defaultShareKeyframes ) ; } public ModelInstance ( final Model model , final Matrix4 transform , final Array < String > rootNodeIds , boolean shareKeyframes ) { this . model = model ; this . transform = transform = = null ? new Matrix4 ( ) : transform ; copyNodes ( model . nodes , rootNodeIds ) ; copyAnimations ( model . animations , shareKeyframes ) ; calculateTransforms ( ) ; } public ModelInstance ( final Model model , Vector3 position ) { this ( model ) ; this . transform . setToTranslation ( position ) ; } public ModelInstance ( final Model model , float x , float y , float z ) { this ( model ) ; this . transform . setToTranslation ( x , y , z ) ; } public ModelInstance ( final Model model , Matrix4 transform ) { this ( model , transform , ( String [ ] ) null ) ; } public ModelInstance ( ModelInstance copyFrom ) { this ( copyFrom , copyFrom . transform . cpy ( ) ) ; } public ModelInstance ( ModelInstance copyFrom , final Matrix4 transform ) { this ( copyFrom , transform , defaultShareKeyframes ) ; } public ModelInstance ( ModelInstance copyFrom , final Matrix4 transform , boolean shareKeyframes ) { this . model = copyFrom . model ; this . transform = transform = = null ? new Matrix4 ( ) : transform ; copyNodes ( copyFrom . nodes ) ; copyAnimations ( copyFrom . animations , shareKeyframes ) ; calculateTransforms ( ) ; } public ModelInstance copy ( ) { return new ModelInstance ( this ) ; } private void copyNodes ( Array < Node > nodes ) { for ( int i = <int> , n = nodes . size ; i < n ; + + i ) { final Node node = nodes . get ( i ) ; this . nodes . add ( node . copy ( ) ) ; } invalidate ( ) ; } private void copyNodes ( Array < Node > nodes , final String . . . nodeIds ) { for ( int i = <int> , n = nodes . size ; i < n ; + + i ) { final Node node = nodes . get ( i ) ; for ( final String nodeId : nodeIds ) { if ( nodeId . equals ( node . id ) ) { this . nodes . add ( node . copy ( ) ) ; break ; } } } invalidate ( ) ; } private void copyNodes ( Array < Node > nodes , final Array < String > nodeIds ) { for ( int i = <int> , n = nodes . size ; i < n ; + + i ) { final Node node = nodes . get ( i ) ; for ( final String nodeId : nodeIds ) { if ( nodeId . equals ( node . id ) ) { this . nodes . add ( node . copy ( ) ) ; break ; } } } invalidate ( ) ; } private void invalidate ( Node node ) { for ( int i = <int> , n = node . parts . size ; i < n ; + + i ) { NodePart part = node . parts . get ( i ) ; ArrayMap < Node , Matrix4 > bindPose = part . invBoneBindTransforms ; if ( bindPose ! = null ) { for ( int j = <int> ; j < bindPose . size ; + + j ) { bindPose . keys [ j ] = getNode ( bindPose . keys [ j ] . id ) ; } } if ( ! materials . contains ( part . material , true ) ) { final int midx = materials . indexOf ( part . material , false ) ; if ( midx < <int> ) materials . add ( part . material = part . material . copy ( ) ) ; else part . material = materials . get ( midx ) ; } } for ( int i = <int> , n = node . getChildCount ( ) ; i < n ; + + i ) { invalidate ( node . getChild ( i ) ) ; } } private void invalidate ( ) { for ( int i = <int> , n = nodes . size ; i < n ; + + i ) { invalidate ( nodes . get ( i ) ) ; } } private void copyAnimations ( final Iterable < Animation > source , boolean shareKeyframes ) { for ( final Animation anim : source ) { Animation animation = new Animation ( ) ; animation . id = anim . id ; animation . duration = anim . duration ; for ( final NodeAnimation nanim : anim . nodeAnimations ) { final Node node = getNode ( nanim . node . id ) ; if ( node = = null ) continue ; NodeAnimation nodeAnim = new NodeAnimation ( ) ; nodeAnim . node = node ; if ( shareKeyframes ) { nodeAnim . translation = nanim . translation ; nodeAnim . rotation = nanim . rotation ; nodeAnim . scaling = nanim . scaling ; } else { if ( nanim . translation ! = null ) { nodeAnim . translation = new Array < NodeKeyframe < Vector3 > > ( ) ; for ( final NodeKeyframe < Vector3 > kf : nanim . translation ) nodeAnim . translation . add ( new NodeKeyframe < Vector3 > ( kf . keytime , kf . value ) ) ; } if ( nanim . rotation ! = null ) { nodeAnim . rotation = new Array < NodeKeyframe < Quaternion > > ( ) ; for ( final NodeKeyframe < Quaternion > kf : nanim . rotation ) nodeAnim . rotation . add ( new NodeKeyframe < Quaternion > ( kf . keytime , kf . value ) ) ; } if ( nanim . scaling ! = null ) { nodeAnim . scaling = new Array < NodeKeyframe < Vector3 > > ( ) ; for ( final NodeKeyframe < Vector3 > kf : nanim . scaling ) nodeAnim . scaling . add ( new NodeKeyframe < Vector3 > ( kf . keytime , kf . value ) ) ; } } if ( nodeAnim . translation ! = null | | nodeAnim . rotation ! = null | | nodeAnim . scaling ! = null ) animation . nodeAnimations . add ( nodeAnim ) ; } if ( animation . nodeAnimations . size > <int> ) animations . add ( animation ) ; } } public void getRenderables ( Array < Renderable > renderables , Pool < Renderable > pool ) { for ( Node node : nodes ) { getRenderables ( node , renderables , pool ) ; } } public Renderable getRenderable ( final Renderable out ) { return getRenderable ( out , nodes . get ( <int> ) ) ; } public Renderable getRenderable ( final Renderable out , final Node node ) { return getRenderable ( out , node , node . parts . get ( <int> ) ) ; } public Renderable getRenderable ( final Renderable out , final Node node , final NodePart nodePart ) { nodePart . setRenderable ( out ) ; if ( nodePart . bones = = null & & transform ! = null ) out . worldTransform . set ( transform ) . mul ( node . globalTransform ) ; else if ( transform ! = null ) out . worldTransform . set ( transform ) ; else out . worldTransform . idt ( ) ; out . userData = userData ; return out ; } protected void getRenderables ( Node node , Array < Renderable > renderables , Pool < Renderable > pool ) { if ( node . parts . size > <int> ) { for ( NodePart nodePart : node . parts ) { if ( nodePart . enabled ) renderables . add ( getRenderable ( pool . obtain ( ) , node , nodePart ) ) ; } } for ( Node child : node . getChildren ( ) ) { getRenderables ( child , renderables , pool ) ; } } public void calculateTransforms ( ) { final int n = nodes . size ; for ( int i = <int> ; i < n ; i + + ) { nodes . get ( i ) . calculateTransforms ( true ) ; } for ( int i = <int> ; i < n ; i + + ) { nodes . get ( i ) . calculateBoneTransforms ( true ) ; } } public BoundingBox calculateBoundingBox ( final BoundingBox out ) { out . inf ( ) ; return extendBoundingBox ( out ) ; } public BoundingBox extendBoundingBox ( final BoundingBox out ) { final int n = nodes . size ; for ( int i = <int> ; i < n ; i + + ) nodes . get ( i ) . extendBoundingBox ( out ) ; return out ; } public Animation getAnimation ( final String id ) { return getAnimation ( id , true ) ; } public Animation getAnimation ( final String id , boolean ignoreCase ) { final int n = animations . size ; Animation animation ; if ( ignoreCase ) { for ( int i = <int> ; i < n ; i + + ) if ( ( animation = animations . get ( i ) ) . id . equalsIgnoreCase ( id ) ) return animation ; } else { for ( int i = <int> ; i < n ; i + + ) if ( ( animation = animations . get ( i ) ) . id . equals ( id ) ) return animation ; } return null ; } public Material getMaterial ( final String id ) { return getMaterial ( id , true ) ; } public Material getMaterial ( final String id , boolean ignoreCase ) { final int n = materials . size ; Material material ; if ( ignoreCase ) { for ( int i = <int> ; i < n ; i + + ) if ( ( material = materials . get ( i ) ) . id . equalsIgnoreCase ( id ) ) return material ; } else { for ( int i = <int> ; i < n ; i + + ) if ( ( material = materials . get ( i ) ) . id . equals ( id ) ) return material ; } return null ; } public Node getNode ( final String id ) { return getNode ( id , true ) ; } public Node getNode ( final String id , boolean recursive ) { return getNode ( id , recursive , false ) ; } public Node getNode ( final String id , boolean recursive , boolean ignoreCase ) { return Node . getNode ( nodes , id , recursive , ignoreCase ) ; } } 
