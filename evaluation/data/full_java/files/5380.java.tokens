package org . elasticsearch . action . search . type ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchScrollRequest ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Base64 ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . util . concurrent . AtomicArray ; import org . elasticsearch . search . SearchPhaseResult ; import org . elasticsearch . search . internal . InternalScrollSearchRequest ; import org . elasticsearch . search . internal . ShardSearchTransportRequest ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . emptyMap ; public abstract class TransportSearchHelper { public static ShardSearchTransportRequest internalSearchRequest ( ShardRouting shardRouting , int numberOfShards , SearchRequest request , String [ ] filteringAliases , long nowInMillis ) { return new ShardSearchTransportRequest ( request , shardRouting , numberOfShards , filteringAliases , nowInMillis ) ; } public static InternalScrollSearchRequest internalScrollSearchRequest ( long id , SearchScrollRequest request ) { return new InternalScrollSearchRequest ( request , id ) ; } public static String buildScrollId ( SearchType searchType , AtomicArray < ? extends SearchPhaseResult > searchPhaseResults , @Nullable Map < String , String > attributes ) throws IOException { if ( searchType = = SearchType . DFS_QUERY_THEN_FETCH | | searchType = = SearchType . QUERY_THEN_FETCH ) { return buildScrollId ( ParsedScrollId . QUERY_THEN_FETCH_TYPE , searchPhaseResults , attributes ) ; } else if ( searchType = = SearchType . QUERY_AND_FETCH | | searchType = = SearchType . DFS_QUERY_AND_FETCH ) { return buildScrollId ( ParsedScrollId . QUERY_AND_FETCH_TYPE , searchPhaseResults , attributes ) ; } else { throw new IllegalStateException ( <str> + searchType + <str> ) ; } } public static String buildScrollId ( String type , AtomicArray < ? extends SearchPhaseResult > searchPhaseResults , @Nullable Map < String , String > attributes ) throws IOException { StringBuilder sb = new StringBuilder ( ) . append ( type ) . append ( <str> ) ; sb . append ( searchPhaseResults . asList ( ) . size ( ) ) . append ( <str> ) ; for ( AtomicArray . Entry < ? extends SearchPhaseResult > entry : searchPhaseResults . asList ( ) ) { SearchPhaseResult searchPhaseResult = entry . value ; sb . append ( searchPhaseResult . id ( ) ) . append ( <str> ) . append ( searchPhaseResult . shardTarget ( ) . nodeId ( ) ) . append ( <str> ) ; } if ( attributes = = null ) { sb . append ( <str> ) ; } else { sb . append ( attributes . size ( ) ) . append ( <str> ) ; for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { sb . append ( entry . getKey ( ) ) . append ( <str> ) . append ( entry . getValue ( ) ) . append ( <str> ) ; } } BytesRef bytesRef = new BytesRef ( sb ) ; return Base64 . encodeBytes ( bytesRef . bytes , bytesRef . offset , bytesRef . length , Base64 . URL_SAFE ) ; } public static ParsedScrollId parseScrollId ( String scrollId ) { CharsRefBuilder spare = new CharsRefBuilder ( ) ; try { byte [ ] decode = Base64 . decode ( scrollId , Base64 . URL_SAFE ) ; spare . copyUTF8Bytes ( decode , <int> , decode . length ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> , e ) ; } String [ ] elements = Strings . splitStringToArray ( spare . get ( ) , <str> ) ; if ( elements . length < <int> ) { throw new IllegalArgumentException ( <str> + scrollId + <str> ) ; } int index = <int> ; String type = elements [ index + + ] ; int contextSize = Integer . parseInt ( elements [ index + + ] ) ; if ( elements . length < contextSize + <int> ) { throw new IllegalArgumentException ( <str> + scrollId + <str> ) ; } ScrollIdForNode [ ] context = new ScrollIdForNode [ contextSize ] ; for ( int i = <int> ; i < contextSize ; i + + ) { String element = elements [ index + + ] ; int sep = element . indexOf ( <str> ) ; if ( sep = = - <int> ) { throw new IllegalArgumentException ( <str> + scrollId + <str> ) ; } context [ i ] = new ScrollIdForNode ( element . substring ( sep + <int> ) , Long . parseLong ( element . substring ( <int> , sep ) ) ) ; } Map < String , String > attributes ; int attributesSize = Integer . parseInt ( elements [ index + + ] ) ; if ( attributesSize = = <int> ) { attributes = emptyMap ( ) ; } else { attributes = new HashMap < > ( attributesSize ) ; for ( int i = <int> ; i < attributesSize ; i + + ) { String element = elements [ index + + ] ; int sep = element . indexOf ( <str> ) ; attributes . put ( element . substring ( <int> , sep ) , element . substring ( sep + <int> ) ) ; } } return new ParsedScrollId ( scrollId , type , context , attributes ) ; } private TransportSearchHelper ( ) { } } 
