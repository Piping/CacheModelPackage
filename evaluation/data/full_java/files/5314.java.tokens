package org . elasticsearch . action . index ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . action . * ; import org . elasticsearch . action . support . replication . ReplicationRequest ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . internal . TimestampFieldMapper ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . util . Locale ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; public class IndexRequest extends ReplicationRequest < IndexRequest > implements DocumentRequest < IndexRequest > { public static enum OpType { INDEX ( ( byte ) <int> ) , CREATE ( ( byte ) <int> ) ; private final byte id ; private final String lowercase ; OpType ( byte id ) { this . id = id ; this . lowercase = this . toString ( ) . toLowerCase ( Locale . ENGLISH ) ; } public byte id ( ) { return id ; } public String lowercase ( ) { return this . lowercase ; } public static OpType fromId ( byte id ) { if ( id = = <int> ) { return INDEX ; } else if ( id = = <int> ) { return CREATE ; } else { throw new IllegalArgumentException ( <str> + id + <str> ) ; } } public static OpType fromString ( String sOpType ) { String lowersOpType = sOpType . toLowerCase ( Locale . ROOT ) ; switch ( lowersOpType ) { case <str> : return OpType . CREATE ; case <str> : return OpType . INDEX ; default : throw new IllegalArgumentException ( <str> + sOpType + <str> ) ; } } } private String type ; private String id ; @Nullable private String routing ; @Nullable private String parent ; @Nullable private String timestamp ; @Nullable private TimeValue ttl ; private BytesReference source ; private OpType opType = OpType . INDEX ; private boolean refresh = false ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; private XContentType contentType = Requests . INDEX_CONTENT_TYPE ; public IndexRequest ( ) { } public IndexRequest ( ActionRequest request ) { super ( request ) ; } public IndexRequest ( IndexRequest indexRequest , ActionRequest originalRequest ) { super ( indexRequest , originalRequest ) ; this . type = indexRequest . type ; this . id = indexRequest . id ; this . routing = indexRequest . routing ; this . parent = indexRequest . parent ; this . timestamp = indexRequest . timestamp ; this . ttl = indexRequest . ttl ; this . source = indexRequest . source ; this . opType = indexRequest . opType ; this . refresh = indexRequest . refresh ; this . version = indexRequest . version ; this . versionType = indexRequest . versionType ; this . contentType = indexRequest . contentType ; } public IndexRequest ( String index ) { this . index = index ; } public IndexRequest ( String index , String type ) { this . index = index ; this . type = type ; } public IndexRequest ( String index , String type , String id ) { this . index = index ; this . type = type ; this . id = id ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = super . validate ( ) ; if ( type = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( source = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( opType ( ) = = OpType . CREATE ) { if ( versionType ! = VersionType . INTERNAL | | version ! = Versions . MATCH_DELETED ) { validationException = addValidationError ( <str> , validationException ) ; return validationException ; } } if ( ! versionType . validateVersionForWrites ( version ) ) { validationException = addValidationError ( <str> + version + <str> + versionType . name ( ) + <str> , validationException ) ; } if ( ttl ! = null ) { if ( ttl . millis ( ) < <int> ) { validationException = addValidationError ( <str> , validationException ) ; } } return validationException ; } public IndexRequest contentType ( XContentType contentType ) { this . contentType = contentType ; return this ; } @Override public String type ( ) { return type ; } public IndexRequest type ( String type ) { this . type = type ; return this ; } @Override public String id ( ) { return id ; } public IndexRequest id ( String id ) { this . id = id ; return this ; } @Override public IndexRequest routing ( String routing ) { if ( routing ! = null & & routing . length ( ) = = <int> ) { this . routing = null ; } else { this . routing = routing ; } return this ; } @Override public String routing ( ) { return this . routing ; } public IndexRequest parent ( String parent ) { this . parent = parent ; if ( routing = = null ) { routing = parent ; } return this ; } public String parent ( ) { return this . parent ; } public IndexRequest timestamp ( String timestamp ) { this . timestamp = timestamp ; return this ; } public String timestamp ( ) { return this . timestamp ; } public IndexRequest ttl ( String ttl ) { this . ttl = TimeValue . parseTimeValue ( ttl , null , <str> ) ; return this ; } public IndexRequest ttl ( TimeValue ttl ) { this . ttl = ttl ; return this ; } public IndexRequest ttl ( long ttl ) { this . ttl = new TimeValue ( ttl ) ; return this ; } public TimeValue ttl ( ) { return this . ttl ; } public BytesReference source ( ) { return source ; } public Map < String , Object > sourceAsMap ( ) { return XContentHelper . convertToMap ( source , false ) . v2 ( ) ; } public IndexRequest source ( Map source ) throws ElasticsearchGenerationException { return source ( source , contentType ) ; } public IndexRequest source ( Map source , XContentType contentType ) throws ElasticsearchGenerationException { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . map ( source ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } } public IndexRequest source ( String source ) { this . source = new BytesArray ( source . getBytes ( StandardCharsets . UTF_8 ) ) ; return this ; } public IndexRequest source ( XContentBuilder sourceBuilder ) { source = sourceBuilder . bytes ( ) ; return this ; } public IndexRequest source ( String field1 , Object value1 ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) . field ( field1 , value1 ) . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public IndexRequest source ( String field1 , Object value1 , String field2 , Object value2 ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) . field ( field1 , value1 ) . field ( field2 , value2 ) . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public IndexRequest source ( String field1 , Object value1 , String field2 , Object value2 , String field3 , Object value3 ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) . field ( field1 , value1 ) . field ( field2 , value2 ) . field ( field3 , value3 ) . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public IndexRequest source ( String field1 , Object value1 , String field2 , Object value2 , String field3 , Object value3 , String field4 , Object value4 ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) . field ( field1 , value1 ) . field ( field2 , value2 ) . field ( field3 , value3 ) . field ( field4 , value4 ) . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public IndexRequest source ( Object . . . source ) { if ( source . length % <int> ! = <int> ) { throw new IllegalArgumentException ( <str> + source . length + <str> ) ; } if ( source . length = = <int> & & source [ <int> ] instanceof BytesReference & & source [ <int> ] instanceof Boolean ) { throw new IllegalArgumentException ( <str> ) ; } try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) ; for ( int i = <int> ; i < source . length ; i + + ) { builder . field ( source [ i + + ] . toString ( ) , source [ i ] ) ; } builder . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public IndexRequest source ( BytesReference source ) { this . source = source ; return this ; } public IndexRequest source ( byte [ ] source ) { return source ( source , <int> , source . length ) ; } public IndexRequest source ( byte [ ] source , int offset , int length ) { this . source = new BytesArray ( source , offset , length ) ; return this ; } public IndexRequest opType ( OpType opType ) { this . opType = opType ; if ( opType = = OpType . CREATE ) { version ( Versions . MATCH_DELETED ) ; versionType ( VersionType . INTERNAL ) ; } return this ; } public IndexRequest opType ( String opType ) { return opType ( OpType . fromString ( opType ) ) ; } public IndexRequest create ( boolean create ) { if ( create ) { return opType ( OpType . CREATE ) ; } else { return opType ( OpType . INDEX ) ; } } public OpType opType ( ) { return this . opType ; } public IndexRequest refresh ( boolean refresh ) { this . refresh = refresh ; return this ; } public boolean refresh ( ) { return this . refresh ; } public IndexRequest version ( long version ) { this . version = version ; return this ; } public long version ( ) { return this . version ; } public IndexRequest versionType ( VersionType versionType ) { this . versionType = versionType ; return this ; } public VersionType versionType ( ) { return this . versionType ; } private Version getVersion ( MetaData metaData , String concreteIndex ) { final IndexMetaData indexMetaData = metaData . getIndices ( ) . get ( concreteIndex ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( concreteIndex ) ; } return Version . indexCreated ( indexMetaData . getSettings ( ) ) ; } public void process ( MetaData metaData , @Nullable MappingMetaData mappingMd , boolean allowIdGeneration , String concreteIndex ) { routing ( metaData . resolveIndexRouting ( routing , index ) ) ; if ( timestamp ! = null ) { timestamp = MappingMetaData . Timestamp . parseStringTimestamp ( timestamp , mappingMd ! = null ? mappingMd . timestamp ( ) . dateTimeFormatter ( ) : TimestampFieldMapper . Defaults . DATE_TIME_FORMATTER , getVersion ( metaData , concreteIndex ) ) ; } if ( mappingMd ! = null ) { MappingMetaData . ParseContext parseContext = mappingMd . createParseContext ( id , routing , timestamp ) ; if ( parseContext . shouldParse ( ) ) { XContentParser parser = null ; try { parser = XContentHelper . createParser ( source ) ; mappingMd . parse ( parser , parseContext ) ; if ( parseContext . shouldParseId ( ) ) { id = parseContext . id ( ) ; } if ( parseContext . shouldParseRouting ( ) ) { if ( routing ! = null & & ! routing . equals ( parseContext . routing ( ) ) ) { throw new MapperParsingException ( <str> + routing + <str> + parseContext . routing ( ) + <str> ) ; } routing = parseContext . routing ( ) ; } if ( parseContext . shouldParseTimestamp ( ) ) { timestamp = parseContext . timestamp ( ) ; if ( timestamp ! = null ) { timestamp = MappingMetaData . Timestamp . parseStringTimestamp ( timestamp , mappingMd . timestamp ( ) . dateTimeFormatter ( ) , getVersion ( metaData , concreteIndex ) ) ; } } } catch ( MapperParsingException e ) { throw e ; } catch ( Exception e ) { throw new ElasticsearchParseException ( <str> , e ) ; } finally { if ( parser ! = null ) { parser . close ( ) ; } } } if ( mappingMd . routing ( ) . required ( ) & & routing = = null ) { throw new RoutingMissingException ( concreteIndex , type , id ) ; } if ( parent ! = null & & ! mappingMd . hasParentField ( ) ) { throw new IllegalArgumentException ( <str> ) ; } } else { if ( parent ! = null ) { throw new IllegalArgumentException ( <str> ) ; } } if ( allowIdGeneration ) { if ( id = = null ) { id ( Strings . base64UUID ( ) ) ; } } if ( timestamp = = null ) { String defaultTimestamp = TimestampFieldMapper . Defaults . DEFAULT_TIMESTAMP ; if ( mappingMd ! = null & & mappingMd . timestamp ( ) ! = null ) { if ( mappingMd . timestamp ( ) . ignoreMissing ( ) ! = null & & mappingMd . timestamp ( ) . ignoreMissing ( ) = = false ) { throw new TimestampParsingException ( <str> ) ; } defaultTimestamp = mappingMd . timestamp ( ) . defaultTimestamp ( ) ; } if ( defaultTimestamp . equals ( TimestampFieldMapper . Defaults . DEFAULT_TIMESTAMP ) ) { timestamp = Long . toString ( System . currentTimeMillis ( ) ) ; } else { timestamp = MappingMetaData . Timestamp . parseStringTimestamp ( defaultTimestamp , mappingMd . timestamp ( ) . dateTimeFormatter ( ) , getVersion ( metaData , concreteIndex ) ) ; } } } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; type = in . readString ( ) ; id = in . readOptionalString ( ) ; routing = in . readOptionalString ( ) ; parent = in . readOptionalString ( ) ; timestamp = in . readOptionalString ( ) ; ttl = in . readBoolean ( ) ? TimeValue . readTimeValue ( in ) : null ; source = in . readBytesReference ( ) ; opType = OpType . fromId ( in . readByte ( ) ) ; refresh = in . readBoolean ( ) ; version = in . readLong ( ) ; versionType = VersionType . fromValue ( in . readByte ( ) ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( type ) ; out . writeOptionalString ( id ) ; out . writeOptionalString ( routing ) ; out . writeOptionalString ( parent ) ; out . writeOptionalString ( timestamp ) ; if ( ttl = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; ttl . writeTo ( out ) ; } out . writeBytesReference ( source ) ; out . writeByte ( opType . id ( ) ) ; out . writeBoolean ( refresh ) ; out . writeLong ( version ) ; out . writeByte ( versionType . getValue ( ) ) ; } @Override public String toString ( ) { String sSource = <str> ; try { sSource = XContentHelper . convertToJson ( source , false ) ; } catch ( Exception e ) { } return <str> + index + <str> + type + <str> + id + <str> + sSource + <str> ; } } 
