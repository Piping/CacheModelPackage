package org . apache . cassandra . utils ; import java . net . InetAddress ; import java . util . * ; import com . datastax . driver . core . * ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . ColumnDefinition . ClusteringOrder ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . dht . Token . TokenFactory ; import org . apache . cassandra . io . sstable . SSTableLoader ; import org . apache . cassandra . schema . CQLTypeParser ; import org . apache . cassandra . schema . SchemaKeyspace ; import org . apache . cassandra . schema . Types ; public class NativeSSTableLoaderClient extends SSTableLoader . Client { protected final Map < String , CFMetaData > tables ; private final Collection < InetAddress > hosts ; private final int port ; private final String username ; private final String password ; private final SSLOptions sslOptions ; public NativeSSTableLoaderClient ( Collection < InetAddress > hosts , int port , String username , String password , SSLOptions sslOptions ) { super ( ) ; this . tables = new HashMap < > ( ) ; this . hosts = hosts ; this . port = port ; this . username = username ; this . password = password ; this . sslOptions = sslOptions ; } public void init ( String keyspace ) { Cluster . Builder builder = Cluster . builder ( ) . addContactPoints ( hosts ) . withPort ( port ) ; if ( sslOptions ! = null ) builder . withSSL ( sslOptions ) ; if ( username ! = null & & password ! = null ) builder = builder . withCredentials ( username , password ) ; try ( Cluster cluster = builder . build ( ) ; Session session = cluster . connect ( ) ) { Metadata metadata = cluster . getMetadata ( ) ; Set < TokenRange > tokenRanges = metadata . getTokenRanges ( ) ; IPartitioner partitioner = FBUtilities . newPartitioner ( metadata . getPartitioner ( ) ) ; TokenFactory tokenFactory = partitioner . getTokenFactory ( ) ; for ( TokenRange tokenRange : tokenRanges ) { Set < Host > endpoints = metadata . getReplicas ( keyspace , tokenRange ) ; Range < Token > range = new Range < > ( tokenFactory . fromString ( tokenRange . getStart ( ) . getValue ( ) . toString ( ) ) , tokenFactory . fromString ( tokenRange . getEnd ( ) . getValue ( ) . toString ( ) ) ) ; for ( Host endpoint : endpoints ) addRangeForEndpoint ( range , endpoint . getAddress ( ) ) ; } Types types = fetchTypes ( keyspace , session ) ; tables . putAll ( fetchTables ( keyspace , session , partitioner , types ) ) ; tables . putAll ( fetchViews ( keyspace , session , partitioner , types ) ) ; } } public CFMetaData getTableMetadata ( String tableName ) { return tables . get ( tableName ) ; } @Override public void setTableMetadata ( CFMetaData cfm ) { tables . put ( cfm . cfName , cfm ) ; } private static Types fetchTypes ( String keyspace , Session session ) { String query = String . format ( <str> , SchemaKeyspace . NAME , SchemaKeyspace . TYPES ) ; Types . RawBuilder types = Types . rawBuilder ( keyspace ) ; for ( Row row : session . execute ( query , keyspace ) ) { String name = row . getString ( <str> ) ; List < String > fieldNames = row . getList ( <str> , String . class ) ; List < String > fieldTypes = row . getList ( <str> , String . class ) ; types . add ( name , fieldNames , fieldTypes ) ; } return types . build ( ) ; } private static Map < String , CFMetaData > fetchTables ( String keyspace , Session session , IPartitioner partitioner , Types types ) { Map < String , CFMetaData > tables = new HashMap < > ( ) ; String query = String . format ( <str> , SchemaKeyspace . NAME , SchemaKeyspace . TABLES ) ; for ( Row row : session . execute ( query , keyspace ) ) { String name = row . getString ( <str> ) ; tables . put ( name , createTableMetadata ( keyspace , session , partitioner , false , row , name , types ) ) ; } return tables ; } private static Map < String , CFMetaData > fetchViews ( String keyspace , Session session , IPartitioner partitioner , Types types ) { Map < String , CFMetaData > tables = new HashMap < > ( ) ; String query = String . format ( <str> , SchemaKeyspace . NAME , SchemaKeyspace . VIEWS ) ; for ( Row row : session . execute ( query , keyspace ) ) { String name = row . getString ( <str> ) ; tables . put ( name , createTableMetadata ( keyspace , session , partitioner , true , row , name , types ) ) ; } return tables ; } private static CFMetaData createTableMetadata ( String keyspace , Session session , IPartitioner partitioner , boolean isView , Row row , String name , Types types ) { UUID id = row . getUUID ( <str> ) ; Set < CFMetaData . Flag > flags = CFMetaData . flagsFromStrings ( row . getSet ( <str> , String . class ) ) ; boolean isSuper = flags . contains ( CFMetaData . Flag . SUPER ) ; boolean isCounter = flags . contains ( CFMetaData . Flag . COUNTER ) ; boolean isDense = flags . contains ( CFMetaData . Flag . DENSE ) ; boolean isCompound = flags . contains ( CFMetaData . Flag . COMPOUND ) ; String columnsQuery = String . format ( <str> , SchemaKeyspace . NAME , SchemaKeyspace . COLUMNS ) ; List < ColumnDefinition > defs = new ArrayList < > ( ) ; for ( Row colRow : session . execute ( columnsQuery , keyspace , name ) ) defs . add ( createDefinitionFromRow ( colRow , keyspace , name , types ) ) ; return CFMetaData . create ( keyspace , name , id , isDense , isCompound , isSuper , isCounter , isView , defs , partitioner ) ; } private static ColumnDefinition createDefinitionFromRow ( Row row , String keyspace , String table , Types types ) { ColumnIdentifier name = ColumnIdentifier . getInterned ( row . getBytes ( <str> ) , row . getString ( <str> ) ) ; ClusteringOrder order = ClusteringOrder . valueOf ( row . getString ( <str> ) . toUpperCase ( ) ) ; AbstractType < ? > type = CQLTypeParser . parse ( keyspace , row . getString ( <str> ) , types ) ; if ( order = = ClusteringOrder . DESC ) type = ReversedType . getInstance ( type ) ; int position = row . getInt ( <str> ) ; ColumnDefinition . Kind kind = ColumnDefinition . Kind . valueOf ( row . getString ( <str> ) . toUpperCase ( ) ) ; return new ColumnDefinition ( keyspace , table , name , type , position , kind ) ; } } 
