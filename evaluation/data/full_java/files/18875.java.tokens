package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; final class Bzip2BitWriter { private long bitBuffer ; private int bitCount ; void writeBits ( ByteBuf out , final int count , final long value ) { if ( count < <int> | | count > <int> ) { throw new IllegalArgumentException ( <str> + count + <str> ) ; } int bitCount = this . bitCount ; long bitBuffer = this . bitBuffer | value < < <int> - count > > > bitCount ; bitCount + = count ; if ( bitCount > = <int> ) { out . writeInt ( ( int ) ( bitBuffer > > > <int> ) ) ; bitBuffer < < = <int> ; bitCount - = <int> ; } this . bitBuffer = bitBuffer ; this . bitCount = bitCount ; } void writeBoolean ( ByteBuf out , final boolean value ) { int bitCount = this . bitCount + <int> ; long bitBuffer = this . bitBuffer | ( value ? <int> < < <int> - bitCount : <int> L ) ; if ( bitCount = = <int> ) { out . writeInt ( ( int ) ( bitBuffer > > > <int> ) ) ; bitBuffer = <int> ; bitCount = <int> ; } this . bitBuffer = bitBuffer ; this . bitCount = bitCount ; } void writeUnary ( ByteBuf out , int value ) { if ( value < <int> ) { throw new IllegalArgumentException ( <str> + value + <str> ) ; } while ( value - - > <int> ) { writeBoolean ( out , true ) ; } writeBoolean ( out , false ) ; } void writeInt ( ByteBuf out , final int value ) { writeBits ( out , <int> , value ) ; } void flush ( ByteBuf out ) { final int bitCount = this . bitCount ; if ( bitCount > <int> ) { final long bitBuffer = this . bitBuffer ; final int shiftToRight = <int> - bitCount ; if ( bitCount < = <int> ) { out . writeByte ( ( int ) ( bitBuffer > > > shiftToRight < < <int> - bitCount ) ) ; } else if ( bitCount < = <int> ) { out . writeShort ( ( int ) ( bitBuffer > > > shiftToRight < < <int> - bitCount ) ) ; } else if ( bitCount < = <int> ) { out . writeMedium ( ( int ) ( bitBuffer > > > shiftToRight < < <int> - bitCount ) ) ; } else { out . writeInt ( ( int ) ( bitBuffer > > > shiftToRight < < <int> - bitCount ) ) ; } } } } 
