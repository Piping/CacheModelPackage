package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_WINDOW_SIZE ; import static io . netty . handler . codec . http2 . Http2Error . FLOW_CONTROL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . streamError ; import static io . netty . handler . codec . http2 . Http2Stream . State . HALF_CLOSED_LOCAL ; import static io . netty . handler . codec . http2 . Http2Stream . State . IDLE ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . max ; import static java . lang . Math . min ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . http2 . StreamByteDistributor . Writer ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . ArrayDeque ; import java . util . Deque ; public class DefaultHttp2RemoteFlowController implements Http2RemoteFlowController { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DefaultHttp2RemoteFlowController . class ) ; private static final int MIN_WRITABLE_CHUNK = <int> * <int> ; private final Http2Connection connection ; private final Http2Connection . PropertyKey stateKey ; private final StreamByteDistributor streamByteDistributor ; private final AbstractState connectionState ; private int initialWindowSize = DEFAULT_WINDOW_SIZE ; private WritabilityMonitor monitor ; private ChannelHandlerContext ctx ; public DefaultHttp2RemoteFlowController ( Http2Connection connection ) { this ( connection , ( Listener ) null ) ; } public DefaultHttp2RemoteFlowController ( Http2Connection connection , StreamByteDistributor streamByteDistributor ) { this ( connection , streamByteDistributor , null ) ; } public DefaultHttp2RemoteFlowController ( Http2Connection connection , final Listener listener ) { this ( connection , new PriorityStreamByteDistributor ( connection ) , listener ) ; } public DefaultHttp2RemoteFlowController ( Http2Connection connection , StreamByteDistributor streamByteDistributor , final Listener listener ) { this . connection = checkNotNull ( connection , <str> ) ; this . streamByteDistributor = checkNotNull ( streamByteDistributor , <str> ) ; stateKey = connection . newKey ( ) ; connectionState = new DefaultState ( connection . connectionStream ( ) , initialWindowSize , initialWindowSize > <int> & & isChannelWritable ( ) ) ; connection . connectionStream ( ) . setProperty ( stateKey , connectionState ) ; listener ( listener ) ; connection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamAdded ( Http2Stream stream ) { stream . setProperty ( stateKey , stream . state ( ) = = IDLE ? new ReducedState ( stream ) : new DefaultState ( stream , <int> , isWritable ( DefaultHttp2RemoteFlowController . this . connection . connectionStream ( ) ) ) ) ; } @Override public void onStreamActive ( Http2Stream stream ) { AbstractState state = state ( stream ) ; if ( state . getClass ( ) = = DefaultState . class ) { state . window ( initialWindowSize ) ; } else { stream . setProperty ( stateKey , new DefaultState ( state , initialWindowSize ) ) ; } } @Override public void onStreamClosed ( Http2Stream stream ) { AbstractState state = state ( stream ) ; state . cancel ( ) ; if ( stream . prioritizableForTree ( ) ! = <int> ) { state = new ReducedState ( state ) ; stream . setProperty ( stateKey , state ) ; } monitor . stateCancelled ( state ) ; } @Override public void onStreamHalfClosed ( Http2Stream stream ) { if ( HALF_CLOSED_LOCAL . equals ( stream . state ( ) ) ) { AbstractState state = state ( stream ) ; state . cancel ( ) ; monitor . stateCancelled ( state ) ; } } } ) ; } @Override public void channelHandlerContext ( ChannelHandlerContext ctx ) throws Http2Exception { this . ctx = checkNotNull ( ctx , <str> ) ; channelWritabilityChanged ( ) ; if ( isChannelWritable ( ) ) { writePendingBytes ( ) ; } } @Override public ChannelHandlerContext channelHandlerContext ( ) { return ctx ; } @Override public void initialWindowSize ( int newWindowSize ) throws Http2Exception { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; monitor . initialWindowSize ( newWindowSize ) ; } @Override public int initialWindowSize ( ) { return initialWindowSize ; } @Override public int windowSize ( Http2Stream stream ) { return state ( stream ) . windowSize ( ) ; } @Override public boolean isWritable ( Http2Stream stream ) { return monitor . isWritable ( state ( stream ) ) ; } @Override public void channelWritabilityChanged ( ) throws Http2Exception { monitor . channelWritabilityChange ( ) ; } private boolean isChannelWritable ( ) { return ctx ! = null & & isChannelWritable0 ( ) ; } private boolean isChannelWritable0 ( ) { return ctx . channel ( ) . isWritable ( ) ; } @Override public void listener ( Listener listener ) { monitor = listener = = null ? new DefaultWritabilityMonitor ( ) : new ListenerWritabilityMonitor ( listener ) ; } @Override public int initialWindowSize ( Http2Stream stream ) { return state ( stream ) . initialWindowSize ( ) ; } @Override public void incrementWindowSize ( Http2Stream stream , int delta ) throws Http2Exception { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; monitor . incrementWindowSize ( state ( stream ) , delta ) ; } @Override public void addFlowControlled ( Http2Stream stream , FlowControlled frame ) { assert ctx = = null | | ctx . executor ( ) . inEventLoop ( ) ; checkNotNull ( frame , <str> ) ; try { monitor . enqueueFrame ( state ( stream ) , frame ) ; } catch ( Throwable t ) { frame . error ( ctx , t ) ; } } private AbstractState state ( Http2Stream stream ) { return ( AbstractState ) checkNotNull ( stream , <str> ) . getProperty ( stateKey ) ; } private int connectionWindowSize ( ) { return connectionState . windowSize ( ) ; } private int minUsableChannelBytes ( ) { return max ( ctx . channel ( ) . config ( ) . getWriteBufferLowWaterMark ( ) , MIN_WRITABLE_CHUNK ) ; } private int maxUsableChannelBytes ( ) { int channelWritableBytes = ( int ) min ( Integer . MAX_VALUE , ctx . channel ( ) . bytesBeforeUnwritable ( ) ) ; int useableBytes = channelWritableBytes > <int> ? max ( channelWritableBytes , minUsableChannelBytes ( ) ) : <int> ; return min ( connectionState . windowSize ( ) , useableBytes ) ; } private int writableBytes ( ) { return min ( connectionWindowSize ( ) , maxUsableChannelBytes ( ) ) ; } @Override public void writePendingBytes ( ) throws Http2Exception { monitor . writePendingBytes ( ) ; } private final class DefaultState extends AbstractState { private final Deque < FlowControlled > pendingWriteQueue ; private int window ; private int pendingBytes ; private boolean writing ; private boolean cancelled ; DefaultState ( Http2Stream stream , int initialWindowSize , boolean markedWritable ) { super ( stream , markedWritable ) ; window ( initialWindowSize ) ; pendingWriteQueue = new ArrayDeque < FlowControlled > ( <int> ) ; } DefaultState ( AbstractState existingState , int initialWindowSize ) { super ( existingState ) ; window ( initialWindowSize ) ; pendingWriteQueue = new ArrayDeque < FlowControlled > ( <int> ) ; } @Override int windowSize ( ) { return window ; } @Override int initialWindowSize ( ) { return initialWindowSize ; } @Override void window ( int initialWindowSize ) { window = initialWindowSize ; } @Override int writeAllocatedBytes ( int allocated ) { final int initialAllocated = allocated ; int writtenBytes ; Throwable cause = null ; FlowControlled frame ; try { assert ! writing ; writing = true ; boolean writeOccurred = false ; while ( ! cancelled & & ( frame = peek ( ) ) ! = null ) { int maxBytes = min ( allocated , writableWindow ( ) ) ; if ( maxBytes < = <int> & & frame . size ( ) > <int> ) { break ; } writeOccurred = true ; int initialFrameSize = frame . size ( ) ; try { frame . write ( ctx , max ( <int> , maxBytes ) ) ; if ( frame . size ( ) = = <int> ) { pendingWriteQueue . remove ( ) ; frame . writeComplete ( ) ; } } finally { allocated - = initialFrameSize - frame . size ( ) ; } } if ( ! writeOccurred ) { return - <int> ; } } catch ( Throwable t ) { cancelled = true ; cause = t ; } finally { writing = false ; writtenBytes = initialAllocated - allocated ; decrementPendingBytes ( writtenBytes , false ) ; decrementFlowControlWindow ( writtenBytes ) ; if ( cancelled ) { cancel ( cause ) ; } } return writtenBytes ; } @Override int incrementStreamWindow ( int delta ) throws Http2Exception { if ( delta > <int> & & Integer . MAX_VALUE - delta < window ) { throw streamError ( stream . id ( ) , FLOW_CONTROL_ERROR , <str> , stream . id ( ) ) ; } window + = delta ; streamByteDistributor . updateStreamableBytes ( this ) ; return window ; } @Override public int streamableBytes ( ) { return max ( <int> , min ( pendingBytes , window ) ) ; } private int writableWindow ( ) { return min ( window , connectionWindowSize ( ) ) ; } @Override int pendingBytes ( ) { return pendingBytes ; } @Override void enqueueFrame ( FlowControlled frame ) { FlowControlled last = pendingWriteQueue . peekLast ( ) ; if ( last = = null | | ! last . merge ( ctx , frame ) ) { pendingWriteQueue . offer ( frame ) ; } incrementPendingBytes ( frame . size ( ) , true ) ; } @Override public boolean hasFrame ( ) { return ! pendingWriteQueue . isEmpty ( ) ; } private FlowControlled peek ( ) { return pendingWriteQueue . peek ( ) ; } @Override void cancel ( ) { cancel ( null ) ; } private void cancel ( Throwable cause ) { cancelled = true ; if ( writing ) { return ; } for ( ; ; ) { FlowControlled frame = pendingWriteQueue . poll ( ) ; if ( frame = = null ) { break ; } writeError ( frame , streamError ( stream . id ( ) , INTERNAL_ERROR , cause , <str> ) ) ; } streamByteDistributor . updateStreamableBytes ( this ) ; } private void incrementPendingBytes ( int numBytes , boolean updateStreamableBytes ) { pendingBytes + = numBytes ; monitor . incrementPendingBytes ( numBytes ) ; if ( updateStreamableBytes ) { streamByteDistributor . updateStreamableBytes ( this ) ; } } private void decrementPendingBytes ( int bytes , boolean updateStreamableBytes ) { incrementPendingBytes ( - bytes , updateStreamableBytes ) ; } private void decrementFlowControlWindow ( int bytes ) { try { int negativeBytes = - bytes ; connectionState . incrementStreamWindow ( negativeBytes ) ; incrementStreamWindow ( negativeBytes ) ; } catch ( Http2Exception e ) { throw new IllegalStateException ( <str> + e . getMessage ( ) , e ) ; } } private void writeError ( FlowControlled frame , Http2Exception cause ) { assert ctx ! = null ; decrementPendingBytes ( frame . size ( ) , true ) ; frame . error ( ctx , cause ) ; } } private final class ReducedState extends AbstractState { ReducedState ( Http2Stream stream ) { super ( stream , false ) ; } ReducedState ( AbstractState existingState ) { super ( existingState ) ; } @Override int windowSize ( ) { return <int> ; } @Override int initialWindowSize ( ) { return <int> ; } @Override public int streamableBytes ( ) { return <int> ; } @Override int pendingBytes ( ) { return <int> ; } @Override int writeAllocatedBytes ( int allocated ) { throw new UnsupportedOperationException ( ) ; } @Override void cancel ( ) { } @Override void window ( int initialWindowSize ) { throw new UnsupportedOperationException ( ) ; } @Override int incrementStreamWindow ( int delta ) throws Http2Exception { return <int> ; } @Override void enqueueFrame ( FlowControlled frame ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean hasFrame ( ) { return false ; } } private abstract class AbstractState implements StreamByteDistributor . StreamState { protected final Http2Stream stream ; private boolean markedWritable ; AbstractState ( Http2Stream stream , boolean markedWritable ) { this . stream = stream ; this . markedWritable = markedWritable ; } AbstractState ( AbstractState existingState ) { stream = existingState . stream ( ) ; markedWritable = existingState . markWritability ( ) ; } @Override public final Http2Stream stream ( ) { return stream ; } final boolean markWritability ( ) { return markedWritable ; } final void markWritability ( boolean isWritable ) { this . markedWritable = isWritable ; } abstract int windowSize ( ) ; abstract int initialWindowSize ( ) ; abstract int writeAllocatedBytes ( int allocated ) ; abstract int pendingBytes ( ) ; abstract void cancel ( ) ; abstract void window ( int initialWindowSize ) ; abstract int incrementStreamWindow ( int delta ) throws Http2Exception ; abstract void enqueueFrame ( FlowControlled frame ) ; } private abstract class WritabilityMonitor { private long totalPendingBytes ; public abstract void initialWindowSize ( int newWindowSize ) throws Http2Exception ; public abstract void writePendingBytes ( ) throws Http2Exception ; public void channelWritabilityChange ( ) throws Http2Exception { } public void stateCancelled ( AbstractState state ) { } public void incrementWindowSize ( AbstractState state , int delta ) throws Http2Exception { state . incrementStreamWindow ( delta ) ; } public void enqueueFrame ( AbstractState state , FlowControlled frame ) throws Http2Exception { state . enqueueFrame ( frame ) ; } public final void incrementPendingBytes ( int delta ) { totalPendingBytes + = delta ; } public final boolean isWritable ( AbstractState state ) { return isWritableConnection ( ) & & state . windowSize ( ) - state . pendingBytes ( ) > <int> ; } protected final void writePendingBytes ( Writer writer ) throws Http2Exception { int bytesToWrite = writableBytes ( ) ; for ( ; ; ) { if ( ! streamByteDistributor . distribute ( bytesToWrite , writer ) | | ( bytesToWrite = writableBytes ( ) ) < = <int> | | ! isChannelWritable0 ( ) ) { break ; } } } protected final boolean initialWindowSize ( int newWindowSize , Writer writer ) throws Http2Exception { if ( newWindowSize < <int> ) { throw new IllegalArgumentException ( <str> + newWindowSize ) ; } final int delta = newWindowSize - initialWindowSize ; initialWindowSize = newWindowSize ; connection . forEachActiveStream ( new Http2StreamVisitor ( ) { @Override public boolean visit ( Http2Stream stream ) throws Http2Exception { state ( stream ) . incrementStreamWindow ( delta ) ; return true ; } } ) ; if ( delta > <int> ) { writePendingBytes ( writer ) ; return false ; } return true ; } protected final boolean isWritableConnection ( ) { return connectionState . windowSize ( ) - totalPendingBytes > <int> & & isChannelWritable ( ) ; } } private final class DefaultWritabilityMonitor extends WritabilityMonitor { private final Writer writer = new StreamByteDistributor . Writer ( ) { @Override public void write ( Http2Stream stream , int numBytes ) { state ( stream ) . writeAllocatedBytes ( numBytes ) ; } } ; @Override public void writePendingBytes ( ) throws Http2Exception { writePendingBytes ( writer ) ; } @Override public void initialWindowSize ( int newWindowSize ) throws Http2Exception { initialWindowSize ( newWindowSize , writer ) ; } } private final class ListenerWritabilityMonitor extends WritabilityMonitor { private final Listener listener ; private final Http2StreamVisitor checkStreamWritabilityVisitor = new Http2StreamVisitor ( ) { @Override public boolean visit ( Http2Stream stream ) throws Http2Exception { AbstractState state = state ( stream ) ; if ( isWritable ( state ) ! = state . markWritability ( ) ) { notifyWritabilityChanged ( state ) ; } return true ; } } ; private final Writer initialWindowSizeWriter = new StreamByteDistributor . Writer ( ) { @Override public void write ( Http2Stream stream , int numBytes ) { AbstractState state = state ( stream ) ; writeAllocatedBytes ( state , numBytes ) ; if ( isWritable ( state ) ! = state . markWritability ( ) ) { notifyWritabilityChanged ( state ) ; } } } ; private final Writer writeAllocatedBytesWriter = new StreamByteDistributor . Writer ( ) { @Override public void write ( Http2Stream stream , int numBytes ) { writeAllocatedBytes ( state ( stream ) , numBytes ) ; } } ; ListenerWritabilityMonitor ( Listener listener ) { this . listener = listener ; } @Override public void writePendingBytes ( ) throws Http2Exception { writePendingBytes ( writeAllocatedBytesWriter ) ; } @Override public void incrementWindowSize ( AbstractState state , int delta ) throws Http2Exception { super . incrementWindowSize ( state , delta ) ; if ( isWritable ( state ) ! = state . markWritability ( ) ) { if ( state = = connectionState ) { checkAllWritabilityChanged ( ) ; } else { notifyWritabilityChanged ( state ) ; } } } @Override public void initialWindowSize ( int newWindowSize ) throws Http2Exception { if ( initialWindowSize ( newWindowSize , initialWindowSizeWriter ) ) { if ( isWritableConnection ( ) ) { checkAllWritabilityChanged ( ) ; } } } @Override public void enqueueFrame ( AbstractState state , FlowControlled frame ) throws Http2Exception { super . enqueueFrame ( state , frame ) ; checkConnectionThenStreamWritabilityChanged ( state ) ; } @Override public void stateCancelled ( AbstractState state ) { try { checkConnectionThenStreamWritabilityChanged ( state ) ; } catch ( Http2Exception e ) { logger . error ( <str> , e ) ; } } @Override public void channelWritabilityChange ( ) throws Http2Exception { if ( connectionState . markWritability ( ) ! = isChannelWritable ( ) ) { checkAllWritabilityChanged ( ) ; } } private void notifyWritabilityChanged ( AbstractState state ) { state . markWritability ( ! state . markWritability ( ) ) ; try { listener . writabilityChanged ( state . stream ) ; } catch ( RuntimeException e ) { logger . error ( <str> , e ) ; } } private void checkConnectionThenStreamWritabilityChanged ( AbstractState state ) throws Http2Exception { if ( isWritableConnection ( ) ! = connectionState . markWritability ( ) ) { checkAllWritabilityChanged ( ) ; } else if ( isWritable ( state ) ! = state . markWritability ( ) ) { notifyWritabilityChanged ( state ) ; } } private void checkAllWritabilityChanged ( ) throws Http2Exception { connectionState . markWritability ( isWritableConnection ( ) ) ; connection . forEachActiveStream ( checkStreamWritabilityVisitor ) ; } private void writeAllocatedBytes ( AbstractState state , int numBytes ) { int written = state . writeAllocatedBytes ( numBytes ) ; if ( written ! = - <int> ) { listener . streamWritten ( state . stream ( ) , written ) ; } } } } 
