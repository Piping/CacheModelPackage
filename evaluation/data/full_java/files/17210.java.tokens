package org . jbox2d . dynamics . joints ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . Body ; import org . jbox2d . dynamics . SolverData ; import org . jbox2d . dynamics . World ; import org . jbox2d . dynamics . contacts . Position ; import org . jbox2d . dynamics . contacts . Velocity ; public class ConstantVolumeJoint extends Joint { private final Body [ ] bodies ; private float [ ] targetLengths ; private float targetVolume ; private Vec2 [ ] normals ; private float m_impulse = <float> ; private World world ; private DistanceJoint [ ] distanceJoints ; public Body [ ] getBodies ( ) { return bodies ; } public DistanceJoint [ ] getJoints ( ) { return distanceJoints ; } public void inflate ( float factor ) { targetVolume * = factor ; } public ConstantVolumeJoint ( World argWorld , ConstantVolumeJointDef def ) { super ( argWorld . getPool ( ) , def ) ; world = argWorld ; if ( def . bodies . size ( ) < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } bodies = def . bodies . toArray ( new Body [ <int> ] ) ; targetLengths = new float [ bodies . length ] ; for ( int i = <int> ; i < targetLengths . length ; + + i ) { final int next = ( i = = targetLengths . length - <int> ) ? <int> : i + <int> ; float dist = bodies [ i ] . getWorldCenter ( ) . sub ( bodies [ next ] . getWorldCenter ( ) ) . length ( ) ; targetLengths [ i ] = dist ; } targetVolume = getBodyArea ( ) ; if ( def . joints ! = null & & def . joints . size ( ) ! = def . bodies . size ( ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( def . joints = = null ) { final DistanceJointDef djd = new DistanceJointDef ( ) ; distanceJoints = new DistanceJoint [ bodies . length ] ; for ( int i = <int> ; i < targetLengths . length ; + + i ) { final int next = ( i = = targetLengths . length - <int> ) ? <int> : i + <int> ; djd . frequencyHz = def . frequencyHz ; djd . dampingRatio = def . dampingRatio ; djd . collideConnected = def . collideConnected ; djd . initialize ( bodies [ i ] , bodies [ next ] , bodies [ i ] . getWorldCenter ( ) , bodies [ next ] . getWorldCenter ( ) ) ; distanceJoints [ i ] = ( DistanceJoint ) world . createJoint ( djd ) ; } } else { distanceJoints = def . joints . toArray ( new DistanceJoint [ <int> ] ) ; } normals = new Vec2 [ bodies . length ] ; for ( int i = <int> ; i < normals . length ; + + i ) { normals [ i ] = new Vec2 ( ) ; } } @Override public void destructor ( ) { for ( int i = <int> ; i < distanceJoints . length ; + + i ) { world . destroyJoint ( distanceJoints [ i ] ) ; } } private float getBodyArea ( ) { float area = <float> ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; area + = bodies [ i ] . getWorldCenter ( ) . x * bodies [ next ] . getWorldCenter ( ) . y - bodies [ next ] . getWorldCenter ( ) . x * bodies [ i ] . getWorldCenter ( ) . y ; } area * = <float> ; return area ; } private float getSolverArea ( Position [ ] positions ) { float area = <float> ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; area + = positions [ bodies [ i ] . m_islandIndex ] . c . x * positions [ bodies [ next ] . m_islandIndex ] . c . y - positions [ bodies [ next ] . m_islandIndex ] . c . x * positions [ bodies [ i ] . m_islandIndex ] . c . y ; } area * = <float> ; return area ; } private boolean constrainEdges ( Position [ ] positions ) { float perimeter = <float> ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; float dx = positions [ bodies [ next ] . m_islandIndex ] . c . x - positions [ bodies [ i ] . m_islandIndex ] . c . x ; float dy = positions [ bodies [ next ] . m_islandIndex ] . c . y - positions [ bodies [ i ] . m_islandIndex ] . c . y ; float dist = MathUtils . sqrt ( dx * dx + dy * dy ) ; if ( dist < Settings . EPSILON ) { dist = <float> ; } normals [ i ] . x = dy / dist ; normals [ i ] . y = - dx / dist ; perimeter + = dist ; } final Vec2 delta = pool . popVec2 ( ) ; float deltaArea = targetVolume - getSolverArea ( positions ) ; float toExtrude = <float> * deltaArea / perimeter ; boolean done = true ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; delta . set ( toExtrude * ( normals [ i ] . x + normals [ next ] . x ) , toExtrude * ( normals [ i ] . y + normals [ next ] . y ) ) ; float normSqrd = delta . lengthSquared ( ) ; if ( normSqrd > Settings . maxLinearCorrection * Settings . maxLinearCorrection ) { delta . mulLocal ( Settings . maxLinearCorrection / MathUtils . sqrt ( normSqrd ) ) ; } if ( normSqrd > Settings . linearSlop * Settings . linearSlop ) { done = false ; } positions [ bodies [ next ] . m_islandIndex ] . c . x + = delta . x ; positions [ bodies [ next ] . m_islandIndex ] . c . y + = delta . y ; } pool . pushVec2 ( <int> ) ; return done ; } @Override public void initVelocityConstraints ( final SolverData step ) { Velocity [ ] velocities = step . velocities ; Position [ ] positions = step . positions ; final Vec2 [ ] d = pool . getVec2Array ( bodies . length ) ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int prev = ( i = = <int> ) ? bodies . length - <int> : i - <int> ; final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; d [ i ] . set ( positions [ bodies [ next ] . m_islandIndex ] . c ) ; d [ i ] . subLocal ( positions [ bodies [ prev ] . m_islandIndex ] . c ) ; } if ( step . step . warmStarting ) { m_impulse * = step . step . dtRatio ; for ( int i = <int> ; i < bodies . length ; + + i ) { velocities [ bodies [ i ] . m_islandIndex ] . v . x + = bodies [ i ] . m_invMass * d [ i ] . y * <float> * m_impulse ; velocities [ bodies [ i ] . m_islandIndex ] . v . y + = bodies [ i ] . m_invMass * - d [ i ] . x * <float> * m_impulse ; } } else { m_impulse = <float> ; } } @Override public boolean solvePositionConstraints ( SolverData step ) { return constrainEdges ( step . positions ) ; } @Override public void solveVelocityConstraints ( final SolverData step ) { float crossMassSum = <float> ; float dotMassSum = <float> ; Velocity [ ] velocities = step . velocities ; Position [ ] positions = step . positions ; final Vec2 d [ ] = pool . getVec2Array ( bodies . length ) ; for ( int i = <int> ; i < bodies . length ; + + i ) { final int prev = ( i = = <int> ) ? bodies . length - <int> : i - <int> ; final int next = ( i = = bodies . length - <int> ) ? <int> : i + <int> ; d [ i ] . set ( positions [ bodies [ next ] . m_islandIndex ] . c ) ; d [ i ] . subLocal ( positions [ bodies [ prev ] . m_islandIndex ] . c ) ; dotMassSum + = ( d [ i ] . lengthSquared ( ) ) / bodies [ i ] . getMass ( ) ; crossMassSum + = Vec2 . cross ( velocities [ bodies [ i ] . m_islandIndex ] . v , d [ i ] ) ; } float lambda = - <float> * crossMassSum / dotMassSum ; m_impulse + = lambda ; for ( int i = <int> ; i < bodies . length ; + + i ) { velocities [ bodies [ i ] . m_islandIndex ] . v . x + = bodies [ i ] . m_invMass * d [ i ] . y * <float> * lambda ; velocities [ bodies [ i ] . m_islandIndex ] . v . y + = bodies [ i ] . m_invMass * - d [ i ] . x * <float> * lambda ; } } @Override public void getAnchorA ( Vec2 argOut ) { } @Override public void getAnchorB ( Vec2 argOut ) { } @Override public void getReactionForce ( float inv_dt , Vec2 argOut ) { } @Override public float getReactionTorque ( float inv_dt ) { return <int> ; } } 
