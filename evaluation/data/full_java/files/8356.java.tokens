package org . elasticsearch . indices . state ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . close . CloseIndexResponse ; import org . elasticsearch . action . admin . indices . close . TransportCloseIndexAction ; import org . elasticsearch . action . support . DestructiveOperations ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class CloseIndexDisableCloseAllIT extends ESIntegTestCase { public void testCloseAllRequiresName ( ) { Settings clusterSettings = Settings . builder ( ) . put ( DestructiveOperations . REQUIRES_NAME , true ) . build ( ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( clusterSettings ) ) ; createIndex ( <str> , <str> , <str> ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> , <str> ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { } CloseIndexResponse closeIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( closeIndexResponse . isAcknowledged ( ) , equalTo ( true ) ) ; assertIndexIsClosed ( <str> , <str> ) ; Client client = client ( ) ; createIndex ( <str> ) ; healthResponse = client . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForGreenStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( TransportCloseIndexAction . SETTING_CLUSTER_INDICES_CLOSE_ENABLE , false ) ) . get ( ) ; try { client . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertEquals ( ex . getMessage ( ) , <str> ) ; } } private void assertIndexIsClosed ( String . . . indices ) { checkIndexState ( IndexMetaData . State . CLOSE , indices ) ; } private void checkIndexState ( IndexMetaData . State state , String . . . indices ) { ClusterStateResponse clusterStateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) ; for ( String index : indices ) { IndexMetaData indexMetaData = clusterStateResponse . getState ( ) . metaData ( ) . indices ( ) . get ( index ) ; assertThat ( indexMetaData , notNullValue ( ) ) ; assertThat ( indexMetaData . getState ( ) , equalTo ( state ) ) ; } } } 
