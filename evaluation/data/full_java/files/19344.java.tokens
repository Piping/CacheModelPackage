package io . netty . handler . codec . http2 ; public final class Http2Flags { public static final short END_STREAM = <hex> ; public static final short END_HEADERS = <hex> ; public static final short ACK = <hex> ; public static final short PADDED = <hex> ; public static final short PRIORITY = <hex> ; private short value ; public Http2Flags ( ) { } public Http2Flags ( short value ) { this . value = value ; } public short value ( ) { return value ; } public boolean endOfStream ( ) { return isFlagSet ( END_STREAM ) ; } public boolean endOfHeaders ( ) { return isFlagSet ( END_HEADERS ) ; } public boolean priorityPresent ( ) { return isFlagSet ( PRIORITY ) ; } public boolean ack ( ) { return isFlagSet ( ACK ) ; } public boolean paddingPresent ( ) { return isFlagSet ( PADDED ) ; } public int getNumPriorityBytes ( ) { return priorityPresent ( ) ? <int> : <int> ; } public int getPaddingPresenceFieldLength ( ) { return paddingPresent ( ) ? <int> : <int> ; } public Http2Flags endOfStream ( boolean endOfStream ) { return setFlag ( endOfStream , END_STREAM ) ; } public Http2Flags endOfHeaders ( boolean endOfHeaders ) { return setFlag ( endOfHeaders , END_HEADERS ) ; } public Http2Flags priorityPresent ( boolean priorityPresent ) { return setFlag ( priorityPresent , PRIORITY ) ; } public Http2Flags paddingPresent ( boolean paddingPresent ) { return setFlag ( paddingPresent , PADDED ) ; } public Http2Flags ack ( boolean ack ) { return setFlag ( ack , ACK ) ; } public Http2Flags setFlag ( boolean on , short mask ) { if ( on ) { value | = mask ; } else { value & = ~ mask ; } return this ; } public boolean isFlagSet ( short mask ) { return ( value & mask ) ! = <int> ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + value ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } return value = = ( ( Http2Flags ) obj ) . value ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( <str> ) . append ( value ) . append ( <str> ) ; if ( ack ( ) ) { builder . append ( <str> ) ; } if ( endOfHeaders ( ) ) { builder . append ( <str> ) ; } if ( endOfStream ( ) ) { builder . append ( <str> ) ; } if ( priorityPresent ( ) ) { builder . append ( <str> ) ; } if ( paddingPresent ( ) ) { builder . append ( <str> ) ; } builder . append ( <str> ) ; return builder . toString ( ) ; } } 
