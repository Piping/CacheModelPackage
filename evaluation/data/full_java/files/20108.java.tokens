package io . netty . resolver . dns ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . ChannelFactory ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . EventLoop ; import io . netty . channel . FixedRecvByteBufAllocator ; import io . netty . channel . ReflectiveChannelFactory ; import io . netty . channel . socket . DatagramChannel ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . handler . codec . dns . DatagramDnsQueryEncoder ; import io . netty . handler . codec . dns . DatagramDnsResponse ; import io . netty . handler . codec . dns . DatagramDnsResponseDecoder ; import io . netty . handler . codec . dns . DnsQuestion ; import io . netty . handler . codec . dns . DnsResponse ; import io . netty . resolver . NameResolver ; import io . netty . resolver . SimpleNameResolver ; import io . netty . util . NetUtil ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . FastThreadLocal ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . net . IDN ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public class DnsNameResolver extends SimpleNameResolver < InetSocketAddress > { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DnsNameResolver . class ) ; static final InetSocketAddress ANY_LOCAL_ADDR = new InetSocketAddress ( <int> ) ; private static final InternetProtocolFamily [ ] DEFAULT_RESOLVE_ADDRESS_TYPES = new InternetProtocolFamily [ <int> ] ; static { if ( <str> . equalsIgnoreCase ( SystemPropertyUtil . get ( <str> ) ) ) { DEFAULT_RESOLVE_ADDRESS_TYPES [ <int> ] = InternetProtocolFamily . IPv6 ; DEFAULT_RESOLVE_ADDRESS_TYPES [ <int> ] = InternetProtocolFamily . IPv4 ; logger . debug ( <str> ) ; } else { DEFAULT_RESOLVE_ADDRESS_TYPES [ <int> ] = InternetProtocolFamily . IPv4 ; DEFAULT_RESOLVE_ADDRESS_TYPES [ <int> ] = InternetProtocolFamily . IPv6 ; logger . debug ( <str> ) ; } } private static final DatagramDnsResponseDecoder DECODER = new DatagramDnsResponseDecoder ( ) ; private static final DatagramDnsQueryEncoder ENCODER = new DatagramDnsQueryEncoder ( ) ; final DnsServerAddresses nameServerAddresses ; final ChannelFuture bindFuture ; final DatagramChannel ch ; final DnsQueryContextManager queryContextManager = new DnsQueryContextManager ( ) ; final ConcurrentMap < String , List < DnsCacheEntry > > resolveCache = PlatformDependent . newConcurrentHashMap ( ) ; private final FastThreadLocal < DnsServerAddressStream > nameServerAddrStream = new FastThreadLocal < DnsServerAddressStream > ( ) { @Override protected DnsServerAddressStream initialValue ( ) throws Exception { return nameServerAddresses . stream ( ) ; } } ; private final DnsResponseHandler responseHandler = new DnsResponseHandler ( ) ; private volatile long queryTimeoutMillis = <int> ; private volatile int minTtl ; private volatile int maxTtl = Integer . MAX_VALUE ; private volatile int negativeTtl ; private volatile int maxQueriesPerResolve = <int> ; private volatile boolean traceEnabled = true ; private volatile InternetProtocolFamily [ ] resolveAddressTypes = DEFAULT_RESOLVE_ADDRESS_TYPES ; private volatile boolean recursionDesired = true ; private volatile int maxPayloadSize ; private volatile boolean optResourceEnabled = true ; public DnsNameResolver ( EventLoop eventLoop , Class < ? extends DatagramChannel > channelType , DnsServerAddresses nameServerAddresses ) { this ( eventLoop , channelType , ANY_LOCAL_ADDR , nameServerAddresses ) ; } public DnsNameResolver ( EventLoop eventLoop , Class < ? extends DatagramChannel > channelType , InetSocketAddress localAddress , DnsServerAddresses nameServerAddresses ) { this ( eventLoop , new ReflectiveChannelFactory < DatagramChannel > ( channelType ) , localAddress , nameServerAddresses ) ; } public DnsNameResolver ( EventLoop eventLoop , ChannelFactory < ? extends DatagramChannel > channelFactory , DnsServerAddresses nameServerAddresses ) { this ( eventLoop , channelFactory , ANY_LOCAL_ADDR , nameServerAddresses ) ; } public DnsNameResolver ( EventLoop eventLoop , ChannelFactory < ? extends DatagramChannel > channelFactory , InetSocketAddress localAddress , DnsServerAddresses nameServerAddresses ) { super ( eventLoop ) ; checkNotNull ( channelFactory , <str> ) ; checkNotNull ( nameServerAddresses , <str> ) ; checkNotNull ( localAddress , <str> ) ; this . nameServerAddresses = nameServerAddresses ; bindFuture = newChannel ( channelFactory , localAddress ) ; ch = ( DatagramChannel ) bindFuture . channel ( ) ; setMaxPayloadSize ( <int> ) ; } private ChannelFuture newChannel ( ChannelFactory < ? extends DatagramChannel > channelFactory , InetSocketAddress localAddress ) { Bootstrap b = new Bootstrap ( ) ; b . group ( executor ( ) ) ; b . channelFactory ( channelFactory ) ; b . handler ( new ChannelInitializer < DatagramChannel > ( ) { @Override protected void initChannel ( DatagramChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( DECODER , ENCODER , responseHandler ) ; } } ) ; ChannelFuture bindFuture = b . bind ( localAddress ) ; bindFuture . channel ( ) . closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { clearCache ( ) ; } } ) ; return bindFuture ; } public int minTtl ( ) { return minTtl ; } public int maxTtl ( ) { return maxTtl ; } public DnsNameResolver setTtl ( int minTtl , int maxTtl ) { if ( minTtl < <int> ) { throw new IllegalArgumentException ( <str> + minTtl + <str> ) ; } if ( maxTtl < <int> ) { throw new IllegalArgumentException ( <str> + maxTtl + <str> ) ; } if ( minTtl > maxTtl ) { throw new IllegalArgumentException ( <str> + minTtl + <str> + maxTtl + <str> ) ; } this . maxTtl = maxTtl ; this . minTtl = minTtl ; return this ; } public int negativeTtl ( ) { return negativeTtl ; } public DnsNameResolver setNegativeTtl ( int negativeTtl ) { if ( negativeTtl < <int> ) { throw new IllegalArgumentException ( <str> + negativeTtl + <str> ) ; } this . negativeTtl = negativeTtl ; return this ; } public long queryTimeoutMillis ( ) { return queryTimeoutMillis ; } public DnsNameResolver setQueryTimeoutMillis ( long queryTimeoutMillis ) { if ( queryTimeoutMillis < <int> ) { throw new IllegalArgumentException ( <str> + queryTimeoutMillis + <str> ) ; } this . queryTimeoutMillis = queryTimeoutMillis ; return this ; } public List < InternetProtocolFamily > resolveAddressTypes ( ) { return Arrays . asList ( resolveAddressTypes ) ; } InternetProtocolFamily [ ] resolveAddressTypesUnsafe ( ) { return resolveAddressTypes ; } public DnsNameResolver setResolveAddressTypes ( InternetProtocolFamily . . . resolveAddressTypes ) { checkNotNull ( resolveAddressTypes , <str> ) ; final List < InternetProtocolFamily > list = new ArrayList < InternetProtocolFamily > ( InternetProtocolFamily . values ( ) . length ) ; for ( InternetProtocolFamily f : resolveAddressTypes ) { if ( f = = null ) { break ; } if ( list . contains ( f ) ) { continue ; } list . add ( f ) ; } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> ) ; } this . resolveAddressTypes = list . toArray ( new InternetProtocolFamily [ list . size ( ) ] ) ; return this ; } public DnsNameResolver setResolveAddressTypes ( Iterable < InternetProtocolFamily > resolveAddressTypes ) { checkNotNull ( resolveAddressTypes , <str> ) ; final List < InternetProtocolFamily > list = new ArrayList < InternetProtocolFamily > ( InternetProtocolFamily . values ( ) . length ) ; for ( InternetProtocolFamily f : resolveAddressTypes ) { if ( f = = null ) { break ; } if ( list . contains ( f ) ) { continue ; } list . add ( f ) ; } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> ) ; } this . resolveAddressTypes = list . toArray ( new InternetProtocolFamily [ list . size ( ) ] ) ; return this ; } public boolean isRecursionDesired ( ) { return recursionDesired ; } public DnsNameResolver setRecursionDesired ( boolean recursionDesired ) { this . recursionDesired = recursionDesired ; return this ; } public int maxQueriesPerResolve ( ) { return maxQueriesPerResolve ; } public DnsNameResolver setMaxQueriesPerResolve ( int maxQueriesPerResolve ) { if ( maxQueriesPerResolve < = <int> ) { throw new IllegalArgumentException ( <str> + maxQueriesPerResolve + <str> ) ; } this . maxQueriesPerResolve = maxQueriesPerResolve ; return this ; } public boolean isTraceEnabled ( ) { return traceEnabled ; } public DnsNameResolver setTraceEnabled ( boolean traceEnabled ) { this . traceEnabled = traceEnabled ; return this ; } public int maxPayloadSize ( ) { return maxPayloadSize ; } public DnsNameResolver setMaxPayloadSize ( int maxPayloadSize ) { if ( maxPayloadSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxPayloadSize + <str> ) ; } if ( this . maxPayloadSize = = maxPayloadSize ) { return this ; } this . maxPayloadSize = maxPayloadSize ; ch . config ( ) . setRecvByteBufAllocator ( new FixedRecvByteBufAllocator ( maxPayloadSize ) ) ; return this ; } public DnsNameResolver setOptResourceEnabled ( boolean optResourceEnabled ) { this . optResourceEnabled = optResourceEnabled ; return this ; } public boolean isOptResourceEnabled ( ) { return optResourceEnabled ; } public DnsNameResolver clearCache ( ) { for ( Iterator < Entry < String , List < DnsCacheEntry > > > i = resolveCache . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final Entry < String , List < DnsCacheEntry > > e = i . next ( ) ; i . remove ( ) ; cancelExpiration ( e ) ; } return this ; } public boolean clearCache ( String hostname ) { boolean removed = false ; for ( Iterator < Entry < String , List < DnsCacheEntry > > > i = resolveCache . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final Entry < String , List < DnsCacheEntry > > e = i . next ( ) ; if ( e . getKey ( ) . equals ( hostname ) ) { i . remove ( ) ; cancelExpiration ( e ) ; removed = true ; } } return removed ; } private static void cancelExpiration ( Entry < String , List < DnsCacheEntry > > e ) { final List < DnsCacheEntry > entries = e . getValue ( ) ; final int numEntries = entries . size ( ) ; for ( int i = <int> ; i < numEntries ; i + + ) { entries . get ( i ) . cancelExpiration ( ) ; } } @Override public void close ( ) { ch . close ( ) ; } @Override protected EventLoop executor ( ) { return ( EventLoop ) super . executor ( ) ; } @Override protected boolean doIsResolved ( InetSocketAddress address ) { return ! address . isUnresolved ( ) ; } @Override protected void doResolve ( InetSocketAddress unresolvedAddress , Promise < InetSocketAddress > promise ) throws Exception { final byte [ ] bytes = NetUtil . createByteArrayFromIpAddressString ( unresolvedAddress . getHostName ( ) ) ; if ( bytes ! = null ) { promise . setSuccess ( new InetSocketAddress ( InetAddress . getByAddress ( bytes ) , unresolvedAddress . getPort ( ) ) ) ; return ; } final String hostname = hostname ( unresolvedAddress ) ; final int port = unresolvedAddress . getPort ( ) ; if ( ! doResolveCached ( hostname , port , promise ) ) { doResolveUncached ( hostname , port , promise ) ; } } private boolean doResolveCached ( String hostname , int port , Promise < InetSocketAddress > promise ) { final List < DnsCacheEntry > cachedEntries = resolveCache . get ( hostname ) ; if ( cachedEntries = = null ) { return false ; } InetAddress address = null ; Throwable cause = null ; synchronized ( cachedEntries ) { final int numEntries = cachedEntries . size ( ) ; assert numEntries > <int> ; if ( cachedEntries . get ( <int> ) . cause ( ) ! = null ) { cause = cachedEntries . get ( <int> ) . cause ( ) ; } else { for ( InternetProtocolFamily f : resolveAddressTypes ) { for ( int i = <int> ; i < numEntries ; i + + ) { final DnsCacheEntry e = cachedEntries . get ( i ) ; if ( f . addressType ( ) . isInstance ( e . address ( ) ) ) { address = e . address ( ) ; break ; } } } } } if ( address ! = null ) { setSuccess ( promise , new InetSocketAddress ( address , port ) ) ; } else if ( cause ! = null ) { if ( ! promise . tryFailure ( cause ) ) { logger . warn ( <str> , promise , cause ) ; } } else { return false ; } return true ; } private static void setSuccess ( Promise < InetSocketAddress > promise , InetSocketAddress result ) { if ( ! promise . trySuccess ( result ) ) { logger . warn ( <str> , result , promise ) ; } } private void doResolveUncached ( String hostname , final int port , Promise < InetSocketAddress > promise ) { final DnsNameResolverContext < InetSocketAddress > ctx = new DnsNameResolverContext < InetSocketAddress > ( this , hostname , promise ) { @Override protected boolean finishResolve ( Class < ? extends InetAddress > addressType , List < DnsCacheEntry > resolvedEntries ) { final int numEntries = resolvedEntries . size ( ) ; for ( int i = <int> ; i < numEntries ; i + + ) { final InetAddress a = resolvedEntries . get ( i ) . address ( ) ; if ( addressType . isInstance ( a ) ) { setSuccess ( promise ( ) , new InetSocketAddress ( a , port ) ) ; return true ; } } return false ; } } ; ctx . resolve ( ) ; } @Override protected void doResolveAll ( InetSocketAddress unresolvedAddress , Promise < List < InetSocketAddress > > promise ) throws Exception { final byte [ ] bytes = NetUtil . createByteArrayFromIpAddressString ( unresolvedAddress . getHostName ( ) ) ; if ( bytes ! = null ) { promise . setSuccess ( Collections . singletonList ( new InetSocketAddress ( InetAddress . getByAddress ( bytes ) , unresolvedAddress . getPort ( ) ) ) ) ; return ; } final String hostname = hostname ( unresolvedAddress ) ; final int port = unresolvedAddress . getPort ( ) ; if ( ! doResolveAllCached ( hostname , port , promise ) ) { doResolveAllUncached ( hostname , port , promise ) ; } } private boolean doResolveAllCached ( String hostname , int port , Promise < List < InetSocketAddress > > promise ) { final List < DnsCacheEntry > cachedEntries = resolveCache . get ( hostname ) ; if ( cachedEntries = = null ) { return false ; } List < InetSocketAddress > result = null ; Throwable cause = null ; synchronized ( cachedEntries ) { final int numEntries = cachedEntries . size ( ) ; assert numEntries > <int> ; if ( cachedEntries . get ( <int> ) . cause ( ) ! = null ) { cause = cachedEntries . get ( <int> ) . cause ( ) ; } else { for ( InternetProtocolFamily f : resolveAddressTypes ) { for ( int i = <int> ; i < numEntries ; i + + ) { final DnsCacheEntry e = cachedEntries . get ( i ) ; if ( f . addressType ( ) . isInstance ( e . address ( ) ) ) { if ( result = = null ) { result = new ArrayList < InetSocketAddress > ( numEntries ) ; } result . add ( new InetSocketAddress ( e . address ( ) , port ) ) ; } } } } } if ( result ! = null ) { promise . trySuccess ( result ) ; } else if ( cause ! = null ) { promise . tryFailure ( cause ) ; } else { return false ; } return true ; } private void doResolveAllUncached ( final String hostname , final int port , final Promise < List < InetSocketAddress > > promise ) { final DnsNameResolverContext < List < InetSocketAddress > > ctx = new DnsNameResolverContext < List < InetSocketAddress > > ( this , hostname , promise ) { @Override protected boolean finishResolve ( Class < ? extends InetAddress > addressType , List < DnsCacheEntry > resolvedEntries ) { List < InetSocketAddress > result = null ; final int numEntries = resolvedEntries . size ( ) ; for ( int i = <int> ; i < numEntries ; i + + ) { final InetAddress a = resolvedEntries . get ( i ) . address ( ) ; if ( addressType . isInstance ( a ) ) { if ( result = = null ) { result = new ArrayList < InetSocketAddress > ( numEntries ) ; } result . add ( new InetSocketAddress ( a , port ) ) ; } } if ( result ! = null ) { promise ( ) . trySuccess ( result ) ; return true ; } return false ; } } ; ctx . resolve ( ) ; } private static String hostname ( InetSocketAddress addr ) { final String hostname ; if ( PlatformDependent . javaVersion ( ) < <int> ) { hostname = addr . getHostName ( ) ; } else { hostname = addr . getHostString ( ) ; } return IDN . toASCII ( hostname ) ; } void cache ( String hostname , InetAddress address , long originalTtl ) { final int maxTtl = maxTtl ( ) ; if ( maxTtl = = <int> ) { return ; } final int ttl = Math . max ( minTtl ( ) , ( int ) Math . min ( maxTtl , originalTtl ) ) ; final List < DnsCacheEntry > entries = cachedEntries ( hostname ) ; final DnsCacheEntry e = new DnsCacheEntry ( hostname , address ) ; synchronized ( entries ) { if ( ! entries . isEmpty ( ) ) { final DnsCacheEntry firstEntry = entries . get ( <int> ) ; if ( firstEntry . cause ( ) ! = null ) { assert entries . size ( ) = = <int> ; firstEntry . cancelExpiration ( ) ; entries . clear ( ) ; } } entries . add ( e ) ; } scheduleCacheExpiration ( entries , e , ttl ) ; } void cache ( String hostname , Throwable cause ) { final int negativeTtl = negativeTtl ( ) ; if ( negativeTtl = = <int> ) { return ; } final List < DnsCacheEntry > entries = cachedEntries ( hostname ) ; final DnsCacheEntry e = new DnsCacheEntry ( hostname , cause ) ; synchronized ( entries ) { final int numEntries = entries . size ( ) ; for ( int i = <int> ; i < numEntries ; i + + ) { entries . get ( i ) . cancelExpiration ( ) ; } entries . clear ( ) ; entries . add ( e ) ; } scheduleCacheExpiration ( entries , e , negativeTtl ) ; } private List < DnsCacheEntry > cachedEntries ( String hostname ) { List < DnsCacheEntry > oldEntries = resolveCache . get ( hostname ) ; final List < DnsCacheEntry > entries ; if ( oldEntries = = null ) { List < DnsCacheEntry > newEntries = new ArrayList < DnsCacheEntry > ( ) ; oldEntries = resolveCache . putIfAbsent ( hostname , newEntries ) ; entries = oldEntries ! = null ? oldEntries : newEntries ; } else { entries = oldEntries ; } return entries ; } private void scheduleCacheExpiration ( final List < DnsCacheEntry > entries , final DnsCacheEntry e , int ttl ) { e . scheduleExpiration ( ch . eventLoop ( ) , new OneTimeTask ( ) { @Override public void run ( ) { synchronized ( entries ) { entries . remove ( e ) ; if ( entries . isEmpty ( ) ) { resolveCache . remove ( e . hostname ( ) ) ; } } } } , ttl , TimeUnit . SECONDS ) ; } public Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > query ( DnsQuestion question ) { return query ( nextNameServerAddress ( ) , question ) ; } public Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > query ( DnsQuestion question , Promise < AddressedEnvelope < ? extends DnsResponse , InetSocketAddress > > promise ) { return query ( nextNameServerAddress ( ) , question , promise ) ; } private InetSocketAddress nextNameServerAddress ( ) { return nameServerAddrStream . get ( ) . next ( ) ; } public Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > query ( InetSocketAddress nameServerAddr , DnsQuestion question ) { return query0 ( checkNotNull ( nameServerAddr , <str> ) , checkNotNull ( question , <str> ) , ch . eventLoop ( ) . < AddressedEnvelope < ? extends DnsResponse , InetSocketAddress > > newPromise ( ) ) ; } public Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > query ( InetSocketAddress nameServerAddr , DnsQuestion question , Promise < AddressedEnvelope < ? extends DnsResponse , InetSocketAddress > > promise ) { return query0 ( checkNotNull ( nameServerAddr , <str> ) , checkNotNull ( question , <str> ) , checkNotNull ( promise , <str> ) ) ; } private Future < AddressedEnvelope < DnsResponse , InetSocketAddress > > query0 ( InetSocketAddress nameServerAddr , DnsQuestion question , Promise < AddressedEnvelope < ? extends DnsResponse , InetSocketAddress > > promise ) { final Promise < AddressedEnvelope < DnsResponse , InetSocketAddress > > castPromise = cast ( promise ) ; try { new DnsQueryContext ( this , nameServerAddr , question , castPromise ) . query ( ) ; return castPromise ; } catch ( Exception e ) { return castPromise . setFailure ( e ) ; } } @SuppressWarnings ( <str> ) private static Promise < AddressedEnvelope < DnsResponse , InetSocketAddress > > cast ( Promise < ? > promise ) { return ( Promise < AddressedEnvelope < DnsResponse , InetSocketAddress > > ) promise ; } private final class DnsResponseHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { try { final DatagramDnsResponse res = ( DatagramDnsResponse ) msg ; final int queryId = res . id ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ch , queryId , res . sender ( ) , res ) ; } final DnsQueryContext qCtx = queryContextManager . get ( res . sender ( ) , queryId ) ; if ( qCtx = = null ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , ch , queryId ) ; } return ; } qCtx . finish ( res ) ; } finally { ReferenceCountUtil . safeRelease ( msg ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . warn ( <str> , ch , cause ) ; } } } 
