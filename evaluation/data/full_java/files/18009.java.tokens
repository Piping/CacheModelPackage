package com . badlogic . gdx . graphics . g3d . environment ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class AmbientCubemap { private final static float clamp ( final float v ) { return v < <float> ? <float> : ( v > <float> ? <float> : v ) ; } public final float data [ ] ; public AmbientCubemap ( ) { data = new float [ <int> * <int> ] ; } public AmbientCubemap ( final float copyFrom [ ] ) { if ( copyFrom . length ! = ( <int> * <int> ) ) throw new GdxRuntimeException ( <str> ) ; data = new float [ copyFrom . length ] ; System . arraycopy ( copyFrom , <int> , data , <int> , data . length ) ; } public AmbientCubemap ( final AmbientCubemap copyFrom ) { this ( copyFrom . data ) ; } public AmbientCubemap set ( final float values [ ] ) { for ( int i = <int> ; i < data . length ; i + + ) data [ i ] = values [ i ] ; return this ; } public AmbientCubemap set ( final AmbientCubemap other ) { return set ( other . data ) ; } public AmbientCubemap set ( final Color color ) { return set ( color . r , color . g , color . b ) ; } public AmbientCubemap set ( float r , float g , float b ) { for ( int idx = <int> ; idx < data . length ; ) { data [ idx + + ] = r ; data [ idx + + ] = g ; data [ idx + + ] = b ; } return this ; } public Color getColor ( final Color out , int side ) { side * = <int> ; return out . set ( data [ side ] , data [ side + <int> ] , data [ side + <int> ] , <float> ) ; } public AmbientCubemap clear ( ) { for ( int i = <int> ; i < data . length ; i + + ) data [ i ] = <float> ; return this ; } public AmbientCubemap clamp ( ) { for ( int i = <int> ; i < data . length ; i + + ) data [ i ] = clamp ( data [ i ] ) ; return this ; } public AmbientCubemap add ( float r , float g , float b ) { for ( int idx = <int> ; idx < data . length ; ) { data [ idx + + ] + = r ; data [ idx + + ] + = g ; data [ idx + + ] + = b ; } return this ; } public AmbientCubemap add ( final Color color ) { return add ( color . r , color . g , color . b ) ; } public AmbientCubemap add ( final float r , final float g , final float b , final float x , final float y , final float z ) { final float x2 = x * x , y2 = y * y , z2 = z * z ; float d = x2 + y2 + z2 ; if ( d = = <float> ) return this ; d = <float> / d * ( d + <float> ) ; final float rd = r * d , gd = g * d , bd = b * d ; int idx = x > <int> ? <int> : <int> ; data [ idx ] + = x2 * rd ; data [ idx + <int> ] + = x2 * gd ; data [ idx + <int> ] + = x2 * bd ; idx = y > <int> ? <int> : <int> ; data [ idx ] + = y2 * rd ; data [ idx + <int> ] + = y2 * gd ; data [ idx + <int> ] + = y2 * bd ; idx = z > <int> ? <int> : <int> ; data [ idx ] + = z2 * rd ; data [ idx + <int> ] + = z2 * gd ; data [ idx + <int> ] + = z2 * bd ; return this ; } public AmbientCubemap add ( final Color color , final Vector3 direction ) { return add ( color . r , color . g , color . b , direction . x , direction . y , direction . z ) ; } public AmbientCubemap add ( final float r , final float g , final float b , final Vector3 direction ) { return add ( r , g , b , direction . x , direction . y , direction . z ) ; } public AmbientCubemap add ( final Color color , final float x , final float y , final float z ) { return add ( color . r , color . g , color . b , x , y , z ) ; } public AmbientCubemap add ( final Color color , final Vector3 point , final Vector3 target ) { return add ( color . r , color . g , color . b , target . x - point . x , target . y - point . y , target . z - point . z ) ; } public AmbientCubemap add ( final Color color , final Vector3 point , final Vector3 target , final float intensity ) { final float t = intensity / ( <float> + target . dst ( point ) ) ; return add ( color . r * t , color . g * t , color . b * t , target . x - point . x , target . y - point . y , target . z - point . z ) ; } @Override public String toString ( ) { String result = <str> ; for ( int i = <int> ; i < data . length ; i + = <int> ) { result + = Float . toString ( data [ i ] ) + <str> + Float . toString ( data [ i + <int> ] ) + <str> + Float . toString ( data [ i + <int> ] ) + <str> ; } return result ; } } 
