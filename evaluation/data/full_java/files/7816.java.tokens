package org . elasticsearch . cluster . allocation ; import org . elasticsearch . cluster . ClusterModule ; import org . elasticsearch . cluster . routing . allocation . allocator . BalancedShardsAllocator ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocator ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import java . io . IOException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . ESIntegTestCase . * ; import static org . hamcrest . Matchers . instanceOf ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class ShardsAllocatorModuleIT extends ESIntegTestCase { public void testLoadDefaultShardsAllocator ( ) throws IOException { assertAllocatorInstance ( Settings . Builder . EMPTY_SETTINGS , BalancedShardsAllocator . class ) ; } public void testLoadByShortKeyShardsAllocator ( ) throws IOException { Settings build = settingsBuilder ( ) . put ( ClusterModule . SHARDS_ALLOCATOR_TYPE_KEY , <str> ) . build ( ) ; assertAllocatorInstance ( build , BalancedShardsAllocator . class ) ; build = settingsBuilder ( ) . put ( ClusterModule . SHARDS_ALLOCATOR_TYPE_KEY , ClusterModule . BALANCED_ALLOCATOR ) . build ( ) ; assertAllocatorInstance ( build , BalancedShardsAllocator . class ) ; } private void assertAllocatorInstance ( Settings settings , Class < ? extends ShardsAllocator > clazz ) throws IOException { while ( cluster ( ) . size ( ) ! = <int> ) { internalCluster ( ) . stopRandomDataNode ( ) ; } internalCluster ( ) . startNode ( settings ) ; ShardsAllocator instance = internalCluster ( ) . getInstance ( ShardsAllocator . class ) ; assertThat ( instance , instanceOf ( clazz ) ) ; } } 
