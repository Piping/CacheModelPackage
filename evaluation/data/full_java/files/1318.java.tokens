package org . apache . cassandra . utils ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import static org . apache . cassandra . utils . FilterFactory . getFilter ; import static org . apache . cassandra . utils . FilterTestHelper . testFalsePositives ; public class LongBloomFilterTest { private static final Logger logger = LoggerFactory . getLogger ( LongBloomFilterTest . class ) ; @Test public void testBigInt ( ) { testBigInt ( false ) ; testBigInt ( true ) ; } private static void testBigInt ( boolean oldBfHashOrder ) { int size = <int> * <int> * <int> ; IFilter bf = getFilter ( size , FilterTestHelper . spec . bucketsPerElement , false , oldBfHashOrder ) ; double fp = testFalsePositives ( bf , new KeyGenerator . IntGenerator ( size ) , new KeyGenerator . IntGenerator ( size , size * <int> ) ) ; logger . info ( <str> , oldBfHashOrder , fp ) ; } @Test public void testBigRandom ( ) { testBigRandom ( false ) ; testBigRandom ( true ) ; } private static void testBigRandom ( boolean oldBfHashOrder ) { int size = <int> * <int> * <int> ; IFilter bf = getFilter ( size , FilterTestHelper . spec . bucketsPerElement , false , oldBfHashOrder ) ; double fp = testFalsePositives ( bf , new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; logger . info ( <str> , oldBfHashOrder , fp ) ; } @Test public void testConstrained ( ) { testConstrained ( false ) ; testConstrained ( true ) ; } private static void testConstrained ( boolean oldBfHashOrder ) { int size = <int> * <int> * <int> ; try ( IFilter bf = getFilter ( size , <float> , false , oldBfHashOrder ) ) { double fp = testFalsePositives ( bf , new KeyGenerator . IntGenerator ( size ) , new KeyGenerator . IntGenerator ( size , size * <int> ) ) ; logger . info ( <str> , oldBfHashOrder , fp ) ; } } private static void testConstrained ( double targetFp , int elements , boolean oldBfHashOrder , int staticBitCount , long . . . staticBits ) { for ( long bits : staticBits ) { try ( IFilter bf = getFilter ( elements , targetFp , false , oldBfHashOrder ) ; ) { SequentialHashGenerator gen = new SequentialHashGenerator ( staticBitCount , bits ) ; long [ ] hash = new long [ <int> ] ; for ( int i = <int> ; i < elements ; i + + ) { gen . nextHash ( hash ) ; bf . add ( filterKey ( hash [ <int> ] , hash [ <int> ] ) ) ; } int falsePositiveCount = <int> ; for ( int i = <int> ; i < elements ; i + + ) { gen . nextHash ( hash ) ; if ( bf . isPresent ( filterKey ( hash [ <int> ] , hash [ <int> ] ) ) ) falsePositiveCount + + ; } double fp = falsePositiveCount / ( double ) elements ; double ratio = fp / targetFp ; System . out . printf ( <str> , ratio ) ; } } System . out . printf ( <str> , elements , staticBitCount , targetFp ) ; } private static IFilter . FilterKey filterKey ( final long hash1 , final long hash2 ) { return new IFilter . FilterKey ( ) { public void filterHash ( long [ ] dest ) { dest [ <int> ] = hash1 ; dest [ <int> ] = hash2 ; } } ; } @Test public void testBffp ( ) { bffp ( false ) ; bffp ( true ) ; } private static void bffp ( boolean flipInputs ) { System . out . println ( <str> + flipInputs ) ; long [ ] staticBits = staticBits ( <int> , <int> ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; testConstrained ( <float> , <int> < < <int> , flipInputs , <int> , staticBits ) ; } static long [ ] staticBits ( int random , long . . . fixed ) { long [ ] result = new long [ random + fixed . length ] ; System . arraycopy ( fixed , <int> , result , <int> , fixed . length ) ; for ( int i = <int> ; i < random ; i + + ) result [ fixed . length + i ] = ThreadLocalRandom . current ( ) . nextLong ( ) ; return result ; } private static class SequentialHashGenerator { final long mask ; final long staticBits ; int next ; private SequentialHashGenerator ( int staticBitCount , long staticBits ) { this . mask = - <int> > > > staticBitCount ; this . staticBits = staticBits & ~ mask ; } void nextHash ( long [ ] fill ) { MurmurHash . hash3_x64_128 ( ByteBufferUtil . bytes ( next ) , <int> , <int> , <int> , fill ) ; fill [ <int> ] & = mask ; fill [ <int> ] | = staticBits ; next + + ; } } @Test public void timeit ( ) { timeit ( false ) ; timeit ( true ) ; } private static void timeit ( boolean oldBfHashOrder ) { int size = <int> * FilterTestHelper . ELEMENTS ; IFilter bf = getFilter ( size , FilterTestHelper . spec . bucketsPerElement , false , oldBfHashOrder ) ; double sumfp = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { testFalsePositives ( bf , new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) , new KeyGenerator . RandomStringGenerator ( new Random ( ) . nextInt ( ) , size ) ) ; bf . clear ( ) ; } logger . info ( <str> , oldBfHashOrder , sumfp / <int> ) ; } } 
