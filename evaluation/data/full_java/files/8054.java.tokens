package org . elasticsearch . gateway ; import org . elasticsearch . action . admin . indices . recovery . RecoveryResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . test . ESBackcompatTestCase ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashMap ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; @ESIntegTestCase.ClusterScope ( numDataNodes = <int> , scope = ESIntegTestCase . Scope . TEST , numClientNodes = <int> , transportClientRatio = <float> ) public class RecoveryBackwardsCompatibilityIT extends ESBackcompatTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , <str> ) . put ( <str> , <int> ) . build ( ) ; } @Override protected int minExternalNodes ( ) { return <int> ; } @Override protected int maxExternalNodes ( ) { return <int> ; } public void testReusePeerRecovery ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( EnableAllocationDecider . INDEX_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) ) ) ; logger . info ( <str> ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , <str> ) ; } indexRandom ( true , builders ) ; ensureGreen ( ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <str> ) . build ( ) ) . get ( ) ; ensureGreen ( ) ; assertAllShardsOnNodes ( <str> , backwardsCluster ( ) . backwardsNodePattern ( ) ) ; logger . info ( <str> ) ; logClusterState ( ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) . execute ( ) . actionGet ( ) ; backwardsCluster ( ) . upgradeAllNodes ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; RecoveryResponse recoveryResponse = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . setDetailed ( true ) . get ( ) ; HashMap < String , String > map = new HashMap < > ( ) ; map . put ( <str> , <str> ) ; final ToXContent . Params params = new ToXContent . MapParams ( map ) ; for ( RecoveryState recoveryState : recoveryResponse . shardRecoveryStates ( ) . get ( <str> ) ) { final String recoverStateAsJSON = XContentHelper . toString ( recoveryState , params ) ; if ( ! recoveryState . getPrimary ( ) ) { RecoveryState . Index index = recoveryState . getIndex ( ) ; assertThat ( recoverStateAsJSON , index . recoveredBytes ( ) , equalTo ( <int> l ) ) ; assertThat ( recoverStateAsJSON , index . reusedBytes ( ) , greaterThan ( <int> l ) ) ; assertThat ( recoverStateAsJSON , index . reusedBytes ( ) , equalTo ( index . totalBytes ( ) ) ) ; assertThat ( recoverStateAsJSON , index . recoveredFileCount ( ) , equalTo ( <int> ) ) ; assertThat ( recoverStateAsJSON , index . reusedFileCount ( ) , equalTo ( index . totalFileCount ( ) ) ) ; assertThat ( recoverStateAsJSON , index . reusedFileCount ( ) , greaterThan ( <int> ) ) ; assertThat ( recoverStateAsJSON , index . recoveredBytesPercent ( ) , equalTo ( <float> ) ) ; assertThat ( recoverStateAsJSON , index . recoveredFilesPercent ( ) , equalTo ( <float> ) ) ; assertThat ( recoverStateAsJSON , index . reusedBytes ( ) , greaterThan ( index . recoveredBytes ( ) ) ) ; } } } } 
