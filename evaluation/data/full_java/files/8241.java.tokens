package org . elasticsearch . index . query ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import com . fasterxml . jackson . core . JsonParseException ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . * ; import org . apache . lucene . search . join . ScoreMode ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingRequest ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . query . support . QueryInnerHits ; import org . elasticsearch . script . Script . ScriptParseException ; import org . elasticsearch . search . fetch . innerhits . InnerHitsBuilder ; import org . elasticsearch . search . fetch . innerhits . InnerHitsContext ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . TestSearchContext ; import java . io . IOException ; import java . util . Collections ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; public class HasChildQueryBuilderTests extends AbstractQueryTestCase < HasChildQueryBuilder > { protected static final String PARENT_TYPE = <str> ; protected static final String CHILD_TYPE = <str> ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; MapperService mapperService = queryShardContext ( ) . getMapperService ( ) ; mapperService . merge ( PARENT_TYPE , new CompressedXContent ( PutMappingRequest . buildFromSimplifiedDef ( PARENT_TYPE , STRING_FIELD_NAME , <str> , INT_FIELD_NAME , <str> , DOUBLE_FIELD_NAME , <str> , BOOLEAN_FIELD_NAME , <str> , DATE_FIELD_NAME , <str> , OBJECT_FIELD_NAME , <str> ) . string ( ) ) , false , false ) ; mapperService . merge ( CHILD_TYPE , new CompressedXContent ( PutMappingRequest . buildFromSimplifiedDef ( CHILD_TYPE , <str> , <str> + PARENT_TYPE , STRING_FIELD_NAME , <str> , INT_FIELD_NAME , <str> , DOUBLE_FIELD_NAME , <str> , BOOLEAN_FIELD_NAME , <str> , DATE_FIELD_NAME , <str> , OBJECT_FIELD_NAME , <str> ) . string ( ) ) , false , false ) ; } @Override protected void setSearchContext ( String [ ] types ) { final MapperService mapperService = queryShardContext ( ) . getMapperService ( ) ; final IndexFieldDataService fieldData = indexFieldDataService ( ) ; TestSearchContext testSearchContext = new TestSearchContext ( ) { private InnerHitsContext context ; @Override public void innerHits ( InnerHitsContext innerHitsContext ) { context = innerHitsContext ; } @Override public InnerHitsContext innerHits ( ) { return context ; } @Override public MapperService mapperService ( ) { return mapperService ; } @Override public IndexFieldDataService fieldData ( ) { return fieldData ; } } ; testSearchContext . setTypes ( types ) ; SearchContext . setCurrent ( testSearchContext ) ; } @Override protected HasChildQueryBuilder doCreateTestQueryBuilder ( ) { int min = randomIntBetween ( <int> , Integer . MAX_VALUE / <int> ) ; int max = randomIntBetween ( min , Integer . MAX_VALUE ) ; InnerHitsBuilder . InnerHit innerHit = new InnerHitsBuilder . InnerHit ( ) . setSize ( <int> ) . addSort ( STRING_FIELD_NAME , SortOrder . ASC ) ; return new HasChildQueryBuilder ( CHILD_TYPE , RandomQueryBuilder . createQuery ( random ( ) ) , max , min , RandomPicks . randomFrom ( random ( ) , ScoreMode . values ( ) ) , randomBoolean ( ) ? null : new QueryInnerHits ( <str> , innerHit ) ) ; } @Override protected void doAssertLuceneQuery ( HasChildQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { QueryBuilder innerQueryBuilder = queryBuilder . query ( ) ; if ( innerQueryBuilder instanceof EmptyQueryBuilder ) { assertNull ( query ) ; } else { assertThat ( query , instanceOf ( HasChildQueryBuilder . LateParsingQuery . class ) ) ; HasChildQueryBuilder . LateParsingQuery lpq = ( HasChildQueryBuilder . LateParsingQuery ) query ; assertEquals ( queryBuilder . minChildren ( ) , lpq . getMinChildren ( ) ) ; assertEquals ( queryBuilder . maxChildren ( ) , lpq . getMaxChildren ( ) ) ; assertEquals ( queryBuilder . scoreMode ( ) , lpq . getScoreMode ( ) ) ; } if ( queryBuilder . innerHit ( ) ! = null ) { assertNotNull ( SearchContext . current ( ) ) ; if ( query ! = null ) { assertNotNull ( SearchContext . current ( ) . innerHits ( ) ) ; assertEquals ( <int> , SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . size ( ) ) ; assertTrue ( SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . containsKey ( <str> ) ) ; InnerHitsContext . BaseInnerHits innerHits = SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . get ( <str> ) ; assertEquals ( innerHits . size ( ) , <int> ) ; assertEquals ( innerHits . sort ( ) . getSort ( ) . length , <int> ) ; assertEquals ( innerHits . sort ( ) . getSort ( ) [ <int> ] . getField ( ) , STRING_FIELD_NAME ) ; } else { assertNull ( SearchContext . current ( ) . innerHits ( ) ) ; } } } public void testIllegalValues ( ) { QueryBuilder query = RandomQueryBuilder . createQuery ( random ( ) ) ; try { new HasChildQueryBuilder ( null , query ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { new HasChildQueryBuilder ( <str> , null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } HasChildQueryBuilder foo = new HasChildQueryBuilder ( <str> , query ) ; try { foo . scoreMode ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } final int positiveValue = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; try { foo . minChildren ( randomIntBetween ( Integer . MIN_VALUE , - <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } foo . minChildren ( positiveValue ) ; assertEquals ( positiveValue , foo . minChildren ( ) ) ; try { foo . maxChildren ( randomIntBetween ( Integer . MIN_VALUE , - <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } foo . maxChildren ( positiveValue ) ; assertEquals ( positiveValue , foo . maxChildren ( ) ) ; } public void testFromJson ( ) throws IOException { String query = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; HasChildQueryBuilder queryBuilder = ( HasChildQueryBuilder ) parseQuery ( query ) ; checkGeneratedJson ( query , queryBuilder ) ; assertEquals ( query , queryBuilder . maxChildren ( ) , <int> ) ; assertEquals ( query , queryBuilder . minChildren ( ) , <int> ) ; assertEquals ( query , queryBuilder . boost ( ) , <float> , <float> ) ; assertEquals ( query , queryBuilder . queryName ( ) , <str> ) ; assertEquals ( query , queryBuilder . childType ( ) , <str> ) ; assertEquals ( query , queryBuilder . scoreMode ( ) , ScoreMode . Avg ) ; assertNotNull ( query , queryBuilder . innerHit ( ) ) ; assertEquals ( query , queryBuilder . innerHit ( ) , new QueryInnerHits ( <str> , new InnerHitsBuilder . InnerHit ( ) . setSize ( <int> ) . addSort ( <str> , SortOrder . ASC ) ) ) ; } public void testToQueryInnerQueryType ( ) throws IOException { String [ ] searchTypes = new String [ ] { PARENT_TYPE } ; QueryShardContext . setTypes ( searchTypes ) ; HasChildQueryBuilder hasChildQueryBuilder = new HasChildQueryBuilder ( CHILD_TYPE , new IdsQueryBuilder ( ) . addIds ( <str> ) ) ; Query query = hasChildQueryBuilder . toQuery ( createShardContext ( ) ) ; assertThat ( QueryShardContext . getTypes ( ) , equalTo ( searchTypes ) ) ; assertLateParsingQuery ( query , CHILD_TYPE , <str> ) ; } static void assertLateParsingQuery ( Query query , String type , String id ) throws IOException { assertThat ( query , instanceOf ( HasChildQueryBuilder . LateParsingQuery . class ) ) ; HasChildQueryBuilder . LateParsingQuery lateParsingQuery = ( HasChildQueryBuilder . LateParsingQuery ) query ; assertThat ( lateParsingQuery . getInnerQuery ( ) , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) lateParsingQuery . getInnerQuery ( ) ; assertThat ( booleanQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getOccur ( ) , equalTo ( BooleanClause . Occur . MUST ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) , instanceOf ( TermsQuery . class ) ) ; TermsQuery termsQuery = ( TermsQuery ) booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) ; Query rewrittenTermsQuery = termsQuery . rewrite ( null ) ; assertThat ( rewrittenTermsQuery , instanceOf ( ConstantScoreQuery . class ) ) ; ConstantScoreQuery constantScoreQuery = ( ConstantScoreQuery ) rewrittenTermsQuery ; assertThat ( constantScoreQuery . getQuery ( ) , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanTermsQuery = ( BooleanQuery ) constantScoreQuery . getQuery ( ) ; assertThat ( booleanTermsQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( booleanTermsQuery . clauses ( ) . get ( <int> ) . getOccur ( ) , equalTo ( BooleanClause . Occur . SHOULD ) ) ; assertThat ( booleanTermsQuery . clauses ( ) . get ( <int> ) . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) booleanTermsQuery . clauses ( ) . get ( <int> ) . getQuery ( ) ; assertThat ( termQuery . getTerm ( ) . field ( ) , equalTo ( UidFieldMapper . NAME ) ) ; BytesRef [ ] ids = Uid . createUidsForTypesAndIds ( Collections . singletonList ( type ) , Collections . singletonList ( id ) ) ; assertThat ( termQuery . getTerm ( ) . bytes ( ) , equalTo ( ids [ <int> ] ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getOccur ( ) , equalTo ( BooleanClause . Occur . FILTER ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) , instanceOf ( ConstantScoreQuery . class ) ) ; ConstantScoreQuery typeConstantScoreQuery = ( ConstantScoreQuery ) booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) ; assertThat ( typeConstantScoreQuery . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; TermQuery typeTermQuery = ( TermQuery ) typeConstantScoreQuery . getQuery ( ) ; assertThat ( typeTermQuery . getTerm ( ) . field ( ) , equalTo ( TypeFieldMapper . NAME ) ) ; assertThat ( typeTermQuery . getTerm ( ) . text ( ) , equalTo ( type ) ) ; } @Override public void testUnknownObjectException ( ) throws IOException { String validQuery = createTestQueryBuilder ( ) . toString ( ) ; assertThat ( validQuery , containsString ( <str> ) ) ; int endPosition = validQuery . indexOf ( <str> ) ; if ( endPosition = = - <int> ) { endPosition = validQuery . length ( ) - <int> ; } for ( int insertionPosition = <int> ; insertionPosition < endPosition ; insertionPosition + + ) { if ( validQuery . charAt ( insertionPosition ) = = <str> ) { String testQuery = validQuery . substring ( <int> , insertionPosition ) + <str> + validQuery . substring ( insertionPosition ) + <str> ; try { parseQuery ( testQuery ) ; fail ( <str> + testQuery ) ; } catch ( ParsingException | ScriptParseException | ElasticsearchParseException e ) { } catch ( JsonParseException e ) { } } } } } 
