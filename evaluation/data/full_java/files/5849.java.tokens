package org . elasticsearch . common . inject . internal ; import org . elasticsearch . common . util . CollectionUtils ; import java . io . IOException ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . Objects ; public final class Join { private Join ( ) { } public static String join ( String delimiter , Iterable < ? > tokens ) { return join ( delimiter , tokens . iterator ( ) ) ; } public static String join ( String delimiter , Object [ ] tokens ) { return join ( delimiter , Arrays . asList ( tokens ) ) ; } public static String join ( String delimiter , @Nullable Object firstToken , Object . . . otherTokens ) { Objects . requireNonNull ( otherTokens ) ; return join ( delimiter , CollectionUtils . asArrayList ( firstToken , otherTokens ) ) ; } public static String join ( String delimiter , Iterator < ? > tokens ) { StringBuilder sb = new StringBuilder ( ) ; join ( sb , delimiter , tokens ) ; return sb . toString ( ) ; } public static String join ( String keyValueSeparator , String entryDelimiter , Map < ? , ? > map ) { return join ( new StringBuilder ( ) , keyValueSeparator , entryDelimiter , map ) . toString ( ) ; } public static < T extends Appendable > T join ( T appendable , String delimiter , Iterable < ? > tokens ) { return join ( appendable , delimiter , tokens . iterator ( ) ) ; } public static < T extends Appendable > T join ( T appendable , String delimiter , Object [ ] tokens ) { return join ( appendable , delimiter , Arrays . asList ( tokens ) ) ; } public static < T extends Appendable > T join ( T appendable , String delimiter , @Nullable Object firstToken , Object . . . otherTokens ) { Objects . requireNonNull ( otherTokens ) ; return join ( appendable , delimiter , CollectionUtils . asArrayList ( firstToken , otherTokens ) ) ; } public static < T extends Appendable > T join ( T appendable , String delimiter , Iterator < ? > tokens ) { Objects . requireNonNull ( appendable ) ; Objects . requireNonNull ( delimiter ) ; if ( tokens . hasNext ( ) ) { try { appendOneToken ( appendable , tokens . next ( ) ) ; while ( tokens . hasNext ( ) ) { appendable . append ( delimiter ) ; appendOneToken ( appendable , tokens . next ( ) ) ; } } catch ( IOException e ) { throw new JoinException ( e ) ; } } return appendable ; } public static < T extends Appendable > T join ( T appendable , String keyValueSeparator , String entryDelimiter , Map < ? , ? > map ) { Objects . requireNonNull ( appendable ) ; Objects . requireNonNull ( keyValueSeparator ) ; Objects . requireNonNull ( entryDelimiter ) ; Iterator < ? extends Map . Entry < ? , ? > > entries = map . entrySet ( ) . iterator ( ) ; if ( entries . hasNext ( ) ) { try { appendOneEntry ( appendable , keyValueSeparator , entries . next ( ) ) ; while ( entries . hasNext ( ) ) { appendable . append ( entryDelimiter ) ; appendOneEntry ( appendable , keyValueSeparator , entries . next ( ) ) ; } } catch ( IOException e ) { throw new JoinException ( e ) ; } } return appendable ; } private static void appendOneEntry ( Appendable appendable , String keyValueSeparator , Map . Entry < ? , ? > entry ) throws IOException { appendOneToken ( appendable , entry . getKey ( ) ) ; appendable . append ( keyValueSeparator ) ; appendOneToken ( appendable , entry . getValue ( ) ) ; } private static void appendOneToken ( Appendable appendable , Object token ) throws IOException { appendable . append ( toCharSequence ( token ) ) ; } private static CharSequence toCharSequence ( Object token ) { return ( token instanceof CharSequence ) ? ( CharSequence ) token : String . valueOf ( token ) ; } public static class JoinException extends RuntimeException { private JoinException ( IOException cause ) { super ( cause ) ; } private static final long serialVersionUID = <int> ; } } 
