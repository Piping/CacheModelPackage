package org . elasticsearch . discovery . zen ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . NotMasterException ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . service . InternalClusterService ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . membership . MembershipAction ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; public class NodeJoinController extends AbstractComponent { final ClusterService clusterService ; final RoutingService routingService ; final DiscoverySettings discoverySettings ; final AtomicBoolean accumulateJoins = new AtomicBoolean ( false ) ; final AtomicReference < ElectionContext > electionContext = new AtomicReference < > ( ) ; protected final Map < DiscoveryNode , List < MembershipAction . JoinCallback > > pendingJoinRequests = new HashMap < > ( ) ; public NodeJoinController ( ClusterService clusterService , RoutingService routingService , DiscoverySettings discoverySettings , Settings settings ) { super ( settings ) ; this . clusterService = clusterService ; this . routingService = routingService ; this . discoverySettings = discoverySettings ; } public void waitToBeElectedAsMaster ( int requiredMasterJoins , TimeValue timeValue , final ElectionCallback callback ) { assert accumulateJoins . get ( ) : <str> ; final CountDownLatch done = new CountDownLatch ( <int> ) ; final ElectionContext newContext = new ElectionContext ( callback , requiredMasterJoins , clusterService ) { @Override void onClose ( ) { if ( electionContext . compareAndSet ( this , null ) ) { stopAccumulatingJoins ( <str> ) ; } else { assert false : <str> ; } done . countDown ( ) ; } } ; if ( electionContext . compareAndSet ( null , newContext ) = = false ) { failContext ( newContext , new IllegalStateException ( <str> ) ) ; return ; } try { checkPendingJoinsAndElectIfNeeded ( ) ; try { if ( done . await ( timeValue . millis ( ) , TimeUnit . MILLISECONDS ) ) { return ; } } catch ( InterruptedException e ) { } if ( logger . isTraceEnabled ( ) ) { final int pendingNodes ; synchronized ( pendingJoinRequests ) { pendingNodes = pendingJoinRequests . size ( ) ; } logger . trace ( <str> , timeValue , pendingNodes ) ; } failContext ( newContext , new ElasticsearchTimeoutException ( <str> ) ) ; } catch ( Throwable t ) { logger . error ( <str> , t ) ; failContext ( newContext , <str> , t ) ; } } private void failContext ( final ElectionContext context , final Throwable throwable ) { failContext ( context , throwable . getMessage ( ) , throwable ) ; } private void failContext ( final ElectionContext context , final String reason , final Throwable throwable ) { clusterService . submitStateUpdateTask ( <str> + reason + <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { context . onFailure ( throwable ) ; return currentState ; } @Override public void onFailure ( String source , Throwable updateFailure ) { logger . warn ( <str> , updateFailure , reason , throwable ) ; context . onFailure ( updateFailure ) ; } } ) ; } public void startAccumulatingJoins ( ) { logger . trace ( <str> ) ; boolean b = accumulateJoins . getAndSet ( true ) ; assert b = = false : <str> ; assert electionContext . get ( ) = = null : <str> ; } public void stopAccumulatingJoins ( String reason ) { logger . trace ( <str> , reason ) ; assert electionContext . get ( ) = = null : <str> ; boolean b = accumulateJoins . getAndSet ( false ) ; assert b : <str> ; synchronized ( pendingJoinRequests ) { if ( pendingJoinRequests . size ( ) > <int> ) { processJoins ( <str> + reason + <str> ) ; } } } public void handleJoinRequest ( final DiscoveryNode node , final MembershipAction . JoinCallback callback ) { synchronized ( pendingJoinRequests ) { List < MembershipAction . JoinCallback > nodeCallbacks = pendingJoinRequests . get ( node ) ; if ( nodeCallbacks = = null ) { nodeCallbacks = new ArrayList < > ( ) ; pendingJoinRequests . put ( node , nodeCallbacks ) ; } nodeCallbacks . add ( callback ) ; } if ( accumulateJoins . get ( ) = = false ) { processJoins ( <str> + node + <str> ) ; } else { checkPendingJoinsAndElectIfNeeded ( ) ; } } private void checkPendingJoinsAndElectIfNeeded ( ) { assert accumulateJoins . get ( ) : <str> ; final ElectionContext context = electionContext . get ( ) ; if ( context = = null ) { return ; } int pendingMasterJoins = <int> ; synchronized ( pendingJoinRequests ) { for ( DiscoveryNode node : pendingJoinRequests . keySet ( ) ) { if ( node . isMasterNode ( ) ) { pendingMasterJoins + + ; } } } if ( pendingMasterJoins < context . requiredMasterJoins ) { if ( context . pendingSetAsMasterTask . get ( ) = = false ) { logger . trace ( <str> , pendingMasterJoins , context . requiredMasterJoins ) ; } return ; } if ( context . pendingSetAsMasterTask . getAndSet ( true ) ) { logger . trace ( <str> ) ; return ; } final String source = <str> + pendingMasterJoins + <str> ; clusterService . submitStateUpdateTask ( source , new ProcessJoinsTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) { if ( currentState . nodes ( ) . masterNode ( ) ! = null ) { logger . trace ( <str> , currentState . nodes ( ) . masterNode ( ) ) ; throw new NotMasterException ( <str> + clusterService . localNode ( ) + <str> ) ; } DiscoveryNodes . Builder builder = new DiscoveryNodes . Builder ( currentState . nodes ( ) ) . masterNodeId ( currentState . nodes ( ) . localNode ( ) . id ( ) ) ; ClusterBlocks clusterBlocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) . removeGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) . build ( ) ; currentState = ClusterState . builder ( currentState ) . nodes ( builder ) . blocks ( clusterBlocks ) . build ( ) ; RoutingAllocation . Result result = routingService . getAllocationService ( ) . reroute ( currentState , <str> ) ; if ( result . changed ( ) ) { currentState = ClusterState . builder ( currentState ) . routingResult ( result ) . build ( ) ; } return super . execute ( currentState ) ; } @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public void onFailure ( String source , Throwable t ) { super . onFailure ( source , t ) ; context . onFailure ( t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { super . clusterStateProcessed ( source , oldState , newState ) ; context . onElectedAsMaster ( newState ) ; } } ) ; } private void processJoins ( String reason ) { clusterService . submitStateUpdateTask ( <str> + reason + <str> , new ProcessJoinsTask ( Priority . URGENT ) ) ; } public interface ElectionCallback { void onElectedAsMaster ( ClusterState state ) ; void onFailure ( Throwable t ) ; } static abstract class ElectionContext implements ElectionCallback { private final ElectionCallback callback ; private final int requiredMasterJoins ; private final ClusterService clusterService ; final AtomicBoolean pendingSetAsMasterTask = new AtomicBoolean ( ) ; final AtomicBoolean closed = new AtomicBoolean ( ) ; ElectionContext ( ElectionCallback callback , int requiredMasterJoins , ClusterService clusterService ) { this . callback = callback ; this . requiredMasterJoins = requiredMasterJoins ; this . clusterService = clusterService ; } abstract void onClose ( ) ; @Override public void onElectedAsMaster ( ClusterState state ) { assert pendingSetAsMasterTask . get ( ) : <str> ; assertClusterStateThread ( ) ; assert state . nodes ( ) . localNodeMaster ( ) : <str> ; if ( closed . compareAndSet ( false , true ) ) { try { onClose ( ) ; } finally { callback . onElectedAsMaster ( state ) ; } } } @Override public void onFailure ( Throwable t ) { assertClusterStateThread ( ) ; if ( closed . compareAndSet ( false , true ) ) { try { onClose ( ) ; } finally { callback . onFailure ( t ) ; } } } private void assertClusterStateThread ( ) { assert clusterService instanceof InternalClusterService = = false | | ( ( InternalClusterService ) clusterService ) . assertClusterStateThread ( ) ; } } class ProcessJoinsTask extends ClusterStateUpdateTask { private final List < MembershipAction . JoinCallback > joinCallbacksToRespondTo = new ArrayList < > ( ) ; private boolean nodeAdded = false ; public ProcessJoinsTask ( Priority priority ) { super ( priority ) ; } @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes . Builder nodesBuilder ; synchronized ( pendingJoinRequests ) { if ( pendingJoinRequests . isEmpty ( ) ) { return currentState ; } nodesBuilder = DiscoveryNodes . builder ( currentState . nodes ( ) ) ; Iterator < Map . Entry < DiscoveryNode , List < MembershipAction . JoinCallback > > > iterator = pendingJoinRequests . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < DiscoveryNode , List < MembershipAction . JoinCallback > > entry = iterator . next ( ) ; final DiscoveryNode node = entry . getKey ( ) ; joinCallbacksToRespondTo . addAll ( entry . getValue ( ) ) ; iterator . remove ( ) ; if ( currentState . nodes ( ) . nodeExists ( node . id ( ) ) ) { logger . debug ( <str> , node ) ; } else { nodeAdded = true ; nodesBuilder . put ( node ) ; for ( DiscoveryNode existingNode : currentState . nodes ( ) ) { if ( node . address ( ) . equals ( existingNode . address ( ) ) ) { nodesBuilder . remove ( existingNode . id ( ) ) ; logger . warn ( <str> , node , existingNode ) ; } } } } } final ClusterState . Builder newState = ClusterState . builder ( currentState ) ; if ( nodeAdded ) { newState . nodes ( nodesBuilder ) ; } return newState . build ( ) ; } @Override public void onNoLongerMaster ( String source ) { synchronized ( pendingJoinRequests ) { Iterator < Map . Entry < DiscoveryNode , List < MembershipAction . JoinCallback > > > iterator = pendingJoinRequests . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < DiscoveryNode , List < MembershipAction . JoinCallback > > entry = iterator . next ( ) ; joinCallbacksToRespondTo . addAll ( entry . getValue ( ) ) ; iterator . remove ( ) ; } } Exception e = new NotMasterException ( <str> + clusterService . localNode ( ) + <str> ) ; innerOnFailure ( e ) ; } void innerOnFailure ( Throwable t ) { for ( MembershipAction . JoinCallback callback : joinCallbacksToRespondTo ) { try { callback . onFailure ( t ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; } } } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; innerOnFailure ( t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { if ( nodeAdded ) { routingService . reroute ( <str> ) ; } for ( MembershipAction . JoinCallback callback : joinCallbacksToRespondTo ) { try { callback . onSuccess ( ) ; } catch ( Exception e ) { logger . error ( <str> , e , source ) ; } } } } } 
