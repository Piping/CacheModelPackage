package org . elasticsearch . bwcompat ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . client . transport . TransportClient ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESBackcompatTestCase ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_METADATA ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_READ ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_WRITE ; import static org . hamcrest . Matchers . equalTo ; public class ClusterStateBackwardsCompatIT extends ESBackcompatTestCase { public void testClusterState ( ) throws Exception { createIndex ( <str> ) ; for ( NodeInfo n : clusterNodes ( ) ) { try ( TransportClient tc = newTransportClient ( ) ) { tc . addTransportAddress ( n . getNode ( ) . address ( ) ) ; ClusterStateResponse response = tc . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) ; assertThat ( response . getState ( ) . status ( ) , equalTo ( ClusterState . ClusterStateStatus . UNKNOWN ) ) ; assertNotNull ( response . getClusterName ( ) ) ; assertTrue ( response . getState ( ) . getMetaData ( ) . hasIndex ( <str> ) ) ; } } } public void testClusterStateWithBlocks ( ) { createIndex ( <str> ) ; Map < String , ClusterBlock > blocks = new HashMap < > ( ) ; blocks . put ( SETTING_BLOCKS_READ , IndexMetaData . INDEX_READ_BLOCK ) ; blocks . put ( SETTING_BLOCKS_WRITE , IndexMetaData . INDEX_WRITE_BLOCK ) ; blocks . put ( SETTING_BLOCKS_METADATA , IndexMetaData . INDEX_METADATA_BLOCK ) ; for ( Map . Entry < String , ClusterBlock > block : blocks . entrySet ( ) ) { try { enableIndexBlock ( <str> , block . getKey ( ) ) ; for ( NodeInfo n : clusterNodes ( ) ) { try ( TransportClient tc = newTransportClient ( ) ) { tc . addTransportAddress ( n . getNode ( ) . address ( ) ) ; ClusterStateResponse response = tc . admin ( ) . cluster ( ) . prepareState ( ) . setIndices ( <str> ) . setBlocks ( true ) . setNodes ( false ) . execute ( ) . actionGet ( ) ; ClusterBlocks clusterBlocks = response . getState ( ) . blocks ( ) ; assertNotNull ( clusterBlocks ) ; assertTrue ( clusterBlocks . hasIndexBlock ( <str> , block . getValue ( ) ) ) ; for ( ClusterBlockLevel level : block . getValue ( ) . levels ( ) ) { assertTrue ( clusterBlocks . indexBlocked ( level , <str> ) ) ; } IndexMetaData indexMetaData = response . getState ( ) . getMetaData ( ) . getIndices ( ) . get ( <str> ) ; assertNotNull ( indexMetaData ) ; assertTrue ( indexMetaData . getSettings ( ) . getAsBoolean ( block . getKey ( ) , null ) ) ; } } } finally { disableIndexBlock ( <str> , block . getKey ( ) ) ; } } } private NodesInfoResponse clusterNodes ( ) { return client ( ) . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . execute ( ) . actionGet ( ) ; } private TransportClient newTransportClient ( ) { Settings settings = Settings . settingsBuilder ( ) . put ( <str> , true ) . put ( <str> , <str> + getTestName ( ) ) . build ( ) ; return TransportClient . builder ( ) . settings ( settings ) . build ( ) ; } } 
