package org . eclipse . debug . internal . ui . viewers ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . debug . internal . ui . commands . actions . AbstractRequestMonitor ; import org . eclipse . ui . progress . WorkbenchJob ; public abstract class AsynchronousRequestMonitor extends AbstractRequestMonitor { private ModelNode fNode ; private AsynchronousModel fModel ; private boolean fDone = false ; protected WorkbenchJob fViewerUpdateJob = new WorkbenchJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { getModel ( ) . viewerUpdateScheduled ( AsynchronousRequestMonitor . this ) ; if ( fDone ) { getModel ( ) . requestComplete ( AsynchronousRequestMonitor . this ) ; } if ( ! isCanceled ( ) & & ! getNode ( ) . isDisposed ( ) ) { IStatus status = getStatus ( ) ; if ( status ! = null & & ! status . isOK ( ) ) { getModel ( ) . getViewer ( ) . handlePresentationFailure ( AsynchronousRequestMonitor . this , status ) ; } else { performUpdate ( ) ; } } getModel ( ) . viewerUpdateComplete ( AsynchronousRequestMonitor . this ) ; return Status . OK_STATUS ; } } ; public AsynchronousRequestMonitor ( ModelNode node , AsynchronousModel model ) { fNode = node ; fModel = model ; fViewerUpdateJob . setRule ( getUpdateSchedulingRule ( ) ) ; fViewerUpdateJob . setSystem ( true ) ; } protected ISchedulingRule getUpdateSchedulingRule ( ) { return AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( getModel ( ) . getViewer ( ) ) ; } protected AsynchronousModel getModel ( ) { return fModel ; } protected ModelNode getNode ( ) { return fNode ; } protected boolean contains ( ModelNode node ) { if ( node = = getNode ( ) ) { return true ; } ModelNode parentNode = getNode ( ) . getParentNode ( ) ; while ( parentNode ! = null ) { if ( parentNode . equals ( getNode ( ) ) ) { return true ; } parentNode = parentNode . getParentNode ( ) ; } return false ; } @Override public void setCanceled ( boolean value ) { super . setCanceled ( value ) ; if ( value ) { getModel ( ) . requestCanceled ( this ) ; } } @Override public final void done ( ) { synchronized ( this ) { fDone = true ; } scheduleViewerUpdate ( <int> L ) ; } protected synchronized boolean isDone ( ) { return fDone ; } protected void scheduleViewerUpdate ( long ms ) { if ( ! isCanceled ( ) ) fViewerUpdateJob . schedule ( ms ) ; } protected abstract void performUpdate ( ) ; protected abstract boolean contains ( AsynchronousRequestMonitor update ) ; } 
