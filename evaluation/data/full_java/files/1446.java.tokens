package org . apache . cassandra . db ; import java . io . IOException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . Arrays ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . EncodingStats ; import org . apache . cassandra . db . rows . UnfilteredRowIterators ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static junit . framework . Assert . assertTrue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; public class PartitionTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private static final String CF_TENCOL = <str> ; private static final String CF_COUNTER1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_TENCOL , <int> , AsciiType . instance ) , SchemaLoader . denseCFMD ( KEYSPACE1 , CF_COUNTER1 , BytesType . instance ) ) ; } @Test public void testSingleColumn ( ) throws IOException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; PartitionUpdate update = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . buildUpdate ( ) ; CachedBTreePartition partition = CachedBTreePartition . create ( update . unfilteredIterator ( ) , FBUtilities . nowInSeconds ( ) ) ; DataOutputBuffer bufOut = new DataOutputBuffer ( ) ; CachedPartition . cacheSerializer . serialize ( partition , bufOut ) ; CachedPartition deserialized = CachedPartition . cacheSerializer . deserialize ( new DataInputBuffer ( bufOut . getData ( ) ) ) ; assert deserialized ! = null ; assert deserialized . metadata ( ) . cfName . equals ( CF_STANDARD1 ) ; assert deserialized . partitionKey ( ) . equals ( partition . partitionKey ( ) ) ; } @Test public void testManyColumns ( ) throws IOException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_TENCOL ) ; RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . add ( <str> + i , <str> + i ) ; PartitionUpdate update = builder . buildUpdate ( ) ; CachedBTreePartition partition = CachedBTreePartition . create ( update . unfilteredIterator ( ) , FBUtilities . nowInSeconds ( ) ) ; DataOutputBuffer bufOut = new DataOutputBuffer ( ) ; CachedPartition . cacheSerializer . serialize ( partition , bufOut ) ; CachedPartition deserialized = CachedPartition . cacheSerializer . deserialize ( new DataInputBuffer ( bufOut . getData ( ) ) ) ; assertEquals ( partition . columns ( ) . regulars . size ( ) , deserialized . columns ( ) . regulars . size ( ) ) ; assertTrue ( deserialized . columns ( ) . regulars . getSimple ( <int> ) . equals ( partition . columns ( ) . regulars . getSimple ( <int> ) ) ) ; assertTrue ( deserialized . columns ( ) . regulars . getSimple ( <int> ) . equals ( partition . columns ( ) . regulars . getSimple ( <int> ) ) ) ; ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; assertTrue ( partition . lastRow ( ) . getCell ( cDef ) . value ( ) . equals ( deserialized . lastRow ( ) . getCell ( cDef ) . value ( ) ) ) ; assert deserialized . partitionKey ( ) . equals ( partition . partitionKey ( ) ) ; } @Test public void testDigest ( ) throws NoSuchAlgorithmException { testDigest ( MessagingService . current_version ) ; } @Test public void testLegacyDigest ( ) throws NoSuchAlgorithmException { testDigest ( MessagingService . VERSION_22 ) ; } public void testDigest ( int version ) throws NoSuchAlgorithmException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_TENCOL ) ; try { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . add ( <str> + i , <str> + i ) ; builder . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; ImmutableBTreePartition p1 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; ImmutableBTreePartition p2 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; MessageDigest digest1 = MessageDigest . getInstance ( <str> ) ; MessageDigest digest2 = MessageDigest . getInstance ( <str> ) ; UnfilteredRowIterators . digest ( p1 . unfilteredIterator ( ) , digest1 , version ) ; UnfilteredRowIterators . digest ( p2 . unfilteredIterator ( ) , digest2 , version ) ; assertFalse ( Arrays . equals ( digest1 . digest ( ) , digest2 . digest ( ) ) ) ; p1 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; p2 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; digest1 = MessageDigest . getInstance ( <str> ) ; digest2 = MessageDigest . getInstance ( <str> ) ; UnfilteredRowIterators . digest ( p1 . unfilteredIterator ( ) , digest1 , version ) ; UnfilteredRowIterators . digest ( p2 . unfilteredIterator ( ) , digest2 , version ) ; assertTrue ( Arrays . equals ( digest1 . digest ( ) , digest2 . digest ( ) ) ) ; p1 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; p2 = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; digest1 = MessageDigest . getInstance ( <str> ) ; digest2 = MessageDigest . getInstance ( <str> ) ; UnfilteredRowIterators . digest ( p1 . unfilteredIterator ( ) , digest1 , version ) ; UnfilteredRowIterators . digest ( p2 . unfilteredIterator ( ) , digest2 , version ) ; assertFalse ( Arrays . equals ( digest1 . digest ( ) , digest2 . digest ( ) ) ) ; } finally { cfs . truncateBlocking ( ) ; } } @Test public void testColumnStatsRecordsRowDeletesCorrectly ( ) { long timestamp = System . currentTimeMillis ( ) ; int localDeletionTime = ( int ) ( timestamp / <int> ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_TENCOL ) ; RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) builder . add ( <str> + i , <str> + i ) ; builder . build ( ) . applyUnsafe ( ) ; RowUpdateBuilder . deleteRowAt ( cfs . metadata , <int> , localDeletionTime , <str> , <str> ) . applyUnsafe ( ) ; ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , <str> ) . build ( ) ) ; EncodingStats stats = partition . stats ( ) ; assertEquals ( localDeletionTime , stats . minLocalDeletionTime ) ; } } 
