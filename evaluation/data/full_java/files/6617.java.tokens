package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class GeoPolygonQueryParser implements QueryParser < GeoPolygonQueryBuilder > { public static final ParseField COERCE_FIELD = new ParseField ( <str> , <str> ) ; public static final ParseField IGNORE_MALFORMED_FIELD = new ParseField ( <str> ) ; public static final ParseField VALIDATION_METHOD = new ParseField ( <str> ) ; public static final ParseField POINTS_FIELD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { GeoPolygonQueryBuilder . NAME , <str> } ; } @Override public GeoPolygonQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; String fieldName = null ; List < GeoPoint > shell = null ; Float boost = null ; boolean coerce = GeoValidationMethod . DEFAULT_LENIENT_PARSING ; boolean ignoreMalformed = GeoValidationMethod . DEFAULT_LENIENT_PARSING ; GeoValidationMethod validationMethod = null ; String queryName = null ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( parseContext . isDeprecatedSetting ( currentFieldName ) ) { } else if ( token = = XContentParser . Token . START_OBJECT ) { fieldName = currentFieldName ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , POINTS_FIELD ) ) { shell = new ArrayList < GeoPoint > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = Token . END_ARRAY ) { shell . add ( GeoUtils . parseGeoPoint ( parser ) ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + token . name ( ) + <str> + currentFieldName + <str> ) ; } } } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { queryName = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , COERCE_FIELD ) ) { coerce = parser . booleanValue ( ) ; if ( coerce = = true ) { ignoreMalformed = true ; } } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , IGNORE_MALFORMED_FIELD ) ) { ignoreMalformed = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , VALIDATION_METHOD ) ) { validationMethod = GeoValidationMethod . fromString ( parser . text ( ) ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + token . name ( ) + <str> ) ; } } GeoPolygonQueryBuilder builder = new GeoPolygonQueryBuilder ( fieldName , shell ) ; if ( validationMethod ! = null ) { builder . setValidationMethod ( validationMethod ) ; } else { builder . setValidationMethod ( GeoValidationMethod . infer ( coerce , ignoreMalformed ) ) ; } if ( queryName ! = null ) { builder . queryName ( queryName ) ; } if ( boost ! = null ) { builder . boost ( boost ) ; } return builder ; } @Override public GeoPolygonQueryBuilder getBuilderPrototype ( ) { return GeoPolygonQueryBuilder . PROTOTYPE ; } } 
