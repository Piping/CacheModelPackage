package org . elasticsearch . search . suggest . term ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . suggest . Suggest . Suggestion ; import org . elasticsearch . search . suggest . Suggest . Suggestion . Entry . Option ; import java . io . IOException ; import java . util . Comparator ; public class TermSuggestion extends Suggestion < TermSuggestion . Entry > { public static final Comparator < Suggestion . Entry . Option > SCORE = new Score ( ) ; public static final Comparator < Suggestion . Entry . Option > FREQUENCY = new Frequency ( ) ; public static class Score implements Comparator < Suggestion . Entry . Option > { @Override public int compare ( Suggestion . Entry . Option first , Suggestion . Entry . Option second ) { int cmp = Float . compare ( second . getScore ( ) , first . getScore ( ) ) ; if ( cmp ! = <int> ) { return cmp ; } return FREQUENCY . compare ( first , second ) ; } } public static class Frequency implements Comparator < Suggestion . Entry . Option > { @Override public int compare ( Suggestion . Entry . Option first , Suggestion . Entry . Option second ) { int cmp = ( ( TermSuggestion . Entry . Option ) second ) . getFreq ( ) - ( ( TermSuggestion . Entry . Option ) first ) . getFreq ( ) ; if ( cmp ! = <int> ) { return cmp ; } cmp = Float . compare ( second . getScore ( ) , first . getScore ( ) ) ; if ( cmp ! = <int> ) { return cmp ; } return first . getText ( ) . compareTo ( second . getText ( ) ) ; } } public static final int TYPE = <int> ; private Sort sort ; public TermSuggestion ( ) { } public TermSuggestion ( String name , int size , Sort sort ) { super ( name , size ) ; this . sort = sort ; } @Override public int getType ( ) { return TYPE ; } @Override protected Comparator < Option > sortComparator ( ) { switch ( sort ) { case SCORE : return SCORE ; case FREQUENCY : return FREQUENCY ; default : throw new ElasticsearchException ( <str> + sort + <str> ) ; } } @Override protected void innerReadFrom ( StreamInput in ) throws IOException { super . innerReadFrom ( in ) ; sort = Sort . fromId ( in . readByte ( ) ) ; } @Override public void innerWriteTo ( StreamOutput out ) throws IOException { super . innerWriteTo ( out ) ; out . writeByte ( sort . id ( ) ) ; } @Override protected Entry newEntry ( ) { return new Entry ( ) ; } public static class Entry extends org . elasticsearch . search . suggest . Suggest . Suggestion . Entry < TermSuggestion . Entry . Option > { Entry ( Text text , int offset , int length ) { super ( text , offset , length ) ; } Entry ( ) { } @Override protected Option newOption ( ) { return new Option ( ) ; } public static class Option extends org . elasticsearch . search . suggest . Suggest . Suggestion . Entry . Option { static class Fields { static final XContentBuilderString FREQ = new XContentBuilderString ( <str> ) ; } private int freq ; protected Option ( Text text , int freq , float score ) { super ( text , score ) ; this . freq = freq ; } @Override protected void mergeInto ( Suggestion . Entry . Option otherOption ) { super . mergeInto ( otherOption ) ; freq + = ( ( Option ) otherOption ) . freq ; } protected Option ( ) { super ( ) ; } public void setFreq ( int freq ) { this . freq = freq ; } public int getFreq ( ) { return freq ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; freq = in . readVInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( freq ) ; } @Override protected XContentBuilder innerToXContent ( XContentBuilder builder , Params params ) throws IOException { builder = super . innerToXContent ( builder , params ) ; builder . field ( Fields . FREQ , freq ) ; return builder ; } } } } 
