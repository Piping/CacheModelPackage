package org . elasticsearch . index . mapper ; import org . elasticsearch . Version ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . mapper . object . RootObjectMapper ; import java . io . IOException ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; public final class Mapping implements ToXContent { public static final List < String > LEGACY_INCLUDE_IN_OBJECT = Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ; final Version indexCreated ; final RootObjectMapper root ; final MetadataFieldMapper [ ] metadataMappers ; final Map < Class < ? extends MetadataFieldMapper > , MetadataFieldMapper > metadataMappersMap ; volatile Map < String , Object > meta ; public Mapping ( Version indexCreated , RootObjectMapper rootObjectMapper , MetadataFieldMapper [ ] metadataMappers , Map < String , Object > meta ) { this . indexCreated = indexCreated ; this . root = rootObjectMapper ; this . metadataMappers = metadataMappers ; Map < Class < ? extends MetadataFieldMapper > , MetadataFieldMapper > metadataMappersMap = new HashMap < > ( ) ; for ( MetadataFieldMapper metadataMapper : metadataMappers ) { if ( indexCreated . before ( Version . V_2_0_0_beta1 ) & & LEGACY_INCLUDE_IN_OBJECT . contains ( metadataMapper . name ( ) ) ) { root . putMapper ( metadataMapper ) ; } metadataMappersMap . put ( metadataMapper . getClass ( ) , metadataMapper ) ; } Arrays . sort ( metadataMappers , new Comparator < Mapper > ( ) { @Override public int compare ( Mapper o1 , Mapper o2 ) { return o1 . name ( ) . compareTo ( o2 . name ( ) ) ; } } ) ; this . metadataMappersMap = unmodifiableMap ( metadataMappersMap ) ; this . meta = meta ; } public RootObjectMapper root ( ) { return root ; } public Mapping mappingUpdate ( Mapper rootObjectMapper ) { return new Mapping ( indexCreated , ( RootObjectMapper ) rootObjectMapper , metadataMappers , meta ) ; } @SuppressWarnings ( <str> ) public < T extends MetadataFieldMapper > T metadataMapper ( Class < T > clazz ) { return ( T ) metadataMappersMap . get ( clazz ) ; } public void merge ( Mapping mergeWith , MergeResult mergeResult ) { assert metadataMappers . length = = mergeWith . metadataMappers . length ; root . merge ( mergeWith . root , mergeResult ) ; for ( MetadataFieldMapper metadataMapper : metadataMappers ) { MetadataFieldMapper mergeWithMetadataMapper = mergeWith . metadataMapper ( metadataMapper . getClass ( ) ) ; if ( mergeWithMetadataMapper ! = null ) { metadataMapper . merge ( mergeWithMetadataMapper , mergeResult ) ; } } if ( mergeResult . simulate ( ) = = false ) { meta = mergeWith . meta ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { root . toXContent ( builder , params , new ToXContent ( ) { @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( meta ! = null & & ! meta . isEmpty ( ) ) { builder . field ( <str> , meta ) ; } for ( Mapper mapper : metadataMappers ) { mapper . toXContent ( builder , params ) ; } return builder ; } } ) ; return builder ; } @Override public String toString ( ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . startObject ( ) ; toXContent ( builder , new ToXContent . MapParams ( emptyMap ( ) ) ) ; return builder . endObject ( ) . string ( ) ; } catch ( IOException bogus ) { throw new AssertionError ( bogus ) ; } } } 
