package io . netty . resolver . dns ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . reflect . Method ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . SocketAddress ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; @SuppressWarnings ( <str> ) public abstract class DnsServerAddresses { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( DnsServerAddresses . class ) ; private static final List < InetSocketAddress > DEFAULT_NAME_SERVER_LIST ; private static final InetSocketAddress [ ] DEFAULT_NAME_SERVER_ARRAY ; private static final DnsServerAddresses DEFAULT_NAME_SERVERS ; static { final int DNS_PORT = <int> ; final List < InetSocketAddress > defaultNameServers = new ArrayList < InetSocketAddress > ( <int> ) ; try { Class < ? > configClass = Class . forName ( <str> ) ; Method open = configClass . getMethod ( <str> ) ; Method nameservers = configClass . getMethod ( <str> ) ; Object instance = open . invoke ( null ) ; @SuppressWarnings ( <str> ) final List < String > list = ( List < String > ) nameservers . invoke ( instance ) ; for ( String a : list ) { if ( a ! = null ) { defaultNameServers . add ( new InetSocketAddress ( InetAddress . getByName ( a ) , DNS_PORT ) ) ; } } } catch ( Exception ignore ) { } if ( ! defaultNameServers . isEmpty ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , defaultNameServers ) ; } } else { Collections . addAll ( defaultNameServers , new InetSocketAddress ( <str> , DNS_PORT ) , new InetSocketAddress ( <str> , DNS_PORT ) ) ; if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , defaultNameServers ) ; } } DEFAULT_NAME_SERVER_LIST = Collections . unmodifiableList ( defaultNameServers ) ; DEFAULT_NAME_SERVER_ARRAY = defaultNameServers . toArray ( new InetSocketAddress [ defaultNameServers . size ( ) ] ) ; DEFAULT_NAME_SERVERS = sequential ( DEFAULT_NAME_SERVER_ARRAY ) ; } public static List < InetSocketAddress > defaultAddressList ( ) { return DEFAULT_NAME_SERVER_LIST ; } public static DnsServerAddresses defaultAddresses ( ) { return DEFAULT_NAME_SERVERS ; } public static DnsServerAddresses sequential ( Iterable < ? extends InetSocketAddress > addresses ) { return sequential0 ( sanitize ( addresses ) ) ; } public static DnsServerAddresses sequential ( InetSocketAddress . . . addresses ) { return sequential0 ( sanitize ( addresses ) ) ; } private static DnsServerAddresses sequential0 ( final InetSocketAddress . . . addresses ) { if ( addresses . length = = <int> ) { return singleton ( addresses [ <int> ] ) ; } return new DefaultDnsServerAddresses ( <str> , addresses ) { @Override public DnsServerAddressStream stream ( ) { return new SequentialDnsServerAddressStream ( addresses , <int> ) ; } } ; } public static DnsServerAddresses shuffled ( Iterable < ? extends InetSocketAddress > addresses ) { return shuffled0 ( sanitize ( addresses ) ) ; } public static DnsServerAddresses shuffled ( InetSocketAddress . . . addresses ) { return shuffled0 ( sanitize ( addresses ) ) ; } private static DnsServerAddresses shuffled0 ( final InetSocketAddress [ ] addresses ) { if ( addresses . length = = <int> ) { return singleton ( addresses [ <int> ] ) ; } return new DefaultDnsServerAddresses ( <str> , addresses ) { @Override public DnsServerAddressStream stream ( ) { return new ShuffledDnsServerAddressStream ( addresses ) ; } } ; } public static DnsServerAddresses rotational ( Iterable < ? extends InetSocketAddress > addresses ) { return rotational0 ( sanitize ( addresses ) ) ; } public static DnsServerAddresses rotational ( InetSocketAddress . . . addresses ) { return rotational0 ( sanitize ( addresses ) ) ; } private static DnsServerAddresses rotational0 ( final InetSocketAddress [ ] addresses ) { if ( addresses . length = = <int> ) { return singleton ( addresses [ <int> ] ) ; } return new RotationalDnsServerAddresses ( addresses ) ; } public static DnsServerAddresses singleton ( final InetSocketAddress address ) { if ( address = = null ) { throw new NullPointerException ( <str> ) ; } if ( address . isUnresolved ( ) ) { throw new IllegalArgumentException ( <str> + address ) ; } return new SingletonDnsServerAddresses ( address ) ; } private static InetSocketAddress [ ] sanitize ( Iterable < ? extends InetSocketAddress > addresses ) { if ( addresses = = null ) { throw new NullPointerException ( <str> ) ; } final List < InetSocketAddress > list ; if ( addresses instanceof Collection ) { list = new ArrayList < InetSocketAddress > ( ( ( Collection < ? > ) addresses ) . size ( ) ) ; } else { list = new ArrayList < InetSocketAddress > ( <int> ) ; } for ( InetSocketAddress a : addresses ) { if ( a = = null ) { break ; } if ( a . isUnresolved ( ) ) { throw new IllegalArgumentException ( <str> + a ) ; } list . add ( a ) ; } if ( list . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> ) ; } return list . toArray ( new InetSocketAddress [ list . size ( ) ] ) ; } private static InetSocketAddress [ ] sanitize ( InetSocketAddress [ ] addresses ) { if ( addresses = = null ) { throw new NullPointerException ( <str> ) ; } List < InetSocketAddress > list = new ArrayList < InetSocketAddress > ( addresses . length ) ; for ( InetSocketAddress a : addresses ) { if ( a = = null ) { break ; } if ( a . isUnresolved ( ) ) { throw new IllegalArgumentException ( <str> + a ) ; } list . add ( a ) ; } if ( list . isEmpty ( ) ) { return DEFAULT_NAME_SERVER_ARRAY ; } return list . toArray ( new InetSocketAddress [ list . size ( ) ] ) ; } public abstract DnsServerAddressStream stream ( ) ; } 
