package org . elasticsearch . gateway ; import org . apache . lucene . index . CorruptIndexException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESAllocationTestCase ; import org . junit . Before ; import java . io . IOException ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import static org . hamcrest . Matchers . * ; public class PrimaryShardAllocatorTests extends ESAllocationTestCase { private final ShardId shardId = new ShardId ( <str> , <int> ) ; private final DiscoveryNode node1 = newNode ( <str> ) ; private final DiscoveryNode node2 = newNode ( <str> ) ; private final DiscoveryNode node3 = newNode ( <str> ) ; private TestAllocator testAllocator ; @Before public void buildTestAllocator ( ) { this . testAllocator = new TestAllocator ( ) ; } public void testNoProcessReplica ( ) { ShardRouting shard = TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , false , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( UnassignedInfo . Reason . CLUSTER_RECOVERED , null ) ) ; assertThat ( testAllocator . needToFindPrimaryCopy ( shard ) , equalTo ( false ) ) ; } public void testNoProcessPrimayNotAllcoatedBefore ( ) { ShardRouting shard = TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , true , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , null ) ) ; assertThat ( testAllocator . needToFindPrimaryCopy ( shard ) , equalTo ( false ) ) ; } public void testNoAsyncFetchData ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( yesAllocationDeciders ( ) ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testNoAllocationFound ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , - <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testStoreException ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , <int> , new CorruptIndexException ( <str> , <str> ) ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testFoundAllocationAndAllocating ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . isEmpty ( ) , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( node1 . id ( ) ) ) ; } public void testFoundAllocationButThrottlingDecider ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( throttleAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; } public void testFoundAllocationButNoDecider ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( noAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . isEmpty ( ) , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( node1 . id ( ) ) ) ; } public void testAllocateToTheHighestVersion ( ) { RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas ( yesAllocationDeciders ( ) ) ; testAllocator . addData ( node1 , <int> ) . addData ( node2 , <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . isEmpty ( ) , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( node2 . id ( ) ) ) ; } public void testRestoreIgnoresNoNodesToAllocate ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsRestore ( metaData . index ( shardId . getIndex ( ) ) , new RestoreSource ( new SnapshotId ( <str> , <str> ) , Version . CURRENT , shardId . getIndex ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; RoutingAllocation allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , state . getRoutingNodes ( ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; testAllocator . addData ( node1 , - <int> ) . addData ( node2 , - <int> ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . isEmpty ( ) , equalTo ( true ) ) ; } public void testEnoughCopiesFoundForAllocation ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsRecovery ( metaData . index ( shardId . getIndex ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; RoutingAllocation allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; testAllocator . addData ( node1 , <int> ) ; allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; testAllocator . addData ( node2 , <int> ) ; allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( node2 . id ( ) ) , equalTo ( node1 . id ( ) ) ) ) ; } public void testEnoughCopiesFoundForAllocationWithDifferentVersion ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsRecovery ( metaData . index ( shardId . getIndex ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; RoutingAllocation allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; boolean changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; testAllocator . addData ( node1 , <int> ) ; allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( false ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . get ( <int> ) . shardId ( ) , equalTo ( shardId ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; testAllocator . addData ( node2 , <int> ) ; allocation = new RoutingAllocation ( yesAllocationDeciders ( ) , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; changed = testAllocator . allocateUnassigned ( allocation ) ; assertThat ( changed , equalTo ( true ) ) ; assertThat ( allocation . routingNodes ( ) . unassigned ( ) . ignored ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allocation . routingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . currentNodeId ( ) , equalTo ( node2 . id ( ) ) ) ; } public void testAllocationOnAnyNodeWithSharedFs ( ) { ShardRouting shard = TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , false , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( UnassignedInfo . Reason . CLUSTER_RECOVERED , null ) ) ; Map < DiscoveryNode , TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > data = new HashMap < > ( ) ; data . put ( node1 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node1 , <int> ) ) ; data . put ( node2 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node2 , <int> ) ) ; data . put ( node3 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node3 , - <int> ) ) ; AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > fetches = new AsyncShardFetch . FetchResult ( shardId , data , new HashSet < > ( ) , new HashSet < > ( ) ) ; PrimaryShardAllocator . NodesAndVersions nAndV = testAllocator . buildNodesAndVersions ( shard , false , new HashSet < String > ( ) , fetches ) ; assertThat ( nAndV . allocationsFound , equalTo ( <int> ) ) ; assertThat ( nAndV . highestVersion , equalTo ( <int> ) ) ; assertThat ( nAndV . nodes , contains ( node2 ) ) ; nAndV = testAllocator . buildNodesAndVersions ( shard , true , new HashSet < String > ( ) , fetches ) ; assertThat ( nAndV . allocationsFound , equalTo ( <int> ) ) ; assertThat ( nAndV . highestVersion , equalTo ( <int> ) ) ; assertThat ( nAndV . nodes , contains ( node2 , node1 , node3 ) ) ; } public void testAllocationOnAnyNodeShouldPutNodesWithExceptionsLast ( ) { ShardRouting shard = TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , false , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( UnassignedInfo . Reason . CLUSTER_RECOVERED , null ) ) ; Map < DiscoveryNode , TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > data = new HashMap < > ( ) ; data . put ( node1 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node1 , <int> ) ) ; data . put ( node2 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node2 , <int> ) ) ; data . put ( node3 , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node3 , <int> , new IOException ( <str> ) ) ) ; HashSet < String > ignoredNodes = new HashSet < > ( ) ; ignoredNodes . add ( node2 . id ( ) ) ; AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > fetches = new AsyncShardFetch . FetchResult ( shardId , data , new HashSet < > ( ) , ignoredNodes ) ; PrimaryShardAllocator . NodesAndVersions nAndV = testAllocator . buildNodesAndVersions ( shard , false , ignoredNodes , fetches ) ; assertThat ( nAndV . allocationsFound , equalTo ( <int> ) ) ; assertThat ( nAndV . highestVersion , equalTo ( <int> ) ) ; assertThat ( nAndV . nodes , contains ( node1 ) ) ; nAndV = testAllocator . buildNodesAndVersions ( shard , true , ignoredNodes , fetches ) ; assertThat ( nAndV . allocationsFound , equalTo ( <int> ) ) ; assertThat ( nAndV . highestVersion , equalTo ( <int> ) ) ; assertThat ( nAndV . nodes . size ( ) , equalTo ( <int> ) ) ; assertThat ( nAndV . nodes , contains ( node1 , node3 ) ) ; } private RoutingAllocation routingAllocationWithOnePrimaryNoReplicas ( AllocationDeciders deciders ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( shardId . getIndex ( ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsRecovery ( metaData . index ( shardId . getIndex ( ) ) ) . build ( ) ; ClusterState state = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . nodes ( DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . put ( node3 ) ) . build ( ) ; return new RoutingAllocation ( deciders , new RoutingNodes ( state , false ) , state . nodes ( ) , null , System . nanoTime ( ) ) ; } class TestAllocator extends PrimaryShardAllocator { private Map < DiscoveryNode , TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > data ; public TestAllocator ( ) { super ( Settings . EMPTY ) ; } public TestAllocator clear ( ) { data = null ; return this ; } public TestAllocator addData ( DiscoveryNode node , long version ) { return addData ( node , version , null ) ; } public TestAllocator addData ( DiscoveryNode node , long version , @Nullable Throwable storeException ) { if ( data = = null ) { data = new HashMap < > ( ) ; } data . put ( node , new TransportNodesListGatewayStartedShards . NodeGatewayStartedShards ( node , version , storeException ) ) ; return this ; } @Override protected AsyncShardFetch . FetchResult < TransportNodesListGatewayStartedShards . NodeGatewayStartedShards > fetchData ( ShardRouting shard , RoutingAllocation allocation ) { return new AsyncShardFetch . FetchResult < > ( shardId , data , Collections . < String > emptySet ( ) , Collections . < String > emptySet ( ) ) ; } } } 
