package org . eclipse . core . externaltools . internal . launchConfigurations ; import org . eclipse . core . externaltools . internal . ExternalToolsCore ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . RefreshUtil ; import org . eclipse . debug . core . model . IProcess ; public class BackgroundResourceRefresher implements IDebugEventSetListener { private ILaunchConfiguration fConfiguration ; private IProcess fProcess ; public BackgroundResourceRefresher ( ILaunchConfiguration configuration , IProcess process ) { fConfiguration = configuration ; fProcess = process ; } public void startBackgroundRefresh ( ) { synchronized ( fProcess ) { if ( fProcess . isTerminated ( ) ) { refresh ( ) ; } else { DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; } } } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) { DebugEvent event = events [ i ] ; if ( event . getSource ( ) = = fProcess & & event . getKind ( ) = = DebugEvent . TERMINATE ) { DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; refresh ( ) ; break ; } } } protected void refresh ( ) { Job job = new Job ( ExternalToolsProgramMessages . BackgroundResourceRefresher_0 ) { @Override public IStatus run ( IProgressMonitor monitor ) { try { RefreshUtil . refreshResources ( fConfiguration , monitor ) ; } catch ( CoreException e ) { ExternalToolsCore . log ( e ) ; return e . getStatus ( ) ; } return Status . OK_STATUS ; } } ; job . schedule ( ) ; } } 
