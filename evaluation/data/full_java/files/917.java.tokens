package org . apache . cassandra . serializers ; import java . nio . BufferUnderflowException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . Pair ; public class MapSerializer < K , V > extends CollectionSerializer < Map < K , V > > { private static final Map < Pair < TypeSerializer < ? > , TypeSerializer < ? > > , MapSerializer > instances = new HashMap < Pair < TypeSerializer < ? > , TypeSerializer < ? > > , MapSerializer > ( ) ; public final TypeSerializer < K > keys ; public final TypeSerializer < V > values ; private final Comparator < Pair < ByteBuffer , ByteBuffer > > comparator ; public static synchronized < K , V > MapSerializer < K , V > getInstance ( TypeSerializer < K > keys , TypeSerializer < V > values , Comparator < ByteBuffer > comparator ) { Pair < TypeSerializer < ? > , TypeSerializer < ? > > p = Pair . < TypeSerializer < ? > , TypeSerializer < ? > > create ( keys , values ) ; MapSerializer < K , V > t = instances . get ( p ) ; if ( t = = null ) { t = new MapSerializer < K , V > ( keys , values , comparator ) ; instances . put ( p , t ) ; } return t ; } private MapSerializer ( TypeSerializer < K > keys , TypeSerializer < V > values , Comparator < ByteBuffer > comparator ) { this . keys = keys ; this . values = values ; this . comparator = ( p1 , p2 ) - > comparator . compare ( p1 . left , p2 . left ) ; } public List < ByteBuffer > serializeValues ( Map < K , V > map ) { List < Pair < ByteBuffer , ByteBuffer > > pairs = new ArrayList < > ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) pairs . add ( Pair . create ( keys . serialize ( entry . getKey ( ) ) , values . serialize ( entry . getValue ( ) ) ) ) ; Collections . sort ( pairs , comparator ) ; List < ByteBuffer > buffers = new ArrayList < > ( pairs . size ( ) * <int> ) ; for ( Pair < ByteBuffer , ByteBuffer > p : pairs ) { buffers . add ( p . left ) ; buffers . add ( p . right ) ; } return buffers ; } public int getElementCount ( Map < K , V > value ) { return value . size ( ) ; } public void validateForNativeProtocol ( ByteBuffer bytes , int version ) { try { ByteBuffer input = bytes . duplicate ( ) ; int n = readCollectionSize ( input , version ) ; for ( int i = <int> ; i < n ; i + + ) { keys . validate ( readValue ( input , version ) ) ; values . validate ( readValue ( input , version ) ) ; } if ( input . hasRemaining ( ) ) throw new MarshalException ( <str> ) ; } catch ( BufferUnderflowException e ) { throw new MarshalException ( <str> ) ; } } public Map < K , V > deserializeForNativeProtocol ( ByteBuffer bytes , int version ) { try { ByteBuffer input = bytes . duplicate ( ) ; int n = readCollectionSize ( input , version ) ; Map < K , V > m = new LinkedHashMap < K , V > ( n ) ; for ( int i = <int> ; i < n ; i + + ) { ByteBuffer kbb = readValue ( input , version ) ; keys . validate ( kbb ) ; ByteBuffer vbb = readValue ( input , version ) ; values . validate ( vbb ) ; m . put ( keys . deserialize ( kbb ) , values . deserialize ( vbb ) ) ; } if ( input . hasRemaining ( ) ) throw new MarshalException ( <str> ) ; return m ; } catch ( BufferUnderflowException e ) { throw new MarshalException ( <str> ) ; } } public ByteBuffer getSerializedValue ( ByteBuffer serializedMap , ByteBuffer serializedKey , AbstractType keyType ) { try { ByteBuffer input = serializedMap . duplicate ( ) ; int n = readCollectionSize ( input , Server . VERSION_3 ) ; for ( int i = <int> ; i < n ; i + + ) { ByteBuffer kbb = readValue ( input , Server . VERSION_3 ) ; ByteBuffer vbb = readValue ( input , Server . VERSION_3 ) ; int comparison = keyType . compare ( kbb , serializedKey ) ; if ( comparison = = <int> ) return vbb ; else if ( comparison > <int> ) return null ; } return null ; } catch ( BufferUnderflowException e ) { throw new MarshalException ( <str> ) ; } } public String toString ( Map < K , V > value ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; boolean isFirst = true ; for ( Map . Entry < K , V > element : value . entrySet ( ) ) { if ( isFirst ) isFirst = false ; else sb . append ( <str> ) ; sb . append ( keys . toString ( element . getKey ( ) ) ) ; sb . append ( <str> ) ; sb . append ( values . toString ( element . getValue ( ) ) ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public Class < Map < K , V > > getType ( ) { return ( Class ) Map . class ; } } 
