package org . elasticsearch . node . internal ; import java . nio . charset . StandardCharsets ; import org . elasticsearch . bootstrap . BootstrapInfo ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . cli . Terminal ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsException ; import org . elasticsearch . env . Environment ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ThreadLocalRandom ; import static org . elasticsearch . common . Strings . cleanPath ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class InternalSettingsPreparer { private static final String [ ] ALLOWED_SUFFIXES = { <str> , <str> , <str> , <str> } ; static final String [ ] PROPERTY_PREFIXES = { <str> , <str> } ; static final String [ ] PROPERTY_DEFAULTS_PREFIXES = { <str> , <str> } ; public static final String SECRET_PROMPT_VALUE = <str> ; public static final String TEXT_PROMPT_VALUE = <str> ; public static final String IGNORE_SYSTEM_PROPERTIES_SETTING = <str> ; public static Settings prepareSettings ( Settings input ) { Settings . Builder output = settingsBuilder ( ) ; initializeSettings ( output , input , true ) ; finalizeSettings ( output , null , null ) ; return output . build ( ) ; } public static Environment prepareEnvironment ( Settings input , Terminal terminal ) { Settings . Builder output = settingsBuilder ( ) ; initializeSettings ( output , input , true ) ; Environment environment = new Environment ( output . build ( ) ) ; boolean settingsFileFound = false ; Set < String > foundSuffixes = new HashSet < > ( ) ; for ( String allowedSuffix : ALLOWED_SUFFIXES ) { Path path = environment . configFile ( ) . resolve ( <str> + allowedSuffix ) ; if ( Files . exists ( path ) ) { if ( ! settingsFileFound ) { output . loadFromPath ( path ) ; } settingsFileFound = true ; foundSuffixes . add ( allowedSuffix ) ; } } if ( foundSuffixes . size ( ) > <int> ) { throw new SettingsException ( <str> + Strings . collectionToDelimitedString ( foundSuffixes , <str> ) ) ; } initializeSettings ( output , input , false ) ; finalizeSettings ( output , terminal , environment . configFile ( ) ) ; environment = new Environment ( output . build ( ) ) ; output . put ( <str> , cleanPath ( environment . logsFile ( ) . toAbsolutePath ( ) . toString ( ) ) ) ; return new Environment ( output . build ( ) ) ; } private static boolean useSystemProperties ( Settings input ) { return ! input . getAsBoolean ( IGNORE_SYSTEM_PROPERTIES_SETTING , false ) ; } private static void initializeSettings ( Settings . Builder output , Settings input , boolean loadDefaults ) { output . put ( input ) ; if ( useSystemProperties ( input ) ) { if ( loadDefaults ) { for ( String prefix : PROPERTY_DEFAULTS_PREFIXES ) { output . putProperties ( prefix , BootstrapInfo . getSystemProperties ( ) ) ; } } for ( String prefix : PROPERTY_PREFIXES ) { output . putProperties ( prefix , BootstrapInfo . getSystemProperties ( ) , PROPERTY_DEFAULTS_PREFIXES ) ; } } output . replacePropertyPlaceholders ( ) ; } private static void finalizeSettings ( Settings . Builder output , Terminal terminal , Path configDir ) { List < String > forcedSettings = new ArrayList < > ( ) ; for ( String setting : output . internalMap ( ) . keySet ( ) ) { if ( setting . startsWith ( <str> ) ) { forcedSettings . add ( setting ) ; } } for ( String forcedSetting : forcedSettings ) { String value = output . remove ( forcedSetting ) ; output . put ( forcedSetting . substring ( <str> . length ( ) ) , value ) ; } output . replacePropertyPlaceholders ( ) ; if ( output . get ( <str> ) = = null ) { String name = System . getProperty ( <str> ) ; if ( name ! = null ) { output . put ( <str> , name ) ; } } if ( output . get ( ClusterName . SETTING ) = = null ) { output . put ( ClusterName . SETTING , ClusterName . DEFAULT . value ( ) ) ; } String v = output . get ( Settings . SETTINGS_REQUIRE_UNITS ) ; if ( v ! = null ) { Settings . setSettingsRequireUnits ( Booleans . parseBoolean ( v , true ) ) ; } replacePromptPlaceholders ( output , terminal ) ; if ( output . get ( <str> ) = = null ) { String name = output . get ( <str> ) ; if ( name = = null | | name . isEmpty ( ) ) { name = randomNodeName ( configDir ) ; } output . put ( <str> , name ) ; } } private static String randomNodeName ( Path configDir ) { InputStream input ; if ( configDir ! = null & & Files . exists ( configDir . resolve ( <str> ) ) ) { Path namesPath = configDir . resolve ( <str> ) ; try { input = Files . newInputStream ( namesPath ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> + namesPath , e ) ; } } else { input = InternalSettingsPreparer . class . getResourceAsStream ( <str> ) ; } try { List < String > names = new ArrayList < > ( ) ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ) { String name = reader . readLine ( ) ; while ( name ! = null ) { names . add ( name ) ; name = reader . readLine ( ) ; } } int index = ThreadLocalRandom . current ( ) . nextInt ( names . size ( ) ) ; return names . get ( index ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } private static void replacePromptPlaceholders ( Settings . Builder settings , Terminal terminal ) { List < String > secretToPrompt = new ArrayList < > ( ) ; List < String > textToPrompt = new ArrayList < > ( ) ; for ( Map . Entry < String , String > entry : settings . internalMap ( ) . entrySet ( ) ) { switch ( entry . getValue ( ) ) { case SECRET_PROMPT_VALUE : secretToPrompt . add ( entry . getKey ( ) ) ; break ; case TEXT_PROMPT_VALUE : textToPrompt . add ( entry . getKey ( ) ) ; break ; } } for ( String setting : secretToPrompt ) { String secretValue = promptForValue ( setting , terminal , true ) ; if ( Strings . hasLength ( secretValue ) ) { settings . put ( setting , secretValue ) ; } else { settings . remove ( setting ) ; } } for ( String setting : textToPrompt ) { String textValue = promptForValue ( setting , terminal , false ) ; if ( Strings . hasLength ( textValue ) ) { settings . put ( setting , textValue ) ; } else { settings . remove ( setting ) ; } } } private static String promptForValue ( String key , Terminal terminal , boolean secret ) { if ( terminal = = null ) { throw new UnsupportedOperationException ( <str> + key + <str> + ( secret ? SECRET_PROMPT_VALUE : TEXT_PROMPT_VALUE ) + <str> ) ; } if ( secret ) { return new String ( terminal . readSecret ( <str> , key ) ) ; } return terminal . readText ( <str> , key ) ; } } 
