package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . collect . Lists ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . RandomAccess ; import javax . annotation . Nullable ; @SuppressWarnings ( <str> ) public abstract class ImmutableList < E > extends ImmutableCollection < E > implements List < E > , RandomAccess { static final ImmutableList < Object > EMPTY = new RegularImmutableList < Object > ( Collections . emptyList ( ) ) ; ImmutableList ( ) { } @SuppressWarnings ( <str> ) public static < E > ImmutableList < E > of ( ) { return ( ImmutableList < E > ) EMPTY ; } public static < E > ImmutableList < E > of ( E element ) { return new SingletonImmutableList < E > ( element ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 ) { return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 ) ) ; } public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 , E e12 , E . . . others ) { final int paramCount = <int> ; Object [ ] array = new Object [ paramCount + others . length ] ; arrayCopy ( array , <int> , e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 , e12 ) ; arrayCopy ( array , paramCount , others ) ; return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( array ) ) ; } private static void arrayCopy ( Object [ ] dest , int pos , Object . . . source ) { System . arraycopy ( source , <int> , dest , pos , source . length ) ; } public static < E > ImmutableList < E > copyOf ( Iterable < ? extends E > elements ) { checkNotNull ( elements ) ; return ( elements instanceof Collection ) ? copyOf ( ( Collection < ? extends E > ) elements ) : copyOf ( elements . iterator ( ) ) ; } public static < E > ImmutableList < E > copyOf ( Iterator < ? extends E > elements ) { return copyFromCollection ( Lists . newArrayList ( elements ) ) ; } public static < E > ImmutableList < E > copyOf ( Collection < ? extends E > elements ) { if ( elements instanceof ImmutableCollection ) { @SuppressWarnings ( <str> ) ImmutableCollection < E > list = ( ImmutableCollection < E > ) elements ; return list . asList ( ) ; } return copyFromCollection ( elements ) ; } public static < E > ImmutableList < E > copyOf ( E [ ] elements ) { checkNotNull ( elements ) ; return copyOf ( Arrays . asList ( elements ) ) ; } private static < E > ImmutableList < E > copyFromCollection ( Collection < ? extends E > collection ) { Object [ ] elements = collection . toArray ( ) ; switch ( elements . length ) { case <int> : return of ( ) ; case <int> : @SuppressWarnings ( <str> ) ImmutableList < E > list = new SingletonImmutableList < E > ( ( E ) elements [ <int> ] ) ; return list ; default : return new RegularImmutableList < E > ( ImmutableList . < E > nullCheckedList ( elements ) ) ; } } static < E > ImmutableList < E > unsafeDelegateList ( List < ? extends E > list ) { switch ( list . size ( ) ) { case <int> : return of ( ) ; case <int> : return new SingletonImmutableList < E > ( list . iterator ( ) . next ( ) ) ; default : @SuppressWarnings ( <str> ) List < E > castedList = ( List < E > ) list ; return new RegularImmutableList < E > ( castedList ) ; } } @SuppressWarnings ( <str> ) static < E > ImmutableList < E > asImmutableList ( Object [ ] elements ) { return unsafeDelegateList ( ( List ) Arrays . asList ( elements ) ) ; } private static < E > List < E > nullCheckedList ( Object . . . array ) { for ( int i = <int> , len = array . length ; i < len ; i + + ) { if ( array [ i ] = = null ) { throw new NullPointerException ( <str> + i ) ; } } @SuppressWarnings ( <str> ) E [ ] castedArray = ( E [ ] ) array ; return Arrays . asList ( castedArray ) ; } @Override public int indexOf ( @Nullable Object object ) { return ( object = = null ) ? - <int> : Lists . indexOfImpl ( this , object ) ; } @Override public int lastIndexOf ( @Nullable Object object ) { return ( object = = null ) ? - <int> : Lists . lastIndexOfImpl ( this , object ) ; } public final boolean addAll ( int index , Collection < ? extends E > newElements ) { throw new UnsupportedOperationException ( ) ; } public final E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } public final void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } public final E remove ( int index ) { throw new UnsupportedOperationException ( ) ; } @Override public UnmodifiableIterator < E > iterator ( ) { return listIterator ( ) ; } @Override public ImmutableList < E > subList ( int fromIndex , int toIndex ) { return unsafeDelegateList ( Lists . subListImpl ( this , fromIndex , toIndex ) ) ; } @Override public UnmodifiableListIterator < E > listIterator ( ) { return listIterator ( <int> ) ; } @Override public UnmodifiableListIterator < E > listIterator ( int index ) { return new AbstractIndexedListIterator < E > ( size ( ) , index ) { @Override protected E get ( int index ) { return ImmutableList . this . get ( index ) ; } } ; } @Override public ImmutableList < E > asList ( ) { return this ; } @Override public boolean equals ( @Nullable Object obj ) { return Lists . equalsImpl ( this , obj ) ; } @Override public int hashCode ( ) { return Lists . hashCodeImpl ( this ) ; } public ImmutableList < E > reverse ( ) { List < E > list = Lists . newArrayList ( this ) ; Collections . reverse ( list ) ; return unsafeDelegateList ( list ) ; } public static < E > Builder < E > builder ( ) { return new Builder < E > ( ) ; } public static final class Builder < E > extends ImmutableCollection . Builder < E > { private final ArrayList < E > contents ; public Builder ( ) { contents = Lists . newArrayList ( ) ; } Builder ( int capacity ) { contents = Lists . newArrayListWithCapacity ( capacity ) ; } @Override public Builder < E > add ( E element ) { contents . add ( checkNotNull ( element ) ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { checkNotNull ( elements ) ; super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableList < E > build ( ) { return copyOf ( contents ) ; } } } 
