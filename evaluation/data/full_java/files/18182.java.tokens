package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . Array ; public class CumulativeDistribution < T > { public class CumulativeValue { public T value ; public float frequency ; public float interval ; public CumulativeValue ( T value , float frequency , float interval ) { this . value = value ; this . frequency = frequency ; this . interval = interval ; } } private Array < CumulativeValue > values ; public CumulativeDistribution ( ) { values = new Array < CumulativeValue > ( false , <int> , CumulativeValue . class ) ; } public void add ( T value , float intervalSize ) { values . add ( new CumulativeValue ( value , <int> , intervalSize ) ) ; } public void add ( T value ) { values . add ( new CumulativeValue ( value , <int> , <int> ) ) ; } public void generate ( ) { float sum = <int> ; for ( int i = <int> ; i < values . size ; + + i ) { sum + = values . items [ i ] . interval ; values . items [ i ] . frequency = sum ; } } public void generateNormalized ( ) { float sum = <int> ; for ( int i = <int> ; i < values . size ; + + i ) { sum + = values . items [ i ] . interval ; } float intervalSum = <int> ; for ( int i = <int> ; i < values . size ; + + i ) { intervalSum + = values . items [ i ] . interval / sum ; values . items [ i ] . frequency = intervalSum ; } } public void generateUniform ( ) { float freq = <float> / values . size ; for ( int i = <int> ; i < values . size ; + + i ) { values . items [ i ] . interval = freq ; values . items [ i ] . frequency = ( i + <int> ) * freq ; } } public T value ( float probability ) { CumulativeValue value = null ; int imax = values . size - <int> , imin = <int> , imid ; while ( imin < = imax ) { imid = imin + ( ( imax - imin ) / <int> ) ; value = values . items [ imid ] ; if ( probability < value . frequency ) imax = imid - <int> ; else if ( probability > value . frequency ) imin = imid + <int> ; else break ; } return values . items [ imin ] . value ; } public T value ( ) { return value ( MathUtils . random ( ) ) ; } public int size ( ) { return values . size ; } public float getInterval ( int index ) { return values . items [ index ] . interval ; } public T getValue ( int index ) { return values . items [ index ] . value ; } public void setInterval ( T obj , float intervalSize ) { for ( CumulativeValue value : values ) if ( value . value = = obj ) { value . interval = intervalSize ; return ; } } public void setInterval ( int index , float intervalSize ) { values . items [ index ] . interval = intervalSize ; } public void clear ( ) { values . clear ( ) ; } } 
