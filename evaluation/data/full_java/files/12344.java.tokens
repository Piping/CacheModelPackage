package org . gradle . util ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . apache . commons . lang . StringUtils ; public class NameMatcher { private final SortedSet < String > matches = new TreeSet < String > ( ) ; private final Set < String > candidates = new TreeSet < String > ( ) ; private String pattern ; public < T > T find ( String pattern , Map < String , ? extends T > items ) { String name = find ( pattern , items . keySet ( ) ) ; if ( name ! = null ) { return items . get ( name ) ; } return null ; } public String find ( String pattern , Collection < String > items ) { this . pattern = pattern ; matches . clear ( ) ; candidates . clear ( ) ; if ( items . contains ( pattern ) ) { matches . add ( pattern ) ; return pattern ; } if ( pattern . length ( ) = = <int> ) { return null ; } Pattern camelCasePattern = getPatternForName ( pattern ) ; Pattern normalisedCamelCasePattern = Pattern . compile ( camelCasePattern . pattern ( ) , Pattern . CASE_INSENSITIVE ) ; String normalisedPattern = pattern . toUpperCase ( ) ; Set < String > caseInsensitiveMatches = new TreeSet < String > ( ) ; Set < String > caseSensitiveCamelCaseMatches = new TreeSet < String > ( ) ; Set < String > caseInsensitiveCamelCaseMatches = new TreeSet < String > ( ) ; for ( String candidate : items ) { if ( candidate . equalsIgnoreCase ( pattern ) ) { caseInsensitiveMatches . add ( candidate ) ; } if ( camelCasePattern . matcher ( candidate ) . matches ( ) ) { caseSensitiveCamelCaseMatches . add ( candidate ) ; continue ; } if ( normalisedCamelCasePattern . matcher ( candidate ) . lookingAt ( ) ) { caseInsensitiveCamelCaseMatches . add ( candidate ) ; continue ; } if ( StringUtils . getLevenshteinDistance ( normalisedPattern , candidate . toUpperCase ( ) ) < = Math . min ( <int> , pattern . length ( ) / <int> ) ) { candidates . add ( candidate ) ; } } if ( ! caseInsensitiveMatches . isEmpty ( ) ) { matches . addAll ( caseInsensitiveMatches ) ; } else if ( ! caseSensitiveCamelCaseMatches . isEmpty ( ) ) { matches . addAll ( caseSensitiveCamelCaseMatches ) ; } else { matches . addAll ( caseInsensitiveCamelCaseMatches ) ; } if ( matches . size ( ) = = <int> ) { return matches . first ( ) ; } return null ; } private static Pattern getPatternForName ( String name ) { Pattern boundaryPattern = Pattern . compile ( <str> ) ; Matcher matcher = boundaryPattern . matcher ( name ) ; int pos = <int> ; StringBuilder builder = new StringBuilder ( ) ; while ( matcher . find ( ) ) { String prefix = name . substring ( pos , matcher . start ( ) ) ; if ( prefix . length ( ) > <int> ) { builder . append ( Pattern . quote ( prefix ) ) ; } builder . append ( Pattern . quote ( matcher . group ( ) ) ) ; builder . append ( <str> ) ; pos = matcher . end ( ) ; } builder . append ( Pattern . quote ( name . substring ( pos , name . length ( ) ) ) ) ; return Pattern . compile ( builder . toString ( ) ) ; } public Set < String > getMatches ( ) { return matches ; } public Set < String > getCandidates ( ) { return candidates ; } public String formatErrorMessage ( String singularItemDescription , Object container ) { String capItem = StringUtils . capitalize ( singularItemDescription ) ; if ( ! matches . isEmpty ( ) ) { return String . format ( <str> , capItem , pattern , container , GUtil . toString ( matches ) ) ; } if ( ! candidates . isEmpty ( ) ) { return String . format ( <str> , capItem , pattern , container , GUtil . toString ( candidates ) ) ; } return String . format ( <str> , capItem , pattern , container ) ; } } 
