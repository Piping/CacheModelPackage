package com . google . common . net ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . escape . UnicodeEscaper ; @Beta @GwtCompatible public final class PercentEscaper extends UnicodeEscaper { private static final char [ ] PLUS_SIGN = { <str> } ; private static final char [ ] UPPER_HEX_DIGITS = <str> . toCharArray ( ) ; private final boolean plusForSpace ; private final boolean [ ] safeOctets ; public PercentEscaper ( String safeChars , boolean plusForSpace ) { checkNotNull ( safeChars ) ; if ( safeChars . matches ( <str> ) ) { throw new IllegalArgumentException ( <str> + <str> ) ; } safeChars + = <str> + <str> + <str> ; if ( plusForSpace & & safeChars . contains ( <str> ) ) { throw new IllegalArgumentException ( <str> ) ; } this . plusForSpace = plusForSpace ; this . safeOctets = createSafeOctets ( safeChars ) ; } private static boolean [ ] createSafeOctets ( String safeChars ) { int maxChar = - <int> ; char [ ] safeCharArray = safeChars . toCharArray ( ) ; for ( char c : safeCharArray ) { maxChar = Math . max ( c , maxChar ) ; } boolean [ ] octets = new boolean [ maxChar + <int> ] ; for ( char c : safeCharArray ) { octets [ c ] = true ; } return octets ; } @Override protected int nextEscapeIndex ( CharSequence csq , int index , int end ) { checkNotNull ( csq ) ; for ( ; index < end ; index + + ) { char c = csq . charAt ( index ) ; if ( c > = safeOctets . length | | ! safeOctets [ c ] ) { break ; } } return index ; } @Override public String escape ( String s ) { checkNotNull ( s ) ; int slen = s . length ( ) ; for ( int index = <int> ; index < slen ; index + + ) { char c = s . charAt ( index ) ; if ( c > = safeOctets . length | | ! safeOctets [ c ] ) { return escapeSlow ( s , index ) ; } } return s ; } @Override protected char [ ] escape ( int cp ) { if ( cp < safeOctets . length & & safeOctets [ cp ] ) { return null ; } else if ( cp = = <str> & & plusForSpace ) { return PLUS_SIGN ; } else if ( cp < = <hex> ) { char [ ] dest = new char [ <int> ] ; dest [ <int> ] = <str> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp > > > <int> ] ; return dest ; } else if ( cp < = <hex> ) { char [ ] dest = new char [ <int> ] ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | cp ] ; return dest ; } else if ( cp < = <hex> ) { char [ ] dest = new char [ <int> ] ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp ] ; return dest ; } else if ( cp < = <hex> ) { char [ ] dest = new char [ <int> ] ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = <str> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ <hex> | ( cp & <hex> ) ] ; cp > > > = <int> ; dest [ <int> ] = UPPER_HEX_DIGITS [ cp & <hex> ] ; return dest ; } else { throw new IllegalArgumentException ( <str> + cp ) ; } } } 
