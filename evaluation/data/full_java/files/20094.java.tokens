package io . netty . microbench . buffer ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . PooledByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . microbench . util . AbstractMicrobenchmark ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . annotations . TearDown ; import java . nio . ByteBuffer ; public class ByteBufBenchmark extends AbstractMicrobenchmark { static { System . setProperty ( <str> , <str> ) ; } private static final byte BYTE = <str> ; private ByteBuffer byteBuffer ; private ByteBuffer directByteBuffer ; private ByteBuf buffer ; private ByteBuf directBuffer ; private ByteBuf directBufferPooled ; @Setup public void setup ( ) { byteBuffer = ByteBuffer . allocate ( <int> ) ; directByteBuffer = ByteBuffer . allocateDirect ( <int> ) ; buffer = Unpooled . buffer ( <int> ) ; directBuffer = Unpooled . directBuffer ( <int> ) ; directBufferPooled = PooledByteBufAllocator . DEFAULT . directBuffer ( <int> ) ; } @TearDown public void tearDown ( ) { buffer . release ( ) ; directBuffer . release ( ) ; directBufferPooled . release ( ) ; } @Benchmark public void setByteBufferHeap ( ) { byteBuffer . put ( <int> , BYTE ) ; } @Benchmark public void setByteBufferDirect ( ) { directByteBuffer . put ( <int> , BYTE ) ; } @Benchmark public void setByteBufHeap ( ) { buffer . setByte ( <int> , BYTE ) ; } @Benchmark public void setByteBufDirect ( ) { directBuffer . setByte ( <int> , BYTE ) ; } @Benchmark public void setByteBufDirectPooled ( ) { directBufferPooled . setByte ( <int> , BYTE ) ; } } 
