package clojure . lang ; import java . io . Serializable ; import java . nio . ByteBuffer ; public final class Murmur3 { private static final int seed = <int> ; private static final int C1 = <hex> ; private static final int C2 = <hex> ; public static int hashInt ( int input ) { if ( input = = <int> ) return <int> ; int k1 = mixK1 ( input ) ; int h1 = mixH1 ( seed , k1 ) ; return fmix ( h1 , <int> ) ; } public static int hashLong ( long input ) { if ( input = = <int> ) return <int> ; int low = ( int ) input ; int high = ( int ) ( input > > > <int> ) ; int k1 = mixK1 ( low ) ; int h1 = mixH1 ( seed , k1 ) ; k1 = mixK1 ( high ) ; h1 = mixH1 ( h1 , k1 ) ; return fmix ( h1 , <int> ) ; } public static int hashUnencodedChars ( CharSequence input ) { int h1 = seed ; for ( int i = <int> ; i < input . length ( ) ; i + = <int> ) { int k1 = input . charAt ( i - <int> ) | ( input . charAt ( i ) < < <int> ) ; k1 = mixK1 ( k1 ) ; h1 = mixH1 ( h1 , k1 ) ; } if ( ( input . length ( ) & <int> ) = = <int> ) { int k1 = input . charAt ( input . length ( ) - <int> ) ; k1 = mixK1 ( k1 ) ; h1 ^ = k1 ; } return fmix ( h1 , <int> * input . length ( ) ) ; } public static int mixCollHash ( int hash , int count ) { int h1 = seed ; int k1 = mixK1 ( hash ) ; h1 = mixH1 ( h1 , k1 ) ; return fmix ( h1 , count ) ; } public static int hashOrdered ( Iterable xs ) { int n = <int> ; int hash = <int> ; for ( Object x : xs ) { hash = <int> * hash + Util . hasheq ( x ) ; + + n ; } return mixCollHash ( hash , n ) ; } public static int hashUnordered ( Iterable xs ) { int hash = <int> ; int n = <int> ; for ( Object x : xs ) { hash + = Util . hasheq ( x ) ; + + n ; } return mixCollHash ( hash , n ) ; } private static int mixK1 ( int k1 ) { k1 * = C1 ; k1 = Integer . rotateLeft ( k1 , <int> ) ; k1 * = C2 ; return k1 ; } private static int mixH1 ( int h1 , int k1 ) { h1 ^ = k1 ; h1 = Integer . rotateLeft ( h1 , <int> ) ; h1 = h1 * <int> + <hex> ; return h1 ; } private static int fmix ( int h1 , int length ) { h1 ^ = length ; h1 ^ = h1 > > > <int> ; h1 * = <hex> ; h1 ^ = h1 > > > <int> ; h1 * = <hex> ; h1 ^ = h1 > > > <int> ; return h1 ; } } 
