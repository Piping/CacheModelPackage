package org . elasticsearch . common . util ; import com . carrotsearch . hppc . DoubleArrayList ; import com . carrotsearch . hppc . FloatArrayList ; import com . carrotsearch . hppc . LongArrayList ; import com . carrotsearch . hppc . ObjectArrayList ; import org . apache . lucene . util . * ; import java . util . * ; public class CollectionUtils { public static void sort ( LongArrayList list ) { sort ( list . buffer , list . size ( ) ) ; } public static void sort ( final long [ ] array , int len ) { new IntroSorter ( ) { long pivot ; @Override protected void swap ( int i , int j ) { final long tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; } @Override protected int compare ( int i , int j ) { return Long . compare ( array [ i ] , array [ j ] ) ; } @Override protected void setPivot ( int i ) { pivot = array [ i ] ; } @Override protected int comparePivot ( int j ) { return Long . compare ( pivot , array [ j ] ) ; } } . sort ( <int> , len ) ; } public static void sortAndDedup ( LongArrayList list ) { list . elementsCount = sortAndDedup ( list . buffer , list . elementsCount ) ; } public static int sortAndDedup ( long [ ] array , int len ) { if ( len < = <int> ) { return len ; } sort ( array , len ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < len ; + + i ) { if ( array [ i ] ! = array [ i - <int> ] ) { array [ uniqueCount + + ] = array [ i ] ; } } return uniqueCount ; } public static void sort ( FloatArrayList list ) { sort ( list . buffer , list . size ( ) ) ; } public static void sort ( final float [ ] array , int len ) { new IntroSorter ( ) { float pivot ; @Override protected void swap ( int i , int j ) { final float tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; } @Override protected int compare ( int i , int j ) { return Float . compare ( array [ i ] , array [ j ] ) ; } @Override protected void setPivot ( int i ) { pivot = array [ i ] ; } @Override protected int comparePivot ( int j ) { return Float . compare ( pivot , array [ j ] ) ; } } . sort ( <int> , len ) ; } public static void sortAndDedup ( FloatArrayList list ) { list . elementsCount = sortAndDedup ( list . buffer , list . elementsCount ) ; } public static int sortAndDedup ( float [ ] array , int len ) { if ( len < = <int> ) { return len ; } sort ( array , len ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < len ; + + i ) { if ( Float . compare ( array [ i ] , array [ i - <int> ] ) ! = <int> ) { array [ uniqueCount + + ] = array [ i ] ; } } return uniqueCount ; } public static void sort ( DoubleArrayList list ) { sort ( list . buffer , list . size ( ) ) ; } public static void sort ( final double [ ] array , int len ) { new IntroSorter ( ) { double pivot ; @Override protected void swap ( int i , int j ) { final double tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; } @Override protected int compare ( int i , int j ) { return Double . compare ( array [ i ] , array [ j ] ) ; } @Override protected void setPivot ( int i ) { pivot = array [ i ] ; } @Override protected int comparePivot ( int j ) { return Double . compare ( pivot , array [ j ] ) ; } } . sort ( <int> , len ) ; } public static void sortAndDedup ( DoubleArrayList list ) { list . elementsCount = sortAndDedup ( list . buffer , list . elementsCount ) ; } public static int sortAndDedup ( double [ ] array , int len ) { if ( len < = <int> ) { return len ; } sort ( array , len ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < len ; + + i ) { if ( Double . compare ( array [ i ] , array [ i - <int> ] ) ! = <int> ) { array [ uniqueCount + + ] = array [ i ] ; } } return uniqueCount ; } public static boolean isEmpty ( Object [ ] array ) { return array = = null | | array . length = = <int> ; } public static < T > List < T > rotate ( final List < T > list , int distance ) { if ( list . isEmpty ( ) ) { return list ; } int d = distance % list . size ( ) ; if ( d < <int> ) { d + = list . size ( ) ; } if ( d = = <int> ) { return list ; } return new RotatedList < > ( list , d ) ; } public static void sortAndDedup ( final ObjectArrayList < byte [ ] > array ) { int len = array . size ( ) ; if ( len > <int> ) { sort ( array ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < len ; + + i ) { if ( ! Arrays . equals ( array . get ( i ) , array . get ( i - <int> ) ) ) { array . set ( uniqueCount + + , array . get ( i ) ) ; } } array . elementsCount = uniqueCount ; } } public static void sort ( final ObjectArrayList < byte [ ] > array ) { new IntroSorter ( ) { byte [ ] pivot ; @Override protected void swap ( int i , int j ) { final byte [ ] tmp = array . get ( i ) ; array . set ( i , array . get ( j ) ) ; array . set ( j , tmp ) ; } @Override protected int compare ( int i , int j ) { return compare ( array . get ( i ) , array . get ( j ) ) ; } @Override protected void setPivot ( int i ) { pivot = array . get ( i ) ; } @Override protected int comparePivot ( int j ) { return compare ( pivot , array . get ( j ) ) ; } private int compare ( byte [ ] left , byte [ ] right ) { for ( int i = <int> , j = <int> ; i < left . length & & j < right . length ; i + + , j + + ) { int a = left [ i ] & <hex> ; int b = right [ j ] & <hex> ; if ( a ! = b ) { return a - b ; } } return left . length - right . length ; } } . sort ( <int> , array . size ( ) ) ; } public static int [ ] toArray ( Collection < Integer > ints ) { Objects . requireNonNull ( ints ) ; return ints . stream ( ) . mapToInt ( s - > s ) . toArray ( ) ; } private static class RotatedList < T > extends AbstractList < T > implements RandomAccess { private final List < T > in ; private final int distance ; public RotatedList ( List < T > list , int distance ) { if ( distance < <int> | | distance > = list . size ( ) ) { throw new IllegalArgumentException ( ) ; } if ( ! ( list instanceof RandomAccess ) ) { throw new IllegalArgumentException ( ) ; } this . in = list ; this . distance = distance ; } @Override public T get ( int index ) { int idx = distance + index ; if ( idx < <int> | | idx > = in . size ( ) ) { idx - = in . size ( ) ; } return in . get ( idx ) ; } @Override public int size ( ) { return in . size ( ) ; } } ; public static void sort ( final BytesRefArray bytes , final int [ ] indices ) { sort ( new BytesRefBuilder ( ) , new BytesRefBuilder ( ) , bytes , indices ) ; } private static void sort ( final BytesRefBuilder scratch , final BytesRefBuilder scratch1 , final BytesRefArray bytes , final int [ ] indices ) { final int numValues = bytes . size ( ) ; assert indices . length > = numValues ; if ( numValues > <int> ) { new InPlaceMergeSorter ( ) { final Comparator < BytesRef > comparator = BytesRef . getUTF8SortedAsUnicodeComparator ( ) ; @Override protected int compare ( int i , int j ) { return comparator . compare ( bytes . get ( scratch , indices [ i ] ) , bytes . get ( scratch1 , indices [ j ] ) ) ; } @Override protected void swap ( int i , int j ) { int value_i = indices [ i ] ; indices [ i ] = indices [ j ] ; indices [ j ] = value_i ; } } . sort ( <int> , numValues ) ; } } public static int sortAndDedup ( final BytesRefArray bytes , final int [ ] indices ) { final BytesRefBuilder scratch = new BytesRefBuilder ( ) ; final BytesRefBuilder scratch1 = new BytesRefBuilder ( ) ; final int numValues = bytes . size ( ) ; assert indices . length > = numValues ; if ( numValues < = <int> ) { return numValues ; } sort ( scratch , scratch1 , bytes , indices ) ; int uniqueCount = <int> ; BytesRefBuilder previous = scratch ; BytesRefBuilder current = scratch1 ; bytes . get ( previous , indices [ <int> ] ) ; for ( int i = <int> ; i < numValues ; + + i ) { bytes . get ( current , indices [ i ] ) ; if ( ! previous . get ( ) . equals ( current . get ( ) ) ) { indices [ uniqueCount + + ] = indices [ i ] ; } BytesRefBuilder tmp = previous ; previous = current ; current = tmp ; } return uniqueCount ; } public static < E > ArrayList < E > iterableAsArrayList ( Iterable < ? extends E > elements ) { if ( elements = = null ) { throw new NullPointerException ( <str> ) ; } if ( elements instanceof Collection ) { return new ArrayList < > ( ( Collection ) elements ) ; } else { ArrayList < E > list = new ArrayList < > ( ) ; for ( E element : elements ) { list . add ( element ) ; } return list ; } } public static < E > ArrayList < E > arrayAsArrayList ( E . . . elements ) { if ( elements = = null ) { throw new NullPointerException ( <str> ) ; } return new ArrayList < > ( Arrays . asList ( elements ) ) ; } public static < E > ArrayList < E > asArrayList ( E first , E . . . other ) { if ( other = = null ) { throw new NullPointerException ( <str> ) ; } ArrayList < E > list = new ArrayList < > ( <int> + other . length ) ; list . add ( first ) ; list . addAll ( Arrays . asList ( other ) ) ; return list ; } public static < E > ArrayList < E > asArrayList ( E first , E second , E . . . other ) { if ( other = = null ) { throw new NullPointerException ( <str> ) ; } ArrayList < E > list = new ArrayList < > ( <int> + <int> + other . length ) ; list . add ( first ) ; list . add ( second ) ; list . addAll ( Arrays . asList ( other ) ) ; return list ; } public static < E > ArrayList < E > newSingletonArrayList ( E element ) { return new ArrayList < > ( Collections . singletonList ( element ) ) ; } public static < E > LinkedList < E > newLinkedList ( Iterable < E > elements ) { if ( elements = = null ) { throw new NullPointerException ( <str> ) ; } LinkedList < E > linkedList = new LinkedList < > ( ) ; for ( E element : elements ) { linkedList . add ( element ) ; } return linkedList ; } public static < E > List < List < E > > eagerPartition ( List < E > list , int size ) { if ( list = = null ) { throw new NullPointerException ( <str> ) ; } if ( size < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } List < List < E > > result = new ArrayList < > ( ( int ) Math . ceil ( list . size ( ) / size ) ) ; List < E > accumulator = new ArrayList < > ( size ) ; int count = <int> ; for ( E element : list ) { if ( count = = size ) { result . add ( accumulator ) ; accumulator = new ArrayList < > ( size ) ; count = <int> ; } accumulator . add ( element ) ; count + + ; } if ( count > <int> ) { result . add ( accumulator ) ; } return result ; } } 
