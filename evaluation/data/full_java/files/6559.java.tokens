package org . elasticsearch . index . mapper . core ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . PositionIncrementAttribute ; import org . apache . lucene . document . Field ; import org . elasticsearch . common . Explicit ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . analysis . NumericIntegerAnalyzer ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . StringFieldMapper . ValueAndBoost ; import java . io . IOException ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . apache . lucene . index . IndexOptions . NONE ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeIntegerValue ; import static org . elasticsearch . index . mapper . MapperBuilders . tokenCountField ; import static org . elasticsearch . index . mapper . core . TypeParsers . parseNumberField ; public class TokenCountFieldMapper extends IntegerFieldMapper { public static final String CONTENT_TYPE = <str> ; public static class Defaults extends IntegerFieldMapper . Defaults { } public static class Builder extends NumberFieldMapper . Builder < Builder , TokenCountFieldMapper > { private NamedAnalyzer analyzer ; public Builder ( String name ) { super ( name , Defaults . FIELD_TYPE , Defaults . PRECISION_STEP_32_BIT ) ; builder = this ; } public Builder analyzer ( NamedAnalyzer analyzer ) { this . analyzer = analyzer ; return this ; } public NamedAnalyzer analyzer ( ) { return analyzer ; } @Override public TokenCountFieldMapper build ( BuilderContext context ) { setupFieldType ( context ) ; TokenCountFieldMapper fieldMapper = new TokenCountFieldMapper ( name , fieldType , defaultFieldType , ignoreMalformed ( context ) , coerce ( context ) , context . indexSettings ( ) , analyzer , multiFieldsBuilder . build ( this , context ) , copyTo ) ; fieldMapper . includeInAll ( includeInAll ) ; return fieldMapper ; } @Override protected NamedAnalyzer makeNumberAnalyzer ( int precisionStep ) { return NumericIntegerAnalyzer . buildNamedAnalyzer ( precisionStep ) ; } @Override protected int maxPrecisionStep ( ) { return <int> ; } } public static class TypeParser implements Mapper . TypeParser { @Override @SuppressWarnings ( <str> ) public Mapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { TokenCountFieldMapper . Builder builder = tokenCountField ( name ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { builder . nullValue ( nodeIntegerValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { NamedAnalyzer analyzer = parserContext . analysisService ( ) . analyzer ( propNode . toString ( ) ) ; if ( analyzer = = null ) { throw new MapperParsingException ( <str> + propNode . toString ( ) + <str> + name + <str> ) ; } builder . analyzer ( analyzer ) ; iterator . remove ( ) ; } } parseNumberField ( builder , name , node , parserContext ) ; if ( builder . analyzer ( ) = = null ) { throw new MapperParsingException ( <str> + name + <str> ) ; } return builder ; } } private NamedAnalyzer analyzer ; protected TokenCountFieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Explicit < Boolean > ignoreMalformed , Explicit < Boolean > coerce , Settings indexSettings , NamedAnalyzer analyzer , MultiFields multiFields , CopyTo copyTo ) { super ( simpleName , fieldType , defaultFieldType , ignoreMalformed , coerce , indexSettings , multiFields , copyTo ) ; this . analyzer = analyzer ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException { ValueAndBoost valueAndBoost = StringFieldMapper . parseCreateFieldForString ( context , null , fieldType ( ) . boost ( ) ) ; if ( valueAndBoost . value ( ) = = null & & fieldType ( ) . nullValue ( ) = = null ) { return ; } if ( fieldType ( ) . indexOptions ( ) ! = NONE | | fieldType ( ) . stored ( ) | | fieldType ( ) . hasDocValues ( ) ) { int count ; if ( valueAndBoost . value ( ) = = null ) { count = fieldType ( ) . nullValue ( ) ; } else { count = countPositions ( analyzer , simpleName ( ) , valueAndBoost . value ( ) ) ; } addIntegerFields ( context , fields , count , valueAndBoost . boost ( ) ) ; } if ( fields . isEmpty ( ) ) { context . ignoredValue ( fieldType ( ) . names ( ) . indexName ( ) , valueAndBoost . value ( ) ) ; } } static int countPositions ( Analyzer analyzer , String fieldName , String fieldValue ) throws IOException { try ( TokenStream tokenStream = analyzer . tokenStream ( fieldName , fieldValue ) ) { int count = <int> ; PositionIncrementAttribute position = tokenStream . addAttribute ( PositionIncrementAttribute . class ) ; tokenStream . reset ( ) ; while ( tokenStream . incrementToken ( ) ) { count + = position . getPositionIncrement ( ) ; } tokenStream . end ( ) ; count + = position . getPositionIncrement ( ) ; return count ; } } public String analyzer ( ) { return analyzer . name ( ) ; } @Override protected String contentType ( ) { return CONTENT_TYPE ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { super . merge ( mergeWith , mergeResult ) ; if ( ! this . getClass ( ) . equals ( mergeWith . getClass ( ) ) ) { return ; } if ( ! mergeResult . simulate ( ) ) { this . analyzer = ( ( TokenCountFieldMapper ) mergeWith ) . analyzer ; } } @Override protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { super . doXContentBody ( builder , includeDefaults , params ) ; builder . field ( <str> , analyzer ( ) ) ; } @Override public boolean isGenerated ( ) { return true ; } } 
