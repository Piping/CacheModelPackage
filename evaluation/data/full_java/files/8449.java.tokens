package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . filter . Filter ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . nested . Nested ; import org . elasticsearch . search . aggregations . bucket . terms . LongTerms ; import org . elasticsearch . search . aggregations . bucket . terms . StringTerms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Bucket ; import org . elasticsearch . search . aggregations . metrics . max . Max ; import org . elasticsearch . search . aggregations . metrics . stats . Stats ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . filter ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . nested ; import static org . elasticsearch . search . aggregations . AggregationBuilders . stats ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . sameInstance ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class NestedIT extends ESIntegTestCase { static int numParents ; static int [ ] numChildren ; static SubAggCollectionMode aggCollectionMode ; @Override public void setupSuiteScopeCluster ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; numParents = randomIntBetween ( <int> , <int> ) ; numChildren = new int [ numParents ] ; aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; logger . info ( <str> + aggCollectionMode ) ; int totalChildren = <int> ; for ( int i = <int> ; i < numParents ; + + i ) { if ( i = = numParents - <int> & & totalChildren = = <int> ) { numChildren [ i ] = randomIntBetween ( <int> , <int> ) ; } else { numChildren [ i ] = randomInt ( <int> ) ; } totalChildren + = numChildren [ i ] ; } assertTrue ( totalChildren > <int> ) ; for ( int i = <int> ; i < numParents ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . field ( <str> , i + <int> ) . startArray ( <str> ) ; for ( int j = <int> ; j < numChildren [ i ] ; + + j ) { source = source . startObject ( ) . field ( <str> , i + <int> + j ) . endObject ( ) ; } source = source . endArray ( ) . endObject ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i + <int> ) . setSource ( source ) ) ; } prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; ensureGreen ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i * <int> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , i + <int> ) . endObject ( ) . startObject ( ) . field ( <str> , i + <int> ) . endObject ( ) . startObject ( ) . field ( <str> , i + <int> ) . endObject ( ) . startObject ( ) . field ( <str> , i + <int> ) . endObject ( ) . startObject ( ) . field ( <str> , i + <int> ) . endObject ( ) . endArray ( ) . endObject ( ) ) ) ; } assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureGreen ( <str> ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) . endArray ( ) . endObject ( ) ) ) ; indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testSimple ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( stats ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; double min = Double . POSITIVE_INFINITY ; double max = Double . NEGATIVE_INFINITY ; long sum = <int> ; long count = <int> ; for ( int i = <int> ; i < numParents ; + + i ) { for ( int j = <int> ; j < numChildren [ i ] ; + + j ) { final long value = i + <int> + j ; min = Math . min ( min , value ) ; max = Math . max ( max , value ) ; sum + = value ; + + count ; } } Nested nested = response . getAggregations ( ) . get ( <str> ) ; assertThat ( nested , notNullValue ( ) ) ; assertThat ( nested . getName ( ) , equalTo ( <str> ) ) ; assertThat ( nested . getDocCount ( ) , equalTo ( count ) ) ; assertThat ( nested . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Stats stats = nested . getAggregations ( ) . get ( <str> ) ; assertThat ( stats , notNullValue ( ) ) ; assertThat ( stats . getMin ( ) , equalTo ( min ) ) ; assertThat ( stats . getMax ( ) , equalTo ( max ) ) ; assertThat ( stats . getCount ( ) , equalTo ( count ) ) ; assertThat ( stats . getSum ( ) , equalTo ( ( double ) sum ) ) ; assertThat ( stats . getAvg ( ) , equalTo ( ( double ) sum / count ) ) ; } public void testNonExistingNestedField ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( stats ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; Nested nested = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( nested , Matchers . notNullValue ( ) ) ; assertThat ( nested . getName ( ) , equalTo ( <str> ) ) ; assertThat ( nested . getDocCount ( ) , is ( <int> l ) ) ; } public void testNestedWithSubTermsAgg ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . size ( <int> ) . collectMode ( aggCollectionMode ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; long docCount = <int> ; long [ ] counts = new long [ numParents + <int> ] ; for ( int i = <int> ; i < numParents ; + + i ) { for ( int j = <int> ; j < numChildren [ i ] ; + + j ) { final int value = i + <int> + j ; + + counts [ value ] ; + + docCount ; } } int uniqueValues = <int> ; for ( long count : counts ) { if ( count > <int> ) { + + uniqueValues ; } } Nested nested = response . getAggregations ( ) . get ( <str> ) ; assertThat ( nested , notNullValue ( ) ) ; assertThat ( nested . getName ( ) , equalTo ( <str> ) ) ; assertThat ( nested . getDocCount ( ) , equalTo ( docCount ) ) ; assertThat ( ( long ) nested . getProperty ( <str> ) , equalTo ( docCount ) ) ; assertThat ( nested . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; LongTerms values = nested . getAggregations ( ) . get ( <str> ) ; assertThat ( values , notNullValue ( ) ) ; assertThat ( values . getName ( ) , equalTo ( <str> ) ) ; assertThat ( values . getBuckets ( ) , notNullValue ( ) ) ; assertThat ( values . getBuckets ( ) . size ( ) , equalTo ( uniqueValues ) ) ; for ( int i = <int> ; i < counts . length ; + + i ) { final String key = Long . toString ( i ) ; if ( counts [ i ] = = <int> ) { assertNull ( values . getBucketByKey ( key ) ) ; } else { Bucket bucket = values . getBucketByKey ( key ) ; assertNotNull ( bucket ) ; assertEquals ( counts [ i ] , bucket . getDocCount ( ) ) ; } } assertThat ( ( LongTerms ) nested . getProperty ( <str> ) , sameInstance ( values ) ) ; } public void testNestedAsSubAggregation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . size ( <int> ) . collectMode ( aggCollectionMode ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( max ( <str> ) . field ( <str> ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; LongTerms values = response . getAggregations ( ) . get ( <str> ) ; assertThat ( values , notNullValue ( ) ) ; assertThat ( values . getName ( ) , equalTo ( <str> ) ) ; assertThat ( values . getBuckets ( ) , notNullValue ( ) ) ; assertThat ( values . getBuckets ( ) . size ( ) , equalTo ( numParents ) ) ; for ( int i = <int> ; i < numParents ; i + + ) { String topValue = <str> + ( i + <int> ) ; assertThat ( values . getBucketByKey ( topValue ) , notNullValue ( ) ) ; Nested nested = values . getBucketByKey ( topValue ) . getAggregations ( ) . get ( <str> ) ; assertThat ( nested , notNullValue ( ) ) ; Max max = nested . getAggregations ( ) . get ( <str> ) ; assertThat ( max , notNullValue ( ) ) ; assertThat ( max . getValue ( ) , equalTo ( numChildren [ i ] = = <int> ? Double . NEGATIVE_INFINITY : ( double ) i + numChildren [ i ] ) ) ; } } public void testNestNestedAggs ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( sum ( <str> ) . field ( <str> ) ) ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Nested level1 = response . getAggregations ( ) . get ( <str> ) ; assertThat ( level1 , notNullValue ( ) ) ; assertThat ( level1 . getName ( ) , equalTo ( <str> ) ) ; assertThat ( level1 . getDocCount ( ) , equalTo ( <int> ) ) ; StringTerms a = level1 . getAggregations ( ) . get ( <str> ) ; Terms . Bucket bBucket = a . getBucketByKey ( <str> ) ; assertThat ( bBucket . getDocCount ( ) , equalTo ( <int> ) ) ; Nested level2 = bBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( level2 . getDocCount ( ) , equalTo ( <int> ) ) ; Sum sum = level2 . getAggregations ( ) . get ( <str> ) ; assertThat ( sum . getValue ( ) , equalTo ( <float> ) ) ; a = level1 . getAggregations ( ) . get ( <str> ) ; bBucket = a . getBucketByKey ( <str> ) ; assertThat ( bBucket . getDocCount ( ) , equalTo ( <int> ) ) ; level2 = bBucket . getAggregations ( ) . get ( <str> ) ; assertThat ( level2 . getDocCount ( ) , equalTo ( <int> ) ) ; sum = level2 . getAggregations ( ) . get ( <str> ) ; assertThat ( sum . getValue ( ) , equalTo ( <float> ) ) ; } public void testEmptyAggregation ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( <int> ) . minDocCount ( <int> ) . subAggregation ( nested ( <str> ) . path ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; Histogram histo = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , Matchers . notNullValue ( ) ) ; Histogram . Bucket bucket = histo . getBuckets ( ) . get ( <int> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; Nested nested = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( nested , Matchers . notNullValue ( ) ) ; assertThat ( nested . getName ( ) , equalTo ( <str> ) ) ; assertThat ( nested . getDocCount ( ) , is ( <int> l ) ) ; } public void testNestedOnObjectField ( ) throws Exception { try { client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( nested ( <str> ) . path ( <str> ) ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . toString ( ) , containsString ( <str> ) ) ; } } public void testParentFilterResolvedCorrectly ( ) throws Exception { XContentBuilder mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) . addMapping ( <str> , mapping ) ) ; ensureGreen ( <str> ) ; List < IndexRequestBuilder > indexRequests = new ArrayList < > ( <int> ) ; indexRequests . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> ) ) ; indexRequests . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> ) ) ; indexRandom ( true , indexRequests ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( filter ( <str> ) . filter ( termQuery ( <str> , <str> ) ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) ) ) ) ) ) ) ) . get ( ) ; assertNoFailures ( response ) ; assertHitCount ( response , <int> ) ; Terms startDate = response . getAggregations ( ) . get ( <str> ) ; assertThat ( startDate . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Terms . Bucket bucket = startDate . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Terms endDate = bucket . getAggregations ( ) . get ( <str> ) ; bucket = endDate . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Terms period = bucket . getAggregations ( ) . get ( <str> ) ; bucket = period . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Nested comments = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( comments . getDocCount ( ) , equalTo ( <int> ) ) ; Filter filter = comments . getAggregations ( ) . get ( <str> ) ; assertThat ( filter . getDocCount ( ) , equalTo ( <int> ) ) ; Nested nestedTags = filter . getAggregations ( ) . get ( <str> ) ; assertThat ( nestedTags . getDocCount ( ) , equalTo ( <int> l ) ) ; Terms tags = nestedTags . getAggregations ( ) . get ( <str> ) ; assertThat ( tags . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; bucket = startDate . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; endDate = bucket . getAggregations ( ) . get ( <str> ) ; bucket = endDate . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; period = bucket . getAggregations ( ) . get ( <str> ) ; bucket = period . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; comments = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( comments . getDocCount ( ) , equalTo ( <int> ) ) ; filter = comments . getAggregations ( ) . get ( <str> ) ; assertThat ( filter . getDocCount ( ) , equalTo ( <int> ) ) ; nestedTags = filter . getAggregations ( ) . get ( <str> ) ; assertThat ( nestedTags . getDocCount ( ) , equalTo ( <int> l ) ) ; tags = nestedTags . getAggregations ( ) . get ( <str> ) ; assertThat ( tags . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testNestedSameDocIdProcessedMultipleTime ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( SETTING_NUMBER_OF_SHARDS , <int> ) . put ( SETTING_NUMBER_OF_REPLICAS , <int> ) ) . addMapping ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> , <str> , <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) ) . get ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) ) . get ( ) ; refresh ( ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) ) ) ) . get ( ) ; assertNoFailures ( response ) ; assertHitCount ( response , <int> ) ; Terms category = response . getAggregations ( ) . get ( <str> ) ; assertThat ( category . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Terms . Bucket bucket = category . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Nested property = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( property . getDocCount ( ) , equalTo ( <int> ) ) ; Terms propertyId = property . getAggregations ( ) . get ( <str> ) ; assertThat ( propertyId . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; bucket = category . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; property = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( property . getDocCount ( ) , equalTo ( <int> ) ) ; propertyId = property . getAggregations ( ) . get ( <str> ) ; assertThat ( propertyId . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; bucket = category . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; property = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( property . getDocCount ( ) , equalTo ( <int> ) ) ; propertyId = property . getAggregations ( ) . get ( <str> ) ; assertThat ( propertyId . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; bucket = category . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; property = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( property . getDocCount ( ) , equalTo ( <int> ) ) ; propertyId = property . getAggregations ( ) . get ( <str> ) ; assertThat ( propertyId . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( propertyId . getBucketByKey ( <str> ) . getDocCount ( ) , equalTo ( <int> ) ) ; } } 
