package org . apache . cassandra . service ; import java . io . IOException ; import java . net . InetAddress ; import java . util . Arrays ; import java . util . Collections ; import java . util . UUID ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . AbstractSerializationsTester ; import org . apache . cassandra . Util ; import org . apache . cassandra . Util . PartitionerSwitcher ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . util . DataInputPlus . DataInputStreamPlus ; import org . apache . cassandra . io . util . DataOutputStreamPlus ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . repair . NodePair ; import org . apache . cassandra . repair . RepairJobDesc ; import org . apache . cassandra . repair . Validator ; import org . apache . cassandra . repair . messages . * ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . MerkleTrees ; public class SerializationsTest extends AbstractSerializationsTester { private static PartitionerSwitcher partitionerSwitcher ; private static UUID RANDOM_UUID ; private static Range < Token > FULL_RANGE ; private static RepairJobDesc DESC ; @BeforeClass public static void defineSchema ( ) throws Exception { partitionerSwitcher = Util . switchPartitioner ( RandomPartitioner . instance ) ; RANDOM_UUID = UUID . fromString ( <str> ) ; FULL_RANGE = new Range < > ( Util . testPartitioner ( ) . getMinimumToken ( ) , Util . testPartitioner ( ) . getMinimumToken ( ) ) ; DESC = new RepairJobDesc ( getVersion ( ) < MessagingService . VERSION_21 ? null : RANDOM_UUID , RANDOM_UUID , <str> , <str> , Arrays . asList ( FULL_RANGE ) ) ; } @AfterClass public static void tearDown ( ) { partitionerSwitcher . close ( ) ; } private void testRepairMessageWrite ( String fileName , RepairMessage . . . messages ) throws IOException { try ( DataOutputStreamPlus out = getOutput ( fileName ) ) { for ( RepairMessage message : messages ) { testSerializedSize ( message , RepairMessage . serializer ) ; RepairMessage . serializer . serialize ( message , out , getVersion ( ) ) ; } for ( RepairMessage message : messages ) message . createMessage ( ) . serialize ( out , getVersion ( ) ) ; } } private void testValidationRequestWrite ( ) throws IOException { ValidationRequest message = new ValidationRequest ( DESC , <int> ) ; testRepairMessageWrite ( <str> , message ) ; } @Test public void testValidationRequestRead ( ) throws IOException { if ( EXECUTE_WRITES ) testValidationRequestWrite ( ) ; try ( DataInputStreamPlus in = getInput ( <str> ) ) { RepairMessage message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . VALIDATION_REQUEST ; assert DESC . equals ( message . desc ) ; assert ( ( ValidationRequest ) message ) . gcBefore = = <int> ; assert MessageIn . read ( in , getVersion ( ) , - <int> ) ! = null ; } } private void testValidationCompleteWrite ( ) throws IOException { IPartitioner p = RandomPartitioner . instance ; MerkleTrees mt = new MerkleTrees ( p ) ; mt . addMerkleTree ( ( int ) Math . pow ( <int> , <int> ) , FULL_RANGE ) ; Validator v0 = new Validator ( DESC , FBUtilities . getBroadcastAddress ( ) , - <int> ) ; ValidationComplete c0 = new ValidationComplete ( DESC , mt ) ; mt = new MerkleTrees ( p ) ; mt . addMerkleTree ( Integer . MAX_VALUE , FULL_RANGE ) ; for ( int i = <int> ; i < <int> ; i + + ) mt . split ( p . getRandomToken ( ) ) ; Validator v1 = new Validator ( DESC , FBUtilities . getBroadcastAddress ( ) , - <int> ) ; ValidationComplete c1 = new ValidationComplete ( DESC , mt ) ; ValidationComplete c3 = new ValidationComplete ( DESC ) ; testRepairMessageWrite ( <str> , c0 , c1 , c3 ) ; } @Test public void testValidationCompleteRead ( ) throws IOException { if ( EXECUTE_WRITES ) testValidationCompleteWrite ( ) ; try ( DataInputStreamPlus in = getInput ( <str> ) ) { RepairMessage message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . VALIDATION_COMPLETE ; assert DESC . equals ( message . desc ) ; assert ( ( ValidationComplete ) message ) . success ( ) ; assert ( ( ValidationComplete ) message ) . trees ! = null ; message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . VALIDATION_COMPLETE ; assert DESC . equals ( message . desc ) ; assert ( ( ValidationComplete ) message ) . success ( ) ; assert ( ( ValidationComplete ) message ) . trees ! = null ; message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . VALIDATION_COMPLETE ; assert DESC . equals ( message . desc ) ; assert ! ( ( ValidationComplete ) message ) . success ( ) ; assert ( ( ValidationComplete ) message ) . trees = = null ; for ( int i = <int> ; i < <int> ; i + + ) assert MessageIn . read ( in , getVersion ( ) , - <int> ) ! = null ; } } private void testSyncRequestWrite ( ) throws IOException { InetAddress local = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress src = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress dest = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; SyncRequest message = new SyncRequest ( DESC , local , src , dest , Collections . singleton ( FULL_RANGE ) ) ; testRepairMessageWrite ( <str> , message ) ; } @Test public void testSyncRequestRead ( ) throws IOException { if ( EXECUTE_WRITES ) testSyncRequestWrite ( ) ; InetAddress local = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress src = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress dest = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; try ( DataInputStreamPlus in = getInput ( <str> ) ) { RepairMessage message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . SYNC_REQUEST ; assert DESC . equals ( message . desc ) ; assert local . equals ( ( ( SyncRequest ) message ) . initiator ) ; assert src . equals ( ( ( SyncRequest ) message ) . src ) ; assert dest . equals ( ( ( SyncRequest ) message ) . dst ) ; assert ( ( SyncRequest ) message ) . ranges . size ( ) = = <int> & & ( ( SyncRequest ) message ) . ranges . contains ( FULL_RANGE ) ; assert MessageIn . read ( in , getVersion ( ) , - <int> ) ! = null ; } } private void testSyncCompleteWrite ( ) throws IOException { InetAddress src = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress dest = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; SyncComplete success = new SyncComplete ( DESC , src , dest , true ) ; SyncComplete fail = new SyncComplete ( DESC , src , dest , false ) ; testRepairMessageWrite ( <str> , success , fail ) ; } @Test public void testSyncCompleteRead ( ) throws IOException { if ( EXECUTE_WRITES ) testSyncCompleteWrite ( ) ; InetAddress src = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; InetAddress dest = InetAddress . getByAddress ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; NodePair nodes = new NodePair ( src , dest ) ; try ( DataInputStreamPlus in = getInput ( <str> ) ) { RepairMessage message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . SYNC_COMPLETE ; assert DESC . equals ( message . desc ) ; assert nodes . equals ( ( ( SyncComplete ) message ) . nodes ) ; assert ( ( SyncComplete ) message ) . success ; message = RepairMessage . serializer . deserialize ( in , getVersion ( ) ) ; assert message . messageType = = RepairMessage . Type . SYNC_COMPLETE ; assert DESC . equals ( message . desc ) ; assert nodes . equals ( ( ( SyncComplete ) message ) . nodes ) ; assert ! ( ( SyncComplete ) message ) . success ; for ( int i = <int> ; i < <int> ; i + + ) assert MessageIn . read ( in , getVersion ( ) , - <int> ) ! = null ; } } } 
