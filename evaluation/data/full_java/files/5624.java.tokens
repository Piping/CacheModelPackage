package org . elasticsearch . cluster . routing . allocation . decider ; import com . carrotsearch . hppc . ObjectIntHashMap ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . HashMap ; import java . util . Map ; public class AwarenessAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP = <str> ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { String [ ] awarenessAttributes = settings . getAsArray ( CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES , null ) ; if ( awarenessAttributes = = null & & <str> . equals ( settings . get ( CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES , null ) ) ) { awarenessAttributes = Strings . EMPTY_ARRAY ; } if ( awarenessAttributes ! = null ) { logger . info ( <str> , AwarenessAllocationDecider . this . awarenessAttributes , awarenessAttributes ) ; AwarenessAllocationDecider . this . awarenessAttributes = awarenessAttributes ; } Map < String , String [ ] > forcedAwarenessAttributes = new HashMap < > ( AwarenessAllocationDecider . this . forcedAwarenessAttributes ) ; Map < String , Settings > forceGroups = settings . getGroups ( CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP ) ; if ( ! forceGroups . isEmpty ( ) ) { for ( Map . Entry < String , Settings > entry : forceGroups . entrySet ( ) ) { String [ ] aValues = entry . getValue ( ) . getAsArray ( <str> ) ; if ( aValues . length > <int> ) { forcedAwarenessAttributes . put ( entry . getKey ( ) , aValues ) ; } } } AwarenessAllocationDecider . this . forcedAwarenessAttributes = forcedAwarenessAttributes ; } } private String [ ] awarenessAttributes ; private Map < String , String [ ] > forcedAwarenessAttributes ; public AwarenessAllocationDecider ( ) { this ( Settings . Builder . EMPTY_SETTINGS ) ; } public AwarenessAllocationDecider ( Settings settings ) { this ( settings , new NodeSettingsService ( settings ) ) ; } @Inject public AwarenessAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . awarenessAttributes = settings . getAsArray ( CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTES ) ; forcedAwarenessAttributes = new HashMap < > ( ) ; Map < String , Settings > forceGroups = settings . getGroups ( CLUSTER_ROUTING_ALLOCATION_AWARENESS_FORCE_GROUP ) ; for ( Map . Entry < String , Settings > entry : forceGroups . entrySet ( ) ) { String [ ] aValues = entry . getValue ( ) . getAsArray ( <str> ) ; if ( aValues . length > <int> ) { forcedAwarenessAttributes . put ( entry . getKey ( ) , aValues ) ; } } nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } public String [ ] awarenessAttributes ( ) { return this . awarenessAttributes ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return underCapacity ( shardRouting , node , allocation , true ) ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return underCapacity ( shardRouting , node , allocation , false ) ; } private Decision underCapacity ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation , boolean moveToNode ) { if ( awarenessAttributes . length = = <int> ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } IndexMetaData indexMetaData = allocation . metaData ( ) . index ( shardRouting . index ( ) ) ; int shardCount = indexMetaData . getNumberOfReplicas ( ) + <int> ; for ( String awarenessAttribute : awarenessAttributes ) { if ( ! node . node ( ) . attributes ( ) . containsKey ( awarenessAttribute ) ) { return allocation . decision ( Decision . NO , NAME , <str> , awarenessAttribute ) ; } ObjectIntHashMap < String > nodesPerAttribute = allocation . routingNodes ( ) . nodesPerAttributesCounts ( awarenessAttribute ) ; ObjectIntHashMap < String > shardPerAttribute = new ObjectIntHashMap < > ( ) ; for ( ShardRouting assignedShard : allocation . routingNodes ( ) . assignedShards ( shardRouting ) ) { if ( assignedShard . started ( ) | | assignedShard . initializing ( ) ) { RoutingNode routingNode = allocation . routingNodes ( ) . node ( assignedShard . currentNodeId ( ) ) ; shardPerAttribute . addTo ( routingNode . node ( ) . attributes ( ) . get ( awarenessAttribute ) , <int> ) ; } } if ( moveToNode ) { if ( shardRouting . assignedToNode ( ) ) { String nodeId = shardRouting . relocating ( ) ? shardRouting . relocatingNodeId ( ) : shardRouting . currentNodeId ( ) ; if ( ! node . nodeId ( ) . equals ( nodeId ) ) { shardPerAttribute . putOrAdd ( allocation . routingNodes ( ) . node ( nodeId ) . node ( ) . attributes ( ) . get ( awarenessAttribute ) , <int> , - <int> ) ; shardPerAttribute . addTo ( node . node ( ) . attributes ( ) . get ( awarenessAttribute ) , <int> ) ; } } else { shardPerAttribute . addTo ( node . node ( ) . attributes ( ) . get ( awarenessAttribute ) , <int> ) ; } } int numberOfAttributes = nodesPerAttribute . size ( ) ; String [ ] fullValues = forcedAwarenessAttributes . get ( awarenessAttribute ) ; if ( fullValues ! = null ) { for ( String fullValue : fullValues ) { if ( ! shardPerAttribute . containsKey ( fullValue ) ) { numberOfAttributes + + ; } } } int averagePerAttribute = shardCount / numberOfAttributes ; int totalLeftover = shardCount % numberOfAttributes ; int requiredCountPerAttribute ; if ( averagePerAttribute = = <int> ) { totalLeftover = <int> ; requiredCountPerAttribute = <int> ; } else { requiredCountPerAttribute = averagePerAttribute ; } int leftoverPerAttribute = totalLeftover = = <int> ? <int> : <int> ; int currentNodeCount = shardPerAttribute . get ( node . node ( ) . attributes ( ) . get ( awarenessAttribute ) ) ; if ( currentNodeCount > ( requiredCountPerAttribute + leftoverPerAttribute ) ) { return allocation . decision ( Decision . NO , NAME , <str> , awarenessAttribute , requiredCountPerAttribute , currentNodeCount , leftoverPerAttribute ) ; } if ( currentNodeCount < = requiredCountPerAttribute ) { continue ; } } return allocation . decision ( Decision . YES , NAME , <str> ) ; } } 
