package org . apache . cassandra . utils ; import java . io . * ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . Arrays ; import java . util . UUID ; import net . nicoulaj . compilecommand . annotations . Inline ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . io . util . FileUtils ; public class ByteBufferUtil { public static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer . wrap ( new byte [ <int> ] ) ; public static final ByteBuffer UNSET_BYTE_BUFFER = ByteBuffer . wrap ( new byte [ ] { } ) ; @Inline public static int compareUnsigned ( ByteBuffer o1 , ByteBuffer o2 ) { return FastByteOperations . compareUnsigned ( o1 , o2 ) ; } @Inline public static int compare ( byte [ ] o1 , ByteBuffer o2 ) { return FastByteOperations . compareUnsigned ( o1 , <int> , o1 . length , o2 ) ; } @Inline public static int compare ( ByteBuffer o1 , byte [ ] o2 ) { return FastByteOperations . compareUnsigned ( o1 , o2 , <int> , o2 . length ) ; } public static String string ( ByteBuffer buffer ) throws CharacterCodingException { return string ( buffer , StandardCharsets . UTF_8 ) ; } public static String string ( ByteBuffer buffer , int position , int length ) throws CharacterCodingException { return string ( buffer , position , length , StandardCharsets . UTF_8 ) ; } public static String string ( ByteBuffer buffer , int position , int length , Charset charset ) throws CharacterCodingException { ByteBuffer copy = buffer . duplicate ( ) ; copy . position ( position ) ; copy . limit ( copy . position ( ) + length ) ; return string ( copy , charset ) ; } public static String string ( ByteBuffer buffer , Charset charset ) throws CharacterCodingException { return charset . newDecoder ( ) . decode ( buffer . duplicate ( ) ) . toString ( ) ; } public static byte [ ] getArray ( ByteBuffer buffer ) { int length = buffer . remaining ( ) ; if ( buffer . hasArray ( ) ) { int boff = buffer . arrayOffset ( ) + buffer . position ( ) ; return Arrays . copyOfRange ( buffer . array ( ) , boff , boff + length ) ; } byte [ ] bytes = new byte [ length ] ; buffer . duplicate ( ) . get ( bytes ) ; return bytes ; } public static int lastIndexOf ( ByteBuffer buffer , byte valueToFind , int startIndex ) { assert buffer ! = null ; if ( startIndex < buffer . position ( ) ) { return - <int> ; } else if ( startIndex > = buffer . limit ( ) ) { startIndex = buffer . limit ( ) - <int> ; } for ( int i = startIndex ; i > = buffer . position ( ) ; i - - ) { if ( valueToFind = = buffer . get ( i ) ) return i ; } return - <int> ; } public static ByteBuffer bytes ( String s ) { return ByteBuffer . wrap ( s . getBytes ( StandardCharsets . UTF_8 ) ) ; } public static ByteBuffer bytes ( String s , Charset charset ) { return ByteBuffer . wrap ( s . getBytes ( charset ) ) ; } public static ByteBuffer clone ( ByteBuffer buffer ) { assert buffer ! = null ; if ( buffer . remaining ( ) = = <int> ) return EMPTY_BYTE_BUFFER ; ByteBuffer clone = ByteBuffer . allocate ( buffer . remaining ( ) ) ; if ( buffer . hasArray ( ) ) { System . arraycopy ( buffer . array ( ) , buffer . arrayOffset ( ) + buffer . position ( ) , clone . array ( ) , <int> , buffer . remaining ( ) ) ; } else { clone . put ( buffer . duplicate ( ) ) ; clone . flip ( ) ; } return clone ; } public static void arrayCopy ( ByteBuffer src , int srcPos , byte [ ] dst , int dstPos , int length ) { FastByteOperations . copy ( src , srcPos , dst , dstPos , length ) ; } public static void arrayCopy ( ByteBuffer src , int srcPos , ByteBuffer dst , int dstPos , int length ) { FastByteOperations . copy ( src , srcPos , dst , dstPos , length ) ; } public static int put ( ByteBuffer src , ByteBuffer trg ) { int length = Math . min ( src . remaining ( ) , trg . remaining ( ) ) ; arrayCopy ( src , src . position ( ) , trg , trg . position ( ) , length ) ; trg . position ( trg . position ( ) + length ) ; src . position ( src . position ( ) + length ) ; return length ; } public static void writeWithLength ( ByteBuffer bytes , DataOutputPlus out ) throws IOException { out . writeInt ( bytes . remaining ( ) ) ; out . write ( bytes ) ; } public static void writeWithVIntLength ( ByteBuffer bytes , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( bytes . remaining ( ) ) ; out . write ( bytes ) ; } public static void writeWithLength ( byte [ ] bytes , DataOutput out ) throws IOException { out . writeInt ( bytes . length ) ; out . write ( bytes ) ; } public static void writeWithShortLength ( ByteBuffer buffer , DataOutputPlus out ) throws IOException { int length = buffer . remaining ( ) ; assert <int> < = length & & length < = FBUtilities . MAX_UNSIGNED_SHORT : length ; out . writeShort ( length ) ; out . write ( buffer ) ; } public static void writeWithShortLength ( byte [ ] buffer , DataOutput out ) throws IOException { int length = buffer . length ; assert <int> < = length & & length < = FBUtilities . MAX_UNSIGNED_SHORT : length ; out . writeShort ( length ) ; out . write ( buffer ) ; } public static ByteBuffer readWithLength ( DataInput in ) throws IOException { int length = in . readInt ( ) ; if ( length < <int> ) { throw new IOException ( <str> ) ; } return ByteBufferUtil . read ( in , length ) ; } public static ByteBuffer readWithVIntLength ( DataInputPlus in ) throws IOException { int length = ( int ) in . readUnsignedVInt ( ) ; if ( length < <int> ) throw new IOException ( <str> ) ; return ByteBufferUtil . read ( in , length ) ; } public static int serializedSizeWithLength ( ByteBuffer buffer ) { int size = buffer . remaining ( ) ; return TypeSizes . sizeof ( size ) + size ; } public static int serializedSizeWithVIntLength ( ByteBuffer buffer ) { int size = buffer . remaining ( ) ; return TypeSizes . sizeofUnsignedVInt ( size ) + size ; } public static void skipWithVIntLength ( DataInputPlus in ) throws IOException { int length = ( int ) in . readUnsignedVInt ( ) ; if ( length < <int> ) throw new IOException ( <str> ) ; in . skipBytesFully ( length ) ; } public static int readShortLength ( DataInput in ) throws IOException { return in . readUnsignedShort ( ) ; } public static ByteBuffer readWithShortLength ( DataInput in ) throws IOException { return ByteBufferUtil . read ( in , readShortLength ( in ) ) ; } public static int serializedSizeWithShortLength ( ByteBuffer buffer ) { int size = buffer . remaining ( ) ; return TypeSizes . sizeof ( ( short ) size ) + size ; } public static void skipShortLength ( DataInputPlus in ) throws IOException { int skip = readShortLength ( in ) ; in . skipBytesFully ( skip ) ; } public static ByteBuffer read ( DataInput in , int length ) throws IOException { if ( length = = <int> ) return EMPTY_BYTE_BUFFER ; byte [ ] buff = new byte [ length ] ; in . readFully ( buff ) ; return ByteBuffer . wrap ( buff ) ; } public static byte [ ] readBytes ( DataInput in , int length ) throws IOException { assert length > <int> : <str> + length ; byte [ ] bytes = new byte [ length ] ; in . readFully ( bytes ) ; return bytes ; } public static int toInt ( ByteBuffer bytes ) { return bytes . getInt ( bytes . position ( ) ) ; } public static short toShort ( ByteBuffer bytes ) { return bytes . getShort ( bytes . position ( ) ) ; } public static long toLong ( ByteBuffer bytes ) { return bytes . getLong ( bytes . position ( ) ) ; } public static float toFloat ( ByteBuffer bytes ) { return bytes . getFloat ( bytes . position ( ) ) ; } public static double toDouble ( ByteBuffer bytes ) { return bytes . getDouble ( bytes . position ( ) ) ; } public static ByteBuffer bytes ( short s ) { return ByteBuffer . allocate ( <int> ) . putShort ( <int> , s ) ; } public static ByteBuffer bytes ( int i ) { return ByteBuffer . allocate ( <int> ) . putInt ( <int> , i ) ; } public static ByteBuffer bytes ( long n ) { return ByteBuffer . allocate ( <int> ) . putLong ( <int> , n ) ; } public static ByteBuffer bytes ( float f ) { return ByteBuffer . allocate ( <int> ) . putFloat ( <int> , f ) ; } public static ByteBuffer bytes ( double d ) { return ByteBuffer . allocate ( <int> ) . putDouble ( <int> , d ) ; } public static InputStream inputStream ( ByteBuffer bytes ) { final ByteBuffer copy = bytes . duplicate ( ) ; return new InputStream ( ) { public int read ( ) { if ( ! copy . hasRemaining ( ) ) return - <int> ; return copy . get ( ) & <hex> ; } @Override public int read ( byte [ ] bytes , int off , int len ) { if ( ! copy . hasRemaining ( ) ) return - <int> ; len = Math . min ( len , copy . remaining ( ) ) ; copy . get ( bytes , off , len ) ; return len ; } @Override public int available ( ) { return copy . remaining ( ) ; } } ; } public static String bytesToHex ( ByteBuffer bytes ) { if ( bytes . hasArray ( ) ) { return Hex . bytesToHex ( bytes . array ( ) , bytes . arrayOffset ( ) + bytes . position ( ) , bytes . remaining ( ) ) ; } final int offset = bytes . position ( ) ; final int size = bytes . remaining ( ) ; final char [ ] c = new char [ size * <int> ] ; for ( int i = <int> ; i < size ; i + + ) { final int bint = bytes . get ( i + offset ) ; c [ i * <int> ] = Hex . byteToChar [ ( bint & <hex> ) > > <int> ] ; c [ <int> + i * <int> ] = Hex . byteToChar [ bint & <hex> ] ; } return Hex . wrapCharArray ( c ) ; } public static ByteBuffer hexToBytes ( String str ) { return ByteBuffer . wrap ( Hex . hexToBytes ( str ) ) ; } public static int compareSubArrays ( ByteBuffer bytes1 , int offset1 , ByteBuffer bytes2 , int offset2 , int length ) { if ( bytes1 = = null ) return bytes2 = = null ? <int> : - <int> ; if ( bytes2 = = null ) return <int> ; assert bytes1 . limit ( ) > = offset1 + length : <str> ; assert bytes2 . limit ( ) > = offset2 + length : <str> ; for ( int i = <int> ; i < length ; i + + ) { byte byte1 = bytes1 . get ( offset1 + i ) ; byte byte2 = bytes2 . get ( offset2 + i ) ; if ( byte1 = = byte2 ) continue ; return ( byte1 & <hex> ) < ( byte2 & <hex> ) ? - <int> : <int> ; } return <int> ; } public static ByteBuffer bytes ( InetAddress address ) { return ByteBuffer . wrap ( address . getAddress ( ) ) ; } public static ByteBuffer bytes ( UUID uuid ) { return ByteBuffer . wrap ( UUIDGen . decompose ( uuid ) ) ; } public static boolean isPrefix ( ByteBuffer prefix , ByteBuffer value ) { if ( prefix . remaining ( ) > value . remaining ( ) ) return false ; int diff = value . remaining ( ) - prefix . remaining ( ) ; return prefix . equals ( value . duplicate ( ) . limit ( value . remaining ( ) - diff ) ) ; } public static ByteBuffer minimalBufferFor ( ByteBuffer buf ) { return buf . capacity ( ) > buf . remaining ( ) | | ! buf . hasArray ( ) ? ByteBuffer . wrap ( getArray ( buf ) ) : buf ; } public static int getShortLength ( ByteBuffer bb , int position ) { int length = ( bb . get ( position ) & <hex> ) < < <int> ; return length | ( bb . get ( position + <int> ) & <hex> ) ; } public static int readShortLength ( ByteBuffer bb ) { int length = ( bb . get ( ) & <hex> ) < < <int> ; return length | ( bb . get ( ) & <hex> ) ; } public static void writeShortLength ( ByteBuffer bb , int length ) { bb . put ( ( byte ) ( ( length > > <int> ) & <hex> ) ) ; bb . put ( ( byte ) ( length & <hex> ) ) ; } public static ByteBuffer readBytes ( ByteBuffer bb , int length ) { ByteBuffer copy = bb . duplicate ( ) ; copy . limit ( copy . position ( ) + length ) ; bb . position ( bb . position ( ) + length ) ; return copy ; } public static ByteBuffer readBytesWithShortLength ( ByteBuffer bb ) { int length = readShortLength ( bb ) ; return readBytes ( bb , length ) ; } } 
