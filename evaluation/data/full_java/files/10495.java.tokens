package com . google . common . hash ; import static org . easymock . EasyMock . aryEq ; import static org . easymock . EasyMock . eq ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import org . easymock . EasyMock ; import java . io . ByteArrayInputStream ; import java . util . Arrays ; public class HashingInputStreamTest extends TestCase { private Hasher hasher ; private HashFunction hashFunction ; private static final byte [ ] testBytes = new byte [ ] { <str> , <str> , <str> , <str> } ; private ByteArrayInputStream buffer ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; hasher = EasyMock . createMock ( Hasher . class ) ; hashFunction = EasyMock . createMock ( HashFunction . class ) ; buffer = new ByteArrayInputStream ( testBytes ) ; EasyMock . expect ( hashFunction . newHasher ( ) ) . andReturn ( hasher ) . once ( ) ; EasyMock . replay ( hashFunction ) ; } public void testRead_putSingleByte ( ) throws Exception { EasyMock . expect ( hasher . putByte ( ( byte ) <str> ) ) . andReturn ( hasher ) . once ( ) ; EasyMock . replay ( hasher ) ; HashingInputStream in = new HashingInputStream ( hashFunction , buffer ) ; int b = in . read ( ) ; assertEquals ( <str> , b ) ; EasyMock . verify ( hashFunction ) ; EasyMock . verify ( hasher ) ; } public void testRead_putByteArray ( ) throws Exception { EasyMock . expect ( hasher . putBytes ( aryEq ( testBytes ) , eq ( <int> ) , eq ( testBytes . length ) ) ) . andReturn ( hasher ) . once ( ) ; EasyMock . replay ( hasher ) ; HashingInputStream in = new HashingInputStream ( hashFunction , buffer ) ; byte [ ] buf = new byte [ <int> ] ; int numOfByteRead = in . read ( buf , <int> , buf . length ) ; assertEquals ( <int> , numOfByteRead ) ; for ( int i = <int> ; i < testBytes . length ; i + + ) { assertEquals ( testBytes [ i ] , buf [ i ] ) ; } EasyMock . verify ( hashFunction ) ; EasyMock . verify ( hasher ) ; } public void testRead_putByteArrayAtPos ( ) throws Exception { EasyMock . expect ( hasher . putBytes ( aryEq ( Arrays . copyOfRange ( testBytes , <int> , <int> ) ) , eq ( <int> ) , eq ( <int> ) ) ) . andReturn ( hasher ) . once ( ) ; EasyMock . replay ( hasher ) ; HashingInputStream in = new HashingInputStream ( hashFunction , buffer ) ; byte [ ] buf = new byte [ <int> ] ; int numOfByteRead = in . read ( buf , <int> , <int> ) ; assertEquals ( <int> , numOfByteRead ) ; for ( int i = <int> ; i < numOfByteRead ; i + + ) { assertEquals ( testBytes [ i ] , buf [ i ] ) ; } EasyMock . verify ( hashFunction ) ; EasyMock . verify ( hasher ) ; } public void testRead_putByteArrayOutOfBound ( ) throws Exception { byte [ ] buf = new byte [ <int> ] ; byte [ ] expectedBytes = buf . clone ( ) ; System . arraycopy ( testBytes , <int> , expectedBytes , <int> , testBytes . length ) ; EasyMock . expect ( hasher . putBytes ( aryEq ( expectedBytes ) , eq ( <int> ) , eq ( <int> ) ) ) . andReturn ( hasher ) . once ( ) ; EasyMock . replay ( hasher ) ; HashingInputStream in = new HashingInputStream ( hashFunction , buffer ) ; int numOfByteRead = in . read ( buf , <int> , <int> ) ; assertEquals ( <int> , numOfByteRead ) ; for ( int i = <int> ; i < numOfByteRead ; i + + ) { assertEquals ( testBytes [ i ] , buf [ i ] ) ; } EasyMock . verify ( hashFunction ) ; EasyMock . verify ( hasher ) ; } public void testHash_hashesCorrectly ( ) throws Exception { HashCode expectedHash = Hashing . md5 ( ) . hashBytes ( testBytes ) ; HashingInputStream in = new HashingInputStream ( Hashing . md5 ( ) , buffer ) ; byte [ ] buf = new byte [ <int> ] ; int numOfByteRead = in . read ( buf , <int> , buf . length ) ; assertEquals ( <int> , numOfByteRead ) ; assertEquals ( expectedHash , in . hash ( ) ) ; } public void testHash_hashesCorrectlyReadOutOfBound ( ) throws Exception { HashCode expectedHash = Hashing . md5 ( ) . hashBytes ( testBytes ) ; HashingInputStream in = new HashingInputStream ( Hashing . md5 ( ) , buffer ) ; byte [ ] buf = new byte [ <int> ] ; int numOfByteRead = in . read ( buf , <int> , buf . length ) ; assertEquals ( - <int> , in . read ( ) ) ; assertEquals ( <int> , numOfByteRead ) ; assertEquals ( expectedHash , in . hash ( ) ) ; } public void testHash_hashesCorrectlyForSkipping ( ) throws Exception { HashCode expectedHash = Hashing . md5 ( ) . hashBytes ( new byte [ ] { <str> , <str> } ) ; HashingInputStream in = new HashingInputStream ( Hashing . md5 ( ) , buffer ) ; long numOfByteSkipped = in . skip ( <int> ) ; assertEquals ( <int> , numOfByteSkipped ) ; byte [ ] buf = new byte [ <int> ] ; int numOfByteRead = in . read ( buf , <int> , buf . length ) ; assertEquals ( <int> , numOfByteRead ) ; assertEquals ( expectedHash , in . hash ( ) ) ; } public void testChecksForNull ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( new HashingInputStream ( Hashing . md5 ( ) , buffer ) ) ; tester . testAllPublicStaticMethods ( HashingInputStream . class ) ; tester . testAllPublicConstructors ( HashingInputStream . class ) ; } } 
