package org . elasticsearch . common . lucene . index ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . FilteredDocIdSetIterator ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Weight ; import org . apache . lucene . util . BitDocIdSet ; import org . apache . lucene . util . BitSet ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Nullable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class FilterableTermsEnum extends TermsEnum { static class Holder { final TermsEnum termsEnum ; @Nullable PostingsEnum docsEnum ; @Nullable final Bits bits ; Holder ( TermsEnum termsEnum , Bits bits ) { this . termsEnum = termsEnum ; this . bits = bits ; } } static final String UNSUPPORTED_MESSAGE = <str> ; protected final static int NOT_FOUND = - <int> ; private final Holder [ ] enums ; protected int currentDocFreq = <int> ; protected long currentTotalTermFreq = <int> ; protected BytesRef current ; protected final int docsEnumFlag ; protected int numDocs ; public FilterableTermsEnum ( IndexReader reader , String field , int docsEnumFlag , @Nullable Query filter ) throws IOException { if ( ( docsEnumFlag ! = PostingsEnum . FREQS ) & & ( docsEnumFlag ! = PostingsEnum . NONE ) ) { throw new IllegalArgumentException ( <str> + docsEnumFlag ) ; } this . docsEnumFlag = docsEnumFlag ; if ( filter = = null ) { numDocs = reader . maxDoc ( ) ; } List < LeafReaderContext > leaves = reader . leaves ( ) ; List < Holder > enums = new ArrayList < > ( leaves . size ( ) ) ; final Weight weight ; if ( filter = = null ) { weight = null ; } else { final IndexSearcher searcher = new IndexSearcher ( reader ) ; searcher . setQueryCache ( null ) ; weight = searcher . createNormalizedWeight ( filter , false ) ; } for ( LeafReaderContext context : leaves ) { Terms terms = context . reader ( ) . terms ( field ) ; if ( terms = = null ) { continue ; } TermsEnum termsEnum = terms . iterator ( ) ; if ( termsEnum = = null ) { continue ; } BitSet bits = null ; if ( weight ! = null ) { DocIdSetIterator docs = weight . scorer ( context ) ; if ( docs = = null ) { continue ; } final Bits liveDocs = context . reader ( ) . getLiveDocs ( ) ; if ( liveDocs ! = null ) { docs = new FilteredDocIdSetIterator ( docs ) { @Override protected boolean match ( int doc ) { return liveDocs . get ( doc ) ; } } ; } BitDocIdSet . Builder builder = new BitDocIdSet . Builder ( context . reader ( ) . maxDoc ( ) ) ; builder . or ( docs ) ; bits = builder . build ( ) . bits ( ) ; numDocs + = bits . cardinality ( ) ; } enums . add ( new Holder ( termsEnum , bits ) ) ; } this . enums = enums . toArray ( new Holder [ enums . size ( ) ] ) ; } public int getNumDocs ( ) { return numDocs ; } @Override public BytesRef term ( ) throws IOException { return current ; } @Override public boolean seekExact ( BytesRef text ) throws IOException { int docFreq = <int> ; long totalTermFreq = <int> ; for ( Holder anEnum : enums ) { if ( anEnum . termsEnum . seekExact ( text ) ) { if ( anEnum . bits = = null ) { docFreq + = anEnum . termsEnum . docFreq ( ) ; if ( docsEnumFlag = = PostingsEnum . FREQS ) { long leafTotalTermFreq = anEnum . termsEnum . totalTermFreq ( ) ; if ( totalTermFreq = = - <int> | | leafTotalTermFreq = = - <int> ) { totalTermFreq = - <int> ; continue ; } totalTermFreq + = leafTotalTermFreq ; } } else { final PostingsEnum docsEnum = anEnum . docsEnum = anEnum . termsEnum . postings ( anEnum . docsEnum , docsEnumFlag ) ; if ( docsEnumFlag = = PostingsEnum . FREQS ) { for ( int docId = docsEnum . nextDoc ( ) ; docId ! = DocIdSetIterator . NO_MORE_DOCS ; docId = docsEnum . nextDoc ( ) ) { if ( anEnum . bits ! = null & & anEnum . bits . get ( docId ) = = false ) { continue ; } docFreq + + ; totalTermFreq + = docsEnum . freq ( ) ; } } else { for ( int docId = docsEnum . nextDoc ( ) ; docId ! = DocIdSetIterator . NO_MORE_DOCS ; docId = docsEnum . nextDoc ( ) ) { if ( anEnum . bits ! = null & & anEnum . bits . get ( docId ) = = false ) { continue ; } docFreq + + ; } } } } } if ( docFreq > <int> ) { currentDocFreq = docFreq ; currentTotalTermFreq = totalTermFreq ; current = text ; return true ; } else { currentDocFreq = NOT_FOUND ; currentTotalTermFreq = NOT_FOUND ; current = null ; return false ; } } @Override public int docFreq ( ) throws IOException { return currentDocFreq ; } @Override public long totalTermFreq ( ) throws IOException { return currentTotalTermFreq ; } @Override public void seekExact ( long ord ) throws IOException { throw new UnsupportedOperationException ( UNSUPPORTED_MESSAGE ) ; } @Override public SeekStatus seekCeil ( BytesRef text ) throws IOException { throw new UnsupportedOperationException ( UNSUPPORTED_MESSAGE ) ; } @Override public long ord ( ) throws IOException { throw new UnsupportedOperationException ( UNSUPPORTED_MESSAGE ) ; } @Override public PostingsEnum postings ( PostingsEnum reuse , int flags ) throws IOException { throw new UnsupportedOperationException ( UNSUPPORTED_MESSAGE ) ; } @Override public BytesRef next ( ) throws IOException { throw new UnsupportedOperationException ( UNSUPPORTED_MESSAGE ) ; } } 
