package org . gradle . internal . resource . local . ivy ; import org . gradle . api . internal . artifacts . ivyservice . ArtifactCacheMetaData ; import org . gradle . internal . component . external . model . ModuleComponentArtifactMetaData ; import org . gradle . api . internal . artifacts . mvnsettings . CannotLocateLocalMavenRepositoryException ; import org . gradle . api . internal . artifacts . mvnsettings . LocalMavenRepositoryLocator ; import org . gradle . api . internal . artifacts . repositories . resolver . IvyResourcePattern ; import org . gradle . api . internal . artifacts . repositories . resolver . M2ResourcePattern ; import org . gradle . api . internal . artifacts . repositories . resolver . ResourcePattern ; import org . gradle . internal . resource . local . CompositeLocallyAvailableResourceFinder ; import org . gradle . internal . resource . local . LocallyAvailableResourceCandidates ; import org . gradle . internal . resource . local . LocallyAvailableResourceFinder ; import org . gradle . internal . resource . local . LocallyAvailableResourceFinderSearchableFileStoreAdapter ; import org . gradle . internal . Factory ; import org . gradle . internal . resource . local . FileStoreSearcher ; import org . gradle . internal . hash . HashValue ; import org . gradle . internal . resource . local . LocallyAvailableResource ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . util . LinkedList ; import java . util . List ; public class LocallyAvailableResourceFinderFactory implements Factory < LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > > { private static final Logger LOGGER = LoggerFactory . getLogger ( LocallyAvailableResourceFinderFactory . class ) ; private final File rootCachesDirectory ; private final LocalMavenRepositoryLocator localMavenRepositoryLocator ; private final FileStoreSearcher < ModuleComponentArtifactMetaData > fileStore ; public LocallyAvailableResourceFinderFactory ( ArtifactCacheMetaData artifactCacheMetaData , LocalMavenRepositoryLocator localMavenRepositoryLocator , FileStoreSearcher < ModuleComponentArtifactMetaData > fileStore ) { this . rootCachesDirectory = artifactCacheMetaData . getCacheDir ( ) . getParentFile ( ) ; this . localMavenRepositoryLocator = localMavenRepositoryLocator ; this . fileStore = fileStore ; } public LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > create ( ) { List < LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > > finders = new LinkedList < LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > > ( ) ; finders . add ( new LocallyAvailableResourceFinderSearchableFileStoreAdapter < ModuleComponentArtifactMetaData > ( fileStore ) ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; addForPattern ( finders , <str> ) ; try { File localMavenRepository = localMavenRepositoryLocator . getLocalMavenRepository ( ) ; if ( localMavenRepository . exists ( ) ) { addForPattern ( finders , localMavenRepository , new M2ResourcePattern ( <str> ) ) ; } } catch ( CannotLocateLocalMavenRepositoryException ex ) { finders . add ( new NoMavenLocalRepositoryResourceFinder ( ex ) ) ; } return new CompositeLocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > ( finders ) ; } private void addForPattern ( List < LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > > finders , String pattern ) { int wildcardPos = pattern . indexOf ( <str> ) ; int patternPos = pattern . indexOf ( <str> ) ; if ( wildcardPos < <int> & & patternPos < <int> ) { throw new IllegalArgumentException ( String . format ( <str> , pattern ) ) ; } int chopAt ; if ( wildcardPos > = <int> & & patternPos > = <int> ) { chopAt = Math . min ( wildcardPos , patternPos ) ; } else if ( wildcardPos > = <int> ) { chopAt = wildcardPos ; } else { chopAt = patternPos ; } String pathPart = pattern . substring ( <int> , chopAt ) ; String patternPart = pattern . substring ( chopAt + <int> ) ; addForPattern ( finders , new File ( rootCachesDirectory , pathPart ) , new IvyResourcePattern ( patternPart ) ) ; } private void addForPattern ( List < LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > > finders , File baseDir , ResourcePattern pattern ) { if ( baseDir . exists ( ) ) { finders . add ( new PatternBasedLocallyAvailableResourceFinder ( baseDir , pattern ) ) ; } } private class NoMavenLocalRepositoryResourceFinder implements LocallyAvailableResourceFinder < ModuleComponentArtifactMetaData > { private final CannotLocateLocalMavenRepositoryException ex ; private boolean logged ; public NoMavenLocalRepositoryResourceFinder ( CannotLocateLocalMavenRepositoryException ex ) { this . ex = ex ; } public LocallyAvailableResourceCandidates findCandidates ( ModuleComponentArtifactMetaData criterion ) { if ( ! logged ) { LOGGER . warn ( <str> ) ; LOGGER . debug ( <str> , ex ) ; logged = true ; } return new LocallyAvailableResourceCandidates ( ) { public boolean isNone ( ) { return true ; } public LocallyAvailableResource findByHashValue ( HashValue hashValue ) { return null ; } } ; } } } 
