package com . google . common . math ; import static com . google . common . math . MathTesting . ALL_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . ALL_ROUNDING_MODES ; import static com . google . common . math . MathTesting . ALL_SAFE_ROUNDING_MODES ; import static com . google . common . math . MathTesting . EXPONENTS ; import static com . google . common . math . MathTesting . NEGATIVE_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . NONZERO_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . POSITIVE_INTEGER_CANDIDATES ; import static com . google . common . math . TestPlatform . intsCanGoOutOfRange ; import static java . math . BigInteger . valueOf ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . UNNECESSARY ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible ( emulated = true ) public class IntMathTest extends TestCase { @GwtIncompatible ( <str> ) public void testConstantMaxPowerOfSqrt2Unsigned ( ) { assertEquals ( BigIntegerMath . sqrt ( BigInteger . ZERO . setBit ( <int> * Integer . SIZE - <int> ) , FLOOR ) . intValue ( ) , IntMath . MAX_POWER_OF_SQRT2_UNSIGNED ) ; } @GwtIncompatible ( <str> ) public void testConstantsPowersOf10 ( ) { for ( int i = <int> ; i < IntMath . powersOf10 . length - <int> ; i + + ) { assertEquals ( IntMath . pow ( <int> , i ) , IntMath . powersOf10 [ i ] ) ; } } @GwtIncompatible ( <str> ) public void testMaxLog10ForLeadingZeros ( ) { for ( int i = <int> ; i < Integer . SIZE ; i + + ) { assertEquals ( BigIntegerMath . log10 ( BigInteger . ONE . shiftLeft ( Integer . SIZE - i ) , FLOOR ) , IntMath . maxLog10ForLeadingZeros [ i ] ) ; } } @GwtIncompatible ( <str> ) public void testConstantsHalfPowersOf10 ( ) { for ( int i = <int> ; i < IntMath . halfPowersOf10 . length ; i + + ) { assert IntMath . halfPowersOf10 [ i ] = = Math . min ( Integer . MAX_VALUE , BigIntegerMath . sqrt ( BigInteger . TEN . pow ( <int> * i + <int> ) , FLOOR ) . longValue ( ) ) ; } } @GwtIncompatible ( <str> ) public void testConstantsBiggestBinomials ( ) { for ( int k = <int> ; k < IntMath . biggestBinomials . length ; k + + ) { assertTrue ( fitsInInt ( BigIntegerMath . binomial ( IntMath . biggestBinomials [ k ] , k ) ) ) ; assertTrue ( IntMath . biggestBinomials [ k ] = = Integer . MAX_VALUE | | ! fitsInInt ( BigIntegerMath . binomial ( IntMath . biggestBinomials [ k ] + <int> , k ) ) ) ; } assertFalse ( fitsInInt ( BigIntegerMath . binomial ( <int> * IntMath . biggestBinomials . length , IntMath . biggestBinomials . length ) ) ) ; } @GwtIncompatible ( <str> ) public void testPowersSqrtMaxInt ( ) { assertEquals ( IntMath . sqrt ( Integer . MAX_VALUE , FLOOR ) , IntMath . FLOOR_SQRT_MAX_INT ) ; } @AndroidIncompatible public void testLessThanBranchFree ( ) { for ( int x : ALL_INTEGER_CANDIDATES ) { for ( int y : ALL_INTEGER_CANDIDATES ) { if ( LongMath . fitsInInt ( ( long ) x - y ) ) { int expected = ( x < y ) ? <int> : <int> ; int actual = IntMath . lessThanBranchFree ( x , y ) ; assertEquals ( expected , actual ) ; } } } } @GwtIncompatible ( <str> ) public void testIsPowerOfTwo ( ) { for ( int x : ALL_INTEGER_CANDIDATES ) { BigInteger bigX = BigInteger . valueOf ( x ) ; boolean expected = ( bigX . signum ( ) > <int> ) & & ( bigX . bitCount ( ) = = <int> ) ; assertEquals ( expected , IntMath . isPowerOfTwo ( x ) ) ; } } public void testLog2ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { IntMath . log2 ( <int> , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testLog2NegativeAlwaysThrows ( ) { for ( int x : NEGATIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { IntMath . log2 ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } public void testLog2MatchesBigInteger ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . log2 ( valueOf ( x ) , mode ) , IntMath . log2 ( x , mode ) ) ; } } } public void testLog2Exact ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { boolean isPowerOf2 = IntMath . isPowerOfTwo ( x ) ; try { assertEquals ( x , <int> < < IntMath . log2 ( x , UNNECESSARY ) ) ; assertTrue ( isPowerOf2 ) ; } catch ( ArithmeticException e ) { assertFalse ( isPowerOf2 ) ; } } } @GwtIncompatible ( <str> ) public void testLog10ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { IntMath . log10 ( <int> , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testLog10NegativeAlwaysThrows ( ) { for ( int x : NEGATIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { IntMath . log10 ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testLog10MatchesBigInteger ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . log10 ( valueOf ( x ) , mode ) , IntMath . log10 ( x , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testLog10Exact ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { int floor = IntMath . log10 ( x , FLOOR ) ; boolean expectSuccess = IntMath . pow ( <int> , floor ) = = x ; try { assertEquals ( floor , IntMath . log10 ( x , UNNECESSARY ) ) ; assertTrue ( expectSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( expectSuccess ) ; } } } @GwtIncompatible ( <str> ) public void testLog10TrivialOnPowerOfTen ( ) { int x = <int> ; for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> , IntMath . log10 ( x , mode ) ) ; } } @GwtIncompatible ( <str> ) public void testSqrtZeroAlwaysZero ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> , IntMath . sqrt ( <int> , mode ) ) ; } } @GwtIncompatible ( <str> ) public void testSqrtNegativeAlwaysThrows ( ) { for ( int x : NEGATIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : RoundingMode . values ( ) ) { try { IntMath . sqrt ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testSqrtMatchesBigInteger ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . sqrt ( valueOf ( x ) , mode ) , valueOf ( IntMath . sqrt ( x , mode ) ) ) ; } } } @GwtIncompatible ( <str> ) public void testSqrtExactMatchesFloorOrThrows ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { int floor = IntMath . sqrt ( x , FLOOR ) ; boolean isPerfectSquare = ( floor * floor = = x ) ; try { assertEquals ( floor , IntMath . sqrt ( x , UNNECESSARY ) ) ; assertTrue ( isPerfectSquare ) ; } catch ( ArithmeticException e ) { assertFalse ( isPerfectSquare ) ; } } } @GwtIncompatible ( <str> ) public void testPow ( ) { for ( int i : ALL_INTEGER_CANDIDATES ) { for ( int pow : EXPONENTS ) { assertEquals ( i + <str> + pow , BigInteger . valueOf ( i ) . pow ( pow ) . intValue ( ) , IntMath . pow ( i , pow ) ) ; } } } @AndroidIncompatible public void testDivNonZero ( ) { for ( int p : NONZERO_INTEGER_CANDIDATES ) { for ( int q : NONZERO_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { if ( p = = - <int> & & q = = - <int> & & intsCanGoOutOfRange ( ) ) { continue ; } int expected = new BigDecimal ( valueOf ( p ) ) . divide ( new BigDecimal ( valueOf ( q ) ) , <int> , mode ) . intValue ( ) ; assertEquals ( p + <str> + q , force32 ( expected ) , IntMath . divide ( p , q , mode ) ) ; } } } } @AndroidIncompatible public void testDivNonZeroExact ( ) { for ( int p : NONZERO_INTEGER_CANDIDATES ) { for ( int q : NONZERO_INTEGER_CANDIDATES ) { if ( p = = - <int> & & q = = - <int> & & intsCanGoOutOfRange ( ) ) { continue ; } boolean dividesEvenly = ( p % q ) = = <int> ; try { assertEquals ( p + <str> + q , p , IntMath . divide ( p , q , UNNECESSARY ) * q ) ; assertTrue ( p + <str> + q + <str> , dividesEvenly ) ; } catch ( ArithmeticException e ) { assertFalse ( p + <str> + q + <str> , dividesEvenly ) ; } } } } public void testZeroDivIsAlwaysZero ( ) { for ( int q : NONZERO_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> , IntMath . divide ( <int> , q , mode ) ) ; } } } public void testDivByZeroAlwaysFails ( ) { for ( int p : ALL_INTEGER_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { IntMath . divide ( p , <int> , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } public void testMod ( ) { for ( int x : ALL_INTEGER_CANDIDATES ) { for ( int m : POSITIVE_INTEGER_CANDIDATES ) { assertEquals ( valueOf ( x ) . mod ( valueOf ( m ) ) . intValue ( ) , IntMath . mod ( x , m ) ) ; } } } public void testModNegativeModulusFails ( ) { for ( int x : POSITIVE_INTEGER_CANDIDATES ) { for ( int m : NEGATIVE_INTEGER_CANDIDATES ) { try { IntMath . mod ( x , m ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } public void testModZeroModulusFails ( ) { for ( int x : ALL_INTEGER_CANDIDATES ) { try { IntMath . mod ( x , <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } public void testGCD ( ) { for ( int a : POSITIVE_INTEGER_CANDIDATES ) { for ( int b : POSITIVE_INTEGER_CANDIDATES ) { assertEquals ( valueOf ( a ) . gcd ( valueOf ( b ) ) , valueOf ( IntMath . gcd ( a , b ) ) ) ; } } } public void testGCDZero ( ) { for ( int a : POSITIVE_INTEGER_CANDIDATES ) { assertEquals ( a , IntMath . gcd ( a , <int> ) ) ; assertEquals ( a , IntMath . gcd ( <int> , a ) ) ; } assertEquals ( <int> , IntMath . gcd ( <int> , <int> ) ) ; } public void testGCDNegativePositiveThrows ( ) { for ( int a : NEGATIVE_INTEGER_CANDIDATES ) { try { IntMath . gcd ( a , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { IntMath . gcd ( <int> , a ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testGCDNegativeZeroThrows ( ) { for ( int a : NEGATIVE_INTEGER_CANDIDATES ) { try { IntMath . gcd ( a , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { IntMath . gcd ( <int> , a ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @AndroidIncompatible public void testCheckedAdd ( ) { for ( int a : ALL_INTEGER_CANDIDATES ) { for ( int b : ALL_INTEGER_CANDIDATES ) { BigInteger expectedResult = valueOf ( a ) . add ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInInt ( expectedResult ) ; try { assertEquals ( a + b , IntMath . checkedAdd ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( expectedSuccess ) ; } } } } @AndroidIncompatible public void testCheckedSubtract ( ) { for ( int a : ALL_INTEGER_CANDIDATES ) { for ( int b : ALL_INTEGER_CANDIDATES ) { BigInteger expectedResult = valueOf ( a ) . subtract ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInInt ( expectedResult ) ; try { assertEquals ( a - b , IntMath . checkedSubtract ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( expectedSuccess ) ; } } } } @AndroidIncompatible public void testCheckedMultiply ( ) { for ( int a : ALL_INTEGER_CANDIDATES ) { for ( int b : ALL_INTEGER_CANDIDATES ) { BigInteger expectedResult = valueOf ( a ) . multiply ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInInt ( expectedResult ) ; try { assertEquals ( a * b , IntMath . checkedMultiply ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( expectedSuccess ) ; } } } } public void testCheckedPow ( ) { for ( int b : ALL_INTEGER_CANDIDATES ) { for ( int k : EXPONENTS ) { BigInteger expectedResult = valueOf ( b ) . pow ( k ) ; boolean expectedSuccess = fitsInInt ( expectedResult ) ; try { assertEquals ( b + <str> + k , force32 ( expectedResult . intValue ( ) ) , IntMath . checkedPow ( b , k ) ) ; assertTrue ( b + <str> + k + <str> , expectedSuccess ) ; } catch ( ArithmeticException e ) { assertFalse ( b + <str> + k + <str> , expectedSuccess ) ; } } } } public void testFactorial ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { BigInteger expectedBig = BigIntegerMath . factorial ( n ) ; int expectedInt = fitsInInt ( expectedBig ) ? expectedBig . intValue ( ) : Integer . MAX_VALUE ; assertEquals ( expectedInt , IntMath . factorial ( n ) ) ; } } public void testFactorialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { try { IntMath . factorial ( n ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testBinomial ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { for ( int k = <int> ; k < = n ; k + + ) { BigInteger expectedBig = BigIntegerMath . binomial ( n , k ) ; int expectedInt = fitsInInt ( expectedBig ) ? expectedBig . intValue ( ) : Integer . MAX_VALUE ; assertEquals ( expectedInt , IntMath . binomial ( n , k ) ) ; } } } @GwtIncompatible ( <str> ) public void testBinomialOutside ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { try { IntMath . binomial ( n , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { IntMath . binomial ( n , n + <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testBinomialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { try { IntMath . binomial ( n , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @AndroidIncompatible @GwtIncompatible ( <str> ) public void testMean ( ) { assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( ( <int> < < <int> ) - <int> , - <int> , Integer . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( <int> , Integer . MIN_VALUE + <int> , Integer . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , <int> ) ; assertMean ( - <int> , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( Integer . MIN_VALUE , Integer . MIN_VALUE , Integer . MIN_VALUE ) ; assertMean ( Integer . MAX_VALUE , Integer . MAX_VALUE , Integer . MAX_VALUE ) ; for ( int x : ALL_INTEGER_CANDIDATES ) { for ( int y : ALL_INTEGER_CANDIDATES ) { assertMean ( x , y ) ; } } } private static void assertMean ( int expectedMean , int x , int y ) { assertEquals ( <str> , expectedMean , computeMeanSafely ( x , y ) ) ; assertMean ( x , y ) ; } private static void assertMean ( int x , int y ) { int expectedMean = computeMeanSafely ( x , y ) ; assertEquals ( expectedMean , IntMath . mean ( x , y ) ) ; assertEquals ( <str> , expectedMean , IntMath . mean ( y , x ) ) ; } private static int computeMeanSafely ( int x , int y ) { BigInteger bigX = BigInteger . valueOf ( x ) ; BigInteger bigY = BigInteger . valueOf ( y ) ; BigDecimal bigMean = new BigDecimal ( bigX . add ( bigY ) ) . divide ( BigDecimal . valueOf ( <int> ) , BigDecimal . ROUND_FLOOR ) ; return Integer . parseInt ( bigMean . toString ( ) ) ; } private static boolean fitsInInt ( BigInteger big ) { return big . bitLength ( ) < = <int> ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . setDefault ( int . class , <int> ) ; tester . testAllPublicStaticMethods ( IntMath . class ) ; } private static int force32 ( int value ) { return value & <hex> ; } } 
