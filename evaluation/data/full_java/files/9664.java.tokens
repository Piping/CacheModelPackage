package com . google . common . collect ; import com . google . common . base . Function ; import jsinterop . annotations . JsFunction ; import jsinterop . annotations . JsMethod ; import jsinterop . annotations . JsPackage ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; public final class MapMaker extends GenericMapMaker < Object , Object > { private static class ExpiringComputingMap < K , V > extends LinkedHashMap < K , V > implements ConcurrentMap < K , V > { private final long expirationMillis ; private final Function < ? super K , ? extends V > computer ; private final int maximumSize ; ExpiringComputingMap ( long expirationMillis , int maximumSize , int initialCapacity ) { this ( expirationMillis , null , maximumSize , initialCapacity ) ; } ExpiringComputingMap ( long expirationMillis , Function < ? super K , ? extends V > computer , int maximumSize , int initialCapacity ) { super ( initialCapacity , <float> , ( maximumSize ! = - <int> ) ) ; this . expirationMillis = expirationMillis ; this . computer = computer ; this . maximumSize = maximumSize ; } @Override public V put ( K key , V value ) { V result = super . put ( key , value ) ; if ( expirationMillis > <int> ) { scheduleRemoval ( key , value ) ; } return result ; } @Override protected boolean removeEldestEntry ( Map . Entry < K , V > ignored ) { return ( maximumSize = = - <int> ) ? false : size ( ) > maximumSize ; } @Override public V putIfAbsent ( K key , V value ) { if ( ! containsKey ( key ) ) { return put ( key , value ) ; } else { return get ( key ) ; } } @Override public boolean remove ( Object key , Object value ) { if ( containsKey ( key ) & & get ( key ) . equals ( value ) ) { remove ( key ) ; return true ; } return false ; } @Override public boolean replace ( K key , V oldValue , V newValue ) { if ( containsKey ( key ) & & get ( key ) . equals ( oldValue ) ) { put ( key , newValue ) ; return true ; } return false ; } @Override public V replace ( K key , V value ) { return containsKey ( key ) ? put ( key , value ) : null ; } private void scheduleRemoval ( final K key , final V value ) { setTimeout ( new Callback ( ) { @Override public void run ( ) { remove ( key , value ) ; } } , ( int ) expirationMillis ) ; } @JsFunction private interface Callback { void run ( ) ; } @JsMethod ( name = <str> , namespace = JsPackage . GLOBAL ) private static native void setTimeout ( Callback callback , int delayInMs ) ; @Override public V get ( Object k ) { V result = super . get ( k ) ; if ( result = = null & & computer ! = null ) { @SuppressWarnings ( <str> ) K key = ( K ) k ; result = compute ( key ) ; } return result ; } private V compute ( K key ) { V value ; try { value = computer . apply ( key ) ; } catch ( Throwable t ) { throw new ComputationException ( t ) ; } if ( value = = null ) { String message = computer + <str> + key + <str> ; throw new NullPointerException ( message ) ; } put ( key , value ) ; return value ; } } private int initialCapacity = <int> ; private long expirationMillis = <int> ; private int maximumSize = - <int> ; private boolean useCustomMap ; public MapMaker ( ) { } @Override public MapMaker initialCapacity ( int initialCapacity ) { if ( initialCapacity < <int> ) { throw new IllegalArgumentException ( ) ; } this . initialCapacity = initialCapacity ; return this ; } @Override MapMaker expireAfterWrite ( long duration , TimeUnit unit ) { if ( expirationMillis ! = <int> ) { throw new IllegalStateException ( <str> + expirationMillis + <str> ) ; } if ( duration < = <int> ) { throw new IllegalArgumentException ( <str> + duration ) ; } this . expirationMillis = unit . toMillis ( duration ) ; useCustomMap = true ; return this ; } @Override MapMaker maximumSize ( int maximumSize ) { if ( this . maximumSize ! = - <int> ) { throw new IllegalStateException ( <str> + maximumSize + <str> ) ; } if ( maximumSize < <int> ) { throw new IllegalArgumentException ( <str> + maximumSize ) ; } this . maximumSize = maximumSize ; useCustomMap = true ; return this ; } @Override public MapMaker concurrencyLevel ( int concurrencyLevel ) { if ( concurrencyLevel < <int> ) { throw new IllegalArgumentException ( <str> ) ; } return this ; } @Override public < K , V > ConcurrentMap < K , V > makeMap ( ) { return useCustomMap ? new ExpiringComputingMap < K , V > ( expirationMillis , null , maximumSize , initialCapacity ) : new ConcurrentHashMap < K , V > ( initialCapacity ) ; } @Override public < K , V > ConcurrentMap < K , V > makeComputingMap ( Function < ? super K , ? extends V > computer ) { return new ExpiringComputingMap < K , V > ( expirationMillis , computer , maximumSize , initialCapacity ) ; } } 
