package org . elasticsearch . snapshots ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . xcontent . * ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class Snapshot implements Comparable < Snapshot > , ToXContent , FromXContentBuilder < Snapshot > { private final String name ; private final Version version ; private final SnapshotState state ; private final String reason ; private final List < String > indices ; private final long startTime ; private final long endTime ; private final int totalShard ; private final int successfulShards ; private final List < SnapshotShardFailure > shardFailures ; private final static List < SnapshotShardFailure > NO_FAILURES = Collections . emptyList ( ) ; public final static Snapshot PROTO = new Snapshot ( ) ; private Snapshot ( String name , List < String > indices , SnapshotState state , String reason , Version version , long startTime , long endTime , int totalShard , int successfulShards , List < SnapshotShardFailure > shardFailures ) { assert name ! = null ; assert indices ! = null ; assert state ! = null ; assert shardFailures ! = null ; this . name = name ; this . indices = indices ; this . state = state ; this . reason = reason ; this . version = version ; this . startTime = startTime ; this . endTime = endTime ; this . totalShard = totalShard ; this . successfulShards = successfulShards ; this . shardFailures = shardFailures ; } public Snapshot ( String name , List < String > indices , long startTime ) { this ( name , indices , SnapshotState . IN_PROGRESS , null , Version . CURRENT , startTime , <int> L , <int> , <int> , NO_FAILURES ) ; } public Snapshot ( String name , List < String > indices , long startTime , String reason , long endTime , int totalShard , List < SnapshotShardFailure > shardFailures ) { this ( name , indices , snapshotState ( reason , shardFailures ) , reason , Version . CURRENT , startTime , endTime , totalShard , totalShard - shardFailures . size ( ) , shardFailures ) ; } private Snapshot ( ) { this ( <str> , Collections . emptyList ( ) , <int> ) ; } private static SnapshotState snapshotState ( String reason , List < SnapshotShardFailure > shardFailures ) { if ( reason = = null ) { if ( shardFailures . isEmpty ( ) ) { return SnapshotState . SUCCESS ; } else { return SnapshotState . PARTIAL ; } } else { return SnapshotState . FAILED ; } } public String name ( ) { return name ; } public SnapshotState state ( ) { return state ; } public String reason ( ) { return reason ; } public Version version ( ) { return version ; } public List < String > indices ( ) { return indices ; } public long startTime ( ) { return startTime ; } public long endTime ( ) { return endTime ; } public int totalShard ( ) { return totalShard ; } public int successfulShards ( ) { return successfulShards ; } public List < SnapshotShardFailure > shardFailures ( ) { return shardFailures ; } @Override public int compareTo ( Snapshot o ) { return Long . compare ( startTime , o . startTime ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Snapshot that = ( Snapshot ) o ; if ( startTime ! = that . startTime ) return false ; if ( ! name . equals ( that . name ) ) return false ; return true ; } @Override public int hashCode ( ) { int result = name . hashCode ( ) ; result = <int> * result + Long . hashCode ( startTime ) ; return result ; } @Override public Snapshot fromXContent ( XContentParser parser , ParseFieldMatcher parseFieldMatcher ) throws IOException { return fromXContent ( parser ) ; } static final class Fields { static final XContentBuilderString SNAPSHOT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VERSION_ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDICES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString STATE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString REASON = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString END_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SUCCESSFUL_SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FAILURES = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( Fields . SNAPSHOT ) ; builder . field ( Fields . NAME , name ) ; builder . field ( Fields . VERSION_ID , version . id ) ; builder . startArray ( Fields . INDICES ) ; for ( String index : indices ) { builder . value ( index ) ; } builder . endArray ( ) ; builder . field ( Fields . STATE , state ) ; if ( reason ! = null ) { builder . field ( Fields . REASON , reason ) ; } builder . field ( Fields . START_TIME , startTime ) ; builder . field ( Fields . END_TIME , endTime ) ; builder . field ( Fields . TOTAL_SHARDS , totalShard ) ; builder . field ( Fields . SUCCESSFUL_SHARDS , successfulShards ) ; builder . startArray ( Fields . FAILURES ) ; for ( SnapshotShardFailure shardFailure : shardFailures ) { builder . startObject ( ) ; shardFailure . toXContent ( builder , params ) ; builder . endObject ( ) ; } builder . endArray ( ) ; builder . endObject ( ) ; return builder ; } public static Snapshot fromXContent ( XContentParser parser ) throws IOException { String name = null ; Version version = Version . CURRENT ; SnapshotState state = SnapshotState . IN_PROGRESS ; String reason = null ; List < String > indices = Collections . emptyList ( ) ; long startTime = <int> ; long endTime = <int> ; int totalShard = <int> ; int successfulShards = <int> ; List < SnapshotShardFailure > shardFailures = NO_FAILURES ; if ( parser . currentToken ( ) = = null ) { parser . nextToken ( ) ; } if ( parser . currentToken ( ) = = XContentParser . Token . START_OBJECT ) { parser . nextToken ( ) ; } XContentParser . Token token ; if ( ( token = parser . nextToken ( ) ) = = XContentParser . Token . START_OBJECT ) { String currentFieldName = parser . currentName ( ) ; if ( <str> . equals ( currentFieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { name = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { state = SnapshotState . valueOf ( parser . text ( ) ) ; } else if ( <str> . equals ( currentFieldName ) ) { reason = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { startTime = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { endTime = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { totalShard = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { successfulShards = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { version = Version . fromId ( parser . intValue ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { ArrayList < String > indicesArray = new ArrayList < > ( ) ; while ( parser . nextToken ( ) ! = XContentParser . Token . END_ARRAY ) { indicesArray . add ( parser . text ( ) ) ; } indices = Collections . unmodifiableList ( indicesArray ) ; } else if ( <str> . equals ( currentFieldName ) ) { ArrayList < SnapshotShardFailure > shardFailureArrayList = new ArrayList < > ( ) ; while ( parser . nextToken ( ) ! = XContentParser . Token . END_ARRAY ) { shardFailureArrayList . add ( SnapshotShardFailure . fromXContent ( parser ) ) ; } shardFailures = Collections . unmodifiableList ( shardFailureArrayList ) ; } else { parser . skipChildren ( ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { parser . skipChildren ( ) ; } } } } } else { throw new ElasticsearchParseException ( <str> + token + <str> ) ; } return new Snapshot ( name , indices , state , reason , version , startTime , endTime , totalShard , successfulShards , shardFailures ) ; } } 
