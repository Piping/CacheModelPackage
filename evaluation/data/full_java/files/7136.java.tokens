package org . elasticsearch . search . aggregations ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . aggregations . InternalAggregation . ReduceContext ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; public class InternalAggregations implements Aggregations , ToXContent , Streamable { public final static InternalAggregations EMPTY = new InternalAggregations ( ) ; private List < InternalAggregation > aggregations = Collections . emptyList ( ) ; private Map < String , Aggregation > aggregationsAsMap ; private InternalAggregations ( ) { } public InternalAggregations ( List < InternalAggregation > aggregations ) { this . aggregations = aggregations ; } @Override public Iterator < Aggregation > iterator ( ) { return aggregations . stream ( ) . map ( ( p ) - > ( Aggregation ) p ) . iterator ( ) ; } @Override public List < Aggregation > asList ( ) { return aggregations . stream ( ) . map ( ( p ) - > ( Aggregation ) p ) . collect ( Collectors . toList ( ) ) ; } @Override public Map < String , Aggregation > asMap ( ) { return getAsMap ( ) ; } @Override public Map < String , Aggregation > getAsMap ( ) { if ( aggregationsAsMap = = null ) { Map < String , InternalAggregation > newAggregationsAsMap = new HashMap < > ( ) ; for ( InternalAggregation aggregation : aggregations ) { newAggregationsAsMap . put ( aggregation . getName ( ) , aggregation ) ; } this . aggregationsAsMap = unmodifiableMap ( newAggregationsAsMap ) ; } return aggregationsAsMap ; } @SuppressWarnings ( <str> ) @Override public < A extends Aggregation > A get ( String name ) { return ( A ) asMap ( ) . get ( name ) ; } @Override public Object getProperty ( String path ) { AggregationPath aggPath = AggregationPath . parse ( path ) ; return getProperty ( aggPath . getPathElementsAsStringList ( ) ) ; } public Object getProperty ( List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } String aggName = path . get ( <int> ) ; InternalAggregation aggregation = get ( aggName ) ; if ( aggregation = = null ) { throw new IllegalArgumentException ( <str> + aggName + <str> ) ; } return aggregation . getProperty ( path . subList ( <int> , path . size ( ) ) ) ; } public static InternalAggregations reduce ( List < InternalAggregations > aggregationsList , ReduceContext context ) { if ( aggregationsList . isEmpty ( ) ) { return null ; } Map < String , List < InternalAggregation > > aggByName = new HashMap < > ( ) ; for ( InternalAggregations aggregations : aggregationsList ) { for ( InternalAggregation aggregation : aggregations . aggregations ) { List < InternalAggregation > aggs = aggByName . get ( aggregation . getName ( ) ) ; if ( aggs = = null ) { aggs = new ArrayList < > ( aggregationsList . size ( ) ) ; aggByName . put ( aggregation . getName ( ) , aggs ) ; } aggs . add ( aggregation ) ; } } List < InternalAggregation > reducedAggregations = new ArrayList < > ( ) ; for ( Map . Entry < String , List < InternalAggregation > > entry : aggByName . entrySet ( ) ) { List < InternalAggregation > aggregations = entry . getValue ( ) ; InternalAggregation first = aggregations . get ( <int> ) ; reducedAggregations . add ( first . reduce ( aggregations , context ) ) ; } return new InternalAggregations ( reducedAggregations ) ; } static class Fields { public static final XContentBuilderString AGGREGATIONS = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( aggregations . isEmpty ( ) ) { return builder ; } builder . startObject ( Fields . AGGREGATIONS ) ; toXContentInternal ( builder , params ) ; return builder . endObject ( ) ; } public XContentBuilder toXContentInternal ( XContentBuilder builder , Params params ) throws IOException { for ( Aggregation aggregation : aggregations ) { ( ( InternalAggregation ) aggregation ) . toXContent ( builder , params ) ; } return builder ; } public static InternalAggregations readAggregations ( StreamInput in ) throws IOException { InternalAggregations result = new InternalAggregations ( ) ; result . readFrom ( in ) ; return result ; } public static InternalAggregations readOptionalAggregations ( StreamInput in ) throws IOException { return in . readOptionalStreamable ( InternalAggregations : : new ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { int size = in . readVInt ( ) ; if ( size = = <int> ) { aggregations = Collections . emptyList ( ) ; aggregationsAsMap = emptyMap ( ) ; } else { aggregations = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { BytesReference type = in . readBytesReference ( ) ; InternalAggregation aggregation = AggregationStreams . stream ( type ) . readResult ( in ) ; aggregations . add ( aggregation ) ; } } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( aggregations . size ( ) ) ; for ( Aggregation aggregation : aggregations ) { InternalAggregation internal = ( InternalAggregation ) aggregation ; out . writeBytesReference ( internal . type ( ) . stream ( ) ) ; internal . writeTo ( out ) ; } } } 
