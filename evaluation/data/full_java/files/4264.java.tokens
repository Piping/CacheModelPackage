package org . eclipse . debug . internal . ui . model . elements ; import java . util . LinkedList ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ICheckUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementLabelProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . ui . progress . UIJob ; public abstract class ElementLabelProvider implements IElementLabelProvider { private Job fLabelJob = null ; interface ILabelJob { public boolean queue ( ILabelUpdate [ ] updates ) ; } class LabelJob extends Job implements ILabelJob { private LabelUpdater fUpdater = new LabelUpdater ( ) ; public LabelJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { fUpdater . run ( ) ; return Status . OK_STATUS ; } @Override public boolean queue ( ILabelUpdate [ ] updates ) { return fUpdater . queue ( updates ) ; } @Override public boolean shouldRun ( ) { return fUpdater . shouldRun ( ) ; } } class UILabelJob extends UIJob implements ILabelJob { private LabelUpdater fUpdater = new LabelUpdater ( ) ; public UILabelJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { fUpdater . run ( ) ; return Status . OK_STATUS ; } @Override public boolean queue ( ILabelUpdate [ ] updates ) { return fUpdater . queue ( updates ) ; } @Override public boolean shouldRun ( ) { return fUpdater . shouldRun ( ) ; } } class LabelUpdater implements Runnable { LinkedList < ILabelUpdate > fQueue = new LinkedList < ILabelUpdate > ( ) ; public synchronized boolean queue ( ILabelUpdate [ ] updates ) { if ( fQueue = = null ) { return false ; } else { for ( int i = <int> ; i < updates . length ; i + + ) { fQueue . addLast ( updates [ i ] ) ; } return true ; } } @Override public void run ( ) { ILabelUpdate update = getNextUpdate ( ) ; while ( update ! = null ) { ISchedulingRule rule = getRule ( update ) ; if ( ! update . isCanceled ( ) ) { try { if ( rule ! = null ) { Job . getJobManager ( ) . beginRule ( rule , null ) ; } retrieveLabel ( update ) ; } catch ( CoreException e ) { update . setStatus ( e . getStatus ( ) ) ; } finally { if ( rule ! = null ) { Job . getJobManager ( ) . endRule ( rule ) ; } } } update . done ( ) ; update = getNextUpdate ( ) ; } } public synchronized ILabelUpdate getNextUpdate ( ) { if ( fQueue = = null ) { return null ; } if ( fQueue . isEmpty ( ) ) { fQueue = null ; return null ; } return fQueue . removeFirst ( ) ; } public boolean shouldRun ( ) { return fQueue ! = null ; } } protected void retrieveLabel ( ILabelUpdate update ) throws CoreException { String [ ] columnIds = update . getColumnIds ( ) ; IPresentationContext presentationContext = update . getPresentationContext ( ) ; TreePath elementPath = update . getElementPath ( ) ; int numColumns = <int> ; if ( columnIds ! = null ) { numColumns = columnIds . length ; } for ( int i = <int> ; i < numColumns ; i + + ) { String columnId = null ; if ( columnIds ! = null ) { columnId = columnIds [ i ] ; } update . setLabel ( getLabel ( elementPath , presentationContext , columnId , i ) , i ) ; update . setImageDescriptor ( getImageDescriptor ( elementPath , presentationContext , columnId , i ) , i ) ; update . setBackground ( getBackground ( elementPath , presentationContext , columnId ) , i ) ; update . setForeground ( getForeground ( elementPath , presentationContext , columnId ) , i ) ; update . setFontData ( getFontData ( elementPath , presentationContext , columnId ) , i ) ; if ( update instanceof ICheckUpdate & & Boolean . TRUE . equals ( presentationContext . getProperty ( ICheckUpdate . PROP_CHECK ) ) ) { ( ( ICheckUpdate ) update ) . setChecked ( getChecked ( elementPath , presentationContext ) , getGrayed ( elementPath , presentationContext ) ) ; } } } protected FontData getFontData ( TreePath elementPath , IPresentationContext presentationContext , String columnId ) throws CoreException { return null ; } protected RGB getForeground ( TreePath elementPath , IPresentationContext presentationContext , String columnId ) throws CoreException { return null ; } protected RGB getBackground ( TreePath elementPath , IPresentationContext presentationContext , String columnId ) throws CoreException { return null ; } protected ImageDescriptor getImageDescriptor ( TreePath elementPath , IPresentationContext presentationContext , String columnId ) throws CoreException { return null ; } protected ImageDescriptor getImageDescriptor ( TreePath elementPath , IPresentationContext presentationContext , String columnId , int columnIndex ) throws CoreException { return getImageDescriptor ( elementPath , presentationContext , columnId ) ; } protected abstract String getLabel ( TreePath elementPath , IPresentationContext presentationContext , String columnId ) throws CoreException ; protected String getLabel ( TreePath elementPath , IPresentationContext presentationContext , String columnId , int columnIndex ) throws CoreException { return getLabel ( elementPath , presentationContext , columnId ) ; } protected boolean getChecked ( TreePath path , IPresentationContext presentationContext ) throws CoreException { return false ; } protected boolean getGrayed ( TreePath path , IPresentationContext presentationContext ) throws CoreException { return false ; } @Override public synchronized void update ( ILabelUpdate [ ] updates ) { if ( fLabelJob = = null ) { fLabelJob = newLabelJob ( updates ) ; } if ( ! ( ( ILabelJob ) fLabelJob ) . queue ( updates ) ) { fLabelJob = newLabelJob ( updates ) ; ( ( ILabelJob ) fLabelJob ) . queue ( updates ) ; } fLabelJob . schedule ( ) ; } private Job newLabelJob ( ILabelUpdate [ ] updates ) { if ( requiresUIJob ( updates ) ) { return new UILabelJob ( ) ; } else { return new LabelJob ( ) ; } } protected boolean requiresUIJob ( ILabelUpdate [ ] updates ) { return false ; } protected ISchedulingRule getRule ( ILabelUpdate update ) { return null ; } } 
