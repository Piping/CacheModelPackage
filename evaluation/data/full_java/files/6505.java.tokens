package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . * ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . fielddata . * ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . fielddata . fieldcomparator . DoubleValuesComparatorSource ; import org . elasticsearch . index . fielddata . fieldcomparator . FloatValuesComparatorSource ; import org . elasticsearch . index . fielddata . fieldcomparator . LongValuesComparatorSource ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . search . MultiValueMode ; import java . io . IOException ; import java . util . Collection ; import java . util . Collections ; public class SortedNumericDVIndexFieldData extends DocValuesIndexFieldData implements IndexNumericFieldData { private final NumericType numericType ; public SortedNumericDVIndexFieldData ( Index index , Names fieldNames , NumericType numericType , FieldDataType fieldDataType ) { super ( index , fieldNames , fieldDataType ) ; if ( numericType = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . numericType = numericType ; } @Override public org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource comparatorSource ( Object missingValue , MultiValueMode sortMode , Nested nested ) { switch ( numericType ) { case FLOAT : return new FloatValuesComparatorSource ( this , missingValue , sortMode , nested ) ; case DOUBLE : return new DoubleValuesComparatorSource ( this , missingValue , sortMode , nested ) ; default : assert ! numericType . isFloatingPoint ( ) ; return new LongValuesComparatorSource ( this , missingValue , sortMode , nested ) ; } } @Override public NumericType getNumericType ( ) { return numericType ; } @Override public AtomicNumericFieldData loadDirect ( LeafReaderContext context ) throws Exception { return load ( context ) ; } @Override public AtomicNumericFieldData load ( LeafReaderContext context ) { final LeafReader reader = context . reader ( ) ; final String field = fieldNames . indexName ( ) ; switch ( numericType ) { case FLOAT : return new SortedNumericFloatFieldData ( reader , field ) ; case DOUBLE : return new SortedNumericDoubleFieldData ( reader , field ) ; default : return new SortedNumericLongFieldData ( reader , field ) ; } } static final class SortedNumericLongFieldData extends AtomicLongFieldData { final LeafReader reader ; final String field ; SortedNumericLongFieldData ( LeafReader reader , String field ) { super ( <int> L ) ; this . reader = reader ; this . field = field ; } @Override public SortedNumericDocValues getLongValues ( ) { try { return DocValues . getSortedNumeric ( reader , field ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } } static final class SortedNumericFloatFieldData extends AtomicDoubleFieldData { final LeafReader reader ; final String field ; SortedNumericFloatFieldData ( LeafReader reader , String field ) { super ( <int> L ) ; this . reader = reader ; this . field = field ; } @Override public SortedNumericDoubleValues getDoubleValues ( ) { try { SortedNumericDocValues raw = DocValues . getSortedNumeric ( reader , field ) ; NumericDocValues single = DocValues . unwrapSingleton ( raw ) ; if ( single ! = null ) { return FieldData . singleton ( new SingleFloatValues ( single ) , DocValues . unwrapSingletonBits ( raw ) ) ; } else { return new MultiFloatValues ( raw ) ; } } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } } static final class SingleFloatValues extends NumericDoubleValues { final NumericDocValues in ; SingleFloatValues ( NumericDocValues in ) { this . in = in ; } @Override public double get ( int docID ) { return NumericUtils . sortableIntToFloat ( ( int ) in . get ( docID ) ) ; } } static final class MultiFloatValues extends SortedNumericDoubleValues { final SortedNumericDocValues in ; MultiFloatValues ( SortedNumericDocValues in ) { this . in = in ; } @Override public void setDocument ( int doc ) { in . setDocument ( doc ) ; } @Override public double valueAt ( int index ) { return NumericUtils . sortableIntToFloat ( ( int ) in . valueAt ( index ) ) ; } @Override public int count ( ) { return in . count ( ) ; } } static final class SortedNumericDoubleFieldData extends AtomicDoubleFieldData { final LeafReader reader ; final String field ; SortedNumericDoubleFieldData ( LeafReader reader , String field ) { super ( <int> L ) ; this . reader = reader ; this . field = field ; } @Override public SortedNumericDoubleValues getDoubleValues ( ) { try { SortedNumericDocValues raw = DocValues . getSortedNumeric ( reader , field ) ; return FieldData . sortableLongBitsToDoubles ( raw ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } } } 
