package com . badlogic . gdx . graphics . glutils ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . TextureData ; import com . badlogic . gdx . graphics . glutils . ETC1 . ETC1Data ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class ETC1TextureData implements TextureData { FileHandle file ; ETC1Data data ; boolean useMipMaps ; int width = <int> ; int height = <int> ; boolean isPrepared = false ; public ETC1TextureData ( FileHandle file ) { this ( file , false ) ; } public ETC1TextureData ( FileHandle file , boolean useMipMaps ) { this . file = file ; this . useMipMaps = useMipMaps ; } public ETC1TextureData ( ETC1Data encodedImage , boolean useMipMaps ) { this . data = encodedImage ; this . useMipMaps = useMipMaps ; } @Override public TextureDataType getType ( ) { return TextureDataType . Custom ; } @Override public boolean isPrepared ( ) { return isPrepared ; } @Override public void prepare ( ) { if ( isPrepared ) throw new GdxRuntimeException ( <str> ) ; if ( file = = null & & data = = null ) throw new GdxRuntimeException ( <str> ) ; if ( file ! = null ) { data = new ETC1Data ( file ) ; } width = data . width ; height = data . height ; isPrepared = true ; } @Override public void consumeCustomData ( int target ) { if ( ! isPrepared ) throw new GdxRuntimeException ( <str> ) ; if ( ! Gdx . graphics . supportsExtension ( <str> ) ) { Pixmap pixmap = ETC1 . decodeImage ( data , Format . RGB565 ) ; Gdx . gl . glTexImage2D ( target , <int> , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; if ( useMipMaps ) MipMapGenerator . generateMipMap ( target , pixmap , pixmap . getWidth ( ) , pixmap . getHeight ( ) ) ; pixmap . dispose ( ) ; useMipMaps = false ; } else { Gdx . gl . glCompressedTexImage2D ( target , <int> , ETC1 . ETC1_RGB8_OES , width , height , <int> , data . compressedData . capacity ( ) - data . dataOffset , data . compressedData ) ; if ( useMipMaps ( ) ) Gdx . gl20 . glGenerateMipmap ( GL20 . GL_TEXTURE_2D ) ; } data . dispose ( ) ; data = null ; isPrepared = false ; } @Override public Pixmap consumePixmap ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public boolean disposePixmap ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public int getWidth ( ) { return width ; } @Override public int getHeight ( ) { return height ; } @Override public Format getFormat ( ) { return Format . RGB565 ; } @Override public boolean useMipMaps ( ) { return useMipMaps ; } @Override public boolean isManaged ( ) { return true ; } } 
