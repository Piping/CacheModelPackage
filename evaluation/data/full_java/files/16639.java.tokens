package org . junit . tests . experimental . theories . internal ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotEquals ; import static org . junit . Assert . assertThat ; import static org . junit . tests . experimental . theories . TheoryTestUtils . potentialAssignments ; import java . util . Arrays ; import java . util . List ; import org . junit . Rule ; import org . junit . Test ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . ParameterSignature ; import org . junit . experimental . theories . PotentialAssignment ; import org . junit . experimental . theories . Theory ; import org . junit . experimental . theories . internal . AllMembersSupplier ; import org . junit . rules . ExpectedException ; import org . junit . runners . model . TestClass ; public class AllMembersSupplierTest { @Rule public ExpectedException expected = ExpectedException . none ( ) ; public static class HasDataPointsArrayField { @DataPoints public static String [ ] list = new String [ ] { <str> , <str> } ; @Theory public void theory ( String param ) { } } @Test public void dataPointsArrayShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayField . class . getMethod ( <str> , String . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } public static class HasDataPointsArrayWithMatchingButInaccurateTypes { @DataPoints public static Object [ ] objects = { <int> , <str> , <int> } ; @Theory public void theory ( Integer param ) { } } @Test public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsArrayWithMatchingButInaccurateTypes . class . getMethod ( <str> , Integer . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } public static class HasDataPointMethodWithOverlyGeneralTypes { @DataPoint public static Integer object ( ) { return <int> ; } @Theory public void theory ( Object param ) { } } @Test public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointMethodWithOverlyGeneralTypes . class . getMethod ( <str> , Object . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } public static class HasDataPointsWithObjectParameter { @DataPoints public static Object [ ] objectField = { <int> , <int> } ; @Theory public void theory ( Object obj ) { } } @Test public void dataPointsAnnotationMeansTreatAsArrayOnly ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsWithObjectParameter . class . getMethod ( <str> , Object . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; for ( PotentialAssignment assignment : assignments ) { assertNotEquals ( HasDataPointsWithObjectParameter . objectField , assignment . getValue ( ) ) ; } } public static class HasDataPointsFieldWithNullValue { @DataPoints public static Object [ ] objects = { null , <str> } ; public HasDataPointsFieldWithNullValue ( Object obj ) { } } @Test public void dataPointsArrayFieldMayContainNullValue ( ) throws Throwable { List < PotentialAssignment > valueSources = allMemberValuesFor ( HasDataPointsFieldWithNullValue . class , Object . class ) ; assertThat ( valueSources . size ( ) , is ( <int> ) ) ; } public static class HasDataPointsMethodWithNullValue { @DataPoints public static Integer [ ] getObjects ( ) { return new Integer [ ] { null , <int> } ; } public HasDataPointsMethodWithNullValue ( Integer i ) { } } @Test public void dataPointsArrayMethodMayContainNullValue ( ) throws Throwable { List < PotentialAssignment > valueSources = allMemberValuesFor ( HasDataPointsMethodWithNullValue . class , Integer . class ) ; assertThat ( valueSources . size ( ) , is ( <int> ) ) ; } public static class HasFailingDataPointsArrayMethod { @DataPoints public static Object [ ] objects ( ) { throw new RuntimeException ( <str> ) ; } public HasFailingDataPointsArrayMethod ( Object obj ) { } } @Test public void allMembersFailsOnFailingDataPointsArrayMethod ( ) throws Throwable { expected . expect ( RuntimeException . class ) ; expected . expectMessage ( <str> ) ; allMemberValuesFor ( HasFailingDataPointsArrayMethod . class , Object . class ) ; } private List < PotentialAssignment > allMemberValuesFor ( Class < ? > testClass , Class < ? > . . . constructorParameterTypes ) throws Throwable { return new AllMembersSupplier ( new TestClass ( testClass ) ) . getValueSources ( ParameterSignature . signatures ( testClass . getConstructor ( constructorParameterTypes ) ) . get ( <int> ) ) ; } public static class HasDataPointsListField { @DataPoints public static List < String > list = Arrays . asList ( <str> , <str> ) ; @Theory public void theory ( String param ) { } } @Test public void dataPointsCollectionFieldsShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListField . class . getMethod ( <str> , String . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } public static class HasDataPointsListMethod { @DataPoints public static List < String > getList ( ) { return Arrays . asList ( <str> , <str> ) ; } @Theory public void theory ( String param ) { } } @Test public void dataPointsCollectionMethodShouldBeRecognized ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListMethod . class . getMethod ( <str> , String . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } public static class HasDataPointsListFieldWithOverlyGenericTypes { @DataPoints public static List < Object > list = Arrays . asList ( <str> , new Object ( ) ) ; @Theory public void theory ( String param ) { } } @Test public void dataPointsCollectionShouldBeRecognizedIgnoringStrangeTypes ( ) throws Throwable { List < PotentialAssignment > assignments = potentialAssignments ( HasDataPointsListFieldWithOverlyGenericTypes . class . getMethod ( <str> , String . class ) ) ; assertEquals ( <int> , assignments . size ( ) ) ; } } 
