package org . gradle . api . internal . tasks ; import org . gradle . api . Buildable ; import org . gradle . api . GradleException ; import org . gradle . api . Task ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . internal . graph . CachingDirectedGraphWalker ; import org . gradle . internal . graph . DirectedGraph ; import java . util . Collection ; import java . util . LinkedList ; import java . util . Set ; public class CachingTaskDependencyResolveContext implements TaskDependencyResolveContext , TaskDependency { private final LinkedList < Object > queue = new LinkedList < Object > ( ) ; private final CachingDirectedGraphWalker < Object , Task > walker = new CachingDirectedGraphWalker < Object , Task > ( new TaskGraphImpl ( ) ) ; private Task task ; public Set < ? extends Task > getDependencies ( Task task ) { add ( task . getTaskDependencies ( ) ) ; return resolve ( task ) ; } public Task getTask ( ) { return task ; } public Set < Task > resolve ( Task task ) { this . task = task ; try { return doResolve ( ) ; } catch ( Exception e ) { throw new GradleException ( String . format ( <str> , task ) , e ) ; } finally { queue . clear ( ) ; this . task = null ; } } private Set < Task > doResolve ( ) { walker . add ( queue ) ; return walker . findValues ( ) ; } public void add ( Object dependency ) { queue . add ( dependency ) ; } private class TaskGraphImpl implements DirectedGraph < Object , Task > { public void getNodeValues ( Object node , Collection < ? super Task > values , Collection < ? super Object > connectedNodes ) { if ( node instanceof TaskDependencyContainer ) { TaskDependencyContainer taskDependency = ( TaskDependencyContainer ) node ; queue . clear ( ) ; taskDependency . visitDependencies ( CachingTaskDependencyResolveContext . this ) ; connectedNodes . addAll ( queue ) ; } else if ( node instanceof Buildable ) { Buildable buildable = ( Buildable ) node ; connectedNodes . add ( buildable . getBuildDependencies ( ) ) ; } else if ( node instanceof TaskDependency ) { TaskDependency dependency = ( TaskDependency ) node ; values . addAll ( dependency . getDependencies ( task ) ) ; } else if ( node instanceof Task ) { values . add ( ( Task ) node ) ; } else { throw new IllegalArgumentException ( String . format ( <str> , node . getClass ( ) . getSimpleName ( ) ) ) ; } } } } 
