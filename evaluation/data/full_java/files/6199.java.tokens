package org . elasticsearch . gateway ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . env . NodeEnvironment ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; public class DanglingIndicesState extends AbstractComponent { private final NodeEnvironment nodeEnv ; private final MetaStateService metaStateService ; private final LocalAllocateDangledIndices allocateDangledIndices ; private final Map < String , IndexMetaData > danglingIndices = ConcurrentCollections . newConcurrentMap ( ) ; @Inject public DanglingIndicesState ( Settings settings , NodeEnvironment nodeEnv , MetaStateService metaStateService , LocalAllocateDangledIndices allocateDangledIndices ) { super ( settings ) ; this . nodeEnv = nodeEnv ; this . metaStateService = metaStateService ; this . allocateDangledIndices = allocateDangledIndices ; } public void processDanglingIndices ( MetaData metaData ) { if ( nodeEnv . hasNodeFile ( ) = = false ) { return ; } cleanupAllocatedDangledIndices ( metaData ) ; findNewAndAddDanglingIndices ( metaData ) ; allocateDanglingIndices ( ) ; } Map < String , IndexMetaData > getDanglingIndices ( ) { return unmodifiableMap ( new HashMap < > ( danglingIndices ) ) ; } void cleanupAllocatedDangledIndices ( MetaData metaData ) { for ( String danglingIndex : danglingIndices . keySet ( ) ) { if ( metaData . hasIndex ( danglingIndex ) ) { logger . debug ( <str> , danglingIndex ) ; danglingIndices . remove ( danglingIndex ) ; } } } void findNewAndAddDanglingIndices ( MetaData metaData ) { danglingIndices . putAll ( findNewDanglingIndices ( metaData ) ) ; } Map < String , IndexMetaData > findNewDanglingIndices ( MetaData metaData ) { final Set < String > indices ; try { indices = nodeEnv . findAllIndices ( ) ; } catch ( Throwable e ) { logger . warn ( <str> , e ) ; return emptyMap ( ) ; } Map < String , IndexMetaData > newIndices = new HashMap < > ( ) ; for ( String indexName : indices ) { if ( metaData . hasIndex ( indexName ) = = false & & danglingIndices . containsKey ( indexName ) = = false ) { try { IndexMetaData indexMetaData = metaStateService . loadIndexState ( indexName ) ; if ( indexMetaData ! = null ) { logger . info ( <str> , indexName ) ; if ( ! indexMetaData . getIndex ( ) . equals ( indexName ) ) { logger . info ( <str> , indexName , indexMetaData . getIndex ( ) ) ; indexMetaData = IndexMetaData . builder ( indexMetaData ) . index ( indexName ) . build ( ) ; } newIndices . put ( indexName , indexMetaData ) ; } else { logger . debug ( <str> , indexName ) ; } } catch ( Throwable t ) { logger . warn ( <str> , t , indexName ) ; } } } return newIndices ; } private void allocateDanglingIndices ( ) { if ( danglingIndices . isEmpty ( ) = = true ) { return ; } try { allocateDangledIndices . allocateDangled ( Collections . unmodifiableCollection ( new ArrayList < > ( danglingIndices . values ( ) ) ) , new LocalAllocateDangledIndices . Listener ( ) { @Override public void onResponse ( LocalAllocateDangledIndices . AllocateDangledResponse response ) { logger . trace ( <str> ) ; } @Override public void onFailure ( Throwable e ) { logger . info ( <str> , e ) ; } } ) ; } catch ( Throwable e ) { logger . warn ( <str> , e ) ; } } } 
