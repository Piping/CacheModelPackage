package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . admin . indices . refresh . RefreshRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . TermQueryBuilder ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTerms ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTerms . Bucket ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsAggregatorFactory . ExecutionMode ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsBuilder ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . ChiSquare ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . GND ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . JLHScore ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . MutualInformation ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . PercentageScore ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Set ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . hasSize ; import static org . hamcrest . Matchers . is ; @ESIntegTestCase.SuiteScopeTestCase public class SignificantTermsIT extends ESIntegTestCase { public String randomExecutionHint ( ) { return randomBoolean ( ) ? null : randomFrom ( ExecutionMode . values ( ) ) . toString ( ) ; } @Override public Settings indexSettings ( ) { return Settings . builder ( ) . put ( <str> , numberOfShards ( ) ) . put ( <str> , numberOfReplicas ( ) ) . build ( ) ; } public static final int MUSIC_CATEGORY = <int> ; public static final int OTHER_CATEGORY = <int> ; public static final int SNOWBOARDING_CATEGORY = <int> ; @Override public void setupSuiteScopeCluster ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; createIndex ( <str> ) ; ensureGreen ( ) ; String data [ ] = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( int i = <int> ; i < data . length ; i + + ) { String [ ] parts = data [ i ] . split ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setRouting ( parts [ <int> ] ) . setSource ( <str> , parts [ <int> ] , <str> , parts [ <int> ] ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . refresh ( new RefreshRequest ( <str> ) ) . get ( ) ; } public void testStructuredAnalysis ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; Number topCategory = ( Number ) topTerms . getBuckets ( ) . iterator ( ) . next ( ) . getKey ( ) ; assertTrue ( topCategory . equals ( new Long ( SNOWBOARDING_CATEGORY ) ) ) ; } public void testStructuredAnalysisWithIncludeExclude ( ) throws Exception { long [ ] excludeTerms = { MUSIC_CATEGORY } ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) . exclude ( excludeTerms ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; Number topCategory = ( Number ) topTerms . getBuckets ( ) . iterator ( ) . next ( ) . getKey ( ) ; assertTrue ( topCategory . equals ( new Long ( OTHER_CATEGORY ) ) ) ; } public void testIncludeExclude ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . exclude ( <str> ) ) . get ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; Set < String > terms = new HashSet < > ( ) ; for ( Bucket topTerm : topTerms ) { terms . add ( topTerm . getKeyAsString ( ) ) ; } assertThat ( terms , hasSize ( <int> ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; response = client ( ) . prepareSearch ( <str> ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . include ( <str> ) ) . get ( ) ; assertSearchResponse ( response ) ; topTerms = response . getAggregations ( ) . get ( <str> ) ; terms = new HashSet < > ( ) ; for ( Bucket topTerm : topTerms ) { terms . add ( topTerm . getKeyAsString ( ) ) ; } assertThat ( terms , hasSize ( <int> ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; } public void testIncludeExcludeExactValues ( ) throws Exception { String [ ] incExcTerms = { <str> , <str> } ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . exclude ( incExcTerms ) ) . get ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; Set < String > terms = new HashSet < > ( ) ; for ( Bucket topTerm : topTerms ) { terms . add ( topTerm . getKeyAsString ( ) ) ; } assertEquals ( new HashSet < String > ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) , terms ) ; response = client ( ) . prepareSearch ( <str> ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . include ( incExcTerms ) ) . get ( ) ; assertSearchResponse ( response ) ; topTerms = response . getAggregations ( ) . get ( <str> ) ; terms = new HashSet < > ( ) ; for ( Bucket topTerm : topTerms ) { terms . add ( topTerm . getKeyAsString ( ) ) ; } assertThat ( terms , hasSize ( <int> ) ) ; assertThat ( terms . contains ( <str> ) , is ( true ) ) ; } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( topTerms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testTextAnalysis ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } public void testTextAnalysisGND ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( new GND . GNDBuilder ( true ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } public void testTextAnalysisChiSquare ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( new ChiSquare . ChiSquareBuilder ( false , true ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } public void testTextAnalysisPercentageScore ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( new PercentageScore . PercentageScoreBuilder ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } public void testBadFilteredAnalysis ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . backgroundFilter ( QueryBuilders . termQuery ( <str> , <int> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; boolean hasMissingBackgroundTerms = false ; for ( Bucket topTerm : topTerms ) { if ( topTerm . getSupersetDf ( ) = = <int> ) { hasMissingBackgroundTerms = true ; break ; } } assertTrue ( hasMissingBackgroundTerms ) ; } public void testFilteredAnalysis ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . backgroundFilter ( QueryBuilders . termsQuery ( <str> , <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; HashSet < String > topWords = new HashSet < String > ( ) ; for ( Bucket topTerm : topTerms ) { topWords . add ( topTerm . getKeyAsString ( ) ) ; } assertFalse ( topWords . contains ( <str> ) ) ; assertTrue ( topWords . contains ( <str> ) ) ; } public void testNestedAggs ( ) throws Exception { String [ ] [ ] expectedKeywordsByCategory = { { <str> , <str> , <str> , <str> , <str> } , { <str> , <str> } , { <str> , <str> , <str> , <str> , <str> } } ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . addAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) . minDocCount ( <int> ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms topCategoryTerms = response . getAggregations ( ) . get ( <str> ) ; for ( org . elasticsearch . search . aggregations . bucket . terms . Terms . Bucket topCategory : topCategoryTerms . getBuckets ( ) ) { SignificantTerms topTerms = topCategory . getAggregations ( ) . get ( <str> ) ; HashSet < String > foundTopWords = new HashSet < String > ( ) ; for ( Bucket topTerm : topTerms ) { foundTopWords . add ( topTerm . getKeyAsString ( ) ) ; } String [ ] expectedKeywords = expectedKeywordsByCategory [ Integer . parseInt ( topCategory . getKeyAsString ( ) ) - <int> ] ; for ( String expectedKeyword : expectedKeywords ) { assertTrue ( expectedKeyword + <str> , foundTopWords . contains ( expectedKeyword ) ) ; } } } public void testPartiallyUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } private void checkExpectedStringTermsFound ( SignificantTerms topTerms ) { HashMap < String , Bucket > topWords = new HashMap < > ( ) ; for ( Bucket topTerm : topTerms ) { topWords . put ( topTerm . getKeyAsString ( ) , topTerm ) ; } assertTrue ( topWords . containsKey ( <str> ) ) ; assertTrue ( topWords . containsKey ( <str> ) ) ; assertTrue ( topWords . containsKey ( <str> ) ) ; assertTrue ( topWords . containsKey ( <str> ) ) ; assertTrue ( topWords . containsKey ( <str> ) ) ; Bucket kellyTerm = topWords . get ( <str> ) ; assertEquals ( <int> , kellyTerm . getSubsetDf ( ) ) ; assertEquals ( <int> , kellyTerm . getSupersetDf ( ) ) ; } public void testDefaultSignificanceHeuristic ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( new JLHScore . JLHScoreBuilder ( ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } public void testMutualInformation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( new MutualInformation . MutualInformationBuilder ( false , true ) ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; SignificantTerms topTerms = response . getAggregations ( ) . get ( <str> ) ; checkExpectedStringTermsFound ( topTerms ) ; } } 
