package io . netty . handler . codec . socksx . v4 ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socksx . v4 . Socks4ClientDecoder . State ; import io . netty . util . NetUtil ; import java . util . List ; public class Socks4ClientDecoder extends ReplayingDecoder < State > { enum State { START , SUCCESS , FAILURE } public Socks4ClientDecoder ( ) { super ( State . START ) ; setSingleDecode ( true ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( state ( ) ) { case START : { final int version = in . readUnsignedByte ( ) ; if ( version ! = <int> ) { throw new DecoderException ( <str> + version + <str> ) ; } final Socks4CommandStatus status = Socks4CommandStatus . valueOf ( in . readByte ( ) ) ; final int dstPort = in . readUnsignedShort ( ) ; final String dstAddr = NetUtil . intToIpAddress ( in . readInt ( ) ) ; out . add ( new DefaultSocks4CommandResponse ( status , dstAddr , dstPort ) ) ; checkpoint ( State . SUCCESS ) ; } case SUCCESS : { int readableBytes = actualReadableBytes ( ) ; if ( readableBytes > <int> ) { out . add ( in . readSlice ( readableBytes ) . retain ( ) ) ; } break ; } case FAILURE : { in . skipBytes ( actualReadableBytes ( ) ) ; break ; } } } catch ( Exception e ) { fail ( out , e ) ; } } private void fail ( List < Object > out , Throwable cause ) { if ( ! ( cause instanceof DecoderException ) ) { cause = new DecoderException ( cause ) ; } Socks4CommandResponse m = new DefaultSocks4CommandResponse ( Socks4CommandStatus . REJECTED_OR_FAILED ) ; m . setDecoderResult ( DecoderResult . failure ( cause ) ) ; out . add ( m ) ; checkpoint ( State . FAILURE ) ; } } 
