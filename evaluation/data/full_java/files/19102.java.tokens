package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . socket . ChannelInputShutdownEvent ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . util . ByteProcessor ; import io . netty . util . internal . AppendableCharSequence ; import java . util . List ; public abstract class HttpObjectDecoder extends ByteToMessageDecoder { private static final String EMPTY_VALUE = <str> ; private final int maxChunkSize ; private final boolean chunkedSupported ; protected final boolean validateHeaders ; private final HeaderParser headerParser ; private final LineParser lineParser ; private HttpMessage message ; private long chunkSize ; private long contentLength = Long . MIN_VALUE ; private volatile boolean resetRequested ; private CharSequence name ; private CharSequence value ; private LastHttpContent trailer ; private enum State { SKIP_CONTROL_CHARS , READ_INITIAL , READ_HEADER , READ_VARIABLE_LENGTH_CONTENT , READ_FIXED_LENGTH_CONTENT , READ_CHUNK_SIZE , READ_CHUNKED_CONTENT , READ_CHUNK_DELIMITER , READ_CHUNK_FOOTER , BAD_MESSAGE , UPGRADED } private State currentState = State . SKIP_CONTROL_CHARS ; protected HttpObjectDecoder ( ) { this ( <int> , <int> , <int> , true ) ; } protected HttpObjectDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , boolean chunkedSupported ) { this ( maxInitialLineLength , maxHeaderSize , maxChunkSize , chunkedSupported , true ) ; } protected HttpObjectDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , boolean chunkedSupported , boolean validateHeaders ) { if ( maxInitialLineLength < = <int> ) { throw new IllegalArgumentException ( <str> + maxInitialLineLength ) ; } if ( maxHeaderSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxHeaderSize ) ; } if ( maxChunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxChunkSize ) ; } this . maxChunkSize = maxChunkSize ; this . chunkedSupported = chunkedSupported ; this . validateHeaders = validateHeaders ; AppendableCharSequence seq = new AppendableCharSequence ( <int> ) ; lineParser = new LineParser ( seq , maxInitialLineLength ) ; headerParser = new HeaderParser ( seq , maxHeaderSize ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buffer , List < Object > out ) throws Exception { if ( resetRequested ) { resetNow ( ) ; } switch ( currentState ) { case SKIP_CONTROL_CHARS : { if ( ! skipControlCharacters ( buffer ) ) { return ; } currentState = State . READ_INITIAL ; } case READ_INITIAL : try { AppendableCharSequence line = lineParser . parse ( buffer ) ; if ( line = = null ) { return ; } String [ ] initialLine = splitInitialLine ( line ) ; if ( initialLine . length < <int> ) { currentState = State . SKIP_CONTROL_CHARS ; return ; } message = createMessage ( initialLine ) ; currentState = State . READ_HEADER ; } catch ( Exception e ) { out . add ( invalidMessage ( buffer , e ) ) ; return ; } case READ_HEADER : try { State nextState = readHeaders ( buffer ) ; if ( nextState = = null ) { return ; } currentState = nextState ; switch ( nextState ) { case SKIP_CONTROL_CHARS : out . add ( message ) ; out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; resetNow ( ) ; return ; case READ_CHUNK_SIZE : if ( ! chunkedSupported ) { throw new IllegalArgumentException ( <str> ) ; } out . add ( message ) ; return ; default : long contentLength = contentLength ( ) ; if ( contentLength = = <int> | | contentLength = = - <int> & & isDecodingRequest ( ) ) { out . add ( message ) ; out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; resetNow ( ) ; return ; } assert nextState = = State . READ_FIXED_LENGTH_CONTENT | | nextState = = State . READ_VARIABLE_LENGTH_CONTENT ; out . add ( message ) ; if ( nextState = = State . READ_FIXED_LENGTH_CONTENT ) { chunkSize = contentLength ; } return ; } } catch ( Exception e ) { out . add ( invalidMessage ( buffer , e ) ) ; return ; } case READ_VARIABLE_LENGTH_CONTENT : { int toRead = Math . min ( buffer . readableBytes ( ) , maxChunkSize ) ; if ( toRead > <int> ) { ByteBuf content = buffer . readSlice ( toRead ) . retain ( ) ; out . add ( new DefaultHttpContent ( content ) ) ; } return ; } case READ_FIXED_LENGTH_CONTENT : { int readLimit = buffer . readableBytes ( ) ; if ( readLimit = = <int> ) { return ; } int toRead = Math . min ( readLimit , maxChunkSize ) ; if ( toRead > chunkSize ) { toRead = ( int ) chunkSize ; } ByteBuf content = buffer . readSlice ( toRead ) . retain ( ) ; chunkSize - = toRead ; if ( chunkSize = = <int> ) { out . add ( new DefaultLastHttpContent ( content , validateHeaders ) ) ; resetNow ( ) ; } else { out . add ( new DefaultHttpContent ( content ) ) ; } return ; } case READ_CHUNK_SIZE : try { AppendableCharSequence line = lineParser . parse ( buffer ) ; if ( line = = null ) { return ; } int chunkSize = getChunkSize ( line . toString ( ) ) ; this . chunkSize = chunkSize ; if ( chunkSize = = <int> ) { currentState = State . READ_CHUNK_FOOTER ; return ; } currentState = State . READ_CHUNKED_CONTENT ; } catch ( Exception e ) { out . add ( invalidChunk ( buffer , e ) ) ; return ; } case READ_CHUNKED_CONTENT : { assert chunkSize < = Integer . MAX_VALUE ; int toRead = Math . min ( ( int ) chunkSize , maxChunkSize ) ; toRead = Math . min ( toRead , buffer . readableBytes ( ) ) ; if ( toRead = = <int> ) { return ; } HttpContent chunk = new DefaultHttpContent ( buffer . readSlice ( toRead ) . retain ( ) ) ; chunkSize - = toRead ; out . add ( chunk ) ; if ( chunkSize ! = <int> ) { return ; } currentState = State . READ_CHUNK_DELIMITER ; } case READ_CHUNK_DELIMITER : { final int wIdx = buffer . writerIndex ( ) ; int rIdx = buffer . readerIndex ( ) ; while ( wIdx > rIdx ) { byte next = buffer . getByte ( rIdx + + ) ; if ( next = = HttpConstants . LF ) { currentState = State . READ_CHUNK_SIZE ; break ; } } buffer . readerIndex ( rIdx ) ; return ; } case READ_CHUNK_FOOTER : try { LastHttpContent trailer = readTrailingHeaders ( buffer ) ; if ( trailer = = null ) { return ; } out . add ( trailer ) ; resetNow ( ) ; return ; } catch ( Exception e ) { out . add ( invalidChunk ( buffer , e ) ) ; return ; } case BAD_MESSAGE : { buffer . skipBytes ( buffer . readableBytes ( ) ) ; break ; } case UPGRADED : { int readableBytes = buffer . readableBytes ( ) ; if ( readableBytes > <int> ) { out . add ( buffer . readBytes ( readableBytes ) ) ; } break ; } } } @Override protected void decodeLast ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { decode ( ctx , in , out ) ; if ( message ! = null ) { boolean chunked = HttpUtil . isTransferEncodingChunked ( message ) ; if ( currentState = = State . READ_VARIABLE_LENGTH_CONTENT & & ! in . isReadable ( ) & & ! chunked ) { out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; reset ( ) ; return ; } boolean prematureClosure ; if ( isDecodingRequest ( ) | | chunked ) { prematureClosure = true ; } else { prematureClosure = contentLength ( ) > <int> ; } resetNow ( ) ; if ( ! prematureClosure ) { out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } } } @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof ChannelInputShutdownEvent ) { super . channelInactive ( ctx ) ; } else if ( evt instanceof HttpExpectationFailedEvent ) { switch ( currentState ) { case READ_FIXED_LENGTH_CONTENT : case READ_VARIABLE_LENGTH_CONTENT : case READ_CHUNK_SIZE : reset ( ) ; break ; default : break ; } } super . userEventTriggered ( ctx , evt ) ; } protected boolean isContentAlwaysEmpty ( HttpMessage msg ) { if ( msg instanceof HttpResponse ) { HttpResponse res = ( HttpResponse ) msg ; int code = res . status ( ) . code ( ) ; if ( code > = <int> & & code < <int> ) { return ! ( code = = <int> & & ! res . headers ( ) . contains ( HttpHeaderNames . SEC_WEBSOCKET_ACCEPT ) & & res . headers ( ) . contains ( HttpHeaderNames . UPGRADE , HttpHeaderValues . WEBSOCKET , true ) ) ; } switch ( code ) { case <int> : case <int> : case <int> : return true ; } } return false ; } public void reset ( ) { resetRequested = true ; } private void resetNow ( ) { HttpMessage message = this . message ; this . message = null ; name = null ; value = null ; contentLength = Long . MIN_VALUE ; lineParser . reset ( ) ; headerParser . reset ( ) ; trailer = null ; if ( ! isDecodingRequest ( ) ) { HttpResponse res = ( HttpResponse ) message ; if ( res ! = null & & res . status ( ) . code ( ) = = <int> ) { currentState = State . UPGRADED ; return ; } } currentState = State . SKIP_CONTROL_CHARS ; } private HttpMessage invalidMessage ( ByteBuf in , Exception cause ) { currentState = State . BAD_MESSAGE ; in . skipBytes ( in . readableBytes ( ) ) ; if ( message ! = null ) { message . setDecoderResult ( DecoderResult . failure ( cause ) ) ; } else { message = createInvalidMessage ( ) ; message . setDecoderResult ( DecoderResult . failure ( cause ) ) ; } HttpMessage ret = message ; message = null ; return ret ; } private HttpContent invalidChunk ( ByteBuf in , Exception cause ) { currentState = State . BAD_MESSAGE ; in . skipBytes ( in . readableBytes ( ) ) ; HttpContent chunk = new DefaultLastHttpContent ( Unpooled . EMPTY_BUFFER ) ; chunk . setDecoderResult ( DecoderResult . failure ( cause ) ) ; message = null ; trailer = null ; return chunk ; } private static boolean skipControlCharacters ( ByteBuf buffer ) { boolean skiped = false ; final int wIdx = buffer . writerIndex ( ) ; int rIdx = buffer . readerIndex ( ) ; while ( wIdx > rIdx ) { int c = buffer . getUnsignedByte ( rIdx + + ) ; if ( ! Character . isISOControl ( c ) & & ! Character . isWhitespace ( c ) ) { rIdx - - ; skiped = true ; break ; } } buffer . readerIndex ( rIdx ) ; return skiped ; } private State readHeaders ( ByteBuf buffer ) { final HttpMessage message = this . message ; final HttpHeaders headers = message . headers ( ) ; AppendableCharSequence line = headerParser . parse ( buffer ) ; if ( line = = null ) { return null ; } if ( line . length ( ) > <int> ) { do { char firstChar = line . charAt ( <int> ) ; if ( name ! = null & & ( firstChar = = <str> | | firstChar = = <str> ) ) { StringBuilder buf = new StringBuilder ( value . length ( ) + line . length ( ) + <int> ) ; buf . append ( value ) . append ( <str> ) . append ( line . toString ( ) . trim ( ) ) ; value = buf . toString ( ) ; } else { if ( name ! = null ) { headers . add ( name , value ) ; } splitHeader ( line ) ; } line = headerParser . parse ( buffer ) ; if ( line = = null ) { return null ; } } while ( line . length ( ) > <int> ) ; } if ( name ! = null ) { headers . add ( name , value ) ; } name = null ; value = null ; State nextState ; if ( isContentAlwaysEmpty ( message ) ) { HttpUtil . setTransferEncodingChunked ( message , false ) ; nextState = State . SKIP_CONTROL_CHARS ; } else if ( HttpUtil . isTransferEncodingChunked ( message ) ) { nextState = State . READ_CHUNK_SIZE ; } else if ( contentLength ( ) > = <int> ) { nextState = State . READ_FIXED_LENGTH_CONTENT ; } else { nextState = State . READ_VARIABLE_LENGTH_CONTENT ; } return nextState ; } private long contentLength ( ) { if ( contentLength = = Long . MIN_VALUE ) { contentLength = HttpUtil . getContentLength ( message , - <int> ) ; } return contentLength ; } private LastHttpContent readTrailingHeaders ( ByteBuf buffer ) { AppendableCharSequence line = headerParser . parse ( buffer ) ; if ( line = = null ) { return null ; } CharSequence lastHeader = null ; if ( line . length ( ) > <int> ) { LastHttpContent trailer = this . trailer ; if ( trailer = = null ) { trailer = this . trailer = new DefaultLastHttpContent ( Unpooled . EMPTY_BUFFER , validateHeaders ) ; } do { char firstChar = line . charAt ( <int> ) ; if ( lastHeader ! = null & & ( firstChar = = <str> | | firstChar = = <str> ) ) { List < String > current = trailer . trailingHeaders ( ) . getAll ( lastHeader ) ; if ( ! current . isEmpty ( ) ) { int lastPos = current . size ( ) - <int> ; String lineTrimmed = line . toString ( ) . trim ( ) ; CharSequence currentLastPos = current . get ( lastPos ) ; StringBuilder b = new StringBuilder ( currentLastPos . length ( ) + lineTrimmed . length ( ) ) ; b . append ( currentLastPos ) . append ( lineTrimmed ) ; current . set ( lastPos , b . toString ( ) ) ; } else { } } else { splitHeader ( line ) ; CharSequence headerName = name ; if ( ! HttpHeaderNames . CONTENT_LENGTH . contentEqualsIgnoreCase ( headerName ) & & ! HttpHeaderNames . TRANSFER_ENCODING . contentEqualsIgnoreCase ( headerName ) & & ! HttpHeaderNames . TRAILER . contentEqualsIgnoreCase ( headerName ) ) { trailer . trailingHeaders ( ) . add ( headerName , value ) ; } lastHeader = name ; name = null ; value = null ; } line = headerParser . parse ( buffer ) ; if ( line = = null ) { return null ; } } while ( line . length ( ) > <int> ) ; this . trailer = null ; return trailer ; } return LastHttpContent . EMPTY_LAST_CONTENT ; } protected abstract boolean isDecodingRequest ( ) ; protected abstract HttpMessage createMessage ( String [ ] initialLine ) throws Exception ; protected abstract HttpMessage createInvalidMessage ( ) ; private static int getChunkSize ( String hex ) { hex = hex . trim ( ) ; for ( int i = <int> ; i < hex . length ( ) ; i + + ) { char c = hex . charAt ( i ) ; if ( c = = <str> | | Character . isWhitespace ( c ) | | Character . isISOControl ( c ) ) { hex = hex . substring ( <int> , i ) ; break ; } } return Integer . parseInt ( hex , <int> ) ; } private static String [ ] splitInitialLine ( AppendableCharSequence sb ) { int aStart ; int aEnd ; int bStart ; int bEnd ; int cStart ; int cEnd ; aStart = findNonWhitespace ( sb , <int> ) ; aEnd = findWhitespace ( sb , aStart ) ; bStart = findNonWhitespace ( sb , aEnd ) ; bEnd = findWhitespace ( sb , bStart ) ; cStart = findNonWhitespace ( sb , bEnd ) ; cEnd = findEndOfString ( sb ) ; return new String [ ] { sb . subStringUnsafe ( aStart , aEnd ) , sb . subStringUnsafe ( bStart , bEnd ) , cStart < cEnd ? sb . subStringUnsafe ( cStart , cEnd ) : <str> } ; } private void splitHeader ( AppendableCharSequence sb ) { final int length = sb . length ( ) ; int nameStart ; int nameEnd ; int colonEnd ; int valueStart ; int valueEnd ; nameStart = findNonWhitespace ( sb , <int> ) ; for ( nameEnd = nameStart ; nameEnd < length ; nameEnd + + ) { char ch = sb . charAt ( nameEnd ) ; if ( ch = = <str> | | Character . isWhitespace ( ch ) ) { break ; } } for ( colonEnd = nameEnd ; colonEnd < length ; colonEnd + + ) { if ( sb . charAt ( colonEnd ) = = <str> ) { colonEnd + + ; break ; } } name = sb . subStringUnsafe ( nameStart , nameEnd ) ; valueStart = findNonWhitespace ( sb , colonEnd ) ; if ( valueStart = = length ) { value = EMPTY_VALUE ; } else { valueEnd = findEndOfString ( sb ) ; value = sb . subStringUnsafe ( valueStart , valueEnd ) ; } } private static int findNonWhitespace ( AppendableCharSequence sb , int offset ) { for ( int result = offset ; result < sb . length ( ) ; + + result ) { if ( ! Character . isWhitespace ( sb . charAtUnsafe ( result ) ) ) { return result ; } } return sb . length ( ) ; } private static int findWhitespace ( AppendableCharSequence sb , int offset ) { for ( int result = offset ; result < sb . length ( ) ; + + result ) { if ( Character . isWhitespace ( sb . charAtUnsafe ( result ) ) ) { return result ; } } return sb . length ( ) ; } private static int findEndOfString ( AppendableCharSequence sb ) { for ( int result = sb . length ( ) - <int> ; result > <int> ; - - result ) { if ( ! Character . isWhitespace ( sb . charAtUnsafe ( result ) ) ) { return result + <int> ; } } return <int> ; } private static class HeaderParser implements ByteProcessor { private final AppendableCharSequence seq ; private final int maxLength ; private int size ; HeaderParser ( AppendableCharSequence seq , int maxLength ) { this . seq = seq ; this . maxLength = maxLength ; } public AppendableCharSequence parse ( ByteBuf buffer ) { final int oldSize = size ; seq . reset ( ) ; int i = buffer . forEachByte ( this ) ; if ( i = = - <int> ) { size = oldSize ; return null ; } buffer . readerIndex ( i + <int> ) ; return seq ; } public void reset ( ) { size = <int> ; } @Override public boolean process ( byte value ) throws Exception { char nextByte = ( char ) value ; if ( nextByte = = HttpConstants . CR ) { return true ; } if ( nextByte = = HttpConstants . LF ) { return false ; } if ( + + size > maxLength ) { throw newException ( maxLength ) ; } seq . append ( nextByte ) ; return true ; } protected TooLongFrameException newException ( int maxLength ) { return new TooLongFrameException ( <str> + maxLength + <str> ) ; } } private static final class LineParser extends HeaderParser { LineParser ( AppendableCharSequence seq , int maxLength ) { super ( seq , maxLength ) ; } @Override public AppendableCharSequence parse ( ByteBuf buffer ) { reset ( ) ; return super . parse ( buffer ) ; } @Override protected TooLongFrameException newException ( int maxLength ) { return new TooLongFrameException ( <str> + maxLength + <str> ) ; } } } 
