package org . elasticsearch . index ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . function . Consumer ; import java . util . function . Predicate ; public final class IndexSettings { public static final String DEFAULT_FIELD = <str> ; public static final String QUERY_STRING_LENIENT = <str> ; public static final String QUERY_STRING_ANALYZE_WILDCARD = <str> ; public static final String QUERY_STRING_ALLOW_LEADING_WILDCARD = <str> ; public static final String ALLOW_UNMAPPED = <str> ; private final String uuid ; private final List < Consumer < Settings > > updateListeners ; private final Index index ; private final Version version ; private final ESLogger logger ; private final String nodeName ; private final Settings nodeSettings ; private final int numberOfShards ; private final boolean isShadowReplicaIndex ; private final ParseFieldMatcher parseFieldMatcher ; private volatile Settings settings ; private volatile IndexMetaData indexMetaData ; private final String defaultField ; private final boolean queryStringLenient ; private final boolean queryStringAnalyzeWildcard ; private final boolean queryStringAllowLeadingWildcard ; private final boolean defaultAllowUnmappedFields ; private final Predicate < String > indexNameMatcher ; public String getDefaultField ( ) { return defaultField ; } public boolean isQueryStringLenient ( ) { return queryStringLenient ; } public boolean isQueryStringAnalyzeWildcard ( ) { return queryStringAnalyzeWildcard ; } public boolean isQueryStringAllowLeadingWildcard ( ) { return queryStringAllowLeadingWildcard ; } public boolean isDefaultAllowUnmappedFields ( ) { return defaultAllowUnmappedFields ; } public IndexSettings ( final IndexMetaData indexMetaData , final Settings nodeSettings , final Collection < Consumer < Settings > > updateListeners ) { this ( indexMetaData , nodeSettings , updateListeners , ( index ) - > Regex . simpleMatch ( index , indexMetaData . getIndex ( ) ) ) ; } public IndexSettings ( final IndexMetaData indexMetaData , final Settings nodeSettings , final Collection < Consumer < Settings > > updateListeners , final Predicate < String > indexNameMatcher ) { this . nodeSettings = nodeSettings ; this . settings = Settings . builder ( ) . put ( nodeSettings ) . put ( indexMetaData . getSettings ( ) ) . build ( ) ; this . updateListeners = Collections . unmodifiableList ( new ArrayList < > ( updateListeners ) ) ; this . index = new Index ( indexMetaData . getIndex ( ) ) ; version = Version . indexCreated ( settings ) ; uuid = settings . get ( IndexMetaData . SETTING_INDEX_UUID , IndexMetaData . INDEX_UUID_NA_VALUE ) ; logger = Loggers . getLogger ( getClass ( ) , settings , index ) ; nodeName = settings . get ( <str> , <str> ) ; this . indexMetaData = indexMetaData ; numberOfShards = settings . getAsInt ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , null ) ; isShadowReplicaIndex = IndexMetaData . isIndexUsingShadowReplicas ( settings ) ; this . defaultField = settings . get ( DEFAULT_FIELD , AllFieldMapper . NAME ) ; this . queryStringLenient = settings . getAsBoolean ( QUERY_STRING_LENIENT , false ) ; this . queryStringAnalyzeWildcard = settings . getAsBoolean ( QUERY_STRING_ANALYZE_WILDCARD , false ) ; this . queryStringAllowLeadingWildcard = settings . getAsBoolean ( QUERY_STRING_ALLOW_LEADING_WILDCARD , true ) ; this . parseFieldMatcher = new ParseFieldMatcher ( settings ) ; this . defaultAllowUnmappedFields = settings . getAsBoolean ( ALLOW_UNMAPPED , true ) ; this . indexNameMatcher = indexNameMatcher ; assert indexNameMatcher . test ( indexMetaData . getIndex ( ) ) ; } IndexSettings newWithListener ( final Collection < Consumer < Settings > > updateListeners ) { ArrayList < Consumer < Settings > > newUpdateListeners = new ArrayList < > ( updateListeners ) ; newUpdateListeners . addAll ( this . updateListeners ) ; return new IndexSettings ( indexMetaData , nodeSettings , newUpdateListeners , indexNameMatcher ) ; } public Settings getSettings ( ) { return settings ; } public Index getIndex ( ) { return index ; } public String getUUID ( ) { return uuid ; } public boolean hasCustomDataPath ( ) { return customDataPath ( ) ! = null ; } public String customDataPath ( ) { return settings . get ( IndexMetaData . SETTING_DATA_PATH ) ; } public boolean isOnSharedFilesystem ( ) { return IndexMetaData . isOnSharedFilesystem ( getSettings ( ) ) ; } public boolean isIndexUsingShadowReplicas ( ) { return IndexMetaData . isOnSharedFilesystem ( getSettings ( ) ) ; } public Version getIndexVersionCreated ( ) { return version ; } public String getNodeName ( ) { return nodeName ; } public IndexMetaData getIndexMetaData ( ) { return indexMetaData ; } public int getNumberOfShards ( ) { return numberOfShards ; } public int getNumberOfReplicas ( ) { return settings . getAsInt ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , null ) ; } public boolean isShadowReplicaIndex ( ) { return isShadowReplicaIndex ; } public Settings getNodeSettings ( ) { return nodeSettings ; } public ParseFieldMatcher getParseFieldMatcher ( ) { return parseFieldMatcher ; } public boolean matchesIndexName ( String expression ) { return indexNameMatcher . test ( expression ) ; } synchronized boolean updateIndexMetaData ( IndexMetaData indexMetaData ) { final Settings newSettings = indexMetaData . getSettings ( ) ; if ( Version . indexCreated ( newSettings ) ! = version ) { throw new IllegalArgumentException ( <str> + version + <str> + Version . indexCreated ( newSettings ) ) ; } final String newUUID = newSettings . get ( IndexMetaData . SETTING_INDEX_UUID , IndexMetaData . INDEX_UUID_NA_VALUE ) ; if ( newUUID . equals ( getUUID ( ) ) = = false ) { throw new IllegalArgumentException ( <str> + uuid + <str> + newUUID ) ; } this . indexMetaData = indexMetaData ; final Settings existingSettings = this . settings ; if ( existingSettings . getByPrefix ( IndexMetaData . INDEX_SETTING_PREFIX ) . getAsMap ( ) . equals ( newSettings . getByPrefix ( IndexMetaData . INDEX_SETTING_PREFIX ) . getAsMap ( ) ) ) { return false ; } final Settings mergedSettings = this . settings = Settings . builder ( ) . put ( nodeSettings ) . put ( newSettings ) . build ( ) ; for ( final Consumer < Settings > consumer : updateListeners ) { try { consumer . accept ( mergedSettings ) ; } catch ( Exception e ) { logger . warn ( <str> , e , mergedSettings ) ; } } return true ; } List < Consumer < Settings > > getUpdateListeners ( ) { return updateListeners ; } } 
