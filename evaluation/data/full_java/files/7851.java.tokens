package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . command . AllocationCommands ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . decider . ClusterRebalanceAllocationDecider ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . test . ESAllocationTestCase ; import java . util . ArrayList ; import java . util . Collections ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . RELOCATING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . STARTED ; import static org . elasticsearch . cluster . routing . ShardRoutingState . UNASSIGNED ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . lessThan ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . nullValue ; public class FailedShardsRoutingTests extends ESAllocationTestCase { private final ESLogger logger = Loggers . getLogger ( FailedShardsRoutingTests . class ) ; public void testFailedShardPrimaryRelocatingToAndFrom ( ) { AllocationService allocation = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingAllocation . Result rerouteResult = allocation . reroute ( clusterState , <str> ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; rerouteResult = allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; rerouteResult = allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; logger . info ( <str> ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; rerouteResult = allocation . reroute ( clusterState , <str> ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; String origPrimaryNodeId = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) ; String origReplicaNodeId = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) ; logger . info ( <str> ) ; rerouteResult = allocation . reroute ( clusterState , new AllocationCommands ( new MoveAllocationCommand ( clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . shardId ( ) , clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) , <str> ) ) ) ; assertThat ( rerouteResult . changed ( ) , equalTo ( true ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( origPrimaryNodeId ) . get ( <int> ) . state ( ) , equalTo ( RELOCATING ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( INITIALIZING ) ) ; logger . info ( <str> ) ; rerouteResult = allocation . applyFailedShard ( clusterState , new ShardRouting ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( origPrimaryNodeId ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; rerouteResult = allocation . reroute ( clusterState , new AllocationCommands ( new MoveAllocationCommand ( clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . shardId ( ) , clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) , <str> ) ) ) ; assertThat ( rerouteResult . changed ( ) , equalTo ( true ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( origPrimaryNodeId ) . get ( <int> ) . state ( ) , equalTo ( RELOCATING ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) . state ( ) , equalTo ( INITIALIZING ) ) ; logger . info ( <str> ) ; rerouteResult = allocation . applyFailedShard ( clusterState , new ShardRouting ( clusterState . getRoutingNodes ( ) . node ( origPrimaryNodeId ) . get ( <int> ) ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( origReplicaNodeId ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( origReplicaNodeId ) ) ; assertThat ( clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( origPrimaryNodeId ) , equalTo ( <str> ) ) ) ; } public void testFailPrimaryStartedCheckReplicaElected ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingTable prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; } logger . info ( <str> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; } logger . info ( <str> ) ; ShardRouting shardToFail = new ShardRouting ( routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyFailedShard ( clusterState , shardToFail ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) , not ( equalTo ( shardToFail . currentNodeId ( ) ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( <int> ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; logger . info ( <str> ) ; assertThat ( strategy . applyFailedShard ( clusterState , shardToFail ) . changed ( ) , equalTo ( false ) ) ; } public void testFirstAllocationFailureSingleNode ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingTable prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } logger . info ( <str> ) ; prevRoutingTable = routingTable ; ShardRouting firstShard = clusterState . getRoutingNodes ( ) . node ( <str> ) . get ( <int> ) ; routingTable = strategy . applyFailedShard ( clusterState , firstShard ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , nullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } logger . info ( <str> ) ; assertThat ( strategy . applyFailedShard ( clusterState , firstShard ) . changed ( ) , equalTo ( false ) ) ; } public void testSingleShardMultipleAllocationFailures ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; int numberOfReplicas = scaledRandomIntBetween ( <int> , <int> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( numberOfReplicas ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> , numberOfReplicas + <int> ) ; DiscoveryNodes . Builder nodeBuilder = DiscoveryNodes . builder ( ) ; for ( int i = <int> ; i < numberOfReplicas + <int> ; i + + ) { nodeBuilder . put ( newNode ( <str> + Integer . toString ( i ) ) ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( nodeBuilder ) . build ( ) ; while ( ! clusterState . routingTable ( ) . shardsWithState ( UNASSIGNED ) . isEmpty ( ) ) { clusterState = ClusterState . builder ( clusterState ) . routingTable ( strategy . applyStartedShards ( clusterState , clusterState . routingTable ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( strategy . reroute ( clusterState , <str> ) . routingTable ( ) ) . build ( ) ; } int shardsToFail = randomIntBetween ( <int> , numberOfReplicas ) ; ArrayList < FailedRerouteAllocation . FailedShard > failedShards = new ArrayList < > ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < shardsToFail ; i + + ) { String n = <str> + Integer . toString ( randomInt ( numberOfReplicas ) ) ; logger . info ( <str> , n ) ; ShardRouting shardToFail = routingNodes . node ( n ) . get ( <int> ) ; failedShards . add ( new FailedRerouteAllocation . FailedShard ( new ShardRouting ( shardToFail ) , null , null ) ) ; } routingTable = strategy . applyFailedShards ( clusterState , failedShards ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( FailedRerouteAllocation . FailedShard failedShard : failedShards ) { if ( ! routingNodes . node ( failedShard . shard . currentNodeId ( ) ) . isEmpty ( ) ) { fail ( <str> + failedShard + <str> ) ; } } } public void testFirstAllocationFailureTwoNodes ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingTable prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; final String nodeHoldingPrimary = routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , equalTo ( nodeHoldingPrimary ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } logger . info ( <str> ) ; prevRoutingTable = routingTable ; final ShardRouting firstShard = clusterState . getRoutingNodes ( ) . node ( nodeHoldingPrimary ) . get ( <int> ) ; routingTable = strategy . applyFailedShard ( clusterState , firstShard ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; final String nodeHoldingPrimary2 = routingTable . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) ; assertThat ( nodeHoldingPrimary2 , not ( equalTo ( nodeHoldingPrimary ) ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , not ( equalTo ( nodeHoldingPrimary ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; } logger . info ( <str> ) ; assertThat ( strategy . applyFailedShard ( clusterState , firstShard ) . changed ( ) , equalTo ( false ) ) ; } public void testRebalanceFailure ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingTable prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; } logger . info ( <str> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; } logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED , RELOCATING ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED ) , lessThan ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED , RELOCATING ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED ) , lessThan ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( INITIALIZING ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; ShardRouting shardToFail = routingNodes . node ( <str> ) . get ( <int> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyFailedShard ( clusterState , new ShardRouting ( shardToFail ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; assertThat ( prevRoutingTable ! = routingTable , equalTo ( true ) ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED , RELOCATING ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED ) , lessThan ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED , RELOCATING ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( STARTED ) , lessThan ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . numberOfShardsWithState ( INITIALIZING ) , equalTo ( <int> ) ) ; assertThat ( routingNodes . node ( <str> ) . get ( <int> ) . shardId ( ) , not ( equalTo ( shardToFail . shardId ( ) ) ) ) ; } public void testFailAllReplicasInitializingOnPrimaryFail ( ) { AllocationService allocation = createAllocationService ( settingsBuilder ( ) . build ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . reroute ( clusterState , <str> ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; ShardRouting primaryShardToFail = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) ; RoutingAllocation . Result routingResult = allocation . applyFailedShard ( clusterState , primaryShardToFail ) ; assertThat ( routingResult . changed ( ) , equalTo ( true ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; ShardRouting newPrimaryShard = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) ; assertThat ( newPrimaryShard , not ( equalTo ( primaryShardToFail ) ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; routingResult = allocation . applyFailedShard ( clusterState , primaryShardToFail ) ; assertThat ( routingResult . changed ( ) , equalTo ( false ) ) ; } public void testFailAllReplicasInitializingOnPrimaryFailWhileHavingAReplicaToElect ( ) { AllocationService allocation = createAllocationService ( settingsBuilder ( ) . build ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . reroute ( clusterState , <str> ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( allocation . applyStartedShards ( clusterState , Collections . singletonList ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . get ( <int> ) ) ) . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; ShardRouting primaryShardToFail = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) ; RoutingAllocation . Result routingResult = allocation . applyFailedShard ( clusterState , primaryShardToFail ) ; assertThat ( routingResult . changed ( ) , equalTo ( true ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; ShardRouting newPrimaryShard = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) ; assertThat ( newPrimaryShard , not ( equalTo ( primaryShardToFail ) ) ) ; routingResult = allocation . applyFailedShard ( clusterState , primaryShardToFail ) ; assertThat ( routingResult . changed ( ) , equalTo ( false ) ) ; } } 
