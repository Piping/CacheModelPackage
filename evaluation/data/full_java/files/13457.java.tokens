package org . gradle . api . internal . tasks . compile ; import com . google . common . collect . Lists ; import org . gradle . api . JavaVersion ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . file . collections . SimpleFileCollection ; import org . gradle . api . tasks . compile . CompileOptions ; import org . gradle . api . tasks . compile . ForkOptions ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; public class JavaCompilerArgumentsBuilder { public static final String USE_UNSHARED_COMPILER_TABLE_OPTION = <str> ; public static final String EMPTY_SOURCE_PATH_REF_DIR = <str> ; private final JavaCompileSpec spec ; private boolean includeLauncherOptions ; private boolean includeMainOptions = true ; private boolean includeClasspath = true ; private boolean includeSourceFiles ; private boolean includeCustomizations = true ; private List < String > args ; public JavaCompilerArgumentsBuilder ( JavaCompileSpec spec ) { this . spec = spec ; } public JavaCompilerArgumentsBuilder includeLauncherOptions ( boolean flag ) { includeLauncherOptions = flag ; return this ; } public JavaCompilerArgumentsBuilder includeMainOptions ( boolean flag ) { includeMainOptions = flag ; return this ; } public JavaCompilerArgumentsBuilder includeClasspath ( boolean flag ) { includeClasspath = flag ; return this ; } public JavaCompilerArgumentsBuilder includeSourceFiles ( boolean flag ) { includeSourceFiles = flag ; return this ; } public JavaCompilerArgumentsBuilder includeCustomizations ( boolean flag ) { includeCustomizations = flag ; return this ; } public List < String > build ( ) { args = new ArrayList < String > ( ) ; addLauncherOptions ( ) ; addMainOptions ( ) ; addClasspath ( ) ; addSourceFiles ( ) ; addCustomizations ( ) ; return args ; } private void addCustomizations ( ) { if ( includeCustomizations ) { args . add ( USE_UNSHARED_COMPILER_TABLE_OPTION ) ; } } private void addLauncherOptions ( ) { if ( ! includeLauncherOptions ) { return ; } ForkOptions forkOptions = spec . getCompileOptions ( ) . getForkOptions ( ) ; if ( forkOptions . getMemoryInitialSize ( ) ! = null ) { args . add ( <str> + forkOptions . getMemoryInitialSize ( ) . trim ( ) ) ; } if ( forkOptions . getMemoryMaximumSize ( ) ! = null ) { args . add ( <str> + forkOptions . getMemoryMaximumSize ( ) . trim ( ) ) ; } if ( forkOptions . getJvmArgs ( ) ! = null ) { args . addAll ( forkOptions . getJvmArgs ( ) ) ; } } private void addMainOptions ( ) { if ( ! includeMainOptions ) { return ; } String sourceCompatibility = spec . getSourceCompatibility ( ) ; if ( sourceCompatibility ! = null & & ! JavaVersion . current ( ) . equals ( JavaVersion . toVersion ( sourceCompatibility ) ) ) { args . add ( <str> ) ; args . add ( sourceCompatibility ) ; } String targetCompatibility = spec . getTargetCompatibility ( ) ; if ( targetCompatibility ! = null & & ! JavaVersion . current ( ) . equals ( JavaVersion . toVersion ( targetCompatibility ) ) ) { args . add ( <str> ) ; args . add ( targetCompatibility ) ; } File destinationDir = spec . getDestinationDir ( ) ; if ( destinationDir ! = null ) { args . add ( <str> ) ; args . add ( destinationDir . getPath ( ) ) ; } CompileOptions compileOptions = spec . getCompileOptions ( ) ; if ( compileOptions . isVerbose ( ) ) { args . add ( <str> ) ; } if ( compileOptions . isDeprecation ( ) ) { args . add ( <str> ) ; } if ( ! compileOptions . isWarnings ( ) ) { args . add ( <str> ) ; } if ( compileOptions . isDebug ( ) ) { if ( compileOptions . getDebugOptions ( ) . getDebugLevel ( ) ! = null ) { args . add ( <str> + compileOptions . getDebugOptions ( ) . getDebugLevel ( ) . trim ( ) ) ; } else { args . add ( <str> ) ; } } else { args . add ( <str> ) ; } if ( compileOptions . getEncoding ( ) ! = null ) { args . add ( <str> ) ; args . add ( compileOptions . getEncoding ( ) ) ; } if ( compileOptions . getBootClasspath ( ) ! = null ) { args . add ( <str> ) ; args . add ( compileOptions . getBootClasspath ( ) ) ; } if ( compileOptions . getExtensionDirs ( ) ! = null ) { args . add ( <str> ) ; args . add ( compileOptions . getExtensionDirs ( ) ) ; } FileCollection sourcepath = compileOptions . getSourcepath ( ) ; Iterable < File > classpath = spec . getClasspath ( ) ; if ( ( sourcepath ! = null & & ! sourcepath . isEmpty ( ) ) | | ( includeClasspath & & ( classpath ! = null & & classpath . iterator ( ) . hasNext ( ) ) ) ) { args . add ( <str> ) ; args . add ( sourcepath = = null ? emptyFolder ( spec . getTempDir ( ) ) : sourcepath . getAsPath ( ) ) ; } if ( compileOptions . getCompilerArgs ( ) ! = null ) { args . addAll ( compileOptions . getCompilerArgs ( ) ) ; } } private String emptyFolder ( File parent ) { File emptySourcePath = new File ( parent , EMPTY_SOURCE_PATH_REF_DIR ) ; emptySourcePath . mkdirs ( ) ; return emptySourcePath . getAbsolutePath ( ) ; } private void addClasspath ( ) { if ( ! includeClasspath ) { return ; } Iterable < File > classpath = spec . getClasspath ( ) ; if ( classpath ! = null & & classpath . iterator ( ) . hasNext ( ) ) { args . add ( <str> ) ; args . add ( toFileCollection ( classpath ) . getAsPath ( ) ) ; } } private void addSourceFiles ( ) { if ( ! includeSourceFiles ) { return ; } for ( File file : spec . getSource ( ) ) { args . add ( file . getPath ( ) ) ; } } private FileCollection toFileCollection ( Iterable < File > classpath ) { if ( classpath instanceof FileCollection ) { return ( FileCollection ) classpath ; } return new SimpleFileCollection ( Lists . newArrayList ( classpath ) ) ; } } 
