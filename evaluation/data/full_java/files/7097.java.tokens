package org . elasticsearch . script ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . indexedscripts . delete . DeleteIndexedScriptRequest ; import org . elasticsearch . action . indexedscripts . get . GetIndexedScriptRequest ; import org . elasticsearch . action . indexedscripts . put . PutIndexedScriptRequest ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . HasContextAndHeaders ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . cache . Cache ; import org . elasticsearch . common . cache . CacheBuilder ; import org . elasticsearch . common . cache . RemovalListener ; import org . elasticsearch . common . cache . RemovalNotification ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . query . TemplateQueryParser ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . lookup . SearchLookup ; import org . elasticsearch . watcher . FileChangesListener ; import org . elasticsearch . watcher . FileWatcher ; import org . elasticsearch . watcher . ResourceWatcherService ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import static java . util . Collections . unmodifiableMap ; public class ScriptService extends AbstractComponent implements Closeable { static final String DISABLE_DYNAMIC_SCRIPTING_SETTING = <str> ; public static final String DEFAULT_SCRIPTING_LANGUAGE_SETTING = <str> ; public static final String SCRIPT_CACHE_SIZE_SETTING = <str> ; public static final int SCRIPT_CACHE_SIZE_DEFAULT = <int> ; public static final String SCRIPT_CACHE_EXPIRE_SETTING = <str> ; public static final String SCRIPT_INDEX = <str> ; public static final String DEFAULT_LANG = <str> ; public static final String SCRIPT_AUTO_RELOAD_ENABLED_SETTING = <str> ; private final String defaultLang ; private final Set < ScriptEngineService > scriptEngines ; private final Map < String , ScriptEngineService > scriptEnginesByLang ; private final Map < String , ScriptEngineService > scriptEnginesByExt ; private final ConcurrentMap < String , CompiledScript > staticCache = ConcurrentCollections . newConcurrentMap ( ) ; private final Cache < String , CompiledScript > cache ; private final Path scriptsDirectory ; private final ScriptModes scriptModes ; private final ScriptContextRegistry scriptContextRegistry ; private final ParseFieldMatcher parseFieldMatcher ; private Client client = null ; private final ScriptMetrics scriptMetrics = new ScriptMetrics ( ) ; @Deprecated public static final ParseField SCRIPT_LANG = new ParseField ( <str> , <str> ) ; @Deprecated public static final ParseField SCRIPT_FILE = new ParseField ( <str> ) ; @Deprecated public static final ParseField SCRIPT_ID = new ParseField ( <str> ) ; @Deprecated public static final ParseField SCRIPT_INLINE = new ParseField ( <str> ) ; @Inject public ScriptService ( Settings settings , Environment env , Set < ScriptEngineService > scriptEngines , ResourceWatcherService resourceWatcherService , ScriptContextRegistry scriptContextRegistry ) throws IOException { super ( settings ) ; this . parseFieldMatcher = new ParseFieldMatcher ( settings ) ; if ( Strings . hasLength ( settings . get ( DISABLE_DYNAMIC_SCRIPTING_SETTING ) ) ) { throw new IllegalArgumentException ( DISABLE_DYNAMIC_SCRIPTING_SETTING + <str> + <str> ) ; } this . scriptEngines = scriptEngines ; this . scriptContextRegistry = scriptContextRegistry ; int cacheMaxSize = settings . getAsInt ( SCRIPT_CACHE_SIZE_SETTING , SCRIPT_CACHE_SIZE_DEFAULT ) ; TimeValue cacheExpire = settings . getAsTime ( SCRIPT_CACHE_EXPIRE_SETTING , null ) ; logger . debug ( <str> , cacheMaxSize , cacheExpire ) ; this . defaultLang = settings . get ( DEFAULT_SCRIPTING_LANGUAGE_SETTING , DEFAULT_LANG ) ; CacheBuilder < String , CompiledScript > cacheBuilder = CacheBuilder . builder ( ) ; if ( cacheMaxSize > = <int> ) { cacheBuilder . setMaximumWeight ( cacheMaxSize ) ; } if ( cacheExpire ! = null ) { cacheBuilder . setExpireAfterAccess ( cacheExpire . nanos ( ) ) ; } this . cache = cacheBuilder . removalListener ( new ScriptCacheRemovalListener ( ) ) . build ( ) ; Map < String , ScriptEngineService > enginesByLangBuilder = new HashMap < > ( ) ; Map < String , ScriptEngineService > enginesByExtBuilder = new HashMap < > ( ) ; for ( ScriptEngineService scriptEngine : scriptEngines ) { for ( String type : scriptEngine . types ( ) ) { enginesByLangBuilder . put ( type , scriptEngine ) ; } for ( String ext : scriptEngine . extensions ( ) ) { enginesByExtBuilder . put ( ext , scriptEngine ) ; } } this . scriptEnginesByLang = unmodifiableMap ( enginesByLangBuilder ) ; this . scriptEnginesByExt = unmodifiableMap ( enginesByExtBuilder ) ; this . scriptModes = new ScriptModes ( this . scriptEnginesByLang , scriptContextRegistry , settings ) ; scriptsDirectory = env . scriptsFile ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , scriptsDirectory ) ; } FileWatcher fileWatcher = new FileWatcher ( scriptsDirectory ) ; fileWatcher . addListener ( new ScriptChangesListener ( ) ) ; if ( settings . getAsBoolean ( SCRIPT_AUTO_RELOAD_ENABLED_SETTING , true ) ) { resourceWatcherService . add ( fileWatcher ) ; } else { fileWatcher . init ( ) ; } } @Inject ( optional = true ) public void setClient ( Client client ) { this . client = client ; } @Override public void close ( ) throws IOException { IOUtils . close ( scriptEngines ) ; } private ScriptEngineService getScriptEngineServiceForLang ( String lang ) { ScriptEngineService scriptEngineService = scriptEnginesByLang . get ( lang ) ; if ( scriptEngineService = = null ) { throw new IllegalArgumentException ( <str> + lang + <str> ) ; } return scriptEngineService ; } private ScriptEngineService getScriptEngineServiceForFileExt ( String fileExtension ) { ScriptEngineService scriptEngineService = scriptEnginesByExt . get ( fileExtension ) ; if ( scriptEngineService = = null ) { throw new IllegalArgumentException ( <str> + fileExtension + <str> ) ; } return scriptEngineService ; } public CompiledScript compile ( Script script , ScriptContext scriptContext , HasContextAndHeaders headersContext ) { if ( script = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( scriptContext = = null ) { throw new IllegalArgumentException ( <str> ) ; } String lang = script . getLang ( ) ; if ( lang = = null ) { lang = defaultLang ; } ScriptEngineService scriptEngineService = getScriptEngineServiceForLang ( lang ) ; if ( canExecuteScript ( lang , scriptEngineService , script . getType ( ) , scriptContext ) = = false ) { throw new ScriptException ( <str> + script . getType ( ) + <str> + scriptContext . getKey ( ) + <str> + lang + <str> ) ; } boolean expression = <str> . equals ( script . getLang ( ) ) ; boolean notSupported = scriptContext . getKey ( ) . equals ( ScriptContext . Standard . UPDATE . getKey ( ) ) ; if ( expression & & notSupported ) { throw new ScriptException ( <str> + script . getType ( ) + <str> + <str> + scriptContext . getKey ( ) + <str> + lang + <str> ) ; } return compileInternal ( script , headersContext ) ; } public CompiledScript compileInternal ( Script script , HasContextAndHeaders context ) { if ( script = = null ) { throw new IllegalArgumentException ( <str> ) ; } String lang = script . getLang ( ) = = null ? defaultLang : script . getLang ( ) ; ScriptType type = script . getType ( ) ; String name = script . getScript ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , lang , type , name ) ; } ScriptEngineService scriptEngineService = getScriptEngineServiceForLang ( lang ) ; if ( type = = ScriptType . FILE ) { String cacheKey = getCacheKey ( scriptEngineService , name , null ) ; CompiledScript compiledScript = staticCache . get ( cacheKey ) ; if ( compiledScript = = null ) { throw new IllegalArgumentException ( <str> + name + <str> + lang + <str> ) ; } return compiledScript ; } String code = script . getScript ( ) ; if ( type = = ScriptType . INDEXED ) { final IndexedScript indexedScript = new IndexedScript ( lang , name ) ; name = indexedScript . id ; code = getScriptFromIndex ( indexedScript . lang , indexedScript . id , context ) ; } String cacheKey = getCacheKey ( scriptEngineService , type = = ScriptType . INLINE ? null : name , code ) ; CompiledScript compiledScript = cache . get ( cacheKey ) ; if ( compiledScript = = null ) { try { compiledScript = new CompiledScript ( type , name , lang , scriptEngineService . compile ( code ) ) ; } catch ( Exception exception ) { throw new ScriptException ( <str> + type + <str> + name + <str> + lang + <str> , exception ) ; } scriptMetrics . onCompilation ( ) ; cache . put ( cacheKey , compiledScript ) ; } return compiledScript ; } public void queryScriptIndex ( GetIndexedScriptRequest request , final ActionListener < GetResponse > listener ) { String scriptLang = validateScriptLanguage ( request . scriptLang ( ) ) ; GetRequest getRequest = new GetRequest ( request , SCRIPT_INDEX ) . type ( scriptLang ) . id ( request . id ( ) ) . version ( request . version ( ) ) . versionType ( request . versionType ( ) ) . preference ( <str> ) ; client . get ( getRequest , listener ) ; } private String validateScriptLanguage ( String scriptLang ) { if ( scriptLang = = null ) { scriptLang = defaultLang ; } else if ( scriptEnginesByLang . containsKey ( scriptLang ) = = false ) { throw new IllegalArgumentException ( <str> + scriptLang + <str> ) ; } return scriptLang ; } String getScriptFromIndex ( String scriptLang , String id , HasContextAndHeaders context ) { if ( client = = null ) { throw new IllegalArgumentException ( <str> ) ; } scriptLang = validateScriptLanguage ( scriptLang ) ; GetRequest getRequest = new GetRequest ( SCRIPT_INDEX , scriptLang , id ) ; getRequest . copyContextAndHeadersFrom ( context ) ; GetResponse responseFields = client . get ( getRequest ) . actionGet ( ) ; if ( responseFields . isExists ( ) ) { return getScriptFromResponse ( responseFields ) ; } throw new IllegalArgumentException ( <str> + SCRIPT_INDEX + <str> + scriptLang + <str> + id + <str> ) ; } private void validate ( BytesReference scriptBytes , String scriptLang ) { try { XContentParser parser = XContentFactory . xContent ( scriptBytes ) . createParser ( scriptBytes ) ; parser . nextToken ( ) ; Template template = TemplateQueryParser . parse ( scriptLang , parser , parseFieldMatcher , <str> , <str> , <str> ) ; if ( Strings . hasLength ( template . getScript ( ) ) ) { try { ScriptEngineService scriptEngineService = getScriptEngineServiceForLang ( scriptLang ) ; if ( isAnyScriptContextEnabled ( scriptLang , scriptEngineService , ScriptType . INDEXED ) ) { Object compiled = scriptEngineService . compile ( template . getScript ( ) ) ; if ( compiled = = null ) { throw new IllegalArgumentException ( <str> + template . getScript ( ) + <str> + scriptLang + <str> ) ; } } else { logger . warn ( <str> , template . getScript ( ) , scriptLang ) ; } } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + template . getScript ( ) + <str> + scriptLang + <str> , e ) ; } } else { throw new IllegalArgumentException ( <str> + scriptBytes . toUtf8 ( ) ) ; } } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } public void putScriptToIndex ( PutIndexedScriptRequest request , ActionListener < IndexResponse > listener ) { String scriptLang = validateScriptLanguage ( request . scriptLang ( ) ) ; validate ( request . source ( ) , scriptLang ) ; IndexRequest indexRequest = new IndexRequest ( request ) . index ( SCRIPT_INDEX ) . type ( scriptLang ) . id ( request . id ( ) ) . version ( request . version ( ) ) . versionType ( request . versionType ( ) ) . source ( request . source ( ) ) . opType ( request . opType ( ) ) . refresh ( true ) ; client . index ( indexRequest , listener ) ; } public void deleteScriptFromIndex ( DeleteIndexedScriptRequest request , ActionListener < DeleteResponse > listener ) { String scriptLang = validateScriptLanguage ( request . scriptLang ( ) ) ; DeleteRequest deleteRequest = new DeleteRequest ( request ) . index ( SCRIPT_INDEX ) . type ( scriptLang ) . id ( request . id ( ) ) . refresh ( true ) . version ( request . version ( ) ) . versionType ( request . versionType ( ) ) ; client . delete ( deleteRequest , listener ) ; } @SuppressWarnings ( <str> ) public static String getScriptFromResponse ( GetResponse responseFields ) { Map < String , Object > source = responseFields . getSourceAsMap ( ) ; if ( source . containsKey ( <str> ) ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; Object template = source . get ( <str> ) ; if ( template instanceof Map ) { builder . map ( ( Map < String , Object > ) template ) ; return builder . string ( ) ; } else { return template . toString ( ) ; } } catch ( IOException | ClassCastException e ) { throw new IllegalStateException ( <str> + responseFields . getSourceAsString ( ) + <str> , e ) ; } } else if ( source . containsKey ( <str> ) ) { return source . get ( <str> ) . toString ( ) ; } else { try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( responseFields . getSource ( ) ) ; return builder . string ( ) ; } catch ( IOException | ClassCastException e ) { throw new IllegalStateException ( <str> + responseFields . getSourceAsString ( ) + <str> , e ) ; } } } public ExecutableScript executable ( Script script , ScriptContext scriptContext , HasContextAndHeaders headersContext ) { return executable ( compile ( script , scriptContext , headersContext ) , script . getParams ( ) ) ; } public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > vars ) { return getScriptEngineServiceForLang ( compiledScript . lang ( ) ) . executable ( compiledScript , vars ) ; } public SearchScript search ( SearchLookup lookup , Script script , ScriptContext scriptContext ) { CompiledScript compiledScript = compile ( script , scriptContext , SearchContext . current ( ) ) ; return getScriptEngineServiceForLang ( compiledScript . lang ( ) ) . search ( compiledScript , lookup , script . getParams ( ) ) ; } private boolean isAnyScriptContextEnabled ( String lang , ScriptEngineService scriptEngineService , ScriptType scriptType ) { for ( ScriptContext scriptContext : scriptContextRegistry . scriptContexts ( ) ) { if ( canExecuteScript ( lang , scriptEngineService , scriptType , scriptContext ) ) { return true ; } } return false ; } private boolean canExecuteScript ( String lang , ScriptEngineService scriptEngineService , ScriptType scriptType , ScriptContext scriptContext ) { assert lang ! = null ; if ( scriptContextRegistry . isSupportedContext ( scriptContext ) = = false ) { throw new IllegalArgumentException ( <str> + scriptContext . getKey ( ) + <str> ) ; } ScriptMode mode = scriptModes . getScriptMode ( lang , scriptType , scriptContext ) ; switch ( mode ) { case ON : return true ; case OFF : return false ; case SANDBOX : return scriptEngineService . sandboxed ( ) ; default : throw new IllegalArgumentException ( <str> + mode + <str> ) ; } } public ScriptStats stats ( ) { return scriptMetrics . stats ( ) ; } private class ScriptCacheRemovalListener implements RemovalListener < String , CompiledScript > { @Override public void onRemoval ( RemovalNotification < String , CompiledScript > notification ) { scriptMetrics . onCacheEviction ( ) ; for ( ScriptEngineService service : scriptEngines ) { try { service . scriptRemoved ( notification . getValue ( ) ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } } } private class ScriptChangesListener extends FileChangesListener { private Tuple < String , String > scriptNameExt ( Path file ) { Path scriptPath = scriptsDirectory . relativize ( file ) ; int extIndex = scriptPath . toString ( ) . lastIndexOf ( <str> ) ; if ( extIndex ! = - <int> ) { String ext = scriptPath . toString ( ) . substring ( extIndex + <int> ) ; String scriptName = scriptPath . toString ( ) . substring ( <int> , extIndex ) . replace ( scriptPath . getFileSystem ( ) . getSeparator ( ) , <str> ) ; return new Tuple < > ( scriptName , ext ) ; } else { return null ; } } @Override public void onFileInit ( Path file ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , file ) ; } Tuple < String , String > scriptNameExt = scriptNameExt ( file ) ; if ( scriptNameExt ! = null ) { ScriptEngineService engineService = getScriptEngineServiceForFileExt ( scriptNameExt . v2 ( ) ) ; if ( engineService = = null ) { logger . warn ( <str> , scriptNameExt . v2 ( ) ) ; } else { try { if ( isAnyScriptContextEnabled ( engineService . types ( ) [ <int> ] , engineService , ScriptType . FILE ) ) { logger . info ( <str> , file . toAbsolutePath ( ) ) ; try ( InputStreamReader reader = new InputStreamReader ( Files . newInputStream ( file ) , StandardCharsets . UTF_8 ) ) { String script = Streams . copyToString ( reader ) ; String cacheKey = getCacheKey ( engineService , scriptNameExt . v1 ( ) , null ) ; staticCache . put ( cacheKey , new CompiledScript ( ScriptType . FILE , scriptNameExt . v1 ( ) , engineService . types ( ) [ <int> ] , engineService . compile ( script ) ) ) ; scriptMetrics . onCompilation ( ) ; } } else { logger . warn ( <str> , file . toAbsolutePath ( ) ) ; } } catch ( Throwable e ) { logger . warn ( <str> , e , scriptNameExt . v1 ( ) ) ; } } } } @Override public void onFileCreated ( Path file ) { onFileInit ( file ) ; } @Override public void onFileDeleted ( Path file ) { Tuple < String , String > scriptNameExt = scriptNameExt ( file ) ; if ( scriptNameExt ! = null ) { ScriptEngineService engineService = getScriptEngineServiceForFileExt ( scriptNameExt . v2 ( ) ) ; assert engineService ! = null ; logger . info ( <str> , file . toAbsolutePath ( ) ) ; staticCache . remove ( getCacheKey ( engineService , scriptNameExt . v1 ( ) , null ) ) ; } } @Override public void onFileChanged ( Path file ) { onFileInit ( file ) ; } } public static enum ScriptType { INLINE ( <int> , <str> ) , INDEXED ( <int> , <str> ) , FILE ( <int> , <str> ) ; private final int val ; private final ParseField parseField ; public static ScriptType readFrom ( StreamInput in ) throws IOException { int scriptTypeVal = in . readVInt ( ) ; for ( ScriptType type : values ( ) ) { if ( type . val = = scriptTypeVal ) { return type ; } } throw new IllegalArgumentException ( <str> + scriptTypeVal + <str> + INLINE . val + <str> + FILE . val + <str> + INDEXED . val + <str> ) ; } public static void writeTo ( ScriptType scriptType , StreamOutput out ) throws IOException { if ( scriptType ! = null ) { out . writeVInt ( scriptType . val ) ; } else { out . writeVInt ( INLINE . val ) ; } } private ScriptType ( int val , String name ) { this . val = val ; this . parseField = new ParseField ( name ) ; } public ParseField getParseField ( ) { return parseField ; } @Override public String toString ( ) { return name ( ) . toLowerCase ( Locale . ROOT ) ; } } private static String getCacheKey ( ScriptEngineService scriptEngineService , String name , String code ) { String lang = scriptEngineService . types ( ) [ <int> ] ; return lang + <str> + ( name ! = null ? <str> + name : <str> ) + ( code ! = null ? <str> + code : <str> ) ; } private static class IndexedScript { private final String lang ; private final String id ; IndexedScript ( String lang , String script ) { this . lang = lang ; final String [ ] parts = script . split ( <str> ) ; if ( parts . length = = <int> ) { this . id = script ; } else { if ( parts . length ! = <int> ) { throw new IllegalArgumentException ( <str> + script + <str> + <str> ) ; } else { if ( ! parts [ <int> ] . equals ( this . lang ) ) { throw new IllegalStateException ( <str> + parts [ <int> ] + <str> + this . lang + <str> ) ; } this . id = parts [ <int> ] ; } } } } } 
