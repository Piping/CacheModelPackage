package io . netty . microbench . concurrent ; import io . netty . microbench . util . AbstractMicrobenchmark ; import io . netty . util . concurrent . FastThreadLocal ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Measurement ; import org . openjdk . jmh . annotations . Threads ; import java . util . Random ; @Threads ( <int> ) @Measurement ( iterations = <int> , batchSize = <int> ) public class FastThreadLocalBenchmark extends AbstractMicrobenchmark { private static final Random rand = new Random ( ) ; @SuppressWarnings ( <str> ) private static final ThreadLocal < Integer > [ ] jdkThreadLocals = new ThreadLocal [ <int> ] ; @SuppressWarnings ( <str> ) private static final FastThreadLocal < Integer > [ ] fastThreadLocals = new FastThreadLocal [ jdkThreadLocals . length ] ; static { for ( int i = <int> ; i < jdkThreadLocals . length ; i + + ) { jdkThreadLocals [ i ] = new ThreadLocal < Integer > ( ) { @Override protected Integer initialValue ( ) { return rand . nextInt ( ) ; } } ; } for ( int i = <int> ; i < fastThreadLocals . length ; i + + ) { fastThreadLocals [ i ] = new FastThreadLocal < Integer > ( ) { @Override protected Integer initialValue ( ) { return rand . nextInt ( ) ; } } ; } } @Benchmark public int jdkThreadLocalGet ( ) { int result = <int> ; for ( ThreadLocal < Integer > i : jdkThreadLocals ) { result + = i . get ( ) ; } return result ; } @Benchmark public int fastThreadLocal ( ) { int result = <int> ; for ( FastThreadLocal < Integer > i : fastThreadLocals ) { result + = i . get ( ) ; } return result ; } } 
