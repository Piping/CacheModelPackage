package org . apache . cassandra . io . util ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . util . Arrays ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . utils . Throwables ; import org . apache . cassandra . utils . concurrent . RefCounted ; import org . apache . cassandra . utils . concurrent . SharedCloseableImpl ; import static java . util . stream . Stream . of ; import static org . apache . cassandra . utils . Throwables . perform ; public class MmappedRegions extends SharedCloseableImpl { public static int MAX_SEGMENT_SIZE = Integer . MAX_VALUE ; static final int REGION_ALLOC_SIZE = <int> ; private final State state ; private volatile State copy ; private MmappedRegions ( ChannelProxy channel , CompressionMetadata metadata , long length ) { this ( new State ( channel ) , metadata , length ) ; } private MmappedRegions ( State state , CompressionMetadata metadata , long length ) { super ( new Tidier ( state ) ) ; this . state = state ; if ( metadata ! = null ) { assert length = = <int> : <str> ; updateState ( metadata ) ; } else if ( length > <int> ) { updateState ( length ) ; } this . copy = new State ( state ) ; } private MmappedRegions ( MmappedRegions original ) { super ( original ) ; this . state = original . copy ; } public static MmappedRegions empty ( ChannelProxy channel ) { return new MmappedRegions ( channel , null , <int> ) ; } public static MmappedRegions map ( ChannelProxy channel , CompressionMetadata metadata ) { if ( metadata = = null ) throw new IllegalArgumentException ( <str> ) ; return new MmappedRegions ( channel , metadata , <int> ) ; } public static MmappedRegions map ( ChannelProxy channel , long length ) { if ( length < = <int> ) throw new IllegalArgumentException ( <str> ) ; return new MmappedRegions ( channel , null , length ) ; } public MmappedRegions sharedCopy ( ) { return new MmappedRegions ( this ) ; } private boolean isCopy ( ) { return copy = = null ; } public void extend ( long length ) { if ( length < <int> ) throw new IllegalArgumentException ( <str> ) ; assert ! isCopy ( ) : <str> ; if ( length < = state . length ) return ; updateState ( length ) ; copy = new State ( state ) ; } private void updateState ( long length ) { state . length = length ; long pos = state . getPosition ( ) ; while ( pos < length ) { long size = Math . min ( MAX_SEGMENT_SIZE , length - pos ) ; state . add ( pos , size ) ; pos + = size ; } } private void updateState ( CompressionMetadata metadata ) { long offset = <int> ; long lastSegmentOffset = <int> ; long segmentSize = <int> ; while ( offset < metadata . dataLength ) { CompressionMetadata . Chunk chunk = metadata . chunkFor ( offset ) ; if ( segmentSize + chunk . length + <int> > MAX_SEGMENT_SIZE ) { if ( segmentSize > <int> ) { state . add ( lastSegmentOffset , segmentSize ) ; lastSegmentOffset + = segmentSize ; segmentSize = <int> ; } } segmentSize + = chunk . length + <int> ; offset + = metadata . chunkLength ( ) ; } if ( segmentSize > <int> ) state . add ( lastSegmentOffset , segmentSize ) ; state . length = lastSegmentOffset + segmentSize ; } public boolean isValid ( ChannelProxy channel ) { return state . isValid ( channel ) ; } public boolean isEmpty ( ) { return state . isEmpty ( ) ; } public Region floor ( long position ) { assert ! isCleanedUp ( ) : <str> ; return state . floor ( position ) ; } public static final class Region { public final long offset ; public final ByteBuffer buffer ; public Region ( long offset , ByteBuffer buffer ) { this . offset = offset ; this . buffer = buffer ; } public long bottom ( ) { return offset ; } public long top ( ) { return offset + buffer . capacity ( ) ; } } private static final class State { private final ChannelProxy channel ; private ByteBuffer [ ] buffers ; private long [ ] offsets ; private long length ; private int last ; private State ( ChannelProxy channel ) { this . channel = channel . sharedCopy ( ) ; this . buffers = new ByteBuffer [ REGION_ALLOC_SIZE ] ; this . offsets = new long [ REGION_ALLOC_SIZE ] ; this . length = <int> ; this . last = - <int> ; } private State ( State original ) { this . channel = original . channel ; this . buffers = original . buffers ; this . offsets = original . offsets ; this . length = original . length ; this . last = original . last ; } private boolean isEmpty ( ) { return last < <int> ; } private boolean isValid ( ChannelProxy channel ) { return this . channel . filePath ( ) . equals ( channel . filePath ( ) ) ; } private Region floor ( long position ) { assert <int> < = position & & position < length : String . format ( <str> , position , length ) ; int idx = Arrays . binarySearch ( offsets , <int> , last + <int> , position ) ; assert idx ! = - <int> : String . format ( <str> , position , Arrays . toString ( offsets ) , last , channel ) ; if ( idx < <int> ) idx = - ( idx + <int> ) ; return new Region ( offsets [ idx ] , buffers [ idx ] ) ; } private long getPosition ( ) { return last < <int> ? <int> : offsets [ last ] + buffers [ last ] . capacity ( ) ; } private void add ( long pos , long size ) { ByteBuffer buffer = channel . map ( FileChannel . MapMode . READ_ONLY , pos , size ) ; + + last ; if ( last = = offsets . length ) { offsets = Arrays . copyOf ( offsets , offsets . length + REGION_ALLOC_SIZE ) ; buffers = Arrays . copyOf ( buffers , buffers . length + REGION_ALLOC_SIZE ) ; } offsets [ last ] = pos ; buffers [ last ] = buffer ; } private Throwable close ( Throwable accumulate ) { accumulate = channel . close ( accumulate ) ; if ( ! FileUtils . isCleanerAvailable ( ) ) return accumulate ; return perform ( accumulate , channel . filePath ( ) , Throwables . FileOpType . READ , of ( buffers ) . map ( ( buffer ) - > ( ) - > { if ( buffer ! = null ) FileUtils . clean ( buffer ) ; } ) ) ; } } public static final class Tidier implements RefCounted . Tidy { final State state ; Tidier ( State state ) { this . state = state ; } public String name ( ) { return state . channel . filePath ( ) ; } public void tidy ( ) { try { Throwables . maybeFail ( state . close ( null ) ) ; } catch ( Exception e ) { throw new FSReadError ( e , state . channel . filePath ( ) ) ; } } } } 
